{"buggy_code": ["/* \n  Copyright 2008-2018 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\nint CLASS fcol(int row, int col)\n{\n  static const char filter[16][16] = {\n      {2, 1, 1, 3, 2, 3, 2, 0, 3, 2, 3, 0, 1, 2, 1, 0}, {0, 3, 0, 2, 0, 1, 3, 1, 0, 1, 1, 2, 0, 3, 3, 2},\n      {2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 2, 1, 2, 0, 0, 3}, {0, 1, 0, 1, 0, 2, 0, 2, 2, 0, 3, 0, 1, 3, 2, 1},\n      {3, 1, 1, 2, 0, 1, 0, 2, 1, 3, 1, 3, 0, 1, 3, 0}, {2, 0, 0, 3, 3, 2, 3, 1, 2, 0, 2, 0, 3, 2, 2, 1},\n      {2, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 0, 0, 1}, {1, 0, 0, 2, 3, 0, 0, 3, 0, 3, 0, 3, 2, 1, 2, 3},\n      {2, 3, 3, 1, 1, 2, 1, 0, 3, 2, 3, 0, 2, 3, 1, 3}, {1, 0, 2, 0, 3, 0, 3, 2, 0, 1, 1, 2, 0, 1, 0, 2},\n      {0, 1, 1, 3, 3, 2, 2, 1, 1, 3, 3, 0, 2, 1, 3, 2}, {2, 3, 2, 0, 0, 1, 3, 0, 2, 0, 1, 2, 3, 0, 1, 0},\n      {1, 3, 1, 2, 3, 2, 3, 2, 0, 2, 0, 1, 1, 0, 3, 0}, {0, 2, 0, 3, 1, 0, 0, 1, 1, 3, 3, 2, 3, 2, 2, 1},\n      {2, 1, 3, 2, 3, 1, 2, 1, 0, 3, 0, 2, 0, 2, 0, 2}, {0, 3, 1, 0, 0, 2, 0, 3, 2, 1, 3, 1, 1, 3, 1, 3}};\n\n  if (filters == 1)\n    return filter[(row + top_margin) & 15][(col + left_margin) & 15];\n  if (filters == 9)\n    return xtrans[(row + 6) % 6][(col + 6) % 6];\n  return FC(row, col);\n}\n\n#if !defined(__FreeBSD__)\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return (p ? p - s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a, b) local_strnlen(a, b)\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int Fuji_wb_list1[] = {LIBRAW_WBI_FineWeather, LIBRAW_WBI_Shade, LIBRAW_WBI_FL_D,\n                              LIBRAW_WBI_FL_L,        LIBRAW_WBI_FL_W,  LIBRAW_WBI_Tungsten};\nstatic int nFuji_wb_list1 = sizeof(Fuji_wb_list1) / sizeof(int);\nstatic int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                            3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                            5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\nstatic int Fuji_wb_list2[] = {LIBRAW_WBI_Auto,  0,  LIBRAW_WBI_Custom,   6,  LIBRAW_WBI_FineWeather, 1,\n                              LIBRAW_WBI_Shade, 8,  LIBRAW_WBI_FL_D,     10, LIBRAW_WBI_FL_L,        11,\n                              LIBRAW_WBI_FL_W,  12, LIBRAW_WBI_Tungsten, 2,  LIBRAW_WBI_Underwater,  35,\n                              LIBRAW_WBI_Ill_A, 82, LIBRAW_WBI_D65,      83};\nstatic int nFuji_wb_list2 = sizeof(Fuji_wb_list2) / sizeof(int);\n\nstatic int Oly_wb_list1[] = {LIBRAW_WBI_Shade,    LIBRAW_WBI_Cloudy, LIBRAW_WBI_FineWeather,\n                             LIBRAW_WBI_Tungsten, LIBRAW_WBI_Sunset, LIBRAW_WBI_FL_D,\n                             LIBRAW_WBI_FL_N,     LIBRAW_WBI_FL_W,   LIBRAW_WBI_FL_WW};\n\nstatic int Oly_wb_list2[] = {LIBRAW_WBI_Auto,\n                             0,\n                             LIBRAW_WBI_Tungsten,\n                             3000,\n                             0x100,\n                             3300,\n                             0x100,\n                             3600,\n                             0x100,\n                             3900,\n                             LIBRAW_WBI_FL_W,\n                             4000,\n                             0x100,\n                             4300,\n                             LIBRAW_WBI_FL_D,\n                             4500,\n                             0x100,\n                             4800,\n                             LIBRAW_WBI_FineWeather,\n                             5300,\n                             LIBRAW_WBI_Cloudy,\n                             6000,\n                             LIBRAW_WBI_FL_N,\n                             6600,\n                             LIBRAW_WBI_Shade,\n                             7500,\n                             LIBRAW_WBI_Custom1,\n                             0,\n                             LIBRAW_WBI_Custom2,\n                             0,\n                             LIBRAW_WBI_Custom3,\n                             0,\n                             LIBRAW_WBI_Custom4,\n                             0};\n\nstatic int Pentax_wb_list1[] = {LIBRAW_WBI_Daylight, LIBRAW_WBI_Shade, LIBRAW_WBI_Cloudy, LIBRAW_WBI_Tungsten,\n                                LIBRAW_WBI_FL_D,     LIBRAW_WBI_FL_N,  LIBRAW_WBI_FL_W,   LIBRAW_WBI_Flash};\n\nstatic int Pentax_wb_list2[] = {LIBRAW_WBI_Daylight, LIBRAW_WBI_Shade, LIBRAW_WBI_Cloudy,\n                                LIBRAW_WBI_Tungsten, LIBRAW_WBI_FL_D,  LIBRAW_WBI_FL_N,\n                                LIBRAW_WBI_FL_W,     LIBRAW_WBI_Flash, LIBRAW_WBI_FL_L};\nstatic int nPentax_wb_list2 = sizeof(Pentax_wb_list2) / sizeof(int);\n\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n  int r = fp->read(buf, len, 1);\n  buf[len - 1] = 0;\n  return r;\n}\n#define stmread(buf, maxlen, fp) stread(buf, MIN(maxlen, sizeof(buf)), fp)\n#endif\n\n#if !defined(__GLIBC__) && !defined(__FreeBSD__)\nchar *my_memmem(char *haystack, size_t haystacklen, char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp(c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr(char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf, sizeof(buf) - 1)\n\nushort CLASS sget2(uchar *s)\n{\n  if (order == 0x4949) /* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define nonDNG 0\n#define CameraDNG 1\n#define AdobeDNG 2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords, int maxlen)\n{\n  line[maxlen - 1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while (1)\n  {\n    while (isspace(*p))\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    words[nwords++] = p;\n    while (!isspace(*p) && *p != '\\0')\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    *p++ = '\\0';\n    if (nwords >= maxwords)\n      return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f)\n{\n  if ((a >> 4) > 9)\n    return 0;\n  else if ((a & 0x0f) > 9)\n    return 0;\n  else if ((b >> 4) > 9)\n    return 0;\n  else if ((b & 0x0f) > 9)\n    return 0;\n  else if ((c >> 4) > 9)\n    return 0;\n  else if ((c & 0x0f) > 9)\n    return 0;\n  else if ((d >> 4) > 9)\n    return 0;\n  else if ((d & 0x0f) > 9)\n    return 0;\n  else if ((e >> 4) > 9)\n    return 0;\n  else if ((e & 0x0f) > 9)\n    return 0;\n  else if ((f >> 4) > 9)\n    return 0;\n  else if ((f & 0x0f) > 9)\n    return 0;\n  return 1;\n}\n\nstatic ushort bcd2dec(uchar data)\n{\n  if ((data >> 4) > 9)\n    return 0;\n  else if ((data & 0x0f) > 9)\n    return 0;\n  else\n    return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] =\n    \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\"\n    \"\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\"\n    \"\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\"\n    \"\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\"\n    \"\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\"\n    \"\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\"\n    \"\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\"\n    \"\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\"\n    \"\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\"\n    \"\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse\n{\n  if (order == 0x4d4d) /* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian... */\n    return s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = {0xff, 0xff};\n  fread(str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4(uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint(int type) { return type == 3 ? get2() : get4(); }\n\nfloat CLASS int_to_float(int i)\n{\n  union {\n    int i;\n    float f;\n  } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal(int type)\n{\n  union {\n    char c[8];\n    double d;\n  } u, v;\n  int i, rev;\n\n  switch (type)\n  {\n  case 3:\n    return (unsigned short)get2();\n  case 4:\n    return (unsigned int)get4();\n  case 5:\n    u.d = (unsigned int)get4();\n    v.d = (unsigned int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 8:\n    return (signed short)get2();\n  case 9:\n    return (signed int)get4();\n  case 10:\n    u.d = (signed int)get4();\n    v.d = (signed int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 11:\n    return int_to_float(get4());\n  case 12:\n    rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n    for (i = 0; i < 8; i++)\n      u.c[i ^ rev] = fgetc(ifp);\n    return u.d;\n  default:\n    return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts(ushort *pixel, unsigned count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}\n\nvoid CLASS cubic_spline(const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **)calloc(((2 * len + 4) * sizeof **A + sizeof *A), 2 * len);\n  if (!A)\n    return;\n  A[0] = (float *)(A + 2 * len);\n  for (i = 1; i < 2 * len; i++)\n    A[i] = A[0] + 2 * len * i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i * i))));\n  for (i = 0; i < len; i++)\n  {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len - 1; i > 0; i--)\n  {\n    b[i] = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);\n    d[i - 1] = x[i] - x[i - 1];\n  }\n  for (i = 1; i < len - 1; i++)\n  {\n    A[i][i] = 2 * (d[i - 1] + d[i]);\n    if (i > 1)\n    {\n      A[i][i - 1] = d[i - 1];\n      A[i - 1][i] = d[i - 1];\n    }\n    A[i][len - 1] = 6 * (b[i + 1] - b[i]);\n  }\n  for (i = 1; i < len - 2; i++)\n  {\n    float v = A[i + 1][i] / A[i][i];\n    for (j = 1; j <= len - 1; j++)\n      A[i + 1][j] -= v * A[i][j];\n  }\n  for (i = len - 2; i > 0; i--)\n  {\n    float acc = 0;\n    for (j = i; j <= len - 2; j++)\n      acc += A[i][j] * c[j];\n    c[i] = (A[i][len - 1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len - 1; j++)\n    {\n      if (x[j] <= x_out && x_out <= x[j + 1])\n      {\n        float v = x_out - x[j];\n        y_out = y[j] + ((y[j + 1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j + 1] * d[j]) / 6) * v + (c[j] * 0.5) * v * v +\n                ((c[j + 1] - c[j]) / (6 * d[j])) * v * v * v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 : (ushort)(y_out * 65535.0 + 0.5));\n  }\n  free(A);\n}\n\nvoid CLASS canon_600_fixed_wb(int temp)\n{\n  static const short mul[4][5] = {\n      {667, 358, 397, 565, 452}, {731, 390, 367, 499, 517}, {1119, 396, 348, 448, 537}, {1399, 485, 431, 508, 688}};\n  int lo, hi, i;\n  float frac = 0;\n\n  for (lo = 4; --lo;)\n    if (*mul[lo] <= temp)\n      break;\n  for (hi = 0; hi < 3; hi++)\n    if (*mul[hi] >= temp)\n      break;\n  if (lo != hi)\n    frac = (float)(temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i = 1; i < 5; i++)\n    pre_mul[i - 1] = 1 / (frac * mul[hi][i] + (1 - frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color(int ratio[2], int mar)\n{\n  int clipped = 0, target, miss;\n\n  if (flash_used)\n  {\n    if (ratio[1] < -104)\n    {\n      ratio[1] = -104;\n      clipped = 1;\n    }\n    if (ratio[1] > 12)\n    {\n      ratio[1] = 12;\n      clipped = 1;\n    }\n  }\n  else\n  {\n    if (ratio[1] < -264 || ratio[1] > 461)\n      return 2;\n    if (ratio[1] < -50)\n    {\n      ratio[1] = -50;\n      clipped = 1;\n    }\n    if (ratio[1] > 307)\n    {\n      ratio[1] = 307;\n      clipped = 1;\n    }\n  }\n  target = flash_used || ratio[1] < 197 ? -38 - (398 * ratio[1] >> 10) : -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] && target + 20 >= ratio[0] && !clipped)\n    return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar * 4)\n    return 2;\n  if (miss < -20)\n    miss = -20;\n  if (miss > mar)\n    miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = {0, 0};\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset(&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if (i < 10)\n    mar = 150;\n  else if (i > 12)\n    mar = 20;\n  else\n    mar = 280 - 20 * i;\n  if (flash_used)\n    mar = 80;\n  for (row = 14; row < height - 14; row += 4)\n    for (col = 10; col < width; col += 2)\n    {\n      for (i = 0; i < 8; i++)\n        test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] = BAYER(row + (i >> 1), col + (i & 1));\n      for (i = 0; i < 8; i++)\n        if (test[i] < 150 || test[i] > 1500)\n          goto next;\n      for (i = 0; i < 4; i++)\n        if (abs(test[i] - test[i + 4]) > 50)\n          goto next;\n      for (i = 0; i < 2; i++)\n      {\n        for (j = 0; j < 4; j += 2)\n          ratio[i][j >> 1] = ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];\n        stat[i] = canon_600_color(ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1)\n        goto next;\n      for (i = 0; i < 2; i++)\n        if (stat[i])\n          for (j = 0; j < 2; j++)\n            test[i * 4 + j * 2 + 1] = test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;\n      for (i = 0; i < 8; i++)\n        total[st][i] += test[i];\n      count[st]++;\n    next:;\n    }\n  if (count[0] | count[1])\n  {\n    st = count[0] * 200 < count[1];\n    for (i = 0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {{-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921, -3409},\n                                     {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},\n                                     {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},\n                                     {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};\n  int t = 0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789)\n    t = 1;\n  if (mc > 1.28 && mc <= 2)\n  {\n    if (yc < 0.8789)\n      t = 3;\n    else if (yc <= 2)\n      t = 4;\n  }\n  if (flash_used)\n    t = 5;\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow = row = 0; irow < height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(data, 1, 1120, ifp) < 1120)\n      derror();\n    pix = raw_image + row * raw_width;\n    for (dp = data; dp < data + 1120; dp += 10, pix += 8)\n    {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6);\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1] & 3);\n      pix[4] = (dp[5] << 2) + (dp[9] & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6);\n    }\n    if ((row += 2) > height)\n      row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] = {{1141, 1145}, {1128, 1109}, {1178, 1149}, {1128, 1109}};\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n    {\n      if ((val = BAYER(row, col) - black) < 0)\n        val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row, col) = val;\n    }\n  }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row = 0; row < 100; row++)\n  {\n    fseek(ifp, row * 3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15)\n      return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff(int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf = 0;\n  static int vbits = 0, reset = 0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits tls->getbits.vbits\n#define reset tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25)\n    return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0)\n    return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF && !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))\n  {\n    bitbuf = (bitbuf << 8) + (uchar)c;\n    vbits += 8;\n  }\n  c = bitbuf << (32 - vbits) >> (32 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    c = (uchar)huff[c];\n  }\n  else\n    vbits -= nbits;\n  if (vbits < 0)\n    derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n, 0)\n#define gethuff(h) getbithuff(*h, h + 1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n        00\t\t0x04\n        010\t\t0x03\n        011\t\t0x05\n        100\t\t0x06\n        101\t\t0x02\n        1100\t\t0x07\n        1101\t\t0x01\n        11100\t\t0x08\n        11101\t\t0x09\n        11110\t\t0x00\n        111110\t\t0x0a\n        1111110\t\t0x0b\n        1111111\t\t0xff\n */\nushort *CLASS make_decoder_ref(const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max = 16; max && !count[max]; max--)\n    ;\n  huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);\n  merror(huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h = len = 1; len <= max; len++)\n    for (i = 0; i < count[len]; i++, ++*source)\n      for (j = 0; j < 1 << (max - len); j++)\n        if (h <= 1 << max)\n          huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort *CLASS make_decoder(const uchar *source) { return make_decoder_ref(&source); }\n\nvoid CLASS crw_init_tables(unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n      {0, 1,    4,    2,    3,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x04, 0x03, 0x05, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},\n      {0, 2,    2,    3,    1,    1,    1,    1,    2,    0,    0,    0,    0,    0,   0,\n       0, 0x03, 0x02, 0x04, 0x01, 0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},\n      {0, 0,    6,    3,    1,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x06, 0x05, 0x07, 0x04, 0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},\n  };\n  static const uchar second_tree[3][180] = {\n      {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,    0,    0,    0,    139,  0x03, 0x04,\n       0x02, 0x05, 0x01, 0x06, 0x07, 0x08, 0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,\n       0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42, 0x35, 0x51, 0x36, 0x37, 0x38, 0x29,\n       0x79, 0x26, 0x1a, 0x39, 0x56, 0x57, 0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,\n       0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98, 0x47, 0x48, 0x95, 0x69, 0x99, 0x91,\n       0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6, 0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,\n       0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7, 0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7,\n       0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1, 0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,\n       0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba, 0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3,\n       0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4, 0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},\n      {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,    0,    0,    0,    140,  0x02, 0x03,\n       0x01, 0x04, 0x05, 0x12, 0x11, 0x06, 0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,\n       0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51, 0x34, 0x43, 0x52, 0x29, 0x35, 0x61,\n       0x39, 0x71, 0x62, 0x36, 0x53, 0x26, 0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,\n       0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9, 0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56,\n       0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99, 0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,\n       0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8, 0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82,\n       0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a, 0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,\n       0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8, 0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64,\n       0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8, 0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},\n      {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,    8,    10,   0,    117,  0x04, 0x05,\n       0x03, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,\n       0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34, 0x35, 0x36, 0x39, 0x79, 0x57, 0x58,\n       0x59, 0x28, 0x56, 0x78, 0x27, 0x41, 0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,\n       0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69, 0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88,\n       0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8, 0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,\n       0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a, 0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a,\n       0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6, 0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,\n       0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5, 0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1,\n       0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3, 0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};\n  if (table > 2)\n    table = 2;\n  huff[0] = make_decoder(first_tree[table]);\n  huff[1] = make_decoder(second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret = 1, i;\n\n  fseek(ifp, 0, SEEK_SET);\n  fread(test, 1, sizeof test, ifp);\n  for (i = 540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff)\n    {\n      if (test[i + 1])\n        return 1;\n      ret = 0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];\n\n  crw_init_tables(tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits)\n    maximum = 0x3ff;\n  fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row += 8)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pixel = raw_image + row * raw_width;\n      nblocks = MIN(8, raw_height - row) * raw_width >> 6;\n      for (block = 0; block < nblocks; block++)\n      {\n        memset(diffbuf, 0, sizeof diffbuf);\n        for (i = 0; i < 64; i++)\n        {\n          leaf = gethuff(huff[i > 0]);\n          if (leaf == 0 && i)\n            break;\n          if (leaf == 0xff)\n            continue;\n          i += leaf >> 4;\n          len = leaf & 15;\n          if (len == 0)\n            continue;\n          diff = getbits(len);\n          if ((diff & (1 << (len - 1))) == 0)\n            diff -= (1 << len) - 1;\n          if (i < 64)\n            diffbuf[i] = diff;\n        }\n        diffbuf[0] += carry;\n        carry = diffbuf[0];\n        for (i = 0; i < 64; i++)\n        {\n          if (pnum++ % raw_width == 0)\n            base[0] = base[1] = 512;\n          if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n            derror();\n        }\n      }\n      if (lowbits)\n      {\n        save = ftell(ifp);\n        fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);\n        for (prow = pixel, i = 0; i < raw_width * 2; i++)\n        {\n          c = fgetc(ifp);\n          for (r = 0; r < 8; r += 2, prow++)\n          {\n            val = (*prow << 2) + ((c >> r) & 3);\n            if (raw_width == 2672 && val < 512)\n              val += 2;\n            *prow = val;\n          }\n        }\n        fseek(ifp, save, SEEK_SET);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    FORC(2) free(huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free(huff[c]);\n}\n\nint CLASS ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end(struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free(jh->free[c]);\n  free(jh->row);\n}\n\nint CLASS ljpeg_diff(ushort *huff)\n{\n  int len, diff;\n  if (!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len - 1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort *CLASS ljpeg_row(int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred = 0;\n  ushort mark = 0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0)\n  {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);\n    if (jrow)\n    {\n      fseek(ifp, -2, SEEK_CUR);\n      do\n        mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);\n  for (col = 0; col < jh->wide; col++)\n    FORC(jh->clrs)\n    {\n      diff = ljpeg_diff(jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n        pred = spred;\n      else if (col)\n        pred = row[0][-jh->clrs];\n      else\n        pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col)\n        switch (jh->psv)\n        {\n        case 1:\n          break;\n        case 2:\n          pred = row[1][0];\n          break;\n        case 3:\n          pred = row[1][-jh->clrs];\n          break;\n        case 4:\n          pred = pred + row[1][0] - row[1][-jh->clrs];\n          break;\n        case 5:\n          pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\n          break;\n        case 6:\n          pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\n          break;\n        case 7:\n          pred = (pred + row[1][0]) >> 1;\n          break;\n        default:\n          pred = 0;\n        }\n      if ((**row = pred + diff) >> jh->bits)\n        derror();\n      if (c <= jh->sraw)\n        spred = **row;\n      row[0]++;\n      row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n\n  if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if (jh.clrs == 4 && jwide >= raw_width * 2)\n    jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (jrow = 0; jrow < jh.high; jrow++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      rp = ljpeg_row(jrow, &jh);\n      if (load_flags & 1)\n        row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;\n      for (jcol = 0; jcol < jwide; jcol++)\n      {\n        val = curve[*rp++];\n        if (cr2_slice[0])\n        {\n          jidx = jrow * jwide + jcol;\n          i = jidx / (cr2_slice[1] * raw_height);\n          if ((j = i >= cr2_slice[0]))\n            i = cr2_slice[0];\n          jidx -= i * (cr2_slice[1] * raw_height);\n          row = jidx / cr2_slice[1 + j];\n          col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];\n        }\n        if (raw_width == 3984 && (col -= 2) < 0)\n          col += (row--, raw_width);\n        if (row > raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp(failure, 3);\n#endif\n        if ((unsigned)row < raw_height)\n          RAW(row, col) = val;\n        if (++col >= raw_width)\n          col = (row++, 0);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  ljpeg_end(&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp = 0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;\n  int v[3] = {0, 0, 0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start(&jh, 0) || jh.clrs < 4)\n    return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_flags & 256)\n  {\n    width = raw_width;\n    height = raw_height;\n  }\n\n  try\n  {\n#endif\n    for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)\n    {\n      scol = ecol;\n      ecol += cr2_slice[1] * 2 / jh.clrs;\n      if (!cr2_slice[0] || ecol > raw_width - 1)\n        ecol = raw_width & -2;\n      for (row = 0; row < height; row += (jh.clrs >> 1) - 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        ip = (short(*)[4])image + row * width;\n        for (col = scol; col < ecol; col += 2, jcol += jh.clrs)\n        {\n          if ((jcol %= jwide) == 0)\n            rp = (short *)ljpeg_row(jrow++, &jh);\n          if (col >= width)\n            continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC(jh.clrs - 2)\n            {\n              ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n              ip[col + (c >> 1) * width + (c & 1)][1] = ip[col + (c >> 1) * width + (c & 1)][2] = 8192;\n            }\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else\n#endif\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;\n          }\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    ljpeg_end(&jh);\n    maximum = 0x3fff;\n    height = saved_h;\n    width = saved_w;\n    return;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (cp = model2; *cp && !isdigit(*cp); cp++)\n      ;\n    sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);\n    ver = (v[0] * 1000 + v[1]) * 1000 + v[2];\n    hue = (jh.sraw + 1) << 2;\n    if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n      hue = jh.sraw << 1;\n    ip = (short(*)[4])image;\n    rp = ip[0];\n    for (row = 0; row < height; row++, ip += width)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (row & (jh.sraw >> 1))\n      {\n        for (col = 0; col < width; col += 2)\n          for (c = 1; c < 3; c++)\n            if (row == height - 1)\n            {\n              ip[col][c] = ip[col - width][c];\n            }\n            else\n            {\n              ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;\n            }\n      }\n      for (col = 1; col < width; col += 2)\n        for (c = 1; c < 3; c++)\n          if (col == width - 1)\n            ip[col][c] = ip[col - 1][c];\n          else\n            ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB))\n#endif\n      for (; rp < ip[0]; rp += 4)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        if (unique_id == 0x80000218 || unique_id == 0x80000250 || unique_id == 0x80000261 || unique_id == 0x80000281 ||\n            unique_id == 0x80000287)\n        {\n          rp[1] = (rp[1] << 2) + hue;\n          rp[2] = (rp[2] << 2) + hue;\n          pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);\n          pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);\n          pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);\n        }\n        else\n        {\n          if (unique_id < 0x80000218)\n            rp[0] -= 512;\n          pix[0] = rp[0] + rp[2];\n          pix[2] = rp[0] + rp[1];\n          pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);\n        }\n        FORC3 rp[c] = CLIP15(pix[c] * sraw_mul[c] >> 10);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end(&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select)\n    (*rp)++;\n  if (raw_image)\n  {\n    if (row < raw_height && col < raw_width)\n      RAW(row, col) = curve[**rp];\n    *rp += tiff_samples;\n  }\n  else\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (row < raw_height && col < raw_width)\n      FORC(tiff_samples)\n    image[row * raw_width + col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n#else\n    if (row < height && col < width)\n      FORC(tiff_samples)\n    image[row * width + col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n#endif\n  }\n  if (tiff_samples == 2 && shot_select)\n    (*rp)--;\n}\n\nvoid CLASS ljpeg_idct(struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = {0};\n  static const uchar zigzag[80] = {0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33,\n                                   40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36,\n                                   29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,\n                                   47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;\n  memset(work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];\n  for (i = 1; i < 64; i++)\n  {\n    len = gethuff(jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15)\n      break;\n    coef = getbits(len);\n    if ((coef & (1 << (len - 1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n    if (!ljpeg_start(&jh, 0))\n      break;\n    jwide = jh.wide;\n    if (filters)\n      jwide *= jh.clrs;\n    jwide /= MIN(is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      switch (jh.algo)\n      {\n      case 0xc1:\n        jh.vpred[0] = 16384;\n        getbits(-1);\n        for (jrow = 0; jrow + 7 < jh.high; jrow += 8)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (jcol = 0; jcol + 7 < jh.wide; jcol += 8)\n          {\n            ljpeg_idct(&jh);\n            rp = jh.idct;\n            row = trow + jcol / tile_width + jrow * 2;\n            col = tcol + jcol % tile_width;\n            for (i = 0; i < 16; i += 2)\n              for (j = 0; j < 8; j++)\n                adobe_copy_pixel(row + i, col + j, &rp);\n          }\n        }\n        break;\n      case 0xc3:\n        for (row = col = jrow = 0; jrow < jh.high; jrow++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          rp = ljpeg_row(jrow, &jh);\n          for (jcol = 0; jcol < jwide; jcol++)\n          {\n            adobe_copy_pixel(trow + row, tcol + col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      ljpeg_end(&jh);\n      throw;\n    }\n#endif\n    fseek(ifp, save + 4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end(&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *)calloc(raw_width, tiff_samples * sizeof *pixel);\n  merror(pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (tiff_bps == 16)\n        read_shorts(pixel, raw_width * tiff_samples);\n      else\n      {\n        getbits(-1);\n        for (col = 0; col < raw_width * tiff_samples; col++)\n          pixel[col] = getbits(tiff_bps);\n      }\n      for (rp = pixel, col = 0; col < raw_width; col++)\n        adobe_copy_pixel(row, col, &rp);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek(ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n  for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)\n    huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  int bypp = tiff_bps <= 8 ? 1 : 2;\n  int bufsize = width * 3 * bypp;\n\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for (int row = 0; row < raw_height; row++)\n  {\n    int red = fread(buf, 1, bufsize, ifp);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (tiff_bps <= 8)\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    else\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n  }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n      {0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0,  0,  0, 0, 0, 0, /* 12-bit lossy */\n       5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},\n      {0,    1,    5,    1,    1,    1, 1, 1, 1, 2, 0, 0,  0,  0, 0, 0, /* 12-bit lossy after split */\n       0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},\n      {0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0,  0,  0, 0, 0, 0, /* 12-bit lossless */\n       5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},\n      {0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0,  0,  0,  0,  0, 0, /* 14-bit lossy */\n       5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},\n      {0, 1,    5,    1,    1,    1, 1, 1, 1, 1, 2, 0, 0, 0,  0, 0, /* 14-bit lossy after split */\n       8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},\n      {0, 1, 4, 2, 2, 3, 1,  2, 0,  0,  0, 0, 0, 0,  0, 0, /* 14-bit lossless */\n       7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step = 0, tree = 0, split = 0, row, col, len, shl, diff;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46)\n    tree = 2;\n  if (tiff_bps == 14)\n    tree += 3;\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize - 1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0)\n  {\n    for (i = 0; i < csize; i++)\n      curve[i * step] = get2();\n    for (i = 0; i < max; i++)\n      curve[i] = (curve[i - i % step] * (step - i % step) + curve[i - i % step + step] * (i % step)) / step;\n    fseek(ifp, meta_offset + 562, SEEK_SET);\n    split = get2();\n  }\n  else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts(curve, max = csize);\n  while (curve[max - 2] == curve[max - 1])\n    max--;\n  huff = make_decoder(nikon_tree[tree]);\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (min = row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (split && row == split)\n      {\n        free(huff);\n        huff = make_decoder(nikon_tree[tree + 1]);\n        max += (min = 16) << 1;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        i = gethuff(huff);\n        len = i & 15;\n        shl = i >> 4;\n        diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;\n        if ((diff & (1 << (len - 1))) == 0)\n          diff -= (1 << len) - !shl;\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if ((ushort)(hpred[col & 1] + min) >= max)\n          derror();\n        RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(huff);\n    throw;\n  }\n#endif\n  free(huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col = 0; col < raw_width; col++)\n    {\n      if (!(b = col & 1))\n      {\n        bitbuf = 0;\n        FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;\n        FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705 * yuv[3];\n      rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];\n      rgb[2] = yuv[b] + 1.732446 * yuv[2];\n      FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = {0x00, 0x55, 0xaa, 0xff};\n\n  memset(histo, 0, sizeof histo);\n  fseek(ifp, -2000, SEEK_END);\n  for (i = 0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i = 0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek(ifp, 0, SEEK_SET);\n  for (i = 0; i < 1024; i++)\n  {\n    fread(t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4 & t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct\n  {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n      {0x00, \"Pentax\", \"Optio 33WR\"}, {0x03, \"Nikon\", \"E3200\"}, {0x32, \"Nikon\", \"E3700\"}, {0x33, \"Olympus\", \"C740UZ\"}};\n\n  fseek(ifp, 3072, SEEK_SET);\n  fread(dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits)\n    {\n      strcpy(make, table[i].t_make);\n      strcpy(model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"ppm_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread(thumb, 1, thumb_length, ifp);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)calloc(thumb_length, 2);\n  merror(thumb, \"ppm16_thumb()\");\n  read_shorts((ushort *)thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n    thumb[i] = ((ushort *)thumb)[i] >> 8;\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = {\"012\", \"102\"};\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width * thumb_height;\n  thumb = (char *)calloc(colors, thumb_length);\n  merror(thumb, \"layer_thumb()\");\n  fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width, thumb_height);\n  fread(thumb, thumb_length, colors, ifp);\n  for (i = 0; i < thumb_length; i++)\n    FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);\n  free(thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *)calloc(thumb_length, 2);\n  merror(thumb, \"rollei_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts(thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n  {\n    putc(thumb[i] << 3, ofp);\n    putc(thumb[i] >> 5 << 2, ofp);\n    putc(thumb[i] >> 11 << 3, ofp);\n  }\n  free(thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(raw_width > 32767 || raw_height > 32767)\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n#endif\n  unsigned maxpixel = raw_width*(raw_height+7);\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread(pixel, 1, 10, ifp) == 10)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i = 0; i < 10; i += 2)\n    {\n      todo[i] = iten++;\n      todo[i + 1] = pixel[i] << 8 | pixel[i + 1];\n      buffer = pixel[i] >> 2 | buffer << 6;\n    }\n    for (; i < 16; i += 2)\n    {\n      todo[i] = isix++;\n      todo[i + 1] = buffer >> (14 - i) * 5;\n    }\n    for (i = 0; i < 16; i += 2)\n      if(todo[i] < maxpixel)\n        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n      else\n        derror();\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw(unsigned row, unsigned col) { return (row < raw_height && col < raw_width) ? RAW(row, col) : 0; }\n\nvoid CLASS phase_one_flat_field(int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts(head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0)\n    return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *)calloc(nc * wide, sizeof *mrow);\n  merror(mrow, \"phase_one_flat_field()\");\n  for (y = 0; y < high; y++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x = 0; x < wide; x++)\n      for (c = 0; c < nc; c += 2)\n      {\n        num = is_float ? getreal(11) : get2() / 32768.0;\n        if (y == 0)\n          mrow[c * wide + x] = num;\n        else\n          mrow[(c + 1) * wide + x] = (num - mrow[c * wide + x]) / head[5];\n      }\n    if (y == 0)\n      continue;\n    rend = head[1] + y * head[5];\n    for (row = rend - head[5]; row < raw_height && row < rend && row < head[1] + head[3] - head[5]; row++)\n    {\n      for (x = 1; x < wide; x++)\n      {\n        for (c = 0; c < nc; c += 2)\n        {\n          mult[c] = mrow[c * wide + x - 1];\n          mult[c + 1] = (mrow[c * wide + x] - mult[c]) / head[4];\n        }\n        cend = head[0] + x * head[4];\n        for (col = cend - head[4]; col < raw_width && col < cend && col < head[0] + head[2] - head[4]; col++)\n        {\n          c = nc > 2 ? FC(row - top_margin, col - left_margin) : 0;\n          if (!(c & 1))\n          {\n            c = RAW(row, col) * mult[c];\n            RAW(row, col) = LIM(c, 0, 65535);\n          }\n          for (c = 0; c < nc; c += 2)\n            mult[c] += mult[c + 1];\n        }\n      }\n      for (x = 0; x < wide; x++)\n        for (c = 0; c < nc; c += 2)\n          mrow[c * wide + x] += mrow[(c + 1) * wide + x];\n    }\n  }\n  free(mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {{-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n                                               {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!meta_length)\n#else\n  if (half_size || !meta_length)\n#endif\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Phase One correction...\\n\"));\n#endif\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    while (entries--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x419)\n      { /* Polynomial curve */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(11);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x41a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(11);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n            for (row = 0; row < raw_height; row++)\n              if (FC(row - top_margin, col - left_margin) == 1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) = 0.5 + sum * 0.0732233 + (raw(row, col - 2) + raw(row, col + 2)) * 0.3535534;\n              }\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += raw(row + dir[i][0], col + dir[i][1]);\n            RAW(row, col) = (sum + 4) >> 3;\n          }\n        }\n      }\n      else if (tag == 0x401)\n      { /* All-color flat fields */\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x416 || tag == 0x410)\n      {\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x40b)\n      { /* Red+blue flat field */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x41f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 16; i++)\n              lc[qr][qc][i] = get4();\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x41e && !qmult_applied)\n      { /* Quadrant multipliers */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(11);\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x431 && !qmult_applied)\n      { /* Quadrant combined */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      merror(yval[0], \"phase_one_correct()\");\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(11);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n            frac = (j == 0 || j == head[1]) ? 0 : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);\n            mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek(ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555 : 0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw()\");\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw()\");\n    if (ph1.black_col)\n    {\n      fseek(ifp, ph1.black_col, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height * 2);\n    }\n    if (ph1.black_row)\n    {\n      fseek(ifp, ph1.black_row, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_rblack[0], raw_width * 2);\n    }\n  }\n#endif\n  fseek(ifp, data_offset, SEEK_SET);\n  read_shorts(raw_image, raw_width * raw_height);\n  if (ph1.format)\n    for (i = 0; i < raw_width * raw_height; i += 2)\n    {\n      a = raw_image[i + 0] ^ akey;\n      b = raw_image[i + 1] ^ bkey;\n      raw_image[i + 0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i + 1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff(int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf = 0;\n  static int vbits = 0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0)\n    return 0;\n  if (vbits < nbits)\n  {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64 - vbits) >> (64 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    return (uchar)huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n, 0)\n#define ph1_huff(h) ph1_bithuff(*h, h + 1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = {8, 7, 6, 9, 11, 10, 5, 12, 14, 13};\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short(*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *)calloc(raw_width * 3 + raw_height * 4, 2);\n  merror(pixel, \"phase_one_load_raw_c()\");\n  offset = (int *)(pixel + raw_width);\n  fseek(ifp, strip_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short(*)[2])(offset + raw_height);\n  fseek(ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n    read_shorts((ushort *)c_black[0], raw_height * 2);\n  r_black = c_black + raw_height;\n  fseek(ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n    read_shorts((ushort *)r_black[0], raw_width * 2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_cblack, (ushort *)c_black[0], raw_height * 2 * sizeof(ushort));\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_rblack, (ushort *)r_black[0], raw_width * 2 * sizeof(ushort));\n  }\n#endif\n\n  for (i = 0; i < 256; i++)\n    curve[i] = i * i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + offset[row], SEEK_SET);\n      ph1_bits(-1);\n      pred[0] = pred[1] = 0;\n      for (col = 0; col < raw_width; col++)\n      {\n        if (col >= (raw_width & -8))\n          len[0] = len[1] = 14;\n        else if ((col & 7) == 0)\n          for (i = 0; i < 2; i++)\n          {\n            for (j = 0; j < 5 && !ph1_bits(1); j++)\n              ;\n            if (j--)\n              len[i] = length[j * 2 + ph1_bits(1)];\n          }\n        if ((i = len[col & 1]) == 14)\n          pixel[col] = pred[col & 1] = ph1_bits(16);\n        else\n          pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n        if (pred[col & 1] >> 16)\n          derror();\n        if (ph1.format == 5 && pixel[col] < 256)\n          pixel[col] = curve[pixel[col]];\n      }\n#ifndef LIBRAW_LIBRARY_BUILD\n      for (col = 0; col < raw_width; col++)\n      {\n        int shift = ph1.format == 8 ? 0 : 2;\n        i = (pixel[col] << shift) - ph1.t_black + c_black[row][col >= ph1.split_col] +\n            r_black[col][row >= ph1.split_row];\n        if (i > 0)\n          RAW(row, col) = i;\n      }\n#else\n    if (ph1.format == 8)\n      memmove(&RAW(row, 0), &pixel[0], raw_width * 2);\n    else\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = pixel[col] << 2;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    back[4] = (int *)calloc(raw_width, 3 * sizeof **back);\n    merror(back[4], \"hasselblad_load_raw()\");\n    FORC3 back[c] = back[4] + c * raw_width;\n    cblack[6] >>= sh = tiff_samples > 1;\n    shot = LIM(shot_select, 1, tiff_samples) - 1;\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      FORC4 back[(c + 3) & 3] = back[c];\n      for (col = 0; col < raw_width; col += 2)\n      {\n        for (s = 0; s < tiff_samples * 2; s += 2)\n        {\n          FORC(2) len[c] = ph1_huff(jh.huff[0]);\n          FORC(2)\n          {\n            diff[s + c] = ph1_bits(len[c]);\n            if ((diff[s + c] & (1 << (len[c] - 1))) == 0)\n              diff[s + c] -= (1 << len[c]) - 1;\n            if (diff[s + c] == 65535)\n              diff[s + c] = -32768;\n          }\n        }\n        for (s = col; s < col + 2; s++)\n        {\n          pred = 0x8000 + load_flags;\n          if (col)\n            pred = back[2][s - 2];\n          if (col && row > 1)\n            switch (jh.psv)\n            {\n            case 11:\n              pred += back[0][s] / 2 - back[0][s - 2] / 2;\n              break;\n            }\n          f = (row & 1) * 3 ^ ((col + s) & 1);\n          FORC(tiff_samples)\n          {\n            pred += diff[(s & 1) * tiff_samples + c];\n            upix = pred >> sh & 0xffff;\n            if (raw_image && c == shot)\n              RAW(row, s) = upix;\n            if (image)\n            {\n              urow = row - top_margin + (c & 1);\n              ucol = col - left_margin - ((c >> 1) & 1);\n              ip = &image[urow * width + ucol][f];\n              if (urow < height && ucol < width)\n                *ip = c < 4 ? upix : (*ip + upix) >> 1;\n            }\n          }\n          back[2][s] = pred;\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(back[4]);\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  free(back[4]);\n  ljpeg_end(&jh);\n  if (image)\n    mix_green = 1;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel = 0;\n  unsigned tile = 0, r, c, row, col;\n\n  if (!filters || !raw_image)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!image)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n    merror(pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    FORC(tiff_samples)\n    for (r = 0; r < raw_height; r++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (r % tile_length == 0)\n      {\n        fseek(ifp, data_offset + 4 * tile++, SEEK_SET);\n        fseek(ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select)\n        continue;\n      if (filters && raw_image)\n        pixel = raw_image + r * raw_width;\n      read_shorts(pixel, raw_width);\n      if (!filters && image && (row = r - top_margin) < height)\n        for (col = 0; col < width; col++)\n          image[row * width + col][c] = pixel[col + left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (!filters)\n      free(pixel);\n    throw;\n  }\n#endif\n  if (!filters)\n  {\n    maximum = 0xffff;\n    raw_color = 1;\n    free(pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  read_shorts(raw_image, raw_width * raw_height);\n  if (maximum < 0xffff || load_flags)\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < raw_width; col++)\n        if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n            (unsigned)(col - left_margin) < width)\n          derror();\n    }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  for (row = raw_height - 1; row >= 0; row--)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    read_shorts(&raw_image[row * raw_width], raw_width);\n    for (col = 0; col < raw_width; col++)\n      if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n          (unsigned)(col - left_margin) < width)\n        derror();\n  }\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \"imacon_full_load_raw\");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits = 0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf = 0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1)\n    bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height + 1) >> 1;\n  for (irow = 0; irow < raw_height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 && (row = irow % half * 2 + irow / half) == 1 && load_flags & 4)\n    {\n      if (vbits = 0, tiff_compress)\n        fseek(ifp, data_offset - (-half * bwide & -2048), SEEK_SET);\n      else\n      {\n        fseek(ifp, 0, SEEK_END);\n        fseek(ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col = 0; col < raw_width; col++)\n    {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      val = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);\n      RAW(row, col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) && row < height + top_margin && col < width + left_margin)\n        derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom()\n{\n\n  /* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct\n  {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek(ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread(&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right) * 5) + 3) >> 2) + 0x1f) & (~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616; /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order)\n  {\n  case 0: /* RGGB */\n    filters = 0x94949494;\n    break;\n  case 1: /* GBRG */\n    filters = 0x49494949;\n    break;\n  case 3: /* GRBG */\n    filters = 0x61616161;\n    break;\n  }\n}\n\nvoid CLASS broadcom_load_raw()\n{\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *)malloc(raw_stride * 2);\n  merror(data, \"broadcom_load_raw()\");\n\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data + raw_stride, 1, raw_stride, ifp) < raw_stride)\n      derror();\n    FORC(raw_stride) data[c] = data[raw_stride + (c ^ rev)];\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar *data, *dp;\n  int rev, dwide, row, col, c;\n  double sum[] = {0, 0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *)malloc(dwide * 2);\n  merror(data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(data + dwide, 1, dwide, ifp) < dwide)\n        derror();\n      FORC(dwide) data[c] = data[dwide + (c ^ rev)];\n      for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n        FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n#endif\n  free(data);\n  maximum = 0x3ff;\n  if (strncmp(make, \"OmniVision\", 10))\n    return;\n  row = raw_height / 2;\n  FORC(width - 1)\n  {\n    sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));\n    sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));\n  }\n  if (sum[1] > sum[0])\n    filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf = 0;\n\n  bwide = (raw_width + 5) / 6 << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_loose_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 8, col += 6)\n    {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c ^ 7];\n      FORC(6) RAW(row, col + c) = (bitbuf >> c * 10) & 0x3ff;\n    }\n  }\n  free(data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));\n  merror(words, \"canon_rmf_load_raw\");\n#endif\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words, sizeof(int), raw_width / 3, ifp);\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = words[col / 3];\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#else\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = get4();\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits(int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4002];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits)\n    return vbits = 0;\n  if (!vbits)\n  {\n    fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);\n    fread(buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte + 1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)\n        derror();\n    }\n  }\n}\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n = 0] = 0xc0c;\n  for (i = 12; i--;)\n    FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;\n  fseek(ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(acarry, 0, sizeof acarry);\n    for (col = 0; col < raw_width; col++)\n    {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)\n        ;\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12, huff)) == 12)\n        high = getbits(16 - nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff * 3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;\n      if (col >= width)\n        continue;\n      if (row < 2 && col < 2)\n        pred = 0;\n      else if (row < 2)\n        pred = RAW(row, col - 2);\n      else if (col < 2)\n        pred = RAW(row - 2, col);\n      else\n      {\n        w = RAW(row, col - 2);\n        n = RAW(row - 2, col);\n        nw = RAW(row - 2, col - 2);\n        if ((w < nw && nw < n) || (n < nw && nw < w))\n        {\n          if (ABS(w - nw) > 32 || ABS(n - nw) > 32)\n            pred = w + n - nw;\n          else\n            pred = (w + n) >> 1;\n        }\n        else\n          pred = ABS(w - nw) > ABS(n - nw) ? w : n;\n      }\n      if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)\n        derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow = 0; irow < 1481; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 768, ifp) < 768)\n      derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);\n    switch (irow)\n    {\n    case 1477:\n    case 1479:\n      continue;\n    case 1476:\n      row = 984;\n      break;\n    case 1480:\n      row = 985;\n      break;\n    case 1478:\n      row = 985;\n      box = 1;\n    }\n    if ((box < 12) && (box & 1))\n    {\n      for (col = 0; col < 1533; col++, row ^= 1)\n        if (col != 1)\n          RAW(row, col) = (col + 1) & 2 ? pixel[col / 2 - 1] + pixel[col / 2 + 1] : pixel[col / 2] << 1;\n      RAW(row, 1) = pixel[1] << 1;\n      RAW(row, 1533) = pixel[765] << 1;\n    }\n    else\n      for (col = row & 1; col < 1534; col += 2)\n        RAW(row, col) = pixel[col / 2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2, 2, 8, 15, 22, 32, 44, 60, 89};\n  static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},   {-8, -2, 2, 8},\n                                    {-13, -3, 3, 13}, {-19, -4, 4, 19}, {-28, -6, 6, 28}};\n  static const short t_curve[256] = {\n      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   11,  12,   13,   14,  15,  16,  17,  18,  19,  20,  21,  22,\n      23,  24,  25,  26,  27,  28,  29,  30,  32,  33,  34,  35,   36,   37,  38,  39,  40,  41,  42,  43,  44,  45,\n      46,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,   59,   60,  61,  62,  63,  64,  65,  66,  67,  68,\n      69,  70,  71,  72,  74,  75,  76,  77,  78,  79,  80,  81,   82,   83,  84,  86,  88,  90,  92,  94,  97,  99,\n      101, 103, 105, 107, 110, 112, 114, 116, 118, 120, 123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147,\n      149, 151, 153, 155, 158, 160, 162, 164, 166, 168, 171, 173,  175,  177, 179, 181, 184, 186, 188, 190, 192, 195,\n      197, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 221,  223,  226, 230, 235, 239, 244, 248, 252, 257, 261,\n      265, 270, 274, 278, 283, 287, 291, 296, 300, 305, 309, 313,  318,  322, 326, 331, 335, 339, 344, 348, 352, 357,\n      361, 365, 370, 374, 379, 383, 387, 392, 396, 400, 405, 409,  413,  418, 422, 426, 431, 435, 440, 444, 448, 453,\n      457, 461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,  519,  531, 542, 553, 564, 575, 587, 598, 609, 620,\n      631, 643, 654, 665, 676, 687, 698, 710, 721, 732, 743, 754,  766,  777, 788, 799, 810, 822, 833, 844, 855, 866,\n      878, 889, 900, 911, 922, 933, 945, 956, 967, 978, 989, 1001, 1012, 1023};\n  int rb, row, col, sharp, val = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(width>640 || height > 480)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  getbits(-1);\n  memset(pixel, 0x80, sizeof pixel);\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 2 + (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] + pixel[row][col - 2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val, 0, 255);\n      if (col < 4)\n        pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;\n      if (row == 2)\n        pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb = 0; rb < 2; rb++)\n    for (row = 2 + rb; row < height + 2; row += 2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 3 - (row & 1); col < width + 2; col += 2)\n      {\n        if (row < 4 || col < 4)\n          sharp = 2;\n        else\n        {\n          val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) + ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +\n                ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);\n          sharp = val < 4 ? 0 : val < 8 ? 1 : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;\n        }\n        val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) + rstep[sharp][getbits(2)];\n        pixel[row][col] = val = LIM(val, 0, 255);\n        if (row < 4)\n          pixel[row - 2][col + 2] = val;\n        if (col < 4)\n          pixel[row + 2][col - 2] = val;\n      }\n    }\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 3 - (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row][col - 1] + (pixel[row][col] << 2) + pixel[row][col + 1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val, 0, 255);\n    }\n  }\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n      RAW(row, col) = t_curve[pixel[row + 2][col + 2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char)getbithuff(8, huff[tree]))\n\n#define FORYX                                                                                                          \\\n  for (y = 1; y < 3; y++)                                                                                              \\\n    for (x = col + 1; x >= col; x--)\n\n#define PREDICTOR                                                                                                      \\\n  (c ? (buf[c][y - 1][x] + buf[c][y][x + 1]) / 2 : (buf[c][y - 1][x + 1] + 2 * buf[c][y - 1][x] + buf[c][y][x + 1]) / 4)\n\n#ifdef __GNUC__\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n#pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n#endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  // All kodak radc images are 768x512\n  if (width > 768 || raw_width > 768 || height > 512 || raw_height > 512)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }\n  for (i = 0; i < height * width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer(j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread(jpeg_buffer, 1, 4096, ifp);\n  swab(jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header(&cinfo, TRUE);\n  jpeg_start_decompress(&cinfo);\n  if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n  {\n    fprintf(stderr, _(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress(&cinfo);\n    longjmp(failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * 3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines(&cinfo, buf, 1);\n    pixel = (JSAMPLE(*)[3])buf[0];\n    for (col = 0; col < width; col += 2)\n    {\n      RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n      RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n      RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n      RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n    }\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if (data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf, \"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char *)malloc(width * 3);\n  jpeg_create_decompress(&cinfo);\n  merror(pixel_buf, \"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf, data_size, 1, ifp);\n  swab((char *)jpg_buf, (char *)jpg_buf, data_size);\n  try\n  {\n    jpeg_mem_src(&cinfo, jpg_buf, data_size);\n    int rc = jpeg_read_header(&cinfo, TRUE);\n    if (rc != 1)\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n    jpeg_start_decompress(&cinfo);\n    if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n    {\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n\n    unsigned char *buf[1];\n    buf[0] = pixel_buf;\n\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n      checkCancel();\n      row = cinfo.output_scanline * 2;\n      jpeg_read_scanlines(&cinfo, buf, 1);\n      unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];\n      for (col = 0; col < width; col += 2)\n      {\n        RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n        RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n        RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n        RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n      }\n    }\n  }\n  catch (...)\n  {\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(jpg_buf);\n    free(pixel_buf);\n    throw;\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  unsigned sorder = order, ntags, opcode, deg, i, j, c;\n  unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset)\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--)\n    {\n      opcode = get4();\n      get4();\n      get4();\n      if (opcode != 8)\n      {\n        fseek(ifp, get4(), SEEK_CUR);\n        continue;\n      }\n      fseek(ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2)\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8)\n        break;\n      for (i = 0; i <= deg && i < 9; i++)\n        coeff[i] = getreal(12);\n      for (i = 0; i < 256; i++)\n      {\n        for (tot = j = 0; j <= deg; j++)\n          tot += coeff[j] * pow(i / 255.0, (int)j);\n        cur[c][i] = tot * 0xffff;\n      }\n    }\n    order = sorder;\n  }\n  else\n  {\n    gamma_curve(1 / 2.4, 12.92, 1, 255);\n    FORC3 memcpy(cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  while (trow < raw_height)\n  {\n    fseek(ifp, save += 4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n#else\n    jpeg_stdio_src(&cinfo, ifp);\n#endif\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, cinfo.output_width * 3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      while (cinfo.output_scanline < cinfo.output_height && (row = trow + cinfo.output_scanline) < height)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        jpeg_read_scanlines(&cinfo, buf, 1);\n        pixel = (JSAMPLE(*)[3])buf[0];\n        for (col = 0; col < cinfo.output_width && tcol + col < width; col++)\n        {\n          FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw;\n    }\n#endif\n    jpeg_abort_decompress(&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = {162, 192, 187, 92};\n  static const int add[4] = {0, 636, 424, 212};\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 848, ifp) < 848)\n      derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col = 0; col < width; col++)\n      RAW(row, col) = (ushort)pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, 1, raw_width, ifp) < raw_width)\n        derror();\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = curve[pixel[col]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] = {\n      {0, 1, 5, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n      {0, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi = 0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder(kodak_tree[c]);\n  ns = (raw_height + 63) >> 5;\n  pixel = (uchar *)malloc(raw_width * 32 + ns * 4);\n  merror(pixel, \"kodak_262_load_raw()\");\n  strip = (int *)(pixel + raw_width * 32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if ((row & 31) == 0)\n      {\n        fseek(ifp, strip[row >> 5], SEEK_SET);\n        getbits(-1);\n        pi = 0;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        chess = (row + col) & 1;\n        pi1 = chess ? pi - 2 : pi - raw_width - 1;\n        pi2 = chess ? pi - 2 * raw_width : pi - raw_width + 1;\n        if (col <= chess)\n          pi1 = -1;\n        if (pi1 < 0)\n          pi1 = pi2;\n        if (pi2 < 0)\n          pi2 = pi1;\n        if (pi1 < 0 && col > 1)\n          pi1 = pi2 = pi - 2;\n        pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n        pixel[pi] = val = pred + ljpeg_diff(huff[chess]);\n        if (val >> 8)\n          derror();\n        val = curve[pixel[pi++]];\n        RAW(row, col) = val;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  FORC(2) free(huff[c]);\n}\n\nint CLASS kodak_65000_decode(short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf = 0;\n  int save, bits = 0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i = 0; i < bsize; i += 2)\n  {\n    c = fgetc(ifp);\n    if ((blen[i] = c & 15) > 12 || (blen[i + 1] = c >> 4) > 12)\n    {\n      fseek(ifp, save, SEEK_SET);\n      for (i = 0; i < bsize; i += 8)\n      {\n        read_shorts(raw, 6);\n        out[i] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n        out[i + 1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n        for (j = 0; j < 6; j++)\n          out[i + 2 + j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4)\n  {\n    bitbuf = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i = 0; i < bsize; i++)\n  {\n    len = blen[i];\n    if (bits < len)\n    {\n      for (j = 0; j < 32; j += 8)\n        bitbuf += (INT64)fgetc(ifp) << (bits + (j ^ 8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16 - len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len - 1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[272]; /* 264 looks enough */\n  int row, col, len, pred[2], ret, i;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      pred[0] = pred[1] = 0;\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len);\n      for (i = 0; i < len; i++)\n      {\n        int idx = ret ? buf[i] : (pred[i & 1] += buf[i]);\n        if (idx >= 0 && idx < 0xffff)\n        {\n          if ((RAW(row, col + i) = curve[idx]) >> 12)\n            derror();\n        }\n        else\n          derror();\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt(unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start)\n  {\n    for (p = 0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;\n    for (p = 4; p < 127; p++)\n      pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;\n    for (p = 0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n  {\n    *data++ ^= pad[p & 127] = pad[(p + 1) & 127] ^ pad[(p + 65) & 127];\n    p++;\n  }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek(ifp, 200896, SEEK_SET);\n  fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek(ifp, 164600, SEEK_SET);\n  fread(head, 1, 40, ifp);\n  sony_decrypt((unsigned *)head, 10, 1, key);\n  for (i = 26; i-- > 22;)\n    key = key << 8 | head[i];\n  fseek(ifp, data_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row * raw_width;\n    if (fread(pixel, 2, raw_width, ifp) < raw_width)\n      derror();\n    sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);\n    for (col = 0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14)\n        derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809,\n                                 0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};\n  int i, c, n, col, row, sum = 0;\n\n  huff[0] = 15;\n  for (n = i = 0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--;)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row = 0; row < raw_height + 1; row += 2)\n    {\n      if (row == raw_height)\n        row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12)\n        derror();\n      if (row < height)\n        RAW(row, col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *)malloc(raw_width + 1);\n  merror(data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fread(data, 1, raw_width, ifp);\n      for (dp = data, col = 0; col < raw_width - 30; dp += 16)\n      {\n        max = 0x7ff & (val = sget4(dp));\n        min = 0x7ff & val >> 11;\n        imax = 0x0f & val >> 22;\n        imin = 0x0f & val >> 26;\n        for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)\n          ;\n#ifdef LIBRAW_LIBRARY_BUILD\n        /* flag checks if outside of loop */\n        if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n            || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n              pix[i] = 0;\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit = 30, i = 0; i < 16; i++)\n        if (i == imax)\n          pix[i] = max;\n        else if (i == imin)\n          pix[i] = min;\n        else\n        {\n          pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n          if (pix[i] > 0x7ff)\n            pix[i] = 0x7ff;\n          bit += 7;\n        }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i = 0; i < 16; i++, col += 2)\n          {\n            unsigned slope = pix[i] < 1001 ? 2 : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];\n            unsigned step = 1 << sh;\n            RAW(row, col) = curve[pix[i] << 1] > black + imgdata.params.sony_arw2_posterization_thr\n                                ? LIM(((slope * step * 1000) / (curve[pix[i] << 1] - black)), 0, 10000)\n                                : 0;\n          }\n        }\n        else\n        {\n          for (i = 0; i < 16; i++, col += 2)\n            RAW(row, col) = curve[pix[i] << 1];\n        }\n#else\n      for (i = 0; i < 16; i++, col += 2)\n        RAW(row, col) = curve[pix[i] << 1] >> 2;\n#endif\n        col -= col & 1 ? 1 : 31;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum = 10000;\n#endif\n  free(data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(raw_width> 32768 || raw_height > 32768)  // definitely too much for old samsung\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n#endif\n  unsigned maxpixels = raw_width*(raw_height+7);\n\n  order = 0x4949;\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, strip_offset + row * 4, SEEK_SET);\n    fseek(ifp, data_offset + get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7 : 4;\n    for (col = 0; col < raw_width; col += 16)\n    {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c])\n      {\n      case 3:\n        len[c] = ph1_bits(4);\n        break;\n      case 2:\n        len[c]--;\n        break;\n      case 1:\n        len[c]++;\n      }\n      for (c = 0; c < 16; c += 2)\n      {\n        i = len[((c & 1) << 1) | (c >> 3)];\n\tunsigned idest = RAWINDEX(row, col + c);\n\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n\tif(idest < maxpixels && isrc < maxpixels) // less than zero is handled by unsigned conversion\n  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n\telse\n  \t  derror();\n        if (c == 14)\n          c = -1;\n      }\n    }\n  }\n  for (row = 0; row < raw_height - 1; row += 2)\n    for (col = 0; col < raw_width - 1; col += 2)\n      SWAP(RAW(row, col + 1), RAW(row + 1, col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403, 0x600, 0x709,\n                                 0x80a, 0x90b, 0xa0c, 0xa0d, 0x501, 0x408, 0x402};\n  ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n = i = 0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek(ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(), get2());\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0;\n    pmode = 7;\n    FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;\n    prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green\n    prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue\n    for (tab = 0; tab + 15 < raw_width; tab += 16)\n    {\n      if (~opt & 4 && !(tab & 63))\n      {\n        i = ph1_bits(2);\n        mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n        pmode = 7 - 4 * ph1_bits(1);\n      else if (!ph1_bits(1))\n        pmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1))\n      {\n        FORC4 len[c] = ph1_bits(2);\n        FORC4\n        {\n          i = ((row & 1) << 1 | (c & 1)) % 3;\n          len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);\n          lent[i][0] = lent[i][1];\n          lent[i][1] = len[c];\n        }\n      }\n      FORC(16)\n      {\n        col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));\n        pred =\n            (pmode == 7 || row < 2)\n                ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)\n                : (prow[col & 1][col - '4' + \"0224468\"[pmode]] + prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >> 1;\n        diff = ph1_bits(i = len[c >> 2]);\n        if (diff >> (i - 1))\n          diff -= 1 << i;\n        diff = diff * (mag * 2 + 1) + mag;\n        RAW(row, col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row)-raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment(unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {{7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {3, 3, 0, 0, 63, 47, 31, 15, 0}};\n  int low, high = 0xff, carry = 0, nbits = 8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[] = {0, 0};\n  ushort data = 0, range = 0;\n\n  fseek(ifp, seg[0][1] + 1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width * raw_height)\n    seg[1][0] = raw_width * raw_height;\n  for (pix = seg[0][0]; pix < seg[1][0]; pix++)\n  {\n    for (s = 0; s < 3; s++)\n    {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n        carry = (nbits += carry + 1) < 1 ? nbits - 1 : 0;\n      while (--nbits >= 0)\n        if ((data >> nbits & 0xff) == 0xff)\n          break;\n      if (nbits > 0)\n        data = ((data & ((1 << (nbits - 1)) - 1)) << 1) |\n               ((data + (((data & (1 << (nbits - 1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0)\n      {\n        data += getbits(1);\n        carry = nbits - 8;\n      }\n      count = ((((data - range + 1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin = 0; hist[s][bin + 5] > count; bin++)\n        ;\n      low = hist[s][bin + 5] * (high >> 4) >> 2;\n      if (bin)\n        high = hist[s][bin + 4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits = 0; high << nbits < 128; nbits++)\n        ;\n      range = (range + low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3])\n      {\n        next = (next + 1) & hist[s][0];\n        hist[s][3] = (hist[s][next + 4] - hist[s][next + 5]) >> 2;\n        hist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1] + 4] - hist[s][hist[s][1] + 5] > 1)\n      {\n        if (bin < hist[s][1])\n          for (i = bin; i < hist[s][1]; i++)\n            hist[s][i + 5]--;\n        else if (next <= bin)\n          for (i = hist[s][1]; i < bin; i++)\n            hist[s][i + 5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (pix >= raw_width * raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width))\n      pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek(ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment(seg, 0);\n}\n\nint CLASS median4(int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i = 1; i < 4; i++)\n  {\n    sum += p[i];\n    if (min > p[i])\n      min = p[i];\n    if (max < p[i])\n      max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes(int holes)\n{\n  int row, col, val[4];\n\n  for (row = 2; row < height - 2; row++)\n  {\n    if (!HOLE(row))\n      continue;\n    for (col = 1; col < width - 1; col += 4)\n    {\n      val[0] = RAW(row - 1, col - 1);\n      val[1] = RAW(row - 1, col + 1);\n      val[2] = RAW(row + 1, col - 1);\n      val[3] = RAW(row + 1, col + 1);\n      RAW(row, col) = median4(val);\n    }\n    for (col = 2; col < width - 2; col += 4)\n      if (HOLE(row - 2) || HOLE(row + 2))\n        RAW(row, col) = (RAW(row, col - 2) + RAW(row, col + 2)) >> 1;\n      else\n      {\n        val[0] = RAW(row, col - 2);\n        val[1] = RAW(row, col + 2);\n        val[2] = RAW(row - 2, col);\n        val[3] = RAW(row + 2, col);\n        RAW(row, col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek(ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar)fgetc(ifp);\n  fseek(ifp, offset, SEEK_SET);\n  for (i = 0; i < nseg * 2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset * (i & 1);\n  fseek(ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek(ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i = 0; i < nseg; i++)\n    smal_decode_segment(seg + i, holes);\n  if (holes)\n    fill_holes(holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen(ifname, \"rb\");\n#else\n  in = (jas_stream_t *)ifp->make_jas_stream();\n  if (!in)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek(in, data_offset + 20, SEEK_SET);\n  jimg = jas_image_decode(in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg)\n    longjmp(failure, 3);\n#else\n  if (!jimg)\n  {\n    jas_stream_close(in);\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  }\n#endif\n  jmat = jas_matrix_create(height / 2, width / 2);\n  merror(jmat, \"redcine_load_raw()\");\n  img = (ushort *)calloc((height + 2), (width + 2) * 2);\n  merror(img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try\n  {\n#endif\n    FORC4\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);\n      data = jas_matrix_getref(jmat, 0, 0);\n      for (row = c >> 1; row < height; row += 2)\n        for (col = c & 1; col < width; col += 2)\n          img[(row + 1) * (width + 2) + col + 1] = data[(row / 2) * (width / 2) + col / 2];\n    }\n    for (col = 1; col <= width; col++)\n    {\n      img[col] = img[2 * (width + 2) + col];\n      img[(height + 1) * (width + 2) + col] = img[(height - 1) * (width + 2) + col];\n    }\n    for (row = 0; row < height + 2; row++)\n    {\n      img[row * (width + 2)] = img[row * (width + 2) + 2];\n      img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];\n    }\n    for (row = 1; row <= height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));\n      for (; col <= width; col += 2, pix += 2)\n      {\n        c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] + pix[-1] + pix[1]) >> 2;\n        pix[0] = LIM(c, 0, 4095);\n      }\n    }\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n        RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    fastexitflag = true;\n  }\n#endif\n  free(img);\n  jas_matrix_destroy(jmat);\n  jas_image_destroy(jimg);\n  jas_stream_close(in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n      r,\n      raw_pitch = raw_width * 2, c, m, mblack[8], zero, val;\n#else\n      c,\n      m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw || load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width)\n  {\n    for (row = 0; row < raw_height - top_margin * 2; row++)\n    {\n      for (col = 0; col < fuji_width << !fuji_layout; col++)\n      {\n        if (fuji_layout)\n        {\n          r = fuji_width - 1 - col + (row >> 1);\n          c = col + ((row + 1) >> 1);\n        }\n        else\n        {\n          r = fuji_width - 1 + row - (col >> 1);\n          c = row + ((col + 1) >> 1);\n        }\n        if (r < height && c < width)\n          BAYER(r, c) = RAW(row + top_margin, col + left_margin);\n      }\n    }\n  }\n  else\n  {\n    for (row = 0; row < height; row++)\n      for (col = 0; col < width; col++)\n        BAYER2(row, col) = RAW(row + top_margin, col + left_margin);\n  }\n#endif\n  if (mask[0][3] > 0)\n    goto mask_set;\n  if (load_raw == &CLASS canon_load_raw || load_raw == &CLASS lossless_jpeg_load_raw)\n  {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw || load_raw == &CLASS sony_load_raw ||\n      (load_raw == &CLASS eight_bit_load_raw && strncmp(model, \"DC2\", 3)) || load_raw == &CLASS kodak_262_load_raw ||\n      (load_raw == &CLASS packed_load_raw && (load_flags & 32)))\n  {\n  sides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin + height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin + width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset(mblack, 0, sizeof mblack);\n  for (zero = m = 0; m < 8; m++)\n    for (row = MAX(mask[m][0], 0); row < MIN(mask[m][2], raw_height); row++)\n      for (col = MAX(mask[m][1], 0); col < MIN(mask[m][3], raw_width); col++)\n      {\n        c = FC(row - top_margin, col - left_margin);\n        mblack[c] += val = raw_image[(row)*raw_pitch / 2 + (col)];\n        mblack[4 + c]++;\n        zero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width)\n  {\n    black = (mblack[0] + mblack[1] + mblack[2] + mblack[3]) / (mblack[4] + mblack[5] + mblack[6] + mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  }\n  else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n  {\n    FORC4 cblack[c] = mblack[c] / mblack[4 + c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 0, 2);\n#endif\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      if (BAYER(row, col) == 0)\n      {\n        tot = n = 0;\n        for (r = row - 2; r <= row + 2; r++)\n          for (c = col - 2; c <= col + 2; c++)\n            if (r < height && c < width && FC(r, c) == FC(row, col) && BAYER(r, c))\n              tot += (n++, BAYER(r, c));\n        if (n)\n          BAYER(row, col) = tot / n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 1, 2);\n#endif\n}\n\nstatic const uchar xlat[2][256] = {\n    {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3,\n     0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d,\n     0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f, 0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b,\n     0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b,\n     0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95,\n     0x17, 0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b,\n     0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65, 0x1d,\n     0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b, 0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43,\n     0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f,\n     0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad,\n     0xe9, 0x2f, 0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35, 0xa3,\n     0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,\n     0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5, 0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07,\n     0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7},\n    {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9,\n     0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68,\n     0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad, 0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95,\n     0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68,\n     0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42,\n     0x9d, 0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca,\n     0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8, 0x87,\n     0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc, 0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45,\n     0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94,\n     0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26,\n     0xbb, 0xd6, 0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c, 0xbe,\n     0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,\n     0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb, 0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65,\n     0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f}};\n\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2] = {0, 0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1] - 1) * (g[0] - 1) <= 0)\n  {\n    for (i = 0; i < 48; i++)\n    {\n      g[2] = (bnd[0] + bnd[1]) / 2;\n      if (g[0])\n        bnd[(pow(g[2] / g[1], -g[0]) - 1) / g[0] - 1 / g[2] > -1] = g[2];\n      else\n        bnd[g[2] / exp(1 - 1 / g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0])\n      g[4] = g[2] * (1 / g[0] - 1);\n  }\n  if (g[0])\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 - g[4] * (1 - g[3]) + (1 - pow(g[3], 1 + g[0])) * (1 + g[4]) / (1 + g[0])) - 1;\n  else\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 + 1 - g[2] - g[3] - g[2] * g[3] * (log(g[3]) - 1)) - 1;\n  if (!mode--)\n  {\n    memcpy(gamm, g, sizeof gamm);\n    return;\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    curve[i] = 0xffff;\n    if ((r = (double)i / imax) < 1)\n      curve[i] = 0x10000 *\n                 (mode ? (r < g[3] ? r * g[1] : (g[0] ? pow(r, g[0]) * (1 + g[4]) - g[4] : log(r) * g[2] + 1))\n                       : (r < g[2] ? r / g[1] : (g[0] ? pow((r + g[4]) / (1 + g[4]), 1 / g[0]) : exp((r - 1) / g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse(double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n  {\n    for (j = 0; j < 6; j++)\n      work[i][j] = j == i + 3;\n    for (j = 0; j < 3; j++)\n      for (k = 0; k < size; k++)\n        work[i][j] += in[k][i] * in[k][j];\n  }\n  for (i = 0; i < 3; i++)\n  {\n    num = work[i][i];\n    for (j = 0; j < 6; j++)\n      if(fabs(num)>0.00001f)\n      \twork[i][j] /= num;\n    for (k = 0; k < 3; k++)\n    {\n      if (k == i)\n        continue;\n      num = work[k][i];\n      for (j = 0; j < 6; j++)\n        work[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i = 0; i < size; i++)\n    for (j = 0; j < 3; j++)\n      for (out[i][j] = k = 0; k < 3; k++)\n        out[i][j] += work[j][k + 3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i = 0; i < colors; i++) /* Multiply out XYZ colorspace */\n    for (j = 0; j < 3; j++)\n      for (cam_rgb[i][j] = k = 0; k < 3; k++)\n        cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i = 0; i < colors; i++)\n  {                               /* Normalize cam_rgb so that */\n    for (num = j = 0; j < 3; j++) /* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if (num > 0.00001)\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] /= num;\n      pre_mul[i] = 1 / num;\n    }\n    else\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] = 0.0;\n      pre_mul[i] = 1.0;\n    }\n  }\n  pseudoinverse(cam_rgb, inverse, colors);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n  // Coordinates of the GretagMacbeth ColorChecker squares\n  // width, height, 1st_column, 1st_row\n  int cut[NSQ][4];                                             // you must set these\n                                                               // ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {{0.400, 0.350, 10.1}, // Dark Skin\n                                         {0.377, 0.345, 35.8}, // Light Skin\n                                         {0.247, 0.251, 19.3}, // Blue Sky\n                                         {0.337, 0.422, 13.3}, // Foliage\n                                         {0.265, 0.240, 24.3}, // Blue Flower\n                                         {0.261, 0.343, 43.1}, // Bluish Green\n                                         {0.506, 0.407, 30.1}, // Orange\n                                         {0.211, 0.175, 12.0}, // Purplish Blue\n                                         {0.453, 0.306, 19.8}, // Moderate Red\n                                         {0.285, 0.202, 6.6},  // Purple\n                                         {0.380, 0.489, 44.3}, // Yellow Green\n                                         {0.473, 0.438, 43.1}, // Orange Yellow\n                                         {0.187, 0.129, 6.1},  // Blue\n                                         {0.305, 0.478, 23.4}, // Green\n                                         {0.539, 0.313, 12.0}, // Red\n                                         {0.448, 0.470, 59.1}, // Yellow\n                                         {0.364, 0.233, 19.8}, // Magenta\n                                         {0.196, 0.252, 19.8}, // Cyan\n                                         {0.310, 0.316, 90.0}, // White\n                                         {0.310, 0.316, 59.1}, // Neutral 8\n                                         {0.310, 0.316, 36.2}, // Neutral 6.5\n                                         {0.310, 0.316, 19.8}, // Neutral 5\n                                         {0.310, 0.316, 9.0},  // Neutral 3.5\n                                         {0.310, 0.316, 3.1}}; // Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset(gmb_cam, 0, sizeof gmb_cam);\n  for (sq = 0; sq < NSQ; sq++)\n  {\n    FORCC count[c] = 0;\n    for (row = cut[sq][3]; row < cut[sq][3] + cut[sq][1]; row++)\n      for (col = cut[sq][2]; col < cut[sq][2] + cut[sq][0]; col++)\n      {\n        c = FC(row, col);\n        if (c >= colors)\n          c -= 2;\n        gmb_cam[sq][c] += BAYER2(row, col);\n        BAYER2(row, col) = black + (BAYER2(row, col) - black) / 2;\n        count[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c] / count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] * (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse(gmb_xyz, inverse, NSQ);\n  for (pass = 0; pass < 2; pass++)\n  {\n    for (raw_color = i = 0; i < colors; i++)\n      for (j = 0; j < 3; j++)\n        for (cam_xyz[i][j] = k = 0; k < NSQ; k++)\n          cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff(rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq = 0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose)\n  {\n    printf(\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j = 0; j < 3; j++) printf(\"%c%d\", (c | j) ? ',' : ' ', (int)(cam_xyz[c][j] * num + 0.5));\n    puts(\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform(float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i = 0; i < sc; i++)\n    temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];\n  for (; i + sc < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];\n  for (; i < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (2 * size - 2 - (i + sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n  FORC(nc)\n  { /* denoise R,G1,B,G3 individually */\n    for (i = 0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass = lev = 0; lev < 5; lev++)\n    {\n      lpass = size * ((lev & 1) + 1);\n      for (row = 0; row < iheight; row++)\n      {\n        hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n        for (col = 0; col < iwidth; col++)\n          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n      }\n      for (col = 0; col < iwidth; col++)\n      {\n        hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n        for (row = 0; row < iheight; row++)\n          fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i = 0; i < size; i++)\n      {\n        fimg[hpass + i] -= fimg[lpass + i];\n        if (fimg[hpass + i] < -thold)\n          fimg[hpass + i] += thold;\n        else if (fimg[hpass + i] > thold)\n          fimg[hpass + i] -= thold;\n        else\n          fimg[hpass + i] = 0;\n        if (hpass)\n          fimg[i] += fimg[hpass + i];\n      }\n      hpass = lpass;\n    }\n    for (i = 0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n  }\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i, col, row, thold, lev, lpass, hpass, temp, c) firstprivate(scale, size)\n#endif\n  {\n    temp = (float *)malloc((iheight + iwidth) * sizeof *fimg);\n    FORC(nc)\n    { /* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass = lev = 0; lev < 5; lev++)\n      {\n        lpass = size * ((lev & 1) + 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (row = 0; row < iheight; row++)\n        {\n          hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n          for (col = 0; col < iwidth; col++)\n            fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n        }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (col = 0; col < iwidth; col++)\n        {\n          hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n          for (row = 0; row < iheight; row++)\n            fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n        }\n        thold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (i = 0; i < size; i++)\n        {\n          fimg[hpass + i] -= fimg[lpass + i];\n          if (fimg[hpass + i] < -thold)\n            fimg[hpass + i] += thold;\n          else if (fimg[hpass + i] > thold)\n            fimg[hpass + i] -= thold;\n          else\n            fimg[hpass + i] = 0;\n          if (hpass)\n            fimg[i] += fimg[hpass + i];\n        }\n        hpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n  /* the following loops are hard to parallize, no idea yes,\n   * problem is wlast which is carrying dependency\n   * second part should be easyer, but did not yet get it right.\n   */\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i, j;\n  double m1, m2, c1, c2;\n  int o1_1, o1_2, o1_3, o1_4;\n  int o2_1, o2_2, o2_3, o2_4;\n  ushort(*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if (half_size || shrink)\n    return;\n  if (FC(oj, oi) != 3)\n    oj++;\n  if (FC(oj, oi) != 3)\n    oi++;\n  if (FC(oj, oi) != 3)\n    oj--;\n\n  img = (ushort(*)[4])calloc(height * width, sizeof *image);\n  merror(img, \"green_matching()\");\n  memcpy(img, image, height * width * sizeof *image);\n\n  for (j = oj; j < height - margin; j += 2)\n    for (i = oi; i < width - margin; i += 2)\n    {\n      o1_1 = img[(j - 1) * width + i - 1][1];\n      o1_2 = img[(j - 1) * width + i + 1][1];\n      o1_3 = img[(j + 1) * width + i - 1][1];\n      o1_4 = img[(j + 1) * width + i + 1][1];\n      o2_1 = img[(j - 2) * width + i][3];\n      o2_2 = img[(j + 2) * width + i][3];\n      o2_3 = img[j * width + i - 2][3];\n      o2_4 = img[j * width + i + 2][3];\n\n      m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0;\n      m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0;\n\n      c1 = (abs(o1_1 - o1_2) + abs(o1_1 - o1_3) + abs(o1_1 - o1_4) + abs(o1_2 - o1_3) + abs(o1_3 - o1_4) +\n            abs(o1_2 - o1_4)) /\n           6.0;\n      c2 = (abs(o2_1 - o2_2) + abs(o2_1 - o2_3) + abs(o2_1 - o2_4) + abs(o2_2 - o2_3) + abs(o2_3 - o2_4) +\n            abs(o2_2 - o2_4)) /\n           6.0;\n      if ((img[j * width + i][3] < maximum * 0.95) && (c1 < maximum * thr) && (c2 < maximum * thr))\n      {\n        f = image[j * width + i][3] * m1 / m2;\n        image[j * width + i][3] = f > 0xffff ? 0xffff : f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img = 0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 0, 2);\n#endif\n\n  if (user_mul[0])\n    memcpy(pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1))\n  {\n    memset(dsum, 0, sizeof dsum);\n    bottom = MIN(greybox[1] + greybox[3], height);\n    right = MIN(greybox[0] + greybox[2], width);\n    for (row = greybox[1]; row < bottom; row += 8)\n      for (col = greybox[0]; col < right; col += 8)\n      {\n        memset(sum, 0, sizeof sum);\n        for (y = row; y < row + 8 && y < bottom; y++)\n          for (x = col; x < col + 8 && x < right; x++)\n            FORC4\n            {\n              if (filters)\n              {\n                c = fcol(y, x);\n                val = BAYER2(y, x);\n              }\n              else\n                val = image[y * width + x][c];\n              if (val > maximum - 25)\n                goto skip_block;\n              if ((val -= cblack[c]) < 0)\n                val = 0;\n              sum[c] += val;\n              sum[c + 4]++;\n              if (filters)\n                break;\n            }\n        FORC(8) dsum[c] += sum[c];\n      skip_block:;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c + 4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1)\n  {\n    memset(sum, 0, sizeof sum);\n    for (row = 0; row < 8; row++)\n      for (col = 0; col < 8; col++)\n      {\n        c = FC(row, col);\n        if ((val = white[row][col] - cblack[c]) > 0)\n          sum[c] += val;\n        sum[c + 4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (load_raw == &LibRaw::nikon_load_sraw)\n    {\n      // Nikon sRAW: camera WB already applied:\n      pre_mul[0] = pre_mul[1] = pre_mul[2] = pre_mul[3] = 1.0;\n    }\n    else\n#endif\n        if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float)sum[c + 4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy(pre_mul, cam_mul, sizeof pre_mul);\n    else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n      fprintf(stderr, _(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && !use_auto_wb && cam_mul[0] > 0.001f &&\n      cam_mul[1] > 0.001f && cam_mul[2] > 0.001f)\n  {\n    for (c = 0; c < 3; c++)\n      pre_mul[c] /= cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0)\n    pre_mul[1] = 1;\n  if (pre_mul[3] == 0)\n    pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold)\n    wavelet_denoise();\n  maximum -= black;\n  for (dmin = DBL_MAX, dmax = c = 0; c < 4; c++)\n  {\n    if (dmin > pre_mul[c])\n      dmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n      dmax = pre_mul[c];\n  }\n  if (!highlight)\n    dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n  {\n    fprintf(stderr, _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf(stderr, \" %f\", pre_mul[c]);\n    fputc('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4] + 1) / 2 == 1 && (cblack[5] + 1) / 2 == 1)\n  {\n    FORC4 cblack[FC(c / 2, c % 2)] += cblack[6 + c / 2 % cblack[4] * cblack[5] + c % 2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight * iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i = 0; i < size * 4; i++)\n  {\n    if (!(val = ((ushort *)image)[i]))\n      continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i / 4 / iwidth % cblack[4] * cblack[5] + i / 4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3)\n  {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c = 0; c < 4; c += 2)\n    {\n      if (aber[c] == 1)\n        continue;\n      img = (ushort *)malloc(size * sizeof *img);\n      merror(img, \"scale_colors()\");\n      for (i = 0; i < size; i++)\n        img[i] = image[i][c];\n      for (row = 0; row < iheight; row++)\n      {\n        ur = fr = (row - iheight * 0.5) * aber[c] + iheight * 0.5;\n        if (ur > iheight - 2)\n          continue;\n        fr -= ur;\n        for (col = 0; col < iwidth; col++)\n        {\n          uc = fc = (col - iwidth * 0.5) * aber[c] + iwidth * 0.5;\n          if (uc > iwidth - 2)\n            continue;\n          fc -= uc;\n          pix = img + ur * iwidth + uc;\n          image[row * iwidth + col][c] =\n              (pix[0] * (1 - fc) + pix[1] * fc) * (1 - fr) + (pix[iwidth] * (1 - fc) + pix[iwidth + 1] * fc) * fr;\n        }\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 1, 2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort(*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 0, 2);\n#endif\n  if (shrink)\n  {\n    if (half_size)\n    {\n      height = iheight;\n      width = iwidth;\n      if (filters == 9)\n      {\n        for (row = 0; row < 3; row++)\n          for (col = 1; col < 4; col++)\n            if (!(image[row * width + col][0] | image[row * width + col][2]))\n              goto break2;\n      break2:\n        for (; row < height; row += 3)\n          for (col = (col - 1) % 3 + 1; col < width - 1; col += 3)\n          {\n            img = image + row * width + col;\n            for (c = 0; c < 3; c += 2)\n              img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n          }\n      }\n    }\n    else\n    {\n      img = (ushort(*)[4])calloc(height, width * sizeof *img);\n      merror(img, \"pre_interpolate()\");\n      for (row = 0; row < height; row++)\n        for (col = 0; col < width; col++)\n        {\n          c = fcol(row, col);\n          img[row * width + col][c] = image[(row >> 1) * iwidth + (col >> 1)][c];\n        }\n      free(image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3)\n  {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size)\n      colors++;\n    else\n    {\n      for (row = FC(1, 0) >> 1; row < height; row += 2)\n        for (col = FC(row, 1) & 1; col < width; col += 2)\n          image[row * width + col][1] = image[row * width + col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size)\n    filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 1, 2);\n#endif\n}\n\nvoid CLASS border_interpolate(int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      if (col == border && row >= border && row < height - border)\n        col = width - border;\n      memset(sum, 0, sizeof sum);\n      for (y = row - 1; y != row + 2; y++)\n        for (x = col - 1; x != col + 2; x++)\n          if (y < height && x < width)\n          {\n            f = fcol(y, x);\n            sum[f] += image[y * width + x][f];\n            sum[f + 4]++;\n          }\n      f = fcol(row, col);\n      FORCC if (c != f && sum[c + 4]) image[row * width + col][c] = sum[c] / sum[c + 4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32], int size)\n{\n  int row;\n  for (row = 1; row < height - 1; row++)\n  {\n    int col, *ip;\n    ushort *pix;\n    for (col = 1; col < width - 1; col++)\n    {\n      int i;\n      int sum[4];\n      pix = image[row * width + col];\n      ip = code[row % size][col % size];\n      memset(sum, 0, sizeof sum);\n      for (i = *ip++; i--; ip += 3)\n        sum[ip[2]] += pix[ip[0]] << ip[1];\n      for (i = colors; --i; ip += 2)\n        pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n    }\n  }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size = 16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#endif\n\n  if (filters == 9)\n    size = 6;\n  border_interpolate(1);\n  for (row = 0; row < size; row++)\n    for (col = 0; col < size; col++)\n    {\n      ip = code[row][col] + 1;\n      f = fcol(row, col);\n      memset(sum, 0, sizeof sum);\n      for (y = -1; y <= 1; y++)\n        for (x = -1; x <= 1; x++)\n        {\n          shift = (y == 0) + (x == 0);\n          color = fcol(row + y, col + x);\n          if (color == f)\n            continue;\n          *ip++ = (width * y + x) * 4 + color;\n          *ip++ = shift;\n          *ip++ = color;\n          sum[color] += 1 << shift;\n        }\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n      if (c != f)\n      {\n        *ip++ = c;\n        *ip++ = sum[c] > 0 ? 256 / sum[c] : 0;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#endif\n  lin_interpolate_loop(code, size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp,\n      terms[] = {-2, -2, +0, -1, 0, 0x01, -2, -2, +0, +0, 1, 0x01, -2, -1, -1, +0, 0, 0x01, -2, -1, +0, -1, 0, 0x02,\n                 -2, -1, +0, +0, 0, 0x03, -2, -1, +0, +1, 1, 0x01, -2, +0, +0, -1, 0, 0x06, -2, +0, +0, +0, 1, 0x02,\n                 -2, +0, +0, +1, 0, 0x03, -2, +1, -1, +0, 0, 0x04, -2, +1, +0, -1, 1, 0x04, -2, +1, +0, +0, 0, 0x06,\n                 -2, +1, +0, +1, 0, 0x02, -2, +2, +0, +0, 1, 0x04, -2, +2, +0, +1, 0, 0x04, -1, -2, -1, +0, 0, -128,\n                 -1, -2, +0, -1, 0, 0x01, -1, -2, +1, -1, 0, 0x01, -1, -2, +1, +0, 1, 0x01, -1, -1, -1, +1, 0, -120,\n                 -1, -1, +1, -2, 0, 0x40, -1, -1, +1, -1, 0, 0x22, -1, -1, +1, +0, 0, 0x33, -1, -1, +1, +1, 1, 0x11,\n                 -1, +0, -1, +2, 0, 0x08, -1, +0, +0, -1, 0, 0x44, -1, +0, +0, +1, 0, 0x11, -1, +0, +1, -2, 1, 0x40,\n                 -1, +0, +1, -1, 0, 0x66, -1, +0, +1, +0, 1, 0x22, -1, +0, +1, +1, 0, 0x33, -1, +0, +1, +2, 1, 0x10,\n                 -1, +1, +1, -1, 1, 0x44, -1, +1, +1, +0, 0, 0x66, -1, +1, +1, +1, 0, 0x22, -1, +1, +1, +2, 0, 0x10,\n                 -1, +2, +0, +1, 0, 0x04, -1, +2, +1, +0, 1, 0x04, -1, +2, +1, +1, 0, 0x04, +0, -2, +0, +0, 1, -128,\n                 +0, -1, +0, +1, 1, -120, +0, -1, +1, -2, 0, 0x40, +0, -1, +1, +0, 0, 0x11, +0, -1, +2, -2, 0, 0x40,\n                 +0, -1, +2, -1, 0, 0x20, +0, -1, +2, +0, 0, 0x30, +0, -1, +2, +1, 1, 0x10, +0, +0, +0, +2, 1, 0x08,\n                 +0, +0, +2, -2, 1, 0x40, +0, +0, +2, -1, 0, 0x60, +0, +0, +2, +0, 1, 0x20, +0, +0, +2, +1, 0, 0x30,\n                 +0, +0, +2, +2, 1, 0x10, +0, +1, +1, +0, 0, 0x44, +0, +1, +1, +2, 0, 0x10, +0, +1, +2, -1, 1, 0x40,\n                 +0, +1, +2, +0, 0, 0x60, +0, +1, +2, +1, 0, 0x20, +0, +1, +2, +2, 0, 0x10, +1, -2, +1, +0, 0, -128,\n                 +1, -1, +1, +1, 0, -120, +1, +0, +1, +2, 0, 0x08, +1, +0, +2, -1, 0, 0x40, +1, +0, +2, +1, 0, 0x10},\n      chood[] = {-1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1};\n  ushort(*brow[5])[4], *pix;\n  int prow = 8, pcol = 2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1)\n    prow = pcol = 16;\n  if (filters == 9)\n    prow = pcol = 6;\n  ip = (int *)calloc(prow * pcol, 1280);\n  merror(ip, \"vng_interpolate()\");\n  for (row = 0; row < prow; row++) /* Precalculate for VNG */\n    for (col = 0; col < pcol; col++)\n    {\n      code[row][col] = ip;\n      for (cp = terms, t = 0; t < 64; t++)\n      {\n        y1 = *cp++;\n        x1 = *cp++;\n        y2 = *cp++;\n        x2 = *cp++;\n        weight = *cp++;\n        grads = *cp++;\n        color = fcol(row + y1, col + x1);\n        if (fcol(row + y2, col + x2) != color)\n          continue;\n        diag = (fcol(row, col + 1) == color && fcol(row + 1, col) == color) ? 2 : 1;\n        if (abs(y1 - y2) == diag && abs(x1 - x2) == diag)\n          continue;\n        *ip++ = (y1 * width + x1) * 4 + color;\n        *ip++ = (y2 * width + x2) * 4 + color;\n        *ip++ = weight;\n        for (g = 0; g < 8; g++)\n          if (grads & 1 << g)\n            *ip++ = g;\n        *ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp = chood, g = 0; g < 8; g++)\n      {\n        y = *cp++;\n        x = *cp++;\n        *ip++ = (y * width + x) * 4;\n        color = fcol(row, col);\n        if (fcol(row + y, col + x) != color && fcol(row + y * 2, col + x * 2) == color)\n          *ip++ = (y * width + x) * 8 + color;\n        else\n          *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort(*)[4])calloc(width * 3, sizeof **brow);\n  merror(brow[4], \"vng_interpolate()\");\n  for (row = 0; row < 3; row++)\n    brow[row] = brow[4] + row * width;\n  for (row = 2; row < height - 2; row++)\n  { /* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!((row - 2) % 256))\n      RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, (row - 2) / 256 + 1, ((height - 3) / 256) + 1);\n#endif\n    for (col = 2; col < width - 2; col++)\n    {\n      pix = image[row * width + col];\n      ip = code[row % prow][col % pcol];\n      memset(gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX)\n      { /* Calculate gradients */\n        diff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n        gval[ip[3]] += diff;\n        ip += 5;\n        if ((g = ip[-1]) == -1)\n          continue;\n        gval[g] += diff;\n        while ((g = *ip++) != -1)\n          gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0]; /* Choose a threshold */\n      for (g = 1; g < 8; g++)\n      {\n        if (gmin > gval[g])\n          gmin = gval[g];\n        if (gmax < gval[g])\n          gmax = gval[g];\n      }\n      if (gmax == 0)\n      {\n        memcpy(brow[2][col], pix, sizeof *image);\n        continue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset(sum, 0, sizeof sum);\n      color = fcol(row, col);\n      for (num = g = 0; g < 8; g++, ip += 2)\n      { /* Average the neighbors */\n        if (gval[g] <= thold)\n        {\n          FORCC\n          if (c == color && ip[1])\n            sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n          else\n            sum[c] += pix[ip[0] + c];\n          num++;\n        }\n      }\n      FORCC\n      { /* Save to buffer */\n        t = pix[color];\n        if (c != color)\n          t += (sum[c] - sum[color]) / num;\n        brow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3) /* Write buffer to image */\n      memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n    for (g = 0; g < 4; g++)\n      brow[(g - 1) & 3] = brow[g];\n  }\n  memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n  memcpy(image[(row - 1) * width + 2], brow[1] + 2, (width - 4) * sizeof *image);\n  free(brow[4]);\n  free(code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = {1, width, -1, -width, 1};\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort(*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 3; row < height - 3; row++)\n    for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; i++)\n      {\n        guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 - pix[-2 * d][c] - pix[2 * d][c];\n        diff[i] = (ABS(pix[-2 * d][c] - pix[0][c]) + ABS(pix[2 * d][c] - pix[0][c]) + ABS(pix[-d][1] - pix[d][1])) * 3 +\n                  (ABS(pix[3 * d][1] - pix[d][1]) + ABS(pix[-3 * d][1] - pix[-d][1])) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 2) & 1), c = FC(row, col + 1); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; c = 2 - c, i++)\n        pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 1) & 1), c = 2 - FC(row, col); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i] + dir[i + 1]) > 0; i++)\n      {\n        diff[i] = ABS(pix[-d][c] - pix[d][c]) + ABS(pix[-d][1] - pix[0][1]) + ABS(pix[d][1] - pix[0][1]);\n        guess[i] = pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n        pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n        pix[0][c] = CLIP((guess[0] + guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab(ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb)\n  {\n#ifndef LIBRAW_NOTHREADS\n    if (cbrt[0] < -1.0f)\n#endif\n      for (i = 0; i < 0x10000; i++)\n      {\n        r = i / 65535.0;\n        cbrt[i] = r > 0.008856 ? pow(r, 1.f / 3.0f) : 7.787f * r + 16.f / 116.0f;\n      }\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (xyz_cam[i][j] = k = 0; k < 3; k++)\n          xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC\n  {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int)xyz[0])];\n  xyz[1] = cbrt[CLIP((int)xyz[1])];\n  xyz[2] = cbrt[CLIP((int)xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512 /* Tile Size */\n#define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate(int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int cstat[4] = {0, 0, 0, 0};\n#endif\n\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1}},\n                     dir[4] = {1, TS, TS + 1, TS - 1};\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][3], (*lix)[3];\n  float(*drv)[TS][TS], diff[6], tr;\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (width < TS || height < TS)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT; // too small image\n                                       /* Check against right pattern */\n  for (row = 0; row < 6; row++)\n    for (col = 0; col < 6; col++)\n      cstat[fcol(row, col)]++;\n\n  if (cstat[0] < 6 || cstat[0] > 10 || cstat[1] < 16 || cstat[1] > 24 || cstat[2] < 6 || cstat[2] > 10 || cstat[3])\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // Init allhex table to unreasonable values\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          allhex[i][j][k][l] = 32700;\n#endif\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  int minv = 0, maxv = 0, minh = 0, maxh = 0;\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n            minv = MIN(v, minv);\n            maxv = MAX(v, maxv);\n            minh = MIN(v, minh);\n            maxh = MAX(v, maxh);\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Check allhex table initialization\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          if (allhex[i][j][k][l] > maxh + maxv * width + 1 || allhex[i][j][k][l] < minh + minv * width - 1)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int retrycount = 0;\n#endif\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n        continue;\n      pix = image + row * width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max)\n        FORC(6)\n        {\n          val = pix[hex[c]][1];\n          if (min > val)\n            min = val;\n          if (max < val)\n            max = val;\n        }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row - sgrow) % 3)\n      {\n      case 1:\n        if (row < height - 3)\n        {\n          row++;\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n        {\n          row--;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (retrycount++ > width * height)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        }\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)\n    {\n      mrow = MIN(top + TS, height - 3);\n      mcol = MIN(left + TS, width - 3);\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n          memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n      FORC3 memcpy(rgb[c + 1], rgb[0], sizeof *rgb);\n\n      /* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n        {\n          if ((f = fcol(row, col)) == 1)\n            continue;\n          pix = image + row * width + col;\n          hex = allhex[row % 3][col % 3][0];\n          color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) - 46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n          color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 + 92 * (pix[0][f] - pix[-hex[2]][f]);\n          FORC(2)\n          color[1][2 + c] = 164 * pix[hex[4 + c]][1] + 92 * pix[-2 * hex[4 + c]][1] +\n                            33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);\n          FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] = LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n        }\n\n      for (pass = 0; pass < passes; pass++)\n      {\n        if (pass == 1)\n          memcpy(rgb += 4, buffer, 4 * sizeof *rgb);\n\n        /* Recalculate green from interpolated values of closer pixels:\t*/\n        if (pass)\n        {\n          for (row = top + 2; row < mrow - 2; row++)\n            for (col = left + 2; col < mcol - 2; col++)\n            {\n              if ((f = fcol(row, col)) == 1)\n                continue;\n              pix = image + row * width + col;\n              hex = allhex[row % 3][col % 3][1];\n              for (d = 3; d < 6; d++)\n              {\n                rix = &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                val =\n                    rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] - rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n              }\n            }\n        }\n\n        /* Interpolate red and blue values for solitary green pixels:\t*/\n        for (row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n          for (col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n          {\n            rix = &rgb[0][row - top][col - left];\n            h = fcol(row, col + 1);\n            memset(diff, 0, sizeof diff);\n            for (i = 1, d = 0; d < 6; d++, i ^= TS ^ 1, h ^= 2)\n            {\n              for (c = 0; c < 2; c++, h ^= 2)\n              {\n                g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                if (d > 1)\n                  diff[d] += SQR(rix[i << c][1] - rix[-i << c][1] - rix[i << c][h] + rix[-i << c][h]) + SQR(g);\n              }\n              if (d > 1 && (d & 1))\n                if (diff[d - 1] < diff[d])\n                  FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n              if (d < 2 || (d & 1))\n              {\n                FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                rix += TS * TS;\n              }\n            }\n          }\n\n        /* Interpolate red for blue pixels and vice versa:\t\t*/\n        for (row = top + 3; row < mrow - 3; row++)\n          for (col = left + 3; col < mcol - 3; col++)\n          {\n            if ((f = 2 - fcol(row, col)) == 1)\n              continue;\n            rix = &rgb[0][row - top][col - left];\n            c = (row - sgrow) % 3 ? TS : 1;\n            h = 3 * (c ^ TS ^ 1);\n            for (d = 0; d < 4; d++, rix += TS * TS)\n            {\n              i = d > 1 || ((d ^ c) & 1) ||\n                          ((ABS(rix[0][1] - rix[c][1]) + ABS(rix[0][1] - rix[-c][1])) <\n                           2 * (ABS(rix[0][1] - rix[h][1]) + ABS(rix[0][1] - rix[-h][1])))\n                      ? c\n                      : h;\n              rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] - rix[i][1] - rix[-i][1]) / 2);\n            }\n          }\n\n        /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n        for (row = top + 2; row < mrow - 2; row++)\n          if ((row - sgrow) % 3)\n            for (col = left + 2; col < mcol - 2; col++)\n              if ((col - sgcol) % 3)\n              {\n                rix = &rgb[0][row - top][col - left];\n                hex = allhex[row % 3][col % 3][1];\n                for (d = 0; d < ndir; d += 2, rix += TS * TS)\n                  if (hex[d] + hex[d + 1])\n                  {\n                    g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                  }\n                  else\n                  {\n                    g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                  }\n              }\n      }\n      rgb = (ushort(*)[TS][TS][3])buffer;\n      mrow -= top;\n      mcol -= left;\n\n      /* Convert to CIELab and differentiate in all directions:\t*/\n      for (d = 0; d < ndir; d++)\n      {\n        for (row = 2; row < mrow - 2; row++)\n          for (col = 2; col < mcol - 2; col++)\n            cielab(rgb[d][row][col], lab[row][col]);\n        for (f = dir[d & 3], row = 3; row < mrow - 3; row++)\n          for (col = 3; col < mcol - 3; col++)\n          {\n            lix = &lab[row][col];\n            g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n            drv[d][row][col] = SQR(g) + SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                               SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n          }\n      }\n\n      /* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir * TS * TS);\n      for (row = 4; row < mrow - 4; row++)\n        for (col = 4; col < mcol - 4; col++)\n        {\n          for (tr = FLT_MAX, d = 0; d < ndir; d++)\n            if (tr > drv[d][row][col])\n              tr = drv[d][row][col];\n          tr *= 8;\n          for (d = 0; d < ndir; d++)\n            for (v = -1; v <= 1; v++)\n              for (h = -1; h <= 1; h++)\n                if (drv[d][row + v][col + h] <= tr)\n                  homo[d][row][col]++;\n        }\n\n      /* Average the most homogenous pixels for the final result:\t*/\n      if (height - top < TS + 4)\n        mrow = height - top + 2;\n      if (width - left < TS + 4)\n        mcol = width - left + 2;\n      for (row = MIN(top, 8); row < mrow - 8; row++)\n        for (col = MIN(left, 8); col < mcol - 8; col++)\n        {\n          for (d = 0; d < ndir; d++)\n            for (hm[d] = 0, v = -2; v <= 2; v++)\n              for (h = -2; h <= 2; h++)\n                hm[d] += homo[d][row + v][col + h];\n          for (d = 0; d < ndir - 4; d++)\n            if (hm[d] < hm[d + 4])\n              hm[d] = 0;\n            else if (hm[d] > hm[d + 4])\n              hm[d + 4] = 0;\n          for (max = hm[0], d = 1; d < ndir; d++)\n            if (max < hm[d])\n              max = hm[d];\n          max -= max >> 3;\n          memset(avg, 0, sizeof avg);\n          for (d = 0; d < ndir; d++)\n            if (hm[d] >= max)\n            {\n              FORC3 avg[c] += rgb[d][row][col][c];\n              avg[3]++;\n            }\n          FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n        }\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + TS, height - 2);\n  const int collimit = MIN(left + TS, width - 2);\n\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n      out_rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3],\n                                                                short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort(*pix)[4];\n  ushort(*rix)[3];\n  short(*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4 * width;\n  const unsigned rowlimit = MIN(top + TS - 1, height - 3);\n  const unsigned collimit = MIN(left + TS - 1, width - 3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top + 1; row < rowlimit; row++)\n  {\n    pix = image + row * width + left;\n    rix = &inout_rgb[row - top][0];\n    lix = &out_lab[row - top][0];\n\n    for (col = left + 1; col < collimit; col++)\n    {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1)\n      {\n        c = FC(row + 1, col);\n        t1 = 2 - c;\n        val = pix[0][1] + ((pix[-1][t1] + pix[1][t1] - rix[-1][1] - rix[1][1]) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + ((pix_above[c] + pix_below[c] - rix[-TS][1] - rix[TS][1]) >> 1);\n      }\n      else\n      {\n        t1 = -4 + c; /* -4+c: pixel of color c to the left */\n        t2 = 4 + c;  /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + ((pix_above[t1] + pix_above[t2] + pix_below[t1] + pix_below[t2] - rix[-TS - 1][1] -\n                            rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                           2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row, col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0], lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3],\n                                                         short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++)\n  {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3],\n                                                 char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short(*lix)[3];\n  short(*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = {-1, 1, -TS, TS};\n  const int rowlimit = MIN(top + TS - 2, height - 4);\n  const int collimit = MIN(left + TS - 2, width - 4);\n  int homogeneity;\n  char(*homogeneity_map_p)[2];\n\n  memset(out_homogeneity_map, 0, 2 * TS * TS);\n\n  for (row = top + 2; row < rowlimit; row++)\n  {\n    tr = row - top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction = 0; direction < 2; direction++)\n    {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col = left + 2; col < collimit; col++)\n    {\n      tc = col - left;\n      homogeneity_map_p++;\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        lix = ++lixs[direction];\n        for (i = 0; i < 4; i++)\n        {\n          adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0] - adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1] - adjacent_lix[1]) + SQR(lix[0][2] - adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n      for (direction = 0; direction < 2; direction++)\n      {\n        homogeneity = 0;\n        for (i = 0; i < 4; i++)\n        {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps)\n          {\n            homogeneity++;\n          }\n        }\n        homogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3],\n                                                      char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top + TS - 3, height - 5);\n  const int collimit = MIN(left + TS - 3, width - 5);\n\n  ushort(*pix)[4];\n  ushort(*rix[2])[3];\n\n  for (row = top + 3; row < rowlimit; row++)\n  {\n    tr = row - top;\n    pix = &image[row * width + left + 2];\n    for (direction = 0; direction < 2; direction++)\n    {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col = left + 3; col < collimit; col++)\n    {\n      tc = col - left;\n      pix++;\n      for (direction = 0; direction < 2; direction++)\n      {\n        rix[direction]++;\n      }\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        hm[direction] = 0;\n        for (i = tr - 1; i <= tr + 1; i++)\n        {\n          for (j = tc - 1; j <= tc + 1; j++)\n          {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1])\n      {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      }\n      else\n      {\n        FORC3 { pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1; }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4], r;\n  char *buffer;\n  ushort(*rgb)[TS][TS][3];\n  short(*lab)[TS][TS][3];\n  char(*homo)[TS][2];\n  int terminate_flag = 0;\n\n  cielab(0, 0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer, rgb, lab, homo, top, left, i, j, k) shared(xyz_cam, terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *)malloc(26 * TS * TS); /* 1664 kB */\n    merror(buffer, \"ahd_interpolate()\");\n    rgb = (ushort(*)[TS][TS][3])buffer;\n    lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n    homo = (char(*)[TS][2])(buffer + 24 * TS * TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top = 2; top < height - 5; top += TS - 6)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n      if (0 == omp_get_thread_num())\n#endif\n        if (callbacks.progress_cb)\n        {\n          int rr =\n              (*callbacks.progress_cb)(callbacks.progresscb_data, LIBRAW_PROGRESS_INTERPOLATE, top - 2, height - 7);\n          if (rr)\n            terminate_flag = 1;\n        }\n#endif\n      for (left = 2; !terminate_flag && (left < width - 5); left += TS - 6)\n      {\n        ahd_interpolate_green_h_and_v(top, left, rgb);\n        ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n        ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n        ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free(buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (terminate_flag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = {-1, 1, -TS, TS};\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][TS][3], (*lix)[3];\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab(0, 0);\n  border_interpolate(5);\n  buffer = (char *)malloc(26 * TS * TS);\n  merror(buffer, \"ahd_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n  homo = (char(*)[TS][TS])(buffer + 24 * TS * TS);\n\n  for (top = 2; top < height - 5; top += TS - 6)\n    for (left = 2; left < width - 5; left += TS - 6)\n    {\n\n      /*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top + TS && row < height - 2; row++)\n      {\n        col = left + (FC(row, left) & 1);\n        for (c = FC(row, col); col < left + TS && col < width - 2; col += 2)\n        {\n          pix = image + row * width + col;\n          val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n          rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n          val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n          rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n        }\n      }\n\n      /*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d = 0; d < 2; d++)\n        for (row = top + 1; row < top + TS - 1 && row < height - 3; row++)\n          for (col = left + 1; col < left + TS - 1 && col < width - 3; col++)\n          {\n            pix = image + row * width + col;\n            rix = &rgb[d][row - top][col - left];\n            lix = &lab[d][row - top][col - left];\n            if ((c = 2 - FC(row, col)) == 1)\n            {\n              c = FC(row + 1, col);\n              val = pix[0][1] + ((pix[-1][2 - c] + pix[1][2 - c] - rix[-1][1] - rix[1][1]) >> 1);\n              rix[0][2 - c] = CLIP(val);\n              val = pix[0][1] + ((pix[-width][c] + pix[width][c] - rix[-TS][1] - rix[TS][1]) >> 1);\n            }\n            else\n              val = rix[0][1] + ((pix[-width - 1][c] + pix[-width + 1][c] + pix[+width - 1][c] + pix[+width + 1][c] -\n                                  rix[-TS - 1][1] - rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                                 2);\n            rix[0][c] = CLIP(val);\n            c = FC(row, col);\n            rix[0][c] = pix[0][c];\n            cielab(rix[0], lix[0]);\n          }\n      /*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset(homo, 0, 2 * TS * TS);\n      for (row = top + 2; row < top + TS - 2 && row < height - 4; row++)\n      {\n        tr = row - top;\n        for (col = left + 2; col < left + TS - 2 && col < width - 4; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n          {\n            lix = &lab[d][tr][tc];\n            for (i = 0; i < 4; i++)\n            {\n              ldiff[d][i] = ABS(lix[0][0] - lix[dir[i]][0]);\n              abdiff[d][i] = SQR(lix[0][1] - lix[dir[i]][1]) + SQR(lix[0][2] - lix[dir[i]][2]);\n            }\n          }\n          leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n          abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n          for (d = 0; d < 2; d++)\n            for (i = 0; i < 4; i++)\n              if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n                homo[d][tr][tc]++;\n        }\n      }\n      /*  Combine the most homogenous pixels for the final result:\t*/\n      for (row = top + 3; row < top + TS - 3 && row < height - 5; row++)\n      {\n        tr = row - top;\n        for (col = left + 3; col < left + TS - 3 && col < width - 5; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n            for (hm[d] = 0, i = tr - 1; i <= tr + 1; i++)\n              for (j = tc - 1; j <= tc + 1; j++)\n                hm[d] += homo[d][i][j];\n          if (hm[0] != hm[1])\n            FORC3 image[row * width + col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n          else\n            FORC3 image[row * width + col][c] = (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n        }\n      }\n    }\n  free(buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort(*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] = /* Optimal 9-element median search */\n      {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,\n       3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};\n\n  for (pass = 1; pass <= med_passes; pass++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c = 0; c < 3; c += 2)\n    {\n      for (pix = image; pix < image + width * height; pix++)\n        pix[0][3] = pix[0][c];\n      for (pix = image + width; pix < image + width * (height - 1); pix++)\n      {\n        if ((pix - image + 1) % width < 2)\n          continue;\n        for (k = 0, i = -width; i <= width; i += width)\n          for (j = i - 1; j <= i + 1; j++)\n            med[k++] = pix[j][3] - pix[j][1];\n        for (i = 0; i < sizeof opt; i += 2)\n          if (med[opt[i]] > med[opt[i + 1]])\n            SWAP(med[opt[i]], med[opt[i + 1]]);\n        pix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {{{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n                                       {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {{{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n                                        {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned)(colors - 3) > 1)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n#endif\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] += trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] += itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow(2.0, 4 - highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc = 0, c = 1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c])\n      kc = c;\n  high = height / SCALE;\n  wide = width / SCALE;\n  map = (float *)calloc(high, wide * sizeof *map);\n  merror(map, \"recover_highlights()\");\n  FORCC if (c != kc)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, c - 1, colors - 1);\n#endif\n    memset(map, 0, high * wide * sizeof *map);\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        sum = wgt = count = 0;\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000)\n            {\n              sum += pixel[c];\n              wgt += pixel[kc];\n              count++;\n            }\n          }\n        if (count == SCALE * SCALE)\n          map[mrow * wide + mcol] = sum / wgt;\n      }\n    for (spread = 32 / grow; spread--;)\n    {\n      for (mrow = 0; mrow < high; mrow++)\n        for (mcol = 0; mcol < wide; mcol++)\n        {\n          if (map[mrow * wide + mcol])\n            continue;\n          sum = count = 0;\n          for (d = 0; d < 8; d++)\n          {\n            y = mrow + dir[d][0];\n            x = mcol + dir[d][1];\n            if (y < high && x < wide && map[y * wide + x] > 0)\n            {\n              sum += (1 + (d & 1)) * map[y * wide + x];\n              count += 1 + (d & 1);\n            }\n          }\n          if (count > 3)\n            map[mrow * wide + mcol] = -(sum + grow) / (count + grow);\n        }\n      for (change = i = 0; i < high * wide; i++)\n        if (map[i] < 0)\n        {\n          map[i] = -map[i];\n          change = 1;\n        }\n      if (!change)\n        break;\n    }\n    for (i = 0; i < high * wide; i++)\n      if (map[i] == 0)\n        map[i] = 1;\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] > 1)\n            {\n              val = pixel[kc] * map[mrow * wide + mcol];\n              if (pixel[c] < val)\n                pixel[c] = CLIP(val);\n            }\n          }\n      }\n  }\n  free(map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get(unsigned base, unsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n#ifdef LIBRAW_IOSPACE_CHECK\n  INT64 pos = ftell(ifp);\n  INT64 fsize = ifp->size();\n  if(fsize < 12 || (fsize-pos) < 12)\n     throw LIBRAW_EXCEPTION_IO_EOF;\n#endif\n  *tag = get2();\n  *type = get2();\n  *len = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type : 0] - '0') > 4)\n    fseek(ifp, get4() + base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note(int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == toff)\n      thumb_offset = get4() + base;\n    if (tag == tlen)\n      thumb_length = get4();\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nstatic float powf_lim(float a, float b, float limup) { return (b > limup || b < -limup) ? 0.f : powf(a, b); }\nstatic float libraw_powf64l(float a, float b) { return powf_lim(a, b, 64.f); }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x)\n{\n  float t;\n  if (x >= 0.0)\n  {\n    t = ceilf(x);\n    if (t - x > 0.5)\n      t -= 1.0;\n    return t;\n  }\n  else\n  {\n    t = ceilf(-x);\n    if (t + x > 0.5)\n      t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))\n    return 0.0f;\n  return libraw_powf64l(2.0, in / 64.0);\n}\n\nstatic float _CanonConvertEV(short in)\n{\n  short EV, Sign, Frac;\n  float Frac_f;\n  EV = in;\n  if (EV < 0)\n  {\n    EV = -EV;\n    Sign = -1;\n  }\n  else\n  {\n    Sign = 1;\n  }\n  Frac = EV & 0x1f;\n  EV -= Frac; // remove fraction\n\n  if (Frac == 0x0c)\n  { // convert 1/3 and 2/3 codes\n    Frac_f = 32.0f / 3.0f;\n  }\n  else if (Frac == 0x14)\n  {\n    Frac_f = 64.0f / 3.0f;\n  }\n  else\n    Frac_f = (float)Frac;\n\n  return ((float)Sign * ((float)EV + Frac_f)) / 32.0f;\n}\n\nunsigned CLASS setCanonBodyFeatures(unsigned id)\n{\n  if (id == 0x03740000) // EOS M3\n    id = 0x80000374;\n  else if (id == 0x03840000) // EOS M10\n    id = 0x80000384;\n  else if (id == 0x03940000) // EOS M5\n    id = 0x80000394;\n  else if (id == 0x04070000) // EOS M6\n    id = 0x80000407;\n  else if (id == 0x03980000) // EOS M100\n    id = 0x80000398;\n\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x80000001) || // 1D\n      (id == 0x80000174) || // 1D2\n      (id == 0x80000232) || // 1D2N\n      (id == 0x80000169) || // 1D3\n      (id == 0x80000281)    // 1D4\n  )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000167) || // 1Ds\n           (id == 0x80000188) || // 1Ds2\n           (id == 0x80000215) || // 1Ds3\n           (id == 0x80000269) || // 1DX\n           (id == 0x80000328) || // 1DX2\n           (id == 0x80000324) || // 1DC\n           (id == 0x80000213) || // 5D\n           (id == 0x80000218) || // 5D2\n           (id == 0x80000285) || // 5D3\n           (id == 0x80000349) || // 5D4\n           (id == 0x80000382) || // 5DS\n           (id == 0x80000401) || // 5DS R\n           (id == 0x80000302)    // 6D\n  )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000331) || // M\n           (id == 0x80000355) || // M2\n           (id == 0x80000374) || // M3\n           (id == 0x80000384) || // M10\n           (id == 0x80000394) || // M5\n           (id == 0x80000407) || // M6\n           (id == 0x80000398)    // M100\n  )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n  }\n  else if ((id == 0x01140000) || // D30\n           (id == 0x01668000) || // D60\n           (id > 0x80000000))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n  }\n  else\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n  }\n\n  return id;\n}\n\nvoid CLASS processCanonCameraInfo(unsigned id, uchar *CameraInfo, unsigned maxlen, unsigned type)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0,\n         iCanonFocalType = 0;\n  if (maxlen < 16)\n    return; // too short\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  if (type == 4)\n  {\n    if ((maxlen == 94) || (maxlen == 138) || (maxlen == 148) || (maxlen == 156) || (maxlen == 162) || (maxlen == 167) ||\n        (maxlen == 171) || (maxlen == 264) || (maxlen > 400))\n      imgdata.other.CameraTemperature = sget4(CameraInfo + ((maxlen - 3) << 2));\n    else if (maxlen == 72)\n      imgdata.other.CameraTemperature = sget4(CameraInfo + ((maxlen - 1) << 2));\n    else if ((maxlen == 85) || (maxlen == 93))\n      imgdata.other.CameraTemperature = sget4(CameraInfo + ((maxlen - 2) << 2));\n    else if ((maxlen == 96) || (maxlen == 104))\n      imgdata.other.CameraTemperature = sget4(CameraInfo + ((maxlen - 4) << 2));\n  }\n\n  switch (id)\n  {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    imgdata.other.CameraTemperature = 0.0f;\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12))\n      iCanonLensID = 151;\n    else\n      iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n  {\n    if (iCanonFocalType >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n    if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'\n      imgdata.lens.makernotes.FocalType = 1;\n  }\n  if (!imgdata.lens.makernotes.CurFocal)\n  {\n    if (iCanonCurFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n  }\n  if (!imgdata.lens.makernotes.LensID)\n  {\n    if (iCanonLensID >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n  }\n  if (!imgdata.lens.makernotes.MinFocal)\n  {\n    if (iCanonMinFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n  }\n  if (!imgdata.lens.makernotes.MaxFocal)\n  {\n    if (iCanonMaxFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n  }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens)\n  {\n    if (iCanonLens + 64 >= maxlen)\n      return;                        // broken;\n    if (CameraInfo[iCanonLens] < 65) // non-Canon lens\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2();\n  get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2();\n  get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2();\n  get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n  {\n    imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n  }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets(short WBCTversion)\n{\n  if (WBCTversion == 0)\n    for (int i = 0; i < 15; i++) // tint, as shot R, as shot B, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if (WBCTversion == 1)\n    for (int i = 0; i < 15; i++) // as shot R, as shot B, tint, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x80000374) || // M3\n                                  (unique_id == 0x80000384) || // M10\n                                  (unique_id == 0x80000394) || // M5\n                                  (unique_id == 0x80000407) || // M6\n                                  (unique_id == 0x80000398) || // M100\n                                  (unique_id == 0x03970000) || // G7 X Mark II\n                                  (unique_id == 0x04100000) || // G9 X Mark II\n                                  (unique_id == 0x04180000)))  // G1 X Mark III\n    for (int i = 0; i < 15; i++)                               // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X\n    for (int i = 0; i < 15; i++) // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  return;\n}\n\nvoid CLASS processNikonLensData(uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n  {\n    if (imgdata.lens.nikon.NikonLensType & 0x04)\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n    else\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n    imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n  {\n    imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n    imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20)\n  {\n    switch (len)\n    {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * libraw_powf64l(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * libraw_powf64l(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = libraw_powf64l(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = libraw_powf64l(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n    {\n      if ((LensData[i - 1]) && (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n        imgdata.lens.makernotes.CurFocal = 5.0f * libraw_powf64l(2.0f, (float)LensData[i - 1] / 24.0f);\n      if (LensData[i + 7])\n        imgdata.lens.nikon.NikonEffectiveMaxAp = libraw_powf64l(2.0f, (float)LensData[i + 7] / 24.0f);\n    }\n    imgdata.lens.makernotes.LensID =\n        (unsigned long long)LensData[i] << 56 | (unsigned long long)LensData[i + 1] << 48 |\n        (unsigned long long)LensData[i + 2] << 40 | (unsigned long long)LensData[i + 3] << 32 |\n        (unsigned long long)LensData[i + 4] << 24 | (unsigned long long)LensData[i + 5] << 16 |\n        (unsigned long long)LensData[i + 6] << 8 | (unsigned long long)imgdata.lens.nikon.NikonLensType;\n  }\n  else if ((len == 459) || (len == 590))\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n  }\n  else if (len == 509)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n  }\n  else if (len == 879)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n  }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures(unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if (id == 0x5330303638ULL)\n  {\n    strcpy(model, \"E-M10MarkIII\");\n  }\n  if ((id == 0x4434303430ULL) || // E-1\n      (id == 0x4434303431ULL) || // E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n    if ((id == 0x4434303430ULL) ||                              // E-1\n        (id == 0x4434303431ULL) ||                              // E-330\n        ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n        (id == 0x5330303233ULL) ||                              // E-620\n        (id == 0x5330303239ULL) ||                              // E-450\n        (id == 0x5330303330ULL) ||                              // E-600\n        (id == 0x5330303333ULL))                                // E-5\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n    }\n    else\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n    }\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes(unsigned tag, unsigned type, unsigned len)\n{\n\n  if (tag == 0x0001)\n    Canon_CameraSettings();\n  else if (tag == 0x0002) // focal length\n  {\n    imgdata.lens.makernotes.FocalType = get2();\n    imgdata.lens.makernotes.CurFocal = get2();\n    if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  }\n\n  else if (tag == 0x0004) // shot info\n  {\n    short tempAp;\n\n    fseek(ifp, 24, SEEK_CUR);\n    tempAp = get2();\n    if (tempAp != 0)\n      imgdata.other.CameraTemperature = (float)(tempAp - 128);\n    tempAp = get2();\n    if (tempAp != -1)\n      imgdata.other.FlashGN = ((float)tempAp) / 32;\n    get2();\n\n    // fseek(ifp, 30, SEEK_CUR);\n    imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n    fseek(ifp, 8 - 32, SEEK_CUR);\n    if ((tempAp = get2()) != 0x7fff)\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n    if (imgdata.lens.makernotes.CurAp < 0.7f)\n    {\n      fseek(ifp, 32, SEEK_CUR);\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n    }\n    if (!aperture)\n      aperture = imgdata.lens.makernotes.CurAp;\n  }\n\n  else if (tag == 0x000c)\n  {\n    unsigned tS = get4();\n    sprintf (imgdata.shootinginfo.BodySerial, \"%d\", tS);\n  }\n\n  else if (tag == 0x0095 && // lens model tag\n           !imgdata.lens.makernotes.Lens[0])\n  {\n    fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    if (imgdata.lens.makernotes.Lens[0] < 65) // non-Canon lens\n      fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n    else\n    {\n      char efs[2];\n      imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n      imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n      fread(efs, 2, 1, ifp);\n      if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n      { // \"EF-S, TS-E, MP-E, EF-M\" lenses\n        imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n        imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n        imgdata.lens.makernotes.Lens[4] = 32;\n        if (efs[1] == 83)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n        }\n        else if (efs[1] == 77)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n        }\n      }\n      else\n      { // \"EF\" lenses\n        imgdata.lens.makernotes.Lens[2] = 32;\n        imgdata.lens.makernotes.Lens[3] = efs[0];\n        imgdata.lens.makernotes.Lens[4] = efs[1];\n      }\n      fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n    }\n  }\n\n  else if (tag == 0x009a)\n  {\n    get4();\n    imgdata.sizes.raw_crop.cwidth = get4();\n    imgdata.sizes.raw_crop.cheight = get4();\n    imgdata.sizes.raw_crop.cleft = get4();\n    imgdata.sizes.raw_crop.ctop = get4();\n  }\n\n  else if (tag == 0x00a9)\n  {\n    long int save1 = ftell(ifp);\n    int c;\n    fseek(ifp, (0x1 << 1), SEEK_CUR);\n    FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n    Canon_WBpresets(0, 0);\n    fseek(ifp, save1, SEEK_SET);\n  }\n\n  else if (tag == 0x00e0) // sensor info\n  {\n    imgdata.makernotes.canon.SensorWidth = (get2(), get2());\n    imgdata.makernotes.canon.SensorHeight = get2();\n    imgdata.makernotes.canon.SensorLeftBorder = (get2(), get2(), get2());\n    imgdata.makernotes.canon.SensorTopBorder = get2();\n    imgdata.makernotes.canon.SensorRightBorder = get2();\n    imgdata.makernotes.canon.SensorBottomBorder = get2();\n    imgdata.makernotes.canon.BlackMaskLeftBorder = get2();\n    imgdata.makernotes.canon.BlackMaskTopBorder = get2();\n    imgdata.makernotes.canon.BlackMaskRightBorder = get2();\n    imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n  }\n\n  else if (tag == 0x4013)\n  {\n    get4();\n    imgdata.makernotes.canon.AFMicroAdjMode = get4();\n    imgdata.makernotes.canon.AFMicroAdjValue = ((float)get4()) / ((float)get4());\n  }\n\n  else if (tag == 0x4001 && len > 500)\n  {\n    int c;\n    long int save1 = ftell(ifp);\n    switch (len)\n    {\n    case 582:\n      imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D\n      {\n        fseek(ifp, save1 + (0x1e << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x41 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x46 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom2][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x23 << 1), SEEK_SET);\n        Canon_WBpresets(2, 2);\n        fseek(ifp, save1 + (0x4b << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 653:\n      imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2\n      {\n        fseek(ifp, save1 + (0x18 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x90 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x95 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom2][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x9a << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom3][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x27 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa4 << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 796:\n      imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x71 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x76 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom2][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x7b << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom3][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x80 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x4e << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0c4 << 1), SEEK_SET); // offset 196 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n    // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n    // 7D / 40D / 50D / 60D / 450D / 500D\n    // 550D / 1000D / 1100D\n    case 674:\n    case 692:\n    case 702:\n    case 1227:\n    case 1250:\n    case 1251:\n    case 1337:\n    case 1338:\n    case 1346:\n      imgdata.makernotes.canon.CanonColorDataVer = 4;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x53 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa8 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0e7 << 1), SEEK_SET); // offset 231 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4) || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n      {\n        fseek(ifp, save1 + (0x2b8 << 1), SEEK_SET); // offset 696 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n               (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n      {\n        fseek(ifp, save1 + (0x2cf << 1), SEEK_SET); // offset 719 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n      {\n        fseek(ifp, save1 + (0x2d3 << 1), SEEK_SET); // offset 723 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    case 5120:\n      imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, G7 X, G9 X, EOS M3, EOS M5, EOS M6\n      {\n        if ((unique_id == 0x03970000) || // G7 X Mark II\n            (unique_id == 0x04100000) || // G9 X Mark II\n            (unique_id == 0x04180000) || // G1 X Mark III\n            (unique_id == 0x80000394) || // EOS M5\n            (unique_id == 0x80000398) || // EOS M100\n            (unique_id == 0x80000407))   // EOS M6\n        {\n          fseek(ifp, save1 + (0x4f << 1), SEEK_SET);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          Canon_WBpresets(8, 24);\n          fseek(ifp, 168, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n          fseek(ifp, 24, SEEK_CUR);\n          Canon_WBCTpresets(2); // BCADT\n          fseek(ifp, 6, SEEK_CUR);\n        }\n        else\n        {\n          fseek(ifp, save1 + (0x4c << 1), SEEK_SET);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n          get2();\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n          get2();\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          get2();\n          Canon_WBpresets(2, 12);\n          fseek(ifp, save1 + (0xba << 1), SEEK_SET);\n          Canon_WBCTpresets(2);                       // BCADT\n          fseek(ifp, save1 + (0x108 << 1), SEEK_SET); // offset 264 short\n        }\n        int bls = 0;\n        FORC4 bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n\n    case 1273:\n    case 1275:\n      imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x67 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xbc << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0fb << 1), SEEK_SET); // offset 251 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      fseek(ifp, save1 + (0x1e3 << 1), SEEK_SET); // offset 483 shorts\n      imgdata.makernotes.canon.NormalWhiteLevel = get2();\n      imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      break;\n\n    // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n    case 1312:\n    case 1313:\n    case 1316:\n    case 1506:\n      imgdata.makernotes.canon.CanonColorDataVer = 7;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x80 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xd5 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x114 << 1), SEEK_SET); // offset 276 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n      {\n        fseek(ifp, save1 + (0x1fc << 1), SEEK_SET); // offset 508 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n      {\n        fseek(ifp, save1 + (0x2dc << 1), SEEK_SET); // offset 732 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    // 5DS / 5DS R / 80D / 1300D / 5D4 / 800D / 77D / 6D II / 200D\n    case 1560:\n    case 1592:\n    case 1353:\n    case 1602:\n      imgdata.makernotes.canon.CanonColorDataVer = 8;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x107 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x146 << 1), SEEK_SET); // offset 326 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 14) // 1300D\n      {\n        fseek(ifp, save1 + (0x230 << 1), SEEK_SET); // offset 560 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else\n      {\n        fseek(ifp, save1 + (0x30e << 1), SEEK_SET); // offset 782 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n    }\n    fseek(ifp, save1, SEEK_SET);\n  }\n}\n\nvoid CLASS setPentaxBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id)\n  {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n  case 0x1322c:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO(ushort c)\n{\n  int code[] = {3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,   16,   17,  18,  19,  20,\n                21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,   34,   35,  36,  37,  38,\n                39,  40,  41,  42,  43,  44,  45,  50,  100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261,\n                262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274,  275,  276, 277, 278};\n  double value[] = {50,     64,     80,     100,    125,    160,    200,    250,   320,   400,    500,    640,\n                    800,    1000,   1250,   1600,   2000,   2500,   3200,   4000,  5000,  6400,   8000,   10000,\n                    12800,  16000,  20000,  25600,  32000,  40000,  51200,  64000, 80000, 102400, 128000, 160000,\n                    204800, 258000, 325000, 409600, 516000, 650000, 819200, 50,    100,   200,    400,    800,\n                    1600,   3200,   50,     70,     100,    140,    200,    280,   400,   560,    800,    1100,\n                    1600,   2200,   3200,   4500,   6400,   9000,   12800,  18000, 25600, 36000,  51200};\n#define numel (sizeof(code) / sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++)\n  {\n    if (code[i] == c)\n    {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel)\n    iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo(unsigned id, unsigned len) // tag 0x0207\n{\n  ushort iLensData = 0;\n  uchar *table_buf;\n  table_buf = (uchar *)malloc(MAX(len, 128));\n  fread(table_buf, len, 1, ifp);\n  if ((id < 0x12b9c) || (((id == 0x12b9c) ||  // K100D\n                          (id == 0x12b9d) ||  // K110D\n                          (id == 0x12ba2)) && // K100D Super\n                         ((!table_buf[20] || (table_buf[20] == 0xff)))))\n  {\n    iLensData = 3;\n    if (imgdata.lens.makernotes.LensID == -1)\n      imgdata.lens.makernotes.LensID = (((unsigned)table_buf[0]) << 8) + table_buf[1];\n  }\n  else\n    switch (len)\n    {\n    case 90: // LensInfo3\n      iLensData = 13;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 91: // LensInfo4\n      iLensData = 12;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 80: // LensInfo5\n    case 128:\n      iLensData = 15;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) << 8) + table_buf[5];\n      break;\n    default:\n      if (id >= 0x12b9c) // LensInfo2\n      {\n        iLensData = 4;\n        if (imgdata.lens.makernotes.LensID == -1)\n          imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) << 8) + table_buf[3];\n      }\n    }\n  if (iLensData)\n  {\n    if (table_buf[iLensData + 9] && (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n      imgdata.lens.makernotes.CurFocal =\n          10 * (table_buf[iLensData + 9] >> 2) * libraw_powf64l(4, (table_buf[iLensData + 9] & 0x03) - 2);\n    if (table_buf[iLensData + 10] & 0xf0)\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          libraw_powf64l(2.0f, (float)((table_buf[iLensData + 10] & 0xf0) >> 4) / 4.0f);\n    if (table_buf[iLensData + 10] & 0x0f)\n      imgdata.lens.makernotes.MinAp4CurFocal =\n          libraw_powf64l(2.0f, (float)((table_buf[iLensData + 10] & 0x0f) + 10) / 4.0f);\n\n    if (iLensData != 12)\n    {\n      switch (table_buf[iLensData] & 0x06)\n      {\n      case 0:\n        imgdata.lens.makernotes.MinAp4MinFocal = 22.0f;\n        break;\n      case 2:\n        imgdata.lens.makernotes.MinAp4MinFocal = 32.0f;\n        break;\n      case 4:\n        imgdata.lens.makernotes.MinAp4MinFocal = 45.0f;\n        break;\n      case 6:\n        imgdata.lens.makernotes.MinAp4MinFocal = 16.0f;\n        break;\n      }\n      if (table_buf[iLensData] & 0x70)\n        imgdata.lens.makernotes.LensFStops = ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n      imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData + 3] & 0xf8);\n      imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData + 3] & 0x07);\n\n      if ((table_buf[iLensData + 14] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n        imgdata.lens.makernotes.MaxAp4CurFocal =\n            libraw_powf64l(2.0f, (float)((table_buf[iLensData + 14] & 0x7f) - 1) / 32.0f);\n    }\n    else if ((id != 0x12e76) && // K-5\n             (table_buf[iLensData + 15] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n    {\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          libraw_powf64l(2.0f, (float)((table_buf[iLensData + 15] & 0x7f) - 1) / 32.0f);\n    }\n  }\n  free(table_buf);\n  return;\n}\n\nvoid CLASS setPhaseOneFeatures(unsigned id)\n{\n\n  ushort i;\n  static const struct\n  {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n      // Phase One section:\n      {1, \"Hasselblad V\"},\n      {10, \"PhaseOne/Mamiya\"},\n      {12, \"Contax 645\"},\n      {16, \"Hasselblad V\"},\n      {17, \"Hasselblad V\"},\n      {18, \"Contax 645\"},\n      {19, \"PhaseOne/Mamiya\"},\n      {20, \"Hasselblad V\"},\n      {21, \"Contax 645\"},\n      {22, \"PhaseOne/Mamiya\"},\n      {23, \"Hasselblad V\"},\n      {24, \"Hasselblad H\"},\n      {25, \"PhaseOne/Mamiya\"},\n      {32, \"Contax 645\"},\n      {34, \"Hasselblad V\"},\n      {35, \"Hasselblad V\"},\n      {36, \"Hasselblad H\"},\n      {37, \"Contax 645\"},\n      {38, \"PhaseOne/Mamiya\"},\n      {39, \"Hasselblad V\"},\n      {40, \"Hasselblad H\"},\n      {41, \"Contax 645\"},\n      {42, \"PhaseOne/Mamiya\"},\n      {44, \"Hasselblad V\"},\n      {45, \"Hasselblad H\"},\n      {46, \"Contax 645\"},\n      {47, \"PhaseOne/Mamiya\"},\n      {48, \"Hasselblad V\"},\n      {49, \"Hasselblad H\"},\n      {50, \"Contax 645\"},\n      {51, \"PhaseOne/Mamiya\"},\n      {52, \"Hasselblad V\"},\n      {53, \"Hasselblad H\"},\n      {54, \"Contax 645\"},\n      {55, \"PhaseOne/Mamiya\"},\n      {67, \"Hasselblad V\"},\n      {68, \"Hasselblad H\"},\n      {69, \"Contax 645\"},\n      {70, \"PhaseOne/Mamiya\"},\n      {71, \"Hasselblad V\"},\n      {72, \"Hasselblad H\"},\n      {73, \"Contax 645\"},\n      {74, \"PhaseOne/Mamiya\"},\n      {76, \"Hasselblad V\"},\n      {77, \"Hasselblad H\"},\n      {78, \"Contax 645\"},\n      {79, \"PhaseOne/Mamiya\"},\n      {80, \"Hasselblad V\"},\n      {81, \"Hasselblad H\"},\n      {82, \"Contax 645\"},\n      {83, \"PhaseOne/Mamiya\"},\n      {84, \"Hasselblad V\"},\n      {85, \"Hasselblad H\"},\n      {86, \"Contax 645\"},\n      {87, \"PhaseOne/Mamiya\"},\n      {99, \"Hasselblad V\"},\n      {100, \"Hasselblad H\"},\n      {101, \"Contax 645\"},\n      {102, \"PhaseOne/Mamiya\"},\n      {103, \"Hasselblad V\"},\n      {104, \"Hasselblad H\"},\n      {105, \"PhaseOne/Mamiya\"},\n      {106, \"Contax 645\"},\n      {112, \"Hasselblad V\"},\n      {113, \"Hasselblad H\"},\n      {114, \"Contax 645\"},\n      {115, \"PhaseOne/Mamiya\"},\n      {131, \"Hasselblad V\"},\n      {132, \"Hasselblad H\"},\n      {133, \"Contax 645\"},\n      {134, \"PhaseOne/Mamiya\"},\n      {135, \"Hasselblad V\"},\n      {136, \"Hasselblad H\"},\n      {137, \"Contax 645\"},\n      {138, \"PhaseOne/Mamiya\"},\n      {140, \"Hasselblad V\"},\n      {141, \"Hasselblad H\"},\n      {142, \"Contax 645\"},\n      {143, \"PhaseOne/Mamiya\"},\n      {148, \"Hasselblad V\"},\n      {149, \"Hasselblad H\"},\n      {150, \"Contax 645\"},\n      {151, \"PhaseOne/Mamiya\"},\n      {160, \"A-250\"},\n      {161, \"A-260\"},\n      {162, \"A-280\"},\n      {167, \"Hasselblad V\"},\n      {168, \"Hasselblad H\"},\n      {169, \"Contax 645\"},\n      {170, \"PhaseOne/Mamiya\"},\n      {172, \"Hasselblad V\"},\n      {173, \"Hasselblad H\"},\n      {174, \"Contax 645\"},\n      {175, \"PhaseOne/Mamiya\"},\n      {176, \"Hasselblad V\"},\n      {177, \"Hasselblad H\"},\n      {178, \"Contax 645\"},\n      {179, \"PhaseOne/Mamiya\"},\n      {180, \"Hasselblad V\"},\n      {181, \"Hasselblad H\"},\n      {182, \"Contax 645\"},\n      {183, \"PhaseOne/Mamiya\"},\n      {208, \"Hasselblad V\"},\n      {211, \"PhaseOne/Mamiya\"},\n      {448, \"Phase One 645AF\"},\n      {457, \"Phase One 645DF\"},\n      {471, \"Phase One 645DF+\"},\n      {704, \"Phase One iXA\"},\n      {705, \"Phase One iXA - R\"},\n      {706, \"Phase One iXU 150\"},\n      {707, \"Phase One iXU 150 - NIR\"},\n      {708, \"Phase One iXU 180\"},\n      {721, \"Phase One iXR\"},\n      // Leaf section:\n      {333, \"Mamiya\"},\n      {329, \"Universal\"},\n      {330, \"Hasselblad H1/H2\"},\n      {332, \"Contax\"},\n      {336, \"AFi\"},\n      {327, \"Mamiya\"},\n      {324, \"Universal\"},\n      {325, \"Hasselblad H1/H2\"},\n      {326, \"Contax\"},\n      {335, \"AFi\"},\n      {340, \"Mamiya\"},\n      {337, \"Universal\"},\n      {338, \"Hasselblad H1/H2\"},\n      {339, \"Contax\"},\n      {323, \"Mamiya\"},\n      {320, \"Universal\"},\n      {322, \"Hasselblad H1/H2\"},\n      {321, \"Contax\"},\n      {334, \"AFi\"},\n      {369, \"Universal\"},\n      {370, \"Mamiya\"},\n      {371, \"Hasselblad H1/H2\"},\n      {372, \"Contax\"},\n      {373, \"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0])\n  {\n    for (i = 0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id)\n      {\n        strcpy(imgdata.lens.makernotes.body, p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes(unsigned tag, unsigned type)\n{\n  switch (tag)\n  {\n  case 0x1002:\n    imgdata.makernotes.fuji.WB_Preset = get2();\n    break;\n  case 0x1011:\n    imgdata.other.FlashEC = getreal(type);\n    break;\n  case 0x1020:\n    imgdata.makernotes.fuji.Macro = get2();\n    break;\n  case 0x1021:\n    imgdata.makernotes.fuji.FocusMode = get2();\n    break;\n  case 0x1022:\n    imgdata.makernotes.fuji.AFMode = get2();\n    break;\n  case 0x1023:\n    imgdata.makernotes.fuji.FocusPixel[0] = get2();\n    imgdata.makernotes.fuji.FocusPixel[1] = get2();\n    break;\n  case 0x1034:\n    imgdata.makernotes.fuji.ExrMode = get2();\n    break;\n  case 0x1050:\n    imgdata.makernotes.fuji.ShutterType = get2();\n    break;\n  case 0x1400:\n    imgdata.makernotes.fuji.FujiDynamicRange = get2();\n    break;\n  case 0x1401:\n    imgdata.makernotes.fuji.FujiFilmMode = get2();\n    break;\n  case 0x1402:\n    imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2();\n    break;\n  case 0x1403:\n    imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2();\n    break;\n  case 0x140b:\n    imgdata.makernotes.fuji.FujiAutoDynamicRange = get2();\n    break;\n  case 0x1404:\n    imgdata.lens.makernotes.MinFocal = getreal(type);\n    break;\n  case 0x1405:\n    imgdata.lens.makernotes.MaxFocal = getreal(type);\n    break;\n  case 0x1406:\n    imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n    break;\n  case 0x1407:\n    imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n    break;\n  case 0x1422:\n    imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n    imgdata.shootinginfo.ImageStabilization =\n        (imgdata.makernotes.fuji.ImageStabilization[0] << 9) + imgdata.makernotes.fuji.ImageStabilization[1];\n    break;\n  case 0x1431:\n    imgdata.makernotes.fuji.Rating = get4();\n    break;\n  case 0x3820:\n    imgdata.makernotes.fuji.FrameRate = get2();\n    break;\n  case 0x3821:\n    imgdata.makernotes.fuji.FrameWidth = get2();\n    break;\n  case 0x3822:\n    imgdata.makernotes.fuji.FrameHeight = get2();\n    break;\n  }\n  return;\n}\n\nvoid CLASS setSonyBodyFeatures(unsigned id)\n{\n  ushort idx;\n  static const struct\n  {\n    ushort scf[8];\n    /*\n    scf[0] camera id\n    scf[1] camera format\n    scf[2] camera mount: Minolta A, Sony E, fixed,\n    scf[3] camera type: DSLR, NEX, SLT, ILCE, ILCA, DSC\n    scf[4] lens mount\n    scf[5] tag 0x2010 group (0 if not used)\n    scf[6] offset of Sony ISO in 0x2010 table, 0xffff if not valid\n    scf[7] offset of ImageCount3 in 0x9050 table, 0xffff if not valid\n    */\n  } SonyCamFeatures[] = {\n      {256, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {257, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {258, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {259, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {260, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {261, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {262, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {263, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {264, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {265, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {266, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {267, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {268, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {269, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {270, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {271, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {272, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {273, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {274, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {275, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {276, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {277, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {278, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0, 0xffff, 0xffff},\n      {279, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0, 0xffff, 0xffff},\n      {280, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0, 0xffff, 0xffff},\n      {281, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0, 0xffff, 0xffff},\n      {282, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {283, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {284, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0, 0xffff, 0xffff},\n      {285, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0, 0xffff, 0xffff},\n      {286, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 2, 0x1218, 0x01bd},\n      {287, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 2, 0x1218, 0x01bd},\n      {288, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 1, 0x113e, 0x01bd},\n      {289, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 2, 0x1218, 0x01bd},\n      {290, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 2, 0x1218, 0x01bd},\n      {291, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 3, 0x11f4, 0x01bd},\n      {292, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 3, 0x11f4, 0x01bd},\n      {293, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 3, 0x11f4, 0x01bd},\n      {294, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 5, 0x1254, 0x01aa},\n      {295, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {296, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {297, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 5, 0x1254, 0xffff},\n      {298, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 5, 0x1258, 0xffff},\n      {299, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {301, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {302, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 5, 0x1280, 0x01aa},\n      {303, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 5, 0x1280, 0x01aa},\n      {304, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {305, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1280, 0x01aa},\n      {306, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {307, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {308, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 6, 0x113c, 0xffff},\n      {309, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 7, 0x0344, 0xffff},\n      {310, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 5, 0x1258, 0xffff},\n      {311, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {312, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {313, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0x01aa},\n      {314, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {315, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {316, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {317, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 7, 0x0344, 0xffff},\n      {318, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {319, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0, 7, 0x0344, 0x01a0},\n      {320, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {321, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {322, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {323, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {324, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {325, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {326, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {327, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {328, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {329, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {330, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {331, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {332, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {333, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {334, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {335, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {336, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {337, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {338, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {339, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0x01a0},\n      {340, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {341, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {342, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {343, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {344, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {345, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {346, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0x01a0},\n      {347, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8, 0x0346, 0x01cb},\n      {348, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {349, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {350, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8, 0x0346, 0x01cb},\n      {351, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {352, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {353, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0, 7, 0x0344, 0x01a0},\n      {354, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0, 8, 0x0346, 0x01cd},\n      {355, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {356, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {357, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8, 0x0346, 0x01cd},\n      {358, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9, 0x0320, 0x019f},\n      {359, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {360, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8, 0x0346, 0x01cd},\n      {361, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {362, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9, 0x0320, 0x019f},\n      {363, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {364, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {365, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff},\n  };\n  imgdata.lens.makernotes.CamID = id;\n\n  if (id == 2)\n  {\n    imgdata.lens.makernotes.CameraMount = imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n    imgdata.makernotes.sony.group2010 = 0;\n    imgdata.makernotes.sony.real_iso_offset = 0xffff;\n    imgdata.makernotes.sony.ImageCount3_offset = 0xffff;\n    return;\n  }\n  else\n    idx = id - 256;\n\n  if ((idx >= 0) && (idx < sizeof SonyCamFeatures / sizeof *SonyCamFeatures))\n  {\n    if (!SonyCamFeatures[idx].scf[2])\n      return;\n    imgdata.lens.makernotes.CameraFormat = SonyCamFeatures[idx].scf[1];\n    imgdata.lens.makernotes.CameraMount = SonyCamFeatures[idx].scf[2];\n    imgdata.makernotes.sony.SonyCameraType = SonyCamFeatures[idx].scf[3];\n    if (SonyCamFeatures[idx].scf[4])\n      imgdata.lens.makernotes.LensMount = SonyCamFeatures[idx].scf[4];\n    imgdata.makernotes.sony.group2010 = SonyCamFeatures[idx].scf[5];\n    imgdata.makernotes.sony.real_iso_offset = SonyCamFeatures[idx].scf[6];\n    imgdata.makernotes.sony.ImageCount3_offset = SonyCamFeatures[idx].scf[7];\n  }\n\n  char *sbstr = strstr(software, \" v\");\n  if (sbstr != NULL)\n  {\n    sbstr += 2;\n    imgdata.makernotes.sony.firmware = atof(sbstr);\n\n    if ((id == 306) || (id == 311))\n    {\n      if (imgdata.makernotes.sony.firmware < 1.2f)\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01aa;\n      else\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01c0;\n    }\n    else if (id == 312)\n    {\n      if (imgdata.makernotes.sony.firmware < 2.0f)\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01aa;\n      else\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01c0;\n    }\n    else if ((id == 318) || (id == 340))\n    {\n      if (imgdata.makernotes.sony.firmware < 1.2f)\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01a0;\n      else\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01b6;\n    }\n  }\n}\n\nvoid CLASS parseSonyLensType2(uchar a, uchar b)\n{\n  ushort lid2;\n  lid2 = (((ushort)a) << 8) | ((ushort)b);\n  if (!lid2)\n    return;\n  if (lid2 < 0x100)\n  {\n    if ((imgdata.lens.makernotes.AdapterID != 0x4900) && (imgdata.lens.makernotes.AdapterID != 0xEF00))\n    {\n      imgdata.lens.makernotes.AdapterID = lid2;\n      switch (lid2)\n      {\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 44:\n      case 78:\n      case 239:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n      }\n    }\n  }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    imgdata.lens.makernotes.AdapterID = 0x4900;\n  }\n  return;\n}\n\n#define strnXcat(buf, string) strncat(buf, string, LIM(sizeof(buf) - strbuflen(buf) - 1, 0, sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures(uchar a, uchar b)\n{\n\n  ushort features;\n  features = (((ushort)a) << 8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) || !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100))\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n  {\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n    if ((features & 0x0200) && (features & 0x0100))\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0200)\n    {\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0100)\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n    }\n  }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\");\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf + 1,\n            strbuflen(imgdata.lens.makernotes.LensFeatures_suf) - 1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x0116(uchar *buf, ushort len, unsigned id)\n{\n  short bufx;\n\n  if (((id == 257) || (id == 262) || (id == 269) || (id == 270)) && (len >= 2))\n    bufx = buf[1];\n  else if ((id >= 273) && (len >= 3))\n    bufx = buf[2];\n  else\n    return;\n\n  imgdata.other.BatteryTemperature = (float)(bufx - 32) / 1.8f;\n}\n\nvoid CLASS process_Sony_0x2010(uchar *buf, ushort len)\n{\n  if ((!imgdata.makernotes.sony.group2010) || (imgdata.makernotes.sony.real_iso_offset == 0xffff) ||\n      (len < (imgdata.makernotes.sony.real_iso_offset + 2)))\n    return;\n\n  if (imgdata.other.real_ISO < 0.1f)\n  {\n    uchar s[2];\n    s[0] = SonySubstitution[buf[imgdata.makernotes.sony.real_iso_offset]];\n    s[1] = SonySubstitution[buf[imgdata.makernotes.sony.real_iso_offset + 1]];\n    imgdata.other.real_ISO = 100.0f * libraw_powf64l(2.0f, (16 - ((float)sget2(s)) / 256.0f));\n  }\n}\n\nvoid CLASS process_Sony_0x9050(uchar *buf, ushort len, unsigned id)\n{\n  ushort lid;\n  uchar s[4];\n  int c;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n  {\n    if (len < 2)\n      return;\n    if (buf[0])\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(libraw_powf64l(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n\n    if (buf[1])\n      imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(libraw_powf64l(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n  }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n  {\n    if (len <= 0x106)\n      return;\n    if (buf[0x3d] | buf[0x3c])\n    {\n      lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];\n      imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);\n    }\n    if (buf[0x105] && (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n        (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n      imgdata.lens.makernotes.LensMount = SonySubstitution[buf[0x105]];\n    if (buf[0x106])\n      imgdata.lens.makernotes.LensFormat = SonySubstitution[buf[0x106]];\n  }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n  {\n    if (len <= 0x108)\n      return;\n    parseSonyLensType2(SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0107]]);\n  }\n\n  if (len <= 0x10a)\n    return;\n  if ((imgdata.lens.makernotes.LensID == -1) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n  {\n    imgdata.lens.makernotes.LensID = // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];\n\n    if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n    {\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    }\n\n    else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n             (imgdata.lens.makernotes.LensID != 0xFF00))\n    {\n      imgdata.lens.makernotes.AdapterID = 0xEF00;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    }\n  }\n\n  if ((id >= 286) && (id <= 293))\n  {\n    if (len <= 0x116)\n      return;\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures(SonySubstitution[buf[0x115]], SonySubstitution[buf[0x116]]);\n  }\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n  {\n    if (len <= 0x117)\n      return;\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n  }\n\n  if ((id == 347) || (id == 350) || (id == 354) || (id == 357) || (id == 358) || (id == 360) || (id == 362))\n  {\n    if (len <= 0x8d)\n      return;\n    unsigned long long b88 = SonySubstitution[buf[0x88]];\n    unsigned long long b89 = SonySubstitution[buf[0x89]];\n    unsigned long long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06llx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A)\n  {\n    if (len <= 0xf4)\n      return;\n    unsigned long long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05llx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    if (len <= 0x7f)\n      return;\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  if ((imgdata.makernotes.sony.ImageCount3_offset != 0xffff) &&\n      (len >= (imgdata.makernotes.sony.ImageCount3_offset + 4)))\n  {\n    FORC4 s[c] = SonySubstitution[buf[imgdata.makernotes.sony.ImageCount3_offset + c]];\n    imgdata.makernotes.sony.ImageCount3 = sget4(s);\n  }\n\n  if (id == 362)\n  {\n    for (c = 0; c < 6; c++)\n    {\n      imgdata.makernotes.sony.TimeStamp[c] = SonySubstitution[buf[0x0066 + c]];\n    }\n  }\n\n  return;\n}\n\nvoid CLASS process_Sony_0x9400(uchar *buf, ushort len, unsigned id)\n{\n\n  uchar s[4];\n  int c;\n  short bufx = buf[0];\n\n  if (((bufx == 0x23) || (bufx == 0x24) || (bufx == 0x26)) && (len >= 0x1f))\n  { // 0x9400 'c' version\n\n    if ((id == 358) || (id == 362) || (id == 365))\n    {\n      imgdata.makernotes.sony.ShotNumberSincePowerUp = SonySubstitution[buf[0x0a]];\n    }\n    else\n    {\n      FORC4 s[c] = SonySubstitution[buf[0x0a + c]];\n      imgdata.makernotes.sony.ShotNumberSincePowerUp = sget4(s);\n    }\n\n    imgdata.makernotes.sony.Sony0x9400_version = 0xc;\n\n    imgdata.makernotes.sony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x09]];\n\n    FORC4 s[c] = SonySubstitution[buf[0x12 + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceImageNumber = sget4(s);\n\n    imgdata.makernotes.sony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x16]]; // shots\n\n    FORC4 s[c] = SonySubstitution[buf[0x1a + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceFileNumber = sget4(s);\n\n    imgdata.makernotes.sony.Sony0x9400_SequenceLength2 = SonySubstitution[buf[0x1e]]; // files\n  }\n\n  else if ((bufx == 0x0c) && (len >= 0x1f))\n  { // 0x9400 'b' version\n    imgdata.makernotes.sony.Sony0x9400_version = 0xb;\n\n    FORC4 s[c] = SonySubstitution[buf[0x08 + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceImageNumber = sget4(s);\n\n    FORC4 s[c] = SonySubstitution[buf[0x0c + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceFileNumber = sget4(s);\n\n    imgdata.makernotes.sony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x10]];\n\n    imgdata.makernotes.sony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x1e]];\n  }\n\n  else if ((bufx == 0x0a) && (len >= 0x23))\n  { // 0x9400 'a' version\n    imgdata.makernotes.sony.Sony0x9400_version = 0xa;\n\n    FORC4 s[c] = SonySubstitution[buf[0x08 + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceImageNumber = sget4(s);\n\n    FORC4 s[c] = SonySubstitution[buf[0x0c + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceFileNumber = sget4(s);\n\n    imgdata.makernotes.sony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x10]];\n\n    imgdata.makernotes.sony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x22]];\n  }\n\n  else\n    return;\n}\n\nvoid CLASS process_Sony_0x9402(uchar *buf, ushort len)\n{\n\n  if ((imgdata.makernotes.sony.SonyCameraType == LIBRAW_SONY_SLT) ||\n      (imgdata.makernotes.sony.SonyCameraType == LIBRAW_SONY_ILCA))\n    return;\n\n  if (len < 5)\n    return;\n\n  short bufx = buf[0x00];\n  if ((bufx == 0x05) || (bufx == 0xff) || (buf[0x02] != 0xff))\n    return;\n\n  imgdata.other.AmbientTemperature = (float)((short)SonySubstitution[buf[0x04]]);\n\n  return;\n}\n\nvoid CLASS process_Sony_0x9403(uchar *buf, ushort len)\n{\n  if (len < 6)\n    return;\n  short bufx = SonySubstitution[buf[4]];\n  if ((bufx == 0x00) || (bufx == 0x94))\n    return;\n\n  imgdata.other.SensorTemperature = (float)((short)SonySubstitution[buf[5]]);\n\n  return;\n}\n\nvoid CLASS process_Sony_0x9406(uchar *buf, ushort len)\n{\n  if (len < 6)\n    return;\n  short bufx = buf[0];\n  if ((bufx != 0x01) && (bufx != 0x08) && (bufx != 0x1b))\n    return;\n  bufx = buf[2];\n  if ((bufx != 0x08) && (bufx != 0x1b))\n    return;\n\n  imgdata.other.BatteryTemperature = (float)(SonySubstitution[buf[5]] - 32) / 1.8f;\n\n  return;\n}\n\nvoid CLASS process_Sony_0x940c(uchar *buf, ushort len)\n{\n  if ((imgdata.makernotes.sony.SonyCameraType != LIBRAW_SONY_ILCE) &&\n      (imgdata.makernotes.sony.SonyCameraType != LIBRAW_SONY_NEX))\n    return;\n  if (len <= 0x000a)\n    return;\n\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n  {\n    switch (SonySubstitution[buf[0x0008]])\n    {\n    case 1:\n    case 5:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n      break;\n    case 4:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n      break;\n    }\n  }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) | ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2(SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0009]]);\n  return;\n}\n\nvoid CLASS process_Sony_0x940e(uchar *buf, ushort len, unsigned id)\n{\n  if (((id == 286) || (id == 287) || (id == 294)) && (len >= 0x017e))\n  {\n    imgdata.makernotes.sony.AFMicroAdjValue = SonySubstitution[buf[0x017d]];\n  }\n  else if ((imgdata.makernotes.sony.SonyCameraType == LIBRAW_SONY_ILCA) && (len >= 0x0051))\n  {\n    imgdata.makernotes.sony.AFMicroAdjValue = SonySubstitution[buf[0x0050]];\n  }\n  else\n    return;\n\n  if (imgdata.makernotes.sony.AFMicroAdjValue != 0)\n    imgdata.makernotes.sony.AFMicroAdjOn = 1;\n}\n\nvoid CLASS parseSonyMakernotes(unsigned tag, unsigned type, unsigned len, unsigned dng_writer, uchar *&table_buf_0x0116,\n                               ushort &table_buf_0x0116_len, uchar *&table_buf_0x2010, ushort &table_buf_0x2010_len,\n                               uchar *&table_buf_0x9050, ushort &table_buf_0x9050_len, uchar *&table_buf_0x9400,\n                               ushort &table_buf_0x9400_len, uchar *&table_buf_0x9402, ushort &table_buf_0x9402_len,\n                               uchar *&table_buf_0x9403, ushort &table_buf_0x9403_len, uchar *&table_buf_0x9406,\n                               ushort &table_buf_0x9406_len, uchar *&table_buf_0x940c, ushort &table_buf_0x940c_len,\n                               uchar *&table_buf_0x940e, ushort &table_buf_0x940e_len)\n{\n\n  ushort lid;\n  uchar *table_buf;\n\n  if (tag == 0xb001) // Sony ModelID\n  {\n    unique_id = get2();\n    setSonyBodyFeatures(unique_id);\n\n    if (table_buf_0x0116_len)\n    {\n      process_Sony_0x0116(table_buf_0x0116, table_buf_0x0116_len, unique_id);\n      free(table_buf_0x0116);\n      table_buf_0x0116_len = 0;\n    }\n\n    if (table_buf_0x2010_len)\n    {\n      process_Sony_0x2010(table_buf_0x2010, table_buf_0x2010_len);\n      free(table_buf_0x2010);\n      table_buf_0x2010_len = 0;\n    }\n\n    if (table_buf_0x9050_len)\n    {\n      process_Sony_0x9050(table_buf_0x9050, table_buf_0x9050_len, unique_id);\n      free(table_buf_0x9050);\n      table_buf_0x9050_len = 0;\n    }\n\n    if (table_buf_0x9400_len)\n    {\n      process_Sony_0x9400(table_buf_0x9400, table_buf_0x9400_len, unique_id);\n      free(table_buf_0x9400);\n      table_buf_0x9400_len = 0;\n    }\n\n    if (table_buf_0x9402_len)\n    {\n      process_Sony_0x9402(table_buf_0x9402, table_buf_0x9402_len);\n      free(table_buf_0x9402);\n      table_buf_0x9402_len = 0;\n    }\n\n    if (table_buf_0x9403_len)\n    {\n      process_Sony_0x9403(table_buf_0x9403, table_buf_0x9403_len);\n      free(table_buf_0x9403);\n      table_buf_0x9403_len = 0;\n    }\n\n    if (table_buf_0x9406_len)\n    {\n      process_Sony_0x9406(table_buf_0x9406, table_buf_0x9406_len);\n      free(table_buf_0x9406);\n      table_buf_0x9406_len = 0;\n    }\n\n    if (table_buf_0x940c_len)\n    {\n      process_Sony_0x940c(table_buf_0x940c, table_buf_0x940c_len);\n      free(table_buf_0x940c);\n      table_buf_0x940c_len = 0;\n    }\n\n    if (table_buf_0x940e_len)\n    {\n      process_Sony_0x940e(table_buf_0x940e, table_buf_0x940e_len, unique_id);\n      free(table_buf_0x940e);\n      table_buf_0x940e_len = 0;\n    }\n  }\n\n  else if ((tag == 0x0010) && // CameraInfo\n           strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n           ((len == 368) ||  // a700\n            (len == 5478) || // a850, a900\n            (len == 5506) || // a200, a300, a350\n            (len == 6118) || // a230, a290, a330, a380, a390\n                             // a450, a500, a550, a560, a580\n                             // a33, a35, a55\n                             // NEX3, NEX5, NEX5C, NEXC3, VG10E\n            (len == 15360)))\n  {\n    table_buf = (uchar *)malloc(len);\n    fread(table_buf, len, 1, ifp);\n    if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n        memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n    {\n      switch (len)\n      {\n      case 368:\n      case 5478:\n        // a700, a850, a900: CameraInfo\n        if ((!dng_writer) ||\n            (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7])))\n        {\n          if (table_buf[0] | table_buf[3])\n            imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n          if (table_buf[2] | table_buf[5])\n            imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n          if (table_buf[4])\n            imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n          if (table_buf[4])\n            imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n          parseSonyLensFeatures(table_buf[1], table_buf[6]);\n\n          if (len == 5478)\n          {\n            imgdata.makernotes.sony.AFMicroAdjValue = table_buf[304] - 20;\n            imgdata.makernotes.sony.AFMicroAdjOn = (((table_buf[305] & 0x80) == 0x80) ? 1 : 0);\n            imgdata.makernotes.sony.AFMicroAdjRegisteredLenses = table_buf[305] & 0x7f;\n          }\n        }\n        break;\n      default:\n        // CameraInfo2 & 3\n        if ((!dng_writer) ||\n            (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6])))\n        {\n          if (table_buf[1] | table_buf[2])\n            imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n          if (table_buf[3] | table_buf[4])\n            imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n          if (table_buf[5])\n            imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n          if (table_buf[6])\n            imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n          parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        }\n      }\n    }\n    free(table_buf);\n  }\n\n  else if ((!dng_writer) && (tag == 0x0020) && // WBInfoA100, needs 0xb028 processing\n           !strncasecmp(model, \"DSLR-A100\", 9))\n  {\n    fseek(ifp, 0x49dc, SEEK_CUR);\n    stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n  }\n\n  else if (tag == 0x0104)\n  {\n    imgdata.other.FlashEC = getreal(type);\n  }\n\n  else if (tag == 0x0105) // Teleconverter\n  {\n    imgdata.lens.makernotes.TeleconverterID = get2();\n  }\n\n  else if (tag == 0x0114 && len < 256000) // CameraSettings\n  {\n    table_buf = (uchar *)malloc(len);\n    fread(table_buf, len, 1, ifp);\n    switch (len)\n    {\n    case 280:\n    case 364:\n    case 332:\n      // CameraSettings and CameraSettings2 are big endian\n      if (table_buf[2] | table_buf[3])\n      {\n        lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n        imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n      }\n      break;\n    case 1536:\n    case 2048:\n      // CameraSettings3 are little endian\n      parseSonyLensType2(table_buf[1016], table_buf[1015]);\n      if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n      {\n        switch (table_buf[153])\n        {\n        case 16:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n          break;\n        case 17:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n          break;\n        }\n      }\n      break;\n    }\n    free(table_buf);\n  }\n\n  else if ((tag == 0x3000) && (len < 256000))\n  {\n    uchar *table_buf_0x3000;\n    table_buf_0x3000 = (uchar *)malloc(len);\n    fread(table_buf_0x3000, len, 1, ifp);\n    for (int i = 0; i < 20; i++)\n      imgdata.makernotes.sony.SonyDateTime[i] = table_buf_0x3000[6 + i];\n  }\n\n  else if (tag == 0x0116 && len < 256000)\n  {\n    table_buf_0x0116 = (uchar *)malloc(len);\n    table_buf_0x0116_len = len;\n    fread(table_buf_0x0116, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x0116(table_buf_0x0116, table_buf_0x0116_len, imgdata.lens.makernotes.CamID);\n      free(table_buf_0x0116);\n      table_buf_0x0116_len = 0;\n    }\n  }\n\n  else if (tag == 0x2010 && len < 256000)\n  {\n    table_buf_0x2010 = (uchar *)malloc(len);\n    table_buf_0x2010_len = len;\n    fread(table_buf_0x2010, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x2010(table_buf_0x2010, table_buf_0x2010_len);\n      free(table_buf_0x2010);\n      table_buf_0x2010_len = 0;\n    }\n  }\n\n  else if (tag == 0x201a)\n  {\n    imgdata.makernotes.sony.ElectronicFrontCurtainShutter = get4();\n  }\n\n  else if (tag == 0x201b)\n  {\n    uchar uc;\n    fread(&uc, 1, 1, ifp);\n    imgdata.shootinginfo.FocusMode = (short)uc;\n  }\n\n  else if (tag == 0x202c)\n  {\n    imgdata.makernotes.sony.MeteringMode2 = get2();\n  }\n\n  else if (tag == 0x9050 && len < 256000) // little endian\n  {\n    table_buf_0x9050 = (uchar *)malloc(len);\n    table_buf_0x9050_len = len;\n    fread(table_buf_0x9050, len, 1, ifp);\n\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9050(table_buf_0x9050, table_buf_0x9050_len, imgdata.lens.makernotes.CamID);\n      free(table_buf_0x9050);\n      table_buf_0x9050_len = 0;\n    }\n  }\n\n  else if (tag == 0x9400 && len < 256000)\n  {\n    table_buf_0x9400 = (uchar *)malloc(len);\n    table_buf_0x9400_len = len;\n    fread(table_buf_0x9400, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9400(table_buf_0x9400, table_buf_0x9400_len, unique_id);\n      free(table_buf_0x9400);\n      table_buf_0x9400_len = 0;\n    }\n  }\n\n  else if (tag == 0x9402 && len < 256000)\n  {\n    table_buf_0x9402 = (uchar *)malloc(len);\n    table_buf_0x9402_len = len;\n    fread(table_buf_0x9402, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9402(table_buf_0x9402, table_buf_0x9402_len);\n      free(table_buf_0x9402);\n      table_buf_0x9402_len = 0;\n    }\n  }\n\n  else if (tag == 0x9403 && len < 256000)\n  {\n    table_buf_0x9403 = (uchar *)malloc(len);\n    table_buf_0x9403_len = len;\n    fread(table_buf_0x9403, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9403(table_buf_0x9403, table_buf_0x9403_len);\n      free(table_buf_0x9403);\n      table_buf_0x9403_len = 0;\n    }\n  }\n\n  else if ((tag == 0x9405) && (len < 256000) && (len > 0x64))\n  {\n    uchar *table_buf_0x9405;\n    table_buf_0x9405 = (uchar *)malloc(len);\n    short bufx = table_buf_0x9405[0x0];\n    fread(table_buf_0x9405, len, 1, ifp);\n    if (imgdata.other.real_ISO < 0.1f)\n    {\n      if ((bufx == 0x25) || (bufx == 0x3a) || (bufx == 0x76) || (bufx == 0x7e) || (bufx == 0x8b) || (bufx == 0x9a) ||\n          (bufx == 0xb3) || (bufx == 0xe1))\n      {\n        uchar s[2];\n        s[0] = SonySubstitution[table_buf_0x9405[0x04]];\n        s[1] = SonySubstitution[table_buf_0x9405[0x05]];\n        imgdata.other.real_ISO = 100.0f * libraw_powf64l(2.0f, (16 - ((float)sget2(s)) / 256.0f));\n      }\n    }\n    free(table_buf_0x9405);\n  }\n\n  else if (tag == 0x9406 && len < 256000)\n  {\n    table_buf_0x9406 = (uchar *)malloc(len);\n    table_buf_0x9406_len = len;\n    fread(table_buf_0x9406, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9406(table_buf_0x9406, table_buf_0x9406_len);\n      free(table_buf_0x9406);\n      table_buf_0x9406_len = 0;\n    }\n  }\n\n  else if (tag == 0x940c && len < 256000)\n  {\n    table_buf_0x940c = (uchar *)malloc(len);\n    table_buf_0x940c_len = len;\n    fread(table_buf_0x940c, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x940c(table_buf_0x940c, table_buf_0x940c_len);\n      free(table_buf_0x940c);\n      table_buf_0x940c_len = 0;\n    }\n  }\n\n  else if (tag == 0x940e && len < 256000)\n  {\n    table_buf_0x940e = (uchar *)malloc(len);\n    table_buf_0x940e_len = len;\n    fread(table_buf_0x940e, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x940e(table_buf_0x940e, table_buf_0x940e_len, imgdata.lens.makernotes.CamID);\n      free(table_buf_0x940e);\n      table_buf_0x940e_len = 0;\n    }\n  }\n\n  else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n  {\n    imgdata.lens.makernotes.LensID = get4();\n    if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n    {\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    }\n\n    else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n             (imgdata.lens.makernotes.LensID != 0xFF00))\n    {\n      imgdata.lens.makernotes.AdapterID = 0xEF00;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    }\n    if (tag == 0x010c)\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n  }\n\n  else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n  {\n    table_buf = (uchar *)malloc(len);\n    fread(table_buf, len, 1, ifp);\n    if ((!dng_writer) ||\n        (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6])))\n    {\n      if (table_buf[1] | table_buf[2])\n        imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n      if (table_buf[3] | table_buf[4])\n        imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n      if (table_buf[5])\n        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n      if (table_buf[6])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n      parseSonyLensFeatures(table_buf[0], table_buf[7]);\n    }\n    free(table_buf);\n  }\n\n  else if ((tag == 0xb02b) && !imgdata.sizes.raw_crop.cwidth && (len == 2))\n  {\n    imgdata.sizes.raw_crop.cheight = get4();\n    imgdata.sizes.raw_crop.cwidth = get4();\n  }\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n  unsigned typeCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x0116;\n  ushort table_buf_0x0116_len = 0;\n  uchar *table_buf_0x2010;\n  ushort table_buf_0x2010_len = 0;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_len = 0;\n  uchar *table_buf_0x9400;\n  ushort table_buf_0x9400_len = 0;\n  uchar *table_buf_0x9402;\n  ushort table_buf_0x9402_len = 0;\n  uchar *table_buf_0x9403;\n  ushort table_buf_0x9403_len = 0;\n  uchar *table_buf_0x9406;\n  ushort table_buf_0x9406_len = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_len = 0;\n  uchar *table_buf_0x940e;\n  ushort table_buf_0x940e_len = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n\n  /*\n    printf(\"===>>buf: 0x\");\n    for (int i = 0; i < sizeof buf; i ++) {\n          printf(\"%02x\", buf[i]);\n    }\n    putchar('\\n');\n  */\n\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if (len > 8 && pos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    tag |= uptag << 16;\n    if (len > 100 * 1024 * 1024)\n      goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        if (type != 4)\n        {\n          CanonCameraInfo = (uchar *)malloc(MAX(16, len));\n          fread(CanonCameraInfo, len, 1, ifp);\n        }\n        else\n        {\n          CanonCameraInfo = (uchar *)malloc(MAX(16, len * 4));\n          fread(CanonCameraInfo, len, 4, ifp);\n        }\n        lenCanonCameraInfo = len;\n        typeCanonCameraInfo = type;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        unique_id = setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo, typeCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes(tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n\n      if ((tag == 0x0320) && (type == 9) && (len == 1) && !strncasecmp(make, \"Leica Camera AG\", 15) &&\n          !strncmp(buf, \"LEICA\", 5) && (buf[5] == 0) && (buf[6] == 0) && (buf[7] == 0))\n        imgdata.other.CameraTemperature = getreal(type);\n\n      if (tag == 0x34003402)\n        imgdata.other.CameraTemperature = getreal(type);\n\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n        imgdata.color.dng_color[ind].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n      }\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x1d) // serial number\n        while ((c = fgetc(ifp)) && c != EOF)\n        {\n          if ((!custom_serial) && (!isdigit(c)))\n          {\n            if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n            {\n              custom_serial = 34;\n            }\n            else\n            {\n              custom_serial = 96;\n            }\n          }\n          serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n        }\n      else if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        imgdata.makernotes.nikon.NEFCompression = i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0097)\n      {\n        for (i = 0; i < 4; i++)\n          ver97 = ver97 * 10 + fgetc(ifp) - '0';\n        if (ver97 == 601) // Coolpix A\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n\n      else if (tag == 0xa7) // shutter count\n      {\n        NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n        if ((NikonLensDataVersion > 200) && lenNikonLensData)\n        {\n          if (custom_serial)\n          {\n            ci = xlat[0][custom_serial];\n          }\n          else\n          {\n            ci = xlat[0][serial & 0xff];\n          }\n          cj = xlat[1][NikonKey];\n          ck = 0x60;\n          for (i = 0; i < lenNikonLensData; i++)\n            table_buf[i] ^= (cj += ci * ck++);\n          processNikonLensData(table_buf, lenNikonLensData);\n          lenNikonLensData = 0;\n          free(table_buf);\n        }\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n\n      else if (tag == 0x00b0)\n      {\n        get4(); // ME tag version, 4 symbols\n        imgdata.makernotes.nikon.ExposureMode = get4();\n        imgdata.makernotes.nikon.nMEshots = get4();\n        imgdata.makernotes.nikon.MEgainOn = get4();\n      }\n\n      else if (tag == 0x00b9)\n      {\n        uchar uc;\n        int8_t sc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTune = uc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTuneIndex = uc;\n        fread(&sc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTuneAdj = sc;\n      }\n\n      else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc, 1, 1, ifp);\n        iso_speed = (int)(100.0 * libraw_powf64l(2.0, (double)(cc) / 12.0 - 5.0));\n        break;\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      short nWB, tWB;\n      int SubDirOffsetValid = strncmp(model, \"E-300\", 5) && strncmp(model, \"E-330\", 5) && strncmp(model, \"E-400\", 5) &&\n                              strncmp(model, \"E-500\", 5) && strncmp(model, \"E-1\", 3);\n\n      if ((tag == 0x2010) || (tag == 0x2020) || (tag == 0x2030) || (tag == 0x2031) || (tag == 0x2040) ||\n          (tag == 0x2050) || (tag == 0x3000))\n      {\n        fseek(ifp, save - 4, SEEK_SET);\n        fseek(ifp, base + get4(), SEEK_SET);\n        parse_makernote_0xc634(base, tag, dng_writer);\n      }\n      if (!SubDirOffsetValid && ((len > 4) || (((type == 3) || (type == 8)) && (len > 2)) ||\n                                 (((type == 4) || (type == 9)) && (len > 1)) || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n      if ((tag >= 0x20400101) && (tag <= 0x20400111))\n      {\n        if ((tag == 0x20400101) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n        {\n          int i;\n          for (i = 0; i < 64; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =\n                imgdata.color.WB_Coeffs[i][3] = 0x100;\n          }\n          for (i = 64; i < 256; i++)\n          {\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n          }\n        }\n        nWB = tag - 0x20400101;\n        tWB = Oly_wb_list2[nWB << 1];\n        ushort CT = Oly_wb_list2[(nWB << 1) | 1];\n        int wb[4];\n        wb[0] = get2();\n        wb[2] = get2();\n        if (tWB != 0x100)\n        {\n          imgdata.color.WB_Coeffs[tWB][0] = wb[0];\n          imgdata.color.WB_Coeffs[tWB][2] = wb[2];\n        }\n        if (CT)\n        {\n          imgdata.color.WBCT_Coeffs[nWB - 1][0] = CT;\n          imgdata.color.WBCT_Coeffs[nWB - 1][1] = wb[0];\n          imgdata.color.WBCT_Coeffs[nWB - 1][3] = wb[2];\n        }\n        if (len == 4)\n        {\n          wb[1] = get2();\n          wb[3] = get2();\n          if (tWB != 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][1] = wb[1];\n            imgdata.color.WB_Coeffs[tWB][3] = wb[3];\n          }\n          if (CT)\n          {\n            imgdata.color.WBCT_Coeffs[nWB - 1][2] = wb[1];\n            imgdata.color.WBCT_Coeffs[nWB - 1][4] = wb[3];\n          }\n        }\n      }\n      else if ((tag >= 0x20400112) && (tag <= 0x2040011e))\n      {\n        nWB = tag - 0x20400112;\n        int wbG = get2();\n        tWB = Oly_wb_list2[nWB << 1];\n        if (nWB)\n          imgdata.color.WBCT_Coeffs[nWB - 1][2] = imgdata.color.WBCT_Coeffs[nWB - 1][4] = wbG;\n        if (tWB != 0x100)\n          imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = wbG;\n      }\n      else if (tag == 0x2040011f)\n      {\n        int wbG = get2();\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0])\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = wbG;\n        FORC4 if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][0])\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][3] =\n            wbG;\n      }\n      else if (tag == 0x20400121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        if (len == 4)\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n        }\n      }\n      else if ((tag == 0x30000110) && strcmp(software, \"v757-71\"))\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][2] = get2();\n        if (len == 2)\n        {\n          for (int i = 0; i < 256; i++)\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n        }\n      }\n      else if ((((tag >= 0x30000120) && (tag <= 0x30000124)) || ((tag >= 0x30000130) && (tag <= 0x30000133))) &&\n               strcmp(software, \"v757-71\"))\n      {\n        int wb_ind;\n        if (tag <= 0x30000124)\n          wb_ind = tag - 0x30000120;\n        else\n          wb_ind = tag - 0x30000130 + 5;\n        imgdata.color.WB_Coeffs[Oly_wb_list1[wb_ind]][0] = get2();\n        imgdata.color.WB_Coeffs[Oly_wb_list1[wb_ind]][2] = get2();\n      }\n      else\n      {\n        switch (tag)\n        {\n        case 0x0207:\n        case 0x20100100:\n        {\n          uchar sOlyID[8];\n          fread(sOlyID, MIN(len, 7), 1, ifp);\n          sOlyID[7] = 0;\n          OlyID = sOlyID[0];\n          i = 1;\n          while (i < 7 && sOlyID[i])\n          {\n            OlyID = OlyID << 8 | sOlyID[i];\n            i++;\n          }\n          setOlympusBodyFeatures(OlyID);\n        }\n        break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, getreal(type) / 2);\n          break;\n        case 0x20100102:\n          stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n          break;\n        case 0x20100201:\n          imgdata.lens.makernotes.LensID = (unsigned long long)fgetc(ifp) << 16 |\n                                           (unsigned long long)(fgetc(ifp), fgetc(ifp)) << 8 |\n                                           (unsigned long long)fgetc(ifp);\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n          }\n          break;\n        case 0x20100202:\n          if ((!imgdata.lens.LensSerial[0]))\n            stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          break;\n        case 0x20200306:\n        {\n          uchar uc;\n          fread(&uc, 1, 1, ifp);\n          imgdata.makernotes.olympus.AFFineTune = uc;\n        }\n        break;\n        case 0x20200307:\n          FORC3 imgdata.makernotes.olympus.AFFineTuneAdj[c] = get2();\n          break;\n        case 0x20200401:\n          imgdata.other.FlashEC = getreal(type);\n          break;\n        case 0x1007:\n          imgdata.other.SensorTemperature = (float)get2();\n          break;\n        case 0x1008:\n          imgdata.other.LensTemperature = (float)get2();\n          break;\n        case 0x20401306:\n        {\n          int temp = get2();\n          if ((temp != 0) && (temp != 100))\n          {\n            if (temp < 61)\n              imgdata.other.CameraTemperature = (float)temp;\n            else\n              imgdata.other.CameraTemperature = (float)(temp - 32) / 1.8f;\n            if ((OlyID == 0x4434353933ULL) && // TG-5\n                (imgdata.other.exifAmbientTemperature > -273.15f))\n              imgdata.other.CameraTemperature += imgdata.other.exifAmbientTemperature;\n          }\n        }\n        break;\n        case 0x20501500:\n          if (OlyID != 0x0ULL)\n          {\n            short temp = get2();\n            if ((OlyID == 0x4434303430ULL) || // E-1\n                (OlyID == 0x5330303336ULL) || // E-M5\n                (len != 1))\n              imgdata.other.SensorTemperature = (float)temp;\n            else if ((temp != -32768) && (temp != 0))\n            {\n              if (temp > 199)\n                imgdata.other.SensorTemperature = 86.474958f - 0.120228f * (float)temp;\n              else\n                imgdata.other.SensorTemperature = (float)temp;\n            }\n          }\n          break;\n        }\n      }\n    skip_Oly_broken_tags:;\n    }\n\n    else if (!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x000d)\n      {\n        imgdata.makernotes.pentax.FocusMode = get2();\n      }\n      else if (tag == 0x000e)\n      {\n        imgdata.makernotes.pentax.AFPointSelected = get2();\n      }\n      else if (tag == 0x000f)\n      {\n        imgdata.makernotes.pentax.AFPointsInFocus = getint(type);\n      }\n      else if (tag == 0x0010)\n      {\n        imgdata.makernotes.pentax.FocusPosition = get2();\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x0034)\n      {\n        uchar uc;\n        FORC4\n        {\n          fread(&uc, 1, 1, ifp);\n          imgdata.makernotes.pentax.DriveMode[c] = uc;\n        }\n      }\n      else if (tag == 0x0038)\n      {\n        imgdata.sizes.raw_crop.cleft = get2();\n        imgdata.sizes.raw_crop.ctop = get2();\n      }\n      else if (tag == 0x0039)\n      {\n        imgdata.sizes.raw_crop.cwidth = get2();\n        imgdata.sizes.raw_crop.cheight = get2();\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x0047)\n      {\n        imgdata.other.CameraTemperature = (float)fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x0072)\n      {\n        imgdata.makernotes.pentax.AFAdjustment = get2();\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if ((tag >= 0x020d) && (tag <= 0x0214))\n      {\n        FORC4 imgdata.color.WB_Coeffs[Pentax_wb_list1[tag - 0x020d]][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        int wb_ind;\n        getc(ifp);\n        for (int wb_cnt = 0; wb_cnt < nPentax_wb_list2; wb_cnt++)\n        {\n          wb_ind = getc(ifp);\n          if (wb_ind < nPentax_wb_list2)\n            FORC4 imgdata.color.WB_Coeffs[Pentax_wb_list2[wb_ind]][c ^ (c >> 1)] = get2();\n        }\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 12, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        imgdata.lens.makernotes.CamID = unique_id = get4();\n      }\n      else if (tag == 0x0043)\n      {\n        int temp = get4();\n        if (temp)\n        {\n          imgdata.other.CameraTemperature = (float)temp;\n          if (get4() == 10)\n            imgdata.other.CameraTemperature /= 10.0f;\n        }\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      parseSonyMakernotes(tag, type, len, AdobeDNG, table_buf_0x0116, table_buf_0x0116_len, table_buf_0x2010,\n                          table_buf_0x2010_len, table_buf_0x9050, table_buf_0x9050_len, table_buf_0x9400,\n                          table_buf_0x9400_len, table_buf_0x9402, table_buf_0x9402_len, table_buf_0x9403,\n                          table_buf_0x9403_len, table_buf_0x9406, table_buf_0x9406_len, table_buf_0x940c,\n                          table_buf_0x940c_len, table_buf_0x940e, table_buf_0x940e_len);\n    }\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{ /*placeholder */\n}\n#endif\n\nvoid CLASS parse_makernote(int base, int uptag)\n{\n  unsigned offset = 0, entries, tag, type, len, save, c;\n  unsigned ver97 = 0, serial = 0, i, wbi = 0, wb[4] = {0, 0, 0, 0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder = order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n  unsigned typeCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x0116;\n  ushort table_buf_0x0116_len = 0;\n  uchar *table_buf_0x2010;\n  ushort table_buf_0x2010_len = 0;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_len = 0;\n  uchar *table_buf_0x9400;\n  ushort table_buf_0x9400_len = 0;\n  uchar *table_buf_0x9402;\n  ushort table_buf_0x9402_len = 0;\n  uchar *table_buf_0x9403;\n  ushort table_buf_0x9403_len = 0;\n  uchar *table_buf_0x9406;\n  ushort table_buf_0x9406_len = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_len = 0;\n  uchar *table_buf_0x940e;\n  ushort table_buf_0x940e_len = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n  /*\n     The MakerNote might have its own TIFF header (possibly with\n     its own byte-order!), or it might just be a table.\n   */\n  if (!strncmp(make, \"Nokia\", 5))\n    return;\n  fread(buf, 1, 10, ifp);\n\n  /*\n    printf(\"===>>buf: 0x\");\n    for (int i = 0; i < sizeof buf; i ++) {\n          printf(\"%02x\", buf[i]);\n    }\n    putchar('\\n');\n  */\n\n  if (!strncmp(buf, \"KDK\", 3) || /* these aren't TIFF tables */\n      !strncmp(buf, \"VER\", 3) || !strncmp(buf, \"IIII\", 4) || !strncmp(buf, \"MMMM\", 4))\n    return;\n  if (!strncmp(buf, \"KC\", 2) || /* Konica KD-400Z, KD-510Z */\n      !strncmp(buf, \"MLY\", 3))\n  { /* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i = ftell(ifp)) < data_offset && i < 16384)\n    {\n      wb[0] = wb[2];\n      wb[2] = wb[1];\n      wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n        FORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \"))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if (!strncmp(make, \"SAMSUNG\", 7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n  {\n    if (!strncmp(model, \"M8\", 2) || !strncasecmp(model, \"Leica M8\", 8) || !strncasecmp(model, \"LEICA X\", 7))\n    {\n      base = ftell(ifp) - 8;\n    }\n    else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n    {\n      base = 0;\n    }\n    else if (!strncmp(model, \"M9\", 2) || !strncasecmp(model, \"Leica M9\", 8) || !strncasecmp(model, \"M Monochrom\", 11) ||\n             !strncasecmp(model, \"Leica M Monochrom\", 11))\n    {\n      if (!uptag)\n      {\n        base = ftell(ifp) - 10;\n        fseek(ifp, 8, SEEK_CUR);\n      }\n      else if (uptag == 0x3400)\n      {\n        fseek(ifp, 10, SEEK_CUR);\n        base += 10;\n      }\n    }\n    else if (!strncasecmp(model, \"LEICA T\", 7))\n    {\n      base = ftell(ifp) - 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (!strncasecmp(model, \"LEICA SL\", 8))\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n#endif\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if (len > 8 && _pos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (!strncasecmp(model, \"KODAK P880\", 10) || !strncasecmp(model, \"KODAK P850\", 10) ||\n        !strncasecmp(model, \"KODAK P712\", 10))\n    {\n      if (tag == 0xf90b)\n      {\n        imgdata.makernotes.kodak.clipBlack = get2();\n      }\n      else if (tag == 0xf90c)\n      {\n        imgdata.makernotes.kodak.clipWhite = get2();\n      }\n    }\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        if (type != 4)\n        {\n          CanonCameraInfo = (uchar *)malloc(MAX(16, len));\n          fread(CanonCameraInfo, len, 1, ifp);\n        }\n        else\n        {\n          CanonCameraInfo = (uchar *)malloc(MAX(16, len * 4));\n          fread(CanonCameraInfo, len, 4, ifp);\n        }\n        lenCanonCameraInfo = len;\n        typeCanonCameraInfo = type;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        unique_id = setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo, typeCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n    {\n      if (tag == 0x0010)\n      {\n        char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n        char *words[4];\n        char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n        int year, nwords, ynum_len;\n        unsigned c;\n        stmread(FujiSerial, len, ifp);\n        nwords = getwords(FujiSerial, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n        for (int i = 0; i < nwords; i++)\n        {\n          mm[2] = dd[2] = 0;\n          if (strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)\n            if (i == 0)\n              strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s\", imgdata.shootinginfo.InternalBodySerial, words[i]);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          else\n          {\n            strncpy(dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 14, 2);\n            strncpy(mm, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 16, 2);\n            strncpy(yy, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18, 2);\n            year = (yy[0] - '0') * 10 + (yy[1] - '0');\n            if (year < 70)\n              year += 2000;\n            else\n              year += 1900;\n\n            ynum_len = (int)strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18;\n            strncpy(ynum, words[i], ynum_len);\n            ynum[ynum_len] = 0;\n            for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, \"%2x\", &c); j += 2)\n              ystr[j / 2] = c;\n            ystr[ynum_len / 2 + 1] = 0;\n            strcpy(model2, ystr);\n\n            if (i == 0)\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n              if (nwords == 1)\n                snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s\",\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12, ystr,\n                         year, mm, dd);\n\n              else\n                snprintf(tbuf, sizeof(tbuf), \"%s %d:%s:%s %s\", ystr, year, mm, dd,\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s %s\", imgdata.shootinginfo.InternalBodySerial, ystr, year, mm,\n                       dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          }\n        }\n      }\n      else\n        parseFujiMakernotes(tag, type);\n    }\n\n    else if (!strncasecmp(model, \"Hasselblad X1D\", 14) || !strncasecmp(model, \"Hasselblad H6D\", 14) ||\n             !strncasecmp(model, \"Hasselblad A6D\", 14))\n    {\n      if (tag == 0x0045)\n      {\n        imgdata.makernotes.hasselblad.BaseISO = get4();\n      }\n      else if (tag == 0x0046)\n      {\n        imgdata.makernotes.hasselblad.Gain = getreal(type);\n      }\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n        imgdata.color.dng_color[ind].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n      }\n\n      if (tag == 0x34003402)\n        imgdata.other.CameraTemperature = getreal(type);\n\n      if ((tag == 0x0320) && (type == 9) && (len == 1) && !strncasecmp(make, \"Leica Camera AG\", 15) &&\n          !strncmp(buf, \"LEICA\", 5) && (buf[5] == 0) && (buf[6] == 0) && (buf[7] == 0))\n        imgdata.other.CameraTemperature = getreal(type);\n\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0012)\n      {\n        char a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n          imgdata.other.FlashEC = (float)(a * b) / (float)c;\n      }\n      else if (tag == 0x003b) // all 1s for regular exposures\n      {\n        imgdata.makernotes.nikon.ME_WB[0] = getreal(type);\n        imgdata.makernotes.nikon.ME_WB[2] = getreal(type);\n        imgdata.makernotes.nikon.ME_WB[1] = getreal(type);\n        imgdata.makernotes.nikon.ME_WB[3] = getreal(type);\n      }\n      else if (tag == 0x0045)\n      {\n        imgdata.sizes.raw_crop.cleft = get2();\n        imgdata.sizes.raw_crop.ctop = get2();\n        imgdata.sizes.raw_crop.cwidth = get2();\n        imgdata.sizes.raw_crop.cheight = get2();\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093) // Nikon compression\n      {\n        imgdata.makernotes.nikon.NEFCompression = i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData > 0)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n      else if (tag == 0x00a0)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n      else if (tag == 0x00b0)\n      {\n        get4(); // ME tag version, 4 symbols\n        imgdata.makernotes.nikon.ExposureMode = get4();\n        imgdata.makernotes.nikon.nMEshots = get4();\n        imgdata.makernotes.nikon.MEgainOn = get4();\n      }\n      else if (tag == 0x00b9)\n      {\n        uchar uc;\n        int8_t sc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTune = uc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTuneIndex = uc;\n        fread(&sc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTuneAdj = sc;\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      switch (tag)\n      {\n      case 0x0404:\n      case 0x101a:\n      case 0x20100101:\n        if (!imgdata.shootinginfo.BodySerial[0])\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n      case 0x20100102:\n        if (!imgdata.shootinginfo.InternalBodySerial[0])\n          stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, getreal(type) / 2);\n        break;\n      case 0x20400612:\n      case 0x30000612:\n        imgdata.sizes.raw_crop.cleft = get2();\n        break;\n      case 0x20400613:\n      case 0x30000613:\n        imgdata.sizes.raw_crop.ctop = get2();\n        break;\n      case 0x20400614:\n      case 0x30000614:\n        imgdata.sizes.raw_crop.cwidth = get2();\n        break;\n      case 0x20400615:\n      case 0x30000615:\n        imgdata.sizes.raw_crop.cheight = get2();\n        break;\n      case 0x20401112:\n        imgdata.makernotes.olympus.OlympusCropID = get2();\n        break;\n      case 0x20401113:\n        FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n        break;\n      case 0x20100201:\n      {\n        unsigned long long oly_lensid[3];\n        oly_lensid[0] = fgetc(ifp);\n        fgetc(ifp);\n        oly_lensid[1] = fgetc(ifp);\n        oly_lensid[2] = fgetc(ifp);\n        imgdata.lens.makernotes.LensID = (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n      }\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      case 0x1007:\n        imgdata.other.SensorTemperature = (float)get2();\n        break;\n      case 0x1008:\n        imgdata.other.LensTemperature = (float)get2();\n        break;\n      case 0x20401306:\n      {\n        int temp = get2();\n        if ((temp != 0) && (temp != 100))\n        {\n          if (temp < 61)\n            imgdata.other.CameraTemperature = (float)temp;\n          else\n            imgdata.other.CameraTemperature = (float)(temp - 32) / 1.8f;\n          if ((OlyID == 0x4434353933ULL) && // TG-5\n              (imgdata.other.exifAmbientTemperature > -273.15f))\n            imgdata.other.CameraTemperature += imgdata.other.exifAmbientTemperature;\n        }\n      }\n      break;\n      case 0x20501500:\n        if (OlyID != 0x0ULL)\n        {\n          short temp = get2();\n          if ((OlyID == 0x4434303430ULL) || // E-1\n              (OlyID == 0x5330303336ULL) || // E-M5\n              (len != 1))\n            imgdata.other.SensorTemperature = (float)temp;\n          else if ((temp != -32768) && (temp != 0))\n          {\n            if (temp > 199)\n              imgdata.other.SensorTemperature = 86.474958f - 0.120228f * (float)temp;\n            else\n              imgdata.other.SensorTemperature = (float)temp;\n          }\n        }\n        break;\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) && !strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        char buffer[17];\n        int count = 0;\n        fread(buffer, 16, 1, ifp);\n        buffer[16] = 0;\n        for (int i = 0; i < 16; i++)\n        {\n          //    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n          if ((isspace(buffer[i])) || (buffer[i] == 0x2D) || (isalnum(buffer[i])))\n            count++;\n        }\n        if (count == 16)\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%8s\", buffer + 8);\n          buffer[8] = 0;\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n        }\n        else\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10],\n                  buffer[11]);\n        }\n      }\n      else if ((tag == 0x1001) && (type == 3))\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n        imgdata.lens.makernotes.LensID = -1;\n        imgdata.lens.makernotes.FocalType = 1;\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n    }\n\n    else if (!strncmp(make, \"RICOH\", 5) && strncmp(model, \"PENTAX\", 6))\n    {\n      if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n      {\n        char buffer[9];\n        buffer[8] = 0;\n        fread(buffer, 8, 1, ifp);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n\n      else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n      {\n        short ntags, cur_tag;\n        fseek(ifp, 20, SEEK_CUR);\n        ntags = get2();\n        cur_tag = get2();\n        while (cur_tag != 0x002c)\n        {\n          fseek(ifp, 10, SEEK_CUR);\n          cur_tag = get2();\n        }\n        fseek(ifp, 6, SEEK_CUR);\n        fseek(ifp, get4() + 20, SEEK_SET);\n        stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n        get2();\n        imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n        switch (imgdata.lens.makernotes.LensID)\n        {\n        case 1:\n        case 2:\n        case 3:\n        case 5:\n        case 6:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n          break;\n        case 8:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n          imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n          imgdata.lens.makernotes.LensID = -1;\n          break;\n        default:\n          imgdata.lens.makernotes.LensID = -1;\n        }\n        fseek(ifp, 17, SEEK_CUR);\n        stread(imgdata.lens.LensSerial, 12, ifp);\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n              (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x000d)\n      {\n        imgdata.makernotes.pentax.FocusMode = get2();\n      }\n      else if (tag == 0x000e)\n      {\n        imgdata.makernotes.pentax.AFPointSelected = get2();\n      }\n      else if (tag == 0x000f)\n      {\n        imgdata.makernotes.pentax.AFPointsInFocus = getint(type);\n      }\n      else if (tag == 0x0010)\n      {\n        imgdata.makernotes.pentax.FocusPosition = get2();\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x0034)\n      {\n        uchar uc;\n        FORC4\n        {\n          fread(&uc, 1, 1, ifp);\n          imgdata.makernotes.pentax.DriveMode[c] = uc;\n        }\n      }\n      else if (tag == 0x0038)\n      {\n        imgdata.sizes.raw_crop.cleft = get2();\n        imgdata.sizes.raw_crop.ctop = get2();\n      }\n      else if (tag == 0x0039)\n      {\n        imgdata.sizes.raw_crop.cwidth = get2();\n        imgdata.sizes.raw_crop.cheight = get2();\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x0047)\n      {\n        imgdata.other.CameraTemperature = (float)fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x0072)\n      {\n        imgdata.makernotes.pentax.AFAdjustment = get2();\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if ((tag >= 0x020d) && (tag <= 0x0214))\n      {\n        FORC4 imgdata.color.WB_Coeffs[Pentax_wb_list1[tag - 0x020d]][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        int wb_ind;\n        getc(ifp);\n        for (int wb_cnt = 0; wb_cnt < nPentax_wb_list2; wb_cnt++)\n        {\n          wb_ind = getc(ifp);\n          if (wb_ind < nPentax_wb_list2)\n            FORC4 imgdata.color.WB_Coeffs[Pentax_wb_list2[wb_ind]][c ^ (c >> 1)] = get2();\n        }\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 2, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        unique_id = imgdata.lens.makernotes.CamID = get4();\n      }\n      else if (tag == 0x0043)\n      {\n        int temp = get4();\n        if (temp)\n        {\n          imgdata.other.CameraTemperature = (float)temp;\n          if (get4() == 10)\n            imgdata.other.CameraTemperature /= 10.0f;\n        }\n      }\n      else if (tag == 0xa002)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      parseSonyMakernotes(tag, type, len, nonDNG, table_buf_0x0116, table_buf_0x0116_len, table_buf_0x2010,\n                          table_buf_0x2010_len, table_buf_0x9050, table_buf_0x9050_len, table_buf_0x9400,\n                          table_buf_0x9400_len, table_buf_0x9402, table_buf_0x9402_len, table_buf_0x9403,\n                          table_buf_0x9403_len, table_buf_0x9406, table_buf_0x9406_len, table_buf_0x940c,\n                          table_buf_0x940c_len, table_buf_0x940e, table_buf_0x940e_len);\n    }\n\n    fseek(ifp, _pos, SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make, \"NIKON\") && !iso_speed)\n      iso_speed = (get2(), get2());\n    if (tag == 37 && strstr(make, \"NIKON\") && (!iso_speed || iso_speed == 65535))\n    {\n      unsigned char cc;\n      fread(&cc, 1, 1, ifp);\n      iso_speed = int(100.0 * libraw_powf64l(2.0f, float(cc) / 12.0 - 5.0));\n    }\n    if (tag == 4 && len > 26 && len < 35)\n    {\n      if ((i = (get4(), get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n        iso_speed = 50 * libraw_powf64l(2.0, i / 32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i = (get2(), get2())) != 0x7fff && !aperture)\n        aperture = libraw_powf64l(2.0, i / 64.0);\n#endif\n      if ((i = get2()) != 0xffff && !shutter)\n        shutter = libraw_powf64l(2.0, (short)i / -32.0);\n      wbi = (get2(), get2());\n      shot_order = (get2(), get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make, \"KONICA\", 6))\n    {\n      fseek(ifp, tag == 4 ? 140 : 160, SEEK_CUR);\n      switch (get2())\n      {\n      case 72:\n        flip = 0;\n        break;\n      case 76:\n        flip = 6;\n        break;\n      case 82:\n        flip = 5;\n        break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets(model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make, \"Canon\", 5))\n      fread(artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa)\n    {\n#if 0 /* Canon rotation data is handled by EXIF.Orientation */\n      for (c = i = 2; (ushort)c != 0xbbbb && i < len; i++)\n        c = c << 8 | fgetc(ifp);\n      while ((i += 4) < len - 5)\n        if (get4() == 257 && (i = len) && (c = (get4(), fgetc(ifp))) < 3)\n          flip = \"065\"[c] - '0';\n#endif\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n    if (!strncasecmp(make, \"Olympus\", 7))\n    {\n      short nWB, tWB;\n      if ((tag == 0x20300108) || (tag == 0x20310109))\n        imgdata.makernotes.olympus.ColorSpace = get2();\n\n      if ((tag == 0x20400101) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n      {\n        int i;\n        for (i = 0; i < 64; i++)\n          imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =\n              imgdata.color.WB_Coeffs[i][3] = 0x100;\n        for (i = 64; i < 256; i++)\n          imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n      }\n      if ((tag >= 0x20400101) && (tag <= 0x20400111))\n      {\n        nWB = tag - 0x20400101;\n        tWB = Oly_wb_list2[nWB << 1];\n        ushort CT = Oly_wb_list2[(nWB << 1) | 1];\n        int wb[4];\n        wb[0] = get2();\n        wb[2] = get2();\n        if (tWB != 0x100)\n        {\n          imgdata.color.WB_Coeffs[tWB][0] = wb[0];\n          imgdata.color.WB_Coeffs[tWB][2] = wb[2];\n        }\n        if (CT)\n        {\n          imgdata.color.WBCT_Coeffs[nWB - 1][0] = CT;\n          imgdata.color.WBCT_Coeffs[nWB - 1][1] = wb[0];\n          imgdata.color.WBCT_Coeffs[nWB - 1][3] = wb[2];\n        }\n        if (len == 4)\n        {\n          wb[1] = get2();\n          wb[3] = get2();\n          if (tWB != 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][1] = wb[1];\n            imgdata.color.WB_Coeffs[tWB][3] = wb[3];\n          }\n          if (CT)\n          {\n            imgdata.color.WBCT_Coeffs[nWB - 1][2] = wb[1];\n            imgdata.color.WBCT_Coeffs[nWB - 1][4] = wb[3];\n          }\n        }\n      }\n      if ((tag >= 0x20400112) && (tag <= 0x2040011e))\n      {\n        nWB = tag - 0x20400112;\n        int wbG = get2();\n        tWB = Oly_wb_list2[nWB << 1];\n        if (nWB)\n          imgdata.color.WBCT_Coeffs[nWB - 1][2] = imgdata.color.WBCT_Coeffs[nWB - 1][4] = wbG;\n        if (tWB != 0x100)\n          imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = wbG;\n      }\n\n      if (tag == 0x20400121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        if (len == 4)\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n        }\n      }\n      if (tag == 0x2040011f)\n      {\n        int wbG = get2();\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0])\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = wbG;\n        FORC4 if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][0])\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][3] =\n            wbG;\n      }\n      if ((tag == 0x30000110) && strcmp(software, \"v757-71\"))\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][2] = get2();\n        if (len == 2)\n        {\n          for (int i = 0; i < 256; i++)\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n        }\n      }\n      if ((((tag >= 0x30000120) && (tag <= 0x30000124)) || ((tag >= 0x30000130) && (tag <= 0x30000133))) &&\n          strcmp(software, \"v757-71\"))\n      {\n        int wb_ind;\n        if (tag <= 0x30000124)\n          wb_ind = tag - 0x30000120;\n        else\n          wb_ind = tag - 0x30000130 + 5;\n        imgdata.color.WB_Coeffs[Oly_wb_list1[wb_ind]][0] = get2();\n        imgdata.color.WB_Coeffs[Oly_wb_list1[wb_ind]][2] = get2();\n      }\n\n      if ((tag == 0x20400805) && (len == 2))\n      {\n        imgdata.makernotes.olympus.OlympusSensorCalibration[0] = getreal(type);\n        imgdata.makernotes.olympus.OlympusSensorCalibration[1] = getreal(type);\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n      }\n      if (tag == 0x20200306)\n      {\n        uchar uc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.olympus.AFFineTune = uc;\n      }\n      if (tag == 0x20200307)\n      {\n        FORC3 imgdata.makernotes.olympus.AFFineTuneAdj[c] = get2();\n      }\n      if (tag == 0x20200401)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n    }\n    fseek(ifp, _pos2, SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make, \"NIKON\", 5))\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n    }\n    if (tag == 0x14 && type == 7)\n    {\n      if (len == 2560)\n      {\n        fseek(ifp, 1248, SEEK_CUR);\n        goto get2_256;\n      }\n      fread(buf, 1, 10, ifp);\n      if (!strncmp(buf, \"NRW \", 4))\n      {\n        fseek(ifp, strcmp(buf + 4, \"0100\") ? 46 : 1546, SEEK_CUR);\n        cam_mul[0] = get4() << 2;\n        cam_mul[1] = get4() + get4();\n        cam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread(model, 64, 1, ifp);\n    if (strstr(make, \"PENTAX\"))\n    {\n      if (tag == 0x1b)\n        tag = 0x1018;\n      if (tag == 0x1c)\n        tag = 0x1017;\n    }\n    if (tag == 0x1d)\n    {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n        serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1)\n    { // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi] - '0' : 0;\n      fseek(ifp, 8 + c * 32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14 - tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4)\n    {\n      data_offset = get4();\n      fseek(ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81 && type == 7) || (tag == 0x100 && type == 7) || (tag == 0x280 && type == 1))\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97)\n    {\n      for (i = 0; i < 4; i++)\n        ver97 = ver97 * 10 + fgetc(ifp) - '0';\n      switch (ver97)\n      {\n      case 100:\n        fseek(ifp, 68, SEEK_CUR);\n        FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n        break;\n      case 102:\n        fseek(ifp, 6, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = get2();\n        break;\n      case 103:\n        fseek(ifp, 16, SEEK_CUR);\n        FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200)\n      {\n        if (ver97 != 205)\n          fseek(ifp, 280, SEEK_CUR);\n        fread(buf97, 324, 1, ifp);\n      }\n    }\n    if ((tag == 0xa1) && (type == 7) && strncasecmp(make, \"Samsung\", 7))\n    {\n      order = 0x4949;\n      fseek(ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3)\n    {\n      fseek(ifp, wbi * 48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7)\n    { // shutter count\n      NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n      if ((unsigned)(ver97 - 200) < 17)\n      {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97 - 200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] = sget2(buf97 + (i & -2) + c * 2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601) // Coolpix A\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n#endif\n    }\n\n    if (tag == 0xb001 && type == 3) // Sony ModelID\n    {\n      unique_id = get2();\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(), get4());\n    if (tag == 0x200 && len == 4) // Pentax black level\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4) // Pentax As Shot WB\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make, \"NIKON\") && len == 4)\n    {\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black += i;\n    }\n#endif\n    if (tag == 0xe01)\n    { /* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n      int loopc = 0;\n#endif\n      order = 0x4949;\n      fseek(ifp, 22, SEEK_CUR);\n      for (offset = 22; offset + 22 < len; offset += 22 + i)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (loopc++ > 1024)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        tag = get4();\n        fseek(ifp, 14, SEEK_CUR);\n        i = get4() - 4;\n        if (tag == 0x76a43207)\n          flip = get2();\n        else\n          fseek(ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7)\n    {\n      fseek(ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7)\n    {\n      if (len == 614)\n        fseek(ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n        fseek(ifp, 148, SEEK_CUR);\n      else\n        goto next;\n      goto get2_256;\n    }\n    if (((tag == 0x1011 && len == 9) || tag == 0x20400200) && strcmp(software, \"v757-71\"))\n      for (i = 0; i < 3; i++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!imgdata.makernotes.olympus.ColorSpace)\n        {\n          FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n        }\n        else\n        {\n          FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;\n        }\n#else\n        FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n#endif\n      }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2)\n    {\n    get2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek(ifp, get4() + base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    if (tag == 0x2010)\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, 0x2010);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n\n    if (((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031) || (tag == 0x2050)) &&\n        ((type == 7) || (type == 13)) && !strncasecmp(make, \"Olympus\", 7))\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, tag);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf, \"OLYMP\", 5))\n      parse_thumb_note(base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote(base, 0x2040);\n    if (tag == 0xb028)\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_thumb_note(base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000)\n    {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek(ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i += 18; i <= len; i += 10)\n      {\n        get2();\n        FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n        if (sraw_mul[1] == 1170)\n          break;\n      }\n    }\n    if (!strncasecmp(make, \"Samsung\", 7))\n    {\n      if (tag == 0xa020) // get the full Samsung encryption key\n        for (i = 0; i < 11; i++)\n          SamsungKey[i] = get4();\n      if (tag == 0xa021) // get and decode Samsung cam_mul array\n        FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tag == 0xa022)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get4() - SamsungKey[c + 4];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][3] >> 4;\n        }\n      }\n\n      if (tag == 0xa023)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n        }\n      }\n      if (tag == 0xa024)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c + 1];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n        }\n      }\n      /*\n            if (tag == 0xa025) {\n              i = get4();\n              imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n                  imgdata.color.linear_max[3] = i - SamsungKey[0]; printf (\"Samsung 0xa025 %d\\n\", i); }\n      */\n      if (tag == 0xa030 && len == 9)\n        for (i = 0; i < 3; i++)\n          FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n#endif\n      if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix\n        for (i = 0; i < 3; i++)\n          FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n\n      if (tag == 0xa028)\n        FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n    }\n    else\n    {\n      // Somebody else use 0xa021 and 0xa028?\n      if (tag == 0xa021)\n        FORC4 cam_mul[c ^ (c >> 1)] = get4();\n      if (tag == 0xa028)\n        FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x4021 && (imgdata.makernotes.canon.multishot[0] = get4()) &&\n        (imgdata.makernotes.canon.multishot[1] = get4()))\n    {\n      if (len >= 4)\n      {\n        imgdata.makernotes.canon.multishot[2] = get4();\n        imgdata.makernotes.canon.multishot[3] = get4();\n      }\n      FORC4 cam_mul[c] = 1024;\n    }\n#else\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\n#endif\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp(int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i = 19; i--;)\n      str[i] = fgetc(ifp);\n  else\n    fread(str, 19, 1, ifp);\n  memset(&t, 0, sizeof t);\n  if (sscanf(str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif(int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo, ape;\n\n  kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;\n  entries = get2();\n  if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > fsize * 2)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n    switch (tag)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\n    case 0x9400:\n      imgdata.other.exifAmbientTemperature = getreal(type);\n      if ((imgdata.other.CameraTemperature > -273.15f) && (OlyID == 0x4434353933ULL)) // TG-5\n        imgdata.other.CameraTemperature += imgdata.other.exifAmbientTemperature;\n      break;\n    case 0x9401:\n      imgdata.other.exifHumidity = getreal(type);\n      break;\n    case 0x9402:\n      imgdata.other.exifPressure = getreal(type);\n      break;\n    case 0x9403:\n      imgdata.other.exifWaterDepth = getreal(type);\n      break;\n    case 0x9404:\n      imgdata.other.exifAcceleration = getreal(type);\n      break;\n    case 0x9405:\n      imgdata.other.exifCameraElevationAngle = getreal(type);\n      break;\n\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n    case 33434:\n      tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);\n      break;\n    case 33437:\n      aperture = getreal(type);\n      break; // 0x829d FNumber\n    case 34855:\n      iso_speed = get2();\n      break;\n    case 34865:\n      if (iso_speed == 0xffff && !strncasecmp(make, \"FUJI\", 4))\n        iso_speed = getreal(type);\n      break;\n    case 34866:\n      if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))\n        iso_speed = getreal(type);\n      break;\n    case 36867:\n    case 36868:\n      get_timestamp(0);\n      break;\n    case 37377:\n      if ((expo = -getreal(type)) < 128 && shutter == 0.)\n        tiff_ifd[tiff_nifds - 1].t_shutter = shutter = libraw_powf64l(2.0, expo);\n      break;\n    case 37378: // 0x9202 ApertureValue\n      if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))\n        aperture = libraw_powf64l(2.0, ape / 2);\n      break;\n    case 37385:\n      flash_used = getreal(type);\n      break;\n    case 37386:\n      focal_len = getreal(type);\n      break;\n    case 37500: // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\", 6))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_OV5647\", 9))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_imx219\", 9))))\n      {\n        char mn_text[512];\n        char *pos;\n        char ccms[512];\n        ushort l;\n        float num;\n\n\tfgets(mn_text, MIN(len,511), ifp);\n        mn_text[511] = 0;\n\n        pos = strstr(mn_text, \"gain_r=\");\n        if (pos)\n          cam_mul[0] = atof(pos + 7);\n        pos = strstr(mn_text, \"gain_b=\");\n        if (pos)\n          cam_mul[2] = atof(pos + 7);\n        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n          cam_mul[1] = cam_mul[3] = 1.0f;\n        else\n          cam_mul[0] = cam_mul[2] = 0.0f;\n\n        pos = strstr(mn_text, \"ccm=\");\n        if(pos)\n        {\n         pos +=4;\n         char *pos2 = strstr(pos, \" \");\n         if(pos2)\n         {\n           l = pos2 - pos;\n           memcpy(ccms, pos, l);\n           ccms[l] = '\\0';\n#if defined WIN32 || defined(__MINGW32__)\n           // Win32 strtok is already thread-safe\n          pos = strtok(ccms, \",\");\n#else\n          char *last=0;\n          pos = strtok_r(ccms, \",\",&last);\n#endif\n          if(pos)\n          {\n            for (l = 0; l < 4; l++)\n            {\n              num = 0.0;\n              for (c = 0; c < 3; c++)\n              {\n                imgdata.color.ccm[l][c] = (float)atoi(pos);\n                num += imgdata.color.ccm[l][c];\n#if defined WIN32 || defined(__MINGW32__)\n                pos = strtok(NULL, \",\");\n#else\n                pos = strtok_r(NULL, \",\",&last);\n#endif\n                if(!pos) goto end; // broken\n              }\n              if (num > 0.01)\n                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n            }\n          }\n        }\n       }\n      end:;\n      }\n      else\n\n#endif\n        parse_makernote(base, 0);\n      break;\n    case 40962:\n      if (kodak)\n        raw_width = get4();\n      break;\n    case 40963:\n      if (kodak)\n        raw_height = get4();\n      break;\n    case 41730:\n      if (get4() == 0x20002)\n        for (exif_cfa = c = 0; c < 8; c += 2)\n          exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n    return;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue; // no GPS tags are 1k or larger\n    }\n    switch (tag)\n    {\n    case 1:\n      imgdata.other.parsed_gps.latref = getc(ifp);\n      break;\n    case 3:\n      imgdata.other.parsed_gps.longref = getc(ifp);\n      break;\n    case 5:\n      imgdata.other.parsed_gps.altref = getc(ifp);\n      break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9:\n      imgdata.other.parsed_gps.gpsstatus = getc(ifp);\n      break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue; // no GPS tags are 1k or larger\n    }\n    switch (tag)\n    {\n    case 1:\n    case 3:\n    case 5:\n      gpsdata[29 + tag / 2] = getc(ifp);\n      break;\n    case 2:\n    case 4:\n    case 7:\n      FORC(6) gpsdata[tag / 3 * 6 + c] = get4();\n      break;\n    case 6:\n      FORC(2) gpsdata[18 + c] = get4();\n      break;\n    case 18:\n    case 29:\n      fgets((char *)(gpsdata + 14 + tag / 3), MIN(len, 12), ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff(float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] = /* ROMM == Kodak ProPhoto */\n      {{2.034193, -0.727420, -0.306766}, {-0.228811, 1.231729, -0.002922}, {-0.008565, -0.153273, 1.161839}};\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      for (cmatrix[i][j] = k = 0; k < 3; k++)\n        cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos(int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes = 0, frot = 0;\n  static const char *mod[] = {\"\",\n                              \"DCB2\",\n                              \"Volare\",\n                              \"Cantare\",\n                              \"CMost\",\n                              \"Valeo 6\",\n                              \"Valeo 11\",\n                              \"Valeo 22\",\n                              \"Valeo 11p\",\n                              \"Valeo 17\",\n                              \"\",\n                              \"Aptus 17\",\n                              \"Aptus 22\",\n                              \"Aptus 75\",\n                              \"Aptus 65\",\n                              \"Aptus 54S\",\n                              \"Aptus 65S\",\n                              \"Aptus 75S\",\n                              \"AFi 5\",\n                              \"AFi 6\",\n                              \"AFi 7\",\n                              \"AFi-II 7\",\n                              \"Aptus-II 7\",\n                              \"\",\n                              \"Aptus-II 6\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10\",\n                              \"Aptus-II 5\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10R\",\n                              \"Aptus-II 8\",\n                              \"\",\n                              \"Aptus-II 12\",\n                              \"\",\n                              \"AFi-II 12\"};\n  float romm_cam[3][3];\n\n  fseek(ifp, offset, SEEK_SET);\n  while (1)\n  {\n    if (get4() != 0x504b5453)\n      break;\n    get4();\n    fread(data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data, \"CameraObj_camera_type\"))\n    {\n      stmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data, \"back_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.BodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));\n      strcpy(imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data, \"CaptProf_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n      strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n    // IB end\n    if (!strcmp(data, \"JPEG_preview_data\"))\n    {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data, \"icc_camera_profile\"))\n    {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data, \"ShootObj_back_type\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      if ((unsigned)i < sizeof mod / sizeof(*mod))\n        strcpy(model, mod[i]);\n    }\n    if (!strcmp(data, \"icc_camera_to_tone_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        ((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_color_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        fscanf(ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_number_of_planes\"))\n      fscanf(ifp, \"%d\", &planes);\n    if (!strcmp(data, \"CaptProf_raw_data_rotation\"))\n      fscanf(ifp, \"%d\", &flip);\n    if (!strcmp(data, \"CaptProf_mosaic_pattern\"))\n      FORC4\n      {\n        fscanf(ifp, \"%d\", &i);\n        if (i == 1)\n          frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data, \"ImgProf_rotation_angle\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data, \"NeutObj_neutrals\") && !cam_mul[0])\n    {\n      FORC4 fscanf(ifp, \"%d\", neut + c);\n      FORC3 cam_mul[c] = (float)neut[0] / neut[c + 1];\n    }\n    if (!strcmp(data, \"Rows_data\"))\n      load_flags = get4();\n    parse_mos(from);\n    fseek(ifp, skip + from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 * (uchar) \"\\x94\\x61\\x16\\x49\"[(flip / 90 + frot) & 3];\n}\n\nvoid CLASS linear_table(unsigned len)\n{\n  int i;\n  if (len > 0x10000)\n    len = 0x10000;\n  else if(len < 1)\n    return;\n  read_shorts(curve, len);\n  for (i = len; i < 0x10000; i++)\n    curve[i] = curve[i - 1];\n  maximum = curve[len < 0x1000 ? 0xfff : len - 1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags(int wb, unsigned type)\n{\n  float mul[3] = {1, 1, 1}, num, mul2;\n  int c;\n  FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n  imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n  mul2 = mul[1] * mul[1];\n  imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n  imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n  return;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int j, c, wbi = -2, romm_camTemp[9], romm_camScale[3];\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n  //  int a_blck = 0;\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  INT64 fsize = ifp->size();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n    if (tag == 1003)\n      imgdata.sizes.raw_crop.cleft = get2();\n    if (tag == 1004)\n      imgdata.sizes.raw_crop.ctop = get2();\n    if (tag == 1005)\n      imgdata.sizes.raw_crop.cwidth = get2();\n    if (tag == 1006)\n      imgdata.sizes.raw_crop.cheight = get2();\n    if (tag == 1007)\n      imgdata.makernotes.kodak.BlackLevelTop = get2();\n    if (tag == 1008)\n      imgdata.makernotes.kodak.BlackLevelBottom = get2();\n    if (tag == 1011)\n      imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());\n      wbi = -2;\n    }\n\n    if ((tag == 1030) && (len == 1))\n      imgdata.other.CameraTemperature = getreal(type);\n    if ((tag == 1043) && (len == 1))\n      imgdata.other.SensorTemperature = getreal(type);\n\n    if ((tag == 0x03ef) && (!strcmp(model, \"EOS D2000C\")))\n      black = get2();\n    if ((tag == 0x03f0) && (!strcmp(model, \"EOS D2000C\")))\n    {\n      if (black) // already set by tag 0x03ef\n        black = (black + get2()) / 2;\n      else\n        black = get2();\n    }\n    INT64 _pos2 = ftell(ifp);\n    if (tag == 0x0848)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x084c)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Custom, type);\n    if (tag == 0x084d)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Auto, type);\n    if (tag == 0x0e93)\n      imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n          imgdata.color.linear_max[3] = get2();\n    if (tag == 0x09ce)\n      stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n    if (tag == 0xfa00)\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n    if (tag == 0xfa27)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n    }\n    if (tag == 0xfa28)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n    }\n    if (tag == 0xfa29)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n    }\n    if (tag == 0xfa2a)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n    }\n\n    fseek(ifp, _pos2, SEEK_SET);\n\n    if (((tag == 0x07e4) || (tag == 0xfb01)) && (len == 9))\n    {\n      short validM = 0;\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camDaylight)[j] = getreal(type);\n        }\n        validM = 1;\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camDaylight)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n          validM = 1;\n        }\n      }\n      if (validM)\n      {\n        romm_coeff(imgdata.makernotes.kodak.romm_camDaylight);\n      }\n    }\n    if (((tag == 0x07e5) || (tag == 0xfb02)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camTungsten)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camTungsten)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n    if (((tag == 0x07e6) || (tag == 0xfb03)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camFluorescent)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camFluorescent)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n    if (((tag == 0x07e7) || (tag == 0xfb04)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camFlash)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camFlash)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n    if (((tag == 0x07e8) || (tag == 0xfb05)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camCustom)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camCustom)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n    if (((tag == 0x07e9) || (tag == 0xfb06)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camAuto)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camAuto)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n\n    if (tag == 2120 + wbi || (wbi < 0 && tag == 2125)) /* use Auto WB if illuminant index is not set */\n    {\n      FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n      FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n    }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 0x903)\n      iso_speed = getreal(type);\n    // if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 0xfa13)\n      width = getint(type);\n    if (tag == 0xfa14)\n      height = (getint(type) + 1) & -2;\n\n    /*\n        height = getint(type);\n\n        if (tag == 0xfa16)\n          raw_width = get2();\n        if (tag == 0xfa17)\n          raw_height = get2();\n    */\n    if (tag == 0xfa18)\n    {\n      imgdata.makernotes.kodak.offset_left = getint(8);\n      if (type != 8)\n        imgdata.makernotes.kodak.offset_left += 1;\n    }\n    if (tag == 0xfa19)\n    {\n      imgdata.makernotes.kodak.offset_top = getint(8);\n      if (type != 8)\n        imgdata.makernotes.kodak.offset_top += 1;\n    }\n\n    if (tag == 0xfa31)\n      imgdata.sizes.raw_crop.cwidth = get2();\n    if (tag == 0xfa32)\n      imgdata.sizes.raw_crop.cheight = get2();\n    if (tag == 0xfa3e)\n      imgdata.sizes.raw_crop.cleft = get2();\n    if (tag == 0xfa3f)\n      imgdata.sizes.raw_crop.ctop = get2();\n\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2, wbtemp = 6500;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, get2());\n      wbi = -2;\n    }\n    if (tag == 2118)\n      wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3\n      {\n        for (num = i = 0; i < 4; i++)\n          num += getreal(type) * pow(wbtemp / 100.0, i);\n        cam_mul[c] = 2048 / fMAX(1.0, (num * mul[c]));\n      }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 6020)\n      iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\nint CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : ((ifd + 1) << 20)), type, len, order,\n                        ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7302:\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c < 2)] = get2();\n        break;\n      case 0x7312:\n      {\n        int i, lc[4];\n        FORC4 lc[c] = get2();\n        i = (lc[1] == 1024 && lc[2] == 1024) << 1;\n        SWAP(lc[i], lc[i + 1]);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c] = lc[c];\n      }\n      break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        if (len == 3)\n        {\n          FORC3 imgdata.color.linear_max[c] = get2();\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        }\n        else if (len == 1)\n        {\n          imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n              imgdata.color.linear_max[3] = getreal(type); // Is non-short possible here??\n        }\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 10:\n      if (pana_raw && len == 1 && type == 3)\n      {\n        libraw_internal_data.unpacker_data.pana_bpp = get2();\n      }\n    break;\n#endif\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n\n    case 0x0120:\n      if (pana_raw)\n      {\n        unsigned sorder = order;\n        unsigned long sbase = base;\n        base = ftell(ifp);\n        order = get2();\n        fseek(ifp, 2, SEEK_CUR);\n        fseek(ifp, get4()-8, SEEK_CUR);\n        parse_tiff_ifd (base);\n        base = sbase;\n        order = sorder;\n      }\n    break;\n\n    case 0x2009:\n      if ((libraw_internal_data.unpacker_data.pana_encoding == 4) ||\n          (libraw_internal_data.unpacker_data.pana_encoding == 5))\n      {\n        int n = MIN (8, len);\n        int permut[8] = {3, 2, 1, 0, 3+4, 2+4, 1+4, 0+4};\n\n        imgdata.makernotes.panasonic.BlackLevelDim = len;\n\n        for (int i=0; i < n; i++)\n        {\n          imgdata.makernotes.panasonic.BlackLevel[permut[i]] =\n            (float) (get2()) / (float) (powf(2.f, 14.f-libraw_internal_data.unpacker_data.pana_bpp));\n        }\n      }\n      break;\n#endif\n\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 45:\n      if (pana_raw && len == 1 && type == 3)\n      {\n        libraw_internal_data.unpacker_data.pana_encoding = get2();\n      }\n      break;\n#endif\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454: // FujiFilm \"As Shot\"\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      if ((pana_raw) && (tag == 11) && (type == 3))\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.makernotes.panasonic.Compression = get2();\n#endif\n        break;\n      }\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n\t  if(cfa_pat[i] > 31) continue; // Skip wrong data\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0x9400:\n      imgdata.other.exifAmbientTemperature = getreal(type);\n      if ((imgdata.other.CameraTemperature > -273.15f) && (OlyID == 0x4434353933ULL)) // TG-5\n        imgdata.other.CameraTemperature += imgdata.other.exifAmbientTemperature;\n      break;\n    case 0x9401:\n      imgdata.other.exifHumidity = getreal(type);\n      break;\n    case 0x9402:\n      imgdata.other.exifPressure = getreal(type);\n      break;\n    case 0x9403:\n      imgdata.other.exifWaterDepth = getreal(type);\n      break;\n    case 0x9404:\n      imgdata.other.exifAcceleration = getreal(type);\n      break;\n    case 0x9405:\n      imgdata.other.exifCameraElevationAngle = getreal(type);\n      break;\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4\n      {\n\tint q = get2();\n\tif(q > 0) cam_mul[c ^ 1] = 4096.0 / q;\n      }\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINTABLE;\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00d:\n      if (strcmp(model, \"X-A3\")  &&\n          strcmp(model, \"X-A10\") &&\n          strcmp(model, \"X-A5\")  &&\n          strcmp(model, \"X-A20\"))\n      {\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][(4 - c) % 3] = getint(type);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][1];\n      }\n      break;\n    case 0xf00c:\n      if (strcmp(model, \"X-A3\")  &&\n          strcmp(model, \"X-A10\") &&\n          strcmp(model, \"X-A5\")  &&\n          strcmp(model, \"X-A20\"))\n      {\n        unsigned fwb[4];\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100)\n        {\n          imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n          imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n          imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n          if ((fwb[3] == 17) && (libraw_internal_data.unpacker_data.lenRAFData > 3) &&\n              (libraw_internal_data.unpacker_data.lenRAFData < 10240000))\n          {\n            INT64 f_save = ftell(ifp);\n            ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n            fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n            fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n            fseek(ifp, f_save, SEEK_SET);\n            int fj, found = 0;\n            for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n            {\n              if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n              {\n                if (rafdata[fi - 15] != fwb[0])\n                  continue;\n\n                for (int wb_ind = 0, ofst = fi - 15; wb_ind < nFuji_wb_list1; wb_ind++, ofst += 3)\n                {\n                  imgdata.color.WB_Coeffs[Fuji_wb_list1[wb_ind]][1] =\n                      imgdata.color.WB_Coeffs[Fuji_wb_list1[wb_ind]][3] = rafdata[ofst];\n                  imgdata.color.WB_Coeffs[Fuji_wb_list1[wb_ind]][0] = rafdata[ofst + 1];\n                  imgdata.color.WB_Coeffs[Fuji_wb_list1[wb_ind]][2] = rafdata[ofst + 2];\n                }\n                fi += 0x60;\n                for (fj = fi; fj < (fi + 15); fj += 3)\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    found = 1;\n                    break;\n                  }\n                if (found)\n                {\n                  fj = fj - 93;\n                  for (int iCCT = 0; iCCT < 31; iCCT++)\n                  {\n                    imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                    imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                  }\n                }\n                free(rafdata);\n                break;\n              }\n            }\n          }\n        }\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100)\n        {\n          imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n          imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n          imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        }\n      }\n      break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      if(len>0)\n       {\n        black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n#endif\n       }\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_WHITE;\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      {\n\tfloat q1 = getreal(type);\n\tfloat q2 = getreal(type);\n\tif(q1 > 0.00001f && q2 > 0.00001f)\n\t {\n      \t\tpixel_aspect = q1/q2;\n      \t\tif (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        \t\tpixel_aspect = 1.0;\n\t }\n      }\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50719: /* DefaultCropOrigin */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPORIGIN;\n        tiff_ifd[ifd].dng_levels.default_crop[0] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[1] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_crop.cleft = tiff_ifd[ifd].dng_levels.default_crop[0];\n          imgdata.sizes.raw_crop.ctop = tiff_ifd[ifd].dng_levels.default_crop[1];\n        }\n      }\n      break;\n    case 50720: /* DefaultCropSize */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPSIZE;\n        tiff_ifd[ifd].dng_levels.default_crop[2] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[3] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_crop.cwidth = tiff_ifd[ifd].dng_levels.default_crop[2];\n          imgdata.sizes.raw_crop.cheight = tiff_ifd[ifd].dng_levels.default_crop[3];\n        }\n      }\n      break;\n    case 0x74c7:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.makernotes.sony.raw_crop.cleft = get4();\n        imgdata.makernotes.sony.raw_crop.ctop = get4();\n      }\n      break;\n    case 0x74c8:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.makernotes.sony.raw_crop.cwidth = get4();\n        imgdata.makernotes.sony.raw_crop.cheight = get4();\n      }\n      break;\n\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      tiff_ifd[ifd].dng_color[0].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      tiff_ifd[ifd].dng_color[1].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n      tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_COLORMATRIX;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n      tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n      tiff_ifd[ifd].dng_color[j].parsedfields |= LIBRAW_DNGFM_CALIBRATION;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ANALOGBALANCE;\n#endif\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n\n            INT64 save_pos = ifp->tell();\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n\n            curr_pos = save_pos + MakN_length - 6;\n            fseek(ifp, curr_pos, SEEK_SET);\n\n            fread(mbuf, 1, 4, ifp);\n            curr_pos += 8;\n            if (!strncmp(mbuf, \"SR2 \", 4))\n            {\n              order = 0x4d4d;\n              MakN_length = get4();\n              MakN_order = get2();\n              pos_in_original_raw = get4();\n              order = MakN_order;\n\n              unsigned *buf_SR2;\n              uchar *cbuf_SR2;\n              unsigned icbuf_SR2;\n              unsigned entries, tag, type, len, save;\n              int ival;\n              unsigned SR2SubIFDOffset = 0;\n              unsigned SR2SubIFDLength = 0;\n              unsigned SR2SubIFDKey = 0;\n              int base = curr_pos + 6 - pos_in_original_raw;\n              entries = get2();\n              while (entries--)\n              {\n                tiff_get(base, &tag, &type, &len, &save);\n\n                if (tag == 0x7200)\n                {\n                  SR2SubIFDOffset = get4();\n                }\n                else if (tag == 0x7201)\n                {\n                  SR2SubIFDLength = get4();\n                }\n                else if (tag == 0x7221)\n                {\n                  SR2SubIFDKey = get4();\n                }\n                fseek(ifp, save, SEEK_SET);\n              }\n\n              if (SR2SubIFDLength && (SR2SubIFDLength < 10240000) && (buf_SR2 = (unsigned *)malloc(SR2SubIFDLength+1024))) // 1024b for safety\n              {\n                fseek(ifp, SR2SubIFDOffset + base, SEEK_SET);\n                fread(buf_SR2, SR2SubIFDLength, 1, ifp);\n                sony_decrypt(buf_SR2, SR2SubIFDLength / 4, 1, SR2SubIFDKey);\n                cbuf_SR2 = (uchar *)buf_SR2;\n                entries = sget2(cbuf_SR2);\n                icbuf_SR2 = 2;\n                while (entries--)\n                {\n                  tag = sget2(cbuf_SR2 + icbuf_SR2);\n                  icbuf_SR2 += 2;\n                  type = sget2(cbuf_SR2 + icbuf_SR2);\n                  icbuf_SR2 += 2;\n                  len = sget4(cbuf_SR2 + icbuf_SR2);\n                  icbuf_SR2 += 4;\n\n                  if (len * (\"11124811248484\"[type < 14 ? type : 0] - '0') > 4)\n                  {\n                    ival = sget4(cbuf_SR2 + icbuf_SR2) - SR2SubIFDOffset;\n                  }\n                  else\n                  {\n                    ival = icbuf_SR2;\n                  }\n\t\t  if(ival > SR2SubIFDLength) // points out of orig. buffer size\n\t\t     break; // END processing. Generally we should check against SR2SubIFDLength minus 6 of 8, depending on tag, but we allocated extra 1024b for buffer, so this does not matter\n\n                  icbuf_SR2 += 4;\n\n                  switch (tag)\n                  {\n                  case 0x7302:\n                    FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c < 2)] = sget2(cbuf_SR2 + ival + 2 * c);\n                    break;\n                  case 0x7312:\n                  {\n                    int i, lc[4];\n                    FORC4 lc[c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    i = (lc[1] == 1024 && lc[2] == 1024) << 1;\n                    SWAP(lc[i], lc[i + 1]);\n                    FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c] = lc[c];\n                  }\n                  break;\n                  case 0x7480:\n                  case 0x7820:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n                    break;\n                  case 0x7481:\n                  case 0x7821:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n                    break;\n                  case 0x7482:\n                  case 0x7822:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n                    break;\n                  case 0x7483:\n                  case 0x7823:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n                    break;\n                  case 0x7484:\n                  case 0x7824:\n                    imgdata.color.WBCT_Coeffs[0][0] = 4500;\n                    FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n                    break;\n                  case 0x7486:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n                    break;\n                  case 0x7825:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n                    break;\n                  case 0x7826:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n                    break;\n                  case 0x7827:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n                    break;\n                  case 0x7828:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n                    break;\n                  case 0x7829:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n                    break;\n                  case 0x782a:\n                    imgdata.color.WBCT_Coeffs[1][0] = 8500;\n                    FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n                    break;\n                  case 0x782b:\n                    imgdata.color.WBCT_Coeffs[2][0] = 6000;\n                    FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n                    break;\n                  case 0x782c:\n                    imgdata.color.WBCT_Coeffs[3][0] = 3200;\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] =\n                        sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n                    break;\n                  case 0x782d:\n                    imgdata.color.WBCT_Coeffs[4][0] = 2500;\n                    FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n                    break;\n                  }\n                }\n\n                free(buf_SR2);\n              }\n\n            } /* SR2 processed */\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50970: /* PreviewColorSpace */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_PREVIEWCS;\n      tiff_ifd[ifd].dng_levels.preview_colorspace = getint(type);\n      break;\n#endif\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE2;\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC\n     if(fabs(asn[c])>0.0001)\n     \tcam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC if(fabs(cc[c][c])>0.0001) pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff(int base)\n{\n  int doff;\n  fseek(ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d)\n    return 0;\n  get2();\n  while ((doff = get4()))\n  {\n    fseek(ifp, doff + base, SEEK_SET);\n    if (parse_tiff_ifd(base))\n      break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp = 0, ties = 0, raw = -1, thm = -1, i;\n  unsigned long long ns, os;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n      {\n        thumb_misc = jh.bits;\n        thumb_width = jh.wide;\n        thumb_height = jh.high;\n      }\n    }\n  }\n  for (i = tiff_nifds; i--;)\n  {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i = 0; i < tiff_nifds; i++)\n  {\n    if( tiff_ifd[i].t_width < 1 ||  tiff_ifd[i].t_width > 65535\n       || tiff_ifd[i].t_height < 1 || tiff_ifd[i].t_height > 65535)\n          continue; /* wrong image dimensions */\n    if (max_samp < tiff_ifd[i].samples)\n      max_samp = tiff_ifd[i].samples;\n    if (max_samp > 3)\n      max_samp = 3;\n    os = raw_width * raw_height;\n    ns = tiff_ifd[i].t_width * tiff_ifd[i].t_height;\n    if (tiff_bps)\n    {\n      os *= tiff_bps;\n      ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 && (unsigned)tiff_ifd[i].bps < 33 &&\n        (unsigned)tiff_ifd[i].samples < 13 && ns && ((ns > os && (ties = 1)) || (ns == os && shot_select == ties++)))\n    {\n      raw_width = tiff_ifd[i].t_width;\n      raw_height = tiff_ifd[i].t_height;\n      tiff_bps = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size = tiff_ifd[i].bytes;\n#endif\n      tiff_flip = tiff_ifd[i].t_flip;\n      tiff_samples = tiff_ifd[i].samples;\n      tile_width = tiff_ifd[i].t_tile_width;\n      tile_length = tiff_ifd[i].t_tile_length;\n      shutter = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties)\n    is_raw = ties;\n  if (!tile_width)\n    tile_width = INT_MAX;\n  if (!tile_length)\n    tile_length = INT_MAX;\n  for (i = tiff_nifds; i--;)\n    if (tiff_ifd[i].t_flip)\n      tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress)\n    {\n    case 32767:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height))\n#else\n      if (tiff_ifd[raw].bytes == raw_width * raw_height)\n#endif\n      {\n        tiff_bps = 12;\n        load_raw = &CLASS sony_arw2_load_raw;\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncasecmp(make, \"Sony\", 4) && INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height) * 2ULL)\n#else\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n#endif\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (INT64(tiff_ifd[raw].bytes) * 8ULL != INT64(raw_width) * INT64(raw_height) * INT64(tiff_bps))\n#else\n      if (tiff_ifd[raw].bytes * 8 != raw_width * raw_height * tiff_bps)\n#endif\n      {\n        raw_height += 8;\n        load_raw = &CLASS sony_arw_load_raw;\n        break;\n      }\n      load_flags = 79;\n    case 32769:\n      load_flags++;\n    case 32770:\n    case 32773:\n      goto slr;\n    case 0:\n    case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n      // Sony 14-bit uncompressed\n      if (!strncasecmp(make, \"Sony\", 4) && INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height) * 2ULL)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].samples == 4 &&\n          INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height) * 8ULL) // Sony ARQ\n      {\n        tiff_bps = 14;\n        tiff_samples = 4;\n        load_raw = &CLASS sony_arq_load_raw;\n        filters = 0;\n        strcpy(cdesc, \"RGBG\");\n        break;\n      }\n      if (!strncasecmp(make, \"Nikon\", 5) && !strncmp(software, \"Nikon Scan\", 10))\n      {\n        load_raw = &CLASS nikon_coolscan_load_raw;\n        raw_color = 1;\n        filters = 0;\n        break;\n      }\n      if (!strncmp(make, \"OLYMPUS\", 7) && INT64(tiff_ifd[raw].bytes) * 2ULL == INT64(raw_width) * INT64(raw_height) * 3ULL)\n#else \n      if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 2 == raw_width * raw_height * 3)\n#endif\n        load_flags = 24;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (INT64(tiff_ifd[raw].bytes) * 5ULL == INT64(raw_width) * INT64(raw_height) * 8ULL)\n#else\n      if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)\n#endif\n      {\n        load_flags = 81;\n        tiff_bps = 12;\n      }\n    slr:\n      switch (tiff_bps)\n      {\n      case 8:\n        load_raw = &CLASS eight_bit_load_raw;\n        break;\n      case 12:\n        if (tiff_ifd[raw].phint == 2)\n          load_flags = 6;\n        load_raw = &CLASS packed_load_raw;\n        break;\n      case 14:\n        load_flags = 0;\n      case 16:\n        load_raw = &CLASS unpacked_load_raw;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"OLYMPUS\", 7) && INT64(tiff_ifd[raw].bytes) * 7ULL > INT64(raw_width) * INT64(raw_height))\n#else\n        if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 7 > raw_width * raw_height)\n#endif\n          load_raw = &CLASS olympus_load_raw;\n      }\n      break;\n    case 6:\n    case 7:\n    case 99:\n      load_raw = &CLASS lossless_jpeg_load_raw;\n      break;\n    case 262:\n      load_raw = &CLASS kodak_262_load_raw;\n      break;\n    case 34713:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((INT64(raw_width) + 9ULL) / 10ULL * 16ULL * INT64(raw_height) == INT64(tiff_ifd[raw].bytes))\n#else\n      if ((raw_width + 9) / 10 * 16 * raw_height == tiff_ifd[raw].bytes)\n#endif\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 1;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (INT64(raw_width) * INT64(raw_height) * 3ULL == INT64(tiff_ifd[raw].bytes) * 2ULL)\n#else\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n#endif\n      {\n        load_raw = &CLASS packed_load_raw;\n        if (model[0] == 'N')\n          load_flags = 80;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (INT64(raw_width) * INT64(raw_height) * 3ULL == INT64(tiff_ifd[raw].bytes))\n#else\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes)\n#endif\n      {\n        load_raw = &CLASS nikon_yuv_load_raw;\n        gamma_curve(1 / 2.4, 12.92, 1, 4095);\n        memset(cblack, 0, sizeof cblack);\n        filters = 0;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (INT64(raw_width) * INT64(raw_height) * 2ULL == INT64(tiff_ifd[raw].bytes))\n#else\n      else if (raw_width * raw_height * 2 == tiff_ifd[raw].bytes)\n#endif\n      {\n        load_raw = &CLASS unpacked_load_raw;\n        load_flags = 4;\n        order = 0x4d4d;\n      }\n      else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (INT64(raw_width) * INT64(raw_height) * 3ULL == INT64(tiff_ifd[raw].bytes) * 2ULL)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 80;\n      }\n      else if (tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n               tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n      {\n        int fit = 1;\n        for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1; i++) // all but last\n          if (INT64(tiff_ifd[raw].strip_byte_counts[i]) * 2ULL != INT64(tiff_ifd[raw].rows_per_strip) * INT64(raw_width) * 3ULL)\n          {\n            fit = 0;\n            break;\n          }\n        if (fit)\n          load_raw = &CLASS nikon_load_striped_packed_raw;\n        else\n          load_raw = &CLASS nikon_load_raw; // fallback\n      }\n      else\n#endif\n        load_raw = &CLASS nikon_load_raw;\n      break;\n    case 65535:\n      load_raw = &CLASS pentax_load_raw;\n      break;\n    case 65000:\n      switch (tiff_ifd[raw].phint)\n      {\n      case 2:\n        load_raw = &CLASS kodak_rgb_load_raw;\n        filters = 0;\n        break;\n      case 6:\n        load_raw = &CLASS kodak_ycbcr_load_raw;\n        filters = 0;\n        break;\n      case 32803:\n        load_raw = &CLASS kodak_65000_load_raw;\n      }\n    case 32867:\n    case 34892:\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      break;\n#endif\n    default:\n      is_raw = 0;\n    }\n  if (!dng_version)\n    if (((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 && (tiff_compress & -16) != 32768) ||\n         (tiff_bps == 8 && strncmp(make, \"Phase\", 5) && strncmp(make, \"Leaf\", 4) && !strcasestr(make, \"Kodak\") &&\n          !strstr(model2, \"DEBUG RAW\"))) &&\n        strncmp(software, \"Nikon Scan\", 10))\n      is_raw = 0;\n  for (i = 0; i < tiff_nifds; i++)\n    if (i != raw &&\n        (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 && tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps) + 1) >\n            thumb_width * thumb_height / (SQR(thumb_misc) + 1) &&\n        tiff_ifd[i].comp != 34892)\n    {\n      thumb_width = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0)\n  {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp)\n    {\n    case 0:\n      write_thumb = &CLASS layer_thumb;\n      break;\n    case 1:\n      if (tiff_ifd[thm].bps <= 8)\n        write_thumb = &CLASS ppm_thumb;\n      else if (!strncmp(make, \"Imacon\", 6))\n        write_thumb = &CLASS ppm16_thumb;\n      else\n        thumb_load_raw = &CLASS kodak_thumb_load_raw;\n      break;\n    case 65000:\n      thumb_load_raw = tiff_ifd[thm].phint == 6 ? &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save = ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if (ifp->wfname())\n  {\n    std::wstring rawfile(ifp->wfname());\n    rawfile.replace(rawfile.length() - 3, 3, L\"JPG\");\n    if (!ifp->subfile_open(rawfile.c_str()))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n  if (!ifp->fname())\n  {\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n\n  ext = strrchr(ifname, '.');\n  file = strrchr(ifname, '/');\n  if (!file)\n    file = strrchr(ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file)\n    file = ifname - 1;\n#else\n  if (!file)\n    file = (char *)ifname - 1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext - file != 8)\n    return;\n  jname = (char *)malloc(strlen(ifname) + 1);\n  merror(jname, \"parse_external_jpeg()\");\n  strcpy(jname, ifname);\n  jfile = file - ifname + jname;\n  jext = ext - ifname + jname;\n  if (strcasecmp(ext, \".jpg\"))\n  {\n    strcpy(jext, isupper(ext[1]) ? \".JPG\" : \".jpg\");\n    if (isdigit(*file))\n    {\n      memcpy(jfile, file + 4, 4);\n      memcpy(jfile + 4, file, 4);\n    }\n  }\n  else\n    while (isdigit(*--jext))\n    {\n      if (*jext != '9')\n      {\n        (*jext)++;\n        break;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp(jname, ifname))\n  {\n    if ((ifp = fopen(jname, \"rb\")))\n    {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose(ifp);\n    }\n  }\n#else\n  if (strcmp(jname, ifname))\n  {\n    if (!ifp->subfile_open(jname))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n  }\n#endif\n  if (!timestamp)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n#endif\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n  }\n  free(jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = {0x410, 0x45f3};\n  int i, bpp, row, col, vbits = 0;\n  unsigned long bitbuf = 0;\n\n  if ((get2(), get4()) != 0x80008 || !get4())\n    return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12)\n    return;\n  for (i = row = 0; row < 8; row++)\n    for (col = 0; col < 8; col++)\n    {\n      if (vbits < bpp)\n      {\n        bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n        vbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff(int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi = -1;\n  ushort key[] = {0x410, 0x45f3};\n\n  fseek(ifp, offset + length - 4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek(ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127)\n    return;\n  while (nrecs--)\n  {\n    type = get2();\n    len = get4();\n    save = ftell(ifp) + 4;\n    fseek(ifp, offset + get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n    {\n      parse_ciff(ftell(ifp), len, depth + 1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004)\n      parse_ciff(ftell(ifp), len, depth + 1);\n#endif\n    if (type == 0x0810)\n      fread(artist, 64, 1, ifp);\n    if (type == 0x080a)\n    {\n      fread(make, 64, 1, ifp);\n      fseek(ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread(model, 64, 1, ifp);\n    }\n    if (type == 0x1810)\n    {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835) /* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007)\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818)\n    {\n      shutter = libraw_powf64l(2.0f, -int_to_float((get4(), get4())));\n      aperture = libraw_powf64l(2.0f, int_to_float(get4()) / 2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a)\n    {\n      //      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = libraw_powf64l(2.0f, ((get2(), get2()) + get2()) / 32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture = _CanonConvertAperture((get2(), get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture = libraw_powf64l(2.0, (get2(), (short)get2()) / 64.0);\n#endif\n      shutter = libraw_powf64l(2.0, -((short)get2()) / 32.0);\n      wbi = (get2(), get2());\n      if (wbi > 17)\n        wbi = 0;\n      fseek(ifp, 32, SEEK_CUR);\n      if (shutter > 1e6)\n        shutter = get2() / 10.0;\n    }\n    if (type == 0x102c)\n    {\n      if (get2() > 512)\n      { /* Pro90, G1 */\n        fseek(ifp, 118, SEEK_CUR);\n        FORC4 cam_mul[c ^ 2] = get2();\n      }\n      else\n      { /* G2, S30, S40 */\n        fseek(ifp, 98, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n    {\n      INT64 o = ftell(ifp);\n      fseek(ifp, (0x1 << 1), SEEK_CUR);\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n      Canon_WBpresets(0, 0);\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x102d)\n    {\n      INT64 o = ftell(ifp);\n      Canon_CameraSettings();\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x580b)\n    {\n      if (strcmp(model, \"Canon EOS D30\"))\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n      else\n        sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len >> 16, len & 0xffff);\n    }\n#endif\n    if (type == 0x0032)\n    {\n      if (len == 768)\n      { /* EOS D30 */\n        fseek(ifp, 72, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n        if (!wbi)\n          cam_mul[0] = -1; /* use my auto white balance */\n      }\n      else if (!cam_mul[0])\n      {\n        if (get2() == key[0]) /* Pro1, G6, S60, S70 */\n          c = (strstr(model, \"Pro1\") ? \"012346000000000000\" : \"01345:000000006008\")[LIM(0, wbi, 17)] - '0' + 2;\n        else\n        { /* G3, G5, S45, S50 */\n          c = \"023457000000006000\"[LIM(0, wbi, 17)] - '0';\n          key[0] = key[1] = 0;\n        }\n        fseek(ifp, 78 + c * 8, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n        if (!wbi)\n          cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9)\n    { /* D60, 10D, 300D, and clones */\n      if (len > 66)\n        wbi = \"0134567028\"[LIM(0, wbi, 9)] - '0';\n      fseek(ifp, 2 + wbi * 8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))\n      ciff_block_1030(); /* all that don't have 0x10a9 */\n    if (type == 0x1031)\n    {\n      raw_width = (get2(), get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c)\n    {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2)\n      {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n        if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n          imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2)\n        focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813)\n      flash_used = int_to_float(len);\n    if (type == 0x5814)\n      canon_ev = int_to_float(len);\n    if (type == 0x5817)\n      shot_order = len;\n    if (type == 0x5834)\n    {\n      unique_id = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n      unique_id = setCanonBodyFeatures(unique_id);\n#endif\n    }\n    if (type == 0x580e)\n      timestamp = len;\n    if (type == 0x180e)\n      timestamp = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime(gmtime(&timestamp));\n#endif\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek(ifp, 0, SEEK_SET);\n  memset(&t, 0, sizeof t);\n  do\n  {\n    fgets(line, 128, ifp);\n    if ((val = strchr(line, '=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line, \"DAT\"))\n      sscanf(val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line, \"TIM\"))\n      sscanf(val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line, \"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line, \"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line, \"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line, \"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line, \"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line, \"EOHD\", 4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy(make, \"Rollei\");\n  strcpy(model, \"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek(ifp, get4(), SEEK_SET);\n  while (entries--)\n  {\n    off = get4();\n    get4();\n    fread(str, 8, 1, ifp);\n    if (!strcmp(str, \"META\"))\n      meta_offset = off;\n    if (!strcmp(str, \"THUMB\"))\n      thumb_offset = off;\n    if (!strcmp(str, \"RAW0\"))\n      data_offset = off;\n  }\n  fseek(ifp, meta_offset + 20, SEEK_SET);\n  fread(make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make, ' ')))\n  {\n    strcpy(model, cp + 1);\n    *cp = 0;\n  }\n  raw_width = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(), get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one(int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset(&ph1, 0, sizeof ph1);\n  fseek(ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177)\n    return; /* \"Raw\" */\n  fseek(ifp, get4() + base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--)\n  {\n    tag = get4();\n    type = get4();\n    len = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek(ifp, base + data, SEEK_SET);\n    switch (tag)\n    {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      }\n      else\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0211:\n      imgdata.other.SensorTemperature2 = int_to_float(data);\n      break;\n    case 0x0401:\n      if (type == 4)\n        imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));\n      else\n        imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x0403:\n      if (type == 4)\n        imgdata.lens.makernotes.CurFocal = int_to_float(data);\n      else\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n      {\n        imgdata.lens.makernotes.MinFocal = 0.0f;\n      }\n      break;\n    case 0x0417:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n    case 0x100:\n      flip = \"0653\"[data & 3] - '0';\n      break;\n    case 0x106:\n      for (i = 0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.P1_color[0].romm_cam[i] =\n#endif\n            ((float *)romm_cam)[i] = getreal(11);\n      romm_coeff(romm_cam);\n      break;\n    case 0x107:\n      FORC3 cam_mul[c] = getreal(11);\n      break;\n    case 0x108:\n      raw_width = data;\n      break;\n    case 0x109:\n      raw_height = data;\n      break;\n    case 0x10a:\n      left_margin = data;\n      break;\n    case 0x10b:\n      top_margin = data;\n      break;\n    case 0x10c:\n      width = data;\n      break;\n    case 0x10d:\n      height = data;\n      break;\n    case 0x10e:\n      ph1.format = data;\n      break;\n    case 0x10f:\n      data_offset = data + base;\n      break;\n    case 0x110:\n      meta_offset = data + base;\n      meta_length = len;\n      break;\n    case 0x112:\n      ph1.key_off = save - 4;\n      break;\n    case 0x210:\n      ph1.tag_210 = int_to_float(data);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.other.SensorTemperature = ph1.tag_210;\n#endif\n      break;\n    case 0x21a:\n      ph1.tag_21a = data;\n      break;\n    case 0x21c:\n      strip_offset = data + base;\n      break;\n    case 0x21d:\n      ph1.t_black = data;\n      break;\n    case 0x222:\n      ph1.split_col = data;\n      break;\n    case 0x223:\n      ph1.black_col = data + base;\n      break;\n    case 0x224:\n      ph1.split_row = data;\n      break;\n    case 0x225:\n      ph1.black_row = data + base;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x226:\n      for (i = 0; i < 9; i++)\n        imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n      break;\n#endif\n    case 0x301:\n      model[63] = 0;\n      fread(model, 1, 63, ifp);\n      if ((cp = strstr(model, \" camera\")))\n        *cp = 0;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0])\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek(ifp, 6, SEEK_CUR);\n    fseek(ifp, meta_offset + get4(), SEEK_SET);\n    entries = get4();\n    get4();\n    while (entries--)\n    {\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x0407)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        }\n        else\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ? &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy(make, \"Phase One\");\n  if (model[0])\n    return;\n  switch (raw_height)\n  {\n  case 2060:\n    strcpy(model, \"LightPhase\");\n    break;\n  case 2682:\n    strcpy(model, \"H 10\");\n    break;\n  case 4128:\n    strcpy(model, \"H 20\");\n    break;\n  case 5488:\n    strcpy(model, \"H 25\");\n    break;\n  }\n}\n\nvoid CLASS parse_fuji(int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek(ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  imgdata.process_warnings |= LIBRAW_WARN_PARSEFUJI_PROCESSED;\n#endif\n  while (entries--)\n  {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100)\n    {\n      raw_height = get2();\n      raw_width = get2();\n    }\n    else if (tag == 0x121)\n    {\n      height = get2();\n      if ((width = get2()) == 4284)\n        width += 3;\n    }\n    else if (tag == 0x130)\n    {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    }\n    else if (tag == 0x131)\n    {\n      filters = 9;\n      FORC(36)\n      {\n        int q = fgetc(ifp);\n        xtrans_abs[0][35 - c] = MAX(0, MIN(q, 2)); /* & 3;*/\n      }\n    }\n    else if (tag == 0x2ff0)\n    {\n      FORC4 cam_mul[c ^ 1] = get2();\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n\n    else if (tag == 0x110)\n    {\n      imgdata.sizes.raw_crop.ctop = get2();\n      imgdata.sizes.raw_crop.cleft = get2();\n    }\n\n    else if (tag == 0x111)\n    {\n      imgdata.sizes.raw_crop.cheight = get2();\n      imgdata.sizes.raw_crop.cwidth = get2();\n    }\n\n    else if ((tag == 0x122) && !strcmp(model, \"DBP for GX680\"))\n    {\n      int k = get2();\n      int l = get2(); /* margins? */\n      int m = get2(); /* margins? */\n      int n = get2();\n      //      printf (\"==>>0x122: height= %d l= %d m= %d width= %d\\n\", k, l, m, n);\n    }\n\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b = fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    }\n\n    else if (tag == 0x2f00)\n    {\n      int nWBs = get4();\n      nWBs = MIN(nWBs, 6);\n      for (int wb_ind = 0; wb_ind < nWBs; wb_ind++)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + wb_ind][c ^ 1] = get2();\n        fseek(ifp, 8, SEEK_CUR);\n      }\n    }\n\n    else if (tag == 0x2000)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ 1] = get2();\n    }\n    else if (tag == 0x2100)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][c ^ 1] = get2();\n    }\n    else if (tag == 0x2200)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ 1] = get2();\n    }\n    else if (tag == 0x2300)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    }\n    else if (tag == 0x2301)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    }\n    else if (tag == 0x2302)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    }\n    else if (tag == 0x2310)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    }\n    else if (tag == 0x2400)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n    }\n    else if (tag == 0x2410)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ 1] = get2();\n#endif\n      // IB end\n    }\n    else if (tag == 0xc000)\n    /* 0xc000 tag versions, second ushort; valid if the first ushort is 0\n    X100F\t0x0259\n    X100T\t0x0153\n    X-E2\t0x014f\t0x024f depends on firmware\n    X-A1\t0x014e\n    XQ2\t\t0x0150\n    XQ1\t\t0x0150\n    X100S\t0x0149\t0x0249 depends on firmware\n    X30\t\t0x0152\n    X20\t\t0x0146\n    X-T10\t0x0154\n    X-T2\t0x0258\n    X-M1\t0x014d\n    X-E2s\t0x0355\n    X-A2\t0x014e\n    X-T20\t0x025b\n    GFX 50S\t0x025a\n    X-T1\t0x0151\t0x0251 0x0351 depends on firmware\n    X70\t\t0x0155\n    X-Pro2\t0x0255\n    */\n    {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000)\n        tag = get4();\n      if (tag > 10000)\n        tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strcmp(model, \"X-A3\")  ||\n          !strcmp(model, \"X-A10\") ||\n          !strcmp(model, \"X-A5\")  ||\n          !strcmp(model, \"X-A20\"))\n      {\n        int wb[4];\n        int nWB, tWB, pWB;\n        int iCCT = 0;\n        int cnt;\n        fseek(ifp, save + 0x200, SEEK_SET);\n        for (int wb_ind = 0; wb_ind < 42; wb_ind++)\n        {\n          nWB = get4();\n          tWB = get4();\n          wb[0] = get4() << 1;\n          wb[1] = get4();\n          wb[3] = get4();\n          wb[2] = get4() << 1;\n          if (tWB && (iCCT < 255))\n          {\n            imgdata.color.WBCT_Coeffs[iCCT][0] = tWB;\n            for (cnt = 0; cnt < 4; cnt++)\n              imgdata.color.WBCT_Coeffs[iCCT][cnt + 1] = wb[cnt];\n            iCCT++;\n          }\n          if (nWB != 70)\n          {\n            for (pWB = 1; pWB < nFuji_wb_list2; pWB += 2)\n            {\n              if (Fuji_wb_list2[pWB] == nWB)\n              {\n                for (cnt = 0; cnt < 4; cnt++)\n                  imgdata.color.WB_Coeffs[Fuji_wb_list2[pWB - 1]][cnt] = wb[cnt];\n                break;\n              }\n            }\n          }\n        }\n      }\n      else\n      {\n        libraw_internal_data.unpacker_data.posRAFData = save;\n        libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);\n      }\n#endif\n      order = c;\n    }\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width >>= fuji_layout;\n}\n\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n        && (save + hlen) >= 0 && (save + hlen) <= ifp->size()\n#endif\n            ) /* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  struct tm t;\n\n  order = 0x4949;\n  fread(tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag, \"RIFF\", 4) || !memcmp(tag, \"LIST\", 4))\n  {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp) + 7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  }\n  else if (!memcmp(tag, \"nctg\", 4))\n  {\n    while (ftell(ifp) + 7 < end)\n    {\n      i = get2();\n      size = get2();\n      if ((i + 1) >> 1 == 10 && size == 20)\n        get_timestamp(0);\n      else\n        fseek(ifp, size, SEEK_CUR);\n    }\n  }\n  else if (!memcmp(tag, \"IDIT\", 4) && size < 64)\n  {\n    fread(date, 64, 1, ifp);\n    date[size] = 0;\n    memset(&t, 0, sizeof t);\n    if (sscanf(date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6)\n    {\n      for (i = 0; i < 12 && strcasecmp(mon[i], month); i++)\n        ;\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n        timestamp = mktime(&t);\n    }\n  }\n  else\n    fseek(ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt(int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp) + 7 < end)\n  {\n    save = ftell(ifp);\n    if ((size = get4()) < 8)\n      return;\n    fread(tag, 4, 1, ifp);\n    if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))\n      parse_qt(save + size);\n    if (!memcmp(tag, \"CNDA\", 4))\n      parse_jpeg(ftell(ifp));\n    fseek(ifp, save + size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal(int offset, int fsize)\n{\n  int ver;\n\n  fseek(ifp, offset + 2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek(ifp, 5, SEEK_CUR);\n  if (get4() != fsize)\n    return;\n  if (ver > 6)\n    data_offset = get4();\n  raw_height = height = get2();\n  raw_width = width = get2();\n  strcpy(make, \"SMaL\");\n  sprintf(model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6)\n    load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9)\n    load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek(ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4()))\n    timestamp = i;\n  fseek(ifp, off_head + 4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(), get2())\n  {\n  case 8:\n    load_raw = &CLASS eight_bit_load_raw;\n    break;\n  case 16:\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  fseek(ifp, off_setup + 792, SEEK_SET);\n  strcpy(make, \"CINE\");\n  sprintf(model, \"%d\", get4());\n  fseek(ifp, 12, SEEK_CUR);\n  switch ((i = get4()) & 0xffffff)\n  {\n  case 3:\n    filters = 0x94949494;\n    break;\n  case 4:\n    filters = 0x49494949;\n    break;\n  default:\n    is_raw = 0;\n  }\n  fseek(ifp, 72, SEEK_CUR);\n  switch ((get4() + 3600) % 360)\n  {\n  case 270:\n    flip = 4;\n    break;\n  case 180:\n    flip = 1;\n    break;\n  case 90:\n    flip = 7;\n    break;\n  case 0:\n    flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek(ifp, 668, SEEK_CUR);\n  shutter = get4() / 1000000000.0;\n  fseek(ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek(ifp, shot_select * 8, SEEK_CUR);\n  data_offset = (INT64)get4() + 8;\n  data_offset += (INT64)get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek(ifp, 52, SEEK_SET);\n  width = get4();\n  height = get4();\n  fseek(ifp, 0, SEEK_END);\n  fseek(ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek(ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF)\n    {\n      if (get4() == 0x52454456)\n        if (is_raw++ == shot_select)\n          data_offset = ftello(ifp) - 8;\n      fseek(ifp, len - 8, SEEK_CUR);\n    }\n  }\n  else\n  {\n    rdvo = get4();\n    fseek(ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko(ifp, rdvo + 8 + shot_select * 4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff(const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n                       ,\n                       int internal_only\n#endif\n)\n{\n  // clang-format off\n  static const struct\n  {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0, /* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n\n    { \"Apple QuickTake\", 0, 0, /* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } }, /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0, /* updated */\n      { 9900,-2771,-1324,-7072,14229,3140,-2790,3344,8861 } },\n    { \"Canon EOS D60\", 0, 0xfa0, /* updated */\n      { 6211,-1358,-896,-8557,15766,3012,-3001,3507,8567 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446,-366,-864,-4436,12204,2513,-952,2496,6348 } },\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D Mark II\", 0, 0x38de, /* updated */\n      { 6875,-970,-932,-4691,12459,2501,-874,1953,5809 } },\n    { \"Canon EOS 6D\", 0, 0x3c82, /* skipped update */\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 77D\", 0, 0,\n      { 7377,-742,-998,-4235,11981,2549,-673,1918,5538 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 800D\", 0, 0,\n      { 6970,-512,-968,-4425,12161,2553,-739,1982,5601 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0, /* updated */\n      { 8250,-2044,-1127,-8092,15606,2664,-2893,3453,8348 } },\n    { \"Canon EOS 200D\", 0, 0,\n      { 7377,-742,-998,-4235,11981,2549,-673,1918,5538 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60Da\", 0, 0x2ff7, /* added */\n      { 17492,-7240,-2023,-1791,10323,1701,-186,1329,5406 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0, /* updated */\n      { 8250,-2044,-1127,-8092,15606,2664,-2893,3453,8348 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939,-1016,-866,-4428,12473,2177,-1175,2178,6162 } },\n    { \"Canon EOS M6\", 0, 0,\n      { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },\n    { \"Canon EOS M5\", 0, 0,\n      { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M2\", 0, 0, /* added */\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M100\", 0, 0,\n      { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20, /* updated */\n      { 3925,4060,-1739,-8973,16552,2545,-3287,3945,8243 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e, /* updated */\n      { 7596,-978,-967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0, /* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    {\"Canon PowerShot 600\", 0, 0, /* added */\n      { -3822,10019,1311,4085,-157,3386,-5341,10829,4812,-1969,10969,1126 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } }, /* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0, /* updated */\n      { 8020,-2687,-682,-3704,11879,2052,-965,1921,5556 } },\n    { \"Canon PowerShot G1 X Mark III\", 0, 0,\n      { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0, /* updated */\n      { -5686,10300,2223,4725,-1157,4383,-6128,10783,6163,-2688,12093,604 } },\n    { \"Canon PowerShot G2\", 0, 0, /* updated */\n      { 9194,-2787,-1059,-8098,15657,2608,-2610,3064,7867 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0, /* updated */\n      { 9326,-2882,-1084,-7940,15447,2677,-2620,3090,7740 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0, /* updated */\n      { 9869,-2972,-942,-7314,15098,2369,-1898,2536,7282 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X Mark II\", 0, 0,\n      { 10056,-4131,-944,-2576,11143,1625,-238,1294,5179 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0, /* updated */\n      { -5106,10695,1576,3820,53,4566,-6497,10736,6701,-3336,11887,1394 } },\n    { \"Canon PowerShot Pro90\", 0, 0, /* updated */\n      { -5912,10768,2288,4612,-989,4333,-6153,10897,5944,-2907,12288,624 } },\n    { \"Canon PowerShot S30\", 0, 0, /* updated */\n      { 10744,-3813,-1142,-7962,15966,2075,-2492,2805,7744 } },\n    { \"Canon PowerShot S40\", 0, 0, /* updated */\n      { 8606,-2573,-949,-8237,15489,2974,-2649,3076,9100 } },\n    { \"Canon PowerShot S45\", 0, 0, /* updated */\n      { 8251,-2410,-964,-8047,15430,2823,-2380,2824,8119 } },\n    { \"Canon PowerShot S50\", 0, 0, /* updated */\n      { 8979,-2658,-871,-7721,15500,2357,-1773,2366,6634 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0, /* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0, /* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0, /* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0, /* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0, /* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0, /* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0, /* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0, /* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot D10\", 127, 0, /* DJC */\n      { 14052,-5229,-1156,-1325,9420,2252,-498,1957,4116 } },\n    { \"Canon PowerShot S3 IS\", 0, 0, /* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0, /* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0, /* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0, /* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n\n    { \"Casio EX-F1\", 0, 0, /* added */\n      { 9084,-2016,-848,-6711,14351,2570,-1059,1725,6135 } },\n    { \"Casio EX-FH100\", 0, 0, /* added */\n      { 12771,-4179,-1558,-2149,10938,1375,-453,1751,4494 } },\n    { \"Casio EX-S20\", 0, 0, /* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0, /* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff, /* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n\n    { \"Fujifilm E550\", 0, 0, /* updated */\n      { 11044,-3888,-1120,-7248,15167,2208,-1531,2276,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F810\", 0, 0, /* added */\n      { 11044,-3888,-1120,-7248,15167,2208,-1531,2276,8069 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0, /* updated */\n      { 12741,-4916,-1420,-8510,16791,1715,-1767,2302,7771 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100F\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A10\", 0, 0,\n      { 11540,-4999,-991,-2949,10963,2278,-382,1049,5605} },\n\n    { \"Fujifilm X-A20\", 0, 0, /* temp */\n      { 11540,-4999,-991,-2949,10963,2278,-382,1049,5605} },\n\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-A3\", 0, 0,\n      { 12407,-5222,-1086,-2971,11116,2120,-294,1029,5284 } },\n\n    { \"Fujifilm X-A5\", 0, 0, /* temp */\n      { 12407,-5222,-1086,-2971,11116,2120,-294,1029,5284 } },\n\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-E3\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T20\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-T10\", 0, 0, /* updated */\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-H1\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm GFX 50S\", 0, 0,\n      { 11756,-4754,-874,-3056,11045,2305,-381,1457,6006 } },\n\n    { \"GITUP GIT2P\", 4160, 0,\n      { 8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"GITUP GIT2\", 3200, 0,\n      { 8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n\n    { \"Hasselblad HV\", 0, 0, /* added */\n      { 6344,-1612,-461,-4862,12476,2680,-864,1785,6898 } },\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Lusso\", 0, 0, /* added */\n      { 4912,-540,-201,-6129,13513,2906,-1563,2151,7182 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad 500 mech.\", 0, 0, /* added */\n      { 8519,-3260,-280,-5081,13459,1738,-1449,2960,7809 } },\n    { \"Hasselblad CFV\", 0, 0,\n      { 8519,-3260,-280,-5081,13459,1738,-1449,2960,7809 } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad 39-Coated\", 0, 0, /* added */\n      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },\n    { \"Hasselblad H-39MP\",0, 0,\n      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },\n    { \"Hasselblad H2D-39\", 0, 0, /* added */\n      { 3894,-110,287,-4672,12610,2295,-2092,4100,6196 } },\n    { \"Hasselblad H3D-50\", 0, 0,\n      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },\n    { \"Hasselblad H3D\", 0, 0, /* added */\n      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0,\n      { 9662,-684,-279,-4903,12293,2950,-344,1669,6024 } },\n    { \"Hasselblad H5D-50c\",0, 0,\n      { 4932,-835,141,-4878,11868,3437,-1138,1961,7067 } },\n    { \"Hasselblad H5D-50\",0, 0,\n      { 5656,-659,-346,-3923,12306,1791,-1602,3509,5442 } },\n    { \"Hasselblad H6D-100c\",0, 0,\n      { 5110,-1357,-308,-5573,12835,3077,-1279,2025,7010 } },\n    { \"Hasselblad X1D\",0, 0,\n      { 4932,-835,141,-4878,11868,3437,-1138,1961,7067 } },\n\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n\n    { \"Imacon Ixpress\", 0, 0, /* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Photo Control Camerz ZDS 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n\n    { \"Leaf C-Most\", 0, 0, /* updated */\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus-II 8\", 0, 0, /* added */\n      { 7361,1257,-163,-6929,14061,3176,-1839,3454,5603 } },\n    { \"Leaf AFi-II 7\", 0, 0, /* added */\n      { 7691,-108,-339,-6185,13627,2833,-2046,3899,5952 } },\n    { \"Leaf Aptus-II 5\", 0, 0, /* added */\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf AFi 65S\", 0, 0, /* added */\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf AFi 75S\", 0, 0, /* added */\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984,0,0,0,10000,0,0,0,7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294,686,-712,-5435, 13417,2211,-1006,2435,5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n\n    { \"Leica M10\", 0, 0, /* added */\n      { 9090,-3342,-740,-4006,13456,493,-569,2266,6871 } },\n    { \"Leica M9\", 0, 0, /* added */\n      { 6687,-1751,-291,-3556,11373,2492,-548,2204,7146 } },\n    { \"Leica M8\", 0, 0, /* added */\n      { 7675,-2196,-305,-5860,14119,1856,-2425,4006,6578 } },\n    { \"Leica M (Typ 240)\", 0, 0, /* added */\n      { 7199,-2140,-712,-4005,13327,649,-810,2521,6673 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n      { 7199,-2140,-712,-4005,13327,649,-810,2521,6673 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Leica S2\", 0, 0, /* added */\n      { 5627,-721,-447,-4423,12456,2192,-1048,2948,7379 } },\n    {\"Leica S-E (Typ 006)\", 0, 0, /* added */\n      { 5749,-1072,-382,-4274,12432,2048,-1166,3104,7105 } },\n    {\"Leica S (Typ 006)\", 0, 0, /* added */\n      { 5749,-1072,-382,-4274,12432,2048,-1166,3104,7105 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n      { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica Q (Typ 116)\", 0, 0, /* updated */\n      { 10068,-4043,-1068,-5319,14268,1044,-765,1701,6522 } },\n    { \"Leica T (Typ 701)\", 0, 0, /* added */\n      { 6295 ,-1679 ,-475 ,-5586 ,13046 ,2837 ,-1410 ,1889 ,7075 } },\n    { \"Leica X2\", 0, 0, /* added */\n      { 8336,-2853,-699,-4425,11989,2760,-954,1625,6396 } },\n    { \"Leica X1\", 0, 0, /* added */\n      { 9055,-2611,-666,-4906,12652,2519,-555,1384,7417 } },\n    { \"Leica X\", 0, 0, /* X(113), X-U(113), XV, X Vario(107) */ /* updated */\n      { 9062,-3198,-828,-4065,11772,2603,-761,1468,6458 } },\n\n    { \"Mamiya M31\", 0, 0, /* added */\n      { 4516 ,-244 ,-36 ,-7020 ,14976 ,2174 ,-3206 ,4670 ,7087 } },\n    { \"Mamiya M22\", 0, 0, /* added */\n      { 2905 ,732 ,-237 ,-8135 ,16626 ,1476 ,-3038 ,4253 ,7517 } },\n    { \"Mamiya M18\", 0, 0, /* added */\n      { 6516 ,-2050 ,-507 ,-8217 ,16703 ,1479 ,-3492 ,4741 ,8489 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n\n    { \"Micron 2010\", 110, 0, /* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n\n    { \"Minolta DiMAGE 5\", 0, 0xf7d, /* updated */\n      { 9117,-3063,-973,-7949,15763,2306,-2752,3136,8093 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d, /* updated */\n      { 11555,-4064,-1256,-7903,15633,2409,-2811,3320,7358 } },\n    { \"Minolta DiMAGE 7i\", 0, 0xf7d, /* added */\n      { 11050,-3791,-1199,-7875,15585,2434,-2797,3359,7560 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d, /* updated */\n      { 9258,-2879,-1008,-8076,15847,2351,-2806,3280,7821 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b, /* updated */\n      { 9274,-2548,-1167,-8220,16324,1943,-2273,2721,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0, /* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta Maxxum 5D\", 0, 0xffb, /* added */\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta ALPHA-5 DIGITAL\", 0, 0xffb, /* added */\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta ALPHA SWEET DIGITAL\", 0, 0xffb, /* added */\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Minolta Maxxum 7D\", 0, 0xffb, /* added */\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Minolta ALPHA-7 DIGITAL\", 0, 0xffb, /* added */\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n\n    { \"Motorola PIXL\", 0, 0, /* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0, /* updated */\n      { 7659,-2238,-935,-8942,16969,2004,-2701,3051,8690 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5733,-911,-629,-7967,15987,2055,-3050,4013,7048 } },\n    { \"Nikon D2X\", 0, 0, /* updated */\n      { 10231,-2768,-1254,-8302,15900,2551,-797,681,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D5600\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0, /* updated */\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7500\", 0, 0,\n      { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D850\", 0, 0,\n      { 10405,-3755,-1270,-5461,13787,1793,-1040,2015,6785 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973,-5685,-888,-1965,10326,1901,-115,1123,7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd, /* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd, /* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd, /* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0, /* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0, /* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0, /* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0, /* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0, /* updated */\n      { -6678,12805,2248,5725,-499,3375,-5903,10713,6034,-270,9976,134 } },\n    { \"Nikon E5400\", 0, 0, /* updated */\n      { 9349,-2988,-1001,-7918,15766,2266,-2097,2680,6839 } },\n    { \"Nikon E5700\", 0, 0, /* updated */\n      { -6475,12496,2428,5409,-16,3180,-5965,10912,5866,-177,9918,248 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX Kalon\", 0, 0, /* added */\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX Deneb\", 0, 0, /* added */\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835 } },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0, /* updated */\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0, /* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0, /* updated */\n      { 10633,-3234,-1285,-7460,15570,1967,-1917,2510,6299 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc, /* updated */\n      { 12970,-4703,-1433,-7466,15843,1644,-2191,2451,6668 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc, /* updated */\n      { 13414,-4950,-1517,-7166,15293,1960,-2325,2664,7212 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL9\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII, E-M10MarkIII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0,\n      { 9383,-3170,-763,-2457,10702,2020,-384,1236,5552 } },\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP565UZ\", 0, 0, /* added */\n      { 11856,-4469,-1159,-4814,12368,2756,-993,1779,5589 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0, /* updated */\n      { 8360,-2420,-880,-3928,12353,1739,-1381,2416,5173 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus TG-5\", 0, 0,\n     { 10899,-3833,-1082,-2112,10736,1575,-267,1452,5269 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax GR\", 0, 0, /* added */\n      { 5329,-1459,-390,-5407,12930,2768,-1119,1772,6046 } },\n    { \"Pentax K-01\", 0, 0, /* added */\n      { 8134,-2728,-645,-4365,11987,2694,-838,1509,6498 } },\n    { \"Pentax K10D\", 0, 0, /* updated */\n      { 9679,-2965,-811,-8622,16514,2182,-975,883,9793 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0, /* updated */\n      { 9730,-2989,-970,-8527,16258,2381,-1060,970,8362 } },\n    { \"Pentax K-m\", 0, 0, /* updated */\n      { 9730,-2989,-970,-8527,16258,2381,-1060,970,8362 } },\n    { \"Pentax KP\", 0, 0,\n      { 7825,-2160,-1403,-4841,13555,1349,-1559,2449,5814 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0, /* updated */\n      { 8596,-2981,-639,-4202,12046,2431,-685,1424,6122 } },\n    { \"Pentax K-30\", 0, 0, /* updated */\n      { 8134,-2728,-645,-4365,11987,2694,-838,1509,6498 } },\n    { \"Pentax K-3 II\", 0, 0, /* updated */\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-500\", 0, 0, /* added */\n      { 8109,-2740,-608,-4593,12175,2731,-1006,1515,6545 } },\n    { \"Pentax K-50\", 0, 0, /* added */\n      { 8109,-2740,-608,-4593,12175,2731,-1006,1515,6545 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      { 8766,-3149,-747,-3976,11943,2292,-517,1259,5552 } },\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax KP\", 0, 0,  /* temp */\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax Q7\", 0, 0, /* added */\n      { 10901,-3938,-1025,-2743,11210,1738,-823,1805,5344 } },\n    { \"Pentax Q10\", 0, 0, /* updated */\n      { 11562,-4183,-1172,-2357,10919,1641,-582,1726,5112 } },\n    { \"Pentax Q\", 0, 0, /* added */\n      { 11731,-4169,-1267,-2015,10727,1473,-217,1492,4870 } },\n    { \"Pentax MX-1\", 0, 0, /* updated */\n      { 9296,-3146,-888,-2860,11287,1783,-618,1698,5151 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* updated */\n      { 9519,-3591,-664,-4074,11725,2671,-624,1501,6653 } },\n\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770,-3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770,-3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DC-FZ82\", -15, 0, /* markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-FZ80\", -15, 0, /* markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0, /* 40,42,45 */\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Leica V-LUX 1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX3\", 0, 0xf7f, /* added */\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX2\", 0, 0, /* added */\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Panasonic DMC-LX9\", -15, 0, /* markets: LX9 LX10 LX15 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-LX10\", -15, 0, /* markets: LX9 LX10 LX15 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-LX15\", -15, 0, /* markets: LX9 LX10 LX15 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-LUX 2\", 0, 0xf7f, /* added */\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX 3\", 0, 0, /* added */\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000, DMC-FZ2500 ,FZH1 */\n      { 7386,-2443,-743,-3437,11864,1757,-608,1660,4766 } },\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386,-2443,-743,-3437,11864,1757,-608,1660,4766 } },\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386,-2443,-743,-3437,11864,1757,-608,1660,4766 } },\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-FX180\", -15, 0xfff, /* added */\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff, /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-G9\", -15, 0,\n      { 7685,-2375,-634,-3687,11700,2249,-748,1546,5111 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic AG-GH4\", -15, 0, /* added */\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    {\"Panasonic DC-GH5s\", -15, 0,\n      { 6929,-2355,-708,-4192,12534,1828,-1097,1989,5195 } },\n    { \"Panasonic DC-GH5\", -15, 0,\n      { 7641,-2336,-605,-3218,11299,2187,-485,1338,5121 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n\n    { \"Panasonic DC-GF10\", -15, 0, /* temp, markets: GF10, GF90 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GF90\", -15, 0, /* temp, markets: GF10, GF90 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n\n    { \"Panasonic DC-GX850\", -15, 0, /* markets: GX850 GX800 GF9 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GX800\", -15, 0, /* markets: GX850 GX800 GF9 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GF9\", -15, 0, /* markets: GX850 GX800 GF9 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX85\", -15, 0, /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0, /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0, /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n\n    { \"Panasonic DC-GX9\", -15, 0, /* temp */\n      { 7685,-2375,-634,-3687,11700,2249,-748,1546,5111 } },\n\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0, /* markets: ZS60 TZ80 TZ81 TZ82 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-TZ90\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DC-TZ91\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DC-TZ92\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DC-T93\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DMC-ZS4\", -15, 0, /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0, /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0, /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0, /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-ZS70\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DMC-ZS100\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n\n    { \"Panasonic DC-ZS200\", -15, 0, /* temp, markets: ZS200 TZ200 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DC-TZ200\", -15, 0, /* temp, markets: ZS200 TZ200 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n\n    { \"Phase One H 20\", 0, 0, /* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H20\", 0, 0, /* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One H25\", 0, 0, /* added */\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ280\", 0, 0, /* added */\n      { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },\n    { \"Phase One IQ260\", 0, 0, /* added */\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One IQ250\",0, 0,\n//    {3984,0,0,0,10000,0,0,0,7666}},\n      {10325,845,-604,-4113,13385,481,-1791,4163,6924}}, /* emb */\n    { \"Phase One IQ180\", 0, 0, /* added */\n      { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },\n    { \"Phase One IQ160\", 0, 0, /* added */\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One IQ150\", 0, 0, /* added */\n      {10325,845,-604,-4113,13385,481,-1791,4163,6924}}, /* temp */ /* emb */\n//      { 3984,0,0,0,10000,0,0,0,7666 } },\n    { \"Phase One IQ140\", 0, 0, /* added */\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P 65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P45\", 0, 0, /* added */\n      { 5053,-24,-117,-5685,14077,1703,-2619,4491,5850 } },\n    { \"Phase One P 45\", 0, 0, /* added */\n      { 5053,-24,-117,-5685,14077,1703,-2619,4491,5850 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P 40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P30\", 0, 0, /* added */\n      { 4516,-244,-36,-7020,14976,2174,-3206,4670,7087 } },\n    { \"Phase One P 30\", 0, 0, /* added */\n      { 4516,-244,-36,-7020,14976,2174,-3206,4670,7087 } },\n    { \"Phase One P25\", 0, 0, /* added */\n      { 2905,732,-237,-8135,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 25\", 0, 0, /* added */\n      { 2905,732,-237,-8135,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P21\", 0, 0, /* added */\n      { 6516,-2050,-507,-8217,16703,1479,-3492,4741,8489 } },\n    { \"Phase One P 21\", 0, 0, /* added */\n      { 6516,-2050,-507,-8217,16703,1479,-3492,4741,8489 } },\n    { \"Phase One P20\", 0, 0, /* added */\n      { 2905,732,-237,-8135,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P20\", 0, 0, /* added */\n      { 2905,732,-237,-8135,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ3 100MP\", 0, 0, /* added */\n//    {2423,0,0,0,9901,0,0,0,7989}},\n      { 10999,354,-742,-4590,13342,937,-1060,2166,8120} }, /* emb */\n    { \"Phase One IQ3 80MP\", 0, 0, /* added */\n      { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },\n    { \"Phase One IQ3 60MP\", 0, 0, /* added */\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One IQ3 50MP\", 0, 0, /* added */\n//      { 3984,0,0,0,10000,0,0,0,7666 } },\n      {10058,1079,-587,-4135,12903,944,-916,2726,7480}}, /* emb */\n    { \"Photron BC2-HD\", 0, 0, /* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n\n    { \"Polaroid x530\", 0, 0,\n      { 13458,-2556,-510,-5444,15081,205,0,0,12120 } },\n\n    { \"Red One\", 704, 0xffff, /* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n\n    { \"Ricoh S10 24-72mm F2.5-4.4 VC\", 0, 0, /* added */\n      { 10531,-4043,-878,-2038,10270,2052,-107,895,4577 } },\n    { \"Ricoh GR A12 50mm F2.5 MACRO\", 0, 0, /* added */\n      { 8849,-2560,-689,-5092,12831,2520,-507,1280,7104 } },\n    { \"Ricoh GR DIGITAL 3\", 0, 0, /* added */\n      { 8170,-2496,-655,-5147,13056,2312,-1367,1859,5265 } },\n    { \"Ricoh GR DIGITAL 4\", 0, 0, /* added */\n      { 8771,-3151,-837,-3097,11015,2389,-703,1343,4924 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n      { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Ricoh GX200\", 0, 0, /* added */\n      { 8040,-2368,-626,-4659,12543,2363,-1125,1581,5660 } },\n    { \"Ricoh RICOH GX200\", 0, 0, /* added */\n      { 8040,-2368,-626,-4659,12543,2363,-1125,1581,5660 } },\n    { \"Ricoh GXR MOUNT A12\", 0, 0, /* added */\n      { 7834,-2182,-739,-5453,13409,2241,-952,2005,6620 } },\n    { \"Ricoh GXR A16\", 0, 0, /* added */\n      { 7837,-2538,-730,-4370,12184,2461,-868,1648,5830 } },\n    { \"Ricoh GXR A12\", 0, 0, /* added */\n      { 10228,-3159,-933,-5304,13158,2371,-943,1873,6685 } },\n\n    { \"Samsung EK-GN100\", 0, 0, /* added */ /* Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EK-GN110\", 0, 0, /* added */ /* Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EK-KN120\", 0, 0, /* added */ /* Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung Galaxy S7 Edge\", 0, 0, /* added */\n      { 9927,-3704,-1024,-3935,12758,1257,-389,1512,4993 } },\n    { \"Samsung Galaxy S7\", 0, 0, /* added */\n      { 9927,-3704,-1024,-3935,12758,1257,-389,1512,4993 } },\n    { \"Samsung Galaxy NX\", 0, 0, /* added */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX U\", 0, 0, /* added */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0, /* used for NX30/NX300/NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff, /* used for NX20/NX200/NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0, /* used for NX10/NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NXF1\", 0, 0, /* added */\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX10\", 0, 0, /* added */ /* Pentax K10D */\n      { 9679,-2965,-811,-8622,16514,2182,-975,883,9793 } },\n    { \"Samsung GX-10\", 0, 0, /* added */ /* Pentax K10D */\n      { 9679,-2965,-811,-8622,16514,2182,-975,883,9793 } },\n    { \"Samsung GX-1\", 0, 0, /* used for GX-1L/GX-1S */\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0, /* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung GX-20\", 0, 0, /* added */ /* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0, /* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n\n// Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0,\n      { 1295,108,-311, 256,828,-65,-28,750,254 } }, /* temp */\n    { \"Sigma sd Quattro\", 2047, 0,\n      { 1295,108,-311, 256,828,-65,-28,750,254 } }, /* temp */\n    { \"Sigma SD9\", 15, 4095, /* updated */\n      { 13564,-2537,-751,-5465,15154,194,-67,116,10425 } },\n    { \"Sigma SD10\", 15, 16383, /* updated */\n      { 6787,-1682,575,-3091,8357,160,217,-369,12314 } },\n    { \"Sigma SD14\", 15, 16383, /* updated */\n      { 13589,-2509,-739,-5440,15104,193,-61,105,10554 } },\n    { \"Sigma SD15\", 15, 4095, /* updated */\n      { 13556,-2537,-730,-5462,15144,195,-61,106,10577 } },\n// Merills + SD1\n    { \"Sigma SD1\", 31, 4095, /* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095, /* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095, /* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095, /* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n// Sigma DP (non-Merill Versions)\n    { \"Sigma DP1X\", 0, 4095, /* updated */\n      { 13704,-2452,-857,-5413,15073,186,-89,151,9820 } },\n    { \"Sigma DP1\", 0, 4095, /* updated */\n      { 12774,-2591,-394,-5333,14676,207,15,-21,12127 } },\n    { \"Sigma DP\", 0, 4095, /* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n\n    { \"Sinar\", 0, 0, /* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100M\", -800, 0, /* used for M2/M3/M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    {\"Sony DSC-RX10M4\", -800, 0,\n      { 7699,-2566,-629,-2967,11270,1928,-378,1286,4807 } },\n    { \"Sony DSC-RX10\",0, 0, /* same for M2/M3 */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0, /* updated */\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n\n    {\"Sony DSC-RX0\", -800, 0, /* temp */\n      { 9396,-3507,-843,-2497,11111,1572,-343,1355,5089 } },\n\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 16596,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 16596,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A550\", 0, 16596,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb, /* Is there any cameras not covered above? */\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0,\n      { 6660,-1918,-471,-4613,12398,2485,-649,1433,6447 } },\n    { \"Sony ILCE-9\", 0, 0,\n      { 6389,-1703,-378,-4562,12265,2587,-670,1489,6550 } },\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM3\", 0, 0,\n      { 6640,-1847,-503,-5238,13010,2474,-993,1673,6527 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0, /* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony MODEL-NAME\", 0, 0, /* added */\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX-VG30\", 0, 0, /* added */\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-VG900\", 0, 0, /* added */\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony NEX\", 0, 0, /* NEX-C3, NEX-F3, NEX-VG20 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  // clang-format on\n\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if (colors > 4 || colors < 1)\n    return;\n\n  int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;\n  if (cblack[4] * cblack[5] > 0)\n  {\n    for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)\n      bl64 += cblack[c + 6];\n    bl64 /= cblack[4] * cblack[5];\n  }\n  int rblack = black + bl4 + bl64;\n\n  sprintf(name, \"%s %s\", t_make, t_model);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix)))\n    {\n      if (!dng_version)\n      {\n        if (table[i].t_black > 0)\n        {\n          black = (ushort)table[i].t_black;\n          memset(cblack, 0, sizeof(cblack));\n        }\n        else if (table[i].t_black < 0 && rblack == 0)\n        {\n          black = (ushort)(-table[i].t_black);\n          memset(cblack, 0, sizeof(cblack));\n        }\n        if (table[i].t_maximum)\n          maximum = (ushort)table[i].t_maximum;\n      }\n      if (table[i].trans[0])\n      {\n        for (raw_color = j = 0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (internal_only)\n            imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n          else\n            imgdata.color.cam_xyz[0][j] =\n#endif\n                ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!internal_only)\n#endif\n          cam_xyz_coeff(rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff(int index)\n{\n  static const float table[][12] = {/* index 0 -- all Foveon cameras */\n                                    {1.4032, -0.2231, -0.1016, -0.5263, 1.4816, 0.017, -0.0112, 0.0183, 0.9113},\n                                    /* index 1 -- Kodak DC20 and DC25 */\n                                    {2.25, 0.75, -1.75, -0.25, -0.25, 0.75, 0.75, -0.25, -0.25, -1.75, 0.75, 2.25},\n                                    /* index 2 -- Logitech Fotoman Pixtura */\n                                    {1.893, -0.418, -0.476, -0.495, 1.773, -0.278, -1.017, -0.655, 2.672},\n                                    /* index 3 -- Nikon E880, E900, and E990 */\n                                    {-1.936280, 1.800443, -1.448486, 2.584324, 1.405365, -0.524955, -0.289090, 0.408680,\n                                     -1.204965, 1.082304, 2.941367, -1.818705}};\n  int i, c;\n\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i * colors + c];\n}\n\nshort CLASS guess_byte_order(int words)\n{\n  uchar test[4][2];\n  int t = 2, msb;\n  double diff, sum[2] = {0, 0};\n\n  fread(test[0], 2, 2, ifp);\n  for (words -= 2; words--;)\n  {\n    fread(test[t], 2, 1, ifp);\n    for (msb = 0; msb < 2; msb++)\n    {\n      diff = (test[t ^ 2][msb] << 8 | test[t ^ 2][!msb]) - (test[t][msb] << 8 | test[t][!msb]);\n      sum[msb] += diff * diff;\n    }\n    t = (t + 1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green(int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf = 0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[] = {0, 0};\n  if(width > 2064) return 0.f; // too wide\n\n  FORC(2)\n  {\n    fseek(ifp, c ? off1 : off0, SEEK_SET);\n    for (vbits = col = 0; col < width; col++)\n    {\n      for (vbits -= bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);\n    }\n  }\n  FORC(width - 1)\n  {\n    sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);\n    sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);\n  }\n  return 100 * log(sum[0] / sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if (len < 1)\n    return; // not needed, b/c sizeof of make/model is 64\n  string[len - 1] = 0;\n  if (len < 3)\n    return; // also not needed\n  len = strnlen(string, len - 1);\n  for (int i = len - 1; i >= 0; i--)\n  {\n    if (isspace((unsigned char)string[i]))\n      string[i] = 0;\n    else\n      break;\n  }\n}\n\nvoid CLASS initdata()\n{\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n  for (int i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n  for (int i = 0; i < 0x10000; i++)\n    curve[i] = i;\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n}\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n      {3130, 1743, 4, 0, -6, 0},    {3130, 2055, 4, 0, -6, 0},      {3130, 2319, 4, 0, -6, 0},\n      {3170, 2103, 18, 0, -42, 20}, {3170, 2367, 18, 13, -42, -21}, {3177, 2367, 0, 0, -1, 0},\n      {3304, 2458, 0, 0, -1, 0},    {3330, 2463, 9, 0, -5, 0},      {3330, 2479, 9, 0, -17, 4},\n      {3370, 1899, 15, 0, -44, 20}, {3370, 2235, 15, 0, -44, 20},   {3370, 2511, 15, 10, -44, -21},\n      {3690, 2751, 3, 0, -8, -3},   {3710, 2751, 0, 0, -3, 0},      {3724, 2450, 0, 0, 0, -2},\n      {3770, 2487, 17, 0, -44, 19}, {3770, 2799, 17, 15, -44, -19}, {3880, 2170, 6, 0, -6, 0},\n      {4060, 3018, 0, 0, 0, -2},    {4290, 2391, 3, 0, -8, -1},     {4330, 2439, 17, 15, -44, -19},\n      {4508, 2962, 0, 0, -3, -4},   {4508, 3330, 0, 0, -3, -6},\n  };\n  static const ushort canon[][11] = {\n      {1944, 1416, 0, 0, 48, 0},\n      {2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25},\n      {2224, 1456, 48, 6, 0, 2},\n      {2376, 1728, 12, 6, 52, 2},\n      {2672, 1968, 12, 6, 44, 2},\n      {3152, 2068, 64, 12, 0, 0, 16},\n      {3160, 2344, 44, 12, 4, 4},\n      {3344, 2484, 4, 6, 52, 6},\n      {3516, 2328, 42, 14, 0, 0},\n      {3596, 2360, 74, 12, 0, 0},\n      {3744, 2784, 52, 12, 8, 12},\n      {3944, 2622, 30, 18, 6, 2},\n      {3948, 2622, 42, 18, 0, 2},\n      {3984, 2622, 76, 20, 0, 2, 14},\n      {4104, 3048, 48, 12, 24, 12},\n      {4116, 2178, 4, 2, 0, 0},\n      {4152, 2772, 192, 12, 0, 0},\n      {4160, 3124, 104, 11, 8, 65},\n      {4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49},\n      {4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49},\n      {4312, 2876, 22, 18, 0, 2},\n      {4352, 2874, 62, 18, 0, 0},\n      {4476, 2954, 90, 34, 0, 0},\n      {4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49},\n      {4480, 3366, 80, 50, 0, 0},\n      {4496, 3366, 80, 50, 12, 0},\n      {4768, 3516, 96, 16, 0, 0, 0, 16},\n      {4832, 3204, 62, 26, 0, 0},\n      {4832, 3228, 62, 51, 0, 0},\n      {5108, 3349, 98, 13, 0, 0},\n      {5120, 3318, 142, 45, 62, 0},\n      {5280, 3528, 72, 52, 0, 0}, /* EOS M */\n      {5344, 3516, 142, 51, 0, 0},\n      {5344, 3584, 126, 100, 0, 2},\n      {5360, 3516, 158, 51, 0, 0},\n      {5568, 3708, 72, 38, 0, 0},\n      {5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49},\n      {5712, 3774, 62, 20, 10, 2},\n      {5792, 3804, 158, 51, 0, 0},\n      {5920, 3950, 122, 80, 2, 0},\n      {6096, 4056, 72, 34, 0, 0},  /* EOS M3 */\n      {6288, 4056, 266, 36, 0, 0}, /* EOS 80D */\n      {6384, 4224, 120, 44, 0, 0}, /* 6D II */\n      {6880, 4544, 136, 42, 0, 0}, /* EOS 5D4 */\n      {8896, 5920, 160, 64, 0, 0},\n  };\n  static const struct\n  {\n    ushort id;\n    char t_model[20];\n  } unique[] =\n      {\n          {0x001, \"EOS-1D\"},\n          {0x167, \"EOS-1DS\"},\n          {0x168, \"EOS 10D\"},\n          {0x169, \"EOS-1D Mark III\"},\n          {0x170, \"EOS 300D\"},\n          {0x174, \"EOS-1D Mark II\"},\n          {0x175, \"EOS 20D\"},\n          {0x176, \"EOS 450D\"},\n          {0x188, \"EOS-1Ds Mark II\"},\n          {0x189, \"EOS 350D\"},\n          {0x190, \"EOS 40D\"},\n          {0x213, \"EOS 5D\"},\n          {0x215, \"EOS-1Ds Mark III\"},\n          {0x218, \"EOS 5D Mark II\"},\n          {0x232, \"EOS-1D Mark II N\"},\n          {0x234, \"EOS 30D\"},\n          {0x236, \"EOS 400D\"},\n          {0x250, \"EOS 7D\"},\n          {0x252, \"EOS 500D\"},\n          {0x254, \"EOS 1000D\"},\n          {0x261, \"EOS 50D\"},\n          {0x269, \"EOS-1D X\"},\n          {0x270, \"EOS 550D\"},\n          {0x281, \"EOS-1D Mark IV\"},\n          {0x285, \"EOS 5D Mark III\"},\n          {0x286, \"EOS 600D\"},\n          {0x287, \"EOS 60D\"},\n          {0x288, \"EOS 1100D\"},\n          {0x289, \"EOS 7D Mark II\"},\n          {0x301, \"EOS 650D\"},\n          {0x302, \"EOS 6D\"},\n          {0x324, \"EOS-1D C\"},\n          {0x325, \"EOS 70D\"},\n          {0x326, \"EOS 700D\"},\n          {0x327, \"EOS 1200D\"},\n          {0x328, \"EOS-1D X Mark II\"},\n          {0x331, \"EOS M\"},\n          {0x335, \"EOS M2\"},\n          {0x374, \"EOS M3\"},   /* temp */\n          {0x384, \"EOS M10\"},  /* temp */\n          {0x394, \"EOS M5\"},   /* temp */\n          {0x398, \"EOS M100\"}, /* temp */\n          {0x346, \"EOS 100D\"},\n          {0x347, \"EOS 760D\"},\n          {0x349, \"EOS 5D Mark IV\"},\n          {0x350, \"EOS 80D\"},\n          {0x382, \"EOS 5DS\"},\n          {0x393, \"EOS 750D\"},\n          {0x401, \"EOS 5DS R\"},\n          {0x404, \"EOS 1300D\"},\n          {0x405, \"EOS 800D\"},\n          {0x406, \"EOS 6D Mark II\"},\n          {0x407, \"EOS M6\"},\n          {0x408, \"EOS 77D\"},\n          {0x417, \"EOS 200D\"},\n      },\n    sonique[] = {\n        {0x002, \"DSC-R1\"},      {0x100, \"DSLR-A100\"},   {0x101, \"DSLR-A900\"},  {0x102, \"DSLR-A700\"},\n        {0x103, \"DSLR-A200\"},   {0x104, \"DSLR-A350\"},   {0x105, \"DSLR-A300\"},  {0x106, \"DSLR-A900\"},\n        {0x107, \"DSLR-A380\"},   {0x108, \"DSLR-A330\"},   {0x109, \"DSLR-A230\"},  {0x10a, \"DSLR-A290\"},\n        {0x10d, \"DSLR-A850\"},   {0x10e, \"DSLR-A850\"},   {0x111, \"DSLR-A550\"},  {0x112, \"DSLR-A500\"},\n        {0x113, \"DSLR-A450\"},   {0x116, \"NEX-5\"},       {0x117, \"NEX-3\"},      {0x118, \"SLT-A33\"},\n        {0x119, \"SLT-A55V\"},    {0x11a, \"DSLR-A560\"},   {0x11b, \"DSLR-A580\"},  {0x11c, \"NEX-C3\"},\n        {0x11d, \"SLT-A35\"},     {0x11e, \"SLT-A65V\"},    {0x11f, \"SLT-A77V\"},   {0x120, \"NEX-5N\"},\n        {0x121, \"NEX-7\"},       {0x122, \"NEX-VG20E\"},   {0x123, \"SLT-A37\"},    {0x124, \"SLT-A57\"},\n        {0x125, \"NEX-F3\"},      {0x126, \"SLT-A99V\"},    {0x127, \"NEX-6\"},      {0x128, \"NEX-5R\"},\n        {0x129, \"DSC-RX100\"},   {0x12a, \"DSC-RX1\"},     {0x12b, \"NEX-VG900\"},  {0x12c, \"NEX-VG30E\"},\n        {0x12e, \"ILCE-3000\"},   {0x12f, \"SLT-A58\"},     {0x131, \"NEX-3N\"},     {0x132, \"ILCE-7\"},\n        {0x133, \"NEX-5T\"},      {0x134, \"DSC-RX100M2\"}, {0x135, \"DSC-RX10\"},   {0x136, \"DSC-RX1R\"},\n        {0x137, \"ILCE-7R\"},     {0x138, \"ILCE-6000\"},   {0x139, \"ILCE-5000\"},  {0x13d, \"DSC-RX100M3\"},\n        {0x13e, \"ILCE-7S\"},     {0x13f, \"ILCA-77M2\"},   {0x153, \"ILCE-5100\"},  {0x154, \"ILCE-7M2\"},\n        {0x155, \"DSC-RX100M4\"}, {0x156, \"DSC-RX10M2\"},  {0x158, \"DSC-RX1RM2\"}, {0x15a, \"ILCE-QX1\"},\n        {0x15b, \"ILCE-7RM2\"},   {0x15e, \"ILCE-7SM2\"},   {0x161, \"ILCA-68\"},    {0x162, \"ILCA-99M2\"},\n        {0x163, \"DSC-RX10M3\"},  {0x164, \"DSC-RX100M5\"}, {0x165, \"ILCE-6300\"},  {0x166, \"ILCE-9\"},\n        {0x168, \"ILCE-6500\"},   {0x16a, \"ILCE-7RM3\"},   {0x16c, \"DSC-RX0\"},    {0x16d, \"DSC-RX10M4\"},\n    };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t const_table[]\n#else\n  static const struct\n  {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  } table[]\n#endif\n      = {\n          {786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-080C\"},\n          {1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-145C\"},\n          {1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-201C\"},\n          {5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-810C\"},\n          {15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, \"AgfaPhoto\", \"DC-833m\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Alcatel\", \"5035D\"},\n          {31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 4:3\"},\n          {23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 16:9\"},\n          {32257024, 4624, 3488, 8, 2, 16, 2, 0, 0x94, 0, 0, \"GITUP\", \"GIT2P 4:3\"},\n          //   Android Raw dumps id start\n          //   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n          {1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"Samsung\", \"S3\"},\n          {2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontMipi\"},\n          {2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontQCOM\"},\n          {2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wMipi\"},\n          {3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wQCOM\"},\n          {3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, \"I_Mobile\", \"I_StyleQ6\"},\n          {5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel1\"},\n          {5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel2\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, \"OmniVisi\", \"OV5648\"},\n          {6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"OmniVisi\", \"OV56482\"},\n          {6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"OneSV\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"5mp\"},\n          {9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, \"NGM\", \"ForwardArt\"},\n          {10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX219-mipi 8mp\"},\n          {10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Sony\", \"IMX\"},\n          {10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"MyTouch4GSlide\"},\n          {10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Xperia\", \"L\"},\n          {15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, \"OmniVison\", \"OV8850\"},\n          {16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3MipiL\"},\n          {16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"IMX135\", \"MipiL\"},\n          {17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3LQCom\"},\n          {17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Sony\", \"IMX135-QCOM\"},\n          {19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7mipi\"},\n          {19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G4\"},\n          {20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"RedmiNote3Pro\"},\n          {20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX298-mipi 16mp\"},\n          {21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7qcom\"},\n          {26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, \"THL\", \"5000\"},\n          {26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, \"Sony\", \"IMX214\"},\n          {26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, \"OV\", \"13860\"},\n          {41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Meizu\", \"MX4\"},\n          {42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"IMX230\"},\n          //   Android Raw dumps id end\n          {20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, \"Aptina\", \"MT9J003\", 0xffff},\n          {2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, \"Baumer\", \"TXG14\", 1078},\n          {5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SD300\"},\n          {6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A460\"},\n          {6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A610\"},\n          {6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A530\"},\n          {7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot S3 IS\"},\n          {9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A620\"},\n          {9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A470\"},\n          {10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A720 IS\"},\n          {10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A630\"},\n          {12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A640\"},\n          {15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A650\"},\n          {15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX110 IS\"},\n          {15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX120 IS\"},\n          {18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX20 IS\"},\n          {18763488, 4104, 3048, 10, 22, 82, 22, 8, 0x49, 0, 0, \"Canon\", \"PowerShot D10\"},\n          {19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX220 HS\"},\n          {21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, \"Canon\", \"PowerShot SX30 IS\"},\n          {24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A3300 IS\"},\n          {30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, \"Canon\", \"IXUS 160\"},\n          {1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-2000UX\"},\n          {3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-3*00EX\"},\n          {6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, \"Casio\", \"QV-5700\"},\n          {7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, \"Casio\", \"EX-Z60\"},\n          {2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, \"Casio\", \"EX-S20\"},\n          {4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, \"Casio\", \"EX-S100\"},\n          {6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R41\"},\n          {7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-P505\"},\n          {7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R51\"},\n          {7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"EX-Z50\"},\n          {7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, \"Casio\", \"EX-Z500\"},\n          {7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, \"Casio\", \"EX-Z55\"},\n          {9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, \"Casio\", \"EX-P600\"},\n          {10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z750\"},\n          {10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z75\"},\n          {10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, \"Casio\", \"EX-P700\"},\n          {12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, \"Casio\", \"EX-Z850\"},\n          {12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, \"Casio\", \"EX-Z8\"},\n          {15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z1050\"},\n          {18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, \"Casio\", \"EX-ZR100\"},\n          {7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, \"Casio\", \"QV-4000\"},\n          {787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, \"Creative\", \"PC-CAM 600\"},\n          {28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, \"DJI\"},\n          {15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Matrix\"},\n          {3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, \"Foculus\", \"531C\"},\n          {307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Generic\"},\n          {62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, \"Kodak\", \"DCS200\"},\n          {4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\"},\n          {4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\", 3160},\n          {2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\"},\n          {6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\", 3160},\n          {460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\"},\n          {12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\", 31556},\n          {18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"12MP\"},\n          {614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, \"Kodak\", \"KAI-0340\"},\n          {15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Lenovo\", \"A820\"},\n          {3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Micron\", \"2010\", 3212},\n          {1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, \"Minolta\", \"RD175\", 513},\n          {1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, \"Nikon\", \"E900\"},\n          {2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, \"Nikon\", \"E950\"},\n          {2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, \"Nikon\", \"E2100\"},\n          {4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, \"Nikon\", \"E990\"},\n          {4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, \"Nikon\", \"E3700\"},\n          {5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E4500\"},\n          {5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, \"Nikon\", \"E4300\"},\n          {7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E5000\"},\n          {8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, \"Nikon\", \"COOLPIX S6\"},\n          {5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, \"Olympus\", \"C770UZ\"},\n          {3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Pentax\", \"Optio S\"},\n          {4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S\"},\n          {6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S4\"},\n          {10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, \"Pentax\", \"Optio 750Z\"},\n          {4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\"},\n          {4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\", 8},\n          {13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, \"Pixelink\", \"A782\"},\n          {6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, \"RoverShot\", \"3320AF\"},\n          {311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, \"ST Micro\", \"STV680 VGA\"},\n          {16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n          {2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n      };\n#ifdef LIBRAW_LIBRARY_BUILD\n  libraw_custom_camera_t table[64 + sizeof(const_table) / sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] = {\"AgfaPhoto\", \"Canon\",     \"Casio\",  \"Epson\",   \"Fujifilm\", \"Mamiya\", \"Minolta\",\n                               \"Motorola\",  \"Kodak\",     \"Konica\", \"Leica\",   \"Nikon\",    \"Nokia\",  \"Olympus\",\n                               \"Pentax\",    \"Phase One\", \"Ricoh\",  \"Samsung\", \"Sigma\",    \"Sinar\",  \"Sony\"};\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize = 1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64, table, imgdata.params.custom_camera_strings);\n  for (int q = 0; q < sizeof(const_table) / sizeof(const_table[0]); q++)\n    memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));\n  camera_count += sizeof(const_table) / sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  imgdata.other.CameraTemperature = imgdata.other.SensorTemperature = imgdata.other.SensorTemperature2 =\n      imgdata.other.LensTemperature = imgdata.other.AmbientTemperature = imgdata.other.BatteryTemperature =\n          imgdata.other.exifAmbientTemperature = -1000.0f;\n\n  for (i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n#endif\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n  for (i = 0; i < 4; i++)\n  {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i = 0; i < 0x10000; i++)\n    curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek(ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(fread(head, 1, 64, ifp) < 64) throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread(head, 1, 32, ifp);\n#endif\n  fseek(ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *)memmem(head, 32, (char *)\"MMMM\", 4)) || (cp = (char *)memmem(head, 32, (char *)\"IIII\", 4)))\n  {\n    parse_phase_one(cp - head);\n    if (cp - head && parse_tiff(0))\n      apply_tiff();\n  }\n  else if (order == 0x4949 || order == 0x4d4d)\n  {\n    if (!memcmp(head + 6, \"HEAPCCDR\", 8))\n    {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(hlen, flen - hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    }\n    else if (parse_tiff(0))\n      apply_tiff();\n  }\n  else if (!memcmp(head, \"\\xff\\xd8\\xff\\xe1\", 4) && !memcmp(head + 6, \"Exif\", 4))\n  {\n    fseek(ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek(ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  }\n  else if (!memcmp(head + 25, \"ARECOYK\", 7))\n  {\n    strcpy(make, \"Contax\");\n    strcpy(model, \"N Digital\");\n    fseek(ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek(ifp, 52, SEEK_SET);\n    switch (get4())\n    {\n    case 7:\n      iso_speed = 25;\n      break;\n    case 8:\n      iso_speed = 32;\n      break;\n    case 9:\n      iso_speed = 40;\n      break;\n    case 10:\n      iso_speed = 50;\n      break;\n    case 11:\n      iso_speed = 64;\n      break;\n    case 12:\n      iso_speed = 80;\n      break;\n    case 13:\n      iso_speed = 100;\n      break;\n    case 14:\n      iso_speed = 125;\n      break;\n    case 15:\n      iso_speed = 160;\n      break;\n    case 16:\n      iso_speed = 200;\n      break;\n    case 17:\n      iso_speed = 250;\n      break;\n    case 18:\n      iso_speed = 320;\n      break;\n    case 19:\n      iso_speed = 400;\n      break;\n    }\n    shutter = libraw_powf64l(2.0f, (((float)get4()) / 8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek(ifp, 88, SEEK_SET);\n    aperture = libraw_powf64l(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek(ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  }\n  else if (!strcmp(head, \"PXN\"))\n  {\n    strcpy(make, \"Logitech\");\n    strcpy(model, \"Fotoman Pixtura\");\n  }\n  else if (!strcmp(head, \"qktk\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  }\n  else if (!strcmp(head, \"qktn\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  }\n  else if (!memcmp(head, \"FUJIFILM\", 8))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strncpy(model, head + 0x1c,0x20);\n    model[0x20]=0;\n    memcpy(model2, head + 0x3c, 4);\n    model2[4] = 0;\n#endif\n    fseek(ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek(ifp, 92, SEEK_SET);\n    parse_fuji(get4());\n    if (thumb_offset > 120)\n    {\n      fseek(ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) ? 1 : 0;\n      if (is_raw == 2 && shot_select)\n        parse_fuji(i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);\n    parse_tiff(data_offset = get4());\n    parse_tiff(thumb_offset + 12);\n    apply_tiff();\n  }\n  else if (!memcmp(head, \"RIFF\", 4))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_riff();\n  }\n  else if (!memcmp(head + 4, \"ftypqt   \", 9))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_qt(fsize);\n    is_raw = 0;\n  }\n  else if (!memcmp(head, \"\\0\\001\\0\\001\\0@\", 6))\n  {\n    fseek(ifp, 6, SEEK_SET);\n    fread(make, 1, 8, ifp);\n    fread(model, 1, 8, ifp);\n    fread(model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"NOKIARAW\", 8))\n  {\n    strcpy(make, \"NOKIA\");\n    order = 0x4949;\n    fseek(ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4(); // bytes count\n    width = get2();\n    height = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // Data integrity check\n    if (width < 1 || width > 16000 || height < 1 || height > 16000 || i < (width * height) || i > (2 * width * height))\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    switch (tiff_bps = i * 8 / (width * height))\n    {\n    case 8:\n      load_raw = &CLASS eight_bit_load_raw;\n      break;\n    case 10:\n      load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"ARRI\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy(make, \"ARRI\");\n    fseek(ifp, 668, SEEK_SET);\n    fread(model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"XPDS\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 0x800, SEEK_SET);\n    fread(make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width = get2();\n    fseek(ifp, 56, SEEK_CUR);\n    fread(model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve(0, 12.25, 1, 1023);\n  }\n  else if (!memcmp(head + 4, \"RED1\", 4))\n  {\n    strcpy(make, \"Red\");\n    strcpy(model, \"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve(1 / 2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  }\n  else if (!memcmp(head, \"DSC-Image\", 9))\n    parse_rollei();\n  else if (!memcmp(head, \"PWAD\", 4))\n    parse_sinar_ia();\n  else if (!memcmp(head, \"\\0MRM\", 4))\n    parse_minolta(0);\n  else if (!memcmp(head, \"FOVb\", 4))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    /* no foveon support for dcraw build from libraw source */\n    parse_x3f();\n#endif\n  }\n  else if (!memcmp(head, \"CI\", 2))\n    parse_cine();\n  if (make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize = i = 0; i < camera_count; i++)\n#else\n    for (zero_fsize = i = 0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize)\n      {\n        strcpy(make, table[i].t_make);\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\", 5))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n#endif\n        strcpy(model, table[i].t_model);\n        flip = table[i].flags >> 2;\n        zero_is_bad = table[i].flags & 2;\n        if (table[i].flags & 1)\n          parse_external_jpeg();\n        data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;\n        raw_width = table[i].rw;\n        raw_height = table[i].rh;\n        left_margin = table[i].lm;\n        top_margin = table[i].tm;\n        width = raw_width - left_margin - table[i].rm;\n        height = raw_height - top_margin - table[i].bm;\n        filters = 0x1010101 * table[i].cf;\n        colors = 4 - !((filters & filters >> 1) & 0x5555);\n        load_flags = table[i].lf;\n        switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))\n        {\n        case 6:\n          load_raw = &CLASS minolta_rd175_load_raw;\n          break;\n        case 8:\n          load_raw = &CLASS eight_bit_load_raw;\n          break;\n        case 10:\n          if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)\n          {\n            load_raw = &CLASS android_loose_load_raw;\n            break;\n          }\n          else if (load_flags & 1)\n          {\n            load_raw = &CLASS android_tight_load_raw;\n            break;\n          }\n        case 12:\n          load_flags |= 128;\n          load_raw = &CLASS packed_load_raw;\n          break;\n        case 16:\n          order = 0x4949 | 0x404 * (load_flags & 1);\n          tiff_bps -= load_flags >> 4;\n          tiff_bps -= load_flags = load_flags >> 1 & 7;\n          load_raw = table[i].offset == 0xffff ? &CLASS unpacked_load_raw_reversed : &CLASS unpacked_load_raw;\n        }\n        maximum = (1 << tiff_bps) - (1 << table[i].max);\n        break;\n      }\n  if (zero_fsize)\n    fsize = 0;\n  if (make[0] == 0)\n    parse_smal(0, flen);\n  if (make[0] == 0)\n  {\n    parse_jpeg(0);\n    fseek(ifp, 0, SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model, \"RP_imx219\", 9) && sz >= 0x9cb600 && !fseek(ifp, -0x9cb600, SEEK_END) &&\n        fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      strcpy(model, \"RPi IMX219\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 66;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    }\n    else if (!(strncmp(model, \"ov5647\", 6) && strncmp(model, \"RP_OV5647\", 9)) && sz >= 0x61b800 &&\n             !fseek(ifp, -0x61b800, SEEK_END) && fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      if (!strncmp(model, \"ov5647\", 6))\n        strcpy(model, \"RPi OV5647 v.1\");\n      else\n        strcpy(model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 16;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model, \"ov\", 2) && strncmp(model, \"RP_OV\", 5)) && sz >= 6404096 && !fseek(ifp, -6404096, SEEK_END) &&\n        fread(head, 1, 32, ifp) && !strcmp(head, \"BRCMn\"))\n    {\n      strcpy(make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000 - 32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    }\n    else\n      is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i = 0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr(make, corp[i])) /* Simplify company names */\n      strcpy(make, corp[i]);\n  if ((!strncmp(make, \"Kodak\", 5) || !strncmp(make, \"Leica\", 5)) &&\n      ((cp = strcasestr(model, \" DIGITAL CAMERA\")) || (cp = strstr(model, \"FILE VERSION\"))))\n    *cp = 0;\n  if (!strncasecmp(model, \"PENTAX\", 6))\n    strcpy(make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make, sizeof(make));\n  remove_trailing_spaces(model, sizeof(model));\n#else\n  cp = make + strlen(make); /* Remove trailing spaces */\n  while (*--cp == ' ')\n    *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ')\n    *cp = 0;\n#endif\n  i = strbuflen(make); /* Remove make from model */\n  if (!strncasecmp(model, make, i) && model[i++] == ' ')\n    memmove(model, model + i, 64 - i);\n  if (!strncmp(model, \"FinePix \", 8))\n    memmove(model, model + 8,strlen(model)-7);\n  if (!strncmp(model, \"Digital Camera \", 15))\n   memmove(model, model + 15,strlen(model)-14);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw)\n    goto notraw;\n\n  if (!height)\n    height = raw_height;\n  if (!width)\n    width = raw_width;\n  if (height == 2624 && width == 3936) /* Pentax K10D and Samsung GX10 */\n  {\n    height = 2616;\n    width = 3896;\n  }\n  if (height == 3136 && width == 4864) /* Pentax K20D and Samsung GX20 */\n  {\n    height = 3124;\n    width = 4688;\n    filters = 0x16161616;\n  }\n  if (width == 4352 && (!strcmp(model, \"K-r\") || !strcmp(model, \"K-x\")))\n  {\n    width = 4309;\n    filters = 0x16161616;\n  }\n  if (width >= 4960 && !strncmp(model, \"K-5\", 3))\n  {\n    left_margin = 10;\n    width = 4950;\n    filters = 0x16161616;\n  }\n  if (width == 6080 && !strcmp(model, \"K-70\"))\n  {\n    height = 4016;\n    top_margin = 32;\n    width = 6020;\n    left_margin = 60;\n  }\n  if (width == 4736 && !strcmp(model, \"K-7\"))\n  {\n    height = 3122;\n    width = 4684;\n    filters = 0x16161616;\n    top_margin = 2;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3 II\")) /* moved back */\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 6112 && !strcmp(model, \"KP\"))\n  {\n    /* From DNG, maybe too strict */\n    left_margin = 54;\n    top_margin = 28;\n    width = 6028;\n    height = raw_height - top_margin;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3\"))\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 7424 && !strcmp(model, \"645D\"))\n  {\n    height = 5502;\n    width = 7328;\n    filters = 0x61616161;\n    top_margin = 29;\n    left_margin = 48;\n  }\n  if (height == 3014 && width == 4096) /* Ricoh GX200 */\n    width = 4014;\n  if (dng_version)\n  {\n    if (filters == UINT_MAX)\n      filters = 0;\n    if (filters)\n      is_raw *= tiff_samples;\n    else\n      colors = tiff_samples;\n    switch (tiff_compress)\n    {\n    case 0: /* Compression not set, assuming uncompressed */\n    case 1:\n      load_raw = &CLASS packed_dng_load_raw;\n      break;\n    case 7:\n      load_raw = &CLASS lossless_dng_load_raw;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      load_raw = &CLASS deflate_dng_load_raw;\n      break;\n#endif\n    case 34892:\n      load_raw = &CLASS lossy_dng_load_raw;\n      break;\n    default:\n      load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\", 5) && unique_id)\n    {\n      for (i = 0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n        {\n          strcpy(model, unique[i].t_model);\n          break;\n        }\n    }\n    if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n    {\n      for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n        {\n          strcpy(model, sonique[i].t_model);\n          break;\n        }\n    }\n    goto dng_skip;\n  }\n  if (!strncmp(make, \"Canon\", 5) && !fsize && tiff_bps != 15)\n  {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i = 0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1])\n      {\n        width = raw_width - (left_margin = canon[i][2]);\n        height = raw_height - (top_margin = canon[i][3]);\n        width -= canon[i][4];\n        height -= canon[i][5];\n        mask[0][1] = canon[i][6];\n        mask[0][3] = -canon[i][7];\n        mask[1][1] = canon[i][8];\n        mask[1][3] = -canon[i][9];\n        if (canon[i][10])\n          filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000)\n    {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make, \"Canon\", 5) && unique_id)\n  {\n    for (i = 0; i < sizeof unique / sizeof *unique; i++)\n      if (unique_id == 0x80000000 + unique[i].id)\n      {\n        adobe_coeff(\"Canon\", unique[i].t_model);\n        strcpy(model, unique[i].t_model);\n      }\n  }\n\n  if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n  {\n    for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n      if (unique_id == sonique[i].id)\n      {\n        adobe_coeff(\"Sony\", sonique[i].t_model);\n        strcpy(model, sonique[i].t_model);\n      }\n  }\n\n  if (!strncmp(make, \"Nikon\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n  /* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model, \"KAI-0340\") && find_green(16, 16, 3840, 5120) < 25)\n  {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy(model, \"C603\");\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n#else\n  /* Always 512 for arw2_load_raw */\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = (load_raw == &LibRaw::sony_arw2_load_raw) ? 512 : (128 << (tiff_bps - 12));\n#endif\n\n  if (is_foveon)\n  {\n    if (height * 2 < width)\n      pixel_aspect = 0.5;\n    if (height > width)\n      pixel_aspect = 2;\n    filters = 0;\n  }\n  else if (!strncmp(make, \"Pentax\", 6) && !strncmp(model, \"K-1\", 3))\n  {\n    top_margin = 18;\n    height = raw_height - top_margin;\n    if (raw_width == 7392)\n    {\n      left_margin = 6;\n      width = 7376;\n    }\n  }\n  else if (!strncmp(make, \"Canon\", 5) && tiff_bps == 15)\n  {\n    switch (width)\n    {\n    case 3344:\n      width -= 66;\n    case 3872:\n      width -= 6;\n    }\n    if (height > width)\n    {\n      SWAP(height, width);\n      SWAP(raw_height, raw_width);\n    }\n    if (width == 7200 && height == 3888)\n    {\n      raw_width = width = 6480;\n      raw_height = height = 4320;\n    }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot 600\"))\n  {\n    height = 613;\n    width = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot A5\") || !strcmp(model, \"PowerShot A5 Zoom\"))\n  {\n    height = 773;\n    width = 960;\n    raw_width = 992;\n    pixel_aspect = 256 / 235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot A50\"))\n  {\n    height = 968;\n    width = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot Pro70\"))\n  {\n    height = 1024;\n    width = 1552;\n    filters = 0x1e4b4e1b;\n  canon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  }\n  else if (!strcmp(model, \"PowerShot Pro90 IS\") || !strcmp(model, \"PowerShot G1\"))\n  {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  }\n  else if (!strcmp(model, \"PowerShot A610\"))\n  {\n    if (canon_s2is())\n      strcpy(model + 10, \"S2 IS\");\n  }\n  else if (!strcmp(model, \"PowerShot SX220 HS\"))\n  {\n    mask[1][3] = -4;\n    top_margin = 16;\n    left_margin = 92;\n  }\n  else if (!strcmp(model, \"PowerShot S120\"))\n  {\n    raw_width = 4192;\n    raw_height = 3062;\n    width = 4022;\n    height = 3016;\n    mask[0][0] = top_margin = 31;\n    mask[0][2] = top_margin + height;\n    left_margin = 120;\n    mask[0][1] = 23;\n    mask[0][3] = 72;\n  }\n  else if (!strcmp(model, \"PowerShot G16\"))\n  {\n    mask[0][0] = 0;\n    mask[0][2] = 80;\n    mask[0][1] = 0;\n    mask[0][3] = 16;\n    top_margin = 29;\n    left_margin = 120;\n    width = raw_width - left_margin - 48;\n    height = raw_height - top_margin - 14;\n  }\n  else if (!strcmp(model, \"PowerShot SX50 HS\"))\n  {\n    top_margin = 17;\n  }\n  else if (!strcmp(model, \"EOS D2000C\"))\n  {\n    filters = 0x61616161;\n    if (!black)\n      black = curve[200];\n  }\n  else if (!strcmp(model, \"D1\"))\n  {\n    cam_mul[0] *= 256 / 527.0;\n    cam_mul[2] *= 256 / 317.0;\n  }\n  else if (!strcmp(model, \"D1X\"))\n  {\n    width -= 4;\n    pixel_aspect = 0.5;\n  }\n  else if (!strcmp(model, \"D40X\") || !strcmp(model, \"D60\") || !strcmp(model, \"D80\") || !strcmp(model, \"D3000\"))\n  {\n    height -= 3;\n    width -= 4;\n  }\n  else if (!strcmp(model, \"D3\") || !strcmp(model, \"D3S\") || !strcmp(model, \"D700\"))\n  {\n    width -= 4;\n    left_margin = 2;\n  }\n  else if (!strcmp(model, \"D3100\"))\n  {\n    width -= 28;\n    left_margin = 6;\n  }\n  else if (!strcmp(model, \"D5000\") || !strcmp(model, \"D90\"))\n  {\n    width -= 42;\n  }\n  else if (!strcmp(model, \"D5100\") || !strcmp(model, \"D7000\") || !strcmp(model, \"COOLPIX A\"))\n  {\n    width -= 44;\n  }\n  else if (!strcmp(model, \"D3200\") || !strncmp(model, \"D6\", 2) || !strncmp(model, \"D800\", 4))\n  {\n    width -= 46;\n  }\n  else if (!strcmp(model, \"D4\") || !strcmp(model, \"Df\"))\n  {\n    width -= 52;\n    left_margin = 2;\n  }\n  else if (!strcmp(model, \"D500\"))\n  {\n    // Empty - to avoid width-1 below\n  }\n  else if (!strncmp(model, \"D40\", 3) || !strncmp(model, \"D50\", 3) || !strncmp(model, \"D70\", 3))\n  {\n    width--;\n  }\n  else if (!strcmp(model, \"D100\"))\n  {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  }\n  else if (!strcmp(model, \"D200\"))\n  {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  }\n  else if (!strncmp(model, \"D2H\", 3))\n  {\n    left_margin = 6;\n    width -= 14;\n  }\n  else if (!strncmp(model, \"D2X\", 3))\n  {\n    if (width == 3264)\n      width -= 32;\n    else\n      width -= 8;\n  }\n  else if (!strncmp(model, \"D300\", 4))\n  {\n    width -= 32;\n  }\n  else if (!strncmp(make, \"Nikon\", 5) && raw_width == 4032)\n  {\n    if (!strcmp(model, \"COOLPIX P7700\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7700\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P7800\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7800\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P340\"))\n      load_flags = 0;\n  }\n  else if (!strncmp(model, \"COOLPIX P\", 9) && raw_width != 4032)\n  {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed == 0) && !strstr(software, \"V1.2\"))\n      black = 255;\n  }\n  else if (!strncmp(model, \"COOLPIX B700\", 12))\n  {\n    load_flags = 24;\n    black = 200;\n  }\n  else if (!strncmp(model, \"1 \", 2))\n  {\n    height -= 2;\n  }\n  else if (fsize == 1581060)\n  {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  }\n  else if (fsize == 3178560)\n  {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  }\n  else if (fsize == 4771840)\n  {\n    if (!timestamp && nikon_e995())\n      strcpy(model, \"E995\");\n    if (strcmp(model, \"E995\"))\n    {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  }\n  else if (fsize == 2940928)\n  {\n    if (!timestamp && !nikon_e2100())\n      strcpy(model, \"E2500\");\n    if (!strcmp(model, \"E2500\"))\n    {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  }\n  else if (fsize == 4775936)\n  {\n    if (!timestamp)\n      nikon_3700();\n    if (model[0] == 'E' && atoi(model + 1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model, \"Optio 33WR\"))\n    {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O')\n    {\n      i = find_green(12, 32, 1188864, 3576832);\n      c = find_green(12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c))\n      {\n        SWAP(i, c);\n        load_flags = 24;\n      }\n      if (i < 0)\n        filters = 0x61616161;\n    }\n  }\n  else if (fsize == 5869568)\n  {\n    if (!timestamp && minolta_z2())\n    {\n      strcpy(make, \"Minolta\");\n      strcpy(model, \"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24 * (make[0] == 'M');\n  }\n  else if (fsize == 6291456)\n  {\n    fseek(ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d)\n    {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy(make, \"ISG\");\n      model[0] = 0;\n    }\n  }\n  else if (!strncmp(make, \"Fujifilm\", 8))\n  {\n    if (!strcmp(model, \"X-A3\") || !strcmp(model, \"X-A10\"))\n    {\n      left_margin = 0;\n      top_margin = 0;\n      width = raw_width;\n      height = raw_height;\n    }\n    if (!strcmp(model + 7, \"S2Pro\"))\n    {\n      strcpy(model, \"S2Pro\");\n      height = 2144;\n      width = 2880;\n      flip = 6;\n    }\n    else if (load_raw != &CLASS packed_load_raw && strncmp(model, \"X-\", 2) && filters >=1000) // Bayer and not X-models\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width) >> 2 << 1;\n    if (width == 2848 || width == 3664)\n      filters = 0x16161616;\n    if (width == 4032 || width == 4952)\n      left_margin = 0;\n    if (width == 3328 && (width -= 66))\n      left_margin = 34;\n    if (width == 4936)\n      left_margin = 4;\n    if (width == 6032)\n      left_margin = 0;\n    if (!strcmp(model, \"HS50EXR\") || !strcmp(model, \"F900EXR\"))\n    {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if (!strcmp(model, \"GFX 50S\"))\n    {\n      left_margin = 0;\n      top_margin = 0;\n    }\n    if (!strcmp(model, \"S5500\"))\n    {\n      height -= (top_margin = 6);\n    }\n    if (fuji_layout)\n      raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36)((char *)xtrans)[c] = xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];\n  }\n  else if (!strcmp(model, \"KD-400Z\"))\n  {\n    height = 1712;\n    width = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  }\n  else if (!strcmp(model, \"KD-510Z\"))\n  {\n    goto konica_510z;\n  }\n  else if (!strncasecmp(make, \"Minolta\", 7))\n  {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model, \"DiMAGE A\", 8))\n    {\n      if (!strcmp(model, \"DiMAGE A200\"))\n        filters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"ALPHA\", 5) || !strncmp(model, \"DYNAX\", 5) || !strncmp(model, \"MAXXUM\", 6))\n    {\n      sprintf(model + 20, \"DYNAX %-10s\", model + 6 + (model[0] == 'M'));\n      adobe_coeff(make, model + 20);\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"DiMAGE G\", 8))\n    {\n      if (model[8] == '4')\n      {\n        height = 1716;\n        width = 2304;\n      }\n      else if (model[8] == '5')\n      {\n      konica_510z:\n        height = 1956;\n        width = 2607;\n        raw_width = 2624;\n      }\n      else if (model[8] == '6')\n      {\n        height = 2136;\n        width = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\n    konica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  }\n  else if (!strcmp(model, \"*ist D\"))\n  {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  }\n  else if (!strcmp(model, \"*ist DS\"))\n  {\n    height -= 2;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 4704)\n  {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && !strcmp(model, \"NX3000\"))\n  {\n    top_margin = 38;\n    left_margin = 92;\n    width = 5456;\n    height = 3634;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_height == 3714)\n  {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5632)\n  {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12)\n      load_flags = 80;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5664)\n  {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 6496)\n  {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n      black = 1 << (tiff_bps - 7);\n  }\n  else if (!strcmp(model, \"EX1\"))\n  {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682)\n    {\n      height -= 10;\n      width -= 46;\n      top_margin = 8;\n    }\n  }\n  else if (!strcmp(model, \"WB2000\"))\n  {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718)\n    {\n      height -= 28;\n      width -= 56;\n      top_margin = 8;\n    }\n  }\n  else if (strstr(model, \"WB550\"))\n  {\n    strcpy(model, \"WB550\");\n  }\n  else if (!strcmp(model, \"EX2F\"))\n  {\n    height = 3030;\n    width = 4040;\n    top_margin = 15;\n    left_margin = 24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  else if (!strcmp(model, \"STV680 VGA\"))\n  {\n    black = 16;\n  }\n  else if (!strcmp(model, \"N95\"))\n  {\n    height = raw_height - (top_margin = 2);\n  }\n  else if (!strcmp(model, \"640x480\"))\n  {\n    gamma_curve(0.45, 4.5, 1, 255);\n  }\n  else if (!strncmp(make, \"Hasselblad\", 10))\n  {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262)\n    {\n      height = 5444;\n      width = 7248;\n      top_margin = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if (!strncasecmp(model, \"H3D\", 3))\n      {\n        adobe_coeff(\"Hasselblad\", \"H3DII-39\");\n        strcpy(model, \"H3DII-39\");\n      }\n    }\n    else if (raw_width == 12000) // H6D 100c, A6D 100c\n    {\n      left_margin = 64;\n      width = 11608;\n      top_margin = 108;\n      height = raw_height - top_margin;\n      adobe_coeff(\"Hasselblad\", \"H6D-100c\");\n    }\n    else if (raw_width == 7410 || raw_width == 8282)\n    {\n      height -= 84;\n      width -= 82;\n      top_margin = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\", \"H4D-40\");\n      strcpy(model, \"H4D-40\");\n    }\n    else if (raw_width == 8384) // X1D\n    {\n      top_margin = 96;\n      height -= 96;\n      left_margin = 48;\n      width -= 106;\n      adobe_coeff(\"Hasselblad\", \"X1D\");\n      maximum = 0xffff;\n      tiff_bps = 16;\n    }\n    else if (raw_width == 9044)\n    {\n      if (black > 500)\n      {\n        top_margin = 12;\n        left_margin = 44;\n        width = 8956;\n        height = 6708;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H4D-60\");\n        strcpy(model, \"H4D-60\");\n        black = 512;\n      }\n      else\n      {\n        height = 6716;\n        width = 8964;\n        top_margin = 8;\n        left_margin = 40;\n        black += load_flags = 256;\n        maximum = 0x8101;\n        strcpy(model, \"H3DII-60\");\n      }\n    }\n    else if (raw_width == 4090)\n    {\n      strcpy(model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n    else if (raw_width == 8282 && raw_height == 6240)\n    {\n      if (!strncasecmp(model, \"H5D\", 3))\n      {\n        /* H5D 50*/\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        black = 256;\n        strcpy(model, \"H5D-50\");\n      }\n      else if (!strncasecmp(model, \"H3D\", 3))\n      {\n        black = 0;\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H3D-50\");\n        strcpy(model, \"H3D-50\");\n      }\n    }\n    else if (raw_width == 8374 && raw_height == 6304)\n    {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model, \"H5D-50c\");\n    }\n    if (tiff_samples > 1)\n    {\n      is_raw = tiff_samples + 1;\n      if (!shot_select && !half_size)\n        filters = 0;\n    }\n  }\n  else if (!strncmp(make, \"Sinar\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size)\n      filters = 0;\n    maximum = 0x3fff;\n  }\n  else if (!strncmp(make, \"Leaf\", 4))\n  {\n    maximum = 0x3fff;\n    fseek(ifp, data_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1)\n      filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height)\n    {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048)\n    {\n      if (tiff_samples == 1)\n      {\n        filters = 1;\n        strcpy(cdesc, \"RBTG\");\n        strcpy(model, \"CatchLight\");\n        top_margin = 8;\n        left_margin = 18;\n        height = 2032;\n        width = 2016;\n      }\n      else\n      {\n        strcpy(model, \"DCB2\");\n        top_margin = 10;\n        left_margin = 16;\n        height = 2028;\n        width = 2022;\n      }\n    }\n    else if (width + height == 3144 + 2060)\n    {\n      if (!model[0])\n        strcpy(model, \"Cantare\");\n      if (width > height)\n      {\n        top_margin = 6;\n        left_margin = 32;\n        height = 2048;\n        width = 3072;\n        filters = 0x61616161;\n      }\n      else\n      {\n        left_margin = 6;\n        top_margin = 32;\n        width = 2048;\n        height = 3072;\n        filters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V')\n        filters = 0;\n      else\n        is_raw = tiff_samples;\n    }\n    else if (width == 2116)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    }\n    else if (width == 3171)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  }\n  else if (!strncmp(make, \"Leica\", 5) || !strncmp(make, \"Panasonic\", 9) || !strncasecmp(make, \"YUNEEC\", 6))\n  {\n\n    if (raw_width > 0 && ((flen - data_offset) / (raw_width * 8 / 7) == raw_height))\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw)\n    {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height)\n      height = raw_height;\n    for (i = 0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1])\n      {\n        left_margin = pana[i][2];\n        top_margin = pana[i][3];\n        width += pana[i][4];\n        height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"[((filters - 1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  }\n  else if (!strcmp(model, \"C770UZ\"))\n  {\n    height = 1718;\n    width = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  }\n  else if (!strncmp(make, \"Olympus\", 7))\n  {\n    height += height & 1;\n    if (exif_cfa)\n      filters = exif_cfa;\n    if (width == 4100)\n      width -= 4;\n    if (width == 4080)\n      width -= 24;\n    if (width == 9280)\n    {\n      width -= 6;\n      height -= 6;\n    }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model, \"E-300\") || !strcmp(model, \"E-500\"))\n    {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw)\n      {\n        maximum = 0xfc3;\n        memset(cblack, 0, sizeof cblack);\n      }\n    }\n    else if (!strcmp(model, \"STYLUS1\"))\n    {\n      width -= 14;\n      maximum = 0xfff;\n    }\n    else if (!strcmp(model, \"E-330\"))\n    {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n        maximum = 0xf79;\n    }\n    else if (!strcmp(model, \"SP550UZ\"))\n    {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width = 640;\n    }\n    else if (!strcmp(model, \"TG-4\"))\n    {\n      width -= 16;\n    }\n    else if (!strcmp(model, \"TG-5\"))\n    {\n      width -= 26;\n    }\n  }\n  else if (!strcmp(model, \"N Digital\"))\n  {\n    height = 2047;\n    width = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strcmp(model, \"DSC-F828\"))\n  {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy(cdesc, \"RGBE\");\n  }\n  else if (!strcmp(model, \"DSC-V3\"))\n  {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 3984)\n  {\n    width = 3925;\n    order = 0x4d4d;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4288)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(make, \"Sony\") && raw_width == 4600)\n  {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4928)\n  {\n    if (height < 3280)\n      width -= 8;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 5504)\n  { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 6048)\n  {\n    width -= 24;\n    if (strstr(model, \"RX1\") || strstr(model, \"A99\"))\n      width -= 6;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 7392)\n  {\n    width -= 30;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 8000)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(model, \"DSLR-A100\"))\n  {\n    if (width == 3880)\n    {\n      height--;\n      width = ++raw_width;\n    }\n    else\n    {\n      height -= 4;\n      width -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strcmp(model, \"PIXL\"))\n  {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve(0, 7, 1, 255);\n  }\n  else if (!strcmp(model, \"C603\") || !strcmp(model, \"C330\") || !strcmp(model, \"12MP\"))\n  {\n    order = 0x4949;\n    if (filters && data_offset)\n    {\n      fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts(curve, 256);\n    }\n    else\n      gamma_curve(0, 3.875, 1, 255);\n    load_raw = filters ? &CLASS eight_bit_load_raw\n                       : strcmp(model, \"C330\") ? &CLASS kodak_c603_load_raw : &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  }\n  else if (!strncasecmp(model, \"EasyShare\", 9))\n  {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strncasecmp(make, \"Kodak\", 5))\n  {\n    if (filters == UINT_MAX)\n      filters = 0x61616161;\n    if (!strncmp(model, \"NC2000\", 6) || !strncmp(model, \"EOSDCS\", 6) || !strncmp(model, \"DCS4\", 4))\n    {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ')\n        model[6] = 0;\n      if (!strcmp(model, \"DCS460A\"))\n        goto bw;\n    }\n    else if (!strcmp(model, \"DCS660M\"))\n    {\n      black = 214;\n      goto bw;\n    }\n    else if (!strcmp(model, \"DCS760M\"))\n    {\n    bw:\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model + 4, \"20X\"))\n      strcpy(cdesc, \"MYCY\");\n    if (strstr(model, \"DC25\"))\n    {\n      strcpy(model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model, \"DC2\", 3))\n    {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000)\n      {\n        raw_width = 256;\n        width = 249;\n        pixel_aspect = (4.0 * height) / (3.0 * width);\n      }\n      else\n      {\n        raw_width = 512;\n        width = 501;\n        pixel_aspect = (493.0 * height) / (373.0 * width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    }\n    else if (!strcmp(model, \"40\"))\n    {\n      strcpy(model, \"DC40\");\n      height = 512;\n      width = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    }\n    else if (strstr(model, \"DC50\"))\n    {\n      strcpy(model, \"DC50\");\n      height = 512;\n      width = 768;\n      iso_speed = 84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    }\n    else if (strstr(model, \"DC120\"))\n    {\n      strcpy(model, \"DC120\");\n      raw_height = height = 976;\n      raw_width = width = 848;\n      iso_speed = 160;\n      pixel_aspect = height / 0.75 / width;\n      load_raw = tiff_compress == 7 ? &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    }\n    else if (!strcmp(model, \"DCS200\"))\n    {\n      thumb_height = 128;\n      thumb_width = 192;\n      thumb_offset = 6144;\n      thumb_misc = 360;\n      iso_speed = 140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  }\n  else if (!strcmp(model, \"Fotoman Pixtura\"))\n  {\n    height = 512;\n    width = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  }\n  else if (!strncmp(model, \"QuickTake\", 9))\n  {\n    if (head[5])\n      strcpy(model + 10, \"200\");\n    fseek(ifp, 544, SEEK_SET);\n    height = get2();\n    width = get2();\n    data_offset = (get4(), get2()) == 30 ? 738 : 736;\n    if (height > width)\n    {\n      SWAP(height, width);\n      fseek(ifp, data_offset - 6, SEEK_SET);\n      flip = ~get2() & 3 ? 5 : 6;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strncmp(make, \"Rollei\", 6) && !load_raw)\n  {\n    switch (raw_width)\n    {\n    case 1316:\n      height = 1030;\n      width = 1300;\n      top_margin = 1;\n      left_margin = 6;\n      break;\n    case 2568:\n      height = 1960;\n      width = 2560;\n      top_margin = 2;\n      left_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model, \"GRAS-50S5C\"))\n  {\n    height = 2048;\n    width = 2440;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x49494949;\n    order = 0x4949;\n    maximum = 0xfffC;\n  }\n  else if (!strcmp(model, \"BB-500CL\"))\n  {\n    height = 2058;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"BB-500GE\"))\n  {\n    height = 2058;\n    width = 2456;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"SVS625CL\"))\n  {\n    height = 2050;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1\n      /* alloc in unpack() may be fooled by size adjust */\n      || ((int)width + (int)left_margin > 65535) || ((int)height + (int)top_margin > 65535))\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if (!model[0])\n    sprintf(model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX)\n    filters = 0x94949494;\n  if (thumb_offset && !thumb_height)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      thumb_width = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (dng_version) /* Override black level by DNG tags */\n  {\n    /* copy DNG data from per-IFD field to color.dng */\n    int iifd = 0; // Active IFD we'll show to user.\n    for (; iifd < tiff_nifds; iifd++)\n      if (tiff_ifd[iifd].offset == data_offset) // found\n        break;\n    int pifd = -1;\n    for (int ii = 0; ii < tiff_nifds; ii++)\n      if (tiff_ifd[ii].offset == thumb_offset) // found\n      {\n        pifd = ii;\n        break;\n      }\n\n#define CFAROUND(value, filters) filters ? (filters >= 1000 ? ((value + 1) / 2) * 2 : ((value + 5) / 6) * 6) : value\n\n#define IFDCOLORINDEX(ifd, subset, bit)                                                                                \\\n  (tiff_ifd[ifd].dng_color[subset].parsedfields & bit) ? ifd                                                           \\\n                                                       : ((tiff_ifd[0].dng_color[subset].parsedfields & bit) ? 0 : -1)\n\n#define IFDLEVELINDEX(ifd, bit)                                                                                        \\\n  (tiff_ifd[ifd].dng_levels.parsedfields & bit) ? ifd : ((tiff_ifd[0].dng_levels.parsedfields & bit) ? 0 : -1)\n\n#define COPYARR(to, from) memmove(&to, &from, sizeof(from))\n\n    if (iifd < tiff_nifds)\n    {\n      int sidx;\n      // Per field, not per structure\n\n      if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP)\n      {\n        sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPORIGIN);\n        int sidx2 = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPSIZE);\n        if (sidx >= 0 && sidx == sidx2 && tiff_ifd[sidx].dng_levels.default_crop[2] > 0 &&\n            tiff_ifd[sidx].dng_levels.default_crop[3] > 0)\n        {\n          int lm = tiff_ifd[sidx].dng_levels.default_crop[0];\n          int lmm = CFAROUND(lm, filters);\n          int tm = tiff_ifd[sidx].dng_levels.default_crop[1];\n          int tmm = CFAROUND(tm, filters);\n          int ww = tiff_ifd[sidx].dng_levels.default_crop[2];\n          int hh = tiff_ifd[sidx].dng_levels.default_crop[3];\n          if (lmm > lm)\n            ww -= (lmm - lm);\n          if (tmm > tm)\n            hh -= (tmm - tm);\n          if (left_margin + lm + ww <= raw_width && top_margin + tm + hh <= raw_height)\n          {\n            left_margin += lmm;\n            top_margin += tmm;\n            width = ww;\n            height = hh;\n          }\n        }\n      }\n      if (!(imgdata.color.dng_color[0].parsedfields & LIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)\n      {\n        sidx = IFDCOLORINDEX(iifd, 0, LIBRAW_DNGFM_FORWARDMATRIX);\n        if (sidx >= 0)\n          COPYARR(imgdata.color.dng_color[0].forwardmatrix, tiff_ifd[sidx].dng_color[0].forwardmatrix);\n      }\n      if (!(imgdata.color.dng_color[1].parsedfields & LIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)\n      {\n        sidx = IFDCOLORINDEX(iifd, 1, LIBRAW_DNGFM_FORWARDMATRIX);\n        if (sidx >= 0)\n          COPYARR(imgdata.color.dng_color[1].forwardmatrix, tiff_ifd[sidx].dng_color[1].forwardmatrix);\n      }\n      for (int ss = 0; ss < 2; ss++)\n      {\n        sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_COLORMATRIX);\n        if (sidx >= 0)\n          COPYARR(imgdata.color.dng_color[ss].colormatrix, tiff_ifd[sidx].dng_color[ss].colormatrix);\n\n        sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_CALIBRATION);\n        if (sidx >= 0)\n          COPYARR(imgdata.color.dng_color[ss].calibration, tiff_ifd[sidx].dng_color[ss].calibration);\n\n        sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_ILLUMINANT);\n        if (sidx >= 0)\n          imgdata.color.dng_color[ss].illuminant = tiff_ifd[sidx].dng_color[ss].illuminant;\n      }\n      // Levels\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ANALOGBALANCE);\n      if (sidx >= 0)\n        COPYARR(imgdata.color.dng_levels.analogbalance, tiff_ifd[sidx].dng_levels.analogbalance);\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_WHITE);\n      if (sidx >= 0)\n        COPYARR(imgdata.color.dng_levels.dng_whitelevel, tiff_ifd[sidx].dng_levels.dng_whitelevel);\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_BLACK);\n      if (sidx >= 0)\n      {\n        imgdata.color.dng_levels.dng_black = tiff_ifd[sidx].dng_levels.dng_black;\n        COPYARR(imgdata.color.dng_levels.dng_cblack, tiff_ifd[sidx].dng_levels.dng_cblack);\n      }\n      if (pifd >= 0)\n      {\n        sidx = IFDLEVELINDEX(pifd, LIBRAW_DNGFM_PREVIEWCS);\n        if (sidx >= 0)\n          imgdata.color.dng_levels.preview_colorspace = tiff_ifd[sidx].dng_levels.preview_colorspace;\n      }\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_OPCODE2);\n      if (sidx >= 0)\n        meta_offset = tiff_ifd[sidx].opcode2_offset;\n\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_LINTABLE);\n      INT64 linoff = -1;\n      int linlen = 0;\n      if (sidx >= 0)\n      {\n        linoff = tiff_ifd[sidx].lineartable_offset;\n        linlen = tiff_ifd[sidx].lineartable_len;\n      }\n\n      if (linoff >= 0 && linlen > 0)\n      {\n        INT64 pos = ftell(ifp);\n        fseek(ifp, linoff, SEEK_SET);\n        linear_table(linlen);\n        fseek(ifp, pos, SEEK_SET);\n      }\n      // Need to add curve too\n    }\n    /* Copy DNG black level to LibRaw's */\n    maximum = imgdata.color.dng_levels.dng_whitelevel[0];\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0, (sizeof(cblack) / sizeof(cblack[0])),\n                 (sizeof(imgdata.color.dng_levels.dng_cblack) / sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for (int i = 0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2)) && cmatrix[0][0] > 0.125)\n  {\n    memcpy(rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color)\n    adobe_coeff(make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if (imgdata.color.cam_xyz[0][0] < 0.01)\n    adobe_coeff(make, model, 1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color)\n      adobe_coeff(\"Apple\", \"Quicktake\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Clear erorneus fuji_width if not set through parse_fuji or for DNG\n  if (fuji_width && !dng_version && !(imgdata.process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED))\n    fuji_width = 0;\n#endif\n  if (fuji_width)\n  {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  }\n  else\n  {\n    if (raw_height < height)\n      raw_height = height;\n    if (raw_width < width)\n      raw_width = width;\n  }\n  if (!tiff_bps)\n    tiff_bps = 12;\n  if (!maximum)\n  {\n    maximum = (1 << tiff_bps) - 1;\n    if (maximum < 0x10000 && curve[maximum] > 0 && load_raw == &CLASS sony_arw2_load_raw)\n      maximum = curve[maximum];\n  }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if (raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_height > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw || load_raw == &CLASS lossy_dng_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy(cdesc, colors == 3 ? \"RGBG\" : \"GMCY\");\n  if (!raw_height)\n    raw_height = height;\n  if (!raw_width)\n    raw_width = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX)\n    flip = tiff_flip;\n  if (flip == UINT_MAX)\n    flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if (flip > 89 || flip < -89)\n  {\n    switch ((flip + 3600) % 360)\n    {\n    case 270:\n      flip = 5;\n      break;\n    case 180:\n      flip = 3;\n      break;\n    case 90:\n      flip = 6;\n      break;\n    }\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n}\n\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] = {\n      {0.436083, 0.385083, 0.143055}, {0.222507, 0.716888, 0.060608}, {0.013930, 0.097097, 0.714022}};\n  static const double rgb_rgb[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n  static const double adobe_rgb[3][3] = {\n      {0.715146, 0.284856, 0.000000}, {0.000000, 1.000000, 0.000000}, {0.000000, 0.041166, 0.958839}};\n  static const double wide_rgb[3][3] = {\n      {0.593087, 0.404710, 0.002206}, {0.095413, 0.843149, 0.061439}, {0.011621, 0.069091, 0.919288}};\n  static const double prophoto_rgb[3][3] = {\n      {0.529317, 0.330092, 0.140588}, {0.098368, 0.873465, 0.028169}, {0.016879, 0.117663, 0.865457}};\n  static const double aces_rgb[3][3] = {\n      {0.432996, 0.375380, 0.189317}, {0.089427, 0.816523, 0.102989}, {0.019165, 0.118150, 0.941914}};\n  static const double(*out_rgb[])[3] = {rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb};\n  static const char *name[] = {\"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\"};\n  static const unsigned phead[] = {1024, 0, 0x2100000,  0x6d6e7472, 0x52474220, 0x58595a20, 0,\n                                   0,    0, 0x61637370, 0,          0,          0x6e6f6e65, 0,\n                                   0,    0, 0,          0xf6d6,     0x10000,    0xd32d};\n  unsigned pbody[] = {10,         0x63707274, 0,  36, /* cprt */\n                      0x64657363, 0,          40,     /* desc */\n                      0x77747074, 0,          20,     /* wtpt */\n                      0x626b7074, 0,          20,     /* bkpt */\n                      0x72545243, 0,          14,     /* rTRC */\n                      0x67545243, 0,          14,     /* gTRC */\n                      0x62545243, 0,          14,     /* bTRC */\n                      0x7258595a, 0,          20,     /* rXYZ */\n                      0x6758595a, 0,          20,     /* gXYZ */\n                      0x6258595a, 0,          20};    /* bXYZ */\n  static const unsigned pwhite[] = {0xf351, 0x10000, 0x116cc};\n  unsigned pcurve[] = {0x63757276, 0, 1, 0x1000000};\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 0, 2);\n#endif\n  gamma_curve(gamm[0], gamm[1], 0, 0);\n  memcpy(out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode || output_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 || output_color < 1 || output_color > 6;\n#endif\n  if (!raw_color)\n  {\n    oprof = (unsigned *)calloc(phead[0], 1);\n    merror(oprof, \"convert_to_rgb()\");\n    memcpy(oprof, phead, sizeof phead);\n    if (output_color == 5)\n      oprof[4] = oprof[5];\n    oprof[0] = 132 + 12 * pbody[0];\n    for (i = 0; i < pbody[0]; i++)\n    {\n      oprof[oprof[0] / 4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i * 3 + 2] = oprof[0];\n      oprof[0] += (pbody[i * 3 + 3] + 3) & -4;\n    }\n    memcpy(oprof + 32, pbody, sizeof pbody);\n    oprof[pbody[5] / 4 + 2] = strlen(name[output_color - 1]) + 1;\n    memcpy((char *)oprof + pbody[8] + 8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256 / gamm[5] + 0.5) << 16;\n    for (i = 4; i < 7; i++)\n      memcpy((char *)oprof + pbody[i * 3 + 2], pcurve, sizeof pcurve);\n    pseudoinverse((double(*)[3])out_rgb[output_color - 1], inverse, 3);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < 3; j++)\n      {\n        for (num = k = 0; k < 3; k++)\n          num += xyzd50_srgb[i][k] * inverse[j][k];\n        oprof[pbody[j * 3 + 23] / 4 + i + 2] = num * 0x10000 + 0.5;\n      }\n    for (i = 0; i < phead[0] / 4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy((char *)oprof + pbody[2] + 8, \"auto-generated by dcraw\");\n    strcpy((char *)oprof + pbody[5] + 12, name[output_color - 1]);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (out_cam[i][j] = k = 0; k < 3; k++)\n          out_cam[i][j] += out_rgb[output_color - 1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, raw_color ? _(\"Building histograms...\\n\") : _(\"Converting to %s colorspace...\\n\"),\n            name[output_color - 1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset(histogram, 0, sizeof histogram);\n  for (img = image[0], row = 0; row < height; row++)\n    for (col = 0; col < width; col++, img += 4)\n    {\n      if (!raw_color)\n      {\n        out[0] = out[1] = out[2] = 0;\n        FORCC\n        {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        FORC3 img[c] = CLIP((int)out[c]);\n      }\n      else if (document_mode)\n        img[0] = img[fcol(row, col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color)\n    colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters)\n    colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 1, 2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort(*)[4])calloc(high, wide * sizeof *img);\n  merror(img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 0, 2);\n#endif\n\n  for (row = 0; row < high; row++)\n    for (col = 0; col < wide; col++)\n    {\n      ur = r = fuji_width + (row - col) * step;\n      uc = c = (row + col) * step;\n      if (ur > height - 2 || uc > width - 2)\n        continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur * width + uc;\n      for (i = 0; i < colors; i++)\n        img[row * wide + col][i] = (pix[0][i] * (1 - fc) + pix[1][i] * fc) * (1 - fr) +\n                                   (pix[width][i] * (1 - fc) + pix[width + 1][i] * fc) * fr;\n    }\n\n  free(image);\n  width = wide;\n  height = high;\n  image = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 1, 2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 0, 2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1)\n  {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(width, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = row = 0; row < newdim; row++, rc += pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c * width];\n      if (c + 1 < height)\n        pix1 += width * 4;\n      for (col = 0; col < width; col++, pix0 += 4, pix1 += 4)\n        FORCC img[row * width + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    height = newdim;\n  }\n  else\n  {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(height, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = col = 0; col < newdim; col++, rc += 1 / pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c + 1 < width)\n        pix1 += 4;\n      for (row = 0; row < height; row++, pix0 += width * 4, pix1 += width * 4)\n        FORCC img[row * newdim + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    width = newdim;\n  }\n  free(image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 1, 2);\n#endif\n}\n\nint CLASS flip_index(int row, int col)\n{\n  if (flip & 4)\n    SWAP(row, col);\n  if (flip & 2)\n    row = iheight - 1 - row;\n  if (flip & 1)\n    col = iwidth - 1 - col;\n  return row * iwidth + col;\n}\n\nvoid CLASS tiff_set(struct tiff_hdr *th, ushort *ntag, ushort tag, ushort type, int count, int val)\n{\n  struct libraw_tiff_tag *tt;\n  int c;\n\n  tt = (struct libraw_tiff_tag *)(ntag + 1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2)\n  {\n    count = strnlen((char *)th + val, count - 1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val + c];\n  }\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head(struct tiff_hdr *th, int full)\n{\n  int c, psize = 0;\n  struct tm *t;\n\n  memset(th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4 + c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy(th->t_desc, desc, 512);\n  strncpy(th->t_make, make, 64);\n  strncpy(th->t_model, model, 64);\n  strcpy(th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime(&timestamp);\n  sprintf(th->date, \"%04d:%02d:%02d %02d:%02d:%02d\", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour,\n          t->tm_min, t->tm_sec);\n  strncpy(th->t_artist, artist, 64);\n  if (full)\n  {\n    tiff_set(th, &th->ntag, 254, 4, 1, 0);\n    tiff_set(th, &th->ntag, 256, 4, 1, width);\n    tiff_set(th, &th->ntag, 257, 4, 1, height);\n    tiff_set(th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag - 1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set(th, &th->ntag, 259, 3, 1, 1);\n    tiff_set(th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set(th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set(th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set(th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full)\n  {\n    if (oprof)\n      psize = ntohl(oprof[0]);\n    tiff_set(th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set(th, &th->ntag, 277, 3, 1, colors);\n    tiff_set(th, &th->ntag, 278, 4, 1, height);\n    tiff_set(th, &th->ntag, 279, 4, 1, height * width * colors * output_bps / 8);\n  }\n  else\n    tiff_set(th, &th->ntag, 274, 3, 1, \"12435867\"[flip] - '0');\n  tiff_set(th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set(th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set(th, &th->ntag, 284, 3, 1, 1);\n  tiff_set(th, &th->ntag, 296, 3, 1, 2);\n  tiff_set(th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set(th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set(th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set(th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize)\n    tiff_set(th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set(th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set(th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set(th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set(th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1])\n  {\n    tiff_set(th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set(th, &th->ngps, 0, 1, 4, 0x202);\n    tiff_set(th, &th->ngps, 1, 2, 2, gpsdata[29]);\n    tiff_set(th, &th->ngps, 2, 5, 3, TOFF(th->gps[0]));\n    tiff_set(th, &th->ngps, 3, 2, 2, gpsdata[30]);\n    tiff_set(th, &th->ngps, 4, 5, 3, TOFF(th->gps[6]));\n    tiff_set(th, &th->ngps, 5, 1, 1, gpsdata[31]);\n    tiff_set(th, &th->ngps, 6, 5, 1, TOFF(th->gps[18]));\n    tiff_set(th, &th->ngps, 7, 5, 3, TOFF(th->gps[12]));\n    tiff_set(th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set(th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy(th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer(FILE *tfp, char *t_humb, int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc(0xff, tfp);\n  fputc(0xd8, tfp);\n  if (strcmp(t_humb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, tfp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, tfp);\n  }\n  fwrite(t_humb + 2, 1, t_humb_length - 2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp, thumb, thumb_length);\n  free(thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  fputc(0xff, ofp);\n  fputc(0xd8, ofp);\n  if (strcmp(thumb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, ofp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, ofp);\n  }\n  fwrite(thumb + 2, 1, thumb_length - 2, ofp);\n  free(thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white = 0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01; /* 99th percentile white level */\n#endif\n  if (fuji_width)\n    perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white = c = 0; c < colors; c++)\n    {\n      for (val = 0x2000, total = 0; --val > 32;)\n        if ((total += histogram[c][val]) > perc)\n          break;\n      if (t_white < val)\n        t_white = val;\n    }\n  gamma_curve(gamm[0], gamm[1], 2, (t_white << 3) / bright);\n  iheight = height;\n  iwidth = width;\n  if (flip & 4)\n    SWAP(height, width);\n  ppm = (uchar *)calloc(width, colors * output_bps / 8);\n  ppm2 = (ushort *)ppm;\n  merror(ppm, \"write_ppm_tiff()\");\n  if (output_tiff)\n  {\n    tiff_head(&th, 1);\n    fwrite(&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite(oprof, ntohl(oprof[0]), 1, ofp);\n  }\n  else if (colors > 3)\n    fprintf(ofp, \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", width, height, colors,\n            (1 << output_bps) - 1, cdesc);\n  else\n    fprintf(ofp, \"P%d\\n%d %d\\n%d\\n\", colors / 2 + 5, width, height, (1 << output_bps) - 1);\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, width);\n  for (row = 0; row < height; row++, soff += rstep)\n  {\n    for (col = 0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n        FORCC ppm[col * colors + c] = curve[image[soff][c]] >> 8;\n      else\n        FORCC ppm2[col * colors + c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab((char *)ppm2, (char *)ppm2, width * colors * 2);\n    fwrite(ppm, colors * output_bps / 8, width, ofp);\n  }\n  free(ppm);\n}\n", "/* Library for accessing X3F Files \n----------------------------------------------------------------\nBSD-style License\n----------------------------------------------------------------\n\n* Copyright (c) 2010, Roland Karlsson (roland@proxel.se)\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are met:\n*     * Redistributions of source code must retain the above copyright\n*       notice, this list of conditions and the following disclaimer.\n*     * Redistributions in binary form must reproduce the above copyright\n*       notice, this list of conditions and the following disclaimer in the\n*       documentation and/or other materials provided with the distribution.\n*     * Neither the name of the organization nor the\n*       names of its contributors may be used to endorse or promote products\n*       derived from this software without specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY ROLAND KARLSSON ''AS IS'' AND ANY\n* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n* DISCLAIMED. IN NO EVENT SHALL ROLAND KARLSSON BE LIABLE FOR ANY\n* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n  /* From X3F_IO.H */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include \"../libraw/libraw_datastream.h\"\n\n#define SIZE_UNIQUE_IDENTIFIER 16\n#define SIZE_WHITE_BALANCE 32\n#define SIZE_COLOR_MODE 32\n#define NUM_EXT_DATA_2_1 32\n#define NUM_EXT_DATA_3_0 64\n#define NUM_EXT_DATA NUM_EXT_DATA_3_0\n\n#define X3F_VERSION(MAJ,MIN) (uint32_t)(((MAJ)<<16) + MIN)\n#define X3F_VERSION_2_0 X3F_VERSION(2,0)\n#define X3F_VERSION_2_1 X3F_VERSION(2,1)\n#define X3F_VERSION_2_2 X3F_VERSION(2,2)\n#define X3F_VERSION_2_3 X3F_VERSION(2,3)\n#define X3F_VERSION_3_0 X3F_VERSION(3,0)\n#define X3F_VERSION_4_0 X3F_VERSION(4,0)\n\n/* Main file identifier */\n#define X3F_FOVb (uint32_t)(0x62564f46)\n/* Directory identifier */\n#define X3F_SECd (uint32_t)(0x64434553)\n/* Property section identifiers */\n#define X3F_PROP (uint32_t)(0x504f5250)\n#define X3F_SECp (uint32_t)(0x70434553)\n/* Image section identifiers */\n#define X3F_IMAG (uint32_t)(0x46414d49)\n#define X3F_IMA2 (uint32_t)(0x32414d49)\n#define X3F_SECi (uint32_t)(0x69434553)\n/* CAMF section identifiers */\n#define X3F_CAMF (uint32_t)(0x464d4143)\n#define X3F_SECc (uint32_t)(0x63434553)\n/* CAMF entry identifiers */\n#define X3F_CMbP (uint32_t)(0x50624d43)\n#define X3F_CMbT (uint32_t)(0x54624d43)\n#define X3F_CMbM (uint32_t)(0x4d624d43)\n#define X3F_CMb  (uint32_t)(0x00624d43)\n/* SDQ section identifiers ? - TODO */\n#define X3F_SPPA (uint32_t)(0x41505053)\n#define X3F_SECs (uint32_t)(0x73434553)\n\n#define X3F_IMAGE_THUMB_PLAIN       (uint32_t)(0x00020003)\n#define X3F_IMAGE_THUMB_HUFFMAN     (uint32_t)(0x0002000b)\n#define X3F_IMAGE_THUMB_JPEG        (uint32_t)(0x00020012)\n#define X3F_IMAGE_THUMB_SDQ         (uint32_t)(0x00020019)  /* SDQ ? - TODO */\n\n#define X3F_IMAGE_RAW_HUFFMAN_X530  (uint32_t)(0x00030005)\n#define X3F_IMAGE_RAW_HUFFMAN_10BIT (uint32_t)(0x00030006)\n#define X3F_IMAGE_RAW_TRUE          (uint32_t)(0x0003001e)\n#define X3F_IMAGE_RAW_MERRILL       (uint32_t)(0x0001001e)\n#define X3F_IMAGE_RAW_QUATTRO       (uint32_t)(0x00010023)\n#define X3F_IMAGE_RAW_SDQ           (uint32_t)(0x00010025)\n#define X3F_IMAGE_RAW_SDQH           (uint32_t)(0x00010027)\n#define X3F_IMAGE_RAW_SDQH2           (uint32_t)(0x00010029)\n\n#define X3F_IMAGE_HEADER_SIZE 28\n#define X3F_CAMF_HEADER_SIZE 28\n#define X3F_PROPERTY_LIST_HEADER_SIZE 24\n\ntypedef uint16_t utf16_t;\n\ntypedef int bool_t;\n\ntypedef enum x3f_extended_types_e {\n  X3F_EXT_TYPE_NONE=0,\n  X3F_EXT_TYPE_EXPOSURE_ADJUST=1,\n  X3F_EXT_TYPE_CONTRAST_ADJUST=2,\n  X3F_EXT_TYPE_SHADOW_ADJUST=3,\n  X3F_EXT_TYPE_HIGHLIGHT_ADJUST=4,\n  X3F_EXT_TYPE_SATURATION_ADJUST=5,\n  X3F_EXT_TYPE_SHARPNESS_ADJUST=6,\n  X3F_EXT_TYPE_RED_ADJUST=7,\n  X3F_EXT_TYPE_GREEN_ADJUST=8,\n  X3F_EXT_TYPE_BLUE_ADJUST=9,\n  X3F_EXT_TYPE_FILL_LIGHT_ADJUST=10\n} x3f_extended_types_t;\n\ntypedef struct x3f_property_s {\n  /* Read from file */\n  uint32_t name_offset;\n  uint32_t value_offset;\n\n  /* Computed */\n  utf16_t *name;\t\t/* 0x0000 terminated UTF 16 */\n  utf16_t *value;               /* 0x0000 terminated UTF 16 */\n  char *name_utf8;\t\t/* converted to UTF 8 */\n  char *value_utf8;          /* converted to UTF 8 */\n} x3f_property_t;\n\ntypedef struct x3f_property_table_s {\n  uint32_t size;\n  x3f_property_t *element;\n} x3f_property_table_t;\n\ntypedef struct x3f_property_list_s {\n  /* 2.0 Fields */\n  uint32_t num_properties;\n  uint32_t character_format;\n  uint32_t reserved;\n  uint32_t total_length;\n\n  x3f_property_table_t property_table;\n\n  void *data;\n\n  uint32_t data_size;\n\n} x3f_property_list_t;\n\ntypedef struct x3f_table8_s {\n  uint32_t size;\n  uint8_t *element;\n} x3f_table8_t;\n\ntypedef struct x3f_table16_s {\n  uint32_t size;\n  uint16_t *element;\n} x3f_table16_t;\n\ntypedef struct x3f_table32_s {\n  uint32_t size;\n  uint32_t *element;\n} x3f_table32_t;\n\ntypedef struct\n{\n  uint8_t *data;\t\t/* Pointer to actual image data */\n  void *buf;\t\t\t/* Pointer to allocated buffer for free() */\n  uint32_t rows;\n  uint32_t columns;\n  uint32_t channels;\n  uint32_t row_stride;\n} x3f_area8_t;\n\ntypedef struct\n{\n  uint16_t *data;\t\t/* Pointer to actual image data */\n  void *buf;\t\t\t/* Pointer to allocated buffer for free() */\n  uint32_t rows;\n  uint32_t columns;\n  uint32_t channels;\n  uint32_t row_stride;\n} x3f_area16_t;\n\n#define UNDEFINED_LEAF 0xffffffff\n\ntypedef struct x3f_huffnode_s {\n  struct x3f_huffnode_s *branch[2];\n  uint32_t leaf;\n} x3f_huffnode_t;\n\ntypedef struct x3f_hufftree_s {\n  uint32_t free_node_index; /* Free node index in huffman tree array */\n  x3f_huffnode_t *nodes;    /* Coding tree */\n} x3f_hufftree_t;\n\ntypedef struct x3f_true_huffman_element_s {\n  uint8_t code_size;\n  uint8_t code;\n} x3f_true_huffman_element_t;\n\ntypedef struct x3f_true_huffman_s {\n  uint32_t size;\n  x3f_true_huffman_element_t *element;\n} x3f_true_huffman_t;\n\n/* 0=bottom, 1=middle, 2=top */\n#define TRUE_PLANES 3\n\ntypedef struct x3f_true_s {\n  uint16_t seed[TRUE_PLANES];\t/* Always 512,512,512 */\n  uint16_t unknown;\t\t/* Always 0 */\n  x3f_true_huffman_t table;\t/* Huffman table - zero\n\t\t\t\t   terminated. size is the number of\n\t\t\t\t   leaves plus 1.*/\n\n  x3f_table32_t plane_size;\t/* Size of the 3 planes */\n  uint8_t *plane_address[TRUE_PLANES]; /* computed offset to the planes */\n  x3f_hufftree_t tree;\t\t/* Coding tree */\n  x3f_area16_t x3rgb16;\t\t/* 3x16 bit X3-RGB data */\n} x3f_true_t;\n\ntypedef struct x3f_quattro_s {\n  struct {\n    uint16_t columns;\n    uint16_t rows;\n  } plane[TRUE_PLANES];\n  uint32_t unknown;\n\n  bool_t quattro_layout;\n  x3f_area16_t top16;\t\t/* Container for the bigger top layer */\n} x3f_quattro_t;\n\ntypedef struct x3f_huffman_s {\n  x3f_table16_t mapping;   /* Value Mapping = X3F lossy compression */\n  x3f_table32_t table;          /* Coding Table */\n  x3f_hufftree_t tree;\t\t/* Coding tree */\n  x3f_table32_t row_offsets;    /* Row offsets */\n  x3f_area8_t rgb8;\t\t/* 3x8 bit RGB data */\n  x3f_area16_t x3rgb16;\t\t/* 3x16 bit X3-RGB data */\n} x3f_huffman_t;\n\ntypedef struct x3f_image_data_s {\n  /* 2.0 Fields */\n  /* ------------------------------------------------------------------ */\n  /* Known combinations of type and format are:\n     1-6, 2-3, 2-11, 2-18, 3-6 */\n  uint32_t type;                /* 1 = RAW X3 (SD1)\n                                   2 = thumbnail or maybe just RGB\n                                   3 = RAW X3 */\n  uint32_t format;              /* 3 = 3x8 bit pixmap\n                                   6 = 3x10 bit huffman with map table\n                                   11 = 3x8 bit huffman\n                                   18 = JPEG */\n  uint32_t type_format;         /* type<<16 + format */\n  /* ------------------------------------------------------------------ */\n\n  uint32_t columns;             /* width / row size in pixels */\n  uint32_t rows;                /* height */\n  uint32_t row_stride;          /* row size in bytes */\n\n  /* NULL if not used */\n  x3f_huffman_t *huffman;       /* Huffman help data */\n  x3f_true_t *tru;\t\t/* TRUE help data */\n  x3f_quattro_t *quattro;\t/* Quattro help data */\n\n  void *data;                   /* Take from file if NULL. Otherwise,\n                                   this is the actual data bytes in\n                                   the file. */\n  uint32_t data_size;\n\n} x3f_image_data_t;\n\ntypedef struct camf_dim_entry_s {\n  uint32_t size;\n  uint32_t name_offset;\n  uint32_t n; /* 0,1,2,3... */\n  char *name;\n} camf_dim_entry_t;\n\ntypedef enum {M_FLOAT, M_INT, M_UINT} matrix_type_t;\n\ntypedef struct camf_entry_s {\n  /* pointer into decoded data */\n  void *entry;\n\n  /* entry header */\n  uint32_t id;\n  uint32_t version;\n  uint32_t entry_size;\n  uint32_t name_offset;\n  uint32_t value_offset;\n\n  /* computed values */\n  char *name_address;\n  void *value_address;\n  uint32_t name_size;\n  uint32_t value_size;\n\n  /* extracted values for explicit CAMF entry types*/\n  uint32_t text_size;\n  char *text;\n\n  uint32_t property_num;\n  char **property_name;\n  uint8_t **property_value;\n\n  uint32_t matrix_dim;\n  camf_dim_entry_t *matrix_dim_entry;\n\n  /* Offset, pointer and size and type of raw data */\n  uint32_t matrix_type;\n  uint32_t matrix_data_off;\n  void *matrix_data;\n  uint32_t matrix_element_size;\n\n  /* Pointer and type of copied data */\n  matrix_type_t matrix_decoded_type;\n  void *matrix_decoded;\n\n  /* Help data to try to estimate element size */\n  uint32_t matrix_elements;\n  uint32_t matrix_used_space;\n  double matrix_estimated_element_size;\n\n} camf_entry_t;\n\ntypedef struct camf_entry_table_s {\n  uint32_t size;\n  camf_entry_t *element;\n} camf_entry_table_t;\n\ntypedef struct x3f_camf_typeN_s {\n  uint32_t val0;\n  uint32_t val1;\n  uint32_t val2;\n  uint32_t val3;\n} x3f_camf_typeN_t;\n\ntypedef struct x3f_camf_type2_s {\n  uint32_t reserved;\n  uint32_t infotype;\n  uint32_t infotype_version;\n  uint32_t crypt_key;\n} x3f_camf_type2_t;\n\ntypedef struct x3f_camf_type4_s {\n  uint32_t decoded_data_size;\n  uint32_t decode_bias;\n  uint32_t block_size;\n  uint32_t block_count;\n} x3f_camf_type4_t;\n\ntypedef struct x3f_camf_type5_s {\n  uint32_t decoded_data_size;\n  uint32_t decode_bias;\n  uint32_t unknown2;\n  uint32_t unknown3;\n} x3f_camf_type5_t;\n\ntypedef struct x3f_camf_s {\n\n  /* Header info */\n  uint32_t type;\n  union {\n    x3f_camf_typeN_t tN;\n    x3f_camf_type2_t t2;\n    x3f_camf_type4_t t4;\n    x3f_camf_type5_t t5;\n  };\n\n  /* The encrypted raw data */\n  void *data;\n  uint32_t data_size;\n\n  /* Help data for type 4 Huffman compression */\n  x3f_true_huffman_t table;\n  x3f_hufftree_t tree;\n  uint8_t *decoding_start;\n  uint32_t decoding_size;\n\n  /* The decrypted data */\n  void *decoded_data;\n  uint32_t decoded_data_size;\n\n  /* Pointers into the decrypted data */\n  camf_entry_table_t entry_table;\n} x3f_camf_t;\n\ntypedef struct x3f_directory_entry_header_s {\n  uint32_t identifier;        /* Should be \u00b4SECp\u00b4, \"SECi\", ... */\n  uint32_t version;           /* 0x00020001 is version 2.1  */\n  union {\n    x3f_property_list_t property_list;\n    x3f_image_data_t image_data;\n    x3f_camf_t camf;\n  } data_subsection;\n} x3f_directory_entry_header_t;\n\ntypedef struct x3f_directory_entry_s {\n  struct {\n    uint32_t offset;\n    uint32_t size;\n  } input, output;\n\n  uint32_t type;\n\n  x3f_directory_entry_header_t header;\n} x3f_directory_entry_t;\n\ntypedef struct x3f_directory_section_s {\n  uint32_t identifier;          /* Should be \u00b4SECd\u00b4 */\n  uint32_t version;             /* 0x00020001 is version 2.1  */\n\n  /* 2.0 Fields */\n  uint32_t num_directory_entries;\n  x3f_directory_entry_t *directory_entry;\n} x3f_directory_section_t;\n\ntypedef struct x3f_header_s {\n  /* 2.0 Fields */\n  uint32_t identifier;          /* Should be \u00b4FOVb\u00b4 */\n  uint32_t version;             /* 0x00020001 means 2.1 */\n  uint8_t unique_identifier[SIZE_UNIQUE_IDENTIFIER];\n  uint32_t mark_bits;\n  uint32_t columns;             /* Columns and rows ... */\n  uint32_t rows;                /* ... before rotation */\n  uint32_t rotation;            /* 0, 90, 180, 270 */\n\n  char white_balance[SIZE_WHITE_BALANCE]; /* Introduced in 2.1 */\n  char color_mode[SIZE_COLOR_MODE]; /* Introduced in 2.3 */\n\n  /* Introduced in 2.1 and extended from 32 to 64 in 3.0 */\n  uint8_t extended_types[NUM_EXT_DATA]; /* x3f_extended_types_t */\n  float extended_data[NUM_EXT_DATA]; /* 32 bits, but do type differ? */\n} x3f_header_t;\n\ntypedef struct x3f_info_s {\n  char *error;\n  struct {\n\tLibRaw_abstract_datastream *file;                 /* Use if more data is needed */\n  } input, output;\n} x3f_info_t;\n\ntypedef struct x3f_s {\n  x3f_info_t info;\n  x3f_header_t header;\n  x3f_directory_section_t directory_section;\n} x3f_t;\n\ntypedef enum x3f_return_e {\n  X3F_OK=0,\n  X3F_ARGUMENT_ERROR=1,\n  X3F_INFILE_ERROR=2,\n  X3F_OUTFILE_ERROR=3,\n  X3F_INTERNAL_ERROR=4\n} x3f_return_t;\n\nx3f_return_t x3f_delete(x3f_t *x3f);\n\n\n/* Hacky external flags                                                 */\n/* --------------------------------------------------------------------- */\n\n/* extern */ int legacy_offset = 0;\n/* extern */ bool_t auto_legacy_offset = 1;\n\n/* --------------------------------------------------------------------- */\n/* Huffman Decode Macros                                                 */\n/* --------------------------------------------------------------------- */\n\n#define HUF_TREE_MAX_LENGTH 27\n#define HUF_TREE_MAX_NODES(_leaves) ((HUF_TREE_MAX_LENGTH+1)*(_leaves))\n#define HUF_TREE_GET_LENGTH(_v) (((_v)>>27)&0x1f)\n#define HUF_TREE_GET_CODE(_v) ((_v)&0x07ffffff)\n\n/* --------------------------------------------------------------------- */\n/* Reading and writing - assuming little endian in the file              */\n/* --------------------------------------------------------------------- */\n\nstatic int x3f_get1(LibRaw_abstract_datastream *f)\n{\n\t/* Little endian file */\n\treturn f->get_char(); \n}\n\nstatic int  x3f_sget2 (uchar *s)\n{\n\treturn s[0] | s[1] << 8;\n}\n\nstatic int x3f_get2(LibRaw_abstract_datastream *f)\n{\n\tuchar str[2] = { 0xff,0xff };\n\tf->read (str, 1, 2);\n\treturn x3f_sget2(str);\n}\n\nunsigned x3f_sget4 (uchar *s)\n{\n\treturn s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n}\n\nunsigned x3f_get4(LibRaw_abstract_datastream *f)\n{\n\tuchar str[4] = { 0xff,0xff,0xff,0xff };\n\tf->read (str, 1, 4);\n\treturn x3f_sget4(str);\n}\n\n#define FREE(P) do { free(P); (P) = NULL; } while (0)\n\n#define PUT_GET_N(_buffer,_size,_file,_func)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint _left = _size;\t\t\t\t\t\t\t\\\n\t\twhile (_left != 0) {\t\t\t\t\t\t\\\n\t\tint _cur = _file->_func(_buffer,1,_left);\t\\\n\t\tif (_cur == 0) {\t\t\t\t\t\t\t\\\n\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\t\t\\\n\t\t\texit(1);\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t_left -= _cur;\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n} while(0)\n\n#define GET1(_v) do {(_v) = x3f_get1(I->input.file);} while (0)\n#define GET2(_v) do {(_v) = x3f_get2(I->input.file);} while (0)\n#define GET4(_v) do {(_v) = x3f_get4(I->input.file);} while (0)\n\n#define GET4F(_v)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\nunion {int32_t i; float f;} _tmp;\t\t\\\n\t_tmp.i = x3f_get4(I->input.file);\t\\\n\t(_v) = _tmp.f;\t\t\t\t\t\t\\\n\t} while (0)\n\n#define GETN(_v,_s) PUT_GET_N(_v,_s,I->input.file,read)\n\n#define GET_TABLE(_T, _GETX, _NUM,_TYPE)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\tint _i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t(_T).size = (_NUM);\t\t\t\t\t\t\t\t\\\n\t(_T).element = (_TYPE *)realloc((_T).element,\t\\\n\t(_NUM)*sizeof((_T).element[0]));\t\t\t\t\\\n\tfor (_i = 0; _i < (_T).size; _i++)\t\t\t\t\\\n\t_GETX((_T).element[_i]);\t\t\t\t\t\t\\\n\t} while (0)\n\n#define GET_PROPERTY_TABLE(_T, _NUM)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\tint _i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t(_T).size = (_NUM);\t\t\t\t\t\t\t\t\\\n\t(_T).element = (x3f_property_t *)realloc((_T).element,\t\\\n\t(_NUM)*sizeof((_T).element[0]));\t\t\t\t\\\n\tfor (_i = 0; _i < (_T).size; _i++) {\t\t\t\\\n\tGET4((_T).element[_i].name_offset);\t\t\t\t\\\n\tGET4((_T).element[_i].value_offset);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define GET_TRUE_HUFF_TABLE(_T)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\tint _i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t(_T).element = NULL;\t\t\t\t\t\t\t\\\n\tfor (_i = 0; ; _i++) {\t\t\t\t\t\t\t\\\n\t(_T).size = _i + 1;\t\t\t\t\t\t\t\t\\\n\t(_T).element = (x3f_true_huffman_element_t *)realloc((_T).element,\t\\\n\t(_i + 1)*sizeof((_T).element[0]));\t\t\t\t\\\n\tGET1((_T).element[_i].code_size);\t\t\t\t\\\n\tGET1((_T).element[_i].code);\t\t\t\t\t\\\n\tif ((_T).element[_i].code_size == 0) break;\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n/* --------------------------------------------------------------------- */\n/* Allocating Huffman tree help data                                   */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_huffman_tree(x3f_hufftree_t *HTP)\n{\n  free(HTP->nodes);\n}\n\nstatic void new_huffman_tree(x3f_hufftree_t *HTP, int bits)\n{\n  int leaves = 1<<bits;\n\n  HTP->free_node_index = 0;\n  HTP->nodes = (x3f_huffnode_t *)\n    calloc(1, HUF_TREE_MAX_NODES(leaves)*sizeof(x3f_huffnode_t));\n}\n\n/* --------------------------------------------------------------------- */\n/* Allocating TRUE engine RAW help data                                  */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_true(x3f_true_t **TRUP)\n{\n  x3f_true_t *TRU = *TRUP;\n\n  if (TRU == NULL) return;\n\n  FREE(TRU->table.element);\n  FREE(TRU->plane_size.element);\n  cleanup_huffman_tree(&TRU->tree);\n  FREE(TRU->x3rgb16.buf);\n\n  FREE(TRU);\n\n  *TRUP = NULL;\n}\n\nstatic x3f_true_t *new_true(x3f_true_t **TRUP)\n{\n  x3f_true_t *TRU = (x3f_true_t *)calloc(1, sizeof(x3f_true_t));\n\n  cleanup_true(TRUP);\n\n  TRU->table.size = 0;\n  TRU->table.element = NULL;\n  TRU->plane_size.size = 0;\n  TRU->plane_size.element = NULL;\n  TRU->tree.nodes = NULL;\n  TRU->x3rgb16.data = NULL;\n  TRU->x3rgb16.buf = NULL;\n\n  *TRUP = TRU;\n\n  return TRU;\n}\n\nstatic void cleanup_quattro(x3f_quattro_t **QP)\n{\n  x3f_quattro_t *Q = *QP;\n\n  if (Q == NULL) return;\n\n  FREE(Q->top16.buf);\n  FREE(Q);\n\n  *QP = NULL;\n}\n\nstatic x3f_quattro_t *new_quattro(x3f_quattro_t **QP)\n{\n  x3f_quattro_t *Q = (x3f_quattro_t *)calloc(1, sizeof(x3f_quattro_t));\n  int i;\n\n  cleanup_quattro(QP);\n\n  for (i=0; i<TRUE_PLANES; i++) {\n    Q->plane[i].columns = 0;\n    Q->plane[i].rows = 0;\n  }\n\n  Q->unknown = 0;\n\n  Q->top16.data = NULL;\n  Q->top16.buf = NULL;\n\n  *QP = Q;\n\n  return Q;\n}\n\n/* --------------------------------------------------------------------- */\n/* Allocating Huffman engine help data                                   */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_huffman(x3f_huffman_t **HUFP)\n{\n  x3f_huffman_t *HUF = *HUFP;\n\n  if (HUF == NULL) return;\n\n  FREE(HUF->mapping.element);\n  FREE(HUF->table.element);\n  cleanup_huffman_tree(&HUF->tree);\n  FREE(HUF->row_offsets.element);\n  FREE(HUF->rgb8.buf);\n  FREE(HUF->x3rgb16.buf);\n  FREE(HUF);\n\n  *HUFP = NULL;\n}\n\nstatic x3f_huffman_t *new_huffman(x3f_huffman_t **HUFP)\n{\n  x3f_huffman_t *HUF = (x3f_huffman_t *)calloc(1, sizeof(x3f_huffman_t));\n\n  cleanup_huffman(HUFP);\n\n  /* Set all not read data block pointers to NULL */\n  HUF->mapping.size = 0;\n  HUF->mapping.element = NULL;\n  HUF->table.size = 0;\n  HUF->table.element = NULL;\n  HUF->tree.nodes = NULL;\n  HUF->row_offsets.size = 0;\n  HUF->row_offsets.element = NULL;\n  HUF->rgb8.data = NULL;\n  HUF->rgb8.buf = NULL;\n  HUF->x3rgb16.data = NULL;\n  HUF->x3rgb16.buf = NULL;\n\n  *HUFP = HUF;\n\n  return HUF;\n}\n\n/* --------------------------------------------------------------------- */\n/* Creating a new x3f structure from file                                */\n/* --------------------------------------------------------------------- */\n\n/* extern */ x3f_t *x3f_new_from_file(LibRaw_abstract_datastream *infile)\n{\n\tif (!infile) return NULL;\n  \tINT64 fsize = infile->size();\n\tx3f_t *x3f = (x3f_t *)calloc(1, sizeof(x3f_t));\n\tx3f_info_t *I = NULL;\n\tx3f_header_t *H = NULL;\n\tx3f_directory_section_t *DS = NULL;\n\tint i, d;\n\n\tI = &x3f->info;\n\tI->error = NULL;\n\tI->input.file = infile;\n\tI->output.file = NULL;\n\n\n  /* Read file header */\n\tH = &x3f->header;\n\tinfile->seek(0, SEEK_SET);\n\tGET4(H->identifier);\n\n\tif (H->identifier != X3F_FOVb) {\n\t\tfree(x3f);\n\t\treturn NULL;\n\t}\n\n\tGET4(H->version);\n\tGETN(H->unique_identifier, SIZE_UNIQUE_IDENTIFIER);\n\t/* TODO: the meaning of the rest of the header for version >= 4.0 (Quattro) is unknown */\n\tif (H->version < X3F_VERSION_4_0) {\n\t\tGET4(H->mark_bits);\n\t\tGET4(H->columns);\n\t\tGET4(H->rows);\n\t\tGET4(H->rotation);\n\t\tif (H->version >= X3F_VERSION_2_1) {\n\t\t\tint num_ext_data =\n\t\t\t\tH->version >= X3F_VERSION_3_0 ? NUM_EXT_DATA_3_0 : NUM_EXT_DATA_2_1;\n\n\t\t\tGETN(H->white_balance, SIZE_WHITE_BALANCE);\n\t\t\tif (H->version >= X3F_VERSION_2_3)\n\t\t\t\tGETN(H->color_mode, SIZE_COLOR_MODE);\n\t\t\tGETN(H->extended_types, num_ext_data);\n\t\t\tfor (i = 0; i < num_ext_data; i++)\n\t\t\t\tGET4F(H->extended_data[i]);\n\t\t}\n\t}\n\n  /* Go to the beginning of the directory */\n  infile->seek(-4, SEEK_END);\n  infile->seek(x3f_get4(infile), SEEK_SET);\n\n  /* Read the directory header */\n  DS = &x3f->directory_section;\n  GET4(DS->identifier);\n  GET4(DS->version);\n  GET4(DS->num_directory_entries);\n\n  if (DS->num_directory_entries > 50)\n\t  goto _err; // too much direntries, most likely broken file\n\n  if (DS->num_directory_entries > 0) {\n    size_t size = DS->num_directory_entries * sizeof(x3f_directory_entry_t);\n    DS->directory_entry = (x3f_directory_entry_t *)calloc(1, size);\n  }\n\n  /* Traverse the directory */\n  for (d=0; d<DS->num_directory_entries; d++) {\n    x3f_directory_entry_t *DE = &DS->directory_entry[d];\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    uint32_t save_dir_pos;\n\n    /* Read the directory entry info */\n    GET4(DE->input.offset);\n    GET4(DE->input.size);\n\tif (DE->input.offset + DE->input.size > fsize * 2)\n\t\tgoto _err;\n\n    DE->output.offset = 0;\n    DE->output.size = 0;\n\n    GET4(DE->type);\n\n    /* Save current pos and go to the entry */\n    save_dir_pos = infile->tell();\n    infile->seek(DE->input.offset, SEEK_SET);\n\n    /* Read the type independent part of the entry header */\n    DEH = &DE->header;\n    GET4(DEH->identifier);\n    GET4(DEH->version);\n\n    /* NOTE - the tests below could be made on DE->type instead */\n\n    if (DEH->identifier == X3F_SECp) {\n      x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\t  if (!PL)\n\t\t  goto _err;\n      /* Read the property part of the header */\n      GET4(PL->num_properties);\n      GET4(PL->character_format);\n      GET4(PL->reserved);\n      GET4(PL->total_length);\n\n      /* Set all not read data block pointers to NULL */\n      PL->data = NULL;\n      PL->data_size = 0;\n    }\n\n    if (DEH->identifier == X3F_SECi) {\n      x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\t  if (!ID)\n\t\t  goto _err;\n      /* Read the image part of the header */\n      GET4(ID->type);\n      GET4(ID->format);\n      ID->type_format = (ID->type << 16) + (ID->format);\n      GET4(ID->columns);\n      GET4(ID->rows);\n      GET4(ID->row_stride);\n\n      /* Set all not read data block pointers to NULL */\n      ID->huffman = NULL;\n\n      ID->data = NULL;\n      ID->data_size = 0;\n    }\n\n    if (DEH->identifier == X3F_SECc) {\n      x3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\t  if (!CAMF)\n\t\t  goto _err;\n      /* Read the CAMF part of the header */\n      GET4(CAMF->type);\n      GET4(CAMF->tN.val0);\n      GET4(CAMF->tN.val1);\n      GET4(CAMF->tN.val2);\n      GET4(CAMF->tN.val3);\n\n      /* Set all not read data block pointers to NULL */\n      CAMF->data = NULL;\n      CAMF->data_size = 0;\n\n      /* Set all not allocated help pointers to NULL */\n      CAMF->table.element = NULL;\n      CAMF->table.size = 0;\n      CAMF->tree.nodes = NULL;\n      CAMF->decoded_data = NULL;\n      CAMF->decoded_data_size = 0;\n      CAMF->entry_table.element = NULL;\n      CAMF->entry_table.size = 0;\n    }\n\n    /* Reset the file pointer back to the directory */\n    infile->seek(save_dir_pos, SEEK_SET);\n  }\n\n  return x3f;\n_err:\n  if (x3f)\n  {\n\t  DS = &x3f->directory_section;\n\t  if (DS && DS->directory_entry)\n\t\t  free(DS->directory_entry);\n\t  free(x3f);\n  }\n  return NULL;\n\n}\n\n/* --------------------------------------------------------------------- */\n/* Clean up an x3f structure                                             */\n/* --------------------------------------------------------------------- */\n\nstatic void free_camf_entry(camf_entry_t *entry)\n{\n\tFREE(entry->property_name);\n\tFREE(entry->property_value);\n\tFREE(entry->matrix_decoded);\n\tFREE(entry->matrix_dim_entry);\n}\n\n/* extern */ x3f_return_t x3f_delete(x3f_t *x3f)\n{\n\tx3f_directory_section_t *DS;\n\tint d;\n\n\tif (x3f == NULL)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tDS = &x3f->directory_section;\n\tif (DS->num_directory_entries > 50)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tfor (d=0; d<DS->num_directory_entries; d++) {\n\t\tx3f_directory_entry_t *DE = &DS->directory_entry[d];\n\t\tx3f_directory_entry_header_t *DEH = &DE->header;\n\t\tif (DEH->identifier == X3F_SECp) {\n\t\t\tx3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\t\t\tif (PL)\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < PL->property_table.size; i++) {\n\t\t\t\t\tFREE(PL->property_table.element[i].name_utf8);\n\t\t\t\t\tFREE(PL->property_table.element[i].value_utf8);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFREE(PL->property_table.element);\n\t\t\tFREE(PL->data);\n\t\t}\n\n\t\tif (DEH->identifier == X3F_SECi) {\n\t\t\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\t\t\tif (ID)\n\t\t\t{\n\t\t\t\tcleanup_huffman(&ID->huffman);\n\t\t\t\tcleanup_true(&ID->tru);\n\t\t\t\tcleanup_quattro(&ID->quattro);\n\t\t\t\tFREE(ID->data);\n\t\t\t}\n\t\t}\n\n\t\tif (DEH->identifier == X3F_SECc) {\n\t\t\tx3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\t\t\tint i;\n\t\t\tif (CAMF)\n\t\t\t{\n\t\t\t\tFREE(CAMF->data);\n\t\t\t\tFREE(CAMF->table.element);\n\t\t\t\tcleanup_huffman_tree(&CAMF->tree);\n\t\t\t\tFREE(CAMF->decoded_data);\n\t\t\t\tfor (i = 0; i < CAMF->entry_table.size; i++) {\n\t\t\t\t\tfree_camf_entry(&CAMF->entry_table.element[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFREE(CAMF->entry_table.element);\n\t\t}\n\t}\n\n\tFREE(DS->directory_entry);\n\tFREE(x3f);\n\n\treturn X3F_OK;\n}\n\n/* --------------------------------------------------------------------- */\n/* Getting a reference to a directory entry                              */\n/* --------------------------------------------------------------------- */\n\n/* TODO: all those only get the first instance */\n\nstatic x3f_directory_entry_t *x3f_get(x3f_t *x3f,\n\tuint32_t type,\n\tuint32_t image_type)\n{\n\tx3f_directory_section_t *DS;\n\tint d;\n\n\tif (x3f == NULL) return NULL;\n\n\tDS = &x3f->directory_section;\n\n\tfor (d=0; d<DS->num_directory_entries; d++) {\n\t\tx3f_directory_entry_t *DE = &DS->directory_entry[d];\n\t\tx3f_directory_entry_header_t *DEH = &DE->header;\n\n\t\tif (DEH->identifier == type) {\n\t\t\tswitch (DEH->identifier) {\n\t\t\tcase X3F_SECi:\n\t\t\t\t{\n\t\t\t\t\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\t\t\t\t\tif (ID->type_format == image_type)\n\t\t\t\t\t\treturn DE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn DE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_raw(x3f_t *x3f)\n{\n\tx3f_directory_entry_t *DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_X530)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_10BIT)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_TRUE)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_MERRILL)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_QUATTRO)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQ)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH)) != NULL)\n\t\treturn DE;\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH2)) != NULL)\n\t\treturn DE;\n\n\treturn NULL;\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_plain(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_PLAIN);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_huffman(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_HUFFMAN);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_jpeg(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_JPEG);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_camf(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECc, 0);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_prop(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECp, 0);\n}\n\n/* For some obscure reason, the bit numbering is weird. It is\n   generally some kind of \"big endian\" style - e.g. the bit 7 is the\n   first in a byte and bit 31 first in a 4 byte int. For patterns in\n   the huffman pattern table, bit 27 is the first bit and bit 26 the\n   next one. */\n\n#define PATTERN_BIT_POS(_len, _bit) ((_len) - (_bit) - 1)\n#define MEMORY_BIT_POS(_bit) PATTERN_BIT_POS(8, _bit)\n\n/* --------------------------------------------------------------------- */\n/* Huffman Decode                                                        */\n/* --------------------------------------------------------------------- */\n\n/* Make the huffman tree */\n\n#ifdef DBG_PRNT\nstatic char *display_code(int length, uint32_t code, char *buffer)\n{\n  int i;\n\n  for (i=0; i<length; i++) {\n    int pos = PATTERN_BIT_POS(length, i);\n    buffer[i] = ((code>>pos)&1) == 0 ? '0' : '1';\n  }\n\n  buffer[i] = 0;\n\n  return buffer;\n}\n#endif\n\nstatic x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n\n  tree->free_node_index++;\n\n  return t;\n}\n\nstatic void add_code_to_tree(x3f_hufftree_t *tree,\n                             int length, uint32_t code, uint32_t value)\n{\n  int i;\n\n  x3f_huffnode_t *t = tree->nodes;\n\n  for (i=0; i<length; i++) {\n    int pos = PATTERN_BIT_POS(length, i);\n    int bit = (code>>pos)&1;\n    x3f_huffnode_t *t_next = t->branch[bit];\n\n    if (t_next == NULL)\n      t_next = t->branch[bit] = new_node(tree);\n\n    t = t_next;\n  }\n\n  t->leaf = value;\n}\n\nstatic void populate_true_huffman_tree(x3f_hufftree_t *tree,\n\t\t\t\t       x3f_true_huffman_t *table)\n{\n  int i;\n\n  new_node(tree);\n\n  for (i=0; i<table->size; i++) {\n    x3f_true_huffman_element_t *element = &table->element[i];\n    uint32_t length = element->code_size;\n\n    if (length != 0) {\n      /* add_code_to_tree wants the code right adjusted */\n      uint32_t code = ((element->code) >> (8 - length)) & 0xff;\n      uint32_t value = i;\n\n      add_code_to_tree(tree, length, code, value);\n\n#ifdef DBG_PRNT\n      {\n        char buffer[100];\n\n        x3f_printf(DEBUG, \"H %5d : %5x : %5d : %02x %08x (%08x) (%s)\\n\",\n\t\t   i, i, value, length, code, value,\n\t\t   display_code(length, code, buffer));\n      }\n#endif\n    }\n  }\n}\n\nstatic void populate_huffman_tree(x3f_hufftree_t *tree,\n\t\t\t\t  x3f_table32_t *table,\n\t\t\t\t  x3f_table16_t *mapping)\n{\n  int i;\n\n  new_node(tree);\n\n  for (i=0; i<table->size; i++) {\n    uint32_t element = table->element[i];\n\n    if (element != 0) {\n      uint32_t length = HUF_TREE_GET_LENGTH(element);\n      uint32_t code = HUF_TREE_GET_CODE(element);\n      uint32_t value;\n\n      /* If we have a valid mapping table - then the value from the\n         mapping table shall be used. Otherwise we use the current\n         index in the table as value. */\n      if (table->size == mapping->size)\n        value = mapping->element[i];\n      else\n        value = i;\n\n      add_code_to_tree(tree, length, code, value);\n\n#ifdef DBG_PRNT\n      {\n        char buffer[100];\n\n        x3f_printf(DEBUG, \"H %5d : %5x : %5d : %02x %08x (%08x) (%s)\\n\",\n\t\t   i, i, value, length, code, element,\n\t\t   display_code(length, code, buffer));\n      }\n#endif\n    }\n  }\n}\n\n#ifdef DBG_PRNT\nstatic void print_huffman_tree(x3f_huffnode_t *t, int length, uint32_t code)\n{\n  char buf1[100];\n  char buf2[100];\n\n  x3f_printf(DEBUG, \"%*s (%s,%s) %s (%s)\\n\",\n\t     length, length < 1 ? \"-\" : (code&1) ? \"1\" : \"0\",\n\t     t->branch[0]==NULL ? \"-\" : \"0\",\n\t     t->branch[1]==NULL ? \"-\" : \"1\",\n\t     t->leaf==UNDEFINED_LEAF ? \"-\" : (sprintf(buf1, \"%x\", t->leaf),buf1),\n\t     display_code(length, code, buf2));\n\n  code = code << 1;\n  if (t->branch[0]) print_huffman_tree(t->branch[0], length+1, code+0);\n  if (t->branch[1]) print_huffman_tree(t->branch[1], length+1, code+1);\n}\n#endif\n\n/* Help machinery for reading bits in a memory */\n\ntypedef struct bit_state_s {\n  uint8_t *next_address;\n  uint8_t bit_offset;\n  uint8_t bits[8];\n} bit_state_t;\n\nstatic void set_bit_state(bit_state_t *BS, uint8_t *address)\n{\n  BS->next_address = address;\n  BS->bit_offset = 8;\n}\n\nstatic uint8_t get_bit(bit_state_t *BS)\n{\n  if (BS->bit_offset == 8) {\n    uint8_t byte = *BS->next_address;\n    int i;\n\n    for (i=7; i>= 0; i--) {\n      BS->bits[i] = byte&1;\n      byte = byte >> 1;\n    }\n    BS->next_address++;\n    BS->bit_offset = 0;\n  }\n\n  return BS->bits[BS->bit_offset++];\n}\n\n/* Decode use the TRUE algorithm */\n\nstatic int32_t get_true_diff(bit_state_t *BS, x3f_hufftree_t *HTP)\n{\n  int32_t diff;\n  x3f_huffnode_t *node = &HTP->nodes[0];\n  uint8_t bits;\n\n  while (node->branch[0] != NULL || node->branch[1] != NULL) {\n    uint8_t bit = get_bit(BS);\n    x3f_huffnode_t *new_node = node->branch[bit];\n\n    node = new_node;\n    if (node == NULL) {\n      /* TODO: Shouldn't this be treated as a fatal error? */\n      return 0;\n    }\n  }\n\n  bits = node->leaf;\n\n  if (bits == 0)\n    diff = 0;\n  else {\n    uint8_t first_bit = get_bit(BS);\n    int i;\n\n    diff = first_bit;\n\n    for (i=1; i<bits; i++)\n      diff = (diff << 1) + get_bit(BS);\n\n    if (first_bit == 0)\n      diff -= (1<<bits) - 1;\n  }\n\n  return diff;\n}\n\n/* This code (that decodes one of the X3F color planes, really is a\n   decoding of a compression algorithm suited for Bayer CFA data. In\n   Bayer CFA the data is divided into 2x2 squares that represents\n   (R,G1,G2,B) data. Those four positions are (in this compression)\n   treated as one data stream each, where you store the differences to\n   previous data in the stream. The reason for this is, of course,\n   that the date is more often than not near to the next data in a\n   stream that represents the same color. */\n\n/* TODO: write more about the compression */\n\nstatic void true_decode_one_color(x3f_image_data_t *ID, int color)\n{\n  x3f_true_t *TRU = ID->tru;\n  x3f_quattro_t *Q = ID->quattro;\n  uint32_t seed = TRU->seed[color]; /* TODO : Is this correct ? */\n  int row;\n\n  x3f_hufftree_t *tree = &TRU->tree;\n  bit_state_t BS;\n\n  int32_t row_start_acc[2][2];\n  uint32_t rows = ID->rows;\n  uint32_t cols = ID->columns;\n  x3f_area16_t *area = &TRU->x3rgb16;\n  uint16_t *dst = area->data + color;\n\n  set_bit_state(&BS, TRU->plane_address[color]);\n\n  row_start_acc[0][0] = seed;\n  row_start_acc[0][1] = seed;\n  row_start_acc[1][0] = seed;\n  row_start_acc[1][1] = seed;\n\n  if (ID->type_format == X3F_IMAGE_RAW_QUATTRO \n\t  || ID->type_format == X3F_IMAGE_RAW_SDQ\n\t  || ID->type_format == X3F_IMAGE_RAW_SDQH \n\t  || ID->type_format == X3F_IMAGE_RAW_SDQH2 \n\t  ) {\n    rows = Q->plane[color].rows;\n    cols = Q->plane[color].columns;\n\n    if (Q->quattro_layout && color == 2) {\n      area = &Q->top16;\n      dst = area->data;\n    }\n  } else {\n  }\n\n  if(rows != area->rows || cols < area->columns)\n\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  for (row = 0; row < rows; row++) {\n    int col;\n    bool_t odd_row = row&1;\n    int32_t acc[2];\n\n    for (col = 0; col < cols; col++) {\n      bool_t odd_col = col&1;\n      int32_t diff = get_true_diff(&BS, tree);\n      int32_t prev = col < 2 ?\n\trow_start_acc[odd_row][odd_col] :\n\tacc[odd_col];\n      int32_t value = prev + diff;\n\n      acc[odd_col] = value;\n      if (col < 2)\n\trow_start_acc[odd_row][odd_col] = value;\n\n      /* Discard additional data at the right for binned Quattro plane 2 */\n      if (col >= area->columns) continue;\n\n      *dst = value;\n      dst += area->channels;\n    }\n  }\n}\n\nstatic void true_decode(x3f_info_t *I,\n\t\t\tx3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  int color;\n\n  for (color = 0; color < 3; color++) {\n    true_decode_one_color(ID, color);\n  }\n}\n\n/* Decode use the huffman tree */\n\nstatic int32_t get_huffman_diff(bit_state_t *BS, x3f_hufftree_t *HTP)\n{\n  int32_t diff;\n  x3f_huffnode_t *node = &HTP->nodes[0];\n\n  while (node->branch[0] != NULL || node->branch[1] != NULL) {\n    uint8_t bit = get_bit(BS);\n    x3f_huffnode_t *new_node = node->branch[bit];\n\n    node = new_node;\n    if (node == NULL) {\n      /* TODO: Shouldn't this be treated as a fatal error? */\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n      return 0;\n    }\n  }\n\n  diff = node->leaf;\n\n  return diff;\n}\n\nstatic void huffman_decode_row(x3f_info_t *I,\n                               x3f_directory_entry_t *DE,\n                               int bits,\n                               int row,\n                               int offset,\n                               int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  int16_t c[3] = {(int16_t)offset,(int16_t)offset,(int16_t)offset};\n  int col;\n  bit_state_t BS;\n\n  set_bit_state(&BS, (uint8_t*)ID->data + HUF->row_offsets.element[row]);\n\n  for (col = 0; col < ID->columns; col++) {\n    int color;\n\n    for (color = 0; color < 3; color++) {\n      uint16_t c_fix;\n\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0) {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      } else {\n        c_fix = c[color];\n      }\n\n      switch (ID->type_format) {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3*(row*ID->columns + col) + color] = (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3*(row*ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n\t/* TODO: Shouldn't this be treated as a fatal error? */\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}\n\nstatic void huffman_decode(x3f_info_t *I,\n                           x3f_directory_entry_t *DE,\n                           int bits)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  int row;\n  int minimum = 0;\n  int offset = legacy_offset;\n\n  for (row = 0; row < ID->rows; row++)\n    huffman_decode_row(I, DE, bits, row, offset, &minimum);\n\n  if (auto_legacy_offset && minimum < 0) {\n    offset = -minimum;\n    for (row = 0; row < ID->rows; row++)\n      huffman_decode_row(I, DE, bits, row, offset, &minimum);\n  }\n}\n\nstatic int32_t get_simple_diff(x3f_huffman_t *HUF, uint16_t index)\n{\n  if (HUF->mapping.size == 0)\n    return index;\n  else\n    return HUF->mapping.element[index];\n}\n\nstatic void simple_decode_row(x3f_info_t *I,\n                              x3f_directory_entry_t *DE,\n                              int bits,\n                              int row,\n                              int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  uint32_t *data = (uint32_t *)((unsigned char*)ID->data + row*row_stride);\n\n  uint16_t c[3] = {0,0,0};\n  int col;\n\n  uint32_t mask = 0;\n\n  switch (bits) {\n  case 8:\n    mask = 0x0ff;\n    break;\n  case 9:\n    mask = 0x1ff;\n    break;\n  case 10:\n    mask = 0x3ff;\n    break;\n  case 11:\n    mask = 0x7ff;\n    break;\n  case 12:\n    mask = 0xfff;\n    break;\n  default:\n    mask = 0;\n    /* TODO: Shouldn't this be treated as a fatal error? */\n\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n    break;\n  }\n\n  for (col = 0; col < ID->columns; col++) {\n    int color;\n    uint32_t val = data[col];\n\n    for (color = 0; color < 3; color++) {\n      uint16_t c_fix;\n      c[color] += get_simple_diff(HUF, (val>>(color*bits))&mask);\n\n      switch (ID->type_format) {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        c_fix = (int16_t)c[color] > 0 ? c[color] : 0;\n\n        HUF->x3rgb16.data[3*(row*ID->columns + col) + color] = c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        c_fix = (int8_t)c[color] > 0 ? c[color] : 0;\n\n        HUF->rgb8.data[3*(row*ID->columns + col) + color] = c_fix;\n        break;\n      default:\n\t/* TODO: Shouldn't this be treated as a fatal error? */\n\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}\n\nstatic void simple_decode(x3f_info_t *I,\n                          x3f_directory_entry_t *DE,\n                          int bits,\n                          int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  int row;\n\n  for (row = 0; row < ID->rows; row++)\n    simple_decode_row(I, DE, bits, row, row_stride);\n}\n\n/* --------------------------------------------------------------------- */\n/* Loading the data in a directory entry                                 */\n/* --------------------------------------------------------------------- */\n\n/* First you set the offset to where to start reading the data ... */\n\nstatic void read_data_set_offset(x3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tuint32_t header_size)\n{\n\tuint32_t i_off = DE->input.offset + header_size;\n\n\t I->input.file->seek(i_off, SEEK_SET);\n}\n\n/* ... then you read the data, block for block */\n\nstatic uint32_t read_data_block(void **data,\n\tx3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tuint32_t footer)\n{\n\tINT64 fpos = I->input.file->tell();\n\tuint32_t size =\n\t\tDE->input.size + DE->input.offset - fpos - footer;\n\t\n\tif (fpos + size > I->input.file->size())\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n\t*data = (void *)malloc(size);\n\n\tGETN(*data, size);\n\n\treturn size;\n}\n\nstatic uint32_t data_block_size(void **data,\n\tx3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tuint32_t footer)\n{\n\tuint32_t size =\n\t\tDE->input.size + DE->input.offset - I->input.file->tell() - footer;\n\treturn size;\n}\n\n\nstatic void x3f_load_image_verbatim(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\tif (!ID->data_size)\n\t\tID->data_size = read_data_block(&ID->data, I, DE, 0);\n}\n\nstatic int32_t x3f_load_image_verbatim_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\treturn data_block_size(&ID->data, I, DE, 0);\n}\n\n\nstatic void x3f_load_property_list(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\tint i;\n\n\tread_data_set_offset(I, DE, X3F_PROPERTY_LIST_HEADER_SIZE);\n\n\tGET_PROPERTY_TABLE(PL->property_table, PL->num_properties);\n\n\tif (!PL->data_size)\n\t\tPL->data_size = read_data_block(&PL->data, I, DE, 0);\n\n\tfor (i=0; i<PL->num_properties; i++) {\n\t\tx3f_property_t *P = &PL->property_table.element[i];\n\n\t\tP->name = ((utf16_t *)PL->data + P->name_offset);\n\t\tP->value = ((utf16_t *)PL->data + P->value_offset);\n\t\tP->name_utf8 = 0;// utf16le_to_utf8(P->name);\n\t\tP->value_utf8 = 0;//utf16le_to_utf8(P->value);\n\t}\n}\n\n\nstatic void x3f_load_true(x3f_info_t *I,\n\tx3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\tx3f_true_t *TRU = new_true(&ID->tru);\n\tx3f_quattro_t *Q = NULL;\n\tint i;\n\n\tif (ID->type_format == X3F_IMAGE_RAW_QUATTRO \n\t\t||\tID->type_format == X3F_IMAGE_RAW_SDQ\n\t\t||\tID->type_format == X3F_IMAGE_RAW_SDQH\n\t\t||\tID->type_format == X3F_IMAGE_RAW_SDQH2\n\t\t) {\n\t\t\tQ = new_quattro(&ID->quattro);\n\n\t\t\tfor (i=0; i<TRUE_PLANES; i++) {\n\t\t\t\tGET2(Q->plane[i].columns);\n\t\t\t\tGET2(Q->plane[i].rows);\n\t\t\t}\n\n\t\t\tif (Q->plane[0].rows == ID->rows/2) {\n\t\t\t\tQ->quattro_layout = 1;\n\t\t\t} else if (Q->plane[0].rows == ID->rows) {\n\t\t\t\tQ->quattro_layout = 0;\n\t\t\t} else {\n\t\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\t\t}\n\t}\n\n\t/* Read TRUE header data */\n\tGET2(TRU->seed[0]);\n\tGET2(TRU->seed[1]);\n\tGET2(TRU->seed[2]);\n\tGET2(TRU->unknown);\n\tGET_TRUE_HUFF_TABLE(TRU->table);\n\n\tif (ID->type_format == X3F_IMAGE_RAW_QUATTRO \n\t\t||ID->type_format == X3F_IMAGE_RAW_SDQ\n\t\t||ID->type_format == X3F_IMAGE_RAW_SDQH\n\t\t||ID->type_format == X3F_IMAGE_RAW_SDQH2\n\t\t) {\n\t\t\tGET4(Q->unknown);\n\t}\n\n\tGET_TABLE(TRU->plane_size, GET4, TRUE_PLANES,uint32_t);\n\n\t/* Read image data */\n\tif (!ID->data_size)\n\t\tID->data_size = read_data_block(&ID->data, I, DE, 0);\n\n\t/* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n\tnew_huffman_tree(&TRU->tree, 8);\n\n\tpopulate_true_huffman_tree(&TRU->tree, &TRU->table);\n\n#ifdef DBG_PRNT\n\tprint_huffman_tree(TRU->tree.nodes, 0, 0);\n#endif\n\n\tTRU->plane_address[0] = (uint8_t*)ID->data;\n\tfor (i=1; i<TRUE_PLANES; i++)\n\t\tTRU->plane_address[i] =\n\t\tTRU->plane_address[i-1] +\n\t\t(((TRU->plane_size.element[i-1] + 15) / 16) * 16);\n\n\tif ( (ID->type_format == X3F_IMAGE_RAW_QUATTRO \n\t\t|| ID->type_format == X3F_IMAGE_RAW_SDQ \n\t\t|| ID->type_format == X3F_IMAGE_RAW_SDQH \n\t\t|| ID->type_format == X3F_IMAGE_RAW_SDQH2 \n\t\t) &&\n\t\tQ->quattro_layout) {\n\t\t\tuint32_t columns = Q->plane[0].columns;\n\t\t\tuint32_t rows = Q->plane[0].rows;\n\t\t\tuint32_t channels = 3;\n\t\t\tuint32_t size = columns * rows * channels;\n\n\t\t\tTRU->x3rgb16.columns = columns;\n\t\t\tTRU->x3rgb16.rows = rows;\n\t\t\tTRU->x3rgb16.channels = channels;\n\t\t\tTRU->x3rgb16.row_stride = columns * channels;\n\t\t\tTRU->x3rgb16.buf = malloc(sizeof(uint16_t)*size);\n\t\t\tTRU->x3rgb16.data = (uint16_t *) TRU->x3rgb16.buf;\n\n\t\t\tcolumns = Q->plane[2].columns;\n\t\t\trows = Q->plane[2].rows;\n\t\t\tchannels = 1;\n\t\t\tsize = columns * rows * channels;\n\n\t\t\tQ->top16.columns = columns;\n\t\t\tQ->top16.rows = rows;\n\t\t\tQ->top16.channels = channels;\n\t\t\tQ->top16.row_stride = columns * channels;\n\t\t\tQ->top16.buf = malloc(sizeof(uint16_t)*size);\n\t\t\tQ->top16.data = (uint16_t *)Q->top16.buf;\n\t\t\t\t\n\t} else {\n\t\tuint32_t size = ID->columns * ID->rows * 3;\n\n\t\tTRU->x3rgb16.columns = ID->columns;\n\t\tTRU->x3rgb16.rows = ID->rows;\n\t\tTRU->x3rgb16.channels = 3;\n\t\tTRU->x3rgb16.row_stride = ID->columns * 3;\n\t\tTRU->x3rgb16.buf =malloc(sizeof(uint16_t)*size);\n\t\tTRU->x3rgb16.data = (uint16_t *)TRU->x3rgb16.buf;\t\t\n\t}\n\n\ttrue_decode(I, DE);\n}\n\nstatic void x3f_load_huffman_compressed(x3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tint bits,\n\tint use_map_table)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\tx3f_huffman_t *HUF = ID->huffman;\n\tint table_size = 1<<bits;\n\tint row_offsets_size = ID->rows * sizeof(HUF->row_offsets.element[0]);\n\n\tGET_TABLE(HUF->table, GET4, table_size,uint32_t);\n\n\tif (!ID->data_size)\n\t\tID->data_size = read_data_block(&ID->data, I, DE, row_offsets_size);\n\n\tGET_TABLE(HUF->row_offsets, GET4, ID->rows,uint32_t);\n\n\tnew_huffman_tree(&HUF->tree, bits);\n\tpopulate_huffman_tree(&HUF->tree, &HUF->table, &HUF->mapping);\n\n\thuffman_decode(I, DE, bits);\n}\n\nstatic void x3f_load_huffman_not_compressed(x3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tint bits,\n\tint use_map_table,\n\tint row_stride)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\tif (!ID->data_size)\n\t\tID->data_size = read_data_block(&ID->data, I, DE, 0);\n\n\tsimple_decode(I, DE, bits, row_stride);\n}\n\nstatic void x3f_load_huffman(x3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tint bits,\n\tint use_map_table,\n\tint row_stride)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\tx3f_huffman_t *HUF = new_huffman(&ID->huffman);\n\tuint32_t size;\n\n\tif (use_map_table) {\n\t\tint table_size = 1<<bits;\n\n\t\tGET_TABLE(HUF->mapping, GET2, table_size,uint16_t);\n\t}\n\n\tswitch (ID->type_format) {\n\tcase X3F_IMAGE_RAW_HUFFMAN_X530:\n\tcase X3F_IMAGE_RAW_HUFFMAN_10BIT:\n\t\tsize = ID->columns * ID->rows * 3;\n\t\tHUF->x3rgb16.columns = ID->columns;\n\t\tHUF->x3rgb16.rows = ID->rows;\n\t\tHUF->x3rgb16.channels = 3;\n\t\tHUF->x3rgb16.row_stride = ID->columns * 3;\n\t\tHUF->x3rgb16.buf = malloc(sizeof(uint16_t)*size);\n\t\tHUF->x3rgb16.data = (uint16_t *)HUF->x3rgb16.buf;\n\t\tbreak;\n\tcase X3F_IMAGE_THUMB_HUFFMAN:\n\t\tsize = ID->columns * ID->rows * 3;\n\t\tHUF->rgb8.columns = ID->columns;\n\t\tHUF->rgb8.rows = ID->rows;\n\t\tHUF->rgb8.channels = 3;\n\t\tHUF->rgb8.row_stride = ID->columns * 3;\n\t\tHUF->rgb8.buf = malloc(sizeof(uint8_t)*size);\n\t\tHUF->rgb8.data = (uint8_t *)HUF->rgb8.buf;\n\t\tbreak;\n\tdefault:\n\t\t/* TODO: Shouldn't this be treated as a fatal error? */\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t}\n\n\tif (row_stride == 0)\n\t\treturn x3f_load_huffman_compressed(I, DE, bits, use_map_table);\n\telse\n\t\treturn x3f_load_huffman_not_compressed(I, DE, bits, use_map_table, row_stride);\n}\n\nstatic void x3f_load_pixmap(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_load_image_verbatim(I, DE);\n}\n\nstatic uint32_t x3f_load_pixmap_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\treturn x3f_load_image_verbatim_size(I, DE);\n}\n\n\nstatic void x3f_load_jpeg(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_load_image_verbatim(I, DE);\n}\n\nstatic uint32_t x3f_load_jpeg_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\treturn x3f_load_image_verbatim_size(I, DE);\n}\n\nstatic void x3f_load_image(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\tread_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\n\tswitch (ID->type_format) {\n\tcase X3F_IMAGE_RAW_TRUE:\n\tcase X3F_IMAGE_RAW_MERRILL:\n\tcase X3F_IMAGE_RAW_QUATTRO:\n\tcase X3F_IMAGE_RAW_SDQ:\n\tcase X3F_IMAGE_RAW_SDQH:\n\tcase X3F_IMAGE_RAW_SDQH2:\n\t\tx3f_load_true(I, DE);\n\t\tbreak;\n\tcase X3F_IMAGE_RAW_HUFFMAN_X530:\n\tcase X3F_IMAGE_RAW_HUFFMAN_10BIT:\n\t\tx3f_load_huffman(I, DE, 10, 1, ID->row_stride);\n\t\tbreak;\n\tcase X3F_IMAGE_THUMB_PLAIN:\n\t\tx3f_load_pixmap(I, DE);\n\t\tbreak;\n\tcase X3F_IMAGE_THUMB_HUFFMAN:\n\t\tx3f_load_huffman(I, DE, 8, 0, ID->row_stride);\n\t\tbreak;\n\tcase X3F_IMAGE_THUMB_JPEG:\n\t\tx3f_load_jpeg(I, DE);\n\t\tbreak;\n\tdefault:\n\t\t/* TODO: Shouldn't this be treated as a fatal error? */\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t}\n}\n\n// Used only for thumbnail size estimation\nstatic uint32_t x3f_load_image_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\tread_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\n\tswitch (ID->type_format) {\n\tcase X3F_IMAGE_THUMB_PLAIN:\n\t\treturn x3f_load_pixmap_size(I, DE);\n\tcase X3F_IMAGE_THUMB_JPEG:\n\t\treturn x3f_load_jpeg_size(I, DE);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\nstatic void x3f_load_camf_decode_type2(x3f_camf_t *CAMF)\n{\n\tuint32_t key = CAMF->t2.crypt_key;\n\tint i;\n\n\tCAMF->decoded_data_size = CAMF->data_size;\n\tCAMF->decoded_data = malloc(CAMF->decoded_data_size);\n\n\tfor (i=0; i<CAMF->data_size; i++) {\n\t\tuint8_t old, _new;\n\t\tuint32_t tmp;\n\n\t\told = ((uint8_t *)CAMF->data)[i];\n\t\tkey = (key * 1597 + 51749) % 244944;\n\t\ttmp = (uint32_t)(key * ((int64_t)301593171) >> 24);\n\t\t_new = (uint8_t)(old ^ (uint8_t)(((((key << 8) - tmp) >> 1) + tmp) >> 17));\n\t\t((uint8_t *)CAMF->decoded_data)[i] = _new;\n\t}\n}\n\n/* NOTE: the unpacking in this code is in big respects identical to\n   true_decode_one_color(). The difference is in the output you\n   build. It might be possible to make some parts shared. NOTE ALSO:\n   This means that the meta data is obfuscated using an image\n   compression algorithm. */\n\nstatic void camf_decode_type4(x3f_camf_t *CAMF)\n{\n  uint32_t seed = CAMF->t4.decode_bias;\n  int row;\n\n  uint8_t *dst;\n  uint32_t dst_size = CAMF->t4.decoded_data_size;\n  uint8_t *dst_end;\n\n  bool_t odd_dst = 0;\n\n  x3f_hufftree_t *tree = &CAMF->tree;\n  bit_state_t BS;\n\n  int32_t row_start_acc[2][2];\n  uint32_t rows = CAMF->t4.block_count;\n  uint32_t cols = CAMF->t4.block_size;\n\n  CAMF->decoded_data_size = dst_size;\n\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n  memset(CAMF->decoded_data, 0, CAMF->decoded_data_size);\n\n  dst = (uint8_t *)CAMF->decoded_data;\n  dst_end = dst + dst_size;\n\n  set_bit_state(&BS, CAMF->decoding_start);\n\n  row_start_acc[0][0] = seed;\n  row_start_acc[0][1] = seed;\n  row_start_acc[1][0] = seed;\n  row_start_acc[1][1] = seed;\n\n  for (row = 0; row < rows; row++) {\n    int col;\n    bool_t odd_row = row&1;\n    int32_t acc[2];\n\n    /* We loop through all the columns and the rows. But the actual\n       data is smaller than that, so we break the loop when reaching\n       the end. */\n    for (col = 0; col < cols; col++) {\n      bool_t odd_col = col&1;\n      int32_t diff = get_true_diff(&BS, tree);\n      int32_t prev = col < 2 ?\n\trow_start_acc[odd_row][odd_col] :\n\tacc[odd_col];\n      int32_t value = prev + diff;\n\n      acc[odd_col] = value;\n      if (col < 2)\n\trow_start_acc[odd_row][odd_col] = value;\n\n      switch(odd_dst) {\n      case 0:\n\t*dst++  = (uint8_t)((value>>4)&0xff);\n\n\tif (dst >= dst_end) {\n\t  goto ready;\n\t}\n\n\t*dst    = (uint8_t)((value<<4)&0xf0);\n\tbreak;\n      case 1:\n\t*dst++ |= (uint8_t)((value>>8)&0x0f);\n\n\tif (dst >= dst_end) {\n\t  goto ready;\n\t}\n\n\t*dst++  = (uint8_t)((value<<0)&0xff);\n\n\tif (dst >= dst_end) {\n\t  goto ready;\n\t}\n\n\tbreak;\n      }\n\n      odd_dst = !odd_dst;\n    } /* end col */\n  } /* end row */\n\n ready:;\n}\n\nstatic void x3f_load_camf_decode_type4(x3f_camf_t *CAMF)\n{\n  int i;\n  uint8_t *p;\n  x3f_true_huffman_element_t *element = NULL;\n\n  for (i=0, p = (uint8_t*)CAMF->data; *p != 0; i++) {\n    /* TODO: Is this too expensive ??*/\n    element =\n      (x3f_true_huffman_element_t *)realloc(element, (i+1)*sizeof(*element));\n\n    element[i].code_size = *p++;\n    element[i].code = *p++;\n  }\n\n  CAMF->table.size = i;\n  CAMF->table.element = element;\n\n  /* TODO: where does the values 28 and 32 come from? */\n#define CAMF_T4_DATA_SIZE_OFFSET 28\n#define CAMF_T4_DATA_OFFSET 32\n  CAMF->decoding_size = *(uint32_t *)((unsigned char*)CAMF->data + CAMF_T4_DATA_SIZE_OFFSET);\n  CAMF->decoding_start = (uint8_t *)CAMF->data + CAMF_T4_DATA_OFFSET;\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&CAMF->tree, 8);\n\n  populate_true_huffman_tree(&CAMF->tree, &CAMF->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(CAMF->tree.nodes, 0, 0);\n#endif\n\n  camf_decode_type4(CAMF);\n}\n\nstatic void camf_decode_type5(x3f_camf_t *CAMF)\n{\n  int32_t acc = CAMF->t5.decode_bias;\n\n  uint8_t *dst;\n\n  x3f_hufftree_t *tree = &CAMF->tree;\n  bit_state_t BS;\n\n  int32_t i;\n\n  CAMF->decoded_data_size = CAMF->t5.decoded_data_size;\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n\n  dst = (uint8_t *)CAMF->decoded_data;\n\n  set_bit_state(&BS, CAMF->decoding_start);\n\n  for (i = 0; i < CAMF->decoded_data_size; i++) {\n    int32_t diff = get_true_diff(&BS, tree);\n\n    acc = acc + diff;\n    *dst++ = (uint8_t)(acc & 0xff);\n  }\n}\n\nstatic void x3f_load_camf_decode_type5(x3f_camf_t *CAMF)\n{\n  int i;\n  uint8_t *p;\n  x3f_true_huffman_element_t *element = NULL;\n\n  for (i=0, p = (uint8_t*)CAMF->data; *p != 0; i++) {\n    /* TODO: Is this too expensive ??*/\n    element =\n      (x3f_true_huffman_element_t *)realloc(element, (i+1)*sizeof(*element));\n\n    element[i].code_size = *p++;\n    element[i].code = *p++;\n  }\n\n  CAMF->table.size = i;\n  CAMF->table.element = element;\n\n  /* TODO: where does the values 28 and 32 come from? */\n#define CAMF_T5_DATA_SIZE_OFFSET 28\n#define CAMF_T5_DATA_OFFSET 32\n  CAMF->decoding_size = *(uint32_t *)((uint8_t*)CAMF->data + CAMF_T5_DATA_SIZE_OFFSET);\n  CAMF->decoding_start = (uint8_t *)CAMF->data + CAMF_T5_DATA_OFFSET;\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&CAMF->tree, 8);\n\n  populate_true_huffman_tree(&CAMF->tree, &CAMF->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(CAMF->tree.nodes, 0, 0);\n#endif\n\n  camf_decode_type5(CAMF);\n}\n\nstatic void x3f_setup_camf_text_entry(camf_entry_t *entry)\n{\n  entry->text_size = *(uint32_t *)entry->value_address;\n  entry->text = (char*)entry->value_address + 4;\n}\n\nstatic void x3f_setup_camf_property_entry(camf_entry_t *entry)\n{\n  int i;\n  uint8_t *e =\n    (uint8_t*)entry->entry;\n  uint8_t *v =\n    (uint8_t*)entry->value_address;\n  uint32_t num =\n    entry->property_num = *(uint32_t *)v;\n  uint32_t off = *(uint32_t *)(v + 4);\n\n  entry->property_name = (char **)malloc(num*sizeof(uint8_t*));\n  entry->property_value = (uint8_t **)malloc(num*sizeof(uint8_t*));\n\n  for (i=0; i<num; i++) {\n    uint32_t name_off = off + *(uint32_t *)(v + 8 + 8*i);\n    uint32_t value_off = off + *(uint32_t *)(v + 8 + 8*i + 4);\n\n    entry->property_name[i] = (char *)(e + name_off);\n    entry->property_value[i] = e + value_off;\n  }\n}\n\nstatic void set_matrix_element_info(uint32_t type,\n\t\t\t\t    uint32_t *size,\n\t\t\t\t    matrix_type_t *decoded_type)\n{\n  switch (type) {\n  case 0:\n    *size = 2;\n    *decoded_type = M_INT; /* known to be true */\n    break;\n  case 1:\n    *size = 4;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 2:\n    *size = 4;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 3:\n    *size = 4;\n    *decoded_type = M_FLOAT; /* known to be true */\n    break;\n  case 5:\n    *size = 1;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 6:\n    *size = 2;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  default:\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\nstatic void get_matrix_copy(camf_entry_t *entry)\n{\n  uint32_t element_size = entry->matrix_element_size;\n  uint32_t elements = entry->matrix_elements;\n  int i, size = (entry->matrix_decoded_type==M_FLOAT ?\n\t\t sizeof(double) :\n\t\t sizeof(uint32_t)) * elements;\n\n  entry->matrix_decoded = malloc(size);\n\n  switch (element_size) {\n  case 4:\n    switch (entry->matrix_decoded_type) {\n    case M_INT:\n    case M_UINT:\n      memcpy(entry->matrix_decoded, entry->matrix_data, size);\n      break;\n    case M_FLOAT:\n      for (i=0; i<elements; i++)\n\t((double *)entry->matrix_decoded)[i] =\n\t  (double)((float *)entry->matrix_data)[i];\n      break;\n    default:\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  case 2:\n    switch (entry->matrix_decoded_type) {\n    case M_INT:\n      for (i=0; i<elements; i++)\n\t((int32_t *)entry->matrix_decoded)[i] =\n\t  (int32_t)((int16_t *)entry->matrix_data)[i];\n      break;\n    case M_UINT:\n      for (i=0; i<elements; i++)\n\t((uint32_t *)entry->matrix_decoded)[i] =\n\t  (uint32_t)((uint16_t *)entry->matrix_data)[i];\n      break;\n    default:\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  case 1:\n    switch (entry->matrix_decoded_type) {\n    case M_INT:\n      for (i=0; i<elements; i++)\n\t((int32_t *)entry->matrix_decoded)[i] =\n\t  (int32_t)((int8_t *)entry->matrix_data)[i];\n      break;\n    case M_UINT:\n      for (i=0; i<elements; i++)\n\t((uint32_t *)entry->matrix_decoded)[i] =\n\t  (uint32_t)((uint8_t *)entry->matrix_data)[i];\n      break;\n    default:\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  default:\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\n\nstatic void x3f_setup_camf_matrix_entry(camf_entry_t *entry)\n{\n\tint i;\n\tint totalsize = 1;\n\n\tuint8_t *e =\n\t\t(uint8_t *)entry->entry;\n\tuint8_t *v =\n\t\t(uint8_t *)entry->value_address;\n\tuint32_t type =\n\t\tentry->matrix_type = *(uint32_t *)(v + 0);\n\tuint32_t dim =\n\t\tentry->matrix_dim = *(uint32_t *)(v + 4);\n\tuint32_t off =\n\t\tentry->matrix_data_off = *(uint32_t *)(v + 8);\n\tcamf_dim_entry_t *dentry =\n\t\tentry->matrix_dim_entry =\n\t\t(camf_dim_entry_t*)malloc(dim*sizeof(camf_dim_entry_t));\n\n\tfor (i=0; i<dim; i++) {\n\t\tuint32_t size =\n\t\t\tdentry[i].size = *(uint32_t *)(v + 12 + 12*i + 0);\n\t\tdentry[i].name_offset = *(uint32_t *)(v + 12 + 12*i + 4);\n\t\tdentry[i].n = *(uint32_t *)(v + 12 + 12*i + 8);\n\t\tdentry[i].name = (char *)(e + dentry[i].name_offset);\n\n\t\tif (dentry[i].n != i) {\n\t\t}\n\n\t\ttotalsize *= size;\n\t}\n\n\tset_matrix_element_info(type,\n\t\t&entry->matrix_element_size,\n\t\t&entry->matrix_decoded_type);\n\tentry->matrix_data = (void *)(e + off);\n\n\tentry->matrix_elements = totalsize;\n\tentry->matrix_used_space = entry->entry_size - off;\n\n\t/* This estimate only works for matrices above a certain size */\n\tentry->matrix_estimated_element_size = entry->matrix_used_space / totalsize;\n\n\tget_matrix_copy(entry);\n}\n\nstatic void x3f_setup_camf_entries(x3f_camf_t *CAMF)\n{\n\tuint8_t *p = (uint8_t *)CAMF->decoded_data;\n\tuint8_t *end = p + CAMF->decoded_data_size;\n\tcamf_entry_t *entry = NULL;\n\tint i;\n\n\tfor (i=0; p < end; i++) {\n\t\tuint32_t *p4 = (uint32_t *)p;\n\n\t\tswitch (*p4) {\n\t\tcase X3F_CMbP:\n\t\tcase X3F_CMbT:\n\t\tcase X3F_CMbM:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto stop;\n\t\t}\n\n\t\t/* TODO: lots of realloc - may be inefficient */\n\t\tentry = (camf_entry_t *)realloc(entry, (i+1)*sizeof(camf_entry_t));\n\n\t\t/* Pointer */\n\t\tentry[i].entry = p;\n\n\t\t/* Header */\n\t\tentry[i].id = *p4++;\n\t\tentry[i].version = *p4++;\n\t\tentry[i].entry_size = *p4++;\n\t\tentry[i].name_offset = *p4++;\n\t\tentry[i].value_offset = *p4++;\n\n\t\t/* Compute adresses and sizes */\n\t\tentry[i].name_address = (char *)(p + entry[i].name_offset);\n\t\tentry[i].value_address = p + entry[i].value_offset;\n\t\tentry[i].name_size = entry[i].value_offset - entry[i].name_offset;\n\t\tentry[i].value_size = entry[i].entry_size - entry[i].value_offset;\n\n\t\tentry[i].text_size = 0;\n\t\tentry[i].text = NULL;\n\t\tentry[i].property_num = 0;\n\t\tentry[i].property_name = NULL;\n\t\tentry[i].property_value = NULL;\n\t\tentry[i].matrix_type = 0;\n\t\tentry[i].matrix_dim = 0;\n\t\tentry[i].matrix_data_off = 0;\n\t\tentry[i].matrix_data = NULL;\n\t\tentry[i].matrix_dim_entry = NULL;\n\n\t\tentry[i].matrix_decoded = NULL;\n\n\t\tswitch (entry[i].id) {\n\t\tcase X3F_CMbP:\n\t\t\tx3f_setup_camf_property_entry(&entry[i]);\n\t\t\tbreak;\n\t\tcase X3F_CMbT:\n\t\t\tx3f_setup_camf_text_entry(&entry[i]);\n\t\t\tbreak;\n\t\tcase X3F_CMbM:\n\t\t\tx3f_setup_camf_matrix_entry(&entry[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tp += entry[i].entry_size;\n\t}\n\nstop:\n\n\tCAMF->entry_table.size = i;\n\tCAMF->entry_table.element = entry;\n}\n\nstatic void x3f_load_camf(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\n\tread_data_set_offset(I, DE, X3F_CAMF_HEADER_SIZE);\n\n\tif (!CAMF->data_size)\n\t\tCAMF->data_size = read_data_block(&CAMF->data, I, DE, 0);\n\n\tswitch (CAMF->type) {\n\tcase 2:\t\t\t/* Older SD9-SD14 */\n\t\tx3f_load_camf_decode_type2(CAMF);\n\t\tbreak;\n\tcase 4:\t\t\t/* TRUE ... Merrill */\n\t\tx3f_load_camf_decode_type4(CAMF);\n\t\tbreak;\n\tcase 5:\t\t\t/* Quattro ... */\n\t\tx3f_load_camf_decode_type5(CAMF);\n\t\tbreak;\n\tdefault:\n\t\t/* TODO: Shouldn't this be treated as a fatal error? */\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t}\n\n\tif (CAMF->decoded_data != NULL)\n\t\tx3f_setup_camf_entries(CAMF);\n\telse\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n}\n\n/* extern */ x3f_return_t x3f_load_data(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n\tx3f_info_t *I = &x3f->info;\n\n\tif (DE == NULL)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tswitch (DE->header.identifier) {\n\tcase X3F_SECp:\n\t\tx3f_load_property_list(I, DE);\n\t\tbreak;\n\tcase X3F_SECi:\n\t\tx3f_load_image(I, DE);\n\t\tbreak;\n\tcase X3F_SECc:\n\t\tx3f_load_camf(I, DE);\n\t\tbreak;\n\tdefault:\n\t\treturn X3F_INTERNAL_ERROR;\n\t}\n\treturn X3F_OK;\n}\n\n/* extern */ int64_t x3f_load_data_size(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n\tx3f_info_t *I = &x3f->info;\n\n\tif (DE == NULL)\n\t\treturn -1;\n\n\tswitch (DE->header.identifier) \n\t{\n\tcase X3F_SECi:\n\t\treturn x3f_load_image_size(I, DE);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n/* extern */ x3f_return_t x3f_load_image_block(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n\tx3f_info_t *I = &x3f->info;\n\n\tif (DE == NULL)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tswitch (DE->header.identifier) {\n\tcase X3F_SECi:\n\t\tread_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\t\tx3f_load_image_verbatim(I, DE);\n\t\tbreak;\n\tdefault:\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\treturn X3F_INTERNAL_ERROR;\n\t}\n\n\treturn X3F_OK;\n}\n\n\n/* --------------------------------------------------------------------- */\n/* The End                                                               */\n/* --------------------------------------------------------------------- */\n", "/* -*- C++ -*-\n * File: libraw_cxx.cpp\n * Copyright 2008-2018 LibRaw LLC (info@libraw.org)\n * Created: Sat Mar  8 , 2008\n *\n * LibRaw C++ interface (implementation)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include <math.h>\n#include <errno.h>\n#include <float.h>\n#include <new>\n#include <exception>\n#include <sys/types.h>\n#include <sys/stat.h>\n#if !defined(_WIN32) && !defined(__MINGW32__)\n#include <netinet/in.h>\n#else\n#include <winsock2.h>\n#endif\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#ifdef USE_ZLIB\n#include <zlib.h>\n#endif\n\n#ifdef USE_RAWSPEED\n#include \"../RawSpeed/rawspeed_xmldata.cpp\"\n#include <RawSpeed/StdAfx.h>\n#include <RawSpeed/FileMap.h>\n#include <RawSpeed/RawParser.h>\n#include <RawSpeed/RawDecoder.h>\n#include <RawSpeed/CameraMetaData.h>\n#include <RawSpeed/ColorFilterArray.h>\n#endif\n\n#ifdef USE_DNGSDK\n#include \"dng_host.h\"\n#include \"dng_negative.h\"\n#include \"dng_simple_image.h\"\n#include \"dng_info.h\"\n#endif\n\n#include \"libraw_fuji_compressed.cpp\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n  void default_memory_callback(void *, const char *file, const char *where)\n  {\n    fprintf(stderr, \"%s: Out of memory in %s\\n\", file ? file : \"unknown file\", where);\n  }\n\n  void default_data_callback(void *, const char *file, const int offset)\n  {\n    if (offset < 0)\n      fprintf(stderr, \"%s: Unexpected end of file\\n\", file ? file : \"unknown file\");\n    else\n      fprintf(stderr, \"%s: data corrupted at %d\\n\", file ? file : \"unknown file\", offset);\n  }\n  const char *libraw_strerror(int e)\n  {\n    enum LibRaw_errors errorcode = (LibRaw_errors)e;\n    switch (errorcode)\n    {\n    case LIBRAW_SUCCESS:\n      return \"No error\";\n    case LIBRAW_UNSPECIFIED_ERROR:\n      return \"Unspecified error\";\n    case LIBRAW_FILE_UNSUPPORTED:\n      return \"Unsupported file format or not RAW file\";\n    case LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:\n      return \"Request for nonexisting image number\";\n    case LIBRAW_OUT_OF_ORDER_CALL:\n      return \"Out of order call of libraw function\";\n    case LIBRAW_NO_THUMBNAIL:\n      return \"No thumbnail in file\";\n    case LIBRAW_UNSUPPORTED_THUMBNAIL:\n      return \"Unsupported thumbnail format\";\n    case LIBRAW_INPUT_CLOSED:\n      return \"No input stream, or input stream closed\";\n    case LIBRAW_UNSUFFICIENT_MEMORY:\n      return \"Unsufficient memory\";\n    case LIBRAW_DATA_ERROR:\n      return \"Corrupted data or unexpected EOF\";\n    case LIBRAW_IO_ERROR:\n      return \"Input/output error\";\n    case LIBRAW_CANCELLED_BY_CALLBACK:\n      return \"Cancelled by user callback\";\n    case LIBRAW_BAD_CROP:\n      return \"Bad crop box\";\n    default:\n      return \"Unknown error code\";\n    }\n  }\n\n#ifdef __cplusplus\n}\n#endif\n\n#define Sigma_X3F 22\n\nconst double LibRaw_constants::xyz_rgb[3][3] = {\n    {0.4124564, 0.3575761, 0.1804375}, {0.2126729, 0.7151522, 0.0721750}, {0.0193339, 0.1191920, 0.9503041}};\n\nconst float LibRaw_constants::d65_white[3] = {0.95047f, 1.0f, 1.08883f};\n\n#define P1 imgdata.idata\n#define S imgdata.sizes\n#define O imgdata.params\n#define C imgdata.color\n#define T imgdata.thumbnail\n#define IO libraw_internal_data.internal_output_params\n#define ID libraw_internal_data.internal_data\n\n#define EXCEPTION_HANDLER(e)                                                                                           \\\n  do                                                                                                                   \\\n  {                                                                                                                    \\\n    /* fprintf(stderr,\"Exception %d caught\\n\",e);*/                                                                    \\\n    switch (e)                                                                                                         \\\n    {                                                                                                                  \\\n    case LIBRAW_EXCEPTION_ALLOC:                                                                                       \\\n      recycle();                                                                                                       \\\n      return LIBRAW_UNSUFFICIENT_MEMORY;                                                                               \\\n    case LIBRAW_EXCEPTION_DECODE_RAW:                                                                                  \\\n    case LIBRAW_EXCEPTION_DECODE_JPEG:                                                                                 \\\n      recycle();                                                                                                       \\\n      return LIBRAW_DATA_ERROR;                                                                                        \\\n    case LIBRAW_EXCEPTION_DECODE_JPEG2000:                                                                             \\\n      recycle();                                                                                                       \\\n      return LIBRAW_DATA_ERROR;                                                                                        \\\n    case LIBRAW_EXCEPTION_IO_EOF:                                                                                      \\\n    case LIBRAW_EXCEPTION_IO_CORRUPT:                                                                                  \\\n      recycle();                                                                                                       \\\n      return LIBRAW_IO_ERROR;                                                                                          \\\n    case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:                                                                       \\\n      recycle();                                                                                                       \\\n      return LIBRAW_CANCELLED_BY_CALLBACK;                                                                             \\\n    case LIBRAW_EXCEPTION_BAD_CROP:                                                                                    \\\n      recycle();                                                                                                       \\\n      return LIBRAW_BAD_CROP;                                                                                          \\\n    default:                                                                                                           \\\n      return LIBRAW_UNSPECIFIED_ERROR;                                                                                 \\\n    }                                                                                                                  \\\n  } while (0)\n\nconst char *LibRaw::version() { return LIBRAW_VERSION_STR; }\nint LibRaw::versionNumber() { return LIBRAW_VERSION; }\nconst char *LibRaw::strerror(int p) { return libraw_strerror(p); }\n\nunsigned LibRaw::capabilities()\n{\n  unsigned ret = 0;\n#ifdef USE_RAWSPEED\n  ret |= LIBRAW_CAPS_RAWSPEED;\n#endif\n#ifdef USE_DNGSDK\n  ret |= LIBRAW_CAPS_DNGSDK;\n#endif\n  return ret;\n}\n\nunsigned LibRaw::parse_custom_cameras(unsigned limit, libraw_custom_camera_t table[], char **list)\n{\n  if (!list)\n    return 0;\n  unsigned index = 0;\n  for (int i = 0; i < limit; i++)\n  {\n    if (!list[i])\n      break;\n    if (strlen(list[i]) < 10)\n      continue;\n    char *string = (char *)malloc(strlen(list[i]) + 1);\n    strcpy(string, list[i]);\n    char *start = string;\n    memset(&table[index], 0, sizeof(table[0]));\n    for (int j = 0; start && j < 14; j++)\n    {\n      char *end = strchr(start, ',');\n      if (end)\n      {\n        *end = 0;\n        end++;\n      } // move to next char\n      while (isspace(*start) && *start)\n        start++; // skip leading spaces?\n      unsigned val = strtol(start, 0, 10);\n      switch (j)\n      {\n      case 0:\n        table[index].fsize = val;\n        break;\n      case 1:\n        table[index].rw = val;\n        break;\n      case 2:\n        table[index].rh = val;\n        break;\n      case 3:\n        table[index].lm = val;\n        break;\n      case 4:\n        table[index].tm = val;\n        break;\n      case 5:\n        table[index].rm = val;\n        break;\n      case 6:\n        table[index].bm = val;\n        break;\n      case 7:\n        table[index].lf = val;\n        break;\n      case 8:\n        table[index].cf = val;\n        break;\n      case 9:\n        table[index].max = val;\n        break;\n      case 10:\n        table[index].flags = val;\n        break;\n      case 11:\n        strncpy(table[index].t_make, start, sizeof(table[index].t_make) - 1);\n        break;\n      case 12:\n        strncpy(table[index].t_model, start, sizeof(table[index].t_model) - 1);\n        break;\n      case 13:\n        table[index].offset = val;\n        break;\n      default:\n        break;\n      }\n      start = end;\n    }\n    free(string);\n    if (table[index].t_make[0])\n      index++;\n  }\n  return index;\n}\n\nvoid LibRaw::derror()\n{\n  if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)\n  {\n    if (libraw_internal_data.internal_data.input->eof())\n    {\n      if (callbacks.data_cb)\n        (*callbacks.data_cb)(callbacks.datacb_data, libraw_internal_data.internal_data.input->fname(), -1);\n      throw LIBRAW_EXCEPTION_IO_EOF;\n    }\n    else\n    {\n      if (callbacks.data_cb)\n        (*callbacks.data_cb)(callbacks.datacb_data, libraw_internal_data.internal_data.input->fname(),\n                             libraw_internal_data.internal_data.input->tell());\n      // throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n  }\n  libraw_internal_data.unpacker_data.data_error++;\n}\n\nvoid LibRaw::dcraw_clear_mem(libraw_processed_image_t *p)\n{\n  if (p)\n    ::free(p);\n}\n\nint LibRaw::is_sraw() { return load_raw == &LibRaw::canon_sraw_load_raw || load_raw == &LibRaw::nikon_load_sraw; }\nint LibRaw::is_coolscan_nef() { return load_raw == &LibRaw::nikon_coolscan_load_raw; }\nint LibRaw::is_jpeg_thumb() { return thumb_load_raw == 0 && write_thumb == &LibRaw::jpeg_thumb; }\n\nint LibRaw::is_nikon_sraw() { return load_raw == &LibRaw::nikon_load_sraw; }\nint LibRaw::sraw_midpoint()\n{\n  if (load_raw == &LibRaw::canon_sraw_load_raw)\n    return 8192;\n  else if (load_raw == &LibRaw::nikon_load_sraw)\n    return 2048;\n  else\n    return 0;\n}\n\n#ifdef USE_RAWSPEED\nusing namespace RawSpeed;\nclass CameraMetaDataLR : public CameraMetaData\n{\npublic:\n  CameraMetaDataLR() : CameraMetaData() {}\n  CameraMetaDataLR(char *filename) : CameraMetaData(filename) {}\n  CameraMetaDataLR(char *data, int sz);\n};\n\nCameraMetaDataLR::CameraMetaDataLR(char *data, int sz) : CameraMetaData()\n{\n  ctxt = xmlNewParserCtxt();\n  if (ctxt == NULL)\n  {\n    ThrowCME(\"CameraMetaData:Could not initialize context.\");\n  }\n\n  xmlResetLastError();\n  doc = xmlCtxtReadMemory(ctxt, data, sz, \"\", NULL, XML_PARSE_DTDVALID);\n\n  if (doc == NULL)\n  {\n    ThrowCME(\"CameraMetaData: XML Document could not be parsed successfully. Error was: %s\", ctxt->lastError.message);\n  }\n\n  if (ctxt->valid == 0)\n  {\n    if (ctxt->lastError.code == 0x5e)\n    {\n      // printf(\"CameraMetaData: Unable to locate DTD, attempting to ignore.\");\n    }\n    else\n    {\n      ThrowCME(\"CameraMetaData: XML file does not validate. DTD Error was: %s\", ctxt->lastError.message);\n    }\n  }\n\n  xmlNodePtr cur;\n  cur = xmlDocGetRootElement(doc);\n  if (xmlStrcmp(cur->name, (const xmlChar *)\"Cameras\"))\n  {\n    ThrowCME(\"CameraMetaData: XML document of the wrong type, root node is not cameras.\");\n    return;\n  }\n\n  cur = cur->xmlChildrenNode;\n  while (cur != NULL)\n  {\n    if ((!xmlStrcmp(cur->name, (const xmlChar *)\"Camera\")))\n    {\n      Camera *camera = new Camera(doc, cur);\n      addCamera(camera);\n\n      // Create cameras for aliases.\n      for (unsigned int i = 0; i < camera->aliases.size(); i++)\n      {\n        addCamera(new Camera(camera, i));\n      }\n    }\n    cur = cur->next;\n  }\n  if (doc)\n    xmlFreeDoc(doc);\n  doc = 0;\n  if (ctxt)\n    xmlFreeParserCtxt(ctxt);\n  ctxt = 0;\n}\n\n#define RAWSPEED_DATA_COUNT (sizeof(_rawspeed_data_xml) / sizeof(_rawspeed_data_xml[0]))\nstatic CameraMetaDataLR *make_camera_metadata()\n{\n  int len = 0, i;\n  for (i = 0; i < RAWSPEED_DATA_COUNT; i++)\n    if (_rawspeed_data_xml[i])\n    {\n      len += strlen(_rawspeed_data_xml[i]);\n    }\n  char *rawspeed_xml = (char *)calloc(len + 1, sizeof(_rawspeed_data_xml[0][0]));\n  if (!rawspeed_xml)\n    return NULL;\n  int offt = 0;\n  for (i = 0; i < RAWSPEED_DATA_COUNT; i++)\n    if (_rawspeed_data_xml[i])\n    {\n      int ll = strlen(_rawspeed_data_xml[i]);\n      if (offt + ll > len)\n        break;\n      memmove(rawspeed_xml + offt, _rawspeed_data_xml[i], ll);\n      offt += ll;\n    }\n  rawspeed_xml[offt] = 0;\n  CameraMetaDataLR *ret = NULL;\n  try\n  {\n    ret = new CameraMetaDataLR(rawspeed_xml, offt);\n  }\n  catch (...)\n  {\n    // Mask all exceptions\n  }\n  free(rawspeed_xml);\n  return ret;\n}\n\n#endif\n\n#define ZERO(a) memset(&a, 0, sizeof(a))\n\nstatic void cleargps(libraw_gps_info_t *q)\n{\n  for (int i = 0; i < 3; i++)\n    q->latitude[i] = q->longtitude[i] = q->gpstimestamp[i] = 0.f;\n  q->altitude = 0.f;\n  q->altref = q->latref = q->longref = q->gpsstatus = q->gpsparsed = 0;\n}\n\nLibRaw::LibRaw(unsigned int flags) : memmgr(1024)\n{\n  double aber[4] = {1, 1, 1, 1};\n  double gamm[6] = {0.45, 4.5, 0, 0, 0, 0};\n  unsigned greybox[4] = {0, 0, UINT_MAX, UINT_MAX};\n  unsigned cropbox[4] = {0, 0, UINT_MAX, UINT_MAX};\n#ifdef DCRAW_VERBOSE\n  verbose = 1;\n#else\n  verbose = 0;\n#endif\n  ZERO(imgdata);\n\n  cleargps(&imgdata.other.parsed_gps);\n  ZERO(libraw_internal_data);\n  ZERO(callbacks);\n\n  _rawspeed_camerameta = _rawspeed_decoder = NULL;\n  dnghost = NULL;\n  _x3f_data = NULL;\n\n#ifdef USE_RAWSPEED\n  CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()\n  _rawspeed_camerameta = static_cast<void *>(camerameta);\n#endif\n  callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL : &default_memory_callback;\n  callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK) ? NULL : &default_data_callback;\n  callbacks.exif_cb = NULL; // no default callback\n  callbacks.pre_identify_cb = NULL;\n  callbacks.post_identify_cb = NULL;\n  callbacks.pre_subtractblack_cb = callbacks.pre_scalecolors_cb = callbacks.pre_preinterpolate_cb\n    = callbacks.pre_interpolate_cb = callbacks.interpolate_bayer_cb = callbacks.interpolate_xtrans_cb\n    = callbacks.post_interpolate_cb = callbacks.pre_converttorgb_cb = callbacks.post_converttorgb_cb \n  = NULL;\n\n  memmove(&imgdata.params.aber, &aber, sizeof(aber));\n  memmove(&imgdata.params.gamm, &gamm, sizeof(gamm));\n  memmove(&imgdata.params.greybox, &greybox, sizeof(greybox));\n  memmove(&imgdata.params.cropbox, &cropbox, sizeof(cropbox));\n\n  imgdata.params.bright = 1;\n  imgdata.params.use_camera_matrix = 1;\n  imgdata.params.user_flip = -1;\n  imgdata.params.user_black = -1;\n  imgdata.params.user_cblack[0] = imgdata.params.user_cblack[1] = imgdata.params.user_cblack[2] =\n      imgdata.params.user_cblack[3] = -1000001;\n  imgdata.params.user_sat = -1;\n  imgdata.params.user_qual = -1;\n  imgdata.params.output_color = 1;\n  imgdata.params.output_bps = 8;\n  imgdata.params.use_fuji_rotate = 1;\n  imgdata.params.exp_shift = 1.0;\n  imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;\n  imgdata.params.adjust_maximum_thr = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;\n  imgdata.params.use_rawspeed = 1;\n  imgdata.params.use_dngsdk = LIBRAW_DNG_DEFAULT;\n  imgdata.params.no_auto_scale = 0;\n  imgdata.params.no_interpolation = 0;\n  imgdata.params.raw_processing_options = LIBRAW_PROCESSING_DP2Q_INTERPOLATERG | LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF |\n                                          LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT;\n  imgdata.params.sony_arw2_posterization_thr = 0;\n  imgdata.params.green_matching = 0;\n  imgdata.params.custom_camera_strings = 0;\n  imgdata.params.coolscan_nef_gamma = 1.0f;\n  imgdata.parent_class = this;\n  imgdata.progress_flags = 0;\n  imgdata.color.baseline_exposure = -999.f;\n  _exitflag = 0;\n  tls = new LibRaw_TLS;\n  tls->init();\n\n}\n\nint LibRaw::set_rawspeed_camerafile(char *filename)\n{\n#ifdef USE_RAWSPEED\n  try\n  {\n    CameraMetaDataLR *camerameta = new CameraMetaDataLR(filename);\n    if (_rawspeed_camerameta)\n    {\n      CameraMetaDataLR *d = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);\n      delete d;\n    }\n    _rawspeed_camerameta = static_cast<void *>(camerameta);\n  }\n  catch (...)\n  {\n    // just return error code\n    return -1;\n  }\n#endif\n  return 0;\n}\n\nLibRaw::~LibRaw()\n{\n  recycle();\n  delete tls;\n#ifdef USE_RAWSPEED\n  if (_rawspeed_camerameta)\n  {\n    CameraMetaDataLR *cmeta = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);\n    delete cmeta;\n    _rawspeed_camerameta = NULL;\n  }\n#endif\n}\n\nvoid *LibRaw::malloc(size_t t)\n{\n  void *p = memmgr.malloc(t);\n  if (!p)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  return p;\n}\nvoid *LibRaw::realloc(void *q, size_t t)\n{\n  void *p = memmgr.realloc(q, t);\n  if (!p)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  return p;\n}\n\nvoid *LibRaw::calloc(size_t n, size_t t)\n{\n  void *p = memmgr.calloc(n, t);\n  if (!p)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  return p;\n}\nvoid LibRaw::free(void *p) { memmgr.free(p); }\n\nvoid LibRaw::recycle_datastream()\n{\n  if (libraw_internal_data.internal_data.input && libraw_internal_data.internal_data.input_internal)\n  {\n    delete libraw_internal_data.internal_data.input;\n    libraw_internal_data.internal_data.input = NULL;\n  }\n  libraw_internal_data.internal_data.input_internal = 0;\n}\n\nvoid x3f_clear(void *);\n\nvoid LibRaw::recycle()\n{\n  recycle_datastream();\n#define FREE(a)                                                                                                        \\\n  do                                                                                                                   \\\n  {                                                                                                                    \\\n    if (a)                                                                                                             \\\n    {                                                                                                                  \\\n      free(a);                                                                                                         \\\n      a = NULL;                                                                                                        \\\n    }                                                                                                                  \\\n  } while (0)\n\n  FREE(imgdata.image);\n\n  FREE(imgdata.thumbnail.thumb);\n  FREE(libraw_internal_data.internal_data.meta_data);\n  FREE(libraw_internal_data.output_data.histogram);\n  FREE(libraw_internal_data.output_data.oprof);\n  FREE(imgdata.color.profile);\n  FREE(imgdata.rawdata.ph1_cblack);\n  FREE(imgdata.rawdata.ph1_rblack);\n  FREE(imgdata.rawdata.raw_alloc);\n  FREE(imgdata.idata.xmpdata);\n\n#undef FREE\n\n  ZERO(imgdata.sizes);\n  imgdata.sizes.raw_crop.cleft = 0xffff;\n  imgdata.sizes.raw_crop.ctop = 0xffff;\n\n  ZERO(imgdata.idata);\n  ZERO(imgdata.makernotes);\n  ZERO(imgdata.color);\n  ZERO(imgdata.other);\n  ZERO(imgdata.thumbnail);\n  ZERO(imgdata.rawdata);\n  imgdata.makernotes.olympus.OlympusCropID = -1;\n  imgdata.makernotes.sony.raw_crop.cleft = 0xffff;\n  imgdata.makernotes.sony.raw_crop.ctop = 0xffff;\n  cleargps(&imgdata.other.parsed_gps);\n  imgdata.color.baseline_exposure = -999.f;\n\n  imgdata.makernotes.fuji.FujiExpoMidPointShift = -999.f;\n  imgdata.makernotes.fuji.FujiDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FujiFilmMode = 0xffff;\n  imgdata.makernotes.fuji.FujiDynamicRangeSetting = 0xffff;\n  imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FujiAutoDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FocusMode = 0xffff;\n  imgdata.makernotes.fuji.AFMode = 0xffff;\n  imgdata.makernotes.fuji.FocusPixel[0] = imgdata.makernotes.fuji.FocusPixel[1] = 0xffff;\n  imgdata.makernotes.fuji.ImageStabilization[0] = imgdata.makernotes.fuji.ImageStabilization[1] =\n      imgdata.makernotes.fuji.ImageStabilization[2] = 0xffff;\n\n  imgdata.makernotes.sony.SonyCameraType = 0xffff;\n  imgdata.makernotes.sony.real_iso_offset = 0xffff;\n  imgdata.makernotes.sony.ImageCount3_offset = 0xffff;\n  imgdata.makernotes.sony.ElectronicFrontCurtainShutter = 0xffff;\n\n  imgdata.makernotes.kodak.BlackLevelTop = 0xffff;\n  imgdata.makernotes.kodak.BlackLevelBottom = 0xffff;\n\n  imgdata.color.dng_color[0].illuminant = imgdata.color.dng_color[1].illuminant = 0xffff;\n\n  for (int i = 0; i < 4; i++)\n    imgdata.color.dng_levels.analogbalance[i] = 1.0f;\n\n  ZERO(libraw_internal_data);\n  ZERO(imgdata.lens);\n  imgdata.lens.makernotes.CanonFocalUnits = 1;\n  imgdata.lens.makernotes.LensID = 0xffffffffffffffffULL;\n  ZERO(imgdata.shootinginfo);\n  imgdata.shootinginfo.DriveMode = -1;\n  imgdata.shootinginfo.FocusMode = -1;\n  imgdata.shootinginfo.MeteringMode = -1;\n  imgdata.shootinginfo.AFPoint = -1;\n  imgdata.shootinginfo.ExposureMode = -1;\n  imgdata.shootinginfo.ImageStabilization = -1;\n\n  _exitflag = 0;\n#ifdef USE_RAWSPEED\n  if (_rawspeed_decoder)\n  {\n    RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);\n    delete d;\n  }\n  _rawspeed_decoder = 0;\n#endif\n\n  if (_x3f_data)\n  {\n    x3f_clear(_x3f_data);\n    _x3f_data = 0;\n  }\n\n  memmgr.cleanup();\n\n  imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n  imgdata.progress_flags = 0;\n\n  load_raw = thumb_load_raw = 0;\n\n  tls->init();\n}\n\nconst char *LibRaw::unpack_function_name()\n{\n  libraw_decoder_info_t decoder_info;\n  get_decoder_info(&decoder_info);\n  return decoder_info.decoder_name;\n}\n\nint LibRaw::get_decoder_info(libraw_decoder_info_t *d_info)\n{\n  if (!d_info)\n    return LIBRAW_UNSPECIFIED_ERROR;\n  d_info->decoder_name = 0;\n  d_info->decoder_flags = 0;\n  if (!load_raw)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  int rawdata = (imgdata.idata.filters || P1.colors == 1);\n  // dcraw.c names order\n  if (load_raw == &LibRaw::android_tight_load_raw)\n  {\n    d_info->decoder_name = \"android_tight_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::android_loose_load_raw)\n  {\n    d_info->decoder_name = \"android_loose_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::canon_600_load_raw)\n  {\n    d_info->decoder_name = \"canon_600_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::fuji_compressed_load_raw)\n  {\n    d_info->decoder_name = \"fuji_compressed_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::fuji_14bit_load_raw)\n  {\n    d_info->decoder_name = \"fuji_14bit_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::canon_load_raw)\n  {\n    d_info->decoder_name = \"canon_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::lossless_jpeg_load_raw)\n  {\n    d_info->decoder_name = \"lossless_jpeg_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::canon_sraw_load_raw)\n  {\n    d_info->decoder_name = \"canon_sraw_load_raw()\";\n    // d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::lossless_dng_load_raw)\n  {\n    d_info->decoder_name = \"lossless_dng_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;\n  }\n  else if (load_raw == &LibRaw::packed_dng_load_raw)\n  {\n    d_info->decoder_name = \"packed_dng_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;\n  }\n  else if (load_raw == &LibRaw::pentax_load_raw)\n  {\n    d_info->decoder_name = \"pentax_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::nikon_load_raw)\n  {\n    d_info->decoder_name = \"nikon_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::nikon_coolscan_load_raw)\n  {\n    d_info->decoder_name = \"nikon_coolscan_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::nikon_load_sraw)\n  {\n    d_info->decoder_name = \"nikon_load_sraw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::nikon_yuv_load_raw)\n  {\n    d_info->decoder_name = \"nikon_load_yuv_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::rollei_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"rollei_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::phase_one_load_raw)\n  {\n    d_info->decoder_name = \"phase_one_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::phase_one_load_raw_c)\n  {\n    d_info->decoder_name = \"phase_one_load_raw_c()\";\n  }\n  else if (load_raw == &LibRaw::hasselblad_load_raw)\n  {\n    d_info->decoder_name = \"hasselblad_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::leaf_hdr_load_raw)\n  {\n    d_info->decoder_name = \"leaf_hdr_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::unpacked_load_raw)\n  {\n    d_info->decoder_name = \"unpacked_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::unpacked_load_raw_reversed)\n  {\n    d_info->decoder_name = \"unpacked_load_raw_reversed()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::sinar_4shot_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"sinar_4shot_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::imacon_full_load_raw)\n  {\n    d_info->decoder_name = \"imacon_full_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::hasselblad_full_load_raw)\n  {\n    d_info->decoder_name = \"hasselblad_full_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::packed_load_raw)\n  {\n    d_info->decoder_name = \"packed_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::broadcom_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"broadcom_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::nokia_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"nokia_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::canon_rmf_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"canon_rmf_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::panasonic_load_raw)\n  {\n    d_info->decoder_name = \"panasonic_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::olympus_load_raw)\n  {\n    d_info->decoder_name = \"olympus_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::minolta_rd175_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"minolta_rd175_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::quicktake_100_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"quicktake_100_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::kodak_radc_load_raw)\n  {\n    d_info->decoder_name = \"kodak_radc_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::kodak_jpeg_load_raw)\n  {\n    // UNTESTED + RBAYER\n    d_info->decoder_name = \"kodak_jpeg_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::lossy_dng_load_raw)\n  {\n    // Check rbayer\n    d_info->decoder_name = \"lossy_dng_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_HASCURVE;\n  }\n  else if (load_raw == &LibRaw::kodak_dc120_load_raw)\n  {\n    d_info->decoder_name = \"kodak_dc120_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::eight_bit_load_raw)\n  {\n    d_info->decoder_name = \"eight_bit_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_c330_load_raw)\n  {\n    d_info->decoder_name = \"kodak_yrgb_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_c603_load_raw)\n  {\n    d_info->decoder_name = \"kodak_yrgb_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_262_load_raw)\n  {\n    d_info->decoder_name = \"kodak_262_load_raw()\"; // UNTESTED!\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_65000_load_raw)\n  {\n    d_info->decoder_name = \"kodak_65000_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;\n  }\n  else if (load_raw == &LibRaw::kodak_ycbcr_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"kodak_ycbcr_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_rgb_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"kodak_rgb_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::sony_load_raw)\n  {\n    d_info->decoder_name = \"sony_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::sony_arw_load_raw)\n  {\n    d_info->decoder_name = \"sony_arw_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::sony_arw2_load_raw)\n  {\n    d_info->decoder_name = \"sony_arw2_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_SONYARW2;\n  }\n  else if (load_raw == &LibRaw::sony_arq_load_raw)\n  {\n    d_info->decoder_name = \"sony_arq_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_LEGACY_WITH_MARGINS;\n  }\n  else if (load_raw == &LibRaw::samsung_load_raw)\n  {\n    d_info->decoder_name = \"samsung_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::samsung2_load_raw)\n  {\n    d_info->decoder_name = \"samsung2_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::samsung3_load_raw)\n  {\n    d_info->decoder_name = \"samsung3_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::smal_v6_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"smal_v6_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::smal_v9_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"smal_v9_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::redcine_load_raw)\n  {\n    d_info->decoder_name = \"redcine_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;\n  }\n  else if (load_raw == &LibRaw::x3f_load_raw)\n  {\n    d_info->decoder_name = \"x3f_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC | LIBRAW_DECODER_FIXEDMAXC | LIBRAW_DECODER_LEGACY_WITH_MARGINS;\n  }\n  else if (load_raw == &LibRaw::pentax_4shot_load_raw)\n  {\n    d_info->decoder_name = \"pentax_4shot_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;\n  }\n  else if (load_raw == &LibRaw::deflate_dng_load_raw)\n  {\n    d_info->decoder_name = \"deflate_dng_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;\n  }\n  else if (load_raw == &LibRaw::nikon_load_striped_packed_raw)\n  {\n    d_info->decoder_name = \"nikon_load_striped_packed_raw()\";\n  }\n  else\n  {\n    d_info->decoder_name = \"Unknown unpack function\";\n    d_info->decoder_flags = LIBRAW_DECODER_NOTSET;\n  }\n  return LIBRAW_SUCCESS;\n}\n\nint LibRaw::adjust_maximum()\n{\n  ushort real_max;\n  float auto_threshold;\n\n  if (O.adjust_maximum_thr < 0.00001)\n    return LIBRAW_SUCCESS;\n  else if (O.adjust_maximum_thr > 0.99999)\n    auto_threshold = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;\n  else\n    auto_threshold = O.adjust_maximum_thr;\n\n  real_max = C.data_maximum;\n  if (real_max > 0 && real_max < C.maximum && real_max > C.maximum * auto_threshold)\n  {\n    C.maximum = real_max;\n  }\n  return LIBRAW_SUCCESS;\n}\n\nvoid LibRaw::merror(void *ptr, const char *where)\n{\n  if (ptr)\n    return;\n  if (callbacks.mem_cb)\n    (*callbacks.mem_cb)(\n        callbacks.memcb_data,\n        libraw_internal_data.internal_data.input ? libraw_internal_data.internal_data.input->fname() : NULL, where);\n  throw LIBRAW_EXCEPTION_ALLOC;\n}\n\nint LibRaw::open_file(const char *fname, INT64 max_buf_size)\n{\n#ifndef WIN32\n  struct stat st;\n  if (stat(fname, &st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size) ? 1 : 0;\n#else\n  struct _stati64 st;\n  if (_stati64(fname, &st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size) ? 1 : 0;\n#endif\n\n  LibRaw_abstract_datastream *stream;\n  try\n  {\n    if (big)\n      stream = new LibRaw_bigfile_datastream(fname);\n    else\n      stream = new LibRaw_file_datastream(fname);\n  }\n\n  catch (std::bad_alloc)\n  {\n    recycle();\n    return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  if (!stream->valid())\n  {\n    delete stream;\n    return LIBRAW_IO_ERROR;\n  }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n  {\n    ID.input_internal = 1; // flag to delete datastream on recycle\n  }\n  else\n  {\n    delete stream;\n    ID.input_internal = 0;\n  }\n  return ret;\n}\n\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\nint LibRaw::open_file(const wchar_t *fname, INT64 max_buf_size)\n{\n  struct _stati64 st;\n  if (_wstati64(fname, &st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size) ? 1 : 0;\n\n  LibRaw_abstract_datastream *stream;\n  try\n  {\n    if (big)\n      stream = new LibRaw_bigfile_datastream(fname);\n    else\n      stream = new LibRaw_file_datastream(fname);\n  }\n\n  catch (std::bad_alloc)\n  {\n    recycle();\n    return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  if (!stream->valid())\n  {\n    delete stream;\n    return LIBRAW_IO_ERROR;\n  }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n  {\n    ID.input_internal = 1; // flag to delete datastream on recycle\n  }\n  else\n  {\n    delete stream;\n    ID.input_internal = 0;\n  }\n  return ret;\n}\n#endif\n\nint LibRaw::open_buffer(void *buffer, size_t size)\n{\n  // this stream will close on recycle()\n  if (!buffer || buffer == (void *)-1)\n    return LIBRAW_IO_ERROR;\n\n  LibRaw_buffer_datastream *stream;\n  try\n  {\n    stream = new LibRaw_buffer_datastream(buffer, size);\n  }\n  catch (std::bad_alloc)\n  {\n    recycle();\n    return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  if (!stream->valid())\n  {\n    delete stream;\n    return LIBRAW_IO_ERROR;\n  }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n  {\n    ID.input_internal = 1; // flag to delete datastream on recycle\n  }\n  else\n  {\n    delete stream;\n    ID.input_internal = 0;\n  }\n  return ret;\n}\n\nint LibRaw::open_bayer(unsigned char *buffer, unsigned datalen, ushort _raw_width, ushort _raw_height,\n                       ushort _left_margin, ushort _top_margin, ushort _right_margin, ushort _bottom_margin,\n                       unsigned char procflags, unsigned char bayer_pattern, unsigned unused_bits, unsigned otherflags,\n                       unsigned black_level)\n{\n  // this stream will close on recycle()\n  if (!buffer || buffer == (void *)-1)\n    return LIBRAW_IO_ERROR;\n\n  LibRaw_buffer_datastream *stream;\n  try\n  {\n    stream = new LibRaw_buffer_datastream(buffer, datalen);\n  }\n  catch (std::bad_alloc)\n  {\n    recycle();\n    return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  if (!stream->valid())\n  {\n    delete stream;\n    return LIBRAW_IO_ERROR;\n  }\n  ID.input = stream;\n  SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);\n  // From identify\n  initdata();\n  strcpy(imgdata.idata.make, \"BayerDump\");\n  snprintf(imgdata.idata.model, sizeof(imgdata.idata.model) - 1, \"%u x %u pixels\", _raw_width, _raw_height);\n  S.flip = procflags >> 2;\n  libraw_internal_data.internal_output_params.zero_is_bad = procflags & 2;\n  libraw_internal_data.unpacker_data.data_offset = 0;\n  S.raw_width = _raw_width;\n  S.raw_height = _raw_height;\n  S.left_margin = _left_margin;\n  S.top_margin = _top_margin;\n  S.width = S.raw_width - S.left_margin - _right_margin;\n  S.height = S.raw_height - S.top_margin - _bottom_margin;\n\n  imgdata.idata.filters = 0x1010101 * bayer_pattern;\n  imgdata.idata.colors = 4 - !((imgdata.idata.filters & imgdata.idata.filters >> 1) & 0x5555);\n  libraw_internal_data.unpacker_data.load_flags = otherflags;\n  switch (libraw_internal_data.unpacker_data.tiff_bps = (datalen)*8 / (S.raw_width * S.raw_height))\n  {\n  case 8:\n    load_raw = &CLASS eight_bit_load_raw;\n    break;\n  case 10:\n    if ((datalen) / S.raw_height * 3 >= S.raw_width * 4)\n    {\n      load_raw = &CLASS android_loose_load_raw;\n      break;\n    }\n    else if (libraw_internal_data.unpacker_data.load_flags & 1)\n    {\n      load_raw = &CLASS android_tight_load_raw;\n      break;\n    }\n  case 12:\n    libraw_internal_data.unpacker_data.load_flags |= 128;\n    load_raw = &CLASS packed_load_raw;\n    break;\n  case 16:\n    libraw_internal_data.unpacker_data.order = 0x4949 | 0x404 * (libraw_internal_data.unpacker_data.load_flags & 1);\n    libraw_internal_data.unpacker_data.tiff_bps -= libraw_internal_data.unpacker_data.load_flags >> 4;\n    libraw_internal_data.unpacker_data.tiff_bps -= libraw_internal_data.unpacker_data.load_flags =\n        libraw_internal_data.unpacker_data.load_flags >> 1 & 7;\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  C.maximum = (1 << libraw_internal_data.unpacker_data.tiff_bps) - (1 << unused_bits);\n  C.black = black_level;\n  S.iwidth = S.width;\n  S.iheight = S.height;\n  imgdata.idata.colors = 3;\n  imgdata.idata.filters |= ((imgdata.idata.filters >> 2 & 0x22222222) | (imgdata.idata.filters << 2 & 0x88888888)) &\n                           imgdata.idata.filters << 1;\n\n  imgdata.idata.raw_count = 1;\n  for (int i = 0; i < 4; i++)\n    imgdata.color.pre_mul[i] = 1.0;\n\n  strcpy(imgdata.idata.cdesc, \"RGBG\");\n\n  ID.input_internal = 1;\n  SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);\n  return LIBRAW_SUCCESS;\n}\n\n#ifdef USE_ZLIB\ninline unsigned int __DNG_HalfToFloat(ushort halfValue)\n{\n  int sign = (halfValue >> 15) & 0x00000001;\n  int exponent = (halfValue >> 10) & 0x0000001f;\n  int mantissa = halfValue & 0x000003ff;\n  if (exponent == 0)\n  {\n    if (mantissa == 0)\n    {\n      return (unsigned int)(sign << 31);\n    }\n    else\n    {\n      while (!(mantissa & 0x00000400))\n      {\n        mantissa <<= 1;\n        exponent -= 1;\n      }\n      exponent += 1;\n      mantissa &= ~0x00000400;\n    }\n  }\n  else if (exponent == 31)\n  {\n    if (mantissa == 0)\n    {\n      return (unsigned int)((sign << 31) | ((0x1eL + 127 - 15) << 23) | (0x3ffL << 13));\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  exponent += (127 - 15);\n  mantissa <<= 13;\n  return (unsigned int)((sign << 31) | (exponent << 23) | mantissa);\n}\n\ninline unsigned int __DNG_FP24ToFloat(const unsigned char *input)\n{\n  int sign = (input[0] >> 7) & 0x01;\n  int exponent = (input[0]) & 0x7F;\n  int mantissa = (((int)input[1]) << 8) | input[2];\n  if (exponent == 0)\n  {\n    if (mantissa == 0)\n    {\n      return (unsigned int)(sign << 31);\n    }\n    else\n    {\n      while (!(mantissa & 0x00010000))\n      {\n        mantissa <<= 1;\n        exponent -= 1;\n      }\n      exponent += 1;\n      mantissa &= ~0x00010000;\n    }\n  }\n  else if (exponent == 127)\n  {\n    if (mantissa == 0)\n    {\n      return (unsigned int)((sign << 31) | ((0x7eL + 128 - 64) << 23) | (0xffffL << 7));\n    }\n    else\n    {\n      // Nan -- Just set to zero.\n      return 0;\n    }\n  }\n  exponent += (128 - 64);\n  mantissa <<= 7;\n  return (uint32_t)((sign << 31) | (exponent << 23) | mantissa);\n}\n\ninline void DecodeDeltaBytes(unsigned char *bytePtr, int cols, int channels)\n{\n  if (channels == 1)\n  {\n    unsigned char b0 = bytePtr[0];\n    bytePtr += 1;\n    for (uint32_t col = 1; col < cols; ++col)\n    {\n      b0 += bytePtr[0];\n      bytePtr[0] = b0;\n      bytePtr += 1;\n    }\n  }\n  else if (channels == 3)\n  {\n    unsigned char b0 = bytePtr[0];\n    unsigned char b1 = bytePtr[1];\n    unsigned char b2 = bytePtr[2];\n    bytePtr += 3;\n    for (int col = 1; col < cols; ++col)\n    {\n      b0 += bytePtr[0];\n      b1 += bytePtr[1];\n      b2 += bytePtr[2];\n      bytePtr[0] = b0;\n      bytePtr[1] = b1;\n      bytePtr[2] = b2;\n      bytePtr += 3;\n    }\n  }\n  else if (channels == 4)\n  {\n    unsigned char b0 = bytePtr[0];\n    unsigned char b1 = bytePtr[1];\n    unsigned char b2 = bytePtr[2];\n    unsigned char b3 = bytePtr[3];\n    bytePtr += 4;\n    for (uint32_t col = 1; col < cols; ++col)\n    {\n      b0 += bytePtr[0];\n      b1 += bytePtr[1];\n      b2 += bytePtr[2];\n      b3 += bytePtr[3];\n      bytePtr[0] = b0;\n      bytePtr[1] = b1;\n      bytePtr[2] = b2;\n      bytePtr[3] = b3;\n      bytePtr += 4;\n    }\n  }\n  else\n  {\n    for (int col = 1; col < cols; ++col)\n    {\n      for (int chan = 0; chan < channels; ++chan)\n      {\n        bytePtr[chan + channels] += bytePtr[chan];\n      }\n      bytePtr += channels;\n    }\n  }\n}\n\nstatic void DecodeFPDelta(unsigned char *input, unsigned char *output, int cols, int channels, int bytesPerSample)\n{\n  DecodeDeltaBytes(input, cols * bytesPerSample, channels);\n  int32_t rowIncrement = cols * channels;\n\n  if (bytesPerSample == 2)\n  {\n\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n#else\n    const unsigned char *input1 = input;\n    const unsigned char *input0 = input + rowIncrement;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output += 2;\n    }\n  }\n  else if (bytesPerSample == 3)\n  {\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output += 3;\n    }\n  }\n  else\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    const unsigned char *input3 = input + rowIncrement * 3;\n#else\n    const unsigned char *input3 = input;\n    const unsigned char *input2 = input + rowIncrement;\n    const unsigned char *input1 = input + rowIncrement * 2;\n    const unsigned char *input0 = input + rowIncrement * 3;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output[3] = input3[col];\n      output += 4;\n    }\n  }\n}\n\nstatic float expandFloats(unsigned char *dst, int tileWidth, int bytesps)\n{\n  float max = 0.f;\n  if (bytesps == 2)\n  {\n    uint16_t *dst16 = (ushort *)dst;\n    uint32_t *dst32 = (unsigned int *)dst;\n    float *f32 = (float *)dst;\n    for (int index = tileWidth - 1; index >= 0; --index)\n    {\n      dst32[index] = __DNG_HalfToFloat(dst16[index]);\n      max = MAX(max, f32[index]);\n    }\n  }\n  else if (bytesps == 3)\n  {\n    uint8_t *dst8 = ((unsigned char *)dst) + (tileWidth - 1) * 3;\n    uint32_t *dst32 = (unsigned int *)dst;\n    float *f32 = (float *)dst;\n    for (int index = tileWidth - 1; index >= 0; --index, dst8 -= 3)\n    {\n      dst32[index] = __DNG_FP24ToFloat(dst8);\n      max = MAX(max, f32[index]);\n    }\n  }\n  else if (bytesps == 4)\n  {\n    float *f32 = (float *)dst;\n    for (int index = 0; index < tileWidth; index++)\n      max = MAX(max, f32[index]);\n  }\n  return max;\n}\n\nvoid LibRaw::deflate_dng_load_raw()\n{\n  struct tiff_ifd_t *ifd = &tiff_ifd[0];\n  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&\n         ifd->offset != libraw_internal_data.unpacker_data.data_offset)\n    ++ifd;\n  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n  {\n    throw LIBRAW_EXCEPTION_DECODE_RAW;\n  }\n\n  float *float_raw_image = 0;\n  float max = 0.f;\n\n  if (ifd->samples != 1 && ifd->samples != 3 && ifd->samples != 4)\n    throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported\n\n  if (libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)\n    throw LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD\n\n  size_t tilesH = (imgdata.sizes.raw_width + libraw_internal_data.unpacker_data.tile_width - 1) /\n                  libraw_internal_data.unpacker_data.tile_width;\n  size_t tilesV = (imgdata.sizes.raw_height + libraw_internal_data.unpacker_data.tile_length - 1) /\n                  libraw_internal_data.unpacker_data.tile_length;\n  size_t tileCnt = tilesH * tilesV;\n\n  if (ifd->sample_format == 3)\n  { // Floating point data\n    float_raw_image = (float *)calloc(tileCnt * libraw_internal_data.unpacker_data.tile_length *\n                                          libraw_internal_data.unpacker_data.tile_width * ifd->samples,\n                                      sizeof(float));\n    // imgdata.color.maximum = 65535;\n    // imgdata.color.black = 0;\n    // memset(imgdata.color.cblack,0,sizeof(imgdata.color.cblack));\n  }\n  else\n    throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported\n\n  int xFactor;\n  switch (ifd->predictor)\n  {\n  case 3:\n  default:\n    xFactor = 1;\n    break;\n  case 34894:\n    xFactor = 2;\n    break;\n  case 34895:\n    xFactor = 4;\n    break;\n  }\n\n  if (libraw_internal_data.unpacker_data.tile_length < INT_MAX)\n  {\n    if (tileCnt < 1 || tileCnt > 1000000)\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n    size_t *tOffsets = (size_t *)malloc(tileCnt * sizeof(size_t));\n    for (int t = 0; t < tileCnt; ++t)\n      tOffsets[t] = get4();\n\n    size_t *tBytes = (size_t *)malloc(tileCnt * sizeof(size_t));\n    unsigned long maxBytesInTile = 0;\n    if (tileCnt == 1)\n      tBytes[0] = maxBytesInTile = ifd->bytes;\n    else\n    {\n      libraw_internal_data.internal_data.input->seek(ifd->bytes, SEEK_SET);\n      for (size_t t = 0; t < tileCnt; ++t)\n      {\n        tBytes[t] = get4();\n        maxBytesInTile = MAX(maxBytesInTile, tBytes[t]);\n      }\n    }\n    unsigned tilePixels =\n        libraw_internal_data.unpacker_data.tile_width * libraw_internal_data.unpacker_data.tile_length;\n    unsigned pixelSize = sizeof(float) * ifd->samples;\n    unsigned tileBytes = tilePixels * pixelSize;\n    unsigned tileRowBytes = libraw_internal_data.unpacker_data.tile_width * pixelSize;\n\n    unsigned char *cBuffer = (unsigned char *)malloc(maxBytesInTile);\n    unsigned char *uBuffer = (unsigned char *)malloc(tileBytes + tileRowBytes); // extra row for decoding\n\n    for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += libraw_internal_data.unpacker_data.tile_length)\n    {\n      for (size_t x = 0; x < imgdata.sizes.raw_width; x += libraw_internal_data.unpacker_data.tile_width, ++t)\n      {\n        libraw_internal_data.internal_data.input->seek(tOffsets[t], SEEK_SET);\n        libraw_internal_data.internal_data.input->read(cBuffer, 1, tBytes[t]);\n        unsigned long dstLen = tileBytes;\n        int err = uncompress(uBuffer + tileRowBytes, &dstLen, cBuffer, tBytes[t]);\n        if (err != Z_OK)\n        {\n          free(tOffsets);\n          free(tBytes);\n          free(cBuffer);\n          free(uBuffer);\n          throw LIBRAW_EXCEPTION_DECODE_RAW;\n          return;\n        }\n        else\n        {\n          int bytesps = ifd->bps >> 3;\n          size_t rowsInTile = y + libraw_internal_data.unpacker_data.tile_length > imgdata.sizes.raw_height\n                                  ? imgdata.sizes.raw_height - y\n                                  : libraw_internal_data.unpacker_data.tile_length;\n          size_t colsInTile = x + libraw_internal_data.unpacker_data.tile_width > imgdata.sizes.raw_width\n                                  ? imgdata.sizes.raw_width - x\n                                  : libraw_internal_data.unpacker_data.tile_width;\n\n          for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed\n          {\n            unsigned char *dst = uBuffer + row * libraw_internal_data.unpacker_data.tile_width * bytesps * ifd->samples;\n            unsigned char *src = dst + tileRowBytes;\n            DecodeFPDelta(src, dst, libraw_internal_data.unpacker_data.tile_width / xFactor, ifd->samples * xFactor,\n                          bytesps);\n            float lmax = expandFloats(dst, libraw_internal_data.unpacker_data.tile_width * ifd->samples, bytesps);\n            max = MAX(max, lmax);\n            unsigned char *dst2 =\n                (unsigned char *)&float_raw_image[((y + row) * imgdata.sizes.raw_width + x) * ifd->samples];\n            memmove(dst2, dst, colsInTile * ifd->samples * sizeof(float));\n          }\n        }\n      }\n    }\n    free(tOffsets);\n    free(tBytes);\n    free(cBuffer);\n    free(uBuffer);\n  }\n  imgdata.color.fmaximum = max;\n\n  // Set fields according to data format\n\n  imgdata.rawdata.raw_alloc = float_raw_image;\n  if (ifd->samples == 1)\n  {\n    imgdata.rawdata.float_image = float_raw_image;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 4;\n  }\n  else if (ifd->samples == 3)\n  {\n    imgdata.rawdata.float3_image = (float(*)[3])float_raw_image;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 12;\n  }\n  else if (ifd->samples == 4)\n  {\n    imgdata.rawdata.float4_image = (float(*)[4])float_raw_image;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 16;\n  }\n\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT)\n    convertFloatToInt(); // with default settings\n}\n#else\nvoid LibRaw::deflate_dng_load_raw() { throw LIBRAW_EXCEPTION_DECODE_RAW; }\n#endif\n\nint LibRaw::is_floating_point()\n{\n  struct tiff_ifd_t *ifd = &tiff_ifd[0];\n  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&\n         ifd->offset != libraw_internal_data.unpacker_data.data_offset)\n    ++ifd;\n  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n    return 0;\n\n  return ifd->sample_format == 3;\n}\n\nint LibRaw::have_fpdata()\n{\n  return imgdata.rawdata.float_image || imgdata.rawdata.float3_image || imgdata.rawdata.float4_image;\n}\n\nvoid LibRaw::convertFloatToInt(float dmin /* =4096.f */, float dmax /* =32767.f */, float dtarget /*= 16383.f */)\n{\n  int samples = 0;\n  float *data = 0;\n  if (imgdata.rawdata.float_image)\n  {\n    samples = 1;\n    data = imgdata.rawdata.float_image;\n  }\n  else if (imgdata.rawdata.float3_image)\n  {\n    samples = 3;\n    data = (float *)imgdata.rawdata.float3_image;\n  }\n  else if (imgdata.rawdata.float4_image)\n  {\n    samples = 4;\n    data = (float *)imgdata.rawdata.float4_image;\n  }\n  else\n    return;\n\n  ushort *raw_alloc = (ushort *)malloc(imgdata.sizes.raw_height * imgdata.sizes.raw_width *\n                                       libraw_internal_data.unpacker_data.tiff_samples * sizeof(ushort));\n  float tmax = MAX(imgdata.color.maximum, 1);\n  float datamax = imgdata.color.fmaximum;\n\n  tmax = MAX(tmax, datamax);\n  tmax = MAX(tmax, 1.f);\n\n  float multip = 1.f;\n  if (tmax < dmin || tmax > dmax)\n  {\n    imgdata.rawdata.color.fnorm = imgdata.color.fnorm = multip = dtarget / tmax;\n    imgdata.rawdata.color.maximum = imgdata.color.maximum = dtarget;\n    imgdata.rawdata.color.black = imgdata.color.black = (float)imgdata.color.black * multip;\n    for (int i = 0; i < sizeof(imgdata.color.cblack) / sizeof(imgdata.color.cblack[0]); i++)\n      if (i != 4 && i != 5)\n        imgdata.rawdata.color.cblack[i] = imgdata.color.cblack[i] = (float)imgdata.color.cblack[i] * multip;\n  }\n  else\n    imgdata.rawdata.color.fnorm = imgdata.color.fnorm = 0.f;\n\n  for (size_t i = 0;\n       i < imgdata.sizes.raw_height * imgdata.sizes.raw_width * libraw_internal_data.unpacker_data.tiff_samples; ++i)\n  {\n    float val = MAX(data[i], 0.f);\n    raw_alloc[i] = (ushort)(val * multip);\n  }\n\n  if (samples == 1)\n  {\n    imgdata.rawdata.raw_alloc = imgdata.rawdata.raw_image = raw_alloc;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 2;\n  }\n  else if (samples == 3)\n  {\n    imgdata.rawdata.raw_alloc = imgdata.rawdata.color3_image = (ushort(*)[3])raw_alloc;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;\n  }\n  else if (samples == 4)\n  {\n    imgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = (ushort(*)[4])raw_alloc;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 8;\n  }\n  free(data); // remove old allocation\n  imgdata.rawdata.float_image = 0;\n  imgdata.rawdata.float3_image = 0;\n  imgdata.rawdata.float4_image = 0;\n}\n\nvoid LibRaw::sony_arq_load_raw()\n{\n  int row, col;\n  read_shorts(imgdata.rawdata.raw_image, imgdata.sizes.raw_width * imgdata.sizes.raw_height * 4);\n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    unsigned short(*rowp)[4] = (unsigned short(*)[4]) & imgdata.rawdata.raw_image[row * imgdata.sizes.raw_width * 4];\n    for (col = 0; col < imgdata.sizes.raw_width; col++)\n    {\n      unsigned short g2 = rowp[col][2];\n      rowp[col][2] = rowp[col][3];\n      rowp[col][3] = g2;\n      if (((unsigned)(row - imgdata.sizes.top_margin) < imgdata.sizes.height) &&\n          ((unsigned)(col - imgdata.sizes.left_margin) < imgdata.sizes.width) &&\n          (MAX(MAX(rowp[col][0], rowp[col][1]), MAX(rowp[col][2], rowp[col][3])) > imgdata.color.maximum))\n        derror();\n    }\n  }\n}\n\nvoid LibRaw::pentax_4shot_load_raw()\n{\n  ushort *plane = (ushort *)malloc(imgdata.sizes.raw_width * imgdata.sizes.raw_height * sizeof(ushort));\n  int alloc_sz = imgdata.sizes.raw_width * (imgdata.sizes.raw_height + 16) * 4 * sizeof(ushort);\n  ushort(*result)[4] = (ushort(*)[4])malloc(alloc_sz);\n  struct movement_t\n  {\n    int row, col;\n  } _move[4] = {\n      {1, 1},\n      {0, 1},\n      {0, 0},\n      {1, 0},\n  };\n\n  int tidx = 0;\n  for (int i = 0; i < 4; i++)\n  {\n    int move_row, move_col;\n    if (imgdata.params.p4shot_order[i] >= '0' && imgdata.params.p4shot_order[i] <= '3')\n    {\n      move_row = (imgdata.params.p4shot_order[i] - '0' & 2) ? 1 : 0;\n      move_col = (imgdata.params.p4shot_order[i] - '0' & 1) ? 1 : 0;\n    }\n    else\n    {\n      move_row = _move[i].row;\n      move_col = _move[i].col;\n    }\n    for (; tidx < 16; tidx++)\n      if (tiff_ifd[tidx].t_width == imgdata.sizes.raw_width && tiff_ifd[tidx].t_height == imgdata.sizes.raw_height &&\n          tiff_ifd[tidx].bps > 8 && tiff_ifd[tidx].samples == 1)\n        break;\n    if (tidx >= 16)\n      break;\n    imgdata.rawdata.raw_image = plane;\n    ID.input->seek(tiff_ifd[tidx].offset, SEEK_SET);\n    imgdata.idata.filters = 0xb4b4b4b4;\n    libraw_internal_data.unpacker_data.data_offset = tiff_ifd[tidx].offset;\n    (this->*pentax_component_load_raw)();\n    for (int row = 0; row < imgdata.sizes.raw_height - move_row; row++)\n    {\n      int colors[2];\n      for (int c = 0; c < 2; c++)\n        colors[c] = COLOR(row, c);\n      ushort *srcrow = &plane[imgdata.sizes.raw_width * row];\n      ushort(*dstrow)[4] = &result[(imgdata.sizes.raw_width) * (row + move_row) + move_col];\n      for (int col = 0; col < imgdata.sizes.raw_width - move_col; col++)\n        dstrow[col][colors[col % 2]] = srcrow[col];\n    }\n    tidx++;\n  }\n  // assign things back:\n  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 8;\n  imgdata.idata.filters = 0;\n  imgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = result;\n  free(plane);\n  imgdata.rawdata.raw_image = 0;\n}\n\nvoid LibRaw::hasselblad_full_load_raw()\n{\n  int row, col;\n\n  for (row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++)\n    {\n      read_shorts(&imgdata.image[row * S.width + col][2], 1); // B\n      read_shorts(&imgdata.image[row * S.width + col][1], 1); // G\n      read_shorts(&imgdata.image[row * S.width + col][0], 1); // R\n    }\n}\n\nstatic inline void unpack7bytesto4x16(unsigned char *src, unsigned short *dest)\n{\n  dest[0] = (src[0] << 6) | (src[1] >> 2);\n  dest[1] = ((src[1] & 0x3) << 12) | (src[2] << 4) | (src[3] >> 4);\n  dest[2] = (src[3] & 0xf) << 10 | (src[4] << 2) | (src[5] >> 6);\n  dest[3] = ((src[5] & 0x3f) << 8) | src[6];\n}\n\nstatic inline void unpack28bytesto16x16ns(unsigned char *src, unsigned short *dest)\n{\n  dest[0] = (src[3] << 6) | (src[2] >> 2);\n  dest[1] = ((src[2] & 0x3) << 12) | (src[1] << 4) | (src[0] >> 4);\n  dest[2] = (src[0] & 0xf) << 10 | (src[7] << 2) | (src[6] >> 6);\n  dest[3] = ((src[6] & 0x3f) << 8) | src[5];\n  dest[4] = (src[4] << 6) | (src[11] >> 2);\n  dest[5] = ((src[11] & 0x3) << 12) | (src[10] << 4) | (src[9] >> 4);\n  dest[6] = (src[9] & 0xf) << 10 | (src[8] << 2) | (src[15] >> 6);\n  dest[7] = ((src[15] & 0x3f) << 8) | src[14];\n  dest[8] = (src[13] << 6) | (src[12] >> 2);\n  dest[9] = ((src[12] & 0x3) << 12) | (src[19] << 4) | (src[18] >> 4);\n  dest[10] = (src[18] & 0xf) << 10 | (src[17] << 2) | (src[16] >> 6);\n  dest[11] = ((src[16] & 0x3f) << 8) | src[23];\n  dest[12] = (src[22] << 6) | (src[21] >> 2);\n  dest[13] = ((src[21] & 0x3) << 12) | (src[20] << 4) | (src[27] >> 4);\n  dest[14] = (src[27] & 0xf) << 10 | (src[26] << 2) | (src[25] >> 6);\n  dest[15] = ((src[25] & 0x3f) << 8) | src[24];\n}\n\n#define swab32(x)                                                                                                      \\\n  ((unsigned int)((((unsigned int)(x) & (unsigned int)0x000000ffUL) << 24) |                                           \\\n                  (((unsigned int)(x) & (unsigned int)0x0000ff00UL) << 8) |                                            \\\n                  (((unsigned int)(x) & (unsigned int)0x00ff0000UL) >> 8) |                                            \\\n                  (((unsigned int)(x) & (unsigned int)0xff000000UL) >> 24)))\n\nstatic inline void swab32arr(unsigned *arr, unsigned len)\n{\n  for (unsigned i = 0; i < len; i++)\n    arr[i] = swab32(arr[i]);\n}\n#undef swab32\n\nvoid LibRaw::fuji_14bit_load_raw()\n{\n  const unsigned linelen = S.raw_width * 7 / 4;\n  const unsigned pitch = S.raw_pitch ? S.raw_pitch / 2 : S.raw_width;\n  unsigned char *buf = (unsigned char *)malloc(linelen);\n  merror(buf, \"fuji_14bit_load_raw()\");\n\n  for (int row = 0; row < S.raw_height; row++)\n  {\n    unsigned bytesread = libraw_internal_data.internal_data.input->read(buf, 1, linelen);\n    unsigned short *dest = &imgdata.rawdata.raw_image[pitch * row];\n    if (bytesread % 28)\n    {\n      swab32arr((unsigned *)buf, bytesread / 4);\n      for (int sp = 0, dp = 0; dp < pitch - 3 && sp < linelen - 6 && sp < bytesread - 6; sp += 7, dp += 4)\n        unpack7bytesto4x16(buf + sp, dest + dp);\n    }\n    else\n      for (int sp = 0, dp = 0; dp < pitch - 15 && sp < linelen - 27 && sp < bytesread - 27; sp += 28, dp += 16)\n        unpack28bytesto16x16ns(buf + sp, dest + dp);\n  }\n  free(buf);\n}\n\nvoid LibRaw::nikon_load_striped_packed_raw()\n{\n  int vbits = 0, bwide, rbits, bite, row, col, val, i;\n\n  UINT64 bitbuf = 0;\n  unsigned load_flags = 24; // libraw_internal_data.unpacker_data.load_flags;\n  unsigned tiff_bps = libraw_internal_data.unpacker_data.tiff_bps;\n  int tiff_compress = libraw_internal_data.unpacker_data.tiff_compress;\n\n  struct tiff_ifd_t *ifd = &tiff_ifd[0];\n  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&\n         ifd->offset != libraw_internal_data.unpacker_data.data_offset)\n    ++ifd;\n  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n    throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n  if (!ifd->rows_per_strip || !ifd->strip_offsets_count)\n    return; // not unpacked\n  int stripcnt = 0;\n\n  bwide = S.raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - S.raw_width * tiff_bps;\n  if (load_flags & 1)\n    bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  for (row = 0; row < S.raw_height; row++)\n  {\n    checkCancel();\n    if (!(row % ifd->rows_per_strip))\n    {\n      if (stripcnt >= ifd->strip_offsets_count)\n        return; // run out of data\n      libraw_internal_data.internal_data.input->seek(ifd->strip_offsets[stripcnt], SEEK_SET);\n      stripcnt++;\n    }\n    for (col = 0; col < S.raw_width; col++)\n    {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(libraw_internal_data.internal_data.input->get_char() << i);\n      }\n      imgdata.rawdata.raw_image[(row)*S.raw_width + (col)] = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);\n    }\n    vbits -= rbits;\n  }\n}\n\nstruct foveon_data_t\n{\n  const char *make;\n  const char *model;\n  const int raw_width, raw_height;\n  const int white;\n  const int left_margin, top_margin;\n  const int width, height;\n} foveon_data[] = {\n    {\"Sigma\", \"SD9\", 2304, 1531, 12000, 20, 8, 2266, 1510},\n    {\"Sigma\", \"SD9\", 1152, 763, 12000, 10, 2, 1132, 755},\n    {\"Sigma\", \"SD10\", 2304, 1531, 12000, 20, 8, 2266, 1510},\n    {\"Sigma\", \"SD10\", 1152, 763, 12000, 10, 2, 1132, 755},\n    {\"Sigma\", \"SD14\", 2688, 1792, 14000, 18, 12, 2651, 1767},\n    {\"Sigma\", \"SD14\", 2688, 896, 14000, 18, 6, 2651, 883}, // 2/3\n    {\"Sigma\", \"SD14\", 1344, 896, 14000, 9, 6, 1326, 883},  // 1/2\n    {\"Sigma\", \"SD15\", 2688, 1792, 2900, 18, 12, 2651, 1767},\n    {\"Sigma\", \"SD15\", 2688, 896, 2900, 18, 6, 2651, 883}, // 2/3 ?\n    {\"Sigma\", \"SD15\", 1344, 896, 2900, 9, 6, 1326, 883},  // 1/2 ?\n    {\"Sigma\", \"DP1\", 2688, 1792, 2100, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP1\", 2688, 896, 2100, 18, 6, 2651, 883}, // 2/3 ?\n    {\"Sigma\", \"DP1\", 1344, 896, 2100, 9, 6, 1326, 883},  // 1/2 ?\n    {\"Sigma\", \"DP1S\", 2688, 1792, 2200, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP1S\", 2688, 896, 2200, 18, 6, 2651, 883}, // 2/3\n    {\"Sigma\", \"DP1S\", 1344, 896, 2200, 9, 6, 1326, 883},  // 1/2\n    {\"Sigma\", \"DP1X\", 2688, 1792, 3560, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP1X\", 2688, 896, 3560, 18, 6, 2651, 883}, // 2/3\n    {\"Sigma\", \"DP1X\", 1344, 896, 3560, 9, 6, 1326, 883},  // 1/2\n    {\"Sigma\", \"DP2\", 2688, 1792, 2326, 13, 16, 2651, 1767},\n    {\"Sigma\", \"DP2\", 2688, 896, 2326, 13, 8, 2651, 883}, // 2/3 ??\n    {\"Sigma\", \"DP2\", 1344, 896, 2326, 7, 8, 1325, 883},  // 1/2 ??\n    {\"Sigma\", \"DP2S\", 2688, 1792, 2300, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP2S\", 2688, 896, 2300, 18, 6, 2651, 883}, // 2/3\n    {\"Sigma\", \"DP2S\", 1344, 896, 2300, 9, 6, 1326, 883},  // 1/2\n    {\"Sigma\", \"DP2X\", 2688, 1792, 2300, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP2X\", 2688, 896, 2300, 18, 6, 2651, 883},           // 2/3\n    {\"Sigma\", \"DP2X\", 1344, 896, 2300, 9, 6, 1325, 883},            // 1/2\n    {\"Sigma\", \"SD1\", 4928, 3264, 3900, 12, 52, 4807, 3205},         // Full size\n    {\"Sigma\", \"SD1\", 4928, 1632, 3900, 12, 26, 4807, 1603},         // 2/3 size\n    {\"Sigma\", \"SD1\", 2464, 1632, 3900, 6, 26, 2403, 1603},          // 1/2 size\n    {\"Sigma\", \"SD1 Merrill\", 4928, 3264, 3900, 12, 52, 4807, 3205}, // Full size\n    {\"Sigma\", \"SD1 Merrill\", 4928, 1632, 3900, 12, 26, 4807, 1603}, // 2/3 size\n    {\"Sigma\", \"SD1 Merrill\", 2464, 1632, 3900, 6, 26, 2403, 1603},  // 1/2 size\n    {\"Sigma\", \"DP1 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},\n    {\"Sigma\", \"DP1 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size\n    {\"Sigma\", \"DP1 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size\n    {\"Sigma\", \"DP2 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},\n    {\"Sigma\", \"DP2 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size\n    {\"Sigma\", \"DP2 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size\n    {\"Sigma\", \"DP3 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},\n    {\"Sigma\", \"DP3 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size\n    {\"Sigma\", \"DP3 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size\n    {\"Polaroid\", \"x530\", 1440, 1088, 2700, 10, 13, 1419, 1059},\n    // dp2 Q\n    {\"Sigma\", \"dp3 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size\n    {\"Sigma\", \"dp3 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size\n    {\"Sigma\", \"dp2 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size\n    {\"Sigma\", \"dp2 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size\n    {\"Sigma\", \"dp1 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size\n    {\"Sigma\", \"dp1 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size\n    {\"Sigma\", \"dp0 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size\n    {\"Sigma\", \"dp0 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size\n    // Sigma sd Quattro\n    {\"Sigma\", \"sd Quattro\", 5888, 3776, 16383, 204, 76, 5446, 3624}, // full size\n    {\"Sigma\", \"sd Quattro\", 2944, 1888, 16383, 102, 38, 2723, 1812}, // half size\n    // Sd Quattro H\n    {\"Sigma\", \"sd Quattro H\", 6656, 4480, 16383, 224, 160, 6208, 4160}, // full size\n    {\"Sigma\", \"sd Quattro H\", 3328, 2240, 16383, 112, 80, 3104, 2080},  // half size\n    {\"Sigma\", \"sd Quattro H\", 5504, 3680, 16383, 0, 4, 5496, 3668},     // full size\n    {\"Sigma\", \"sd Quattro H\", 2752, 1840, 16383, 0, 2, 2748, 1834},     // half size\n};\nconst int foveon_count = sizeof(foveon_data) / sizeof(foveon_data[0]);\n\nint LibRaw::open_datastream(LibRaw_abstract_datastream *stream)\n{\n\n  if (!stream)\n    return ENOENT;\n  if (!stream->valid())\n    return LIBRAW_IO_ERROR;\n  recycle();\n  if(callbacks.pre_identify_cb)\n  {\n    int r = (callbacks.pre_identify_cb)(this);\n    if(r == 1) goto final;\n  }\n\n\n  try\n  {\n    ID.input = stream;\n    SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);\n\n    identify();\n    if(callbacks.post_identify_cb)\n\t(callbacks.post_identify_cb)(this);\n\n#if 0\n    if(!strcasecmp(imgdata.idata.make, \"Sony\")\n       && imgdata.color.maximum > 0\n       && imgdata.color.linear_max[0] > imgdata.color.maximum*3\n       && imgdata.color.linear_max[0] <= imgdata.color.maximum*4)\n         for(int c = 0; c<4; c++)\n\t   imgdata.color.linear_max[c] /= 4;\n#endif\n\n    if (!strcasecmp(imgdata.idata.make, \"Canon\") && (load_raw == &LibRaw::canon_sraw_load_raw) &&\n        imgdata.sizes.raw_width > 0)\n    {\n      float ratio = float(imgdata.sizes.raw_height) / float(imgdata.sizes.raw_width);\n      if ((ratio < 0.57 || ratio > 0.75) && imgdata.makernotes.canon.SensorHeight > 1 &&\n          imgdata.makernotes.canon.SensorWidth > 1)\n      {\n        imgdata.sizes.raw_width = imgdata.makernotes.canon.SensorWidth;\n        imgdata.sizes.left_margin = imgdata.makernotes.canon.SensorLeftBorder;\n        imgdata.sizes.iwidth = imgdata.sizes.width =\n            imgdata.makernotes.canon.SensorRightBorder - imgdata.makernotes.canon.SensorLeftBorder + 1;\n        imgdata.sizes.raw_height = imgdata.makernotes.canon.SensorHeight;\n        imgdata.sizes.top_margin = imgdata.makernotes.canon.SensorTopBorder;\n        imgdata.sizes.iheight = imgdata.sizes.height =\n            imgdata.makernotes.canon.SensorBottomBorder - imgdata.makernotes.canon.SensorTopBorder + 1;\n        libraw_internal_data.unpacker_data.load_flags |= 256; // reset width/height in canon_sraw_load_raw()\n        imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;\n      }\n      else if (imgdata.sizes.raw_width == 4032 && imgdata.sizes.raw_height == 3402 &&\n               !strcasecmp(imgdata.idata.model, \"EOS 80D\")) // 80D hardcoded\n      {\n        imgdata.sizes.raw_width = 4536;\n        imgdata.sizes.left_margin = 28;\n        imgdata.sizes.iwidth = imgdata.sizes.width = imgdata.sizes.raw_width - imgdata.sizes.left_margin;\n        imgdata.sizes.raw_height = 3024;\n        imgdata.sizes.top_margin = 8;\n        imgdata.sizes.iheight = imgdata.sizes.height = imgdata.sizes.raw_height - imgdata.sizes.top_margin;\n        libraw_internal_data.unpacker_data.load_flags |= 256;\n        imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;\n      }\n    }\n\n    // XTrans Compressed?\n    if (!imgdata.idata.dng_version && !strcasecmp(imgdata.idata.make, \"Fujifilm\") &&\n        (load_raw == &LibRaw::unpacked_load_raw))\n    {\n      if (imgdata.sizes.raw_width * imgdata.sizes.raw_height * 2 != libraw_internal_data.unpacker_data.data_size)\n      {\n        if (imgdata.sizes.raw_width * imgdata.sizes.raw_height * 7 / 4 == libraw_internal_data.unpacker_data.data_size)\n          load_raw = &LibRaw::fuji_14bit_load_raw;\n        else\n          parse_fuji_compressed_header();\n      }\n      if (imgdata.idata.filters == 9)\n      {\n        // Adjust top/left margins for X-Trans\n        int newtm = imgdata.sizes.top_margin % 6 ? (imgdata.sizes.top_margin / 6 + 1) * 6 : imgdata.sizes.top_margin;\n        int newlm = imgdata.sizes.left_margin % 6 ? (imgdata.sizes.left_margin / 6 + 1) * 6 : imgdata.sizes.left_margin;\n        if (newtm != imgdata.sizes.top_margin || newlm != imgdata.sizes.left_margin)\n        {\n          imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);\n          imgdata.sizes.top_margin = newtm;\n          imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);\n          imgdata.sizes.left_margin = newlm;\n          for (int c1 = 0; c1 < 6; c1++)\n            for (int c2 = 0; c2 < 6; c2++)\n              imgdata.idata.xtrans[c1][c2] = imgdata.idata.xtrans_abs[c1][c2];\n        }\n      }\n    }\n\n    // Fix DNG white balance if needed\n    if (imgdata.idata.dng_version && (imgdata.idata.filters == 0) && imgdata.idata.colors > 1 &&\n        imgdata.idata.colors < 5)\n    {\n      float delta[4] = {0.f, 0.f, 0.f, 0.f};\n      int black[4];\n      for (int c = 0; c < 4; c++)\n        black[c] = imgdata.color.dng_levels.dng_black + imgdata.color.dng_levels.dng_cblack[c];\n      for (int c = 0; c < imgdata.idata.colors; c++)\n        delta[c] = imgdata.color.dng_levels.dng_whitelevel[c] - black[c];\n      float mindelta = delta[0], maxdelta = delta[0];\n      for (int c = 1; c < imgdata.idata.colors; c++)\n      {\n        if (mindelta > delta[c])\n          mindelta = delta[c];\n        if (maxdelta < delta[c])\n          maxdelta = delta[c];\n      }\n      if (mindelta > 1 && maxdelta < (mindelta * 20)) // safety\n      {\n        for (int c = 0; c < imgdata.idata.colors; c++)\n        {\n          imgdata.color.cam_mul[c] /= (delta[c] / maxdelta);\n          imgdata.color.pre_mul[c] /= (delta[c] / maxdelta);\n        }\n        imgdata.color.maximum = imgdata.color.cblack[0] + maxdelta;\n      }\n    }\n\n    if (imgdata.idata.dng_version &&\n        ((!strcasecmp(imgdata.idata.make, \"Leica\") && !strcasecmp(imgdata.idata.model, \"D-LUX (Typ 109)\")) ||\n         (!strcasecmp(imgdata.idata.make, \"Panasonic\") && !strcasecmp(imgdata.idata.model, \"LX100\"))))\n      imgdata.sizes.width = 4288;\n\n    if (!strncasecmp(imgdata.idata.make, \"Sony\", 4) && imgdata.idata.dng_version &&\n        !(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP))\n    {\n      if (S.raw_width == 3984)\n        S.width = 3925;\n      else if (S.raw_width == 4288)\n        S.width = S.raw_width - 32;\n      else if (S.raw_width == 4928 && S.height < 3280)\n        S.width = S.raw_width - 8;\n      else if (S.raw_width == 5504)\n        S.width = S.raw_width - (S.height > 3664 ? 8 : 32);\n    }\n\n    if (!strcasecmp(imgdata.idata.make, \"Pentax\") &&\n        /*!strcasecmp(imgdata.idata.model,\"K-3 II\")  &&*/ imgdata.idata.raw_count == 4 &&\n        (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES))\n    {\n      imgdata.idata.raw_count = 1;\n      imgdata.idata.filters = 0;\n      imgdata.idata.colors = 4;\n      IO.mix_green = 1;\n      pentax_component_load_raw = load_raw;\n      load_raw = &LibRaw::pentax_4shot_load_raw;\n    }\n\n    if (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Leaf\") && !strcmp(imgdata.idata.model, \"Credo 50\"))\n    {\n      imgdata.color.pre_mul[0] = 1.f / 0.3984f;\n      imgdata.color.pre_mul[2] = 1.f / 0.7666f;\n      imgdata.color.pre_mul[1] = imgdata.color.pre_mul[3] = 1.0;\n    }\n\n    // S3Pro DNG patch\n    if (imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") && !strcmp(imgdata.idata.model, \"S3Pro\") &&\n        imgdata.sizes.raw_width == 4288)\n    {\n      imgdata.sizes.left_margin++;\n      imgdata.sizes.width--;\n    }\n    if (imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") && !strcmp(imgdata.idata.model, \"S5Pro\") &&\n        imgdata.sizes.raw_width == 4288)\n    {\n      imgdata.sizes.left_margin++;\n      imgdata.sizes.width--;\n    }\n    if (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") &&\n        (!strncmp(imgdata.idata.model, \"S20Pro\", 6) || !strncmp(imgdata.idata.model, \"F700\", 4)))\n    {\n      imgdata.sizes.raw_width /= 2;\n      load_raw = &LibRaw::unpacked_load_raw_fuji_f700s20;\n    }\n    if (load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\") &&\n        !libraw_internal_data.unpacker_data.load_flags &&\n        (!strncasecmp(imgdata.idata.model, \"D810\", 4) || !strcasecmp(imgdata.idata.model, \"D4S\")) &&\n        libraw_internal_data.unpacker_data.data_size * 2 == imgdata.sizes.raw_height * imgdata.sizes.raw_width * 3)\n    {\n      libraw_internal_data.unpacker_data.load_flags = 80;\n    }\n    // Adjust BL for Sony A900/A850\n    if (load_raw == &LibRaw::packed_load_raw &&\n        !strcasecmp(imgdata.idata.make, \"Sony\")) // 12 bit sony, but metadata may be for 14-bit range\n    {\n      if (C.maximum > 4095)\n        C.maximum = 4095;\n      if (C.black > 256 || C.cblack[0] > 256)\n      {\n        C.black /= 4;\n        for (int c = 0; c < 4; c++)\n          C.cblack[c] /= 4;\n        for (int c = 0; c < C.cblack[4] * C.cblack[5]; c++)\n          C.cblack[6 + c] /= 4;\n      }\n    }\n    if (load_raw == &LibRaw::nikon_yuv_load_raw) // Is it Nikon sRAW?\n    {\n      load_raw = &LibRaw::nikon_load_sraw;\n      C.black = 0;\n      memset(C.cblack, 0, sizeof(C.cblack));\n      imgdata.idata.filters = 0;\n      libraw_internal_data.unpacker_data.tiff_samples = 3;\n      imgdata.idata.colors = 3;\n      double beta_1 = -5.79342238397656E-02;\n      double beta_2 = 3.28163551282665;\n      double beta_3 = -8.43136004842678;\n      double beta_4 = 1.03533181861023E+01;\n      for (int i = 0; i <= 3072; i++)\n      {\n        double x = (double)i / 3072.;\n        double y = (1. - exp(-beta_1 * x - beta_2 * x * x - beta_3 * x * x * x - beta_4 * x * x * x * x));\n        if (y < 0.)\n          y = 0.;\n        imgdata.color.curve[i] = (y * 16383.);\n      }\n      for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 4; j++)\n          imgdata.color.rgb_cam[i][j] = float(i == j);\n    }\n    // Adjust BL for Nikon 12bit\n    if ((load_raw == &LibRaw::nikon_load_raw || load_raw == &LibRaw::packed_load_raw) &&\n        !strcasecmp(imgdata.idata.make, \"Nikon\") &&\n        strncmp(imgdata.idata.model, \"COOLPIX\", 7)\n        //\t   && strncmp(imgdata.idata.model,\"1 \",2)\n        && libraw_internal_data.unpacker_data.tiff_bps == 12)\n    {\n      C.maximum = 4095;\n      C.black /= 4;\n      for (int c = 0; c < 4; c++)\n        C.cblack[c] /= 4;\n      for (int c = 0; c < C.cblack[4] * C.cblack[5]; c++)\n        C.cblack[6 + c] /= 4;\n    }\n\n    // Adjust Highlight Linearity limit\n    if (C.linear_max[0] < 0)\n    {\n      if (imgdata.idata.dng_version)\n      {\n        for (int c = 0; c < 4; c++)\n          C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c + 6];\n      }\n      else\n      {\n        for (int c = 0; c < 4; c++)\n          C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c];\n      }\n    }\n\n    if (!strcasecmp(imgdata.idata.make, \"Nikon\") && (!C.linear_max[0]) && (C.maximum > 1024) &&\n        (load_raw != &LibRaw::nikon_load_sraw))\n    {\n      C.linear_max[0] = C.linear_max[1] = C.linear_max[2] = C.linear_max[3] = (long)((float)(C.maximum) / 1.07f);\n    }\n\n    // Correct WB for Samsung GX20\n    if (!strcasecmp(imgdata.idata.make, \"Samsung\") && !strcasecmp(imgdata.idata.model, \"GX20\"))\n    {\n      C.WB_Coeffs[LIBRAW_WBI_Daylight][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Daylight][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Shade][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Shade][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Cloudy][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Tungsten][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_D][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_D][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_N][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_N][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_W][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_W][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Flash][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Flash][2]) * 2.56f);\n      for (int c = 0; c < 64; c++)\n      {\n        if (imgdata.color.WBCT_Coeffs[c][0] > 0.0f)\n        {\n          imgdata.color.WBCT_Coeffs[c][3] *= 2.56f;\n        }\n      }\n    }\n\n    // Adjust BL for Panasonic\n    if (load_raw == &LibRaw::panasonic_load_raw &&\n        (!strcasecmp(imgdata.idata.make, \"Panasonic\") || !strcasecmp(imgdata.idata.make, \"Leica\") ||\n         !strcasecmp(imgdata.idata.make, \"YUNEEC\")) &&\n        ID.pana_black[0] && ID.pana_black[1] && ID.pana_black[2])\n    {\n      if(libraw_internal_data.unpacker_data.pana_encoding == 5)\n          P1.raw_count = 0; // Disable for new decoder\n      C.black = 0;\n      int add = libraw_internal_data.unpacker_data.pana_encoding == 4?15:0;\n      C.cblack[0] = ID.pana_black[0]+add;\n      C.cblack[1] = C.cblack[3] = ID.pana_black[1]+add;\n      C.cblack[2] = ID.pana_black[2]+add;\n      int i = C.cblack[3];\n      for (int c = 0; c < 3; c++)\n        if (i > C.cblack[c])\n          i = C.cblack[c];\n      for (int c = 0; c < 4; c++)\n        C.cblack[c] -= i;\n      C.black = i;\n    }\n\n    // Adjust sizes for X3F processing\n    if (load_raw == &LibRaw::x3f_load_raw)\n    {\n      for (int i = 0; i < foveon_count; i++)\n        if (!strcasecmp(imgdata.idata.make, foveon_data[i].make) &&\n            !strcasecmp(imgdata.idata.model, foveon_data[i].model) &&\n            imgdata.sizes.raw_width == foveon_data[i].raw_width &&\n            imgdata.sizes.raw_height == foveon_data[i].raw_height)\n        {\n          imgdata.sizes.top_margin = foveon_data[i].top_margin;\n          imgdata.sizes.left_margin = foveon_data[i].left_margin;\n          imgdata.sizes.width = imgdata.sizes.iwidth = foveon_data[i].width;\n          imgdata.sizes.height = imgdata.sizes.iheight = foveon_data[i].height;\n          C.maximum = foveon_data[i].white;\n          break;\n        }\n    }\n#if 0\n    size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;\n    float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);\n    float bpp2 = float(bytes)/float(S.width)/float(S.height);\n    printf(\"RawSize: %dx%d data offset: %d data size:%d bpp: %g bpp2: %g\\n\",S.raw_width,S.raw_height,libraw_internal_data.unpacker_data.data_offset,bytes,bpp,bpp2);\n    if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)\n      {\n        load_raw = &LibRaw::hasselblad_full_load_raw;\n        S.width = S.raw_width;\n        S.height = S.raw_height;\n        P1.filters = 0;\n        P1.colors=3;\n        P1.raw_count=1;\n        C.maximum=0xffff;\n        printf(\"3 channel hassy found\\n\");\n      }\n#endif\n    if (C.profile_length)\n    {\n      if (C.profile)\n        free(C.profile);\n      C.profile = malloc(C.profile_length);\n      merror(C.profile, \"LibRaw::open_file()\");\n      ID.input->seek(ID.profile_offset, SEEK_SET);\n      ID.input->read(C.profile, C.profile_length, 1);\n    }\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee)\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n\nfinal:;\n\n  if (P1.raw_count < 1)\n    return LIBRAW_FILE_UNSUPPORTED;\n\n  write_fun = &LibRaw::write_ppm_tiff;\n\n  if (load_raw == &LibRaw::kodak_ycbcr_load_raw)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  IO.shrink = P1.filters && (O.half_size || ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1)));\n  if (IO.shrink && P1.filters >= 1000)\n  {\n    S.width &= 65534;\n    S.height &= 65534;\n  }\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n\n  // Save color,sizes and internal data into raw_image fields\n  memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n  memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n  memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n  memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,\n          sizeof(libraw_internal_data.internal_output_params));\n\n  SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);\n\n  return LIBRAW_SUCCESS;\n}\n\n#ifdef USE_RAWSPEED\nvoid LibRaw::fix_after_rawspeed(int bl)\n{\n  if (load_raw == &LibRaw::lossy_dng_load_raw)\n    C.maximum = 0xffff;\n  else if (load_raw == &LibRaw::sony_load_raw)\n    C.maximum = 0x3ff0;\n}\n#else\nvoid LibRaw::fix_after_rawspeed(int) {}\n#endif\n\nvoid LibRaw::clearCancelFlag()\n{\n#ifdef WIN32\n  InterlockedExchange(&_exitflag, 0);\n#else\n  __sync_fetch_and_and(&_exitflag, 0);\n#endif\n#ifdef RAWSPEED_FASTEXIT\n  if (_rawspeed_decoder)\n  {\n    RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);\n    d->resumeProcessing();\n  }\n#endif\n}\n\nvoid LibRaw::setCancelFlag()\n{\n#ifdef WIN32\n  InterlockedExchange(&_exitflag, 1);\n#else\n  __sync_fetch_and_add(&_exitflag, 1);\n#endif\n#ifdef RAWSPEED_FASTEXIT\n  if (_rawspeed_decoder)\n  {\n    RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);\n    d->cancelProcessing();\n  }\n#endif\n}\n\nvoid LibRaw::checkCancel()\n{\n#ifdef WIN32\n  if (InterlockedExchange(&_exitflag, 0))\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#else\n  if (__sync_fetch_and_and(&_exitflag, 0))\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\nint LibRaw::try_rawspeed()\n{\n#ifdef USE_RAWSPEED\n  int ret = LIBRAW_SUCCESS;\n\n  int rawspeed_ignore_errors = 0;\n  if (imgdata.idata.dng_version && imgdata.idata.colors == 3 &&\n      !strcasecmp(imgdata.idata.software, \"Adobe Photoshop Lightroom 6.1.1 (Windows)\"))\n    rawspeed_ignore_errors = 1;\n\n  // RawSpeed Supported,\n  INT64 spos = ID.input->tell();\n  void *_rawspeed_buffer = 0;\n  try\n  {\n    //                printf(\"Using rawspeed\\n\");\n    ID.input->seek(0, SEEK_SET);\n    INT64 _rawspeed_buffer_sz = ID.input->size() + 32;\n    _rawspeed_buffer = malloc(_rawspeed_buffer_sz);\n    if (!_rawspeed_buffer)\n      throw LIBRAW_EXCEPTION_ALLOC;\n    ID.input->read(_rawspeed_buffer, _rawspeed_buffer_sz, 1);\n    FileMap map((uchar8 *)_rawspeed_buffer, _rawspeed_buffer_sz);\n    RawParser t(&map);\n    RawDecoder *d = 0;\n    CameraMetaDataLR *meta = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);\n    d = t.getDecoder();\n    if (!d)\n      throw \"Unable to find decoder\";\n    try\n    {\n      d->checkSupport(meta);\n    }\n    catch (const RawDecoderException &e)\n    {\n      imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;\n      throw e;\n    }\n    d->interpolateBadPixels = FALSE;\n    d->applyStage1DngOpcodes = FALSE;\n    _rawspeed_decoder = static_cast<void *>(d);\n    d->decodeRaw();\n    d->decodeMetaData(meta);\n    RawImage r = d->mRaw;\n    if (r->errors.size() > 0 && !rawspeed_ignore_errors)\n    {\n      delete d;\n      _rawspeed_decoder = 0;\n      throw 1;\n    }\n    if (r->isCFA)\n    {\n      imgdata.rawdata.raw_image = (ushort *)r->getDataUncropped(0, 0);\n    }\n    else if (r->getCpp() == 4)\n    {\n      imgdata.rawdata.color4_image = (ushort(*)[4])r->getDataUncropped(0, 0);\n      if (r->whitePoint > 0 && r->whitePoint < 65536)\n        C.maximum = r->whitePoint;\n    }\n    else if (r->getCpp() == 3)\n    {\n      imgdata.rawdata.color3_image = (ushort(*)[3])r->getDataUncropped(0, 0);\n      if (r->whitePoint > 0 && r->whitePoint < 65536)\n        C.maximum = r->whitePoint;\n    }\n    else\n    {\n      delete d;\n      _rawspeed_decoder = 0;\n      ret = LIBRAW_UNSPECIFIED_ERROR;\n    }\n    if (_rawspeed_decoder)\n    {\n      // set sizes\n      iPoint2D rsdim = r->getUncroppedDim();\n      S.raw_pitch = r->pitch;\n      S.raw_width = rsdim.x;\n      S.raw_height = rsdim.y;\n      // C.maximum = r->whitePoint;\n      fix_after_rawspeed(r->blackLevel);\n    }\n    free(_rawspeed_buffer);\n    _rawspeed_buffer = 0;\n    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;\n  }\n  catch (const RawDecoderException &RDE)\n  {\n    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;\n    if (_rawspeed_buffer)\n    {\n      free(_rawspeed_buffer);\n      _rawspeed_buffer = 0;\n    }\n    const char *p = RDE.what();\n    if (!strncmp(RDE.what(), \"Decoder canceled\", strlen(\"Decoder canceled\")))\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n    ret = LIBRAW_UNSPECIFIED_ERROR;\n  }\n  catch (...)\n  {\n    // We may get here due to cancellation flag\n    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;\n    if (_rawspeed_buffer)\n    {\n      free(_rawspeed_buffer);\n      _rawspeed_buffer = 0;\n    }\n    ret = LIBRAW_UNSPECIFIED_ERROR;\n  }\n  ID.input->seek(spos, SEEK_SET);\n\n  return ret;\n#else\n  return LIBRAW_NOT_IMPLEMENTED;\n#endif\n}\n\nint LibRaw::valid_for_dngsdk()\n{\n#ifndef USE_DNGSDK\n  return 0;\n#else\n  if (!imgdata.idata.dng_version)\n    return 0;\n  if (!imgdata.params.use_dngsdk)\n    return 0;\n  if (load_raw == &LibRaw::lossy_dng_load_raw)\n    return 0;\n  if (is_floating_point() && (imgdata.params.use_dngsdk & LIBRAW_DNG_FLOAT))\n    return 1;\n  if (!imgdata.idata.filters && (imgdata.params.use_dngsdk & LIBRAW_DNG_LINEAR))\n    return 1;\n  if (libraw_internal_data.unpacker_data.tiff_bps == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_8BIT))\n    return 1;\n  if (libraw_internal_data.unpacker_data.tiff_compress == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_DEFLATE))\n    return 1;\n  if (libraw_internal_data.unpacker_data.tiff_samples == 2)\n    return 0; // Always deny 2-samples (old fuji superccd)\n  if (imgdata.idata.filters == 9 && (imgdata.params.use_dngsdk & LIBRAW_DNG_XTRANS))\n    return 1;\n  if (is_fuji_rotated())\n    return 0; // refuse\n  if (imgdata.params.use_dngsdk & LIBRAW_DNG_OTHER)\n    return 1;\n  return 0;\n#endif\n}\n\nint LibRaw::is_curve_linear()\n{\n  for (int i = 0; i < 0x10000; i++)\n    if (imgdata.color.curve[i] != i)\n      return 0;\n  return 1;\n}\n\nint LibRaw::try_dngsdk()\n{\n#ifdef USE_DNGSDK\n  if (!dnghost)\n    return LIBRAW_UNSPECIFIED_ERROR;\n\n  dng_host *host = static_cast<dng_host *>(dnghost);\n\n  try\n  {\n    libraw_dng_stream stream(libraw_internal_data.internal_data.input);\n\n    AutoPtr<dng_negative> negative;\n    negative.Reset(host->Make_dng_negative());\n\n    dng_info info;\n    info.Parse(*host, stream);\n    info.PostParse(*host);\n\n    if (!info.IsValidDNG())\n    {\n      return LIBRAW_DATA_ERROR;\n    }\n    negative->Parse(*host, stream, info);\n    negative->PostParse(*host, stream, info);\n    negative->ReadStage1Image(*host, stream, info);\n    dng_simple_image *stage2 = (dng_simple_image *)negative->Stage1Image();\n    if (stage2->Bounds().W() != S.raw_width || stage2->Bounds().H() != S.raw_height)\n    {\n      return LIBRAW_DATA_ERROR;\n    }\n\n    int pplanes = stage2->Planes();\n    int ptype = stage2->PixelType();\n\n    dng_pixel_buffer buffer;\n    stage2->GetPixelBuffer(buffer);\n\n    int pixels = stage2->Bounds().H() * stage2->Bounds().W() * pplanes;\n    if (ptype == ttByte)\n      imgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ttShort));\n    else\n      imgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ptype));\n\n    if (ptype == ttShort && !is_curve_linear())\n    {\n      ushort *src = (ushort *)buffer.fData;\n      ushort *dst = (ushort *)imgdata.rawdata.raw_alloc;\n      for (int i = 0; i < pixels; i++)\n        dst[i] = imgdata.color.curve[src[i]];\n      S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ptype);\n    }\n    else if (ptype == ttByte)\n    {\n      unsigned char *src = (unsigned char *)buffer.fData;\n      ushort *dst = (ushort *)imgdata.rawdata.raw_alloc;\n      if (is_curve_linear())\n      {\n        for (int i = 0; i < pixels; i++)\n          dst[i] = src[i];\n      }\n      else\n      {\n        for (int i = 0; i < pixels; i++)\n          dst[i] = imgdata.color.curve[src[i]];\n      }\n      S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ttShort);\n    }\n    else\n    {\n      memmove(imgdata.rawdata.raw_alloc, buffer.fData, pixels * TagTypeSize(ptype));\n      S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ptype);\n    }\n\n    switch (ptype)\n    {\n    case ttFloat:\n      if (pplanes == 1)\n        imgdata.rawdata.float_image = (float *)imgdata.rawdata.raw_alloc;\n      else if (pplanes == 3)\n        imgdata.rawdata.float3_image = (float(*)[3])imgdata.rawdata.raw_alloc;\n      else if (pplanes == 4)\n        imgdata.rawdata.float4_image = (float(*)[4])imgdata.rawdata.raw_alloc;\n      break;\n\n    case ttByte:\n    case ttShort:\n      if (pplanes == 1)\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n      else if (pplanes == 3)\n        imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n      else if (pplanes == 4)\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n      break;\n    default:\n      /* do nothing */\n      break;\n    }\n  }\n  catch (...)\n  {\n    return LIBRAW_UNSPECIFIED_ERROR;\n  }\n  return imgdata.rawdata.raw_alloc ? LIBRAW_SUCCESS : LIBRAW_UNSPECIFIED_ERROR;\n#else\n  return LIBRAW_UNSPECIFIED_ERROR;\n#endif\n}\nvoid LibRaw::set_dng_host(void *p)\n{\n#ifdef USE_DNGSDK\n  dnghost = p;\n#endif\n}\n\nint LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try\n  {\n\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if (!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if (imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n    }\n    if (imgdata.rawdata.raw_alloc)\n    {\n      free(imgdata.rawdata.raw_alloc);\n      imgdata.rawdata.raw_alloc = 0;\n    }\n    if (libraw_internal_data.unpacker_data.meta_length)\n    {\n      libraw_internal_data.internal_data.meta_data = (char *)malloc(libraw_internal_data.unpacker_data.meta_length);\n      merror(libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");\n    }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if (!IO.fuji_width)\n    {\n      // adjust non-Fuji allocation\n      if (rwidth < S.width + S.left_margin)\n        rwidth = S.width + S.left_margin;\n      if (rheight < S.height + S.top_margin)\n        rheight = S.height + S.top_margin;\n    }\n    if (rwidth > 65535 || rheight > 65535) // No way to make image larger than 64k pix\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n    imgdata.rawdata.float_image = 0;\n    imgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n    if (imgdata.idata.dng_version && dnghost && imgdata.idata.raw_count == 1 && valid_for_dngsdk() &&\n        load_raw != &LibRaw::pentax_4shot_load_raw)\n    {\n      int rr = try_dngsdk();\n    }\n#endif\n\n#ifdef USE_RAWSPEED\n    if (!raw_was_read())\n    {\n      int rawspeed_enabled = 1;\n\n      if (imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.raw_count > 1)\n        rawspeed_enabled = 0;\n      if (!strncasecmp(imgdata.idata.software, \"Magic\", 5))\n        rawspeed_enabled = 0;\n      // Disable rawspeed for double-sized Oly files\n      if (!strncasecmp(imgdata.idata.make, \"Olympus\", 7) &&\n          ((imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model, \"SH-2\", 4) ||\n           !strncasecmp(imgdata.idata.model, \"SH-3\", 4) || !strncasecmp(imgdata.idata.model, \"TG-4\", 4) ||\n           !strncasecmp(imgdata.idata.model, \"TG-5\", 4)))\n        rawspeed_enabled = 0;\n\n      if (!strncasecmp(imgdata.idata.make, \"Canon\", 5) && !strcasecmp(imgdata.idata.model, \"EOS 6D Mark II\"))\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&\n          libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make, \"Nikon\", 5) &&\n          (!strncasecmp(imgdata.idata.model, \"E\", 1) || !strncasecmp(imgdata.idata.model, \"COOLPIX B\", 9)))\n        rawspeed_enabled = 0;\n\n      // RawSpeed Supported,\n      if (O.use_rawspeed && rawspeed_enabled &&\n          !(is_sraw() &&\n            (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE))) &&\n          (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n      {\n        int rr = try_rawspeed();\n      }\n    }\n#endif\n    if (!raw_was_read()) // RawSpeed failed or not run\n    {\n      // Not allocated on RawSpeed call, try call LibRaow\n      int zero_rawimage = 0;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder and DNG float\n        // Do nothing! Decoder will allocate data internally\n      }\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_3CHANNEL)\n      {\n        if (INT64(rwidth) * INT64(rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) * 3 >\n            LIBRAW_MAX_ALLOC_MB * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_ALLOC;\n\n        imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) * 3);\n        imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 6;\n      }\n      else if (imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n      {\n        if (INT64(rwidth) * INT64(rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) >\n            LIBRAW_MAX_ALLOC_MB * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_ALLOC;\n        imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n      }\n      else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)\n        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch =\n                (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        if (INT64(MAX(S.width, S.raw_width)) * INT64(MAX(S.height, S.raw_height)) * sizeof(*imgdata.image) >\n            LIBRAW_MAX_ALLOC_MB * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_ALLOC;\n\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image = (ushort(*)[4])calloc(\n            unsigned(MAX(S.width, S.raw_width)) * unsigned(MAX(S.height, S.raw_height)), sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\"))\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\"))\n        C.maximum = m_save;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder only: do nothing\n      }\n      else if (!(imgdata.idata.filters || P1.colors == 1)) // legacy decoder, ownalloc handled above\n      {\n        // successfully decoded legacy image, attach image to raw_alloc\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n        // Restore saved values. Note: Foveon have masked frame\n        // Other 4-color legacy data: no borders\n        if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS))\n        {\n          S.raw_width = S.width;\n          S.left_margin = 0;\n          S.raw_height = S.height;\n          S.top_margin = 0;\n        }\n      }\n    }\n\n    if (imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for (c = 0; c < 3; c++)\n      if (i > C.cblack[c])\n        i = C.cblack[c];\n    for (c = 0; c < 4; c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,\n            sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);\n\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee)\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}\n\nvoid LibRaw::unpacked_load_raw_fuji_f700s20()\n{\n  int base_offset = 0;\n  int row_size = imgdata.sizes.raw_width * 2; // in bytes\n  if (imgdata.idata.raw_count == 2 && imgdata.params.shot_select)\n  {\n    libraw_internal_data.internal_data.input->seek(-row_size, SEEK_CUR);\n    base_offset = row_size; // in bytes\n  }\n  unsigned char *buffer = (unsigned char *)malloc(row_size * 2);\n  for (int row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    read_shorts((ushort *)buffer, imgdata.sizes.raw_width * 2);\n    memmove(&imgdata.rawdata.raw_image[row * imgdata.sizes.raw_pitch / 2], buffer + base_offset, row_size);\n  }\n  free(buffer);\n}\n\nvoid LibRaw::nikon_load_sraw()\n{\n  // We're already seeked to data!\n  unsigned char *rd = (unsigned char *)malloc(3 * (imgdata.sizes.raw_width + 2));\n  if (!rd)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  try\n  {\n    int row, col;\n    for (row = 0; row < imgdata.sizes.raw_height; row++)\n    {\n      checkCancel();\n      libraw_internal_data.internal_data.input->read(rd, 3, imgdata.sizes.raw_width);\n      for (col = 0; col < imgdata.sizes.raw_width - 1; col += 2)\n      {\n        int bi = col * 3;\n        ushort bits1 = (rd[bi + 1] & 0xf) << 8 | rd[bi];            // 3,0,1\n        ushort bits2 = rd[bi + 2] << 4 | ((rd[bi + 1] >> 4) & 0xf); // 452\n        ushort bits3 = ((rd[bi + 4] & 0xf) << 8) | rd[bi + 3];      // 967\n        ushort bits4 = rd[bi + 5] << 4 | ((rd[bi + 4] >> 4) & 0xf); // ab8\n        imgdata.image[row * imgdata.sizes.raw_width + col][0] = bits1;\n        imgdata.image[row * imgdata.sizes.raw_width + col][1] = bits3;\n        imgdata.image[row * imgdata.sizes.raw_width + col][2] = bits4;\n        imgdata.image[row * imgdata.sizes.raw_width + col + 1][0] = bits2;\n        imgdata.image[row * imgdata.sizes.raw_width + col + 1][1] = 2048;\n        imgdata.image[row * imgdata.sizes.raw_width + col + 1][2] = 2048;\n      }\n    }\n  }\n  catch (...)\n  {\n    free(rd);\n    throw;\n  }\n  free(rd);\n  C.maximum = 0xfff; // 12 bit?\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    return; // no CbCr interpolation\n  }\n  // Interpolate CC channels\n  int row, col;\n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    checkCancel(); // will throw out\n    for (col = 0; col < imgdata.sizes.raw_width; col += 2)\n    {\n      int col2 = col < imgdata.sizes.raw_width - 2 ? col + 2 : col;\n      imgdata.image[row * imgdata.sizes.raw_width + col + 1][1] =\n          (unsigned short)(int(imgdata.image[row * imgdata.sizes.raw_width + col][1] +\n                               imgdata.image[row * imgdata.sizes.raw_width + col2][1]) /\n                           2);\n      imgdata.image[row * imgdata.sizes.raw_width + col + 1][2] =\n          (unsigned short)(int(imgdata.image[row * imgdata.sizes.raw_width + col][2] +\n                               imgdata.image[row * imgdata.sizes.raw_width + col2][2]) /\n                           2);\n    }\n  }\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n    return;\n\n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    checkCancel(); // will throw out\n    for (col = 0; col < imgdata.sizes.raw_width; col++)\n    {\n      float Y = float(imgdata.image[row * imgdata.sizes.raw_width + col][0]) / 2549.f;\n      float Ch2 = float(imgdata.image[row * imgdata.sizes.raw_width + col][1] - 1280) / 1536.f;\n      float Ch3 = float(imgdata.image[row * imgdata.sizes.raw_width + col][2] - 1280) / 1536.f;\n      if (Y > 1.f)\n        Y = 1.f;\n      if (Y > 0.803f)\n        Ch2 = Ch3 = 0.5f;\n      float r = Y + 1.40200f * (Ch3 - 0.5f);\n      if (r < 0.f)\n        r = 0.f;\n      if (r > 1.f)\n        r = 1.f;\n      float g = Y - 0.34414f * (Ch2 - 0.5f) - 0.71414 * (Ch3 - 0.5f);\n      if (g > 1.f)\n        g = 1.f;\n      if (g < 0.f)\n        g = 0.f;\n      float b = Y + 1.77200 * (Ch2 - 0.5f);\n      if (b > 1.f)\n        b = 1.f;\n      if (b < 0.f)\n        b = 0.f;\n      imgdata.image[row * imgdata.sizes.raw_width + col][0] = imgdata.color.curve[int(r * 3072.f)];\n      imgdata.image[row * imgdata.sizes.raw_width + col][1] = imgdata.color.curve[int(g * 3072.f)];\n      imgdata.image[row * imgdata.sizes.raw_width + col][2] = imgdata.color.curve[int(b * 3072.f)];\n    }\n  }\n  C.maximum = 16383;\n}\n\nvoid LibRaw::free_image(void)\n{\n  if (imgdata.image)\n  {\n    free(imgdata.image);\n    imgdata.image = 0;\n    imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_IDENTIFY |\n                             LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;\n  }\n}\n\nvoid LibRaw::raw2image_start()\n{\n  // restore color,sizes and internal data into raw_image fields\n  memmove(&imgdata.color, &imgdata.rawdata.color, sizeof(imgdata.color));\n  memmove(&imgdata.sizes, &imgdata.rawdata.sizes, sizeof(imgdata.sizes));\n  memmove(&imgdata.idata, &imgdata.rawdata.iparams, sizeof(imgdata.idata));\n  memmove(&libraw_internal_data.internal_output_params, &imgdata.rawdata.ioparams,\n          sizeof(libraw_internal_data.internal_output_params));\n\n  if (O.user_flip >= 0)\n    S.flip = O.user_flip;\n\n  switch ((S.flip + 3600) % 360)\n  {\n  case 270:\n    S.flip = 5;\n    break;\n  case 180:\n    S.flip = 3;\n    break;\n  case 90:\n    S.flip = 6;\n    break;\n  }\n\n  // adjust for half mode!\n  IO.shrink = P1.filters && (O.half_size || ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1)));\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n}\n\nint LibRaw::is_phaseone_compressed()\n{\n  return (load_raw == &LibRaw::phase_one_load_raw_c || load_raw == &LibRaw::phase_one_load_raw);\n}\n\nint LibRaw::is_canon_600() { return load_raw == &LibRaw::canon_600_load_raw; }\n\nint LibRaw::raw2image(void)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try\n  {\n    raw2image_start();\n\n    if (is_phaseone_compressed())\n    {\n      phase_one_allocate_tempbuffer();\n      int rc = phase_one_subtract_black((ushort *)imgdata.rawdata.raw_alloc, imgdata.rawdata.raw_image);\n      if (rc == 0)\n        rc = phase_one_correct();\n      if (rc != 0)\n      {\n        phase_one_free_tempbuffer();\n        return rc;\n      }\n    }\n\n    // free and re-allocate image bitmap\n    if (imgdata.image)\n    {\n      imgdata.image = (ushort(*)[4])realloc(imgdata.image, S.iheight * S.iwidth * sizeof(*imgdata.image));\n      memset(imgdata.image, 0, S.iheight * S.iwidth * sizeof(*imgdata.image));\n    }\n    else\n      imgdata.image = (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n    merror(imgdata.image, \"raw2image()\");\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Move saved bitmap to imgdata.image\n    if (imgdata.idata.filters || P1.colors == 1)\n    {\n      if (IO.fuji_width)\n      {\n        unsigned r, c;\n        int row, col;\n        for (row = 0; row < S.raw_height - S.top_margin * 2; row++)\n        {\n          for (col = 0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)\n          {\n            if (libraw_internal_data.unpacker_data.fuji_layout)\n            {\n              r = IO.fuji_width - 1 - col + (row >> 1);\n              c = col + ((row + 1) >> 1);\n            }\n            else\n            {\n              r = IO.fuji_width - 1 + row - (col >> 1);\n              c = row + ((col + 1) >> 1);\n            }\n            if (r < S.height && c < S.width)\n              imgdata.image[((r) >> IO.shrink) * S.iwidth + ((c) >> IO.shrink)][FC(r, c)] =\n                  imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n          }\n        }\n      }\n      else\n      {\n        int row, col;\n        for (row = 0; row < S.height; row++)\n          for (col = 0; col < S.width; col++)\n            imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][fcol(row, col)] =\n                imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n      }\n    }\n    else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n    {\n      if (imgdata.rawdata.color4_image)\n      {\n        if (S.width * 8 == S.raw_pitch)\n          memmove(imgdata.image, imgdata.rawdata.color4_image, S.width * S.height * sizeof(*imgdata.image));\n        else\n        {\n          for (int row = 0; row < S.height; row++)\n            memmove(&imgdata.image[row * S.width],\n                    &imgdata.rawdata.color4_image[(row + S.top_margin) * S.raw_pitch / 8 + S.left_margin],\n                    S.width * sizeof(*imgdata.image));\n        }\n      }\n      else if (imgdata.rawdata.color3_image)\n      {\n        unsigned char *c3image = (unsigned char *)imgdata.rawdata.color3_image;\n        for (int row = 0; row < S.height; row++)\n        {\n          ushort(*srcrow)[3] = (ushort(*)[3]) & c3image[(row + S.top_margin) * S.raw_pitch];\n          ushort(*dstrow)[4] = (ushort(*)[4]) & imgdata.image[row * S.width];\n          for (int col = 0; col < S.width; col++)\n          {\n            for (int c = 0; c < 3; c++)\n              dstrow[col][c] = srcrow[S.left_margin + col][c];\n            dstrow[col][3] = 0;\n          }\n        }\n      }\n      else\n      {\n        // legacy decoder, but no data?\n        throw LIBRAW_EXCEPTION_DECODE_RAW;\n      }\n    }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n    {\n      phase_one_free_tempbuffer();\n    }\n    // hack - clear later flags!\n\n    if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)\n    {\n      canon_600_correct();\n    }\n\n    imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE |\n                             LIBRAW_PROGRESS_IDENTIFY | LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nvoid LibRaw::phase_one_allocate_tempbuffer()\n{\n  // Allocate temp raw_image buffer\n  imgdata.rawdata.raw_image = (ushort *)malloc(S.raw_pitch * S.raw_height);\n  merror(imgdata.rawdata.raw_image, \"phase_one_prepare_to_correct()\");\n}\nvoid LibRaw::phase_one_free_tempbuffer()\n{\n  free(imgdata.rawdata.raw_image);\n  imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n}\n\nint LibRaw::phase_one_subtract_black(ushort *src, ushort *dest)\n{\n\n  try\n  {\n    if (O.user_black < 0 && O.user_cblack[0] <= -1000000 && O.user_cblack[1] <= -1000000 &&\n        O.user_cblack[2] <= -1000000 && O.user_cblack[3] <= -1000000)\n    {\n      if (!imgdata.rawdata.ph1_cblack || !imgdata.rawdata.ph1_rblack)\n      {\n        register int bl = imgdata.color.phase_one_data.t_black;\n        for (int row = 0; row < S.raw_height; row++)\n        {\n          checkCancel();\n          for (int col = 0; col < S.raw_width; col++)\n          {\n            int idx = row * S.raw_width + col;\n            int val = int(src[idx]) - bl;\n            dest[idx] = val > 0 ? val : 0;\n          }\n        }\n      }\n      else\n      {\n        register int bl = imgdata.color.phase_one_data.t_black;\n        for (int row = 0; row < S.raw_height; row++)\n        {\n          checkCancel();\n          for (int col = 0; col < S.raw_width; col++)\n          {\n            int idx = row * S.raw_width + col;\n            int val = int(src[idx]) - bl +\n                      imgdata.rawdata.ph1_cblack[row][col >= imgdata.rawdata.color.phase_one_data.split_col] +\n                      imgdata.rawdata.ph1_rblack[col][row >= imgdata.rawdata.color.phase_one_data.split_row];\n            dest[idx] = val > 0 ? val : 0;\n          }\n        }\n      }\n    }\n    else // black set by user interaction\n    {\n      // Black level in cblack!\n      for (int row = 0; row < S.raw_height; row++)\n      {\n        checkCancel();\n        unsigned short cblk[16];\n        for (int cc = 0; cc < 16; cc++)\n          cblk[cc] = C.cblack[fcol(row, cc)];\n        for (int col = 0; col < S.raw_width; col++)\n        {\n          int idx = row * S.raw_width + col;\n          ushort val = src[idx];\n          ushort bl = cblk[col & 0xf];\n          dest[idx] = val > bl ? val - bl : 0;\n        }\n      }\n    }\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n}\n\nvoid LibRaw::copy_fuji_uncropped(unsigned short cblack[4], unsigned short *dmaxp)\n{\n  int row;\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for default(shared)\n#endif\n  for (row = 0; row < S.raw_height - S.top_margin * 2; row++)\n  {\n    int col;\n    unsigned short ldmax = 0;\n    for (col = 0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)\n    {\n      unsigned r, c;\n      if (libraw_internal_data.unpacker_data.fuji_layout)\n      {\n        r = IO.fuji_width - 1 - col + (row >> 1);\n        c = col + ((row + 1) >> 1);\n      }\n      else\n      {\n        r = IO.fuji_width - 1 + row - (col >> 1);\n        c = row + ((col + 1) >> 1);\n      }\n      if (r < S.height && c < S.width)\n      {\n        unsigned short val = imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n        int cc = FC(r, c);\n        if (val > cblack[cc])\n        {\n          val -= cblack[cc];\n          if (val > ldmax)\n            ldmax = val;\n        }\n        else\n          val = 0;\n        imgdata.image[((r) >> IO.shrink) * S.iwidth + ((c) >> IO.shrink)][cc] = val;\n      }\n    }\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp critical(dataupdate)\n#endif\n    {\n      if (*dmaxp < ldmax)\n        *dmaxp = ldmax;\n    }\n  }\n}\n\nvoid LibRaw::copy_bayer(unsigned short cblack[4], unsigned short *dmaxp)\n{\n  // Both cropped and uncropped\n  int row;\n\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for default(shared)\n#endif\n  for (row = 0; row < S.height; row++)\n  {\n    int col;\n    unsigned short ldmax = 0;\n    for (col = 0; col < S.width; col++)\n    {\n      unsigned short val = imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n      int cc = fcol(row, col);\n      if (val > cblack[cc])\n      {\n        val -= cblack[cc];\n        if (val > ldmax)\n          ldmax = val;\n      }\n      else\n        val = 0;\n      imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][cc] = val;\n    }\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp critical(dataupdate)\n#endif\n    {\n      if (*dmaxp < ldmax)\n        *dmaxp = ldmax;\n    }\n  }\n}\n\nint LibRaw::raw2image_ex(int do_subtract_black)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try\n  {\n    raw2image_start();\n\n    // Compressed P1 files with bl data!\n    if (is_phaseone_compressed())\n    {\n      phase_one_allocate_tempbuffer();\n      int rc = phase_one_subtract_black((ushort *)imgdata.rawdata.raw_alloc, imgdata.rawdata.raw_image);\n      if (rc == 0)\n        rc = phase_one_correct();\n      if (rc != 0)\n      {\n        phase_one_free_tempbuffer();\n        return rc;\n      }\n    }\n\n    // process cropping\n    int do_crop = 0;\n    unsigned save_width = S.width;\n    if (~O.cropbox[2] && ~O.cropbox[3])\n    {\n      int crop[4], c, filt;\n      for (int c = 0; c < 4; c++)\n      {\n        crop[c] = O.cropbox[c];\n        if (crop[c] < 0)\n          crop[c] = 0;\n      }\n\n      if (IO.fuji_width && imgdata.idata.filters >= 1000)\n      {\n        crop[0] = (crop[0] / 4) * 4;\n        crop[1] = (crop[1] / 4) * 4;\n        if (!libraw_internal_data.unpacker_data.fuji_layout)\n        {\n          crop[2] *= sqrt(2.0);\n          crop[3] /= sqrt(2.0);\n        }\n        crop[2] = (crop[2] / 4 + 1) * 4;\n        crop[3] = (crop[3] / 4 + 1) * 4;\n      }\n      else if (imgdata.idata.filters == 1)\n      {\n        crop[0] = (crop[0] / 16) * 16;\n        crop[1] = (crop[1] / 16) * 16;\n      }\n      else if (imgdata.idata.filters == LIBRAW_XTRANS)\n      {\n        crop[0] = (crop[0] / 6) * 6;\n        crop[1] = (crop[1] / 6) * 6;\n      }\n      do_crop = 1;\n\n      crop[2] = MIN(crop[2], (signed)S.width - crop[0]);\n      crop[3] = MIN(crop[3], (signed)S.height - crop[1]);\n      if (crop[2] <= 0 || crop[3] <= 0)\n        throw LIBRAW_EXCEPTION_BAD_CROP;\n\n      // adjust sizes!\n      S.left_margin += crop[0];\n      S.top_margin += crop[1];\n      S.width = crop[2];\n      S.height = crop[3];\n\n      S.iheight = (S.height + IO.shrink) >> IO.shrink;\n      S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n      if (!IO.fuji_width && imgdata.idata.filters && imgdata.idata.filters >= 1000)\n      {\n        for (filt = c = 0; c < 16; c++)\n          filt |= FC((c >> 1) + (crop[1]), (c & 1) + (crop[0])) << c * 2;\n        imgdata.idata.filters = filt;\n      }\n    }\n\n    int alloc_width = S.iwidth;\n    int alloc_height = S.iheight;\n\n    if (IO.fuji_width && do_crop)\n    {\n      int IO_fw = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;\n      int t_alloc_width = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO_fw;\n      int t_alloc_height = t_alloc_width - 1;\n      alloc_height = (t_alloc_height + IO.shrink) >> IO.shrink;\n      alloc_width = (t_alloc_width + IO.shrink) >> IO.shrink;\n    }\n    int alloc_sz = alloc_width * alloc_height;\n\n    if (imgdata.image)\n    {\n      imgdata.image = (ushort(*)[4])realloc(imgdata.image, alloc_sz * sizeof(*imgdata.image));\n      memset(imgdata.image, 0, alloc_sz * sizeof(*imgdata.image));\n    }\n    else\n      imgdata.image = (ushort(*)[4])calloc(alloc_sz, sizeof(*imgdata.image));\n    merror(imgdata.image, \"raw2image_ex()\");\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Adjust black levels\n    unsigned short cblack[4] = {0, 0, 0, 0};\n    unsigned short dmax = 0;\n    if (do_subtract_black)\n    {\n      adjust_bl();\n      for (int i = 0; i < 4; i++)\n        cblack[i] = (unsigned short)C.cblack[i];\n    }\n\n    // Move saved bitmap to imgdata.image\n    if (imgdata.idata.filters || P1.colors == 1)\n    {\n      if (IO.fuji_width)\n      {\n        if (do_crop)\n        {\n          IO.fuji_width = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;\n          int IO_fwidth = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO.fuji_width;\n          int IO_fheight = IO_fwidth - 1;\n\n          int row, col;\n          for (row = 0; row < S.height; row++)\n          {\n            for (col = 0; col < S.width; col++)\n            {\n              int r, c;\n              if (libraw_internal_data.unpacker_data.fuji_layout)\n              {\n                r = IO.fuji_width - 1 - col + (row >> 1);\n                c = col + ((row + 1) >> 1);\n              }\n              else\n              {\n                r = IO.fuji_width - 1 + row - (col >> 1);\n                c = row + ((col + 1) >> 1);\n              }\n\n              unsigned short val =\n                  imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n              int cc = FCF(row, col);\n              if (val > cblack[cc])\n              {\n                val -= cblack[cc];\n                if (dmax < val)\n                  dmax = val;\n              }\n              else\n                val = 0;\n              imgdata.image[((r) >> IO.shrink) * alloc_width + ((c) >> IO.shrink)][cc] = val;\n            }\n          }\n          S.height = IO_fheight;\n          S.width = IO_fwidth;\n          S.iheight = (S.height + IO.shrink) >> IO.shrink;\n          S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n          S.raw_height -= 2 * S.top_margin;\n        }\n        else\n        {\n          copy_fuji_uncropped(cblack, &dmax);\n        }\n      } // end Fuji\n      else\n      {\n        copy_bayer(cblack, &dmax);\n      }\n    }\n    else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n    {\n      if (imgdata.rawdata.color4_image)\n      {\n        if (S.raw_pitch != S.width * 8)\n        {\n          for (int row = 0; row < S.height; row++)\n            memmove(&imgdata.image[row * S.width],\n                    &imgdata.rawdata.color4_image[(row + S.top_margin) * S.raw_pitch / 8 + S.left_margin],\n                    S.width * sizeof(*imgdata.image));\n        }\n        else\n        {\n          // legacy is always 4channel and not shrinked!\n          memmove(imgdata.image, imgdata.rawdata.color4_image, S.width * S.height * sizeof(*imgdata.image));\n        }\n      }\n      else if (imgdata.rawdata.color3_image)\n      {\n        unsigned char *c3image = (unsigned char *)imgdata.rawdata.color3_image;\n        for (int row = 0; row < S.height; row++)\n        {\n          ushort(*srcrow)[3] = (ushort(*)[3]) & c3image[(row + S.top_margin) * S.raw_pitch];\n          ushort(*dstrow)[4] = (ushort(*)[4]) & imgdata.image[row * S.width];\n          for (int col = 0; col < S.width; col++)\n          {\n            for (int c = 0; c < 3; c++)\n              dstrow[col][c] = srcrow[S.left_margin + col][c];\n            dstrow[col][3] = 0;\n          }\n        }\n      }\n      else\n      {\n        // legacy decoder, but no data?\n        throw LIBRAW_EXCEPTION_DECODE_RAW;\n      }\n    }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n    {\n      phase_one_free_tempbuffer();\n    }\n    if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)\n    {\n      canon_600_correct();\n    }\n\n    if (do_subtract_black)\n    {\n      C.data_maximum = (int)dmax;\n      C.maximum -= C.black;\n      //        ZERO(C.cblack);\n      C.cblack[0] = C.cblack[1] = C.cblack[2] = C.cblack[3] = 0;\n      C.black = 0;\n    }\n\n    // hack - clear later flags!\n    imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE |\n                             LIBRAW_PROGRESS_IDENTIFY | LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#if 1\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_thumb(int *errcode)\n{\n  if (!T.thumb)\n  {\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      if (errcode)\n        *errcode = LIBRAW_NO_THUMBNAIL;\n    }\n    else\n    {\n      if (errcode)\n        *errcode = LIBRAW_OUT_OF_ORDER_CALL;\n    }\n    return NULL;\n  }\n\n  if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)\n  {\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + T.tlength);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n    ret->type = LIBRAW_IMAGE_BITMAP;\n    ret->height = T.theight;\n    ret->width = T.twidth;\n    ret->colors = 3;\n    ret->bits = 8;\n    ret->data_size = T.tlength;\n    memmove(ret->data, T.thumb, T.tlength);\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)\n  {\n    ushort exif[5];\n    int mk_exif = 0;\n    if (strcmp(T.thumb + 6, \"Exif\"))\n      mk_exif = 1;\n\n    int dsize = T.tlength + mk_exif * (sizeof(exif) + sizeof(tiff_hdr));\n\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + dsize);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n\n    ret->type = LIBRAW_IMAGE_JPEG;\n    ret->data_size = dsize;\n\n    ret->data[0] = 0xff;\n    ret->data[1] = 0xd8;\n    if (mk_exif)\n    {\n      struct tiff_hdr th;\n      memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n      exif[1] = htons(8 + sizeof th);\n      memmove(ret->data + 2, exif, sizeof(exif));\n      tiff_head(&th, 0);\n      memmove(ret->data + (2 + sizeof(exif)), &th, sizeof(th));\n      memmove(ret->data + (2 + sizeof(exif) + sizeof(th)), T.thumb + 2, T.tlength - 2);\n    }\n    else\n    {\n      memmove(ret->data + 2, T.thumb + 2, T.tlength - 2);\n    }\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else\n  {\n    if (errcode)\n      *errcode = LIBRAW_UNSUPPORTED_THUMBNAIL;\n    return NULL;\n  }\n}\n\n// jlb\n// macros for copying pixels to either BGR or RGB formats\n#define FORBGR for (c = P1.colors - 1; c >= 0; c--)\n#define FORRGB for (c = 0; c < P1.colors; c++)\n\nvoid LibRaw::get_mem_image_format(int *width, int *height, int *colors, int *bps) const\n\n{\n  if (S.flip & 4)\n  {\n    *width = S.height;\n    *height = S.width;\n  }\n  else\n  {\n    *width = S.width;\n    *height = S.height;\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}\n\nint LibRaw::copy_mem_image(void *scan0, int stride, int bgr)\n\n{\n  // the image memory pointed to by scan0 is assumed to be in the format returned by get_mem_image_format\n  if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) < LIBRAW_PROGRESS_PRE_INTERPOLATE)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  if (libraw_internal_data.output_data.histogram)\n  {\n    int perc, val, total, t_white = 0x2000, c;\n    perc = S.width * S.height * O.auto_bright_thr;\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  int s_iheight = S.iheight;\n  int s_iwidth = S.iwidth;\n  int s_width = S.width;\n  int s_hwight = S.height;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n  for (row = 0; row < S.height; row++, soff += rstep)\n  {\n    uchar *bufp = ((uchar *)scan0) + row * stride;\n    ppm2 = (ushort *)(ppm = bufp);\n    // keep trivial decisions in the outer loop for speed\n    if (bgr)\n    {\n      if (O.output_bps == 8)\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORBGR *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n      }\n      else\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORBGR *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n      }\n    }\n    else\n    {\n      if (O.output_bps == 8)\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORRGB *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n      }\n      else\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORRGB *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n      }\n    }\n\n    //            bufp += stride;           // go to the next line\n  }\n\n  S.iheight = s_iheight;\n  S.iwidth = s_iwidth;\n  S.width = s_width;\n  S.height = s_hwight;\n\n  return 0;\n}\n#undef FORBGR\n#undef FORRGB\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_image(int *errcode)\n\n{\n  int width, height, colors, bps;\n  get_mem_image_format(&width, &height, &colors, &bps);\n  int stride = width * (bps / 8) * colors;\n  unsigned ds = height * stride;\n  libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + ds);\n  if (!ret)\n  {\n    if (errcode)\n      *errcode = ENOMEM;\n    return NULL;\n  }\n  memset(ret, 0, sizeof(libraw_processed_image_t));\n\n  // metadata init\n  ret->type = LIBRAW_IMAGE_BITMAP;\n  ret->height = height;\n  ret->width = width;\n  ret->colors = colors;\n  ret->bits = bps;\n  ret->data_size = ds;\n  copy_mem_image(ret->data, stride, 0);\n\n  return ret;\n}\n\n#undef FORC\n#undef FORCC\n#undef SWAP\n#endif\n\nint LibRaw::dcraw_ppm_tiff_writer(const char *filename)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  if (!imgdata.image)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  if (!filename)\n    return ENOENT;\n  FILE *f = fopen(filename, \"wb\");\n\n  if (!f)\n    return errno;\n\n  try\n  {\n    if (!libraw_internal_data.output_data.histogram)\n    {\n      libraw_internal_data.output_data.histogram =\n          (int(*)[LIBRAW_HISTOGRAM_SIZE])malloc(sizeof(*libraw_internal_data.output_data.histogram) * 4);\n      merror(libraw_internal_data.output_data.histogram, \"LibRaw::dcraw_ppm_tiff_writer()\");\n    }\n    libraw_internal_data.internal_data.output = f;\n    write_ppm_tiff();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n    libraw_internal_data.internal_data.output = NULL;\n    fclose(f);\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    fclose(f);\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#define THUMB_READ_BEYOND 16384\n\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize = T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth, s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n  if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image = (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n  merror(imgdata.image, \"LibRaw::kodak_thumb_loader()\");\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n    (this->*thumb_load_raw)();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n// copy-n-paste from image pipe\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LIM(x, min, max) MAX(min, MIN(x, max))\n#ifndef CLIP\n#define CLIP(x) LIM(x, 0, 65535)\n#endif\n#define SWAP(a, b)                                                                                                     \\\n  {                                                                                                                    \\\n    a ^= b;                                                                                                            \\\n    a ^= (b ^= a);                                                                                                     \\\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] = (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n  merror(t_hist, \"LibRaw::kodak_thumb_loader()\");\n\n  float out[3], out_cam[3][4] = {{2.81761312, -1.98369181, 0.166078627, 0},\n                                 {-0.111855984, 1.73688626, -0.625030339, 0},\n                                 {-0.0379119813, -0.891268849, 1.92918086, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort(*t_curve) = (ushort *)calloc(sizeof(C.curve), 1);\n  merror(t_curve, \"LibRaw::kodak_thumb_loader()\");\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  merror(T.thumb, \"LibRaw::kodak_thumb_loader()\");\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int row = 0; row < S.height; row++, soff += rstep)\n    {\n      char *ppm = T.thumb + row * S.width * P1.colors;\n      for (int col = 0; col < S.width; col++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[col * P1.colors + c] = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n#undef SWAP\n\n// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumbnail \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd, \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumb_format \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\nint LibRaw::thumbOK(INT64 maxsz)\n{\n  if (!ID.input)\n    return 0;\n  if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n  )\n    return 0;\n  INT64 fsize = ID.input->size();\n  if (fsize > 0x7fffffffU)\n    return 0; // No thumb for raw > 2Gb\n  int tsize = 0;\n  int tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;\n  if (write_thumb == &LibRaw::jpeg_thumb)\n    tsize = T.tlength;\n  else if (write_thumb == &LibRaw::ppm_thumb)\n    tsize = tcol * T.twidth * T.theight;\n  else if (write_thumb == &LibRaw::ppm16_thumb)\n    tsize = tcol * T.twidth * T.theight *\n            ((imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_PPM16_THUMBS) ? 2 : 1);\n  else if (write_thumb == &LibRaw::x3f_thumb_loader)\n  {\n    tsize = x3f_thumb_size();\n  }\n  else // Kodak => no check\n    tsize = 1;\n  if (tsize < 0)\n    return 0;\n  if (maxsz > 0 && tsize > maxsz)\n    return 0;\n  return (tsize + ID.toffset <= fsize) ? 1 : 0;\n}\n\n#ifndef NO_JPEG\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n  jmp_buf setjmp_buffer;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  longjmp(myerr->setjmp_buffer, 1);\n}\n#endif\n\nint LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if (thumb_load_raw)\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n      if (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (write_thumb == &LibRaw::jpeg_thumb)\n      {\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        merror(T.thumb, \"jpeg_thumb()\");\n        ID.input->read(T.thumb, 1, T.tlength);\n        unsigned char *tthumb = (unsigned char *)T.thumb;\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3) ? cinfo.num_components : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm_thumb)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more bits\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength && T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = -1;\n          for (int ii = 0; ii < libraw_internal_data.identify_data.tiff_nifds && ii < LIBRAW_IFD_MAXCOUNT; ii++)\n            if (tiff_ifd[ii].offset == libraw_internal_data.internal_data.toffset) // found\n            {\n              pifd = ii;\n              break;\n            }\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count && tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n            merror(T.thumb, \"ppm_thumb()\");\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count && i < tiff_ifd[pifd].strip_offsets_count; i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n        merror(T.thumb, \"ppm_thumb()\");\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm16_thumb)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for more bits\n        int o_bps = (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_PPM16_THUMBS) ? 2 : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234))\n          swab((char *)t_thumb, (char *)t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          merror(T.thumb, \"ppm_thumb()\");\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nint LibRaw::dcraw_thumb_writer(const char *fname)\n{\n  //    CHECK_ORDER_LOW(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  if (!fname)\n    return ENOENT;\n\n  FILE *tfp = fopen(fname, \"wb\");\n\n  if (!tfp)\n    return errno;\n\n  if (!T.thumb)\n  {\n    fclose(tfp);\n    return LIBRAW_OUT_OF_ORDER_CALL;\n  }\n\n  try\n  {\n    switch (T.tformat)\n    {\n    case LIBRAW_THUMBNAIL_JPEG:\n      jpeg_thumb_writer(tfp, T.thumb, T.tlength);\n      break;\n    case LIBRAW_THUMBNAIL_BITMAP:\n      fprintf(tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n      fwrite(T.thumb, 1, T.tlength, tfp);\n      break;\n    default:\n      fclose(tfp);\n      return LIBRAW_UNSUPPORTED_THUMBNAIL;\n    }\n    fclose(tfp);\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nint LibRaw::adjust_sizes_info_only(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n\n  raw2image_start();\n  if (O.use_fuji_rotate)\n  {\n    if (IO.fuji_width)\n    {\n      IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;\n      S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));\n      S.iheight = (ushort)((S.iheight - IO.fuji_width) / sqrt(0.5));\n    }\n    else\n    {\n      if (S.pixel_aspect < 0.995)\n        S.iheight = (ushort)(S.iheight / S.pixel_aspect + 0.5);\n      if (S.pixel_aspect > 1.005)\n        S.iwidth = (ushort)(S.iwidth * S.pixel_aspect + 0.5);\n    }\n  }\n  SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n  if (S.flip & 4)\n  {\n    unsigned short t = S.iheight;\n    S.iheight = S.iwidth;\n    S.iwidth = t;\n    SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n  }\n  return 0;\n}\n\nint LibRaw::subtract_black()\n{\n  adjust_bl();\n  return subtract_black_internal();\n}\n\nint LibRaw::subtract_black_internal()\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\n  try\n  {\n    if (!is_phaseone_compressed() &&\n        (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3] || (C.cblack[4] && C.cblack[5])))\n    {\n#define BAYERC(row, col, c) imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][c]\n      int cblk[4], i;\n      for (i = 0; i < 4; i++)\n        cblk[i] = C.cblack[i];\n\n      int size = S.iheight * S.iwidth;\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LIM(x, min, max) MAX(min, MIN(x, max))\n#define CLIP(x) LIM(x, 0, 65535)\n      int dmax = 0;\n      if (C.cblack[4] && C.cblack[5])\n      {\n        for (i = 0; i < size * 4; i++)\n        {\n          int val = imgdata.image[0][i];\n          val -= C.cblack[6 + i / 4 / S.iwidth % C.cblack[4] * C.cblack[5] + i / 4 % S.iwidth % C.cblack[5]];\n          val -= cblk[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n          if (dmax < val)\n            dmax = val;\n        }\n      }\n      else\n      {\n        for (i = 0; i < size * 4; i++)\n        {\n          int val = imgdata.image[0][i];\n          val -= cblk[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n          if (dmax < val)\n            dmax = val;\n        }\n      }\n      C.data_maximum = dmax & 0xffff;\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n      C.maximum -= C.black;\n      ZERO(C.cblack); // Yeah, we used cblack[6+] values too!\n      C.black = 0;\n#undef BAYERC\n    }\n    else\n    {\n      // Nothing to Do, maximum is already calculated, black level is 0, so no change\n      // only calculate channel maximum;\n      int idx;\n      ushort *p = (ushort *)imgdata.image;\n      int dmax = 0;\n      for (idx = 0; idx < S.iheight * S.iwidth * 4; idx++)\n        if (dmax < p[idx])\n          dmax = p[idx];\n      C.data_maximum = dmax;\n    }\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#define TBLN 65535\n\nvoid LibRaw::exp_bef(float shift, float smooth)\n{\n  // params limits\n  if (shift > 8)\n    shift = 8;\n  if (shift < 0.25)\n    shift = 0.25;\n  if (smooth < 0.0)\n    smooth = 0.0;\n  if (smooth > 1.0)\n    smooth = 1.0;\n\n  unsigned short *lut = (ushort *)malloc((TBLN + 1) * sizeof(unsigned short));\n\n  if (shift <= 1.0)\n  {\n    for (int i = 0; i <= TBLN; i++)\n      lut[i] = (unsigned short)((float)i * shift);\n  }\n  else\n  {\n    float x1, x2, y1, y2;\n\n    float cstops = log(shift) / log(2.0f);\n    float room = cstops * 2;\n    float roomlin = powf(2.0f, room);\n    x2 = (float)TBLN;\n    x1 = (x2 + 1) / roomlin - 1;\n    y1 = x1 * shift;\n    y2 = x2 * (1 + (1 - smooth) * (shift - 1));\n    float sq3x = powf(x1 * x1 * x2, 1.0f / 3.0f);\n    float B = (y2 - y1 + shift * (3 * x1 - 3.0f * sq3x)) / (x2 + 2.0f * x1 - 3.0f * sq3x);\n    float A = (shift - B) * 3.0f * powf(x1 * x1, 1.0f / 3.0f);\n    float CC = y2 - A * powf(x2, 1.0f / 3.0f) - B * x2;\n    for (int i = 0; i <= TBLN; i++)\n    {\n      float X = (float)i;\n      float Y = A * powf(X, 1.0f / 3.0f) + B * X + CC;\n      if (i < x1)\n        lut[i] = (unsigned short)((float)i * shift);\n      else\n        lut[i] = Y < 0 ? 0 : (Y > TBLN ? TBLN : (unsigned short)(Y));\n    }\n  }\n  for (int i = 0; i < S.height * S.width; i++)\n  {\n    imgdata.image[i][0] = lut[imgdata.image[i][0]];\n    imgdata.image[i][1] = lut[imgdata.image[i][1]];\n    imgdata.image[i][2] = lut[imgdata.image[i][2]];\n    imgdata.image[i][3] = lut[imgdata.image[i][3]];\n  }\n\n  if (C.data_maximum <= TBLN)\n    C.data_maximum = lut[C.data_maximum];\n  if (C.maximum <= TBLN)\n    C.maximum = lut[C.maximum];\n  free(lut);\n}\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LIM(x, min, max) MAX(min, MIN(x, max))\n#define ULIM(x, y, z) ((y) < (z) ? LIM(x, y, z) : LIM(x, z, y))\n#define CLIP(x) LIM(x, 0, 65535)\n\nvoid LibRaw::convert_to_rgb_loop(float out_cam[3][4])\n{\n  int row, col, c;\n  float out[3];\n  ushort *img;\n  memset(libraw_internal_data.output_data.histogram, 0, sizeof(int) * LIBRAW_HISTOGRAM_SIZE * 4);\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      if (!libraw_internal_data.internal_output_params.raw_color)\n      {\n        out[0] = out[1] = out[2] = 0;\n        for (c = 0; c < imgdata.idata.colors; c++)\n        {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        for (c = 0; c < 3; c++)\n          img[c] = CLIP((int)out[c]);\n      }\n      for (c = 0; c < imgdata.idata.colors; c++)\n        libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;\n    }\n}\n\nvoid LibRaw::scale_colors_loop(float scale_mul[4])\n{\n  unsigned size = S.iheight * S.iwidth;\n\n  if (C.cblack[4] && C.cblack[5])\n  {\n    int val;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      if (!(val = imgdata.image[0][i]))\n        continue;\n      val -= C.cblack[6 + i / 4 / S.iwidth % C.cblack[4] * C.cblack[5] + i / 4 % S.iwidth % C.cblack[5]];\n      val -= C.cblack[i & 3];\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n  else if (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3])\n  {\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      int val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val -= C.cblack[i & 3];\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n  else // BL is zero\n  {\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      int val = imgdata.image[0][i];\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n}\n\nvoid LibRaw::adjust_bl()\n{\n  int clear_repeat = 0;\n  if (O.user_black >= 0)\n  {\n    C.black = O.user_black;\n    clear_repeat = 1;\n  }\n  for (int i = 0; i < 4; i++)\n    if (O.user_cblack[i] > -1000000)\n    {\n      C.cblack[i] = O.user_cblack[i];\n      clear_repeat = 1;\n    }\n\n  if (clear_repeat)\n    C.cblack[4] = C.cblack[5] = 0;\n\n  // Add common part to cblack[] early\n  if (imgdata.idata.filters > 1000 && (C.cblack[4] + 1) / 2 == 1 && (C.cblack[5] + 1) / 2 == 1)\n  {\n    int clrs[4];\n    int lastg = -1, gcnt = 0;\n    for (int c = 0; c < 4; c++)\n    {\n      clrs[c] = FC(c / 2, c % 2);\n      if (clrs[c] == 1)\n      {\n        gcnt++;\n        lastg = c;\n      }\n    }\n    if (gcnt > 1 && lastg >= 0)\n      clrs[lastg] = 3;\n    for (int c = 0; c < 4; c++)\n      C.cblack[clrs[c]] += C.cblack[6 + c / 2 % C.cblack[4] * C.cblack[5] + c % 2 % C.cblack[5]];\n    C.cblack[4] = C.cblack[5] = 0;\n    // imgdata.idata.filters = sfilters;\n  }\n  else if (imgdata.idata.filters <= 1000 && C.cblack[4] == 1 && C.cblack[5] == 1) // Fuji RAF dng\n  {\n    for (int c = 0; c < 4; c++)\n      C.cblack[c] += C.cblack[6];\n    C.cblack[4] = C.cblack[5] = 0;\n  }\n  // remove common part from C.cblack[]\n  int i = C.cblack[3];\n  int c;\n  for (c = 0; c < 3; c++)\n    if (i > C.cblack[c])\n      i = C.cblack[c];\n\n  for (c = 0; c < 4; c++)\n    C.cblack[c] -= i; // remove common part\n  C.black += i;\n\n  // Now calculate common part for cblack[6+] part and move it to C.black\n\n  if (C.cblack[4] && C.cblack[5])\n  {\n    i = C.cblack[6];\n    for (c = 1; c < C.cblack[4] * C.cblack[5]; c++)\n      if (i > C.cblack[6 + c])\n        i = C.cblack[6 + c];\n    // Remove i from cblack[6+]\n    int nonz = 0;\n    for (c = 0; c < C.cblack[4] * C.cblack[5]; c++)\n    {\n      C.cblack[6 + c] -= i;\n      if (C.cblack[6 + c])\n        nonz++;\n    }\n    C.black += i;\n    if (!nonz)\n      C.cblack[4] = C.cblack[5] = 0;\n  }\n  for (c = 0; c < 4; c++)\n    C.cblack[c] += C.black;\n}\n\nint LibRaw::dcraw_process(void)\n{\n  int quality, i;\n\n  int iterations = -1, dcb_enhance = 1, noiserd = 0;\n  int eeci_refine_fl = 0, es_med_passes_fl = 0;\n  float cared = 0, cablue = 0;\n  float linenoise = 0;\n  float lclean = 0, cclean = 0;\n  float thresh = 0;\n  float preser = 0;\n  float expos = 1.0;\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n  //    CHECK_ORDER_HIGH(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n  try\n  {\n\n    int no_crop = 1;\n\n    if (~O.cropbox[2] && ~O.cropbox[3])\n      no_crop = 0;\n\n    libraw_decoder_info_t di;\n    get_decoder_info(&di);\n\n    bool is_bayer = (imgdata.idata.filters || P1.colors == 1);\n    int subtract_inline = !O.bad_pixels && !O.dark_frame && is_bayer && !IO.zero_is_bad;\n\n    raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!\n\n    // Adjust sizes\n\n    int save_4color = O.four_color_rgb;\n\n    if (IO.zero_is_bad)\n    {\n      remove_zeroes();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);\n    }\n\n    if (O.bad_pixels && no_crop)\n    {\n      bad_pixels(O.bad_pixels);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);\n    }\n\n    if (O.dark_frame && no_crop)\n    {\n      subtract(O.dark_frame);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);\n    }\n    /* pre subtract black callback: check for it above to disable subtract inline */\n\n    if(callbacks.pre_subtractblack_cb)\n\t(callbacks.pre_subtractblack_cb)(this);\n\n    quality = 2 + !IO.fuji_width;\n\n    if (O.user_qual >= 0)\n      quality = O.user_qual;\n\n    if (!subtract_inline || !C.data_maximum)\n    {\n      adjust_bl();\n      subtract_black_internal();\n    }\n\n    if (!(di.decoder_flags & LIBRAW_DECODER_FIXEDMAXC))\n      adjust_maximum();\n\n    if (O.user_sat > 0)\n      C.maximum = O.user_sat;\n\n    if (P1.is_foveon)\n    {\n      if (load_raw == &LibRaw::x3f_load_raw)\n      {\n        // Filter out zeroes\n        for (int i = 0; i < S.height * S.width * 4; i++)\n          if ((short)imgdata.image[0][i] < 0)\n            imgdata.image[0][i] = 0;\n      }\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);\n    }\n\n    if (O.green_matching && !O.half_size)\n    {\n      green_matching();\n    }\n\n    if(callbacks.pre_scalecolors_cb)\n\t(callbacks.pre_scalecolors_cb)(this);\n\n    if (!O.no_auto_scale)\n    {\n      scale_colors();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);\n    }\n\n    if(callbacks.pre_preinterpolate_cb)\n\t(callbacks.pre_preinterpolate_cb)(this);\n\n    pre_interpolate();\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n    if (O.dcb_iterations >= 0)\n      iterations = O.dcb_iterations;\n    if (O.dcb_enhance_fl >= 0)\n      dcb_enhance = O.dcb_enhance_fl;\n    if (O.fbdd_noiserd >= 0)\n      noiserd = O.fbdd_noiserd;\n\n    /* pre-exposure correction callback */\n\n    if (O.exp_correc > 0)\n    {\n      expos = O.exp_shift;\n      preser = O.exp_preser;\n      exp_bef(expos, preser);\n    }\n\n    if(callbacks.pre_interpolate_cb)\n\t(callbacks.pre_interpolate_cb)(this);\n\n    /* post-exposure correction fallback */\n    if (P1.filters && !O.no_interpolation)\n    {\n      if (noiserd > 0 && P1.colors == 3 && P1.filters)\n        fbdd(noiserd);\n\n      if (P1.filters > 1000 && callbacks.interpolate_bayer_cb)\n        (callbacks.interpolate_bayer_cb)(this);\n      else if (P1.filters == 9 && callbacks.interpolate_xtrans_cb)\n        (callbacks.interpolate_xtrans_cb)(this);\n      else if (quality == 0)\n        lin_interpolate();\n      else if (quality == 1 || P1.colors > 3)\n        vng_interpolate();\n      else if (quality == 2 && P1.filters > 1000)\n        ppg_interpolate();\n      else if (P1.filters == LIBRAW_XTRANS)\n      {\n        // Fuji X-Trans\n        xtrans_interpolate(quality > 2 ? 3 : 1);\n      }\n      else if (quality == 3)\n        ahd_interpolate(); // really don't need it here due to fallback op\n      else if (quality == 4)\n        dcb(iterations, dcb_enhance);\n\n      else if (quality == 11)\n        dht_interpolate();\n      else if (quality == 12)\n        aahd_interpolate();\n      // fallback to AHD\n      else\n      {\n        ahd_interpolate();\n        imgdata.process_warnings |= LIBRAW_WARN_FALLBACK_TO_AHD;\n      }\n\n      SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);\n    }\n    if (IO.mix_green)\n    {\n      for (P1.colors = 3, i = 0; i < S.height * S.width; i++)\n        imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);\n    }\n\n    if(callbacks.post_interpolate_cb)\n\t(callbacks.post_interpolate_cb)(this);\n\n    if (!P1.is_foveon)\n    {\n      if (P1.colors == 3)\n      {\n\n        /* median filter callback, if not set use own */\n        median_filter();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);\n      }\n    }\n\n    if (O.highlight == 2)\n    {\n      blend_highlights();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n    }\n\n    if (O.highlight > 2)\n    {\n      recover_highlights();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n    }\n\n    if (O.use_fuji_rotate)\n    {\n      fuji_rotate();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n    }\n\n    if (!libraw_internal_data.output_data.histogram)\n    {\n      libraw_internal_data.output_data.histogram =\n          (int(*)[LIBRAW_HISTOGRAM_SIZE])malloc(sizeof(*libraw_internal_data.output_data.histogram) * 4);\n      merror(libraw_internal_data.output_data.histogram, \"LibRaw::dcraw_process()\");\n    }\n#ifndef NO_LCMS\n    if (O.camera_profile)\n    {\n      apply_profile(O.camera_profile, O.output_profile);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);\n    }\n#endif\n\n    if(callbacks.pre_converttorgb_cb)\n\t(callbacks.pre_converttorgb_cb)(this);\n\n    convert_to_rgb();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);\n\n    if(callbacks.post_converttorgb_cb)\n\t(callbacks.post_converttorgb_cb)(this);\n\n    if (O.use_fuji_rotate)\n    {\n      stretch();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);\n    }\n    O.four_color_rgb = save_4color; // also, restore\n\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n// clang-format off\n// Supported cameras:\nstatic const char *static_camera_list[] = {\n\t\"Adobe Digital Negative (DNG)\",\n\t\"AgfaPhoto DC-833m\",\n\t\"Alcatel 5035D\",\n\t\"Apple iPad Pro\",\n\t\"Apple iPhone SE\",\n\t\"Apple iPhone 6s\",\n\t\"Apple iPhone 6 plus\",\n\t\"Apple iPhone 7\",\n\t\"Apple iPhone 7 plus\",\n\t\"Apple iPhone 8\",\n\t\"Apple iPhone 8 plus\",\n\t\"Apple iPhone X\",\n\t\"Apple QuickTake 100\",\n\t\"Apple QuickTake 150\",\n\t\"Apple QuickTake 200\",\n\t\"ARRIRAW format\",\n\t\"AVT F-080C\",\n\t\"AVT F-145C\",\n\t\"AVT F-201C\",\n\t\"AVT F-510C\",\n\t\"AVT F-810C\",\n\t\"Baumer TXG14\",\n\t\"BlackMagic Cinema Camera\",\n\t\"BlackMagic Micro Cinema Camera\",\n\t\"BlackMagic Pocket Cinema Camera\",\n\t\"BlackMagic Production Camera 4k\",\n\t\"BlackMagic URSA\",\n\t\"BlackMagic URSA Mini 4k\",\n\t\"BlackMagic URSA Mini 4.6k\",\n\t\"BlackMagic URSA Mini Pro 4.6k\",\n\t\"Canon PowerShot 600\",\n\t\"Canon PowerShot A5\",\n\t\"Canon PowerShot A5 Zoom\",\n\t\"Canon PowerShot A50\",\n\t\"Canon PowerShot A410 (CHDK hack)\",\n\t\"Canon PowerShot A460 (CHDK hack)\",\n\t\"Canon PowerShot A470 (CHDK hack)\",\n\t\"Canon PowerShot A530 (CHDK hack)\",\n\t\"Canon PowerShot A540 (CHDK hack)\",\n\t\"Canon PowerShot A550 (CHDK hack)\",\n\t\"Canon PowerShot A570 (CHDK hack)\",\n\t\"Canon PowerShot A590 (CHDK hack)\",\n\t\"Canon PowerShot A610 (CHDK hack)\",\n\t\"Canon PowerShot A620 (CHDK hack)\",\n\t\"Canon PowerShot A630 (CHDK hack)\",\n\t\"Canon PowerShot A640 (CHDK hack)\",\n\t\"Canon PowerShot A650 (CHDK hack)\",\n\t\"Canon PowerShot A710 IS (CHDK hack)\",\n\t\"Canon PowerShot A720 IS (CHDK hack)\",\n\t\"Canon PowerShot A3300 IS (CHDK hack)\",\n\t\"Canon PowerShot D10 (CHDK hack)\",\n\t\"Canon PowerShot ELPH 130 IS (CHDK hack)\",\n\t\"Canon PowerShot ELPH 160 IS (CHDK hack)\",\n\t\"Canon PowerShot Pro70\",\n\t\"Canon PowerShot Pro90 IS\",\n\t\"Canon PowerShot Pro1\",\n\t\"Canon PowerShot G1\",\n\t\"Canon PowerShot G1 X\",\n\t\"Canon PowerShot G1 X Mark II\",\n\t\"Canon PowerShot G1 X Mark III\",\n\t\"Canon PowerShot G2\",\n\t\"Canon PowerShot G3\",\n\t\"Canon PowerShot G3 X\",\n\t\"Canon PowerShot G5\",\n\t\"Canon PowerShot G5 X\",\n\t\"Canon PowerShot G6\",\n\t\"Canon PowerShot G7 (CHDK hack)\",\n\t\"Canon PowerShot G7 X\",\n\t\"Canon PowerShot G7 X Mark II\",\n\t\"Canon PowerShot G9\",\n\t\"Canon PowerShot G9 X\",\n\t\"Canon PowerShot G9 X Mark II\",\n\t\"Canon PowerShot G10\",\n\t\"Canon PowerShot G11\",\n\t\"Canon PowerShot G12\",\n\t\"Canon PowerShot G15\",\n\t\"Canon PowerShot G16\",\n\t\"Canon PowerShot S2 IS (CHDK hack)\",\n\t\"Canon PowerShot S3 IS (CHDK hack)\",\n\t\"Canon PowerShot S5 IS (CHDK hack)\",\n\t\"Canon PowerShot SD300 (CHDK hack)\",\n\t\"Canon PowerShot SD750 (CHDK hack)\",\n\t\"Canon PowerShot SD950 (CHDK hack)\",\n\t\"Canon PowerShot S30\",\n\t\"Canon PowerShot S40\",\n\t\"Canon PowerShot S45\",\n\t\"Canon PowerShot S50\",\n\t\"Canon PowerShot S60\",\n\t\"Canon PowerShot S70\",\n\t\"Canon PowerShot S90\",\n\t\"Canon PowerShot S95\",\n\t\"Canon PowerShot S100\",\n\t\"Canon PowerShot S110\",\n\t\"Canon PowerShot S120\",\n\t\"Canon PowerShot SX1 IS\",\n\t\"Canon PowerShot SX50 HS\",\n\t\"Canon PowerShot SX60 HS\",\n\t\"Canon PowerShot SX100 IS (CHDK hack)\",\n\t\"Canon PowerShot SX110 IS (CHDK hack)\",\n\t\"Canon PowerShot SX120 IS (CHDK hack)\",\n\t\"Canon PowerShot SX130 IS (CHDK hack)\",\n\t\"Canon PowerShot SX160 IS (CHDK hack)\",\n\t\"Canon PowerShot SX220 HS (CHDK hack)\",\n\t\"Canon PowerShot SX510 HS (CHDK hack)\",\n\t\"Canon PowerShot SX10 IS (CHDK hack)\",\n\t\"Canon PowerShot SX20 IS (CHDK hack)\",\n\t\"Canon PowerShot SX30 IS (CHDK hack)\",\n\t\"Canon PowerShot IXUS 160 (CHDK hack)\",\n\t\"Canon PowerShot IXUS 900Ti (CHDK hack)\",\n\t\"Canon EOS D30\",\n\t\"Canon EOS D60\",\n\t\"Canon EOS 5D\",\n\t\"Canon EOS 5DS\",\n\t\"Canon EOS 5DS R\",\n\t\"Canon EOS 5D Mark II\",\n\t\"Canon EOS 5D Mark III\",\n\t\"Canon EOS 5D Mark IV\",\n\t\"Canon EOS 6D\",\n\t\"Canon EOS 6D Mark II\",\n\t\"Canon EOS 7D\",\n\t\"Canon EOS 7D Mark II\",\n\t\"Canon EOS 10D\",\n\t\"Canon EOS 20D\",\n\t\"Canon EOS 20Da\",\n\t\"Canon EOS 30D\",\n\t\"Canon EOS 40D\",\n\t\"Canon EOS 50D\",\n\t\"Canon EOS 60D\",\n\t\"Canon EOS 60Da\",\n\t\"Canon EOS 70D\",\n\t\"Canon EOS 77D\",\n\t\"Canon EOS 80D\",\n\t\"Canon EOS 200D\",\n\t\"Canon EOS 300D / Digital Rebel / Kiss Digital\",\n\t\"Canon EOS 350D / Digital Rebel XT / Kiss Digital N\",\n\t\"Canon EOS 400D / Digital Rebel XTi / Kiss Digital X\",\n\t\"Canon EOS 450D / Digital Rebel XSi / Kiss Digital X2\",\n\t\"Canon EOS 500D / Digital Rebel T1i / Kiss Digital X3\",\n\t\"Canon EOS 550D / Digital Rebel T2i / Kiss Digital X4\",\n\t\"Canon EOS 600D / Digital Rebel T3i / Kiss Digital X5\",\n\t\"Canon EOS 650D / Digital Rebel T4i / Kiss Digital X6i\",\n\t\"Canon EOS 700D / Digital Rebel T5i\",\n\t\"Canon EOS 750D / Digital Rebel T6i\",\n\t\"Canon EOS 760D / Digital Rebel T6S\",\n\t\"Canon EOS 800D\",\n\t\"Canon EOS 100D / Digital Rebel SL1\",\n\t\"Canon EOS 1000D / Digital Rebel XS / Kiss Digital F\",\n\t\"Canon EOS 1100D / Digital Rebel T3 / Kiss Digital X50\",\n\t\"Canon EOS 1200D\",\n\t\"Canon EOS 1300D\",\n\t\"Canon EOS C500\",\n\t\"Canon EOS D2000C\",\n\t\"Canon EOS M\",\n\t\"Canon EOS M2\",\n\t\"Canon EOS M3\",\n\t\"Canon EOS M5\",\n\t\"Canon EOS M6\",\n\t\"Canon EOS M10\",\n\t\"Canon EOS M100\",\n\t\"Canon EOS-1D\",\n\t\"Canon EOS-1DS\",\n\t\"Canon EOS-1D C\",\n\t\"Canon EOS-1D X\",\n\t\"Canon EOS-1D Mark II\",\n\t\"Canon EOS-1D Mark II N\",\n\t\"Canon EOS-1D Mark III\",\n\t\"Canon EOS-1D Mark IV\",\n\t\"Canon EOS-1Ds Mark II\",\n\t\"Canon EOS-1Ds Mark III\",\n\t\"Canon EOS-1D X Mark II\",\n\t\"Casio QV-2000UX\",\n\t\"Casio QV-3000EX\",\n\t\"Casio QV-3500EX\",\n\t\"Casio QV-4000\",\n\t\"Casio QV-5700\",\n\t\"Casio QV-R41\",\n\t\"Casio QV-R51\",\n\t\"Casio QV-R61\",\n\t\"Casio EX-F1\",\n\t\"Casio EX-FC300S\",\n\t\"Casio EX-FC400S\",\n\t\"Casio EX-FH20\",\n\t\"Casio EX-FH25\",\n\t\"Casio EX-FH100\",\n\t\"Casio EX-P600\",\n\t\"Casio EX-S20\",\n\t\"Casio EX-S100\",\n\t\"Casio EX-Z4\",\n\t\"Casio EX-Z50\",\n\t\"Casio EX-Z500\",\n\t\"Casio EX-Z55\",\n\t\"Casio EX-Z60\",\n\t\"Casio EX-Z75\",\n\t\"Casio EX-Z750\",\n\t\"Casio EX-Z8\",\n\t\"Casio EX-Z850\",\n\t\"Casio EX-Z1050\",\n\t\"Casio EX-ZR100\",\n\t\"Casio EX-Z1080\",\n\t\"Casio EX-ZR700\",\n\t\"Casio EX-ZR710\",\n\t\"Casio EX-ZR750\",\n\t\"Casio EX-ZR800\",\n\t\"Casio EX-ZR850\",\n\t\"Casio EX-ZR1000\",\n\t\"Casio EX-ZR1100\",\n\t\"Casio EX-ZR1200\",\n\t\"Casio EX-ZR1300\",\n\t\"Casio EX-ZR1500\",\n\t\"Casio EX-ZR3000\",\n\t\"Casio EX-ZR4000/5000\",\n\t\"Casio EX-ZR4100/5100\",\n\t\"Casio EX-100\",\n\t\"Casio EX-100F\",\n\t\"Casio EX-10\",\n\t\"Casio Exlim Pro 505\",\n\t\"Casio Exlim Pro 600\",\n\t\"Casio Exlim Pro 700\",\n\t\"Contax N Digital\",\n\t\"Creative PC-CAM 600\",\n\t\"Digital Bolex D16\",\n\t\"Digital Bolex D16M\",\n\t\"DJI 4384x3288\",\n\t\"DJI Phantom4 Pro/Pro+\",\n\t\"DJI Zenmuse X5\",\n\t\"DJI Zenmuse X5R\",\n\t\"DXO One\",\n\t\"Epson R-D1\",\n\t\"Epson R-D1s\",\n\t\"Epson R-D1x\",\n\t\"Foculus 531C\",\n\t\"FujiFilm E505\",\n\t\"FujiFilm E550\",\n\t\"FujiFilm E900\",\n\t\"FujiFilm F700\",\n\t\"FujiFilm F710\",\n\t\"FujiFilm F800\",\n\t\"FujiFilm F810\",\n\t\"FujiFilm S2Pro\",\n\t\"FujiFilm S3Pro\",\n\t\"FujiFilm S5Pro\",\n\t\"FujiFilm S20Pro\",\n\t\"FujiFilm S1\",\n\t\"FujiFilm S100FS\",\n\t\"FujiFilm S5000\",\n\t\"FujiFilm S5100/S5500\",\n\t\"FujiFilm S5200/S5600\",\n\t\"FujiFilm S6000fd\",\n\t\"FujiFilm S6500fd\",\n\t\"FujiFilm S7000\",\n\t\"FujiFilm S9000/S9500\",\n\t\"FujiFilm S9100/S9600\",\n\t\"FujiFilm S200EXR\",\n\t\"FujiFilm S205EXR\",\n\t\"FujiFilm SL1000\",\n\t\"FujiFilm HS10/HS11\",\n\t\"FujiFilm HS20EXR\",\n\t\"FujiFilm HS22EXR\",\n\t\"FujiFilm HS30EXR\",\n\t\"FujiFilm HS33EXR\",\n\t\"FujiFilm HS35EXR\",\n\t\"FujiFilm HS50EXR\",\n\t\"FujiFilm F505EXR\",\n\t\"FujiFilm F550EXR\",\n\t\"FujiFilm F600EXR\",\n\t\"FujiFilm F605EXR\",\n\t\"FujiFilm F770EXR\",\n\t\"FujiFilm F775EXR\",\n\t\"FujiFilm F800EXR\",\n\t\"FujiFilm F900EXR\",\n\t\"FujiFilm GFX 50S\",\n\t\"FujiFilm X-Pro1\",\n\t\"FujiFilm X-Pro2\",\n\t\"FujiFilm X-S1\",\n\t\"FujiFilm XQ1\",\n\t\"FujiFilm XQ2\",\n\t\"FujiFilm X100\",\n\t\"FujiFilm X100f\",\n\t\"FujiFilm X100S\",\n\t\"FujiFilm X100T\",\n\t\"FujiFilm X10\",\n\t\"FujiFilm X20\",\n\t\"FujiFilm X30\",\n\t\"FujiFilm X70\",\n\t\"FujiFilm X-A1\",\n\t\"FujiFilm X-A2\",\n\t\"FujiFilm X-A3\",\n\t\"FujiFilm X-A5\",\n\t\"FujiFilm X-A10\",\n\t\"FujiFilm X-A20\",\n\t\"FujiFilm X-E1\",\n\t\"FujiFilm X-E2\",\n\t\"FujiFilm X-E2S\",\n\t\"FujiFilm X-E3\",\n\t\"FujiFilm X-M1\",\n\t\"FujiFilm XF1\",\n\t\"FujiFilm X-H1\",\n\t\"FujiFilm X-T1\",\n\t\"FujiFilm X-T1 Graphite Silver\",\n\t\"FujiFilm X-T2\",\n\t\"FujiFilm X-T10\",\n\t\"FujiFilm X-T20\",\n\t\"FujiFilm IS-1\",\n\t\"Gione E7\",\n\t\"GITUP GIT2\",\n\t\"GITUP GIT2P\",\n\t\"Google Pixel\",\n\t\"Google Pixel XL\",\n\t\"Hasselblad H2D-22\",\n\t\"Hasselblad H2D-39\",\n\t\"Hasselblad H3DII-22\",\n\t\"Hasselblad H3DII-31\",\n\t\"Hasselblad H3DII-39\",\n\t\"Hasselblad H3DII-50\",\n\t\"Hasselblad H3D-22\",\n\t\"Hasselblad H3D-31\",\n\t\"Hasselblad H3D-39\",\n\t\"Hasselblad H4D-60\",\n\t\"Hasselblad H4D-50\",\n\t\"Hasselblad H4D-40\",\n\t\"Hasselblad H4D-31\",\n\t\"Hasselblad H5D-60\",\n\t\"Hasselblad H5D-50\",\n\t\"Hasselblad H5D-50c\",\n\t\"Hasselblad H5D-40\",\n\t\"Hasselblad H6D-100c\",\n\t\"Hasselblad A6D-100c\", // Aerial camera\n\t\"Hasselblad CFV\",\n\t\"Hasselblad CFV-50\",\n\t\"Hasselblad CFH\",\n\t\"Hasselblad CF-22\",\n\t\"Hasselblad CF-31\",\n\t\"Hasselblad CF-39\",\n\t\"Hasselblad V96C\",\n\t\"Hasselblad Lusso\",\n\t\"Hasselblad Lunar\",\n\t\"Hasselblad True Zoom\",\n\t\"Hasselblad Stellar\",\n\t\"Hasselblad Stellar II\",\n\t\"Hasselblad HV\",\n\t\"Hasselblad X1D\",\n\t\"HTC UltraPixel\",\n\t\"HTC MyTouch 4G\",\n\t\"HTC One (A9)\",\n\t\"HTC One (M9)\",\n\t\"HTC 10\",\n\t\"Huawei P9 (EVA-L09/AL00)\",\n\t\"Huawei Honor6a\",\n\t\"Huawei Honor9\",\n\t\"Huawei Mate10 (BLA-L29)\",\n\t\"Imacon Ixpress 96, 96C\",\n\t\"Imacon Ixpress 384, 384C (single shot only)\",\n\t\"Imacon Ixpress 132C\",\n\t\"Imacon Ixpress 528C (single shot only)\",\n\t\"ISG 2020x1520\",\n\t\"Ikonoskop A-Cam dII Panchromatic\",\n\t\"Ikonoskop A-Cam dII\",\n\t\"Kinefinity KineMINI\",\n\t\"Kinefinity KineRAW Mini\",\n\t\"Kinefinity KineRAW S35\",\n\t\"Kodak DC20\",\n\t\"Kodak DC25\",\n\t\"Kodak DC40\",\n\t\"Kodak DC50\",\n\t\"Kodak DC120\",\n\t\"Kodak DCS200\",\n\t\"Kodak DCS315C\",\n\t\"Kodak DCS330C\",\n\t\"Kodak DCS420\",\n\t\"Kodak DCS460\",\n\t\"Kodak DCS460A\",\n\t\"Kodak DCS460D\",\n\t\"Kodak DCS520C\",\n\t\"Kodak DCS560C\",\n\t\"Kodak DCS620C\",\n\t\"Kodak DCS620X\",\n\t\"Kodak DCS660C\",\n\t\"Kodak DCS660M\",\n\t\"Kodak DCS720X\",\n\t\"Kodak DCS760C\",\n\t\"Kodak DCS760M\",\n\t\"Kodak EOSDCS1\",\n\t\"Kodak EOSDCS3B\",\n\t\"Kodak NC2000F\",\n\t\"Kodak ProBack\",\n\t\"Kodak PB645C\",\n\t\"Kodak PB645H\",\n\t\"Kodak PB645M\",\n\t\"Kodak DCS Pro 14n\",\n\t\"Kodak DCS Pro 14nx\",\n\t\"Kodak DCS Pro SLR/c\",\n\t\"Kodak DCS Pro SLR/n\",\n\t\"Kodak C330\",\n\t\"Kodak C603\",\n\t\"Kodak P850\",\n\t\"Kodak P880\",\n\t\"Kodak S-1\",\n\t\"Kodak Z980\",\n\t\"Kodak Z981\",\n\t\"Kodak Z990\",\n\t\"Kodak Z1015\",\n\t\"Kodak KAI-0340\",\n\t\"Konica KD-400Z\",\n\t\"Konica KD-510Z\",\n\t\"Leaf AFi 5\",\n\t\"Leaf AFi 6\",\n\t\"Leaf AFi 7\",\n\t\"Leaf AFi-II 6\",\n\t\"Leaf AFi-II 7\",\n\t\"Leaf AFi-II 10\",\n\t\"Leaf AFi-II 10R\",\n\t\"Leaf Aptus-II 5\",\n\t\"Leaf Aptus-II 6\",\n\t\"Leaf Aptus-II 7\",\n\t\"Leaf Aptus-II 8\",\n\t\"Leaf Aptus-II 10\",\n\t\"Leaf Aptus-II 12\",\n\t\"Leaf Aptus-II 12R\",\n\t\"Leaf Aptus 17\",\n\t\"Leaf Aptus 22\",\n\t\"Leaf Aptus 54S\",\n\t\"Leaf Aptus 65\",\n\t\"Leaf Aptus 65S\",\n\t\"Leaf Aptus 75\",\n\t\"Leaf Aptus 75S\",\n\t\"Leaf Cantare\",\n\t\"Leaf Cantare XY\",\n\t\"Leaf CatchLight\",\n\t\"Leaf CMost\",\n\t\"Leaf Credo 40\",\n\t\"Leaf Credo 50\",\n\t\"Leaf Credo 60\",\n\t\"Leaf Credo 80 (low compression mode only)\",\n\t\"Leaf DCB-II\",\n\t\"Leaf Valeo 6\",\n\t\"Leaf Valeo 11\",\n\t\"Leaf Valeo 17\",\n\t\"Leaf Valeo 17wi\",\n\t\"Leaf Valeo 22\",\n\t\"Leaf Valeo 22wi\",\n\t\"Leaf Volare\",\n\t\"Lenovo a820\",\n\t\"Leica C (Typ 112)\",\n\t\"Leica CL\",\n\t\"Leica Digilux 2\",\n\t\"Leica Digilux 3\",\n\t\"Leica Digital-Modul-R\",\n\t\"Leica D-LUX2\",\n\t\"Leica D-LUX3\",\n\t\"Leica D-LUX4\",\n\t\"Leica D-LUX5\",\n\t\"Leica D-LUX6\",\n\t\"Leica D-Lux (Typ 109)\",\n\t\"Leica M8\",\n\t\"Leica M8.2\",\n\t\"Leica M9\",\n\t\"Leica M10\",\n\t\"Leica M (Typ 240)\",\n\t\"Leica M (Typ 262)\",\n\t\"Leica Monochrom (Typ 240)\",\n\t\"Leica Monochrom (Typ 246)\",\n\t\"Leica M-D (Typ 262)\",\n\t\"Leica M-E\",\n\t\"Leica M-P\",\n\t\"Leica R8\",\n\t\"Leica Q (Typ 116)\",\n\t\"Leica S\",\n\t\"Leica S2\",\n\t\"Leica S (Typ 007)\",\n\t\"Leica SL (Typ 601)\",\n\t\"Leica T (Typ 701)\",\n\t\"Leica TL\",\n\t\"Leica TL2\",\n\t\"Leica X1\",\n\t\"Leica X (Typ 113)\",\n\t\"Leica X2\",\n\t\"Leica X-E (Typ 102)\",\n\t\"Leica X-U (Typ 113)\",\n\t\"Leica V-LUX1\",\n\t\"Leica V-LUX2\",\n\t\"Leica V-LUX3\",\n\t\"Leica V-LUX4\",\n\t\"Leica V-Lux (Typ 114)\",\n\t\"Leica X VARIO (Typ 107)\",\n\t\"LG G3\",\n\t\"LG G4\",\n\t\"LG V20 (F800K)\",\n\t\"LG VS995\",\n\t\"Logitech Fotoman Pixtura\",\n\t\"Mamiya ZD\",\n\t\"Matrix 4608x3288\",\n\t\"Meizy MX4\",\n\t\"Micron 2010\",\n\t\"Minolta RD175\",\n\t\"Minolta DiMAGE 5\",\n\t\"Minolta DiMAGE 7\",\n\t\"Minolta DiMAGE 7i\",\n\t\"Minolta DiMAGE 7Hi\",\n\t\"Minolta DiMAGE A1\",\n\t\"Minolta DiMAGE A2\",\n\t\"Minolta DiMAGE A200\",\n\t\"Minolta DiMAGE G400\",\n\t\"Minolta DiMAGE G500\",\n\t\"Minolta DiMAGE G530\",\n\t\"Minolta DiMAGE G600\",\n\t\"Minolta DiMAGE Z2\",\n\t\"Minolta Alpha/Dynax/Maxxum 5D\",\n\t\"Minolta Alpha/Dynax/Maxxum 7D\",\n\t\"Motorola PIXL\",\n\t\"Nikon D1\",\n\t\"Nikon D1H\",\n\t\"Nikon D1X\",\n\t\"Nikon D2H\",\n\t\"Nikon D2Hs\",\n\t\"Nikon D2X\",\n\t\"Nikon D2Xs\",\n\t\"Nikon D3\",\n\t\"Nikon D3s\",\n\t\"Nikon D3X\",\n\t\"Nikon D4\",\n\t\"Nikon D4s\",\n\t\"Nikon D40\",\n\t\"Nikon D40X\",\n\t\"Nikon D5\",\n\t\"Nikon D50\",\n\t\"Nikon D60\",\n\t\"Nikon D70\",\n\t\"Nikon D70s\",\n\t\"Nikon D80\",\n\t\"Nikon D90\",\n\t\"Nikon D100\",\n\t\"Nikon D200\",\n\t\"Nikon D300\",\n\t\"Nikon D300s\",\n\t\"Nikon D500\",\n\t\"Nikon D600\",\n\t\"Nikon D610\",\n\t\"Nikon D700\",\n\t\"Nikon D750\",\n\t\"Nikon D800\",\n\t\"Nikon D800E\",\n\t\"Nikon D810\",\n\t\"Nikon D810A\",\n\t\"Nikon D850\",\n\t\"Nikon D3000\",\n\t\"Nikon D3100\",\n\t\"Nikon D3200\",\n\t\"Nikon D3300\",\n\t\"Nikon D3400\",\n\t\"Nikon D5000\",\n\t\"Nikon D5100\",\n\t\"Nikon D5200\",\n\t\"Nikon D5300\",\n\t\"Nikon D5500\",\n\t\"Nikon D5600\",\n\t\"Nikon D7000\",\n\t\"Nikon D7100\",\n\t\"Nikon D7200\",\n\t\"Nikon D7500\",\n\t\"Nikon Df\",\n\t\"Nikon 1 AW1\",\n\t\"Nikon 1 J1\",\n\t\"Nikon 1 J2\",\n\t\"Nikon 1 J3\",\n\t\"Nikon 1 J4\",\n\t\"Nikon 1 J5\",\n\t\"Nikon 1 S1\",\n\t\"Nikon 1 S2\",\n\t\"Nikon 1 V1\",\n\t\"Nikon 1 V2\",\n\t\"Nikon 1 V3\",\n\t\"Nikon E700 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E800 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E880 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E900 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E950 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E990 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E995 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E2100 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E2500 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E3200 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E3700 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E4300 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E4500 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E5000\",\n\t\"Nikon E5400\",\n\t\"Nikon E5700\",\n\t\"Nikon E8400\",\n\t\"Nikon E8700\",\n\t\"Nikon E8800\",\n\t\"Nikon Coolpix A\",\n\t\"Nikon Coolpix B700\",\n\t\"Nikon Coolpix P330\",\n\t\"Nikon Coolpix P340\",\n\t\"Nikon Coolpix P6000\",\n\t\"Nikon Coolpix P7000\",\n\t\"Nikon Coolpix P7100\",\n\t\"Nikon Coolpix P7700\",\n\t\"Nikon Coolpix P7800\",\n\t\"Nikon Coolpix S6 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon Coolscan NEF\",\n\t\"Nokia N95\",\n\t\"Nokia X2\",\n\t\"Nokia 1200x1600\",\n\t\"Nokia Lumia 950 XL\",\n\t\"Nokia Lumia 1020\",\n\t\"Nokia Lumia 1520\",\n\t\"Olympus AIR A01\",\n\t\"Olympus C3030Z\",\n\t\"Olympus C5050Z\",\n\t\"Olympus C5060Z\",\n\t\"Olympus C7070WZ\",\n\t\"Olympus C70Z,C7000Z\",\n\t\"Olympus C740UZ\",\n\t\"Olympus C770UZ\",\n\t\"Olympus C8080WZ\",\n\t\"Olympus X200,D560Z,C350Z\",\n\t\"Olympus E-1\",\n\t\"Olympus E-3\",\n\t\"Olympus E-5\",\n\t\"Olympus E-10\",\n\t\"Olympus E-20\",\n\t\"Olympus E-30\",\n\t\"Olympus E-300\",\n\t\"Olympus E-330\",\n\t\"Olympus E-400\",\n\t\"Olympus E-410\",\n\t\"Olympus E-420\",\n\t\"Olympus E-450\",\n\t\"Olympus E-500\",\n\t\"Olympus E-510\",\n\t\"Olympus E-520\",\n\t\"Olympus E-600\",\n\t\"Olympus E-620\",\n\t\"Olympus E-P1\",\n\t\"Olympus E-P2\",\n\t\"Olympus E-P3\",\n\t\"Olympus E-P5\",\n\t\"Olympus E-PL1\",\n\t\"Olympus E-PL1s\",\n\t\"Olympus E-PL2\",\n\t\"Olympus E-PL3\",\n\t\"Olympus E-PL5\",\n\t\"Olympus E-PL6\",\n\t\"Olympus E-PL7\",\n\t\"Olympus E-PL8\",\n\t\"Olympus E-PL9\",\n\t\"Olympus E-PM1\",\n\t\"Olympus E-PM2\",\n\t\"Olympus E-M1\",\n\t\"Olympus E-M1 Mark II\",\n\t\"Olympus E-M10\",\n\t\"Olympus E-M10 Mark II\",\n\t\"Olympus E-M10 Mark III\",\n\t\"Olympus E-M5\",\n\t\"Olympus E-M5 Mark II\",\n\t\"Olympus Pen F\",\n\t\"Olympus SP310\",\n\t\"Olympus SP320\",\n\t\"Olympus SP350\",\n\t\"Olympus SP500UZ\",\n\t\"Olympus SP510UZ\",\n\t\"Olympus SP550UZ\",\n\t\"Olympus SP560UZ\",\n\t\"Olympus SP565UZ\",\n\t\"Olympus SP570UZ\",\n\t\"Olympus STYLUS1\",\n\t\"Olympus STYLUS1s\",\n\t\"Olympus SH-2\",\n\t\"Olympus SH-3\",\n\t\"Olympus TG-4\",\n\t\"Olympus TG-5\",\n\t\"Olympus XZ-1\",\n\t\"Olympus XZ-2\",\n\t\"Olympus XZ-10\",\n\t\"OmniVision 4688\",\n\t\"OmniVision OV5647\",\n\t\"OmniVision OV5648\",\n\t\"OmniVision OV8850\",\n\t\"OmniVision 13860\",\n        \"OnePlus One\",\n        \"OnePlus A3303\",\n        \"OnePlus A5000\",\n\t\"Panasonic DMC-CM1\",\n\t\"Panasonic DMC-FZ8\",\n\t\"Panasonic DMC-FZ18\",\n\t\"Panasonic DMC-FZ28\",\n\t\"Panasonic DMC-FZ30\",\n\t\"Panasonic DMC-FZ35/FZ38\",\n\t\"Panasonic DMC-FZ40\",\n\t\"Panasonic DMC-FZ45\",\n\t\"Panasonic DMC-FZ50\",\n\t\"Panasonic DMC-FZ7\",\n\t\"Panasonic DMC-FZ70\",\n\t\"Panasonic DMC-FZ72\",\n\t\"Panasonic DC-FZ80/82\",\n\t\"Panasonic DMC-FZ100\",\n\t\"Panasonic DMC-FZ150\",\n\t\"Panasonic DMC-FZ200\",\n\t\"Panasonic DMC-FZ300/330\",\n\t\"Panasonic DMC-FZ1000\",\n\t\"Panasonic DMC-FZ2000/2500/FZH1\",\n\t\"Panasonic DMC-FX150\",\n\t\"Panasonic DMC-G1\",\n\t\"Panasonic DMC-G10\",\n\t\"Panasonic DMC-G2\",\n\t\"Panasonic DMC-G3\",\n\t\"Panasonic DMC-G5\",\n\t\"Panasonic DMC-G6\",\n\t\"Panasonic DMC-G7/G70\",\n\t\"Panasonic DMC-G8/80/81/85\",\n\t\"Panasonic DC-G9\",\n\t\"Panasonic DMC-GF1\",\n\t\"Panasonic DMC-GF2\",\n\t\"Panasonic DMC-GF3\",\n\t\"Panasonic DMC-GF5\",\n\t\"Panasonic DMC-GF6\",\n\t\"Panasonic DMC-GF7\",\n\t\"Panasonic DC-GF10/GF90\",\n\t\"Panasonic DMC-GH1\",\n\t\"Panasonic DMC-GH2\",\n\t\"Panasonic DMC-GH3\",\n\t\"Panasonic DMC-GH4\",\n\t\"Panasonic AG-GH4\",\n\t\"Panasonic DC-GH5\",\n\t\"Panasonic DMC-GM1\",\n\t\"Panasonic DMC-GM1s\",\n\t\"Panasonic DMC-GM5\",\n\t\"Panasonic DMC-GX1\",\n\t\"Panasonic DMC-GX7\",\n\t\"Panasonic DMC-GX8\",\n\t\"Panasonic DC-GX9\",\n\t\"Panasonic DMC-GX80/85\",\n\t\"Panasonic DC-GX800/850/GF9\",\n\t\"Panasonic DMC-L1\",\n\t\"Panasonic DMC-L10\",\n\t\"Panasonic DMC-LC1\",\n\t\"Panasonic DMC-LF1\",\n\t\"Panasonic DMC-LX1\",\n\t\"Panasonic DMC-LX2\",\n\t\"Panasonic DMC-LX3\",\n\t\"Panasonic DMC-LX5\",\n\t\"Panasonic DMC-LX7\",\n\t\"Panasonic DMC-LX9/10/15\",\n\t\"Panasonic DMC-LX100\",\n\t\"Panasonic DMC-TZ60/61/SZ40\",\n\t\"Panasonic DMC-TZ70/71/ZS50\",\n\t\"Panasonic DMC-TZ80/81/85/ZS60\",\n\t\"Panasonic DC-ZS70 (DC-TZ90/91/92, DC-T93)\",\n\t\"Panasonic DC-TZ100/101/ZS100\",\n\t\"Panasonic DC-TZ200/ZS200\",\n\t\"PARROT Bebop 2\",\n\t\"PARROT Bebop Drone\",\n\t\"Pentax *ist D\",\n\t\"Pentax *ist DL\",\n\t\"Pentax *ist DL2\",\n\t\"Pentax *ist DS\",\n\t\"Pentax *ist DS2\",\n\t\"Pentax GR\",\n\t\"Pentax K10D\",\n\t\"Pentax K20D\",\n\t\"Pentax K100D\",\n\t\"Pentax K100D Super\",\n\t\"Pentax K110D\",\n\t\"Pentax K200D\",\n\t\"Pentax K2000/K-m\",\n\t\"Pentax KP\",\n\t\"Pentax K-x\",\n\t\"Pentax K-r\",\n\t\"Pentax K-01\",\n\t\"Pentax K-1\",\n\t\"Pentax K-3\",\n\t\"Pentax K-3 II\",\n\t\"Pentax K-30\",\n\t\"Pentax K-5\",\n\t\"Pentax K-5 II\",\n\t\"Pentax K-5 IIs\",\n\t\"Pentax K-50\",\n\t\"Pentax K-500\",\n\t\"Pentax K-7\",\n\t\"Pentax K-70\",\n\t\"Pentax K-S1\",\n\t\"Pentax K-S2\",\n\t\"Pentax MX-1\",\n\t\"Pentax Q\",\n\t\"Pentax Q7\",\n\t\"Pentax Q10\",\n\t\"Pentax QS-1\",\n\t\"Pentax Optio S\",\n\t\"Pentax Optio S4\",\n\t\"Pentax Optio 33WR\",\n\t\"Pentax Optio 750Z\",\n\t\"Pentax 645D\",\n\t\"Pentax 645Z\",\n\t\"PhaseOne IQ140\",\n\t\"PhaseOne IQ150\",\n\t\"PhaseOne IQ160\",\n\t\"PhaseOne IQ180\",\n\t\"PhaseOne IQ180 IR\",\n\t\"PhaseOne IQ250\",\n\t\"PhaseOne IQ260\",\n\t\"PhaseOne IQ260 Achromatic\",\n\t\"PhaseOne IQ280\",\n\t\"PhaseOne IQ3 50MP\",\n\t\"PhaseOne IQ3 60MP\",\n\t\"PhaseOne IQ3 80MP\",\n\t\"PhaseOne IQ3 100MP\",\n\t\"PhaseOne IQ3 100MP Trichromatic\",\n\t\"PhaseOne LightPhase\",\n\t\"PhaseOne Achromatic+\",\n\t\"PhaseOne H 10\",\n\t\"PhaseOne H 20\",\n\t\"PhaseOne H 25\",\n\t\"PhaseOne P 20\",\n\t\"PhaseOne P 20+\",\n\t\"PhaseOne P 21\",\n\t\"PhaseOne P 25\",\n\t\"PhaseOne P 25+\",\n\t\"PhaseOne P 30\",\n\t\"PhaseOne P 30+\",\n\t\"PhaseOne P 40+\",\n\t\"PhaseOne P 45\",\n\t\"PhaseOne P 45+\",\n\t\"PhaseOne P 65\",\n\t\"PhaseOne P 65+\",\n\t\"Photron BC2-HD\",\n\t\"Pixelink A782\",\n\t\"Polaroid x530\",\n\t\"RaspberryPi Camera\",\n\t\"RaspberryPi Camera V2\",\n\t\"Ricoh GR\",\n\t\"Ricoh GR Digital\",\n\t\"Ricoh GR Digital II\",\n\t\"Ricoh GR Digital III\",\n\t\"Ricoh GR Digital IV\",\n\t\"Ricoh GR II\",\n\t\"Ricoh GX100\",\n\t\"Ricoh GX200\",\n\t\"Ricoh GXR MOUNT A12\",\n\t\"Ricoh GXR MOUNT A16 24-85mm F3.5-5.5\",\n\t\"Ricoh GXR, S10 24-72mm F2.5-4.4 VC\",\n\t\"Ricoh GXR, GR A12 50mm F2.5 MACRO\",\n\t\"Ricoh GXR, GR LENS A12 28mm F2.5\",\n\t\"Ricoh GXR, GXR P10\",\n#ifndef NO_JASPER\n\t\"Redcode R3D format\",\n#endif\n\t\"Rollei d530flex\",\n\t\"RoverShot 3320af\",\n\t\"Samsung EX1\",\n\t\"Samsung EX2F\",\n\t\"Samsung GX-1L\",\n\t\"Samsung GX-1S\",\n\t\"Samsung GX10\",\n\t\"Samsung GX20\",\n\t\"Samsung Galaxy Nexus\",\n\t\"Samsung Galaxy NX (EK-GN120)\",\n\t\"Samsung Galaxy S3\",\n\t\"Samsung Galaxy S6 (SM-G920F)\",\n\t\"Samsung Galaxy S7\",\n\t\"Samsung Galaxy S7 Edge\",\n\t\"Samsung Galaxy S8 (SM-G950U)\",\n\t\"Samsung NX1\",\n\t\"Samsung NX5\",\n\t\"Samsung NX10\",\n\t\"Samsung NX11\",\n\t\"Samsung NX100\",\n\t\"Samsung NX1000\",\n\t\"Samsung NX1100\",\n\t\"Samsung NX20\",\n\t\"Samsung NX200\",\n\t\"Samsung NX210\",\n\t\"Samsung NX2000\",\n\t\"Samsung NX30\",\n\t\"Samsung NX300\",\n\t\"Samsung NX300M\",\n\t\"Samsung NX3000\",\n\t\"Samsung NX500\",\n\t\"Samsung NX mini\",\n\t\"Samsung Pro815\",\n\t\"Samsung WB550\",\n\t\"Samsung WB2000\",\n\t\"Samsung S85 (hacked)\",\n\t\"Samsung S850 (hacked)\",\n\t\"Sarnoff 4096x5440\",\n\t\"Seitz 6x17\",\n\t\"Seitz Roundshot D3\",\n\t\"Seitz Roundshot D2X\",\n\t\"Seitz Roundshot D2Xs\",\n\t\"Sigma SD9 (raw decode only)\",\n\t\"Sigma SD10 (raw decode only)\",\n\t\"Sigma SD14 (raw decode only)\",\n\t\"Sigma SD15 (raw decode only)\",\n\t\"Sigma SD1\",\n\t\"Sigma SD1 Merill\",\n\t\"Sigma DP1\",\n\t\"Sigma DP1 Merill\",\n\t\"Sigma DP1S\",\n\t\"Sigma DP1X\",\n\t\"Sigma DP2\",\n\t\"Sigma DP2 Merill\",\n\t\"Sigma DP2S\",\n\t\"Sigma DP2X\",\n\t\"Sigma DP3 Merill\",\n\t\"Sigma dp0 Quattro\",\n\t\"Sigma dp1 Quattro\",\n\t\"Sigma dp2 Quattro\",\n\t\"Sigma dp3 Quattro\",\n\t\"Sigma sd Quattro\",\n\t\"Sigma sd Quattro H\",\n\t\"Sinar eMotion 22\",\n\t\"Sinar eMotion 54\",\n\t\"Sinar eSpirit 65\",\n\t\"Sinar eMotion 75\",\n\t\"Sinar eVolution 75\",\n\t\"Sinar 3072x2048\",\n\t\"Sinar 4080x4080\",\n\t\"Sinar 4080x5440\",\n\t\"Sinar STI format\",\n\t\"Sinar Sinarback 54\",\n\t\"SMaL Ultra-Pocket 3\",\n\t\"SMaL Ultra-Pocket 4\",\n\t\"SMaL Ultra-Pocket 5\",\n\t\"Sony A7\",\n\t\"Sony A7 II\",\n\t\"Sony A7R\",\n\t\"Sony A7R II\",\n\t\"Sony A7R III\",\n\t\"Sony A7S\",\n\t\"Sony A7S II\",\n\t\"Sony A9\",\n\t\"Sony ILCA-68 (A68)\",\n\t\"Sony ILCA-77M2 (A77-II)\",\n\t\"Sony ILCA-99M2 (A99-II)\",\n\t\"Sony ILCE-3000\",\n\t\"Sony ILCE-5000\",\n\t\"Sony ILCE-5100\",\n\t\"Sony ILCE-6000\",\n\t\"Sony ILCE-6300\",\n\t\"Sony ILCE-6500\",\n\t\"Sony ILCE-QX1\",\n\t\"Sony DSC-F828\",\n\t\"Sony DSC-R1\",\n\t\"Sony DSC-RX0\",\n\t\"Sony DSC-RX1\",\n\t\"Sony DSC-RX1R\",\n\t\"Sony DSC-RX1R II\",\n\t\"Sony DSC-RX10\",\n\t\"Sony DSC-RX10II\",\n\t\"Sony DSC-RX10III\",\n\t\"Sony DSC-RX10IV\",\n\t\"Sony DSC-RX100\",\n\t\"Sony DSC-RX100II\",\n\t\"Sony DSC-RX100III\",\n\t\"Sony DSC-RX100IV\",\n\t\"Sony DSC-RX100V\",\n\t\"Sony DSC-V3\",\n\t\"Sony DSLR-A100\",\n\t\"Sony DSLR-A200\",\n\t\"Sony DSLR-A230\",\n\t\"Sony DSLR-A290\",\n\t\"Sony DSLR-A300\",\n\t\"Sony DSLR-A330\",\n\t\"Sony DSLR-A350\",\n\t\"Sony DSLR-A380\",\n\t\"Sony DSLR-A390\",\n\t\"Sony DSLR-A450\",\n\t\"Sony DSLR-A500\",\n\t\"Sony DSLR-A550\",\n\t\"Sony DSLR-A560\",\n\t\"Sony DSLR-A580\",\n\t\"Sony DSLR-A700\",\n\t\"Sony DSLR-A850\",\n\t\"Sony DSLR-A900\",\n\t\"Sony NEX-3\",\n\t\"Sony NEX-3N\",\n\t\"Sony NEX-5\",\n\t\"Sony NEX-5N\",\n\t\"Sony NEX-5R\",\n\t\"Sony NEX-5T\",\n\t\"Sony NEX-6\",\n\t\"Sony NEX-7\",\n\t\"Sony NEX-C3\",\n\t\"Sony NEX-F3\",\n\t\"Sony NEX-VG20\",\n\t\"Sony NEX-VG30\",\n\t\"Sony NEX-VG900\",\n\t\"Sony SLT-A33\",\n\t\"Sony SLT-A35\",\n\t\"Sony SLT-A37\",\n\t\"Sony SLT-A55V\",\n\t\"Sony SLT-A57\",\n\t\"Sony SLT-A58\",\n\t\"Sony SLT-A65V\",\n\t\"Sony SLT-A77V\",\n\t\"Sony SLT-A99V\",\n\t\"Sony XCD-SX910CR\",\n\t\"Sony IMX135-mipi 13mp\",\n\t\"Sony IMX135-QCOM\",\n\t\"Sony IMX072-mipi\",\n\t\"Sony IMX214\",\n\t\"Sony IMX219\",\n\t\"Sony IMX230\",\n\t\"Sony IMX298-mipi 16mp\",\n\t\"Sony IMX219-mipi 8mp\",\n\t\"Sony Xperia L\",\n\t\"STV680 VGA\",\n\t\"PtGrey GRAS-50S5C\",\n\t\"JaiPulnix BB-500CL\",\n\t\"JaiPulnix BB-500GE\",\n\t\"SVS SVS625CL\",\n\t\"Yi M1\",\n\t\"YUNEEC CGO3\",\n\t\"YUNEEC CGO3P\",\n\t\"YUNEEC CGO4\",\n\t\"Xiaomi MI3\",\n\t\"Xiaomi RedMi Note3 Pro\",\n\t\"Xiaoyi YIAC3 (YI 4k)\",\n\tNULL\n};\n// clang-format on\n\nconst char **LibRaw::cameraList() { return static_camera_list; }\nint LibRaw::cameraCount() { return (sizeof(static_camera_list) / sizeof(static_camera_list[0])) - 1; }\n\nconst char *LibRaw::strprogress(enum LibRaw_progress p)\n{\n  switch (p)\n  {\n  case LIBRAW_PROGRESS_START:\n    return \"Starting\";\n  case LIBRAW_PROGRESS_OPEN:\n    return \"Opening file\";\n  case LIBRAW_PROGRESS_IDENTIFY:\n    return \"Reading metadata\";\n  case LIBRAW_PROGRESS_SIZE_ADJUST:\n    return \"Adjusting size\";\n  case LIBRAW_PROGRESS_LOAD_RAW:\n    return \"Reading RAW data\";\n  case LIBRAW_PROGRESS_REMOVE_ZEROES:\n    return \"Clearing zero values\";\n  case LIBRAW_PROGRESS_BAD_PIXELS:\n    return \"Removing dead pixels\";\n  case LIBRAW_PROGRESS_DARK_FRAME:\n    return \"Subtracting dark frame data\";\n  case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:\n    return \"Interpolating Foveon sensor data\";\n  case LIBRAW_PROGRESS_SCALE_COLORS:\n    return \"Scaling colors\";\n  case LIBRAW_PROGRESS_PRE_INTERPOLATE:\n    return \"Pre-interpolating\";\n  case LIBRAW_PROGRESS_INTERPOLATE:\n    return \"Interpolating\";\n  case LIBRAW_PROGRESS_MIX_GREEN:\n    return \"Mixing green channels\";\n  case LIBRAW_PROGRESS_MEDIAN_FILTER:\n    return \"Median filter\";\n  case LIBRAW_PROGRESS_HIGHLIGHTS:\n    return \"Highlight recovery\";\n  case LIBRAW_PROGRESS_FUJI_ROTATE:\n    return \"Rotating Fuji diagonal data\";\n  case LIBRAW_PROGRESS_FLIP:\n    return \"Flipping image\";\n  case LIBRAW_PROGRESS_APPLY_PROFILE:\n    return \"ICC conversion\";\n  case LIBRAW_PROGRESS_CONVERT_RGB:\n    return \"Converting to RGB\";\n  case LIBRAW_PROGRESS_STRETCH:\n    return \"Stretching image\";\n  case LIBRAW_PROGRESS_THUMB_LOAD:\n    return \"Loading thumbnail\";\n  default:\n    return \"Some strange things\";\n  }\n}\n\n#undef ID\n\n#include \"../internal/libraw_x3f.cpp\"\n\nvoid x3f_clear(void *p) { x3f_delete((x3f_t *)p); }\n\nvoid utf2char(utf16_t *str, char *buffer, unsigned bufsz)\n{\n if(bufsz<1) return;\n buffer[bufsz-1] = 0;\n  char *b = buffer;\n\n  while (*str != 0x00 && --bufsz>0)\n  {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n}\n\nstatic void *lr_memmem(const void *l, size_t l_len, const void *s, size_t s_len)\n{\n  register char *cur, *last;\n  const char *cl = (const char *)l;\n  const char *cs = (const char *)s;\n\n  /* we need something to compare */\n  if (l_len == 0 || s_len == 0)\n    return NULL;\n\n  /* \"s\" must be smaller or equal to \"l\" */\n  if (l_len < s_len)\n    return NULL;\n\n  /* special case where s_len == 1 */\n  if (s_len == 1)\n    return (void *)memchr(l, (int)*cs, l_len);\n\n  /* the last position where its possible to find \"s\" in \"l\" */\n  last = (char *)cl + l_len - s_len;\n\n  for (cur = (char *)cl; cur <= last; cur++)\n    if (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)\n      return cur;\n  return NULL;\n}\n\nvoid LibRaw::parse_x3f()\n{\n  x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);\n  if (!x3f)\n    return;\n  _x3f_data = x3f;\n\n  x3f_header_t *H = NULL;\n  x3f_directory_section_t *DS = NULL;\n\n  H = &x3f->header;\n  // Parse RAW size from RAW section\n  x3f_directory_entry_t *DE = x3f_get_raw(x3f);\n  if (!DE)\n    return;\n  imgdata.sizes.flip = H->rotation;\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  imgdata.sizes.raw_width = ID->columns;\n  imgdata.sizes.raw_height = ID->rows;\n  // Parse other params from property section\n  DE = x3f_get_prop(x3f);\n  if ((x3f_load_data(x3f, DE) == X3F_OK))\n  {\n    // Parse property list\n    DEH = &DE->header;\n    x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n    if (PL->property_table.size != 0)\n    {\n      int i;\n      x3f_property_t *P = PL->property_table.element;\n      for (i = 0; i < PL->num_properties; i++)\n      {\n        char name[100], value[100];\n        utf2char(P[i].name, name,sizeof(name));\n        utf2char(P[i].value, value,sizeof(value));\n        if (!strcmp(name, \"ISO\"))\n          imgdata.other.iso_speed = atoi(value);\n        if (!strcmp(name, \"CAMMANUF\"))\n          strcpy(imgdata.idata.make, value);\n        if (!strcmp(name, \"CAMMODEL\"))\n          strcpy(imgdata.idata.model, value);\n        if (!strcmp(name, \"CAMSERIAL\"))\n          strcpy(imgdata.shootinginfo.BodySerial, value);\n        if (!strcmp(name, \"WB_DESC\"))\n          strcpy(imgdata.color.model2, value);\n        if (!strcmp(name, \"TIME\"))\n          imgdata.other.timestamp = atoi(value);\n        if (!strcmp(name, \"SHUTTER\"))\n          imgdata.other.shutter = atof(value);\n        if (!strcmp(name, \"APERTURE\"))\n          imgdata.other.aperture = atof(value);\n        if (!strcmp(name, \"FLENGTH\"))\n          imgdata.other.focal_len = atof(value);\n        if (!strcmp(name, \"FLEQ35MM\"))\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);\n        if (!strcmp(name, \"IMAGERTEMP\"))\n          imgdata.other.SensorTemperature = atof(value);\n        if (!strcmp(name, \"LENSARANGE\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);\n          sp = strrchr(value, ' ');\n          if (sp)\n          {\n            imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);\n            if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)\n              my_swap(float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);\n          }\n        }\n        if (!strcmp(name, \"LENSFRANGE\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);\n          sp = strrchr(value, ' ');\n          if (sp)\n          {\n            imgdata.lens.makernotes.MaxFocal = atof(sp);\n            if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)\n              my_swap(float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);\n          }\n        }\n        if (!strcmp(name, \"LENSMODEL\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.LensID = strtol(value, &sp, 16); // atoi(value);\n          if (imgdata.lens.makernotes.LensID)\n            imgdata.lens.makernotes.LensMount = Sigma_X3F;\n        }\n      }\n      imgdata.idata.raw_count = 1;\n      load_raw = &LibRaw::x3f_load_raw;\n      imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;\n      imgdata.idata.is_foveon = 1;\n      libraw_internal_data.internal_output_params.raw_color = 1; // Force adobe coeff\n      imgdata.color.maximum = 0x3fff;                            // To be reset by color table\n      libraw_internal_data.unpacker_data.order = 0x4949;\n    }\n  }\n  else\n  {\n    // No property list\n    if (imgdata.sizes.raw_width == 5888 || imgdata.sizes.raw_width == 2944 || imgdata.sizes.raw_width == 6656 ||\n        imgdata.sizes.raw_width == 3328 || imgdata.sizes.raw_width == 5504 ||\n        imgdata.sizes.raw_width == 2752) // Quattro\n    {\n      imgdata.idata.raw_count = 1;\n      load_raw = &LibRaw::x3f_load_raw;\n      imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;\n      imgdata.idata.is_foveon = 1;\n      libraw_internal_data.internal_output_params.raw_color = 1; // Force adobe coeff\n      libraw_internal_data.unpacker_data.order = 0x4949;\n      strcpy(imgdata.idata.make, \"SIGMA\");\n#if 1\n      // Try to find model number in first 2048 bytes;\n      int pos = libraw_internal_data.internal_data.input->tell();\n      libraw_internal_data.internal_data.input->seek(0, SEEK_SET);\n      unsigned char buf[2048];\n      libraw_internal_data.internal_data.input->read(buf, 2048, 1);\n      libraw_internal_data.internal_data.input->seek(pos, SEEK_SET);\n      unsigned char *fnd = (unsigned char *)lr_memmem(buf, 2048, \"SIGMA dp\", 8);\n      unsigned char *fndsd = (unsigned char *)lr_memmem(buf, 2048, \"sd Quatt\", 8);\n      if (fnd)\n      {\n        unsigned char *nm = fnd + 8;\n        snprintf(imgdata.idata.model, 64, \"dp%c Quattro\", *nm <= '9' && *nm >= '0' ? *nm : '2');\n      }\n      else if (fndsd)\n      {\n        snprintf(imgdata.idata.model, 64, \"%s\", fndsd);\n      }\n      else\n#endif\n          if (imgdata.sizes.raw_width == 6656 || imgdata.sizes.raw_width == 3328)\n        strcpy(imgdata.idata.model, \"sd Quattro H\");\n      else\n        strcpy(imgdata.idata.model, \"dp2 Quattro\");\n    }\n    // else\n  }\n  // Try to get thumbnail data\n  LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;\n  if ((DE = x3f_get_thumb_jpeg(x3f)))\n  {\n    format = LIBRAW_THUMBNAIL_JPEG;\n  }\n  else if ((DE = x3f_get_thumb_plain(x3f)))\n  {\n    format = LIBRAW_THUMBNAIL_BITMAP;\n  }\n  if (DE)\n  {\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n    imgdata.thumbnail.twidth = ID->columns;\n    imgdata.thumbnail.theight = ID->rows;\n    imgdata.thumbnail.tcolors = 3;\n    imgdata.thumbnail.tformat = format;\n    libraw_internal_data.internal_data.toffset = DE->input.offset;\n    write_thumb = &LibRaw::x3f_thumb_loader;\n  }\n}\n\nINT64 LibRaw::x3f_thumb_size()\n{\n  try\n  {\n    x3f_t *x3f = (x3f_t *)_x3f_data;\n    if (!x3f)\n      return -1; // No data pointer set\n    x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n    if (!DE)\n      DE = x3f_get_thumb_plain(x3f);\n    if (!DE)\n      return -1;\n    int64_t p = x3f_load_data_size(x3f, DE);\n    if (p < 0 || p > 0xffffffff)\n      return -1;\n    return p;\n  }\n  catch (...)\n  {\n    return -1;\n  }\n}\n\nvoid LibRaw::x3f_thumb_loader()\n{\n  try\n  {\n    x3f_t *x3f = (x3f_t *)_x3f_data;\n    if (!x3f)\n      return; // No data pointer set\n    x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n    if (!DE)\n      DE = x3f_get_thumb_plain(x3f);\n    if (!DE)\n      return;\n    if (X3F_OK != x3f_load_data(x3f, DE))\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n    imgdata.thumbnail.twidth = ID->columns;\n    imgdata.thumbnail.theight = ID->rows;\n    imgdata.thumbnail.tcolors = 3;\n    if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_JPEG)\n    {\n      imgdata.thumbnail.thumb = (char *)malloc(ID->data_size);\n      merror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");\n      memmove(imgdata.thumbnail.thumb, ID->data, ID->data_size);\n      imgdata.thumbnail.tlength = ID->data_size;\n    }\n    else if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_BITMAP)\n    {\n      imgdata.thumbnail.tlength = ID->columns * ID->rows * 3;\n      imgdata.thumbnail.thumb = (char *)malloc(ID->columns * ID->rows * 3);\n      merror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");\n      char *src0 = (char *)ID->data;\n      for (int row = 0; row < ID->rows; row++)\n      {\n        int offset = row * ID->row_stride;\n        if (offset + ID->columns * 3 > ID->data_size)\n          break;\n        char *dest = &imgdata.thumbnail.thumb[row * ID->columns * 3];\n        char *src = &src0[offset];\n        memmove(dest, src, ID->columns * 3);\n      }\n    }\n  }\n  catch (...)\n  {\n    // do nothing\n  }\n}\n\nstatic inline uint32_t _clampbits(int x, uint32_t n)\n{\n  uint32_t _y_temp;\n  if ((_y_temp = x >> n))\n    x = ~_y_temp >> (32 - n);\n  return x;\n}\n\nvoid LibRaw::x3f_dpq_interpolate_rg()\n{\n  int w = imgdata.sizes.raw_width / 2;\n  int h = imgdata.sizes.raw_height / 2;\n  unsigned short *image = (ushort *)imgdata.rawdata.color3_image;\n\n  for (int color = 0; color < 2; color++)\n  {\n    for (int y = 2; y < (h - 2); y++)\n    {\n      uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * (y * 2) + color]; // dst[1]\n      uint16_t row0_3 = row0[3];\n      uint16_t *row1 = &image[imgdata.sizes.raw_width * 3 * (y * 2 + 1) + color]; // dst1[1]\n      uint16_t row1_3 = row1[3];\n      for (int x = 2; x < (w - 2); x++)\n      {\n        row1[0] = row1[3] = row0[3] = row0[0];\n        row0 += 6;\n        row1 += 6;\n      }\n    }\n  }\n}\n\n#define _ABS(a) ((a) < 0 ? -(a) : (a))\n\n#undef CLIP\n#define CLIP(value, high) ((value) > (high) ? (high) : (value))\n\nvoid LibRaw::x3f_dpq_interpolate_af(int xstep, int ystep, int scale)\n{\n  unsigned short *image = (ushort *)imgdata.rawdata.color3_image;\n  unsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch / 2; // in 16-bit words\n                                                               // Interpolate single pixel\n  for (int y = 0; y < imgdata.rawdata.sizes.height + imgdata.rawdata.sizes.top_margin; y += ystep)\n  {\n    if (y < imgdata.rawdata.sizes.top_margin)\n      continue;\n    if (y < scale)\n      continue;\n    if (y > imgdata.rawdata.sizes.raw_height - scale)\n      break;\n    uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * y];                // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430\n    uint16_t *row_minus = &image[imgdata.sizes.raw_width * 3 * (y - scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435\n    uint16_t *row_plus = &image[imgdata.sizes.raw_width * 3 * (y + scale)];  // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435\n    for (int x = 0; x < imgdata.rawdata.sizes.width + imgdata.rawdata.sizes.left_margin; x += xstep)\n    {\n      if (x < imgdata.rawdata.sizes.left_margin)\n        continue;\n      if (x < scale)\n        continue;\n      if (x > imgdata.rawdata.sizes.raw_width - scale)\n        break;\n      uint16_t *pixel0 = &row0[x * 3];\n      uint16_t *pixel_top = &row_minus[x * 3];\n      uint16_t *pixel_bottom = &row_plus[x * 3];\n      uint16_t *pixel_left = &row0[(x - scale) * 3];\n      uint16_t *pixel_right = &row0[(x + scale) * 3];\n      uint16_t *pixf = pixel_top;\n      if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_bottom[2] - pixel0[2]))\n        pixf = pixel_bottom;\n      if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_left[2] - pixel0[2]))\n        pixf = pixel_left;\n      if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_right[2] - pixel0[2]))\n        pixf = pixel_right;\n      int blocal = pixel0[2], bnear = pixf[2];\n      if (blocal < imgdata.color.black + 16 || bnear < imgdata.color.black + 16)\n      {\n        if (pixel0[0] < imgdata.color.black)\n          pixel0[0] = imgdata.color.black;\n        if (pixel0[1] < imgdata.color.black)\n          pixel0[1] = imgdata.color.black;\n        pixel0[0] = CLIP((pixel0[0] - imgdata.color.black) * 4 + imgdata.color.black, 16383);\n        pixel0[1] = CLIP((pixel0[1] - imgdata.color.black) * 4 + imgdata.color.black, 16383);\n      }\n      else\n      {\n        float multip = float(bnear - imgdata.color.black) / float(blocal - imgdata.color.black);\n        if (pixel0[0] < imgdata.color.black)\n          pixel0[0] = imgdata.color.black;\n        if (pixel0[1] < imgdata.color.black)\n          pixel0[1] = imgdata.color.black;\n        float pixf0 = pixf[0];\n        if (pixf0 < imgdata.color.black)\n          pixf0 = imgdata.color.black;\n        float pixf1 = pixf[1];\n        if (pixf1 < imgdata.color.black)\n          pixf1 = imgdata.color.black;\n\n        pixel0[0] = CLIP(((float(pixf0 - imgdata.color.black) * multip + imgdata.color.black) +\n                          ((pixel0[0] - imgdata.color.black) * 3.75 + imgdata.color.black)) /\n                             2,\n                         16383);\n        pixel0[1] = CLIP(((float(pixf1 - imgdata.color.black) * multip + imgdata.color.black) +\n                          ((pixel0[1] - imgdata.color.black) * 3.75 + imgdata.color.black)) /\n                             2,\n                         16383);\n        // pixel0[1] = float(pixf[1]-imgdata.color.black)*multip + imgdata.color.black;\n      }\n    }\n  }\n}\n\nvoid LibRaw::x3f_dpq_interpolate_af_sd(int xstart, int ystart, int xend, int yend, int xstep, int ystep, int scale)\n{\n  unsigned short *image = (ushort *)imgdata.rawdata.color3_image;\n  unsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch / 2; // in 16-bit words\n  // Interpolate single pixel\n  for (int y = ystart; y < yend && y < imgdata.rawdata.sizes.height + imgdata.rawdata.sizes.top_margin; y += ystep)\n  {\n    uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * y];                // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430\n    uint16_t *row1 = &image[imgdata.sizes.raw_width * 3 * (y + 1)];          // \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\n    uint16_t *row_minus = &image[imgdata.sizes.raw_width * 3 * (y - scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435\n    uint16_t *row_plus =\n        &image[imgdata.sizes.raw_width * 3 * (y + scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435 AF-point (scale=2 -> \u043d\u0438\u0436\u0435 row1\n    uint16_t *row_minus1 = &image[imgdata.sizes.raw_width * 3 * (y - 1)];\n    for (int x = xstart; x < xend && x < imgdata.rawdata.sizes.width + imgdata.rawdata.sizes.left_margin; x += xstep)\n    {\n      uint16_t *pixel00 = &row0[x * 3]; // Current pixel\n      float sumR = 0.f, sumG = 0.f;\n      float cnt = 0.f;\n      for (int xx = -scale; xx <= scale; xx += scale)\n      {\n        sumR += row_minus[(x + xx) * 3];\n        sumR += row_plus[(x + xx) * 3];\n        sumG += row_minus[(x + xx) * 3 + 1];\n        sumG += row_plus[(x + xx) * 3 + 1];\n        cnt += 1.f;\n        if (xx)\n        {\n          cnt += 1.f;\n          sumR += row0[(x + xx) * 3];\n          sumG += row0[(x + xx) * 3 + 1];\n        }\n      }\n      pixel00[0] = sumR / 8.f;\n      pixel00[1] = sumG / 8.f;\n\n      if (scale == 2)\n      {\n        uint16_t *pixel0B = &row0[x * 3 + 3]; // right pixel\n        uint16_t *pixel1B = &row1[x * 3 + 3]; // right pixel\n        float sumG0 = 0, sumG1 = 0.f;\n        float cnt = 0.f;\n        for (int xx = -scale; xx <= scale; xx += scale)\n        {\n          sumG0 += row_minus1[(x + xx) * 3 + 2];\n          sumG1 += row_plus[(x + xx) * 3 + 2];\n          cnt += 1.f;\n          if (xx)\n          {\n            sumG0 += row0[(x + xx) * 3 + 2];\n            sumG1 += row1[(x + xx) * 3 + 2];\n            cnt += 1.f;\n          }\n        }\n        pixel0B[2] = sumG0 / cnt;\n        pixel1B[2] = sumG1 / cnt;\n      }\n\n      //\t\t\tuint16_t* pixel10 = &row1[x*3]; // Pixel below current\n      //\t\t\tuint16_t* pixel_bottom = &row_plus[x*3];\n    }\n  }\n}\n\nvoid LibRaw::x3f_load_raw()\n{\n  // already in try/catch\n  int raise_error = 0;\n  x3f_t *x3f = (x3f_t *)_x3f_data;\n  if (!x3f)\n    return; // No data pointer set\n  if (X3F_OK == x3f_load_data(x3f, x3f_get_raw(x3f)))\n  {\n    x3f_directory_entry_t *DE = x3f_get_raw(x3f);\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n    if (!ID)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    x3f_quattro_t *Q = ID->quattro;\n    x3f_huffman_t *HUF = ID->huffman;\n    x3f_true_t *TRU = ID->tru;\n    uint16_t *data = NULL;\n    if (ID->rows != S.raw_height || ID->columns != S.raw_width)\n    {\n      raise_error = 1;\n      goto end;\n    }\n    if (HUF != NULL)\n      data = HUF->x3rgb16.data;\n    if (TRU != NULL)\n      data = TRU->x3rgb16.data;\n    if (data == NULL)\n    {\n      raise_error = 1;\n      goto end;\n    }\n\n    size_t datasize = S.raw_height * S.raw_width * 3 * sizeof(unsigned short);\n    S.raw_pitch = S.raw_width * 3 * sizeof(unsigned short);\n    if (!(imgdata.rawdata.raw_alloc = malloc(datasize)))\n      throw LIBRAW_EXCEPTION_ALLOC;\n\n    imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n    if (HUF)\n      memmove(imgdata.rawdata.raw_alloc, data, datasize);\n    else if (TRU && (!Q || !Q->quattro_layout))\n      memmove(imgdata.rawdata.raw_alloc, data, datasize);\n    else if (TRU && Q)\n    {\n      // Move quattro data in place\n      // R/B plane\n      for (int prow = 0; prow < TRU->x3rgb16.rows && prow < S.raw_height / 2; prow++)\n      {\n        ushort(*destrow)[3] =\n            (unsigned short(*)[3]) & imgdata.rawdata.color3_image[prow * 2 * S.raw_pitch / 3 / sizeof(ushort)][0];\n        ushort(*srcrow)[3] = (unsigned short(*)[3]) & data[prow * TRU->x3rgb16.row_stride];\n        for (int pcol = 0; pcol < TRU->x3rgb16.columns && pcol < S.raw_width / 2; pcol++)\n        {\n          destrow[pcol * 2][0] = srcrow[pcol][0];\n          destrow[pcol * 2][1] = srcrow[pcol][1];\n        }\n      }\n      for (int row = 0; row < Q->top16.rows && row < S.raw_height; row++)\n      {\n        ushort(*destrow)[3] =\n            (unsigned short(*)[3]) & imgdata.rawdata.color3_image[row * S.raw_pitch / 3 / sizeof(ushort)][0];\n        ushort(*srcrow) = (unsigned short *)&Q->top16.data[row * Q->top16.columns];\n        for (int col = 0; col < Q->top16.columns && col < S.raw_width; col++)\n          destrow[col][2] = srcrow[col];\n      }\n    }\n\n#if 1\n    if (TRU && Q && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF))\n    {\n      if (imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3672) // dpN Quattro normal\n      {\n        x3f_dpq_interpolate_af(32, 8, 2);\n      }\n      else if (imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3776) // sd Quattro normal raw\n      {\n        x3f_dpq_interpolate_af_sd(216, 464, imgdata.sizes.raw_width - 1, 3312, 16, 32, 2);\n      }\n      else if (imgdata.sizes.raw_width == 6656 && imgdata.sizes.raw_height == 4480) // sd Quattro H normal raw\n      {\n        x3f_dpq_interpolate_af_sd(232, 592, imgdata.sizes.raw_width - 1, 3920, 16, 32, 2);\n      }\n      else if (imgdata.sizes.raw_width == 3328 && imgdata.sizes.raw_height == 2240) // sd Quattro H half size\n      {\n        x3f_dpq_interpolate_af_sd(116, 296, imgdata.sizes.raw_width - 1, 2200, 8, 16, 1);\n      }\n      else if (imgdata.sizes.raw_width == 5504 && imgdata.sizes.raw_height == 3680) // sd Quattro H APS-C raw\n      {\n        x3f_dpq_interpolate_af_sd(8, 192, imgdata.sizes.raw_width - 1, 3185, 16, 32, 2);\n      }\n      else if (imgdata.sizes.raw_width == 2752 && imgdata.sizes.raw_height == 1840) // sd Quattro H APS-C half size\n      {\n        x3f_dpq_interpolate_af_sd(4, 96, imgdata.sizes.raw_width - 1, 1800, 8, 16, 1);\n      }\n      else if (imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1836) // dpN Quattro small raw\n      {\n        x3f_dpq_interpolate_af(16, 4, 1);\n      }\n      else if (imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1888) // sd Quattro small\n      {\n        x3f_dpq_interpolate_af_sd(108, 232, imgdata.sizes.raw_width - 1, 1656, 8, 16, 1);\n      }\n    }\n#endif\n    if (TRU && Q && Q->quattro_layout && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATERG))\n      x3f_dpq_interpolate_rg();\n  }\n  else\n    raise_error = 1;\nend:\n  if (raise_error)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n}\n"], "fixing_code": ["/* \n  Copyright 2008-2018 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\nint CLASS fcol(int row, int col)\n{\n  static const char filter[16][16] = {\n      {2, 1, 1, 3, 2, 3, 2, 0, 3, 2, 3, 0, 1, 2, 1, 0}, {0, 3, 0, 2, 0, 1, 3, 1, 0, 1, 1, 2, 0, 3, 3, 2},\n      {2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 2, 1, 2, 0, 0, 3}, {0, 1, 0, 1, 0, 2, 0, 2, 2, 0, 3, 0, 1, 3, 2, 1},\n      {3, 1, 1, 2, 0, 1, 0, 2, 1, 3, 1, 3, 0, 1, 3, 0}, {2, 0, 0, 3, 3, 2, 3, 1, 2, 0, 2, 0, 3, 2, 2, 1},\n      {2, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 0, 0, 1}, {1, 0, 0, 2, 3, 0, 0, 3, 0, 3, 0, 3, 2, 1, 2, 3},\n      {2, 3, 3, 1, 1, 2, 1, 0, 3, 2, 3, 0, 2, 3, 1, 3}, {1, 0, 2, 0, 3, 0, 3, 2, 0, 1, 1, 2, 0, 1, 0, 2},\n      {0, 1, 1, 3, 3, 2, 2, 1, 1, 3, 3, 0, 2, 1, 3, 2}, {2, 3, 2, 0, 0, 1, 3, 0, 2, 0, 1, 2, 3, 0, 1, 0},\n      {1, 3, 1, 2, 3, 2, 3, 2, 0, 2, 0, 1, 1, 0, 3, 0}, {0, 2, 0, 3, 1, 0, 0, 1, 1, 3, 3, 2, 3, 2, 2, 1},\n      {2, 1, 3, 2, 3, 1, 2, 1, 0, 3, 0, 2, 0, 2, 0, 2}, {0, 3, 1, 0, 0, 2, 0, 3, 2, 1, 3, 1, 1, 3, 1, 3}};\n\n  if (filters == 1)\n    return filter[(row + top_margin) & 15][(col + left_margin) & 15];\n  if (filters == 9)\n    return xtrans[(row + 6) % 6][(col + 6) % 6];\n  return FC(row, col);\n}\n\n#if !defined(__FreeBSD__)\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return (p ? p - s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a, b) local_strnlen(a, b)\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int Fuji_wb_list1[] = {LIBRAW_WBI_FineWeather, LIBRAW_WBI_Shade, LIBRAW_WBI_FL_D,\n                              LIBRAW_WBI_FL_L,        LIBRAW_WBI_FL_W,  LIBRAW_WBI_Tungsten};\nstatic int nFuji_wb_list1 = sizeof(Fuji_wb_list1) / sizeof(int);\nstatic int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                            3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                            5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\nstatic int Fuji_wb_list2[] = {LIBRAW_WBI_Auto,  0,  LIBRAW_WBI_Custom,   6,  LIBRAW_WBI_FineWeather, 1,\n                              LIBRAW_WBI_Shade, 8,  LIBRAW_WBI_FL_D,     10, LIBRAW_WBI_FL_L,        11,\n                              LIBRAW_WBI_FL_W,  12, LIBRAW_WBI_Tungsten, 2,  LIBRAW_WBI_Underwater,  35,\n                              LIBRAW_WBI_Ill_A, 82, LIBRAW_WBI_D65,      83};\nstatic int nFuji_wb_list2 = sizeof(Fuji_wb_list2) / sizeof(int);\n\nstatic int Oly_wb_list1[] = {LIBRAW_WBI_Shade,    LIBRAW_WBI_Cloudy, LIBRAW_WBI_FineWeather,\n                             LIBRAW_WBI_Tungsten, LIBRAW_WBI_Sunset, LIBRAW_WBI_FL_D,\n                             LIBRAW_WBI_FL_N,     LIBRAW_WBI_FL_W,   LIBRAW_WBI_FL_WW};\n\nstatic int Oly_wb_list2[] = {LIBRAW_WBI_Auto,\n                             0,\n                             LIBRAW_WBI_Tungsten,\n                             3000,\n                             0x100,\n                             3300,\n                             0x100,\n                             3600,\n                             0x100,\n                             3900,\n                             LIBRAW_WBI_FL_W,\n                             4000,\n                             0x100,\n                             4300,\n                             LIBRAW_WBI_FL_D,\n                             4500,\n                             0x100,\n                             4800,\n                             LIBRAW_WBI_FineWeather,\n                             5300,\n                             LIBRAW_WBI_Cloudy,\n                             6000,\n                             LIBRAW_WBI_FL_N,\n                             6600,\n                             LIBRAW_WBI_Shade,\n                             7500,\n                             LIBRAW_WBI_Custom1,\n                             0,\n                             LIBRAW_WBI_Custom2,\n                             0,\n                             LIBRAW_WBI_Custom3,\n                             0,\n                             LIBRAW_WBI_Custom4,\n                             0};\n\nstatic int Pentax_wb_list1[] = {LIBRAW_WBI_Daylight, LIBRAW_WBI_Shade, LIBRAW_WBI_Cloudy, LIBRAW_WBI_Tungsten,\n                                LIBRAW_WBI_FL_D,     LIBRAW_WBI_FL_N,  LIBRAW_WBI_FL_W,   LIBRAW_WBI_Flash};\n\nstatic int Pentax_wb_list2[] = {LIBRAW_WBI_Daylight, LIBRAW_WBI_Shade, LIBRAW_WBI_Cloudy,\n                                LIBRAW_WBI_Tungsten, LIBRAW_WBI_FL_D,  LIBRAW_WBI_FL_N,\n                                LIBRAW_WBI_FL_W,     LIBRAW_WBI_Flash, LIBRAW_WBI_FL_L};\nstatic int nPentax_wb_list2 = sizeof(Pentax_wb_list2) / sizeof(int);\n\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n  int r = fp->read(buf, len, 1);\n  buf[len - 1] = 0;\n  return r;\n}\n#define stmread(buf, maxlen, fp) stread(buf, MIN(maxlen, sizeof(buf)), fp)\n#endif\n\n#if !defined(__GLIBC__) && !defined(__FreeBSD__)\nchar *my_memmem(char *haystack, size_t haystacklen, char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp(c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr(char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf, sizeof(buf) - 1)\n\nushort CLASS sget2(uchar *s)\n{\n  if (order == 0x4949) /* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define nonDNG 0\n#define CameraDNG 1\n#define AdobeDNG 2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords, int maxlen)\n{\n  line[maxlen - 1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while (1)\n  {\n    while (isspace(*p))\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    words[nwords++] = p;\n    while (!isspace(*p) && *p != '\\0')\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    *p++ = '\\0';\n    if (nwords >= maxwords)\n      return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f)\n{\n  if ((a >> 4) > 9)\n    return 0;\n  else if ((a & 0x0f) > 9)\n    return 0;\n  else if ((b >> 4) > 9)\n    return 0;\n  else if ((b & 0x0f) > 9)\n    return 0;\n  else if ((c >> 4) > 9)\n    return 0;\n  else if ((c & 0x0f) > 9)\n    return 0;\n  else if ((d >> 4) > 9)\n    return 0;\n  else if ((d & 0x0f) > 9)\n    return 0;\n  else if ((e >> 4) > 9)\n    return 0;\n  else if ((e & 0x0f) > 9)\n    return 0;\n  else if ((f >> 4) > 9)\n    return 0;\n  else if ((f & 0x0f) > 9)\n    return 0;\n  return 1;\n}\n\nstatic ushort bcd2dec(uchar data)\n{\n  if ((data >> 4) > 9)\n    return 0;\n  else if ((data & 0x0f) > 9)\n    return 0;\n  else\n    return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] =\n    \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\"\n    \"\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\"\n    \"\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\"\n    \"\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\"\n    \"\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\"\n    \"\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\"\n    \"\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\"\n    \"\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\"\n    \"\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\"\n    \"\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse\n{\n  if (order == 0x4d4d) /* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian... */\n    return s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = {0xff, 0xff};\n  fread(str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4(uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint(int type) { return type == 3 ? get2() : get4(); }\n\nfloat CLASS int_to_float(int i)\n{\n  union {\n    int i;\n    float f;\n  } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal(int type)\n{\n  union {\n    char c[8];\n    double d;\n  } u, v;\n  int i, rev;\n\n  switch (type)\n  {\n  case 3:\n    return (unsigned short)get2();\n  case 4:\n    return (unsigned int)get4();\n  case 5:\n    u.d = (unsigned int)get4();\n    v.d = (unsigned int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 8:\n    return (signed short)get2();\n  case 9:\n    return (signed int)get4();\n  case 10:\n    u.d = (signed int)get4();\n    v.d = (signed int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 11:\n    return int_to_float(get4());\n  case 12:\n    rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n    for (i = 0; i < 8; i++)\n      u.c[i ^ rev] = fgetc(ifp);\n    return u.d;\n  default:\n    return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts(ushort *pixel, unsigned count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}\n\nvoid CLASS cubic_spline(const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **)calloc(((2 * len + 4) * sizeof **A + sizeof *A), 2 * len);\n  if (!A)\n    return;\n  A[0] = (float *)(A + 2 * len);\n  for (i = 1; i < 2 * len; i++)\n    A[i] = A[0] + 2 * len * i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i * i))));\n  for (i = 0; i < len; i++)\n  {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len - 1; i > 0; i--)\n  {\n    b[i] = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);\n    d[i - 1] = x[i] - x[i - 1];\n  }\n  for (i = 1; i < len - 1; i++)\n  {\n    A[i][i] = 2 * (d[i - 1] + d[i]);\n    if (i > 1)\n    {\n      A[i][i - 1] = d[i - 1];\n      A[i - 1][i] = d[i - 1];\n    }\n    A[i][len - 1] = 6 * (b[i + 1] - b[i]);\n  }\n  for (i = 1; i < len - 2; i++)\n  {\n    float v = A[i + 1][i] / A[i][i];\n    for (j = 1; j <= len - 1; j++)\n      A[i + 1][j] -= v * A[i][j];\n  }\n  for (i = len - 2; i > 0; i--)\n  {\n    float acc = 0;\n    for (j = i; j <= len - 2; j++)\n      acc += A[i][j] * c[j];\n    c[i] = (A[i][len - 1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len - 1; j++)\n    {\n      if (x[j] <= x_out && x_out <= x[j + 1])\n      {\n        float v = x_out - x[j];\n        y_out = y[j] + ((y[j + 1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j + 1] * d[j]) / 6) * v + (c[j] * 0.5) * v * v +\n                ((c[j + 1] - c[j]) / (6 * d[j])) * v * v * v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 : (ushort)(y_out * 65535.0 + 0.5));\n  }\n  free(A);\n}\n\nvoid CLASS canon_600_fixed_wb(int temp)\n{\n  static const short mul[4][5] = {\n      {667, 358, 397, 565, 452}, {731, 390, 367, 499, 517}, {1119, 396, 348, 448, 537}, {1399, 485, 431, 508, 688}};\n  int lo, hi, i;\n  float frac = 0;\n\n  for (lo = 4; --lo;)\n    if (*mul[lo] <= temp)\n      break;\n  for (hi = 0; hi < 3; hi++)\n    if (*mul[hi] >= temp)\n      break;\n  if (lo != hi)\n    frac = (float)(temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i = 1; i < 5; i++)\n    pre_mul[i - 1] = 1 / (frac * mul[hi][i] + (1 - frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color(int ratio[2], int mar)\n{\n  int clipped = 0, target, miss;\n\n  if (flash_used)\n  {\n    if (ratio[1] < -104)\n    {\n      ratio[1] = -104;\n      clipped = 1;\n    }\n    if (ratio[1] > 12)\n    {\n      ratio[1] = 12;\n      clipped = 1;\n    }\n  }\n  else\n  {\n    if (ratio[1] < -264 || ratio[1] > 461)\n      return 2;\n    if (ratio[1] < -50)\n    {\n      ratio[1] = -50;\n      clipped = 1;\n    }\n    if (ratio[1] > 307)\n    {\n      ratio[1] = 307;\n      clipped = 1;\n    }\n  }\n  target = flash_used || ratio[1] < 197 ? -38 - (398 * ratio[1] >> 10) : -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] && target + 20 >= ratio[0] && !clipped)\n    return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar * 4)\n    return 2;\n  if (miss < -20)\n    miss = -20;\n  if (miss > mar)\n    miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = {0, 0};\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset(&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if (i < 10)\n    mar = 150;\n  else if (i > 12)\n    mar = 20;\n  else\n    mar = 280 - 20 * i;\n  if (flash_used)\n    mar = 80;\n  for (row = 14; row < height - 14; row += 4)\n    for (col = 10; col < width; col += 2)\n    {\n      for (i = 0; i < 8; i++)\n        test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] = BAYER(row + (i >> 1), col + (i & 1));\n      for (i = 0; i < 8; i++)\n        if (test[i] < 150 || test[i] > 1500)\n          goto next;\n      for (i = 0; i < 4; i++)\n        if (abs(test[i] - test[i + 4]) > 50)\n          goto next;\n      for (i = 0; i < 2; i++)\n      {\n        for (j = 0; j < 4; j += 2)\n          ratio[i][j >> 1] = ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];\n        stat[i] = canon_600_color(ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1)\n        goto next;\n      for (i = 0; i < 2; i++)\n        if (stat[i])\n          for (j = 0; j < 2; j++)\n            test[i * 4 + j * 2 + 1] = test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;\n      for (i = 0; i < 8; i++)\n        total[st][i] += test[i];\n      count[st]++;\n    next:;\n    }\n  if (count[0] | count[1])\n  {\n    st = count[0] * 200 < count[1];\n    for (i = 0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {{-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921, -3409},\n                                     {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},\n                                     {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},\n                                     {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};\n  int t = 0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789)\n    t = 1;\n  if (mc > 1.28 && mc <= 2)\n  {\n    if (yc < 0.8789)\n      t = 3;\n    else if (yc <= 2)\n      t = 4;\n  }\n  if (flash_used)\n    t = 5;\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow = row = 0; irow < height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(data, 1, 1120, ifp) < 1120)\n      derror();\n    pix = raw_image + row * raw_width;\n    for (dp = data; dp < data + 1120; dp += 10, pix += 8)\n    {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6);\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1] & 3);\n      pix[4] = (dp[5] << 2) + (dp[9] & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6);\n    }\n    if ((row += 2) > height)\n      row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] = {{1141, 1145}, {1128, 1109}, {1178, 1149}, {1128, 1109}};\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n    {\n      if ((val = BAYER(row, col) - black) < 0)\n        val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row, col) = val;\n    }\n  }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row = 0; row < 100; row++)\n  {\n    fseek(ifp, row * 3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15)\n      return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff(int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf = 0;\n  static int vbits = 0, reset = 0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits tls->getbits.vbits\n#define reset tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25)\n    return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0)\n    return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF && !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))\n  {\n    bitbuf = (bitbuf << 8) + (uchar)c;\n    vbits += 8;\n  }\n  c = bitbuf << (32 - vbits) >> (32 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    c = (uchar)huff[c];\n  }\n  else\n    vbits -= nbits;\n  if (vbits < 0)\n    derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n, 0)\n#define gethuff(h) getbithuff(*h, h + 1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n        00\t\t0x04\n        010\t\t0x03\n        011\t\t0x05\n        100\t\t0x06\n        101\t\t0x02\n        1100\t\t0x07\n        1101\t\t0x01\n        11100\t\t0x08\n        11101\t\t0x09\n        11110\t\t0x00\n        111110\t\t0x0a\n        1111110\t\t0x0b\n        1111111\t\t0xff\n */\nushort *CLASS make_decoder_ref(const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max = 16; max && !count[max]; max--)\n    ;\n  huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);\n  merror(huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h = len = 1; len <= max; len++)\n    for (i = 0; i < count[len]; i++, ++*source)\n      for (j = 0; j < 1 << (max - len); j++)\n        if (h <= 1 << max)\n          huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort *CLASS make_decoder(const uchar *source) { return make_decoder_ref(&source); }\n\nvoid CLASS crw_init_tables(unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n      {0, 1,    4,    2,    3,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x04, 0x03, 0x05, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},\n      {0, 2,    2,    3,    1,    1,    1,    1,    2,    0,    0,    0,    0,    0,   0,\n       0, 0x03, 0x02, 0x04, 0x01, 0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},\n      {0, 0,    6,    3,    1,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x06, 0x05, 0x07, 0x04, 0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},\n  };\n  static const uchar second_tree[3][180] = {\n      {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,    0,    0,    0,    139,  0x03, 0x04,\n       0x02, 0x05, 0x01, 0x06, 0x07, 0x08, 0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,\n       0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42, 0x35, 0x51, 0x36, 0x37, 0x38, 0x29,\n       0x79, 0x26, 0x1a, 0x39, 0x56, 0x57, 0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,\n       0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98, 0x47, 0x48, 0x95, 0x69, 0x99, 0x91,\n       0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6, 0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,\n       0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7, 0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7,\n       0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1, 0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,\n       0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba, 0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3,\n       0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4, 0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},\n      {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,    0,    0,    0,    140,  0x02, 0x03,\n       0x01, 0x04, 0x05, 0x12, 0x11, 0x06, 0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,\n       0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51, 0x34, 0x43, 0x52, 0x29, 0x35, 0x61,\n       0x39, 0x71, 0x62, 0x36, 0x53, 0x26, 0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,\n       0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9, 0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56,\n       0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99, 0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,\n       0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8, 0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82,\n       0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a, 0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,\n       0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8, 0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64,\n       0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8, 0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},\n      {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,    8,    10,   0,    117,  0x04, 0x05,\n       0x03, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,\n       0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34, 0x35, 0x36, 0x39, 0x79, 0x57, 0x58,\n       0x59, 0x28, 0x56, 0x78, 0x27, 0x41, 0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,\n       0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69, 0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88,\n       0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8, 0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,\n       0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a, 0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a,\n       0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6, 0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,\n       0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5, 0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1,\n       0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3, 0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};\n  if (table > 2)\n    table = 2;\n  huff[0] = make_decoder(first_tree[table]);\n  huff[1] = make_decoder(second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret = 1, i;\n\n  fseek(ifp, 0, SEEK_SET);\n  fread(test, 1, sizeof test, ifp);\n  for (i = 540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff)\n    {\n      if (test[i + 1])\n        return 1;\n      ret = 0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];\n\n  crw_init_tables(tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits)\n    maximum = 0x3ff;\n  fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row += 8)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pixel = raw_image + row * raw_width;\n      nblocks = MIN(8, raw_height - row) * raw_width >> 6;\n      for (block = 0; block < nblocks; block++)\n      {\n        memset(diffbuf, 0, sizeof diffbuf);\n        for (i = 0; i < 64; i++)\n        {\n          leaf = gethuff(huff[i > 0]);\n          if (leaf == 0 && i)\n            break;\n          if (leaf == 0xff)\n            continue;\n          i += leaf >> 4;\n          len = leaf & 15;\n          if (len == 0)\n            continue;\n          diff = getbits(len);\n          if ((diff & (1 << (len - 1))) == 0)\n            diff -= (1 << len) - 1;\n          if (i < 64)\n            diffbuf[i] = diff;\n        }\n        diffbuf[0] += carry;\n        carry = diffbuf[0];\n        for (i = 0; i < 64; i++)\n        {\n          if (pnum++ % raw_width == 0)\n            base[0] = base[1] = 512;\n          if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n            derror();\n        }\n      }\n      if (lowbits)\n      {\n        save = ftell(ifp);\n        fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);\n        for (prow = pixel, i = 0; i < raw_width * 2; i++)\n        {\n          c = fgetc(ifp);\n          for (r = 0; r < 8; r += 2, prow++)\n          {\n            val = (*prow << 2) + ((c >> r) & 3);\n            if (raw_width == 2672 && val < 512)\n              val += 2;\n            *prow = val;\n          }\n        }\n        fseek(ifp, save, SEEK_SET);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    FORC(2) free(huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free(huff[c]);\n}\n\nint CLASS ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end(struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free(jh->free[c]);\n  free(jh->row);\n}\n\nint CLASS ljpeg_diff(ushort *huff)\n{\n  int len, diff;\n  if (!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len - 1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort *CLASS ljpeg_row(int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred = 0;\n  ushort mark = 0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0)\n  {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);\n    if (jrow)\n    {\n      fseek(ifp, -2, SEEK_CUR);\n      do\n        mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);\n  for (col = 0; col < jh->wide; col++)\n    FORC(jh->clrs)\n    {\n      diff = ljpeg_diff(jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n        pred = spred;\n      else if (col)\n        pred = row[0][-jh->clrs];\n      else\n        pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col)\n        switch (jh->psv)\n        {\n        case 1:\n          break;\n        case 2:\n          pred = row[1][0];\n          break;\n        case 3:\n          pred = row[1][-jh->clrs];\n          break;\n        case 4:\n          pred = pred + row[1][0] - row[1][-jh->clrs];\n          break;\n        case 5:\n          pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\n          break;\n        case 6:\n          pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\n          break;\n        case 7:\n          pred = (pred + row[1][0]) >> 1;\n          break;\n        default:\n          pred = 0;\n        }\n      if ((**row = pred + diff) >> jh->bits)\n        derror();\n      if (c <= jh->sraw)\n        spred = **row;\n      row[0]++;\n      row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n\n  if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if (jh.clrs == 4 && jwide >= raw_width * 2)\n    jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (jrow = 0; jrow < jh.high; jrow++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      rp = ljpeg_row(jrow, &jh);\n      if (load_flags & 1)\n        row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;\n      for (jcol = 0; jcol < jwide; jcol++)\n      {\n        val = curve[*rp++];\n        if (cr2_slice[0])\n        {\n          jidx = jrow * jwide + jcol;\n          i = jidx / (cr2_slice[1] * raw_height);\n          if ((j = i >= cr2_slice[0]))\n            i = cr2_slice[0];\n          jidx -= i * (cr2_slice[1] * raw_height);\n          row = jidx / cr2_slice[1 + j];\n          col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];\n        }\n        if (raw_width == 3984 && (col -= 2) < 0)\n          col += (row--, raw_width);\n        if (row > raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp(failure, 3);\n#endif\n        if ((unsigned)row < raw_height)\n          RAW(row, col) = val;\n        if (++col >= raw_width)\n          col = (row++, 0);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  ljpeg_end(&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp = 0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;\n  int v[3] = {0, 0, 0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start(&jh, 0) || jh.clrs < 4)\n    return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_flags & 256)\n  {\n    width = raw_width;\n    height = raw_height;\n  }\n\n  try\n  {\n#endif\n    for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)\n    {\n      scol = ecol;\n      ecol += cr2_slice[1] * 2 / jh.clrs;\n      if (!cr2_slice[0] || ecol > raw_width - 1)\n        ecol = raw_width & -2;\n      for (row = 0; row < height; row += (jh.clrs >> 1) - 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        ip = (short(*)[4])image + row * width;\n        for (col = scol; col < ecol; col += 2, jcol += jh.clrs)\n        {\n          if ((jcol %= jwide) == 0)\n            rp = (short *)ljpeg_row(jrow++, &jh);\n          if (col >= width)\n            continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC(jh.clrs - 2)\n            {\n              ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n              ip[col + (c >> 1) * width + (c & 1)][1] = ip[col + (c >> 1) * width + (c & 1)][2] = 8192;\n            }\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else\n#endif\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;\n          }\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    ljpeg_end(&jh);\n    maximum = 0x3fff;\n    height = saved_h;\n    width = saved_w;\n    return;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (cp = model2; *cp && !isdigit(*cp); cp++)\n      ;\n    sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);\n    ver = (v[0] * 1000 + v[1]) * 1000 + v[2];\n    hue = (jh.sraw + 1) << 2;\n    if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n      hue = jh.sraw << 1;\n    ip = (short(*)[4])image;\n    rp = ip[0];\n    for (row = 0; row < height; row++, ip += width)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (row & (jh.sraw >> 1))\n      {\n        for (col = 0; col < width; col += 2)\n          for (c = 1; c < 3; c++)\n            if (row == height - 1)\n            {\n              ip[col][c] = ip[col - width][c];\n            }\n            else\n            {\n              ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;\n            }\n      }\n      for (col = 1; col < width; col += 2)\n        for (c = 1; c < 3; c++)\n          if (col == width - 1)\n            ip[col][c] = ip[col - 1][c];\n          else\n            ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB))\n#endif\n      for (; rp < ip[0]; rp += 4)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        if (unique_id == 0x80000218 || unique_id == 0x80000250 || unique_id == 0x80000261 || unique_id == 0x80000281 ||\n            unique_id == 0x80000287)\n        {\n          rp[1] = (rp[1] << 2) + hue;\n          rp[2] = (rp[2] << 2) + hue;\n          pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);\n          pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);\n          pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);\n        }\n        else\n        {\n          if (unique_id < 0x80000218)\n            rp[0] -= 512;\n          pix[0] = rp[0] + rp[2];\n          pix[2] = rp[0] + rp[1];\n          pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);\n        }\n        FORC3 rp[c] = CLIP15(pix[c] * sraw_mul[c] >> 10);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end(&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select)\n    (*rp)++;\n  if (raw_image)\n  {\n    if (row < raw_height && col < raw_width)\n      RAW(row, col) = curve[**rp];\n    *rp += tiff_samples;\n  }\n  else\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (row < raw_height && col < raw_width)\n      FORC(tiff_samples)\n    image[row * raw_width + col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n#else\n    if (row < height && col < width)\n      FORC(tiff_samples)\n    image[row * width + col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n#endif\n  }\n  if (tiff_samples == 2 && shot_select)\n    (*rp)--;\n}\n\nvoid CLASS ljpeg_idct(struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = {0};\n  static const uchar zigzag[80] = {0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33,\n                                   40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36,\n                                   29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,\n                                   47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;\n  memset(work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];\n  for (i = 1; i < 64; i++)\n  {\n    len = gethuff(jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15)\n      break;\n    coef = getbits(len);\n    if ((coef & (1 << (len - 1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n    if (!ljpeg_start(&jh, 0))\n      break;\n    jwide = jh.wide;\n    if (filters)\n      jwide *= jh.clrs;\n    jwide /= MIN(is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      switch (jh.algo)\n      {\n      case 0xc1:\n        jh.vpred[0] = 16384;\n        getbits(-1);\n        for (jrow = 0; jrow + 7 < jh.high; jrow += 8)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (jcol = 0; jcol + 7 < jh.wide; jcol += 8)\n          {\n            ljpeg_idct(&jh);\n            rp = jh.idct;\n            row = trow + jcol / tile_width + jrow * 2;\n            col = tcol + jcol % tile_width;\n            for (i = 0; i < 16; i += 2)\n              for (j = 0; j < 8; j++)\n                adobe_copy_pixel(row + i, col + j, &rp);\n          }\n        }\n        break;\n      case 0xc3:\n        for (row = col = jrow = 0; jrow < jh.high; jrow++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          rp = ljpeg_row(jrow, &jh);\n          for (jcol = 0; jcol < jwide; jcol++)\n          {\n            adobe_copy_pixel(trow + row, tcol + col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      ljpeg_end(&jh);\n      throw;\n    }\n#endif\n    fseek(ifp, save + 4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end(&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *)calloc(raw_width, tiff_samples * sizeof *pixel);\n  merror(pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (tiff_bps == 16)\n        read_shorts(pixel, raw_width * tiff_samples);\n      else\n      {\n        getbits(-1);\n        for (col = 0; col < raw_width * tiff_samples; col++)\n          pixel[col] = getbits(tiff_bps);\n      }\n      for (rp = pixel, col = 0; col < raw_width; col++)\n        adobe_copy_pixel(row, col, &rp);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek(ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n  for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)\n    huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  int bypp = tiff_bps <= 8 ? 1 : 2;\n  int bufsize = width * 3 * bypp;\n\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for (int row = 0; row < raw_height; row++)\n  {\n    int red = fread(buf, 1, bufsize, ifp);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (tiff_bps <= 8)\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    else\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n  }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n      {0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0,  0,  0, 0, 0, 0, /* 12-bit lossy */\n       5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},\n      {0,    1,    5,    1,    1,    1, 1, 1, 1, 2, 0, 0,  0,  0, 0, 0, /* 12-bit lossy after split */\n       0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},\n      {0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0,  0,  0, 0, 0, 0, /* 12-bit lossless */\n       5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},\n      {0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0,  0,  0,  0,  0, 0, /* 14-bit lossy */\n       5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},\n      {0, 1,    5,    1,    1,    1, 1, 1, 1, 1, 2, 0, 0, 0,  0, 0, /* 14-bit lossy after split */\n       8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},\n      {0, 1, 4, 2, 2, 3, 1,  2, 0,  0,  0, 0, 0, 0,  0, 0, /* 14-bit lossless */\n       7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step = 0, tree = 0, split = 0, row, col, len, shl, diff;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46)\n    tree = 2;\n  if (tiff_bps == 14)\n    tree += 3;\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize - 1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0)\n  {\n    for (i = 0; i < csize; i++)\n      curve[i * step] = get2();\n    for (i = 0; i < max; i++)\n      curve[i] = (curve[i - i % step] * (step - i % step) + curve[i - i % step + step] * (i % step)) / step;\n    fseek(ifp, meta_offset + 562, SEEK_SET);\n    split = get2();\n  }\n  else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts(curve, max = csize);\n  while (curve[max - 2] == curve[max - 1])\n    max--;\n  huff = make_decoder(nikon_tree[tree]);\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (min = row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (split && row == split)\n      {\n        free(huff);\n        huff = make_decoder(nikon_tree[tree + 1]);\n        max += (min = 16) << 1;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        i = gethuff(huff);\n        len = i & 15;\n        shl = i >> 4;\n        diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;\n        if ((diff & (1 << (len - 1))) == 0)\n          diff -= (1 << len) - !shl;\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if ((ushort)(hpred[col & 1] + min) >= max)\n          derror();\n        RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(huff);\n    throw;\n  }\n#endif\n  free(huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col = 0; col < raw_width; col++)\n    {\n      if (!(b = col & 1))\n      {\n        bitbuf = 0;\n        FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;\n        FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705 * yuv[3];\n      rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];\n      rgb[2] = yuv[b] + 1.732446 * yuv[2];\n      FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = {0x00, 0x55, 0xaa, 0xff};\n\n  memset(histo, 0, sizeof histo);\n  fseek(ifp, -2000, SEEK_END);\n  for (i = 0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i = 0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek(ifp, 0, SEEK_SET);\n  for (i = 0; i < 1024; i++)\n  {\n    fread(t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4 & t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct\n  {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n      {0x00, \"Pentax\", \"Optio 33WR\"}, {0x03, \"Nikon\", \"E3200\"}, {0x32, \"Nikon\", \"E3700\"}, {0x33, \"Olympus\", \"C740UZ\"}};\n\n  fseek(ifp, 3072, SEEK_SET);\n  fread(dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits)\n    {\n      strcpy(make, table[i].t_make);\n      strcpy(model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"ppm_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread(thumb, 1, thumb_length, ifp);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)calloc(thumb_length, 2);\n  merror(thumb, \"ppm16_thumb()\");\n  read_shorts((ushort *)thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n    thumb[i] = ((ushort *)thumb)[i] >> 8;\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = {\"012\", \"102\"};\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width * thumb_height;\n  thumb = (char *)calloc(colors, thumb_length);\n  merror(thumb, \"layer_thumb()\");\n  fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width, thumb_height);\n  fread(thumb, thumb_length, colors, ifp);\n  for (i = 0; i < thumb_length; i++)\n    FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);\n  free(thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *)calloc(thumb_length, 2);\n  merror(thumb, \"rollei_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts(thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n  {\n    putc(thumb[i] << 3, ofp);\n    putc(thumb[i] >> 5 << 2, ofp);\n    putc(thumb[i] >> 11 << 3, ofp);\n  }\n  free(thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(raw_width > 32767 || raw_height > 32767)\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n#endif\n  unsigned maxpixel = raw_width*(raw_height+7);\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread(pixel, 1, 10, ifp) == 10)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i = 0; i < 10; i += 2)\n    {\n      todo[i] = iten++;\n      todo[i + 1] = pixel[i] << 8 | pixel[i + 1];\n      buffer = pixel[i] >> 2 | buffer << 6;\n    }\n    for (; i < 16; i += 2)\n    {\n      todo[i] = isix++;\n      todo[i + 1] = buffer >> (14 - i) * 5;\n    }\n    for (i = 0; i < 16; i += 2)\n      if(todo[i] < maxpixel)\n        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n      else\n        derror();\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw(unsigned row, unsigned col) { return (row < raw_height && col < raw_width) ? RAW(row, col) : 0; }\n\nvoid CLASS phase_one_flat_field(int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts(head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0)\n    return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *)calloc(nc * wide, sizeof *mrow);\n  merror(mrow, \"phase_one_flat_field()\");\n  for (y = 0; y < high; y++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x = 0; x < wide; x++)\n      for (c = 0; c < nc; c += 2)\n      {\n        num = is_float ? getreal(11) : get2() / 32768.0;\n        if (y == 0)\n          mrow[c * wide + x] = num;\n        else\n          mrow[(c + 1) * wide + x] = (num - mrow[c * wide + x]) / head[5];\n      }\n    if (y == 0)\n      continue;\n    rend = head[1] + y * head[5];\n    for (row = rend - head[5]; row < raw_height && row < rend && row < head[1] + head[3] - head[5]; row++)\n    {\n      for (x = 1; x < wide; x++)\n      {\n        for (c = 0; c < nc; c += 2)\n        {\n          mult[c] = mrow[c * wide + x - 1];\n          mult[c + 1] = (mrow[c * wide + x] - mult[c]) / head[4];\n        }\n        cend = head[0] + x * head[4];\n        for (col = cend - head[4]; col < raw_width && col < cend && col < head[0] + head[2] - head[4]; col++)\n        {\n          c = nc > 2 ? FC(row - top_margin, col - left_margin) : 0;\n          if (!(c & 1))\n          {\n            c = RAW(row, col) * mult[c];\n            RAW(row, col) = LIM(c, 0, 65535);\n          }\n          for (c = 0; c < nc; c += 2)\n            mult[c] += mult[c + 1];\n        }\n      }\n      for (x = 0; x < wide; x++)\n        for (c = 0; c < nc; c += 2)\n          mrow[c * wide + x] += mrow[(c + 1) * wide + x];\n    }\n  }\n  free(mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {{-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n                                               {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!meta_length)\n#else\n  if (half_size || !meta_length)\n#endif\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Phase One correction...\\n\"));\n#endif\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    while (entries--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x419)\n      { /* Polynomial curve */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(11);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x41a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(11);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n            for (row = 0; row < raw_height; row++)\n              if (FC(row - top_margin, col - left_margin) == 1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) = 0.5 + sum * 0.0732233 + (raw(row, col - 2) + raw(row, col + 2)) * 0.3535534;\n              }\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += raw(row + dir[i][0], col + dir[i][1]);\n            RAW(row, col) = (sum + 4) >> 3;\n          }\n        }\n      }\n      else if (tag == 0x401)\n      { /* All-color flat fields */\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x416 || tag == 0x410)\n      {\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x40b)\n      { /* Red+blue flat field */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x41f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 16; i++)\n              lc[qr][qc][i] = get4();\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x41e && !qmult_applied)\n      { /* Quadrant multipliers */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(11);\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x431 && !qmult_applied)\n      { /* Quadrant combined */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      merror(yval[0], \"phase_one_correct()\");\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(11);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n            frac = (j == 0 || j == head[1]) ? 0 : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);\n            mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek(ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555 : 0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw()\");\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw()\");\n    if (ph1.black_col)\n    {\n      fseek(ifp, ph1.black_col, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height * 2);\n    }\n    if (ph1.black_row)\n    {\n      fseek(ifp, ph1.black_row, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_rblack[0], raw_width * 2);\n    }\n  }\n#endif\n  fseek(ifp, data_offset, SEEK_SET);\n  read_shorts(raw_image, raw_width * raw_height);\n  if (ph1.format)\n    for (i = 0; i < raw_width * raw_height; i += 2)\n    {\n      a = raw_image[i + 0] ^ akey;\n      b = raw_image[i + 1] ^ bkey;\n      raw_image[i + 0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i + 1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff(int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf = 0;\n  static int vbits = 0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0)\n    return 0;\n  if (vbits < nbits)\n  {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64 - vbits) >> (64 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    return (uchar)huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n, 0)\n#define ph1_huff(h) ph1_bithuff(*h, h + 1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = {8, 7, 6, 9, 11, 10, 5, 12, 14, 13};\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short(*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *)calloc(raw_width * 3 + raw_height * 4, 2);\n  merror(pixel, \"phase_one_load_raw_c()\");\n  offset = (int *)(pixel + raw_width);\n  fseek(ifp, strip_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short(*)[2])(offset + raw_height);\n  fseek(ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n    read_shorts((ushort *)c_black[0], raw_height * 2);\n  r_black = c_black + raw_height;\n  fseek(ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n    read_shorts((ushort *)r_black[0], raw_width * 2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_cblack, (ushort *)c_black[0], raw_height * 2 * sizeof(ushort));\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_rblack, (ushort *)r_black[0], raw_width * 2 * sizeof(ushort));\n  }\n#endif\n\n  for (i = 0; i < 256; i++)\n    curve[i] = i * i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + offset[row], SEEK_SET);\n      ph1_bits(-1);\n      pred[0] = pred[1] = 0;\n      for (col = 0; col < raw_width; col++)\n      {\n        if (col >= (raw_width & -8))\n          len[0] = len[1] = 14;\n        else if ((col & 7) == 0)\n          for (i = 0; i < 2; i++)\n          {\n            for (j = 0; j < 5 && !ph1_bits(1); j++)\n              ;\n            if (j--)\n              len[i] = length[j * 2 + ph1_bits(1)];\n          }\n        if ((i = len[col & 1]) == 14)\n          pixel[col] = pred[col & 1] = ph1_bits(16);\n        else\n          pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n        if (pred[col & 1] >> 16)\n          derror();\n        if (ph1.format == 5 && pixel[col] < 256)\n          pixel[col] = curve[pixel[col]];\n      }\n#ifndef LIBRAW_LIBRARY_BUILD\n      for (col = 0; col < raw_width; col++)\n      {\n        int shift = ph1.format == 8 ? 0 : 2;\n        i = (pixel[col] << shift) - ph1.t_black + c_black[row][col >= ph1.split_col] +\n            r_black[col][row >= ph1.split_row];\n        if (i > 0)\n          RAW(row, col) = i;\n      }\n#else\n    if (ph1.format == 8)\n      memmove(&RAW(row, 0), &pixel[0], raw_width * 2);\n    else\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = pixel[col] << 2;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    back[4] = (int *)calloc(raw_width, 3 * sizeof **back);\n    merror(back[4], \"hasselblad_load_raw()\");\n    FORC3 back[c] = back[4] + c * raw_width;\n    cblack[6] >>= sh = tiff_samples > 1;\n    shot = LIM(shot_select, 1, tiff_samples) - 1;\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      FORC4 back[(c + 3) & 3] = back[c];\n      for (col = 0; col < raw_width; col += 2)\n      {\n        for (s = 0; s < tiff_samples * 2; s += 2)\n        {\n          FORC(2) len[c] = ph1_huff(jh.huff[0]);\n          FORC(2)\n          {\n            diff[s + c] = ph1_bits(len[c]);\n            if ((diff[s + c] & (1 << (len[c] - 1))) == 0)\n              diff[s + c] -= (1 << len[c]) - 1;\n            if (diff[s + c] == 65535)\n              diff[s + c] = -32768;\n          }\n        }\n        for (s = col; s < col + 2; s++)\n        {\n          pred = 0x8000 + load_flags;\n          if (col)\n            pred = back[2][s - 2];\n          if (col && row > 1)\n            switch (jh.psv)\n            {\n            case 11:\n              pred += back[0][s] / 2 - back[0][s - 2] / 2;\n              break;\n            }\n          f = (row & 1) * 3 ^ ((col + s) & 1);\n          FORC(tiff_samples)\n          {\n            pred += diff[(s & 1) * tiff_samples + c];\n            upix = pred >> sh & 0xffff;\n            if (raw_image && c == shot)\n              RAW(row, s) = upix;\n            if (image)\n            {\n              urow = row - top_margin + (c & 1);\n              ucol = col - left_margin - ((c >> 1) & 1);\n              ip = &image[urow * width + ucol][f];\n              if (urow < height && ucol < width)\n                *ip = c < 4 ? upix : (*ip + upix) >> 1;\n            }\n          }\n          back[2][s] = pred;\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(back[4]);\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  free(back[4]);\n  ljpeg_end(&jh);\n  if (image)\n    mix_green = 1;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel = 0;\n  unsigned tile = 0, r, c, row, col;\n\n  if (!filters || !raw_image)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!image)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n    merror(pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    FORC(tiff_samples)\n    for (r = 0; r < raw_height; r++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (r % tile_length == 0)\n      {\n        fseek(ifp, data_offset + 4 * tile++, SEEK_SET);\n        fseek(ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select)\n        continue;\n      if (filters && raw_image)\n        pixel = raw_image + r * raw_width;\n      read_shorts(pixel, raw_width);\n      if (!filters && image && (row = r - top_margin) < height)\n        for (col = 0; col < width; col++)\n          image[row * width + col][c] = pixel[col + left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (!filters)\n      free(pixel);\n    throw;\n  }\n#endif\n  if (!filters)\n  {\n    maximum = 0xffff;\n    raw_color = 1;\n    free(pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  read_shorts(raw_image, raw_width * raw_height);\n  if (maximum < 0xffff || load_flags)\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < raw_width; col++)\n        if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n            (unsigned)(col - left_margin) < width)\n          derror();\n    }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  for (row = raw_height - 1; row >= 0; row--)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    read_shorts(&raw_image[row * raw_width], raw_width);\n    for (col = 0; col < raw_width; col++)\n      if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n          (unsigned)(col - left_margin) < width)\n        derror();\n  }\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \"imacon_full_load_raw\");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits = 0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf = 0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1)\n    bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height + 1) >> 1;\n  for (irow = 0; irow < raw_height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 && (row = irow % half * 2 + irow / half) == 1 && load_flags & 4)\n    {\n      if (vbits = 0, tiff_compress)\n        fseek(ifp, data_offset - (-half * bwide & -2048), SEEK_SET);\n      else\n      {\n        fseek(ifp, 0, SEEK_END);\n        fseek(ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col = 0; col < raw_width; col++)\n    {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      val = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);\n      RAW(row, col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) && row < height + top_margin && col < width + left_margin)\n        derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom()\n{\n\n  /* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct\n  {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek(ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread(&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right) * 5) + 3) >> 2) + 0x1f) & (~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616; /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order)\n  {\n  case 0: /* RGGB */\n    filters = 0x94949494;\n    break;\n  case 1: /* GBRG */\n    filters = 0x49494949;\n    break;\n  case 3: /* GRBG */\n    filters = 0x61616161;\n    break;\n  }\n}\n\nvoid CLASS broadcom_load_raw()\n{\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *)malloc(raw_stride * 2);\n  merror(data, \"broadcom_load_raw()\");\n\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data + raw_stride, 1, raw_stride, ifp) < raw_stride)\n      derror();\n    FORC(raw_stride) data[c] = data[raw_stride + (c ^ rev)];\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar *data, *dp;\n  int rev, dwide, row, col, c;\n  double sum[] = {0, 0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *)malloc(dwide * 2);\n  merror(data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(data + dwide, 1, dwide, ifp) < dwide)\n        derror();\n      FORC(dwide) data[c] = data[dwide + (c ^ rev)];\n      for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n        FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n#endif\n  free(data);\n  maximum = 0x3ff;\n  if (strncmp(make, \"OmniVision\", 10))\n    return;\n  row = raw_height / 2;\n  FORC(width - 1)\n  {\n    sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));\n    sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));\n  }\n  if (sum[1] > sum[0])\n    filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf = 0;\n\n  bwide = (raw_width + 5) / 6 << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_loose_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 8, col += 6)\n    {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c ^ 7];\n      FORC(6) RAW(row, col + c) = (bitbuf >> c * 10) & 0x3ff;\n    }\n  }\n  free(data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));\n  merror(words, \"canon_rmf_load_raw\");\n#endif\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words, sizeof(int), raw_width / 3, ifp);\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = words[col / 3];\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#else\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = get4();\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits(int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4002];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits)\n    return vbits = 0;\n  if (!vbits)\n  {\n    fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);\n    fread(buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte + 1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)\n        derror();\n    }\n  }\n}\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n = 0] = 0xc0c;\n  for (i = 12; i--;)\n    FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;\n  fseek(ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(acarry, 0, sizeof acarry);\n    for (col = 0; col < raw_width; col++)\n    {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)\n        ;\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12, huff)) == 12)\n        high = getbits(16 - nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff * 3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;\n      if (col >= width)\n        continue;\n      if (row < 2 && col < 2)\n        pred = 0;\n      else if (row < 2)\n        pred = RAW(row, col - 2);\n      else if (col < 2)\n        pred = RAW(row - 2, col);\n      else\n      {\n        w = RAW(row, col - 2);\n        n = RAW(row - 2, col);\n        nw = RAW(row - 2, col - 2);\n        if ((w < nw && nw < n) || (n < nw && nw < w))\n        {\n          if (ABS(w - nw) > 32 || ABS(n - nw) > 32)\n            pred = w + n - nw;\n          else\n            pred = (w + n) >> 1;\n        }\n        else\n          pred = ABS(w - nw) > ABS(n - nw) ? w : n;\n      }\n      if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)\n        derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow = 0; irow < 1481; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 768, ifp) < 768)\n      derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);\n    switch (irow)\n    {\n    case 1477:\n    case 1479:\n      continue;\n    case 1476:\n      row = 984;\n      break;\n    case 1480:\n      row = 985;\n      break;\n    case 1478:\n      row = 985;\n      box = 1;\n    }\n    if ((box < 12) && (box & 1))\n    {\n      for (col = 0; col < 1533; col++, row ^= 1)\n        if (col != 1)\n          RAW(row, col) = (col + 1) & 2 ? pixel[col / 2 - 1] + pixel[col / 2 + 1] : pixel[col / 2] << 1;\n      RAW(row, 1) = pixel[1] << 1;\n      RAW(row, 1533) = pixel[765] << 1;\n    }\n    else\n      for (col = row & 1; col < 1534; col += 2)\n        RAW(row, col) = pixel[col / 2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2, 2, 8, 15, 22, 32, 44, 60, 89};\n  static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},   {-8, -2, 2, 8},\n                                    {-13, -3, 3, 13}, {-19, -4, 4, 19}, {-28, -6, 6, 28}};\n  static const short t_curve[256] = {\n      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   11,  12,   13,   14,  15,  16,  17,  18,  19,  20,  21,  22,\n      23,  24,  25,  26,  27,  28,  29,  30,  32,  33,  34,  35,   36,   37,  38,  39,  40,  41,  42,  43,  44,  45,\n      46,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,   59,   60,  61,  62,  63,  64,  65,  66,  67,  68,\n      69,  70,  71,  72,  74,  75,  76,  77,  78,  79,  80,  81,   82,   83,  84,  86,  88,  90,  92,  94,  97,  99,\n      101, 103, 105, 107, 110, 112, 114, 116, 118, 120, 123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147,\n      149, 151, 153, 155, 158, 160, 162, 164, 166, 168, 171, 173,  175,  177, 179, 181, 184, 186, 188, 190, 192, 195,\n      197, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 221,  223,  226, 230, 235, 239, 244, 248, 252, 257, 261,\n      265, 270, 274, 278, 283, 287, 291, 296, 300, 305, 309, 313,  318,  322, 326, 331, 335, 339, 344, 348, 352, 357,\n      361, 365, 370, 374, 379, 383, 387, 392, 396, 400, 405, 409,  413,  418, 422, 426, 431, 435, 440, 444, 448, 453,\n      457, 461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,  519,  531, 542, 553, 564, 575, 587, 598, 609, 620,\n      631, 643, 654, 665, 676, 687, 698, 710, 721, 732, 743, 754,  766,  777, 788, 799, 810, 822, 833, 844, 855, 866,\n      878, 889, 900, 911, 922, 933, 945, 956, 967, 978, 989, 1001, 1012, 1023};\n  int rb, row, col, sharp, val = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(width>640 || height > 480)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  getbits(-1);\n  memset(pixel, 0x80, sizeof pixel);\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 2 + (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] + pixel[row][col - 2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val, 0, 255);\n      if (col < 4)\n        pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;\n      if (row == 2)\n        pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb = 0; rb < 2; rb++)\n    for (row = 2 + rb; row < height + 2; row += 2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 3 - (row & 1); col < width + 2; col += 2)\n      {\n        if (row < 4 || col < 4)\n          sharp = 2;\n        else\n        {\n          val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) + ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +\n                ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);\n          sharp = val < 4 ? 0 : val < 8 ? 1 : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;\n        }\n        val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) + rstep[sharp][getbits(2)];\n        pixel[row][col] = val = LIM(val, 0, 255);\n        if (row < 4)\n          pixel[row - 2][col + 2] = val;\n        if (col < 4)\n          pixel[row + 2][col - 2] = val;\n      }\n    }\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 3 - (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row][col - 1] + (pixel[row][col] << 2) + pixel[row][col + 1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val, 0, 255);\n    }\n  }\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n      RAW(row, col) = t_curve[pixel[row + 2][col + 2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char)getbithuff(8, huff[tree]))\n\n#define FORYX                                                                                                          \\\n  for (y = 1; y < 3; y++)                                                                                              \\\n    for (x = col + 1; x >= col; x--)\n\n#define PREDICTOR                                                                                                      \\\n  (c ? (buf[c][y - 1][x] + buf[c][y][x + 1]) / 2 : (buf[c][y - 1][x + 1] + 2 * buf[c][y - 1][x] + buf[c][y][x + 1]) / 4)\n\n#ifdef __GNUC__\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n#pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n#endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  // All kodak radc images are 768x512\n  if (width > 768 || raw_width > 768 || height > 512 || raw_height > 512)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }\n  for (i = 0; i < height * width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer(j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread(jpeg_buffer, 1, 4096, ifp);\n  swab(jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header(&cinfo, TRUE);\n  jpeg_start_decompress(&cinfo);\n  if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n  {\n    fprintf(stderr, _(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress(&cinfo);\n    longjmp(failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * 3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines(&cinfo, buf, 1);\n    pixel = (JSAMPLE(*)[3])buf[0];\n    for (col = 0; col < width; col += 2)\n    {\n      RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n      RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n      RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n      RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n    }\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if (data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf, \"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char *)malloc(width * 3);\n  jpeg_create_decompress(&cinfo);\n  merror(pixel_buf, \"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf, data_size, 1, ifp);\n  swab((char *)jpg_buf, (char *)jpg_buf, data_size);\n  try\n  {\n    jpeg_mem_src(&cinfo, jpg_buf, data_size);\n    int rc = jpeg_read_header(&cinfo, TRUE);\n    if (rc != 1)\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n    jpeg_start_decompress(&cinfo);\n    if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n    {\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n\n    unsigned char *buf[1];\n    buf[0] = pixel_buf;\n\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n      checkCancel();\n      row = cinfo.output_scanline * 2;\n      jpeg_read_scanlines(&cinfo, buf, 1);\n      unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];\n      for (col = 0; col < width; col += 2)\n      {\n        RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n        RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n        RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n        RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n      }\n    }\n  }\n  catch (...)\n  {\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(jpg_buf);\n    free(pixel_buf);\n    throw;\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  unsigned sorder = order, ntags, opcode, deg, i, j, c;\n  unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset)\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--)\n    {\n      opcode = get4();\n      get4();\n      get4();\n      if (opcode != 8)\n      {\n        fseek(ifp, get4(), SEEK_CUR);\n        continue;\n      }\n      fseek(ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2)\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8)\n        break;\n      for (i = 0; i <= deg && i < 9; i++)\n        coeff[i] = getreal(12);\n      for (i = 0; i < 256; i++)\n      {\n        for (tot = j = 0; j <= deg; j++)\n          tot += coeff[j] * pow(i / 255.0, (int)j);\n        cur[c][i] = tot * 0xffff;\n      }\n    }\n    order = sorder;\n  }\n  else\n  {\n    gamma_curve(1 / 2.4, 12.92, 1, 255);\n    FORC3 memcpy(cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  while (trow < raw_height)\n  {\n    fseek(ifp, save += 4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n#else\n    jpeg_stdio_src(&cinfo, ifp);\n#endif\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, cinfo.output_width * 3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      while (cinfo.output_scanline < cinfo.output_height && (row = trow + cinfo.output_scanline) < height)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        jpeg_read_scanlines(&cinfo, buf, 1);\n        pixel = (JSAMPLE(*)[3])buf[0];\n        for (col = 0; col < cinfo.output_width && tcol + col < width; col++)\n        {\n          FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw;\n    }\n#endif\n    jpeg_abort_decompress(&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = {162, 192, 187, 92};\n  static const int add[4] = {0, 636, 424, 212};\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 848, ifp) < 848)\n      derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col = 0; col < width; col++)\n      RAW(row, col) = (ushort)pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, 1, raw_width, ifp) < raw_width)\n        derror();\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = curve[pixel[col]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] = {\n      {0, 1, 5, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n      {0, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi = 0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder(kodak_tree[c]);\n  ns = (raw_height + 63) >> 5;\n  pixel = (uchar *)malloc(raw_width * 32 + ns * 4);\n  merror(pixel, \"kodak_262_load_raw()\");\n  strip = (int *)(pixel + raw_width * 32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if ((row & 31) == 0)\n      {\n        fseek(ifp, strip[row >> 5], SEEK_SET);\n        getbits(-1);\n        pi = 0;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        chess = (row + col) & 1;\n        pi1 = chess ? pi - 2 : pi - raw_width - 1;\n        pi2 = chess ? pi - 2 * raw_width : pi - raw_width + 1;\n        if (col <= chess)\n          pi1 = -1;\n        if (pi1 < 0)\n          pi1 = pi2;\n        if (pi2 < 0)\n          pi2 = pi1;\n        if (pi1 < 0 && col > 1)\n          pi1 = pi2 = pi - 2;\n        pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n        pixel[pi] = val = pred + ljpeg_diff(huff[chess]);\n        if (val >> 8)\n          derror();\n        val = curve[pixel[pi++]];\n        RAW(row, col) = val;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  FORC(2) free(huff[c]);\n}\n\nint CLASS kodak_65000_decode(short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf = 0;\n  int save, bits = 0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i = 0; i < bsize; i += 2)\n  {\n    c = fgetc(ifp);\n    if ((blen[i] = c & 15) > 12 || (blen[i + 1] = c >> 4) > 12)\n    {\n      fseek(ifp, save, SEEK_SET);\n      for (i = 0; i < bsize; i += 8)\n      {\n        read_shorts(raw, 6);\n        out[i] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n        out[i + 1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n        for (j = 0; j < 6; j++)\n          out[i + 2 + j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4)\n  {\n    bitbuf = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i = 0; i < bsize; i++)\n  {\n    len = blen[i];\n    if (bits < len)\n    {\n      for (j = 0; j < 32; j += 8)\n        bitbuf += (INT64)fgetc(ifp) << (bits + (j ^ 8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16 - len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len - 1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[272]; /* 264 looks enough */\n  int row, col, len, pred[2], ret, i;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      pred[0] = pred[1] = 0;\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len);\n      for (i = 0; i < len; i++)\n      {\n        int idx = ret ? buf[i] : (pred[i & 1] += buf[i]);\n        if (idx >= 0 && idx < 0xffff)\n        {\n          if ((RAW(row, col + i) = curve[idx]) >> 12)\n            derror();\n        }\n        else\n          derror();\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt(unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start)\n  {\n    for (p = 0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;\n    for (p = 4; p < 127; p++)\n      pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;\n    for (p = 0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n  {\n    *data++ ^= pad[p & 127] = pad[(p + 1) & 127] ^ pad[(p + 65) & 127];\n    p++;\n  }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek(ifp, 200896, SEEK_SET);\n  fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek(ifp, 164600, SEEK_SET);\n  fread(head, 1, 40, ifp);\n  sony_decrypt((unsigned *)head, 10, 1, key);\n  for (i = 26; i-- > 22;)\n    key = key << 8 | head[i];\n  fseek(ifp, data_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row * raw_width;\n    if (fread(pixel, 2, raw_width, ifp) < raw_width)\n      derror();\n    sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);\n    for (col = 0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14)\n        derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809,\n                                 0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};\n  int i, c, n, col, row, sum = 0;\n\n  huff[0] = 15;\n  for (n = i = 0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--;)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row = 0; row < raw_height + 1; row += 2)\n    {\n      if (row == raw_height)\n        row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12)\n        derror();\n      if (row < height)\n        RAW(row, col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *)malloc(raw_width + 1);\n  merror(data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fread(data, 1, raw_width, ifp);\n      for (dp = data, col = 0; col < raw_width - 30; dp += 16)\n      {\n        max = 0x7ff & (val = sget4(dp));\n        min = 0x7ff & val >> 11;\n        imax = 0x0f & val >> 22;\n        imin = 0x0f & val >> 26;\n        for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)\n          ;\n#ifdef LIBRAW_LIBRARY_BUILD\n        /* flag checks if outside of loop */\n        if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n            || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n              pix[i] = 0;\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit = 30, i = 0; i < 16; i++)\n        if (i == imax)\n          pix[i] = max;\n        else if (i == imin)\n          pix[i] = min;\n        else\n        {\n          pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n          if (pix[i] > 0x7ff)\n            pix[i] = 0x7ff;\n          bit += 7;\n        }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i = 0; i < 16; i++, col += 2)\n          {\n            unsigned slope = pix[i] < 1001 ? 2 : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];\n            unsigned step = 1 << sh;\n            RAW(row, col) = curve[pix[i] << 1] > black + imgdata.params.sony_arw2_posterization_thr\n                                ? LIM(((slope * step * 1000) / (curve[pix[i] << 1] - black)), 0, 10000)\n                                : 0;\n          }\n        }\n        else\n        {\n          for (i = 0; i < 16; i++, col += 2)\n            RAW(row, col) = curve[pix[i] << 1];\n        }\n#else\n      for (i = 0; i < 16; i++, col += 2)\n        RAW(row, col) = curve[pix[i] << 1] >> 2;\n#endif\n        col -= col & 1 ? 1 : 31;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum = 10000;\n#endif\n  free(data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(raw_width> 32768 || raw_height > 32768)  // definitely too much for old samsung\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n#endif\n  unsigned maxpixels = raw_width*(raw_height+7);\n\n  order = 0x4949;\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, strip_offset + row * 4, SEEK_SET);\n    fseek(ifp, data_offset + get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7 : 4;\n    for (col = 0; col < raw_width; col += 16)\n    {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c])\n      {\n      case 3:\n        len[c] = ph1_bits(4);\n        break;\n      case 2:\n        len[c]--;\n        break;\n      case 1:\n        len[c]++;\n      }\n      for (c = 0; c < 16; c += 2)\n      {\n        i = len[((c & 1) << 1) | (c >> 3)];\n\tunsigned idest = RAWINDEX(row, col + c);\n\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n\tif(idest < maxpixels && isrc < maxpixels) // less than zero is handled by unsigned conversion\n  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n\telse\n  \t  derror();\n        if (c == 14)\n          c = -1;\n      }\n    }\n  }\n  for (row = 0; row < raw_height - 1; row += 2)\n    for (col = 0; col < raw_width - 1; col += 2)\n      SWAP(RAW(row, col + 1), RAW(row + 1, col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403, 0x600, 0x709,\n                                 0x80a, 0x90b, 0xa0c, 0xa0d, 0x501, 0x408, 0x402};\n  ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n = i = 0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek(ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(), get2());\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0;\n    pmode = 7;\n    FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;\n    prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green\n    prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue\n    for (tab = 0; tab + 15 < raw_width; tab += 16)\n    {\n      if (~opt & 4 && !(tab & 63))\n      {\n        i = ph1_bits(2);\n        mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n        pmode = 7 - 4 * ph1_bits(1);\n      else if (!ph1_bits(1))\n        pmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1))\n      {\n        FORC4 len[c] = ph1_bits(2);\n        FORC4\n        {\n          i = ((row & 1) << 1 | (c & 1)) % 3;\n          len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);\n          lent[i][0] = lent[i][1];\n          lent[i][1] = len[c];\n        }\n      }\n      FORC(16)\n      {\n        col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));\n        pred =\n            (pmode == 7 || row < 2)\n                ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)\n                : (prow[col & 1][col - '4' + \"0224468\"[pmode]] + prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >> 1;\n        diff = ph1_bits(i = len[c >> 2]);\n        if (diff >> (i - 1))\n          diff -= 1 << i;\n        diff = diff * (mag * 2 + 1) + mag;\n        RAW(row, col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row)-raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment(unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {{7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {3, 3, 0, 0, 63, 47, 31, 15, 0}};\n  int low, high = 0xff, carry = 0, nbits = 8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[] = {0, 0};\n  ushort data = 0, range = 0;\n\n  fseek(ifp, seg[0][1] + 1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width * raw_height)\n    seg[1][0] = raw_width * raw_height;\n  for (pix = seg[0][0]; pix < seg[1][0]; pix++)\n  {\n    for (s = 0; s < 3; s++)\n    {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n        carry = (nbits += carry + 1) < 1 ? nbits - 1 : 0;\n      while (--nbits >= 0)\n        if ((data >> nbits & 0xff) == 0xff)\n          break;\n      if (nbits > 0)\n        data = ((data & ((1 << (nbits - 1)) - 1)) << 1) |\n               ((data + (((data & (1 << (nbits - 1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0)\n      {\n        data += getbits(1);\n        carry = nbits - 8;\n      }\n      count = ((((data - range + 1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin = 0; hist[s][bin + 5] > count; bin++)\n        ;\n      low = hist[s][bin + 5] * (high >> 4) >> 2;\n      if (bin)\n        high = hist[s][bin + 4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits = 0; high << nbits < 128; nbits++)\n        ;\n      range = (range + low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3])\n      {\n        next = (next + 1) & hist[s][0];\n        hist[s][3] = (hist[s][next + 4] - hist[s][next + 5]) >> 2;\n        hist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1] + 4] - hist[s][hist[s][1] + 5] > 1)\n      {\n        if (bin < hist[s][1])\n          for (i = bin; i < hist[s][1]; i++)\n            hist[s][i + 5]--;\n        else if (next <= bin)\n          for (i = hist[s][1]; i < bin; i++)\n            hist[s][i + 5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (pix >= raw_width * raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width))\n      pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek(ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment(seg, 0);\n}\n\nint CLASS median4(int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i = 1; i < 4; i++)\n  {\n    sum += p[i];\n    if (min > p[i])\n      min = p[i];\n    if (max < p[i])\n      max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes(int holes)\n{\n  int row, col, val[4];\n\n  for (row = 2; row < height - 2; row++)\n  {\n    if (!HOLE(row))\n      continue;\n    for (col = 1; col < width - 1; col += 4)\n    {\n      val[0] = RAW(row - 1, col - 1);\n      val[1] = RAW(row - 1, col + 1);\n      val[2] = RAW(row + 1, col - 1);\n      val[3] = RAW(row + 1, col + 1);\n      RAW(row, col) = median4(val);\n    }\n    for (col = 2; col < width - 2; col += 4)\n      if (HOLE(row - 2) || HOLE(row + 2))\n        RAW(row, col) = (RAW(row, col - 2) + RAW(row, col + 2)) >> 1;\n      else\n      {\n        val[0] = RAW(row, col - 2);\n        val[1] = RAW(row, col + 2);\n        val[2] = RAW(row - 2, col);\n        val[3] = RAW(row + 2, col);\n        RAW(row, col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek(ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar)fgetc(ifp);\n  fseek(ifp, offset, SEEK_SET);\n  for (i = 0; i < nseg * 2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset * (i & 1);\n  fseek(ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek(ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i = 0; i < nseg; i++)\n    smal_decode_segment(seg + i, holes);\n  if (holes)\n    fill_holes(holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen(ifname, \"rb\");\n#else\n  in = (jas_stream_t *)ifp->make_jas_stream();\n  if (!in)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek(in, data_offset + 20, SEEK_SET);\n  jimg = jas_image_decode(in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg)\n    longjmp(failure, 3);\n#else\n  if (!jimg)\n  {\n    jas_stream_close(in);\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  }\n#endif\n  jmat = jas_matrix_create(height / 2, width / 2);\n  merror(jmat, \"redcine_load_raw()\");\n  img = (ushort *)calloc((height + 2), (width + 2) * 2);\n  merror(img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try\n  {\n#endif\n    FORC4\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);\n      data = jas_matrix_getref(jmat, 0, 0);\n      for (row = c >> 1; row < height; row += 2)\n        for (col = c & 1; col < width; col += 2)\n          img[(row + 1) * (width + 2) + col + 1] = data[(row / 2) * (width / 2) + col / 2];\n    }\n    for (col = 1; col <= width; col++)\n    {\n      img[col] = img[2 * (width + 2) + col];\n      img[(height + 1) * (width + 2) + col] = img[(height - 1) * (width + 2) + col];\n    }\n    for (row = 0; row < height + 2; row++)\n    {\n      img[row * (width + 2)] = img[row * (width + 2) + 2];\n      img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];\n    }\n    for (row = 1; row <= height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));\n      for (; col <= width; col += 2, pix += 2)\n      {\n        c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] + pix[-1] + pix[1]) >> 2;\n        pix[0] = LIM(c, 0, 4095);\n      }\n    }\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n        RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    fastexitflag = true;\n  }\n#endif\n  free(img);\n  jas_matrix_destroy(jmat);\n  jas_image_destroy(jimg);\n  jas_stream_close(in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n      r,\n      raw_pitch = raw_width * 2, c, m, mblack[8], zero, val;\n#else\n      c,\n      m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw || load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width)\n  {\n    for (row = 0; row < raw_height - top_margin * 2; row++)\n    {\n      for (col = 0; col < fuji_width << !fuji_layout; col++)\n      {\n        if (fuji_layout)\n        {\n          r = fuji_width - 1 - col + (row >> 1);\n          c = col + ((row + 1) >> 1);\n        }\n        else\n        {\n          r = fuji_width - 1 + row - (col >> 1);\n          c = row + ((col + 1) >> 1);\n        }\n        if (r < height && c < width)\n          BAYER(r, c) = RAW(row + top_margin, col + left_margin);\n      }\n    }\n  }\n  else\n  {\n    for (row = 0; row < height; row++)\n      for (col = 0; col < width; col++)\n        BAYER2(row, col) = RAW(row + top_margin, col + left_margin);\n  }\n#endif\n  if (mask[0][3] > 0)\n    goto mask_set;\n  if (load_raw == &CLASS canon_load_raw || load_raw == &CLASS lossless_jpeg_load_raw)\n  {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw || load_raw == &CLASS sony_load_raw ||\n      (load_raw == &CLASS eight_bit_load_raw && strncmp(model, \"DC2\", 3)) || load_raw == &CLASS kodak_262_load_raw ||\n      (load_raw == &CLASS packed_load_raw && (load_flags & 32)))\n  {\n  sides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin + height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin + width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset(mblack, 0, sizeof mblack);\n  for (zero = m = 0; m < 8; m++)\n    for (row = MAX(mask[m][0], 0); row < MIN(mask[m][2], raw_height); row++)\n      for (col = MAX(mask[m][1], 0); col < MIN(mask[m][3], raw_width); col++)\n      {\n        c = FC(row - top_margin, col - left_margin);\n        mblack[c] += val = raw_image[(row)*raw_pitch / 2 + (col)];\n        mblack[4 + c]++;\n        zero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width)\n  {\n    black = (mblack[0] + mblack[1] + mblack[2] + mblack[3]) / (mblack[4] + mblack[5] + mblack[6] + mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  }\n  else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n  {\n    FORC4 cblack[c] = mblack[c] / mblack[4 + c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 0, 2);\n#endif\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      if (BAYER(row, col) == 0)\n      {\n        tot = n = 0;\n        for (r = row - 2; r <= row + 2; r++)\n          for (c = col - 2; c <= col + 2; c++)\n            if (r < height && c < width && FC(r, c) == FC(row, col) && BAYER(r, c))\n              tot += (n++, BAYER(r, c));\n        if (n)\n          BAYER(row, col) = tot / n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 1, 2);\n#endif\n}\n\nstatic const uchar xlat[2][256] = {\n    {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3,\n     0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d,\n     0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f, 0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b,\n     0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b,\n     0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95,\n     0x17, 0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b,\n     0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65, 0x1d,\n     0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b, 0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43,\n     0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f,\n     0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad,\n     0xe9, 0x2f, 0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35, 0xa3,\n     0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,\n     0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5, 0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07,\n     0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7},\n    {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9,\n     0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68,\n     0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad, 0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95,\n     0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68,\n     0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42,\n     0x9d, 0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca,\n     0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8, 0x87,\n     0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc, 0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45,\n     0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94,\n     0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26,\n     0xbb, 0xd6, 0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c, 0xbe,\n     0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,\n     0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb, 0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65,\n     0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f}};\n\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2] = {0, 0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1] - 1) * (g[0] - 1) <= 0)\n  {\n    for (i = 0; i < 48; i++)\n    {\n      g[2] = (bnd[0] + bnd[1]) / 2;\n      if (g[0])\n        bnd[(pow(g[2] / g[1], -g[0]) - 1) / g[0] - 1 / g[2] > -1] = g[2];\n      else\n        bnd[g[2] / exp(1 - 1 / g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0])\n      g[4] = g[2] * (1 / g[0] - 1);\n  }\n  if (g[0])\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 - g[4] * (1 - g[3]) + (1 - pow(g[3], 1 + g[0])) * (1 + g[4]) / (1 + g[0])) - 1;\n  else\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 + 1 - g[2] - g[3] - g[2] * g[3] * (log(g[3]) - 1)) - 1;\n  if (!mode--)\n  {\n    memcpy(gamm, g, sizeof gamm);\n    return;\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    curve[i] = 0xffff;\n    if ((r = (double)i / imax) < 1)\n      curve[i] = 0x10000 *\n                 (mode ? (r < g[3] ? r * g[1] : (g[0] ? pow(r, g[0]) * (1 + g[4]) - g[4] : log(r) * g[2] + 1))\n                       : (r < g[2] ? r / g[1] : (g[0] ? pow((r + g[4]) / (1 + g[4]), 1 / g[0]) : exp((r - 1) / g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse(double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n  {\n    for (j = 0; j < 6; j++)\n      work[i][j] = j == i + 3;\n    for (j = 0; j < 3; j++)\n      for (k = 0; k < size; k++)\n        work[i][j] += in[k][i] * in[k][j];\n  }\n  for (i = 0; i < 3; i++)\n  {\n    num = work[i][i];\n    for (j = 0; j < 6; j++)\n      if(fabs(num)>0.00001f)\n      \twork[i][j] /= num;\n    for (k = 0; k < 3; k++)\n    {\n      if (k == i)\n        continue;\n      num = work[k][i];\n      for (j = 0; j < 6; j++)\n        work[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i = 0; i < size; i++)\n    for (j = 0; j < 3; j++)\n      for (out[i][j] = k = 0; k < 3; k++)\n        out[i][j] += work[j][k + 3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i = 0; i < colors; i++) /* Multiply out XYZ colorspace */\n    for (j = 0; j < 3; j++)\n      for (cam_rgb[i][j] = k = 0; k < 3; k++)\n        cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i = 0; i < colors; i++)\n  {                               /* Normalize cam_rgb so that */\n    for (num = j = 0; j < 3; j++) /* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if (num > 0.00001)\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] /= num;\n      pre_mul[i] = 1 / num;\n    }\n    else\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] = 0.0;\n      pre_mul[i] = 1.0;\n    }\n  }\n  pseudoinverse(cam_rgb, inverse, colors);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n  // Coordinates of the GretagMacbeth ColorChecker squares\n  // width, height, 1st_column, 1st_row\n  int cut[NSQ][4];                                             // you must set these\n                                                               // ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {{0.400, 0.350, 10.1}, // Dark Skin\n                                         {0.377, 0.345, 35.8}, // Light Skin\n                                         {0.247, 0.251, 19.3}, // Blue Sky\n                                         {0.337, 0.422, 13.3}, // Foliage\n                                         {0.265, 0.240, 24.3}, // Blue Flower\n                                         {0.261, 0.343, 43.1}, // Bluish Green\n                                         {0.506, 0.407, 30.1}, // Orange\n                                         {0.211, 0.175, 12.0}, // Purplish Blue\n                                         {0.453, 0.306, 19.8}, // Moderate Red\n                                         {0.285, 0.202, 6.6},  // Purple\n                                         {0.380, 0.489, 44.3}, // Yellow Green\n                                         {0.473, 0.438, 43.1}, // Orange Yellow\n                                         {0.187, 0.129, 6.1},  // Blue\n                                         {0.305, 0.478, 23.4}, // Green\n                                         {0.539, 0.313, 12.0}, // Red\n                                         {0.448, 0.470, 59.1}, // Yellow\n                                         {0.364, 0.233, 19.8}, // Magenta\n                                         {0.196, 0.252, 19.8}, // Cyan\n                                         {0.310, 0.316, 90.0}, // White\n                                         {0.310, 0.316, 59.1}, // Neutral 8\n                                         {0.310, 0.316, 36.2}, // Neutral 6.5\n                                         {0.310, 0.316, 19.8}, // Neutral 5\n                                         {0.310, 0.316, 9.0},  // Neutral 3.5\n                                         {0.310, 0.316, 3.1}}; // Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset(gmb_cam, 0, sizeof gmb_cam);\n  for (sq = 0; sq < NSQ; sq++)\n  {\n    FORCC count[c] = 0;\n    for (row = cut[sq][3]; row < cut[sq][3] + cut[sq][1]; row++)\n      for (col = cut[sq][2]; col < cut[sq][2] + cut[sq][0]; col++)\n      {\n        c = FC(row, col);\n        if (c >= colors)\n          c -= 2;\n        gmb_cam[sq][c] += BAYER2(row, col);\n        BAYER2(row, col) = black + (BAYER2(row, col) - black) / 2;\n        count[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c] / count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] * (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse(gmb_xyz, inverse, NSQ);\n  for (pass = 0; pass < 2; pass++)\n  {\n    for (raw_color = i = 0; i < colors; i++)\n      for (j = 0; j < 3; j++)\n        for (cam_xyz[i][j] = k = 0; k < NSQ; k++)\n          cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff(rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq = 0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose)\n  {\n    printf(\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j = 0; j < 3; j++) printf(\"%c%d\", (c | j) ? ',' : ' ', (int)(cam_xyz[c][j] * num + 0.5));\n    puts(\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform(float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i = 0; i < sc; i++)\n    temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];\n  for (; i + sc < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];\n  for (; i < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (2 * size - 2 - (i + sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n  FORC(nc)\n  { /* denoise R,G1,B,G3 individually */\n    for (i = 0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass = lev = 0; lev < 5; lev++)\n    {\n      lpass = size * ((lev & 1) + 1);\n      for (row = 0; row < iheight; row++)\n      {\n        hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n        for (col = 0; col < iwidth; col++)\n          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n      }\n      for (col = 0; col < iwidth; col++)\n      {\n        hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n        for (row = 0; row < iheight; row++)\n          fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i = 0; i < size; i++)\n      {\n        fimg[hpass + i] -= fimg[lpass + i];\n        if (fimg[hpass + i] < -thold)\n          fimg[hpass + i] += thold;\n        else if (fimg[hpass + i] > thold)\n          fimg[hpass + i] -= thold;\n        else\n          fimg[hpass + i] = 0;\n        if (hpass)\n          fimg[i] += fimg[hpass + i];\n      }\n      hpass = lpass;\n    }\n    for (i = 0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n  }\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i, col, row, thold, lev, lpass, hpass, temp, c) firstprivate(scale, size)\n#endif\n  {\n    temp = (float *)malloc((iheight + iwidth) * sizeof *fimg);\n    FORC(nc)\n    { /* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass = lev = 0; lev < 5; lev++)\n      {\n        lpass = size * ((lev & 1) + 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (row = 0; row < iheight; row++)\n        {\n          hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n          for (col = 0; col < iwidth; col++)\n            fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n        }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (col = 0; col < iwidth; col++)\n        {\n          hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n          for (row = 0; row < iheight; row++)\n            fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n        }\n        thold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (i = 0; i < size; i++)\n        {\n          fimg[hpass + i] -= fimg[lpass + i];\n          if (fimg[hpass + i] < -thold)\n            fimg[hpass + i] += thold;\n          else if (fimg[hpass + i] > thold)\n            fimg[hpass + i] -= thold;\n          else\n            fimg[hpass + i] = 0;\n          if (hpass)\n            fimg[i] += fimg[hpass + i];\n        }\n        hpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n  /* the following loops are hard to parallize, no idea yes,\n   * problem is wlast which is carrying dependency\n   * second part should be easyer, but did not yet get it right.\n   */\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i, j;\n  double m1, m2, c1, c2;\n  int o1_1, o1_2, o1_3, o1_4;\n  int o2_1, o2_2, o2_3, o2_4;\n  ushort(*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if (half_size || shrink)\n    return;\n  if (FC(oj, oi) != 3)\n    oj++;\n  if (FC(oj, oi) != 3)\n    oi++;\n  if (FC(oj, oi) != 3)\n    oj--;\n\n  img = (ushort(*)[4])calloc(height * width, sizeof *image);\n  merror(img, \"green_matching()\");\n  memcpy(img, image, height * width * sizeof *image);\n\n  for (j = oj; j < height - margin; j += 2)\n    for (i = oi; i < width - margin; i += 2)\n    {\n      o1_1 = img[(j - 1) * width + i - 1][1];\n      o1_2 = img[(j - 1) * width + i + 1][1];\n      o1_3 = img[(j + 1) * width + i - 1][1];\n      o1_4 = img[(j + 1) * width + i + 1][1];\n      o2_1 = img[(j - 2) * width + i][3];\n      o2_2 = img[(j + 2) * width + i][3];\n      o2_3 = img[j * width + i - 2][3];\n      o2_4 = img[j * width + i + 2][3];\n\n      m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0;\n      m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0;\n\n      c1 = (abs(o1_1 - o1_2) + abs(o1_1 - o1_3) + abs(o1_1 - o1_4) + abs(o1_2 - o1_3) + abs(o1_3 - o1_4) +\n            abs(o1_2 - o1_4)) /\n           6.0;\n      c2 = (abs(o2_1 - o2_2) + abs(o2_1 - o2_3) + abs(o2_1 - o2_4) + abs(o2_2 - o2_3) + abs(o2_3 - o2_4) +\n            abs(o2_2 - o2_4)) /\n           6.0;\n      if ((img[j * width + i][3] < maximum * 0.95) && (c1 < maximum * thr) && (c2 < maximum * thr))\n      {\n        f = image[j * width + i][3] * m1 / m2;\n        image[j * width + i][3] = f > 0xffff ? 0xffff : f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img = 0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 0, 2);\n#endif\n\n  if (user_mul[0])\n    memcpy(pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1))\n  {\n    memset(dsum, 0, sizeof dsum);\n    bottom = MIN(greybox[1] + greybox[3], height);\n    right = MIN(greybox[0] + greybox[2], width);\n    for (row = greybox[1]; row < bottom; row += 8)\n      for (col = greybox[0]; col < right; col += 8)\n      {\n        memset(sum, 0, sizeof sum);\n        for (y = row; y < row + 8 && y < bottom; y++)\n          for (x = col; x < col + 8 && x < right; x++)\n            FORC4\n            {\n              if (filters)\n              {\n                c = fcol(y, x);\n                val = BAYER2(y, x);\n              }\n              else\n                val = image[y * width + x][c];\n              if (val > maximum - 25)\n                goto skip_block;\n              if ((val -= cblack[c]) < 0)\n                val = 0;\n              sum[c] += val;\n              sum[c + 4]++;\n              if (filters)\n                break;\n            }\n        FORC(8) dsum[c] += sum[c];\n      skip_block:;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c + 4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1)\n  {\n    memset(sum, 0, sizeof sum);\n    for (row = 0; row < 8; row++)\n      for (col = 0; col < 8; col++)\n      {\n        c = FC(row, col);\n        if ((val = white[row][col] - cblack[c]) > 0)\n          sum[c] += val;\n        sum[c + 4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (load_raw == &LibRaw::nikon_load_sraw)\n    {\n      // Nikon sRAW: camera WB already applied:\n      pre_mul[0] = pre_mul[1] = pre_mul[2] = pre_mul[3] = 1.0;\n    }\n    else\n#endif\n        if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float)sum[c + 4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy(pre_mul, cam_mul, sizeof pre_mul);\n    else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n      fprintf(stderr, _(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && !use_auto_wb && cam_mul[0] > 0.001f &&\n      cam_mul[1] > 0.001f && cam_mul[2] > 0.001f)\n  {\n    for (c = 0; c < 3; c++)\n      pre_mul[c] /= cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0)\n    pre_mul[1] = 1;\n  if (pre_mul[3] == 0)\n    pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold)\n    wavelet_denoise();\n  maximum -= black;\n  for (dmin = DBL_MAX, dmax = c = 0; c < 4; c++)\n  {\n    if (dmin > pre_mul[c])\n      dmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n      dmax = pre_mul[c];\n  }\n  if (!highlight)\n    dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n  {\n    fprintf(stderr, _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf(stderr, \" %f\", pre_mul[c]);\n    fputc('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4] + 1) / 2 == 1 && (cblack[5] + 1) / 2 == 1)\n  {\n    FORC4 cblack[FC(c / 2, c % 2)] += cblack[6 + c / 2 % cblack[4] * cblack[5] + c % 2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight * iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i = 0; i < size * 4; i++)\n  {\n    if (!(val = ((ushort *)image)[i]))\n      continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i / 4 / iwidth % cblack[4] * cblack[5] + i / 4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3)\n  {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c = 0; c < 4; c += 2)\n    {\n      if (aber[c] == 1)\n        continue;\n      img = (ushort *)malloc(size * sizeof *img);\n      merror(img, \"scale_colors()\");\n      for (i = 0; i < size; i++)\n        img[i] = image[i][c];\n      for (row = 0; row < iheight; row++)\n      {\n        ur = fr = (row - iheight * 0.5) * aber[c] + iheight * 0.5;\n        if (ur > iheight - 2)\n          continue;\n        fr -= ur;\n        for (col = 0; col < iwidth; col++)\n        {\n          uc = fc = (col - iwidth * 0.5) * aber[c] + iwidth * 0.5;\n          if (uc > iwidth - 2)\n            continue;\n          fc -= uc;\n          pix = img + ur * iwidth + uc;\n          image[row * iwidth + col][c] =\n              (pix[0] * (1 - fc) + pix[1] * fc) * (1 - fr) + (pix[iwidth] * (1 - fc) + pix[iwidth + 1] * fc) * fr;\n        }\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 1, 2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort(*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 0, 2);\n#endif\n  if (shrink)\n  {\n    if (half_size)\n    {\n      height = iheight;\n      width = iwidth;\n      if (filters == 9)\n      {\n        for (row = 0; row < 3; row++)\n          for (col = 1; col < 4; col++)\n            if (!(image[row * width + col][0] | image[row * width + col][2]))\n              goto break2;\n      break2:\n        for (; row < height; row += 3)\n          for (col = (col - 1) % 3 + 1; col < width - 1; col += 3)\n          {\n            img = image + row * width + col;\n            for (c = 0; c < 3; c += 2)\n              img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n          }\n      }\n    }\n    else\n    {\n      img = (ushort(*)[4])calloc(height, width * sizeof *img);\n      merror(img, \"pre_interpolate()\");\n      for (row = 0; row < height; row++)\n        for (col = 0; col < width; col++)\n        {\n          c = fcol(row, col);\n          img[row * width + col][c] = image[(row >> 1) * iwidth + (col >> 1)][c];\n        }\n      free(image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3)\n  {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size)\n      colors++;\n    else\n    {\n      for (row = FC(1, 0) >> 1; row < height; row += 2)\n        for (col = FC(row, 1) & 1; col < width; col += 2)\n          image[row * width + col][1] = image[row * width + col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size)\n    filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 1, 2);\n#endif\n}\n\nvoid CLASS border_interpolate(int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      if (col == border && row >= border && row < height - border)\n        col = width - border;\n      memset(sum, 0, sizeof sum);\n      for (y = row - 1; y != row + 2; y++)\n        for (x = col - 1; x != col + 2; x++)\n          if (y < height && x < width)\n          {\n            f = fcol(y, x);\n            sum[f] += image[y * width + x][f];\n            sum[f + 4]++;\n          }\n      f = fcol(row, col);\n      FORCC if (c != f && sum[c + 4]) image[row * width + col][c] = sum[c] / sum[c + 4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32], int size)\n{\n  int row;\n  for (row = 1; row < height - 1; row++)\n  {\n    int col, *ip;\n    ushort *pix;\n    for (col = 1; col < width - 1; col++)\n    {\n      int i;\n      int sum[4];\n      pix = image[row * width + col];\n      ip = code[row % size][col % size];\n      memset(sum, 0, sizeof sum);\n      for (i = *ip++; i--; ip += 3)\n        sum[ip[2]] += pix[ip[0]] << ip[1];\n      for (i = colors; --i; ip += 2)\n        pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n    }\n  }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size = 16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#endif\n\n  if (filters == 9)\n    size = 6;\n  border_interpolate(1);\n  for (row = 0; row < size; row++)\n    for (col = 0; col < size; col++)\n    {\n      ip = code[row][col] + 1;\n      f = fcol(row, col);\n      memset(sum, 0, sizeof sum);\n      for (y = -1; y <= 1; y++)\n        for (x = -1; x <= 1; x++)\n        {\n          shift = (y == 0) + (x == 0);\n          color = fcol(row + y, col + x);\n          if (color == f)\n            continue;\n          *ip++ = (width * y + x) * 4 + color;\n          *ip++ = shift;\n          *ip++ = color;\n          sum[color] += 1 << shift;\n        }\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n      if (c != f)\n      {\n        *ip++ = c;\n        *ip++ = sum[c] > 0 ? 256 / sum[c] : 0;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#endif\n  lin_interpolate_loop(code, size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp,\n      terms[] = {-2, -2, +0, -1, 0, 0x01, -2, -2, +0, +0, 1, 0x01, -2, -1, -1, +0, 0, 0x01, -2, -1, +0, -1, 0, 0x02,\n                 -2, -1, +0, +0, 0, 0x03, -2, -1, +0, +1, 1, 0x01, -2, +0, +0, -1, 0, 0x06, -2, +0, +0, +0, 1, 0x02,\n                 -2, +0, +0, +1, 0, 0x03, -2, +1, -1, +0, 0, 0x04, -2, +1, +0, -1, 1, 0x04, -2, +1, +0, +0, 0, 0x06,\n                 -2, +1, +0, +1, 0, 0x02, -2, +2, +0, +0, 1, 0x04, -2, +2, +0, +1, 0, 0x04, -1, -2, -1, +0, 0, -128,\n                 -1, -2, +0, -1, 0, 0x01, -1, -2, +1, -1, 0, 0x01, -1, -2, +1, +0, 1, 0x01, -1, -1, -1, +1, 0, -120,\n                 -1, -1, +1, -2, 0, 0x40, -1, -1, +1, -1, 0, 0x22, -1, -1, +1, +0, 0, 0x33, -1, -1, +1, +1, 1, 0x11,\n                 -1, +0, -1, +2, 0, 0x08, -1, +0, +0, -1, 0, 0x44, -1, +0, +0, +1, 0, 0x11, -1, +0, +1, -2, 1, 0x40,\n                 -1, +0, +1, -1, 0, 0x66, -1, +0, +1, +0, 1, 0x22, -1, +0, +1, +1, 0, 0x33, -1, +0, +1, +2, 1, 0x10,\n                 -1, +1, +1, -1, 1, 0x44, -1, +1, +1, +0, 0, 0x66, -1, +1, +1, +1, 0, 0x22, -1, +1, +1, +2, 0, 0x10,\n                 -1, +2, +0, +1, 0, 0x04, -1, +2, +1, +0, 1, 0x04, -1, +2, +1, +1, 0, 0x04, +0, -2, +0, +0, 1, -128,\n                 +0, -1, +0, +1, 1, -120, +0, -1, +1, -2, 0, 0x40, +0, -1, +1, +0, 0, 0x11, +0, -1, +2, -2, 0, 0x40,\n                 +0, -1, +2, -1, 0, 0x20, +0, -1, +2, +0, 0, 0x30, +0, -1, +2, +1, 1, 0x10, +0, +0, +0, +2, 1, 0x08,\n                 +0, +0, +2, -2, 1, 0x40, +0, +0, +2, -1, 0, 0x60, +0, +0, +2, +0, 1, 0x20, +0, +0, +2, +1, 0, 0x30,\n                 +0, +0, +2, +2, 1, 0x10, +0, +1, +1, +0, 0, 0x44, +0, +1, +1, +2, 0, 0x10, +0, +1, +2, -1, 1, 0x40,\n                 +0, +1, +2, +0, 0, 0x60, +0, +1, +2, +1, 0, 0x20, +0, +1, +2, +2, 0, 0x10, +1, -2, +1, +0, 0, -128,\n                 +1, -1, +1, +1, 0, -120, +1, +0, +1, +2, 0, 0x08, +1, +0, +2, -1, 0, 0x40, +1, +0, +2, +1, 0, 0x10},\n      chood[] = {-1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1};\n  ushort(*brow[5])[4], *pix;\n  int prow = 8, pcol = 2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1)\n    prow = pcol = 16;\n  if (filters == 9)\n    prow = pcol = 6;\n  ip = (int *)calloc(prow * pcol, 1280);\n  merror(ip, \"vng_interpolate()\");\n  for (row = 0; row < prow; row++) /* Precalculate for VNG */\n    for (col = 0; col < pcol; col++)\n    {\n      code[row][col] = ip;\n      for (cp = terms, t = 0; t < 64; t++)\n      {\n        y1 = *cp++;\n        x1 = *cp++;\n        y2 = *cp++;\n        x2 = *cp++;\n        weight = *cp++;\n        grads = *cp++;\n        color = fcol(row + y1, col + x1);\n        if (fcol(row + y2, col + x2) != color)\n          continue;\n        diag = (fcol(row, col + 1) == color && fcol(row + 1, col) == color) ? 2 : 1;\n        if (abs(y1 - y2) == diag && abs(x1 - x2) == diag)\n          continue;\n        *ip++ = (y1 * width + x1) * 4 + color;\n        *ip++ = (y2 * width + x2) * 4 + color;\n        *ip++ = weight;\n        for (g = 0; g < 8; g++)\n          if (grads & 1 << g)\n            *ip++ = g;\n        *ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp = chood, g = 0; g < 8; g++)\n      {\n        y = *cp++;\n        x = *cp++;\n        *ip++ = (y * width + x) * 4;\n        color = fcol(row, col);\n        if (fcol(row + y, col + x) != color && fcol(row + y * 2, col + x * 2) == color)\n          *ip++ = (y * width + x) * 8 + color;\n        else\n          *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort(*)[4])calloc(width * 3, sizeof **brow);\n  merror(brow[4], \"vng_interpolate()\");\n  for (row = 0; row < 3; row++)\n    brow[row] = brow[4] + row * width;\n  for (row = 2; row < height - 2; row++)\n  { /* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!((row - 2) % 256))\n      RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, (row - 2) / 256 + 1, ((height - 3) / 256) + 1);\n#endif\n    for (col = 2; col < width - 2; col++)\n    {\n      pix = image[row * width + col];\n      ip = code[row % prow][col % pcol];\n      memset(gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX)\n      { /* Calculate gradients */\n        diff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n        gval[ip[3]] += diff;\n        ip += 5;\n        if ((g = ip[-1]) == -1)\n          continue;\n        gval[g] += diff;\n        while ((g = *ip++) != -1)\n          gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0]; /* Choose a threshold */\n      for (g = 1; g < 8; g++)\n      {\n        if (gmin > gval[g])\n          gmin = gval[g];\n        if (gmax < gval[g])\n          gmax = gval[g];\n      }\n      if (gmax == 0)\n      {\n        memcpy(brow[2][col], pix, sizeof *image);\n        continue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset(sum, 0, sizeof sum);\n      color = fcol(row, col);\n      for (num = g = 0; g < 8; g++, ip += 2)\n      { /* Average the neighbors */\n        if (gval[g] <= thold)\n        {\n          FORCC\n          if (c == color && ip[1])\n            sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n          else\n            sum[c] += pix[ip[0] + c];\n          num++;\n        }\n      }\n      FORCC\n      { /* Save to buffer */\n        t = pix[color];\n        if (c != color)\n          t += (sum[c] - sum[color]) / num;\n        brow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3) /* Write buffer to image */\n      memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n    for (g = 0; g < 4; g++)\n      brow[(g - 1) & 3] = brow[g];\n  }\n  memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n  memcpy(image[(row - 1) * width + 2], brow[1] + 2, (width - 4) * sizeof *image);\n  free(brow[4]);\n  free(code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = {1, width, -1, -width, 1};\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort(*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 3; row < height - 3; row++)\n    for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; i++)\n      {\n        guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 - pix[-2 * d][c] - pix[2 * d][c];\n        diff[i] = (ABS(pix[-2 * d][c] - pix[0][c]) + ABS(pix[2 * d][c] - pix[0][c]) + ABS(pix[-d][1] - pix[d][1])) * 3 +\n                  (ABS(pix[3 * d][1] - pix[d][1]) + ABS(pix[-3 * d][1] - pix[-d][1])) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 2) & 1), c = FC(row, col + 1); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; c = 2 - c, i++)\n        pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 1) & 1), c = 2 - FC(row, col); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i] + dir[i + 1]) > 0; i++)\n      {\n        diff[i] = ABS(pix[-d][c] - pix[d][c]) + ABS(pix[-d][1] - pix[0][1]) + ABS(pix[d][1] - pix[0][1]);\n        guess[i] = pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n        pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n        pix[0][c] = CLIP((guess[0] + guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab(ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb)\n  {\n#ifndef LIBRAW_NOTHREADS\n    if (cbrt[0] < -1.0f)\n#endif\n      for (i = 0; i < 0x10000; i++)\n      {\n        r = i / 65535.0;\n        cbrt[i] = r > 0.008856 ? pow(r, 1.f / 3.0f) : 7.787f * r + 16.f / 116.0f;\n      }\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (xyz_cam[i][j] = k = 0; k < 3; k++)\n          xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC\n  {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int)xyz[0])];\n  xyz[1] = cbrt[CLIP((int)xyz[1])];\n  xyz[2] = cbrt[CLIP((int)xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512 /* Tile Size */\n#define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate(int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int cstat[4] = {0, 0, 0, 0};\n#endif\n\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1}},\n                     dir[4] = {1, TS, TS + 1, TS - 1};\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][3], (*lix)[3];\n  float(*drv)[TS][TS], diff[6], tr;\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (width < TS || height < TS)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT; // too small image\n                                       /* Check against right pattern */\n  for (row = 0; row < 6; row++)\n    for (col = 0; col < 6; col++)\n      cstat[fcol(row, col)]++;\n\n  if (cstat[0] < 6 || cstat[0] > 10 || cstat[1] < 16 || cstat[1] > 24 || cstat[2] < 6 || cstat[2] > 10 || cstat[3])\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // Init allhex table to unreasonable values\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          allhex[i][j][k][l] = 32700;\n#endif\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  int minv = 0, maxv = 0, minh = 0, maxh = 0;\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n            minv = MIN(v, minv);\n            maxv = MAX(v, maxv);\n            minh = MIN(v, minh);\n            maxh = MAX(v, maxh);\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Check allhex table initialization\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          if (allhex[i][j][k][l] > maxh + maxv * width + 1 || allhex[i][j][k][l] < minh + minv * width - 1)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int retrycount = 0;\n#endif\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n        continue;\n      pix = image + row * width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max)\n        FORC(6)\n        {\n          val = pix[hex[c]][1];\n          if (min > val)\n            min = val;\n          if (max < val)\n            max = val;\n        }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row - sgrow) % 3)\n      {\n      case 1:\n        if (row < height - 3)\n        {\n          row++;\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n        {\n          row--;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (retrycount++ > width * height)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        }\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)\n    {\n      mrow = MIN(top + TS, height - 3);\n      mcol = MIN(left + TS, width - 3);\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n          memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n      FORC3 memcpy(rgb[c + 1], rgb[0], sizeof *rgb);\n\n      /* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n        {\n          if ((f = fcol(row, col)) == 1)\n            continue;\n          pix = image + row * width + col;\n          hex = allhex[row % 3][col % 3][0];\n          color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) - 46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n          color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 + 92 * (pix[0][f] - pix[-hex[2]][f]);\n          FORC(2)\n          color[1][2 + c] = 164 * pix[hex[4 + c]][1] + 92 * pix[-2 * hex[4 + c]][1] +\n                            33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);\n          FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] = LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n        }\n\n      for (pass = 0; pass < passes; pass++)\n      {\n        if (pass == 1)\n          memcpy(rgb += 4, buffer, 4 * sizeof *rgb);\n\n        /* Recalculate green from interpolated values of closer pixels:\t*/\n        if (pass)\n        {\n          for (row = top + 2; row < mrow - 2; row++)\n            for (col = left + 2; col < mcol - 2; col++)\n            {\n              if ((f = fcol(row, col)) == 1)\n                continue;\n              pix = image + row * width + col;\n              hex = allhex[row % 3][col % 3][1];\n              for (d = 3; d < 6; d++)\n              {\n                rix = &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                val =\n                    rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] - rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n              }\n            }\n        }\n\n        /* Interpolate red and blue values for solitary green pixels:\t*/\n        for (row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n          for (col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n          {\n            rix = &rgb[0][row - top][col - left];\n            h = fcol(row, col + 1);\n            memset(diff, 0, sizeof diff);\n            for (i = 1, d = 0; d < 6; d++, i ^= TS ^ 1, h ^= 2)\n            {\n              for (c = 0; c < 2; c++, h ^= 2)\n              {\n                g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                if (d > 1)\n                  diff[d] += SQR(rix[i << c][1] - rix[-i << c][1] - rix[i << c][h] + rix[-i << c][h]) + SQR(g);\n              }\n              if (d > 1 && (d & 1))\n                if (diff[d - 1] < diff[d])\n                  FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n              if (d < 2 || (d & 1))\n              {\n                FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                rix += TS * TS;\n              }\n            }\n          }\n\n        /* Interpolate red for blue pixels and vice versa:\t\t*/\n        for (row = top + 3; row < mrow - 3; row++)\n          for (col = left + 3; col < mcol - 3; col++)\n          {\n            if ((f = 2 - fcol(row, col)) == 1)\n              continue;\n            rix = &rgb[0][row - top][col - left];\n            c = (row - sgrow) % 3 ? TS : 1;\n            h = 3 * (c ^ TS ^ 1);\n            for (d = 0; d < 4; d++, rix += TS * TS)\n            {\n              i = d > 1 || ((d ^ c) & 1) ||\n                          ((ABS(rix[0][1] - rix[c][1]) + ABS(rix[0][1] - rix[-c][1])) <\n                           2 * (ABS(rix[0][1] - rix[h][1]) + ABS(rix[0][1] - rix[-h][1])))\n                      ? c\n                      : h;\n              rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] - rix[i][1] - rix[-i][1]) / 2);\n            }\n          }\n\n        /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n        for (row = top + 2; row < mrow - 2; row++)\n          if ((row - sgrow) % 3)\n            for (col = left + 2; col < mcol - 2; col++)\n              if ((col - sgcol) % 3)\n              {\n                rix = &rgb[0][row - top][col - left];\n                hex = allhex[row % 3][col % 3][1];\n                for (d = 0; d < ndir; d += 2, rix += TS * TS)\n                  if (hex[d] + hex[d + 1])\n                  {\n                    g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                  }\n                  else\n                  {\n                    g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                  }\n              }\n      }\n      rgb = (ushort(*)[TS][TS][3])buffer;\n      mrow -= top;\n      mcol -= left;\n\n      /* Convert to CIELab and differentiate in all directions:\t*/\n      for (d = 0; d < ndir; d++)\n      {\n        for (row = 2; row < mrow - 2; row++)\n          for (col = 2; col < mcol - 2; col++)\n            cielab(rgb[d][row][col], lab[row][col]);\n        for (f = dir[d & 3], row = 3; row < mrow - 3; row++)\n          for (col = 3; col < mcol - 3; col++)\n          {\n            lix = &lab[row][col];\n            g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n            drv[d][row][col] = SQR(g) + SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                               SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n          }\n      }\n\n      /* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir * TS * TS);\n      for (row = 4; row < mrow - 4; row++)\n        for (col = 4; col < mcol - 4; col++)\n        {\n          for (tr = FLT_MAX, d = 0; d < ndir; d++)\n            if (tr > drv[d][row][col])\n              tr = drv[d][row][col];\n          tr *= 8;\n          for (d = 0; d < ndir; d++)\n            for (v = -1; v <= 1; v++)\n              for (h = -1; h <= 1; h++)\n                if (drv[d][row + v][col + h] <= tr)\n                  homo[d][row][col]++;\n        }\n\n      /* Average the most homogenous pixels for the final result:\t*/\n      if (height - top < TS + 4)\n        mrow = height - top + 2;\n      if (width - left < TS + 4)\n        mcol = width - left + 2;\n      for (row = MIN(top, 8); row < mrow - 8; row++)\n        for (col = MIN(left, 8); col < mcol - 8; col++)\n        {\n          for (d = 0; d < ndir; d++)\n            for (hm[d] = 0, v = -2; v <= 2; v++)\n              for (h = -2; h <= 2; h++)\n                hm[d] += homo[d][row + v][col + h];\n          for (d = 0; d < ndir - 4; d++)\n            if (hm[d] < hm[d + 4])\n              hm[d] = 0;\n            else if (hm[d] > hm[d + 4])\n              hm[d + 4] = 0;\n          for (max = hm[0], d = 1; d < ndir; d++)\n            if (max < hm[d])\n              max = hm[d];\n          max -= max >> 3;\n          memset(avg, 0, sizeof avg);\n          for (d = 0; d < ndir; d++)\n            if (hm[d] >= max)\n            {\n              FORC3 avg[c] += rgb[d][row][col][c];\n              avg[3]++;\n            }\n          FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n        }\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + TS, height - 2);\n  const int collimit = MIN(left + TS, width - 2);\n\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n      out_rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3],\n                                                                short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort(*pix)[4];\n  ushort(*rix)[3];\n  short(*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4 * width;\n  const unsigned rowlimit = MIN(top + TS - 1, height - 3);\n  const unsigned collimit = MIN(left + TS - 1, width - 3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top + 1; row < rowlimit; row++)\n  {\n    pix = image + row * width + left;\n    rix = &inout_rgb[row - top][0];\n    lix = &out_lab[row - top][0];\n\n    for (col = left + 1; col < collimit; col++)\n    {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1)\n      {\n        c = FC(row + 1, col);\n        t1 = 2 - c;\n        val = pix[0][1] + ((pix[-1][t1] + pix[1][t1] - rix[-1][1] - rix[1][1]) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + ((pix_above[c] + pix_below[c] - rix[-TS][1] - rix[TS][1]) >> 1);\n      }\n      else\n      {\n        t1 = -4 + c; /* -4+c: pixel of color c to the left */\n        t2 = 4 + c;  /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + ((pix_above[t1] + pix_above[t2] + pix_below[t1] + pix_below[t2] - rix[-TS - 1][1] -\n                            rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                           2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row, col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0], lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3],\n                                                         short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++)\n  {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3],\n                                                 char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short(*lix)[3];\n  short(*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = {-1, 1, -TS, TS};\n  const int rowlimit = MIN(top + TS - 2, height - 4);\n  const int collimit = MIN(left + TS - 2, width - 4);\n  int homogeneity;\n  char(*homogeneity_map_p)[2];\n\n  memset(out_homogeneity_map, 0, 2 * TS * TS);\n\n  for (row = top + 2; row < rowlimit; row++)\n  {\n    tr = row - top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction = 0; direction < 2; direction++)\n    {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col = left + 2; col < collimit; col++)\n    {\n      tc = col - left;\n      homogeneity_map_p++;\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        lix = ++lixs[direction];\n        for (i = 0; i < 4; i++)\n        {\n          adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0] - adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1] - adjacent_lix[1]) + SQR(lix[0][2] - adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n      for (direction = 0; direction < 2; direction++)\n      {\n        homogeneity = 0;\n        for (i = 0; i < 4; i++)\n        {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps)\n          {\n            homogeneity++;\n          }\n        }\n        homogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3],\n                                                      char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top + TS - 3, height - 5);\n  const int collimit = MIN(left + TS - 3, width - 5);\n\n  ushort(*pix)[4];\n  ushort(*rix[2])[3];\n\n  for (row = top + 3; row < rowlimit; row++)\n  {\n    tr = row - top;\n    pix = &image[row * width + left + 2];\n    for (direction = 0; direction < 2; direction++)\n    {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col = left + 3; col < collimit; col++)\n    {\n      tc = col - left;\n      pix++;\n      for (direction = 0; direction < 2; direction++)\n      {\n        rix[direction]++;\n      }\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        hm[direction] = 0;\n        for (i = tr - 1; i <= tr + 1; i++)\n        {\n          for (j = tc - 1; j <= tc + 1; j++)\n          {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1])\n      {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      }\n      else\n      {\n        FORC3 { pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1; }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4], r;\n  char *buffer;\n  ushort(*rgb)[TS][TS][3];\n  short(*lab)[TS][TS][3];\n  char(*homo)[TS][2];\n  int terminate_flag = 0;\n\n  cielab(0, 0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer, rgb, lab, homo, top, left, i, j, k) shared(xyz_cam, terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *)malloc(26 * TS * TS); /* 1664 kB */\n    merror(buffer, \"ahd_interpolate()\");\n    rgb = (ushort(*)[TS][TS][3])buffer;\n    lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n    homo = (char(*)[TS][2])(buffer + 24 * TS * TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top = 2; top < height - 5; top += TS - 6)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n      if (0 == omp_get_thread_num())\n#endif\n        if (callbacks.progress_cb)\n        {\n          int rr =\n              (*callbacks.progress_cb)(callbacks.progresscb_data, LIBRAW_PROGRESS_INTERPOLATE, top - 2, height - 7);\n          if (rr)\n            terminate_flag = 1;\n        }\n#endif\n      for (left = 2; !terminate_flag && (left < width - 5); left += TS - 6)\n      {\n        ahd_interpolate_green_h_and_v(top, left, rgb);\n        ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n        ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n        ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free(buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (terminate_flag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = {-1, 1, -TS, TS};\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][TS][3], (*lix)[3];\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab(0, 0);\n  border_interpolate(5);\n  buffer = (char *)malloc(26 * TS * TS);\n  merror(buffer, \"ahd_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n  homo = (char(*)[TS][TS])(buffer + 24 * TS * TS);\n\n  for (top = 2; top < height - 5; top += TS - 6)\n    for (left = 2; left < width - 5; left += TS - 6)\n    {\n\n      /*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top + TS && row < height - 2; row++)\n      {\n        col = left + (FC(row, left) & 1);\n        for (c = FC(row, col); col < left + TS && col < width - 2; col += 2)\n        {\n          pix = image + row * width + col;\n          val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n          rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n          val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n          rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n        }\n      }\n\n      /*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d = 0; d < 2; d++)\n        for (row = top + 1; row < top + TS - 1 && row < height - 3; row++)\n          for (col = left + 1; col < left + TS - 1 && col < width - 3; col++)\n          {\n            pix = image + row * width + col;\n            rix = &rgb[d][row - top][col - left];\n            lix = &lab[d][row - top][col - left];\n            if ((c = 2 - FC(row, col)) == 1)\n            {\n              c = FC(row + 1, col);\n              val = pix[0][1] + ((pix[-1][2 - c] + pix[1][2 - c] - rix[-1][1] - rix[1][1]) >> 1);\n              rix[0][2 - c] = CLIP(val);\n              val = pix[0][1] + ((pix[-width][c] + pix[width][c] - rix[-TS][1] - rix[TS][1]) >> 1);\n            }\n            else\n              val = rix[0][1] + ((pix[-width - 1][c] + pix[-width + 1][c] + pix[+width - 1][c] + pix[+width + 1][c] -\n                                  rix[-TS - 1][1] - rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                                 2);\n            rix[0][c] = CLIP(val);\n            c = FC(row, col);\n            rix[0][c] = pix[0][c];\n            cielab(rix[0], lix[0]);\n          }\n      /*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset(homo, 0, 2 * TS * TS);\n      for (row = top + 2; row < top + TS - 2 && row < height - 4; row++)\n      {\n        tr = row - top;\n        for (col = left + 2; col < left + TS - 2 && col < width - 4; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n          {\n            lix = &lab[d][tr][tc];\n            for (i = 0; i < 4; i++)\n            {\n              ldiff[d][i] = ABS(lix[0][0] - lix[dir[i]][0]);\n              abdiff[d][i] = SQR(lix[0][1] - lix[dir[i]][1]) + SQR(lix[0][2] - lix[dir[i]][2]);\n            }\n          }\n          leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n          abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n          for (d = 0; d < 2; d++)\n            for (i = 0; i < 4; i++)\n              if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n                homo[d][tr][tc]++;\n        }\n      }\n      /*  Combine the most homogenous pixels for the final result:\t*/\n      for (row = top + 3; row < top + TS - 3 && row < height - 5; row++)\n      {\n        tr = row - top;\n        for (col = left + 3; col < left + TS - 3 && col < width - 5; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n            for (hm[d] = 0, i = tr - 1; i <= tr + 1; i++)\n              for (j = tc - 1; j <= tc + 1; j++)\n                hm[d] += homo[d][i][j];\n          if (hm[0] != hm[1])\n            FORC3 image[row * width + col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n          else\n            FORC3 image[row * width + col][c] = (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n        }\n      }\n    }\n  free(buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort(*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] = /* Optimal 9-element median search */\n      {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,\n       3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};\n\n  for (pass = 1; pass <= med_passes; pass++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c = 0; c < 3; c += 2)\n    {\n      for (pix = image; pix < image + width * height; pix++)\n        pix[0][3] = pix[0][c];\n      for (pix = image + width; pix < image + width * (height - 1); pix++)\n      {\n        if ((pix - image + 1) % width < 2)\n          continue;\n        for (k = 0, i = -width; i <= width; i += width)\n          for (j = i - 1; j <= i + 1; j++)\n            med[k++] = pix[j][3] - pix[j][1];\n        for (i = 0; i < sizeof opt; i += 2)\n          if (med[opt[i]] > med[opt[i + 1]])\n            SWAP(med[opt[i]], med[opt[i + 1]]);\n        pix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {{{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n                                       {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {{{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n                                        {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned)(colors - 3) > 1)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n#endif\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] += trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] += itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow(2.0, 4 - highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc = 0, c = 1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c])\n      kc = c;\n  high = height / SCALE;\n  wide = width / SCALE;\n  map = (float *)calloc(high, wide * sizeof *map);\n  merror(map, \"recover_highlights()\");\n  FORCC if (c != kc)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, c - 1, colors - 1);\n#endif\n    memset(map, 0, high * wide * sizeof *map);\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        sum = wgt = count = 0;\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000)\n            {\n              sum += pixel[c];\n              wgt += pixel[kc];\n              count++;\n            }\n          }\n        if (count == SCALE * SCALE)\n          map[mrow * wide + mcol] = sum / wgt;\n      }\n    for (spread = 32 / grow; spread--;)\n    {\n      for (mrow = 0; mrow < high; mrow++)\n        for (mcol = 0; mcol < wide; mcol++)\n        {\n          if (map[mrow * wide + mcol])\n            continue;\n          sum = count = 0;\n          for (d = 0; d < 8; d++)\n          {\n            y = mrow + dir[d][0];\n            x = mcol + dir[d][1];\n            if (y < high && x < wide && map[y * wide + x] > 0)\n            {\n              sum += (1 + (d & 1)) * map[y * wide + x];\n              count += 1 + (d & 1);\n            }\n          }\n          if (count > 3)\n            map[mrow * wide + mcol] = -(sum + grow) / (count + grow);\n        }\n      for (change = i = 0; i < high * wide; i++)\n        if (map[i] < 0)\n        {\n          map[i] = -map[i];\n          change = 1;\n        }\n      if (!change)\n        break;\n    }\n    for (i = 0; i < high * wide; i++)\n      if (map[i] == 0)\n        map[i] = 1;\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] > 1)\n            {\n              val = pixel[kc] * map[mrow * wide + mcol];\n              if (pixel[c] < val)\n                pixel[c] = CLIP(val);\n            }\n          }\n      }\n  }\n  free(map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get(unsigned base, unsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n#ifdef LIBRAW_IOSPACE_CHECK\n  INT64 pos = ftell(ifp);\n  INT64 fsize = ifp->size();\n  if(fsize < 12 || (fsize-pos) < 12)\n     throw LIBRAW_EXCEPTION_IO_EOF;\n#endif\n  *tag = get2();\n  *type = get2();\n  *len = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type : 0] - '0') > 4)\n    fseek(ifp, get4() + base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note(int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == toff)\n      thumb_offset = get4() + base;\n    if (tag == tlen)\n      thumb_length = get4();\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nstatic float powf_lim(float a, float b, float limup) { return (b > limup || b < -limup) ? 0.f : powf(a, b); }\nstatic float libraw_powf64l(float a, float b) { return powf_lim(a, b, 64.f); }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x)\n{\n  float t;\n  if (x >= 0.0)\n  {\n    t = ceilf(x);\n    if (t - x > 0.5)\n      t -= 1.0;\n    return t;\n  }\n  else\n  {\n    t = ceilf(-x);\n    if (t + x > 0.5)\n      t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))\n    return 0.0f;\n  return libraw_powf64l(2.0, in / 64.0);\n}\n\nstatic float _CanonConvertEV(short in)\n{\n  short EV, Sign, Frac;\n  float Frac_f;\n  EV = in;\n  if (EV < 0)\n  {\n    EV = -EV;\n    Sign = -1;\n  }\n  else\n  {\n    Sign = 1;\n  }\n  Frac = EV & 0x1f;\n  EV -= Frac; // remove fraction\n\n  if (Frac == 0x0c)\n  { // convert 1/3 and 2/3 codes\n    Frac_f = 32.0f / 3.0f;\n  }\n  else if (Frac == 0x14)\n  {\n    Frac_f = 64.0f / 3.0f;\n  }\n  else\n    Frac_f = (float)Frac;\n\n  return ((float)Sign * ((float)EV + Frac_f)) / 32.0f;\n}\n\nunsigned CLASS setCanonBodyFeatures(unsigned id)\n{\n  if (id == 0x03740000) // EOS M3\n    id = 0x80000374;\n  else if (id == 0x03840000) // EOS M10\n    id = 0x80000384;\n  else if (id == 0x03940000) // EOS M5\n    id = 0x80000394;\n  else if (id == 0x04070000) // EOS M6\n    id = 0x80000407;\n  else if (id == 0x03980000) // EOS M100\n    id = 0x80000398;\n\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x80000001) || // 1D\n      (id == 0x80000174) || // 1D2\n      (id == 0x80000232) || // 1D2N\n      (id == 0x80000169) || // 1D3\n      (id == 0x80000281)    // 1D4\n  )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000167) || // 1Ds\n           (id == 0x80000188) || // 1Ds2\n           (id == 0x80000215) || // 1Ds3\n           (id == 0x80000269) || // 1DX\n           (id == 0x80000328) || // 1DX2\n           (id == 0x80000324) || // 1DC\n           (id == 0x80000213) || // 5D\n           (id == 0x80000218) || // 5D2\n           (id == 0x80000285) || // 5D3\n           (id == 0x80000349) || // 5D4\n           (id == 0x80000382) || // 5DS\n           (id == 0x80000401) || // 5DS R\n           (id == 0x80000302)    // 6D\n  )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000331) || // M\n           (id == 0x80000355) || // M2\n           (id == 0x80000374) || // M3\n           (id == 0x80000384) || // M10\n           (id == 0x80000394) || // M5\n           (id == 0x80000407) || // M6\n           (id == 0x80000398)    // M100\n  )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n  }\n  else if ((id == 0x01140000) || // D30\n           (id == 0x01668000) || // D60\n           (id > 0x80000000))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n  }\n  else\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n  }\n\n  return id;\n}\n\nvoid CLASS processCanonCameraInfo(unsigned id, uchar *CameraInfo, unsigned maxlen, unsigned type)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0,\n         iCanonFocalType = 0;\n  if (maxlen < 16)\n    return; // too short\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  if (type == 4)\n  {\n    if ((maxlen == 94) || (maxlen == 138) || (maxlen == 148) || (maxlen == 156) || (maxlen == 162) || (maxlen == 167) ||\n        (maxlen == 171) || (maxlen == 264) || (maxlen > 400))\n      imgdata.other.CameraTemperature = sget4(CameraInfo + ((maxlen - 3) << 2));\n    else if (maxlen == 72)\n      imgdata.other.CameraTemperature = sget4(CameraInfo + ((maxlen - 1) << 2));\n    else if ((maxlen == 85) || (maxlen == 93))\n      imgdata.other.CameraTemperature = sget4(CameraInfo + ((maxlen - 2) << 2));\n    else if ((maxlen == 96) || (maxlen == 104))\n      imgdata.other.CameraTemperature = sget4(CameraInfo + ((maxlen - 4) << 2));\n  }\n\n  switch (id)\n  {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    imgdata.other.CameraTemperature = 0.0f;\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12))\n      iCanonLensID = 151;\n    else\n      iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n  {\n    if (iCanonFocalType >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n    if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'\n      imgdata.lens.makernotes.FocalType = 1;\n  }\n  if (!imgdata.lens.makernotes.CurFocal)\n  {\n    if (iCanonCurFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n  }\n  if (!imgdata.lens.makernotes.LensID)\n  {\n    if (iCanonLensID >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n  }\n  if (!imgdata.lens.makernotes.MinFocal)\n  {\n    if (iCanonMinFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n  }\n  if (!imgdata.lens.makernotes.MaxFocal)\n  {\n    if (iCanonMaxFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n  }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens)\n  {\n    if (iCanonLens + 64 >= maxlen)\n      return;                        // broken;\n    if (CameraInfo[iCanonLens] < 65) // non-Canon lens\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2();\n  get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2();\n  get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2();\n  get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n  {\n    imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n  }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets(short WBCTversion)\n{\n  if (WBCTversion == 0)\n    for (int i = 0; i < 15; i++) // tint, as shot R, as shot B, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if (WBCTversion == 1)\n    for (int i = 0; i < 15; i++) // as shot R, as shot B, tint, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x80000374) || // M3\n                                  (unique_id == 0x80000384) || // M10\n                                  (unique_id == 0x80000394) || // M5\n                                  (unique_id == 0x80000407) || // M6\n                                  (unique_id == 0x80000398) || // M100\n                                  (unique_id == 0x03970000) || // G7 X Mark II\n                                  (unique_id == 0x04100000) || // G9 X Mark II\n                                  (unique_id == 0x04180000)))  // G1 X Mark III\n    for (int i = 0; i < 15; i++)                               // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X\n    for (int i = 0; i < 15; i++) // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  return;\n}\n\nvoid CLASS processNikonLensData(uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n  {\n    if (imgdata.lens.nikon.NikonLensType & 0x04)\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n    else\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n    imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n  {\n    imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n    imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20)\n  {\n    switch (len)\n    {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * libraw_powf64l(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * libraw_powf64l(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = libraw_powf64l(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = libraw_powf64l(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n    {\n      if ((LensData[i - 1]) && (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n        imgdata.lens.makernotes.CurFocal = 5.0f * libraw_powf64l(2.0f, (float)LensData[i - 1] / 24.0f);\n      if (LensData[i + 7])\n        imgdata.lens.nikon.NikonEffectiveMaxAp = libraw_powf64l(2.0f, (float)LensData[i + 7] / 24.0f);\n    }\n    imgdata.lens.makernotes.LensID =\n        (unsigned long long)LensData[i] << 56 | (unsigned long long)LensData[i + 1] << 48 |\n        (unsigned long long)LensData[i + 2] << 40 | (unsigned long long)LensData[i + 3] << 32 |\n        (unsigned long long)LensData[i + 4] << 24 | (unsigned long long)LensData[i + 5] << 16 |\n        (unsigned long long)LensData[i + 6] << 8 | (unsigned long long)imgdata.lens.nikon.NikonLensType;\n  }\n  else if ((len == 459) || (len == 590))\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n  }\n  else if (len == 509)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n  }\n  else if (len == 879)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n  }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures(unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if (id == 0x5330303638ULL)\n  {\n    strcpy(model, \"E-M10MarkIII\");\n  }\n  if ((id == 0x4434303430ULL) || // E-1\n      (id == 0x4434303431ULL) || // E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n    if ((id == 0x4434303430ULL) ||                              // E-1\n        (id == 0x4434303431ULL) ||                              // E-330\n        ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n        (id == 0x5330303233ULL) ||                              // E-620\n        (id == 0x5330303239ULL) ||                              // E-450\n        (id == 0x5330303330ULL) ||                              // E-600\n        (id == 0x5330303333ULL))                                // E-5\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n    }\n    else\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n    }\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes(unsigned tag, unsigned type, unsigned len)\n{\n\n  if (tag == 0x0001)\n    Canon_CameraSettings();\n  else if (tag == 0x0002) // focal length\n  {\n    imgdata.lens.makernotes.FocalType = get2();\n    imgdata.lens.makernotes.CurFocal = get2();\n    if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  }\n\n  else if (tag == 0x0004) // shot info\n  {\n    short tempAp;\n\n    fseek(ifp, 24, SEEK_CUR);\n    tempAp = get2();\n    if (tempAp != 0)\n      imgdata.other.CameraTemperature = (float)(tempAp - 128);\n    tempAp = get2();\n    if (tempAp != -1)\n      imgdata.other.FlashGN = ((float)tempAp) / 32;\n    get2();\n\n    // fseek(ifp, 30, SEEK_CUR);\n    imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n    fseek(ifp, 8 - 32, SEEK_CUR);\n    if ((tempAp = get2()) != 0x7fff)\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n    if (imgdata.lens.makernotes.CurAp < 0.7f)\n    {\n      fseek(ifp, 32, SEEK_CUR);\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n    }\n    if (!aperture)\n      aperture = imgdata.lens.makernotes.CurAp;\n  }\n\n  else if (tag == 0x000c)\n  {\n    unsigned tS = get4();\n    sprintf (imgdata.shootinginfo.BodySerial, \"%d\", tS);\n  }\n\n  else if (tag == 0x0095 && // lens model tag\n           !imgdata.lens.makernotes.Lens[0])\n  {\n    fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    if (imgdata.lens.makernotes.Lens[0] < 65) // non-Canon lens\n      fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n    else\n    {\n      char efs[2];\n      imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n      imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n      fread(efs, 2, 1, ifp);\n      if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n      { // \"EF-S, TS-E, MP-E, EF-M\" lenses\n        imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n        imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n        imgdata.lens.makernotes.Lens[4] = 32;\n        if (efs[1] == 83)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n        }\n        else if (efs[1] == 77)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n        }\n      }\n      else\n      { // \"EF\" lenses\n        imgdata.lens.makernotes.Lens[2] = 32;\n        imgdata.lens.makernotes.Lens[3] = efs[0];\n        imgdata.lens.makernotes.Lens[4] = efs[1];\n      }\n      fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n    }\n  }\n\n  else if (tag == 0x009a)\n  {\n    get4();\n    imgdata.sizes.raw_crop.cwidth = get4();\n    imgdata.sizes.raw_crop.cheight = get4();\n    imgdata.sizes.raw_crop.cleft = get4();\n    imgdata.sizes.raw_crop.ctop = get4();\n  }\n\n  else if (tag == 0x00a9)\n  {\n    long int save1 = ftell(ifp);\n    int c;\n    fseek(ifp, (0x1 << 1), SEEK_CUR);\n    FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n    Canon_WBpresets(0, 0);\n    fseek(ifp, save1, SEEK_SET);\n  }\n\n  else if (tag == 0x00e0) // sensor info\n  {\n    imgdata.makernotes.canon.SensorWidth = (get2(), get2());\n    imgdata.makernotes.canon.SensorHeight = get2();\n    imgdata.makernotes.canon.SensorLeftBorder = (get2(), get2(), get2());\n    imgdata.makernotes.canon.SensorTopBorder = get2();\n    imgdata.makernotes.canon.SensorRightBorder = get2();\n    imgdata.makernotes.canon.SensorBottomBorder = get2();\n    imgdata.makernotes.canon.BlackMaskLeftBorder = get2();\n    imgdata.makernotes.canon.BlackMaskTopBorder = get2();\n    imgdata.makernotes.canon.BlackMaskRightBorder = get2();\n    imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n  }\n\n  else if (tag == 0x4013)\n  {\n    get4();\n    imgdata.makernotes.canon.AFMicroAdjMode = get4();\n    imgdata.makernotes.canon.AFMicroAdjValue = ((float)get4()) / ((float)get4());\n  }\n\n  else if (tag == 0x4001 && len > 500)\n  {\n    int c;\n    long int save1 = ftell(ifp);\n    switch (len)\n    {\n    case 582:\n      imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D\n      {\n        fseek(ifp, save1 + (0x1e << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x41 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x46 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom2][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x23 << 1), SEEK_SET);\n        Canon_WBpresets(2, 2);\n        fseek(ifp, save1 + (0x4b << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 653:\n      imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2\n      {\n        fseek(ifp, save1 + (0x18 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x90 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x95 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom2][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x9a << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom3][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x27 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa4 << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 796:\n      imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x71 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x76 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom2][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x7b << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom3][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x80 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x4e << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0c4 << 1), SEEK_SET); // offset 196 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n    // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n    // 7D / 40D / 50D / 60D / 450D / 500D\n    // 550D / 1000D / 1100D\n    case 674:\n    case 692:\n    case 702:\n    case 1227:\n    case 1250:\n    case 1251:\n    case 1337:\n    case 1338:\n    case 1346:\n      imgdata.makernotes.canon.CanonColorDataVer = 4;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x53 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa8 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0e7 << 1), SEEK_SET); // offset 231 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4) || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n      {\n        fseek(ifp, save1 + (0x2b8 << 1), SEEK_SET); // offset 696 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n               (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n      {\n        fseek(ifp, save1 + (0x2cf << 1), SEEK_SET); // offset 719 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n      {\n        fseek(ifp, save1 + (0x2d3 << 1), SEEK_SET); // offset 723 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    case 5120:\n      imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, G7 X, G9 X, EOS M3, EOS M5, EOS M6\n      {\n        if ((unique_id == 0x03970000) || // G7 X Mark II\n            (unique_id == 0x04100000) || // G9 X Mark II\n            (unique_id == 0x04180000) || // G1 X Mark III\n            (unique_id == 0x80000394) || // EOS M5\n            (unique_id == 0x80000398) || // EOS M100\n            (unique_id == 0x80000407))   // EOS M6\n        {\n          fseek(ifp, save1 + (0x4f << 1), SEEK_SET);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          Canon_WBpresets(8, 24);\n          fseek(ifp, 168, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n          fseek(ifp, 24, SEEK_CUR);\n          Canon_WBCTpresets(2); // BCADT\n          fseek(ifp, 6, SEEK_CUR);\n        }\n        else\n        {\n          fseek(ifp, save1 + (0x4c << 1), SEEK_SET);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n          get2();\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n          get2();\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          get2();\n          Canon_WBpresets(2, 12);\n          fseek(ifp, save1 + (0xba << 1), SEEK_SET);\n          Canon_WBCTpresets(2);                       // BCADT\n          fseek(ifp, save1 + (0x108 << 1), SEEK_SET); // offset 264 short\n        }\n        int bls = 0;\n        FORC4 bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n\n    case 1273:\n    case 1275:\n      imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x67 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xbc << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0fb << 1), SEEK_SET); // offset 251 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      fseek(ifp, save1 + (0x1e3 << 1), SEEK_SET); // offset 483 shorts\n      imgdata.makernotes.canon.NormalWhiteLevel = get2();\n      imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      break;\n\n    // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n    case 1312:\n    case 1313:\n    case 1316:\n    case 1506:\n      imgdata.makernotes.canon.CanonColorDataVer = 7;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x80 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xd5 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x114 << 1), SEEK_SET); // offset 276 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n      {\n        fseek(ifp, save1 + (0x1fc << 1), SEEK_SET); // offset 508 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n      {\n        fseek(ifp, save1 + (0x2dc << 1), SEEK_SET); // offset 732 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    // 5DS / 5DS R / 80D / 1300D / 5D4 / 800D / 77D / 6D II / 200D\n    case 1560:\n    case 1592:\n    case 1353:\n    case 1602:\n      imgdata.makernotes.canon.CanonColorDataVer = 8;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x44 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n        fseek(ifp, save1 + (0x49 << 1), SEEK_SET);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Measured][c ^ (c >> 1)] = get2();\n\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x107 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x146 << 1), SEEK_SET); // offset 326 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 14) // 1300D\n      {\n        fseek(ifp, save1 + (0x230 << 1), SEEK_SET); // offset 560 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else\n      {\n        fseek(ifp, save1 + (0x30e << 1), SEEK_SET); // offset 782 shorts\n        imgdata.makernotes.canon.NormalWhiteLevel = get2();\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n    }\n    fseek(ifp, save1, SEEK_SET);\n  }\n}\n\nvoid CLASS setPentaxBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id)\n  {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n  case 0x1322c:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO(ushort c)\n{\n  int code[] = {3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,   16,   17,  18,  19,  20,\n                21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,   34,   35,  36,  37,  38,\n                39,  40,  41,  42,  43,  44,  45,  50,  100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261,\n                262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274,  275,  276, 277, 278};\n  double value[] = {50,     64,     80,     100,    125,    160,    200,    250,   320,   400,    500,    640,\n                    800,    1000,   1250,   1600,   2000,   2500,   3200,   4000,  5000,  6400,   8000,   10000,\n                    12800,  16000,  20000,  25600,  32000,  40000,  51200,  64000, 80000, 102400, 128000, 160000,\n                    204800, 258000, 325000, 409600, 516000, 650000, 819200, 50,    100,   200,    400,    800,\n                    1600,   3200,   50,     70,     100,    140,    200,    280,   400,   560,    800,    1100,\n                    1600,   2200,   3200,   4500,   6400,   9000,   12800,  18000, 25600, 36000,  51200};\n#define numel (sizeof(code) / sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++)\n  {\n    if (code[i] == c)\n    {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel)\n    iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo(unsigned id, unsigned len) // tag 0x0207\n{\n  ushort iLensData = 0;\n  uchar *table_buf;\n  table_buf = (uchar *)malloc(MAX(len, 128));\n  fread(table_buf, len, 1, ifp);\n  if ((id < 0x12b9c) || (((id == 0x12b9c) ||  // K100D\n                          (id == 0x12b9d) ||  // K110D\n                          (id == 0x12ba2)) && // K100D Super\n                         ((!table_buf[20] || (table_buf[20] == 0xff)))))\n  {\n    iLensData = 3;\n    if (imgdata.lens.makernotes.LensID == -1)\n      imgdata.lens.makernotes.LensID = (((unsigned)table_buf[0]) << 8) + table_buf[1];\n  }\n  else\n    switch (len)\n    {\n    case 90: // LensInfo3\n      iLensData = 13;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 91: // LensInfo4\n      iLensData = 12;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 80: // LensInfo5\n    case 128:\n      iLensData = 15;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) << 8) + table_buf[5];\n      break;\n    default:\n      if (id >= 0x12b9c) // LensInfo2\n      {\n        iLensData = 4;\n        if (imgdata.lens.makernotes.LensID == -1)\n          imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) << 8) + table_buf[3];\n      }\n    }\n  if (iLensData)\n  {\n    if (table_buf[iLensData + 9] && (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n      imgdata.lens.makernotes.CurFocal =\n          10 * (table_buf[iLensData + 9] >> 2) * libraw_powf64l(4, (table_buf[iLensData + 9] & 0x03) - 2);\n    if (table_buf[iLensData + 10] & 0xf0)\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          libraw_powf64l(2.0f, (float)((table_buf[iLensData + 10] & 0xf0) >> 4) / 4.0f);\n    if (table_buf[iLensData + 10] & 0x0f)\n      imgdata.lens.makernotes.MinAp4CurFocal =\n          libraw_powf64l(2.0f, (float)((table_buf[iLensData + 10] & 0x0f) + 10) / 4.0f);\n\n    if (iLensData != 12)\n    {\n      switch (table_buf[iLensData] & 0x06)\n      {\n      case 0:\n        imgdata.lens.makernotes.MinAp4MinFocal = 22.0f;\n        break;\n      case 2:\n        imgdata.lens.makernotes.MinAp4MinFocal = 32.0f;\n        break;\n      case 4:\n        imgdata.lens.makernotes.MinAp4MinFocal = 45.0f;\n        break;\n      case 6:\n        imgdata.lens.makernotes.MinAp4MinFocal = 16.0f;\n        break;\n      }\n      if (table_buf[iLensData] & 0x70)\n        imgdata.lens.makernotes.LensFStops = ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n      imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData + 3] & 0xf8);\n      imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData + 3] & 0x07);\n\n      if ((table_buf[iLensData + 14] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n        imgdata.lens.makernotes.MaxAp4CurFocal =\n            libraw_powf64l(2.0f, (float)((table_buf[iLensData + 14] & 0x7f) - 1) / 32.0f);\n    }\n    else if ((id != 0x12e76) && // K-5\n             (table_buf[iLensData + 15] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n    {\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          libraw_powf64l(2.0f, (float)((table_buf[iLensData + 15] & 0x7f) - 1) / 32.0f);\n    }\n  }\n  free(table_buf);\n  return;\n}\n\nvoid CLASS setPhaseOneFeatures(unsigned id)\n{\n\n  ushort i;\n  static const struct\n  {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n      // Phase One section:\n      {1, \"Hasselblad V\"},\n      {10, \"PhaseOne/Mamiya\"},\n      {12, \"Contax 645\"},\n      {16, \"Hasselblad V\"},\n      {17, \"Hasselblad V\"},\n      {18, \"Contax 645\"},\n      {19, \"PhaseOne/Mamiya\"},\n      {20, \"Hasselblad V\"},\n      {21, \"Contax 645\"},\n      {22, \"PhaseOne/Mamiya\"},\n      {23, \"Hasselblad V\"},\n      {24, \"Hasselblad H\"},\n      {25, \"PhaseOne/Mamiya\"},\n      {32, \"Contax 645\"},\n      {34, \"Hasselblad V\"},\n      {35, \"Hasselblad V\"},\n      {36, \"Hasselblad H\"},\n      {37, \"Contax 645\"},\n      {38, \"PhaseOne/Mamiya\"},\n      {39, \"Hasselblad V\"},\n      {40, \"Hasselblad H\"},\n      {41, \"Contax 645\"},\n      {42, \"PhaseOne/Mamiya\"},\n      {44, \"Hasselblad V\"},\n      {45, \"Hasselblad H\"},\n      {46, \"Contax 645\"},\n      {47, \"PhaseOne/Mamiya\"},\n      {48, \"Hasselblad V\"},\n      {49, \"Hasselblad H\"},\n      {50, \"Contax 645\"},\n      {51, \"PhaseOne/Mamiya\"},\n      {52, \"Hasselblad V\"},\n      {53, \"Hasselblad H\"},\n      {54, \"Contax 645\"},\n      {55, \"PhaseOne/Mamiya\"},\n      {67, \"Hasselblad V\"},\n      {68, \"Hasselblad H\"},\n      {69, \"Contax 645\"},\n      {70, \"PhaseOne/Mamiya\"},\n      {71, \"Hasselblad V\"},\n      {72, \"Hasselblad H\"},\n      {73, \"Contax 645\"},\n      {74, \"PhaseOne/Mamiya\"},\n      {76, \"Hasselblad V\"},\n      {77, \"Hasselblad H\"},\n      {78, \"Contax 645\"},\n      {79, \"PhaseOne/Mamiya\"},\n      {80, \"Hasselblad V\"},\n      {81, \"Hasselblad H\"},\n      {82, \"Contax 645\"},\n      {83, \"PhaseOne/Mamiya\"},\n      {84, \"Hasselblad V\"},\n      {85, \"Hasselblad H\"},\n      {86, \"Contax 645\"},\n      {87, \"PhaseOne/Mamiya\"},\n      {99, \"Hasselblad V\"},\n      {100, \"Hasselblad H\"},\n      {101, \"Contax 645\"},\n      {102, \"PhaseOne/Mamiya\"},\n      {103, \"Hasselblad V\"},\n      {104, \"Hasselblad H\"},\n      {105, \"PhaseOne/Mamiya\"},\n      {106, \"Contax 645\"},\n      {112, \"Hasselblad V\"},\n      {113, \"Hasselblad H\"},\n      {114, \"Contax 645\"},\n      {115, \"PhaseOne/Mamiya\"},\n      {131, \"Hasselblad V\"},\n      {132, \"Hasselblad H\"},\n      {133, \"Contax 645\"},\n      {134, \"PhaseOne/Mamiya\"},\n      {135, \"Hasselblad V\"},\n      {136, \"Hasselblad H\"},\n      {137, \"Contax 645\"},\n      {138, \"PhaseOne/Mamiya\"},\n      {140, \"Hasselblad V\"},\n      {141, \"Hasselblad H\"},\n      {142, \"Contax 645\"},\n      {143, \"PhaseOne/Mamiya\"},\n      {148, \"Hasselblad V\"},\n      {149, \"Hasselblad H\"},\n      {150, \"Contax 645\"},\n      {151, \"PhaseOne/Mamiya\"},\n      {160, \"A-250\"},\n      {161, \"A-260\"},\n      {162, \"A-280\"},\n      {167, \"Hasselblad V\"},\n      {168, \"Hasselblad H\"},\n      {169, \"Contax 645\"},\n      {170, \"PhaseOne/Mamiya\"},\n      {172, \"Hasselblad V\"},\n      {173, \"Hasselblad H\"},\n      {174, \"Contax 645\"},\n      {175, \"PhaseOne/Mamiya\"},\n      {176, \"Hasselblad V\"},\n      {177, \"Hasselblad H\"},\n      {178, \"Contax 645\"},\n      {179, \"PhaseOne/Mamiya\"},\n      {180, \"Hasselblad V\"},\n      {181, \"Hasselblad H\"},\n      {182, \"Contax 645\"},\n      {183, \"PhaseOne/Mamiya\"},\n      {208, \"Hasselblad V\"},\n      {211, \"PhaseOne/Mamiya\"},\n      {448, \"Phase One 645AF\"},\n      {457, \"Phase One 645DF\"},\n      {471, \"Phase One 645DF+\"},\n      {704, \"Phase One iXA\"},\n      {705, \"Phase One iXA - R\"},\n      {706, \"Phase One iXU 150\"},\n      {707, \"Phase One iXU 150 - NIR\"},\n      {708, \"Phase One iXU 180\"},\n      {721, \"Phase One iXR\"},\n      // Leaf section:\n      {333, \"Mamiya\"},\n      {329, \"Universal\"},\n      {330, \"Hasselblad H1/H2\"},\n      {332, \"Contax\"},\n      {336, \"AFi\"},\n      {327, \"Mamiya\"},\n      {324, \"Universal\"},\n      {325, \"Hasselblad H1/H2\"},\n      {326, \"Contax\"},\n      {335, \"AFi\"},\n      {340, \"Mamiya\"},\n      {337, \"Universal\"},\n      {338, \"Hasselblad H1/H2\"},\n      {339, \"Contax\"},\n      {323, \"Mamiya\"},\n      {320, \"Universal\"},\n      {322, \"Hasselblad H1/H2\"},\n      {321, \"Contax\"},\n      {334, \"AFi\"},\n      {369, \"Universal\"},\n      {370, \"Mamiya\"},\n      {371, \"Hasselblad H1/H2\"},\n      {372, \"Contax\"},\n      {373, \"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0])\n  {\n    for (i = 0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id)\n      {\n        strcpy(imgdata.lens.makernotes.body, p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes(unsigned tag, unsigned type)\n{\n  switch (tag)\n  {\n  case 0x1002:\n    imgdata.makernotes.fuji.WB_Preset = get2();\n    break;\n  case 0x1011:\n    imgdata.other.FlashEC = getreal(type);\n    break;\n  case 0x1020:\n    imgdata.makernotes.fuji.Macro = get2();\n    break;\n  case 0x1021:\n    imgdata.makernotes.fuji.FocusMode = get2();\n    break;\n  case 0x1022:\n    imgdata.makernotes.fuji.AFMode = get2();\n    break;\n  case 0x1023:\n    imgdata.makernotes.fuji.FocusPixel[0] = get2();\n    imgdata.makernotes.fuji.FocusPixel[1] = get2();\n    break;\n  case 0x1034:\n    imgdata.makernotes.fuji.ExrMode = get2();\n    break;\n  case 0x1050:\n    imgdata.makernotes.fuji.ShutterType = get2();\n    break;\n  case 0x1400:\n    imgdata.makernotes.fuji.FujiDynamicRange = get2();\n    break;\n  case 0x1401:\n    imgdata.makernotes.fuji.FujiFilmMode = get2();\n    break;\n  case 0x1402:\n    imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2();\n    break;\n  case 0x1403:\n    imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2();\n    break;\n  case 0x140b:\n    imgdata.makernotes.fuji.FujiAutoDynamicRange = get2();\n    break;\n  case 0x1404:\n    imgdata.lens.makernotes.MinFocal = getreal(type);\n    break;\n  case 0x1405:\n    imgdata.lens.makernotes.MaxFocal = getreal(type);\n    break;\n  case 0x1406:\n    imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n    break;\n  case 0x1407:\n    imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n    break;\n  case 0x1422:\n    imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n    imgdata.shootinginfo.ImageStabilization =\n        (imgdata.makernotes.fuji.ImageStabilization[0] << 9) + imgdata.makernotes.fuji.ImageStabilization[1];\n    break;\n  case 0x1431:\n    imgdata.makernotes.fuji.Rating = get4();\n    break;\n  case 0x3820:\n    imgdata.makernotes.fuji.FrameRate = get2();\n    break;\n  case 0x3821:\n    imgdata.makernotes.fuji.FrameWidth = get2();\n    break;\n  case 0x3822:\n    imgdata.makernotes.fuji.FrameHeight = get2();\n    break;\n  }\n  return;\n}\n\nvoid CLASS setSonyBodyFeatures(unsigned id)\n{\n  ushort idx;\n  static const struct\n  {\n    ushort scf[8];\n    /*\n    scf[0] camera id\n    scf[1] camera format\n    scf[2] camera mount: Minolta A, Sony E, fixed,\n    scf[3] camera type: DSLR, NEX, SLT, ILCE, ILCA, DSC\n    scf[4] lens mount\n    scf[5] tag 0x2010 group (0 if not used)\n    scf[6] offset of Sony ISO in 0x2010 table, 0xffff if not valid\n    scf[7] offset of ImageCount3 in 0x9050 table, 0xffff if not valid\n    */\n  } SonyCamFeatures[] = {\n      {256, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {257, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {258, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {259, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {260, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {261, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {262, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {263, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {264, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {265, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {266, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {267, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {268, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {269, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {270, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {271, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {272, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {273, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {274, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {275, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {276, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {277, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {278, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0, 0xffff, 0xffff},\n      {279, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0, 0xffff, 0xffff},\n      {280, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0, 0xffff, 0xffff},\n      {281, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0, 0xffff, 0xffff},\n      {282, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {283, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0, 0xffff, 0xffff},\n      {284, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0, 0xffff, 0xffff},\n      {285, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0, 0xffff, 0xffff},\n      {286, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 2, 0x1218, 0x01bd},\n      {287, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 2, 0x1218, 0x01bd},\n      {288, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 1, 0x113e, 0x01bd},\n      {289, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 2, 0x1218, 0x01bd},\n      {290, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 2, 0x1218, 0x01bd},\n      {291, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 3, 0x11f4, 0x01bd},\n      {292, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 3, 0x11f4, 0x01bd},\n      {293, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 3, 0x11f4, 0x01bd},\n      {294, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 5, 0x1254, 0x01aa},\n      {295, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {296, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {297, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 5, 0x1254, 0xffff},\n      {298, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 5, 0x1258, 0xffff},\n      {299, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {301, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {302, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 5, 0x1280, 0x01aa},\n      {303, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 5, 0x1280, 0x01aa},\n      {304, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {305, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1280, 0x01aa},\n      {306, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {307, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5, 0x1254, 0x01aa},\n      {308, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 6, 0x113c, 0xffff},\n      {309, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 7, 0x0344, 0xffff},\n      {310, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 5, 0x1258, 0xffff},\n      {311, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {312, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {313, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0x01aa},\n      {314, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {315, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {316, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {317, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 7, 0x0344, 0xffff},\n      {318, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {319, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0, 7, 0x0344, 0x01a0},\n      {320, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {321, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {322, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {323, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {324, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {325, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {326, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {327, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {328, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {329, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {330, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {331, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {332, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {333, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {334, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {335, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {336, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {337, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {338, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {339, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0x01a0},\n      {340, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0xffff},\n      {341, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {342, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {343, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {344, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {345, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {346, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7, 0x0344, 0x01a0},\n      {347, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8, 0x0346, 0x01cb},\n      {348, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {349, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {350, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8, 0x0346, 0x01cb},\n      {351, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {352, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {353, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0, 7, 0x0344, 0x01a0},\n      {354, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0, 8, 0x0346, 0x01cd},\n      {355, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {356, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {357, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8, 0x0346, 0x01cd},\n      {358, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9, 0x0320, 0x019f},\n      {359, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {360, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8, 0x0346, 0x01cd},\n      {361, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {362, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9, 0x0320, 0x019f},\n      {363, 0, 0, 0, 0, 0, 0xffff, 0xffff},\n      {364, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff},\n      {365, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff},\n  };\n  imgdata.lens.makernotes.CamID = id;\n\n  if (id == 2)\n  {\n    imgdata.lens.makernotes.CameraMount = imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n    imgdata.makernotes.sony.group2010 = 0;\n    imgdata.makernotes.sony.real_iso_offset = 0xffff;\n    imgdata.makernotes.sony.ImageCount3_offset = 0xffff;\n    return;\n  }\n  else\n    idx = id - 256;\n\n  if ((idx >= 0) && (idx < sizeof SonyCamFeatures / sizeof *SonyCamFeatures))\n  {\n    if (!SonyCamFeatures[idx].scf[2])\n      return;\n    imgdata.lens.makernotes.CameraFormat = SonyCamFeatures[idx].scf[1];\n    imgdata.lens.makernotes.CameraMount = SonyCamFeatures[idx].scf[2];\n    imgdata.makernotes.sony.SonyCameraType = SonyCamFeatures[idx].scf[3];\n    if (SonyCamFeatures[idx].scf[4])\n      imgdata.lens.makernotes.LensMount = SonyCamFeatures[idx].scf[4];\n    imgdata.makernotes.sony.group2010 = SonyCamFeatures[idx].scf[5];\n    imgdata.makernotes.sony.real_iso_offset = SonyCamFeatures[idx].scf[6];\n    imgdata.makernotes.sony.ImageCount3_offset = SonyCamFeatures[idx].scf[7];\n  }\n\n  char *sbstr = strstr(software, \" v\");\n  if (sbstr != NULL)\n  {\n    sbstr += 2;\n    imgdata.makernotes.sony.firmware = atof(sbstr);\n\n    if ((id == 306) || (id == 311))\n    {\n      if (imgdata.makernotes.sony.firmware < 1.2f)\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01aa;\n      else\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01c0;\n    }\n    else if (id == 312)\n    {\n      if (imgdata.makernotes.sony.firmware < 2.0f)\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01aa;\n      else\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01c0;\n    }\n    else if ((id == 318) || (id == 340))\n    {\n      if (imgdata.makernotes.sony.firmware < 1.2f)\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01a0;\n      else\n        imgdata.makernotes.sony.ImageCount3_offset = 0x01b6;\n    }\n  }\n}\n\nvoid CLASS parseSonyLensType2(uchar a, uchar b)\n{\n  ushort lid2;\n  lid2 = (((ushort)a) << 8) | ((ushort)b);\n  if (!lid2)\n    return;\n  if (lid2 < 0x100)\n  {\n    if ((imgdata.lens.makernotes.AdapterID != 0x4900) && (imgdata.lens.makernotes.AdapterID != 0xEF00))\n    {\n      imgdata.lens.makernotes.AdapterID = lid2;\n      switch (lid2)\n      {\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 44:\n      case 78:\n      case 239:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n      }\n    }\n  }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    imgdata.lens.makernotes.AdapterID = 0x4900;\n  }\n  return;\n}\n\n#define strnXcat(buf, string) strncat(buf, string, LIM(sizeof(buf) - strbuflen(buf) - 1, 0, sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures(uchar a, uchar b)\n{\n\n  ushort features;\n  features = (((ushort)a) << 8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) || !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100))\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n  {\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n    if ((features & 0x0200) && (features & 0x0100))\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0200)\n    {\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0100)\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n    }\n  }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\");\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf + 1,\n            strbuflen(imgdata.lens.makernotes.LensFeatures_suf) - 1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x0116(uchar *buf, ushort len, unsigned id)\n{\n  short bufx;\n\n  if (((id == 257) || (id == 262) || (id == 269) || (id == 270)) && (len >= 2))\n    bufx = buf[1];\n  else if ((id >= 273) && (len >= 3))\n    bufx = buf[2];\n  else\n    return;\n\n  imgdata.other.BatteryTemperature = (float)(bufx - 32) / 1.8f;\n}\n\nvoid CLASS process_Sony_0x2010(uchar *buf, ushort len)\n{\n  if ((!imgdata.makernotes.sony.group2010) || (imgdata.makernotes.sony.real_iso_offset == 0xffff) ||\n      (len < (imgdata.makernotes.sony.real_iso_offset + 2)))\n    return;\n\n  if (imgdata.other.real_ISO < 0.1f)\n  {\n    uchar s[2];\n    s[0] = SonySubstitution[buf[imgdata.makernotes.sony.real_iso_offset]];\n    s[1] = SonySubstitution[buf[imgdata.makernotes.sony.real_iso_offset + 1]];\n    imgdata.other.real_ISO = 100.0f * libraw_powf64l(2.0f, (16 - ((float)sget2(s)) / 256.0f));\n  }\n}\n\nvoid CLASS process_Sony_0x9050(uchar *buf, ushort len, unsigned id)\n{\n  ushort lid;\n  uchar s[4];\n  int c;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n  {\n    if (len < 2)\n      return;\n    if (buf[0])\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(libraw_powf64l(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n\n    if (buf[1])\n      imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(libraw_powf64l(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n  }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n  {\n    if (len <= 0x106)\n      return;\n    if (buf[0x3d] | buf[0x3c])\n    {\n      lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];\n      imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);\n    }\n    if (buf[0x105] && (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n        (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n      imgdata.lens.makernotes.LensMount = SonySubstitution[buf[0x105]];\n    if (buf[0x106])\n      imgdata.lens.makernotes.LensFormat = SonySubstitution[buf[0x106]];\n  }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n  {\n    if (len <= 0x108)\n      return;\n    parseSonyLensType2(SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0107]]);\n  }\n\n  if (len <= 0x10a)\n    return;\n  if ((imgdata.lens.makernotes.LensID == -1) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n  {\n    imgdata.lens.makernotes.LensID = // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];\n\n    if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n    {\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    }\n\n    else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n             (imgdata.lens.makernotes.LensID != 0xFF00))\n    {\n      imgdata.lens.makernotes.AdapterID = 0xEF00;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    }\n  }\n\n  if ((id >= 286) && (id <= 293))\n  {\n    if (len <= 0x116)\n      return;\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures(SonySubstitution[buf[0x115]], SonySubstitution[buf[0x116]]);\n  }\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n  {\n    if (len <= 0x117)\n      return;\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n  }\n\n  if ((id == 347) || (id == 350) || (id == 354) || (id == 357) || (id == 358) || (id == 360) || (id == 362))\n  {\n    if (len <= 0x8d)\n      return;\n    unsigned long long b88 = SonySubstitution[buf[0x88]];\n    unsigned long long b89 = SonySubstitution[buf[0x89]];\n    unsigned long long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06llx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A)\n  {\n    if (len <= 0xf4)\n      return;\n    unsigned long long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05llx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    if (len <= 0x7f)\n      return;\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  if ((imgdata.makernotes.sony.ImageCount3_offset != 0xffff) &&\n      (len >= (imgdata.makernotes.sony.ImageCount3_offset + 4)))\n  {\n    FORC4 s[c] = SonySubstitution[buf[imgdata.makernotes.sony.ImageCount3_offset + c]];\n    imgdata.makernotes.sony.ImageCount3 = sget4(s);\n  }\n\n  if (id == 362)\n  {\n    for (c = 0; c < 6; c++)\n    {\n      imgdata.makernotes.sony.TimeStamp[c] = SonySubstitution[buf[0x0066 + c]];\n    }\n  }\n\n  return;\n}\n\nvoid CLASS process_Sony_0x9400(uchar *buf, ushort len, unsigned id)\n{\n\n  uchar s[4];\n  int c;\n  short bufx = buf[0];\n\n  if (((bufx == 0x23) || (bufx == 0x24) || (bufx == 0x26)) && (len >= 0x1f))\n  { // 0x9400 'c' version\n\n    if ((id == 358) || (id == 362) || (id == 365))\n    {\n      imgdata.makernotes.sony.ShotNumberSincePowerUp = SonySubstitution[buf[0x0a]];\n    }\n    else\n    {\n      FORC4 s[c] = SonySubstitution[buf[0x0a + c]];\n      imgdata.makernotes.sony.ShotNumberSincePowerUp = sget4(s);\n    }\n\n    imgdata.makernotes.sony.Sony0x9400_version = 0xc;\n\n    imgdata.makernotes.sony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x09]];\n\n    FORC4 s[c] = SonySubstitution[buf[0x12 + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceImageNumber = sget4(s);\n\n    imgdata.makernotes.sony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x16]]; // shots\n\n    FORC4 s[c] = SonySubstitution[buf[0x1a + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceFileNumber = sget4(s);\n\n    imgdata.makernotes.sony.Sony0x9400_SequenceLength2 = SonySubstitution[buf[0x1e]]; // files\n  }\n\n  else if ((bufx == 0x0c) && (len >= 0x1f))\n  { // 0x9400 'b' version\n    imgdata.makernotes.sony.Sony0x9400_version = 0xb;\n\n    FORC4 s[c] = SonySubstitution[buf[0x08 + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceImageNumber = sget4(s);\n\n    FORC4 s[c] = SonySubstitution[buf[0x0c + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceFileNumber = sget4(s);\n\n    imgdata.makernotes.sony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x10]];\n\n    imgdata.makernotes.sony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x1e]];\n  }\n\n  else if ((bufx == 0x0a) && (len >= 0x23))\n  { // 0x9400 'a' version\n    imgdata.makernotes.sony.Sony0x9400_version = 0xa;\n\n    FORC4 s[c] = SonySubstitution[buf[0x08 + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceImageNumber = sget4(s);\n\n    FORC4 s[c] = SonySubstitution[buf[0x0c + c]];\n    imgdata.makernotes.sony.Sony0x9400_SequenceFileNumber = sget4(s);\n\n    imgdata.makernotes.sony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x10]];\n\n    imgdata.makernotes.sony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x22]];\n  }\n\n  else\n    return;\n}\n\nvoid CLASS process_Sony_0x9402(uchar *buf, ushort len)\n{\n\n  if ((imgdata.makernotes.sony.SonyCameraType == LIBRAW_SONY_SLT) ||\n      (imgdata.makernotes.sony.SonyCameraType == LIBRAW_SONY_ILCA))\n    return;\n\n  if (len < 5)\n    return;\n\n  short bufx = buf[0x00];\n  if ((bufx == 0x05) || (bufx == 0xff) || (buf[0x02] != 0xff))\n    return;\n\n  imgdata.other.AmbientTemperature = (float)((short)SonySubstitution[buf[0x04]]);\n\n  return;\n}\n\nvoid CLASS process_Sony_0x9403(uchar *buf, ushort len)\n{\n  if (len < 6)\n    return;\n  short bufx = SonySubstitution[buf[4]];\n  if ((bufx == 0x00) || (bufx == 0x94))\n    return;\n\n  imgdata.other.SensorTemperature = (float)((short)SonySubstitution[buf[5]]);\n\n  return;\n}\n\nvoid CLASS process_Sony_0x9406(uchar *buf, ushort len)\n{\n  if (len < 6)\n    return;\n  short bufx = buf[0];\n  if ((bufx != 0x01) && (bufx != 0x08) && (bufx != 0x1b))\n    return;\n  bufx = buf[2];\n  if ((bufx != 0x08) && (bufx != 0x1b))\n    return;\n\n  imgdata.other.BatteryTemperature = (float)(SonySubstitution[buf[5]] - 32) / 1.8f;\n\n  return;\n}\n\nvoid CLASS process_Sony_0x940c(uchar *buf, ushort len)\n{\n  if ((imgdata.makernotes.sony.SonyCameraType != LIBRAW_SONY_ILCE) &&\n      (imgdata.makernotes.sony.SonyCameraType != LIBRAW_SONY_NEX))\n    return;\n  if (len <= 0x000a)\n    return;\n\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n  {\n    switch (SonySubstitution[buf[0x0008]])\n    {\n    case 1:\n    case 5:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n      break;\n    case 4:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n      break;\n    }\n  }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) | ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2(SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0009]]);\n  return;\n}\n\nvoid CLASS process_Sony_0x940e(uchar *buf, ushort len, unsigned id)\n{\n  if (((id == 286) || (id == 287) || (id == 294)) && (len >= 0x017e))\n  {\n    imgdata.makernotes.sony.AFMicroAdjValue = SonySubstitution[buf[0x017d]];\n  }\n  else if ((imgdata.makernotes.sony.SonyCameraType == LIBRAW_SONY_ILCA) && (len >= 0x0051))\n  {\n    imgdata.makernotes.sony.AFMicroAdjValue = SonySubstitution[buf[0x0050]];\n  }\n  else\n    return;\n\n  if (imgdata.makernotes.sony.AFMicroAdjValue != 0)\n    imgdata.makernotes.sony.AFMicroAdjOn = 1;\n}\n\nvoid CLASS parseSonyMakernotes(unsigned tag, unsigned type, unsigned len, unsigned dng_writer, uchar *&table_buf_0x0116,\n                               ushort &table_buf_0x0116_len, uchar *&table_buf_0x2010, ushort &table_buf_0x2010_len,\n                               uchar *&table_buf_0x9050, ushort &table_buf_0x9050_len, uchar *&table_buf_0x9400,\n                               ushort &table_buf_0x9400_len, uchar *&table_buf_0x9402, ushort &table_buf_0x9402_len,\n                               uchar *&table_buf_0x9403, ushort &table_buf_0x9403_len, uchar *&table_buf_0x9406,\n                               ushort &table_buf_0x9406_len, uchar *&table_buf_0x940c, ushort &table_buf_0x940c_len,\n                               uchar *&table_buf_0x940e, ushort &table_buf_0x940e_len)\n{\n\n  ushort lid;\n  uchar *table_buf;\n\n  if (tag == 0xb001) // Sony ModelID\n  {\n    unique_id = get2();\n    setSonyBodyFeatures(unique_id);\n\n    if (table_buf_0x0116_len)\n    {\n      process_Sony_0x0116(table_buf_0x0116, table_buf_0x0116_len, unique_id);\n      free(table_buf_0x0116);\n      table_buf_0x0116_len = 0;\n    }\n\n    if (table_buf_0x2010_len)\n    {\n      process_Sony_0x2010(table_buf_0x2010, table_buf_0x2010_len);\n      free(table_buf_0x2010);\n      table_buf_0x2010_len = 0;\n    }\n\n    if (table_buf_0x9050_len)\n    {\n      process_Sony_0x9050(table_buf_0x9050, table_buf_0x9050_len, unique_id);\n      free(table_buf_0x9050);\n      table_buf_0x9050_len = 0;\n    }\n\n    if (table_buf_0x9400_len)\n    {\n      process_Sony_0x9400(table_buf_0x9400, table_buf_0x9400_len, unique_id);\n      free(table_buf_0x9400);\n      table_buf_0x9400_len = 0;\n    }\n\n    if (table_buf_0x9402_len)\n    {\n      process_Sony_0x9402(table_buf_0x9402, table_buf_0x9402_len);\n      free(table_buf_0x9402);\n      table_buf_0x9402_len = 0;\n    }\n\n    if (table_buf_0x9403_len)\n    {\n      process_Sony_0x9403(table_buf_0x9403, table_buf_0x9403_len);\n      free(table_buf_0x9403);\n      table_buf_0x9403_len = 0;\n    }\n\n    if (table_buf_0x9406_len)\n    {\n      process_Sony_0x9406(table_buf_0x9406, table_buf_0x9406_len);\n      free(table_buf_0x9406);\n      table_buf_0x9406_len = 0;\n    }\n\n    if (table_buf_0x940c_len)\n    {\n      process_Sony_0x940c(table_buf_0x940c, table_buf_0x940c_len);\n      free(table_buf_0x940c);\n      table_buf_0x940c_len = 0;\n    }\n\n    if (table_buf_0x940e_len)\n    {\n      process_Sony_0x940e(table_buf_0x940e, table_buf_0x940e_len, unique_id);\n      free(table_buf_0x940e);\n      table_buf_0x940e_len = 0;\n    }\n  }\n\n  else if ((tag == 0x0010) && // CameraInfo\n           strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n           ((len == 368) ||  // a700\n            (len == 5478) || // a850, a900\n            (len == 5506) || // a200, a300, a350\n            (len == 6118) || // a230, a290, a330, a380, a390\n                             // a450, a500, a550, a560, a580\n                             // a33, a35, a55\n                             // NEX3, NEX5, NEX5C, NEXC3, VG10E\n            (len == 15360)))\n  {\n    table_buf = (uchar *)malloc(len);\n    fread(table_buf, len, 1, ifp);\n    if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n        memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n    {\n      switch (len)\n      {\n      case 368:\n      case 5478:\n        // a700, a850, a900: CameraInfo\n        if ((!dng_writer) ||\n            (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7])))\n        {\n          if (table_buf[0] | table_buf[3])\n            imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n          if (table_buf[2] | table_buf[5])\n            imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n          if (table_buf[4])\n            imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n          if (table_buf[4])\n            imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n          parseSonyLensFeatures(table_buf[1], table_buf[6]);\n\n          if (len == 5478)\n          {\n            imgdata.makernotes.sony.AFMicroAdjValue = table_buf[304] - 20;\n            imgdata.makernotes.sony.AFMicroAdjOn = (((table_buf[305] & 0x80) == 0x80) ? 1 : 0);\n            imgdata.makernotes.sony.AFMicroAdjRegisteredLenses = table_buf[305] & 0x7f;\n          }\n        }\n        break;\n      default:\n        // CameraInfo2 & 3\n        if ((!dng_writer) ||\n            (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6])))\n        {\n          if (table_buf[1] | table_buf[2])\n            imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n          if (table_buf[3] | table_buf[4])\n            imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n          if (table_buf[5])\n            imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n          if (table_buf[6])\n            imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n          parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        }\n      }\n    }\n    free(table_buf);\n  }\n\n  else if ((!dng_writer) && (tag == 0x0020) && // WBInfoA100, needs 0xb028 processing\n           !strncasecmp(model, \"DSLR-A100\", 9))\n  {\n    fseek(ifp, 0x49dc, SEEK_CUR);\n    stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n  }\n\n  else if (tag == 0x0104)\n  {\n    imgdata.other.FlashEC = getreal(type);\n  }\n\n  else if (tag == 0x0105) // Teleconverter\n  {\n    imgdata.lens.makernotes.TeleconverterID = get2();\n  }\n\n  else if (tag == 0x0114 && len < 256000) // CameraSettings\n  {\n    table_buf = (uchar *)malloc(len);\n    fread(table_buf, len, 1, ifp);\n    switch (len)\n    {\n    case 280:\n    case 364:\n    case 332:\n      // CameraSettings and CameraSettings2 are big endian\n      if (table_buf[2] | table_buf[3])\n      {\n        lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n        imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n      }\n      break;\n    case 1536:\n    case 2048:\n      // CameraSettings3 are little endian\n      parseSonyLensType2(table_buf[1016], table_buf[1015]);\n      if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n      {\n        switch (table_buf[153])\n        {\n        case 16:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n          break;\n        case 17:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n          break;\n        }\n      }\n      break;\n    }\n    free(table_buf);\n  }\n\n  else if ((tag == 0x3000) && (len < 256000))\n  {\n    uchar *table_buf_0x3000;\n    table_buf_0x3000 = (uchar *)malloc(len);\n    fread(table_buf_0x3000, len, 1, ifp);\n    for (int i = 0; i < 20; i++)\n      imgdata.makernotes.sony.SonyDateTime[i] = table_buf_0x3000[6 + i];\n  }\n\n  else if (tag == 0x0116 && len < 256000)\n  {\n    table_buf_0x0116 = (uchar *)malloc(len);\n    table_buf_0x0116_len = len;\n    fread(table_buf_0x0116, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x0116(table_buf_0x0116, table_buf_0x0116_len, imgdata.lens.makernotes.CamID);\n      free(table_buf_0x0116);\n      table_buf_0x0116_len = 0;\n    }\n  }\n\n  else if (tag == 0x2010 && len < 256000)\n  {\n    table_buf_0x2010 = (uchar *)malloc(len);\n    table_buf_0x2010_len = len;\n    fread(table_buf_0x2010, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x2010(table_buf_0x2010, table_buf_0x2010_len);\n      free(table_buf_0x2010);\n      table_buf_0x2010_len = 0;\n    }\n  }\n\n  else if (tag == 0x201a)\n  {\n    imgdata.makernotes.sony.ElectronicFrontCurtainShutter = get4();\n  }\n\n  else if (tag == 0x201b)\n  {\n    uchar uc;\n    fread(&uc, 1, 1, ifp);\n    imgdata.shootinginfo.FocusMode = (short)uc;\n  }\n\n  else if (tag == 0x202c)\n  {\n    imgdata.makernotes.sony.MeteringMode2 = get2();\n  }\n\n  else if (tag == 0x9050 && len < 256000) // little endian\n  {\n    table_buf_0x9050 = (uchar *)malloc(len);\n    table_buf_0x9050_len = len;\n    fread(table_buf_0x9050, len, 1, ifp);\n\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9050(table_buf_0x9050, table_buf_0x9050_len, imgdata.lens.makernotes.CamID);\n      free(table_buf_0x9050);\n      table_buf_0x9050_len = 0;\n    }\n  }\n\n  else if (tag == 0x9400 && len < 256000)\n  {\n    table_buf_0x9400 = (uchar *)malloc(len);\n    table_buf_0x9400_len = len;\n    fread(table_buf_0x9400, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9400(table_buf_0x9400, table_buf_0x9400_len, unique_id);\n      free(table_buf_0x9400);\n      table_buf_0x9400_len = 0;\n    }\n  }\n\n  else if (tag == 0x9402 && len < 256000)\n  {\n    table_buf_0x9402 = (uchar *)malloc(len);\n    table_buf_0x9402_len = len;\n    fread(table_buf_0x9402, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9402(table_buf_0x9402, table_buf_0x9402_len);\n      free(table_buf_0x9402);\n      table_buf_0x9402_len = 0;\n    }\n  }\n\n  else if (tag == 0x9403 && len < 256000)\n  {\n    table_buf_0x9403 = (uchar *)malloc(len);\n    table_buf_0x9403_len = len;\n    fread(table_buf_0x9403, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9403(table_buf_0x9403, table_buf_0x9403_len);\n      free(table_buf_0x9403);\n      table_buf_0x9403_len = 0;\n    }\n  }\n\n  else if ((tag == 0x9405) && (len < 256000) && (len > 0x64))\n  {\n    uchar *table_buf_0x9405;\n    table_buf_0x9405 = (uchar *)malloc(len);\n    short bufx = table_buf_0x9405[0x0];\n    fread(table_buf_0x9405, len, 1, ifp);\n    if (imgdata.other.real_ISO < 0.1f)\n    {\n      if ((bufx == 0x25) || (bufx == 0x3a) || (bufx == 0x76) || (bufx == 0x7e) || (bufx == 0x8b) || (bufx == 0x9a) ||\n          (bufx == 0xb3) || (bufx == 0xe1))\n      {\n        uchar s[2];\n        s[0] = SonySubstitution[table_buf_0x9405[0x04]];\n        s[1] = SonySubstitution[table_buf_0x9405[0x05]];\n        imgdata.other.real_ISO = 100.0f * libraw_powf64l(2.0f, (16 - ((float)sget2(s)) / 256.0f));\n      }\n    }\n    free(table_buf_0x9405);\n  }\n\n  else if (tag == 0x9406 && len < 256000)\n  {\n    table_buf_0x9406 = (uchar *)malloc(len);\n    table_buf_0x9406_len = len;\n    fread(table_buf_0x9406, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x9406(table_buf_0x9406, table_buf_0x9406_len);\n      free(table_buf_0x9406);\n      table_buf_0x9406_len = 0;\n    }\n  }\n\n  else if (tag == 0x940c && len < 256000)\n  {\n    table_buf_0x940c = (uchar *)malloc(len);\n    table_buf_0x940c_len = len;\n    fread(table_buf_0x940c, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x940c(table_buf_0x940c, table_buf_0x940c_len);\n      free(table_buf_0x940c);\n      table_buf_0x940c_len = 0;\n    }\n  }\n\n  else if (tag == 0x940e && len < 256000)\n  {\n    table_buf_0x940e = (uchar *)malloc(len);\n    table_buf_0x940e_len = len;\n    fread(table_buf_0x940e, len, 1, ifp);\n    if (imgdata.lens.makernotes.CamID)\n    {\n      process_Sony_0x940e(table_buf_0x940e, table_buf_0x940e_len, imgdata.lens.makernotes.CamID);\n      free(table_buf_0x940e);\n      table_buf_0x940e_len = 0;\n    }\n  }\n\n  else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n  {\n    imgdata.lens.makernotes.LensID = get4();\n    if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n    {\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    }\n\n    else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n             (imgdata.lens.makernotes.LensID != 0xFF00))\n    {\n      imgdata.lens.makernotes.AdapterID = 0xEF00;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    }\n    if (tag == 0x010c)\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n  }\n\n  else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n  {\n    table_buf = (uchar *)malloc(len);\n    fread(table_buf, len, 1, ifp);\n    if ((!dng_writer) ||\n        (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6])))\n    {\n      if (table_buf[1] | table_buf[2])\n        imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n      if (table_buf[3] | table_buf[4])\n        imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n      if (table_buf[5])\n        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n      if (table_buf[6])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n      parseSonyLensFeatures(table_buf[0], table_buf[7]);\n    }\n    free(table_buf);\n  }\n\n  else if ((tag == 0xb02b) && !imgdata.sizes.raw_crop.cwidth && (len == 2))\n  {\n    imgdata.sizes.raw_crop.cheight = get4();\n    imgdata.sizes.raw_crop.cwidth = get4();\n  }\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n  unsigned typeCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x0116;\n  ushort table_buf_0x0116_len = 0;\n  uchar *table_buf_0x2010;\n  ushort table_buf_0x2010_len = 0;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_len = 0;\n  uchar *table_buf_0x9400;\n  ushort table_buf_0x9400_len = 0;\n  uchar *table_buf_0x9402;\n  ushort table_buf_0x9402_len = 0;\n  uchar *table_buf_0x9403;\n  ushort table_buf_0x9403_len = 0;\n  uchar *table_buf_0x9406;\n  ushort table_buf_0x9406_len = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_len = 0;\n  uchar *table_buf_0x940e;\n  ushort table_buf_0x940e_len = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n\n  /*\n    printf(\"===>>buf: 0x\");\n    for (int i = 0; i < sizeof buf; i ++) {\n          printf(\"%02x\", buf[i]);\n    }\n    putchar('\\n');\n  */\n\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if (len > 8 && pos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    tag |= uptag << 16;\n    if (len > 100 * 1024 * 1024)\n      goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        if (type != 4)\n        {\n          CanonCameraInfo = (uchar *)malloc(MAX(16, len));\n          fread(CanonCameraInfo, len, 1, ifp);\n        }\n        else\n        {\n          CanonCameraInfo = (uchar *)malloc(MAX(16, len * 4));\n          fread(CanonCameraInfo, len, 4, ifp);\n        }\n        lenCanonCameraInfo = len;\n        typeCanonCameraInfo = type;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        unique_id = setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo, typeCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes(tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n\n      if ((tag == 0x0320) && (type == 9) && (len == 1) && !strncasecmp(make, \"Leica Camera AG\", 15) &&\n          !strncmp(buf, \"LEICA\", 5) && (buf[5] == 0) && (buf[6] == 0) && (buf[7] == 0))\n        imgdata.other.CameraTemperature = getreal(type);\n\n      if (tag == 0x34003402)\n        imgdata.other.CameraTemperature = getreal(type);\n\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n        imgdata.color.dng_color[ind].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n      }\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x1d) // serial number\n        while ((c = fgetc(ifp)) && c != EOF)\n        {\n          if ((!custom_serial) && (!isdigit(c)))\n          {\n            if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n            {\n              custom_serial = 34;\n            }\n            else\n            {\n              custom_serial = 96;\n            }\n          }\n          serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n        }\n      else if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        imgdata.makernotes.nikon.NEFCompression = i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0097)\n      {\n        for (i = 0; i < 4; i++)\n          ver97 = ver97 * 10 + fgetc(ifp) - '0';\n        if (ver97 == 601) // Coolpix A\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n\n      else if (tag == 0xa7) // shutter count\n      {\n        NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n        if ((NikonLensDataVersion > 200) && lenNikonLensData)\n        {\n          if (custom_serial)\n          {\n            ci = xlat[0][custom_serial];\n          }\n          else\n          {\n            ci = xlat[0][serial & 0xff];\n          }\n          cj = xlat[1][NikonKey];\n          ck = 0x60;\n          for (i = 0; i < lenNikonLensData; i++)\n            table_buf[i] ^= (cj += ci * ck++);\n          processNikonLensData(table_buf, lenNikonLensData);\n          lenNikonLensData = 0;\n          free(table_buf);\n        }\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n\n      else if (tag == 0x00b0)\n      {\n        get4(); // ME tag version, 4 symbols\n        imgdata.makernotes.nikon.ExposureMode = get4();\n        imgdata.makernotes.nikon.nMEshots = get4();\n        imgdata.makernotes.nikon.MEgainOn = get4();\n      }\n\n      else if (tag == 0x00b9)\n      {\n        uchar uc;\n        int8_t sc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTune = uc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTuneIndex = uc;\n        fread(&sc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTuneAdj = sc;\n      }\n\n      else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc, 1, 1, ifp);\n        iso_speed = (int)(100.0 * libraw_powf64l(2.0, (double)(cc) / 12.0 - 5.0));\n        break;\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      short nWB, tWB;\n      int SubDirOffsetValid = strncmp(model, \"E-300\", 5) && strncmp(model, \"E-330\", 5) && strncmp(model, \"E-400\", 5) &&\n                              strncmp(model, \"E-500\", 5) && strncmp(model, \"E-1\", 3);\n\n      if ((tag == 0x2010) || (tag == 0x2020) || (tag == 0x2030) || (tag == 0x2031) || (tag == 0x2040) ||\n          (tag == 0x2050) || (tag == 0x3000))\n      {\n        fseek(ifp, save - 4, SEEK_SET);\n        fseek(ifp, base + get4(), SEEK_SET);\n        parse_makernote_0xc634(base, tag, dng_writer);\n      }\n      if (!SubDirOffsetValid && ((len > 4) || (((type == 3) || (type == 8)) && (len > 2)) ||\n                                 (((type == 4) || (type == 9)) && (len > 1)) || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n      if ((tag >= 0x20400101) && (tag <= 0x20400111))\n      {\n        if ((tag == 0x20400101) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n        {\n          int i;\n          for (i = 0; i < 64; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =\n                imgdata.color.WB_Coeffs[i][3] = 0x100;\n          }\n          for (i = 64; i < 256; i++)\n          {\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n          }\n        }\n        nWB = tag - 0x20400101;\n        tWB = Oly_wb_list2[nWB << 1];\n        ushort CT = Oly_wb_list2[(nWB << 1) | 1];\n        int wb[4];\n        wb[0] = get2();\n        wb[2] = get2();\n        if (tWB != 0x100)\n        {\n          imgdata.color.WB_Coeffs[tWB][0] = wb[0];\n          imgdata.color.WB_Coeffs[tWB][2] = wb[2];\n        }\n        if (CT)\n        {\n          imgdata.color.WBCT_Coeffs[nWB - 1][0] = CT;\n          imgdata.color.WBCT_Coeffs[nWB - 1][1] = wb[0];\n          imgdata.color.WBCT_Coeffs[nWB - 1][3] = wb[2];\n        }\n        if (len == 4)\n        {\n          wb[1] = get2();\n          wb[3] = get2();\n          if (tWB != 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][1] = wb[1];\n            imgdata.color.WB_Coeffs[tWB][3] = wb[3];\n          }\n          if (CT)\n          {\n            imgdata.color.WBCT_Coeffs[nWB - 1][2] = wb[1];\n            imgdata.color.WBCT_Coeffs[nWB - 1][4] = wb[3];\n          }\n        }\n      }\n      else if ((tag >= 0x20400112) && (tag <= 0x2040011e))\n      {\n        nWB = tag - 0x20400112;\n        int wbG = get2();\n        tWB = Oly_wb_list2[nWB << 1];\n        if (nWB)\n          imgdata.color.WBCT_Coeffs[nWB - 1][2] = imgdata.color.WBCT_Coeffs[nWB - 1][4] = wbG;\n        if (tWB != 0x100)\n          imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = wbG;\n      }\n      else if (tag == 0x2040011f)\n      {\n        int wbG = get2();\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0])\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = wbG;\n        FORC4 if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][0])\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][3] =\n            wbG;\n      }\n      else if (tag == 0x20400121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        if (len == 4)\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n        }\n      }\n      else if ((tag == 0x30000110) && strcmp(software, \"v757-71\"))\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][2] = get2();\n        if (len == 2)\n        {\n          for (int i = 0; i < 256; i++)\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n        }\n      }\n      else if ((((tag >= 0x30000120) && (tag <= 0x30000124)) || ((tag >= 0x30000130) && (tag <= 0x30000133))) &&\n               strcmp(software, \"v757-71\"))\n      {\n        int wb_ind;\n        if (tag <= 0x30000124)\n          wb_ind = tag - 0x30000120;\n        else\n          wb_ind = tag - 0x30000130 + 5;\n        imgdata.color.WB_Coeffs[Oly_wb_list1[wb_ind]][0] = get2();\n        imgdata.color.WB_Coeffs[Oly_wb_list1[wb_ind]][2] = get2();\n      }\n      else\n      {\n        switch (tag)\n        {\n        case 0x0207:\n        case 0x20100100:\n        {\n          uchar sOlyID[8];\n          fread(sOlyID, MIN(len, 7), 1, ifp);\n          sOlyID[7] = 0;\n          OlyID = sOlyID[0];\n          i = 1;\n          while (i < 7 && sOlyID[i])\n          {\n            OlyID = OlyID << 8 | sOlyID[i];\n            i++;\n          }\n          setOlympusBodyFeatures(OlyID);\n        }\n        break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, getreal(type) / 2);\n          break;\n        case 0x20100102:\n          stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n          break;\n        case 0x20100201:\n          imgdata.lens.makernotes.LensID = (unsigned long long)fgetc(ifp) << 16 |\n                                           (unsigned long long)(fgetc(ifp), fgetc(ifp)) << 8 |\n                                           (unsigned long long)fgetc(ifp);\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n          }\n          break;\n        case 0x20100202:\n          if ((!imgdata.lens.LensSerial[0]))\n            stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          break;\n        case 0x20200306:\n        {\n          uchar uc;\n          fread(&uc, 1, 1, ifp);\n          imgdata.makernotes.olympus.AFFineTune = uc;\n        }\n        break;\n        case 0x20200307:\n          FORC3 imgdata.makernotes.olympus.AFFineTuneAdj[c] = get2();\n          break;\n        case 0x20200401:\n          imgdata.other.FlashEC = getreal(type);\n          break;\n        case 0x1007:\n          imgdata.other.SensorTemperature = (float)get2();\n          break;\n        case 0x1008:\n          imgdata.other.LensTemperature = (float)get2();\n          break;\n        case 0x20401306:\n        {\n          int temp = get2();\n          if ((temp != 0) && (temp != 100))\n          {\n            if (temp < 61)\n              imgdata.other.CameraTemperature = (float)temp;\n            else\n              imgdata.other.CameraTemperature = (float)(temp - 32) / 1.8f;\n            if ((OlyID == 0x4434353933ULL) && // TG-5\n                (imgdata.other.exifAmbientTemperature > -273.15f))\n              imgdata.other.CameraTemperature += imgdata.other.exifAmbientTemperature;\n          }\n        }\n        break;\n        case 0x20501500:\n          if (OlyID != 0x0ULL)\n          {\n            short temp = get2();\n            if ((OlyID == 0x4434303430ULL) || // E-1\n                (OlyID == 0x5330303336ULL) || // E-M5\n                (len != 1))\n              imgdata.other.SensorTemperature = (float)temp;\n            else if ((temp != -32768) && (temp != 0))\n            {\n              if (temp > 199)\n                imgdata.other.SensorTemperature = 86.474958f - 0.120228f * (float)temp;\n              else\n                imgdata.other.SensorTemperature = (float)temp;\n            }\n          }\n          break;\n        }\n      }\n    skip_Oly_broken_tags:;\n    }\n\n    else if (!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x000d)\n      {\n        imgdata.makernotes.pentax.FocusMode = get2();\n      }\n      else if (tag == 0x000e)\n      {\n        imgdata.makernotes.pentax.AFPointSelected = get2();\n      }\n      else if (tag == 0x000f)\n      {\n        imgdata.makernotes.pentax.AFPointsInFocus = getint(type);\n      }\n      else if (tag == 0x0010)\n      {\n        imgdata.makernotes.pentax.FocusPosition = get2();\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x0034)\n      {\n        uchar uc;\n        FORC4\n        {\n          fread(&uc, 1, 1, ifp);\n          imgdata.makernotes.pentax.DriveMode[c] = uc;\n        }\n      }\n      else if (tag == 0x0038)\n      {\n        imgdata.sizes.raw_crop.cleft = get2();\n        imgdata.sizes.raw_crop.ctop = get2();\n      }\n      else if (tag == 0x0039)\n      {\n        imgdata.sizes.raw_crop.cwidth = get2();\n        imgdata.sizes.raw_crop.cheight = get2();\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x0047)\n      {\n        imgdata.other.CameraTemperature = (float)fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x0072)\n      {\n        imgdata.makernotes.pentax.AFAdjustment = get2();\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if ((tag >= 0x020d) && (tag <= 0x0214))\n      {\n        FORC4 imgdata.color.WB_Coeffs[Pentax_wb_list1[tag - 0x020d]][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        int wb_ind;\n        getc(ifp);\n        for (int wb_cnt = 0; wb_cnt < nPentax_wb_list2; wb_cnt++)\n        {\n          wb_ind = getc(ifp);\n          if (wb_ind < nPentax_wb_list2)\n            FORC4 imgdata.color.WB_Coeffs[Pentax_wb_list2[wb_ind]][c ^ (c >> 1)] = get2();\n        }\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 12, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        imgdata.lens.makernotes.CamID = unique_id = get4();\n      }\n      else if (tag == 0x0043)\n      {\n        int temp = get4();\n        if (temp)\n        {\n          imgdata.other.CameraTemperature = (float)temp;\n          if (get4() == 10)\n            imgdata.other.CameraTemperature /= 10.0f;\n        }\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      parseSonyMakernotes(tag, type, len, AdobeDNG, table_buf_0x0116, table_buf_0x0116_len, table_buf_0x2010,\n                          table_buf_0x2010_len, table_buf_0x9050, table_buf_0x9050_len, table_buf_0x9400,\n                          table_buf_0x9400_len, table_buf_0x9402, table_buf_0x9402_len, table_buf_0x9403,\n                          table_buf_0x9403_len, table_buf_0x9406, table_buf_0x9406_len, table_buf_0x940c,\n                          table_buf_0x940c_len, table_buf_0x940e, table_buf_0x940e_len);\n    }\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{ /*placeholder */\n}\n#endif\n\nvoid CLASS parse_makernote(int base, int uptag)\n{\n  unsigned offset = 0, entries, tag, type, len, save, c;\n  unsigned ver97 = 0, serial = 0, i, wbi = 0, wb[4] = {0, 0, 0, 0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder = order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n  unsigned typeCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x0116;\n  ushort table_buf_0x0116_len = 0;\n  uchar *table_buf_0x2010;\n  ushort table_buf_0x2010_len = 0;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_len = 0;\n  uchar *table_buf_0x9400;\n  ushort table_buf_0x9400_len = 0;\n  uchar *table_buf_0x9402;\n  ushort table_buf_0x9402_len = 0;\n  uchar *table_buf_0x9403;\n  ushort table_buf_0x9403_len = 0;\n  uchar *table_buf_0x9406;\n  ushort table_buf_0x9406_len = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_len = 0;\n  uchar *table_buf_0x940e;\n  ushort table_buf_0x940e_len = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n  /*\n     The MakerNote might have its own TIFF header (possibly with\n     its own byte-order!), or it might just be a table.\n   */\n  if (!strncmp(make, \"Nokia\", 5))\n    return;\n  fread(buf, 1, 10, ifp);\n\n  /*\n    printf(\"===>>buf: 0x\");\n    for (int i = 0; i < sizeof buf; i ++) {\n          printf(\"%02x\", buf[i]);\n    }\n    putchar('\\n');\n  */\n\n  if (!strncmp(buf, \"KDK\", 3) || /* these aren't TIFF tables */\n      !strncmp(buf, \"VER\", 3) || !strncmp(buf, \"IIII\", 4) || !strncmp(buf, \"MMMM\", 4))\n    return;\n  if (!strncmp(buf, \"KC\", 2) || /* Konica KD-400Z, KD-510Z */\n      !strncmp(buf, \"MLY\", 3))\n  { /* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i = ftell(ifp)) < data_offset && i < 16384)\n    {\n      wb[0] = wb[2];\n      wb[2] = wb[1];\n      wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n        FORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \"))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if (!strncmp(make, \"SAMSUNG\", 7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n  {\n    if (!strncmp(model, \"M8\", 2) || !strncasecmp(model, \"Leica M8\", 8) || !strncasecmp(model, \"LEICA X\", 7))\n    {\n      base = ftell(ifp) - 8;\n    }\n    else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n    {\n      base = 0;\n    }\n    else if (!strncmp(model, \"M9\", 2) || !strncasecmp(model, \"Leica M9\", 8) || !strncasecmp(model, \"M Monochrom\", 11) ||\n             !strncasecmp(model, \"Leica M Monochrom\", 11))\n    {\n      if (!uptag)\n      {\n        base = ftell(ifp) - 10;\n        fseek(ifp, 8, SEEK_CUR);\n      }\n      else if (uptag == 0x3400)\n      {\n        fseek(ifp, 10, SEEK_CUR);\n        base += 10;\n      }\n    }\n    else if (!strncasecmp(model, \"LEICA T\", 7))\n    {\n      base = ftell(ifp) - 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (!strncasecmp(model, \"LEICA SL\", 8))\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n#endif\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if (len > 8 && _pos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (!strncasecmp(model, \"KODAK P880\", 10) || !strncasecmp(model, \"KODAK P850\", 10) ||\n        !strncasecmp(model, \"KODAK P712\", 10))\n    {\n      if (tag == 0xf90b)\n      {\n        imgdata.makernotes.kodak.clipBlack = get2();\n      }\n      else if (tag == 0xf90c)\n      {\n        imgdata.makernotes.kodak.clipWhite = get2();\n      }\n    }\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        if (type != 4)\n        {\n          CanonCameraInfo = (uchar *)malloc(MAX(16, len));\n          fread(CanonCameraInfo, len, 1, ifp);\n        }\n        else\n        {\n          CanonCameraInfo = (uchar *)malloc(MAX(16, len * 4));\n          fread(CanonCameraInfo, len, 4, ifp);\n        }\n        lenCanonCameraInfo = len;\n        typeCanonCameraInfo = type;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        unique_id = setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo, typeCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n    {\n      if (tag == 0x0010)\n      {\n        char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n        char *words[4];\n        char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n        int year, nwords, ynum_len;\n        unsigned c;\n        stmread(FujiSerial, len, ifp);\n        nwords = getwords(FujiSerial, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n        for (int i = 0; i < nwords; i++)\n        {\n          mm[2] = dd[2] = 0;\n          if (strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)\n            if (i == 0)\n              strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s\", imgdata.shootinginfo.InternalBodySerial, words[i]);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          else\n          {\n            strncpy(dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 14, 2);\n            strncpy(mm, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 16, 2);\n            strncpy(yy, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18, 2);\n            year = (yy[0] - '0') * 10 + (yy[1] - '0');\n            if (year < 70)\n              year += 2000;\n            else\n              year += 1900;\n\n            ynum_len = (int)strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18;\n            strncpy(ynum, words[i], ynum_len);\n            ynum[ynum_len] = 0;\n            for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, \"%2x\", &c); j += 2)\n              ystr[j / 2] = c;\n            ystr[ynum_len / 2 + 1] = 0;\n            strcpy(model2, ystr);\n\n            if (i == 0)\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n              if (nwords == 1)\n                snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s\",\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12, ystr,\n                         year, mm, dd);\n\n              else\n                snprintf(tbuf, sizeof(tbuf), \"%s %d:%s:%s %s\", ystr, year, mm, dd,\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s %s\", imgdata.shootinginfo.InternalBodySerial, ystr, year, mm,\n                       dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          }\n        }\n      }\n      else\n        parseFujiMakernotes(tag, type);\n    }\n\n    else if (!strncasecmp(model, \"Hasselblad X1D\", 14) || !strncasecmp(model, \"Hasselblad H6D\", 14) ||\n             !strncasecmp(model, \"Hasselblad A6D\", 14))\n    {\n      if (tag == 0x0045)\n      {\n        imgdata.makernotes.hasselblad.BaseISO = get4();\n      }\n      else if (tag == 0x0046)\n      {\n        imgdata.makernotes.hasselblad.Gain = getreal(type);\n      }\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n        imgdata.color.dng_color[ind].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n      }\n\n      if (tag == 0x34003402)\n        imgdata.other.CameraTemperature = getreal(type);\n\n      if ((tag == 0x0320) && (type == 9) && (len == 1) && !strncasecmp(make, \"Leica Camera AG\", 15) &&\n          !strncmp(buf, \"LEICA\", 5) && (buf[5] == 0) && (buf[6] == 0) && (buf[7] == 0))\n        imgdata.other.CameraTemperature = getreal(type);\n\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0012)\n      {\n        char a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n          imgdata.other.FlashEC = (float)(a * b) / (float)c;\n      }\n      else if (tag == 0x003b) // all 1s for regular exposures\n      {\n        imgdata.makernotes.nikon.ME_WB[0] = getreal(type);\n        imgdata.makernotes.nikon.ME_WB[2] = getreal(type);\n        imgdata.makernotes.nikon.ME_WB[1] = getreal(type);\n        imgdata.makernotes.nikon.ME_WB[3] = getreal(type);\n      }\n      else if (tag == 0x0045)\n      {\n        imgdata.sizes.raw_crop.cleft = get2();\n        imgdata.sizes.raw_crop.ctop = get2();\n        imgdata.sizes.raw_crop.cwidth = get2();\n        imgdata.sizes.raw_crop.cheight = get2();\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093) // Nikon compression\n      {\n        imgdata.makernotes.nikon.NEFCompression = i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData > 0)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n      else if (tag == 0x00a0)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n      else if (tag == 0x00b0)\n      {\n        get4(); // ME tag version, 4 symbols\n        imgdata.makernotes.nikon.ExposureMode = get4();\n        imgdata.makernotes.nikon.nMEshots = get4();\n        imgdata.makernotes.nikon.MEgainOn = get4();\n      }\n      else if (tag == 0x00b9)\n      {\n        uchar uc;\n        int8_t sc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTune = uc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTuneIndex = uc;\n        fread(&sc, 1, 1, ifp);\n        imgdata.makernotes.nikon.AFFineTuneAdj = sc;\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      switch (tag)\n      {\n      case 0x0404:\n      case 0x101a:\n      case 0x20100101:\n        if (!imgdata.shootinginfo.BodySerial[0])\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n      case 0x20100102:\n        if (!imgdata.shootinginfo.InternalBodySerial[0])\n          stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, getreal(type) / 2);\n        break;\n      case 0x20400612:\n      case 0x30000612:\n        imgdata.sizes.raw_crop.cleft = get2();\n        break;\n      case 0x20400613:\n      case 0x30000613:\n        imgdata.sizes.raw_crop.ctop = get2();\n        break;\n      case 0x20400614:\n      case 0x30000614:\n        imgdata.sizes.raw_crop.cwidth = get2();\n        break;\n      case 0x20400615:\n      case 0x30000615:\n        imgdata.sizes.raw_crop.cheight = get2();\n        break;\n      case 0x20401112:\n        imgdata.makernotes.olympus.OlympusCropID = get2();\n        break;\n      case 0x20401113:\n        FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n        break;\n      case 0x20100201:\n      {\n        unsigned long long oly_lensid[3];\n        oly_lensid[0] = fgetc(ifp);\n        fgetc(ifp);\n        oly_lensid[1] = fgetc(ifp);\n        oly_lensid[2] = fgetc(ifp);\n        imgdata.lens.makernotes.LensID = (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n      }\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      case 0x1007:\n        imgdata.other.SensorTemperature = (float)get2();\n        break;\n      case 0x1008:\n        imgdata.other.LensTemperature = (float)get2();\n        break;\n      case 0x20401306:\n      {\n        int temp = get2();\n        if ((temp != 0) && (temp != 100))\n        {\n          if (temp < 61)\n            imgdata.other.CameraTemperature = (float)temp;\n          else\n            imgdata.other.CameraTemperature = (float)(temp - 32) / 1.8f;\n          if ((OlyID == 0x4434353933ULL) && // TG-5\n              (imgdata.other.exifAmbientTemperature > -273.15f))\n            imgdata.other.CameraTemperature += imgdata.other.exifAmbientTemperature;\n        }\n      }\n      break;\n      case 0x20501500:\n        if (OlyID != 0x0ULL)\n        {\n          short temp = get2();\n          if ((OlyID == 0x4434303430ULL) || // E-1\n              (OlyID == 0x5330303336ULL) || // E-M5\n              (len != 1))\n            imgdata.other.SensorTemperature = (float)temp;\n          else if ((temp != -32768) && (temp != 0))\n          {\n            if (temp > 199)\n              imgdata.other.SensorTemperature = 86.474958f - 0.120228f * (float)temp;\n            else\n              imgdata.other.SensorTemperature = (float)temp;\n          }\n        }\n        break;\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) && !strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        char buffer[17];\n        int count = 0;\n        fread(buffer, 16, 1, ifp);\n        buffer[16] = 0;\n        for (int i = 0; i < 16; i++)\n        {\n          //    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n          if ((isspace(buffer[i])) || (buffer[i] == 0x2D) || (isalnum(buffer[i])))\n            count++;\n        }\n        if (count == 16)\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%8s\", buffer + 8);\n          buffer[8] = 0;\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n        }\n        else\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10],\n                  buffer[11]);\n        }\n      }\n      else if ((tag == 0x1001) && (type == 3))\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n        imgdata.lens.makernotes.LensID = -1;\n        imgdata.lens.makernotes.FocalType = 1;\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n    }\n\n    else if (!strncmp(make, \"RICOH\", 5) && strncmp(model, \"PENTAX\", 6))\n    {\n      if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n      {\n        char buffer[9];\n        buffer[8] = 0;\n        fread(buffer, 8, 1, ifp);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n\n      else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n      {\n        short ntags, cur_tag;\n        fseek(ifp, 20, SEEK_CUR);\n        ntags = get2();\n        cur_tag = get2();\n        while (cur_tag != 0x002c)\n        {\n          fseek(ifp, 10, SEEK_CUR);\n          cur_tag = get2();\n        }\n        fseek(ifp, 6, SEEK_CUR);\n        fseek(ifp, get4() + 20, SEEK_SET);\n        stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n        get2();\n        imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n        switch (imgdata.lens.makernotes.LensID)\n        {\n        case 1:\n        case 2:\n        case 3:\n        case 5:\n        case 6:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n          break;\n        case 8:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n          imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n          imgdata.lens.makernotes.LensID = -1;\n          break;\n        default:\n          imgdata.lens.makernotes.LensID = -1;\n        }\n        fseek(ifp, 17, SEEK_CUR);\n        stread(imgdata.lens.LensSerial, 12, ifp);\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n              (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x000d)\n      {\n        imgdata.makernotes.pentax.FocusMode = get2();\n      }\n      else if (tag == 0x000e)\n      {\n        imgdata.makernotes.pentax.AFPointSelected = get2();\n      }\n      else if (tag == 0x000f)\n      {\n        imgdata.makernotes.pentax.AFPointsInFocus = getint(type);\n      }\n      else if (tag == 0x0010)\n      {\n        imgdata.makernotes.pentax.FocusPosition = get2();\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x0034)\n      {\n        uchar uc;\n        FORC4\n        {\n          fread(&uc, 1, 1, ifp);\n          imgdata.makernotes.pentax.DriveMode[c] = uc;\n        }\n      }\n      else if (tag == 0x0038)\n      {\n        imgdata.sizes.raw_crop.cleft = get2();\n        imgdata.sizes.raw_crop.ctop = get2();\n      }\n      else if (tag == 0x0039)\n      {\n        imgdata.sizes.raw_crop.cwidth = get2();\n        imgdata.sizes.raw_crop.cheight = get2();\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x0047)\n      {\n        imgdata.other.CameraTemperature = (float)fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x0072)\n      {\n        imgdata.makernotes.pentax.AFAdjustment = get2();\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if ((tag >= 0x020d) && (tag <= 0x0214))\n      {\n        FORC4 imgdata.color.WB_Coeffs[Pentax_wb_list1[tag - 0x020d]][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        int wb_ind;\n        getc(ifp);\n        for (int wb_cnt = 0; wb_cnt < nPentax_wb_list2; wb_cnt++)\n        {\n          wb_ind = getc(ifp);\n          if (wb_ind < nPentax_wb_list2)\n            FORC4 imgdata.color.WB_Coeffs[Pentax_wb_list2[wb_ind]][c ^ (c >> 1)] = get2();\n        }\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 2, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        unique_id = imgdata.lens.makernotes.CamID = get4();\n      }\n      else if (tag == 0x0043)\n      {\n        int temp = get4();\n        if (temp)\n        {\n          imgdata.other.CameraTemperature = (float)temp;\n          if (get4() == 10)\n            imgdata.other.CameraTemperature /= 10.0f;\n        }\n      }\n      else if (tag == 0xa002)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      parseSonyMakernotes(tag, type, len, nonDNG, table_buf_0x0116, table_buf_0x0116_len, table_buf_0x2010,\n                          table_buf_0x2010_len, table_buf_0x9050, table_buf_0x9050_len, table_buf_0x9400,\n                          table_buf_0x9400_len, table_buf_0x9402, table_buf_0x9402_len, table_buf_0x9403,\n                          table_buf_0x9403_len, table_buf_0x9406, table_buf_0x9406_len, table_buf_0x940c,\n                          table_buf_0x940c_len, table_buf_0x940e, table_buf_0x940e_len);\n    }\n\n    fseek(ifp, _pos, SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make, \"NIKON\") && !iso_speed)\n      iso_speed = (get2(), get2());\n    if (tag == 37 && strstr(make, \"NIKON\") && (!iso_speed || iso_speed == 65535))\n    {\n      unsigned char cc;\n      fread(&cc, 1, 1, ifp);\n      iso_speed = int(100.0 * libraw_powf64l(2.0f, float(cc) / 12.0 - 5.0));\n    }\n    if (tag == 4 && len > 26 && len < 35)\n    {\n      if ((i = (get4(), get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n        iso_speed = 50 * libraw_powf64l(2.0, i / 32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i = (get2(), get2())) != 0x7fff && !aperture)\n        aperture = libraw_powf64l(2.0, i / 64.0);\n#endif\n      if ((i = get2()) != 0xffff && !shutter)\n        shutter = libraw_powf64l(2.0, (short)i / -32.0);\n      wbi = (get2(), get2());\n      shot_order = (get2(), get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make, \"KONICA\", 6))\n    {\n      fseek(ifp, tag == 4 ? 140 : 160, SEEK_CUR);\n      switch (get2())\n      {\n      case 72:\n        flip = 0;\n        break;\n      case 76:\n        flip = 6;\n        break;\n      case 82:\n        flip = 5;\n        break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets(model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make, \"Canon\", 5))\n      fread(artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa)\n    {\n#if 0 /* Canon rotation data is handled by EXIF.Orientation */\n      for (c = i = 2; (ushort)c != 0xbbbb && i < len; i++)\n        c = c << 8 | fgetc(ifp);\n      while ((i += 4) < len - 5)\n        if (get4() == 257 && (i = len) && (c = (get4(), fgetc(ifp))) < 3)\n          flip = \"065\"[c] - '0';\n#endif\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n    if (!strncasecmp(make, \"Olympus\", 7))\n    {\n      short nWB, tWB;\n      if ((tag == 0x20300108) || (tag == 0x20310109))\n        imgdata.makernotes.olympus.ColorSpace = get2();\n\n      if ((tag == 0x20400101) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n      {\n        int i;\n        for (i = 0; i < 64; i++)\n          imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =\n              imgdata.color.WB_Coeffs[i][3] = 0x100;\n        for (i = 64; i < 256; i++)\n          imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n      }\n      if ((tag >= 0x20400101) && (tag <= 0x20400111))\n      {\n        nWB = tag - 0x20400101;\n        tWB = Oly_wb_list2[nWB << 1];\n        ushort CT = Oly_wb_list2[(nWB << 1) | 1];\n        int wb[4];\n        wb[0] = get2();\n        wb[2] = get2();\n        if (tWB != 0x100)\n        {\n          imgdata.color.WB_Coeffs[tWB][0] = wb[0];\n          imgdata.color.WB_Coeffs[tWB][2] = wb[2];\n        }\n        if (CT)\n        {\n          imgdata.color.WBCT_Coeffs[nWB - 1][0] = CT;\n          imgdata.color.WBCT_Coeffs[nWB - 1][1] = wb[0];\n          imgdata.color.WBCT_Coeffs[nWB - 1][3] = wb[2];\n        }\n        if (len == 4)\n        {\n          wb[1] = get2();\n          wb[3] = get2();\n          if (tWB != 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][1] = wb[1];\n            imgdata.color.WB_Coeffs[tWB][3] = wb[3];\n          }\n          if (CT)\n          {\n            imgdata.color.WBCT_Coeffs[nWB - 1][2] = wb[1];\n            imgdata.color.WBCT_Coeffs[nWB - 1][4] = wb[3];\n          }\n        }\n      }\n      if ((tag >= 0x20400112) && (tag <= 0x2040011e))\n      {\n        nWB = tag - 0x20400112;\n        int wbG = get2();\n        tWB = Oly_wb_list2[nWB << 1];\n        if (nWB)\n          imgdata.color.WBCT_Coeffs[nWB - 1][2] = imgdata.color.WBCT_Coeffs[nWB - 1][4] = wbG;\n        if (tWB != 0x100)\n          imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = wbG;\n      }\n\n      if (tag == 0x20400121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        if (len == 4)\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n        }\n      }\n      if (tag == 0x2040011f)\n      {\n        int wbG = get2();\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0])\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = wbG;\n        FORC4 if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][0])\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + c][3] =\n            wbG;\n      }\n      if ((tag == 0x30000110) && strcmp(software, \"v757-71\"))\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][2] = get2();\n        if (len == 2)\n        {\n          for (int i = 0; i < 256; i++)\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n        }\n      }\n      if ((((tag >= 0x30000120) && (tag <= 0x30000124)) || ((tag >= 0x30000130) && (tag <= 0x30000133))) &&\n          strcmp(software, \"v757-71\"))\n      {\n        int wb_ind;\n        if (tag <= 0x30000124)\n          wb_ind = tag - 0x30000120;\n        else\n          wb_ind = tag - 0x30000130 + 5;\n        imgdata.color.WB_Coeffs[Oly_wb_list1[wb_ind]][0] = get2();\n        imgdata.color.WB_Coeffs[Oly_wb_list1[wb_ind]][2] = get2();\n      }\n\n      if ((tag == 0x20400805) && (len == 2))\n      {\n        imgdata.makernotes.olympus.OlympusSensorCalibration[0] = getreal(type);\n        imgdata.makernotes.olympus.OlympusSensorCalibration[1] = getreal(type);\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n      }\n      if (tag == 0x20200306)\n      {\n        uchar uc;\n        fread(&uc, 1, 1, ifp);\n        imgdata.makernotes.olympus.AFFineTune = uc;\n      }\n      if (tag == 0x20200307)\n      {\n        FORC3 imgdata.makernotes.olympus.AFFineTuneAdj[c] = get2();\n      }\n      if (tag == 0x20200401)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n    }\n    fseek(ifp, _pos2, SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make, \"NIKON\", 5))\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n    }\n    if (tag == 0x14 && type == 7)\n    {\n      if (len == 2560)\n      {\n        fseek(ifp, 1248, SEEK_CUR);\n        goto get2_256;\n      }\n      fread(buf, 1, 10, ifp);\n      if (!strncmp(buf, \"NRW \", 4))\n      {\n        fseek(ifp, strcmp(buf + 4, \"0100\") ? 46 : 1546, SEEK_CUR);\n        cam_mul[0] = get4() << 2;\n        cam_mul[1] = get4() + get4();\n        cam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread(model, 64, 1, ifp);\n    if (strstr(make, \"PENTAX\"))\n    {\n      if (tag == 0x1b)\n        tag = 0x1018;\n      if (tag == 0x1c)\n        tag = 0x1017;\n    }\n    if (tag == 0x1d)\n    {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n        serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1)\n    { // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi] - '0' : 0;\n      fseek(ifp, 8 + c * 32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14 - tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4)\n    {\n      data_offset = get4();\n      fseek(ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81 && type == 7) || (tag == 0x100 && type == 7) || (tag == 0x280 && type == 1))\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97)\n    {\n      for (i = 0; i < 4; i++)\n        ver97 = ver97 * 10 + fgetc(ifp) - '0';\n      switch (ver97)\n      {\n      case 100:\n        fseek(ifp, 68, SEEK_CUR);\n        FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n        break;\n      case 102:\n        fseek(ifp, 6, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = get2();\n        break;\n      case 103:\n        fseek(ifp, 16, SEEK_CUR);\n        FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200)\n      {\n        if (ver97 != 205)\n          fseek(ifp, 280, SEEK_CUR);\n        fread(buf97, 324, 1, ifp);\n      }\n    }\n    if ((tag == 0xa1) && (type == 7) && strncasecmp(make, \"Samsung\", 7))\n    {\n      order = 0x4949;\n      fseek(ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3)\n    {\n      fseek(ifp, wbi * 48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7)\n    { // shutter count\n      NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n      if ((unsigned)(ver97 - 200) < 17)\n      {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97 - 200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] = sget2(buf97 + (i & -2) + c * 2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601) // Coolpix A\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n#endif\n    }\n\n    if (tag == 0xb001 && type == 3) // Sony ModelID\n    {\n      unique_id = get2();\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(), get4());\n    if (tag == 0x200 && len == 4) // Pentax black level\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4) // Pentax As Shot WB\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make, \"NIKON\") && len == 4)\n    {\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black += i;\n    }\n#endif\n    if (tag == 0xe01)\n    { /* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n      int loopc = 0;\n#endif\n      order = 0x4949;\n      fseek(ifp, 22, SEEK_CUR);\n      for (offset = 22; offset + 22 < len; offset += 22 + i)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (loopc++ > 1024)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        tag = get4();\n        fseek(ifp, 14, SEEK_CUR);\n        i = get4() - 4;\n        if (tag == 0x76a43207)\n          flip = get2();\n        else\n          fseek(ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7)\n    {\n      fseek(ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7)\n    {\n      if (len == 614)\n        fseek(ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n        fseek(ifp, 148, SEEK_CUR);\n      else\n        goto next;\n      goto get2_256;\n    }\n    if (((tag == 0x1011 && len == 9) || tag == 0x20400200) && strcmp(software, \"v757-71\"))\n      for (i = 0; i < 3; i++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!imgdata.makernotes.olympus.ColorSpace)\n        {\n          FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n        }\n        else\n        {\n          FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;\n        }\n#else\n        FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n#endif\n      }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2)\n    {\n    get2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek(ifp, get4() + base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    if (tag == 0x2010)\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, 0x2010);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n\n    if (((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031) || (tag == 0x2050)) &&\n        ((type == 7) || (type == 13)) && !strncasecmp(make, \"Olympus\", 7))\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, tag);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf, \"OLYMP\", 5))\n      parse_thumb_note(base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote(base, 0x2040);\n    if (tag == 0xb028)\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_thumb_note(base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000)\n    {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek(ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i += 18; i <= len; i += 10)\n      {\n        get2();\n        FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n        if (sraw_mul[1] == 1170)\n          break;\n      }\n    }\n    if (!strncasecmp(make, \"Samsung\", 7))\n    {\n      if (tag == 0xa020) // get the full Samsung encryption key\n        for (i = 0; i < 11; i++)\n          SamsungKey[i] = get4();\n      if (tag == 0xa021) // get and decode Samsung cam_mul array\n        FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tag == 0xa022)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get4() - SamsungKey[c + 4];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][3] >> 4;\n        }\n      }\n\n      if (tag == 0xa023)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n        }\n      }\n      if (tag == 0xa024)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c + 1];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n        }\n      }\n      /*\n            if (tag == 0xa025) {\n              i = get4();\n              imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n                  imgdata.color.linear_max[3] = i - SamsungKey[0]; printf (\"Samsung 0xa025 %d\\n\", i); }\n      */\n      if (tag == 0xa030 && len == 9)\n        for (i = 0; i < 3; i++)\n          FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n#endif\n      if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix\n        for (i = 0; i < 3; i++)\n          FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n\n      if (tag == 0xa028)\n        FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n    }\n    else\n    {\n      // Somebody else use 0xa021 and 0xa028?\n      if (tag == 0xa021)\n        FORC4 cam_mul[c ^ (c >> 1)] = get4();\n      if (tag == 0xa028)\n        FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x4021 && (imgdata.makernotes.canon.multishot[0] = get4()) &&\n        (imgdata.makernotes.canon.multishot[1] = get4()))\n    {\n      if (len >= 4)\n      {\n        imgdata.makernotes.canon.multishot[2] = get4();\n        imgdata.makernotes.canon.multishot[3] = get4();\n      }\n      FORC4 cam_mul[c] = 1024;\n    }\n#else\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\n#endif\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp(int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i = 19; i--;)\n      str[i] = fgetc(ifp);\n  else\n    fread(str, 19, 1, ifp);\n  memset(&t, 0, sizeof t);\n  if (sscanf(str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif(int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo, ape;\n\n  kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;\n  entries = get2();\n  if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > fsize * 2)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n    switch (tag)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\n    case 0x9400:\n      imgdata.other.exifAmbientTemperature = getreal(type);\n      if ((imgdata.other.CameraTemperature > -273.15f) && (OlyID == 0x4434353933ULL)) // TG-5\n        imgdata.other.CameraTemperature += imgdata.other.exifAmbientTemperature;\n      break;\n    case 0x9401:\n      imgdata.other.exifHumidity = getreal(type);\n      break;\n    case 0x9402:\n      imgdata.other.exifPressure = getreal(type);\n      break;\n    case 0x9403:\n      imgdata.other.exifWaterDepth = getreal(type);\n      break;\n    case 0x9404:\n      imgdata.other.exifAcceleration = getreal(type);\n      break;\n    case 0x9405:\n      imgdata.other.exifCameraElevationAngle = getreal(type);\n      break;\n\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n    case 33434:\n      tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);\n      break;\n    case 33437:\n      aperture = getreal(type);\n      break; // 0x829d FNumber\n    case 34855:\n      iso_speed = get2();\n      break;\n    case 34865:\n      if (iso_speed == 0xffff && !strncasecmp(make, \"FUJI\", 4))\n        iso_speed = getreal(type);\n      break;\n    case 34866:\n      if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))\n        iso_speed = getreal(type);\n      break;\n    case 36867:\n    case 36868:\n      get_timestamp(0);\n      break;\n    case 37377:\n      if ((expo = -getreal(type)) < 128 && shutter == 0.)\n        tiff_ifd[tiff_nifds - 1].t_shutter = shutter = libraw_powf64l(2.0, expo);\n      break;\n    case 37378: // 0x9202 ApertureValue\n      if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))\n        aperture = libraw_powf64l(2.0, ape / 2);\n      break;\n    case 37385:\n      flash_used = getreal(type);\n      break;\n    case 37386:\n      focal_len = getreal(type);\n      break;\n    case 37500: // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\", 6))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_OV5647\", 9))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_imx219\", 9))))\n      {\n        char mn_text[512];\n        char *pos;\n        char ccms[512];\n        ushort l;\n        float num;\n\n\tfgets(mn_text, MIN(len,511), ifp);\n        mn_text[511] = 0;\n\n        pos = strstr(mn_text, \"gain_r=\");\n        if (pos)\n          cam_mul[0] = atof(pos + 7);\n        pos = strstr(mn_text, \"gain_b=\");\n        if (pos)\n          cam_mul[2] = atof(pos + 7);\n        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n          cam_mul[1] = cam_mul[3] = 1.0f;\n        else\n          cam_mul[0] = cam_mul[2] = 0.0f;\n\n        pos = strstr(mn_text, \"ccm=\");\n        if(pos)\n        {\n         pos +=4;\n         char *pos2 = strstr(pos, \" \");\n         if(pos2)\n         {\n           l = pos2 - pos;\n           memcpy(ccms, pos, l);\n           ccms[l] = '\\0';\n#if defined WIN32 || defined(__MINGW32__)\n           // Win32 strtok is already thread-safe\n          pos = strtok(ccms, \",\");\n#else\n          char *last=0;\n          pos = strtok_r(ccms, \",\",&last);\n#endif\n          if(pos)\n          {\n            for (l = 0; l < 4; l++)\n            {\n              num = 0.0;\n              for (c = 0; c < 3; c++)\n              {\n                imgdata.color.ccm[l][c] = (float)atoi(pos);\n                num += imgdata.color.ccm[l][c];\n#if defined WIN32 || defined(__MINGW32__)\n                pos = strtok(NULL, \",\");\n#else\n                pos = strtok_r(NULL, \",\",&last);\n#endif\n                if(!pos) goto end; // broken\n              }\n              if (num > 0.01)\n                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n            }\n          }\n        }\n       }\n      end:;\n      }\n      else\n\n#endif\n        parse_makernote(base, 0);\n      break;\n    case 40962:\n      if (kodak)\n        raw_width = get4();\n      break;\n    case 40963:\n      if (kodak)\n        raw_height = get4();\n      break;\n    case 41730:\n      if (get4() == 0x20002)\n        for (exif_cfa = c = 0; c < 8; c += 2)\n          exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n    return;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue; // no GPS tags are 1k or larger\n    }\n    switch (tag)\n    {\n    case 1:\n      imgdata.other.parsed_gps.latref = getc(ifp);\n      break;\n    case 3:\n      imgdata.other.parsed_gps.longref = getc(ifp);\n      break;\n    case 5:\n      imgdata.other.parsed_gps.altref = getc(ifp);\n      break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9:\n      imgdata.other.parsed_gps.gpsstatus = getc(ifp);\n      break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue; // no GPS tags are 1k or larger\n    }\n    switch (tag)\n    {\n    case 1:\n    case 3:\n    case 5:\n      gpsdata[29 + tag / 2] = getc(ifp);\n      break;\n    case 2:\n    case 4:\n    case 7:\n      FORC(6) gpsdata[tag / 3 * 6 + c] = get4();\n      break;\n    case 6:\n      FORC(2) gpsdata[18 + c] = get4();\n      break;\n    case 18:\n    case 29:\n      fgets((char *)(gpsdata + 14 + tag / 3), MIN(len, 12), ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff(float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] = /* ROMM == Kodak ProPhoto */\n      {{2.034193, -0.727420, -0.306766}, {-0.228811, 1.231729, -0.002922}, {-0.008565, -0.153273, 1.161839}};\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      for (cmatrix[i][j] = k = 0; k < 3; k++)\n        cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos(int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes = 0, frot = 0;\n  static const char *mod[] = {\"\",\n                              \"DCB2\",\n                              \"Volare\",\n                              \"Cantare\",\n                              \"CMost\",\n                              \"Valeo 6\",\n                              \"Valeo 11\",\n                              \"Valeo 22\",\n                              \"Valeo 11p\",\n                              \"Valeo 17\",\n                              \"\",\n                              \"Aptus 17\",\n                              \"Aptus 22\",\n                              \"Aptus 75\",\n                              \"Aptus 65\",\n                              \"Aptus 54S\",\n                              \"Aptus 65S\",\n                              \"Aptus 75S\",\n                              \"AFi 5\",\n                              \"AFi 6\",\n                              \"AFi 7\",\n                              \"AFi-II 7\",\n                              \"Aptus-II 7\",\n                              \"\",\n                              \"Aptus-II 6\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10\",\n                              \"Aptus-II 5\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10R\",\n                              \"Aptus-II 8\",\n                              \"\",\n                              \"Aptus-II 12\",\n                              \"\",\n                              \"AFi-II 12\"};\n  float romm_cam[3][3];\n\n  fseek(ifp, offset, SEEK_SET);\n  while (1)\n  {\n    if (get4() != 0x504b5453)\n      break;\n    get4();\n    fread(data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data, \"CameraObj_camera_type\"))\n    {\n      stmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data, \"back_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.BodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));\n      strcpy(imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data, \"CaptProf_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n      strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n    // IB end\n    if (!strcmp(data, \"JPEG_preview_data\"))\n    {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data, \"icc_camera_profile\"))\n    {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data, \"ShootObj_back_type\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      if ((unsigned)i < sizeof mod / sizeof(*mod))\n        strcpy(model, mod[i]);\n    }\n    if (!strcmp(data, \"icc_camera_to_tone_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        ((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_color_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        fscanf(ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_number_of_planes\"))\n      fscanf(ifp, \"%d\", &planes);\n    if (!strcmp(data, \"CaptProf_raw_data_rotation\"))\n      fscanf(ifp, \"%d\", &flip);\n    if (!strcmp(data, \"CaptProf_mosaic_pattern\"))\n      FORC4\n      {\n        fscanf(ifp, \"%d\", &i);\n        if (i == 1)\n          frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data, \"ImgProf_rotation_angle\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data, \"NeutObj_neutrals\") && !cam_mul[0])\n    {\n      FORC4 fscanf(ifp, \"%d\", neut + c);\n      FORC3 cam_mul[c] = (float)neut[0] / neut[c + 1];\n    }\n    if (!strcmp(data, \"Rows_data\"))\n      load_flags = get4();\n    parse_mos(from);\n    fseek(ifp, skip + from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 * (uchar) \"\\x94\\x61\\x16\\x49\"[(flip / 90 + frot) & 3];\n}\n\nvoid CLASS linear_table(unsigned len)\n{\n  int i;\n  if (len > 0x10000)\n    len = 0x10000;\n  else if(len < 1)\n    return;\n  read_shorts(curve, len);\n  for (i = len; i < 0x10000; i++)\n    curve[i] = curve[i - 1];\n  maximum = curve[len < 0x1000 ? 0xfff : len - 1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags(int wb, unsigned type)\n{\n  float mul[3] = {1, 1, 1}, num, mul2;\n  int c;\n  FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n  imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n  mul2 = mul[1] * mul[1];\n  imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n  imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n  return;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int j, c, wbi = -2, romm_camTemp[9], romm_camScale[3];\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n  //  int a_blck = 0;\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  INT64 fsize = ifp->size();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n    if (tag == 1003)\n      imgdata.sizes.raw_crop.cleft = get2();\n    if (tag == 1004)\n      imgdata.sizes.raw_crop.ctop = get2();\n    if (tag == 1005)\n      imgdata.sizes.raw_crop.cwidth = get2();\n    if (tag == 1006)\n      imgdata.sizes.raw_crop.cheight = get2();\n    if (tag == 1007)\n      imgdata.makernotes.kodak.BlackLevelTop = get2();\n    if (tag == 1008)\n      imgdata.makernotes.kodak.BlackLevelBottom = get2();\n    if (tag == 1011)\n      imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());\n      wbi = -2;\n    }\n\n    if ((tag == 1030) && (len == 1))\n      imgdata.other.CameraTemperature = getreal(type);\n    if ((tag == 1043) && (len == 1))\n      imgdata.other.SensorTemperature = getreal(type);\n\n    if ((tag == 0x03ef) && (!strcmp(model, \"EOS D2000C\")))\n      black = get2();\n    if ((tag == 0x03f0) && (!strcmp(model, \"EOS D2000C\")))\n    {\n      if (black) // already set by tag 0x03ef\n        black = (black + get2()) / 2;\n      else\n        black = get2();\n    }\n    INT64 _pos2 = ftell(ifp);\n    if (tag == 0x0848)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x084c)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Custom, type);\n    if (tag == 0x084d)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Auto, type);\n    if (tag == 0x0e93)\n      imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n          imgdata.color.linear_max[3] = get2();\n    if (tag == 0x09ce)\n      stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n    if (tag == 0xfa00)\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n    if (tag == 0xfa27)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n    }\n    if (tag == 0xfa28)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n    }\n    if (tag == 0xfa29)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n    }\n    if (tag == 0xfa2a)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n    }\n\n    fseek(ifp, _pos2, SEEK_SET);\n\n    if (((tag == 0x07e4) || (tag == 0xfb01)) && (len == 9))\n    {\n      short validM = 0;\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camDaylight)[j] = getreal(type);\n        }\n        validM = 1;\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camDaylight)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n          validM = 1;\n        }\n      }\n      if (validM)\n      {\n        romm_coeff(imgdata.makernotes.kodak.romm_camDaylight);\n      }\n    }\n    if (((tag == 0x07e5) || (tag == 0xfb02)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camTungsten)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camTungsten)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n    if (((tag == 0x07e6) || (tag == 0xfb03)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camFluorescent)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camFluorescent)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n    if (((tag == 0x07e7) || (tag == 0xfb04)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camFlash)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camFlash)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n    if (((tag == 0x07e8) || (tag == 0xfb05)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camCustom)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camCustom)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n    if (((tag == 0x07e9) || (tag == 0xfb06)) && (len == 9))\n    {\n      if (type == 10)\n      {\n        for (j = 0; j < 9; j++)\n        {\n          ((float *)imgdata.makernotes.kodak.romm_camAuto)[j] = getreal(type);\n        }\n      }\n      else if (type == 9)\n      {\n        FORC3\n        {\n          romm_camScale[c] = 0;\n          for (j = 0; j < 3; j++)\n          {\n            romm_camTemp[c * 3 + j] = get4();\n            romm_camScale[c] += romm_camTemp[c * 3 + j];\n          }\n        }\n        if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) && (romm_camScale[2] > 0x1fff))\n        {\n          FORC3 for (j = 0; j < 3; j++)\n          {\n            ((float *)imgdata.makernotes.kodak.romm_camAuto)[c * 3 + j] =\n                ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n          }\n        }\n      }\n    }\n\n    if (tag == 2120 + wbi || (wbi < 0 && tag == 2125)) /* use Auto WB if illuminant index is not set */\n    {\n      FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n      FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n    }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 0x903)\n      iso_speed = getreal(type);\n    // if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 0xfa13)\n      width = getint(type);\n    if (tag == 0xfa14)\n      height = (getint(type) + 1) & -2;\n\n    /*\n        height = getint(type);\n\n        if (tag == 0xfa16)\n          raw_width = get2();\n        if (tag == 0xfa17)\n          raw_height = get2();\n    */\n    if (tag == 0xfa18)\n    {\n      imgdata.makernotes.kodak.offset_left = getint(8);\n      if (type != 8)\n        imgdata.makernotes.kodak.offset_left += 1;\n    }\n    if (tag == 0xfa19)\n    {\n      imgdata.makernotes.kodak.offset_top = getint(8);\n      if (type != 8)\n        imgdata.makernotes.kodak.offset_top += 1;\n    }\n\n    if (tag == 0xfa31)\n      imgdata.sizes.raw_crop.cwidth = get2();\n    if (tag == 0xfa32)\n      imgdata.sizes.raw_crop.cheight = get2();\n    if (tag == 0xfa3e)\n      imgdata.sizes.raw_crop.cleft = get2();\n    if (tag == 0xfa3f)\n      imgdata.sizes.raw_crop.ctop = get2();\n\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2, wbtemp = 6500;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, get2());\n      wbi = -2;\n    }\n    if (tag == 2118)\n      wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3\n      {\n        for (num = i = 0; i < 4; i++)\n          num += getreal(type) * pow(wbtemp / 100.0, i);\n        cam_mul[c] = 2048 / fMAX(1.0, (num * mul[c]));\n      }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 6020)\n      iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\nint CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > 2 * fsize)\n    {\n      fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!\n      continue;\n    }\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : ((ifd + 1) << 20)), type, len, order,\n                        ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7302:\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c < 2)] = get2();\n        break;\n      case 0x7312:\n      {\n        int i, lc[4];\n        FORC4 lc[c] = get2();\n        i = (lc[1] == 1024 && lc[2] == 1024) << 1;\n        SWAP(lc[i], lc[i + 1]);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c] = lc[c];\n      }\n      break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        if (len == 3)\n        {\n          FORC3 imgdata.color.linear_max[c] = get2();\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        }\n        else if (len == 1)\n        {\n          imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n              imgdata.color.linear_max[3] = getreal(type); // Is non-short possible here??\n        }\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 10:\n      if (pana_raw && len == 1 && type == 3)\n      {\n        libraw_internal_data.unpacker_data.pana_bpp = get2();\n      }\n    break;\n#endif\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n\n    case 0x0120:\n      if (pana_raw)\n      {\n        unsigned sorder = order;\n        unsigned long sbase = base;\n        base = ftell(ifp);\n        order = get2();\n        fseek(ifp, 2, SEEK_CUR);\n        fseek(ifp, get4()-8, SEEK_CUR);\n        parse_tiff_ifd (base);\n        base = sbase;\n        order = sorder;\n      }\n    break;\n\n    case 0x2009:\n      if ((libraw_internal_data.unpacker_data.pana_encoding == 4) ||\n          (libraw_internal_data.unpacker_data.pana_encoding == 5))\n      {\n        int n = MIN (8, len);\n        int permut[8] = {3, 2, 1, 0, 3+4, 2+4, 1+4, 0+4};\n\n        imgdata.makernotes.panasonic.BlackLevelDim = len;\n\n        for (int i=0; i < n; i++)\n        {\n          imgdata.makernotes.panasonic.BlackLevel[permut[i]] =\n            (float) (get2()) / (float) (powf(2.f, 14.f-libraw_internal_data.unpacker_data.pana_bpp));\n        }\n      }\n      break;\n#endif\n\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 45:\n      if (pana_raw && len == 1 && type == 3)\n      {\n        libraw_internal_data.unpacker_data.pana_encoding = get2();\n      }\n      break;\n#endif\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454: // FujiFilm \"As Shot\"\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      if ((pana_raw) && (tag == 11) && (type == 3))\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.makernotes.panasonic.Compression = get2();\n#endif\n        break;\n      }\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n\t  if(cfa_pat[i] > 31) continue; // Skip wrong data\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0x9400:\n      imgdata.other.exifAmbientTemperature = getreal(type);\n      if ((imgdata.other.CameraTemperature > -273.15f) && (OlyID == 0x4434353933ULL)) // TG-5\n        imgdata.other.CameraTemperature += imgdata.other.exifAmbientTemperature;\n      break;\n    case 0x9401:\n      imgdata.other.exifHumidity = getreal(type);\n      break;\n    case 0x9402:\n      imgdata.other.exifPressure = getreal(type);\n      break;\n    case 0x9403:\n      imgdata.other.exifWaterDepth = getreal(type);\n      break;\n    case 0x9404:\n      imgdata.other.exifAcceleration = getreal(type);\n      break;\n    case 0x9405:\n      imgdata.other.exifCameraElevationAngle = getreal(type);\n      break;\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4\n      {\n\tint q = get2();\n\tif(q > 0) cam_mul[c ^ 1] = 4096.0 / q;\n      }\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINTABLE;\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00d:\n      if (strcmp(model, \"X-A3\")  &&\n          strcmp(model, \"X-A10\") &&\n          strcmp(model, \"X-A5\")  &&\n          strcmp(model, \"X-A20\"))\n      {\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][(4 - c) % 3] = getint(type);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][1];\n      }\n      break;\n    case 0xf00c:\n      if (strcmp(model, \"X-A3\")  &&\n          strcmp(model, \"X-A10\") &&\n          strcmp(model, \"X-A5\")  &&\n          strcmp(model, \"X-A20\"))\n      {\n        unsigned fwb[4];\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100)\n        {\n          imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n          imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n          imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n          if ((fwb[3] == 17) && (libraw_internal_data.unpacker_data.lenRAFData > 3) &&\n              (libraw_internal_data.unpacker_data.lenRAFData < 10240000))\n          {\n            INT64 f_save = ftell(ifp);\n            ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n            fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n            fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n            fseek(ifp, f_save, SEEK_SET);\n            int fj, found = 0;\n            for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n            {\n              if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n              {\n                if (rafdata[fi - 15] != fwb[0])\n                  continue;\n\n                for (int wb_ind = 0, ofst = fi - 15; wb_ind < nFuji_wb_list1; wb_ind++, ofst += 3)\n                {\n                  imgdata.color.WB_Coeffs[Fuji_wb_list1[wb_ind]][1] =\n                      imgdata.color.WB_Coeffs[Fuji_wb_list1[wb_ind]][3] = rafdata[ofst];\n                  imgdata.color.WB_Coeffs[Fuji_wb_list1[wb_ind]][0] = rafdata[ofst + 1];\n                  imgdata.color.WB_Coeffs[Fuji_wb_list1[wb_ind]][2] = rafdata[ofst + 2];\n                }\n                fi += 0x60;\n                for (fj = fi; fj < (fi + 15); fj += 3)\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    found = 1;\n                    break;\n                  }\n                if (found)\n                {\n                  fj = fj - 93;\n                  for (int iCCT = 0; iCCT < 31; iCCT++)\n                  {\n                    imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                    imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                  }\n                }\n                free(rafdata);\n                break;\n              }\n            }\n          }\n        }\n        FORC4 fwb[c] = get4();\n        if (fwb[3] < 0x100)\n        {\n          imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n          imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n          imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        }\n      }\n      break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      if(len>0)\n       {\n        black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;\n#endif\n       }\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_WHITE;\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      {\n\tfloat q1 = getreal(type);\n\tfloat q2 = getreal(type);\n\tif(q1 > 0.00001f && q2 > 0.00001f)\n\t {\n      \t\tpixel_aspect = q1/q2;\n      \t\tif (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        \t\tpixel_aspect = 1.0;\n\t }\n      }\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50719: /* DefaultCropOrigin */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPORIGIN;\n        tiff_ifd[ifd].dng_levels.default_crop[0] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[1] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_crop.cleft = tiff_ifd[ifd].dng_levels.default_crop[0];\n          imgdata.sizes.raw_crop.ctop = tiff_ifd[ifd].dng_levels.default_crop[1];\n        }\n      }\n      break;\n    case 50720: /* DefaultCropSize */\n      if (len == 2)\n      {\n        tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPSIZE;\n        tiff_ifd[ifd].dng_levels.default_crop[2] = getreal(type);\n        tiff_ifd[ifd].dng_levels.default_crop[3] = getreal(type);\n        if (!strncasecmp(make, \"SONY\", 4))\n        {\n          imgdata.sizes.raw_crop.cwidth = tiff_ifd[ifd].dng_levels.default_crop[2];\n          imgdata.sizes.raw_crop.cheight = tiff_ifd[ifd].dng_levels.default_crop[3];\n        }\n      }\n      break;\n    case 0x74c7:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.makernotes.sony.raw_crop.cleft = get4();\n        imgdata.makernotes.sony.raw_crop.ctop = get4();\n      }\n      break;\n    case 0x74c8:\n      if ((len == 2) && !strncasecmp(make, \"SONY\", 4))\n      {\n        imgdata.makernotes.sony.raw_crop.cwidth = get4();\n        imgdata.makernotes.sony.raw_crop.cheight = get4();\n      }\n      break;\n\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      tiff_ifd[ifd].dng_color[0].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      tiff_ifd[ifd].dng_color[1].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;\n      break;\n\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n      tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_COLORMATRIX;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n      tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n      tiff_ifd[ifd].dng_color[j].parsedfields |= LIBRAW_DNGFM_CALIBRATION;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ANALOGBALANCE;\n#endif\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n\n            INT64 save_pos = ifp->tell();\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n\n            curr_pos = save_pos + MakN_length - 6;\n            fseek(ifp, curr_pos, SEEK_SET);\n\n            fread(mbuf, 1, 4, ifp);\n            curr_pos += 8;\n            if (!strncmp(mbuf, \"SR2 \", 4))\n            {\n              order = 0x4d4d;\n              MakN_length = get4();\n              MakN_order = get2();\n              pos_in_original_raw = get4();\n              order = MakN_order;\n\n              unsigned *buf_SR2;\n              uchar *cbuf_SR2;\n              unsigned icbuf_SR2;\n              unsigned entries, tag, type, len, save;\n              int ival;\n              unsigned SR2SubIFDOffset = 0;\n              unsigned SR2SubIFDLength = 0;\n              unsigned SR2SubIFDKey = 0;\n              int base = curr_pos + 6 - pos_in_original_raw;\n              entries = get2();\n              while (entries--)\n              {\n                tiff_get(base, &tag, &type, &len, &save);\n\n                if (tag == 0x7200)\n                {\n                  SR2SubIFDOffset = get4();\n                }\n                else if (tag == 0x7201)\n                {\n                  SR2SubIFDLength = get4();\n                }\n                else if (tag == 0x7221)\n                {\n                  SR2SubIFDKey = get4();\n                }\n                fseek(ifp, save, SEEK_SET);\n              }\n\n              if (SR2SubIFDLength && (SR2SubIFDLength < 10240000) && (buf_SR2 = (unsigned *)malloc(SR2SubIFDLength+1024))) // 1024b for safety\n              {\n                fseek(ifp, SR2SubIFDOffset + base, SEEK_SET);\n                fread(buf_SR2, SR2SubIFDLength, 1, ifp);\n                sony_decrypt(buf_SR2, SR2SubIFDLength / 4, 1, SR2SubIFDKey);\n                cbuf_SR2 = (uchar *)buf_SR2;\n                entries = sget2(cbuf_SR2);\n                icbuf_SR2 = 2;\n                while (entries--)\n                {\n                  tag = sget2(cbuf_SR2 + icbuf_SR2);\n                  icbuf_SR2 += 2;\n                  type = sget2(cbuf_SR2 + icbuf_SR2);\n                  icbuf_SR2 += 2;\n                  len = sget4(cbuf_SR2 + icbuf_SR2);\n                  icbuf_SR2 += 4;\n\n                  if (len * (\"11124811248484\"[type < 14 ? type : 0] - '0') > 4)\n                  {\n                    ival = sget4(cbuf_SR2 + icbuf_SR2) - SR2SubIFDOffset;\n                  }\n                  else\n                  {\n                    ival = icbuf_SR2;\n                  }\n\t\t  if(ival > SR2SubIFDLength) // points out of orig. buffer size\n\t\t     break; // END processing. Generally we should check against SR2SubIFDLength minus 6 of 8, depending on tag, but we allocated extra 1024b for buffer, so this does not matter\n\n                  icbuf_SR2 += 4;\n\n                  switch (tag)\n                  {\n                  case 0x7302:\n                    FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c < 2)] = sget2(cbuf_SR2 + ival + 2 * c);\n                    break;\n                  case 0x7312:\n                  {\n                    int i, lc[4];\n                    FORC4 lc[c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    i = (lc[1] == 1024 && lc[2] == 1024) << 1;\n                    SWAP(lc[i], lc[i + 1]);\n                    FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c] = lc[c];\n                  }\n                  break;\n                  case 0x7480:\n                  case 0x7820:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n                    break;\n                  case 0x7481:\n                  case 0x7821:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n                    break;\n                  case 0x7482:\n                  case 0x7822:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n                    break;\n                  case 0x7483:\n                  case 0x7823:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n                    break;\n                  case 0x7484:\n                  case 0x7824:\n                    imgdata.color.WBCT_Coeffs[0][0] = 4500;\n                    FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n                    break;\n                  case 0x7486:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n                    break;\n                  case 0x7825:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n                    break;\n                  case 0x7826:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n                    break;\n                  case 0x7827:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n                    break;\n                  case 0x7828:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n                    break;\n                  case 0x7829:\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n                    break;\n                  case 0x782a:\n                    imgdata.color.WBCT_Coeffs[1][0] = 8500;\n                    FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n                    break;\n                  case 0x782b:\n                    imgdata.color.WBCT_Coeffs[2][0] = 6000;\n                    FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n                    break;\n                  case 0x782c:\n                    imgdata.color.WBCT_Coeffs[3][0] = 3200;\n                    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] =\n                        sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n                    break;\n                  case 0x782d:\n                    imgdata.color.WBCT_Coeffs[4][0] = 2500;\n                    FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = sget2(cbuf_SR2 + ival + 2 * c);\n                    imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n                    break;\n                  }\n                }\n\n                free(buf_SR2);\n              }\n\n            } /* SR2 processed */\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50970: /* PreviewColorSpace */\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_PREVIEWCS;\n      tiff_ifd[ifd].dng_levels.preview_colorspace = getint(type);\n      break;\n#endif\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE2;\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC\n     if(fabs(asn[c])>0.0001)\n     \tcam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC if(fabs(cc[c][c])>0.0001) pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff(int base)\n{\n  int doff;\n  fseek(ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d)\n    return 0;\n  get2();\n  while ((doff = get4()))\n  {\n    fseek(ifp, doff + base, SEEK_SET);\n    if (parse_tiff_ifd(base))\n      break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp = 0, ties = 0, raw = -1, thm = -1, i;\n  unsigned long long ns, os;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n      {\n        thumb_misc = jh.bits;\n        thumb_width = jh.wide;\n        thumb_height = jh.high;\n      }\n    }\n  }\n  for (i = tiff_nifds; i--;)\n  {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i = 0; i < tiff_nifds; i++)\n  {\n    if( tiff_ifd[i].t_width < 1 ||  tiff_ifd[i].t_width > 65535\n       || tiff_ifd[i].t_height < 1 || tiff_ifd[i].t_height > 65535)\n          continue; /* wrong image dimensions */\n    if (max_samp < tiff_ifd[i].samples)\n      max_samp = tiff_ifd[i].samples;\n    if (max_samp > 3)\n      max_samp = 3;\n    os = raw_width * raw_height;\n    ns = tiff_ifd[i].t_width * tiff_ifd[i].t_height;\n    if (tiff_bps)\n    {\n      os *= tiff_bps;\n      ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 && (unsigned)tiff_ifd[i].bps < 33 &&\n        (unsigned)tiff_ifd[i].samples < 13 && ns && ((ns > os && (ties = 1)) || (ns == os && shot_select == ties++)))\n    {\n      raw_width = tiff_ifd[i].t_width;\n      raw_height = tiff_ifd[i].t_height;\n      tiff_bps = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size = tiff_ifd[i].bytes;\n#endif\n      tiff_flip = tiff_ifd[i].t_flip;\n      tiff_samples = tiff_ifd[i].samples;\n      tile_width = tiff_ifd[i].t_tile_width;\n      tile_length = tiff_ifd[i].t_tile_length;\n      shutter = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties)\n    is_raw = ties;\n  if (!tile_width)\n    tile_width = INT_MAX;\n  if (!tile_length)\n    tile_length = INT_MAX;\n  for (i = tiff_nifds; i--;)\n    if (tiff_ifd[i].t_flip)\n      tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress)\n    {\n    case 32767:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height))\n#else\n      if (tiff_ifd[raw].bytes == raw_width * raw_height)\n#endif\n      {\n        tiff_bps = 12;\n        load_raw = &CLASS sony_arw2_load_raw;\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncasecmp(make, \"Sony\", 4) && INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height) * 2ULL)\n#else\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n#endif\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (INT64(tiff_ifd[raw].bytes) * 8ULL != INT64(raw_width) * INT64(raw_height) * INT64(tiff_bps))\n#else\n      if (tiff_ifd[raw].bytes * 8 != raw_width * raw_height * tiff_bps)\n#endif\n      {\n        raw_height += 8;\n        load_raw = &CLASS sony_arw_load_raw;\n        break;\n      }\n      load_flags = 79;\n    case 32769:\n      load_flags++;\n    case 32770:\n    case 32773:\n      goto slr;\n    case 0:\n    case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n      // Sony 14-bit uncompressed\n      if (!strncasecmp(make, \"Sony\", 4) && INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height) * 2ULL)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].samples == 4 &&\n          INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height) * 8ULL) // Sony ARQ\n      {\n        tiff_bps = 14;\n        tiff_samples = 4;\n        load_raw = &CLASS sony_arq_load_raw;\n        filters = 0;\n        strcpy(cdesc, \"RGBG\");\n        break;\n      }\n      if (!strncasecmp(make, \"Nikon\", 5) && !strncmp(software, \"Nikon Scan\", 10))\n      {\n        load_raw = &CLASS nikon_coolscan_load_raw;\n        raw_color = 1;\n        filters = 0;\n        break;\n      }\n      if (!strncmp(make, \"OLYMPUS\", 7) && INT64(tiff_ifd[raw].bytes) * 2ULL == INT64(raw_width) * INT64(raw_height) * 3ULL)\n#else \n      if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 2 == raw_width * raw_height * 3)\n#endif\n        load_flags = 24;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (INT64(tiff_ifd[raw].bytes) * 5ULL == INT64(raw_width) * INT64(raw_height) * 8ULL)\n#else\n      if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)\n#endif\n      {\n        load_flags = 81;\n        tiff_bps = 12;\n      }\n    slr:\n      switch (tiff_bps)\n      {\n      case 8:\n        load_raw = &CLASS eight_bit_load_raw;\n        break;\n      case 12:\n        if (tiff_ifd[raw].phint == 2)\n          load_flags = 6;\n        load_raw = &CLASS packed_load_raw;\n        break;\n      case 14:\n        load_flags = 0;\n      case 16:\n        load_raw = &CLASS unpacked_load_raw;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"OLYMPUS\", 7) && INT64(tiff_ifd[raw].bytes) * 7ULL > INT64(raw_width) * INT64(raw_height))\n#else\n        if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 7 > raw_width * raw_height)\n#endif\n          load_raw = &CLASS olympus_load_raw;\n      }\n      break;\n    case 6:\n    case 7:\n    case 99:\n      load_raw = &CLASS lossless_jpeg_load_raw;\n      break;\n    case 262:\n      load_raw = &CLASS kodak_262_load_raw;\n      break;\n    case 34713:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((INT64(raw_width) + 9ULL) / 10ULL * 16ULL * INT64(raw_height) == INT64(tiff_ifd[raw].bytes))\n#else\n      if ((raw_width + 9) / 10 * 16 * raw_height == tiff_ifd[raw].bytes)\n#endif\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 1;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (INT64(raw_width) * INT64(raw_height) * 3ULL == INT64(tiff_ifd[raw].bytes) * 2ULL)\n#else\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n#endif\n      {\n        load_raw = &CLASS packed_load_raw;\n        if (model[0] == 'N')\n          load_flags = 80;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (INT64(raw_width) * INT64(raw_height) * 3ULL == INT64(tiff_ifd[raw].bytes))\n#else\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes)\n#endif\n      {\n        load_raw = &CLASS nikon_yuv_load_raw;\n        gamma_curve(1 / 2.4, 12.92, 1, 4095);\n        memset(cblack, 0, sizeof cblack);\n        filters = 0;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (INT64(raw_width) * INT64(raw_height) * 2ULL == INT64(tiff_ifd[raw].bytes))\n#else\n      else if (raw_width * raw_height * 2 == tiff_ifd[raw].bytes)\n#endif\n      {\n        load_raw = &CLASS unpacked_load_raw;\n        load_flags = 4;\n        order = 0x4d4d;\n      }\n      else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (INT64(raw_width) * INT64(raw_height) * 3ULL == INT64(tiff_ifd[raw].bytes) * 2ULL)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 80;\n      }\n      else if (tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n               tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n      {\n        int fit = 1;\n        for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1; i++) // all but last\n          if (INT64(tiff_ifd[raw].strip_byte_counts[i]) * 2ULL != INT64(tiff_ifd[raw].rows_per_strip) * INT64(raw_width) * 3ULL)\n          {\n            fit = 0;\n            break;\n          }\n        if (fit)\n          load_raw = &CLASS nikon_load_striped_packed_raw;\n        else\n          load_raw = &CLASS nikon_load_raw; // fallback\n      }\n      else\n#endif\n        load_raw = &CLASS nikon_load_raw;\n      break;\n    case 65535:\n      load_raw = &CLASS pentax_load_raw;\n      break;\n    case 65000:\n      switch (tiff_ifd[raw].phint)\n      {\n      case 2:\n        load_raw = &CLASS kodak_rgb_load_raw;\n        filters = 0;\n        break;\n      case 6:\n        load_raw = &CLASS kodak_ycbcr_load_raw;\n        filters = 0;\n        break;\n      case 32803:\n        load_raw = &CLASS kodak_65000_load_raw;\n      }\n    case 32867:\n    case 34892:\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      break;\n#endif\n    default:\n      is_raw = 0;\n    }\n  if (!dng_version)\n    if (((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 && (tiff_compress & -16) != 32768) ||\n         (tiff_bps == 8 && strncmp(make, \"Phase\", 5) && strncmp(make, \"Leaf\", 4) && !strcasestr(make, \"Kodak\") &&\n          !strstr(model2, \"DEBUG RAW\"))) &&\n        strncmp(software, \"Nikon Scan\", 10))\n      is_raw = 0;\n  for (i = 0; i < tiff_nifds; i++)\n    if (i != raw &&\n        (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 && tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps) + 1) >\n            thumb_width * thumb_height / (SQR(thumb_misc) + 1) &&\n        tiff_ifd[i].comp != 34892)\n    {\n      thumb_width = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0)\n  {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp)\n    {\n    case 0:\n      write_thumb = &CLASS layer_thumb;\n      break;\n    case 1:\n      if (tiff_ifd[thm].bps <= 8)\n        write_thumb = &CLASS ppm_thumb;\n      else if (!strncmp(make, \"Imacon\", 6))\n        write_thumb = &CLASS ppm16_thumb;\n      else\n        thumb_load_raw = &CLASS kodak_thumb_load_raw;\n      break;\n    case 65000:\n      thumb_load_raw = tiff_ifd[thm].phint == 6 ? &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save = ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if (ifp->wfname())\n  {\n    std::wstring rawfile(ifp->wfname());\n    rawfile.replace(rawfile.length() - 3, 3, L\"JPG\");\n    if (!ifp->subfile_open(rawfile.c_str()))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n  if (!ifp->fname())\n  {\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n\n  ext = strrchr(ifname, '.');\n  file = strrchr(ifname, '/');\n  if (!file)\n    file = strrchr(ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file)\n    file = ifname - 1;\n#else\n  if (!file)\n    file = (char *)ifname - 1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext - file != 8)\n    return;\n  jname = (char *)malloc(strlen(ifname) + 1);\n  merror(jname, \"parse_external_jpeg()\");\n  strcpy(jname, ifname);\n  jfile = file - ifname + jname;\n  jext = ext - ifname + jname;\n  if (strcasecmp(ext, \".jpg\"))\n  {\n    strcpy(jext, isupper(ext[1]) ? \".JPG\" : \".jpg\");\n    if (isdigit(*file))\n    {\n      memcpy(jfile, file + 4, 4);\n      memcpy(jfile + 4, file, 4);\n    }\n  }\n  else\n    while (isdigit(*--jext))\n    {\n      if (*jext != '9')\n      {\n        (*jext)++;\n        break;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp(jname, ifname))\n  {\n    if ((ifp = fopen(jname, \"rb\")))\n    {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose(ifp);\n    }\n  }\n#else\n  if (strcmp(jname, ifname))\n  {\n    if (!ifp->subfile_open(jname))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n  }\n#endif\n  if (!timestamp)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n#endif\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n  }\n  free(jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = {0x410, 0x45f3};\n  int i, bpp, row, col, vbits = 0;\n  unsigned long bitbuf = 0;\n\n  if ((get2(), get4()) != 0x80008 || !get4())\n    return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12)\n    return;\n  for (i = row = 0; row < 8; row++)\n    for (col = 0; col < 8; col++)\n    {\n      if (vbits < bpp)\n      {\n        bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n        vbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff(int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi = -1;\n  ushort key[] = {0x410, 0x45f3};\n\n  fseek(ifp, offset + length - 4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek(ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127)\n    return;\n  while (nrecs--)\n  {\n    type = get2();\n    len = get4();\n    save = ftell(ifp) + 4;\n    fseek(ifp, offset + get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n    {\n      parse_ciff(ftell(ifp), len, depth + 1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004)\n      parse_ciff(ftell(ifp), len, depth + 1);\n#endif\n    if (type == 0x0810)\n      fread(artist, 64, 1, ifp);\n    if (type == 0x080a)\n    {\n      fread(make, 64, 1, ifp);\n      fseek(ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread(model, 64, 1, ifp);\n    }\n    if (type == 0x1810)\n    {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835) /* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007)\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818)\n    {\n      shutter = libraw_powf64l(2.0f, -int_to_float((get4(), get4())));\n      aperture = libraw_powf64l(2.0f, int_to_float(get4()) / 2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a)\n    {\n      //      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = libraw_powf64l(2.0f, ((get2(), get2()) + get2()) / 32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture = _CanonConvertAperture((get2(), get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture = libraw_powf64l(2.0, (get2(), (short)get2()) / 64.0);\n#endif\n      shutter = libraw_powf64l(2.0, -((short)get2()) / 32.0);\n      wbi = (get2(), get2());\n      if (wbi > 17)\n        wbi = 0;\n      fseek(ifp, 32, SEEK_CUR);\n      if (shutter > 1e6)\n        shutter = get2() / 10.0;\n    }\n    if (type == 0x102c)\n    {\n      if (get2() > 512)\n      { /* Pro90, G1 */\n        fseek(ifp, 118, SEEK_CUR);\n        FORC4 cam_mul[c ^ 2] = get2();\n      }\n      else\n      { /* G2, S30, S40 */\n        fseek(ifp, 98, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n    {\n      INT64 o = ftell(ifp);\n      fseek(ifp, (0x1 << 1), SEEK_CUR);\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ (c >> 1)] = get2();\n      Canon_WBpresets(0, 0);\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x102d)\n    {\n      INT64 o = ftell(ifp);\n      Canon_CameraSettings();\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x580b)\n    {\n      if (strcmp(model, \"Canon EOS D30\"))\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n      else\n        sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len >> 16, len & 0xffff);\n    }\n#endif\n    if (type == 0x0032)\n    {\n      if (len == 768)\n      { /* EOS D30 */\n        fseek(ifp, 72, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n        if (!wbi)\n          cam_mul[0] = -1; /* use my auto white balance */\n      }\n      else if (!cam_mul[0])\n      {\n        if (get2() == key[0]) /* Pro1, G6, S60, S70 */\n          c = (strstr(model, \"Pro1\") ? \"012346000000000000\" : \"01345:000000006008\")[LIM(0, wbi, 17)] - '0' + 2;\n        else\n        { /* G3, G5, S45, S50 */\n          c = \"023457000000006000\"[LIM(0, wbi, 17)] - '0';\n          key[0] = key[1] = 0;\n        }\n        fseek(ifp, 78 + c * 8, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n        if (!wbi)\n          cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9)\n    { /* D60, 10D, 300D, and clones */\n      if (len > 66)\n        wbi = \"0134567028\"[LIM(0, wbi, 9)] - '0';\n      fseek(ifp, 2 + wbi * 8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))\n      ciff_block_1030(); /* all that don't have 0x10a9 */\n    if (type == 0x1031)\n    {\n      raw_width = (get2(), get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c)\n    {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2)\n      {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n        if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n          imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2)\n        focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813)\n      flash_used = int_to_float(len);\n    if (type == 0x5814)\n      canon_ev = int_to_float(len);\n    if (type == 0x5817)\n      shot_order = len;\n    if (type == 0x5834)\n    {\n      unique_id = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n      unique_id = setCanonBodyFeatures(unique_id);\n#endif\n    }\n    if (type == 0x580e)\n      timestamp = len;\n    if (type == 0x180e)\n      timestamp = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime(gmtime(&timestamp));\n#endif\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek(ifp, 0, SEEK_SET);\n  memset(&t, 0, sizeof t);\n  do\n  {\n    fgets(line, 128, ifp);\n    if ((val = strchr(line, '=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line, \"DAT\"))\n      sscanf(val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line, \"TIM\"))\n      sscanf(val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line, \"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line, \"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line, \"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line, \"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line, \"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line, \"EOHD\", 4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy(make, \"Rollei\");\n  strcpy(model, \"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek(ifp, get4(), SEEK_SET);\n  while (entries--)\n  {\n    off = get4();\n    get4();\n    fread(str, 8, 1, ifp);\n    if (!strcmp(str, \"META\"))\n      meta_offset = off;\n    if (!strcmp(str, \"THUMB\"))\n      thumb_offset = off;\n    if (!strcmp(str, \"RAW0\"))\n      data_offset = off;\n  }\n  fseek(ifp, meta_offset + 20, SEEK_SET);\n  fread(make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make, ' ')))\n  {\n    strcpy(model, cp + 1);\n    *cp = 0;\n  }\n  raw_width = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(), get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one(int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset(&ph1, 0, sizeof ph1);\n  fseek(ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177)\n    return; /* \"Raw\" */\n  fseek(ifp, get4() + base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--)\n  {\n    tag = get4();\n    type = get4();\n    len = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek(ifp, base + data, SEEK_SET);\n    switch (tag)\n    {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      }\n      else\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0211:\n      imgdata.other.SensorTemperature2 = int_to_float(data);\n      break;\n    case 0x0401:\n      if (type == 4)\n        imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));\n      else\n        imgdata.lens.makernotes.CurAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x0403:\n      if (type == 4)\n        imgdata.lens.makernotes.CurFocal = int_to_float(data);\n      else\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n      {\n        imgdata.lens.makernotes.MinFocal = 0.0f;\n      }\n      break;\n    case 0x0417:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n    case 0x100:\n      flip = \"0653\"[data & 3] - '0';\n      break;\n    case 0x106:\n      for (i = 0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.P1_color[0].romm_cam[i] =\n#endif\n            ((float *)romm_cam)[i] = getreal(11);\n      romm_coeff(romm_cam);\n      break;\n    case 0x107:\n      FORC3 cam_mul[c] = getreal(11);\n      break;\n    case 0x108:\n      raw_width = data;\n      break;\n    case 0x109:\n      raw_height = data;\n      break;\n    case 0x10a:\n      left_margin = data;\n      break;\n    case 0x10b:\n      top_margin = data;\n      break;\n    case 0x10c:\n      width = data;\n      break;\n    case 0x10d:\n      height = data;\n      break;\n    case 0x10e:\n      ph1.format = data;\n      break;\n    case 0x10f:\n      data_offset = data + base;\n      break;\n    case 0x110:\n      meta_offset = data + base;\n      meta_length = len;\n      break;\n    case 0x112:\n      ph1.key_off = save - 4;\n      break;\n    case 0x210:\n      ph1.tag_210 = int_to_float(data);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.other.SensorTemperature = ph1.tag_210;\n#endif\n      break;\n    case 0x21a:\n      ph1.tag_21a = data;\n      break;\n    case 0x21c:\n      strip_offset = data + base;\n      break;\n    case 0x21d:\n      ph1.t_black = data;\n      break;\n    case 0x222:\n      ph1.split_col = data;\n      break;\n    case 0x223:\n      ph1.black_col = data + base;\n      break;\n    case 0x224:\n      ph1.split_row = data;\n      break;\n    case 0x225:\n      ph1.black_row = data + base;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x226:\n      for (i = 0; i < 9; i++)\n        imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n      break;\n#endif\n    case 0x301:\n      model[63] = 0;\n      fread(model, 1, 63, ifp);\n      if ((cp = strstr(model, \" camera\")))\n        *cp = 0;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0])\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek(ifp, 6, SEEK_CUR);\n    fseek(ifp, meta_offset + get4(), SEEK_SET);\n    entries = get4();\n    get4();\n    while (entries--)\n    {\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x0407)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        }\n        else\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ? &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy(make, \"Phase One\");\n  if (model[0])\n    return;\n  switch (raw_height)\n  {\n  case 2060:\n    strcpy(model, \"LightPhase\");\n    break;\n  case 2682:\n    strcpy(model, \"H 10\");\n    break;\n  case 4128:\n    strcpy(model, \"H 20\");\n    break;\n  case 5488:\n    strcpy(model, \"H 25\");\n    break;\n  }\n}\n\nvoid CLASS parse_fuji(int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek(ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  imgdata.process_warnings |= LIBRAW_WARN_PARSEFUJI_PROCESSED;\n#endif\n  while (entries--)\n  {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100)\n    {\n      raw_height = get2();\n      raw_width = get2();\n    }\n    else if (tag == 0x121)\n    {\n      height = get2();\n      if ((width = get2()) == 4284)\n        width += 3;\n    }\n    else if (tag == 0x130)\n    {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    }\n    else if (tag == 0x131)\n    {\n      filters = 9;\n      FORC(36)\n      {\n        int q = fgetc(ifp);\n        xtrans_abs[0][35 - c] = MAX(0, MIN(q, 2)); /* & 3;*/\n      }\n    }\n    else if (tag == 0x2ff0)\n    {\n      FORC4 cam_mul[c ^ 1] = get2();\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n\n    else if (tag == 0x110)\n    {\n      imgdata.sizes.raw_crop.ctop = get2();\n      imgdata.sizes.raw_crop.cleft = get2();\n    }\n\n    else if (tag == 0x111)\n    {\n      imgdata.sizes.raw_crop.cheight = get2();\n      imgdata.sizes.raw_crop.cwidth = get2();\n    }\n\n    else if ((tag == 0x122) && !strcmp(model, \"DBP for GX680\"))\n    {\n      int k = get2();\n      int l = get2(); /* margins? */\n      int m = get2(); /* margins? */\n      int n = get2();\n      //      printf (\"==>>0x122: height= %d l= %d m= %d width= %d\\n\", k, l, m, n);\n    }\n\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b = fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    }\n\n    else if (tag == 0x2f00)\n    {\n      int nWBs = get4();\n      nWBs = MIN(nWBs, 6);\n      for (int wb_ind = 0; wb_ind < nWBs; wb_ind++)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + wb_ind][c ^ 1] = get2();\n        fseek(ifp, 8, SEEK_CUR);\n      }\n    }\n\n    else if (tag == 0x2000)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ 1] = get2();\n    }\n    else if (tag == 0x2100)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][c ^ 1] = get2();\n    }\n    else if (tag == 0x2200)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ 1] = get2();\n    }\n    else if (tag == 0x2300)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    }\n    else if (tag == 0x2301)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    }\n    else if (tag == 0x2302)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    }\n    else if (tag == 0x2310)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    }\n    else if (tag == 0x2400)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n    }\n    else if (tag == 0x2410)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ 1] = get2();\n#endif\n      // IB end\n    }\n    else if (tag == 0xc000)\n    /* 0xc000 tag versions, second ushort; valid if the first ushort is 0\n    X100F\t0x0259\n    X100T\t0x0153\n    X-E2\t0x014f\t0x024f depends on firmware\n    X-A1\t0x014e\n    XQ2\t\t0x0150\n    XQ1\t\t0x0150\n    X100S\t0x0149\t0x0249 depends on firmware\n    X30\t\t0x0152\n    X20\t\t0x0146\n    X-T10\t0x0154\n    X-T2\t0x0258\n    X-M1\t0x014d\n    X-E2s\t0x0355\n    X-A2\t0x014e\n    X-T20\t0x025b\n    GFX 50S\t0x025a\n    X-T1\t0x0151\t0x0251 0x0351 depends on firmware\n    X70\t\t0x0155\n    X-Pro2\t0x0255\n    */\n    {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000)\n        tag = get4();\n      if (tag > 10000)\n        tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strcmp(model, \"X-A3\")  ||\n          !strcmp(model, \"X-A10\") ||\n          !strcmp(model, \"X-A5\")  ||\n          !strcmp(model, \"X-A20\"))\n      {\n        int wb[4];\n        int nWB, tWB, pWB;\n        int iCCT = 0;\n        int cnt;\n        fseek(ifp, save + 0x200, SEEK_SET);\n        for (int wb_ind = 0; wb_ind < 42; wb_ind++)\n        {\n          nWB = get4();\n          tWB = get4();\n          wb[0] = get4() << 1;\n          wb[1] = get4();\n          wb[3] = get4();\n          wb[2] = get4() << 1;\n          if (tWB && (iCCT < 255))\n          {\n            imgdata.color.WBCT_Coeffs[iCCT][0] = tWB;\n            for (cnt = 0; cnt < 4; cnt++)\n              imgdata.color.WBCT_Coeffs[iCCT][cnt + 1] = wb[cnt];\n            iCCT++;\n          }\n          if (nWB != 70)\n          {\n            for (pWB = 1; pWB < nFuji_wb_list2; pWB += 2)\n            {\n              if (Fuji_wb_list2[pWB] == nWB)\n              {\n                for (cnt = 0; cnt < 4; cnt++)\n                  imgdata.color.WB_Coeffs[Fuji_wb_list2[pWB - 1]][cnt] = wb[cnt];\n                break;\n              }\n            }\n          }\n        }\n      }\n      else\n      {\n        libraw_internal_data.unpacker_data.posRAFData = save;\n        libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);\n      }\n#endif\n      order = c;\n    }\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width >>= fuji_layout;\n}\n\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n        && (save + hlen) >= 0 && (save + hlen) <= ifp->size()\n#endif\n            ) /* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  struct tm t;\n\n  order = 0x4949;\n  fread(tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag, \"RIFF\", 4) || !memcmp(tag, \"LIST\", 4))\n  {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp) + 7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  }\n  else if (!memcmp(tag, \"nctg\", 4))\n  {\n    while (ftell(ifp) + 7 < end)\n    {\n      i = get2();\n      size = get2();\n      if ((i + 1) >> 1 == 10 && size == 20)\n        get_timestamp(0);\n      else\n        fseek(ifp, size, SEEK_CUR);\n    }\n  }\n  else if (!memcmp(tag, \"IDIT\", 4) && size < 64)\n  {\n    fread(date, 64, 1, ifp);\n    date[size] = 0;\n    memset(&t, 0, sizeof t);\n    if (sscanf(date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6)\n    {\n      for (i = 0; i < 12 && strcasecmp(mon[i], month); i++)\n        ;\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n        timestamp = mktime(&t);\n    }\n  }\n  else\n    fseek(ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt(int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp) + 7 < end)\n  {\n    save = ftell(ifp);\n    if ((size = get4()) < 8)\n      return;\n    fread(tag, 4, 1, ifp);\n    if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))\n      parse_qt(save + size);\n    if (!memcmp(tag, \"CNDA\", 4))\n      parse_jpeg(ftell(ifp));\n    fseek(ifp, save + size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal(int offset, int fsize)\n{\n  int ver;\n\n  fseek(ifp, offset + 2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek(ifp, 5, SEEK_CUR);\n  if (get4() != fsize)\n    return;\n  if (ver > 6)\n    data_offset = get4();\n  raw_height = height = get2();\n  raw_width = width = get2();\n  strcpy(make, \"SMaL\");\n  sprintf(model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6)\n    load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9)\n    load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek(ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4()))\n    timestamp = i;\n  fseek(ifp, off_head + 4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(), get2())\n  {\n  case 8:\n    load_raw = &CLASS eight_bit_load_raw;\n    break;\n  case 16:\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  fseek(ifp, off_setup + 792, SEEK_SET);\n  strcpy(make, \"CINE\");\n  sprintf(model, \"%d\", get4());\n  fseek(ifp, 12, SEEK_CUR);\n  switch ((i = get4()) & 0xffffff)\n  {\n  case 3:\n    filters = 0x94949494;\n    break;\n  case 4:\n    filters = 0x49494949;\n    break;\n  default:\n    is_raw = 0;\n  }\n  fseek(ifp, 72, SEEK_CUR);\n  switch ((get4() + 3600) % 360)\n  {\n  case 270:\n    flip = 4;\n    break;\n  case 180:\n    flip = 1;\n    break;\n  case 90:\n    flip = 7;\n    break;\n  case 0:\n    flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek(ifp, 668, SEEK_CUR);\n  shutter = get4() / 1000000000.0;\n  fseek(ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek(ifp, shot_select * 8, SEEK_CUR);\n  data_offset = (INT64)get4() + 8;\n  data_offset += (INT64)get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek(ifp, 52, SEEK_SET);\n  width = get4();\n  height = get4();\n  fseek(ifp, 0, SEEK_END);\n  fseek(ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek(ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF)\n    {\n      if (get4() == 0x52454456)\n        if (is_raw++ == shot_select)\n          data_offset = ftello(ifp) - 8;\n      fseek(ifp, len - 8, SEEK_CUR);\n    }\n  }\n  else\n  {\n    rdvo = get4();\n    fseek(ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko(ifp, rdvo + 8 + shot_select * 4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff(const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n                       ,\n                       int internal_only\n#endif\n)\n{\n  // clang-format off\n  static const struct\n  {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0, /* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n\n    { \"Apple QuickTake\", 0, 0, /* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } }, /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0, /* updated */\n      { 9900,-2771,-1324,-7072,14229,3140,-2790,3344,8861 } },\n    { \"Canon EOS D60\", 0, 0xfa0, /* updated */\n      { 6211,-1358,-896,-8557,15766,3012,-3001,3507,8567 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446,-366,-864,-4436,12204,2513,-952,2496,6348 } },\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D Mark II\", 0, 0x38de, /* updated */\n      { 6875,-970,-932,-4691,12459,2501,-874,1953,5809 } },\n    { \"Canon EOS 6D\", 0, 0x3c82, /* skipped update */\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 77D\", 0, 0,\n      { 7377,-742,-998,-4235,11981,2549,-673,1918,5538 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 800D\", 0, 0,\n      { 6970,-512,-968,-4425,12161,2553,-739,1982,5601 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0, /* updated */\n      { 8250,-2044,-1127,-8092,15606,2664,-2893,3453,8348 } },\n    { \"Canon EOS 200D\", 0, 0,\n      { 7377,-742,-998,-4235,11981,2549,-673,1918,5538 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60Da\", 0, 0x2ff7, /* added */\n      { 17492,-7240,-2023,-1791,10323,1701,-186,1329,5406 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0, /* updated */\n      { 8250,-2044,-1127,-8092,15606,2664,-2893,3453,8348 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939,-1016,-866,-4428,12473,2177,-1175,2178,6162 } },\n    { \"Canon EOS M6\", 0, 0,\n      { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },\n    { \"Canon EOS M5\", 0, 0,\n      { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M2\", 0, 0, /* added */\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M100\", 0, 0,\n      { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20, /* updated */\n      { 3925,4060,-1739,-8973,16552,2545,-3287,3945,8243 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e, /* updated */\n      { 7596,-978,-967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0, /* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    {\"Canon PowerShot 600\", 0, 0, /* added */\n      { -3822,10019,1311,4085,-157,3386,-5341,10829,4812,-1969,10969,1126 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } }, /* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0, /* updated */\n      { 8020,-2687,-682,-3704,11879,2052,-965,1921,5556 } },\n    { \"Canon PowerShot G1 X Mark III\", 0, 0,\n      { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0, /* updated */\n      { -5686,10300,2223,4725,-1157,4383,-6128,10783,6163,-2688,12093,604 } },\n    { \"Canon PowerShot G2\", 0, 0, /* updated */\n      { 9194,-2787,-1059,-8098,15657,2608,-2610,3064,7867 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0, /* updated */\n      { 9326,-2882,-1084,-7940,15447,2677,-2620,3090,7740 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0, /* updated */\n      { 9869,-2972,-942,-7314,15098,2369,-1898,2536,7282 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X Mark II\", 0, 0,\n      { 10056,-4131,-944,-2576,11143,1625,-238,1294,5179 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0, /* updated */\n      { -5106,10695,1576,3820,53,4566,-6497,10736,6701,-3336,11887,1394 } },\n    { \"Canon PowerShot Pro90\", 0, 0, /* updated */\n      { -5912,10768,2288,4612,-989,4333,-6153,10897,5944,-2907,12288,624 } },\n    { \"Canon PowerShot S30\", 0, 0, /* updated */\n      { 10744,-3813,-1142,-7962,15966,2075,-2492,2805,7744 } },\n    { \"Canon PowerShot S40\", 0, 0, /* updated */\n      { 8606,-2573,-949,-8237,15489,2974,-2649,3076,9100 } },\n    { \"Canon PowerShot S45\", 0, 0, /* updated */\n      { 8251,-2410,-964,-8047,15430,2823,-2380,2824,8119 } },\n    { \"Canon PowerShot S50\", 0, 0, /* updated */\n      { 8979,-2658,-871,-7721,15500,2357,-1773,2366,6634 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0, /* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0, /* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0, /* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0, /* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0, /* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0, /* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0, /* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0, /* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot D10\", 127, 0, /* DJC */\n      { 14052,-5229,-1156,-1325,9420,2252,-498,1957,4116 } },\n    { \"Canon PowerShot S3 IS\", 0, 0, /* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0, /* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0, /* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0, /* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n\n    { \"Casio EX-F1\", 0, 0, /* added */\n      { 9084,-2016,-848,-6711,14351,2570,-1059,1725,6135 } },\n    { \"Casio EX-FH100\", 0, 0, /* added */\n      { 12771,-4179,-1558,-2149,10938,1375,-453,1751,4494 } },\n    { \"Casio EX-S20\", 0, 0, /* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0, /* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff, /* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n\n    { \"Fujifilm E550\", 0, 0, /* updated */\n      { 11044,-3888,-1120,-7248,15167,2208,-1531,2276,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F810\", 0, 0, /* added */\n      { 11044,-3888,-1120,-7248,15167,2208,-1531,2276,8069 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0, /* updated */\n      { 12741,-4916,-1420,-8510,16791,1715,-1767,2302,7771 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100F\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A10\", 0, 0,\n      { 11540,-4999,-991,-2949,10963,2278,-382,1049,5605} },\n\n    { \"Fujifilm X-A20\", 0, 0, /* temp */\n      { 11540,-4999,-991,-2949,10963,2278,-382,1049,5605} },\n\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-A3\", 0, 0,\n      { 12407,-5222,-1086,-2971,11116,2120,-294,1029,5284 } },\n\n    { \"Fujifilm X-A5\", 0, 0, /* temp */\n      { 12407,-5222,-1086,-2971,11116,2120,-294,1029,5284 } },\n\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-E3\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T20\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-T10\", 0, 0, /* updated */\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-H1\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm GFX 50S\", 0, 0,\n      { 11756,-4754,-874,-3056,11045,2305,-381,1457,6006 } },\n\n    { \"GITUP GIT2P\", 4160, 0,\n      { 8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"GITUP GIT2\", 3200, 0,\n      { 8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n\n    { \"Hasselblad HV\", 0, 0, /* added */\n      { 6344,-1612,-461,-4862,12476,2680,-864,1785,6898 } },\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Lusso\", 0, 0, /* added */\n      { 4912,-540,-201,-6129,13513,2906,-1563,2151,7182 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad 500 mech.\", 0, 0, /* added */\n      { 8519,-3260,-280,-5081,13459,1738,-1449,2960,7809 } },\n    { \"Hasselblad CFV\", 0, 0,\n      { 8519,-3260,-280,-5081,13459,1738,-1449,2960,7809 } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad 39-Coated\", 0, 0, /* added */\n      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },\n    { \"Hasselblad H-39MP\",0, 0,\n      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },\n    { \"Hasselblad H2D-39\", 0, 0, /* added */\n      { 3894,-110,287,-4672,12610,2295,-2092,4100,6196 } },\n    { \"Hasselblad H3D-50\", 0, 0,\n      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },\n    { \"Hasselblad H3D\", 0, 0, /* added */\n      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0,\n      { 9662,-684,-279,-4903,12293,2950,-344,1669,6024 } },\n    { \"Hasselblad H5D-50c\",0, 0,\n      { 4932,-835,141,-4878,11868,3437,-1138,1961,7067 } },\n    { \"Hasselblad H5D-50\",0, 0,\n      { 5656,-659,-346,-3923,12306,1791,-1602,3509,5442 } },\n    { \"Hasselblad H6D-100c\",0, 0,\n      { 5110,-1357,-308,-5573,12835,3077,-1279,2025,7010 } },\n    { \"Hasselblad X1D\",0, 0,\n      { 4932,-835,141,-4878,11868,3437,-1138,1961,7067 } },\n\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n\n    { \"Imacon Ixpress\", 0, 0, /* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Photo Control Camerz ZDS 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n\n    { \"Leaf C-Most\", 0, 0, /* updated */\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus-II 8\", 0, 0, /* added */\n      { 7361,1257,-163,-6929,14061,3176,-1839,3454,5603 } },\n    { \"Leaf AFi-II 7\", 0, 0, /* added */\n      { 7691,-108,-339,-6185,13627,2833,-2046,3899,5952 } },\n    { \"Leaf Aptus-II 5\", 0, 0, /* added */\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf AFi 65S\", 0, 0, /* added */\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf AFi 75S\", 0, 0, /* added */\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984,0,0,0,10000,0,0,0,7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294,686,-712,-5435, 13417,2211,-1006,2435,5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n\n    { \"Leica M10\", 0, 0, /* added */\n      { 9090,-3342,-740,-4006,13456,493,-569,2266,6871 } },\n    { \"Leica M9\", 0, 0, /* added */\n      { 6687,-1751,-291,-3556,11373,2492,-548,2204,7146 } },\n    { \"Leica M8\", 0, 0, /* added */\n      { 7675,-2196,-305,-5860,14119,1856,-2425,4006,6578 } },\n    { \"Leica M (Typ 240)\", 0, 0, /* added */\n      { 7199,-2140,-712,-4005,13327,649,-810,2521,6673 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n      { 7199,-2140,-712,-4005,13327,649,-810,2521,6673 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Leica S2\", 0, 0, /* added */\n      { 5627,-721,-447,-4423,12456,2192,-1048,2948,7379 } },\n    {\"Leica S-E (Typ 006)\", 0, 0, /* added */\n      { 5749,-1072,-382,-4274,12432,2048,-1166,3104,7105 } },\n    {\"Leica S (Typ 006)\", 0, 0, /* added */\n      { 5749,-1072,-382,-4274,12432,2048,-1166,3104,7105 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n      { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica Q (Typ 116)\", 0, 0, /* updated */\n      { 10068,-4043,-1068,-5319,14268,1044,-765,1701,6522 } },\n    { \"Leica T (Typ 701)\", 0, 0, /* added */\n      { 6295 ,-1679 ,-475 ,-5586 ,13046 ,2837 ,-1410 ,1889 ,7075 } },\n    { \"Leica X2\", 0, 0, /* added */\n      { 8336,-2853,-699,-4425,11989,2760,-954,1625,6396 } },\n    { \"Leica X1\", 0, 0, /* added */\n      { 9055,-2611,-666,-4906,12652,2519,-555,1384,7417 } },\n    { \"Leica X\", 0, 0, /* X(113), X-U(113), XV, X Vario(107) */ /* updated */\n      { 9062,-3198,-828,-4065,11772,2603,-761,1468,6458 } },\n\n    { \"Mamiya M31\", 0, 0, /* added */\n      { 4516 ,-244 ,-36 ,-7020 ,14976 ,2174 ,-3206 ,4670 ,7087 } },\n    { \"Mamiya M22\", 0, 0, /* added */\n      { 2905 ,732 ,-237 ,-8135 ,16626 ,1476 ,-3038 ,4253 ,7517 } },\n    { \"Mamiya M18\", 0, 0, /* added */\n      { 6516 ,-2050 ,-507 ,-8217 ,16703 ,1479 ,-3492 ,4741 ,8489 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n\n    { \"Micron 2010\", 110, 0, /* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n\n    { \"Minolta DiMAGE 5\", 0, 0xf7d, /* updated */\n      { 9117,-3063,-973,-7949,15763,2306,-2752,3136,8093 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d, /* updated */\n      { 11555,-4064,-1256,-7903,15633,2409,-2811,3320,7358 } },\n    { \"Minolta DiMAGE 7i\", 0, 0xf7d, /* added */\n      { 11050,-3791,-1199,-7875,15585,2434,-2797,3359,7560 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d, /* updated */\n      { 9258,-2879,-1008,-8076,15847,2351,-2806,3280,7821 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b, /* updated */\n      { 9274,-2548,-1167,-8220,16324,1943,-2273,2721,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0, /* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta Maxxum 5D\", 0, 0xffb, /* added */\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta ALPHA-5 DIGITAL\", 0, 0xffb, /* added */\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta ALPHA SWEET DIGITAL\", 0, 0xffb, /* added */\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Minolta Maxxum 7D\", 0, 0xffb, /* added */\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Minolta ALPHA-7 DIGITAL\", 0, 0xffb, /* added */\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n\n    { \"Motorola PIXL\", 0, 0, /* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0, /* updated */\n      { 7659,-2238,-935,-8942,16969,2004,-2701,3051,8690 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5733,-911,-629,-7967,15987,2055,-3050,4013,7048 } },\n    { \"Nikon D2X\", 0, 0, /* updated */\n      { 10231,-2768,-1254,-8302,15900,2551,-797,681,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D5600\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0, /* updated */\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7500\", 0, 0,\n      { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D850\", 0, 0,\n      { 10405,-3755,-1270,-5461,13787,1793,-1040,2015,6785 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973,-5685,-888,-1965,10326,1901,-115,1123,7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd, /* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd, /* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd, /* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0, /* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0, /* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0, /* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0, /* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0, /* updated */\n      { -6678,12805,2248,5725,-499,3375,-5903,10713,6034,-270,9976,134 } },\n    { \"Nikon E5400\", 0, 0, /* updated */\n      { 9349,-2988,-1001,-7918,15766,2266,-2097,2680,6839 } },\n    { \"Nikon E5700\", 0, 0, /* updated */\n      { -6475,12496,2428,5409,-16,3180,-5965,10912,5866,-177,9918,248 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX Kalon\", 0, 0, /* added */\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX Deneb\", 0, 0, /* added */\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835 } },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0, /* updated */\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0, /* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0, /* updated */\n      { 10633,-3234,-1285,-7460,15570,1967,-1917,2510,6299 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc, /* updated */\n      { 12970,-4703,-1433,-7466,15843,1644,-2191,2451,6668 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc, /* updated */\n      { 13414,-4950,-1517,-7166,15293,1960,-2325,2664,7212 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL9\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII, E-M10MarkIII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0,\n      { 9383,-3170,-763,-2457,10702,2020,-384,1236,5552 } },\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP565UZ\", 0, 0, /* added */\n      { 11856,-4469,-1159,-4814,12368,2756,-993,1779,5589 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0, /* updated */\n      { 8360,-2420,-880,-3928,12353,1739,-1381,2416,5173 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus TG-5\", 0, 0,\n     { 10899,-3833,-1082,-2112,10736,1575,-267,1452,5269 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax GR\", 0, 0, /* added */\n      { 5329,-1459,-390,-5407,12930,2768,-1119,1772,6046 } },\n    { \"Pentax K-01\", 0, 0, /* added */\n      { 8134,-2728,-645,-4365,11987,2694,-838,1509,6498 } },\n    { \"Pentax K10D\", 0, 0, /* updated */\n      { 9679,-2965,-811,-8622,16514,2182,-975,883,9793 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0, /* updated */\n      { 9730,-2989,-970,-8527,16258,2381,-1060,970,8362 } },\n    { \"Pentax K-m\", 0, 0, /* updated */\n      { 9730,-2989,-970,-8527,16258,2381,-1060,970,8362 } },\n    { \"Pentax KP\", 0, 0,\n      { 7825,-2160,-1403,-4841,13555,1349,-1559,2449,5814 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0, /* updated */\n      { 8596,-2981,-639,-4202,12046,2431,-685,1424,6122 } },\n    { \"Pentax K-30\", 0, 0, /* updated */\n      { 8134,-2728,-645,-4365,11987,2694,-838,1509,6498 } },\n    { \"Pentax K-3 II\", 0, 0, /* updated */\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-500\", 0, 0, /* added */\n      { 8109,-2740,-608,-4593,12175,2731,-1006,1515,6545 } },\n    { \"Pentax K-50\", 0, 0, /* added */\n      { 8109,-2740,-608,-4593,12175,2731,-1006,1515,6545 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      { 8766,-3149,-747,-3976,11943,2292,-517,1259,5552 } },\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax KP\", 0, 0,  /* temp */\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax Q7\", 0, 0, /* added */\n      { 10901,-3938,-1025,-2743,11210,1738,-823,1805,5344 } },\n    { \"Pentax Q10\", 0, 0, /* updated */\n      { 11562,-4183,-1172,-2357,10919,1641,-582,1726,5112 } },\n    { \"Pentax Q\", 0, 0, /* added */\n      { 11731,-4169,-1267,-2015,10727,1473,-217,1492,4870 } },\n    { \"Pentax MX-1\", 0, 0, /* updated */\n      { 9296,-3146,-888,-2860,11287,1783,-618,1698,5151 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* updated */\n      { 9519,-3591,-664,-4074,11725,2671,-624,1501,6653 } },\n\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770,-3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770,-3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DC-FZ82\", -15, 0, /* markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-FZ80\", -15, 0, /* markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0, /* 40,42,45 */\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Leica V-LUX 1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX3\", 0, 0xf7f, /* added */\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX2\", 0, 0, /* added */\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Panasonic DMC-LX9\", -15, 0, /* markets: LX9 LX10 LX15 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-LX10\", -15, 0, /* markets: LX9 LX10 LX15 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-LX15\", -15, 0, /* markets: LX9 LX10 LX15 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-LUX 2\", 0, 0xf7f, /* added */\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX 3\", 0, 0, /* added */\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000, DMC-FZ2500 ,FZH1 */\n      { 7386,-2443,-743,-3437,11864,1757,-608,1660,4766 } },\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386,-2443,-743,-3437,11864,1757,-608,1660,4766 } },\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386,-2443,-743,-3437,11864,1757,-608,1660,4766 } },\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-FX180\", -15, 0xfff, /* added */\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff, /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-G9\", -15, 0,\n      { 7685,-2375,-634,-3687,11700,2249,-748,1546,5111 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic AG-GH4\", -15, 0, /* added */\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    {\"Panasonic DC-GH5s\", -15, 0,\n      { 6929,-2355,-708,-4192,12534,1828,-1097,1989,5195 } },\n    { \"Panasonic DC-GH5\", -15, 0,\n      { 7641,-2336,-605,-3218,11299,2187,-485,1338,5121 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n\n    { \"Panasonic DC-GF10\", -15, 0, /* temp, markets: GF10, GF90 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GF90\", -15, 0, /* temp, markets: GF10, GF90 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n\n    { \"Panasonic DC-GX850\", -15, 0, /* markets: GX850 GX800 GF9 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GX800\", -15, 0, /* markets: GX850 GX800 GF9 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GF9\", -15, 0, /* markets: GX850 GX800 GF9 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX85\", -15, 0, /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0, /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0, /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n\n    { \"Panasonic DC-GX9\", -15, 0, /* temp */\n      { 7685,-2375,-634,-3687,11700,2249,-748,1546,5111 } },\n\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0, /* markets: ZS60 TZ80 TZ81 TZ82 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-TZ90\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DC-TZ91\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DC-TZ92\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DC-T93\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DMC-ZS4\", -15, 0, /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0, /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0, /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0, /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-ZS70\", -15, 0, /* markets: ZS70  TZ90 TZ91 TZ92 T93 */\n      { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },\n    { \"Panasonic DMC-ZS100\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0, /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n\n    { \"Panasonic DC-ZS200\", -15, 0, /* temp, markets: ZS200 TZ200 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DC-TZ200\", -15, 0, /* temp, markets: ZS200 TZ200 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n\n    { \"Phase One H 20\", 0, 0, /* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H20\", 0, 0, /* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One H25\", 0, 0, /* added */\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ280\", 0, 0, /* added */\n      { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },\n    { \"Phase One IQ260\", 0, 0, /* added */\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One IQ250\",0, 0,\n//    {3984,0,0,0,10000,0,0,0,7666}},\n      {10325,845,-604,-4113,13385,481,-1791,4163,6924}}, /* emb */\n    { \"Phase One IQ180\", 0, 0, /* added */\n      { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },\n    { \"Phase One IQ160\", 0, 0, /* added */\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One IQ150\", 0, 0, /* added */\n      {10325,845,-604,-4113,13385,481,-1791,4163,6924}}, /* temp */ /* emb */\n//      { 3984,0,0,0,10000,0,0,0,7666 } },\n    { \"Phase One IQ140\", 0, 0, /* added */\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P 65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P45\", 0, 0, /* added */\n      { 5053,-24,-117,-5685,14077,1703,-2619,4491,5850 } },\n    { \"Phase One P 45\", 0, 0, /* added */\n      { 5053,-24,-117,-5685,14077,1703,-2619,4491,5850 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P 40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P30\", 0, 0, /* added */\n      { 4516,-244,-36,-7020,14976,2174,-3206,4670,7087 } },\n    { \"Phase One P 30\", 0, 0, /* added */\n      { 4516,-244,-36,-7020,14976,2174,-3206,4670,7087 } },\n    { \"Phase One P25\", 0, 0, /* added */\n      { 2905,732,-237,-8135,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 25\", 0, 0, /* added */\n      { 2905,732,-237,-8135,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P21\", 0, 0, /* added */\n      { 6516,-2050,-507,-8217,16703,1479,-3492,4741,8489 } },\n    { \"Phase One P 21\", 0, 0, /* added */\n      { 6516,-2050,-507,-8217,16703,1479,-3492,4741,8489 } },\n    { \"Phase One P20\", 0, 0, /* added */\n      { 2905,732,-237,-8135,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P20\", 0, 0, /* added */\n      { 2905,732,-237,-8135,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ3 100MP\", 0, 0, /* added */\n//    {2423,0,0,0,9901,0,0,0,7989}},\n      { 10999,354,-742,-4590,13342,937,-1060,2166,8120} }, /* emb */\n    { \"Phase One IQ3 80MP\", 0, 0, /* added */\n      { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },\n    { \"Phase One IQ3 60MP\", 0, 0, /* added */\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One IQ3 50MP\", 0, 0, /* added */\n//      { 3984,0,0,0,10000,0,0,0,7666 } },\n      {10058,1079,-587,-4135,12903,944,-916,2726,7480}}, /* emb */\n    { \"Photron BC2-HD\", 0, 0, /* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n\n    { \"Polaroid x530\", 0, 0,\n      { 13458,-2556,-510,-5444,15081,205,0,0,12120 } },\n\n    { \"Red One\", 704, 0xffff, /* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n\n    { \"Ricoh S10 24-72mm F2.5-4.4 VC\", 0, 0, /* added */\n      { 10531,-4043,-878,-2038,10270,2052,-107,895,4577 } },\n    { \"Ricoh GR A12 50mm F2.5 MACRO\", 0, 0, /* added */\n      { 8849,-2560,-689,-5092,12831,2520,-507,1280,7104 } },\n    { \"Ricoh GR DIGITAL 3\", 0, 0, /* added */\n      { 8170,-2496,-655,-5147,13056,2312,-1367,1859,5265 } },\n    { \"Ricoh GR DIGITAL 4\", 0, 0, /* added */\n      { 8771,-3151,-837,-3097,11015,2389,-703,1343,4924 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n      { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Ricoh GX200\", 0, 0, /* added */\n      { 8040,-2368,-626,-4659,12543,2363,-1125,1581,5660 } },\n    { \"Ricoh RICOH GX200\", 0, 0, /* added */\n      { 8040,-2368,-626,-4659,12543,2363,-1125,1581,5660 } },\n    { \"Ricoh GXR MOUNT A12\", 0, 0, /* added */\n      { 7834,-2182,-739,-5453,13409,2241,-952,2005,6620 } },\n    { \"Ricoh GXR A16\", 0, 0, /* added */\n      { 7837,-2538,-730,-4370,12184,2461,-868,1648,5830 } },\n    { \"Ricoh GXR A12\", 0, 0, /* added */\n      { 10228,-3159,-933,-5304,13158,2371,-943,1873,6685 } },\n\n    { \"Samsung EK-GN100\", 0, 0, /* added */ /* Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EK-GN110\", 0, 0, /* added */ /* Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EK-KN120\", 0, 0, /* added */ /* Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung Galaxy S7 Edge\", 0, 0, /* added */\n      { 9927,-3704,-1024,-3935,12758,1257,-389,1512,4993 } },\n    { \"Samsung Galaxy S7\", 0, 0, /* added */\n      { 9927,-3704,-1024,-3935,12758,1257,-389,1512,4993 } },\n    { \"Samsung Galaxy NX\", 0, 0, /* added */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX U\", 0, 0, /* added */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0, /* used for NX30/NX300/NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff, /* used for NX20/NX200/NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0, /* used for NX10/NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NXF1\", 0, 0, /* added */\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX10\", 0, 0, /* added */ /* Pentax K10D */\n      { 9679,-2965,-811,-8622,16514,2182,-975,883,9793 } },\n    { \"Samsung GX-10\", 0, 0, /* added */ /* Pentax K10D */\n      { 9679,-2965,-811,-8622,16514,2182,-975,883,9793 } },\n    { \"Samsung GX-1\", 0, 0, /* used for GX-1L/GX-1S */\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0, /* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung GX-20\", 0, 0, /* added */ /* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0, /* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n\n// Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0,\n      { 1295,108,-311, 256,828,-65,-28,750,254 } }, /* temp */\n    { \"Sigma sd Quattro\", 2047, 0,\n      { 1295,108,-311, 256,828,-65,-28,750,254 } }, /* temp */\n    { \"Sigma SD9\", 15, 4095, /* updated */\n      { 13564,-2537,-751,-5465,15154,194,-67,116,10425 } },\n    { \"Sigma SD10\", 15, 16383, /* updated */\n      { 6787,-1682,575,-3091,8357,160,217,-369,12314 } },\n    { \"Sigma SD14\", 15, 16383, /* updated */\n      { 13589,-2509,-739,-5440,15104,193,-61,105,10554 } },\n    { \"Sigma SD15\", 15, 4095, /* updated */\n      { 13556,-2537,-730,-5462,15144,195,-61,106,10577 } },\n// Merills + SD1\n    { \"Sigma SD1\", 31, 4095, /* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095, /* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095, /* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095, /* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n// Sigma DP (non-Merill Versions)\n    { \"Sigma DP1X\", 0, 4095, /* updated */\n      { 13704,-2452,-857,-5413,15073,186,-89,151,9820 } },\n    { \"Sigma DP1\", 0, 4095, /* updated */\n      { 12774,-2591,-394,-5333,14676,207,15,-21,12127 } },\n    { \"Sigma DP\", 0, 4095, /* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n\n    { \"Sinar\", 0, 0, /* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100M\", -800, 0, /* used for M2/M3/M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    {\"Sony DSC-RX10M4\", -800, 0,\n      { 7699,-2566,-629,-2967,11270,1928,-378,1286,4807 } },\n    { \"Sony DSC-RX10\",0, 0, /* same for M2/M3 */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0, /* updated */\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n\n    {\"Sony DSC-RX0\", -800, 0, /* temp */\n      { 9396,-3507,-843,-2497,11111,1572,-343,1355,5089 } },\n\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 16596,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 16596,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A550\", 0, 16596,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb, /* Is there any cameras not covered above? */\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0,\n      { 6660,-1918,-471,-4613,12398,2485,-649,1433,6447 } },\n    { \"Sony ILCE-9\", 0, 0,\n      { 6389,-1703,-378,-4562,12265,2587,-670,1489,6550 } },\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM3\", 0, 0,\n      { 6640,-1847,-503,-5238,13010,2474,-993,1673,6527 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0, /* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony MODEL-NAME\", 0, 0, /* added */\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX-VG30\", 0, 0, /* added */\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-VG900\", 0, 0, /* added */\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony NEX\", 0, 0, /* NEX-C3, NEX-F3, NEX-VG20 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  // clang-format on\n\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if (colors > 4 || colors < 1)\n    return;\n\n  int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;\n  if (cblack[4] * cblack[5] > 0)\n  {\n    for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)\n      bl64 += cblack[c + 6];\n    bl64 /= cblack[4] * cblack[5];\n  }\n  int rblack = black + bl4 + bl64;\n\n  sprintf(name, \"%s %s\", t_make, t_model);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix)))\n    {\n      if (!dng_version)\n      {\n        if (table[i].t_black > 0)\n        {\n          black = (ushort)table[i].t_black;\n          memset(cblack, 0, sizeof(cblack));\n        }\n        else if (table[i].t_black < 0 && rblack == 0)\n        {\n          black = (ushort)(-table[i].t_black);\n          memset(cblack, 0, sizeof(cblack));\n        }\n        if (table[i].t_maximum)\n          maximum = (ushort)table[i].t_maximum;\n      }\n      if (table[i].trans[0])\n      {\n        for (raw_color = j = 0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (internal_only)\n            imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n          else\n            imgdata.color.cam_xyz[0][j] =\n#endif\n                ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!internal_only)\n#endif\n          cam_xyz_coeff(rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff(int index)\n{\n  static const float table[][12] = {/* index 0 -- all Foveon cameras */\n                                    {1.4032, -0.2231, -0.1016, -0.5263, 1.4816, 0.017, -0.0112, 0.0183, 0.9113},\n                                    /* index 1 -- Kodak DC20 and DC25 */\n                                    {2.25, 0.75, -1.75, -0.25, -0.25, 0.75, 0.75, -0.25, -0.25, -1.75, 0.75, 2.25},\n                                    /* index 2 -- Logitech Fotoman Pixtura */\n                                    {1.893, -0.418, -0.476, -0.495, 1.773, -0.278, -1.017, -0.655, 2.672},\n                                    /* index 3 -- Nikon E880, E900, and E990 */\n                                    {-1.936280, 1.800443, -1.448486, 2.584324, 1.405365, -0.524955, -0.289090, 0.408680,\n                                     -1.204965, 1.082304, 2.941367, -1.818705}};\n  int i, c;\n\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i * colors + c];\n}\n\nshort CLASS guess_byte_order(int words)\n{\n  uchar test[4][2];\n  int t = 2, msb;\n  double diff, sum[2] = {0, 0};\n\n  fread(test[0], 2, 2, ifp);\n  for (words -= 2; words--;)\n  {\n    fread(test[t], 2, 1, ifp);\n    for (msb = 0; msb < 2; msb++)\n    {\n      diff = (test[t ^ 2][msb] << 8 | test[t ^ 2][!msb]) - (test[t][msb] << 8 | test[t][!msb]);\n      sum[msb] += diff * diff;\n    }\n    t = (t + 1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green(int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf = 0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[] = {0, 0};\n  if(width > 2064) return 0.f; // too wide\n\n  FORC(2)\n  {\n    fseek(ifp, c ? off1 : off0, SEEK_SET);\n    for (vbits = col = 0; col < width; col++)\n    {\n      for (vbits -= bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);\n    }\n  }\n  FORC(width - 1)\n  {\n    sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);\n    sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);\n  }\n  return 100 * log(sum[0] / sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if (len < 1)\n    return; // not needed, b/c sizeof of make/model is 64\n  string[len - 1] = 0;\n  if (len < 3)\n    return; // also not needed\n  len = strnlen(string, len - 1);\n  for (int i = len - 1; i >= 0; i--)\n  {\n    if (isspace((unsigned char)string[i]))\n      string[i] = 0;\n    else\n      break;\n  }\n}\n\nvoid CLASS initdata()\n{\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n  for (int i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n  for (int i = 0; i < 0x10000; i++)\n    curve[i] = i;\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n}\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n      {3130, 1743, 4, 0, -6, 0},    {3130, 2055, 4, 0, -6, 0},      {3130, 2319, 4, 0, -6, 0},\n      {3170, 2103, 18, 0, -42, 20}, {3170, 2367, 18, 13, -42, -21}, {3177, 2367, 0, 0, -1, 0},\n      {3304, 2458, 0, 0, -1, 0},    {3330, 2463, 9, 0, -5, 0},      {3330, 2479, 9, 0, -17, 4},\n      {3370, 1899, 15, 0, -44, 20}, {3370, 2235, 15, 0, -44, 20},   {3370, 2511, 15, 10, -44, -21},\n      {3690, 2751, 3, 0, -8, -3},   {3710, 2751, 0, 0, -3, 0},      {3724, 2450, 0, 0, 0, -2},\n      {3770, 2487, 17, 0, -44, 19}, {3770, 2799, 17, 15, -44, -19}, {3880, 2170, 6, 0, -6, 0},\n      {4060, 3018, 0, 0, 0, -2},    {4290, 2391, 3, 0, -8, -1},     {4330, 2439, 17, 15, -44, -19},\n      {4508, 2962, 0, 0, -3, -4},   {4508, 3330, 0, 0, -3, -6},\n  };\n  static const ushort canon[][11] = {\n      {1944, 1416, 0, 0, 48, 0},\n      {2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25},\n      {2224, 1456, 48, 6, 0, 2},\n      {2376, 1728, 12, 6, 52, 2},\n      {2672, 1968, 12, 6, 44, 2},\n      {3152, 2068, 64, 12, 0, 0, 16},\n      {3160, 2344, 44, 12, 4, 4},\n      {3344, 2484, 4, 6, 52, 6},\n      {3516, 2328, 42, 14, 0, 0},\n      {3596, 2360, 74, 12, 0, 0},\n      {3744, 2784, 52, 12, 8, 12},\n      {3944, 2622, 30, 18, 6, 2},\n      {3948, 2622, 42, 18, 0, 2},\n      {3984, 2622, 76, 20, 0, 2, 14},\n      {4104, 3048, 48, 12, 24, 12},\n      {4116, 2178, 4, 2, 0, 0},\n      {4152, 2772, 192, 12, 0, 0},\n      {4160, 3124, 104, 11, 8, 65},\n      {4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49},\n      {4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49},\n      {4312, 2876, 22, 18, 0, 2},\n      {4352, 2874, 62, 18, 0, 0},\n      {4476, 2954, 90, 34, 0, 0},\n      {4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49},\n      {4480, 3366, 80, 50, 0, 0},\n      {4496, 3366, 80, 50, 12, 0},\n      {4768, 3516, 96, 16, 0, 0, 0, 16},\n      {4832, 3204, 62, 26, 0, 0},\n      {4832, 3228, 62, 51, 0, 0},\n      {5108, 3349, 98, 13, 0, 0},\n      {5120, 3318, 142, 45, 62, 0},\n      {5280, 3528, 72, 52, 0, 0}, /* EOS M */\n      {5344, 3516, 142, 51, 0, 0},\n      {5344, 3584, 126, 100, 0, 2},\n      {5360, 3516, 158, 51, 0, 0},\n      {5568, 3708, 72, 38, 0, 0},\n      {5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49},\n      {5712, 3774, 62, 20, 10, 2},\n      {5792, 3804, 158, 51, 0, 0},\n      {5920, 3950, 122, 80, 2, 0},\n      {6096, 4056, 72, 34, 0, 0},  /* EOS M3 */\n      {6288, 4056, 266, 36, 0, 0}, /* EOS 80D */\n      {6384, 4224, 120, 44, 0, 0}, /* 6D II */\n      {6880, 4544, 136, 42, 0, 0}, /* EOS 5D4 */\n      {8896, 5920, 160, 64, 0, 0},\n  };\n  static const struct\n  {\n    ushort id;\n    char t_model[20];\n  } unique[] =\n      {\n          {0x001, \"EOS-1D\"},\n          {0x167, \"EOS-1DS\"},\n          {0x168, \"EOS 10D\"},\n          {0x169, \"EOS-1D Mark III\"},\n          {0x170, \"EOS 300D\"},\n          {0x174, \"EOS-1D Mark II\"},\n          {0x175, \"EOS 20D\"},\n          {0x176, \"EOS 450D\"},\n          {0x188, \"EOS-1Ds Mark II\"},\n          {0x189, \"EOS 350D\"},\n          {0x190, \"EOS 40D\"},\n          {0x213, \"EOS 5D\"},\n          {0x215, \"EOS-1Ds Mark III\"},\n          {0x218, \"EOS 5D Mark II\"},\n          {0x232, \"EOS-1D Mark II N\"},\n          {0x234, \"EOS 30D\"},\n          {0x236, \"EOS 400D\"},\n          {0x250, \"EOS 7D\"},\n          {0x252, \"EOS 500D\"},\n          {0x254, \"EOS 1000D\"},\n          {0x261, \"EOS 50D\"},\n          {0x269, \"EOS-1D X\"},\n          {0x270, \"EOS 550D\"},\n          {0x281, \"EOS-1D Mark IV\"},\n          {0x285, \"EOS 5D Mark III\"},\n          {0x286, \"EOS 600D\"},\n          {0x287, \"EOS 60D\"},\n          {0x288, \"EOS 1100D\"},\n          {0x289, \"EOS 7D Mark II\"},\n          {0x301, \"EOS 650D\"},\n          {0x302, \"EOS 6D\"},\n          {0x324, \"EOS-1D C\"},\n          {0x325, \"EOS 70D\"},\n          {0x326, \"EOS 700D\"},\n          {0x327, \"EOS 1200D\"},\n          {0x328, \"EOS-1D X Mark II\"},\n          {0x331, \"EOS M\"},\n          {0x335, \"EOS M2\"},\n          {0x374, \"EOS M3\"},   /* temp */\n          {0x384, \"EOS M10\"},  /* temp */\n          {0x394, \"EOS M5\"},   /* temp */\n          {0x398, \"EOS M100\"}, /* temp */\n          {0x346, \"EOS 100D\"},\n          {0x347, \"EOS 760D\"},\n          {0x349, \"EOS 5D Mark IV\"},\n          {0x350, \"EOS 80D\"},\n          {0x382, \"EOS 5DS\"},\n          {0x393, \"EOS 750D\"},\n          {0x401, \"EOS 5DS R\"},\n          {0x404, \"EOS 1300D\"},\n          {0x405, \"EOS 800D\"},\n          {0x406, \"EOS 6D Mark II\"},\n          {0x407, \"EOS M6\"},\n          {0x408, \"EOS 77D\"},\n          {0x417, \"EOS 200D\"},\n      },\n    sonique[] = {\n        {0x002, \"DSC-R1\"},      {0x100, \"DSLR-A100\"},   {0x101, \"DSLR-A900\"},  {0x102, \"DSLR-A700\"},\n        {0x103, \"DSLR-A200\"},   {0x104, \"DSLR-A350\"},   {0x105, \"DSLR-A300\"},  {0x106, \"DSLR-A900\"},\n        {0x107, \"DSLR-A380\"},   {0x108, \"DSLR-A330\"},   {0x109, \"DSLR-A230\"},  {0x10a, \"DSLR-A290\"},\n        {0x10d, \"DSLR-A850\"},   {0x10e, \"DSLR-A850\"},   {0x111, \"DSLR-A550\"},  {0x112, \"DSLR-A500\"},\n        {0x113, \"DSLR-A450\"},   {0x116, \"NEX-5\"},       {0x117, \"NEX-3\"},      {0x118, \"SLT-A33\"},\n        {0x119, \"SLT-A55V\"},    {0x11a, \"DSLR-A560\"},   {0x11b, \"DSLR-A580\"},  {0x11c, \"NEX-C3\"},\n        {0x11d, \"SLT-A35\"},     {0x11e, \"SLT-A65V\"},    {0x11f, \"SLT-A77V\"},   {0x120, \"NEX-5N\"},\n        {0x121, \"NEX-7\"},       {0x122, \"NEX-VG20E\"},   {0x123, \"SLT-A37\"},    {0x124, \"SLT-A57\"},\n        {0x125, \"NEX-F3\"},      {0x126, \"SLT-A99V\"},    {0x127, \"NEX-6\"},      {0x128, \"NEX-5R\"},\n        {0x129, \"DSC-RX100\"},   {0x12a, \"DSC-RX1\"},     {0x12b, \"NEX-VG900\"},  {0x12c, \"NEX-VG30E\"},\n        {0x12e, \"ILCE-3000\"},   {0x12f, \"SLT-A58\"},     {0x131, \"NEX-3N\"},     {0x132, \"ILCE-7\"},\n        {0x133, \"NEX-5T\"},      {0x134, \"DSC-RX100M2\"}, {0x135, \"DSC-RX10\"},   {0x136, \"DSC-RX1R\"},\n        {0x137, \"ILCE-7R\"},     {0x138, \"ILCE-6000\"},   {0x139, \"ILCE-5000\"},  {0x13d, \"DSC-RX100M3\"},\n        {0x13e, \"ILCE-7S\"},     {0x13f, \"ILCA-77M2\"},   {0x153, \"ILCE-5100\"},  {0x154, \"ILCE-7M2\"},\n        {0x155, \"DSC-RX100M4\"}, {0x156, \"DSC-RX10M2\"},  {0x158, \"DSC-RX1RM2\"}, {0x15a, \"ILCE-QX1\"},\n        {0x15b, \"ILCE-7RM2\"},   {0x15e, \"ILCE-7SM2\"},   {0x161, \"ILCA-68\"},    {0x162, \"ILCA-99M2\"},\n        {0x163, \"DSC-RX10M3\"},  {0x164, \"DSC-RX100M5\"}, {0x165, \"ILCE-6300\"},  {0x166, \"ILCE-9\"},\n        {0x168, \"ILCE-6500\"},   {0x16a, \"ILCE-7RM3\"},   {0x16c, \"DSC-RX0\"},    {0x16d, \"DSC-RX10M4\"},\n    };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t const_table[]\n#else\n  static const struct\n  {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  } table[]\n#endif\n      = {\n          {786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-080C\"},\n          {1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-145C\"},\n          {1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-201C\"},\n          {5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-810C\"},\n          {15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, \"AgfaPhoto\", \"DC-833m\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Alcatel\", \"5035D\"},\n          {31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 4:3\"},\n          {23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 16:9\"},\n          {32257024, 4624, 3488, 8, 2, 16, 2, 0, 0x94, 0, 0, \"GITUP\", \"GIT2P 4:3\"},\n          //   Android Raw dumps id start\n          //   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n          {1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"Samsung\", \"S3\"},\n          {2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontMipi\"},\n          {2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontQCOM\"},\n          {2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wMipi\"},\n          {3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wQCOM\"},\n          {3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, \"I_Mobile\", \"I_StyleQ6\"},\n          {5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel1\"},\n          {5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel2\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, \"OmniVisi\", \"OV5648\"},\n          {6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"OmniVisi\", \"OV56482\"},\n          {6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"OneSV\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"5mp\"},\n          {9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, \"NGM\", \"ForwardArt\"},\n          {10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX219-mipi 8mp\"},\n          {10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Sony\", \"IMX\"},\n          {10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"MyTouch4GSlide\"},\n          {10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Xperia\", \"L\"},\n          {15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, \"OmniVison\", \"OV8850\"},\n          {16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3MipiL\"},\n          {16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"IMX135\", \"MipiL\"},\n          {17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3LQCom\"},\n          {17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Sony\", \"IMX135-QCOM\"},\n          {19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7mipi\"},\n          {19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G4\"},\n          {20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"RedmiNote3Pro\"},\n          {20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX298-mipi 16mp\"},\n          {21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7qcom\"},\n          {26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, \"THL\", \"5000\"},\n          {26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, \"Sony\", \"IMX214\"},\n          {26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, \"OV\", \"13860\"},\n          {41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Meizu\", \"MX4\"},\n          {42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"IMX230\"},\n          //   Android Raw dumps id end\n          {20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, \"Aptina\", \"MT9J003\", 0xffff},\n          {2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, \"Baumer\", \"TXG14\", 1078},\n          {5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SD300\"},\n          {6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A460\"},\n          {6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A610\"},\n          {6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A530\"},\n          {7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot S3 IS\"},\n          {9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A620\"},\n          {9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A470\"},\n          {10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A720 IS\"},\n          {10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A630\"},\n          {12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A640\"},\n          {15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A650\"},\n          {15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX110 IS\"},\n          {15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX120 IS\"},\n          {18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX20 IS\"},\n          {18763488, 4104, 3048, 10, 22, 82, 22, 8, 0x49, 0, 0, \"Canon\", \"PowerShot D10\"},\n          {19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX220 HS\"},\n          {21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, \"Canon\", \"PowerShot SX30 IS\"},\n          {24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A3300 IS\"},\n          {30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, \"Canon\", \"IXUS 160\"},\n          {1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-2000UX\"},\n          {3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-3*00EX\"},\n          {6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, \"Casio\", \"QV-5700\"},\n          {7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, \"Casio\", \"EX-Z60\"},\n          {2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, \"Casio\", \"EX-S20\"},\n          {4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, \"Casio\", \"EX-S100\"},\n          {6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R41\"},\n          {7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-P505\"},\n          {7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R51\"},\n          {7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"EX-Z50\"},\n          {7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, \"Casio\", \"EX-Z500\"},\n          {7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, \"Casio\", \"EX-Z55\"},\n          {9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, \"Casio\", \"EX-P600\"},\n          {10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z750\"},\n          {10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z75\"},\n          {10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, \"Casio\", \"EX-P700\"},\n          {12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, \"Casio\", \"EX-Z850\"},\n          {12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, \"Casio\", \"EX-Z8\"},\n          {15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z1050\"},\n          {18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, \"Casio\", \"EX-ZR100\"},\n          {7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, \"Casio\", \"QV-4000\"},\n          {787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, \"Creative\", \"PC-CAM 600\"},\n          {28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, \"DJI\"},\n          {15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Matrix\"},\n          {3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, \"Foculus\", \"531C\"},\n          {307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Generic\"},\n          {62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, \"Kodak\", \"DCS200\"},\n          {4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\"},\n          {4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\", 3160},\n          {2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\"},\n          {6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\", 3160},\n          {460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\"},\n          {12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\", 31556},\n          {18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"12MP\"},\n          {614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, \"Kodak\", \"KAI-0340\"},\n          {15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Lenovo\", \"A820\"},\n          {3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Micron\", \"2010\", 3212},\n          {1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, \"Minolta\", \"RD175\", 513},\n          {1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, \"Nikon\", \"E900\"},\n          {2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, \"Nikon\", \"E950\"},\n          {2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, \"Nikon\", \"E2100\"},\n          {4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, \"Nikon\", \"E990\"},\n          {4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, \"Nikon\", \"E3700\"},\n          {5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E4500\"},\n          {5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, \"Nikon\", \"E4300\"},\n          {7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E5000\"},\n          {8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, \"Nikon\", \"COOLPIX S6\"},\n          {5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, \"Olympus\", \"C770UZ\"},\n          {3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Pentax\", \"Optio S\"},\n          {4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S\"},\n          {6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S4\"},\n          {10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, \"Pentax\", \"Optio 750Z\"},\n          {4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\"},\n          {4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\", 8},\n          {13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, \"Pixelink\", \"A782\"},\n          {6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, \"RoverShot\", \"3320AF\"},\n          {311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, \"ST Micro\", \"STV680 VGA\"},\n          {16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n          {2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n      };\n#ifdef LIBRAW_LIBRARY_BUILD\n  libraw_custom_camera_t table[64 + sizeof(const_table) / sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] = {\"AgfaPhoto\", \"Canon\",     \"Casio\",  \"Epson\",   \"Fujifilm\", \"Mamiya\", \"Minolta\",\n                               \"Motorola\",  \"Kodak\",     \"Konica\", \"Leica\",   \"Nikon\",    \"Nokia\",  \"Olympus\",\n                               \"Pentax\",    \"Phase One\", \"Ricoh\",  \"Samsung\", \"Sigma\",    \"Sinar\",  \"Sony\"};\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize = 1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64, table, imgdata.params.custom_camera_strings);\n  for (int q = 0; q < sizeof(const_table) / sizeof(const_table[0]); q++)\n    memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));\n  camera_count += sizeof(const_table) / sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  imgdata.other.CameraTemperature = imgdata.other.SensorTemperature = imgdata.other.SensorTemperature2 =\n      imgdata.other.LensTemperature = imgdata.other.AmbientTemperature = imgdata.other.BatteryTemperature =\n          imgdata.other.exifAmbientTemperature = -1000.0f;\n\n  for (i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n#endif\n\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n  for (i = 0; i < 4; i++)\n  {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i = 0; i < 0x10000; i++)\n    curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek(ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(fread(head, 1, 64, ifp) < 64) throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread(head, 1, 32, ifp);\n#endif\n  fseek(ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *)memmem(head, 32, (char *)\"MMMM\", 4)) || (cp = (char *)memmem(head, 32, (char *)\"IIII\", 4)))\n  {\n    parse_phase_one(cp - head);\n    if (cp - head && parse_tiff(0))\n      apply_tiff();\n  }\n  else if (order == 0x4949 || order == 0x4d4d)\n  {\n    if (!memcmp(head + 6, \"HEAPCCDR\", 8))\n    {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(hlen, flen - hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    }\n    else if (parse_tiff(0))\n      apply_tiff();\n  }\n  else if (!memcmp(head, \"\\xff\\xd8\\xff\\xe1\", 4) && !memcmp(head + 6, \"Exif\", 4))\n  {\n    fseek(ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek(ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  }\n  else if (!memcmp(head + 25, \"ARECOYK\", 7))\n  {\n    strcpy(make, \"Contax\");\n    strcpy(model, \"N Digital\");\n    fseek(ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek(ifp, 52, SEEK_SET);\n    switch (get4())\n    {\n    case 7:\n      iso_speed = 25;\n      break;\n    case 8:\n      iso_speed = 32;\n      break;\n    case 9:\n      iso_speed = 40;\n      break;\n    case 10:\n      iso_speed = 50;\n      break;\n    case 11:\n      iso_speed = 64;\n      break;\n    case 12:\n      iso_speed = 80;\n      break;\n    case 13:\n      iso_speed = 100;\n      break;\n    case 14:\n      iso_speed = 125;\n      break;\n    case 15:\n      iso_speed = 160;\n      break;\n    case 16:\n      iso_speed = 200;\n      break;\n    case 17:\n      iso_speed = 250;\n      break;\n    case 18:\n      iso_speed = 320;\n      break;\n    case 19:\n      iso_speed = 400;\n      break;\n    }\n    shutter = libraw_powf64l(2.0f, (((float)get4()) / 8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek(ifp, 88, SEEK_SET);\n    aperture = libraw_powf64l(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek(ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = libraw_powf64l(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  }\n  else if (!strcmp(head, \"PXN\"))\n  {\n    strcpy(make, \"Logitech\");\n    strcpy(model, \"Fotoman Pixtura\");\n  }\n  else if (!strcmp(head, \"qktk\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  }\n  else if (!strcmp(head, \"qktn\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  }\n  else if (!memcmp(head, \"FUJIFILM\", 8))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strncpy(model, head + 0x1c,0x20);\n    model[0x20]=0;\n    memcpy(model2, head + 0x3c, 4);\n    model2[4] = 0;\n#endif\n    fseek(ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek(ifp, 92, SEEK_SET);\n    parse_fuji(get4());\n    if (thumb_offset > 120)\n    {\n      fseek(ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) ? 1 : 0;\n      if (is_raw == 2 && shot_select)\n        parse_fuji(i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);\n    parse_tiff(data_offset = get4());\n    parse_tiff(thumb_offset + 12);\n    apply_tiff();\n  }\n  else if (!memcmp(head, \"RIFF\", 4))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_riff();\n  }\n  else if (!memcmp(head + 4, \"ftypqt   \", 9))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_qt(fsize);\n    is_raw = 0;\n  }\n  else if (!memcmp(head, \"\\0\\001\\0\\001\\0@\", 6))\n  {\n    fseek(ifp, 6, SEEK_SET);\n    fread(make, 1, 8, ifp);\n    fread(model, 1, 8, ifp);\n    fread(model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"NOKIARAW\", 8))\n  {\n    strcpy(make, \"NOKIA\");\n    order = 0x4949;\n    fseek(ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4(); // bytes count\n    width = get2();\n    height = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // Data integrity check\n    if (width < 1 || width > 16000 || height < 1 || height > 16000 || i < (width * height) || i > (2 * width * height))\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    switch (tiff_bps = i * 8 / (width * height))\n    {\n    case 8:\n      load_raw = &CLASS eight_bit_load_raw;\n      break;\n    case 10:\n      load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"ARRI\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy(make, \"ARRI\");\n    fseek(ifp, 668, SEEK_SET);\n    fread(model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"XPDS\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 0x800, SEEK_SET);\n    fread(make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width = get2();\n    fseek(ifp, 56, SEEK_CUR);\n    fread(model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve(0, 12.25, 1, 1023);\n  }\n  else if (!memcmp(head + 4, \"RED1\", 4))\n  {\n    strcpy(make, \"Red\");\n    strcpy(model, \"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve(1 / 2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  }\n  else if (!memcmp(head, \"DSC-Image\", 9))\n    parse_rollei();\n  else if (!memcmp(head, \"PWAD\", 4))\n    parse_sinar_ia();\n  else if (!memcmp(head, \"\\0MRM\", 4))\n    parse_minolta(0);\n  else if (!memcmp(head, \"FOVb\", 4))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    /* no foveon support for dcraw build from libraw source */\n    parse_x3f();\n#endif\n  }\n  else if (!memcmp(head, \"CI\", 2))\n    parse_cine();\n  if (make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize = i = 0; i < camera_count; i++)\n#else\n    for (zero_fsize = i = 0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize)\n      {\n        strcpy(make, table[i].t_make);\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\", 5))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n#endif\n        strcpy(model, table[i].t_model);\n        flip = table[i].flags >> 2;\n        zero_is_bad = table[i].flags & 2;\n        if (table[i].flags & 1)\n          parse_external_jpeg();\n        data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;\n        raw_width = table[i].rw;\n        raw_height = table[i].rh;\n        left_margin = table[i].lm;\n        top_margin = table[i].tm;\n        width = raw_width - left_margin - table[i].rm;\n        height = raw_height - top_margin - table[i].bm;\n        filters = 0x1010101 * table[i].cf;\n        colors = 4 - !((filters & filters >> 1) & 0x5555);\n        load_flags = table[i].lf;\n        switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))\n        {\n        case 6:\n          load_raw = &CLASS minolta_rd175_load_raw;\n          break;\n        case 8:\n          load_raw = &CLASS eight_bit_load_raw;\n          break;\n        case 10:\n          if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)\n          {\n            load_raw = &CLASS android_loose_load_raw;\n            break;\n          }\n          else if (load_flags & 1)\n          {\n            load_raw = &CLASS android_tight_load_raw;\n            break;\n          }\n        case 12:\n          load_flags |= 128;\n          load_raw = &CLASS packed_load_raw;\n          break;\n        case 16:\n          order = 0x4949 | 0x404 * (load_flags & 1);\n          tiff_bps -= load_flags >> 4;\n          tiff_bps -= load_flags = load_flags >> 1 & 7;\n          load_raw = table[i].offset == 0xffff ? &CLASS unpacked_load_raw_reversed : &CLASS unpacked_load_raw;\n        }\n        maximum = (1 << tiff_bps) - (1 << table[i].max);\n        break;\n      }\n  if (zero_fsize)\n    fsize = 0;\n  if (make[0] == 0)\n    parse_smal(0, flen);\n  if (make[0] == 0)\n  {\n    parse_jpeg(0);\n    fseek(ifp, 0, SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model, \"RP_imx219\", 9) && sz >= 0x9cb600 && !fseek(ifp, -0x9cb600, SEEK_END) &&\n        fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      strcpy(model, \"RPi IMX219\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 66;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    }\n    else if (!(strncmp(model, \"ov5647\", 6) && strncmp(model, \"RP_OV5647\", 9)) && sz >= 0x61b800 &&\n             !fseek(ifp, -0x61b800, SEEK_END) && fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      if (!strncmp(model, \"ov5647\", 6))\n        strcpy(model, \"RPi OV5647 v.1\");\n      else\n        strcpy(model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 16;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model, \"ov\", 2) && strncmp(model, \"RP_OV\", 5)) && sz >= 6404096 && !fseek(ifp, -6404096, SEEK_END) &&\n        fread(head, 1, 32, ifp) && !strcmp(head, \"BRCMn\"))\n    {\n      strcpy(make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000 - 32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    }\n    else\n      is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i = 0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr(make, corp[i])) /* Simplify company names */\n      strcpy(make, corp[i]);\n  if ((!strncmp(make, \"Kodak\", 5) || !strncmp(make, \"Leica\", 5)) &&\n      ((cp = strcasestr(model, \" DIGITAL CAMERA\")) || (cp = strstr(model, \"FILE VERSION\"))))\n    *cp = 0;\n  if (!strncasecmp(model, \"PENTAX\", 6))\n    strcpy(make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make, sizeof(make));\n  remove_trailing_spaces(model, sizeof(model));\n#else\n  cp = make + strlen(make); /* Remove trailing spaces */\n  while (*--cp == ' ')\n    *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ')\n    *cp = 0;\n#endif\n  i = strbuflen(make); /* Remove make from model */\n  if (!strncasecmp(model, make, i) && model[i++] == ' ')\n    memmove(model, model + i, 64 - i);\n  if (!strncmp(model, \"FinePix \", 8))\n    memmove(model, model + 8,strlen(model)-7);\n  if (!strncmp(model, \"Digital Camera \", 15))\n   memmove(model, model + 15,strlen(model)-14);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw)\n    goto notraw;\n\n  if (!height)\n    height = raw_height;\n  if (!width)\n    width = raw_width;\n  if (height == 2624 && width == 3936) /* Pentax K10D and Samsung GX10 */\n  {\n    height = 2616;\n    width = 3896;\n  }\n  if (height == 3136 && width == 4864) /* Pentax K20D and Samsung GX20 */\n  {\n    height = 3124;\n    width = 4688;\n    filters = 0x16161616;\n  }\n  if (width == 4352 && (!strcmp(model, \"K-r\") || !strcmp(model, \"K-x\")))\n  {\n    width = 4309;\n    filters = 0x16161616;\n  }\n  if (width >= 4960 && !strncmp(model, \"K-5\", 3))\n  {\n    left_margin = 10;\n    width = 4950;\n    filters = 0x16161616;\n  }\n  if (width == 6080 && !strcmp(model, \"K-70\"))\n  {\n    height = 4016;\n    top_margin = 32;\n    width = 6020;\n    left_margin = 60;\n  }\n  if (width == 4736 && !strcmp(model, \"K-7\"))\n  {\n    height = 3122;\n    width = 4684;\n    filters = 0x16161616;\n    top_margin = 2;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3 II\")) /* moved back */\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 6112 && !strcmp(model, \"KP\"))\n  {\n    /* From DNG, maybe too strict */\n    left_margin = 54;\n    top_margin = 28;\n    width = 6028;\n    height = raw_height - top_margin;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3\"))\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 7424 && !strcmp(model, \"645D\"))\n  {\n    height = 5502;\n    width = 7328;\n    filters = 0x61616161;\n    top_margin = 29;\n    left_margin = 48;\n  }\n  if (height == 3014 && width == 4096) /* Ricoh GX200 */\n    width = 4014;\n  if (dng_version)\n  {\n    if (filters == UINT_MAX)\n      filters = 0;\n    if (filters)\n      is_raw *= tiff_samples;\n    else\n      colors = tiff_samples;\n    switch (tiff_compress)\n    {\n    case 0: /* Compression not set, assuming uncompressed */\n    case 1:\n      load_raw = &CLASS packed_dng_load_raw;\n      break;\n    case 7:\n      load_raw = &CLASS lossless_dng_load_raw;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      load_raw = &CLASS deflate_dng_load_raw;\n      break;\n#endif\n    case 34892:\n      load_raw = &CLASS lossy_dng_load_raw;\n      break;\n    default:\n      load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\", 5) && unique_id)\n    {\n      for (i = 0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n        {\n          strcpy(model, unique[i].t_model);\n          break;\n        }\n    }\n    if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n    {\n      for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n        {\n          strcpy(model, sonique[i].t_model);\n          break;\n        }\n    }\n    goto dng_skip;\n  }\n  if (!strncmp(make, \"Canon\", 5) && !fsize && tiff_bps != 15)\n  {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i = 0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1])\n      {\n        width = raw_width - (left_margin = canon[i][2]);\n        height = raw_height - (top_margin = canon[i][3]);\n        width -= canon[i][4];\n        height -= canon[i][5];\n        mask[0][1] = canon[i][6];\n        mask[0][3] = -canon[i][7];\n        mask[1][1] = canon[i][8];\n        mask[1][3] = -canon[i][9];\n        if (canon[i][10])\n          filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000)\n    {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make, \"Canon\", 5) && unique_id)\n  {\n    for (i = 0; i < sizeof unique / sizeof *unique; i++)\n      if (unique_id == 0x80000000 + unique[i].id)\n      {\n        adobe_coeff(\"Canon\", unique[i].t_model);\n        strcpy(model, unique[i].t_model);\n      }\n  }\n\n  if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n  {\n    for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n      if (unique_id == sonique[i].id)\n      {\n        adobe_coeff(\"Sony\", sonique[i].t_model);\n        strcpy(model, sonique[i].t_model);\n      }\n  }\n\n  if (!strncmp(make, \"Nikon\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n  /* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model, \"KAI-0340\") && find_green(16, 16, 3840, 5120) < 25)\n  {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy(model, \"C603\");\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n#else\n  /* Always 512 for arw2_load_raw */\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = (load_raw == &LibRaw::sony_arw2_load_raw) ? 512 : (128 << (tiff_bps - 12));\n#endif\n\n  if (is_foveon)\n  {\n    if (height * 2 < width)\n      pixel_aspect = 0.5;\n    if (height > width)\n      pixel_aspect = 2;\n    filters = 0;\n  }\n  else if (!strncmp(make, \"Pentax\", 6) && !strncmp(model, \"K-1\", 3))\n  {\n    top_margin = 18;\n    height = raw_height - top_margin;\n    if (raw_width == 7392)\n    {\n      left_margin = 6;\n      width = 7376;\n    }\n  }\n  else if (!strncmp(make, \"Canon\", 5) && tiff_bps == 15)\n  {\n    switch (width)\n    {\n    case 3344:\n      width -= 66;\n    case 3872:\n      width -= 6;\n    }\n    if (height > width)\n    {\n      SWAP(height, width);\n      SWAP(raw_height, raw_width);\n    }\n    if (width == 7200 && height == 3888)\n    {\n      raw_width = width = 6480;\n      raw_height = height = 4320;\n    }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot 600\"))\n  {\n    height = 613;\n    width = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot A5\") || !strcmp(model, \"PowerShot A5 Zoom\"))\n  {\n    height = 773;\n    width = 960;\n    raw_width = 992;\n    pixel_aspect = 256 / 235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot A50\"))\n  {\n    height = 968;\n    width = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot Pro70\"))\n  {\n    height = 1024;\n    width = 1552;\n    filters = 0x1e4b4e1b;\n  canon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  }\n  else if (!strcmp(model, \"PowerShot Pro90 IS\") || !strcmp(model, \"PowerShot G1\"))\n  {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  }\n  else if (!strcmp(model, \"PowerShot A610\"))\n  {\n    if (canon_s2is())\n      strcpy(model + 10, \"S2 IS\");\n  }\n  else if (!strcmp(model, \"PowerShot SX220 HS\"))\n  {\n    mask[1][3] = -4;\n    top_margin = 16;\n    left_margin = 92;\n  }\n  else if (!strcmp(model, \"PowerShot S120\"))\n  {\n    raw_width = 4192;\n    raw_height = 3062;\n    width = 4022;\n    height = 3016;\n    mask[0][0] = top_margin = 31;\n    mask[0][2] = top_margin + height;\n    left_margin = 120;\n    mask[0][1] = 23;\n    mask[0][3] = 72;\n  }\n  else if (!strcmp(model, \"PowerShot G16\"))\n  {\n    mask[0][0] = 0;\n    mask[0][2] = 80;\n    mask[0][1] = 0;\n    mask[0][3] = 16;\n    top_margin = 29;\n    left_margin = 120;\n    width = raw_width - left_margin - 48;\n    height = raw_height - top_margin - 14;\n  }\n  else if (!strcmp(model, \"PowerShot SX50 HS\"))\n  {\n    top_margin = 17;\n  }\n  else if (!strcmp(model, \"EOS D2000C\"))\n  {\n    filters = 0x61616161;\n    if (!black)\n      black = curve[200];\n  }\n  else if (!strcmp(model, \"D1\"))\n  {\n    cam_mul[0] *= 256 / 527.0;\n    cam_mul[2] *= 256 / 317.0;\n  }\n  else if (!strcmp(model, \"D1X\"))\n  {\n    width -= 4;\n    pixel_aspect = 0.5;\n  }\n  else if (!strcmp(model, \"D40X\") || !strcmp(model, \"D60\") || !strcmp(model, \"D80\") || !strcmp(model, \"D3000\"))\n  {\n    height -= 3;\n    width -= 4;\n  }\n  else if (!strcmp(model, \"D3\") || !strcmp(model, \"D3S\") || !strcmp(model, \"D700\"))\n  {\n    width -= 4;\n    left_margin = 2;\n  }\n  else if (!strcmp(model, \"D3100\"))\n  {\n    width -= 28;\n    left_margin = 6;\n  }\n  else if (!strcmp(model, \"D5000\") || !strcmp(model, \"D90\"))\n  {\n    width -= 42;\n  }\n  else if (!strcmp(model, \"D5100\") || !strcmp(model, \"D7000\") || !strcmp(model, \"COOLPIX A\"))\n  {\n    width -= 44;\n  }\n  else if (!strcmp(model, \"D3200\") || !strncmp(model, \"D6\", 2) || !strncmp(model, \"D800\", 4))\n  {\n    width -= 46;\n  }\n  else if (!strcmp(model, \"D4\") || !strcmp(model, \"Df\"))\n  {\n    width -= 52;\n    left_margin = 2;\n  }\n  else if (!strcmp(model, \"D500\"))\n  {\n    // Empty - to avoid width-1 below\n  }\n  else if (!strncmp(model, \"D40\", 3) || !strncmp(model, \"D50\", 3) || !strncmp(model, \"D70\", 3))\n  {\n    width--;\n  }\n  else if (!strcmp(model, \"D100\"))\n  {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  }\n  else if (!strcmp(model, \"D200\"))\n  {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  }\n  else if (!strncmp(model, \"D2H\", 3))\n  {\n    left_margin = 6;\n    width -= 14;\n  }\n  else if (!strncmp(model, \"D2X\", 3))\n  {\n    if (width == 3264)\n      width -= 32;\n    else\n      width -= 8;\n  }\n  else if (!strncmp(model, \"D300\", 4))\n  {\n    width -= 32;\n  }\n  else if (!strncmp(make, \"Nikon\", 5) && raw_width == 4032)\n  {\n    if (!strcmp(model, \"COOLPIX P7700\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7700\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P7800\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7800\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P340\"))\n      load_flags = 0;\n  }\n  else if (!strncmp(model, \"COOLPIX P\", 9) && raw_width != 4032)\n  {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed == 0) && !strstr(software, \"V1.2\"))\n      black = 255;\n  }\n  else if (!strncmp(model, \"COOLPIX B700\", 12))\n  {\n    load_flags = 24;\n    black = 200;\n  }\n  else if (!strncmp(model, \"1 \", 2))\n  {\n    height -= 2;\n  }\n  else if (fsize == 1581060)\n  {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  }\n  else if (fsize == 3178560)\n  {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  }\n  else if (fsize == 4771840)\n  {\n    if (!timestamp && nikon_e995())\n      strcpy(model, \"E995\");\n    if (strcmp(model, \"E995\"))\n    {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  }\n  else if (fsize == 2940928)\n  {\n    if (!timestamp && !nikon_e2100())\n      strcpy(model, \"E2500\");\n    if (!strcmp(model, \"E2500\"))\n    {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  }\n  else if (fsize == 4775936)\n  {\n    if (!timestamp)\n      nikon_3700();\n    if (model[0] == 'E' && atoi(model + 1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model, \"Optio 33WR\"))\n    {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O')\n    {\n      i = find_green(12, 32, 1188864, 3576832);\n      c = find_green(12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c))\n      {\n        SWAP(i, c);\n        load_flags = 24;\n      }\n      if (i < 0)\n        filters = 0x61616161;\n    }\n  }\n  else if (fsize == 5869568)\n  {\n    if (!timestamp && minolta_z2())\n    {\n      strcpy(make, \"Minolta\");\n      strcpy(model, \"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24 * (make[0] == 'M');\n  }\n  else if (fsize == 6291456)\n  {\n    fseek(ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d)\n    {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy(make, \"ISG\");\n      model[0] = 0;\n    }\n  }\n  else if (!strncmp(make, \"Fujifilm\", 8))\n  {\n    if (!strcmp(model, \"X-A3\") || !strcmp(model, \"X-A10\"))\n    {\n      left_margin = 0;\n      top_margin = 0;\n      width = raw_width;\n      height = raw_height;\n    }\n    if (!strcmp(model + 7, \"S2Pro\"))\n    {\n      strcpy(model, \"S2Pro\");\n      height = 2144;\n      width = 2880;\n      flip = 6;\n    }\n    else if (load_raw != &CLASS packed_load_raw && strncmp(model, \"X-\", 2) && filters >=1000) // Bayer and not X-models\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width) >> 2 << 1;\n    if (width == 2848 || width == 3664)\n      filters = 0x16161616;\n    if (width == 4032 || width == 4952)\n      left_margin = 0;\n    if (width == 3328 && (width -= 66))\n      left_margin = 34;\n    if (width == 4936)\n      left_margin = 4;\n    if (width == 6032)\n      left_margin = 0;\n    if (!strcmp(model, \"HS50EXR\") || !strcmp(model, \"F900EXR\"))\n    {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if (!strcmp(model, \"GFX 50S\"))\n    {\n      left_margin = 0;\n      top_margin = 0;\n    }\n    if (!strcmp(model, \"S5500\"))\n    {\n      height -= (top_margin = 6);\n    }\n    if (fuji_layout)\n      raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36)((char *)xtrans)[c] = xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];\n  }\n  else if (!strcmp(model, \"KD-400Z\"))\n  {\n    height = 1712;\n    width = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  }\n  else if (!strcmp(model, \"KD-510Z\"))\n  {\n    goto konica_510z;\n  }\n  else if (!strncasecmp(make, \"Minolta\", 7))\n  {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model, \"DiMAGE A\", 8))\n    {\n      if (!strcmp(model, \"DiMAGE A200\"))\n        filters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"ALPHA\", 5) || !strncmp(model, \"DYNAX\", 5) || !strncmp(model, \"MAXXUM\", 6))\n    {\n      sprintf(model + 20, \"DYNAX %-10s\", model + 6 + (model[0] == 'M'));\n      adobe_coeff(make, model + 20);\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"DiMAGE G\", 8))\n    {\n      if (model[8] == '4')\n      {\n        height = 1716;\n        width = 2304;\n      }\n      else if (model[8] == '5')\n      {\n      konica_510z:\n        height = 1956;\n        width = 2607;\n        raw_width = 2624;\n      }\n      else if (model[8] == '6')\n      {\n        height = 2136;\n        width = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\n    konica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  }\n  else if (!strcmp(model, \"*ist D\"))\n  {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  }\n  else if (!strcmp(model, \"*ist DS\"))\n  {\n    height -= 2;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 4704)\n  {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && !strcmp(model, \"NX3000\"))\n  {\n    top_margin = 38;\n    left_margin = 92;\n    width = 5456;\n    height = 3634;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_height == 3714)\n  {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5632)\n  {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12)\n      load_flags = 80;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5664)\n  {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 6496)\n  {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n      black = 1 << (tiff_bps - 7);\n  }\n  else if (!strcmp(model, \"EX1\"))\n  {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682)\n    {\n      height -= 10;\n      width -= 46;\n      top_margin = 8;\n    }\n  }\n  else if (!strcmp(model, \"WB2000\"))\n  {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718)\n    {\n      height -= 28;\n      width -= 56;\n      top_margin = 8;\n    }\n  }\n  else if (strstr(model, \"WB550\"))\n  {\n    strcpy(model, \"WB550\");\n  }\n  else if (!strcmp(model, \"EX2F\"))\n  {\n    height = 3030;\n    width = 4040;\n    top_margin = 15;\n    left_margin = 24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  else if (!strcmp(model, \"STV680 VGA\"))\n  {\n    black = 16;\n  }\n  else if (!strcmp(model, \"N95\"))\n  {\n    height = raw_height - (top_margin = 2);\n  }\n  else if (!strcmp(model, \"640x480\"))\n  {\n    gamma_curve(0.45, 4.5, 1, 255);\n  }\n  else if (!strncmp(make, \"Hasselblad\", 10))\n  {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262)\n    {\n      height = 5444;\n      width = 7248;\n      top_margin = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if (!strncasecmp(model, \"H3D\", 3))\n      {\n        adobe_coeff(\"Hasselblad\", \"H3DII-39\");\n        strcpy(model, \"H3DII-39\");\n      }\n    }\n    else if (raw_width == 12000) // H6D 100c, A6D 100c\n    {\n      left_margin = 64;\n      width = 11608;\n      top_margin = 108;\n      height = raw_height - top_margin;\n      adobe_coeff(\"Hasselblad\", \"H6D-100c\");\n    }\n    else if (raw_width == 7410 || raw_width == 8282)\n    {\n      height -= 84;\n      width -= 82;\n      top_margin = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\", \"H4D-40\");\n      strcpy(model, \"H4D-40\");\n    }\n    else if (raw_width == 8384) // X1D\n    {\n      top_margin = 96;\n      height -= 96;\n      left_margin = 48;\n      width -= 106;\n      adobe_coeff(\"Hasselblad\", \"X1D\");\n      maximum = 0xffff;\n      tiff_bps = 16;\n    }\n    else if (raw_width == 9044)\n    {\n      if (black > 500)\n      {\n        top_margin = 12;\n        left_margin = 44;\n        width = 8956;\n        height = 6708;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H4D-60\");\n        strcpy(model, \"H4D-60\");\n        black = 512;\n      }\n      else\n      {\n        height = 6716;\n        width = 8964;\n        top_margin = 8;\n        left_margin = 40;\n        black += load_flags = 256;\n        maximum = 0x8101;\n        strcpy(model, \"H3DII-60\");\n      }\n    }\n    else if (raw_width == 4090)\n    {\n      strcpy(model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n    else if (raw_width == 8282 && raw_height == 6240)\n    {\n      if (!strncasecmp(model, \"H5D\", 3))\n      {\n        /* H5D 50*/\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        black = 256;\n        strcpy(model, \"H5D-50\");\n      }\n      else if (!strncasecmp(model, \"H3D\", 3))\n      {\n        black = 0;\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H3D-50\");\n        strcpy(model, \"H3D-50\");\n      }\n    }\n    else if (raw_width == 8374 && raw_height == 6304)\n    {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model, \"H5D-50c\");\n    }\n    if (tiff_samples > 1)\n    {\n      is_raw = tiff_samples + 1;\n      if (!shot_select && !half_size)\n        filters = 0;\n    }\n  }\n  else if (!strncmp(make, \"Sinar\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size)\n      filters = 0;\n    maximum = 0x3fff;\n  }\n  else if (!strncmp(make, \"Leaf\", 4))\n  {\n    maximum = 0x3fff;\n    fseek(ifp, data_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1)\n      filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height)\n    {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048)\n    {\n      if (tiff_samples == 1)\n      {\n        filters = 1;\n        strcpy(cdesc, \"RBTG\");\n        strcpy(model, \"CatchLight\");\n        top_margin = 8;\n        left_margin = 18;\n        height = 2032;\n        width = 2016;\n      }\n      else\n      {\n        strcpy(model, \"DCB2\");\n        top_margin = 10;\n        left_margin = 16;\n        height = 2028;\n        width = 2022;\n      }\n    }\n    else if (width + height == 3144 + 2060)\n    {\n      if (!model[0])\n        strcpy(model, \"Cantare\");\n      if (width > height)\n      {\n        top_margin = 6;\n        left_margin = 32;\n        height = 2048;\n        width = 3072;\n        filters = 0x61616161;\n      }\n      else\n      {\n        left_margin = 6;\n        top_margin = 32;\n        width = 2048;\n        height = 3072;\n        filters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V')\n        filters = 0;\n      else\n        is_raw = tiff_samples;\n    }\n    else if (width == 2116)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    }\n    else if (width == 3171)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  }\n  else if (!strncmp(make, \"Leica\", 5) || !strncmp(make, \"Panasonic\", 9) || !strncasecmp(make, \"YUNEEC\", 6))\n  {\n\n    if (raw_width > 0 && ((flen - data_offset) / (raw_width * 8 / 7) == raw_height))\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw)\n    {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height)\n      height = raw_height;\n    for (i = 0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1])\n      {\n        left_margin = pana[i][2];\n        top_margin = pana[i][3];\n        width += pana[i][4];\n        height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"[((filters - 1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  }\n  else if (!strcmp(model, \"C770UZ\"))\n  {\n    height = 1718;\n    width = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  }\n  else if (!strncmp(make, \"Olympus\", 7))\n  {\n    height += height & 1;\n    if (exif_cfa)\n      filters = exif_cfa;\n    if (width == 4100)\n      width -= 4;\n    if (width == 4080)\n      width -= 24;\n    if (width == 9280)\n    {\n      width -= 6;\n      height -= 6;\n    }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model, \"E-300\") || !strcmp(model, \"E-500\"))\n    {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw)\n      {\n        maximum = 0xfc3;\n        memset(cblack, 0, sizeof cblack);\n      }\n    }\n    else if (!strcmp(model, \"STYLUS1\"))\n    {\n      width -= 14;\n      maximum = 0xfff;\n    }\n    else if (!strcmp(model, \"E-330\"))\n    {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n        maximum = 0xf79;\n    }\n    else if (!strcmp(model, \"SP550UZ\"))\n    {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width = 640;\n    }\n    else if (!strcmp(model, \"TG-4\"))\n    {\n      width -= 16;\n    }\n    else if (!strcmp(model, \"TG-5\"))\n    {\n      width -= 26;\n    }\n  }\n  else if (!strcmp(model, \"N Digital\"))\n  {\n    height = 2047;\n    width = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strcmp(model, \"DSC-F828\"))\n  {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy(cdesc, \"RGBE\");\n  }\n  else if (!strcmp(model, \"DSC-V3\"))\n  {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 3984)\n  {\n    width = 3925;\n    order = 0x4d4d;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4288)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(make, \"Sony\") && raw_width == 4600)\n  {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4928)\n  {\n    if (height < 3280)\n      width -= 8;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 5504)\n  { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 6048)\n  {\n    width -= 24;\n    if (strstr(model, \"RX1\") || strstr(model, \"A99\"))\n      width -= 6;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 7392)\n  {\n    width -= 30;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 8000)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(model, \"DSLR-A100\"))\n  {\n    if (width == 3880)\n    {\n      height--;\n      width = ++raw_width;\n    }\n    else\n    {\n      height -= 4;\n      width -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strcmp(model, \"PIXL\"))\n  {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve(0, 7, 1, 255);\n  }\n  else if (!strcmp(model, \"C603\") || !strcmp(model, \"C330\") || !strcmp(model, \"12MP\"))\n  {\n    order = 0x4949;\n    if (filters && data_offset)\n    {\n      fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts(curve, 256);\n    }\n    else\n      gamma_curve(0, 3.875, 1, 255);\n    load_raw = filters ? &CLASS eight_bit_load_raw\n                       : strcmp(model, \"C330\") ? &CLASS kodak_c603_load_raw : &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  }\n  else if (!strncasecmp(model, \"EasyShare\", 9))\n  {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strncasecmp(make, \"Kodak\", 5))\n  {\n    if (filters == UINT_MAX)\n      filters = 0x61616161;\n    if (!strncmp(model, \"NC2000\", 6) || !strncmp(model, \"EOSDCS\", 6) || !strncmp(model, \"DCS4\", 4))\n    {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ')\n        model[6] = 0;\n      if (!strcmp(model, \"DCS460A\"))\n        goto bw;\n    }\n    else if (!strcmp(model, \"DCS660M\"))\n    {\n      black = 214;\n      goto bw;\n    }\n    else if (!strcmp(model, \"DCS760M\"))\n    {\n    bw:\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model + 4, \"20X\"))\n      strcpy(cdesc, \"MYCY\");\n    if (strstr(model, \"DC25\"))\n    {\n      strcpy(model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model, \"DC2\", 3))\n    {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000)\n      {\n        raw_width = 256;\n        width = 249;\n        pixel_aspect = (4.0 * height) / (3.0 * width);\n      }\n      else\n      {\n        raw_width = 512;\n        width = 501;\n        pixel_aspect = (493.0 * height) / (373.0 * width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    }\n    else if (!strcmp(model, \"40\"))\n    {\n      strcpy(model, \"DC40\");\n      height = 512;\n      width = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    }\n    else if (strstr(model, \"DC50\"))\n    {\n      strcpy(model, \"DC50\");\n      height = 512;\n      width = 768;\n      iso_speed = 84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    }\n    else if (strstr(model, \"DC120\"))\n    {\n      strcpy(model, \"DC120\");\n      raw_height = height = 976;\n      raw_width = width = 848;\n      iso_speed = 160;\n      pixel_aspect = height / 0.75 / width;\n      load_raw = tiff_compress == 7 ? &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    }\n    else if (!strcmp(model, \"DCS200\"))\n    {\n      thumb_height = 128;\n      thumb_width = 192;\n      thumb_offset = 6144;\n      thumb_misc = 360;\n      iso_speed = 140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  }\n  else if (!strcmp(model, \"Fotoman Pixtura\"))\n  {\n    height = 512;\n    width = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  }\n  else if (!strncmp(model, \"QuickTake\", 9))\n  {\n    if (head[5])\n      strcpy(model + 10, \"200\");\n    fseek(ifp, 544, SEEK_SET);\n    height = get2();\n    width = get2();\n    data_offset = (get4(), get2()) == 30 ? 738 : 736;\n    if (height > width)\n    {\n      SWAP(height, width);\n      fseek(ifp, data_offset - 6, SEEK_SET);\n      flip = ~get2() & 3 ? 5 : 6;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strncmp(make, \"Rollei\", 6) && !load_raw)\n  {\n    switch (raw_width)\n    {\n    case 1316:\n      height = 1030;\n      width = 1300;\n      top_margin = 1;\n      left_margin = 6;\n      break;\n    case 2568:\n      height = 1960;\n      width = 2560;\n      top_margin = 2;\n      left_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model, \"GRAS-50S5C\"))\n  {\n    height = 2048;\n    width = 2440;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x49494949;\n    order = 0x4949;\n    maximum = 0xfffC;\n  }\n  else if (!strcmp(model, \"BB-500CL\"))\n  {\n    height = 2058;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"BB-500GE\"))\n  {\n    height = 2058;\n    width = 2456;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"SVS625CL\"))\n  {\n    height = 2050;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1\n      /* alloc in unpack() may be fooled by size adjust */\n      || ((int)width + (int)left_margin > 65535) || ((int)height + (int)top_margin > 65535))\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if (!model[0])\n    sprintf(model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX)\n    filters = 0x94949494;\n  if (thumb_offset && !thumb_height)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      thumb_width = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (dng_version) /* Override black level by DNG tags */\n  {\n    /* copy DNG data from per-IFD field to color.dng */\n    int iifd = 0; // Active IFD we'll show to user.\n    for (; iifd < tiff_nifds; iifd++)\n      if (tiff_ifd[iifd].offset == data_offset) // found\n        break;\n    int pifd = -1;\n    for (int ii = 0; ii < tiff_nifds; ii++)\n      if (tiff_ifd[ii].offset == thumb_offset) // found\n      {\n        pifd = ii;\n        break;\n      }\n\n#define CFAROUND(value, filters) filters ? (filters >= 1000 ? ((value + 1) / 2) * 2 : ((value + 5) / 6) * 6) : value\n\n#define IFDCOLORINDEX(ifd, subset, bit)                                                                                \\\n  (tiff_ifd[ifd].dng_color[subset].parsedfields & bit) ? ifd                                                           \\\n                                                       : ((tiff_ifd[0].dng_color[subset].parsedfields & bit) ? 0 : -1)\n\n#define IFDLEVELINDEX(ifd, bit)                                                                                        \\\n  (tiff_ifd[ifd].dng_levels.parsedfields & bit) ? ifd : ((tiff_ifd[0].dng_levels.parsedfields & bit) ? 0 : -1)\n\n#define COPYARR(to, from) memmove(&to, &from, sizeof(from))\n\n    if (iifd < tiff_nifds)\n    {\n      int sidx;\n      // Per field, not per structure\n\n      if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP)\n      {\n        sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPORIGIN);\n        int sidx2 = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPSIZE);\n        if (sidx >= 0 && sidx == sidx2 && tiff_ifd[sidx].dng_levels.default_crop[2] > 0 &&\n            tiff_ifd[sidx].dng_levels.default_crop[3] > 0)\n        {\n          int lm = tiff_ifd[sidx].dng_levels.default_crop[0];\n          int lmm = CFAROUND(lm, filters);\n          int tm = tiff_ifd[sidx].dng_levels.default_crop[1];\n          int tmm = CFAROUND(tm, filters);\n          int ww = tiff_ifd[sidx].dng_levels.default_crop[2];\n          int hh = tiff_ifd[sidx].dng_levels.default_crop[3];\n          if (lmm > lm)\n            ww -= (lmm - lm);\n          if (tmm > tm)\n            hh -= (tmm - tm);\n          if (left_margin + lm + ww <= raw_width && top_margin + tm + hh <= raw_height)\n          {\n            left_margin += lmm;\n            top_margin += tmm;\n            width = ww;\n            height = hh;\n          }\n        }\n      }\n      if (!(imgdata.color.dng_color[0].parsedfields & LIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)\n      {\n        sidx = IFDCOLORINDEX(iifd, 0, LIBRAW_DNGFM_FORWARDMATRIX);\n        if (sidx >= 0)\n          COPYARR(imgdata.color.dng_color[0].forwardmatrix, tiff_ifd[sidx].dng_color[0].forwardmatrix);\n      }\n      if (!(imgdata.color.dng_color[1].parsedfields & LIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)\n      {\n        sidx = IFDCOLORINDEX(iifd, 1, LIBRAW_DNGFM_FORWARDMATRIX);\n        if (sidx >= 0)\n          COPYARR(imgdata.color.dng_color[1].forwardmatrix, tiff_ifd[sidx].dng_color[1].forwardmatrix);\n      }\n      for (int ss = 0; ss < 2; ss++)\n      {\n        sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_COLORMATRIX);\n        if (sidx >= 0)\n          COPYARR(imgdata.color.dng_color[ss].colormatrix, tiff_ifd[sidx].dng_color[ss].colormatrix);\n\n        sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_CALIBRATION);\n        if (sidx >= 0)\n          COPYARR(imgdata.color.dng_color[ss].calibration, tiff_ifd[sidx].dng_color[ss].calibration);\n\n        sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_ILLUMINANT);\n        if (sidx >= 0)\n          imgdata.color.dng_color[ss].illuminant = tiff_ifd[sidx].dng_color[ss].illuminant;\n      }\n      // Levels\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ANALOGBALANCE);\n      if (sidx >= 0)\n        COPYARR(imgdata.color.dng_levels.analogbalance, tiff_ifd[sidx].dng_levels.analogbalance);\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_WHITE);\n      if (sidx >= 0)\n        COPYARR(imgdata.color.dng_levels.dng_whitelevel, tiff_ifd[sidx].dng_levels.dng_whitelevel);\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_BLACK);\n      if (sidx >= 0)\n      {\n        imgdata.color.dng_levels.dng_black = tiff_ifd[sidx].dng_levels.dng_black;\n        COPYARR(imgdata.color.dng_levels.dng_cblack, tiff_ifd[sidx].dng_levels.dng_cblack);\n      }\n      if (pifd >= 0)\n      {\n        sidx = IFDLEVELINDEX(pifd, LIBRAW_DNGFM_PREVIEWCS);\n        if (sidx >= 0)\n          imgdata.color.dng_levels.preview_colorspace = tiff_ifd[sidx].dng_levels.preview_colorspace;\n      }\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_OPCODE2);\n      if (sidx >= 0)\n        meta_offset = tiff_ifd[sidx].opcode2_offset;\n\n      sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_LINTABLE);\n      INT64 linoff = -1;\n      int linlen = 0;\n      if (sidx >= 0)\n      {\n        linoff = tiff_ifd[sidx].lineartable_offset;\n        linlen = tiff_ifd[sidx].lineartable_len;\n      }\n\n      if (linoff >= 0 && linlen > 0)\n      {\n        INT64 pos = ftell(ifp);\n        fseek(ifp, linoff, SEEK_SET);\n        linear_table(linlen);\n        fseek(ifp, pos, SEEK_SET);\n      }\n      // Need to add curve too\n    }\n    /* Copy DNG black level to LibRaw's */\n    maximum = imgdata.color.dng_levels.dng_whitelevel[0];\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0, (sizeof(cblack) / sizeof(cblack[0])),\n                 (sizeof(imgdata.color.dng_levels.dng_cblack) / sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for (int i = 0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2)) && cmatrix[0][0] > 0.125)\n  {\n    memcpy(rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color)\n    adobe_coeff(make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if (imgdata.color.cam_xyz[0][0] < 0.01)\n    adobe_coeff(make, model, 1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color)\n      adobe_coeff(\"Apple\", \"Quicktake\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Clear erorneus fuji_width if not set through parse_fuji or for DNG\n  if (fuji_width && !dng_version && !(imgdata.process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED))\n    fuji_width = 0;\n#endif\n  if (fuji_width)\n  {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  }\n  else\n  {\n    if (raw_height < height)\n      raw_height = height;\n    if (raw_width < width)\n      raw_width = width;\n  }\n  if (!tiff_bps)\n    tiff_bps = 12;\n  if (!maximum)\n  {\n    maximum = (1 << tiff_bps) - 1;\n    if (maximum < 0x10000 && curve[maximum] > 0 && load_raw == &CLASS sony_arw2_load_raw)\n      maximum = curve[maximum];\n  }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if (raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_height > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw || load_raw == &CLASS lossy_dng_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy(cdesc, colors == 3 ? \"RGBG\" : \"GMCY\");\n  if (!raw_height)\n    raw_height = height;\n  if (!raw_width)\n    raw_width = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX)\n    flip = tiff_flip;\n  if (flip == UINT_MAX)\n    flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if (flip > 89 || flip < -89)\n  {\n    switch ((flip + 3600) % 360)\n    {\n    case 270:\n      flip = 5;\n      break;\n    case 180:\n      flip = 3;\n      break;\n    case 90:\n      flip = 6;\n      break;\n    }\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n}\n\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] = {\n      {0.436083, 0.385083, 0.143055}, {0.222507, 0.716888, 0.060608}, {0.013930, 0.097097, 0.714022}};\n  static const double rgb_rgb[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n  static const double adobe_rgb[3][3] = {\n      {0.715146, 0.284856, 0.000000}, {0.000000, 1.000000, 0.000000}, {0.000000, 0.041166, 0.958839}};\n  static const double wide_rgb[3][3] = {\n      {0.593087, 0.404710, 0.002206}, {0.095413, 0.843149, 0.061439}, {0.011621, 0.069091, 0.919288}};\n  static const double prophoto_rgb[3][3] = {\n      {0.529317, 0.330092, 0.140588}, {0.098368, 0.873465, 0.028169}, {0.016879, 0.117663, 0.865457}};\n  static const double aces_rgb[3][3] = {\n      {0.432996, 0.375380, 0.189317}, {0.089427, 0.816523, 0.102989}, {0.019165, 0.118150, 0.941914}};\n  static const double(*out_rgb[])[3] = {rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb};\n  static const char *name[] = {\"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\"};\n  static const unsigned phead[] = {1024, 0, 0x2100000,  0x6d6e7472, 0x52474220, 0x58595a20, 0,\n                                   0,    0, 0x61637370, 0,          0,          0x6e6f6e65, 0,\n                                   0,    0, 0,          0xf6d6,     0x10000,    0xd32d};\n  unsigned pbody[] = {10,         0x63707274, 0,  36, /* cprt */\n                      0x64657363, 0,          40,     /* desc */\n                      0x77747074, 0,          20,     /* wtpt */\n                      0x626b7074, 0,          20,     /* bkpt */\n                      0x72545243, 0,          14,     /* rTRC */\n                      0x67545243, 0,          14,     /* gTRC */\n                      0x62545243, 0,          14,     /* bTRC */\n                      0x7258595a, 0,          20,     /* rXYZ */\n                      0x6758595a, 0,          20,     /* gXYZ */\n                      0x6258595a, 0,          20};    /* bXYZ */\n  static const unsigned pwhite[] = {0xf351, 0x10000, 0x116cc};\n  unsigned pcurve[] = {0x63757276, 0, 1, 0x1000000};\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 0, 2);\n#endif\n  gamma_curve(gamm[0], gamm[1], 0, 0);\n  memcpy(out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode || output_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 || output_color < 1 || output_color > 6;\n#endif\n  if (!raw_color)\n  {\n    oprof = (unsigned *)calloc(phead[0], 1);\n    merror(oprof, \"convert_to_rgb()\");\n    memcpy(oprof, phead, sizeof phead);\n    if (output_color == 5)\n      oprof[4] = oprof[5];\n    oprof[0] = 132 + 12 * pbody[0];\n    for (i = 0; i < pbody[0]; i++)\n    {\n      oprof[oprof[0] / 4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i * 3 + 2] = oprof[0];\n      oprof[0] += (pbody[i * 3 + 3] + 3) & -4;\n    }\n    memcpy(oprof + 32, pbody, sizeof pbody);\n    oprof[pbody[5] / 4 + 2] = strlen(name[output_color - 1]) + 1;\n    memcpy((char *)oprof + pbody[8] + 8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256 / gamm[5] + 0.5) << 16;\n    for (i = 4; i < 7; i++)\n      memcpy((char *)oprof + pbody[i * 3 + 2], pcurve, sizeof pcurve);\n    pseudoinverse((double(*)[3])out_rgb[output_color - 1], inverse, 3);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < 3; j++)\n      {\n        for (num = k = 0; k < 3; k++)\n          num += xyzd50_srgb[i][k] * inverse[j][k];\n        oprof[pbody[j * 3 + 23] / 4 + i + 2] = num * 0x10000 + 0.5;\n      }\n    for (i = 0; i < phead[0] / 4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy((char *)oprof + pbody[2] + 8, \"auto-generated by dcraw\");\n    strcpy((char *)oprof + pbody[5] + 12, name[output_color - 1]);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (out_cam[i][j] = k = 0; k < 3; k++)\n          out_cam[i][j] += out_rgb[output_color - 1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, raw_color ? _(\"Building histograms...\\n\") : _(\"Converting to %s colorspace...\\n\"),\n            name[output_color - 1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset(histogram, 0, sizeof histogram);\n  for (img = image[0], row = 0; row < height; row++)\n    for (col = 0; col < width; col++, img += 4)\n    {\n      if (!raw_color)\n      {\n        out[0] = out[1] = out[2] = 0;\n        FORCC\n        {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        FORC3 img[c] = CLIP((int)out[c]);\n      }\n      else if (document_mode)\n        img[0] = img[fcol(row, col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color)\n    colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters)\n    colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 1, 2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort(*)[4])calloc(high, wide * sizeof *img);\n  merror(img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 0, 2);\n#endif\n\n  for (row = 0; row < high; row++)\n    for (col = 0; col < wide; col++)\n    {\n      ur = r = fuji_width + (row - col) * step;\n      uc = c = (row + col) * step;\n      if (ur > height - 2 || uc > width - 2)\n        continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur * width + uc;\n      for (i = 0; i < colors; i++)\n        img[row * wide + col][i] = (pix[0][i] * (1 - fc) + pix[1][i] * fc) * (1 - fr) +\n                                   (pix[width][i] * (1 - fc) + pix[width + 1][i] * fc) * fr;\n    }\n\n  free(image);\n  width = wide;\n  height = high;\n  image = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 1, 2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 0, 2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1)\n  {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(width, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = row = 0; row < newdim; row++, rc += pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c * width];\n      if (c + 1 < height)\n        pix1 += width * 4;\n      for (col = 0; col < width; col++, pix0 += 4, pix1 += 4)\n        FORCC img[row * width + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    height = newdim;\n  }\n  else\n  {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(height, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = col = 0; col < newdim; col++, rc += 1 / pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c + 1 < width)\n        pix1 += 4;\n      for (row = 0; row < height; row++, pix0 += width * 4, pix1 += width * 4)\n        FORCC img[row * newdim + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    width = newdim;\n  }\n  free(image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 1, 2);\n#endif\n}\n\nint CLASS flip_index(int row, int col)\n{\n  if (flip & 4)\n    SWAP(row, col);\n  if (flip & 2)\n    row = iheight - 1 - row;\n  if (flip & 1)\n    col = iwidth - 1 - col;\n  return row * iwidth + col;\n}\n\nvoid CLASS tiff_set(struct tiff_hdr *th, ushort *ntag, ushort tag, ushort type, int count, int val)\n{\n  struct libraw_tiff_tag *tt;\n  int c;\n\n  tt = (struct libraw_tiff_tag *)(ntag + 1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2)\n  {\n    count = strnlen((char *)th + val, count - 1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val + c];\n  }\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head(struct tiff_hdr *th, int full)\n{\n  int c, psize = 0;\n  struct tm *t;\n\n  memset(th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4 + c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy(th->t_desc, desc, 512);\n  strncpy(th->t_make, make, 64);\n  strncpy(th->t_model, model, 64);\n  strcpy(th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime(&timestamp);\n  sprintf(th->date, \"%04d:%02d:%02d %02d:%02d:%02d\", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour,\n          t->tm_min, t->tm_sec);\n  strncpy(th->t_artist, artist, 64);\n  if (full)\n  {\n    tiff_set(th, &th->ntag, 254, 4, 1, 0);\n    tiff_set(th, &th->ntag, 256, 4, 1, width);\n    tiff_set(th, &th->ntag, 257, 4, 1, height);\n    tiff_set(th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag - 1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set(th, &th->ntag, 259, 3, 1, 1);\n    tiff_set(th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set(th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set(th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set(th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full)\n  {\n    if (oprof)\n      psize = ntohl(oprof[0]);\n    tiff_set(th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set(th, &th->ntag, 277, 3, 1, colors);\n    tiff_set(th, &th->ntag, 278, 4, 1, height);\n    tiff_set(th, &th->ntag, 279, 4, 1, height * width * colors * output_bps / 8);\n  }\n  else\n    tiff_set(th, &th->ntag, 274, 3, 1, \"12435867\"[flip] - '0');\n  tiff_set(th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set(th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set(th, &th->ntag, 284, 3, 1, 1);\n  tiff_set(th, &th->ntag, 296, 3, 1, 2);\n  tiff_set(th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set(th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set(th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set(th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize)\n    tiff_set(th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set(th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set(th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set(th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set(th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1])\n  {\n    tiff_set(th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set(th, &th->ngps, 0, 1, 4, 0x202);\n    tiff_set(th, &th->ngps, 1, 2, 2, gpsdata[29]);\n    tiff_set(th, &th->ngps, 2, 5, 3, TOFF(th->gps[0]));\n    tiff_set(th, &th->ngps, 3, 2, 2, gpsdata[30]);\n    tiff_set(th, &th->ngps, 4, 5, 3, TOFF(th->gps[6]));\n    tiff_set(th, &th->ngps, 5, 1, 1, gpsdata[31]);\n    tiff_set(th, &th->ngps, 6, 5, 1, TOFF(th->gps[18]));\n    tiff_set(th, &th->ngps, 7, 5, 3, TOFF(th->gps[12]));\n    tiff_set(th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set(th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy(th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer(FILE *tfp, char *t_humb, int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc(0xff, tfp);\n  fputc(0xd8, tfp);\n  if (strcmp(t_humb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, tfp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, tfp);\n  }\n  fwrite(t_humb + 2, 1, t_humb_length - 2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp, thumb, thumb_length);\n  free(thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  fputc(0xff, ofp);\n  fputc(0xd8, ofp);\n  if (strcmp(thumb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, ofp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, ofp);\n  }\n  fwrite(thumb + 2, 1, thumb_length - 2, ofp);\n  free(thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white = 0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01; /* 99th percentile white level */\n#endif\n  if (fuji_width)\n    perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white = c = 0; c < colors; c++)\n    {\n      for (val = 0x2000, total = 0; --val > 32;)\n        if ((total += histogram[c][val]) > perc)\n          break;\n      if (t_white < val)\n        t_white = val;\n    }\n  gamma_curve(gamm[0], gamm[1], 2, (t_white << 3) / bright);\n  iheight = height;\n  iwidth = width;\n  if (flip & 4)\n    SWAP(height, width);\n  ppm = (uchar *)calloc(width, colors * output_bps / 8);\n  ppm2 = (ushort *)ppm;\n  merror(ppm, \"write_ppm_tiff()\");\n  if (output_tiff)\n  {\n    tiff_head(&th, 1);\n    fwrite(&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite(oprof, ntohl(oprof[0]), 1, ofp);\n  }\n  else if (colors > 3)\n    fprintf(ofp, \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", width, height, colors,\n            (1 << output_bps) - 1, cdesc);\n  else\n    fprintf(ofp, \"P%d\\n%d %d\\n%d\\n\", colors / 2 + 5, width, height, (1 << output_bps) - 1);\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, width);\n  for (row = 0; row < height; row++, soff += rstep)\n  {\n    for (col = 0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n        FORCC ppm[col * colors + c] = curve[image[soff][c]] >> 8;\n      else\n        FORCC ppm2[col * colors + c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab((char *)ppm2, (char *)ppm2, width * colors * 2);\n    fwrite(ppm, colors * output_bps / 8, width, ofp);\n  }\n  free(ppm);\n}\n", "/* Library for accessing X3F Files \n----------------------------------------------------------------\nBSD-style License\n----------------------------------------------------------------\n\n* Copyright (c) 2010, Roland Karlsson (roland@proxel.se)\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are met:\n*     * Redistributions of source code must retain the above copyright\n*       notice, this list of conditions and the following disclaimer.\n*     * Redistributions in binary form must reproduce the above copyright\n*       notice, this list of conditions and the following disclaimer in the\n*       documentation and/or other materials provided with the distribution.\n*     * Neither the name of the organization nor the\n*       names of its contributors may be used to endorse or promote products\n*       derived from this software without specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY ROLAND KARLSSON ''AS IS'' AND ANY\n* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n* DISCLAIMED. IN NO EVENT SHALL ROLAND KARLSSON BE LIABLE FOR ANY\n* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n  /* From X3F_IO.H */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include \"../libraw/libraw_datastream.h\"\n\n#define SIZE_UNIQUE_IDENTIFIER 16\n#define SIZE_WHITE_BALANCE 32\n#define SIZE_COLOR_MODE 32\n#define NUM_EXT_DATA_2_1 32\n#define NUM_EXT_DATA_3_0 64\n#define NUM_EXT_DATA NUM_EXT_DATA_3_0\n\n#define X3F_VERSION(MAJ,MIN) (uint32_t)(((MAJ)<<16) + MIN)\n#define X3F_VERSION_2_0 X3F_VERSION(2,0)\n#define X3F_VERSION_2_1 X3F_VERSION(2,1)\n#define X3F_VERSION_2_2 X3F_VERSION(2,2)\n#define X3F_VERSION_2_3 X3F_VERSION(2,3)\n#define X3F_VERSION_3_0 X3F_VERSION(3,0)\n#define X3F_VERSION_4_0 X3F_VERSION(4,0)\n\n/* Main file identifier */\n#define X3F_FOVb (uint32_t)(0x62564f46)\n/* Directory identifier */\n#define X3F_SECd (uint32_t)(0x64434553)\n/* Property section identifiers */\n#define X3F_PROP (uint32_t)(0x504f5250)\n#define X3F_SECp (uint32_t)(0x70434553)\n/* Image section identifiers */\n#define X3F_IMAG (uint32_t)(0x46414d49)\n#define X3F_IMA2 (uint32_t)(0x32414d49)\n#define X3F_SECi (uint32_t)(0x69434553)\n/* CAMF section identifiers */\n#define X3F_CAMF (uint32_t)(0x464d4143)\n#define X3F_SECc (uint32_t)(0x63434553)\n/* CAMF entry identifiers */\n#define X3F_CMbP (uint32_t)(0x50624d43)\n#define X3F_CMbT (uint32_t)(0x54624d43)\n#define X3F_CMbM (uint32_t)(0x4d624d43)\n#define X3F_CMb  (uint32_t)(0x00624d43)\n/* SDQ section identifiers ? - TODO */\n#define X3F_SPPA (uint32_t)(0x41505053)\n#define X3F_SECs (uint32_t)(0x73434553)\n\n#define X3F_IMAGE_THUMB_PLAIN       (uint32_t)(0x00020003)\n#define X3F_IMAGE_THUMB_HUFFMAN     (uint32_t)(0x0002000b)\n#define X3F_IMAGE_THUMB_JPEG        (uint32_t)(0x00020012)\n#define X3F_IMAGE_THUMB_SDQ         (uint32_t)(0x00020019)  /* SDQ ? - TODO */\n\n#define X3F_IMAGE_RAW_HUFFMAN_X530  (uint32_t)(0x00030005)\n#define X3F_IMAGE_RAW_HUFFMAN_10BIT (uint32_t)(0x00030006)\n#define X3F_IMAGE_RAW_TRUE          (uint32_t)(0x0003001e)\n#define X3F_IMAGE_RAW_MERRILL       (uint32_t)(0x0001001e)\n#define X3F_IMAGE_RAW_QUATTRO       (uint32_t)(0x00010023)\n#define X3F_IMAGE_RAW_SDQ           (uint32_t)(0x00010025)\n#define X3F_IMAGE_RAW_SDQH           (uint32_t)(0x00010027)\n#define X3F_IMAGE_RAW_SDQH2           (uint32_t)(0x00010029)\n\n#define X3F_IMAGE_HEADER_SIZE 28\n#define X3F_CAMF_HEADER_SIZE 28\n#define X3F_PROPERTY_LIST_HEADER_SIZE 24\n\ntypedef uint16_t utf16_t;\n\ntypedef int bool_t;\n\ntypedef enum x3f_extended_types_e {\n  X3F_EXT_TYPE_NONE=0,\n  X3F_EXT_TYPE_EXPOSURE_ADJUST=1,\n  X3F_EXT_TYPE_CONTRAST_ADJUST=2,\n  X3F_EXT_TYPE_SHADOW_ADJUST=3,\n  X3F_EXT_TYPE_HIGHLIGHT_ADJUST=4,\n  X3F_EXT_TYPE_SATURATION_ADJUST=5,\n  X3F_EXT_TYPE_SHARPNESS_ADJUST=6,\n  X3F_EXT_TYPE_RED_ADJUST=7,\n  X3F_EXT_TYPE_GREEN_ADJUST=8,\n  X3F_EXT_TYPE_BLUE_ADJUST=9,\n  X3F_EXT_TYPE_FILL_LIGHT_ADJUST=10\n} x3f_extended_types_t;\n\ntypedef struct x3f_property_s {\n  /* Read from file */\n  uint32_t name_offset;\n  uint32_t value_offset;\n\n  /* Computed */\n  utf16_t *name;\t\t/* 0x0000 terminated UTF 16 */\n  utf16_t *value;               /* 0x0000 terminated UTF 16 */\n} x3f_property_t;\n\ntypedef struct x3f_property_table_s {\n  uint32_t size;\n  x3f_property_t *element;\n} x3f_property_table_t;\n\ntypedef struct x3f_property_list_s {\n  /* 2.0 Fields */\n  uint32_t num_properties;\n  uint32_t character_format;\n  uint32_t reserved;\n  uint32_t total_length;\n\n  x3f_property_table_t property_table;\n\n  void *data;\n\n  uint32_t data_size;\n\n} x3f_property_list_t;\n\ntypedef struct x3f_table8_s {\n  uint32_t size;\n  uint8_t *element;\n} x3f_table8_t;\n\ntypedef struct x3f_table16_s {\n  uint32_t size;\n  uint16_t *element;\n} x3f_table16_t;\n\ntypedef struct x3f_table32_s {\n  uint32_t size;\n  uint32_t *element;\n} x3f_table32_t;\n\ntypedef struct\n{\n  uint8_t *data;\t\t/* Pointer to actual image data */\n  void *buf;\t\t\t/* Pointer to allocated buffer for free() */\n  uint32_t rows;\n  uint32_t columns;\n  uint32_t channels;\n  uint32_t row_stride;\n} x3f_area8_t;\n\ntypedef struct\n{\n  uint16_t *data;\t\t/* Pointer to actual image data */\n  void *buf;\t\t\t/* Pointer to allocated buffer for free() */\n  uint32_t rows;\n  uint32_t columns;\n  uint32_t channels;\n  uint32_t row_stride;\n} x3f_area16_t;\n\n#define UNDEFINED_LEAF 0xffffffff\n\ntypedef struct x3f_huffnode_s {\n  struct x3f_huffnode_s *branch[2];\n  uint32_t leaf;\n} x3f_huffnode_t;\n\ntypedef struct x3f_hufftree_s {\n  uint32_t free_node_index; /* Free node index in huffman tree array */\n  x3f_huffnode_t *nodes;    /* Coding tree */\n} x3f_hufftree_t;\n\ntypedef struct x3f_true_huffman_element_s {\n  uint8_t code_size;\n  uint8_t code;\n} x3f_true_huffman_element_t;\n\ntypedef struct x3f_true_huffman_s {\n  uint32_t size;\n  x3f_true_huffman_element_t *element;\n} x3f_true_huffman_t;\n\n/* 0=bottom, 1=middle, 2=top */\n#define TRUE_PLANES 3\n\ntypedef struct x3f_true_s {\n  uint16_t seed[TRUE_PLANES];\t/* Always 512,512,512 */\n  uint16_t unknown;\t\t/* Always 0 */\n  x3f_true_huffman_t table;\t/* Huffman table - zero\n\t\t\t\t   terminated. size is the number of\n\t\t\t\t   leaves plus 1.*/\n\n  x3f_table32_t plane_size;\t/* Size of the 3 planes */\n  uint8_t *plane_address[TRUE_PLANES]; /* computed offset to the planes */\n  x3f_hufftree_t tree;\t\t/* Coding tree */\n  x3f_area16_t x3rgb16;\t\t/* 3x16 bit X3-RGB data */\n} x3f_true_t;\n\ntypedef struct x3f_quattro_s {\n  struct {\n    uint16_t columns;\n    uint16_t rows;\n  } plane[TRUE_PLANES];\n  uint32_t unknown;\n\n  bool_t quattro_layout;\n  x3f_area16_t top16;\t\t/* Container for the bigger top layer */\n} x3f_quattro_t;\n\ntypedef struct x3f_huffman_s {\n  x3f_table16_t mapping;   /* Value Mapping = X3F lossy compression */\n  x3f_table32_t table;          /* Coding Table */\n  x3f_hufftree_t tree;\t\t/* Coding tree */\n  x3f_table32_t row_offsets;    /* Row offsets */\n  x3f_area8_t rgb8;\t\t/* 3x8 bit RGB data */\n  x3f_area16_t x3rgb16;\t\t/* 3x16 bit X3-RGB data */\n} x3f_huffman_t;\n\ntypedef struct x3f_image_data_s {\n  /* 2.0 Fields */\n  /* ------------------------------------------------------------------ */\n  /* Known combinations of type and format are:\n     1-6, 2-3, 2-11, 2-18, 3-6 */\n  uint32_t type;                /* 1 = RAW X3 (SD1)\n                                   2 = thumbnail or maybe just RGB\n                                   3 = RAW X3 */\n  uint32_t format;              /* 3 = 3x8 bit pixmap\n                                   6 = 3x10 bit huffman with map table\n                                   11 = 3x8 bit huffman\n                                   18 = JPEG */\n  uint32_t type_format;         /* type<<16 + format */\n  /* ------------------------------------------------------------------ */\n\n  uint32_t columns;             /* width / row size in pixels */\n  uint32_t rows;                /* height */\n  uint32_t row_stride;          /* row size in bytes */\n\n  /* NULL if not used */\n  x3f_huffman_t *huffman;       /* Huffman help data */\n  x3f_true_t *tru;\t\t/* TRUE help data */\n  x3f_quattro_t *quattro;\t/* Quattro help data */\n\n  void *data;                   /* Take from file if NULL. Otherwise,\n                                   this is the actual data bytes in\n                                   the file. */\n  uint32_t data_size;\n\n} x3f_image_data_t;\n\ntypedef struct camf_dim_entry_s {\n  uint32_t size;\n  uint32_t name_offset;\n  uint32_t n; /* 0,1,2,3... */\n  char *name;\n} camf_dim_entry_t;\n\ntypedef enum {M_FLOAT, M_INT, M_UINT} matrix_type_t;\n\ntypedef struct camf_entry_s {\n  /* pointer into decoded data */\n  void *entry;\n\n  /* entry header */\n  uint32_t id;\n  uint32_t version;\n  uint32_t entry_size;\n  uint32_t name_offset;\n  uint32_t value_offset;\n\n  /* computed values */\n  char *name_address;\n  void *value_address;\n  uint32_t name_size;\n  uint32_t value_size;\n\n  /* extracted values for explicit CAMF entry types*/\n  uint32_t text_size;\n  char *text;\n\n  uint32_t property_num;\n  char **property_name;\n  uint8_t **property_value;\n\n  uint32_t matrix_dim;\n  camf_dim_entry_t *matrix_dim_entry;\n\n  /* Offset, pointer and size and type of raw data */\n  uint32_t matrix_type;\n  uint32_t matrix_data_off;\n  void *matrix_data;\n  uint32_t matrix_element_size;\n\n  /* Pointer and type of copied data */\n  matrix_type_t matrix_decoded_type;\n  void *matrix_decoded;\n\n  /* Help data to try to estimate element size */\n  uint32_t matrix_elements;\n  uint32_t matrix_used_space;\n  double matrix_estimated_element_size;\n\n} camf_entry_t;\n\ntypedef struct camf_entry_table_s {\n  uint32_t size;\n  camf_entry_t *element;\n} camf_entry_table_t;\n\ntypedef struct x3f_camf_typeN_s {\n  uint32_t val0;\n  uint32_t val1;\n  uint32_t val2;\n  uint32_t val3;\n} x3f_camf_typeN_t;\n\ntypedef struct x3f_camf_type2_s {\n  uint32_t reserved;\n  uint32_t infotype;\n  uint32_t infotype_version;\n  uint32_t crypt_key;\n} x3f_camf_type2_t;\n\ntypedef struct x3f_camf_type4_s {\n  uint32_t decoded_data_size;\n  uint32_t decode_bias;\n  uint32_t block_size;\n  uint32_t block_count;\n} x3f_camf_type4_t;\n\ntypedef struct x3f_camf_type5_s {\n  uint32_t decoded_data_size;\n  uint32_t decode_bias;\n  uint32_t unknown2;\n  uint32_t unknown3;\n} x3f_camf_type5_t;\n\ntypedef struct x3f_camf_s {\n\n  /* Header info */\n  uint32_t type;\n  union {\n    x3f_camf_typeN_t tN;\n    x3f_camf_type2_t t2;\n    x3f_camf_type4_t t4;\n    x3f_camf_type5_t t5;\n  };\n\n  /* The encrypted raw data */\n  void *data;\n  uint32_t data_size;\n\n  /* Help data for type 4 Huffman compression */\n  x3f_true_huffman_t table;\n  x3f_hufftree_t tree;\n  uint8_t *decoding_start;\n  uint32_t decoding_size;\n\n  /* The decrypted data */\n  void *decoded_data;\n  uint32_t decoded_data_size;\n\n  /* Pointers into the decrypted data */\n  camf_entry_table_t entry_table;\n} x3f_camf_t;\n\ntypedef struct x3f_directory_entry_header_s {\n  uint32_t identifier;        /* Should be \u00b4SECp\u00b4, \"SECi\", ... */\n  uint32_t version;           /* 0x00020001 is version 2.1  */\n  union {\n    x3f_property_list_t property_list;\n    x3f_image_data_t image_data;\n    x3f_camf_t camf;\n  } data_subsection;\n} x3f_directory_entry_header_t;\n\ntypedef struct x3f_directory_entry_s {\n  struct {\n    uint32_t offset;\n    uint32_t size;\n  } input, output;\n\n  uint32_t type;\n\n  x3f_directory_entry_header_t header;\n} x3f_directory_entry_t;\n\ntypedef struct x3f_directory_section_s {\n  uint32_t identifier;          /* Should be \u00b4SECd\u00b4 */\n  uint32_t version;             /* 0x00020001 is version 2.1  */\n\n  /* 2.0 Fields */\n  uint32_t num_directory_entries;\n  x3f_directory_entry_t *directory_entry;\n} x3f_directory_section_t;\n\ntypedef struct x3f_header_s {\n  /* 2.0 Fields */\n  uint32_t identifier;          /* Should be \u00b4FOVb\u00b4 */\n  uint32_t version;             /* 0x00020001 means 2.1 */\n  uint8_t unique_identifier[SIZE_UNIQUE_IDENTIFIER];\n  uint32_t mark_bits;\n  uint32_t columns;             /* Columns and rows ... */\n  uint32_t rows;                /* ... before rotation */\n  uint32_t rotation;            /* 0, 90, 180, 270 */\n\n  char white_balance[SIZE_WHITE_BALANCE]; /* Introduced in 2.1 */\n  char color_mode[SIZE_COLOR_MODE]; /* Introduced in 2.3 */\n\n  /* Introduced in 2.1 and extended from 32 to 64 in 3.0 */\n  uint8_t extended_types[NUM_EXT_DATA]; /* x3f_extended_types_t */\n  float extended_data[NUM_EXT_DATA]; /* 32 bits, but do type differ? */\n} x3f_header_t;\n\ntypedef struct x3f_info_s {\n  char *error;\n  struct {\n\tLibRaw_abstract_datastream *file;                 /* Use if more data is needed */\n  } input, output;\n} x3f_info_t;\n\ntypedef struct x3f_s {\n  x3f_info_t info;\n  x3f_header_t header;\n  x3f_directory_section_t directory_section;\n} x3f_t;\n\ntypedef enum x3f_return_e {\n  X3F_OK=0,\n  X3F_ARGUMENT_ERROR=1,\n  X3F_INFILE_ERROR=2,\n  X3F_OUTFILE_ERROR=3,\n  X3F_INTERNAL_ERROR=4\n} x3f_return_t;\n\nx3f_return_t x3f_delete(x3f_t *x3f);\n\n\n/* Hacky external flags                                                 */\n/* --------------------------------------------------------------------- */\n\n/* extern */ int legacy_offset = 0;\n/* extern */ bool_t auto_legacy_offset = 1;\n\n/* --------------------------------------------------------------------- */\n/* Huffman Decode Macros                                                 */\n/* --------------------------------------------------------------------- */\n\n#define HUF_TREE_MAX_LENGTH 27\n#define HUF_TREE_MAX_NODES(_leaves) ((HUF_TREE_MAX_LENGTH+1)*(_leaves))\n#define HUF_TREE_GET_LENGTH(_v) (((_v)>>27)&0x1f)\n#define HUF_TREE_GET_CODE(_v) ((_v)&0x07ffffff)\n\n/* --------------------------------------------------------------------- */\n/* Reading and writing - assuming little endian in the file              */\n/* --------------------------------------------------------------------- */\n\nstatic int x3f_get1(LibRaw_abstract_datastream *f)\n{\n\t/* Little endian file */\n\treturn f->get_char(); \n}\n\nstatic int  x3f_sget2 (uchar *s)\n{\n\treturn s[0] | s[1] << 8;\n}\n\nstatic int x3f_get2(LibRaw_abstract_datastream *f)\n{\n\tuchar str[2] = { 0xff,0xff };\n\tf->read (str, 1, 2);\n\treturn x3f_sget2(str);\n}\n\nunsigned x3f_sget4 (uchar *s)\n{\n\treturn s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n}\n\nunsigned x3f_get4(LibRaw_abstract_datastream *f)\n{\n\tuchar str[4] = { 0xff,0xff,0xff,0xff };\n\tf->read (str, 1, 4);\n\treturn x3f_sget4(str);\n}\n\n#define FREE(P) do { free(P); (P) = NULL; } while (0)\n\n#define PUT_GET_N(_buffer,_size,_file,_func)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint _left = _size;\t\t\t\t\t\t\t\\\n\t\twhile (_left != 0) {\t\t\t\t\t\t\\\n\t\tint _cur = _file->_func(_buffer,1,_left);\t\\\n\t\tif (_cur == 0) {\t\t\t\t\t\t\t\\\n\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t_left -= _cur;\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n} while(0)\n\n#define GET1(_v) do {(_v) = x3f_get1(I->input.file);} while (0)\n#define GET2(_v) do {(_v) = x3f_get2(I->input.file);} while (0)\n#define GET4(_v) do {(_v) = x3f_get4(I->input.file);} while (0)\n\n#define GET4F(_v)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\nunion {int32_t i; float f;} _tmp;\t\t\\\n\t_tmp.i = x3f_get4(I->input.file);\t\\\n\t(_v) = _tmp.f;\t\t\t\t\t\t\\\n\t} while (0)\n\n#define GETN(_v,_s) PUT_GET_N(_v,_s,I->input.file,read)\n\n#define GET_TABLE(_T, _GETX, _NUM,_TYPE)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\tint _i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t(_T).size = (_NUM);\t\t\t\t\t\t\t\t\\\n\t(_T).element = (_TYPE *)realloc((_T).element,\t\\\n\t(_NUM)*sizeof((_T).element[0]));\t\t\t\t\\\n\tfor (_i = 0; _i < (_T).size; _i++)\t\t\t\t\\\n\t_GETX((_T).element[_i]);\t\t\t\t\t\t\\\n\t} while (0)\n\n#define GET_PROPERTY_TABLE(_T, _NUM)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\tint _i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t(_T).size = (_NUM);\t\t\t\t\t\t\t\t\\\n\t(_T).element = (x3f_property_t *)realloc((_T).element,\t\\\n\t(_NUM)*sizeof((_T).element[0]));\t\t\t\t\\\n\tfor (_i = 0; _i < (_T).size; _i++) {\t\t\t\\\n\tGET4((_T).element[_i].name_offset);\t\t\t\t\\\n\tGET4((_T).element[_i].value_offset);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define GET_TRUE_HUFF_TABLE(_T)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\tint _i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t(_T).element = NULL;\t\t\t\t\t\t\t\\\n\tfor (_i = 0; ; _i++) {\t\t\t\t\t\t\t\\\n\t(_T).size = _i + 1;\t\t\t\t\t\t\t\t\\\n\t(_T).element = (x3f_true_huffman_element_t *)realloc((_T).element,\t\\\n\t(_i + 1)*sizeof((_T).element[0]));\t\t\t\t\\\n\tGET1((_T).element[_i].code_size);\t\t\t\t\\\n\tGET1((_T).element[_i].code);\t\t\t\t\t\\\n\tif ((_T).element[_i].code_size == 0) break;\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n/* --------------------------------------------------------------------- */\n/* Allocating Huffman tree help data                                   */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_huffman_tree(x3f_hufftree_t *HTP)\n{\n  free(HTP->nodes);\n}\n\nstatic void new_huffman_tree(x3f_hufftree_t *HTP, int bits)\n{\n  int leaves = 1<<bits;\n\n  HTP->free_node_index = 0;\n  HTP->nodes = (x3f_huffnode_t *)\n    calloc(1, HUF_TREE_MAX_NODES(leaves)*sizeof(x3f_huffnode_t));\n}\n\n/* --------------------------------------------------------------------- */\n/* Allocating TRUE engine RAW help data                                  */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_true(x3f_true_t **TRUP)\n{\n  x3f_true_t *TRU = *TRUP;\n\n  if (TRU == NULL) return;\n\n  FREE(TRU->table.element);\n  FREE(TRU->plane_size.element);\n  cleanup_huffman_tree(&TRU->tree);\n  FREE(TRU->x3rgb16.buf);\n\n  FREE(TRU);\n\n  *TRUP = NULL;\n}\n\nstatic x3f_true_t *new_true(x3f_true_t **TRUP)\n{\n  x3f_true_t *TRU = (x3f_true_t *)calloc(1, sizeof(x3f_true_t));\n\n  cleanup_true(TRUP);\n\n  TRU->table.size = 0;\n  TRU->table.element = NULL;\n  TRU->plane_size.size = 0;\n  TRU->plane_size.element = NULL;\n  TRU->tree.nodes = NULL;\n  TRU->x3rgb16.data = NULL;\n  TRU->x3rgb16.buf = NULL;\n\n  *TRUP = TRU;\n\n  return TRU;\n}\n\nstatic void cleanup_quattro(x3f_quattro_t **QP)\n{\n  x3f_quattro_t *Q = *QP;\n\n  if (Q == NULL) return;\n\n  FREE(Q->top16.buf);\n  FREE(Q);\n\n  *QP = NULL;\n}\n\nstatic x3f_quattro_t *new_quattro(x3f_quattro_t **QP)\n{\n  x3f_quattro_t *Q = (x3f_quattro_t *)calloc(1, sizeof(x3f_quattro_t));\n  int i;\n\n  cleanup_quattro(QP);\n\n  for (i=0; i<TRUE_PLANES; i++) {\n    Q->plane[i].columns = 0;\n    Q->plane[i].rows = 0;\n  }\n\n  Q->unknown = 0;\n\n  Q->top16.data = NULL;\n  Q->top16.buf = NULL;\n\n  *QP = Q;\n\n  return Q;\n}\n\n/* --------------------------------------------------------------------- */\n/* Allocating Huffman engine help data                                   */\n/* --------------------------------------------------------------------- */\n\nstatic void cleanup_huffman(x3f_huffman_t **HUFP)\n{\n  x3f_huffman_t *HUF = *HUFP;\n\n  if (HUF == NULL) return;\n\n  FREE(HUF->mapping.element);\n  FREE(HUF->table.element);\n  cleanup_huffman_tree(&HUF->tree);\n  FREE(HUF->row_offsets.element);\n  FREE(HUF->rgb8.buf);\n  FREE(HUF->x3rgb16.buf);\n  FREE(HUF);\n\n  *HUFP = NULL;\n}\n\nstatic x3f_huffman_t *new_huffman(x3f_huffman_t **HUFP)\n{\n  x3f_huffman_t *HUF = (x3f_huffman_t *)calloc(1, sizeof(x3f_huffman_t));\n\n  cleanup_huffman(HUFP);\n\n  /* Set all not read data block pointers to NULL */\n  HUF->mapping.size = 0;\n  HUF->mapping.element = NULL;\n  HUF->table.size = 0;\n  HUF->table.element = NULL;\n  HUF->tree.nodes = NULL;\n  HUF->row_offsets.size = 0;\n  HUF->row_offsets.element = NULL;\n  HUF->rgb8.data = NULL;\n  HUF->rgb8.buf = NULL;\n  HUF->x3rgb16.data = NULL;\n  HUF->x3rgb16.buf = NULL;\n\n  *HUFP = HUF;\n\n  return HUF;\n}\n\n/* --------------------------------------------------------------------- */\n/* Creating a new x3f structure from file                                */\n/* --------------------------------------------------------------------- */\n\n/* extern */ x3f_t *x3f_new_from_file(LibRaw_abstract_datastream *infile)\n{\n\tif (!infile) return NULL;\n  \tINT64 fsize = infile->size();\n\tx3f_t *x3f = (x3f_t *)calloc(1, sizeof(x3f_t));\n\tx3f_info_t *I = NULL;\n\tx3f_header_t *H = NULL;\n\tx3f_directory_section_t *DS = NULL;\n\tint i, d;\n\n\tI = &x3f->info;\n\tI->error = NULL;\n\tI->input.file = infile;\n\tI->output.file = NULL;\n\n\n  /* Read file header */\n\tH = &x3f->header;\n\tinfile->seek(0, SEEK_SET);\n\tGET4(H->identifier);\n\n\tif (H->identifier != X3F_FOVb) {\n\t\tfree(x3f);\n\t\treturn NULL;\n\t}\n\n\tGET4(H->version);\n\tGETN(H->unique_identifier, SIZE_UNIQUE_IDENTIFIER);\n\t/* TODO: the meaning of the rest of the header for version >= 4.0 (Quattro) is unknown */\n\tif (H->version < X3F_VERSION_4_0) {\n\t\tGET4(H->mark_bits);\n\t\tGET4(H->columns);\n\t\tGET4(H->rows);\n\t\tGET4(H->rotation);\n\t\tif (H->version >= X3F_VERSION_2_1) {\n\t\t\tint num_ext_data =\n\t\t\t\tH->version >= X3F_VERSION_3_0 ? NUM_EXT_DATA_3_0 : NUM_EXT_DATA_2_1;\n\n\t\t\tGETN(H->white_balance, SIZE_WHITE_BALANCE);\n\t\t\tif (H->version >= X3F_VERSION_2_3)\n\t\t\t\tGETN(H->color_mode, SIZE_COLOR_MODE);\n\t\t\tGETN(H->extended_types, num_ext_data);\n\t\t\tfor (i = 0; i < num_ext_data; i++)\n\t\t\t\tGET4F(H->extended_data[i]);\n\t\t}\n\t}\n\n  /* Go to the beginning of the directory */\n  infile->seek(-4, SEEK_END);\n  infile->seek(x3f_get4(infile), SEEK_SET);\n\n  /* Read the directory header */\n  DS = &x3f->directory_section;\n  GET4(DS->identifier);\n  GET4(DS->version);\n  GET4(DS->num_directory_entries);\n\n  if (DS->num_directory_entries > 50)\n\t  goto _err; // too much direntries, most likely broken file\n\n  if (DS->num_directory_entries > 0) {\n    size_t size = DS->num_directory_entries * sizeof(x3f_directory_entry_t);\n    DS->directory_entry = (x3f_directory_entry_t *)calloc(1, size);\n  }\n\n  /* Traverse the directory */\n  for (d=0; d<DS->num_directory_entries; d++) {\n    x3f_directory_entry_t *DE = &DS->directory_entry[d];\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    uint32_t save_dir_pos;\n\n    /* Read the directory entry info */\n    GET4(DE->input.offset);\n    GET4(DE->input.size);\n\tif (DE->input.offset + DE->input.size > fsize * 2)\n\t\tgoto _err;\n\n    DE->output.offset = 0;\n    DE->output.size = 0;\n\n    GET4(DE->type);\n\n    /* Save current pos and go to the entry */\n    save_dir_pos = infile->tell();\n    infile->seek(DE->input.offset, SEEK_SET);\n\n    /* Read the type independent part of the entry header */\n    DEH = &DE->header;\n    GET4(DEH->identifier);\n    GET4(DEH->version);\n\n    /* NOTE - the tests below could be made on DE->type instead */\n\n    if (DEH->identifier == X3F_SECp) {\n      x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\t  if (!PL)\n\t\t  goto _err;\n      /* Read the property part of the header */\n      GET4(PL->num_properties);\n      GET4(PL->character_format);\n      GET4(PL->reserved);\n      GET4(PL->total_length);\n\n      /* Set all not read data block pointers to NULL */\n      PL->data = NULL;\n      PL->data_size = 0;\n    }\n\n    if (DEH->identifier == X3F_SECi) {\n      x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\t  if (!ID)\n\t\t  goto _err;\n      /* Read the image part of the header */\n      GET4(ID->type);\n      GET4(ID->format);\n      ID->type_format = (ID->type << 16) + (ID->format);\n      GET4(ID->columns);\n      GET4(ID->rows);\n      GET4(ID->row_stride);\n\n      /* Set all not read data block pointers to NULL */\n      ID->huffman = NULL;\n\n      ID->data = NULL;\n      ID->data_size = 0;\n    }\n\n    if (DEH->identifier == X3F_SECc) {\n      x3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\t  if (!CAMF)\n\t\t  goto _err;\n      /* Read the CAMF part of the header */\n      GET4(CAMF->type);\n      GET4(CAMF->tN.val0);\n      GET4(CAMF->tN.val1);\n      GET4(CAMF->tN.val2);\n      GET4(CAMF->tN.val3);\n\n      /* Set all not read data block pointers to NULL */\n      CAMF->data = NULL;\n      CAMF->data_size = 0;\n\n      /* Set all not allocated help pointers to NULL */\n      CAMF->table.element = NULL;\n      CAMF->table.size = 0;\n      CAMF->tree.nodes = NULL;\n      CAMF->decoded_data = NULL;\n      CAMF->decoded_data_size = 0;\n      CAMF->entry_table.element = NULL;\n      CAMF->entry_table.size = 0;\n    }\n\n    /* Reset the file pointer back to the directory */\n    infile->seek(save_dir_pos, SEEK_SET);\n  }\n\n  return x3f;\n_err:\n  if (x3f)\n  {\n\t  DS = &x3f->directory_section;\n\t  if (DS && DS->directory_entry)\n\t\t  free(DS->directory_entry);\n\t  free(x3f);\n  }\n  return NULL;\n\n}\n\n/* --------------------------------------------------------------------- */\n/* Clean up an x3f structure                                             */\n/* --------------------------------------------------------------------- */\n\nstatic void free_camf_entry(camf_entry_t *entry)\n{\n\tFREE(entry->property_name);\n\tFREE(entry->property_value);\n\tFREE(entry->matrix_decoded);\n\tFREE(entry->matrix_dim_entry);\n}\n\n/* extern */ x3f_return_t x3f_delete(x3f_t *x3f)\n{\n\tx3f_directory_section_t *DS;\n\tint d;\n\n\tif (x3f == NULL)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tDS = &x3f->directory_section;\n\tif (DS->num_directory_entries > 50)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tfor (d=0; d<DS->num_directory_entries; d++) {\n\t\tx3f_directory_entry_t *DE = &DS->directory_entry[d];\n\t\tx3f_directory_entry_header_t *DEH = &DE->header;\n\t\tif (DEH->identifier == X3F_SECp) {\n\t\t\tx3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\t\t\tif (PL)\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t}\n\t\t\tFREE(PL->property_table.element);\n\t\t\tFREE(PL->data);\n\t\t}\n\n\t\tif (DEH->identifier == X3F_SECi) {\n\t\t\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\t\t\tif (ID)\n\t\t\t{\n\t\t\t\tcleanup_huffman(&ID->huffman);\n\t\t\t\tcleanup_true(&ID->tru);\n\t\t\t\tcleanup_quattro(&ID->quattro);\n\t\t\t\tFREE(ID->data);\n\t\t\t}\n\t\t}\n\n\t\tif (DEH->identifier == X3F_SECc) {\n\t\t\tx3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\t\t\tint i;\n\t\t\tif (CAMF)\n\t\t\t{\n\t\t\t\tFREE(CAMF->data);\n\t\t\t\tFREE(CAMF->table.element);\n\t\t\t\tcleanup_huffman_tree(&CAMF->tree);\n\t\t\t\tFREE(CAMF->decoded_data);\n\t\t\t\tfor (i = 0; i < CAMF->entry_table.size; i++) {\n\t\t\t\t\tfree_camf_entry(&CAMF->entry_table.element[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFREE(CAMF->entry_table.element);\n\t\t}\n\t}\n\n\tFREE(DS->directory_entry);\n\tFREE(x3f);\n\n\treturn X3F_OK;\n}\n\n/* --------------------------------------------------------------------- */\n/* Getting a reference to a directory entry                              */\n/* --------------------------------------------------------------------- */\n\n/* TODO: all those only get the first instance */\n\nstatic x3f_directory_entry_t *x3f_get(x3f_t *x3f,\n\tuint32_t type,\n\tuint32_t image_type)\n{\n\tx3f_directory_section_t *DS;\n\tint d;\n\n\tif (x3f == NULL) return NULL;\n\n\tDS = &x3f->directory_section;\n\n\tfor (d=0; d<DS->num_directory_entries; d++) {\n\t\tx3f_directory_entry_t *DE = &DS->directory_entry[d];\n\t\tx3f_directory_entry_header_t *DEH = &DE->header;\n\n\t\tif (DEH->identifier == type) {\n\t\t\tswitch (DEH->identifier) {\n\t\t\tcase X3F_SECi:\n\t\t\t\t{\n\t\t\t\t\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\t\t\t\t\tif (ID->type_format == image_type)\n\t\t\t\t\t\treturn DE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn DE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_raw(x3f_t *x3f)\n{\n\tx3f_directory_entry_t *DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_X530)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_10BIT)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_TRUE)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_MERRILL)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_QUATTRO)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQ)) != NULL)\n\t\treturn DE;\n\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH)) != NULL)\n\t\treturn DE;\n\tif ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH2)) != NULL)\n\t\treturn DE;\n\n\treturn NULL;\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_plain(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_PLAIN);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_huffman(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_HUFFMAN);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_thumb_jpeg(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_JPEG);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_camf(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECc, 0);\n}\n\n/* extern */ x3f_directory_entry_t *x3f_get_prop(x3f_t *x3f)\n{\n\treturn x3f_get(x3f, X3F_SECp, 0);\n}\n\n/* For some obscure reason, the bit numbering is weird. It is\n   generally some kind of \"big endian\" style - e.g. the bit 7 is the\n   first in a byte and bit 31 first in a 4 byte int. For patterns in\n   the huffman pattern table, bit 27 is the first bit and bit 26 the\n   next one. */\n\n#define PATTERN_BIT_POS(_len, _bit) ((_len) - (_bit) - 1)\n#define MEMORY_BIT_POS(_bit) PATTERN_BIT_POS(8, _bit)\n\n/* --------------------------------------------------------------------- */\n/* Huffman Decode                                                        */\n/* --------------------------------------------------------------------- */\n\n/* Make the huffman tree */\n\n#ifdef DBG_PRNT\nstatic char *display_code(int length, uint32_t code, char *buffer)\n{\n  int i;\n\n  for (i=0; i<length; i++) {\n    int pos = PATTERN_BIT_POS(length, i);\n    buffer[i] = ((code>>pos)&1) == 0 ? '0' : '1';\n  }\n\n  buffer[i] = 0;\n\n  return buffer;\n}\n#endif\n\nstatic x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n\n  tree->free_node_index++;\n\n  return t;\n}\n\nstatic void add_code_to_tree(x3f_hufftree_t *tree,\n                             int length, uint32_t code, uint32_t value)\n{\n  int i;\n\n  x3f_huffnode_t *t = tree->nodes;\n\n  for (i=0; i<length; i++) {\n    int pos = PATTERN_BIT_POS(length, i);\n    int bit = (code>>pos)&1;\n    x3f_huffnode_t *t_next = t->branch[bit];\n\n    if (t_next == NULL)\n      t_next = t->branch[bit] = new_node(tree);\n\n    t = t_next;\n  }\n\n  t->leaf = value;\n}\n\nstatic void populate_true_huffman_tree(x3f_hufftree_t *tree,\n\t\t\t\t       x3f_true_huffman_t *table)\n{\n  int i;\n\n  new_node(tree);\n\n  for (i=0; i<table->size; i++) {\n    x3f_true_huffman_element_t *element = &table->element[i];\n    uint32_t length = element->code_size;\n\n    if (length != 0) {\n      /* add_code_to_tree wants the code right adjusted */\n      uint32_t code = ((element->code) >> (8 - length)) & 0xff;\n      uint32_t value = i;\n\n      add_code_to_tree(tree, length, code, value);\n\n#ifdef DBG_PRNT\n      {\n        char buffer[100];\n\n        x3f_printf(DEBUG, \"H %5d : %5x : %5d : %02x %08x (%08x) (%s)\\n\",\n\t\t   i, i, value, length, code, value,\n\t\t   display_code(length, code, buffer));\n      }\n#endif\n    }\n  }\n}\n\nstatic void populate_huffman_tree(x3f_hufftree_t *tree,\n\t\t\t\t  x3f_table32_t *table,\n\t\t\t\t  x3f_table16_t *mapping)\n{\n  int i;\n\n  new_node(tree);\n\n  for (i=0; i<table->size; i++) {\n    uint32_t element = table->element[i];\n\n    if (element != 0) {\n      uint32_t length = HUF_TREE_GET_LENGTH(element);\n      uint32_t code = HUF_TREE_GET_CODE(element);\n      uint32_t value;\n\n      /* If we have a valid mapping table - then the value from the\n         mapping table shall be used. Otherwise we use the current\n         index in the table as value. */\n      if (table->size == mapping->size)\n        value = mapping->element[i];\n      else\n        value = i;\n\n      add_code_to_tree(tree, length, code, value);\n\n#ifdef DBG_PRNT\n      {\n        char buffer[100];\n\n        x3f_printf(DEBUG, \"H %5d : %5x : %5d : %02x %08x (%08x) (%s)\\n\",\n\t\t   i, i, value, length, code, element,\n\t\t   display_code(length, code, buffer));\n      }\n#endif\n    }\n  }\n}\n\n#ifdef DBG_PRNT\nstatic void print_huffman_tree(x3f_huffnode_t *t, int length, uint32_t code)\n{\n  char buf1[100];\n  char buf2[100];\n\n  x3f_printf(DEBUG, \"%*s (%s,%s) %s (%s)\\n\",\n\t     length, length < 1 ? \"-\" : (code&1) ? \"1\" : \"0\",\n\t     t->branch[0]==NULL ? \"-\" : \"0\",\n\t     t->branch[1]==NULL ? \"-\" : \"1\",\n\t     t->leaf==UNDEFINED_LEAF ? \"-\" : (sprintf(buf1, \"%x\", t->leaf),buf1),\n\t     display_code(length, code, buf2));\n\n  code = code << 1;\n  if (t->branch[0]) print_huffman_tree(t->branch[0], length+1, code+0);\n  if (t->branch[1]) print_huffman_tree(t->branch[1], length+1, code+1);\n}\n#endif\n\n/* Help machinery for reading bits in a memory */\n\ntypedef struct bit_state_s {\n  uint8_t *next_address;\n  uint8_t bit_offset;\n  uint8_t bits[8];\n} bit_state_t;\n\nstatic void set_bit_state(bit_state_t *BS, uint8_t *address)\n{\n  BS->next_address = address;\n  BS->bit_offset = 8;\n}\n\nstatic uint8_t get_bit(bit_state_t *BS)\n{\n  if (BS->bit_offset == 8) {\n    uint8_t byte = *BS->next_address;\n    int i;\n\n    for (i=7; i>= 0; i--) {\n      BS->bits[i] = byte&1;\n      byte = byte >> 1;\n    }\n    BS->next_address++;\n    BS->bit_offset = 0;\n  }\n\n  return BS->bits[BS->bit_offset++];\n}\n\n/* Decode use the TRUE algorithm */\n\nstatic int32_t get_true_diff(bit_state_t *BS, x3f_hufftree_t *HTP)\n{\n  int32_t diff;\n  x3f_huffnode_t *node = &HTP->nodes[0];\n  uint8_t bits;\n\n  while (node->branch[0] != NULL || node->branch[1] != NULL) {\n    uint8_t bit = get_bit(BS);\n    x3f_huffnode_t *new_node = node->branch[bit];\n\n    node = new_node;\n    if (node == NULL) {\n      /* TODO: Shouldn't this be treated as a fatal error? */\n      return 0;\n    }\n  }\n\n  bits = node->leaf;\n\n  if (bits == 0)\n    diff = 0;\n  else {\n    uint8_t first_bit = get_bit(BS);\n    int i;\n\n    diff = first_bit;\n\n    for (i=1; i<bits; i++)\n      diff = (diff << 1) + get_bit(BS);\n\n    if (first_bit == 0)\n      diff -= (1<<bits) - 1;\n  }\n\n  return diff;\n}\n\n/* This code (that decodes one of the X3F color planes, really is a\n   decoding of a compression algorithm suited for Bayer CFA data. In\n   Bayer CFA the data is divided into 2x2 squares that represents\n   (R,G1,G2,B) data. Those four positions are (in this compression)\n   treated as one data stream each, where you store the differences to\n   previous data in the stream. The reason for this is, of course,\n   that the date is more often than not near to the next data in a\n   stream that represents the same color. */\n\n/* TODO: write more about the compression */\n\nstatic void true_decode_one_color(x3f_image_data_t *ID, int color)\n{\n  x3f_true_t *TRU = ID->tru;\n  x3f_quattro_t *Q = ID->quattro;\n  uint32_t seed = TRU->seed[color]; /* TODO : Is this correct ? */\n  int row;\n\n  x3f_hufftree_t *tree = &TRU->tree;\n  bit_state_t BS;\n\n  int32_t row_start_acc[2][2];\n  uint32_t rows = ID->rows;\n  uint32_t cols = ID->columns;\n  x3f_area16_t *area = &TRU->x3rgb16;\n  uint16_t *dst = area->data + color;\n\n  set_bit_state(&BS, TRU->plane_address[color]);\n\n  row_start_acc[0][0] = seed;\n  row_start_acc[0][1] = seed;\n  row_start_acc[1][0] = seed;\n  row_start_acc[1][1] = seed;\n\n  if (ID->type_format == X3F_IMAGE_RAW_QUATTRO \n\t  || ID->type_format == X3F_IMAGE_RAW_SDQ\n\t  || ID->type_format == X3F_IMAGE_RAW_SDQH \n\t  || ID->type_format == X3F_IMAGE_RAW_SDQH2 \n\t  ) {\n    rows = Q->plane[color].rows;\n    cols = Q->plane[color].columns;\n\n    if (Q->quattro_layout && color == 2) {\n      area = &Q->top16;\n      dst = area->data;\n    }\n  } else {\n  }\n\n  if(rows != area->rows || cols < area->columns)\n\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  for (row = 0; row < rows; row++) {\n    int col;\n    bool_t odd_row = row&1;\n    int32_t acc[2];\n\n    for (col = 0; col < cols; col++) {\n      bool_t odd_col = col&1;\n      int32_t diff = get_true_diff(&BS, tree);\n      int32_t prev = col < 2 ?\n\trow_start_acc[odd_row][odd_col] :\n\tacc[odd_col];\n      int32_t value = prev + diff;\n\n      acc[odd_col] = value;\n      if (col < 2)\n\trow_start_acc[odd_row][odd_col] = value;\n\n      /* Discard additional data at the right for binned Quattro plane 2 */\n      if (col >= area->columns) continue;\n\n      *dst = value;\n      dst += area->channels;\n    }\n  }\n}\n\nstatic void true_decode(x3f_info_t *I,\n\t\t\tx3f_directory_entry_t *DE)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  int color;\n\n  for (color = 0; color < 3; color++) {\n    true_decode_one_color(ID, color);\n  }\n}\n\n/* Decode use the huffman tree */\n\nstatic int32_t get_huffman_diff(bit_state_t *BS, x3f_hufftree_t *HTP)\n{\n  int32_t diff;\n  x3f_huffnode_t *node = &HTP->nodes[0];\n\n  while (node->branch[0] != NULL || node->branch[1] != NULL) {\n    uint8_t bit = get_bit(BS);\n    x3f_huffnode_t *new_node = node->branch[bit];\n\n    node = new_node;\n    if (node == NULL) {\n      /* TODO: Shouldn't this be treated as a fatal error? */\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n      return 0;\n    }\n  }\n\n  diff = node->leaf;\n\n  return diff;\n}\n\nstatic void huffman_decode_row(x3f_info_t *I,\n                               x3f_directory_entry_t *DE,\n                               int bits,\n                               int row,\n                               int offset,\n                               int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  int16_t c[3] = {(int16_t)offset,(int16_t)offset,(int16_t)offset};\n  int col;\n  bit_state_t BS;\n\n  set_bit_state(&BS, (uint8_t*)ID->data + HUF->row_offsets.element[row]);\n\n  for (col = 0; col < ID->columns; col++) {\n    int color;\n\n    for (color = 0; color < 3; color++) {\n      uint16_t c_fix;\n\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0) {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      } else {\n        c_fix = c[color];\n      }\n\n      switch (ID->type_format) {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3*(row*ID->columns + col) + color] = (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3*(row*ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n\t/* TODO: Shouldn't this be treated as a fatal error? */\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}\n\nstatic void huffman_decode(x3f_info_t *I,\n                           x3f_directory_entry_t *DE,\n                           int bits)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  int row;\n  int minimum = 0;\n  int offset = legacy_offset;\n\n  for (row = 0; row < ID->rows; row++)\n    huffman_decode_row(I, DE, bits, row, offset, &minimum);\n\n  if (auto_legacy_offset && minimum < 0) {\n    offset = -minimum;\n    for (row = 0; row < ID->rows; row++)\n      huffman_decode_row(I, DE, bits, row, offset, &minimum);\n  }\n}\n\nstatic int32_t get_simple_diff(x3f_huffman_t *HUF, uint16_t index)\n{\n  if (HUF->mapping.size == 0)\n    return index;\n  else\n    return HUF->mapping.element[index];\n}\n\nstatic void simple_decode_row(x3f_info_t *I,\n                              x3f_directory_entry_t *DE,\n                              int bits,\n                              int row,\n                              int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  uint32_t *data = (uint32_t *)((unsigned char*)ID->data + row*row_stride);\n\n  uint16_t c[3] = {0,0,0};\n  int col;\n\n  uint32_t mask = 0;\n\n  switch (bits) {\n  case 8:\n    mask = 0x0ff;\n    break;\n  case 9:\n    mask = 0x1ff;\n    break;\n  case 10:\n    mask = 0x3ff;\n    break;\n  case 11:\n    mask = 0x7ff;\n    break;\n  case 12:\n    mask = 0xfff;\n    break;\n  default:\n    mask = 0;\n    /* TODO: Shouldn't this be treated as a fatal error? */\n\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n    break;\n  }\n\n  for (col = 0; col < ID->columns; col++) {\n    int color;\n    uint32_t val = data[col];\n\n    for (color = 0; color < 3; color++) {\n      uint16_t c_fix;\n      c[color] += get_simple_diff(HUF, (val>>(color*bits))&mask);\n\n      switch (ID->type_format) {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        c_fix = (int16_t)c[color] > 0 ? c[color] : 0;\n\n        HUF->x3rgb16.data[3*(row*ID->columns + col) + color] = c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        c_fix = (int8_t)c[color] > 0 ? c[color] : 0;\n\n        HUF->rgb8.data[3*(row*ID->columns + col) + color] = c_fix;\n        break;\n      default:\n\t/* TODO: Shouldn't this be treated as a fatal error? */\n\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}\n\nstatic void simple_decode(x3f_info_t *I,\n                          x3f_directory_entry_t *DE,\n                          int bits,\n                          int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n  int row;\n\n  for (row = 0; row < ID->rows; row++)\n    simple_decode_row(I, DE, bits, row, row_stride);\n}\n\n/* --------------------------------------------------------------------- */\n/* Loading the data in a directory entry                                 */\n/* --------------------------------------------------------------------- */\n\n/* First you set the offset to where to start reading the data ... */\n\nstatic void read_data_set_offset(x3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tuint32_t header_size)\n{\n\tuint32_t i_off = DE->input.offset + header_size;\n\n\t I->input.file->seek(i_off, SEEK_SET);\n}\n\n/* ... then you read the data, block for block */\n\nstatic uint32_t read_data_block(void **data,\n\tx3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tuint32_t footer)\n{\n\tINT64 fpos = I->input.file->tell();\n\tuint32_t size =\n\t\tDE->input.size + DE->input.offset - fpos - footer;\n\t\n\tif (fpos + size > I->input.file->size())\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n\t*data = (void *)malloc(size);\n\n\tGETN(*data, size);\n\n\treturn size;\n}\n\nstatic uint32_t data_block_size(void **data,\n\tx3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tuint32_t footer)\n{\n\tuint32_t size =\n\t\tDE->input.size + DE->input.offset - I->input.file->tell() - footer;\n\treturn size;\n}\n\n\nstatic void x3f_load_image_verbatim(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\tif (!ID->data_size)\n\t\tID->data_size = read_data_block(&ID->data, I, DE, 0);\n}\n\nstatic int32_t x3f_load_image_verbatim_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\treturn data_block_size(&ID->data, I, DE, 0);\n}\n\n\nstatic void x3f_load_property_list(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\tint i;\n\n\tread_data_set_offset(I, DE, X3F_PROPERTY_LIST_HEADER_SIZE);\n\n\tGET_PROPERTY_TABLE(PL->property_table, PL->num_properties);\n\n\tif (!PL->data_size)\n\t\tPL->data_size = read_data_block(&PL->data, I, DE, 0);\n\tuint32_t maxoffset = PL->data_size/sizeof(utf16_t)-2; // at least 2 chars, value + terminating 0x0000\n\n\tfor (i=0; i<PL->num_properties; i++) {\n\t\tx3f_property_t *P = &PL->property_table.element[i];\n\t\tif(P->name_offset > maxoffset || P->value_offset > maxoffset)\n\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\tP->name = ((utf16_t *)PL->data + P->name_offset);\n\t\tP->value = ((utf16_t *)PL->data + P->value_offset);\n\t}\n}\n\n\nstatic void x3f_load_true(x3f_info_t *I,\n\tx3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\tx3f_true_t *TRU = new_true(&ID->tru);\n\tx3f_quattro_t *Q = NULL;\n\tint i;\n\n\tif (ID->type_format == X3F_IMAGE_RAW_QUATTRO \n\t\t||\tID->type_format == X3F_IMAGE_RAW_SDQ\n\t\t||\tID->type_format == X3F_IMAGE_RAW_SDQH\n\t\t||\tID->type_format == X3F_IMAGE_RAW_SDQH2\n\t\t) {\n\t\t\tQ = new_quattro(&ID->quattro);\n\n\t\t\tfor (i=0; i<TRUE_PLANES; i++) {\n\t\t\t\tGET2(Q->plane[i].columns);\n\t\t\t\tGET2(Q->plane[i].rows);\n\t\t\t}\n\n\t\t\tif (Q->plane[0].rows == ID->rows/2) {\n\t\t\t\tQ->quattro_layout = 1;\n\t\t\t} else if (Q->plane[0].rows == ID->rows) {\n\t\t\t\tQ->quattro_layout = 0;\n\t\t\t} else {\n\t\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\t\t}\n\t}\n\n\t/* Read TRUE header data */\n\tGET2(TRU->seed[0]);\n\tGET2(TRU->seed[1]);\n\tGET2(TRU->seed[2]);\n\tGET2(TRU->unknown);\n\tGET_TRUE_HUFF_TABLE(TRU->table);\n\n\tif (ID->type_format == X3F_IMAGE_RAW_QUATTRO \n\t\t||ID->type_format == X3F_IMAGE_RAW_SDQ\n\t\t||ID->type_format == X3F_IMAGE_RAW_SDQH\n\t\t||ID->type_format == X3F_IMAGE_RAW_SDQH2\n\t\t) {\n\t\t\tGET4(Q->unknown);\n\t}\n\n\tGET_TABLE(TRU->plane_size, GET4, TRUE_PLANES,uint32_t);\n\n\t/* Read image data */\n\tif (!ID->data_size)\n\t\tID->data_size = read_data_block(&ID->data, I, DE, 0);\n\n\t/* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n\tnew_huffman_tree(&TRU->tree, 8);\n\n\tpopulate_true_huffman_tree(&TRU->tree, &TRU->table);\n\n#ifdef DBG_PRNT\n\tprint_huffman_tree(TRU->tree.nodes, 0, 0);\n#endif\n\n\tTRU->plane_address[0] = (uint8_t*)ID->data;\n\tfor (i=1; i<TRUE_PLANES; i++)\n\t\tTRU->plane_address[i] =\n\t\tTRU->plane_address[i-1] +\n\t\t(((TRU->plane_size.element[i-1] + 15) / 16) * 16);\n\n\tif ( (ID->type_format == X3F_IMAGE_RAW_QUATTRO \n\t\t|| ID->type_format == X3F_IMAGE_RAW_SDQ \n\t\t|| ID->type_format == X3F_IMAGE_RAW_SDQH \n\t\t|| ID->type_format == X3F_IMAGE_RAW_SDQH2 \n\t\t) &&\n\t\tQ->quattro_layout) {\n\t\t\tuint32_t columns = Q->plane[0].columns;\n\t\t\tuint32_t rows = Q->plane[0].rows;\n\t\t\tuint32_t channels = 3;\n\t\t\tuint32_t size = columns * rows * channels;\n\n\t\t\tTRU->x3rgb16.columns = columns;\n\t\t\tTRU->x3rgb16.rows = rows;\n\t\t\tTRU->x3rgb16.channels = channels;\n\t\t\tTRU->x3rgb16.row_stride = columns * channels;\n\t\t\tTRU->x3rgb16.buf = malloc(sizeof(uint16_t)*size);\n\t\t\tTRU->x3rgb16.data = (uint16_t *) TRU->x3rgb16.buf;\n\n\t\t\tcolumns = Q->plane[2].columns;\n\t\t\trows = Q->plane[2].rows;\n\t\t\tchannels = 1;\n\t\t\tsize = columns * rows * channels;\n\n\t\t\tQ->top16.columns = columns;\n\t\t\tQ->top16.rows = rows;\n\t\t\tQ->top16.channels = channels;\n\t\t\tQ->top16.row_stride = columns * channels;\n\t\t\tQ->top16.buf = malloc(sizeof(uint16_t)*size);\n\t\t\tQ->top16.data = (uint16_t *)Q->top16.buf;\n\t\t\t\t\n\t} else {\n\t\tuint32_t size = ID->columns * ID->rows * 3;\n\n\t\tTRU->x3rgb16.columns = ID->columns;\n\t\tTRU->x3rgb16.rows = ID->rows;\n\t\tTRU->x3rgb16.channels = 3;\n\t\tTRU->x3rgb16.row_stride = ID->columns * 3;\n\t\tTRU->x3rgb16.buf =malloc(sizeof(uint16_t)*size);\n\t\tTRU->x3rgb16.data = (uint16_t *)TRU->x3rgb16.buf;\t\t\n\t}\n\n\ttrue_decode(I, DE);\n}\n\nstatic void x3f_load_huffman_compressed(x3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tint bits,\n\tint use_map_table)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\tx3f_huffman_t *HUF = ID->huffman;\n\tint table_size = 1<<bits;\n\tint row_offsets_size = ID->rows * sizeof(HUF->row_offsets.element[0]);\n\n\tGET_TABLE(HUF->table, GET4, table_size,uint32_t);\n\n\tif (!ID->data_size)\n\t\tID->data_size = read_data_block(&ID->data, I, DE, row_offsets_size);\n\n\tGET_TABLE(HUF->row_offsets, GET4, ID->rows,uint32_t);\n\n\tnew_huffman_tree(&HUF->tree, bits);\n\tpopulate_huffman_tree(&HUF->tree, &HUF->table, &HUF->mapping);\n\n\thuffman_decode(I, DE, bits);\n}\n\nstatic void x3f_load_huffman_not_compressed(x3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tint bits,\n\tint use_map_table,\n\tint row_stride)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\tif (!ID->data_size)\n\t\tID->data_size = read_data_block(&ID->data, I, DE, 0);\n\n\tsimple_decode(I, DE, bits, row_stride);\n}\n\nstatic void x3f_load_huffman(x3f_info_t *I,\n\tx3f_directory_entry_t *DE,\n\tint bits,\n\tint use_map_table,\n\tint row_stride)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\tx3f_huffman_t *HUF = new_huffman(&ID->huffman);\n\tuint32_t size;\n\n\tif (use_map_table) {\n\t\tint table_size = 1<<bits;\n\n\t\tGET_TABLE(HUF->mapping, GET2, table_size,uint16_t);\n\t}\n\n\tswitch (ID->type_format) {\n\tcase X3F_IMAGE_RAW_HUFFMAN_X530:\n\tcase X3F_IMAGE_RAW_HUFFMAN_10BIT:\n\t\tsize = ID->columns * ID->rows * 3;\n\t\tHUF->x3rgb16.columns = ID->columns;\n\t\tHUF->x3rgb16.rows = ID->rows;\n\t\tHUF->x3rgb16.channels = 3;\n\t\tHUF->x3rgb16.row_stride = ID->columns * 3;\n\t\tHUF->x3rgb16.buf = malloc(sizeof(uint16_t)*size);\n\t\tHUF->x3rgb16.data = (uint16_t *)HUF->x3rgb16.buf;\n\t\tbreak;\n\tcase X3F_IMAGE_THUMB_HUFFMAN:\n\t\tsize = ID->columns * ID->rows * 3;\n\t\tHUF->rgb8.columns = ID->columns;\n\t\tHUF->rgb8.rows = ID->rows;\n\t\tHUF->rgb8.channels = 3;\n\t\tHUF->rgb8.row_stride = ID->columns * 3;\n\t\tHUF->rgb8.buf = malloc(sizeof(uint8_t)*size);\n\t\tHUF->rgb8.data = (uint8_t *)HUF->rgb8.buf;\n\t\tbreak;\n\tdefault:\n\t\t/* TODO: Shouldn't this be treated as a fatal error? */\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t}\n\n\tif (row_stride == 0)\n\t\treturn x3f_load_huffman_compressed(I, DE, bits, use_map_table);\n\telse\n\t\treturn x3f_load_huffman_not_compressed(I, DE, bits, use_map_table, row_stride);\n}\n\nstatic void x3f_load_pixmap(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_load_image_verbatim(I, DE);\n}\n\nstatic uint32_t x3f_load_pixmap_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\treturn x3f_load_image_verbatim_size(I, DE);\n}\n\n\nstatic void x3f_load_jpeg(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_load_image_verbatim(I, DE);\n}\n\nstatic uint32_t x3f_load_jpeg_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\treturn x3f_load_image_verbatim_size(I, DE);\n}\n\nstatic void x3f_load_image(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\tread_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\n\tswitch (ID->type_format) {\n\tcase X3F_IMAGE_RAW_TRUE:\n\tcase X3F_IMAGE_RAW_MERRILL:\n\tcase X3F_IMAGE_RAW_QUATTRO:\n\tcase X3F_IMAGE_RAW_SDQ:\n\tcase X3F_IMAGE_RAW_SDQH:\n\tcase X3F_IMAGE_RAW_SDQH2:\n\t\tx3f_load_true(I, DE);\n\t\tbreak;\n\tcase X3F_IMAGE_RAW_HUFFMAN_X530:\n\tcase X3F_IMAGE_RAW_HUFFMAN_10BIT:\n\t\tx3f_load_huffman(I, DE, 10, 1, ID->row_stride);\n\t\tbreak;\n\tcase X3F_IMAGE_THUMB_PLAIN:\n\t\tx3f_load_pixmap(I, DE);\n\t\tbreak;\n\tcase X3F_IMAGE_THUMB_HUFFMAN:\n\t\tx3f_load_huffman(I, DE, 8, 0, ID->row_stride);\n\t\tbreak;\n\tcase X3F_IMAGE_THUMB_JPEG:\n\t\tx3f_load_jpeg(I, DE);\n\t\tbreak;\n\tdefault:\n\t\t/* TODO: Shouldn't this be treated as a fatal error? */\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t}\n}\n\n// Used only for thumbnail size estimation\nstatic uint32_t x3f_load_image_size(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\tread_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\n\tswitch (ID->type_format) {\n\tcase X3F_IMAGE_THUMB_PLAIN:\n\t\treturn x3f_load_pixmap_size(I, DE);\n\tcase X3F_IMAGE_THUMB_JPEG:\n\t\treturn x3f_load_jpeg_size(I, DE);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\nstatic void x3f_load_camf_decode_type2(x3f_camf_t *CAMF)\n{\n\tuint32_t key = CAMF->t2.crypt_key;\n\tint i;\n\n\tCAMF->decoded_data_size = CAMF->data_size;\n\tCAMF->decoded_data = malloc(CAMF->decoded_data_size);\n\n\tfor (i=0; i<CAMF->data_size; i++) {\n\t\tuint8_t old, _new;\n\t\tuint32_t tmp;\n\n\t\told = ((uint8_t *)CAMF->data)[i];\n\t\tkey = (key * 1597 + 51749) % 244944;\n\t\ttmp = (uint32_t)(key * ((int64_t)301593171) >> 24);\n\t\t_new = (uint8_t)(old ^ (uint8_t)(((((key << 8) - tmp) >> 1) + tmp) >> 17));\n\t\t((uint8_t *)CAMF->decoded_data)[i] = _new;\n\t}\n}\n\n/* NOTE: the unpacking in this code is in big respects identical to\n   true_decode_one_color(). The difference is in the output you\n   build. It might be possible to make some parts shared. NOTE ALSO:\n   This means that the meta data is obfuscated using an image\n   compression algorithm. */\n\nstatic void camf_decode_type4(x3f_camf_t *CAMF)\n{\n  uint32_t seed = CAMF->t4.decode_bias;\n  int row;\n\n  uint8_t *dst;\n  uint32_t dst_size = CAMF->t4.decoded_data_size;\n  uint8_t *dst_end;\n\n  bool_t odd_dst = 0;\n\n  x3f_hufftree_t *tree = &CAMF->tree;\n  bit_state_t BS;\n\n  int32_t row_start_acc[2][2];\n  uint32_t rows = CAMF->t4.block_count;\n  uint32_t cols = CAMF->t4.block_size;\n\n  CAMF->decoded_data_size = dst_size;\n\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n  memset(CAMF->decoded_data, 0, CAMF->decoded_data_size);\n\n  dst = (uint8_t *)CAMF->decoded_data;\n  dst_end = dst + dst_size;\n\n  set_bit_state(&BS, CAMF->decoding_start);\n\n  row_start_acc[0][0] = seed;\n  row_start_acc[0][1] = seed;\n  row_start_acc[1][0] = seed;\n  row_start_acc[1][1] = seed;\n\n  for (row = 0; row < rows; row++) {\n    int col;\n    bool_t odd_row = row&1;\n    int32_t acc[2];\n\n    /* We loop through all the columns and the rows. But the actual\n       data is smaller than that, so we break the loop when reaching\n       the end. */\n    for (col = 0; col < cols; col++) {\n      bool_t odd_col = col&1;\n      int32_t diff = get_true_diff(&BS, tree);\n      int32_t prev = col < 2 ?\n\trow_start_acc[odd_row][odd_col] :\n\tacc[odd_col];\n      int32_t value = prev + diff;\n\n      acc[odd_col] = value;\n      if (col < 2)\n\trow_start_acc[odd_row][odd_col] = value;\n\n      switch(odd_dst) {\n      case 0:\n\t*dst++  = (uint8_t)((value>>4)&0xff);\n\n\tif (dst >= dst_end) {\n\t  goto ready;\n\t}\n\n\t*dst    = (uint8_t)((value<<4)&0xf0);\n\tbreak;\n      case 1:\n\t*dst++ |= (uint8_t)((value>>8)&0x0f);\n\n\tif (dst >= dst_end) {\n\t  goto ready;\n\t}\n\n\t*dst++  = (uint8_t)((value<<0)&0xff);\n\n\tif (dst >= dst_end) {\n\t  goto ready;\n\t}\n\n\tbreak;\n      }\n\n      odd_dst = !odd_dst;\n    } /* end col */\n  } /* end row */\n\n ready:;\n}\n\nstatic void x3f_load_camf_decode_type4(x3f_camf_t *CAMF)\n{\n  int i;\n  uint8_t *p;\n  x3f_true_huffman_element_t *element = NULL;\n\n  for (i=0, p = (uint8_t*)CAMF->data; *p != 0; i++) {\n    /* TODO: Is this too expensive ??*/\n    element =\n      (x3f_true_huffman_element_t *)realloc(element, (i+1)*sizeof(*element));\n\n    element[i].code_size = *p++;\n    element[i].code = *p++;\n  }\n\n  CAMF->table.size = i;\n  CAMF->table.element = element;\n\n  /* TODO: where does the values 28 and 32 come from? */\n#define CAMF_T4_DATA_SIZE_OFFSET 28\n#define CAMF_T4_DATA_OFFSET 32\n  CAMF->decoding_size = *(uint32_t *)((unsigned char*)CAMF->data + CAMF_T4_DATA_SIZE_OFFSET);\n  CAMF->decoding_start = (uint8_t *)CAMF->data + CAMF_T4_DATA_OFFSET;\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&CAMF->tree, 8);\n\n  populate_true_huffman_tree(&CAMF->tree, &CAMF->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(CAMF->tree.nodes, 0, 0);\n#endif\n\n  camf_decode_type4(CAMF);\n}\n\nstatic void camf_decode_type5(x3f_camf_t *CAMF)\n{\n  int32_t acc = CAMF->t5.decode_bias;\n\n  uint8_t *dst;\n\n  x3f_hufftree_t *tree = &CAMF->tree;\n  bit_state_t BS;\n\n  int32_t i;\n\n  CAMF->decoded_data_size = CAMF->t5.decoded_data_size;\n  CAMF->decoded_data = malloc(CAMF->decoded_data_size);\n\n  dst = (uint8_t *)CAMF->decoded_data;\n\n  set_bit_state(&BS, CAMF->decoding_start);\n\n  for (i = 0; i < CAMF->decoded_data_size; i++) {\n    int32_t diff = get_true_diff(&BS, tree);\n\n    acc = acc + diff;\n    *dst++ = (uint8_t)(acc & 0xff);\n  }\n}\n\nstatic void x3f_load_camf_decode_type5(x3f_camf_t *CAMF)\n{\n  int i;\n  uint8_t *p;\n  x3f_true_huffman_element_t *element = NULL;\n\n  for (i=0, p = (uint8_t*)CAMF->data; *p != 0; i++) {\n    /* TODO: Is this too expensive ??*/\n    element =\n      (x3f_true_huffman_element_t *)realloc(element, (i+1)*sizeof(*element));\n\n    element[i].code_size = *p++;\n    element[i].code = *p++;\n  }\n\n  CAMF->table.size = i;\n  CAMF->table.element = element;\n\n  /* TODO: where does the values 28 and 32 come from? */\n#define CAMF_T5_DATA_SIZE_OFFSET 28\n#define CAMF_T5_DATA_OFFSET 32\n  CAMF->decoding_size = *(uint32_t *)((uint8_t*)CAMF->data + CAMF_T5_DATA_SIZE_OFFSET);\n  CAMF->decoding_start = (uint8_t *)CAMF->data + CAMF_T5_DATA_OFFSET;\n\n  /* TODO: can it be fewer than 8 bits? Maybe taken from TRU->table? */\n  new_huffman_tree(&CAMF->tree, 8);\n\n  populate_true_huffman_tree(&CAMF->tree, &CAMF->table);\n\n#ifdef DBG_PRNT\n  print_huffman_tree(CAMF->tree.nodes, 0, 0);\n#endif\n\n  camf_decode_type5(CAMF);\n}\n\nstatic void x3f_setup_camf_text_entry(camf_entry_t *entry)\n{\n  entry->text_size = *(uint32_t *)entry->value_address;\n  entry->text = (char*)entry->value_address + 4;\n}\n\nstatic void x3f_setup_camf_property_entry(camf_entry_t *entry)\n{\n  int i;\n  uint8_t *e =\n    (uint8_t*)entry->entry;\n  uint8_t *v =\n    (uint8_t*)entry->value_address;\n  uint32_t num =\n    entry->property_num = *(uint32_t *)v;\n  uint32_t off = *(uint32_t *)(v + 4);\n\n  entry->property_name = (char **)malloc(num*sizeof(uint8_t*));\n  entry->property_value = (uint8_t **)malloc(num*sizeof(uint8_t*));\n\n  for (i=0; i<num; i++) {\n    uint32_t name_off = off + *(uint32_t *)(v + 8 + 8*i);\n    uint32_t value_off = off + *(uint32_t *)(v + 8 + 8*i + 4);\n\n    entry->property_name[i] = (char *)(e + name_off);\n    entry->property_value[i] = e + value_off;\n  }\n}\n\nstatic void set_matrix_element_info(uint32_t type,\n\t\t\t\t    uint32_t *size,\n\t\t\t\t    matrix_type_t *decoded_type)\n{\n  switch (type) {\n  case 0:\n    *size = 2;\n    *decoded_type = M_INT; /* known to be true */\n    break;\n  case 1:\n    *size = 4;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 2:\n    *size = 4;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 3:\n    *size = 4;\n    *decoded_type = M_FLOAT; /* known to be true */\n    break;\n  case 5:\n    *size = 1;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  case 6:\n    *size = 2;\n    *decoded_type = M_UINT; /* TODO: unknown ???? */\n    break;\n  default:\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\nstatic void get_matrix_copy(camf_entry_t *entry)\n{\n  uint32_t element_size = entry->matrix_element_size;\n  uint32_t elements = entry->matrix_elements;\n  int i, size = (entry->matrix_decoded_type==M_FLOAT ?\n\t\t sizeof(double) :\n\t\t sizeof(uint32_t)) * elements;\n\n  entry->matrix_decoded = malloc(size);\n\n  switch (element_size) {\n  case 4:\n    switch (entry->matrix_decoded_type) {\n    case M_INT:\n    case M_UINT:\n      memcpy(entry->matrix_decoded, entry->matrix_data, size);\n      break;\n    case M_FLOAT:\n      for (i=0; i<elements; i++)\n\t((double *)entry->matrix_decoded)[i] =\n\t  (double)((float *)entry->matrix_data)[i];\n      break;\n    default:\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  case 2:\n    switch (entry->matrix_decoded_type) {\n    case M_INT:\n      for (i=0; i<elements; i++)\n\t((int32_t *)entry->matrix_decoded)[i] =\n\t  (int32_t)((int16_t *)entry->matrix_data)[i];\n      break;\n    case M_UINT:\n      for (i=0; i<elements; i++)\n\t((uint32_t *)entry->matrix_decoded)[i] =\n\t  (uint32_t)((uint16_t *)entry->matrix_data)[i];\n      break;\n    default:\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  case 1:\n    switch (entry->matrix_decoded_type) {\n    case M_INT:\n      for (i=0; i<elements; i++)\n\t((int32_t *)entry->matrix_decoded)[i] =\n\t  (int32_t)((int8_t *)entry->matrix_data)[i];\n      break;\n    case M_UINT:\n      for (i=0; i<elements; i++)\n\t((uint32_t *)entry->matrix_decoded)[i] =\n\t  (uint32_t)((uint8_t *)entry->matrix_data)[i];\n      break;\n    default:\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n    break;\n  default:\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  }\n}\n\n\nstatic void x3f_setup_camf_matrix_entry(camf_entry_t *entry)\n{\n\tint i;\n\tint totalsize = 1;\n\n\tuint8_t *e =\n\t\t(uint8_t *)entry->entry;\n\tuint8_t *v =\n\t\t(uint8_t *)entry->value_address;\n\tuint32_t type =\n\t\tentry->matrix_type = *(uint32_t *)(v + 0);\n\tuint32_t dim =\n\t\tentry->matrix_dim = *(uint32_t *)(v + 4);\n\tuint32_t off =\n\t\tentry->matrix_data_off = *(uint32_t *)(v + 8);\n\tcamf_dim_entry_t *dentry =\n\t\tentry->matrix_dim_entry =\n\t\t(camf_dim_entry_t*)malloc(dim*sizeof(camf_dim_entry_t));\n\n\tfor (i=0; i<dim; i++) {\n\t\tuint32_t size =\n\t\t\tdentry[i].size = *(uint32_t *)(v + 12 + 12*i + 0);\n\t\tdentry[i].name_offset = *(uint32_t *)(v + 12 + 12*i + 4);\n\t\tdentry[i].n = *(uint32_t *)(v + 12 + 12*i + 8);\n\t\tdentry[i].name = (char *)(e + dentry[i].name_offset);\n\n\t\tif (dentry[i].n != i) {\n\t\t}\n\n\t\ttotalsize *= size;\n\t}\n\n\tset_matrix_element_info(type,\n\t\t&entry->matrix_element_size,\n\t\t&entry->matrix_decoded_type);\n\tentry->matrix_data = (void *)(e + off);\n\n\tentry->matrix_elements = totalsize;\n\tentry->matrix_used_space = entry->entry_size - off;\n\n\t/* This estimate only works for matrices above a certain size */\n\tentry->matrix_estimated_element_size = entry->matrix_used_space / totalsize;\n\n\tget_matrix_copy(entry);\n}\n\nstatic void x3f_setup_camf_entries(x3f_camf_t *CAMF)\n{\n\tuint8_t *p = (uint8_t *)CAMF->decoded_data;\n\tuint8_t *end = p + CAMF->decoded_data_size;\n\tcamf_entry_t *entry = NULL;\n\tint i;\n\n\tfor (i=0; p < end; i++) {\n\t\tuint32_t *p4 = (uint32_t *)p;\n\n\t\tswitch (*p4) {\n\t\tcase X3F_CMbP:\n\t\tcase X3F_CMbT:\n\t\tcase X3F_CMbM:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto stop;\n\t\t}\n\n\t\t/* TODO: lots of realloc - may be inefficient */\n\t\tentry = (camf_entry_t *)realloc(entry, (i+1)*sizeof(camf_entry_t));\n\n\t\t/* Pointer */\n\t\tentry[i].entry = p;\n\n\t\t/* Header */\n\t\tentry[i].id = *p4++;\n\t\tentry[i].version = *p4++;\n\t\tentry[i].entry_size = *p4++;\n\t\tentry[i].name_offset = *p4++;\n\t\tentry[i].value_offset = *p4++;\n\n\t\t/* Compute adresses and sizes */\n\t\tentry[i].name_address = (char *)(p + entry[i].name_offset);\n\t\tentry[i].value_address = p + entry[i].value_offset;\n\t\tentry[i].name_size = entry[i].value_offset - entry[i].name_offset;\n\t\tentry[i].value_size = entry[i].entry_size - entry[i].value_offset;\n\n\t\tentry[i].text_size = 0;\n\t\tentry[i].text = NULL;\n\t\tentry[i].property_num = 0;\n\t\tentry[i].property_name = NULL;\n\t\tentry[i].property_value = NULL;\n\t\tentry[i].matrix_type = 0;\n\t\tentry[i].matrix_dim = 0;\n\t\tentry[i].matrix_data_off = 0;\n\t\tentry[i].matrix_data = NULL;\n\t\tentry[i].matrix_dim_entry = NULL;\n\n\t\tentry[i].matrix_decoded = NULL;\n\n\t\tswitch (entry[i].id) {\n\t\tcase X3F_CMbP:\n\t\t\tx3f_setup_camf_property_entry(&entry[i]);\n\t\t\tbreak;\n\t\tcase X3F_CMbT:\n\t\t\tx3f_setup_camf_text_entry(&entry[i]);\n\t\t\tbreak;\n\t\tcase X3F_CMbM:\n\t\t\tx3f_setup_camf_matrix_entry(&entry[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tp += entry[i].entry_size;\n\t}\n\nstop:\n\n\tCAMF->entry_table.size = i;\n\tCAMF->entry_table.element = entry;\n}\n\nstatic void x3f_load_camf(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\n\tread_data_set_offset(I, DE, X3F_CAMF_HEADER_SIZE);\n\n\tif (!CAMF->data_size)\n\t\tCAMF->data_size = read_data_block(&CAMF->data, I, DE, 0);\n\n\tswitch (CAMF->type) {\n\tcase 2:\t\t\t/* Older SD9-SD14 */\n\t\tx3f_load_camf_decode_type2(CAMF);\n\t\tbreak;\n\tcase 4:\t\t\t/* TRUE ... Merrill */\n\t\tx3f_load_camf_decode_type4(CAMF);\n\t\tbreak;\n\tcase 5:\t\t\t/* Quattro ... */\n\t\tx3f_load_camf_decode_type5(CAMF);\n\t\tbreak;\n\tdefault:\n\t\t/* TODO: Shouldn't this be treated as a fatal error? */\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t}\n\n\tif (CAMF->decoded_data != NULL)\n\t\tx3f_setup_camf_entries(CAMF);\n\telse\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n}\n\n/* extern */ x3f_return_t x3f_load_data(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n\tx3f_info_t *I = &x3f->info;\n\n\tif (DE == NULL)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tswitch (DE->header.identifier) {\n\tcase X3F_SECp:\n\t\tx3f_load_property_list(I, DE);\n\t\tbreak;\n\tcase X3F_SECi:\n\t\tx3f_load_image(I, DE);\n\t\tbreak;\n\tcase X3F_SECc:\n\t\tx3f_load_camf(I, DE);\n\t\tbreak;\n\tdefault:\n\t\treturn X3F_INTERNAL_ERROR;\n\t}\n\treturn X3F_OK;\n}\n\n/* extern */ int64_t x3f_load_data_size(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n\tx3f_info_t *I = &x3f->info;\n\n\tif (DE == NULL)\n\t\treturn -1;\n\n\tswitch (DE->header.identifier) \n\t{\n\tcase X3F_SECi:\n\t\treturn x3f_load_image_size(I, DE);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n/* extern */ x3f_return_t x3f_load_image_block(x3f_t *x3f, x3f_directory_entry_t *DE)\n{\n\tx3f_info_t *I = &x3f->info;\n\n\tif (DE == NULL)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tswitch (DE->header.identifier) {\n\tcase X3F_SECi:\n\t\tread_data_set_offset(I, DE, X3F_IMAGE_HEADER_SIZE);\n\t\tx3f_load_image_verbatim(I, DE);\n\t\tbreak;\n\tdefault:\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\treturn X3F_INTERNAL_ERROR;\n\t}\n\n\treturn X3F_OK;\n}\n\n\n/* --------------------------------------------------------------------- */\n/* The End                                                               */\n/* --------------------------------------------------------------------- */\n", "/* -*- C++ -*-\n * File: libraw_cxx.cpp\n * Copyright 2008-2018 LibRaw LLC (info@libraw.org)\n * Created: Sat Mar  8 , 2008\n *\n * LibRaw C++ interface (implementation)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include <math.h>\n#include <errno.h>\n#include <float.h>\n#include <new>\n#include <exception>\n#include <sys/types.h>\n#include <sys/stat.h>\n#if !defined(_WIN32) && !defined(__MINGW32__)\n#include <netinet/in.h>\n#else\n#include <winsock2.h>\n#endif\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#ifdef USE_ZLIB\n#include <zlib.h>\n#endif\n\n#ifdef USE_RAWSPEED\n#include \"../RawSpeed/rawspeed_xmldata.cpp\"\n#include <RawSpeed/StdAfx.h>\n#include <RawSpeed/FileMap.h>\n#include <RawSpeed/RawParser.h>\n#include <RawSpeed/RawDecoder.h>\n#include <RawSpeed/CameraMetaData.h>\n#include <RawSpeed/ColorFilterArray.h>\n#endif\n\n#ifdef USE_DNGSDK\n#include \"dng_host.h\"\n#include \"dng_negative.h\"\n#include \"dng_simple_image.h\"\n#include \"dng_info.h\"\n#endif\n\n#include \"libraw_fuji_compressed.cpp\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n  void default_memory_callback(void *, const char *file, const char *where)\n  {\n    fprintf(stderr, \"%s: Out of memory in %s\\n\", file ? file : \"unknown file\", where);\n  }\n\n  void default_data_callback(void *, const char *file, const int offset)\n  {\n    if (offset < 0)\n      fprintf(stderr, \"%s: Unexpected end of file\\n\", file ? file : \"unknown file\");\n    else\n      fprintf(stderr, \"%s: data corrupted at %d\\n\", file ? file : \"unknown file\", offset);\n  }\n  const char *libraw_strerror(int e)\n  {\n    enum LibRaw_errors errorcode = (LibRaw_errors)e;\n    switch (errorcode)\n    {\n    case LIBRAW_SUCCESS:\n      return \"No error\";\n    case LIBRAW_UNSPECIFIED_ERROR:\n      return \"Unspecified error\";\n    case LIBRAW_FILE_UNSUPPORTED:\n      return \"Unsupported file format or not RAW file\";\n    case LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:\n      return \"Request for nonexisting image number\";\n    case LIBRAW_OUT_OF_ORDER_CALL:\n      return \"Out of order call of libraw function\";\n    case LIBRAW_NO_THUMBNAIL:\n      return \"No thumbnail in file\";\n    case LIBRAW_UNSUPPORTED_THUMBNAIL:\n      return \"Unsupported thumbnail format\";\n    case LIBRAW_INPUT_CLOSED:\n      return \"No input stream, or input stream closed\";\n    case LIBRAW_UNSUFFICIENT_MEMORY:\n      return \"Unsufficient memory\";\n    case LIBRAW_DATA_ERROR:\n      return \"Corrupted data or unexpected EOF\";\n    case LIBRAW_IO_ERROR:\n      return \"Input/output error\";\n    case LIBRAW_CANCELLED_BY_CALLBACK:\n      return \"Cancelled by user callback\";\n    case LIBRAW_BAD_CROP:\n      return \"Bad crop box\";\n    default:\n      return \"Unknown error code\";\n    }\n  }\n\n#ifdef __cplusplus\n}\n#endif\n\n#define Sigma_X3F 22\n\nconst double LibRaw_constants::xyz_rgb[3][3] = {\n    {0.4124564, 0.3575761, 0.1804375}, {0.2126729, 0.7151522, 0.0721750}, {0.0193339, 0.1191920, 0.9503041}};\n\nconst float LibRaw_constants::d65_white[3] = {0.95047f, 1.0f, 1.08883f};\n\n#define P1 imgdata.idata\n#define S imgdata.sizes\n#define O imgdata.params\n#define C imgdata.color\n#define T imgdata.thumbnail\n#define IO libraw_internal_data.internal_output_params\n#define ID libraw_internal_data.internal_data\n\n#define EXCEPTION_HANDLER(e)                                                                                           \\\n  do                                                                                                                   \\\n  {                                                                                                                    \\\n    /* fprintf(stderr,\"Exception %d caught\\n\",e);*/                                                                    \\\n    switch (e)                                                                                                         \\\n    {                                                                                                                  \\\n    case LIBRAW_EXCEPTION_ALLOC:                                                                                       \\\n      recycle();                                                                                                       \\\n      return LIBRAW_UNSUFFICIENT_MEMORY;                                                                               \\\n    case LIBRAW_EXCEPTION_DECODE_RAW:                                                                                  \\\n    case LIBRAW_EXCEPTION_DECODE_JPEG:                                                                                 \\\n      recycle();                                                                                                       \\\n      return LIBRAW_DATA_ERROR;                                                                                        \\\n    case LIBRAW_EXCEPTION_DECODE_JPEG2000:                                                                             \\\n      recycle();                                                                                                       \\\n      return LIBRAW_DATA_ERROR;                                                                                        \\\n    case LIBRAW_EXCEPTION_IO_EOF:                                                                                      \\\n    case LIBRAW_EXCEPTION_IO_CORRUPT:                                                                                  \\\n      recycle();                                                                                                       \\\n      return LIBRAW_IO_ERROR;                                                                                          \\\n    case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:                                                                       \\\n      recycle();                                                                                                       \\\n      return LIBRAW_CANCELLED_BY_CALLBACK;                                                                             \\\n    case LIBRAW_EXCEPTION_BAD_CROP:                                                                                    \\\n      recycle();                                                                                                       \\\n      return LIBRAW_BAD_CROP;                                                                                          \\\n    default:                                                                                                           \\\n      return LIBRAW_UNSPECIFIED_ERROR;                                                                                 \\\n    }                                                                                                                  \\\n  } while (0)\n\nconst char *LibRaw::version() { return LIBRAW_VERSION_STR; }\nint LibRaw::versionNumber() { return LIBRAW_VERSION; }\nconst char *LibRaw::strerror(int p) { return libraw_strerror(p); }\n\nunsigned LibRaw::capabilities()\n{\n  unsigned ret = 0;\n#ifdef USE_RAWSPEED\n  ret |= LIBRAW_CAPS_RAWSPEED;\n#endif\n#ifdef USE_DNGSDK\n  ret |= LIBRAW_CAPS_DNGSDK;\n#endif\n  return ret;\n}\n\nunsigned LibRaw::parse_custom_cameras(unsigned limit, libraw_custom_camera_t table[], char **list)\n{\n  if (!list)\n    return 0;\n  unsigned index = 0;\n  for (int i = 0; i < limit; i++)\n  {\n    if (!list[i])\n      break;\n    if (strlen(list[i]) < 10)\n      continue;\n    char *string = (char *)malloc(strlen(list[i]) + 1);\n    strcpy(string, list[i]);\n    char *start = string;\n    memset(&table[index], 0, sizeof(table[0]));\n    for (int j = 0; start && j < 14; j++)\n    {\n      char *end = strchr(start, ',');\n      if (end)\n      {\n        *end = 0;\n        end++;\n      } // move to next char\n      while (isspace(*start) && *start)\n        start++; // skip leading spaces?\n      unsigned val = strtol(start, 0, 10);\n      switch (j)\n      {\n      case 0:\n        table[index].fsize = val;\n        break;\n      case 1:\n        table[index].rw = val;\n        break;\n      case 2:\n        table[index].rh = val;\n        break;\n      case 3:\n        table[index].lm = val;\n        break;\n      case 4:\n        table[index].tm = val;\n        break;\n      case 5:\n        table[index].rm = val;\n        break;\n      case 6:\n        table[index].bm = val;\n        break;\n      case 7:\n        table[index].lf = val;\n        break;\n      case 8:\n        table[index].cf = val;\n        break;\n      case 9:\n        table[index].max = val;\n        break;\n      case 10:\n        table[index].flags = val;\n        break;\n      case 11:\n        strncpy(table[index].t_make, start, sizeof(table[index].t_make) - 1);\n        break;\n      case 12:\n        strncpy(table[index].t_model, start, sizeof(table[index].t_model) - 1);\n        break;\n      case 13:\n        table[index].offset = val;\n        break;\n      default:\n        break;\n      }\n      start = end;\n    }\n    free(string);\n    if (table[index].t_make[0])\n      index++;\n  }\n  return index;\n}\n\nvoid LibRaw::derror()\n{\n  if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)\n  {\n    if (libraw_internal_data.internal_data.input->eof())\n    {\n      if (callbacks.data_cb)\n        (*callbacks.data_cb)(callbacks.datacb_data, libraw_internal_data.internal_data.input->fname(), -1);\n      throw LIBRAW_EXCEPTION_IO_EOF;\n    }\n    else\n    {\n      if (callbacks.data_cb)\n        (*callbacks.data_cb)(callbacks.datacb_data, libraw_internal_data.internal_data.input->fname(),\n                             libraw_internal_data.internal_data.input->tell());\n      // throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    }\n  }\n  libraw_internal_data.unpacker_data.data_error++;\n}\n\nvoid LibRaw::dcraw_clear_mem(libraw_processed_image_t *p)\n{\n  if (p)\n    ::free(p);\n}\n\nint LibRaw::is_sraw() { return load_raw == &LibRaw::canon_sraw_load_raw || load_raw == &LibRaw::nikon_load_sraw; }\nint LibRaw::is_coolscan_nef() { return load_raw == &LibRaw::nikon_coolscan_load_raw; }\nint LibRaw::is_jpeg_thumb() { return thumb_load_raw == 0 && write_thumb == &LibRaw::jpeg_thumb; }\n\nint LibRaw::is_nikon_sraw() { return load_raw == &LibRaw::nikon_load_sraw; }\nint LibRaw::sraw_midpoint()\n{\n  if (load_raw == &LibRaw::canon_sraw_load_raw)\n    return 8192;\n  else if (load_raw == &LibRaw::nikon_load_sraw)\n    return 2048;\n  else\n    return 0;\n}\n\n#ifdef USE_RAWSPEED\nusing namespace RawSpeed;\nclass CameraMetaDataLR : public CameraMetaData\n{\npublic:\n  CameraMetaDataLR() : CameraMetaData() {}\n  CameraMetaDataLR(char *filename) : CameraMetaData(filename) {}\n  CameraMetaDataLR(char *data, int sz);\n};\n\nCameraMetaDataLR::CameraMetaDataLR(char *data, int sz) : CameraMetaData()\n{\n  ctxt = xmlNewParserCtxt();\n  if (ctxt == NULL)\n  {\n    ThrowCME(\"CameraMetaData:Could not initialize context.\");\n  }\n\n  xmlResetLastError();\n  doc = xmlCtxtReadMemory(ctxt, data, sz, \"\", NULL, XML_PARSE_DTDVALID);\n\n  if (doc == NULL)\n  {\n    ThrowCME(\"CameraMetaData: XML Document could not be parsed successfully. Error was: %s\", ctxt->lastError.message);\n  }\n\n  if (ctxt->valid == 0)\n  {\n    if (ctxt->lastError.code == 0x5e)\n    {\n      // printf(\"CameraMetaData: Unable to locate DTD, attempting to ignore.\");\n    }\n    else\n    {\n      ThrowCME(\"CameraMetaData: XML file does not validate. DTD Error was: %s\", ctxt->lastError.message);\n    }\n  }\n\n  xmlNodePtr cur;\n  cur = xmlDocGetRootElement(doc);\n  if (xmlStrcmp(cur->name, (const xmlChar *)\"Cameras\"))\n  {\n    ThrowCME(\"CameraMetaData: XML document of the wrong type, root node is not cameras.\");\n    return;\n  }\n\n  cur = cur->xmlChildrenNode;\n  while (cur != NULL)\n  {\n    if ((!xmlStrcmp(cur->name, (const xmlChar *)\"Camera\")))\n    {\n      Camera *camera = new Camera(doc, cur);\n      addCamera(camera);\n\n      // Create cameras for aliases.\n      for (unsigned int i = 0; i < camera->aliases.size(); i++)\n      {\n        addCamera(new Camera(camera, i));\n      }\n    }\n    cur = cur->next;\n  }\n  if (doc)\n    xmlFreeDoc(doc);\n  doc = 0;\n  if (ctxt)\n    xmlFreeParserCtxt(ctxt);\n  ctxt = 0;\n}\n\n#define RAWSPEED_DATA_COUNT (sizeof(_rawspeed_data_xml) / sizeof(_rawspeed_data_xml[0]))\nstatic CameraMetaDataLR *make_camera_metadata()\n{\n  int len = 0, i;\n  for (i = 0; i < RAWSPEED_DATA_COUNT; i++)\n    if (_rawspeed_data_xml[i])\n    {\n      len += strlen(_rawspeed_data_xml[i]);\n    }\n  char *rawspeed_xml = (char *)calloc(len + 1, sizeof(_rawspeed_data_xml[0][0]));\n  if (!rawspeed_xml)\n    return NULL;\n  int offt = 0;\n  for (i = 0; i < RAWSPEED_DATA_COUNT; i++)\n    if (_rawspeed_data_xml[i])\n    {\n      int ll = strlen(_rawspeed_data_xml[i]);\n      if (offt + ll > len)\n        break;\n      memmove(rawspeed_xml + offt, _rawspeed_data_xml[i], ll);\n      offt += ll;\n    }\n  rawspeed_xml[offt] = 0;\n  CameraMetaDataLR *ret = NULL;\n  try\n  {\n    ret = new CameraMetaDataLR(rawspeed_xml, offt);\n  }\n  catch (...)\n  {\n    // Mask all exceptions\n  }\n  free(rawspeed_xml);\n  return ret;\n}\n\n#endif\n\n#define ZERO(a) memset(&a, 0, sizeof(a))\n\nstatic void cleargps(libraw_gps_info_t *q)\n{\n  for (int i = 0; i < 3; i++)\n    q->latitude[i] = q->longtitude[i] = q->gpstimestamp[i] = 0.f;\n  q->altitude = 0.f;\n  q->altref = q->latref = q->longref = q->gpsstatus = q->gpsparsed = 0;\n}\n\nLibRaw::LibRaw(unsigned int flags) : memmgr(1024)\n{\n  double aber[4] = {1, 1, 1, 1};\n  double gamm[6] = {0.45, 4.5, 0, 0, 0, 0};\n  unsigned greybox[4] = {0, 0, UINT_MAX, UINT_MAX};\n  unsigned cropbox[4] = {0, 0, UINT_MAX, UINT_MAX};\n#ifdef DCRAW_VERBOSE\n  verbose = 1;\n#else\n  verbose = 0;\n#endif\n  ZERO(imgdata);\n\n  cleargps(&imgdata.other.parsed_gps);\n  ZERO(libraw_internal_data);\n  ZERO(callbacks);\n\n  _rawspeed_camerameta = _rawspeed_decoder = NULL;\n  dnghost = NULL;\n  _x3f_data = NULL;\n\n#ifdef USE_RAWSPEED\n  CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()\n  _rawspeed_camerameta = static_cast<void *>(camerameta);\n#endif\n  callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL : &default_memory_callback;\n  callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK) ? NULL : &default_data_callback;\n  callbacks.exif_cb = NULL; // no default callback\n  callbacks.pre_identify_cb = NULL;\n  callbacks.post_identify_cb = NULL;\n  callbacks.pre_subtractblack_cb = callbacks.pre_scalecolors_cb = callbacks.pre_preinterpolate_cb\n    = callbacks.pre_interpolate_cb = callbacks.interpolate_bayer_cb = callbacks.interpolate_xtrans_cb\n    = callbacks.post_interpolate_cb = callbacks.pre_converttorgb_cb = callbacks.post_converttorgb_cb \n  = NULL;\n\n  memmove(&imgdata.params.aber, &aber, sizeof(aber));\n  memmove(&imgdata.params.gamm, &gamm, sizeof(gamm));\n  memmove(&imgdata.params.greybox, &greybox, sizeof(greybox));\n  memmove(&imgdata.params.cropbox, &cropbox, sizeof(cropbox));\n\n  imgdata.params.bright = 1;\n  imgdata.params.use_camera_matrix = 1;\n  imgdata.params.user_flip = -1;\n  imgdata.params.user_black = -1;\n  imgdata.params.user_cblack[0] = imgdata.params.user_cblack[1] = imgdata.params.user_cblack[2] =\n      imgdata.params.user_cblack[3] = -1000001;\n  imgdata.params.user_sat = -1;\n  imgdata.params.user_qual = -1;\n  imgdata.params.output_color = 1;\n  imgdata.params.output_bps = 8;\n  imgdata.params.use_fuji_rotate = 1;\n  imgdata.params.exp_shift = 1.0;\n  imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;\n  imgdata.params.adjust_maximum_thr = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;\n  imgdata.params.use_rawspeed = 1;\n  imgdata.params.use_dngsdk = LIBRAW_DNG_DEFAULT;\n  imgdata.params.no_auto_scale = 0;\n  imgdata.params.no_interpolation = 0;\n  imgdata.params.raw_processing_options = LIBRAW_PROCESSING_DP2Q_INTERPOLATERG | LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF |\n                                          LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT;\n  imgdata.params.sony_arw2_posterization_thr = 0;\n  imgdata.params.green_matching = 0;\n  imgdata.params.custom_camera_strings = 0;\n  imgdata.params.coolscan_nef_gamma = 1.0f;\n  imgdata.parent_class = this;\n  imgdata.progress_flags = 0;\n  imgdata.color.baseline_exposure = -999.f;\n  _exitflag = 0;\n  tls = new LibRaw_TLS;\n  tls->init();\n\n}\n\nint LibRaw::set_rawspeed_camerafile(char *filename)\n{\n#ifdef USE_RAWSPEED\n  try\n  {\n    CameraMetaDataLR *camerameta = new CameraMetaDataLR(filename);\n    if (_rawspeed_camerameta)\n    {\n      CameraMetaDataLR *d = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);\n      delete d;\n    }\n    _rawspeed_camerameta = static_cast<void *>(camerameta);\n  }\n  catch (...)\n  {\n    // just return error code\n    return -1;\n  }\n#endif\n  return 0;\n}\n\nLibRaw::~LibRaw()\n{\n  recycle();\n  delete tls;\n#ifdef USE_RAWSPEED\n  if (_rawspeed_camerameta)\n  {\n    CameraMetaDataLR *cmeta = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);\n    delete cmeta;\n    _rawspeed_camerameta = NULL;\n  }\n#endif\n}\n\nvoid *LibRaw::malloc(size_t t)\n{\n  void *p = memmgr.malloc(t);\n  if (!p)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  return p;\n}\nvoid *LibRaw::realloc(void *q, size_t t)\n{\n  void *p = memmgr.realloc(q, t);\n  if (!p)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  return p;\n}\n\nvoid *LibRaw::calloc(size_t n, size_t t)\n{\n  void *p = memmgr.calloc(n, t);\n  if (!p)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  return p;\n}\nvoid LibRaw::free(void *p) { memmgr.free(p); }\n\nvoid LibRaw::recycle_datastream()\n{\n  if (libraw_internal_data.internal_data.input && libraw_internal_data.internal_data.input_internal)\n  {\n    delete libraw_internal_data.internal_data.input;\n    libraw_internal_data.internal_data.input = NULL;\n  }\n  libraw_internal_data.internal_data.input_internal = 0;\n}\n\nvoid x3f_clear(void *);\n\nvoid LibRaw::recycle()\n{\n  recycle_datastream();\n#define FREE(a)                                                                                                        \\\n  do                                                                                                                   \\\n  {                                                                                                                    \\\n    if (a)                                                                                                             \\\n    {                                                                                                                  \\\n      free(a);                                                                                                         \\\n      a = NULL;                                                                                                        \\\n    }                                                                                                                  \\\n  } while (0)\n\n  FREE(imgdata.image);\n\n  FREE(imgdata.thumbnail.thumb);\n  FREE(libraw_internal_data.internal_data.meta_data);\n  FREE(libraw_internal_data.output_data.histogram);\n  FREE(libraw_internal_data.output_data.oprof);\n  FREE(imgdata.color.profile);\n  FREE(imgdata.rawdata.ph1_cblack);\n  FREE(imgdata.rawdata.ph1_rblack);\n  FREE(imgdata.rawdata.raw_alloc);\n  FREE(imgdata.idata.xmpdata);\n\n#undef FREE\n\n  ZERO(imgdata.sizes);\n  imgdata.sizes.raw_crop.cleft = 0xffff;\n  imgdata.sizes.raw_crop.ctop = 0xffff;\n\n  ZERO(imgdata.idata);\n  ZERO(imgdata.makernotes);\n  ZERO(imgdata.color);\n  ZERO(imgdata.other);\n  ZERO(imgdata.thumbnail);\n  ZERO(imgdata.rawdata);\n  imgdata.makernotes.olympus.OlympusCropID = -1;\n  imgdata.makernotes.sony.raw_crop.cleft = 0xffff;\n  imgdata.makernotes.sony.raw_crop.ctop = 0xffff;\n  cleargps(&imgdata.other.parsed_gps);\n  imgdata.color.baseline_exposure = -999.f;\n\n  imgdata.makernotes.fuji.FujiExpoMidPointShift = -999.f;\n  imgdata.makernotes.fuji.FujiDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FujiFilmMode = 0xffff;\n  imgdata.makernotes.fuji.FujiDynamicRangeSetting = 0xffff;\n  imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FujiAutoDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FocusMode = 0xffff;\n  imgdata.makernotes.fuji.AFMode = 0xffff;\n  imgdata.makernotes.fuji.FocusPixel[0] = imgdata.makernotes.fuji.FocusPixel[1] = 0xffff;\n  imgdata.makernotes.fuji.ImageStabilization[0] = imgdata.makernotes.fuji.ImageStabilization[1] =\n      imgdata.makernotes.fuji.ImageStabilization[2] = 0xffff;\n\n  imgdata.makernotes.sony.SonyCameraType = 0xffff;\n  imgdata.makernotes.sony.real_iso_offset = 0xffff;\n  imgdata.makernotes.sony.ImageCount3_offset = 0xffff;\n  imgdata.makernotes.sony.ElectronicFrontCurtainShutter = 0xffff;\n\n  imgdata.makernotes.kodak.BlackLevelTop = 0xffff;\n  imgdata.makernotes.kodak.BlackLevelBottom = 0xffff;\n\n  imgdata.color.dng_color[0].illuminant = imgdata.color.dng_color[1].illuminant = 0xffff;\n\n  for (int i = 0; i < 4; i++)\n    imgdata.color.dng_levels.analogbalance[i] = 1.0f;\n\n  ZERO(libraw_internal_data);\n  ZERO(imgdata.lens);\n  imgdata.lens.makernotes.CanonFocalUnits = 1;\n  imgdata.lens.makernotes.LensID = 0xffffffffffffffffULL;\n  ZERO(imgdata.shootinginfo);\n  imgdata.shootinginfo.DriveMode = -1;\n  imgdata.shootinginfo.FocusMode = -1;\n  imgdata.shootinginfo.MeteringMode = -1;\n  imgdata.shootinginfo.AFPoint = -1;\n  imgdata.shootinginfo.ExposureMode = -1;\n  imgdata.shootinginfo.ImageStabilization = -1;\n\n  _exitflag = 0;\n#ifdef USE_RAWSPEED\n  if (_rawspeed_decoder)\n  {\n    RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);\n    delete d;\n  }\n  _rawspeed_decoder = 0;\n#endif\n\n  if (_x3f_data)\n  {\n    x3f_clear(_x3f_data);\n    _x3f_data = 0;\n  }\n\n  memmgr.cleanup();\n\n  imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n  imgdata.progress_flags = 0;\n\n  load_raw = thumb_load_raw = 0;\n\n  tls->init();\n}\n\nconst char *LibRaw::unpack_function_name()\n{\n  libraw_decoder_info_t decoder_info;\n  get_decoder_info(&decoder_info);\n  return decoder_info.decoder_name;\n}\n\nint LibRaw::get_decoder_info(libraw_decoder_info_t *d_info)\n{\n  if (!d_info)\n    return LIBRAW_UNSPECIFIED_ERROR;\n  d_info->decoder_name = 0;\n  d_info->decoder_flags = 0;\n  if (!load_raw)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  int rawdata = (imgdata.idata.filters || P1.colors == 1);\n  // dcraw.c names order\n  if (load_raw == &LibRaw::android_tight_load_raw)\n  {\n    d_info->decoder_name = \"android_tight_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::android_loose_load_raw)\n  {\n    d_info->decoder_name = \"android_loose_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::canon_600_load_raw)\n  {\n    d_info->decoder_name = \"canon_600_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::fuji_compressed_load_raw)\n  {\n    d_info->decoder_name = \"fuji_compressed_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::fuji_14bit_load_raw)\n  {\n    d_info->decoder_name = \"fuji_14bit_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::canon_load_raw)\n  {\n    d_info->decoder_name = \"canon_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::lossless_jpeg_load_raw)\n  {\n    d_info->decoder_name = \"lossless_jpeg_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::canon_sraw_load_raw)\n  {\n    d_info->decoder_name = \"canon_sraw_load_raw()\";\n    // d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::lossless_dng_load_raw)\n  {\n    d_info->decoder_name = \"lossless_dng_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;\n  }\n  else if (load_raw == &LibRaw::packed_dng_load_raw)\n  {\n    d_info->decoder_name = \"packed_dng_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;\n  }\n  else if (load_raw == &LibRaw::pentax_load_raw)\n  {\n    d_info->decoder_name = \"pentax_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::nikon_load_raw)\n  {\n    d_info->decoder_name = \"nikon_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::nikon_coolscan_load_raw)\n  {\n    d_info->decoder_name = \"nikon_coolscan_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::nikon_load_sraw)\n  {\n    d_info->decoder_name = \"nikon_load_sraw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::nikon_yuv_load_raw)\n  {\n    d_info->decoder_name = \"nikon_load_yuv_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::rollei_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"rollei_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::phase_one_load_raw)\n  {\n    d_info->decoder_name = \"phase_one_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::phase_one_load_raw_c)\n  {\n    d_info->decoder_name = \"phase_one_load_raw_c()\";\n  }\n  else if (load_raw == &LibRaw::hasselblad_load_raw)\n  {\n    d_info->decoder_name = \"hasselblad_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::leaf_hdr_load_raw)\n  {\n    d_info->decoder_name = \"leaf_hdr_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::unpacked_load_raw)\n  {\n    d_info->decoder_name = \"unpacked_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::unpacked_load_raw_reversed)\n  {\n    d_info->decoder_name = \"unpacked_load_raw_reversed()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::sinar_4shot_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"sinar_4shot_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::imacon_full_load_raw)\n  {\n    d_info->decoder_name = \"imacon_full_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::hasselblad_full_load_raw)\n  {\n    d_info->decoder_name = \"hasselblad_full_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::packed_load_raw)\n  {\n    d_info->decoder_name = \"packed_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::broadcom_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"broadcom_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::nokia_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"nokia_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::canon_rmf_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"canon_rmf_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::panasonic_load_raw)\n  {\n    d_info->decoder_name = \"panasonic_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::olympus_load_raw)\n  {\n    d_info->decoder_name = \"olympus_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::minolta_rd175_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"minolta_rd175_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::quicktake_100_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"quicktake_100_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::kodak_radc_load_raw)\n  {\n    d_info->decoder_name = \"kodak_radc_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::kodak_jpeg_load_raw)\n  {\n    // UNTESTED + RBAYER\n    d_info->decoder_name = \"kodak_jpeg_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::lossy_dng_load_raw)\n  {\n    // Check rbayer\n    d_info->decoder_name = \"lossy_dng_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_HASCURVE;\n  }\n  else if (load_raw == &LibRaw::kodak_dc120_load_raw)\n  {\n    d_info->decoder_name = \"kodak_dc120_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::eight_bit_load_raw)\n  {\n    d_info->decoder_name = \"eight_bit_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_c330_load_raw)\n  {\n    d_info->decoder_name = \"kodak_yrgb_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_c603_load_raw)\n  {\n    d_info->decoder_name = \"kodak_yrgb_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_262_load_raw)\n  {\n    d_info->decoder_name = \"kodak_262_load_raw()\"; // UNTESTED!\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_65000_load_raw)\n  {\n    d_info->decoder_name = \"kodak_65000_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;\n  }\n  else if (load_raw == &LibRaw::kodak_ycbcr_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"kodak_ycbcr_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::kodak_rgb_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"kodak_rgb_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::sony_load_raw)\n  {\n    d_info->decoder_name = \"sony_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::sony_arw_load_raw)\n  {\n    d_info->decoder_name = \"sony_arw_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::sony_arw2_load_raw)\n  {\n    d_info->decoder_name = \"sony_arw2_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_SONYARW2;\n  }\n  else if (load_raw == &LibRaw::sony_arq_load_raw)\n  {\n    d_info->decoder_name = \"sony_arq_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_LEGACY_WITH_MARGINS;\n  }\n  else if (load_raw == &LibRaw::samsung_load_raw)\n  {\n    d_info->decoder_name = \"samsung_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n  }\n  else if (load_raw == &LibRaw::samsung2_load_raw)\n  {\n    d_info->decoder_name = \"samsung2_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::samsung3_load_raw)\n  {\n    d_info->decoder_name = \"samsung3_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::smal_v6_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"smal_v6_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::smal_v9_load_raw)\n  {\n    // UNTESTED\n    d_info->decoder_name = \"smal_v9_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::redcine_load_raw)\n  {\n    d_info->decoder_name = \"redcine_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;\n  }\n  else if (load_raw == &LibRaw::x3f_load_raw)\n  {\n    d_info->decoder_name = \"x3f_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC | LIBRAW_DECODER_FIXEDMAXC | LIBRAW_DECODER_LEGACY_WITH_MARGINS;\n  }\n  else if (load_raw == &LibRaw::pentax_4shot_load_raw)\n  {\n    d_info->decoder_name = \"pentax_4shot_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;\n  }\n  else if (load_raw == &LibRaw::deflate_dng_load_raw)\n  {\n    d_info->decoder_name = \"deflate_dng_load_raw()\";\n    d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;\n  }\n  else if (load_raw == &LibRaw::nikon_load_striped_packed_raw)\n  {\n    d_info->decoder_name = \"nikon_load_striped_packed_raw()\";\n  }\n  else\n  {\n    d_info->decoder_name = \"Unknown unpack function\";\n    d_info->decoder_flags = LIBRAW_DECODER_NOTSET;\n  }\n  return LIBRAW_SUCCESS;\n}\n\nint LibRaw::adjust_maximum()\n{\n  ushort real_max;\n  float auto_threshold;\n\n  if (O.adjust_maximum_thr < 0.00001)\n    return LIBRAW_SUCCESS;\n  else if (O.adjust_maximum_thr > 0.99999)\n    auto_threshold = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;\n  else\n    auto_threshold = O.adjust_maximum_thr;\n\n  real_max = C.data_maximum;\n  if (real_max > 0 && real_max < C.maximum && real_max > C.maximum * auto_threshold)\n  {\n    C.maximum = real_max;\n  }\n  return LIBRAW_SUCCESS;\n}\n\nvoid LibRaw::merror(void *ptr, const char *where)\n{\n  if (ptr)\n    return;\n  if (callbacks.mem_cb)\n    (*callbacks.mem_cb)(\n        callbacks.memcb_data,\n        libraw_internal_data.internal_data.input ? libraw_internal_data.internal_data.input->fname() : NULL, where);\n  throw LIBRAW_EXCEPTION_ALLOC;\n}\n\nint LibRaw::open_file(const char *fname, INT64 max_buf_size)\n{\n#ifndef WIN32\n  struct stat st;\n  if (stat(fname, &st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size) ? 1 : 0;\n#else\n  struct _stati64 st;\n  if (_stati64(fname, &st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size) ? 1 : 0;\n#endif\n\n  LibRaw_abstract_datastream *stream;\n  try\n  {\n    if (big)\n      stream = new LibRaw_bigfile_datastream(fname);\n    else\n      stream = new LibRaw_file_datastream(fname);\n  }\n\n  catch (std::bad_alloc)\n  {\n    recycle();\n    return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  if (!stream->valid())\n  {\n    delete stream;\n    return LIBRAW_IO_ERROR;\n  }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n  {\n    ID.input_internal = 1; // flag to delete datastream on recycle\n  }\n  else\n  {\n    delete stream;\n    ID.input_internal = 0;\n  }\n  return ret;\n}\n\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\nint LibRaw::open_file(const wchar_t *fname, INT64 max_buf_size)\n{\n  struct _stati64 st;\n  if (_wstati64(fname, &st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size) ? 1 : 0;\n\n  LibRaw_abstract_datastream *stream;\n  try\n  {\n    if (big)\n      stream = new LibRaw_bigfile_datastream(fname);\n    else\n      stream = new LibRaw_file_datastream(fname);\n  }\n\n  catch (std::bad_alloc)\n  {\n    recycle();\n    return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  if (!stream->valid())\n  {\n    delete stream;\n    return LIBRAW_IO_ERROR;\n  }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n  {\n    ID.input_internal = 1; // flag to delete datastream on recycle\n  }\n  else\n  {\n    delete stream;\n    ID.input_internal = 0;\n  }\n  return ret;\n}\n#endif\n\nint LibRaw::open_buffer(void *buffer, size_t size)\n{\n  // this stream will close on recycle()\n  if (!buffer || buffer == (void *)-1)\n    return LIBRAW_IO_ERROR;\n\n  LibRaw_buffer_datastream *stream;\n  try\n  {\n    stream = new LibRaw_buffer_datastream(buffer, size);\n  }\n  catch (std::bad_alloc)\n  {\n    recycle();\n    return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  if (!stream->valid())\n  {\n    delete stream;\n    return LIBRAW_IO_ERROR;\n  }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n  {\n    ID.input_internal = 1; // flag to delete datastream on recycle\n  }\n  else\n  {\n    delete stream;\n    ID.input_internal = 0;\n  }\n  return ret;\n}\n\nint LibRaw::open_bayer(unsigned char *buffer, unsigned datalen, ushort _raw_width, ushort _raw_height,\n                       ushort _left_margin, ushort _top_margin, ushort _right_margin, ushort _bottom_margin,\n                       unsigned char procflags, unsigned char bayer_pattern, unsigned unused_bits, unsigned otherflags,\n                       unsigned black_level)\n{\n  // this stream will close on recycle()\n  if (!buffer || buffer == (void *)-1)\n    return LIBRAW_IO_ERROR;\n\n  LibRaw_buffer_datastream *stream;\n  try\n  {\n    stream = new LibRaw_buffer_datastream(buffer, datalen);\n  }\n  catch (std::bad_alloc)\n  {\n    recycle();\n    return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  if (!stream->valid())\n  {\n    delete stream;\n    return LIBRAW_IO_ERROR;\n  }\n  ID.input = stream;\n  SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);\n  // From identify\n  initdata();\n  strcpy(imgdata.idata.make, \"BayerDump\");\n  snprintf(imgdata.idata.model, sizeof(imgdata.idata.model) - 1, \"%u x %u pixels\", _raw_width, _raw_height);\n  S.flip = procflags >> 2;\n  libraw_internal_data.internal_output_params.zero_is_bad = procflags & 2;\n  libraw_internal_data.unpacker_data.data_offset = 0;\n  S.raw_width = _raw_width;\n  S.raw_height = _raw_height;\n  S.left_margin = _left_margin;\n  S.top_margin = _top_margin;\n  S.width = S.raw_width - S.left_margin - _right_margin;\n  S.height = S.raw_height - S.top_margin - _bottom_margin;\n\n  imgdata.idata.filters = 0x1010101 * bayer_pattern;\n  imgdata.idata.colors = 4 - !((imgdata.idata.filters & imgdata.idata.filters >> 1) & 0x5555);\n  libraw_internal_data.unpacker_data.load_flags = otherflags;\n  switch (libraw_internal_data.unpacker_data.tiff_bps = (datalen)*8 / (S.raw_width * S.raw_height))\n  {\n  case 8:\n    load_raw = &CLASS eight_bit_load_raw;\n    break;\n  case 10:\n    if ((datalen) / S.raw_height * 3 >= S.raw_width * 4)\n    {\n      load_raw = &CLASS android_loose_load_raw;\n      break;\n    }\n    else if (libraw_internal_data.unpacker_data.load_flags & 1)\n    {\n      load_raw = &CLASS android_tight_load_raw;\n      break;\n    }\n  case 12:\n    libraw_internal_data.unpacker_data.load_flags |= 128;\n    load_raw = &CLASS packed_load_raw;\n    break;\n  case 16:\n    libraw_internal_data.unpacker_data.order = 0x4949 | 0x404 * (libraw_internal_data.unpacker_data.load_flags & 1);\n    libraw_internal_data.unpacker_data.tiff_bps -= libraw_internal_data.unpacker_data.load_flags >> 4;\n    libraw_internal_data.unpacker_data.tiff_bps -= libraw_internal_data.unpacker_data.load_flags =\n        libraw_internal_data.unpacker_data.load_flags >> 1 & 7;\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  C.maximum = (1 << libraw_internal_data.unpacker_data.tiff_bps) - (1 << unused_bits);\n  C.black = black_level;\n  S.iwidth = S.width;\n  S.iheight = S.height;\n  imgdata.idata.colors = 3;\n  imgdata.idata.filters |= ((imgdata.idata.filters >> 2 & 0x22222222) | (imgdata.idata.filters << 2 & 0x88888888)) &\n                           imgdata.idata.filters << 1;\n\n  imgdata.idata.raw_count = 1;\n  for (int i = 0; i < 4; i++)\n    imgdata.color.pre_mul[i] = 1.0;\n\n  strcpy(imgdata.idata.cdesc, \"RGBG\");\n\n  ID.input_internal = 1;\n  SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);\n  return LIBRAW_SUCCESS;\n}\n\n#ifdef USE_ZLIB\ninline unsigned int __DNG_HalfToFloat(ushort halfValue)\n{\n  int sign = (halfValue >> 15) & 0x00000001;\n  int exponent = (halfValue >> 10) & 0x0000001f;\n  int mantissa = halfValue & 0x000003ff;\n  if (exponent == 0)\n  {\n    if (mantissa == 0)\n    {\n      return (unsigned int)(sign << 31);\n    }\n    else\n    {\n      while (!(mantissa & 0x00000400))\n      {\n        mantissa <<= 1;\n        exponent -= 1;\n      }\n      exponent += 1;\n      mantissa &= ~0x00000400;\n    }\n  }\n  else if (exponent == 31)\n  {\n    if (mantissa == 0)\n    {\n      return (unsigned int)((sign << 31) | ((0x1eL + 127 - 15) << 23) | (0x3ffL << 13));\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  exponent += (127 - 15);\n  mantissa <<= 13;\n  return (unsigned int)((sign << 31) | (exponent << 23) | mantissa);\n}\n\ninline unsigned int __DNG_FP24ToFloat(const unsigned char *input)\n{\n  int sign = (input[0] >> 7) & 0x01;\n  int exponent = (input[0]) & 0x7F;\n  int mantissa = (((int)input[1]) << 8) | input[2];\n  if (exponent == 0)\n  {\n    if (mantissa == 0)\n    {\n      return (unsigned int)(sign << 31);\n    }\n    else\n    {\n      while (!(mantissa & 0x00010000))\n      {\n        mantissa <<= 1;\n        exponent -= 1;\n      }\n      exponent += 1;\n      mantissa &= ~0x00010000;\n    }\n  }\n  else if (exponent == 127)\n  {\n    if (mantissa == 0)\n    {\n      return (unsigned int)((sign << 31) | ((0x7eL + 128 - 64) << 23) | (0xffffL << 7));\n    }\n    else\n    {\n      // Nan -- Just set to zero.\n      return 0;\n    }\n  }\n  exponent += (128 - 64);\n  mantissa <<= 7;\n  return (uint32_t)((sign << 31) | (exponent << 23) | mantissa);\n}\n\ninline void DecodeDeltaBytes(unsigned char *bytePtr, int cols, int channels)\n{\n  if (channels == 1)\n  {\n    unsigned char b0 = bytePtr[0];\n    bytePtr += 1;\n    for (uint32_t col = 1; col < cols; ++col)\n    {\n      b0 += bytePtr[0];\n      bytePtr[0] = b0;\n      bytePtr += 1;\n    }\n  }\n  else if (channels == 3)\n  {\n    unsigned char b0 = bytePtr[0];\n    unsigned char b1 = bytePtr[1];\n    unsigned char b2 = bytePtr[2];\n    bytePtr += 3;\n    for (int col = 1; col < cols; ++col)\n    {\n      b0 += bytePtr[0];\n      b1 += bytePtr[1];\n      b2 += bytePtr[2];\n      bytePtr[0] = b0;\n      bytePtr[1] = b1;\n      bytePtr[2] = b2;\n      bytePtr += 3;\n    }\n  }\n  else if (channels == 4)\n  {\n    unsigned char b0 = bytePtr[0];\n    unsigned char b1 = bytePtr[1];\n    unsigned char b2 = bytePtr[2];\n    unsigned char b3 = bytePtr[3];\n    bytePtr += 4;\n    for (uint32_t col = 1; col < cols; ++col)\n    {\n      b0 += bytePtr[0];\n      b1 += bytePtr[1];\n      b2 += bytePtr[2];\n      b3 += bytePtr[3];\n      bytePtr[0] = b0;\n      bytePtr[1] = b1;\n      bytePtr[2] = b2;\n      bytePtr[3] = b3;\n      bytePtr += 4;\n    }\n  }\n  else\n  {\n    for (int col = 1; col < cols; ++col)\n    {\n      for (int chan = 0; chan < channels; ++chan)\n      {\n        bytePtr[chan + channels] += bytePtr[chan];\n      }\n      bytePtr += channels;\n    }\n  }\n}\n\nstatic void DecodeFPDelta(unsigned char *input, unsigned char *output, int cols, int channels, int bytesPerSample)\n{\n  DecodeDeltaBytes(input, cols * bytesPerSample, channels);\n  int32_t rowIncrement = cols * channels;\n\n  if (bytesPerSample == 2)\n  {\n\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n#else\n    const unsigned char *input1 = input;\n    const unsigned char *input0 = input + rowIncrement;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output += 2;\n    }\n  }\n  else if (bytesPerSample == 3)\n  {\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output += 3;\n    }\n  }\n  else\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    const unsigned char *input3 = input + rowIncrement * 3;\n#else\n    const unsigned char *input3 = input;\n    const unsigned char *input2 = input + rowIncrement;\n    const unsigned char *input1 = input + rowIncrement * 2;\n    const unsigned char *input0 = input + rowIncrement * 3;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output[3] = input3[col];\n      output += 4;\n    }\n  }\n}\n\nstatic float expandFloats(unsigned char *dst, int tileWidth, int bytesps)\n{\n  float max = 0.f;\n  if (bytesps == 2)\n  {\n    uint16_t *dst16 = (ushort *)dst;\n    uint32_t *dst32 = (unsigned int *)dst;\n    float *f32 = (float *)dst;\n    for (int index = tileWidth - 1; index >= 0; --index)\n    {\n      dst32[index] = __DNG_HalfToFloat(dst16[index]);\n      max = MAX(max, f32[index]);\n    }\n  }\n  else if (bytesps == 3)\n  {\n    uint8_t *dst8 = ((unsigned char *)dst) + (tileWidth - 1) * 3;\n    uint32_t *dst32 = (unsigned int *)dst;\n    float *f32 = (float *)dst;\n    for (int index = tileWidth - 1; index >= 0; --index, dst8 -= 3)\n    {\n      dst32[index] = __DNG_FP24ToFloat(dst8);\n      max = MAX(max, f32[index]);\n    }\n  }\n  else if (bytesps == 4)\n  {\n    float *f32 = (float *)dst;\n    for (int index = 0; index < tileWidth; index++)\n      max = MAX(max, f32[index]);\n  }\n  return max;\n}\n\nvoid LibRaw::deflate_dng_load_raw()\n{\n  struct tiff_ifd_t *ifd = &tiff_ifd[0];\n  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&\n         ifd->offset != libraw_internal_data.unpacker_data.data_offset)\n    ++ifd;\n  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n  {\n    throw LIBRAW_EXCEPTION_DECODE_RAW;\n  }\n\n  float *float_raw_image = 0;\n  float max = 0.f;\n\n  if (ifd->samples != 1 && ifd->samples != 3 && ifd->samples != 4)\n    throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported\n\n  if (libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)\n    throw LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD\n\n  size_t tilesH = (imgdata.sizes.raw_width + libraw_internal_data.unpacker_data.tile_width - 1) /\n                  libraw_internal_data.unpacker_data.tile_width;\n  size_t tilesV = (imgdata.sizes.raw_height + libraw_internal_data.unpacker_data.tile_length - 1) /\n                  libraw_internal_data.unpacker_data.tile_length;\n  size_t tileCnt = tilesH * tilesV;\n\n  if (ifd->sample_format == 3)\n  { // Floating point data\n    float_raw_image = (float *)calloc(tileCnt * libraw_internal_data.unpacker_data.tile_length *\n                                          libraw_internal_data.unpacker_data.tile_width * ifd->samples,\n                                      sizeof(float));\n    // imgdata.color.maximum = 65535;\n    // imgdata.color.black = 0;\n    // memset(imgdata.color.cblack,0,sizeof(imgdata.color.cblack));\n  }\n  else\n    throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported\n\n  int xFactor;\n  switch (ifd->predictor)\n  {\n  case 3:\n  default:\n    xFactor = 1;\n    break;\n  case 34894:\n    xFactor = 2;\n    break;\n  case 34895:\n    xFactor = 4;\n    break;\n  }\n\n  if (libraw_internal_data.unpacker_data.tile_length < INT_MAX)\n  {\n    if (tileCnt < 1 || tileCnt > 1000000)\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n    size_t *tOffsets = (size_t *)malloc(tileCnt * sizeof(size_t));\n    for (int t = 0; t < tileCnt; ++t)\n      tOffsets[t] = get4();\n\n    size_t *tBytes = (size_t *)malloc(tileCnt * sizeof(size_t));\n    unsigned long maxBytesInTile = 0;\n    if (tileCnt == 1)\n      tBytes[0] = maxBytesInTile = ifd->bytes;\n    else\n    {\n      libraw_internal_data.internal_data.input->seek(ifd->bytes, SEEK_SET);\n      for (size_t t = 0; t < tileCnt; ++t)\n      {\n        tBytes[t] = get4();\n        maxBytesInTile = MAX(maxBytesInTile, tBytes[t]);\n      }\n    }\n    unsigned tilePixels =\n        libraw_internal_data.unpacker_data.tile_width * libraw_internal_data.unpacker_data.tile_length;\n    unsigned pixelSize = sizeof(float) * ifd->samples;\n    unsigned tileBytes = tilePixels * pixelSize;\n    unsigned tileRowBytes = libraw_internal_data.unpacker_data.tile_width * pixelSize;\n\n    unsigned char *cBuffer = (unsigned char *)malloc(maxBytesInTile);\n    unsigned char *uBuffer = (unsigned char *)malloc(tileBytes + tileRowBytes); // extra row for decoding\n\n    for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += libraw_internal_data.unpacker_data.tile_length)\n    {\n      for (size_t x = 0; x < imgdata.sizes.raw_width; x += libraw_internal_data.unpacker_data.tile_width, ++t)\n      {\n        libraw_internal_data.internal_data.input->seek(tOffsets[t], SEEK_SET);\n        libraw_internal_data.internal_data.input->read(cBuffer, 1, tBytes[t]);\n        unsigned long dstLen = tileBytes;\n        int err = uncompress(uBuffer + tileRowBytes, &dstLen, cBuffer, tBytes[t]);\n        if (err != Z_OK)\n        {\n          free(tOffsets);\n          free(tBytes);\n          free(cBuffer);\n          free(uBuffer);\n          throw LIBRAW_EXCEPTION_DECODE_RAW;\n          return;\n        }\n        else\n        {\n          int bytesps = ifd->bps >> 3;\n          size_t rowsInTile = y + libraw_internal_data.unpacker_data.tile_length > imgdata.sizes.raw_height\n                                  ? imgdata.sizes.raw_height - y\n                                  : libraw_internal_data.unpacker_data.tile_length;\n          size_t colsInTile = x + libraw_internal_data.unpacker_data.tile_width > imgdata.sizes.raw_width\n                                  ? imgdata.sizes.raw_width - x\n                                  : libraw_internal_data.unpacker_data.tile_width;\n\n          for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed\n          {\n            unsigned char *dst = uBuffer + row * libraw_internal_data.unpacker_data.tile_width * bytesps * ifd->samples;\n            unsigned char *src = dst + tileRowBytes;\n            DecodeFPDelta(src, dst, libraw_internal_data.unpacker_data.tile_width / xFactor, ifd->samples * xFactor,\n                          bytesps);\n            float lmax = expandFloats(dst, libraw_internal_data.unpacker_data.tile_width * ifd->samples, bytesps);\n            max = MAX(max, lmax);\n            unsigned char *dst2 =\n                (unsigned char *)&float_raw_image[((y + row) * imgdata.sizes.raw_width + x) * ifd->samples];\n            memmove(dst2, dst, colsInTile * ifd->samples * sizeof(float));\n          }\n        }\n      }\n    }\n    free(tOffsets);\n    free(tBytes);\n    free(cBuffer);\n    free(uBuffer);\n  }\n  imgdata.color.fmaximum = max;\n\n  // Set fields according to data format\n\n  imgdata.rawdata.raw_alloc = float_raw_image;\n  if (ifd->samples == 1)\n  {\n    imgdata.rawdata.float_image = float_raw_image;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 4;\n  }\n  else if (ifd->samples == 3)\n  {\n    imgdata.rawdata.float3_image = (float(*)[3])float_raw_image;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 12;\n  }\n  else if (ifd->samples == 4)\n  {\n    imgdata.rawdata.float4_image = (float(*)[4])float_raw_image;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 16;\n  }\n\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT)\n    convertFloatToInt(); // with default settings\n}\n#else\nvoid LibRaw::deflate_dng_load_raw() { throw LIBRAW_EXCEPTION_DECODE_RAW; }\n#endif\n\nint LibRaw::is_floating_point()\n{\n  struct tiff_ifd_t *ifd = &tiff_ifd[0];\n  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&\n         ifd->offset != libraw_internal_data.unpacker_data.data_offset)\n    ++ifd;\n  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n    return 0;\n\n  return ifd->sample_format == 3;\n}\n\nint LibRaw::have_fpdata()\n{\n  return imgdata.rawdata.float_image || imgdata.rawdata.float3_image || imgdata.rawdata.float4_image;\n}\n\nvoid LibRaw::convertFloatToInt(float dmin /* =4096.f */, float dmax /* =32767.f */, float dtarget /*= 16383.f */)\n{\n  int samples = 0;\n  float *data = 0;\n  if (imgdata.rawdata.float_image)\n  {\n    samples = 1;\n    data = imgdata.rawdata.float_image;\n  }\n  else if (imgdata.rawdata.float3_image)\n  {\n    samples = 3;\n    data = (float *)imgdata.rawdata.float3_image;\n  }\n  else if (imgdata.rawdata.float4_image)\n  {\n    samples = 4;\n    data = (float *)imgdata.rawdata.float4_image;\n  }\n  else\n    return;\n\n  ushort *raw_alloc = (ushort *)malloc(imgdata.sizes.raw_height * imgdata.sizes.raw_width *\n                                       libraw_internal_data.unpacker_data.tiff_samples * sizeof(ushort));\n  float tmax = MAX(imgdata.color.maximum, 1);\n  float datamax = imgdata.color.fmaximum;\n\n  tmax = MAX(tmax, datamax);\n  tmax = MAX(tmax, 1.f);\n\n  float multip = 1.f;\n  if (tmax < dmin || tmax > dmax)\n  {\n    imgdata.rawdata.color.fnorm = imgdata.color.fnorm = multip = dtarget / tmax;\n    imgdata.rawdata.color.maximum = imgdata.color.maximum = dtarget;\n    imgdata.rawdata.color.black = imgdata.color.black = (float)imgdata.color.black * multip;\n    for (int i = 0; i < sizeof(imgdata.color.cblack) / sizeof(imgdata.color.cblack[0]); i++)\n      if (i != 4 && i != 5)\n        imgdata.rawdata.color.cblack[i] = imgdata.color.cblack[i] = (float)imgdata.color.cblack[i] * multip;\n  }\n  else\n    imgdata.rawdata.color.fnorm = imgdata.color.fnorm = 0.f;\n\n  for (size_t i = 0;\n       i < imgdata.sizes.raw_height * imgdata.sizes.raw_width * libraw_internal_data.unpacker_data.tiff_samples; ++i)\n  {\n    float val = MAX(data[i], 0.f);\n    raw_alloc[i] = (ushort)(val * multip);\n  }\n\n  if (samples == 1)\n  {\n    imgdata.rawdata.raw_alloc = imgdata.rawdata.raw_image = raw_alloc;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 2;\n  }\n  else if (samples == 3)\n  {\n    imgdata.rawdata.raw_alloc = imgdata.rawdata.color3_image = (ushort(*)[3])raw_alloc;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;\n  }\n  else if (samples == 4)\n  {\n    imgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = (ushort(*)[4])raw_alloc;\n    imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 8;\n  }\n  free(data); // remove old allocation\n  imgdata.rawdata.float_image = 0;\n  imgdata.rawdata.float3_image = 0;\n  imgdata.rawdata.float4_image = 0;\n}\n\nvoid LibRaw::sony_arq_load_raw()\n{\n  int row, col;\n  read_shorts(imgdata.rawdata.raw_image, imgdata.sizes.raw_width * imgdata.sizes.raw_height * 4);\n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    unsigned short(*rowp)[4] = (unsigned short(*)[4]) & imgdata.rawdata.raw_image[row * imgdata.sizes.raw_width * 4];\n    for (col = 0; col < imgdata.sizes.raw_width; col++)\n    {\n      unsigned short g2 = rowp[col][2];\n      rowp[col][2] = rowp[col][3];\n      rowp[col][3] = g2;\n      if (((unsigned)(row - imgdata.sizes.top_margin) < imgdata.sizes.height) &&\n          ((unsigned)(col - imgdata.sizes.left_margin) < imgdata.sizes.width) &&\n          (MAX(MAX(rowp[col][0], rowp[col][1]), MAX(rowp[col][2], rowp[col][3])) > imgdata.color.maximum))\n        derror();\n    }\n  }\n}\n\nvoid LibRaw::pentax_4shot_load_raw()\n{\n  ushort *plane = (ushort *)malloc(imgdata.sizes.raw_width * imgdata.sizes.raw_height * sizeof(ushort));\n  int alloc_sz = imgdata.sizes.raw_width * (imgdata.sizes.raw_height + 16) * 4 * sizeof(ushort);\n  ushort(*result)[4] = (ushort(*)[4])malloc(alloc_sz);\n  struct movement_t\n  {\n    int row, col;\n  } _move[4] = {\n      {1, 1},\n      {0, 1},\n      {0, 0},\n      {1, 0},\n  };\n\n  int tidx = 0;\n  for (int i = 0; i < 4; i++)\n  {\n    int move_row, move_col;\n    if (imgdata.params.p4shot_order[i] >= '0' && imgdata.params.p4shot_order[i] <= '3')\n    {\n      move_row = (imgdata.params.p4shot_order[i] - '0' & 2) ? 1 : 0;\n      move_col = (imgdata.params.p4shot_order[i] - '0' & 1) ? 1 : 0;\n    }\n    else\n    {\n      move_row = _move[i].row;\n      move_col = _move[i].col;\n    }\n    for (; tidx < 16; tidx++)\n      if (tiff_ifd[tidx].t_width == imgdata.sizes.raw_width && tiff_ifd[tidx].t_height == imgdata.sizes.raw_height &&\n          tiff_ifd[tidx].bps > 8 && tiff_ifd[tidx].samples == 1)\n        break;\n    if (tidx >= 16)\n      break;\n    imgdata.rawdata.raw_image = plane;\n    ID.input->seek(tiff_ifd[tidx].offset, SEEK_SET);\n    imgdata.idata.filters = 0xb4b4b4b4;\n    libraw_internal_data.unpacker_data.data_offset = tiff_ifd[tidx].offset;\n    (this->*pentax_component_load_raw)();\n    for (int row = 0; row < imgdata.sizes.raw_height - move_row; row++)\n    {\n      int colors[2];\n      for (int c = 0; c < 2; c++)\n        colors[c] = COLOR(row, c);\n      ushort *srcrow = &plane[imgdata.sizes.raw_width * row];\n      ushort(*dstrow)[4] = &result[(imgdata.sizes.raw_width) * (row + move_row) + move_col];\n      for (int col = 0; col < imgdata.sizes.raw_width - move_col; col++)\n        dstrow[col][colors[col % 2]] = srcrow[col];\n    }\n    tidx++;\n  }\n  // assign things back:\n  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 8;\n  imgdata.idata.filters = 0;\n  imgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = result;\n  free(plane);\n  imgdata.rawdata.raw_image = 0;\n}\n\nvoid LibRaw::hasselblad_full_load_raw()\n{\n  int row, col;\n\n  for (row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++)\n    {\n      read_shorts(&imgdata.image[row * S.width + col][2], 1); // B\n      read_shorts(&imgdata.image[row * S.width + col][1], 1); // G\n      read_shorts(&imgdata.image[row * S.width + col][0], 1); // R\n    }\n}\n\nstatic inline void unpack7bytesto4x16(unsigned char *src, unsigned short *dest)\n{\n  dest[0] = (src[0] << 6) | (src[1] >> 2);\n  dest[1] = ((src[1] & 0x3) << 12) | (src[2] << 4) | (src[3] >> 4);\n  dest[2] = (src[3] & 0xf) << 10 | (src[4] << 2) | (src[5] >> 6);\n  dest[3] = ((src[5] & 0x3f) << 8) | src[6];\n}\n\nstatic inline void unpack28bytesto16x16ns(unsigned char *src, unsigned short *dest)\n{\n  dest[0] = (src[3] << 6) | (src[2] >> 2);\n  dest[1] = ((src[2] & 0x3) << 12) | (src[1] << 4) | (src[0] >> 4);\n  dest[2] = (src[0] & 0xf) << 10 | (src[7] << 2) | (src[6] >> 6);\n  dest[3] = ((src[6] & 0x3f) << 8) | src[5];\n  dest[4] = (src[4] << 6) | (src[11] >> 2);\n  dest[5] = ((src[11] & 0x3) << 12) | (src[10] << 4) | (src[9] >> 4);\n  dest[6] = (src[9] & 0xf) << 10 | (src[8] << 2) | (src[15] >> 6);\n  dest[7] = ((src[15] & 0x3f) << 8) | src[14];\n  dest[8] = (src[13] << 6) | (src[12] >> 2);\n  dest[9] = ((src[12] & 0x3) << 12) | (src[19] << 4) | (src[18] >> 4);\n  dest[10] = (src[18] & 0xf) << 10 | (src[17] << 2) | (src[16] >> 6);\n  dest[11] = ((src[16] & 0x3f) << 8) | src[23];\n  dest[12] = (src[22] << 6) | (src[21] >> 2);\n  dest[13] = ((src[21] & 0x3) << 12) | (src[20] << 4) | (src[27] >> 4);\n  dest[14] = (src[27] & 0xf) << 10 | (src[26] << 2) | (src[25] >> 6);\n  dest[15] = ((src[25] & 0x3f) << 8) | src[24];\n}\n\n#define swab32(x)                                                                                                      \\\n  ((unsigned int)((((unsigned int)(x) & (unsigned int)0x000000ffUL) << 24) |                                           \\\n                  (((unsigned int)(x) & (unsigned int)0x0000ff00UL) << 8) |                                            \\\n                  (((unsigned int)(x) & (unsigned int)0x00ff0000UL) >> 8) |                                            \\\n                  (((unsigned int)(x) & (unsigned int)0xff000000UL) >> 24)))\n\nstatic inline void swab32arr(unsigned *arr, unsigned len)\n{\n  for (unsigned i = 0; i < len; i++)\n    arr[i] = swab32(arr[i]);\n}\n#undef swab32\n\nvoid LibRaw::fuji_14bit_load_raw()\n{\n  const unsigned linelen = S.raw_width * 7 / 4;\n  const unsigned pitch = S.raw_pitch ? S.raw_pitch / 2 : S.raw_width;\n  unsigned char *buf = (unsigned char *)malloc(linelen);\n  merror(buf, \"fuji_14bit_load_raw()\");\n\n  for (int row = 0; row < S.raw_height; row++)\n  {\n    unsigned bytesread = libraw_internal_data.internal_data.input->read(buf, 1, linelen);\n    unsigned short *dest = &imgdata.rawdata.raw_image[pitch * row];\n    if (bytesread % 28)\n    {\n      swab32arr((unsigned *)buf, bytesread / 4);\n      for (int sp = 0, dp = 0; dp < pitch - 3 && sp < linelen - 6 && sp < bytesread - 6; sp += 7, dp += 4)\n        unpack7bytesto4x16(buf + sp, dest + dp);\n    }\n    else\n      for (int sp = 0, dp = 0; dp < pitch - 15 && sp < linelen - 27 && sp < bytesread - 27; sp += 28, dp += 16)\n        unpack28bytesto16x16ns(buf + sp, dest + dp);\n  }\n  free(buf);\n}\n\nvoid LibRaw::nikon_load_striped_packed_raw()\n{\n  int vbits = 0, bwide, rbits, bite, row, col, val, i;\n\n  UINT64 bitbuf = 0;\n  unsigned load_flags = 24; // libraw_internal_data.unpacker_data.load_flags;\n  unsigned tiff_bps = libraw_internal_data.unpacker_data.tiff_bps;\n  int tiff_compress = libraw_internal_data.unpacker_data.tiff_compress;\n\n  struct tiff_ifd_t *ifd = &tiff_ifd[0];\n  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&\n         ifd->offset != libraw_internal_data.unpacker_data.data_offset)\n    ++ifd;\n  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n    throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n  if (!ifd->rows_per_strip || !ifd->strip_offsets_count)\n    return; // not unpacked\n  int stripcnt = 0;\n\n  bwide = S.raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - S.raw_width * tiff_bps;\n  if (load_flags & 1)\n    bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  for (row = 0; row < S.raw_height; row++)\n  {\n    checkCancel();\n    if (!(row % ifd->rows_per_strip))\n    {\n      if (stripcnt >= ifd->strip_offsets_count)\n        return; // run out of data\n      libraw_internal_data.internal_data.input->seek(ifd->strip_offsets[stripcnt], SEEK_SET);\n      stripcnt++;\n    }\n    for (col = 0; col < S.raw_width; col++)\n    {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(libraw_internal_data.internal_data.input->get_char() << i);\n      }\n      imgdata.rawdata.raw_image[(row)*S.raw_width + (col)] = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);\n    }\n    vbits -= rbits;\n  }\n}\n\nstruct foveon_data_t\n{\n  const char *make;\n  const char *model;\n  const int raw_width, raw_height;\n  const int white;\n  const int left_margin, top_margin;\n  const int width, height;\n} foveon_data[] = {\n    {\"Sigma\", \"SD9\", 2304, 1531, 12000, 20, 8, 2266, 1510},\n    {\"Sigma\", \"SD9\", 1152, 763, 12000, 10, 2, 1132, 755},\n    {\"Sigma\", \"SD10\", 2304, 1531, 12000, 20, 8, 2266, 1510},\n    {\"Sigma\", \"SD10\", 1152, 763, 12000, 10, 2, 1132, 755},\n    {\"Sigma\", \"SD14\", 2688, 1792, 14000, 18, 12, 2651, 1767},\n    {\"Sigma\", \"SD14\", 2688, 896, 14000, 18, 6, 2651, 883}, // 2/3\n    {\"Sigma\", \"SD14\", 1344, 896, 14000, 9, 6, 1326, 883},  // 1/2\n    {\"Sigma\", \"SD15\", 2688, 1792, 2900, 18, 12, 2651, 1767},\n    {\"Sigma\", \"SD15\", 2688, 896, 2900, 18, 6, 2651, 883}, // 2/3 ?\n    {\"Sigma\", \"SD15\", 1344, 896, 2900, 9, 6, 1326, 883},  // 1/2 ?\n    {\"Sigma\", \"DP1\", 2688, 1792, 2100, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP1\", 2688, 896, 2100, 18, 6, 2651, 883}, // 2/3 ?\n    {\"Sigma\", \"DP1\", 1344, 896, 2100, 9, 6, 1326, 883},  // 1/2 ?\n    {\"Sigma\", \"DP1S\", 2688, 1792, 2200, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP1S\", 2688, 896, 2200, 18, 6, 2651, 883}, // 2/3\n    {\"Sigma\", \"DP1S\", 1344, 896, 2200, 9, 6, 1326, 883},  // 1/2\n    {\"Sigma\", \"DP1X\", 2688, 1792, 3560, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP1X\", 2688, 896, 3560, 18, 6, 2651, 883}, // 2/3\n    {\"Sigma\", \"DP1X\", 1344, 896, 3560, 9, 6, 1326, 883},  // 1/2\n    {\"Sigma\", \"DP2\", 2688, 1792, 2326, 13, 16, 2651, 1767},\n    {\"Sigma\", \"DP2\", 2688, 896, 2326, 13, 8, 2651, 883}, // 2/3 ??\n    {\"Sigma\", \"DP2\", 1344, 896, 2326, 7, 8, 1325, 883},  // 1/2 ??\n    {\"Sigma\", \"DP2S\", 2688, 1792, 2300, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP2S\", 2688, 896, 2300, 18, 6, 2651, 883}, // 2/3\n    {\"Sigma\", \"DP2S\", 1344, 896, 2300, 9, 6, 1326, 883},  // 1/2\n    {\"Sigma\", \"DP2X\", 2688, 1792, 2300, 18, 12, 2651, 1767},\n    {\"Sigma\", \"DP2X\", 2688, 896, 2300, 18, 6, 2651, 883},           // 2/3\n    {\"Sigma\", \"DP2X\", 1344, 896, 2300, 9, 6, 1325, 883},            // 1/2\n    {\"Sigma\", \"SD1\", 4928, 3264, 3900, 12, 52, 4807, 3205},         // Full size\n    {\"Sigma\", \"SD1\", 4928, 1632, 3900, 12, 26, 4807, 1603},         // 2/3 size\n    {\"Sigma\", \"SD1\", 2464, 1632, 3900, 6, 26, 2403, 1603},          // 1/2 size\n    {\"Sigma\", \"SD1 Merrill\", 4928, 3264, 3900, 12, 52, 4807, 3205}, // Full size\n    {\"Sigma\", \"SD1 Merrill\", 4928, 1632, 3900, 12, 26, 4807, 1603}, // 2/3 size\n    {\"Sigma\", \"SD1 Merrill\", 2464, 1632, 3900, 6, 26, 2403, 1603},  // 1/2 size\n    {\"Sigma\", \"DP1 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},\n    {\"Sigma\", \"DP1 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size\n    {\"Sigma\", \"DP1 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size\n    {\"Sigma\", \"DP2 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},\n    {\"Sigma\", \"DP2 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size\n    {\"Sigma\", \"DP2 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size\n    {\"Sigma\", \"DP3 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},\n    {\"Sigma\", \"DP3 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size\n    {\"Sigma\", \"DP3 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size\n    {\"Polaroid\", \"x530\", 1440, 1088, 2700, 10, 13, 1419, 1059},\n    // dp2 Q\n    {\"Sigma\", \"dp3 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size\n    {\"Sigma\", \"dp3 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size\n    {\"Sigma\", \"dp2 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size\n    {\"Sigma\", \"dp2 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size\n    {\"Sigma\", \"dp1 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size\n    {\"Sigma\", \"dp1 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size\n    {\"Sigma\", \"dp0 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size\n    {\"Sigma\", \"dp0 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size\n    // Sigma sd Quattro\n    {\"Sigma\", \"sd Quattro\", 5888, 3776, 16383, 204, 76, 5446, 3624}, // full size\n    {\"Sigma\", \"sd Quattro\", 2944, 1888, 16383, 102, 38, 2723, 1812}, // half size\n    // Sd Quattro H\n    {\"Sigma\", \"sd Quattro H\", 6656, 4480, 16383, 224, 160, 6208, 4160}, // full size\n    {\"Sigma\", \"sd Quattro H\", 3328, 2240, 16383, 112, 80, 3104, 2080},  // half size\n    {\"Sigma\", \"sd Quattro H\", 5504, 3680, 16383, 0, 4, 5496, 3668},     // full size\n    {\"Sigma\", \"sd Quattro H\", 2752, 1840, 16383, 0, 2, 2748, 1834},     // half size\n};\nconst int foveon_count = sizeof(foveon_data) / sizeof(foveon_data[0]);\n\nint LibRaw::open_datastream(LibRaw_abstract_datastream *stream)\n{\n\n  if (!stream)\n    return ENOENT;\n  if (!stream->valid())\n    return LIBRAW_IO_ERROR;\n  recycle();\n  if(callbacks.pre_identify_cb)\n  {\n    int r = (callbacks.pre_identify_cb)(this);\n    if(r == 1) goto final;\n  }\n\n\n  try\n  {\n    ID.input = stream;\n    SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);\n\n    identify();\n    if(callbacks.post_identify_cb)\n\t(callbacks.post_identify_cb)(this);\n\n#if 0\n    if(!strcasecmp(imgdata.idata.make, \"Sony\")\n       && imgdata.color.maximum > 0\n       && imgdata.color.linear_max[0] > imgdata.color.maximum*3\n       && imgdata.color.linear_max[0] <= imgdata.color.maximum*4)\n         for(int c = 0; c<4; c++)\n\t   imgdata.color.linear_max[c] /= 4;\n#endif\n\n    if (!strcasecmp(imgdata.idata.make, \"Canon\") && (load_raw == &LibRaw::canon_sraw_load_raw) &&\n        imgdata.sizes.raw_width > 0)\n    {\n      float ratio = float(imgdata.sizes.raw_height) / float(imgdata.sizes.raw_width);\n      if ((ratio < 0.57 || ratio > 0.75) && imgdata.makernotes.canon.SensorHeight > 1 &&\n          imgdata.makernotes.canon.SensorWidth > 1)\n      {\n        imgdata.sizes.raw_width = imgdata.makernotes.canon.SensorWidth;\n        imgdata.sizes.left_margin = imgdata.makernotes.canon.SensorLeftBorder;\n        imgdata.sizes.iwidth = imgdata.sizes.width =\n            imgdata.makernotes.canon.SensorRightBorder - imgdata.makernotes.canon.SensorLeftBorder + 1;\n        imgdata.sizes.raw_height = imgdata.makernotes.canon.SensorHeight;\n        imgdata.sizes.top_margin = imgdata.makernotes.canon.SensorTopBorder;\n        imgdata.sizes.iheight = imgdata.sizes.height =\n            imgdata.makernotes.canon.SensorBottomBorder - imgdata.makernotes.canon.SensorTopBorder + 1;\n        libraw_internal_data.unpacker_data.load_flags |= 256; // reset width/height in canon_sraw_load_raw()\n        imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;\n      }\n      else if (imgdata.sizes.raw_width == 4032 && imgdata.sizes.raw_height == 3402 &&\n               !strcasecmp(imgdata.idata.model, \"EOS 80D\")) // 80D hardcoded\n      {\n        imgdata.sizes.raw_width = 4536;\n        imgdata.sizes.left_margin = 28;\n        imgdata.sizes.iwidth = imgdata.sizes.width = imgdata.sizes.raw_width - imgdata.sizes.left_margin;\n        imgdata.sizes.raw_height = 3024;\n        imgdata.sizes.top_margin = 8;\n        imgdata.sizes.iheight = imgdata.sizes.height = imgdata.sizes.raw_height - imgdata.sizes.top_margin;\n        libraw_internal_data.unpacker_data.load_flags |= 256;\n        imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;\n      }\n    }\n\n    // XTrans Compressed?\n    if (!imgdata.idata.dng_version && !strcasecmp(imgdata.idata.make, \"Fujifilm\") &&\n        (load_raw == &LibRaw::unpacked_load_raw))\n    {\n      if (imgdata.sizes.raw_width * imgdata.sizes.raw_height * 2 != libraw_internal_data.unpacker_data.data_size)\n      {\n        if (imgdata.sizes.raw_width * imgdata.sizes.raw_height * 7 / 4 == libraw_internal_data.unpacker_data.data_size)\n          load_raw = &LibRaw::fuji_14bit_load_raw;\n        else\n          parse_fuji_compressed_header();\n      }\n      if (imgdata.idata.filters == 9)\n      {\n        // Adjust top/left margins for X-Trans\n        int newtm = imgdata.sizes.top_margin % 6 ? (imgdata.sizes.top_margin / 6 + 1) * 6 : imgdata.sizes.top_margin;\n        int newlm = imgdata.sizes.left_margin % 6 ? (imgdata.sizes.left_margin / 6 + 1) * 6 : imgdata.sizes.left_margin;\n        if (newtm != imgdata.sizes.top_margin || newlm != imgdata.sizes.left_margin)\n        {\n          imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);\n          imgdata.sizes.top_margin = newtm;\n          imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);\n          imgdata.sizes.left_margin = newlm;\n          for (int c1 = 0; c1 < 6; c1++)\n            for (int c2 = 0; c2 < 6; c2++)\n              imgdata.idata.xtrans[c1][c2] = imgdata.idata.xtrans_abs[c1][c2];\n        }\n      }\n    }\n\n    // Fix DNG white balance if needed\n    if (imgdata.idata.dng_version && (imgdata.idata.filters == 0) && imgdata.idata.colors > 1 &&\n        imgdata.idata.colors < 5)\n    {\n      float delta[4] = {0.f, 0.f, 0.f, 0.f};\n      int black[4];\n      for (int c = 0; c < 4; c++)\n        black[c] = imgdata.color.dng_levels.dng_black + imgdata.color.dng_levels.dng_cblack[c];\n      for (int c = 0; c < imgdata.idata.colors; c++)\n        delta[c] = imgdata.color.dng_levels.dng_whitelevel[c] - black[c];\n      float mindelta = delta[0], maxdelta = delta[0];\n      for (int c = 1; c < imgdata.idata.colors; c++)\n      {\n        if (mindelta > delta[c])\n          mindelta = delta[c];\n        if (maxdelta < delta[c])\n          maxdelta = delta[c];\n      }\n      if (mindelta > 1 && maxdelta < (mindelta * 20)) // safety\n      {\n        for (int c = 0; c < imgdata.idata.colors; c++)\n        {\n          imgdata.color.cam_mul[c] /= (delta[c] / maxdelta);\n          imgdata.color.pre_mul[c] /= (delta[c] / maxdelta);\n        }\n        imgdata.color.maximum = imgdata.color.cblack[0] + maxdelta;\n      }\n    }\n\n    if (imgdata.idata.dng_version &&\n        ((!strcasecmp(imgdata.idata.make, \"Leica\") && !strcasecmp(imgdata.idata.model, \"D-LUX (Typ 109)\")) ||\n         (!strcasecmp(imgdata.idata.make, \"Panasonic\") && !strcasecmp(imgdata.idata.model, \"LX100\"))))\n      imgdata.sizes.width = 4288;\n\n    if (!strncasecmp(imgdata.idata.make, \"Sony\", 4) && imgdata.idata.dng_version &&\n        !(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP))\n    {\n      if (S.raw_width == 3984)\n        S.width = 3925;\n      else if (S.raw_width == 4288)\n        S.width = S.raw_width - 32;\n      else if (S.raw_width == 4928 && S.height < 3280)\n        S.width = S.raw_width - 8;\n      else if (S.raw_width == 5504)\n        S.width = S.raw_width - (S.height > 3664 ? 8 : 32);\n    }\n\n    if (!strcasecmp(imgdata.idata.make, \"Pentax\") &&\n        /*!strcasecmp(imgdata.idata.model,\"K-3 II\")  &&*/ imgdata.idata.raw_count == 4 &&\n        (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES))\n    {\n      imgdata.idata.raw_count = 1;\n      imgdata.idata.filters = 0;\n      imgdata.idata.colors = 4;\n      IO.mix_green = 1;\n      pentax_component_load_raw = load_raw;\n      load_raw = &LibRaw::pentax_4shot_load_raw;\n    }\n\n    if (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Leaf\") && !strcmp(imgdata.idata.model, \"Credo 50\"))\n    {\n      imgdata.color.pre_mul[0] = 1.f / 0.3984f;\n      imgdata.color.pre_mul[2] = 1.f / 0.7666f;\n      imgdata.color.pre_mul[1] = imgdata.color.pre_mul[3] = 1.0;\n    }\n\n    // S3Pro DNG patch\n    if (imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") && !strcmp(imgdata.idata.model, \"S3Pro\") &&\n        imgdata.sizes.raw_width == 4288)\n    {\n      imgdata.sizes.left_margin++;\n      imgdata.sizes.width--;\n    }\n    if (imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") && !strcmp(imgdata.idata.model, \"S5Pro\") &&\n        imgdata.sizes.raw_width == 4288)\n    {\n      imgdata.sizes.left_margin++;\n      imgdata.sizes.width--;\n    }\n    if (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") &&\n        (!strncmp(imgdata.idata.model, \"S20Pro\", 6) || !strncmp(imgdata.idata.model, \"F700\", 4)))\n    {\n      imgdata.sizes.raw_width /= 2;\n      load_raw = &LibRaw::unpacked_load_raw_fuji_f700s20;\n    }\n    if (load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\") &&\n        !libraw_internal_data.unpacker_data.load_flags &&\n        (!strncasecmp(imgdata.idata.model, \"D810\", 4) || !strcasecmp(imgdata.idata.model, \"D4S\")) &&\n        libraw_internal_data.unpacker_data.data_size * 2 == imgdata.sizes.raw_height * imgdata.sizes.raw_width * 3)\n    {\n      libraw_internal_data.unpacker_data.load_flags = 80;\n    }\n    // Adjust BL for Sony A900/A850\n    if (load_raw == &LibRaw::packed_load_raw &&\n        !strcasecmp(imgdata.idata.make, \"Sony\")) // 12 bit sony, but metadata may be for 14-bit range\n    {\n      if (C.maximum > 4095)\n        C.maximum = 4095;\n      if (C.black > 256 || C.cblack[0] > 256)\n      {\n        C.black /= 4;\n        for (int c = 0; c < 4; c++)\n          C.cblack[c] /= 4;\n        for (int c = 0; c < C.cblack[4] * C.cblack[5]; c++)\n          C.cblack[6 + c] /= 4;\n      }\n    }\n    if (load_raw == &LibRaw::nikon_yuv_load_raw) // Is it Nikon sRAW?\n    {\n      load_raw = &LibRaw::nikon_load_sraw;\n      C.black = 0;\n      memset(C.cblack, 0, sizeof(C.cblack));\n      imgdata.idata.filters = 0;\n      libraw_internal_data.unpacker_data.tiff_samples = 3;\n      imgdata.idata.colors = 3;\n      double beta_1 = -5.79342238397656E-02;\n      double beta_2 = 3.28163551282665;\n      double beta_3 = -8.43136004842678;\n      double beta_4 = 1.03533181861023E+01;\n      for (int i = 0; i <= 3072; i++)\n      {\n        double x = (double)i / 3072.;\n        double y = (1. - exp(-beta_1 * x - beta_2 * x * x - beta_3 * x * x * x - beta_4 * x * x * x * x));\n        if (y < 0.)\n          y = 0.;\n        imgdata.color.curve[i] = (y * 16383.);\n      }\n      for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 4; j++)\n          imgdata.color.rgb_cam[i][j] = float(i == j);\n    }\n    // Adjust BL for Nikon 12bit\n    if ((load_raw == &LibRaw::nikon_load_raw || load_raw == &LibRaw::packed_load_raw) &&\n        !strcasecmp(imgdata.idata.make, \"Nikon\") &&\n        strncmp(imgdata.idata.model, \"COOLPIX\", 7)\n        //\t   && strncmp(imgdata.idata.model,\"1 \",2)\n        && libraw_internal_data.unpacker_data.tiff_bps == 12)\n    {\n      C.maximum = 4095;\n      C.black /= 4;\n      for (int c = 0; c < 4; c++)\n        C.cblack[c] /= 4;\n      for (int c = 0; c < C.cblack[4] * C.cblack[5]; c++)\n        C.cblack[6 + c] /= 4;\n    }\n\n    // Adjust Highlight Linearity limit\n    if (C.linear_max[0] < 0)\n    {\n      if (imgdata.idata.dng_version)\n      {\n        for (int c = 0; c < 4; c++)\n          C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c + 6];\n      }\n      else\n      {\n        for (int c = 0; c < 4; c++)\n          C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c];\n      }\n    }\n\n    if (!strcasecmp(imgdata.idata.make, \"Nikon\") && (!C.linear_max[0]) && (C.maximum > 1024) &&\n        (load_raw != &LibRaw::nikon_load_sraw))\n    {\n      C.linear_max[0] = C.linear_max[1] = C.linear_max[2] = C.linear_max[3] = (long)((float)(C.maximum) / 1.07f);\n    }\n\n    // Correct WB for Samsung GX20\n    if (!strcasecmp(imgdata.idata.make, \"Samsung\") && !strcasecmp(imgdata.idata.model, \"GX20\"))\n    {\n      C.WB_Coeffs[LIBRAW_WBI_Daylight][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Daylight][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Shade][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Shade][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Cloudy][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Tungsten][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_D][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_D][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_N][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_N][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_W][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_W][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Flash][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Flash][2]) * 2.56f);\n      for (int c = 0; c < 64; c++)\n      {\n        if (imgdata.color.WBCT_Coeffs[c][0] > 0.0f)\n        {\n          imgdata.color.WBCT_Coeffs[c][3] *= 2.56f;\n        }\n      }\n    }\n\n    // Adjust BL for Panasonic\n    if (load_raw == &LibRaw::panasonic_load_raw &&\n        (!strcasecmp(imgdata.idata.make, \"Panasonic\") || !strcasecmp(imgdata.idata.make, \"Leica\") ||\n         !strcasecmp(imgdata.idata.make, \"YUNEEC\")) &&\n        ID.pana_black[0] && ID.pana_black[1] && ID.pana_black[2])\n    {\n      if(libraw_internal_data.unpacker_data.pana_encoding == 5)\n          P1.raw_count = 0; // Disable for new decoder\n      C.black = 0;\n      int add = libraw_internal_data.unpacker_data.pana_encoding == 4?15:0;\n      C.cblack[0] = ID.pana_black[0]+add;\n      C.cblack[1] = C.cblack[3] = ID.pana_black[1]+add;\n      C.cblack[2] = ID.pana_black[2]+add;\n      int i = C.cblack[3];\n      for (int c = 0; c < 3; c++)\n        if (i > C.cblack[c])\n          i = C.cblack[c];\n      for (int c = 0; c < 4; c++)\n        C.cblack[c] -= i;\n      C.black = i;\n    }\n\n    // Adjust sizes for X3F processing\n    if (load_raw == &LibRaw::x3f_load_raw)\n    {\n      for (int i = 0; i < foveon_count; i++)\n        if (!strcasecmp(imgdata.idata.make, foveon_data[i].make) &&\n            !strcasecmp(imgdata.idata.model, foveon_data[i].model) &&\n            imgdata.sizes.raw_width == foveon_data[i].raw_width &&\n            imgdata.sizes.raw_height == foveon_data[i].raw_height)\n        {\n          imgdata.sizes.top_margin = foveon_data[i].top_margin;\n          imgdata.sizes.left_margin = foveon_data[i].left_margin;\n          imgdata.sizes.width = imgdata.sizes.iwidth = foveon_data[i].width;\n          imgdata.sizes.height = imgdata.sizes.iheight = foveon_data[i].height;\n          C.maximum = foveon_data[i].white;\n          break;\n        }\n    }\n#if 0\n    size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;\n    float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);\n    float bpp2 = float(bytes)/float(S.width)/float(S.height);\n    printf(\"RawSize: %dx%d data offset: %d data size:%d bpp: %g bpp2: %g\\n\",S.raw_width,S.raw_height,libraw_internal_data.unpacker_data.data_offset,bytes,bpp,bpp2);\n    if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)\n      {\n        load_raw = &LibRaw::hasselblad_full_load_raw;\n        S.width = S.raw_width;\n        S.height = S.raw_height;\n        P1.filters = 0;\n        P1.colors=3;\n        P1.raw_count=1;\n        C.maximum=0xffff;\n        printf(\"3 channel hassy found\\n\");\n      }\n#endif\n    if (C.profile_length)\n    {\n      if (C.profile)\n        free(C.profile);\n      C.profile = malloc(C.profile_length);\n      merror(C.profile, \"LibRaw::open_file()\");\n      ID.input->seek(ID.profile_offset, SEEK_SET);\n      ID.input->read(C.profile, C.profile_length, 1);\n    }\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee)\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n\nfinal:;\n\n  if (P1.raw_count < 1)\n    return LIBRAW_FILE_UNSUPPORTED;\n\n  write_fun = &LibRaw::write_ppm_tiff;\n\n  if (load_raw == &LibRaw::kodak_ycbcr_load_raw)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  IO.shrink = P1.filters && (O.half_size || ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1)));\n  if (IO.shrink && P1.filters >= 1000)\n  {\n    S.width &= 65534;\n    S.height &= 65534;\n  }\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n\n  // Save color,sizes and internal data into raw_image fields\n  memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n  memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n  memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n  memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,\n          sizeof(libraw_internal_data.internal_output_params));\n\n  SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);\n\n  return LIBRAW_SUCCESS;\n}\n\n#ifdef USE_RAWSPEED\nvoid LibRaw::fix_after_rawspeed(int bl)\n{\n  if (load_raw == &LibRaw::lossy_dng_load_raw)\n    C.maximum = 0xffff;\n  else if (load_raw == &LibRaw::sony_load_raw)\n    C.maximum = 0x3ff0;\n}\n#else\nvoid LibRaw::fix_after_rawspeed(int) {}\n#endif\n\nvoid LibRaw::clearCancelFlag()\n{\n#ifdef WIN32\n  InterlockedExchange(&_exitflag, 0);\n#else\n  __sync_fetch_and_and(&_exitflag, 0);\n#endif\n#ifdef RAWSPEED_FASTEXIT\n  if (_rawspeed_decoder)\n  {\n    RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);\n    d->resumeProcessing();\n  }\n#endif\n}\n\nvoid LibRaw::setCancelFlag()\n{\n#ifdef WIN32\n  InterlockedExchange(&_exitflag, 1);\n#else\n  __sync_fetch_and_add(&_exitflag, 1);\n#endif\n#ifdef RAWSPEED_FASTEXIT\n  if (_rawspeed_decoder)\n  {\n    RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);\n    d->cancelProcessing();\n  }\n#endif\n}\n\nvoid LibRaw::checkCancel()\n{\n#ifdef WIN32\n  if (InterlockedExchange(&_exitflag, 0))\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#else\n  if (__sync_fetch_and_and(&_exitflag, 0))\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\nint LibRaw::try_rawspeed()\n{\n#ifdef USE_RAWSPEED\n  int ret = LIBRAW_SUCCESS;\n\n  int rawspeed_ignore_errors = 0;\n  if (imgdata.idata.dng_version && imgdata.idata.colors == 3 &&\n      !strcasecmp(imgdata.idata.software, \"Adobe Photoshop Lightroom 6.1.1 (Windows)\"))\n    rawspeed_ignore_errors = 1;\n\n  // RawSpeed Supported,\n  INT64 spos = ID.input->tell();\n  void *_rawspeed_buffer = 0;\n  try\n  {\n    //                printf(\"Using rawspeed\\n\");\n    ID.input->seek(0, SEEK_SET);\n    INT64 _rawspeed_buffer_sz = ID.input->size() + 32;\n    _rawspeed_buffer = malloc(_rawspeed_buffer_sz);\n    if (!_rawspeed_buffer)\n      throw LIBRAW_EXCEPTION_ALLOC;\n    ID.input->read(_rawspeed_buffer, _rawspeed_buffer_sz, 1);\n    FileMap map((uchar8 *)_rawspeed_buffer, _rawspeed_buffer_sz);\n    RawParser t(&map);\n    RawDecoder *d = 0;\n    CameraMetaDataLR *meta = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);\n    d = t.getDecoder();\n    if (!d)\n      throw \"Unable to find decoder\";\n    try\n    {\n      d->checkSupport(meta);\n    }\n    catch (const RawDecoderException &e)\n    {\n      imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;\n      throw e;\n    }\n    d->interpolateBadPixels = FALSE;\n    d->applyStage1DngOpcodes = FALSE;\n    _rawspeed_decoder = static_cast<void *>(d);\n    d->decodeRaw();\n    d->decodeMetaData(meta);\n    RawImage r = d->mRaw;\n    if (r->errors.size() > 0 && !rawspeed_ignore_errors)\n    {\n      delete d;\n      _rawspeed_decoder = 0;\n      throw 1;\n    }\n    if (r->isCFA)\n    {\n      imgdata.rawdata.raw_image = (ushort *)r->getDataUncropped(0, 0);\n    }\n    else if (r->getCpp() == 4)\n    {\n      imgdata.rawdata.color4_image = (ushort(*)[4])r->getDataUncropped(0, 0);\n      if (r->whitePoint > 0 && r->whitePoint < 65536)\n        C.maximum = r->whitePoint;\n    }\n    else if (r->getCpp() == 3)\n    {\n      imgdata.rawdata.color3_image = (ushort(*)[3])r->getDataUncropped(0, 0);\n      if (r->whitePoint > 0 && r->whitePoint < 65536)\n        C.maximum = r->whitePoint;\n    }\n    else\n    {\n      delete d;\n      _rawspeed_decoder = 0;\n      ret = LIBRAW_UNSPECIFIED_ERROR;\n    }\n    if (_rawspeed_decoder)\n    {\n      // set sizes\n      iPoint2D rsdim = r->getUncroppedDim();\n      S.raw_pitch = r->pitch;\n      S.raw_width = rsdim.x;\n      S.raw_height = rsdim.y;\n      // C.maximum = r->whitePoint;\n      fix_after_rawspeed(r->blackLevel);\n    }\n    free(_rawspeed_buffer);\n    _rawspeed_buffer = 0;\n    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;\n  }\n  catch (const RawDecoderException &RDE)\n  {\n    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;\n    if (_rawspeed_buffer)\n    {\n      free(_rawspeed_buffer);\n      _rawspeed_buffer = 0;\n    }\n    const char *p = RDE.what();\n    if (!strncmp(RDE.what(), \"Decoder canceled\", strlen(\"Decoder canceled\")))\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n    ret = LIBRAW_UNSPECIFIED_ERROR;\n  }\n  catch (...)\n  {\n    // We may get here due to cancellation flag\n    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;\n    if (_rawspeed_buffer)\n    {\n      free(_rawspeed_buffer);\n      _rawspeed_buffer = 0;\n    }\n    ret = LIBRAW_UNSPECIFIED_ERROR;\n  }\n  ID.input->seek(spos, SEEK_SET);\n\n  return ret;\n#else\n  return LIBRAW_NOT_IMPLEMENTED;\n#endif\n}\n\nint LibRaw::valid_for_dngsdk()\n{\n#ifndef USE_DNGSDK\n  return 0;\n#else\n  if (!imgdata.idata.dng_version)\n    return 0;\n  if (!imgdata.params.use_dngsdk)\n    return 0;\n  if (load_raw == &LibRaw::lossy_dng_load_raw)\n    return 0;\n  if (is_floating_point() && (imgdata.params.use_dngsdk & LIBRAW_DNG_FLOAT))\n    return 1;\n  if (!imgdata.idata.filters && (imgdata.params.use_dngsdk & LIBRAW_DNG_LINEAR))\n    return 1;\n  if (libraw_internal_data.unpacker_data.tiff_bps == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_8BIT))\n    return 1;\n  if (libraw_internal_data.unpacker_data.tiff_compress == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_DEFLATE))\n    return 1;\n  if (libraw_internal_data.unpacker_data.tiff_samples == 2)\n    return 0; // Always deny 2-samples (old fuji superccd)\n  if (imgdata.idata.filters == 9 && (imgdata.params.use_dngsdk & LIBRAW_DNG_XTRANS))\n    return 1;\n  if (is_fuji_rotated())\n    return 0; // refuse\n  if (imgdata.params.use_dngsdk & LIBRAW_DNG_OTHER)\n    return 1;\n  return 0;\n#endif\n}\n\nint LibRaw::is_curve_linear()\n{\n  for (int i = 0; i < 0x10000; i++)\n    if (imgdata.color.curve[i] != i)\n      return 0;\n  return 1;\n}\n\nint LibRaw::try_dngsdk()\n{\n#ifdef USE_DNGSDK\n  if (!dnghost)\n    return LIBRAW_UNSPECIFIED_ERROR;\n\n  dng_host *host = static_cast<dng_host *>(dnghost);\n\n  try\n  {\n    libraw_dng_stream stream(libraw_internal_data.internal_data.input);\n\n    AutoPtr<dng_negative> negative;\n    negative.Reset(host->Make_dng_negative());\n\n    dng_info info;\n    info.Parse(*host, stream);\n    info.PostParse(*host);\n\n    if (!info.IsValidDNG())\n    {\n      return LIBRAW_DATA_ERROR;\n    }\n    negative->Parse(*host, stream, info);\n    negative->PostParse(*host, stream, info);\n    negative->ReadStage1Image(*host, stream, info);\n    dng_simple_image *stage2 = (dng_simple_image *)negative->Stage1Image();\n    if (stage2->Bounds().W() != S.raw_width || stage2->Bounds().H() != S.raw_height)\n    {\n      return LIBRAW_DATA_ERROR;\n    }\n\n    int pplanes = stage2->Planes();\n    int ptype = stage2->PixelType();\n\n    dng_pixel_buffer buffer;\n    stage2->GetPixelBuffer(buffer);\n\n    int pixels = stage2->Bounds().H() * stage2->Bounds().W() * pplanes;\n    if (ptype == ttByte)\n      imgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ttShort));\n    else\n      imgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ptype));\n\n    if (ptype == ttShort && !is_curve_linear())\n    {\n      ushort *src = (ushort *)buffer.fData;\n      ushort *dst = (ushort *)imgdata.rawdata.raw_alloc;\n      for (int i = 0; i < pixels; i++)\n        dst[i] = imgdata.color.curve[src[i]];\n      S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ptype);\n    }\n    else if (ptype == ttByte)\n    {\n      unsigned char *src = (unsigned char *)buffer.fData;\n      ushort *dst = (ushort *)imgdata.rawdata.raw_alloc;\n      if (is_curve_linear())\n      {\n        for (int i = 0; i < pixels; i++)\n          dst[i] = src[i];\n      }\n      else\n      {\n        for (int i = 0; i < pixels; i++)\n          dst[i] = imgdata.color.curve[src[i]];\n      }\n      S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ttShort);\n    }\n    else\n    {\n      memmove(imgdata.rawdata.raw_alloc, buffer.fData, pixels * TagTypeSize(ptype));\n      S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ptype);\n    }\n\n    switch (ptype)\n    {\n    case ttFloat:\n      if (pplanes == 1)\n        imgdata.rawdata.float_image = (float *)imgdata.rawdata.raw_alloc;\n      else if (pplanes == 3)\n        imgdata.rawdata.float3_image = (float(*)[3])imgdata.rawdata.raw_alloc;\n      else if (pplanes == 4)\n        imgdata.rawdata.float4_image = (float(*)[4])imgdata.rawdata.raw_alloc;\n      break;\n\n    case ttByte:\n    case ttShort:\n      if (pplanes == 1)\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n      else if (pplanes == 3)\n        imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n      else if (pplanes == 4)\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n      break;\n    default:\n      /* do nothing */\n      break;\n    }\n  }\n  catch (...)\n  {\n    return LIBRAW_UNSPECIFIED_ERROR;\n  }\n  return imgdata.rawdata.raw_alloc ? LIBRAW_SUCCESS : LIBRAW_UNSPECIFIED_ERROR;\n#else\n  return LIBRAW_UNSPECIFIED_ERROR;\n#endif\n}\nvoid LibRaw::set_dng_host(void *p)\n{\n#ifdef USE_DNGSDK\n  dnghost = p;\n#endif\n}\n\nint LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try\n  {\n\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if (!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if (imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n    }\n    if (imgdata.rawdata.raw_alloc)\n    {\n      free(imgdata.rawdata.raw_alloc);\n      imgdata.rawdata.raw_alloc = 0;\n    }\n    if (libraw_internal_data.unpacker_data.meta_length)\n    {\n      libraw_internal_data.internal_data.meta_data = (char *)malloc(libraw_internal_data.unpacker_data.meta_length);\n      merror(libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");\n    }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if (!IO.fuji_width)\n    {\n      // adjust non-Fuji allocation\n      if (rwidth < S.width + S.left_margin)\n        rwidth = S.width + S.left_margin;\n      if (rheight < S.height + S.top_margin)\n        rheight = S.height + S.top_margin;\n    }\n    if (rwidth > 65535 || rheight > 65535) // No way to make image larger than 64k pix\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n    imgdata.rawdata.float_image = 0;\n    imgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n    if (imgdata.idata.dng_version && dnghost && imgdata.idata.raw_count == 1 && valid_for_dngsdk() &&\n        load_raw != &LibRaw::pentax_4shot_load_raw)\n    {\n      int rr = try_dngsdk();\n    }\n#endif\n\n#ifdef USE_RAWSPEED\n    if (!raw_was_read())\n    {\n      int rawspeed_enabled = 1;\n\n      if (imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.raw_count > 1)\n        rawspeed_enabled = 0;\n      if (!strncasecmp(imgdata.idata.software, \"Magic\", 5))\n        rawspeed_enabled = 0;\n      // Disable rawspeed for double-sized Oly files\n      if (!strncasecmp(imgdata.idata.make, \"Olympus\", 7) &&\n          ((imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model, \"SH-2\", 4) ||\n           !strncasecmp(imgdata.idata.model, \"SH-3\", 4) || !strncasecmp(imgdata.idata.model, \"TG-4\", 4) ||\n           !strncasecmp(imgdata.idata.model, \"TG-5\", 4)))\n        rawspeed_enabled = 0;\n\n      if (!strncasecmp(imgdata.idata.make, \"Canon\", 5) && !strcasecmp(imgdata.idata.model, \"EOS 6D Mark II\"))\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&\n          libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make, \"Nikon\", 5) &&\n          (!strncasecmp(imgdata.idata.model, \"E\", 1) || !strncasecmp(imgdata.idata.model, \"COOLPIX B\", 9)))\n        rawspeed_enabled = 0;\n\n      // RawSpeed Supported,\n      if (O.use_rawspeed && rawspeed_enabled &&\n          !(is_sraw() &&\n            (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE))) &&\n          (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n      {\n        int rr = try_rawspeed();\n      }\n    }\n#endif\n    if (!raw_was_read()) // RawSpeed failed or not run\n    {\n      // Not allocated on RawSpeed call, try call LibRaow\n      int zero_rawimage = 0;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder and DNG float\n        // Do nothing! Decoder will allocate data internally\n      }\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_3CHANNEL)\n      {\n        if (INT64(rwidth) * INT64(rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) * 3 >\n            LIBRAW_MAX_ALLOC_MB * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_ALLOC;\n\n        imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) * 3);\n        imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 6;\n      }\n      else if (imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n      {\n        if (INT64(rwidth) * INT64(rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) >\n            LIBRAW_MAX_ALLOC_MB * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_ALLOC;\n        imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n      }\n      else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)\n        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch =\n                (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        if (INT64(MAX(S.width, S.raw_width)) * INT64(MAX(S.height, S.raw_height)) * sizeof(*imgdata.image) >\n            LIBRAW_MAX_ALLOC_MB * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_ALLOC;\n\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image = (ushort(*)[4])calloc(\n            unsigned(MAX(S.width, S.raw_width)) * unsigned(MAX(S.height, S.raw_height)), sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\"))\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\"))\n        C.maximum = m_save;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder only: do nothing\n      }\n      else if (!(imgdata.idata.filters || P1.colors == 1)) // legacy decoder, ownalloc handled above\n      {\n        // successfully decoded legacy image, attach image to raw_alloc\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n        // Restore saved values. Note: Foveon have masked frame\n        // Other 4-color legacy data: no borders\n        if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS))\n        {\n          S.raw_width = S.width;\n          S.left_margin = 0;\n          S.raw_height = S.height;\n          S.top_margin = 0;\n        }\n      }\n    }\n\n    if (imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for (c = 0; c < 3; c++)\n      if (i > C.cblack[c])\n        i = C.cblack[c];\n    for (c = 0; c < 4; c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,\n            sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);\n\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee)\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}\n\nvoid LibRaw::unpacked_load_raw_fuji_f700s20()\n{\n  int base_offset = 0;\n  int row_size = imgdata.sizes.raw_width * 2; // in bytes\n  if (imgdata.idata.raw_count == 2 && imgdata.params.shot_select)\n  {\n    libraw_internal_data.internal_data.input->seek(-row_size, SEEK_CUR);\n    base_offset = row_size; // in bytes\n  }\n  unsigned char *buffer = (unsigned char *)malloc(row_size * 2);\n  for (int row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    read_shorts((ushort *)buffer, imgdata.sizes.raw_width * 2);\n    memmove(&imgdata.rawdata.raw_image[row * imgdata.sizes.raw_pitch / 2], buffer + base_offset, row_size);\n  }\n  free(buffer);\n}\n\nvoid LibRaw::nikon_load_sraw()\n{\n  // We're already seeked to data!\n  unsigned char *rd = (unsigned char *)malloc(3 * (imgdata.sizes.raw_width + 2));\n  if (!rd)\n    throw LIBRAW_EXCEPTION_ALLOC;\n  try\n  {\n    int row, col;\n    for (row = 0; row < imgdata.sizes.raw_height; row++)\n    {\n      checkCancel();\n      libraw_internal_data.internal_data.input->read(rd, 3, imgdata.sizes.raw_width);\n      for (col = 0; col < imgdata.sizes.raw_width - 1; col += 2)\n      {\n        int bi = col * 3;\n        ushort bits1 = (rd[bi + 1] & 0xf) << 8 | rd[bi];            // 3,0,1\n        ushort bits2 = rd[bi + 2] << 4 | ((rd[bi + 1] >> 4) & 0xf); // 452\n        ushort bits3 = ((rd[bi + 4] & 0xf) << 8) | rd[bi + 3];      // 967\n        ushort bits4 = rd[bi + 5] << 4 | ((rd[bi + 4] >> 4) & 0xf); // ab8\n        imgdata.image[row * imgdata.sizes.raw_width + col][0] = bits1;\n        imgdata.image[row * imgdata.sizes.raw_width + col][1] = bits3;\n        imgdata.image[row * imgdata.sizes.raw_width + col][2] = bits4;\n        imgdata.image[row * imgdata.sizes.raw_width + col + 1][0] = bits2;\n        imgdata.image[row * imgdata.sizes.raw_width + col + 1][1] = 2048;\n        imgdata.image[row * imgdata.sizes.raw_width + col + 1][2] = 2048;\n      }\n    }\n  }\n  catch (...)\n  {\n    free(rd);\n    throw;\n  }\n  free(rd);\n  C.maximum = 0xfff; // 12 bit?\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    return; // no CbCr interpolation\n  }\n  // Interpolate CC channels\n  int row, col;\n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    checkCancel(); // will throw out\n    for (col = 0; col < imgdata.sizes.raw_width; col += 2)\n    {\n      int col2 = col < imgdata.sizes.raw_width - 2 ? col + 2 : col;\n      imgdata.image[row * imgdata.sizes.raw_width + col + 1][1] =\n          (unsigned short)(int(imgdata.image[row * imgdata.sizes.raw_width + col][1] +\n                               imgdata.image[row * imgdata.sizes.raw_width + col2][1]) /\n                           2);\n      imgdata.image[row * imgdata.sizes.raw_width + col + 1][2] =\n          (unsigned short)(int(imgdata.image[row * imgdata.sizes.raw_width + col][2] +\n                               imgdata.image[row * imgdata.sizes.raw_width + col2][2]) /\n                           2);\n    }\n  }\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n    return;\n\n  for (row = 0; row < imgdata.sizes.raw_height; row++)\n  {\n    checkCancel(); // will throw out\n    for (col = 0; col < imgdata.sizes.raw_width; col++)\n    {\n      float Y = float(imgdata.image[row * imgdata.sizes.raw_width + col][0]) / 2549.f;\n      float Ch2 = float(imgdata.image[row * imgdata.sizes.raw_width + col][1] - 1280) / 1536.f;\n      float Ch3 = float(imgdata.image[row * imgdata.sizes.raw_width + col][2] - 1280) / 1536.f;\n      if (Y > 1.f)\n        Y = 1.f;\n      if (Y > 0.803f)\n        Ch2 = Ch3 = 0.5f;\n      float r = Y + 1.40200f * (Ch3 - 0.5f);\n      if (r < 0.f)\n        r = 0.f;\n      if (r > 1.f)\n        r = 1.f;\n      float g = Y - 0.34414f * (Ch2 - 0.5f) - 0.71414 * (Ch3 - 0.5f);\n      if (g > 1.f)\n        g = 1.f;\n      if (g < 0.f)\n        g = 0.f;\n      float b = Y + 1.77200 * (Ch2 - 0.5f);\n      if (b > 1.f)\n        b = 1.f;\n      if (b < 0.f)\n        b = 0.f;\n      imgdata.image[row * imgdata.sizes.raw_width + col][0] = imgdata.color.curve[int(r * 3072.f)];\n      imgdata.image[row * imgdata.sizes.raw_width + col][1] = imgdata.color.curve[int(g * 3072.f)];\n      imgdata.image[row * imgdata.sizes.raw_width + col][2] = imgdata.color.curve[int(b * 3072.f)];\n    }\n  }\n  C.maximum = 16383;\n}\n\nvoid LibRaw::free_image(void)\n{\n  if (imgdata.image)\n  {\n    free(imgdata.image);\n    imgdata.image = 0;\n    imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_IDENTIFY |\n                             LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;\n  }\n}\n\nvoid LibRaw::raw2image_start()\n{\n  // restore color,sizes and internal data into raw_image fields\n  memmove(&imgdata.color, &imgdata.rawdata.color, sizeof(imgdata.color));\n  memmove(&imgdata.sizes, &imgdata.rawdata.sizes, sizeof(imgdata.sizes));\n  memmove(&imgdata.idata, &imgdata.rawdata.iparams, sizeof(imgdata.idata));\n  memmove(&libraw_internal_data.internal_output_params, &imgdata.rawdata.ioparams,\n          sizeof(libraw_internal_data.internal_output_params));\n\n  if (O.user_flip >= 0)\n    S.flip = O.user_flip;\n\n  switch ((S.flip + 3600) % 360)\n  {\n  case 270:\n    S.flip = 5;\n    break;\n  case 180:\n    S.flip = 3;\n    break;\n  case 90:\n    S.flip = 6;\n    break;\n  }\n\n  // adjust for half mode!\n  IO.shrink = P1.filters && (O.half_size || ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1)));\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n}\n\nint LibRaw::is_phaseone_compressed()\n{\n  return (load_raw == &LibRaw::phase_one_load_raw_c || load_raw == &LibRaw::phase_one_load_raw);\n}\n\nint LibRaw::is_canon_600() { return load_raw == &LibRaw::canon_600_load_raw; }\n\nint LibRaw::raw2image(void)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try\n  {\n    raw2image_start();\n\n    if (is_phaseone_compressed())\n    {\n      phase_one_allocate_tempbuffer();\n      int rc = phase_one_subtract_black((ushort *)imgdata.rawdata.raw_alloc, imgdata.rawdata.raw_image);\n      if (rc == 0)\n        rc = phase_one_correct();\n      if (rc != 0)\n      {\n        phase_one_free_tempbuffer();\n        return rc;\n      }\n    }\n\n    // free and re-allocate image bitmap\n    if (imgdata.image)\n    {\n      imgdata.image = (ushort(*)[4])realloc(imgdata.image, S.iheight * S.iwidth * sizeof(*imgdata.image));\n      memset(imgdata.image, 0, S.iheight * S.iwidth * sizeof(*imgdata.image));\n    }\n    else\n      imgdata.image = (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n    merror(imgdata.image, \"raw2image()\");\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Move saved bitmap to imgdata.image\n    if (imgdata.idata.filters || P1.colors == 1)\n    {\n      if (IO.fuji_width)\n      {\n        unsigned r, c;\n        int row, col;\n        for (row = 0; row < S.raw_height - S.top_margin * 2; row++)\n        {\n          for (col = 0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)\n          {\n            if (libraw_internal_data.unpacker_data.fuji_layout)\n            {\n              r = IO.fuji_width - 1 - col + (row >> 1);\n              c = col + ((row + 1) >> 1);\n            }\n            else\n            {\n              r = IO.fuji_width - 1 + row - (col >> 1);\n              c = row + ((col + 1) >> 1);\n            }\n            if (r < S.height && c < S.width)\n              imgdata.image[((r) >> IO.shrink) * S.iwidth + ((c) >> IO.shrink)][FC(r, c)] =\n                  imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n          }\n        }\n      }\n      else\n      {\n        int row, col;\n        for (row = 0; row < S.height; row++)\n          for (col = 0; col < S.width; col++)\n            imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][fcol(row, col)] =\n                imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n      }\n    }\n    else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n    {\n      if (imgdata.rawdata.color4_image)\n      {\n        if (S.width * 8 == S.raw_pitch)\n          memmove(imgdata.image, imgdata.rawdata.color4_image, S.width * S.height * sizeof(*imgdata.image));\n        else\n        {\n          for (int row = 0; row < S.height; row++)\n            memmove(&imgdata.image[row * S.width],\n                    &imgdata.rawdata.color4_image[(row + S.top_margin) * S.raw_pitch / 8 + S.left_margin],\n                    S.width * sizeof(*imgdata.image));\n        }\n      }\n      else if (imgdata.rawdata.color3_image)\n      {\n        unsigned char *c3image = (unsigned char *)imgdata.rawdata.color3_image;\n        for (int row = 0; row < S.height; row++)\n        {\n          ushort(*srcrow)[3] = (ushort(*)[3]) & c3image[(row + S.top_margin) * S.raw_pitch];\n          ushort(*dstrow)[4] = (ushort(*)[4]) & imgdata.image[row * S.width];\n          for (int col = 0; col < S.width; col++)\n          {\n            for (int c = 0; c < 3; c++)\n              dstrow[col][c] = srcrow[S.left_margin + col][c];\n            dstrow[col][3] = 0;\n          }\n        }\n      }\n      else\n      {\n        // legacy decoder, but no data?\n        throw LIBRAW_EXCEPTION_DECODE_RAW;\n      }\n    }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n    {\n      phase_one_free_tempbuffer();\n    }\n    // hack - clear later flags!\n\n    if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)\n    {\n      canon_600_correct();\n    }\n\n    imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE |\n                             LIBRAW_PROGRESS_IDENTIFY | LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nvoid LibRaw::phase_one_allocate_tempbuffer()\n{\n  // Allocate temp raw_image buffer\n  imgdata.rawdata.raw_image = (ushort *)malloc(S.raw_pitch * S.raw_height);\n  merror(imgdata.rawdata.raw_image, \"phase_one_prepare_to_correct()\");\n}\nvoid LibRaw::phase_one_free_tempbuffer()\n{\n  free(imgdata.rawdata.raw_image);\n  imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n}\n\nint LibRaw::phase_one_subtract_black(ushort *src, ushort *dest)\n{\n\n  try\n  {\n    if (O.user_black < 0 && O.user_cblack[0] <= -1000000 && O.user_cblack[1] <= -1000000 &&\n        O.user_cblack[2] <= -1000000 && O.user_cblack[3] <= -1000000)\n    {\n      if (!imgdata.rawdata.ph1_cblack || !imgdata.rawdata.ph1_rblack)\n      {\n        register int bl = imgdata.color.phase_one_data.t_black;\n        for (int row = 0; row < S.raw_height; row++)\n        {\n          checkCancel();\n          for (int col = 0; col < S.raw_width; col++)\n          {\n            int idx = row * S.raw_width + col;\n            int val = int(src[idx]) - bl;\n            dest[idx] = val > 0 ? val : 0;\n          }\n        }\n      }\n      else\n      {\n        register int bl = imgdata.color.phase_one_data.t_black;\n        for (int row = 0; row < S.raw_height; row++)\n        {\n          checkCancel();\n          for (int col = 0; col < S.raw_width; col++)\n          {\n            int idx = row * S.raw_width + col;\n            int val = int(src[idx]) - bl +\n                      imgdata.rawdata.ph1_cblack[row][col >= imgdata.rawdata.color.phase_one_data.split_col] +\n                      imgdata.rawdata.ph1_rblack[col][row >= imgdata.rawdata.color.phase_one_data.split_row];\n            dest[idx] = val > 0 ? val : 0;\n          }\n        }\n      }\n    }\n    else // black set by user interaction\n    {\n      // Black level in cblack!\n      for (int row = 0; row < S.raw_height; row++)\n      {\n        checkCancel();\n        unsigned short cblk[16];\n        for (int cc = 0; cc < 16; cc++)\n          cblk[cc] = C.cblack[fcol(row, cc)];\n        for (int col = 0; col < S.raw_width; col++)\n        {\n          int idx = row * S.raw_width + col;\n          ushort val = src[idx];\n          ushort bl = cblk[col & 0xf];\n          dest[idx] = val > bl ? val - bl : 0;\n        }\n      }\n    }\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n}\n\nvoid LibRaw::copy_fuji_uncropped(unsigned short cblack[4], unsigned short *dmaxp)\n{\n  int row;\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for default(shared)\n#endif\n  for (row = 0; row < S.raw_height - S.top_margin * 2; row++)\n  {\n    int col;\n    unsigned short ldmax = 0;\n    for (col = 0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)\n    {\n      unsigned r, c;\n      if (libraw_internal_data.unpacker_data.fuji_layout)\n      {\n        r = IO.fuji_width - 1 - col + (row >> 1);\n        c = col + ((row + 1) >> 1);\n      }\n      else\n      {\n        r = IO.fuji_width - 1 + row - (col >> 1);\n        c = row + ((col + 1) >> 1);\n      }\n      if (r < S.height && c < S.width)\n      {\n        unsigned short val = imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n        int cc = FC(r, c);\n        if (val > cblack[cc])\n        {\n          val -= cblack[cc];\n          if (val > ldmax)\n            ldmax = val;\n        }\n        else\n          val = 0;\n        imgdata.image[((r) >> IO.shrink) * S.iwidth + ((c) >> IO.shrink)][cc] = val;\n      }\n    }\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp critical(dataupdate)\n#endif\n    {\n      if (*dmaxp < ldmax)\n        *dmaxp = ldmax;\n    }\n  }\n}\n\nvoid LibRaw::copy_bayer(unsigned short cblack[4], unsigned short *dmaxp)\n{\n  // Both cropped and uncropped\n  int row;\n\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for default(shared)\n#endif\n  for (row = 0; row < S.height; row++)\n  {\n    int col;\n    unsigned short ldmax = 0;\n    for (col = 0; col < S.width; col++)\n    {\n      unsigned short val = imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n      int cc = fcol(row, col);\n      if (val > cblack[cc])\n      {\n        val -= cblack[cc];\n        if (val > ldmax)\n          ldmax = val;\n      }\n      else\n        val = 0;\n      imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][cc] = val;\n    }\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp critical(dataupdate)\n#endif\n    {\n      if (*dmaxp < ldmax)\n        *dmaxp = ldmax;\n    }\n  }\n}\n\nint LibRaw::raw2image_ex(int do_subtract_black)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try\n  {\n    raw2image_start();\n\n    // Compressed P1 files with bl data!\n    if (is_phaseone_compressed())\n    {\n      phase_one_allocate_tempbuffer();\n      int rc = phase_one_subtract_black((ushort *)imgdata.rawdata.raw_alloc, imgdata.rawdata.raw_image);\n      if (rc == 0)\n        rc = phase_one_correct();\n      if (rc != 0)\n      {\n        phase_one_free_tempbuffer();\n        return rc;\n      }\n    }\n\n    // process cropping\n    int do_crop = 0;\n    unsigned save_width = S.width;\n    if (~O.cropbox[2] && ~O.cropbox[3])\n    {\n      int crop[4], c, filt;\n      for (int c = 0; c < 4; c++)\n      {\n        crop[c] = O.cropbox[c];\n        if (crop[c] < 0)\n          crop[c] = 0;\n      }\n\n      if (IO.fuji_width && imgdata.idata.filters >= 1000)\n      {\n        crop[0] = (crop[0] / 4) * 4;\n        crop[1] = (crop[1] / 4) * 4;\n        if (!libraw_internal_data.unpacker_data.fuji_layout)\n        {\n          crop[2] *= sqrt(2.0);\n          crop[3] /= sqrt(2.0);\n        }\n        crop[2] = (crop[2] / 4 + 1) * 4;\n        crop[3] = (crop[3] / 4 + 1) * 4;\n      }\n      else if (imgdata.idata.filters == 1)\n      {\n        crop[0] = (crop[0] / 16) * 16;\n        crop[1] = (crop[1] / 16) * 16;\n      }\n      else if (imgdata.idata.filters == LIBRAW_XTRANS)\n      {\n        crop[0] = (crop[0] / 6) * 6;\n        crop[1] = (crop[1] / 6) * 6;\n      }\n      do_crop = 1;\n\n      crop[2] = MIN(crop[2], (signed)S.width - crop[0]);\n      crop[3] = MIN(crop[3], (signed)S.height - crop[1]);\n      if (crop[2] <= 0 || crop[3] <= 0)\n        throw LIBRAW_EXCEPTION_BAD_CROP;\n\n      // adjust sizes!\n      S.left_margin += crop[0];\n      S.top_margin += crop[1];\n      S.width = crop[2];\n      S.height = crop[3];\n\n      S.iheight = (S.height + IO.shrink) >> IO.shrink;\n      S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n      if (!IO.fuji_width && imgdata.idata.filters && imgdata.idata.filters >= 1000)\n      {\n        for (filt = c = 0; c < 16; c++)\n          filt |= FC((c >> 1) + (crop[1]), (c & 1) + (crop[0])) << c * 2;\n        imgdata.idata.filters = filt;\n      }\n    }\n\n    int alloc_width = S.iwidth;\n    int alloc_height = S.iheight;\n\n    if (IO.fuji_width && do_crop)\n    {\n      int IO_fw = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;\n      int t_alloc_width = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO_fw;\n      int t_alloc_height = t_alloc_width - 1;\n      alloc_height = (t_alloc_height + IO.shrink) >> IO.shrink;\n      alloc_width = (t_alloc_width + IO.shrink) >> IO.shrink;\n    }\n    int alloc_sz = alloc_width * alloc_height;\n\n    if (imgdata.image)\n    {\n      imgdata.image = (ushort(*)[4])realloc(imgdata.image, alloc_sz * sizeof(*imgdata.image));\n      memset(imgdata.image, 0, alloc_sz * sizeof(*imgdata.image));\n    }\n    else\n      imgdata.image = (ushort(*)[4])calloc(alloc_sz, sizeof(*imgdata.image));\n    merror(imgdata.image, \"raw2image_ex()\");\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Adjust black levels\n    unsigned short cblack[4] = {0, 0, 0, 0};\n    unsigned short dmax = 0;\n    if (do_subtract_black)\n    {\n      adjust_bl();\n      for (int i = 0; i < 4; i++)\n        cblack[i] = (unsigned short)C.cblack[i];\n    }\n\n    // Move saved bitmap to imgdata.image\n    if (imgdata.idata.filters || P1.colors == 1)\n    {\n      if (IO.fuji_width)\n      {\n        if (do_crop)\n        {\n          IO.fuji_width = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;\n          int IO_fwidth = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO.fuji_width;\n          int IO_fheight = IO_fwidth - 1;\n\n          int row, col;\n          for (row = 0; row < S.height; row++)\n          {\n            for (col = 0; col < S.width; col++)\n            {\n              int r, c;\n              if (libraw_internal_data.unpacker_data.fuji_layout)\n              {\n                r = IO.fuji_width - 1 - col + (row >> 1);\n                c = col + ((row + 1) >> 1);\n              }\n              else\n              {\n                r = IO.fuji_width - 1 + row - (col >> 1);\n                c = row + ((col + 1) >> 1);\n              }\n\n              unsigned short val =\n                  imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];\n              int cc = FCF(row, col);\n              if (val > cblack[cc])\n              {\n                val -= cblack[cc];\n                if (dmax < val)\n                  dmax = val;\n              }\n              else\n                val = 0;\n              imgdata.image[((r) >> IO.shrink) * alloc_width + ((c) >> IO.shrink)][cc] = val;\n            }\n          }\n          S.height = IO_fheight;\n          S.width = IO_fwidth;\n          S.iheight = (S.height + IO.shrink) >> IO.shrink;\n          S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n          S.raw_height -= 2 * S.top_margin;\n        }\n        else\n        {\n          copy_fuji_uncropped(cblack, &dmax);\n        }\n      } // end Fuji\n      else\n      {\n        copy_bayer(cblack, &dmax);\n      }\n    }\n    else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n    {\n      if (imgdata.rawdata.color4_image)\n      {\n        if (S.raw_pitch != S.width * 8)\n        {\n          for (int row = 0; row < S.height; row++)\n            memmove(&imgdata.image[row * S.width],\n                    &imgdata.rawdata.color4_image[(row + S.top_margin) * S.raw_pitch / 8 + S.left_margin],\n                    S.width * sizeof(*imgdata.image));\n        }\n        else\n        {\n          // legacy is always 4channel and not shrinked!\n          memmove(imgdata.image, imgdata.rawdata.color4_image, S.width * S.height * sizeof(*imgdata.image));\n        }\n      }\n      else if (imgdata.rawdata.color3_image)\n      {\n        unsigned char *c3image = (unsigned char *)imgdata.rawdata.color3_image;\n        for (int row = 0; row < S.height; row++)\n        {\n          ushort(*srcrow)[3] = (ushort(*)[3]) & c3image[(row + S.top_margin) * S.raw_pitch];\n          ushort(*dstrow)[4] = (ushort(*)[4]) & imgdata.image[row * S.width];\n          for (int col = 0; col < S.width; col++)\n          {\n            for (int c = 0; c < 3; c++)\n              dstrow[col][c] = srcrow[S.left_margin + col][c];\n            dstrow[col][3] = 0;\n          }\n        }\n      }\n      else\n      {\n        // legacy decoder, but no data?\n        throw LIBRAW_EXCEPTION_DECODE_RAW;\n      }\n    }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n    {\n      phase_one_free_tempbuffer();\n    }\n    if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)\n    {\n      canon_600_correct();\n    }\n\n    if (do_subtract_black)\n    {\n      C.data_maximum = (int)dmax;\n      C.maximum -= C.black;\n      //        ZERO(C.cblack);\n      C.cblack[0] = C.cblack[1] = C.cblack[2] = C.cblack[3] = 0;\n      C.black = 0;\n    }\n\n    // hack - clear later flags!\n    imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE |\n                             LIBRAW_PROGRESS_IDENTIFY | LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#if 1\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_thumb(int *errcode)\n{\n  if (!T.thumb)\n  {\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      if (errcode)\n        *errcode = LIBRAW_NO_THUMBNAIL;\n    }\n    else\n    {\n      if (errcode)\n        *errcode = LIBRAW_OUT_OF_ORDER_CALL;\n    }\n    return NULL;\n  }\n\n  if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)\n  {\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + T.tlength);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n    ret->type = LIBRAW_IMAGE_BITMAP;\n    ret->height = T.theight;\n    ret->width = T.twidth;\n    ret->colors = 3;\n    ret->bits = 8;\n    ret->data_size = T.tlength;\n    memmove(ret->data, T.thumb, T.tlength);\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)\n  {\n    ushort exif[5];\n    int mk_exif = 0;\n    if (strcmp(T.thumb + 6, \"Exif\"))\n      mk_exif = 1;\n\n    int dsize = T.tlength + mk_exif * (sizeof(exif) + sizeof(tiff_hdr));\n\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + dsize);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n\n    ret->type = LIBRAW_IMAGE_JPEG;\n    ret->data_size = dsize;\n\n    ret->data[0] = 0xff;\n    ret->data[1] = 0xd8;\n    if (mk_exif)\n    {\n      struct tiff_hdr th;\n      memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n      exif[1] = htons(8 + sizeof th);\n      memmove(ret->data + 2, exif, sizeof(exif));\n      tiff_head(&th, 0);\n      memmove(ret->data + (2 + sizeof(exif)), &th, sizeof(th));\n      memmove(ret->data + (2 + sizeof(exif) + sizeof(th)), T.thumb + 2, T.tlength - 2);\n    }\n    else\n    {\n      memmove(ret->data + 2, T.thumb + 2, T.tlength - 2);\n    }\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else\n  {\n    if (errcode)\n      *errcode = LIBRAW_UNSUPPORTED_THUMBNAIL;\n    return NULL;\n  }\n}\n\n// jlb\n// macros for copying pixels to either BGR or RGB formats\n#define FORBGR for (c = P1.colors - 1; c >= 0; c--)\n#define FORRGB for (c = 0; c < P1.colors; c++)\n\nvoid LibRaw::get_mem_image_format(int *width, int *height, int *colors, int *bps) const\n\n{\n  if (S.flip & 4)\n  {\n    *width = S.height;\n    *height = S.width;\n  }\n  else\n  {\n    *width = S.width;\n    *height = S.height;\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}\n\nint LibRaw::copy_mem_image(void *scan0, int stride, int bgr)\n\n{\n  // the image memory pointed to by scan0 is assumed to be in the format returned by get_mem_image_format\n  if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) < LIBRAW_PROGRESS_PRE_INTERPOLATE)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  if (libraw_internal_data.output_data.histogram)\n  {\n    int perc, val, total, t_white = 0x2000, c;\n    perc = S.width * S.height * O.auto_bright_thr;\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  int s_iheight = S.iheight;\n  int s_iwidth = S.iwidth;\n  int s_width = S.width;\n  int s_hwight = S.height;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n  for (row = 0; row < S.height; row++, soff += rstep)\n  {\n    uchar *bufp = ((uchar *)scan0) + row * stride;\n    ppm2 = (ushort *)(ppm = bufp);\n    // keep trivial decisions in the outer loop for speed\n    if (bgr)\n    {\n      if (O.output_bps == 8)\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORBGR *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n      }\n      else\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORBGR *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n      }\n    }\n    else\n    {\n      if (O.output_bps == 8)\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORRGB *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n      }\n      else\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORRGB *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n      }\n    }\n\n    //            bufp += stride;           // go to the next line\n  }\n\n  S.iheight = s_iheight;\n  S.iwidth = s_iwidth;\n  S.width = s_width;\n  S.height = s_hwight;\n\n  return 0;\n}\n#undef FORBGR\n#undef FORRGB\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_image(int *errcode)\n\n{\n  int width, height, colors, bps;\n  get_mem_image_format(&width, &height, &colors, &bps);\n  int stride = width * (bps / 8) * colors;\n  unsigned ds = height * stride;\n  libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + ds);\n  if (!ret)\n  {\n    if (errcode)\n      *errcode = ENOMEM;\n    return NULL;\n  }\n  memset(ret, 0, sizeof(libraw_processed_image_t));\n\n  // metadata init\n  ret->type = LIBRAW_IMAGE_BITMAP;\n  ret->height = height;\n  ret->width = width;\n  ret->colors = colors;\n  ret->bits = bps;\n  ret->data_size = ds;\n  copy_mem_image(ret->data, stride, 0);\n\n  return ret;\n}\n\n#undef FORC\n#undef FORCC\n#undef SWAP\n#endif\n\nint LibRaw::dcraw_ppm_tiff_writer(const char *filename)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  if (!imgdata.image)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  if (!filename)\n    return ENOENT;\n  FILE *f = fopen(filename, \"wb\");\n\n  if (!f)\n    return errno;\n\n  try\n  {\n    if (!libraw_internal_data.output_data.histogram)\n    {\n      libraw_internal_data.output_data.histogram =\n          (int(*)[LIBRAW_HISTOGRAM_SIZE])malloc(sizeof(*libraw_internal_data.output_data.histogram) * 4);\n      merror(libraw_internal_data.output_data.histogram, \"LibRaw::dcraw_ppm_tiff_writer()\");\n    }\n    libraw_internal_data.internal_data.output = f;\n    write_ppm_tiff();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n    libraw_internal_data.internal_data.output = NULL;\n    fclose(f);\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    fclose(f);\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#define THUMB_READ_BEYOND 16384\n\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize = T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth, s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n  if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image = (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n  merror(imgdata.image, \"LibRaw::kodak_thumb_loader()\");\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n    (this->*thumb_load_raw)();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n// copy-n-paste from image pipe\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LIM(x, min, max) MAX(min, MIN(x, max))\n#ifndef CLIP\n#define CLIP(x) LIM(x, 0, 65535)\n#endif\n#define SWAP(a, b)                                                                                                     \\\n  {                                                                                                                    \\\n    a ^= b;                                                                                                            \\\n    a ^= (b ^= a);                                                                                                     \\\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] = (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n  merror(t_hist, \"LibRaw::kodak_thumb_loader()\");\n\n  float out[3], out_cam[3][4] = {{2.81761312, -1.98369181, 0.166078627, 0},\n                                 {-0.111855984, 1.73688626, -0.625030339, 0},\n                                 {-0.0379119813, -0.891268849, 1.92918086, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort(*t_curve) = (ushort *)calloc(sizeof(C.curve), 1);\n  merror(t_curve, \"LibRaw::kodak_thumb_loader()\");\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  merror(T.thumb, \"LibRaw::kodak_thumb_loader()\");\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int row = 0; row < S.height; row++, soff += rstep)\n    {\n      char *ppm = T.thumb + row * S.width * P1.colors;\n      for (int col = 0; col < S.width; col++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[col * P1.colors + c] = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n#undef SWAP\n\n// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumbnail \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd, \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumb_format \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\nint LibRaw::thumbOK(INT64 maxsz)\n{\n  if (!ID.input)\n    return 0;\n  if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n  )\n    return 0;\n  INT64 fsize = ID.input->size();\n  if (fsize > 0x7fffffffU)\n    return 0; // No thumb for raw > 2Gb\n  int tsize = 0;\n  int tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;\n  if (write_thumb == &LibRaw::jpeg_thumb)\n    tsize = T.tlength;\n  else if (write_thumb == &LibRaw::ppm_thumb)\n    tsize = tcol * T.twidth * T.theight;\n  else if (write_thumb == &LibRaw::ppm16_thumb)\n    tsize = tcol * T.twidth * T.theight *\n            ((imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_PPM16_THUMBS) ? 2 : 1);\n  else if (write_thumb == &LibRaw::x3f_thumb_loader)\n  {\n    tsize = x3f_thumb_size();\n  }\n  else // Kodak => no check\n    tsize = 1;\n  if (tsize < 0)\n    return 0;\n  if (maxsz > 0 && tsize > maxsz)\n    return 0;\n  return (tsize + ID.toffset <= fsize) ? 1 : 0;\n}\n\n#ifndef NO_JPEG\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n  jmp_buf setjmp_buffer;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  longjmp(myerr->setjmp_buffer, 1);\n}\n#endif\n\nint LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if (thumb_load_raw)\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n      if (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (write_thumb == &LibRaw::jpeg_thumb)\n      {\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        merror(T.thumb, \"jpeg_thumb()\");\n        ID.input->read(T.thumb, 1, T.tlength);\n        unsigned char *tthumb = (unsigned char *)T.thumb;\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3) ? cinfo.num_components : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm_thumb)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more bits\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength && T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = -1;\n          for (int ii = 0; ii < libraw_internal_data.identify_data.tiff_nifds && ii < LIBRAW_IFD_MAXCOUNT; ii++)\n            if (tiff_ifd[ii].offset == libraw_internal_data.internal_data.toffset) // found\n            {\n              pifd = ii;\n              break;\n            }\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count && tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n            merror(T.thumb, \"ppm_thumb()\");\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count && i < tiff_ifd[pifd].strip_offsets_count; i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n        merror(T.thumb, \"ppm_thumb()\");\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm16_thumb)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for more bits\n        int o_bps = (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_PPM16_THUMBS) ? 2 : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234))\n          swab((char *)t_thumb, (char *)t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.params.raw_processing_options & LIBRAW_PROCESSING_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          merror(T.thumb, \"ppm_thumb()\");\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nint LibRaw::dcraw_thumb_writer(const char *fname)\n{\n  //    CHECK_ORDER_LOW(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  if (!fname)\n    return ENOENT;\n\n  FILE *tfp = fopen(fname, \"wb\");\n\n  if (!tfp)\n    return errno;\n\n  if (!T.thumb)\n  {\n    fclose(tfp);\n    return LIBRAW_OUT_OF_ORDER_CALL;\n  }\n\n  try\n  {\n    switch (T.tformat)\n    {\n    case LIBRAW_THUMBNAIL_JPEG:\n      jpeg_thumb_writer(tfp, T.thumb, T.tlength);\n      break;\n    case LIBRAW_THUMBNAIL_BITMAP:\n      fprintf(tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n      fwrite(T.thumb, 1, T.tlength, tfp);\n      break;\n    default:\n      fclose(tfp);\n      return LIBRAW_UNSUPPORTED_THUMBNAIL;\n    }\n    fclose(tfp);\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nint LibRaw::adjust_sizes_info_only(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n\n  raw2image_start();\n  if (O.use_fuji_rotate)\n  {\n    if (IO.fuji_width)\n    {\n      IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;\n      S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));\n      S.iheight = (ushort)((S.iheight - IO.fuji_width) / sqrt(0.5));\n    }\n    else\n    {\n      if (S.pixel_aspect < 0.995)\n        S.iheight = (ushort)(S.iheight / S.pixel_aspect + 0.5);\n      if (S.pixel_aspect > 1.005)\n        S.iwidth = (ushort)(S.iwidth * S.pixel_aspect + 0.5);\n    }\n  }\n  SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n  if (S.flip & 4)\n  {\n    unsigned short t = S.iheight;\n    S.iheight = S.iwidth;\n    S.iwidth = t;\n    SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n  }\n  return 0;\n}\n\nint LibRaw::subtract_black()\n{\n  adjust_bl();\n  return subtract_black_internal();\n}\n\nint LibRaw::subtract_black_internal()\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\n  try\n  {\n    if (!is_phaseone_compressed() &&\n        (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3] || (C.cblack[4] && C.cblack[5])))\n    {\n#define BAYERC(row, col, c) imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][c]\n      int cblk[4], i;\n      for (i = 0; i < 4; i++)\n        cblk[i] = C.cblack[i];\n\n      int size = S.iheight * S.iwidth;\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LIM(x, min, max) MAX(min, MIN(x, max))\n#define CLIP(x) LIM(x, 0, 65535)\n      int dmax = 0;\n      if (C.cblack[4] && C.cblack[5])\n      {\n        for (i = 0; i < size * 4; i++)\n        {\n          int val = imgdata.image[0][i];\n          val -= C.cblack[6 + i / 4 / S.iwidth % C.cblack[4] * C.cblack[5] + i / 4 % S.iwidth % C.cblack[5]];\n          val -= cblk[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n          if (dmax < val)\n            dmax = val;\n        }\n      }\n      else\n      {\n        for (i = 0; i < size * 4; i++)\n        {\n          int val = imgdata.image[0][i];\n          val -= cblk[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n          if (dmax < val)\n            dmax = val;\n        }\n      }\n      C.data_maximum = dmax & 0xffff;\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n      C.maximum -= C.black;\n      ZERO(C.cblack); // Yeah, we used cblack[6+] values too!\n      C.black = 0;\n#undef BAYERC\n    }\n    else\n    {\n      // Nothing to Do, maximum is already calculated, black level is 0, so no change\n      // only calculate channel maximum;\n      int idx;\n      ushort *p = (ushort *)imgdata.image;\n      int dmax = 0;\n      for (idx = 0; idx < S.iheight * S.iwidth * 4; idx++)\n        if (dmax < p[idx])\n          dmax = p[idx];\n      C.data_maximum = dmax;\n    }\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#define TBLN 65535\n\nvoid LibRaw::exp_bef(float shift, float smooth)\n{\n  // params limits\n  if (shift > 8)\n    shift = 8;\n  if (shift < 0.25)\n    shift = 0.25;\n  if (smooth < 0.0)\n    smooth = 0.0;\n  if (smooth > 1.0)\n    smooth = 1.0;\n\n  unsigned short *lut = (ushort *)malloc((TBLN + 1) * sizeof(unsigned short));\n\n  if (shift <= 1.0)\n  {\n    for (int i = 0; i <= TBLN; i++)\n      lut[i] = (unsigned short)((float)i * shift);\n  }\n  else\n  {\n    float x1, x2, y1, y2;\n\n    float cstops = log(shift) / log(2.0f);\n    float room = cstops * 2;\n    float roomlin = powf(2.0f, room);\n    x2 = (float)TBLN;\n    x1 = (x2 + 1) / roomlin - 1;\n    y1 = x1 * shift;\n    y2 = x2 * (1 + (1 - smooth) * (shift - 1));\n    float sq3x = powf(x1 * x1 * x2, 1.0f / 3.0f);\n    float B = (y2 - y1 + shift * (3 * x1 - 3.0f * sq3x)) / (x2 + 2.0f * x1 - 3.0f * sq3x);\n    float A = (shift - B) * 3.0f * powf(x1 * x1, 1.0f / 3.0f);\n    float CC = y2 - A * powf(x2, 1.0f / 3.0f) - B * x2;\n    for (int i = 0; i <= TBLN; i++)\n    {\n      float X = (float)i;\n      float Y = A * powf(X, 1.0f / 3.0f) + B * X + CC;\n      if (i < x1)\n        lut[i] = (unsigned short)((float)i * shift);\n      else\n        lut[i] = Y < 0 ? 0 : (Y > TBLN ? TBLN : (unsigned short)(Y));\n    }\n  }\n  for (int i = 0; i < S.height * S.width; i++)\n  {\n    imgdata.image[i][0] = lut[imgdata.image[i][0]];\n    imgdata.image[i][1] = lut[imgdata.image[i][1]];\n    imgdata.image[i][2] = lut[imgdata.image[i][2]];\n    imgdata.image[i][3] = lut[imgdata.image[i][3]];\n  }\n\n  if (C.data_maximum <= TBLN)\n    C.data_maximum = lut[C.data_maximum];\n  if (C.maximum <= TBLN)\n    C.maximum = lut[C.maximum];\n  free(lut);\n}\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LIM(x, min, max) MAX(min, MIN(x, max))\n#define ULIM(x, y, z) ((y) < (z) ? LIM(x, y, z) : LIM(x, z, y))\n#define CLIP(x) LIM(x, 0, 65535)\n\nvoid LibRaw::convert_to_rgb_loop(float out_cam[3][4])\n{\n  int row, col, c;\n  float out[3];\n  ushort *img;\n  memset(libraw_internal_data.output_data.histogram, 0, sizeof(int) * LIBRAW_HISTOGRAM_SIZE * 4);\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      if (!libraw_internal_data.internal_output_params.raw_color)\n      {\n        out[0] = out[1] = out[2] = 0;\n        for (c = 0; c < imgdata.idata.colors; c++)\n        {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        for (c = 0; c < 3; c++)\n          img[c] = CLIP((int)out[c]);\n      }\n      for (c = 0; c < imgdata.idata.colors; c++)\n        libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;\n    }\n}\n\nvoid LibRaw::scale_colors_loop(float scale_mul[4])\n{\n  unsigned size = S.iheight * S.iwidth;\n\n  if (C.cblack[4] && C.cblack[5])\n  {\n    int val;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      if (!(val = imgdata.image[0][i]))\n        continue;\n      val -= C.cblack[6 + i / 4 / S.iwidth % C.cblack[4] * C.cblack[5] + i / 4 % S.iwidth % C.cblack[5]];\n      val -= C.cblack[i & 3];\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n  else if (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3])\n  {\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      int val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val -= C.cblack[i & 3];\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n  else // BL is zero\n  {\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      int val = imgdata.image[0][i];\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n}\n\nvoid LibRaw::adjust_bl()\n{\n  int clear_repeat = 0;\n  if (O.user_black >= 0)\n  {\n    C.black = O.user_black;\n    clear_repeat = 1;\n  }\n  for (int i = 0; i < 4; i++)\n    if (O.user_cblack[i] > -1000000)\n    {\n      C.cblack[i] = O.user_cblack[i];\n      clear_repeat = 1;\n    }\n\n  if (clear_repeat)\n    C.cblack[4] = C.cblack[5] = 0;\n\n  // Add common part to cblack[] early\n  if (imgdata.idata.filters > 1000 && (C.cblack[4] + 1) / 2 == 1 && (C.cblack[5] + 1) / 2 == 1)\n  {\n    int clrs[4];\n    int lastg = -1, gcnt = 0;\n    for (int c = 0; c < 4; c++)\n    {\n      clrs[c] = FC(c / 2, c % 2);\n      if (clrs[c] == 1)\n      {\n        gcnt++;\n        lastg = c;\n      }\n    }\n    if (gcnt > 1 && lastg >= 0)\n      clrs[lastg] = 3;\n    for (int c = 0; c < 4; c++)\n      C.cblack[clrs[c]] += C.cblack[6 + c / 2 % C.cblack[4] * C.cblack[5] + c % 2 % C.cblack[5]];\n    C.cblack[4] = C.cblack[5] = 0;\n    // imgdata.idata.filters = sfilters;\n  }\n  else if (imgdata.idata.filters <= 1000 && C.cblack[4] == 1 && C.cblack[5] == 1) // Fuji RAF dng\n  {\n    for (int c = 0; c < 4; c++)\n      C.cblack[c] += C.cblack[6];\n    C.cblack[4] = C.cblack[5] = 0;\n  }\n  // remove common part from C.cblack[]\n  int i = C.cblack[3];\n  int c;\n  for (c = 0; c < 3; c++)\n    if (i > C.cblack[c])\n      i = C.cblack[c];\n\n  for (c = 0; c < 4; c++)\n    C.cblack[c] -= i; // remove common part\n  C.black += i;\n\n  // Now calculate common part for cblack[6+] part and move it to C.black\n\n  if (C.cblack[4] && C.cblack[5])\n  {\n    i = C.cblack[6];\n    for (c = 1; c < C.cblack[4] * C.cblack[5]; c++)\n      if (i > C.cblack[6 + c])\n        i = C.cblack[6 + c];\n    // Remove i from cblack[6+]\n    int nonz = 0;\n    for (c = 0; c < C.cblack[4] * C.cblack[5]; c++)\n    {\n      C.cblack[6 + c] -= i;\n      if (C.cblack[6 + c])\n        nonz++;\n    }\n    C.black += i;\n    if (!nonz)\n      C.cblack[4] = C.cblack[5] = 0;\n  }\n  for (c = 0; c < 4; c++)\n    C.cblack[c] += C.black;\n}\n\nint LibRaw::dcraw_process(void)\n{\n  int quality, i;\n\n  int iterations = -1, dcb_enhance = 1, noiserd = 0;\n  int eeci_refine_fl = 0, es_med_passes_fl = 0;\n  float cared = 0, cablue = 0;\n  float linenoise = 0;\n  float lclean = 0, cclean = 0;\n  float thresh = 0;\n  float preser = 0;\n  float expos = 1.0;\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n  //    CHECK_ORDER_HIGH(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n  try\n  {\n\n    int no_crop = 1;\n\n    if (~O.cropbox[2] && ~O.cropbox[3])\n      no_crop = 0;\n\n    libraw_decoder_info_t di;\n    get_decoder_info(&di);\n\n    bool is_bayer = (imgdata.idata.filters || P1.colors == 1);\n    int subtract_inline = !O.bad_pixels && !O.dark_frame && is_bayer && !IO.zero_is_bad;\n\n    raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!\n\n    // Adjust sizes\n\n    int save_4color = O.four_color_rgb;\n\n    if (IO.zero_is_bad)\n    {\n      remove_zeroes();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);\n    }\n\n    if (O.bad_pixels && no_crop)\n    {\n      bad_pixels(O.bad_pixels);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);\n    }\n\n    if (O.dark_frame && no_crop)\n    {\n      subtract(O.dark_frame);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);\n    }\n    /* pre subtract black callback: check for it above to disable subtract inline */\n\n    if(callbacks.pre_subtractblack_cb)\n\t(callbacks.pre_subtractblack_cb)(this);\n\n    quality = 2 + !IO.fuji_width;\n\n    if (O.user_qual >= 0)\n      quality = O.user_qual;\n\n    if (!subtract_inline || !C.data_maximum)\n    {\n      adjust_bl();\n      subtract_black_internal();\n    }\n\n    if (!(di.decoder_flags & LIBRAW_DECODER_FIXEDMAXC))\n      adjust_maximum();\n\n    if (O.user_sat > 0)\n      C.maximum = O.user_sat;\n\n    if (P1.is_foveon)\n    {\n      if (load_raw == &LibRaw::x3f_load_raw)\n      {\n        // Filter out zeroes\n        for (int i = 0; i < S.height * S.width * 4; i++)\n          if ((short)imgdata.image[0][i] < 0)\n            imgdata.image[0][i] = 0;\n      }\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);\n    }\n\n    if (O.green_matching && !O.half_size)\n    {\n      green_matching();\n    }\n\n    if(callbacks.pre_scalecolors_cb)\n\t(callbacks.pre_scalecolors_cb)(this);\n\n    if (!O.no_auto_scale)\n    {\n      scale_colors();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);\n    }\n\n    if(callbacks.pre_preinterpolate_cb)\n\t(callbacks.pre_preinterpolate_cb)(this);\n\n    pre_interpolate();\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n    if (O.dcb_iterations >= 0)\n      iterations = O.dcb_iterations;\n    if (O.dcb_enhance_fl >= 0)\n      dcb_enhance = O.dcb_enhance_fl;\n    if (O.fbdd_noiserd >= 0)\n      noiserd = O.fbdd_noiserd;\n\n    /* pre-exposure correction callback */\n\n    if (O.exp_correc > 0)\n    {\n      expos = O.exp_shift;\n      preser = O.exp_preser;\n      exp_bef(expos, preser);\n    }\n\n    if(callbacks.pre_interpolate_cb)\n\t(callbacks.pre_interpolate_cb)(this);\n\n    /* post-exposure correction fallback */\n    if (P1.filters && !O.no_interpolation)\n    {\n      if (noiserd > 0 && P1.colors == 3 && P1.filters)\n        fbdd(noiserd);\n\n      if (P1.filters > 1000 && callbacks.interpolate_bayer_cb)\n        (callbacks.interpolate_bayer_cb)(this);\n      else if (P1.filters == 9 && callbacks.interpolate_xtrans_cb)\n        (callbacks.interpolate_xtrans_cb)(this);\n      else if (quality == 0)\n        lin_interpolate();\n      else if (quality == 1 || P1.colors > 3)\n        vng_interpolate();\n      else if (quality == 2 && P1.filters > 1000)\n        ppg_interpolate();\n      else if (P1.filters == LIBRAW_XTRANS)\n      {\n        // Fuji X-Trans\n        xtrans_interpolate(quality > 2 ? 3 : 1);\n      }\n      else if (quality == 3)\n        ahd_interpolate(); // really don't need it here due to fallback op\n      else if (quality == 4)\n        dcb(iterations, dcb_enhance);\n\n      else if (quality == 11)\n        dht_interpolate();\n      else if (quality == 12)\n        aahd_interpolate();\n      // fallback to AHD\n      else\n      {\n        ahd_interpolate();\n        imgdata.process_warnings |= LIBRAW_WARN_FALLBACK_TO_AHD;\n      }\n\n      SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);\n    }\n    if (IO.mix_green)\n    {\n      for (P1.colors = 3, i = 0; i < S.height * S.width; i++)\n        imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);\n    }\n\n    if(callbacks.post_interpolate_cb)\n\t(callbacks.post_interpolate_cb)(this);\n\n    if (!P1.is_foveon)\n    {\n      if (P1.colors == 3)\n      {\n\n        /* median filter callback, if not set use own */\n        median_filter();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);\n      }\n    }\n\n    if (O.highlight == 2)\n    {\n      blend_highlights();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n    }\n\n    if (O.highlight > 2)\n    {\n      recover_highlights();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n    }\n\n    if (O.use_fuji_rotate)\n    {\n      fuji_rotate();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n    }\n\n    if (!libraw_internal_data.output_data.histogram)\n    {\n      libraw_internal_data.output_data.histogram =\n          (int(*)[LIBRAW_HISTOGRAM_SIZE])malloc(sizeof(*libraw_internal_data.output_data.histogram) * 4);\n      merror(libraw_internal_data.output_data.histogram, \"LibRaw::dcraw_process()\");\n    }\n#ifndef NO_LCMS\n    if (O.camera_profile)\n    {\n      apply_profile(O.camera_profile, O.output_profile);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);\n    }\n#endif\n\n    if(callbacks.pre_converttorgb_cb)\n\t(callbacks.pre_converttorgb_cb)(this);\n\n    convert_to_rgb();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);\n\n    if(callbacks.post_converttorgb_cb)\n\t(callbacks.post_converttorgb_cb)(this);\n\n    if (O.use_fuji_rotate)\n    {\n      stretch();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);\n    }\n    O.four_color_rgb = save_4color; // also, restore\n\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n// clang-format off\n// Supported cameras:\nstatic const char *static_camera_list[] = {\n\t\"Adobe Digital Negative (DNG)\",\n\t\"AgfaPhoto DC-833m\",\n\t\"Alcatel 5035D\",\n\t\"Apple iPad Pro\",\n\t\"Apple iPhone SE\",\n\t\"Apple iPhone 6s\",\n\t\"Apple iPhone 6 plus\",\n\t\"Apple iPhone 7\",\n\t\"Apple iPhone 7 plus\",\n\t\"Apple iPhone 8\",\n\t\"Apple iPhone 8 plus\",\n\t\"Apple iPhone X\",\n\t\"Apple QuickTake 100\",\n\t\"Apple QuickTake 150\",\n\t\"Apple QuickTake 200\",\n\t\"ARRIRAW format\",\n\t\"AVT F-080C\",\n\t\"AVT F-145C\",\n\t\"AVT F-201C\",\n\t\"AVT F-510C\",\n\t\"AVT F-810C\",\n\t\"Baumer TXG14\",\n\t\"BlackMagic Cinema Camera\",\n\t\"BlackMagic Micro Cinema Camera\",\n\t\"BlackMagic Pocket Cinema Camera\",\n\t\"BlackMagic Production Camera 4k\",\n\t\"BlackMagic URSA\",\n\t\"BlackMagic URSA Mini 4k\",\n\t\"BlackMagic URSA Mini 4.6k\",\n\t\"BlackMagic URSA Mini Pro 4.6k\",\n\t\"Canon PowerShot 600\",\n\t\"Canon PowerShot A5\",\n\t\"Canon PowerShot A5 Zoom\",\n\t\"Canon PowerShot A50\",\n\t\"Canon PowerShot A410 (CHDK hack)\",\n\t\"Canon PowerShot A460 (CHDK hack)\",\n\t\"Canon PowerShot A470 (CHDK hack)\",\n\t\"Canon PowerShot A530 (CHDK hack)\",\n\t\"Canon PowerShot A540 (CHDK hack)\",\n\t\"Canon PowerShot A550 (CHDK hack)\",\n\t\"Canon PowerShot A570 (CHDK hack)\",\n\t\"Canon PowerShot A590 (CHDK hack)\",\n\t\"Canon PowerShot A610 (CHDK hack)\",\n\t\"Canon PowerShot A620 (CHDK hack)\",\n\t\"Canon PowerShot A630 (CHDK hack)\",\n\t\"Canon PowerShot A640 (CHDK hack)\",\n\t\"Canon PowerShot A650 (CHDK hack)\",\n\t\"Canon PowerShot A710 IS (CHDK hack)\",\n\t\"Canon PowerShot A720 IS (CHDK hack)\",\n\t\"Canon PowerShot A3300 IS (CHDK hack)\",\n\t\"Canon PowerShot D10 (CHDK hack)\",\n\t\"Canon PowerShot ELPH 130 IS (CHDK hack)\",\n\t\"Canon PowerShot ELPH 160 IS (CHDK hack)\",\n\t\"Canon PowerShot Pro70\",\n\t\"Canon PowerShot Pro90 IS\",\n\t\"Canon PowerShot Pro1\",\n\t\"Canon PowerShot G1\",\n\t\"Canon PowerShot G1 X\",\n\t\"Canon PowerShot G1 X Mark II\",\n\t\"Canon PowerShot G1 X Mark III\",\n\t\"Canon PowerShot G2\",\n\t\"Canon PowerShot G3\",\n\t\"Canon PowerShot G3 X\",\n\t\"Canon PowerShot G5\",\n\t\"Canon PowerShot G5 X\",\n\t\"Canon PowerShot G6\",\n\t\"Canon PowerShot G7 (CHDK hack)\",\n\t\"Canon PowerShot G7 X\",\n\t\"Canon PowerShot G7 X Mark II\",\n\t\"Canon PowerShot G9\",\n\t\"Canon PowerShot G9 X\",\n\t\"Canon PowerShot G9 X Mark II\",\n\t\"Canon PowerShot G10\",\n\t\"Canon PowerShot G11\",\n\t\"Canon PowerShot G12\",\n\t\"Canon PowerShot G15\",\n\t\"Canon PowerShot G16\",\n\t\"Canon PowerShot S2 IS (CHDK hack)\",\n\t\"Canon PowerShot S3 IS (CHDK hack)\",\n\t\"Canon PowerShot S5 IS (CHDK hack)\",\n\t\"Canon PowerShot SD300 (CHDK hack)\",\n\t\"Canon PowerShot SD750 (CHDK hack)\",\n\t\"Canon PowerShot SD950 (CHDK hack)\",\n\t\"Canon PowerShot S30\",\n\t\"Canon PowerShot S40\",\n\t\"Canon PowerShot S45\",\n\t\"Canon PowerShot S50\",\n\t\"Canon PowerShot S60\",\n\t\"Canon PowerShot S70\",\n\t\"Canon PowerShot S90\",\n\t\"Canon PowerShot S95\",\n\t\"Canon PowerShot S100\",\n\t\"Canon PowerShot S110\",\n\t\"Canon PowerShot S120\",\n\t\"Canon PowerShot SX1 IS\",\n\t\"Canon PowerShot SX50 HS\",\n\t\"Canon PowerShot SX60 HS\",\n\t\"Canon PowerShot SX100 IS (CHDK hack)\",\n\t\"Canon PowerShot SX110 IS (CHDK hack)\",\n\t\"Canon PowerShot SX120 IS (CHDK hack)\",\n\t\"Canon PowerShot SX130 IS (CHDK hack)\",\n\t\"Canon PowerShot SX160 IS (CHDK hack)\",\n\t\"Canon PowerShot SX220 HS (CHDK hack)\",\n\t\"Canon PowerShot SX510 HS (CHDK hack)\",\n\t\"Canon PowerShot SX10 IS (CHDK hack)\",\n\t\"Canon PowerShot SX20 IS (CHDK hack)\",\n\t\"Canon PowerShot SX30 IS (CHDK hack)\",\n\t\"Canon PowerShot IXUS 160 (CHDK hack)\",\n\t\"Canon PowerShot IXUS 900Ti (CHDK hack)\",\n\t\"Canon EOS D30\",\n\t\"Canon EOS D60\",\n\t\"Canon EOS 5D\",\n\t\"Canon EOS 5DS\",\n\t\"Canon EOS 5DS R\",\n\t\"Canon EOS 5D Mark II\",\n\t\"Canon EOS 5D Mark III\",\n\t\"Canon EOS 5D Mark IV\",\n\t\"Canon EOS 6D\",\n\t\"Canon EOS 6D Mark II\",\n\t\"Canon EOS 7D\",\n\t\"Canon EOS 7D Mark II\",\n\t\"Canon EOS 10D\",\n\t\"Canon EOS 20D\",\n\t\"Canon EOS 20Da\",\n\t\"Canon EOS 30D\",\n\t\"Canon EOS 40D\",\n\t\"Canon EOS 50D\",\n\t\"Canon EOS 60D\",\n\t\"Canon EOS 60Da\",\n\t\"Canon EOS 70D\",\n\t\"Canon EOS 77D\",\n\t\"Canon EOS 80D\",\n\t\"Canon EOS 200D\",\n\t\"Canon EOS 300D / Digital Rebel / Kiss Digital\",\n\t\"Canon EOS 350D / Digital Rebel XT / Kiss Digital N\",\n\t\"Canon EOS 400D / Digital Rebel XTi / Kiss Digital X\",\n\t\"Canon EOS 450D / Digital Rebel XSi / Kiss Digital X2\",\n\t\"Canon EOS 500D / Digital Rebel T1i / Kiss Digital X3\",\n\t\"Canon EOS 550D / Digital Rebel T2i / Kiss Digital X4\",\n\t\"Canon EOS 600D / Digital Rebel T3i / Kiss Digital X5\",\n\t\"Canon EOS 650D / Digital Rebel T4i / Kiss Digital X6i\",\n\t\"Canon EOS 700D / Digital Rebel T5i\",\n\t\"Canon EOS 750D / Digital Rebel T6i\",\n\t\"Canon EOS 760D / Digital Rebel T6S\",\n\t\"Canon EOS 800D\",\n\t\"Canon EOS 100D / Digital Rebel SL1\",\n\t\"Canon EOS 1000D / Digital Rebel XS / Kiss Digital F\",\n\t\"Canon EOS 1100D / Digital Rebel T3 / Kiss Digital X50\",\n\t\"Canon EOS 1200D\",\n\t\"Canon EOS 1300D\",\n\t\"Canon EOS C500\",\n\t\"Canon EOS D2000C\",\n\t\"Canon EOS M\",\n\t\"Canon EOS M2\",\n\t\"Canon EOS M3\",\n\t\"Canon EOS M5\",\n\t\"Canon EOS M6\",\n\t\"Canon EOS M10\",\n\t\"Canon EOS M100\",\n\t\"Canon EOS-1D\",\n\t\"Canon EOS-1DS\",\n\t\"Canon EOS-1D C\",\n\t\"Canon EOS-1D X\",\n\t\"Canon EOS-1D Mark II\",\n\t\"Canon EOS-1D Mark II N\",\n\t\"Canon EOS-1D Mark III\",\n\t\"Canon EOS-1D Mark IV\",\n\t\"Canon EOS-1Ds Mark II\",\n\t\"Canon EOS-1Ds Mark III\",\n\t\"Canon EOS-1D X Mark II\",\n\t\"Casio QV-2000UX\",\n\t\"Casio QV-3000EX\",\n\t\"Casio QV-3500EX\",\n\t\"Casio QV-4000\",\n\t\"Casio QV-5700\",\n\t\"Casio QV-R41\",\n\t\"Casio QV-R51\",\n\t\"Casio QV-R61\",\n\t\"Casio EX-F1\",\n\t\"Casio EX-FC300S\",\n\t\"Casio EX-FC400S\",\n\t\"Casio EX-FH20\",\n\t\"Casio EX-FH25\",\n\t\"Casio EX-FH100\",\n\t\"Casio EX-P600\",\n\t\"Casio EX-S20\",\n\t\"Casio EX-S100\",\n\t\"Casio EX-Z4\",\n\t\"Casio EX-Z50\",\n\t\"Casio EX-Z500\",\n\t\"Casio EX-Z55\",\n\t\"Casio EX-Z60\",\n\t\"Casio EX-Z75\",\n\t\"Casio EX-Z750\",\n\t\"Casio EX-Z8\",\n\t\"Casio EX-Z850\",\n\t\"Casio EX-Z1050\",\n\t\"Casio EX-ZR100\",\n\t\"Casio EX-Z1080\",\n\t\"Casio EX-ZR700\",\n\t\"Casio EX-ZR710\",\n\t\"Casio EX-ZR750\",\n\t\"Casio EX-ZR800\",\n\t\"Casio EX-ZR850\",\n\t\"Casio EX-ZR1000\",\n\t\"Casio EX-ZR1100\",\n\t\"Casio EX-ZR1200\",\n\t\"Casio EX-ZR1300\",\n\t\"Casio EX-ZR1500\",\n\t\"Casio EX-ZR3000\",\n\t\"Casio EX-ZR4000/5000\",\n\t\"Casio EX-ZR4100/5100\",\n\t\"Casio EX-100\",\n\t\"Casio EX-100F\",\n\t\"Casio EX-10\",\n\t\"Casio Exlim Pro 505\",\n\t\"Casio Exlim Pro 600\",\n\t\"Casio Exlim Pro 700\",\n\t\"Contax N Digital\",\n\t\"Creative PC-CAM 600\",\n\t\"Digital Bolex D16\",\n\t\"Digital Bolex D16M\",\n\t\"DJI 4384x3288\",\n\t\"DJI Phantom4 Pro/Pro+\",\n\t\"DJI Zenmuse X5\",\n\t\"DJI Zenmuse X5R\",\n\t\"DXO One\",\n\t\"Epson R-D1\",\n\t\"Epson R-D1s\",\n\t\"Epson R-D1x\",\n\t\"Foculus 531C\",\n\t\"FujiFilm E505\",\n\t\"FujiFilm E550\",\n\t\"FujiFilm E900\",\n\t\"FujiFilm F700\",\n\t\"FujiFilm F710\",\n\t\"FujiFilm F800\",\n\t\"FujiFilm F810\",\n\t\"FujiFilm S2Pro\",\n\t\"FujiFilm S3Pro\",\n\t\"FujiFilm S5Pro\",\n\t\"FujiFilm S20Pro\",\n\t\"FujiFilm S1\",\n\t\"FujiFilm S100FS\",\n\t\"FujiFilm S5000\",\n\t\"FujiFilm S5100/S5500\",\n\t\"FujiFilm S5200/S5600\",\n\t\"FujiFilm S6000fd\",\n\t\"FujiFilm S6500fd\",\n\t\"FujiFilm S7000\",\n\t\"FujiFilm S9000/S9500\",\n\t\"FujiFilm S9100/S9600\",\n\t\"FujiFilm S200EXR\",\n\t\"FujiFilm S205EXR\",\n\t\"FujiFilm SL1000\",\n\t\"FujiFilm HS10/HS11\",\n\t\"FujiFilm HS20EXR\",\n\t\"FujiFilm HS22EXR\",\n\t\"FujiFilm HS30EXR\",\n\t\"FujiFilm HS33EXR\",\n\t\"FujiFilm HS35EXR\",\n\t\"FujiFilm HS50EXR\",\n\t\"FujiFilm F505EXR\",\n\t\"FujiFilm F550EXR\",\n\t\"FujiFilm F600EXR\",\n\t\"FujiFilm F605EXR\",\n\t\"FujiFilm F770EXR\",\n\t\"FujiFilm F775EXR\",\n\t\"FujiFilm F800EXR\",\n\t\"FujiFilm F900EXR\",\n\t\"FujiFilm GFX 50S\",\n\t\"FujiFilm X-Pro1\",\n\t\"FujiFilm X-Pro2\",\n\t\"FujiFilm X-S1\",\n\t\"FujiFilm XQ1\",\n\t\"FujiFilm XQ2\",\n\t\"FujiFilm X100\",\n\t\"FujiFilm X100f\",\n\t\"FujiFilm X100S\",\n\t\"FujiFilm X100T\",\n\t\"FujiFilm X10\",\n\t\"FujiFilm X20\",\n\t\"FujiFilm X30\",\n\t\"FujiFilm X70\",\n\t\"FujiFilm X-A1\",\n\t\"FujiFilm X-A2\",\n\t\"FujiFilm X-A3\",\n\t\"FujiFilm X-A5\",\n\t\"FujiFilm X-A10\",\n\t\"FujiFilm X-A20\",\n\t\"FujiFilm X-E1\",\n\t\"FujiFilm X-E2\",\n\t\"FujiFilm X-E2S\",\n\t\"FujiFilm X-E3\",\n\t\"FujiFilm X-M1\",\n\t\"FujiFilm XF1\",\n\t\"FujiFilm X-H1\",\n\t\"FujiFilm X-T1\",\n\t\"FujiFilm X-T1 Graphite Silver\",\n\t\"FujiFilm X-T2\",\n\t\"FujiFilm X-T10\",\n\t\"FujiFilm X-T20\",\n\t\"FujiFilm IS-1\",\n\t\"Gione E7\",\n\t\"GITUP GIT2\",\n\t\"GITUP GIT2P\",\n\t\"Google Pixel\",\n\t\"Google Pixel XL\",\n\t\"Hasselblad H2D-22\",\n\t\"Hasselblad H2D-39\",\n\t\"Hasselblad H3DII-22\",\n\t\"Hasselblad H3DII-31\",\n\t\"Hasselblad H3DII-39\",\n\t\"Hasselblad H3DII-50\",\n\t\"Hasselblad H3D-22\",\n\t\"Hasselblad H3D-31\",\n\t\"Hasselblad H3D-39\",\n\t\"Hasselblad H4D-60\",\n\t\"Hasselblad H4D-50\",\n\t\"Hasselblad H4D-40\",\n\t\"Hasselblad H4D-31\",\n\t\"Hasselblad H5D-60\",\n\t\"Hasselblad H5D-50\",\n\t\"Hasselblad H5D-50c\",\n\t\"Hasselblad H5D-40\",\n\t\"Hasselblad H6D-100c\",\n\t\"Hasselblad A6D-100c\", // Aerial camera\n\t\"Hasselblad CFV\",\n\t\"Hasselblad CFV-50\",\n\t\"Hasselblad CFH\",\n\t\"Hasselblad CF-22\",\n\t\"Hasselblad CF-31\",\n\t\"Hasselblad CF-39\",\n\t\"Hasselblad V96C\",\n\t\"Hasselblad Lusso\",\n\t\"Hasselblad Lunar\",\n\t\"Hasselblad True Zoom\",\n\t\"Hasselblad Stellar\",\n\t\"Hasselblad Stellar II\",\n\t\"Hasselblad HV\",\n\t\"Hasselblad X1D\",\n\t\"HTC UltraPixel\",\n\t\"HTC MyTouch 4G\",\n\t\"HTC One (A9)\",\n\t\"HTC One (M9)\",\n\t\"HTC 10\",\n\t\"Huawei P9 (EVA-L09/AL00)\",\n\t\"Huawei Honor6a\",\n\t\"Huawei Honor9\",\n\t\"Huawei Mate10 (BLA-L29)\",\n\t\"Imacon Ixpress 96, 96C\",\n\t\"Imacon Ixpress 384, 384C (single shot only)\",\n\t\"Imacon Ixpress 132C\",\n\t\"Imacon Ixpress 528C (single shot only)\",\n\t\"ISG 2020x1520\",\n\t\"Ikonoskop A-Cam dII Panchromatic\",\n\t\"Ikonoskop A-Cam dII\",\n\t\"Kinefinity KineMINI\",\n\t\"Kinefinity KineRAW Mini\",\n\t\"Kinefinity KineRAW S35\",\n\t\"Kodak DC20\",\n\t\"Kodak DC25\",\n\t\"Kodak DC40\",\n\t\"Kodak DC50\",\n\t\"Kodak DC120\",\n\t\"Kodak DCS200\",\n\t\"Kodak DCS315C\",\n\t\"Kodak DCS330C\",\n\t\"Kodak DCS420\",\n\t\"Kodak DCS460\",\n\t\"Kodak DCS460A\",\n\t\"Kodak DCS460D\",\n\t\"Kodak DCS520C\",\n\t\"Kodak DCS560C\",\n\t\"Kodak DCS620C\",\n\t\"Kodak DCS620X\",\n\t\"Kodak DCS660C\",\n\t\"Kodak DCS660M\",\n\t\"Kodak DCS720X\",\n\t\"Kodak DCS760C\",\n\t\"Kodak DCS760M\",\n\t\"Kodak EOSDCS1\",\n\t\"Kodak EOSDCS3B\",\n\t\"Kodak NC2000F\",\n\t\"Kodak ProBack\",\n\t\"Kodak PB645C\",\n\t\"Kodak PB645H\",\n\t\"Kodak PB645M\",\n\t\"Kodak DCS Pro 14n\",\n\t\"Kodak DCS Pro 14nx\",\n\t\"Kodak DCS Pro SLR/c\",\n\t\"Kodak DCS Pro SLR/n\",\n\t\"Kodak C330\",\n\t\"Kodak C603\",\n\t\"Kodak P850\",\n\t\"Kodak P880\",\n\t\"Kodak S-1\",\n\t\"Kodak Z980\",\n\t\"Kodak Z981\",\n\t\"Kodak Z990\",\n\t\"Kodak Z1015\",\n\t\"Kodak KAI-0340\",\n\t\"Konica KD-400Z\",\n\t\"Konica KD-510Z\",\n\t\"Leaf AFi 5\",\n\t\"Leaf AFi 6\",\n\t\"Leaf AFi 7\",\n\t\"Leaf AFi-II 6\",\n\t\"Leaf AFi-II 7\",\n\t\"Leaf AFi-II 10\",\n\t\"Leaf AFi-II 10R\",\n\t\"Leaf Aptus-II 5\",\n\t\"Leaf Aptus-II 6\",\n\t\"Leaf Aptus-II 7\",\n\t\"Leaf Aptus-II 8\",\n\t\"Leaf Aptus-II 10\",\n\t\"Leaf Aptus-II 12\",\n\t\"Leaf Aptus-II 12R\",\n\t\"Leaf Aptus 17\",\n\t\"Leaf Aptus 22\",\n\t\"Leaf Aptus 54S\",\n\t\"Leaf Aptus 65\",\n\t\"Leaf Aptus 65S\",\n\t\"Leaf Aptus 75\",\n\t\"Leaf Aptus 75S\",\n\t\"Leaf Cantare\",\n\t\"Leaf Cantare XY\",\n\t\"Leaf CatchLight\",\n\t\"Leaf CMost\",\n\t\"Leaf Credo 40\",\n\t\"Leaf Credo 50\",\n\t\"Leaf Credo 60\",\n\t\"Leaf Credo 80 (low compression mode only)\",\n\t\"Leaf DCB-II\",\n\t\"Leaf Valeo 6\",\n\t\"Leaf Valeo 11\",\n\t\"Leaf Valeo 17\",\n\t\"Leaf Valeo 17wi\",\n\t\"Leaf Valeo 22\",\n\t\"Leaf Valeo 22wi\",\n\t\"Leaf Volare\",\n\t\"Lenovo a820\",\n\t\"Leica C (Typ 112)\",\n\t\"Leica CL\",\n\t\"Leica Digilux 2\",\n\t\"Leica Digilux 3\",\n\t\"Leica Digital-Modul-R\",\n\t\"Leica D-LUX2\",\n\t\"Leica D-LUX3\",\n\t\"Leica D-LUX4\",\n\t\"Leica D-LUX5\",\n\t\"Leica D-LUX6\",\n\t\"Leica D-Lux (Typ 109)\",\n\t\"Leica M8\",\n\t\"Leica M8.2\",\n\t\"Leica M9\",\n\t\"Leica M10\",\n\t\"Leica M (Typ 240)\",\n\t\"Leica M (Typ 262)\",\n\t\"Leica Monochrom (Typ 240)\",\n\t\"Leica Monochrom (Typ 246)\",\n\t\"Leica M-D (Typ 262)\",\n\t\"Leica M-E\",\n\t\"Leica M-P\",\n\t\"Leica R8\",\n\t\"Leica Q (Typ 116)\",\n\t\"Leica S\",\n\t\"Leica S2\",\n\t\"Leica S (Typ 007)\",\n\t\"Leica SL (Typ 601)\",\n\t\"Leica T (Typ 701)\",\n\t\"Leica TL\",\n\t\"Leica TL2\",\n\t\"Leica X1\",\n\t\"Leica X (Typ 113)\",\n\t\"Leica X2\",\n\t\"Leica X-E (Typ 102)\",\n\t\"Leica X-U (Typ 113)\",\n\t\"Leica V-LUX1\",\n\t\"Leica V-LUX2\",\n\t\"Leica V-LUX3\",\n\t\"Leica V-LUX4\",\n\t\"Leica V-Lux (Typ 114)\",\n\t\"Leica X VARIO (Typ 107)\",\n\t\"LG G3\",\n\t\"LG G4\",\n\t\"LG V20 (F800K)\",\n\t\"LG VS995\",\n\t\"Logitech Fotoman Pixtura\",\n\t\"Mamiya ZD\",\n\t\"Matrix 4608x3288\",\n\t\"Meizy MX4\",\n\t\"Micron 2010\",\n\t\"Minolta RD175\",\n\t\"Minolta DiMAGE 5\",\n\t\"Minolta DiMAGE 7\",\n\t\"Minolta DiMAGE 7i\",\n\t\"Minolta DiMAGE 7Hi\",\n\t\"Minolta DiMAGE A1\",\n\t\"Minolta DiMAGE A2\",\n\t\"Minolta DiMAGE A200\",\n\t\"Minolta DiMAGE G400\",\n\t\"Minolta DiMAGE G500\",\n\t\"Minolta DiMAGE G530\",\n\t\"Minolta DiMAGE G600\",\n\t\"Minolta DiMAGE Z2\",\n\t\"Minolta Alpha/Dynax/Maxxum 5D\",\n\t\"Minolta Alpha/Dynax/Maxxum 7D\",\n\t\"Motorola PIXL\",\n\t\"Nikon D1\",\n\t\"Nikon D1H\",\n\t\"Nikon D1X\",\n\t\"Nikon D2H\",\n\t\"Nikon D2Hs\",\n\t\"Nikon D2X\",\n\t\"Nikon D2Xs\",\n\t\"Nikon D3\",\n\t\"Nikon D3s\",\n\t\"Nikon D3X\",\n\t\"Nikon D4\",\n\t\"Nikon D4s\",\n\t\"Nikon D40\",\n\t\"Nikon D40X\",\n\t\"Nikon D5\",\n\t\"Nikon D50\",\n\t\"Nikon D60\",\n\t\"Nikon D70\",\n\t\"Nikon D70s\",\n\t\"Nikon D80\",\n\t\"Nikon D90\",\n\t\"Nikon D100\",\n\t\"Nikon D200\",\n\t\"Nikon D300\",\n\t\"Nikon D300s\",\n\t\"Nikon D500\",\n\t\"Nikon D600\",\n\t\"Nikon D610\",\n\t\"Nikon D700\",\n\t\"Nikon D750\",\n\t\"Nikon D800\",\n\t\"Nikon D800E\",\n\t\"Nikon D810\",\n\t\"Nikon D810A\",\n\t\"Nikon D850\",\n\t\"Nikon D3000\",\n\t\"Nikon D3100\",\n\t\"Nikon D3200\",\n\t\"Nikon D3300\",\n\t\"Nikon D3400\",\n\t\"Nikon D5000\",\n\t\"Nikon D5100\",\n\t\"Nikon D5200\",\n\t\"Nikon D5300\",\n\t\"Nikon D5500\",\n\t\"Nikon D5600\",\n\t\"Nikon D7000\",\n\t\"Nikon D7100\",\n\t\"Nikon D7200\",\n\t\"Nikon D7500\",\n\t\"Nikon Df\",\n\t\"Nikon 1 AW1\",\n\t\"Nikon 1 J1\",\n\t\"Nikon 1 J2\",\n\t\"Nikon 1 J3\",\n\t\"Nikon 1 J4\",\n\t\"Nikon 1 J5\",\n\t\"Nikon 1 S1\",\n\t\"Nikon 1 S2\",\n\t\"Nikon 1 V1\",\n\t\"Nikon 1 V2\",\n\t\"Nikon 1 V3\",\n\t\"Nikon E700 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E800 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E880 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E900 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E950 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E990 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E995 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E2100 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E2500 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E3200 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E3700 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E4300 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E4500 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon E5000\",\n\t\"Nikon E5400\",\n\t\"Nikon E5700\",\n\t\"Nikon E8400\",\n\t\"Nikon E8700\",\n\t\"Nikon E8800\",\n\t\"Nikon Coolpix A\",\n\t\"Nikon Coolpix B700\",\n\t\"Nikon Coolpix P330\",\n\t\"Nikon Coolpix P340\",\n\t\"Nikon Coolpix P6000\",\n\t\"Nikon Coolpix P7000\",\n\t\"Nikon Coolpix P7100\",\n\t\"Nikon Coolpix P7700\",\n\t\"Nikon Coolpix P7800\",\n\t\"Nikon Coolpix S6 (\\\"DIAG RAW\\\" hack)\",\n\t\"Nikon Coolscan NEF\",\n\t\"Nokia N95\",\n\t\"Nokia X2\",\n\t\"Nokia 1200x1600\",\n\t\"Nokia Lumia 950 XL\",\n\t\"Nokia Lumia 1020\",\n\t\"Nokia Lumia 1520\",\n\t\"Olympus AIR A01\",\n\t\"Olympus C3030Z\",\n\t\"Olympus C5050Z\",\n\t\"Olympus C5060Z\",\n\t\"Olympus C7070WZ\",\n\t\"Olympus C70Z,C7000Z\",\n\t\"Olympus C740UZ\",\n\t\"Olympus C770UZ\",\n\t\"Olympus C8080WZ\",\n\t\"Olympus X200,D560Z,C350Z\",\n\t\"Olympus E-1\",\n\t\"Olympus E-3\",\n\t\"Olympus E-5\",\n\t\"Olympus E-10\",\n\t\"Olympus E-20\",\n\t\"Olympus E-30\",\n\t\"Olympus E-300\",\n\t\"Olympus E-330\",\n\t\"Olympus E-400\",\n\t\"Olympus E-410\",\n\t\"Olympus E-420\",\n\t\"Olympus E-450\",\n\t\"Olympus E-500\",\n\t\"Olympus E-510\",\n\t\"Olympus E-520\",\n\t\"Olympus E-600\",\n\t\"Olympus E-620\",\n\t\"Olympus E-P1\",\n\t\"Olympus E-P2\",\n\t\"Olympus E-P3\",\n\t\"Olympus E-P5\",\n\t\"Olympus E-PL1\",\n\t\"Olympus E-PL1s\",\n\t\"Olympus E-PL2\",\n\t\"Olympus E-PL3\",\n\t\"Olympus E-PL5\",\n\t\"Olympus E-PL6\",\n\t\"Olympus E-PL7\",\n\t\"Olympus E-PL8\",\n\t\"Olympus E-PL9\",\n\t\"Olympus E-PM1\",\n\t\"Olympus E-PM2\",\n\t\"Olympus E-M1\",\n\t\"Olympus E-M1 Mark II\",\n\t\"Olympus E-M10\",\n\t\"Olympus E-M10 Mark II\",\n\t\"Olympus E-M10 Mark III\",\n\t\"Olympus E-M5\",\n\t\"Olympus E-M5 Mark II\",\n\t\"Olympus Pen F\",\n\t\"Olympus SP310\",\n\t\"Olympus SP320\",\n\t\"Olympus SP350\",\n\t\"Olympus SP500UZ\",\n\t\"Olympus SP510UZ\",\n\t\"Olympus SP550UZ\",\n\t\"Olympus SP560UZ\",\n\t\"Olympus SP565UZ\",\n\t\"Olympus SP570UZ\",\n\t\"Olympus STYLUS1\",\n\t\"Olympus STYLUS1s\",\n\t\"Olympus SH-2\",\n\t\"Olympus SH-3\",\n\t\"Olympus TG-4\",\n\t\"Olympus TG-5\",\n\t\"Olympus XZ-1\",\n\t\"Olympus XZ-2\",\n\t\"Olympus XZ-10\",\n\t\"OmniVision 4688\",\n\t\"OmniVision OV5647\",\n\t\"OmniVision OV5648\",\n\t\"OmniVision OV8850\",\n\t\"OmniVision 13860\",\n        \"OnePlus One\",\n        \"OnePlus A3303\",\n        \"OnePlus A5000\",\n\t\"Panasonic DMC-CM1\",\n\t\"Panasonic DMC-FZ8\",\n\t\"Panasonic DMC-FZ18\",\n\t\"Panasonic DMC-FZ28\",\n\t\"Panasonic DMC-FZ30\",\n\t\"Panasonic DMC-FZ35/FZ38\",\n\t\"Panasonic DMC-FZ40\",\n\t\"Panasonic DMC-FZ45\",\n\t\"Panasonic DMC-FZ50\",\n\t\"Panasonic DMC-FZ7\",\n\t\"Panasonic DMC-FZ70\",\n\t\"Panasonic DMC-FZ72\",\n\t\"Panasonic DC-FZ80/82\",\n\t\"Panasonic DMC-FZ100\",\n\t\"Panasonic DMC-FZ150\",\n\t\"Panasonic DMC-FZ200\",\n\t\"Panasonic DMC-FZ300/330\",\n\t\"Panasonic DMC-FZ1000\",\n\t\"Panasonic DMC-FZ2000/2500/FZH1\",\n\t\"Panasonic DMC-FX150\",\n\t\"Panasonic DMC-G1\",\n\t\"Panasonic DMC-G10\",\n\t\"Panasonic DMC-G2\",\n\t\"Panasonic DMC-G3\",\n\t\"Panasonic DMC-G5\",\n\t\"Panasonic DMC-G6\",\n\t\"Panasonic DMC-G7/G70\",\n\t\"Panasonic DMC-G8/80/81/85\",\n\t\"Panasonic DC-G9\",\n\t\"Panasonic DMC-GF1\",\n\t\"Panasonic DMC-GF2\",\n\t\"Panasonic DMC-GF3\",\n\t\"Panasonic DMC-GF5\",\n\t\"Panasonic DMC-GF6\",\n\t\"Panasonic DMC-GF7\",\n\t\"Panasonic DC-GF10/GF90\",\n\t\"Panasonic DMC-GH1\",\n\t\"Panasonic DMC-GH2\",\n\t\"Panasonic DMC-GH3\",\n\t\"Panasonic DMC-GH4\",\n\t\"Panasonic AG-GH4\",\n\t\"Panasonic DC-GH5\",\n\t\"Panasonic DMC-GM1\",\n\t\"Panasonic DMC-GM1s\",\n\t\"Panasonic DMC-GM5\",\n\t\"Panasonic DMC-GX1\",\n\t\"Panasonic DMC-GX7\",\n\t\"Panasonic DMC-GX8\",\n\t\"Panasonic DC-GX9\",\n\t\"Panasonic DMC-GX80/85\",\n\t\"Panasonic DC-GX800/850/GF9\",\n\t\"Panasonic DMC-L1\",\n\t\"Panasonic DMC-L10\",\n\t\"Panasonic DMC-LC1\",\n\t\"Panasonic DMC-LF1\",\n\t\"Panasonic DMC-LX1\",\n\t\"Panasonic DMC-LX2\",\n\t\"Panasonic DMC-LX3\",\n\t\"Panasonic DMC-LX5\",\n\t\"Panasonic DMC-LX7\",\n\t\"Panasonic DMC-LX9/10/15\",\n\t\"Panasonic DMC-LX100\",\n\t\"Panasonic DMC-TZ60/61/SZ40\",\n\t\"Panasonic DMC-TZ70/71/ZS50\",\n\t\"Panasonic DMC-TZ80/81/85/ZS60\",\n\t\"Panasonic DC-ZS70 (DC-TZ90/91/92, DC-T93)\",\n\t\"Panasonic DC-TZ100/101/ZS100\",\n\t\"Panasonic DC-TZ200/ZS200\",\n\t\"PARROT Bebop 2\",\n\t\"PARROT Bebop Drone\",\n\t\"Pentax *ist D\",\n\t\"Pentax *ist DL\",\n\t\"Pentax *ist DL2\",\n\t\"Pentax *ist DS\",\n\t\"Pentax *ist DS2\",\n\t\"Pentax GR\",\n\t\"Pentax K10D\",\n\t\"Pentax K20D\",\n\t\"Pentax K100D\",\n\t\"Pentax K100D Super\",\n\t\"Pentax K110D\",\n\t\"Pentax K200D\",\n\t\"Pentax K2000/K-m\",\n\t\"Pentax KP\",\n\t\"Pentax K-x\",\n\t\"Pentax K-r\",\n\t\"Pentax K-01\",\n\t\"Pentax K-1\",\n\t\"Pentax K-3\",\n\t\"Pentax K-3 II\",\n\t\"Pentax K-30\",\n\t\"Pentax K-5\",\n\t\"Pentax K-5 II\",\n\t\"Pentax K-5 IIs\",\n\t\"Pentax K-50\",\n\t\"Pentax K-500\",\n\t\"Pentax K-7\",\n\t\"Pentax K-70\",\n\t\"Pentax K-S1\",\n\t\"Pentax K-S2\",\n\t\"Pentax MX-1\",\n\t\"Pentax Q\",\n\t\"Pentax Q7\",\n\t\"Pentax Q10\",\n\t\"Pentax QS-1\",\n\t\"Pentax Optio S\",\n\t\"Pentax Optio S4\",\n\t\"Pentax Optio 33WR\",\n\t\"Pentax Optio 750Z\",\n\t\"Pentax 645D\",\n\t\"Pentax 645Z\",\n\t\"PhaseOne IQ140\",\n\t\"PhaseOne IQ150\",\n\t\"PhaseOne IQ160\",\n\t\"PhaseOne IQ180\",\n\t\"PhaseOne IQ180 IR\",\n\t\"PhaseOne IQ250\",\n\t\"PhaseOne IQ260\",\n\t\"PhaseOne IQ260 Achromatic\",\n\t\"PhaseOne IQ280\",\n\t\"PhaseOne IQ3 50MP\",\n\t\"PhaseOne IQ3 60MP\",\n\t\"PhaseOne IQ3 80MP\",\n\t\"PhaseOne IQ3 100MP\",\n\t\"PhaseOne IQ3 100MP Trichromatic\",\n\t\"PhaseOne LightPhase\",\n\t\"PhaseOne Achromatic+\",\n\t\"PhaseOne H 10\",\n\t\"PhaseOne H 20\",\n\t\"PhaseOne H 25\",\n\t\"PhaseOne P 20\",\n\t\"PhaseOne P 20+\",\n\t\"PhaseOne P 21\",\n\t\"PhaseOne P 25\",\n\t\"PhaseOne P 25+\",\n\t\"PhaseOne P 30\",\n\t\"PhaseOne P 30+\",\n\t\"PhaseOne P 40+\",\n\t\"PhaseOne P 45\",\n\t\"PhaseOne P 45+\",\n\t\"PhaseOne P 65\",\n\t\"PhaseOne P 65+\",\n\t\"Photron BC2-HD\",\n\t\"Pixelink A782\",\n\t\"Polaroid x530\",\n\t\"RaspberryPi Camera\",\n\t\"RaspberryPi Camera V2\",\n\t\"Ricoh GR\",\n\t\"Ricoh GR Digital\",\n\t\"Ricoh GR Digital II\",\n\t\"Ricoh GR Digital III\",\n\t\"Ricoh GR Digital IV\",\n\t\"Ricoh GR II\",\n\t\"Ricoh GX100\",\n\t\"Ricoh GX200\",\n\t\"Ricoh GXR MOUNT A12\",\n\t\"Ricoh GXR MOUNT A16 24-85mm F3.5-5.5\",\n\t\"Ricoh GXR, S10 24-72mm F2.5-4.4 VC\",\n\t\"Ricoh GXR, GR A12 50mm F2.5 MACRO\",\n\t\"Ricoh GXR, GR LENS A12 28mm F2.5\",\n\t\"Ricoh GXR, GXR P10\",\n#ifndef NO_JASPER\n\t\"Redcode R3D format\",\n#endif\n\t\"Rollei d530flex\",\n\t\"RoverShot 3320af\",\n\t\"Samsung EX1\",\n\t\"Samsung EX2F\",\n\t\"Samsung GX-1L\",\n\t\"Samsung GX-1S\",\n\t\"Samsung GX10\",\n\t\"Samsung GX20\",\n\t\"Samsung Galaxy Nexus\",\n\t\"Samsung Galaxy NX (EK-GN120)\",\n\t\"Samsung Galaxy S3\",\n\t\"Samsung Galaxy S6 (SM-G920F)\",\n\t\"Samsung Galaxy S7\",\n\t\"Samsung Galaxy S7 Edge\",\n\t\"Samsung Galaxy S8 (SM-G950U)\",\n\t\"Samsung NX1\",\n\t\"Samsung NX5\",\n\t\"Samsung NX10\",\n\t\"Samsung NX11\",\n\t\"Samsung NX100\",\n\t\"Samsung NX1000\",\n\t\"Samsung NX1100\",\n\t\"Samsung NX20\",\n\t\"Samsung NX200\",\n\t\"Samsung NX210\",\n\t\"Samsung NX2000\",\n\t\"Samsung NX30\",\n\t\"Samsung NX300\",\n\t\"Samsung NX300M\",\n\t\"Samsung NX3000\",\n\t\"Samsung NX500\",\n\t\"Samsung NX mini\",\n\t\"Samsung Pro815\",\n\t\"Samsung WB550\",\n\t\"Samsung WB2000\",\n\t\"Samsung S85 (hacked)\",\n\t\"Samsung S850 (hacked)\",\n\t\"Sarnoff 4096x5440\",\n\t\"Seitz 6x17\",\n\t\"Seitz Roundshot D3\",\n\t\"Seitz Roundshot D2X\",\n\t\"Seitz Roundshot D2Xs\",\n\t\"Sigma SD9 (raw decode only)\",\n\t\"Sigma SD10 (raw decode only)\",\n\t\"Sigma SD14 (raw decode only)\",\n\t\"Sigma SD15 (raw decode only)\",\n\t\"Sigma SD1\",\n\t\"Sigma SD1 Merill\",\n\t\"Sigma DP1\",\n\t\"Sigma DP1 Merill\",\n\t\"Sigma DP1S\",\n\t\"Sigma DP1X\",\n\t\"Sigma DP2\",\n\t\"Sigma DP2 Merill\",\n\t\"Sigma DP2S\",\n\t\"Sigma DP2X\",\n\t\"Sigma DP3 Merill\",\n\t\"Sigma dp0 Quattro\",\n\t\"Sigma dp1 Quattro\",\n\t\"Sigma dp2 Quattro\",\n\t\"Sigma dp3 Quattro\",\n\t\"Sigma sd Quattro\",\n\t\"Sigma sd Quattro H\",\n\t\"Sinar eMotion 22\",\n\t\"Sinar eMotion 54\",\n\t\"Sinar eSpirit 65\",\n\t\"Sinar eMotion 75\",\n\t\"Sinar eVolution 75\",\n\t\"Sinar 3072x2048\",\n\t\"Sinar 4080x4080\",\n\t\"Sinar 4080x5440\",\n\t\"Sinar STI format\",\n\t\"Sinar Sinarback 54\",\n\t\"SMaL Ultra-Pocket 3\",\n\t\"SMaL Ultra-Pocket 4\",\n\t\"SMaL Ultra-Pocket 5\",\n\t\"Sony A7\",\n\t\"Sony A7 II\",\n\t\"Sony A7R\",\n\t\"Sony A7R II\",\n\t\"Sony A7R III\",\n\t\"Sony A7S\",\n\t\"Sony A7S II\",\n\t\"Sony A9\",\n\t\"Sony ILCA-68 (A68)\",\n\t\"Sony ILCA-77M2 (A77-II)\",\n\t\"Sony ILCA-99M2 (A99-II)\",\n\t\"Sony ILCE-3000\",\n\t\"Sony ILCE-5000\",\n\t\"Sony ILCE-5100\",\n\t\"Sony ILCE-6000\",\n\t\"Sony ILCE-6300\",\n\t\"Sony ILCE-6500\",\n\t\"Sony ILCE-QX1\",\n\t\"Sony DSC-F828\",\n\t\"Sony DSC-R1\",\n\t\"Sony DSC-RX0\",\n\t\"Sony DSC-RX1\",\n\t\"Sony DSC-RX1R\",\n\t\"Sony DSC-RX1R II\",\n\t\"Sony DSC-RX10\",\n\t\"Sony DSC-RX10II\",\n\t\"Sony DSC-RX10III\",\n\t\"Sony DSC-RX10IV\",\n\t\"Sony DSC-RX100\",\n\t\"Sony DSC-RX100II\",\n\t\"Sony DSC-RX100III\",\n\t\"Sony DSC-RX100IV\",\n\t\"Sony DSC-RX100V\",\n\t\"Sony DSC-V3\",\n\t\"Sony DSLR-A100\",\n\t\"Sony DSLR-A200\",\n\t\"Sony DSLR-A230\",\n\t\"Sony DSLR-A290\",\n\t\"Sony DSLR-A300\",\n\t\"Sony DSLR-A330\",\n\t\"Sony DSLR-A350\",\n\t\"Sony DSLR-A380\",\n\t\"Sony DSLR-A390\",\n\t\"Sony DSLR-A450\",\n\t\"Sony DSLR-A500\",\n\t\"Sony DSLR-A550\",\n\t\"Sony DSLR-A560\",\n\t\"Sony DSLR-A580\",\n\t\"Sony DSLR-A700\",\n\t\"Sony DSLR-A850\",\n\t\"Sony DSLR-A900\",\n\t\"Sony NEX-3\",\n\t\"Sony NEX-3N\",\n\t\"Sony NEX-5\",\n\t\"Sony NEX-5N\",\n\t\"Sony NEX-5R\",\n\t\"Sony NEX-5T\",\n\t\"Sony NEX-6\",\n\t\"Sony NEX-7\",\n\t\"Sony NEX-C3\",\n\t\"Sony NEX-F3\",\n\t\"Sony NEX-VG20\",\n\t\"Sony NEX-VG30\",\n\t\"Sony NEX-VG900\",\n\t\"Sony SLT-A33\",\n\t\"Sony SLT-A35\",\n\t\"Sony SLT-A37\",\n\t\"Sony SLT-A55V\",\n\t\"Sony SLT-A57\",\n\t\"Sony SLT-A58\",\n\t\"Sony SLT-A65V\",\n\t\"Sony SLT-A77V\",\n\t\"Sony SLT-A99V\",\n\t\"Sony XCD-SX910CR\",\n\t\"Sony IMX135-mipi 13mp\",\n\t\"Sony IMX135-QCOM\",\n\t\"Sony IMX072-mipi\",\n\t\"Sony IMX214\",\n\t\"Sony IMX219\",\n\t\"Sony IMX230\",\n\t\"Sony IMX298-mipi 16mp\",\n\t\"Sony IMX219-mipi 8mp\",\n\t\"Sony Xperia L\",\n\t\"STV680 VGA\",\n\t\"PtGrey GRAS-50S5C\",\n\t\"JaiPulnix BB-500CL\",\n\t\"JaiPulnix BB-500GE\",\n\t\"SVS SVS625CL\",\n\t\"Yi M1\",\n\t\"YUNEEC CGO3\",\n\t\"YUNEEC CGO3P\",\n\t\"YUNEEC CGO4\",\n\t\"Xiaomi MI3\",\n\t\"Xiaomi RedMi Note3 Pro\",\n\t\"Xiaoyi YIAC3 (YI 4k)\",\n\tNULL\n};\n// clang-format on\n\nconst char **LibRaw::cameraList() { return static_camera_list; }\nint LibRaw::cameraCount() { return (sizeof(static_camera_list) / sizeof(static_camera_list[0])) - 1; }\n\nconst char *LibRaw::strprogress(enum LibRaw_progress p)\n{\n  switch (p)\n  {\n  case LIBRAW_PROGRESS_START:\n    return \"Starting\";\n  case LIBRAW_PROGRESS_OPEN:\n    return \"Opening file\";\n  case LIBRAW_PROGRESS_IDENTIFY:\n    return \"Reading metadata\";\n  case LIBRAW_PROGRESS_SIZE_ADJUST:\n    return \"Adjusting size\";\n  case LIBRAW_PROGRESS_LOAD_RAW:\n    return \"Reading RAW data\";\n  case LIBRAW_PROGRESS_REMOVE_ZEROES:\n    return \"Clearing zero values\";\n  case LIBRAW_PROGRESS_BAD_PIXELS:\n    return \"Removing dead pixels\";\n  case LIBRAW_PROGRESS_DARK_FRAME:\n    return \"Subtracting dark frame data\";\n  case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:\n    return \"Interpolating Foveon sensor data\";\n  case LIBRAW_PROGRESS_SCALE_COLORS:\n    return \"Scaling colors\";\n  case LIBRAW_PROGRESS_PRE_INTERPOLATE:\n    return \"Pre-interpolating\";\n  case LIBRAW_PROGRESS_INTERPOLATE:\n    return \"Interpolating\";\n  case LIBRAW_PROGRESS_MIX_GREEN:\n    return \"Mixing green channels\";\n  case LIBRAW_PROGRESS_MEDIAN_FILTER:\n    return \"Median filter\";\n  case LIBRAW_PROGRESS_HIGHLIGHTS:\n    return \"Highlight recovery\";\n  case LIBRAW_PROGRESS_FUJI_ROTATE:\n    return \"Rotating Fuji diagonal data\";\n  case LIBRAW_PROGRESS_FLIP:\n    return \"Flipping image\";\n  case LIBRAW_PROGRESS_APPLY_PROFILE:\n    return \"ICC conversion\";\n  case LIBRAW_PROGRESS_CONVERT_RGB:\n    return \"Converting to RGB\";\n  case LIBRAW_PROGRESS_STRETCH:\n    return \"Stretching image\";\n  case LIBRAW_PROGRESS_THUMB_LOAD:\n    return \"Loading thumbnail\";\n  default:\n    return \"Some strange things\";\n  }\n}\n\n#undef ID\n\n#include \"../internal/libraw_x3f.cpp\"\n\nvoid x3f_clear(void *p) { x3f_delete((x3f_t *)p); }\n\nvoid utf2char(utf16_t *str, char *buffer, unsigned bufsz)\n{\n if(bufsz<1) return;\n buffer[bufsz-1] = 0;\n  char *b = buffer;\n\n  while (*str != 0x00 && --bufsz>0)\n  {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n}\n\nstatic void *lr_memmem(const void *l, size_t l_len, const void *s, size_t s_len)\n{\n  register char *cur, *last;\n  const char *cl = (const char *)l;\n  const char *cs = (const char *)s;\n\n  /* we need something to compare */\n  if (l_len == 0 || s_len == 0)\n    return NULL;\n\n  /* \"s\" must be smaller or equal to \"l\" */\n  if (l_len < s_len)\n    return NULL;\n\n  /* special case where s_len == 1 */\n  if (s_len == 1)\n    return (void *)memchr(l, (int)*cs, l_len);\n\n  /* the last position where its possible to find \"s\" in \"l\" */\n  last = (char *)cl + l_len - s_len;\n\n  for (cur = (char *)cl; cur <= last; cur++)\n    if (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)\n      return cur;\n  return NULL;\n}\n\nvoid LibRaw::parse_x3f()\n{\n  x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);\n  if (!x3f)\n    return;\n  _x3f_data = x3f;\n\n  x3f_header_t *H = NULL;\n  x3f_directory_section_t *DS = NULL;\n\n  H = &x3f->header;\n  // Parse RAW size from RAW section\n  x3f_directory_entry_t *DE = x3f_get_raw(x3f);\n  if (!DE)\n    return;\n  imgdata.sizes.flip = H->rotation;\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  imgdata.sizes.raw_width = ID->columns;\n  imgdata.sizes.raw_height = ID->rows;\n  // Parse other params from property section\n\n  DE = x3f_get_prop(x3f);\n  if ((x3f_load_data(x3f, DE) == X3F_OK))\n  {\n    // Parse property list\n    DEH = &DE->header;\n    x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n    utf16_t *datap = (utf16_t*) PL->data;\n    uint32_t maxitems = PL->data_size/sizeof(utf16_t);\n    if (PL->property_table.size != 0)\n    {\n      int i;\n      x3f_property_t *P = PL->property_table.element;\n      for (i = 0; i < PL->num_properties; i++)\n      {\n        char name[100], value[100];\n        int noffset = (P[i].name - datap);\n        int voffset = (P[i].value - datap);\n        if(noffset < 0 || noffset>maxitems || voffset<0 || voffset>maxitems)\n           throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        int maxnsize = maxitems - (P[i].name - datap);\n        int maxvsize = maxitems - (P[i].value - datap);\n        utf2char(P[i].name, name,MIN(maxnsize,sizeof(name)));\n        utf2char(P[i].value, value,MIN(maxvsize,sizeof(value)));\n        if (!strcmp(name, \"ISO\"))\n          imgdata.other.iso_speed = atoi(value);\n        if (!strcmp(name, \"CAMMANUF\"))\n          strcpy(imgdata.idata.make, value);\n        if (!strcmp(name, \"CAMMODEL\"))\n          strcpy(imgdata.idata.model, value);\n        if (!strcmp(name, \"CAMSERIAL\"))\n          strcpy(imgdata.shootinginfo.BodySerial, value);\n        if (!strcmp(name, \"WB_DESC\"))\n          strcpy(imgdata.color.model2, value);\n        if (!strcmp(name, \"TIME\"))\n          imgdata.other.timestamp = atoi(value);\n        if (!strcmp(name, \"SHUTTER\"))\n          imgdata.other.shutter = atof(value);\n        if (!strcmp(name, \"APERTURE\"))\n          imgdata.other.aperture = atof(value);\n        if (!strcmp(name, \"FLENGTH\"))\n          imgdata.other.focal_len = atof(value);\n        if (!strcmp(name, \"FLEQ35MM\"))\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);\n        if (!strcmp(name, \"IMAGERTEMP\"))\n          imgdata.other.SensorTemperature = atof(value);\n        if (!strcmp(name, \"LENSARANGE\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);\n          sp = strrchr(value, ' ');\n          if (sp)\n          {\n            imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);\n            if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)\n              my_swap(float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);\n          }\n        }\n        if (!strcmp(name, \"LENSFRANGE\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);\n          sp = strrchr(value, ' ');\n          if (sp)\n          {\n            imgdata.lens.makernotes.MaxFocal = atof(sp);\n            if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)\n              my_swap(float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);\n          }\n        }\n        if (!strcmp(name, \"LENSMODEL\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.LensID = strtol(value, &sp, 16); // atoi(value);\n          if (imgdata.lens.makernotes.LensID)\n            imgdata.lens.makernotes.LensMount = Sigma_X3F;\n        }\n      }\n      imgdata.idata.raw_count = 1;\n      load_raw = &LibRaw::x3f_load_raw;\n      imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;\n      imgdata.idata.is_foveon = 1;\n      libraw_internal_data.internal_output_params.raw_color = 1; // Force adobe coeff\n      imgdata.color.maximum = 0x3fff;                            // To be reset by color table\n      libraw_internal_data.unpacker_data.order = 0x4949;\n    }\n  }\n  else\n  {\n    // No property list\n    if (imgdata.sizes.raw_width == 5888 || imgdata.sizes.raw_width == 2944 || imgdata.sizes.raw_width == 6656 ||\n        imgdata.sizes.raw_width == 3328 || imgdata.sizes.raw_width == 5504 ||\n        imgdata.sizes.raw_width == 2752) // Quattro\n    {\n      imgdata.idata.raw_count = 1;\n      load_raw = &LibRaw::x3f_load_raw;\n      imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;\n      imgdata.idata.is_foveon = 1;\n      libraw_internal_data.internal_output_params.raw_color = 1; // Force adobe coeff\n      libraw_internal_data.unpacker_data.order = 0x4949;\n      strcpy(imgdata.idata.make, \"SIGMA\");\n#if 1\n      // Try to find model number in first 2048 bytes;\n      int pos = libraw_internal_data.internal_data.input->tell();\n      libraw_internal_data.internal_data.input->seek(0, SEEK_SET);\n      unsigned char buf[2048];\n      libraw_internal_data.internal_data.input->read(buf, 2048, 1);\n      libraw_internal_data.internal_data.input->seek(pos, SEEK_SET);\n      unsigned char *fnd = (unsigned char *)lr_memmem(buf, 2048, \"SIGMA dp\", 8);\n      unsigned char *fndsd = (unsigned char *)lr_memmem(buf, 2048, \"sd Quatt\", 8);\n      if (fnd)\n      {\n        unsigned char *nm = fnd + 8;\n        snprintf(imgdata.idata.model, 64, \"dp%c Quattro\", *nm <= '9' && *nm >= '0' ? *nm : '2');\n      }\n      else if (fndsd)\n      {\n        snprintf(imgdata.idata.model, 64, \"%s\", fndsd);\n      }\n      else\n#endif\n          if (imgdata.sizes.raw_width == 6656 || imgdata.sizes.raw_width == 3328)\n        strcpy(imgdata.idata.model, \"sd Quattro H\");\n      else\n        strcpy(imgdata.idata.model, \"dp2 Quattro\");\n    }\n    // else\n  }\n  // Try to get thumbnail data\n  LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;\n  if ((DE = x3f_get_thumb_jpeg(x3f)))\n  {\n    format = LIBRAW_THUMBNAIL_JPEG;\n  }\n  else if ((DE = x3f_get_thumb_plain(x3f)))\n  {\n    format = LIBRAW_THUMBNAIL_BITMAP;\n  }\n  if (DE)\n  {\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n    imgdata.thumbnail.twidth = ID->columns;\n    imgdata.thumbnail.theight = ID->rows;\n    imgdata.thumbnail.tcolors = 3;\n    imgdata.thumbnail.tformat = format;\n    libraw_internal_data.internal_data.toffset = DE->input.offset;\n    write_thumb = &LibRaw::x3f_thumb_loader;\n  }\n}\n\nINT64 LibRaw::x3f_thumb_size()\n{\n  try\n  {\n    x3f_t *x3f = (x3f_t *)_x3f_data;\n    if (!x3f)\n      return -1; // No data pointer set\n    x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n    if (!DE)\n      DE = x3f_get_thumb_plain(x3f);\n    if (!DE)\n      return -1;\n    int64_t p = x3f_load_data_size(x3f, DE);\n    if (p < 0 || p > 0xffffffff)\n      return -1;\n    return p;\n  }\n  catch (...)\n  {\n    return -1;\n  }\n}\n\nvoid LibRaw::x3f_thumb_loader()\n{\n  try\n  {\n    x3f_t *x3f = (x3f_t *)_x3f_data;\n    if (!x3f)\n      return; // No data pointer set\n    x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n    if (!DE)\n      DE = x3f_get_thumb_plain(x3f);\n    if (!DE)\n      return;\n    if (X3F_OK != x3f_load_data(x3f, DE))\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n    imgdata.thumbnail.twidth = ID->columns;\n    imgdata.thumbnail.theight = ID->rows;\n    imgdata.thumbnail.tcolors = 3;\n    if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_JPEG)\n    {\n      imgdata.thumbnail.thumb = (char *)malloc(ID->data_size);\n      merror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");\n      memmove(imgdata.thumbnail.thumb, ID->data, ID->data_size);\n      imgdata.thumbnail.tlength = ID->data_size;\n    }\n    else if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_BITMAP)\n    {\n      imgdata.thumbnail.tlength = ID->columns * ID->rows * 3;\n      imgdata.thumbnail.thumb = (char *)malloc(ID->columns * ID->rows * 3);\n      merror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");\n      char *src0 = (char *)ID->data;\n      for (int row = 0; row < ID->rows; row++)\n      {\n        int offset = row * ID->row_stride;\n        if (offset + ID->columns * 3 > ID->data_size)\n          break;\n        char *dest = &imgdata.thumbnail.thumb[row * ID->columns * 3];\n        char *src = &src0[offset];\n        memmove(dest, src, ID->columns * 3);\n      }\n    }\n  }\n  catch (...)\n  {\n    // do nothing\n  }\n}\n\nstatic inline uint32_t _clampbits(int x, uint32_t n)\n{\n  uint32_t _y_temp;\n  if ((_y_temp = x >> n))\n    x = ~_y_temp >> (32 - n);\n  return x;\n}\n\nvoid LibRaw::x3f_dpq_interpolate_rg()\n{\n  int w = imgdata.sizes.raw_width / 2;\n  int h = imgdata.sizes.raw_height / 2;\n  unsigned short *image = (ushort *)imgdata.rawdata.color3_image;\n\n  for (int color = 0; color < 2; color++)\n  {\n    for (int y = 2; y < (h - 2); y++)\n    {\n      uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * (y * 2) + color]; // dst[1]\n      uint16_t row0_3 = row0[3];\n      uint16_t *row1 = &image[imgdata.sizes.raw_width * 3 * (y * 2 + 1) + color]; // dst1[1]\n      uint16_t row1_3 = row1[3];\n      for (int x = 2; x < (w - 2); x++)\n      {\n        row1[0] = row1[3] = row0[3] = row0[0];\n        row0 += 6;\n        row1 += 6;\n      }\n    }\n  }\n}\n\n#define _ABS(a) ((a) < 0 ? -(a) : (a))\n\n#undef CLIP\n#define CLIP(value, high) ((value) > (high) ? (high) : (value))\n\nvoid LibRaw::x3f_dpq_interpolate_af(int xstep, int ystep, int scale)\n{\n  unsigned short *image = (ushort *)imgdata.rawdata.color3_image;\n  unsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch / 2; // in 16-bit words\n                                                               // Interpolate single pixel\n  for (int y = 0; y < imgdata.rawdata.sizes.height + imgdata.rawdata.sizes.top_margin; y += ystep)\n  {\n    if (y < imgdata.rawdata.sizes.top_margin)\n      continue;\n    if (y < scale)\n      continue;\n    if (y > imgdata.rawdata.sizes.raw_height - scale)\n      break;\n    uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * y];                // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430\n    uint16_t *row_minus = &image[imgdata.sizes.raw_width * 3 * (y - scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435\n    uint16_t *row_plus = &image[imgdata.sizes.raw_width * 3 * (y + scale)];  // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435\n    for (int x = 0; x < imgdata.rawdata.sizes.width + imgdata.rawdata.sizes.left_margin; x += xstep)\n    {\n      if (x < imgdata.rawdata.sizes.left_margin)\n        continue;\n      if (x < scale)\n        continue;\n      if (x > imgdata.rawdata.sizes.raw_width - scale)\n        break;\n      uint16_t *pixel0 = &row0[x * 3];\n      uint16_t *pixel_top = &row_minus[x * 3];\n      uint16_t *pixel_bottom = &row_plus[x * 3];\n      uint16_t *pixel_left = &row0[(x - scale) * 3];\n      uint16_t *pixel_right = &row0[(x + scale) * 3];\n      uint16_t *pixf = pixel_top;\n      if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_bottom[2] - pixel0[2]))\n        pixf = pixel_bottom;\n      if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_left[2] - pixel0[2]))\n        pixf = pixel_left;\n      if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_right[2] - pixel0[2]))\n        pixf = pixel_right;\n      int blocal = pixel0[2], bnear = pixf[2];\n      if (blocal < imgdata.color.black + 16 || bnear < imgdata.color.black + 16)\n      {\n        if (pixel0[0] < imgdata.color.black)\n          pixel0[0] = imgdata.color.black;\n        if (pixel0[1] < imgdata.color.black)\n          pixel0[1] = imgdata.color.black;\n        pixel0[0] = CLIP((pixel0[0] - imgdata.color.black) * 4 + imgdata.color.black, 16383);\n        pixel0[1] = CLIP((pixel0[1] - imgdata.color.black) * 4 + imgdata.color.black, 16383);\n      }\n      else\n      {\n        float multip = float(bnear - imgdata.color.black) / float(blocal - imgdata.color.black);\n        if (pixel0[0] < imgdata.color.black)\n          pixel0[0] = imgdata.color.black;\n        if (pixel0[1] < imgdata.color.black)\n          pixel0[1] = imgdata.color.black;\n        float pixf0 = pixf[0];\n        if (pixf0 < imgdata.color.black)\n          pixf0 = imgdata.color.black;\n        float pixf1 = pixf[1];\n        if (pixf1 < imgdata.color.black)\n          pixf1 = imgdata.color.black;\n\n        pixel0[0] = CLIP(((float(pixf0 - imgdata.color.black) * multip + imgdata.color.black) +\n                          ((pixel0[0] - imgdata.color.black) * 3.75 + imgdata.color.black)) /\n                             2,\n                         16383);\n        pixel0[1] = CLIP(((float(pixf1 - imgdata.color.black) * multip + imgdata.color.black) +\n                          ((pixel0[1] - imgdata.color.black) * 3.75 + imgdata.color.black)) /\n                             2,\n                         16383);\n        // pixel0[1] = float(pixf[1]-imgdata.color.black)*multip + imgdata.color.black;\n      }\n    }\n  }\n}\n\nvoid LibRaw::x3f_dpq_interpolate_af_sd(int xstart, int ystart, int xend, int yend, int xstep, int ystep, int scale)\n{\n  unsigned short *image = (ushort *)imgdata.rawdata.color3_image;\n  unsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch / 2; // in 16-bit words\n  // Interpolate single pixel\n  for (int y = ystart; y < yend && y < imgdata.rawdata.sizes.height + imgdata.rawdata.sizes.top_margin; y += ystep)\n  {\n    uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * y];                // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430\n    uint16_t *row1 = &image[imgdata.sizes.raw_width * 3 * (y + 1)];          // \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\n    uint16_t *row_minus = &image[imgdata.sizes.raw_width * 3 * (y - scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435\n    uint16_t *row_plus =\n        &image[imgdata.sizes.raw_width * 3 * (y + scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435 AF-point (scale=2 -> \u043d\u0438\u0436\u0435 row1\n    uint16_t *row_minus1 = &image[imgdata.sizes.raw_width * 3 * (y - 1)];\n    for (int x = xstart; x < xend && x < imgdata.rawdata.sizes.width + imgdata.rawdata.sizes.left_margin; x += xstep)\n    {\n      uint16_t *pixel00 = &row0[x * 3]; // Current pixel\n      float sumR = 0.f, sumG = 0.f;\n      float cnt = 0.f;\n      for (int xx = -scale; xx <= scale; xx += scale)\n      {\n        sumR += row_minus[(x + xx) * 3];\n        sumR += row_plus[(x + xx) * 3];\n        sumG += row_minus[(x + xx) * 3 + 1];\n        sumG += row_plus[(x + xx) * 3 + 1];\n        cnt += 1.f;\n        if (xx)\n        {\n          cnt += 1.f;\n          sumR += row0[(x + xx) * 3];\n          sumG += row0[(x + xx) * 3 + 1];\n        }\n      }\n      pixel00[0] = sumR / 8.f;\n      pixel00[1] = sumG / 8.f;\n\n      if (scale == 2)\n      {\n        uint16_t *pixel0B = &row0[x * 3 + 3]; // right pixel\n        uint16_t *pixel1B = &row1[x * 3 + 3]; // right pixel\n        float sumG0 = 0, sumG1 = 0.f;\n        float cnt = 0.f;\n        for (int xx = -scale; xx <= scale; xx += scale)\n        {\n          sumG0 += row_minus1[(x + xx) * 3 + 2];\n          sumG1 += row_plus[(x + xx) * 3 + 2];\n          cnt += 1.f;\n          if (xx)\n          {\n            sumG0 += row0[(x + xx) * 3 + 2];\n            sumG1 += row1[(x + xx) * 3 + 2];\n            cnt += 1.f;\n          }\n        }\n        pixel0B[2] = sumG0 / cnt;\n        pixel1B[2] = sumG1 / cnt;\n      }\n\n      //\t\t\tuint16_t* pixel10 = &row1[x*3]; // Pixel below current\n      //\t\t\tuint16_t* pixel_bottom = &row_plus[x*3];\n    }\n  }\n}\n\nvoid LibRaw::x3f_load_raw()\n{\n  // already in try/catch\n  int raise_error = 0;\n  x3f_t *x3f = (x3f_t *)_x3f_data;\n  if (!x3f)\n    return; // No data pointer set\n  if (X3F_OK == x3f_load_data(x3f, x3f_get_raw(x3f)))\n  {\n    x3f_directory_entry_t *DE = x3f_get_raw(x3f);\n    x3f_directory_entry_header_t *DEH = &DE->header;\n    x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n    if (!ID)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    x3f_quattro_t *Q = ID->quattro;\n    x3f_huffman_t *HUF = ID->huffman;\n    x3f_true_t *TRU = ID->tru;\n    uint16_t *data = NULL;\n    if (ID->rows != S.raw_height || ID->columns != S.raw_width)\n    {\n      raise_error = 1;\n      goto end;\n    }\n    if (HUF != NULL)\n      data = HUF->x3rgb16.data;\n    if (TRU != NULL)\n      data = TRU->x3rgb16.data;\n    if (data == NULL)\n    {\n      raise_error = 1;\n      goto end;\n    }\n\n    size_t datasize = S.raw_height * S.raw_width * 3 * sizeof(unsigned short);\n    S.raw_pitch = S.raw_width * 3 * sizeof(unsigned short);\n    if (!(imgdata.rawdata.raw_alloc = malloc(datasize)))\n      throw LIBRAW_EXCEPTION_ALLOC;\n\n    imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n    if (HUF)\n      memmove(imgdata.rawdata.raw_alloc, data, datasize);\n    else if (TRU && (!Q || !Q->quattro_layout))\n      memmove(imgdata.rawdata.raw_alloc, data, datasize);\n    else if (TRU && Q)\n    {\n      // Move quattro data in place\n      // R/B plane\n      for (int prow = 0; prow < TRU->x3rgb16.rows && prow < S.raw_height / 2; prow++)\n      {\n        ushort(*destrow)[3] =\n            (unsigned short(*)[3]) & imgdata.rawdata.color3_image[prow * 2 * S.raw_pitch / 3 / sizeof(ushort)][0];\n        ushort(*srcrow)[3] = (unsigned short(*)[3]) & data[prow * TRU->x3rgb16.row_stride];\n        for (int pcol = 0; pcol < TRU->x3rgb16.columns && pcol < S.raw_width / 2; pcol++)\n        {\n          destrow[pcol * 2][0] = srcrow[pcol][0];\n          destrow[pcol * 2][1] = srcrow[pcol][1];\n        }\n      }\n      for (int row = 0; row < Q->top16.rows && row < S.raw_height; row++)\n      {\n        ushort(*destrow)[3] =\n            (unsigned short(*)[3]) & imgdata.rawdata.color3_image[row * S.raw_pitch / 3 / sizeof(ushort)][0];\n        ushort(*srcrow) = (unsigned short *)&Q->top16.data[row * Q->top16.columns];\n        for (int col = 0; col < Q->top16.columns && col < S.raw_width; col++)\n          destrow[col][2] = srcrow[col];\n      }\n    }\n\n#if 1\n    if (TRU && Q && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF))\n    {\n      if (imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3672) // dpN Quattro normal\n      {\n        x3f_dpq_interpolate_af(32, 8, 2);\n      }\n      else if (imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3776) // sd Quattro normal raw\n      {\n        x3f_dpq_interpolate_af_sd(216, 464, imgdata.sizes.raw_width - 1, 3312, 16, 32, 2);\n      }\n      else if (imgdata.sizes.raw_width == 6656 && imgdata.sizes.raw_height == 4480) // sd Quattro H normal raw\n      {\n        x3f_dpq_interpolate_af_sd(232, 592, imgdata.sizes.raw_width - 1, 3920, 16, 32, 2);\n      }\n      else if (imgdata.sizes.raw_width == 3328 && imgdata.sizes.raw_height == 2240) // sd Quattro H half size\n      {\n        x3f_dpq_interpolate_af_sd(116, 296, imgdata.sizes.raw_width - 1, 2200, 8, 16, 1);\n      }\n      else if (imgdata.sizes.raw_width == 5504 && imgdata.sizes.raw_height == 3680) // sd Quattro H APS-C raw\n      {\n        x3f_dpq_interpolate_af_sd(8, 192, imgdata.sizes.raw_width - 1, 3185, 16, 32, 2);\n      }\n      else if (imgdata.sizes.raw_width == 2752 && imgdata.sizes.raw_height == 1840) // sd Quattro H APS-C half size\n      {\n        x3f_dpq_interpolate_af_sd(4, 96, imgdata.sizes.raw_width - 1, 1800, 8, 16, 1);\n      }\n      else if (imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1836) // dpN Quattro small raw\n      {\n        x3f_dpq_interpolate_af(16, 4, 1);\n      }\n      else if (imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1888) // sd Quattro small\n      {\n        x3f_dpq_interpolate_af_sd(108, 232, imgdata.sizes.raw_width - 1, 1656, 8, 16, 1);\n      }\n    }\n#endif\n    if (TRU && Q && Q->quattro_layout && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATERG))\n      x3f_dpq_interpolate_rg();\n  }\n  else\n    raise_error = 1;\nend:\n  if (raise_error)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n}\n"], "filenames": ["internal/dcraw_common.cpp", "internal/libraw_x3f.cpp", "src/libraw_cxx.cpp"], "buggy_code_start_loc": [17604, 124, 6145], "buggy_code_end_loc": [17604, 1635, 6161], "fixing_code_start_loc": [17605, 123, 6146], "fixing_code_end_loc": [17606, 1626, 6170], "type": "CWE-125", "message": "An issue was discovered in LibRaw 0.18.9. There is an out-of-bounds read affecting the X3F property table list implementation in libraw_x3f.cpp and libraw_cxx.cpp.", "other": {"cve": {"id": "CVE-2018-10529", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-29T03:29:00.373", "lastModified": "2018-06-04T16:21:35.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in LibRaw 0.18.9. There is an out-of-bounds read affecting the X3F property table list implementation in libraw_x3f.cpp and libraw_cxx.cpp."}, {"lang": "es", "value": "Se ha descubierto un problema en LibRaw 0.18.9. Hay una lectura fuera de l\u00edmites que afecta a la implementaci\u00f3n de la lista de tablas de propiedades X3F en libraw_x3f.cpp y libraw_cxx.cpp."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.18.9:*:*:*:*:*:*:*", "matchCriteriaId": "7E0EC812-F04B-4671-B565-1B48A368C85F"}]}]}], "references": [{"url": "https://github.com/LibRaw/LibRaw/commit/f0c505a3e5d47989a5f69be2d0d4f250af6b1a6c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibRaw/LibRaw/issues/144", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3639-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/f0c505a3e5d47989a5f69be2d0d4f250af6b1a6c"}}