{"buggy_code": ["import { Brackets } from 'typeorm';\nimport { Inject, Injectable } from '@nestjs/common';\nimport type { NotesRepository } from '@/models/index.js';\nimport { safeForSql } from '@/misc/safe-for-sql.js';\nimport { normalizeForSearch } from '@/misc/normalize-for-search.js';\nimport { Endpoint } from '@/server/api/endpoint-base.js';\nimport { QueryService } from '@/core/QueryService.js';\nimport { NoteEntityService } from '@/core/entities/NoteEntityService.js';\nimport { DI } from '@/di-symbols.js';\n\nexport const meta = {\n\ttags: ['notes', 'hashtags'],\n\n\tres: {\n\t\ttype: 'array',\n\t\toptional: false, nullable: false,\n\t\titems: {\n\t\t\ttype: 'object',\n\t\t\toptional: false, nullable: false,\n\t\t\tref: 'Note',\n\t\t},\n\t},\n} as const;\n\nexport const paramDef = {\n\ttype: 'object',\n\tproperties: {\n\t\treply: { type: 'boolean', nullable: true, default: null },\n\t\trenote: { type: 'boolean', nullable: true, default: null },\n\t\twithFiles: {\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription: 'Only show notes that have attached files.',\n\t\t},\n\t\tpoll: { type: 'boolean', nullable: true, default: null },\n\t\tsinceId: { type: 'string', format: 'misskey:id' },\n\t\tuntilId: { type: 'string', format: 'misskey:id' },\n\t\tlimit: { type: 'integer', minimum: 1, maximum: 100, default: 10 },\n\t},\n\tanyOf: [\n\t\t{\n\t\t\tproperties: {\n\t\t\t\ttag: { type: 'string', minLength: 1 },\n\t\t\t},\n\t\t\trequired: ['tag'],\n\t\t},\n\t\t{\n\t\t\tproperties: {\n\t\t\t\tquery: {\n\t\t\t\t\ttype: 'array',\n\t\t\t\t\tdescription: 'The outer arrays are chained with OR, the inner arrays are chained with AND.',\n\t\t\t\t\titems: {\n\t\t\t\t\t\ttype: 'array',\n\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tminLength: 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tminItems: 1,\n\t\t\t\t\t},\n\t\t\t\t\tminItems: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\trequired: ['query'],\n\t\t},\n\t],\n} as const;\n\n// eslint-disable-next-line import/no-default-export\n@Injectable()\nexport default class extends Endpoint<typeof meta, typeof paramDef> {\n\tconstructor(\n\t\t@Inject(DI.notesRepository)\n\t\tprivate notesRepository: NotesRepository,\n\n\t\tprivate noteEntityService: NoteEntityService,\n\t\tprivate queryService: QueryService,\n\t) {\n\t\tsuper(meta, paramDef, async (ps, me) => {\n\t\t\tconst query = this.queryService.makePaginationQuery(this.notesRepository.createQueryBuilder('note'), ps.sinceId, ps.untilId)\n\t\t\t\t.innerJoinAndSelect('note.user', 'user')\n\t\t\t\t.leftJoinAndSelect('user.avatar', 'avatar')\n\t\t\t\t.leftJoinAndSelect('user.banner', 'banner')\n\t\t\t\t.leftJoinAndSelect('note.reply', 'reply')\n\t\t\t\t.leftJoinAndSelect('note.renote', 'renote')\n\t\t\t\t.leftJoinAndSelect('reply.user', 'replyUser')\n\t\t\t\t.leftJoinAndSelect('replyUser.avatar', 'replyUserAvatar')\n\t\t\t\t.leftJoinAndSelect('replyUser.banner', 'replyUserBanner')\n\t\t\t\t.leftJoinAndSelect('renote.user', 'renoteUser')\n\t\t\t\t.leftJoinAndSelect('renoteUser.avatar', 'renoteUserAvatar')\n\t\t\t\t.leftJoinAndSelect('renoteUser.banner', 'renoteUserBanner');\n\n\t\t\tthis.queryService.generateVisibilityQuery(query, me);\n\t\t\tif (me) this.queryService.generateMutedUserQuery(query, me);\n\t\t\tif (me) this.queryService.generateBlockedUserQuery(query, me);\n\n\t\t\ttry {\n\t\t\t\tif (ps.tag) {\n\t\t\t\t\tif (!safeForSql(ps.tag)) throw 'Injection';\n\t\t\t\t\tquery.andWhere(`'{\"${normalizeForSearch(ps.tag)}\"}' <@ note.tags`);\n\t\t\t\t} else {\n\t\t\t\t\tquery.andWhere(new Brackets(qb => {\n\t\t\t\t\t\tfor (const tags of ps.query!) {\n\t\t\t\t\t\t\tqb.orWhere(new Brackets(qb => {\n\t\t\t\t\t\t\t\tfor (const tag of tags) {\n\t\t\t\t\t\t\t\t\tif (!safeForSql(tag)) throw 'Injection';\n\t\t\t\t\t\t\t\t\tqb.andWhere(`'{\"${normalizeForSearch(tag)}\"}' <@ note.tags`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (e === 'Injection') return [];\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tif (ps.reply != null) {\n\t\t\t\tif (ps.reply) {\n\t\t\t\t\tquery.andWhere('note.replyId IS NOT NULL');\n\t\t\t\t} else {\n\t\t\t\t\tquery.andWhere('note.replyId IS NULL');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ps.renote != null) {\n\t\t\t\tif (ps.renote) {\n\t\t\t\t\tquery.andWhere('note.renoteId IS NOT NULL');\n\t\t\t\t} else {\n\t\t\t\t\tquery.andWhere('note.renoteId IS NULL');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ps.withFiles) {\n\t\t\t\tquery.andWhere('note.fileIds != \\'{}\\'');\n\t\t\t}\n\n\t\t\tif (ps.poll != null) {\n\t\t\t\tif (ps.poll) {\n\t\t\t\t\tquery.andWhere('note.hasPoll = TRUE');\n\t\t\t\t} else {\n\t\t\t\t\tquery.andWhere('note.hasPoll = FALSE');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Search notes\n\t\t\tconst notes = await query.take(ps.limit).getMany();\n\n\t\t\treturn await this.noteEntityService.packMany(notes, me);\n\t\t});\n\t}\n}\n"], "fixing_code": ["import { Brackets } from 'typeorm';\nimport { Inject, Injectable } from '@nestjs/common';\nimport type { NotesRepository } from '@/models/index.js';\nimport { safeForSql } from '@/misc/safe-for-sql.js';\nimport { normalizeForSearch } from '@/misc/normalize-for-search.js';\nimport { Endpoint } from '@/server/api/endpoint-base.js';\nimport { QueryService } from '@/core/QueryService.js';\nimport { NoteEntityService } from '@/core/entities/NoteEntityService.js';\nimport { DI } from '@/di-symbols.js';\n\nexport const meta = {\n\ttags: ['notes', 'hashtags'],\n\n\tres: {\n\t\ttype: 'array',\n\t\toptional: false, nullable: false,\n\t\titems: {\n\t\t\ttype: 'object',\n\t\t\toptional: false, nullable: false,\n\t\t\tref: 'Note',\n\t\t},\n\t},\n} as const;\n\nexport const paramDef = {\n\ttype: 'object',\n\tproperties: {\n\t\treply: { type: 'boolean', nullable: true, default: null },\n\t\trenote: { type: 'boolean', nullable: true, default: null },\n\t\twithFiles: {\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdescription: 'Only show notes that have attached files.',\n\t\t},\n\t\tpoll: { type: 'boolean', nullable: true, default: null },\n\t\tsinceId: { type: 'string', format: 'misskey:id' },\n\t\tuntilId: { type: 'string', format: 'misskey:id' },\n\t\tlimit: { type: 'integer', minimum: 1, maximum: 100, default: 10 },\n\t},\n\tanyOf: [\n\t\t{\n\t\t\tproperties: {\n\t\t\t\ttag: { type: 'string', minLength: 1 },\n\t\t\t},\n\t\t\trequired: ['tag'],\n\t\t},\n\t\t{\n\t\t\tproperties: {\n\t\t\t\tquery: {\n\t\t\t\t\ttype: 'array',\n\t\t\t\t\tdescription: 'The outer arrays are chained with OR, the inner arrays are chained with AND.',\n\t\t\t\t\titems: {\n\t\t\t\t\t\ttype: 'array',\n\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tminLength: 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tminItems: 1,\n\t\t\t\t\t},\n\t\t\t\t\tminItems: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\trequired: ['query'],\n\t\t},\n\t],\n} as const;\n\n// eslint-disable-next-line import/no-default-export\n@Injectable()\nexport default class extends Endpoint<typeof meta, typeof paramDef> {\n\tconstructor(\n\t\t@Inject(DI.notesRepository)\n\t\tprivate notesRepository: NotesRepository,\n\n\t\tprivate noteEntityService: NoteEntityService,\n\t\tprivate queryService: QueryService,\n\t) {\n\t\tsuper(meta, paramDef, async (ps, me) => {\n\t\t\tconst query = this.queryService.makePaginationQuery(this.notesRepository.createQueryBuilder('note'), ps.sinceId, ps.untilId)\n\t\t\t\t.innerJoinAndSelect('note.user', 'user')\n\t\t\t\t.leftJoinAndSelect('user.avatar', 'avatar')\n\t\t\t\t.leftJoinAndSelect('user.banner', 'banner')\n\t\t\t\t.leftJoinAndSelect('note.reply', 'reply')\n\t\t\t\t.leftJoinAndSelect('note.renote', 'renote')\n\t\t\t\t.leftJoinAndSelect('reply.user', 'replyUser')\n\t\t\t\t.leftJoinAndSelect('replyUser.avatar', 'replyUserAvatar')\n\t\t\t\t.leftJoinAndSelect('replyUser.banner', 'replyUserBanner')\n\t\t\t\t.leftJoinAndSelect('renote.user', 'renoteUser')\n\t\t\t\t.leftJoinAndSelect('renoteUser.avatar', 'renoteUserAvatar')\n\t\t\t\t.leftJoinAndSelect('renoteUser.banner', 'renoteUserBanner');\n\n\t\t\tthis.queryService.generateVisibilityQuery(query, me);\n\t\t\tif (me) this.queryService.generateMutedUserQuery(query, me);\n\t\t\tif (me) this.queryService.generateBlockedUserQuery(query, me);\n\n\t\t\ttry {\n\t\t\t\tif (ps.tag) {\n\t\t\t\t\tif (!safeForSql(normalizeForSearch(ps.tag))) throw 'Injection';\n\t\t\t\t\tquery.andWhere(`'{\"${normalizeForSearch(ps.tag)}\"}' <@ note.tags`);\n\t\t\t\t} else {\n\t\t\t\t\tquery.andWhere(new Brackets(qb => {\n\t\t\t\t\t\tfor (const tags of ps.query!) {\n\t\t\t\t\t\t\tqb.orWhere(new Brackets(qb => {\n\t\t\t\t\t\t\t\tfor (const tag of tags) {\n\t\t\t\t\t\t\t\t\tif (!safeForSql(normalizeForSearch(tag))) throw 'Injection';\n\t\t\t\t\t\t\t\t\tqb.andWhere(`'{\"${normalizeForSearch(tag)}\"}' <@ note.tags`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (e === 'Injection') return [];\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tif (ps.reply != null) {\n\t\t\t\tif (ps.reply) {\n\t\t\t\t\tquery.andWhere('note.replyId IS NOT NULL');\n\t\t\t\t} else {\n\t\t\t\t\tquery.andWhere('note.replyId IS NULL');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ps.renote != null) {\n\t\t\t\tif (ps.renote) {\n\t\t\t\t\tquery.andWhere('note.renoteId IS NOT NULL');\n\t\t\t\t} else {\n\t\t\t\t\tquery.andWhere('note.renoteId IS NULL');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ps.withFiles) {\n\t\t\t\tquery.andWhere('note.fileIds != \\'{}\\'');\n\t\t\t}\n\n\t\t\tif (ps.poll != null) {\n\t\t\t\tif (ps.poll) {\n\t\t\t\t\tquery.andWhere('note.hasPoll = TRUE');\n\t\t\t\t} else {\n\t\t\t\t\tquery.andWhere('note.hasPoll = FALSE');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Search notes\n\t\t\tconst notes = await query.take(ps.limit).getMany();\n\n\t\t\treturn await this.noteEntityService.packMany(notes, me);\n\t\t});\n\t}\n}\n"], "filenames": ["packages/backend/src/server/api/endpoints/notes/search-by-tag.ts"], "buggy_code_start_loc": [98], "buggy_code_end_loc": [106], "fixing_code_start_loc": [98], "fixing_code_end_loc": [106], "type": "CWE-89", "message": "Misskey is an open source, decentralized social media platform. In versions prior to 13.3.3 SQL injection is possible due to insufficient parameter validation in the note search API by tag (notes/search-by-tag). This has been fixed in version 13.3.3. Users are advised to upgrade. Users unable to upgrade should block access to the `api/notes/search-by-tag` endpoint.", "other": {"cve": {"id": "CVE-2023-24812", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-22T20:15:12.777", "lastModified": "2023-04-10T16:27:37.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Misskey is an open source, decentralized social media platform. In versions prior to 13.3.3 SQL injection is possible due to insufficient parameter validation in the note search API by tag (notes/search-by-tag). This has been fixed in version 13.3.3. Users are advised to upgrade. Users unable to upgrade should block access to the `api/notes/search-by-tag` endpoint."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misskey:misskey:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.3.3", "matchCriteriaId": "C283C863-C990-470A-9815-AC6A14462687"}]}]}], "references": [{"url": "https://github.com/misskey-dev/misskey/commit/ee74df68233adcd5b167258c621565f97c3b2306", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/misskey-dev/misskey/security/advisories/GHSA-cgwp-vmr4-wx4q", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/misskey-dev/misskey/commit/ee74df68233adcd5b167258c621565f97c3b2306"}}