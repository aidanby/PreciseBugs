{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.bridge;\n\nimport java.util.Date;\n\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.stability.Unstable;\n\n/**\n * Exposes methods for accessing Documents. This is temporary until we remodel the Model classes and the Document\n * services. The implementation is actually the XWikiDocument class, so this is just a light interface that hides the\n * old xwiki-core.\n * \n * @version $Id$\n * @since 1.6M1\n */\npublic interface DocumentModelBridge\n{    \n    /**\n     * Retrieve the full name of the document, in the <code>Space.Name</code> format, for example {@code Main.WebHome}.\n     * \n     * @return A <code>String</code> representation of the document's full name.\n     * @deprecated use {@link #getDocumentReference} instead\n     */\n    @Deprecated\n    String getFullName();\n\n    /**\n     * @return the document's reference (without the document locale)\n     * @since 2.2M1\n     */\n    DocumentReference getDocumentReference();\n\n    /**\n     * Retrieve the actual language of the document variant. If this is a translation, then it is the language of the\n     * translation. If this is the original variant of the document, then it it is the default language of the document.\n     * \n     * @return The document's language in a 2-letter code.\n     */\n    String getRealLanguage();\n\n    /**\n     * Retrieves the textual content of the document.\n     * \n     * @return The document's content.\n     */\n    String getContent();\n\n    /**\n     * Retrieves a copy of the document before it was changed.\n     * \n     * @return the copy of this Document instance before any modification was made to it.\n     */\n    DocumentModelBridge getOriginalDocument();\n    \n    /**\n     * @return the Syntax id representing the syntax used for the current document. For example \"xwiki/1.0\" represents\n     *         the first version XWiki syntax while \"xwiki/2.0\" represents version 2.0 of the XWiki Syntax.\n     * @deprecated since 3.0M1 use {@link #getSyntax()} instead\n     */\n    @Deprecated\n    String getSyntaxId();\n\n    /**\n     * @return the Syntax id representing the syntax used for the current document. For example \"xwiki/1.0\" represents\n     *         the first version XWiki syntax while \"xwiki/2.0\" represents version 2.0 of the XWiki Syntax.\n     * @since 3.0M1\n     */\n    Syntax getSyntax();\n\n    /**\n     * @return the page to which the document belongs to (eg \"WebHome\")\n     * @deprecated since 2.2M1 use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    String getPageName();\n    \n    /**\n     * Return the full local space reference. For example a document located in sub-space <code>space11</code> of space\n     * <code>space1</code> will return <code>space1.space11</code>.\n     * \n     * @return the space to which the document belongs to (eg \"Main\")\n     * @deprecated since 2.2M1 use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    String getSpaceName();\n\n    /**\n     * Retrieve the name of the virtual wiki this document belongs to.\n     *\n     * @return A <code>String</code> representation of the document's wiki name.\n     * @deprecated since 2.2M1 use {@link #getDocumentReference()}  instead\n     */\n    @Deprecated\n    String getWikiName();\n\n    /**\n     * @return the document's title or null if not set\n     */\n    String getTitle();\n\n    /**\n     * @return a string identifying the current version of this document\n     */\n    String getVersion();\n\n    /**\n     * @return the XDOM for the document\n     * @since 3.0M3\n     */\n    XDOM getXDOM();\n\n    /**\n     * @return the document's content author user reference\n     * @since 7.2M1\n     * @deprecated since 14.0RC1 rely on {@link #getAuthors()}.\n     */\n    @Deprecated\n    DocumentReference getContentAuthorReference();\n\n    /**\n     * @return the various authors information of a document.\n     * @since 14.0RC1\n     */\n    @Unstable\n    default DocumentAuthors getAuthors()\n    {\n        return null;\n    }\n\n    /**\n     * @return the creation date of the current document.\n     * @since 12.8RC1\n     * @since 12.6.3\n     */\n    default Date getCreationDate()\n    {\n        return null;\n    }\n\n    /**\n     * @return {@code true} if the document is hidden.\n     * @since 13.1\n     * @since 12.10.5\n     * @since 12.6.8\n     */\n    default Boolean isHidden()\n    {\n        return false;\n    }\n\n    /**\n     * @return the last save date of the current document.\n     * @since 14.0RC1\n     */\n    @Unstable\n    default Date getDate()\n    {\n        return null;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.display.internal;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.ModelContext;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.parser.Parser;\nimport org.xwiki.rendering.util.ParserUtils;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.velocity.VelocityEngine;\nimport org.xwiki.velocity.VelocityManager;\n\n/**\n * Displays the title of a document.\n *\n * @version $Id$\n * @since 3.2M3\n */\npublic abstract class AbstractDocumentTitleDisplayer implements DocumentDisplayer\n{\n    /**\n     * The key used to store on the XWiki context map the stack of references to documents whose titles are currently\n     * being evaluated (in the current execution context). This stack is used to prevent infinite recursion, which can\n     * happen if the title displayer is called on the current document from the title field or from a script within the\n     * first content heading.\n     */\n    private static final String DOCUMENT_REFERENCE_STACK_KEY = \"internal.displayer.title.documentReferenceStack\";\n\n    /**\n     * The object used for logging.\n     */\n    @Inject\n    private Logger logger;\n\n    /**\n     * The component used to parse the rendered title into an XDOM.\n     */\n    @Inject\n    @Named(\"plain/1.0\")\n    private Parser plainTextParser;\n\n    /**\n     * The component used to get the Velocity Engine and the Velocity Context needed to evaluate the Velocity script\n     * from the document title.\n     */\n    @Inject\n    private VelocityManager velocityManager;\n\n    /**\n     * The component used to get the current document reference.\n     */\n    @Inject\n    private DocumentAccessBridge documentAccessBridge;\n\n    /**\n     * The component used to serialize entity references.\n     */\n    @Inject\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Execution context handler, needed for accessing the XWiki context map.\n     */\n    @Inject\n    private Execution execution;\n\n    @Inject\n    @Named(\"xwikicfg\")\n    private ConfigurationSource xwikicfg;\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    /**\n     * Used to get the default document reference, which normally is used to represent the home page of a space.\n     *\n     * @see #getStaticTitle(DocumentModelBridge)\n     */\n    @Inject\n    private EntityReferenceProvider defaultEntityReferenceProvider;\n\n    @Inject\n    private ModelContext modelContext;\n\n    /**\n     * Used to emulate an in-line parsing.\n     */\n    private ParserUtils parserUtils = new ParserUtils();\n\n    @Override\n    public XDOM display(DocumentModelBridge document, DocumentDisplayerParameters parameters)\n    {\n        // Protect against infinite recursion which can happen for instance if the document title displayer is called on\n        // the current document from the title field or from a script within the first content heading.\n        Deque<DocumentReference> documentReferenceStack = getDocumentReferenceDeque();\n\n        if (documentReferenceStack.contains(document.getDocumentReference())) {\n            this.logger.warn(\n                \"Infinite recursion detected while displaying the title of [{}]. Using the document name as title.\",\n                document.getDocumentReference());\n\n            return getStaticTitle(document);\n        }\n\n        documentReferenceStack.push(document.getDocumentReference());\n        try {\n            return displayTitle(document, parameters);\n        } finally {\n            documentReferenceStack.pop();\n        }\n    }\n\n    private Deque<DocumentReference> getDocumentReferenceDeque()\n    {\n        ExecutionContext econtext = this.execution.getContext();\n\n        Deque<DocumentReference> documentReferenceStack =\n            (Deque<DocumentReference>) econtext.getProperty(DOCUMENT_REFERENCE_STACK_KEY);\n\n        if (documentReferenceStack == null) {\n            documentReferenceStack = new LinkedList<>();\n            econtext.newProperty(DOCUMENT_REFERENCE_STACK_KEY).inherited().initial(documentReferenceStack).declare();\n        }\n\n        return documentReferenceStack;\n    }\n\n    private XDOM displayTitle(DocumentModelBridge document, DocumentDisplayerParameters parameters)\n    {\n        // 1. Try to use the title provided by the user.\n        String rawTitle = document.getTitle();\n        if (!StringUtils.isEmpty(rawTitle)) {\n            try {\n                String title = rawTitle;\n                // Evaluate the title only if the document has script rights, otherwise use the raw title.\n                if (authorizationManager.hasAccess(Right.SCRIPT, document.getContentAuthorReference(),\n                    document.getDocumentReference())) {\n                    title = evaluateTitle(rawTitle, document, parameters);\n                }\n                return parseTitle(title);\n            } catch (Exception e) {\n                logger.warn(\"Failed to interpret title of document [{}].\", document.getDocumentReference(), e);\n            }\n        }\n\n        // 2. Try to extract the title from the document content.\n        if (\"1\".equals(this.xwikicfg.getProperty(\"xwiki.title.compatibility\", \"0\"))) {\n            try {\n                XDOM title = extractTitleFromContent(document, parameters);\n                if (title != null) {\n                    return title;\n                }\n            } catch (Exception e) {\n                logger.warn(\"Failed to extract title from content of document [{}].\", document.getDocumentReference(),\n                    e);\n            }\n        }\n\n        // 3. The title was not specified or its evaluation failed. Use the document name as a fall-back.\n        return getStaticTitle(document);\n    }\n\n    /**\n     * Parses the given title as plain text and returns the generated XDOM.\n     *\n     * @param title the title to be parsed\n     * @return the XDOM generated from parsing the title as plain text\n     */\n    protected XDOM parseTitle(String title)\n    {\n        try {\n            XDOM xdom = plainTextParser.parse(new StringReader(title));\n            parserUtils.removeTopLevelParagraph(xdom.getChildren());\n            return xdom;\n        } catch (ParseException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Evaluates the Velocity script from the specified title.\n     *\n     * @param title the title to evaluate\n     * @param documentReference a reference to the document whose title is evaluated\n     * @param parameters display parameters\n     * @return the result of evaluating the Velocity script from the given title\n     */\n    protected String evaluateTitle(String title, DocumentModelBridge document,\n        DocumentDisplayerParameters parameters)\n    {\n        StringWriter writer = new StringWriter();\n        String namespace = defaultEntityReferenceSerializer.serialize(parameters.isTransformationContextIsolated()\n            ? document.getDocumentReference() : documentAccessBridge.getCurrentDocumentReference());\n\n        // Get the velocity engine\n        VelocityEngine velocityEngine;\n        try {\n            velocityEngine = this.velocityManager.getVelocityEngine();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        // Execute Velocity code\n        Map<String, Object> backupObjects = null;\n        boolean canPop = false;\n        EntityReference currentWikiReference = this.modelContext.getCurrentEntityReference();\n        try {\n            if (parameters.isExecutionContextIsolated()) {\n                backupObjects = new HashMap<>();\n                // The following method call also clones the execution context.\n                documentAccessBridge.pushDocumentInContext(backupObjects, document);\n                // Pop the document from the context only if the push was successful!\n                canPop = true;\n                // Make sure to synchronize the context wiki with the context document's wiki.\n                modelContext.setCurrentEntityReference(document.getDocumentReference().getWikiReference());\n            }\n            velocityEngine.evaluate(velocityManager.getVelocityContext(), writer, namespace, title);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (canPop) {\n                documentAccessBridge.popDocumentFromContext(backupObjects);\n                // Also restore the context wiki.\n                this.modelContext.setCurrentEntityReference(currentWikiReference);\n            }\n        }\n        return writer.toString();\n    }\n\n    /**\n     * Extracts the title from the document content.\n     *\n     * @param document the document to extract the title from\n     * @param parameters display parameters\n     * @return the title XDOM\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    protected abstract XDOM extractTitleFromContent(DocumentModelBridge document,\n        DocumentDisplayerParameters parameters);\n\n    /**\n     * @param document an XWiki document\n     * @return the title used as a fall-back when the dynamic title cannot be evaluated\n     */\n    private XDOM getStaticTitle(DocumentModelBridge document)\n    {\n        String documentName = document.getDocumentReference().getName();\n        if (defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName().equals(documentName)) {\n            // This document represents a space (it is the home page of a space). Use the space name instead.\n            documentName = document.getDocumentReference().getParent().getName();\n        }\n        return parseTitle(documentName);\n    }\n\n    /**\n     * @return the object used for logging\n     */\n    protected Logger getLogger()\n    {\n        return logger;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.display.internal;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.inject.Inject;\n\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.rendering.RenderingException;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.async.internal.AsyncProperties;\nimport org.xwiki.rendering.async.internal.block.AbstractBlockAsyncRenderer;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.syntax.Syntax;\n\n/**\n * Default implementation of DocumentContentAsyncRenderer.\n * \n * @version $Id$\n * @since 11.8RC1\n */\n@Component(roles = DocumentContentAsyncRenderer.class)\npublic class DocumentContentAsyncRenderer extends AbstractBlockAsyncRenderer\n{\n    @Inject\n    private DocumentContentAsyncExecutor executor;\n\n    @Inject\n    private AsyncContext asyncContext;\n\n    @Inject\n    private DocumentAccessBridge documentAccessBridge;\n\n    @Inject\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    @Inject\n    private DocumentContentAsyncParser asyncParser;\n\n    private DocumentDisplayerParameters parameters;\n\n    private AsyncProperties asyncProperties;\n\n    private DocumentReference documentReference;\n\n    private List<String> id;\n\n    /**\n     * @param document the document to execute\n     * @param parameters display parameters\n     * @return the context elements required during the execution\n     */\n    public Set<String> initialize(DocumentModelBridge document, DocumentDisplayerParameters parameters)\n    {\n        this.parameters = parameters;\n\n        this.asyncProperties = this.asyncParser.getAsyncProperties(document);\n\n        String transformationId = this.defaultEntityReferenceSerializer\n            .serialize(parameters.isContentTransformed() && parameters.isTransformationContextIsolated()\n                ? document.getDocumentReference() : this.documentAccessBridge.getCurrentDocumentReference());\n\n        this.documentReference = document.getDocumentReference();\n\n        if (this.asyncProperties.isAsyncAllowed() || this.asyncProperties.isCacheAllowed()) {\n            this.id = createId(\"display\", \"document\", \"content\",\n                this.defaultEntityReferenceSerializer.serialize(this.documentReference), this.parameters.getSectionId(),\n                this.parameters.getTargetSyntax() != null ? this.parameters.getTargetSyntax().toIdString() : \"\",\n                transformationId, this.parameters.isContentTransformed(),\n                this.parameters.isTransformationContextRestricted(), this.parameters.isTransformationContextIsolated());\n        }\n\n        this.executor.initialize(transformationId, document, parameters);\n\n        return this.asyncProperties.getContextElements();\n    }\n\n    @Override\n    public Block execute(boolean async, boolean cached) throws RenderingException\n    {\n        // Register the known involved references\n        this.asyncContext.useEntity(this.documentReference);\n\n        return this.executor.execute(async);\n    }\n\n    @Override\n    public List<String> getId()\n    {\n        return this.id;\n    }\n\n    @Override\n    public boolean isAsyncAllowed()\n    {\n        return this.asyncProperties.isAsyncAllowed();\n    }\n\n    @Override\n    public boolean isCacheAllowed()\n    {\n        return this.asyncProperties.isCacheAllowed();\n    }\n\n    @Override\n    public boolean isInline()\n    {\n        return false;\n    }\n\n    @Override\n    public Syntax getTargetSyntax()\n    {\n        return this.parameters.getTargetSyntax();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.display.internal;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.HeaderBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationException;\nimport org.xwiki.rendering.transformation.TransformationManager;\n\n/**\n * Displays the title of a document. If the title is not specified, extracts the document title from the first heading\n * in the document content that has the level less than or equal to {@link DisplayConfiguration#getTitleHeadingDepth()}.\n * \n * @version $Id$\n * @since 3.2M3\n */\n@Component\n@Named(\"title\")\n@Singleton\npublic class DocumentTitleDisplayer extends AbstractDocumentTitleDisplayer\n{\n    /**\n     * The component used to perform the rendering transformations on the title extracted from the document content.\n     */\n    @Inject\n    private TransformationManager transformationManager;\n\n    /**\n     * The display configuration.\n     */\n    @Inject\n    private DisplayConfiguration displayConfiguration;\n\n    @Override\n    protected XDOM extractTitleFromContent(DocumentModelBridge document, DocumentDisplayerParameters parameters)\n    {\n        // Note: Ideally we should apply transformations on the document's returned XDOM here since macros could\n        // generate headings for example or some other transformations could modify headings. However we don't do this\n        // at the moment since it would be too costly to do so. In the future we will even probably remove the feature\n        // of generating the title from the content.\n        List<HeaderBlock> blocks =\n            document.getXDOM().getBlocks(new ClassBlockMatcher(HeaderBlock.class), Block.Axes.DESCENDANT);\n        if (!blocks.isEmpty()) {\n            HeaderBlock heading = blocks.get(0);\n            // Check the heading depth after which we should return null if no heading was found.\n            if (heading.getLevel().getAsInt() <= displayConfiguration.getTitleHeadingDepth()) {\n                XDOM headingXDOM = new XDOM(Collections.<Block> singletonList(heading));\n                try {\n                    TransformationContext txContext =\n                        new TransformationContext(headingXDOM, document.getSyntax(),\n                                                  parameters.isTransformationContextRestricted());\n                    txContext.setTargetSyntax(parameters.getTargetSyntax());\n                    transformationManager.performTransformations(headingXDOM, txContext);\n\n                    Block headingBlock = headingXDOM.getChildren().size() > 0 ? headingXDOM.getChildren().get(0) : null;\n                    if (headingBlock instanceof HeaderBlock) {\n                        return new XDOM(headingBlock.getChildren());\n                    }\n                } catch (TransformationException e) {\n                    getLogger().warn(\"Failed to extract title from document content.\");\n                }\n            }\n        }\n        return null;\n    }\n}\n", "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n<div class=\"row document-header\">\n  <div class=\"document-info col-xs-12 #if($displayContentMenu)col-md-7#end\">\n    ## --------------------------------------------------------\n    ## Display UI Extensions before the title element\n    ## --------------------------------------------------------\n    #foreach ($uix in $services.uix.getExtensions('org.xwiki.platform.template.title.before'))\n      $services.rendering.render($uix.execute(), 'xhtml/1.0')\n    #end\n    <div id=\"document-title\"><h1>$titleToDisplay</h1></div>\n    #if (!$doc.isNew())\n      ## Note that this serialization step is mandatory and we cannot count on the UserReferenceConverter here\n      ## because UserReference#toString does not rely on the serializer so it's not the expected format for\n      ## XWiki#getUserName(String).\n      #set ($authorName = $services.user.serialize($tdoc.authors.originalMetadataAuthor))\n      <div class=\"xdocLastModification\">\n        #if (!$doc.isMostRecent())\n          $services.localization.render(\n            'core.document.modificationWithVersion',\n            [\"<a href='$tdoc.getURL('view', \"\"rev=$tdoc.version\"\")'>$tdoc.version</a>\",\n            $xwiki.getUserName($authorName),\n            $xwiki.formatDate($tdoc.date)\n          ])\n        #else\n          $services.localization.render('core.footer.modification', [$xwiki.getUserName($authorName), $xwiki.formatDate($tdoc.date)])\n        #end\n      </div>\n    #end\n  </div>\n  #if($displayContentMenu)\n    <div class=\"document-menu col-xs-12 col-md-5\">\n      #template(\"menus_content.vm\")\n    </div>\n  #end\n</div>\n<hr/>\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.flamingo.test.docker;\n\nimport java.io.File;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsPane;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsViewPage;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.test.docker.junit5.TestConfiguration;\nimport org.xwiki.test.docker.junit5.TestReference;\nimport org.xwiki.test.docker.junit5.UITest;\nimport org.xwiki.test.ui.TestUtils;\nimport org.xwiki.test.ui.po.DeletePageOutcomePage;\nimport org.xwiki.test.ui.po.DeletedPageEntry;\nimport org.xwiki.test.ui.po.DeletingPage;\nimport org.xwiki.test.ui.po.HistoryPane;\nimport org.xwiki.test.ui.po.ViewPage;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Functional tests related to recycle bin operations.\n *\n * @version $Id$\n * @since 13.10.4\n * @since 14.2RC1\n */\n@UITest\nclass RecycleBinIT\n{\n    /**\n     * @see \"XWIKI-9421: Attachment version is incremented when a document is restored from recycle bin\"\n     */\n    @Test\n    @Order(1)\n    void restore(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration) throws Exception\n    {\n        setup.loginAsSuperAdmin();\n\n        // Clean up.\n        setup.rest().deletePage(testReference.getLastSpaceReference().getName(), testReference.getName());\n\n        // Create a new page.\n        ViewPage page = setup.createPage(testReference, \"Once upon a time..\", \"A story\");\n\n        // Add an attachment.\n        new AttachmentsViewPage().openAttachmentsDocExtraPane().setFileToUpload(\n            new File(testConfiguration.getBrowser().getTestResourcesPath(),\n                \"RecycleBinIT/SmallAttachment.txt\").getAbsolutePath());\n\n        // Delete the page.\n        page.delete().clickYes();\n        DeletingPage deletingPage = new DeletingPage();\n        deletingPage.waitUntilFinished();\n\n        DeletePageOutcomePage deletePageOutcomePage = deletingPage.getDeletePageOutcomePage();\n\n        // Open the page in preview mode (by clicking on the link of the second column), and check that the content is\n        // the one expected.\n        ViewPage viewPage = deletePageOutcomePage.clickViewDocument(1);\n        assertEquals(\"A story\", viewPage.getDocumentTitle());\n        assertEquals(\"Once upon a time..\", viewPage.getContent());\n\n        // Goes back to the previous page to continue the page restoration.\n        setup.getDriver().navigate().back();\n\n        // Restore the page.\n        page = deletePageOutcomePage.clickRestore();\n\n        // Check the page title and content.\n        assertEquals(\"A story\", page.getDocumentTitle());\n        assertEquals(\"Once upon a time..\", page.getContent());\n\n        // Check document version/history.\n        HistoryPane historyPane = page.openHistoryDocExtraPane();\n        assertEquals(\"2.1\", historyPane.getCurrentVersion());\n\n        // Check the attachment.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(\"SmallAttachment.txt\"));\n\n        // Check the attachment content.\n        attachmentsPane.getAttachmentLink(\"SmallAttachment.txt\").click();\n        assertEquals(\"This is a small attachment.\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n    }\n\n    /**\n     * Check that viewing a terminal deleted page works and that rights are properly checked for viewing a deleted page.\n     */\n    @Test\n    @Order(2)\n    void viewDeletedPage(TestUtils testUtils, TestReference parentReference)\n    {\n        /*\n        Fixture:\n          * 3 pages:\n            - ParentSpace\n              - Page1.WebHome\n              - Page1 -> terminal\n          * 2 users\n            - viewDeletedPageUser1: allow edit, delete, view -> deleter of the pages\n            - viewDeletedPageUser2: denied edit, allowed view on the space\n            - viewDeletedPageUser3: denied view / edit on the space\n         */\n\n        String testUserPrefix = parentReference.getName();\n        String user1 = testUserPrefix + \"User1\";\n        String user2 = testUserPrefix + \"User2\";\n        String user3 = testUserPrefix + \"User3\";\n\n        testUtils.loginAsSuperAdmin();\n        testUtils.createUser(user1, user1, null);\n        testUtils.createUser(user2, user2, null);\n        testUtils.createUser(user3, user3, null);\n\n        testUtils.createPage(parentReference, \"Parent space\");\n\n        DocumentReference page1 =\n            new DocumentReference(\"WebHome\", new SpaceReference(\"Page1\", parentReference.getLastSpaceReference()));\n        DocumentReference page1Terminal = new DocumentReference(\"Page1\", parentReference.getLastSpaceReference());\n        DocumentReference page2 =\n            new DocumentReference(\"WebHome\", new SpaceReference(\"Page2\", parentReference.getLastSpaceReference()));\n\n        testUtils.createPage(page1, \"Page 1 non terminal page content\", \"Page 1 Non Terminal\");\n        testUtils.createPage(page1Terminal, \"Page 1 **terminal** page content\", \"Page 1 Terminal\");\n        testUtils.createPage(page2, \"Page 2 content\", \"Page 2\");\n\n        testUtils.setRightsOnSpace(parentReference.getLastSpaceReference(), \"\",\n            String.format(\"XWiki.%s\", user1), \"delete\", true);\n        testUtils.setRightsOnSpace(parentReference.getLastSpaceReference(), \"\",\n            String.format(\"XWiki.%s,XWiki.%s\", user2, user3), \"edit\", false);\n        testUtils.setRightsOnSpace(parentReference.getLastSpaceReference(), \"\",\n            String.format(\"XWiki.%s\", user3), \"view\", false);\n\n        testUtils.login(user3, user3);\n        ViewPage viewPage = testUtils.gotoPage(page1);\n        assertTrue(viewPage.isForbidden());\n\n        viewPage = testUtils.gotoPage(page1Terminal);\n        assertTrue(viewPage.isForbidden());\n\n        viewPage = testUtils.gotoPage(page2);\n        assertTrue(viewPage.isForbidden());\n\n        // Delete all 3 pages\n        testUtils.login(user1, user1);\n\n        viewPage = testUtils.gotoPage(page1);\n        viewPage.deletePage().confirmDeletePage().waitUntilFinished();\n\n        viewPage = testUtils.gotoPage(page1Terminal);\n        viewPage.deletePage().confirmDeletePage().waitUntilFinished();\n\n        viewPage = testUtils.gotoPage(page2);\n        viewPage.deletePage().confirmDeletePage().waitUntilFinished();\n\n        // Check view deleted page with User2\n        testUtils.login(user2, user2);\n        testUtils.gotoPage(page1);\n\n        DeletePageOutcomePage recycleBinPage1 = new DeletePageOutcomePage();\n        List<DeletedPageEntry> deletedPagesEntries = recycleBinPage1.getDeletedPagesEntries();\n        List<DeletedPageEntry> deletedTerminalPagesEntries = recycleBinPage1.getDeletedTerminalPagesEntries();\n\n        // Check that both Page1 and Page1 terminal are shown\n        assertEquals(1, deletedPagesEntries.size());\n        assertEquals(1, deletedTerminalPagesEntries.size());\n\n        assertEquals(user1, deletedPagesEntries.get(0).getDeleter());\n        assertEquals(user1, deletedTerminalPagesEntries.get(0).getDeleter());\n\n        // Check that the user cannot view the page as it's not the deleter\n        assertFalse(deletedPagesEntries.get(0).canBeViewed());\n        assertFalse(deletedTerminalPagesEntries.get(0).canBeViewed());\n\n        // Check that however other actions are not possible\n        assertFalse(deletedPagesEntries.get(0).canBeDeleted());\n        assertFalse(deletedTerminalPagesEntries.get(0).canBeDeleted());\n\n        // Check that however other actions are not possible\n        assertFalse(deletedPagesEntries.get(0).canBeRestored());\n        assertFalse(deletedTerminalPagesEntries.get(0).canBeRestored());\n\n        // Check view deleted page with User1\n        testUtils.login(user1, user1);\n        testUtils.gotoPage(page1);\n\n        recycleBinPage1 = new DeletePageOutcomePage();\n        deletedPagesEntries = recycleBinPage1.getDeletedPagesEntries();\n        deletedTerminalPagesEntries = recycleBinPage1.getDeletedTerminalPagesEntries();\n\n        // Check that both Page1 and Page1 terminal are shown\n        assertEquals(1, deletedPagesEntries.size());\n        assertEquals(1, deletedTerminalPagesEntries.size());\n\n        assertEquals(user1, deletedPagesEntries.get(0).getDeleter());\n        assertEquals(user1, deletedTerminalPagesEntries.get(0).getDeleter());\n\n        // Check that both are viewable by the user\n        assertTrue(deletedPagesEntries.get(0).canBeViewed());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeViewed());\n\n        // Check that permanently delete is not possible\n        assertFalse(deletedPagesEntries.get(0).canBeDeleted());\n        assertFalse(deletedTerminalPagesEntries.get(0).canBeDeleted());\n\n        // Check that restore is also possible\n        assertTrue(deletedPagesEntries.get(0).canBeRestored());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeRestored());\n\n        // View content of the deleted terminal page\n        viewPage = deletedTerminalPagesEntries.get(0).clickView();\n\n        // Keep track of the URL to try accessing it later on\n        String terminalPageDeletedViewUrl = testUtils.getDriver().getCurrentUrl();\n\n        assertEquals(\"Page 1 Terminal\", viewPage.getDocumentTitle());\n        assertEquals(\"Page 1 terminal page content\", viewPage.getContent());\n\n        // Check view deleted page with User3\n        testUtils.login(user3, user3);\n        viewPage = testUtils.gotoPage(page1);\n\n        assertTrue(viewPage.isForbidden());\n\n        // Try to access the deleted revision\n        testUtils.gotoPage(terminalPageDeletedViewUrl);\n        viewPage = new ViewPage();\n\n        assertTrue(viewPage.isForbidden());\n\n        // Also try access the deleted revision with user2\n        testUtils.login(user2, user2);\n        testUtils.gotoPage(terminalPageDeletedViewUrl);\n        viewPage = new ViewPage();\n\n        assertTrue(viewPage.isForbidden());\n\n        // Check view deleted page with superadmin\n        testUtils.loginAsSuperAdmin();\n        viewPage = testUtils.gotoPage(page1);\n\n        recycleBinPage1 = new DeletePageOutcomePage();\n        deletedPagesEntries = recycleBinPage1.getDeletedPagesEntries();\n        deletedTerminalPagesEntries = recycleBinPage1.getDeletedTerminalPagesEntries();\n\n        // Check that both Page1 and Page1 terminal are shown\n        assertEquals(1, deletedPagesEntries.size());\n        assertEquals(1, deletedTerminalPagesEntries.size());\n\n        // Check that all actions are possible\n        assertTrue(deletedPagesEntries.get(0).canBeViewed());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeViewed());\n\n        assertTrue(deletedPagesEntries.get(0).canBeDeleted());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeDeleted());\n\n        assertTrue(deletedPagesEntries.get(0).canBeRestored());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeRestored());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.flamingo.test.docker;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsPane;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsViewPage;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.test.docker.junit5.TestReference;\nimport org.xwiki.test.docker.junit5.UITest;\nimport org.xwiki.test.ui.TestUtils;\nimport org.xwiki.test.ui.po.HistoryPane;\nimport org.xwiki.test.ui.po.ViewPage;\nimport org.xwiki.test.ui.po.editor.WikiEditPage;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Verify versioning features of documents and attachments.\n * \n * @version $Id$\n */\n@UITest(properties = {\n    // Add the FileUploadPlugin which is needed by the test to upload attachment files\n    \"xwikiCfgPlugins=com.xpn.xwiki.plugin.fileupload.FileUploadPlugin\"})\nclass VersionIT\n{\n    private static final String TITLE = \"Page Title\";\n\n    private static final String CONTENT1 = \"First version of Content\";\n\n    private static final String CONTENT2 = \"Second version of Content\";\n\n    @BeforeAll\n    void setup(TestUtils setup)\n    {\n        setup.loginAsSuperAdmin();\n    }\n\n    @Test\n    @Order(1)\n    void testRollbackToFirstVersion(TestUtils utils, TestReference testReference) throws Exception\n    {\n        utils.rest().delete(testReference);\n\n        // Create first version of the page\n        ViewPage vp = utils.createPage(testReference, CONTENT1, TITLE);\n\n        // Adds second version\n        WikiEditPage wikiEditPage = vp.editWiki();\n        wikiEditPage.setContent(CONTENT2);\n        wikiEditPage.clickSaveAndView();\n\n        // TODO: Remove when XWIKI-6688 (Possible race condition when clicking on a tab at the bottom of a page in\n        // view mode) is fixed.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        // Verify that we can rollback to the first version\n        HistoryPane historyTab = vp.openHistoryDocExtraPane();\n        vp = historyTab.rollbackToVersion(\"1.1\");\n\n        // Rollback doesn't wait...\n        // Wait for the comment tab to be selected since we're currently on the history tab and rolling\n        // back is going to load a new page and make the focus active on the comments tab.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        assertEquals(\"First version of Content\", vp.getContent());\n\n        historyTab = vp.openHistoryDocExtraPane();\n        assertEquals(\"Rollback to version 1.1\", historyTab.getCurrentVersionComment());\n        assertEquals(\"superadmin\", historyTab.getCurrentAuthor());\n    }\n\n    /**\n     * See XWIKI-8781 & XWIKI-20589\n     */\n    @Test\n    @Order(2)\n    void testDeleteLatestVersion(TestUtils setup, TestReference testReference) throws Exception\n    {\n        setup.rest().delete(testReference);\n\n        // Create first version of the page, as superadmin\n        setup.createPage(testReference, CONTENT1, TITLE);\n\n        // Log as another user having admin permissions (to be able to delete a revision)\n        setup.createAdminUser();\n\n        // Adds second version, as Admin\n        ViewPage vp = setup.gotoPage(testReference);\n        vp.edit();\n        WikiEditPage wikiEditPage = new WikiEditPage();\n        wikiEditPage.setContent(CONTENT2);\n        wikiEditPage.clickSaveAndView();\n\n        // TODO: Remove when XWIKI-6688 (Possible race condition when clicking on a tab at the bottom of a page in\n        // view mode) is fixed.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        // Verify and delete the latest version.\n        HistoryPane historyTab = vp.openHistoryDocExtraPane();\n        assertEquals(\"2.1\", historyTab.getCurrentVersion());\n        historyTab = historyTab.deleteVersion(\"2.1\");\n\n        // Verify that the current version is now the previous one.\n        assertEquals(\"1.1\", historyTab.getCurrentVersion());\n        assertEquals(\"superadmin\", historyTab.getCurrentAuthor());\n\n        // Verify that the last modified author of the page is the author from revision 1.1\n        assertTrue(vp.getLastModifiedText().startsWith(\"Last modified by superadmin\"));\n    }\n\n    @Test\n    @Order(3)\n    void rollbackAttachments(TestUtils utils, TestReference testReference) throws Exception\n    {\n        utils.rest().delete(testReference);\n\n        // Create empty page\n        utils.rest().savePage(testReference);\n\n        // Add attachment\n        AttachmentReference attachmentReference = new AttachmentReference(\"file.txt\", testReference);\n        utils.rest().attachFile(attachmentReference, \"attachment1\".getBytes(), true);\n\n        // Add a second version of the attachment\n        utils.rest().attachFile(attachmentReference, \"attachment2\".getBytes(), false);\n\n        // Load page\n        ViewPage vp = utils.gotoPage(testReference);\n\n        // Make sure expected attachment is there\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.2\", attachmentsPane.getLatestVersionOfAttachment(attachmentReference.getName()));\n\n        // Revert to 1.1 (empty page)\n        vp = vp.openHistoryDocExtraPane().rollbackToVersion(\"1.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(0, attachmentsPane.getNumberOfAttachments());\n\n        // Revert to 3.1 (second update of the attachment)\n        vp = vp.openHistoryDocExtraPane().rollbackToVersion(\"3.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.2\", attachmentsPane.getLatestVersionOfAttachment(attachmentReference.getName()));\n        attachmentsPane.getAttachmentLink(attachmentReference.getName()).click();\n        assertEquals(\"attachment2\", utils.getDriver().findElement(By.tagName(\"html\")).getText());\n\n        // Revert to 2.1 (first update of the attachment)\n        vp = utils.gotoPage(testReference).openHistoryDocExtraPane().rollbackToVersion(\"2.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.3\", attachmentsPane.getLatestVersionOfAttachment(attachmentReference.getName()));\n        attachmentsPane.getAttachmentLink(attachmentReference.getName()).click();\n        assertEquals(\"attachment1\", utils.getDriver().findElement(By.tagName(\"html\")).getText());\n\n        // Back to empty page again\n        vp = utils.gotoPage(testReference).openHistoryDocExtraPane().rollbackToVersion(\"1.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(0, attachmentsPane.getNumberOfAttachments());\n\n        // Revert to 2.1 (first update of the attachment)\n        vp = vp.openHistoryDocExtraPane().rollbackToVersion(\"2.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.3\", attachmentsPane.getLatestVersionOfAttachment(attachmentReference.getName()));\n        attachmentsPane.getAttachmentLink(attachmentReference.getName()).click();\n        assertEquals(\"attachment1\", utils.getDriver().findElement(By.tagName(\"html\")).getText());\n    }\n\n    /**\n     * Ensure that a previous deleted attachment with same name and version than an existing one is properly restored\n     * after a rollback of a page version.\n     */\n    @Test\n    @Order(4)\n    void rollbackAttachmentWithSameNameAndVersion(TestUtils utils, TestReference testReference) throws Exception\n    {\n        utils.rest().delete(testReference);\n\n        // Create empty page (1.1)\n        utils.createPage(testReference, \"\");\n\n        // Add attachment (2.1)\n        AttachmentReference attachmentReference = new AttachmentReference(\"file.txt\", testReference);\n        utils.rest().attachFile(attachmentReference, \"1\".getBytes(), true);\n\n        // Delete attachment (3.1)\n        utils.rest().deleteAttachement(attachmentReference);\n\n        // Make sure those two attachments are not saved at during the same second since the granularity is the second\n        // in some databases\n        Thread.sleep(1000);\n\n        // Add a new attachment with the same name (4.1)\n        utils.rest().attachFile(attachmentReference, \"2\".getBytes(), true);\n\n        ViewPage viewPage = utils.gotoPage(testReference);\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(\"file.txt\"));\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(\"file.txt\"));\n\n        // Revert to first attachment (2.1)\n        viewPage = utils.gotoPage(testReference);\n        HistoryPane historyPane = viewPage.openHistoryDocExtraPane();\n\n        viewPage = historyPane.rollbackToVersion(\"2.1\");\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(\"file.txt\"));\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(\"file.txt\"));\n        attachmentsPane.getAttachmentLink(\"file.txt\").click();\n        assertEquals(\"1\", utils.getDriver().findElement(By.tagName(\"html\")).getText());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.dom4j.Document;\nimport org.dom4j.io.OutputFormat;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.HeaderBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.listener.HeaderLevel;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationManager;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.api.DocumentSection;\nimport com.xpn.xwiki.internal.xml.XMLWriter;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.plugin.query.XWikiCriteria;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Add a backward compatibility layer to the {@link com.xpn.xwiki.doc.XWikiDocument} class.\n *\n * @version $Id$\n */\nprivileged public aspect XWikiDocumentCompatibilityAspect\n{\n    /**\n     * @deprecated since 3.0M3 use {@code Syntax.XWIKI_1_0} instead\n     */\n    @Deprecated\n    public static final String XWikiDocument.XWIKI10_SYNTAXID = Syntax.XWIKI_1_0.toIdString();\n\n    /**\n     * @deprecated since 3.0M3 use {@code Syntax.XWIKI_2_0} instead\n     */\n    @Deprecated\n    public static final String XWikiDocument.XWIKI20_SYNTAXID = Syntax.XWIKI_2_0.toIdString();\n\n    /**\n     * @deprecated use setStringListValue or setDBStringListProperty\n     */\n    @Deprecated\n    public void XWikiDocument.setListValue(String className, String fieldName, List value)\n    {\n        BaseObject bobject = getObject(className);\n        if (bobject == null) {\n            bobject = new BaseObject();\n            addObject(className, bobject);\n        }\n        bobject.setName(getFullName());\n        bobject.setClassName(className);\n        bobject.setListValue(fieldName, value);\n        setMetaDataDirty(true);\n    }\n    \n    /**\n     * This method to split section according to title.\n     * \n     * @return the sections in the current document\n     * @throws XWikiException\n     * @deprecated use {@link #getSections()} instead, since 1.6M1\n     */\n    @Deprecated\n    public List<DocumentSection> XWikiDocument.getSplitSectionsAccordingToTitle() throws XWikiException\n    {\n        return getSections();\n    }\n    \n    /**\n     * @deprecated use {@link #getUniqueLinkedPages(XWikiContext)}\n     */\n    @Deprecated\n    public List<String> XWikiDocument.getLinkedPages(XWikiContext context)\n    {\n        return new ArrayList<String>(getUniqueLinkedPages(context));\n    }\n    \n    /**\n     * @deprecated use {@link #getUniqueWikiLinkedPages(XWikiContext)} instead\n     */\n    @Deprecated\n    public List<XWikiLink> XWikiDocument.getLinks(XWikiContext context) throws XWikiException\n    {\n        return getWikiLinkedPages(context);\n    }\n\n    /**\n     * @deprecated use {@link #getUniqueWikiLinkedPages(XWikiContext)} instead\n     */\n    @Deprecated\n    public List<XWikiLink> XWikiDocument.getWikiLinkedPages(XWikiContext context) throws XWikiException\n    {\n        return new ArrayList<XWikiLink>(getUniqueWikiLinkedPages(context));\n    }\n    \n    /**\n     * @deprecated use {@link #getBackLinkedPages(XWikiContext)} instead\n     */\n    @Deprecated\n    public List<String> XWikiDocument.getBacklinks(XWikiContext context) throws XWikiException\n    {\n        return getBackLinkedPages(context);\n    }\n    \n    /**\n     * @param text the text to render\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document\n     * @deprecated since 1.6M1 use {@link #getRenderedContent(String, String, com.xpn.xwiki.XWikiContext)}\n     */\n    @Deprecated\n    public String XWikiDocument.getRenderedContent(String text, XWikiContext context)\n    {\n        return getRenderedContent(text, Syntax.XWIKI_1_0.toIdString(), context);\n    }\n\n    @Deprecated\n    public String XWikiDocument.displaySearch(PropertyClass pclass, String prefix, XWikiCriteria criteria, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displaySearch(pclass.getName(), prefix, criteria, context);\n    }\n\n    /**\n     * @param context the XWiki context used to get access to the com.xpn.xwiki.render.XWikiRenderingEngine object\n     * @return the document title. If a title has not been provided, look for a section title in the document's content\n     *         and if not found return the page name. The returned title is also interpreted which means it's allowed to\n     *         use Velocity, Groovy, etc syntax within a title.\n     * @deprecated use {@link #getRenderedTitle(Syntax, XWikiContext)} instead\n     */\n    @Deprecated\n    public String XWikiDocument.getDisplayTitle(XWikiContext context)\n    {\n        return getRenderedTitle(Syntax.XHTML_1_0, context);\n    }\n\n    /**\n     * @deprecated since 2.2M1, use {@link #getXClass()} instead\n     */\n    @Deprecated\n    public BaseClass XWikiDocument.getxWikiClass()\n    {\n        return getXClass();\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #addXObjectFromRequest(XWikiContext)}\n     */\n    @Deprecated\n    public BaseObject XWikiDocument.addObjectFromRequest(XWikiContext context) throws XWikiException\n    {\n        return addXObjectFromRequest(context);\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #setXObjectsToRemove(List)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setObjectsToRemove(ArrayList<BaseObject> objectsToRemove)\n    {\n        setXObjectsToRemove(objectsToRemove);\n    }\n\n    /**\n     * @deprecated since 2.2M1, use {@link #setXClass(BaseClass)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setxWikiClass(BaseClass xwikiClass)\n    {\n        setXClass(xwikiClass);\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #getXObjects()} instead. Warning: if you used to modify the returned Map note\n     *             that since 2.2M1 this will no longer work and you'll need to call the setXObject methods instead (or\n     *             setxWikiObjects()). Obviously the best is to move to the new API.\n     */\n    @Deprecated\n    public Map<String, Vector<BaseObject>> XWikiDocument.getxWikiObjects()\n    {\n        // Use a liked hash map to ensure we keep the order stored from the internal objects map.\n        Map<String, Vector<BaseObject>> objects = new LinkedHashMap<String, Vector<BaseObject>>();\n\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : getXObjects().entrySet()) {\n            objects.put(getCompactWikiEntityReferenceSerializer().serialize(entry.getKey()), new Vector<BaseObject>(\n                entry.getValue()));\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #setXObjects(Map)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setxWikiObjects(Map<String, Vector<BaseObject>> objects)\n    {\n        // Use a liked hash map to ensure we keep the order stored from the internal objects map.\n        Map<DocumentReference, List<BaseObject>> newObjects = new LinkedHashMap<DocumentReference, List<BaseObject>>();\n\n        for (Map.Entry<String, Vector<BaseObject>> entry : objects.entrySet()) {\n            newObjects.put(resolveClassReference(entry.getKey()), new ArrayList<BaseObject>(entry.getValue()));\n        }\n\n        setXObjects(newObjects);\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #getXClasses(XWikiContext)} instead\n     */\n    @Deprecated\n    public List<BaseClass> XWikiDocument.getxWikiClasses(XWikiContext context)\n    {\n        return getXClasses(context);\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #setXObjects(DocumentReference, List)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setObjects(String className, Vector<BaseObject> objects)\n    {\n        setXObjects(resolveClassReference(className), new ArrayList<BaseObject>(objects));\n    }\n\n    /**\n     * @deprecated since 3.2M3, use {@link #getRenderedTitle(Syntax, XWikiContext)} instead\n     */\n    @Deprecated\n    public String XWikiDocument.extractTitle()\n    {\n        String title = \"\";\n\n        try {\n            if (is10Syntax()) {\n                title = extractTitle10();\n            } else {\n                List<HeaderBlock> blocks =\n                    getXDOM().getBlocks(new ClassBlockMatcher(HeaderBlock.class), Block.Axes.DESCENDANT);\n                if (!blocks.isEmpty()) {\n                    HeaderBlock header = blocks.get(0);\n                    if (header.getLevel().compareTo(HeaderLevel.LEVEL2) <= 0) {\n                        XDOM headerXDOM = new XDOM(Collections.<Block> singletonList(header));\n\n                        // transform\n                        TransformationContext context = new TransformationContext(headerXDOM, getSyntax());\n                        Utils.getComponent(TransformationManager.class).performTransformations(headerXDOM, context);\n\n                        // render\n                        Block headerBlock = headerXDOM.getChildren().get(0);\n                        if (headerBlock instanceof HeaderBlock) {\n                            title = renderXDOM(new XDOM(headerBlock.getChildren()), Syntax.XHTML_1_0);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Don't stop when there's a problem rendering the title.\n        }\n\n        return title;\n    }\n\n    /**\n     * Regex for finding the first level 1 or 2 heading in the document title, to be used as the document title.\n     * \n     * @deprecated since 3.2M3\n     **/\n    @Deprecated\n    private static final Pattern HEADING_PATTERN_10 = Pattern.compile(\"^\\\\s*+1(?:\\\\.1)?\\\\s++(.++)$\", Pattern.MULTILINE);\n\n    /**\n     * @return the first level 1 or level 1.1 title text in the document's content or \"\" if none are found\n     * @deprecated since 3.2M3\n     */\n    @Deprecated\n    private String XWikiDocument.extractTitle10()\n    {\n        String content = getContent();\n        Matcher m = HEADING_PATTERN_10.matcher(content);\n        if (m.find()) {\n            return m.group(1).trim();\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Convert a {@link Document} into an XML string. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to avoid memory load.\n     * \n     * @param doc the {@link Document} to convert to a String\n     * @param context current XWikiContext\n     * @return an XML representation of the {@link Document}\n     * @deprecated this method has nothing to do here and is apparently unused\n     */\n    @Deprecated\n    public String XWikiDocument.toXML(Document doc, XWikiContext context)\n    {\n        String encoding = context.getWiki().getEncoding();\n\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        try {\n            XMLWriter wr = new XMLWriter(os, new OutputFormat(\"\", true, encoding));\n            wr.write(doc);\n            return os.toString(encoding);\n        } catch (IOException e) {\n            LOGGER.error(\"Exception while doc.toXML\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #cloneXObjects(XWikiDocument)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.clonexWikiObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc);\n    }\n    \n    /**\n     * @deprecated since 5.2M1 use {@link #removeAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.deleteAttachment(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        deleteAttachment(attachment, true, context);\n    }\n\n    /**\n     * @deprecated since 5.2M1 use {@link #removeAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.deleteAttachment(XWikiAttachment attachment, boolean toRecycleBin, XWikiContext context)\n        throws XWikiException\n    {\n        deleteAttachment(attachment, true, toRecycleBin, context);\n    }\n\n    /**\n     * @deprecated since 5.2M1 use {@link #removeAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated\n    private void XWikiDocument.deleteAttachment(XWikiAttachment attachment, boolean saveDocument, boolean toRecycleBin,\n        XWikiContext context) throws XWikiException\n    {\n        removeAttachment(attachment, toRecycleBin);\n\n        if (saveDocument) {\n            // Save the document\n            context.getWiki().saveDocument(this, \"Deleted attachment [\" + attachment.getFilename() + \"]\", context);\n        }\n    }\n\n    private String XWikiDocument.serializeReference(DocumentReference reference, EntityReferenceSerializer<String> serializer,\n        DocumentReference defaultReference)\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        String originalWikiName = xcontext.getWikiId();\n        XWikiDocument originalCurentDocument = xcontext.getDoc();\n        try {\n            xcontext.setWikiId(defaultReference.getWikiReference().getName());\n            xcontext.setDoc(new XWikiDocument(defaultReference));\n\n            return serializer.serialize(reference);\n        } finally {\n            xcontext.setDoc(originalCurentDocument);\n            xcontext.setWikiId(originalWikiName);\n        }\n    }\n\n    /**\n     * Convert a full document reference into the proper relative document reference (wiki part is removed if it's the\n     * same as document wiki) to store as parent.\n     * \n     * @deprecated since 2.2.3 use {@link #setParentReference(org.xwiki.model.reference.EntityReference)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setParentReference(DocumentReference parentReference)\n    {\n        if (parentReference != null) {\n            setParent(serializeReference(parentReference, getCompactWikiEntityReferenceSerializer(),\n                getDocumentReference()));\n        } else {\n            setParentReference((EntityReference) null);\n        }\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #rename(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public void XWikiDocument.rename(String newDocumentName, XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentName, getBackLinkedPages(context), context);\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #rename(DocumentReference, java.util.List, com.xpn.xwiki.XWikiContext)}\n     */\n    @Deprecated\n    public void XWikiDocument.rename(String newDocumentName, List<String> backlinkDocumentNames, XWikiContext context)\n        throws XWikiException\n    {\n        rename(newDocumentName, backlinkDocumentNames, getChildren(context), context);\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #rename(DocumentReference, List, List, com.xpn.xwiki.XWikiContext)}\n     */\n    @Deprecated\n    public void XWikiDocument.rename(String newDocumentName, List<String> backlinkDocumentNames,\n        List<String> childDocumentNames, XWikiContext context) throws XWikiException\n    {\n        List<DocumentReference> backlinkDocumentReferences = new ArrayList<DocumentReference>();\n        for (String backlinkDocumentName : backlinkDocumentNames) {\n            backlinkDocumentReferences.add(getCurrentMixedDocumentReferenceResolver().resolve(backlinkDocumentName));\n        }\n\n        List<DocumentReference> childDocumentReferences = new ArrayList<DocumentReference>();\n        for (String childDocumentName : childDocumentNames) {\n            childDocumentReferences.add(getCurrentMixedDocumentReferenceResolver().resolve(childDocumentName));\n        }\n\n        rename(getCurrentMixedDocumentReferenceResolver().resolve(newDocumentName), backlinkDocumentReferences,\n            childDocumentReferences, context);\n    }\n\n    /**\n     * Read the document data from the template without performing permission check on the template.\n     *\n     * @param eform the form containing a template information.\n     * @param context current context\n     * @throws XWikiException in case of problem to read the information.\n     * @deprecated Since 14.1RC1 prefer using {@link #readFromTemplate(DocumentReference, XWikiContext)} and be careful\n     *             to check the template rights before.\n     */\n    @Deprecated\n    public void XWikiDocument.readFromTemplate(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String template = eform.getTemplate();\n        readFromTemplate(template, context);\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #readFromTemplate(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.readFromTemplate(String template, XWikiContext context) throws XWikiException\n    {\n        // Keep the same behavior for backward compatibility\n        DocumentReference templateDocumentReference = null;\n        if (StringUtils.isNotEmpty(template)) {\n            templateDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n        }\n        readFromTemplate(templateDocumentReference, context);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.diff.DifferentiationFailedException;\nimport org.suigeneris.jrcs.diff.delta.Delta;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.display.internal.DocumentDisplayerParameters;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.internal.document.SafeDocumentAuthors;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiConstant;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.criteria.impl.Period;\nimport com.xpn.xwiki.criteria.impl.PeriodFactory;\nimport com.xpn.xwiki.criteria.impl.Range;\nimport com.xpn.xwiki.criteria.impl.RangeFactory;\nimport com.xpn.xwiki.criteria.impl.RevisionCriteria;\nimport com.xpn.xwiki.criteria.impl.Scope;\nimport com.xpn.xwiki.criteria.impl.ScopeFactory;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MetaDataDiff;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.doc.XWikiLink;\nimport com.xpn.xwiki.doc.XWikiLock;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.ObjectDiff;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.DocumentStats;\nimport com.xpn.xwiki.stats.impl.RefererStats;\nimport com.xpn.xwiki.util.TOCGenerator;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * This class represents a document or page in the wiki. This is a security and usability wrapper which wraps\n * {@link com.xpn.xwiki.doc.XWikiDocument} In scripting, an object representing the document in which the script resides\n * will be bound to a variable called doc.\n *\n * @version $Id$\n */\npublic class Document extends Api\n{\n    /** Logging helper object. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(Document.class);\n\n    /**\n     * The XWikiDocument object wrapped by this API.\n     */\n    protected XWikiDocument initialDoc;\n\n    /**\n     * The XWikiDocument object wrapped by this API.\n     */\n    protected XWikiDocument doc;\n\n    /**\n     * Convenience object used by object related methods.\n     */\n    protected Object currentObj;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    /**\n     * Used to convert a proper Document Reference to string (standard form).\n     */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to convert a proper Document Reference to a string but without the wiki name.\n     */\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private ConfigurationSource configuration;\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    private EntityReferenceSerializer<String> getLocalEntityReferenceSerializer()\n    {\n        if (this.localEntityReferenceSerializer == null) {\n            this.localEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localEntityReferenceSerializer;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private ConfigurationSource getConfiguration()\n    {\n        if (this.configuration == null) {\n            this.configuration = Utils.getComponent(ConfigurationSource.class);\n        }\n\n        return this.configuration;\n    }\n\n    /**\n     * Document constructor.\n     *\n     * @param doc The XWikiDocument object to wrap.\n     * @param context The current request context.\n     */\n    public Document(XWikiDocument doc, XWikiContext context)\n    {\n        super(context);\n\n        this.initialDoc = doc;\n        this.doc = this.initialDoc;\n    }\n\n    /**\n     * Get the XWikiDocument wrapped by this API. This function is accessible only if you have the programming rights\n     * give access to the priviledged API of the Document.\n     *\n     * @return The XWikiDocument wrapped by this API.\n     */\n    public XWikiDocument getDocument()\n    {\n        if (hasProgrammingRights()) {\n            return this.doc;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a clone of the XWikiDocument wrapped by this API.\n     *\n     * @return A clone of the XWikiDocument wrapped by this API.\n     */\n    protected XWikiDocument getDoc()\n    {\n        if (this.initialDoc == this.doc) {\n            this.doc = this.initialDoc.clone();\n        }\n\n        return this.doc;\n    }\n\n    /**\n     * return the ID of the document. this ID is unique across the wiki.\n     *\n     * @return the id of the document.\n     */\n    public long getId()\n    {\n        return this.doc.getId();\n    }\n\n    /**\n     * returns the DocumentReference for the current document\n     *\n     * @return the DocumentReference of the current document\n     * @since 2.3M1\n     */\n    public DocumentReference getDocumentReference()\n    {\n        return this.doc.getDocumentReference();\n    }\n\n    /**\n     * @return the {@link DocumentReference} of the document also containing the document {@link Locale}\n     * @since 9.3RC1\n     */\n    public DocumentReference getDocumentReferenceWithLocale()\n    {\n        return this.doc.getDocumentReferenceWithLocale();\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference} without the {@link Locale}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReference()\n    {\n        return this.doc.getPageReference();\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference} including the {@link Locale}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReferenceWithLocale()\n    {\n        return this.doc.getPageReferenceWithLocale();\n    }\n\n    /**\n     * @return the last part of the document's reference. For example if the reference of a document is\n     *         {@code MySpace.Mydoc}, the returned name is {@code MyDoc}. For a nested document, the last part of the\n     *         reference is always {@code WebHome} and thus the returned name is {@code Webhome}. It's better to use\n     *         {@link #getPageReference()} or {@link #getDocumentReference()}, e.g. with\n     *         {@code getPageReference().getName()} or {@code getDocumentReference().getName()}. To get the space name\n     *         of the nested document you can use {@code getPageReference().getName()} or\n     *         {@code getDocumentReference().getParent().getName()}.\n     * @see #getPageReference()\n     * @see #getDocumentReference()\n     * @deprecated since 11.0, use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    public String getName()\n{\n    return this.doc.getDocumentReference().getName();\n}\n\n    /**\n     * Return the full local space reference of the Document. For example a document located in sub-space\n     * <code>space11</code> of space <code>space1</code> will return <code>space1.space11</code>.\n     *\n     * @return the name of the spaces of the document\n     */\n    public String getSpace()\n    {\n        return this.doc.getSpace();\n    }\n\n    /**\n     * Get the name wiki where the document is stored.\n     *\n     * @return The name of the wiki where this document is stored.\n     * @since 1.1.2\n     * @since 1.2M2\n     */\n    public String getWiki()\n    {\n        return this.doc.getDocumentReference().getWikiReference().getName();\n    }\n\n    /**\n     * Get the fullName of the document. If a document is named \"MyDoc\" in space \"MySpace\", the fullname is\n     * \"MySpace.MyDoc\". In a wiki, all the documents have a different fullName.\n     *\n     * @return fullName of the document.\n     */\n    public String getFullName()\n    {\n        return getLocalEntityReferenceSerializer().serialize(this.doc.getDocumentReference());\n    }\n\n    /**\n     * Get the complete fullName of the document. The real full name of the document containing the name of the wiki\n     * where the document is stored. For a document stored in the wiki \"xwiki\", in space \"MySpace\", named \"MyDoc\", its\n     * complete full name is \"xwiki:MySpace.MyDoc\".\n     *\n     * @return The complete fullName of the document.\n     * @since 1.1.2\n     * @since 1.2M2\n     */\n    public String getPrefixedFullName()\n    {\n        return getDefaultEntityReferenceSerializer().serialize(this.doc.getDocumentReference());\n    }\n\n    /**\n     * Get a Version object representing the current version of the document.\n     *\n     * @return A Version object representing the current version of the document\n     */\n    public Version getRCSVersion()\n    {\n        return this.doc.getRCSVersion();\n    }\n\n    /**\n     * Get a string representing the current version of the document.\n     *\n     * @return A string representing the current version of the document.\n     */\n    public String getVersion()\n    {\n        return this.doc.getVersion();\n    }\n\n    /**\n     * Get a string representing the previous version of the document.\n     *\n     * @return A string representing the previous version of the document. If this is the first version then it returns\n     *         null.\n     */\n    public String getPreviousVersion()\n    {\n        return this.doc.getPreviousVersion();\n    }\n\n    /**\n     * Get the value of the title field of the document.\n     *\n     * @return The value of the title field of the document.\n     */\n    public String getTitle()\n    {\n        return this.doc.getTitle();\n    }\n\n    /**\n     * Get document title. If a title has not been provided through the title field, it looks for a section title in the\n     * document's content and if not found return the page name. The returned title is also interpreted which means it's\n     * allowed to use Velocity, Groovy, etc syntax within a title.\n     *\n     * @return The document title as XHTML\n     */\n    public String getDisplayTitle()\n    {\n        return this.doc.getRenderedTitle(getXWikiContext());\n    }\n\n    /**\n     * Returns the document title as plain text\n     *\n     * @return the document title as plain text (all markup removed)\n     * @since 3.0M1\n     */\n    public String getPlainTitle()\n    {\n        return this.doc.getRenderedTitle(Syntax.PLAIN_1_0, getXWikiContext());\n    }\n\n    /**\n     * Returns the title of the document rendered through wiki syntax and velocity\n     *\n     * @return the title rendered through wiki syntax and velocity\n     * @see XWikiDocument#getRenderedTitle(Syntax, XWikiContext)\n     */\n    public String getRenderedTitle(String syntaxId) throws XWikiException\n    {\n        try {\n            return this.doc.getRenderedTitle(Syntax.valueOf(syntaxId), getXWikiContext());\n        } catch (ParseException e) {\n            LOGGER.error(\"Failed to parse provided syntax identifier [\" + syntaxId + \"]\", e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to parse syntax identifier [\" + syntaxId + \"]\", e);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to render document [\" + getPrefixedFullName() + \"] title content\", e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to render document [\" + getPrefixedFullName() + \"] content title\", e);\n        }\n    }\n\n    /**\n     * TODO document this or mark it deprecated\n     */\n    public String getFormat()\n    {\n        return this.doc.getFormat();\n    }\n\n    /**\n     * Get fullName of the profile document of the author of the current version of the document. Example: XWiki.Admin.\n     *\n     * @return The fullName of the profile document of the effective metadata author of the current version of the\n     *         document.\n     */\n    public String getAuthor()\n    {\n        return this.doc.getAuthor();\n    }\n\n    /**\n     * @return the document author reference\n     * @since 6.4RC1\n     */\n    public DocumentReference getAuthorReference()\n    {\n        return this.doc.getAuthorReference();\n    }\n\n    /**\n     * Get fullName of the profile document of the author of the content modification of this document version. Example:\n     * XWiki.Admin.\n     *\n     * @return The fullName of the profile document of the author of the content modification in this document version.\n     */\n    public String getContentAuthor()\n    {\n        return this.doc.getContentAuthor();\n    }\n\n    /**\n     * @return the document content author reference\n     * @since 6.4RC1\n     */\n    public DocumentReference getContentAuthorReference()\n    {\n        return this.doc.getContentAuthorReference();\n    }\n\n    /**\n     * @return The date when this document version has been modified.\n     */\n    public Date getDate()\n    {\n        return this.doc.getDate();\n    }\n\n    /**\n     * Get the date when the content modification has been done on this document version. A content update excludes\n     * modifications to meta data fields or comments of the document.\n     *\n     * @return The date where the content modification has been done on this document version.\n     */\n    public Date getContentUpdateDate()\n    {\n        return this.doc.getContentUpdateDate();\n    }\n\n    /**\n     * @return the original creation date of the document.\n     */\n    public Date getCreationDate()\n    {\n        return this.doc.getCreationDate();\n    }\n\n    /**\n     * Get the name of the parent of this document.\n     *\n     * @return The name of the parent of this document.\n     */\n    public String getParent()\n    {\n        return this.doc.getParent();\n    }\n\n    /**\n     * @return the parent reference or null if the parent is not set\n     * @since 7.3M1\n     */\n    public DocumentReference getParentReference()\n    {\n        return this.doc.getParentReference();\n    }\n\n    /**\n     * Get fullName of the profile document of the document creator.\n     *\n     * @return The fullName of the profile document of the document creator.\n     */\n    public String getCreator()\n    {\n        return this.doc.getCreator();\n    }\n\n    /**\n     * @return the document creator reference\n     * @since 6.4RC1\n     */\n    public DocumentReference getCreatorReference()\n    {\n        return this.doc.getCreatorReference();\n    }\n\n    /**\n     * Get raw content of the document, i.e. the content that is visible through the wiki editor.\n     *\n     * @return The raw content of the document.\n     */\n    public String getContent()\n    {\n        return this.doc.getContent();\n    }\n\n    /**\n     * NOTE: This method caches the XDOM and returns a clone that can be safely modified.\n     *\n     * @return the XDOM corresponding to the document's string content\n     * @since 7.0RC1\n     */\n    public XDOM getXDOM()\n    {\n        return this.doc.getXDOM();\n    }\n\n    /**\n     * @return The syntax representing the syntax used for the document's content\n     * @since 2.3M1\n     */\n    public Syntax getSyntax()\n    {\n        return this.doc.getSyntax();\n    }\n\n    /**\n     * Get the Syntax id representing the syntax used for the document. For example \"xwiki/1.0\" represents the first\n     * version XWiki syntax while \"xwiki/2.0\" represents version 2.0 of the XWiki Syntax.\n     *\n     * @return The syntax id representing the syntax used for the document.\n     * @deprecated since 2.3M1 use {@link #getSyntax()} instead\n     */\n    @Deprecated\n    public String getSyntaxId()\n    {\n        return this.doc.getSyntax().toIdString();\n    }\n\n    /**\n     * Same as {@link #getLocale()} but as String.\n     *\n     * @return the locale of the document.\n     * @deprecated since 5.4M1 use {@link #getLocale()} instead\n     */\n    @Deprecated\n    public String getLanguage()\n    {\n        return this.doc.getLanguage();\n    }\n\n    /**\n     * Get the locale of the document. If the document is a translation it returns the locale set for it, otherwise, it\n     * returns the root locale.\n     *\n     * @return the locale of the document\n     * @since 5.4M1\n     */\n    public Locale getLocale()\n    {\n        return this.doc.getLocale();\n    }\n\n    /**\n     * TODO document this or mark it deprecated\n     */\n    public String getTemplate()\n    {\n        String templateReferenceAsString = \"\";\n        DocumentReference templateDocumentReference = this.doc.getTemplateDocumentReference();\n        if (templateDocumentReference != null) {\n            templateReferenceAsString = getLocalEntityReferenceSerializer().serialize(templateDocumentReference);\n        }\n        return templateReferenceAsString;\n    }\n\n    /**\n     * Same as {@link #getRealLocale()} but as String.\n     *\n     * @return the real locale\n     * @deprecated since 8.0M1, use {@link #getRealLocale()} instead\n     */\n    @Deprecated\n    public String getRealLanguage() throws XWikiException\n    {\n        return this.doc.getRealLanguage(getXWikiContext());\n    }\n\n    /**\n     * Gets the real locale of the document. The real locale is either the default locale field when the locale field is\n     * empty (when the document is the default document) or the locale field otherwise when the document is a\n     * translation document\n     * \n     * @return the actual locale of the document\n     * @since 8.0M1\n     */\n    public Locale getRealLocale()\n    {\n        return this.doc.getRealLocale();\n    }\n\n    /**\n     * Same as {@link #getDefaultLocale()} but as String.\n     * \n     * @return the locale of the default document\n     * @deprecated since 8.0M1, use {@link #getDefaultLocale()} instead\n     */\n    @Deprecated\n    public String getDefaultLanguage()\n    {\n        return this.doc.getDefaultLanguage();\n    }\n\n    /**\n     * @return the Locale of the default version of the document (usually {@link Locale#ROOT} or {@link Locale#ENGLISH})\n     * @since 8.0M1\n     */\n    public Locale getDefaultLocale()\n    {\n        return this.doc.getDefaultLocale();\n    }\n\n    /**\n     * @param defaultLocale the locale content in the default document version\n     * @since 11.9RC1\n     */\n    public void setDefaultLocale(Locale defaultLocale)\n    {\n        this.doc.setDefaultLocale(defaultLocale);\n    }\n\n    /**\n     * TODO document this or mark it deprecated\n     */\n    public String getDefaultTemplate()\n    {\n        return this.doc.getDefaultTemplate();\n    }\n\n    /**\n     * @return the comment of of the document version\n     */\n    public String getComment()\n    {\n        return this.doc.getComment();\n    }\n\n    /**\n     * @return true if the this document version was a minor edit.\n     */\n    public boolean isMinorEdit()\n    {\n        return this.doc.isMinorEdit();\n    }\n\n    /**\n     * @return the list of locales for which this document has a translation; the original (default) locale is not\n     *         included\n     * @throws XWikiException if retrieving the document translations from the database fails\n     * @since 12.4RC1\n     */\n    public List<Locale> getTranslationLocales() throws XWikiException\n    {\n        return this.doc.getTranslationLocales(getXWikiContext());\n    }\n\n    /**\n     * @return the translated document's content if the wiki is multilingual, the locale is first checked in the URL,\n     *         the cookie, the user profile and finally the wiki configuration if not, the locale is the one on the wiki\n     *         configuration.\n     */\n    public String getTranslatedContent() throws XWikiException\n    {\n        return this.doc.getTranslatedContent(getXWikiContext());\n    }\n\n    /**\n     * @return the translated content in the given locale\n     */\n    public String getTranslatedContent(String locale) throws XWikiException\n    {\n        return this.doc.getTranslatedContent(locale, getXWikiContext());\n    }\n\n    /**\n     * @return the translated document in the given locale\n     */\n    public Document getTranslatedDocument(String locale) throws XWikiException\n    {\n        return this.doc.getTranslatedDocument(locale, getXWikiContext()).newDocument(getXWikiContext());\n    }\n\n    /**\n     * @return the tranlated Document if the wiki is multilingual, the locale is first checked in the URL, the cookie,\n     *         the user profile and finally the wiki configuration if not, the locale is the one on the wiki\n     *         configuration.\n     */\n    public Document getTranslatedDocument() throws XWikiException\n    {\n        return this.doc.getTranslatedDocument(getXWikiContext()).newDocument(getXWikiContext());\n    }\n\n    /**\n     * @param targetSyntax the syntax in which to render the document content\n     * @return the content of the current document rendered.\n     * @since 11.3RC1\n     */\n    public String displayDocument(Syntax targetSyntax) throws XWikiException\n    {\n        return this.doc.displayDocument(targetSyntax, getXWikiContext());\n    }\n\n    /**\n     * @param targetSyntax the syntax in which to render the document content\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return the content of the current document rendered.\n     * @since 11.5RC1\n     */\n    public String displayDocument(Syntax targetSyntax, boolean restricted) throws XWikiException\n    {\n        return this.doc.displayDocument(targetSyntax, restricted, getXWikiContext());\n    }\n\n    /**\n     * @return the content of the current document rendered.\n     * @since 11.3RC1\n     */\n    public String displayDocument() throws XWikiException\n    {\n        return this.doc.displayDocument(getXWikiContext());\n    }\n\n    /**\n     * @return the content of the current document rendered.\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @since 11.5RC1\n     */\n    public String displayDocument(boolean restricted) throws XWikiException\n    {\n        return this.doc.displayDocument(restricted, getXWikiContext());\n    }\n\n    /**\n     * @return the content of the document or its translations rendered.\n     */\n    public String getRenderedContent() throws XWikiException\n    {\n        return this.doc.getRenderedContent(getXWikiContext());\n    }\n\n    /**\n     * Execute and render the document in the current context.\n     * <p>\n     * The code is executed with right of this document content author.\n     * \n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @return the result\n     * @throws XWikiException when failing to display the document\n     * @since 8.4RC1\n     */\n    public String getRenderedContent(boolean transformationContextIsolated) throws XWikiException\n    {\n        return this.doc.getRenderedContent(transformationContextIsolated, getXWikiContext());\n    }\n\n    /**\n     * @param text the text to render\n     * @return the given text rendered in the context of this document\n     * @deprecated since 1.6M1 use {@link #getRenderedContent(String, String)}\n     */\n    @Deprecated\n    public String getRenderedContent(String text) throws XWikiException\n    {\n        return getRenderedContent(text, Syntax.XWIKI_1_0.toIdString());\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (for example: \"xwiki/1.0\")\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 1.6M1\n     */\n    public String getRenderedContent(String text, String syntaxId) throws XWikiException\n    {\n        return getRenderedContent(text, syntaxId, false);\n    }\n\n    /**\n     * Render a text in a restricted mode, where script macros are completely disabled.\n     *\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (for example: \"xwiki/1.0\")\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContentRestricted(String text, String syntaxId) throws XWikiException\n    {\n        return getRenderedContent(text, syntaxId, true);\n    }\n\n    /**\n     * Render a text in a restricted mode, where script macros are completely disabled.\n     *\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (for example: \"xwiki/1.0\")\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return the given text rendered in the context of this document using the passed Syntax\n     */\n    private String getRenderedContent(String text, String syntaxId, boolean restricted) throws XWikiException\n    {\n        // Make sure we keep using current author as passed content author\n        return this.doc.getRenderedContent(text, syntaxId, restricted, getCallerDocument(getXWikiContext()),\n            getXWikiContext());\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (for example: \"xwiki/1.0\")\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 2.0M3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId) throws XWikiException\n    {\n        // Make sure we keep using current author as passed content author\n        return this.doc.getRenderedContent(text, sourceSyntaxId, targetSyntaxId, false,\n            getCallerDocument(getXWikiContext()), getXWikiContext());\n    }\n\n    private XWikiDocument getCallerDocument(XWikiContext xcontext)\n    {\n        XWikiDocument sdoc = (XWikiDocument) xcontext.get(\"sdoc\");\n        if (sdoc == null) {\n            sdoc = xcontext.getDoc();\n        }\n\n        return sdoc;\n    }\n\n    /**\n     * @param targetSyntax the syntax in which to render the document content\n     * @return the rendered content\n     * @throws XWikiException error when rendering content\n     */\n    public String getRenderedContent(Syntax targetSyntax) throws XWikiException\n    {\n        return this.doc.getRenderedContent(targetSyntax, getXWikiContext());\n    }\n\n    /**\n     * Get the document's content XML-escaped.\n     *\n     * @return an XML-escaped version of the content of this document.\n     */\n    public String getEscapedContent() throws XWikiException\n    {\n        return this.doc.getEscapedContent(getXWikiContext());\n    }\n\n    /**\n     * @return the archive of this document's history in string format\n     */\n    public String getArchive() throws XWikiException\n    {\n        return this.doc.getDocumentArchive(getXWikiContext()).getArchive(getXWikiContext());\n    }\n\n    /**\n     * Get the archive of this document's history. This function is accessible only if you have the programming rights.\n     *\n     * @return the archive of this document's history as an {@link XWikiDocumentArchive}.\n     */\n    public XWikiDocumentArchive getDocumentArchive() throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.doc.getDocumentArchive(getXWikiContext());\n        }\n        return null;\n    }\n\n    /**\n     * @return true if the document is a new one (ie it has never been saved) or false otherwise\n     */\n    public boolean isNew()\n    {\n        return this.doc.isNew();\n    }\n\n    /**\n     * Return the relative URL of download for the the given attachment name.\n     *\n     * @param filename the name of the attachment\n     * @return A String with the URL or null if the file name is empty\n     */\n    public String getAttachmentURL(String filename)\n    {\n        return this.doc.getAttachmentURL(filename, getXWikiContext());\n    }\n\n    /**\n     * Get the relative URL of the given action for the the given attachment name.\n     *\n     * @param filename the name of the attachment.\n     * @param action what to do to the file for example \"delattachment\", \"download\" or \"downloadrev\".\n     * @return a string representation of a URL to do the given operation or null if the file name is empty\n     */\n    public String getAttachmentURL(String filename, String action)\n    {\n        return this.doc.getAttachmentURL(filename, action, getXWikiContext());\n    }\n\n    /**\n     * Get the relative URL of an action on an attachment. the given action for the the given attachment name with\n     * \"queryString\" parameters\n     *\n     * @param filename the name of the attachment.\n     * @param action what to do to the file for example \"delattachment\", \"download\" or \"downloadrev\"\n     * @param queryString parameters added to the URL, the \"rev\" parameter is used to specify a revision if using the\n     *            \"downloadrev\" action. The query string must not begin with an ? character.\n     * @return a string representation of a URL to do the given operation or null if the file name is empty\n     */\n    public String getAttachmentURL(String filename, String action, String queryString)\n    {\n        return this.doc.getAttachmentURL(filename, action, queryString, getXWikiContext());\n    }\n\n    /**\n     * Get an old revision of an attachment.\n     *\n     * @param filename the name of the attachment.\n     * @param version a revision number such as \"1.1\" or \"1.2\".\n     * @return the URL for accessing to the archive of the attachment \"filename\" at the version \"version\" or null if the\n     *         file name is empty\n     */\n    public String getAttachmentRevisionURL(String filename, String version)\n    {\n        return this.doc.getAttachmentRevisionURL(filename, version, getXWikiContext());\n    }\n\n    /**\n     * Get an old revision of an attachment.\n     *\n     * @param filename the name of the attachment.\n     * @param version a revision number such as \"1.1\" or \"1.2\".\n     * @param queryString additional query parameters to pass in the request.\n     * @return the URL for accessing to the archive of the attachment \"filename\" at the version \"version\" with the given\n     *         queryString parameters or null if the file name is empty\n     */\n    public String getAttachmentRevisionURL(String filename, String version, String queryString)\n    {\n        return this.doc.getAttachmentRevisionURL(filename, version, queryString, getXWikiContext());\n    }\n\n    /**\n     * Get the URL of this document.\n     *\n     * @return the URL to view this document, this will be a relative URL for example: /xwiki/bin/view/Main/WebHome\n     * @see #getExternalURL() for an absolute URL which can used outside of the site.\n     */\n    public String getURL()\n    {\n        return this.doc.getURL(\"view\", getXWikiContext());\n    }\n\n    /**\n     * Get the URL to do a given action on this document.\n     *\n     * @param action what to do to the document for example \"view\", \"edit\" or \"inline\".\n     * @return the URL of this document with the given action.\n     * @see #getExternalURL(String) for an absolute URL which can used outside of the site.\n     */\n    public String getURL(String action)\n    {\n        return this.doc.getURL(action, getXWikiContext());\n    }\n\n    /**\n     * Get the URL to do a given action on this document.\n     *\n     * @param action what to do to the document for example \"view\", \"edit\" or \"inline\".\n     * @param queryString parameters to pass in the request eg: {@code paramA=value1&paramB=value2}\n     * @return the URL of this document with the given action and queryString as parameters.\n     * @see #getExternalURL(String, String) for an absolute URL which can used outside of the site.\n     */\n    public String getURL(String action, String queryString)\n    {\n        return this.doc.getURL(action, queryString, getXWikiContext());\n    }\n\n    /**\n     * Get the external URL to do a given action on this document.\n     *\n     * @return the full URL of the document, sutable for use at external websites for example:\n     *         http://www.xwiki.org/xwiki/bin/view/Main/WebHome\n     * @see #getURL() for a relative URL which can only be used inside of the site.\n     */\n    public String getExternalURL()\n    {\n        return this.doc.getExternalURL(\"view\", getXWikiContext());\n    }\n\n    /**\n     * Get the external URL to do a given action on this document.\n     *\n     * @param action what to do to the document for example \"view\", \"edit\" or \"inline\".\n     * @return the URL of this document with the given action.\n     * @see #getURL() for a relative URL which can only be used inside of the site.\n     */\n    public String getExternalURL(String action)\n    {\n        return this.doc.getExternalURL(action, getXWikiContext());\n    }\n\n    /**\n     * Get the URL to do a given action on this document.\n     *\n     * @param action what to do to the document for example \"view\", \"edit\" or \"inline\".\n     * @param queryString parameters to pass in the request eg: {@code paramA=value1&paramB=value2}\n     * @return the URL of this document with the given action and queryString as parameters.\n     * @see #getURL() for a relative URL which can only be used inside of the site.\n     */\n    public String getExternalURL(String action, String queryString)\n    {\n        return this.doc.getExternalURL(action, queryString, getXWikiContext());\n    }\n\n    /**\n     * @return the relative URL of the parent document of this document\n     */\n    public String getParentURL() throws XWikiException\n    {\n        return this.doc.getParentURL(getXWikiContext());\n    }\n\n    /**\n     * @return the XClass associated to this document when the document represents an XWiki Class\n     */\n    public Class getxWikiClass()\n    {\n        BaseClass bclass = this.getDoc().getXClass();\n        if (bclass == null) {\n            return null;\n        } else {\n            return new Class(bclass, getXWikiContext());\n        }\n    }\n\n    /**\n     * @return the array of XClasses representing the objects of this document\n     */\n    public Class[] getxWikiClasses()\n    {\n        List<BaseClass> list = this.getDoc().getXClasses(getXWikiContext());\n        if (list == null) {\n            return null;\n        }\n        Class[] result = new Class[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            result[i] = new Class(list.get(i), getXWikiContext());\n        }\n        return result;\n    }\n\n    /**\n     * Creates a New XWiki Object of the given classname\n     *\n     * @param classname the classname used\n     * @return the number of the object created\n     */\n    public int createNewObject(String classname) throws XWikiException\n    {\n        int index = getDoc().createNewObject(classname, getXWikiContext());\n\n        updateAuthor();\n\n        return index;\n    }\n\n    /**\n     * Creates a New XWiki Object of the given classname\n     *\n     * @param classname the classname used\n     * @return the object created\n     */\n    public Object newObject(String classname) throws XWikiException\n    {\n        int nb = createNewObject(classname);\n        return getObject(classname, nb);\n    }\n\n    /**\n     * @return true of the document has been loaded from cache\n     */\n    public boolean isFromCache()\n    {\n        return this.doc.isFromCache();\n    }\n\n    /**\n     * @param classname the classname used\n     * @return the number of objects available for a given classname\n     */\n    public int getObjectNumbers(String classname)\n    {\n        return this.doc.getObjectNumbers(classname);\n    }\n\n    /**\n     * Get the list of all objects available in this document organized in a Map by classname\n     *\n     * @return the map of objects\n     */\n    public Map<String, Vector<Object>> getxWikiObjects()\n    {\n        Map<DocumentReference, List<BaseObject>> map = this.getDoc().getXObjects();\n        Map<String, Vector<Object>> resultmap = new HashMap<String, Vector<Object>>();\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : map.entrySet()) {\n            List<BaseObject> objects = entry.getValue();\n            if (objects != null) {\n                resultmap.put(getLocalEntityReferenceSerializer().serialize(entry.getKey()), getXObjects(objects));\n            }\n        }\n        return resultmap;\n    }\n\n    protected Vector<Object> getXObjects(List<BaseObject> objects)\n    {\n        if (objects == null) {\n            return new Vector<Object>(0);\n        }\n        Vector<Object> result = new Vector<Object>(objects.size());\n        for (BaseObject bobj : objects) {\n            if (bobj != null) {\n                result.add(newObjectApi(bobj, getXWikiContext()));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the list of objects for a given classname classname\n     *\n     * @return the vector of objects\n     */\n    public Vector<Object> getObjects(String className)\n    {\n        List<BaseObject> objects = this.getDoc().getXObjects(this.doc.resolveClassReference(className));\n        return getXObjects(objects);\n    }\n\n    /**\n     * Get the first object that contains the given fieldname\n     *\n     * @param fieldname name of the field to find in the object\n     * @return the XWiki Object\n     */\n    public Object getFirstObject(String fieldname)\n    {\n        try {\n            BaseObject obj = this.getDoc().getFirstObject(fieldname, getXWikiContext());\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the first object of a given classname that has a field name matching the given value\n     *\n     * @param classname name of the class of the object to look for\n     * @param key name of the field to find in the object\n     * @param value value of the field to find in the object\n     * @param failover true if the first object will be given when none found\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname, String key, String value, boolean failover)\n    {\n        try {\n            BaseObject obj = this.getDoc().getObject(classname, key, value, failover);\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Select a subset of objects from a given class, filtered on a \"key = value\" criteria.\n     *\n     * @param classname The type of objects to return.\n     * @param key The name of the property used for filtering.\n     * @param value The required value.\n     * @return A Vector of {@link Object objects} matching the criteria. If no objects are found, or if the key is an\n     *         empty String, then an empty vector is returned.\n     */\n    public Vector<Object> getObjects(String classname, String key, String value)\n    {\n        Vector<Object> result = new Vector<Object>();\n        if (StringUtils.isBlank(key) || value == null) {\n            return getObjects(classname);\n        }\n        try {\n            Vector<BaseObject> allObjects = this.getDoc().getObjects(classname);\n            if (allObjects == null || allObjects.size() == 0) {\n                return result;\n            } else {\n                for (BaseObject obj : allObjects) {\n                    if (obj != null) {\n                        BaseProperty prop = (BaseProperty) obj.get(key);\n                        if (prop == null || prop.getValue() == null) {\n                            continue;\n                        }\n                        if (value.equals(prop.getValue().toString())) {\n                            result.add(newObjectApi(obj, getXWikiContext()));\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n        return result;\n    }\n\n    /**\n     * Get the first object of a given classname that has a field name matching the given value When none found this\n     * method will return null\n     *\n     * @param classname name of the class of the object to look for\n     * @param key name of the field to find in the object\n     * @param value value of the field to find in the object\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname, String key, String value)\n    {\n        try {\n            BaseObject obj = this.getDoc().getObject(classname, key, value);\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the first object matching the given classname\n     *\n     * @param classname name of the class of the object to look for\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname)\n    {\n        return getObject(classname, false);\n    }\n\n    /**\n     * get the object of the given className. If there is no object of this className and the create parameter at true,\n     * the object is created.\n     *\n     * @param classname name of the class of the object to look for\n     * @param create true of the object should be created when it does not exist\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname, boolean create)\n    {\n        try {\n            BaseObject obj = getDoc().getObject(classname, create, getXWikiContext());\n\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the object matching the given classname and given object number\n     *\n     * @param classname name of the class of the object\n     * @param nb number of the object\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname, int nb)\n    {\n        try {\n            BaseObject obj = this.getDoc().getObject(classname, nb);\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @param objectReference the object reference\n     * @return the XWiki object from this document that matches the specified object reference\n     * @since 12.3RC1\n     */\n    public Object getObject(ObjectReference objectReference)\n    {\n        try {\n            BaseObject obj = this.getDoc().getXObject(objectReference);\n            return obj == null ? null : newObjectApi(obj, getXWikiContext());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @param objectReference the object reference\n     * @param create if true, the object will be created when missing\n     * @return the XWiki object from this document that matches the specified object reference\n     * @since 14.0RC1\n     */\n    @Unstable\n    public Object getObject(ObjectReference objectReference, boolean create)\n    {\n        try {\n            BaseObject obj = this.getDoc().getXObject(objectReference, create, getXWikiContext());\n            return obj == null ? null : newObjectApi(obj, getXWikiContext());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private Object newObjectApi(BaseObject obj, XWikiContext context)\n    {\n        return obj.newObjectApi(obj, context);\n    }\n\n    public String getXMLContent() throws XWikiException\n    {\n        String xml = this.doc.getXMLContent(getXWikiContext());\n        return getXWikiContext().getUtil().substitute(\"s/<email>.*?<\\\\/email>/<email>********<\\\\/email>/goi\",\n            getXWikiContext().getUtil().substitute(\"s/<password>.*?<\\\\/password>/<password>********<\\\\/password>/goi\",\n                xml));\n    }\n\n    public String toXML() throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.doc.toXML(getXWikiContext());\n        } else {\n            return \"\";\n        }\n    }\n\n    public org.dom4j.Document toXMLDocument() throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.doc.toXMLDocument(getXWikiContext());\n        } else {\n            return null;\n        }\n    }\n\n    public Version[] getRevisions() throws XWikiException\n    {\n        return this.doc.getRevisions(getXWikiContext());\n    }\n\n    public String[] getRecentRevisions() throws XWikiException\n    {\n        return this.doc.getRecentRevisions(5, getXWikiContext());\n    }\n\n    public String[] getRecentRevisions(int nb) throws XWikiException\n    {\n        return this.doc.getRecentRevisions(nb, getXWikiContext());\n    }\n\n    /**\n     * Get document versions matching criterias like author, minimum creation date, etc.\n     *\n     * @param criteria criteria used to match versions\n     * @return a list of matching versions\n     */\n    public List<String> getRevisions(RevisionCriteria criteria) throws XWikiException\n    {\n        return this.doc.getRevisions(criteria, this.context);\n    }\n\n    /**\n     * Get information about a document version : author, date, etc.\n     *\n     * @param version the version you want to get information about\n     * @return a new RevisionInfo object\n     */\n    public RevisionInfo getRevisionInfo(String version) throws XWikiException\n    {\n        return new RevisionInfo(this.doc.getRevisionInfo(version, getXWikiContext()), getXWikiContext());\n    }\n\n    public List<Attachment> getAttachmentList()\n    {\n        List<Attachment> apis = new ArrayList<Attachment>();\n        for (XWikiAttachment attachment : this.getDoc().getAttachmentList()) {\n            apis.add(new Attachment(this, attachment, getXWikiContext()));\n        }\n        return apis;\n    }\n\n    public Vector<Object> getComments()\n    {\n        return getComments(true);\n    }\n\n    public Vector<Object> getComments(boolean asc)\n    {\n        return getXObjects(this.getDoc().getComments(asc));\n    }\n\n    /**\n     * Setting the current object to the given object. Following calls to display() will use this object as the\n     * reference for finding properties.\n     *\n     * @param object Object to use as a reference for further display calls\n     */\n    public void use(Object object)\n    {\n        this.currentObj = object;\n    }\n\n    /**\n     * Setting the current object to the first object of the given class name. Following calls to display() will use\n     * this object as the reference for finding properties.\n     *\n     * @param className class used to find the first object to use as the reference for display calls\n     */\n    public void use(String className)\n    {\n        this.currentObj = getObject(className);\n    }\n\n    /**\n     * Setting the current object to the object of the given class name and the given number. Following calls to\n     * display() will use this object as the reference for finding properties.\n     *\n     * @param className class used to find the object to use as the reference for display calls\n     * @param nb number of the object to use as the reference for display calls\n     */\n    public void use(String className, int nb)\n    {\n        this.currentObj = getObject(className, nb);\n    }\n\n    /**\n     * @return the className of the current active object use for display calls.\n     */\n    public String getActiveClass()\n    {\n        if (this.currentObj == null) {\n            return null;\n        } else {\n            return this.currentObj.getName();\n        }\n    }\n\n    /**\n     * Displays the pretty name of the given field. This function uses the active object or will find the first object\n     * that has the given field.\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname)\n    {\n        if (this.currentObj == null) {\n            return this.doc.displayPrettyName(fieldname, getXWikiContext());\n        } else {\n            return this.doc.displayPrettyName(fieldname, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the pretty name of the given field of the given object.\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param obj Object to find the class to display the pretty name of\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.displayPrettyName(fieldname, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the pretty name of the given field. This function uses the active object or will find the first object\n     * that has the given field. with the optional addition of a mandatory field.\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param showMandatory true to display a mandatory sign\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, boolean showMandatory)\n    {\n        if (this.currentObj == null) {\n            return this.doc.displayPrettyName(fieldname, showMandatory, getXWikiContext());\n        } else {\n            return this.doc.displayPrettyName(fieldname, showMandatory, this.currentObj.getBaseObject(),\n                getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the pretty name of the given field of the given object. with the optional addition of a mandatory field.\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param obj Object to find the class to display the pretty name of\n     * @param showMandatory true to display a mandatory sign\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, boolean showMandatory, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.displayPrettyName(fieldname, showMandatory, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the pretty name of the given field. This function uses the active object or will find the first object\n     * that has the given field. with the optional addition of a mandatory field before or after the field\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param showMandatory true to display a mandatory sign\n     * @param before true if the mandatory sign should be before the field\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before)\n    {\n        if (this.currentObj == null) {\n            return this.doc.displayPrettyName(fieldname, showMandatory, before, getXWikiContext());\n        } else {\n            return this.doc.displayPrettyName(fieldname, showMandatory, before, this.currentObj.getBaseObject(),\n                getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the pretty name of the given field of the given object. with the optional addition of a mandatory field\n     * before or after the field\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param showMandatory true to display a mandatory sign\n     * @param before true if the mandatory sign should be before the field\n     * @param obj Object to find the class to display the pretty name of\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.displayPrettyName(fieldname, showMandatory, before, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the tooltip of the given field. This function uses the active object or will find the first object that\n     * has the given field.\n     *\n     * @param fieldname fieldname to display the tooltip of\n     * @return the tooltip display of the field.\n     */\n    public String displayTooltip(String fieldname)\n    {\n        if (this.currentObj == null) {\n            return this.doc.displayTooltip(fieldname, getXWikiContext());\n        } else {\n            return this.doc.displayTooltip(fieldname, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the tooltip of the given field of the given object.\n     *\n     * @param fieldname fieldname to display the tooltip of\n     * @param obj Object to find the class to display the tooltip of\n     * @return the tooltip display of the field.\n     */\n    public String displayTooltip(String fieldname, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.displayTooltip(fieldname, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the given field. The display mode will be decided depending on page context (edit or inline context will\n     * display in edit, view context in view) This function uses the active object or will find the first object that\n     * has the given field. This function can return html inside and html macro\n     *\n     * @param fieldname fieldname to display\n     * @return the display of the field.\n     */\n    public String display(String fieldname)\n    {\n        if (this.currentObj == null) {\n            return this.doc.display(fieldname, getXWikiContext());\n        } else {\n            return this.doc.display(fieldname, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the given field in the given mode. This function uses the active object or will find the first object\n     * that has the given field. This function can return html inside and html macro\n     *\n     * @param fieldname fieldname to display\n     * @param mode display mode to use (view, edit, hidden, search)\n     * @return the display of the field.\n     */\n    public String display(String fieldname, String mode)\n    {\n        if (this.currentObj == null) {\n            return this.doc.display(fieldname, mode, getXWikiContext());\n        } else {\n            return this.doc.display(fieldname, mode, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the given field in the given mode. This function uses the active object or will find the first object\n     * that has the given field. This function can return html inside and html macro A given prefix is added to the\n     * field names when these are forms.\n     *\n     * @param fieldname fieldname to display\n     * @param mode display mode to use (view, edit, hidden, search)\n     * @param prefix prefix to use for the form names\n     * @return the display of the field.\n     */\n    public String display(String fieldname, String mode, String prefix)\n    {\n        if (this.currentObj == null) {\n            return this.doc.display(fieldname, mode, prefix, getXWikiContext());\n        } else {\n            return this.doc.display(fieldname, mode, prefix, this.currentObj.getBaseObject(), getSyntaxId(),\n                getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the given field of the given object The display mode will be decided depending on page context (edit or\n     * inline context will display in edit, view context in view) This function can return html inside and html macro\n     *\n     * @param fieldname fieldname to display\n     * @param obj object from which to take the field\n     * @return the display of the field.\n     */\n    public String display(String fieldname, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.display(fieldname, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the given field of the given object using the given mode and syntax rendering The display mode will be\n     * decided depending on page context (edit or inline context will display in edit, view context in view) This\n     * function can return html inside and html macro\n     *\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, Object obj, String wrappingSyntaxId)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.display(fieldname, type, obj.getBaseObject(), wrappingSyntaxId, getXWikiContext());\n    }\n\n    /**\n     * Displays the given field of the given object in the given mode. This function can return html inside and html\n     * macro\n     *\n     * @param fieldname fieldname to display\n     * @param mode display mode to use (view, edit, hidden, search)\n     * @param obj the object containing the field to display\n     * @return the display of the field.\n     */\n    public String display(String fieldname, String mode, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.display(fieldname, mode, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the given field of the given object in the given mode. This function can return html inside and html\n     * macro A given prefix is added to the field names when these are forms.\n     *\n     * @param fieldname fieldname to display\n     * @param mode display mode to use (view, edit, hidden, search)\n     * @param prefix prefix to use for the form names\n     * @param obj the object containing the field to display\n     * @return the display of the field.\n     */\n    public String display(String fieldname, String mode, String prefix, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.display(fieldname, mode, prefix, obj.getBaseObject(), getSyntaxId(), getXWikiContext());\n    }\n\n    public String displayForm(String className, String header, String format)\n    {\n        return this.doc.displayForm(className, header, format, getXWikiContext());\n    }\n\n    public String displayForm(String className, String header, String format, boolean linebreak)\n    {\n        return this.doc.displayForm(className, header, format, linebreak, getXWikiContext());\n    }\n\n    public String displayForm(String className)\n    {\n        return this.doc.displayForm(className, getXWikiContext());\n    }\n\n    public String displayRendered(com.xpn.xwiki.api.PropertyClass pclass, String prefix, Collection object)\n        throws XWikiException\n    {\n        if ((pclass == null) || (object == null)) {\n            return \"\";\n        }\n        return this.doc.displayRendered(pclass.getBasePropertyClass(), prefix, object.getCollection(),\n            getXWikiContext());\n    }\n\n    public String displayView(com.xpn.xwiki.api.PropertyClass pclass, String prefix, Collection object)\n    {\n        if ((pclass == null) || (object == null)) {\n            return \"\";\n        }\n        return this.doc.displayView(pclass.getBasePropertyClass(), prefix, object.getCollection(), getXWikiContext());\n    }\n\n    public String displayEdit(com.xpn.xwiki.api.PropertyClass pclass, String prefix, Collection object)\n    {\n        if ((pclass == null) || (object == null)) {\n            return \"\";\n        }\n        return this.doc.displayEdit(pclass.getBasePropertyClass(), prefix, object.getCollection(), getXWikiContext());\n    }\n\n    public String displayHidden(com.xpn.xwiki.api.PropertyClass pclass, String prefix, Collection object)\n    {\n        if ((pclass == null) || (object == null)) {\n            return \"\";\n        }\n        return this.doc.displayHidden(pclass.getBasePropertyClass(), prefix, object.getCollection(), getXWikiContext());\n    }\n\n    public List<String> getIncludedPages()\n    {\n        return this.doc.getIncludedPages(getXWikiContext());\n    }\n\n    public List<String> getIncludedMacros()\n    {\n        return this.doc.getIncludedMacros(getXWikiContext());\n    }\n\n    public List<String> getLinkedPages()\n    {\n        return new ArrayList<String>(this.doc.getUniqueLinkedPages(getXWikiContext()));\n    }\n\n    public Attachment getAttachment(String filename)\n    {\n        XWikiAttachment attach = this.getDoc().getAttachment(filename);\n        if (attach == null) {\n            return null;\n        } else {\n            return new Attachment(this, attach, getXWikiContext());\n        }\n    }\n\n    public List<Delta> getContentDiff(Document origdoc, Document newdoc)\n        throws XWikiException, DifferentiationFailedException\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getContentDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getContentDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getContentDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                    \"Error while making content diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<Delta> getXMLDiff(Document origdoc, Document newdoc)\n        throws XWikiException, DifferentiationFailedException\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getXMLDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getXMLDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getXMLDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_XML_ERROR,\n                    \"Error while making xml diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<Delta> getRenderedContentDiff(Document origdoc, Document newdoc)\n        throws XWikiException, DifferentiationFailedException\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getRenderedContentDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getRenderedContentDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getRenderedContentDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_RENDERED_ERROR,\n                    \"Error while making rendered diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(Document origdoc, Document newdoc) throws XWikiException\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getMetaDataDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getMetaDataDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getMetaDataDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_METADATA_ERROR,\n                    \"Error while making meta data diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(Document origdoc, Document newdoc)\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getObjectDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getObjectDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getObjectDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_OBJECT_ERROR,\n                    \"Error while making meta object diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<List<ObjectDiff>> getClassDiff(Document origdoc, Document newdoc)\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getClassDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getClassDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getClassDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CLASS_ERROR,\n                    \"Error while making class diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<AttachmentDiff> getAttachmentDiff(Document origdoc, Document newdoc)\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return wrapAttachmentDiff(this.doc.getAttachmentDiff(new XWikiDocument(newdoc.getDocumentReference()),\n                    newdoc.doc, getXWikiContext()));\n            }\n            if (newdoc == null) {\n                return wrapAttachmentDiff(this.doc.getAttachmentDiff(origdoc.doc,\n                    new XWikiDocument(origdoc.getDocumentReference()), getXWikiContext()));\n            }\n\n            return wrapAttachmentDiff(this.doc.getAttachmentDiff(origdoc.doc, newdoc.doc, getXWikiContext()));\n        } catch (Exception e) {\n            java.lang.Object[] args = { (origdoc != null) ? origdoc.getFullName() : null,\n            (origdoc != null) ? origdoc.getVersion() : null, (newdoc != null) ? newdoc.getVersion() : null };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_ATTACHMENT_ERROR,\n                    \"Error while making attachment diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    private List<AttachmentDiff> wrapAttachmentDiff(List<com.xpn.xwiki.doc.AttachmentDiff> diffs)\n    {\n        List<AttachmentDiff> safeAttachmentDiffs = new ArrayList<>();\n        for (com.xpn.xwiki.doc.AttachmentDiff diff : diffs) {\n            safeAttachmentDiffs.add(new AttachmentDiff(diff, getXWikiContext()));\n        }\n        return safeAttachmentDiffs;\n    }\n\n    public List<Delta> getLastChanges() throws XWikiException, DifferentiationFailedException\n    {\n        return this.doc.getLastChanges(getXWikiContext());\n    }\n\n    /**\n     * Get statistics about the number of request for the current page during the current month.\n     *\n     * @param action the type of request for which to retrieve statistics: view, edit...\n     * @return the statistics object holding information for this document and the current month\n     */\n    public DocumentStats getCurrentMonthPageStats(String action)\n    {\n        Scope scope = ScopeFactory.createPageScope(this.getFullName());\n        Range range = RangeFactory.ALL;\n        Period period = PeriodFactory.getCurrentMonth();\n        XWikiStatsService statisticsService = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        List<DocumentStats> stats = statisticsService.getDocumentStatistics(action, scope, period, range, this.context);\n        if (stats.size() > 0) {\n            return stats.get(0);\n        }\n        return new DocumentStats();\n    }\n\n    /**\n     * Get statistics about the number of request for the current space during the current month.\n     *\n     * @param action the type of request for which to retrieve statistics: view, edit...\n     * @return the statistics object holding information for the document's space and the current month\n     */\n    public DocumentStats getCurrentMonthSpaceStats(String action)\n    {\n        Scope scope = ScopeFactory.createSpaceScope(this.doc.getSpace(), false);\n        Range range = RangeFactory.ALL;\n        Period period = PeriodFactory.getCurrentMonth();\n        XWikiStatsService statisticsService = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        List<DocumentStats> stats = statisticsService.getDocumentStatistics(action, scope, period, range, this.context);\n        if (stats.size() > 0) {\n            return stats.get(0);\n        }\n        return new DocumentStats();\n    }\n\n    /**\n     * Get referer statistics for the current document during the current month.\n     *\n     * @return a list of referer statistics for the document's space\n     */\n    public List<RefererStats> getCurrentMonthRefStats()\n    {\n        Scope scope = ScopeFactory.createPageScope(this.getFullName());\n        Range range = RangeFactory.ALL;\n        Period period = PeriodFactory.getCurrentMonth();\n        XWikiStatsService statisticsService = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        List<RefererStats> stats = statisticsService.getRefererStatistics(\"\", scope, period, range, this.context);\n        return stats;\n    }\n\n    public boolean checkAccess(String right)\n    {\n        try {\n            return getXWikiContext().getWiki().checkAccess(right, this.doc, getXWikiContext());\n        } catch (XWikiException e) {\n            return false;\n        }\n    }\n\n    public boolean hasAccessLevel(String level)\n    {\n        try {\n            return getXWikiContext().getWiki().getRightService().hasAccessLevel(level, getXWikiContext().getUser(),\n                this.getPrefixedFullName(), getXWikiContext());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    @Override\n    public boolean hasAccessLevel(String level, String user)\n    {\n        try {\n            return getXWikiContext().getWiki().getRightService().hasAccessLevel(level, user, this.getPrefixedFullName(),\n                getXWikiContext());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * Verifies if the user identified by {@code userReference} has the access identified by {@code right} on this\n     * document.\n     * Note that this method does not override {@link Api#hasAccess(Right, DocumentReference)}: they share same\n     * signature but on the {@code Api} one the {@link DocumentReference} parameter is about the entity where to check\n     * the right, while here it's about the user to check right for.\n     * \n     * @param right the right to check\n     * @param userReference the user to check the right for\n     * @return {@code true} if the user has the specified right on this document, {@code false} otherwise\n     * @since 10.6RC1\n     */\n    public boolean hasAccess(Right right, DocumentReference userReference)\n    {\n        return getAuthorizationManager().hasAccess(right, userReference, getDocumentReference());\n    }\n\n    /**\n     * Verifies if the context user has the access identified by {@code right} on the current context document.\n     * @param right the right to check\n     * @return {@code true} if the user has the specified right on this document, {@code false} otherwise\n     * @since 14.10\n     * @since 14.4.7\n     */\n    @Unstable\n    public boolean hasAccess(Right right)\n    {\n        return hasAccess(right, getXWikiContext().getUserReference());\n    }\n\n    public boolean getLocked()\n    {\n        try {\n            XWikiLock lock = this.doc.getLock(getXWikiContext());\n            if (lock != null && !getXWikiContext().getUser().equals(lock.getUserName())) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public String getLockingUser()\n    {\n        try {\n            XWikiLock lock = this.doc.getLock(getXWikiContext());\n            if (lock != null && !getXWikiContext().getUser().equals(lock.getUserName())) {\n                return lock.getUserName();\n            } else {\n                return \"\";\n            }\n        } catch (XWikiException e) {\n            return \"\";\n        }\n    }\n\n    public Date getLockingDate()\n    {\n        try {\n            XWikiLock lock = this.doc.getLock(getXWikiContext());\n            if (lock != null && !getXWikiContext().getUser().equals(lock.getUserName())) {\n                return lock.getDate();\n            } else {\n                return null;\n            }\n        } catch (XWikiException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Renders the passed xproperty as HTML. Note that if you need the raw value, you should call \n     * {@link #getValue(String)} instead. \n     *\n     * @param classOrFieldName the xproperty (aka field) name to render or an xclass reference\n     * @return the rendered xproperty as HTML if an xobject exists with that xproperty. Otherwise considers that the\n     *         passed parameter is an xclass reference and return the xobject for it or null if none exist\n     * @see #getValue(String) \n     * @see #getValue(String, Object) \n     */\n    public java.lang.Object get(String classOrFieldName)\n    {\n        if (this.currentObj != null) {\n            return this.doc.display(classOrFieldName, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n        BaseObject object = this.doc.getFirstObject(classOrFieldName, getXWikiContext());\n        if (object != null) {\n            return this.doc.display(classOrFieldName, object, getXWikiContext());\n        }\n        return this.getDoc().getObject(classOrFieldName);\n    }\n\n    /**\n     * @param fieldName the xproperty (aka field) name for which to get the value\n     * @return the raw value of the passed xproperty found in the current xobject or in the first xobject containing\n     *         such a field\n     * @see #getValue(String, Object) \n     */\n    public java.lang.Object getValue(String fieldName)\n    {\n        Object object;\n        if (this.currentObj == null) {\n            object = new Object(this.getDoc().getFirstObject(fieldName, getXWikiContext()), getXWikiContext());\n        } else {\n            object = this.currentObj;\n        }\n        return getValue(fieldName, object);\n    }\n\n    /**\n     * @param fieldName the xproperty (aka field) name for which to get the value\n     * @param object the specific xobject from which to get the xproperty value\n     * @return the raw value of the passed xproperty\n     * @see #getValue(String)\n     */\n    public java.lang.Object getValue(String fieldName, Object object)\n    {\n        if (object != null) {\n            return object.getValue(fieldName);\n        }\n\n        return null;\n    }\n\n    public String getTextArea()\n    {\n        return com.xpn.xwiki.XWiki.getTextArea(this.doc.getContent(), getXWikiContext());\n    }\n\n    /**\n     * Returns data needed for a generation of Table of Content for this document.\n     *\n     * @param init an intial level where the TOC generation should start at\n     * @param max maximum level TOC is generated for\n     * @param numbered if should generate numbering for headings\n     * @return a map where an heading (title) ID is the key and value is another map with two keys: text, level and\n     *         numbering\n     */\n    public Map<String, Map<String, java.lang.Object>> getTOC(int init, int max, boolean numbered)\n    {\n        getXWikiContext().put(\"tocNumbered\", new Boolean(numbered));\n        return TOCGenerator.generateTOC(getContent(), init, max, numbered, getXWikiContext());\n    }\n\n    public String getTags()\n    {\n        return this.doc.getTags(getXWikiContext());\n    }\n\n    public List<String> getTagList()\n    {\n        return this.getDoc().getTagsList(getXWikiContext());\n    }\n\n    public List<String> getTagsPossibleValues()\n    {\n        return this.doc.getTagsPossibleValues(getXWikiContext());\n    }\n\n    public void insertText(String text, String marker) throws XWikiException\n    {\n        if (hasAccessLevel(\"edit\")) {\n            getDoc().insertText(text, marker, getXWikiContext());\n\n            updateAuthor();\n            updateContentAuthor();\n        }\n    }\n\n    @Override\n    public boolean equals(java.lang.Object arg0)\n    {\n        if (!(arg0 instanceof Document)) {\n            return false;\n        }\n        Document d = (Document) arg0;\n        return d.getXWikiContext().equals(getXWikiContext()) && this.doc.equals(d.doc);\n    }\n\n    /**\n     * Check if the passed one is the one wrapped by this {@link Document}.\n     * \n     * @param document the document to compare\n     * @return true if passed document is the wrapped one\n     * @since 8.3M1\n     */\n    public boolean same(XWikiDocument document)\n    {\n        return document == this.doc || document == this.initialDoc;\n    }\n\n    public List<String> getBacklinks() throws XWikiException\n    {\n        return this.doc.getBackLinkedPages(getXWikiContext());\n    }\n\n    /**\n     * Retrieve the references of the page containing a link to the current page.\n     *\n     * @return a list of references of the page containing a link to the current page.\n     * @throws XWikiException in case of problem to perform the query.\n     * @since 12.5RC1\n     */\n    public List<DocumentReference> getBackLinkedReferences() throws XWikiException\n    {\n        return this.doc.getBackLinkedReferences(getXWikiContext());\n    }\n\n    public List<XWikiLink> getLinks() throws XWikiException\n    {\n        return new ArrayList<XWikiLink>(this.doc.getUniqueWikiLinkedPages(getXWikiContext()));\n    }\n\n    /**\n     * Get the top sections contained in the document.\n     * <p>\n     * The section are filtered by xwiki.section.depth property on the maximum depth of the sections to return. This\n     * method is usually used to get \"editable\" sections.\n     *\n     * @return the sections in the current document\n     */\n    public List<DocumentSection> getSections() throws XWikiException\n    {\n        return this.doc.getSections();\n    }\n\n    /**\n     * Get document children. Children are documents with the current document as parent.\n     *\n     * @return The list of children for the current document.\n     * @since 1.8 Milestone 2\n     */\n    public List<String> getChildren() throws XWikiException\n    {\n        return this.doc.getChildren(getXWikiContext());\n    }\n\n    /**\n     * Get document children references. Children are documents with the current document as parent.\n     * @return The list of children for the current document.\n     * @throws XWikiException in case of problem to query the children.\n     * @since 12.5RC1\n     */\n    public List<DocumentReference> getChildrenReferences() throws XWikiException\n    {\n        return this.doc.getChildrenReferences(getXWikiContext());\n    }\n\n    /**\n     * Get document children. Children are documents with the current document as parent. Where a document has a large\n     * number of children, one may desire to return a certain number of children (nb) and skip some number (start) of\n     * the first results.\n     *\n     * @param nb The number of results to return.\n     * @param start The number of results to skip before we begin returning results.\n     * @return The list of children for the current document.\n     */\n    public List<String> getChildren(int nb, int start) throws XWikiException\n    {\n        return this.doc.getChildren(nb, start, getXWikiContext());\n    }\n\n    /**\n     * Gets the default edit mode for this document. An edit mode (other than the default \"edit\") can be enforced by\n     * creating an {@code XWiki.EditModeClass} object in the current document, with the appropriate value for the\n     * defaultEditMode property, or by adding this object in a sheet included by the document. This function also falls\n     * back on the old {@code SheetClass}, deprecated since 3.1M2, which can be attached to included documents to\n     * specify that the current document should be edited inline.\n     *\n     * @return the default edit mode for this document (\"edit\" or \"inline\" usually)\n     * @throws XWikiException since XWiki 6.3M1 it's not used anymore and \"edit\" is returned in case of error, with an\n     *             error log\n     */\n    public String getDefaultEditMode() throws XWikiException\n    {\n        return this.doc.getDefaultEditMode(getXWikiContext());\n    }\n\n    public String getDefaultEditURL() throws XWikiException\n    {\n        return this.doc.getDefaultEditURL(getXWikiContext());\n    }\n\n    public String getEditURL(String action, String mode) throws XWikiException\n    {\n        return this.doc.getEditURL(action, mode, getXWikiContext());\n    }\n\n    public String getEditURL(String action, String mode, String locale)\n    {\n        return this.doc.getEditURL(action, mode, locale, getXWikiContext());\n    }\n\n    public boolean isCurrentUserCreator()\n    {\n        return this.doc.isCurrentUserCreator(getXWikiContext());\n    }\n\n    public boolean isCurrentUserPage()\n    {\n        return this.doc.isCurrentUserPage(getXWikiContext());\n    }\n\n    public boolean isCurrentLocalUserPage()\n    {\n        return this.doc.isCurrentLocalUserPage(getXWikiContext());\n    }\n\n    public boolean isCreator(String username)\n    {\n        return this.doc.isCreator(username);\n    }\n\n    public void set(String fieldname, java.lang.Object value)\n    {\n        Object obj;\n        if (this.currentObj != null) {\n            obj = this.currentObj;\n        } else {\n            obj = getFirstObject(fieldname);\n        }\n        set(fieldname, value, obj);\n    }\n\n    public void set(String fieldname, java.lang.Object value, Object obj)\n    {\n        if (obj == null) {\n            return;\n        }\n        obj.set(fieldname, value);\n    }\n\n    public void setTitle(String title)\n    {\n        getDoc().setTitle(title);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    public void setCustomClass(String customClass)\n    {\n        getDoc().setCustomClass(customClass);\n\n        updateAuthor();\n    }\n\n    public void setParent(String parent)\n    {\n        getDoc().setParent(parent);\n\n        updateAuthor();\n    }\n\n    private void updateContentAuthor()\n    {\n        // Temporary set as content author of the document the current script author (until the document is saved)\n        XWikiContext xcontext = getXWikiContext();\n        getDoc().setContentAuthorReference(xcontext.getAuthorReference());\n    }\n\n    private void updateAuthor()\n    {\n        // Temporary set as author of the document the current script author (until the document is saved)\n        XWikiContext xcontext = getXWikiContext();\n        getDoc().setAuthorReference(xcontext.getAuthorReference());\n    }\n\n    public void setContent(String content)\n    {\n        getDoc().setContent(content);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    /**\n     * @param content the content as XDOM\n     * @throws XWikiException when failing to convert the XDOM to String content\n     * @since 7.0RC1\n     */\n    public void setContent(XDOM content) throws XWikiException\n    {\n        getDoc().setContent(content);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    /**\n     * @param syntax the Syntax representing the syntax used for the current document's content.\n     * @since 2.3M1\n     */\n    public void setSyntax(Syntax syntax)\n    {\n        getDoc().setSyntax(syntax);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    /**\n     * @param syntaxId the Syntax id representing the syntax used for the current document. For example \"xwiki/1.0\"\n     *            represents the first version XWiki syntax while \"xwiki/2.0\" represents version 2.0 of the XWiki\n     *            Syntax.\n     */\n    public void setSyntaxId(String syntaxId)\n    {\n        getDoc().setSyntaxId(syntaxId);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    public void setDefaultTemplate(String dtemplate)\n    {\n        getDoc().setDefaultTemplate(dtemplate);\n\n        updateAuthor();\n    }\n\n    public void setComment(String comment)\n    {\n        getDoc().setComment(comment);\n    }\n\n    public void setMinorEdit(boolean isMinor)\n    {\n        getDoc().setMinorEdit(isMinor);\n    }\n\n    public void save() throws XWikiException\n    {\n        save(\"\", false);\n    }\n\n    public void save(String comment) throws XWikiException\n    {\n        save(comment, false);\n    }\n\n    private UserReferenceResolver<CurrentUserReference> getCurrentUserReferenceResolver()\n    {\n        return Utils.getComponent(new DefaultParameterizedType(null, UserReferenceResolver.class,\n                CurrentUserReference.class));\n    }\n\n    public void save(String comment, boolean minorEdit) throws XWikiException\n    {\n        if (hasAccessLevel(\"edit\")) {\n\n            DocumentAuthors authors = getDoc().getAuthors();\n            authors.setOriginalMetadataAuthor(getCurrentUserReferenceResolver().resolve(CurrentUserReference.INSTANCE));\n            // If the current author does not have PR don't let it set current user as author of the saved document\n            // since it can lead to right escalation\n            if (hasProgrammingRights() || !getConfiguration().getProperty(\"security.script.save.checkAuthor\", true)) {\n                saveDocument(comment, minorEdit);\n            } else {\n                saveAsAuthor(comment, minorEdit);\n            }\n        } else {\n            java.lang.Object[] args = {getDefaultEntityReferenceSerializer().serialize(getDocumentReference())};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied in edit mode on document {0}\", null, args);\n        }\n    }\n\n    public void saveWithProgrammingRights() throws XWikiException\n    {\n        saveWithProgrammingRights(\"\", false);\n    }\n\n    public void saveWithProgrammingRights(String comment) throws XWikiException\n    {\n        saveWithProgrammingRights(comment, false);\n    }\n\n    public void saveWithProgrammingRights(String comment, boolean minorEdit) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            // The rights check above is generic, but the current method is a save operation, thus it should not be\n            // performed if the document's wiki is in read only mode.\n            XWikiContext context = getXWikiContext();\n            String currentWikiId = context.getWikiId();\n            try {\n                // Make sure we check the current document's wiki and not the current context's wiki.\n                context.setWikiId(getWiki());\n\n                if (!context.getWiki().isReadOnly()) {\n                    saveDocument(comment, minorEdit, false);\n                } else {\n                    java.lang.Object[] args =\n                        { getDefaultEntityReferenceSerializer().serialize(getDocumentReference()), getWiki() };\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        \"Access denied in edit mode on document [{0}]. The wiki [{1}] is in read only mode.\", null,\n                        args);\n                }\n            } finally {\n                // Restore the context wiki.\n                context.setWikiId(currentWikiId);\n            }\n        } else {\n            java.lang.Object[] args = { this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied with no programming rights document {0}\", null, args);\n        }\n    }\n\n    /**\n     * Save the document if the current author of the script calling this method has permission to do so. The author of\n     * this document is also set to the said author.\n     *\n     * @throws XWikiException if script author is not allowed to save the document or if save operation fails.\n     * @since 2.3M2\n     */\n    public void saveAsAuthor() throws XWikiException\n    {\n        saveAsAuthor(\"\", false);\n    }\n\n    /**\n     * Save the document if the current author of the script calling this method has permission to do so. The author of\n     * this document is also set to the said author.\n     *\n     * @param comment The comment to display in document history (what did you change in the document)\n     * @throws XWikiException if script author is not allowed to save the document or if save operation fails.\n     * @since 2.3M2\n     */\n    public void saveAsAuthor(String comment) throws XWikiException\n    {\n        saveAsAuthor(comment, false);\n    }\n\n    /**\n     * Save the document if the current author of the script calling this method has permission to do so. The author of\n     * this document is also set to the said author.\n     *\n     * @param comment The comment to display in document history (what did you change in the document)\n     * @param minorEdit Set true to advance the document version number by 0.1 or false to advance version to the next\n     *            integer + 0.1 eg: 25.1\n     * @throws XWikiException if script author is not allowed to save the document or if save operation fails.\n     * @since 2.3M2\n     */\n    public void saveAsAuthor(String comment, boolean minorEdit) throws XWikiException\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        getDoc().getAuthors()\n            .setOriginalMetadataAuthor(getCurrentUserReferenceResolver().resolve(CurrentUserReference.INSTANCE));\n        DocumentReference author = getEffectiveAuthorReference();\n        if (hasAccess(Right.EDIT, author)) {\n            DocumentReference currentUser = xcontext.getUserReference();\n            try {\n                xcontext.setUserReference(author);\n\n                saveDocument(comment, minorEdit);\n            } finally {\n                xcontext.setUserReference(currentUser);\n            }\n        } else {\n            java.lang.Object[] args = { author, xcontext.getDoc(), getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied; user {0}, acting through script in document {1} cannot save document {2}\", null, args);\n        }\n    }\n\n    protected void saveDocument(String comment, boolean minorEdit) throws XWikiException\n    {\n        saveDocument(comment, minorEdit, true);\n    }\n\n    private void saveDocument(String comment, boolean minorEdit, boolean checkSaving) throws XWikiException\n    {\n        XWikiDocument doc = getDoc();\n\n        UserReference currentUserReference = getCurrentUserReferenceResolver().resolve(CurrentUserReference.INSTANCE);\n        doc.getAuthors().setEffectiveMetadataAuthor(currentUserReference);\n\n        if (doc.isNew()) {\n            doc.getAuthors().setCreator(currentUserReference);\n        }\n\n        if (checkSaving) {\n            // Make sure the user is allowed to make this modification\n            getXWikiContext().getWiki().checkSavingDocument(doc.getAuthorReference(), doc, comment, minorEdit,\n                getXWikiContext());\n        }\n\n        getXWikiContext().getWiki().saveDocument(doc, comment, minorEdit, getXWikiContext());\n        this.initialDoc = this.doc;\n    }\n\n    public com.xpn.xwiki.api.Object addObjectFromRequest() throws XWikiException\n    {\n        // Call to getDoc() ensures that we are working on a clone()\n        com.xpn.xwiki.api.Object obj =\n            new com.xpn.xwiki.api.Object(getDoc().addXObjectFromRequest(getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public com.xpn.xwiki.api.Object addObjectFromRequest(String className) throws XWikiException\n    {\n        com.xpn.xwiki.api.Object obj = new com.xpn.xwiki.api.Object(\n            getDoc().addObjectFromRequest(className, getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public List<Object> addObjectsFromRequest(String className) throws XWikiException\n    {\n        return addObjectsFromRequest(className, \"\");\n    }\n\n    public com.xpn.xwiki.api.Object addObjectFromRequest(String className, String prefix) throws XWikiException\n    {\n        com.xpn.xwiki.api.Object obj = new com.xpn.xwiki.api.Object(\n            getDoc().addObjectFromRequest(className, prefix, getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public List<Object> addObjectsFromRequest(String className, String prefix) throws XWikiException\n    {\n        List<BaseObject> objs = getDoc().addObjectsFromRequest(className, prefix, getXWikiContext());\n        List<Object> wrapped = new ArrayList<Object>();\n        for (BaseObject object : objs) {\n            wrapped.add(new com.xpn.xwiki.api.Object(object, getXWikiContext()));\n        }\n\n        updateAuthor();\n\n        return wrapped;\n    }\n\n    public com.xpn.xwiki.api.Object updateObjectFromRequest(String className) throws XWikiException\n    {\n        com.xpn.xwiki.api.Object obj = new com.xpn.xwiki.api.Object(\n            getDoc().updateObjectFromRequest(className, getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public List<Object> updateObjectsFromRequest(String className) throws XWikiException\n    {\n        return updateObjectsFromRequest(className, \"\");\n    }\n\n    public com.xpn.xwiki.api.Object updateObjectFromRequest(String className, String prefix) throws XWikiException\n    {\n        com.xpn.xwiki.api.Object obj = new com.xpn.xwiki.api.Object(\n            getDoc().updateObjectFromRequest(className, prefix, getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public List<Object> updateObjectsFromRequest(String className, String prefix) throws XWikiException\n    {\n        List<BaseObject> objs = getDoc().updateObjectsFromRequest(className, prefix, getXWikiContext());\n        List<Object> wrapped = new ArrayList<Object>();\n        for (BaseObject object : objs) {\n            wrapped.add(new com.xpn.xwiki.api.Object(object, getXWikiContext()));\n        }\n\n        updateAuthor();\n\n        return wrapped;\n    }\n\n    public boolean isAdvancedContent()\n    {\n        return this.doc.isAdvancedContent();\n    }\n\n    public boolean isProgrammaticContent()\n    {\n        return this.doc.isProgrammaticContent();\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     */\n    public boolean removeObject(Object object)\n    {\n        return getDoc().removeObject(object.getBaseObject());\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param className The class name of the objects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     */\n    public boolean removeObjects(String className)\n    {\n        return getDoc().removeObjects(className);\n    }\n\n    /**\n     * Remove document from the wiki. Reinit <code>cloned</code>.\n     *\n     * @throws XWikiException\n     */\n    protected void deleteDocument() throws XWikiException\n    {\n        getXWikiContext().getWiki().deleteDocument(this.doc, getXWikiContext());\n        this.initialDoc = this.doc;\n    }\n\n    public void delete() throws XWikiException\n    {\n        if (hasAccessLevel(\"delete\")) {\n            deleteDocument();\n        } else {\n            java.lang.Object[] args = { this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied in edit mode on document {0}\", null, args);\n        }\n    }\n\n    /**\n     * Delete the document if the {@link #getContentAuthor content author} of the script calling this method has\n     * permission to do so. The deleter is also set to the said content author.\n     *\n     * @throws XWikiException if script author is not allowed to delete the document or if save operation fails.\n     * @since 2.3M2\n     */\n    public void deleteAsAuthor() throws XWikiException\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        DocumentReference author = getEffectiveAuthorReference();\n        if (hasAccess(Right.DELETE, author)) {\n            DocumentReference currentUser = xcontext.getUserReference();\n            try {\n                xcontext.setUserReference(author);\n\n                deleteDocument();\n            } finally {\n                xcontext.setUserReference(currentUser);\n            }\n        } else {\n            java.lang.Object[] args = { author, xcontext.getDoc(), this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied; user {0}, acting through script in document {1} cannot delete document {2}\", null,\n                args);\n        }\n    }\n\n    public void deleteWithProgrammingRights() throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            deleteDocument();\n        } else {\n            java.lang.Object[] args = { this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied with no programming rights document {0}\", null, args);\n        }\n    }\n\n    public String getVersionHashCode()\n    {\n        return this.doc.getVersionHashCode(getXWikiContext());\n    }\n\n    public int addAttachments() throws XWikiException\n    {\n        return addAttachments(null);\n    }\n\n    public int addAttachments(String fieldName) throws XWikiException\n    {\n        if (!hasAccessLevel(\"edit\")) {\n            java.lang.Object[] args = { this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied in edit mode on document {0}\", null, args);\n        }\n        XWiki xwiki = getXWikiContext().getWiki();\n        FileUploadPlugin fileupload = (FileUploadPlugin) xwiki.getPlugin(\"fileupload\", getXWikiContext());\n        List<FileItem> fileuploadlist = fileupload.getFileItems(getXWikiContext());\n        List<XWikiAttachment> attachments = new ArrayList<XWikiAttachment>();\n        // adding attachment list to context so we find the names\n        this.context.put(\"addedAttachments\", attachments);\n        int nb = 0;\n\n        if (fileuploadlist == null) {\n            return 0;\n        }\n\n        for (FileItem item : fileuploadlist) {\n            String name = item.getFieldName();\n            if (fieldName != null && !fieldName.equals(name)) {\n                continue;\n            }\n            if (item.isFormField()) {\n                continue;\n            }\n            byte[] data = fileupload.getFileItemData(name, getXWikiContext());\n            String filename;\n            String fname = fileupload.getFileName(name, getXWikiContext());\n            int i = fname.lastIndexOf(\"\\\\\");\n            if (i == -1) {\n                i = fname.lastIndexOf(\"/\");\n            }\n            filename = fname.substring(i + 1);\n            filename = filename.replaceAll(\"\\\\+\", \" \");\n\n            if ((data != null) && (data.length > 0)) {\n                XWikiAttachment attachment = this.getDoc().addAttachment(filename, data, getXWikiContext());\n                getDoc().saveAttachmentContent(attachment, getXWikiContext());\n                // commenting because this was already done by addAttachment\n                // getDoc().getAttachmentList().add(attachment);\n                attachments.add(attachment);\n                nb++;\n            }\n        }\n\n        if (nb > 0) {\n            getXWikiContext().getWiki().saveDocument(getDoc(), getXWikiContext());\n            this.initialDoc = this.doc;\n        }\n\n        return nb;\n    }\n\n    public Attachment addAttachment(String fileName, InputStream iStream)\n    {\n        try {\n            return new Attachment(this, this.getDoc().setAttachment(fileName, iStream, getXWikiContext()),\n                getXWikiContext());\n        } catch (IOException e) {\n            // TODO Log the error and let the user know about it\n        } finally {\n            updateAuthor();\n        }\n\n        return null;\n    }\n\n    public Attachment addAttachment(String fileName, byte[] data)\n    {\n        try {\n            return new Attachment(this, this.getDoc().addAttachment(fileName, data, getXWikiContext()),\n                getXWikiContext());\n        } catch (XWikiException e) {\n            // TODO Log the error and let the user know about it\n        } finally {\n            updateAuthor();\n        }\n\n        return null;\n    }\n\n    public boolean validate() throws XWikiException\n    {\n        return this.doc.validate(getXWikiContext());\n    }\n\n    public boolean validate(String[] classNames) throws XWikiException\n    {\n        return this.doc.validate(classNames, getXWikiContext());\n    }\n\n    /**\n     * Retrieves the validation script associated with this document, a Velocity script that is executed when validating\n     * the document data.\n     *\n     * @return A <code>String</code> representation of the validation script, or an empty string if there is no such\n     *         script.\n     */\n    public String getValidationScript()\n    {\n        return getDoc().getValidationScript();\n    }\n\n    /**\n     * Sets a new validation script for this document, a Velocity script that is executed when validating the document\n     * data.\n     *\n     * @param validationScript The new validation script, which can be an empty string or <code>null</code> if the\n     *            script should be removed.\n     */\n    public void setValidationScript(String validationScript)\n    {\n        getDoc().setValidationScript(validationScript);\n\n        updateAuthor();\n    }\n\n    /**\n     * Rename the current document and all the backlinks leading to it. Will also change parent field in all documents\n     * which list the document we are renaming as their parent. See\n     * {@link #rename(String, java.util.List, java.util.List)} for more details.\n     *\n     * @param newReference the reference to the new document\n     * @throws XWikiException in case of an error\n     * @since 2.3M2\n     */\n    public void rename(DocumentReference newReference) throws XWikiException\n    {\n        if (hasAccessLevel(\"delete\") && this.context.getWiki().checkAccess(\"edit\",\n            this.context.getWiki().getDocument(newReference, this.context), this.context)) {\n            this.getDoc().rename(newReference, getXWikiContext());\n        }\n    }\n\n    /**\n     * Rename the current document and all the links pointing to it in the list of passed backlink documents. The\n     * renaming algorithm takes into account the fact that there are several ways to write a link to a given page and\n     * all those forms need to be renamed. For example the following links all point to the same page:\n     * <ul>\n     * <li>[Page]</li>\n     * <li>[Page?param=1]</li>\n     * <li>[currentwiki:Page]</li>\n     * <li>[currentwiki:CurrentSpace.Page]</li>\n     * </ul>\n     * <p>\n     * Note: links without a space are renamed with the space added and all documents which have the document being\n     * renamed as parent have their parent field set to \"currentwiki:CurrentSpace.Page\".\n     * </p>\n     *\n     * @param newDocumentName the new document name. If the space is not specified then defaults to the current space.\n     * @param backlinkDocumentNames the list of documents to parse and for which links will be modified to point to the\n     *            new renamed document.\n     * @throws XWikiException in case of an error\n     */\n    public void rename(String newDocumentName, List<String> backlinkDocumentNames) throws XWikiException\n    {\n        rename(newDocumentName, backlinkDocumentNames, Collections.emptyList());\n    }\n\n    /**\n     * Same as {@link #rename(String, List)} but the list of documents having the current document as their parent is\n     * passed in parameter.\n     *\n     * @param newDocumentName the new document name. If the space is not specified then defaults to the current space.\n     * @param backlinkDocumentNames the list of documents to parse and for which links will be modified to point to the\n     *            new renamed document.\n     * @param childDocumentNames the list of documents whose parent field will be set to the new document name.\n     * @throws XWikiException in case of an error\n     */\n    public void rename(String newDocumentName, List<String> backlinkDocumentNames, List<String> childDocumentNames)\n        throws XWikiException\n    {\n        List<DocumentReference> backlinkDocumentReferences = new ArrayList<DocumentReference>();\n        for (String backlinkDocumentName : backlinkDocumentNames) {\n            backlinkDocumentReferences.add(getCurrentMixedDocumentReferenceResolver().resolve(backlinkDocumentName));\n        }\n\n        List<DocumentReference> childDocumentReferences = new ArrayList<DocumentReference>();\n        for (String childDocumentName : childDocumentNames) {\n            childDocumentReferences.add(getCurrentMixedDocumentReferenceResolver().resolve(childDocumentName));\n        }\n\n        rename(getCurrentMixedDocumentReferenceResolver().resolve(newDocumentName), backlinkDocumentReferences,\n            childDocumentReferences);\n    }\n\n    /**\n     * Same as {@link #rename(String, List)} but the list of documents having the current document as their parent is\n     * passed in parameter.\n     *\n     * @param newReference the reference to the new document\n     * @param backlinkDocumentNames the list of reference to documents to parse and for which links will be modified to\n     *            point to the new renamed document\n     * @param childDocumentNames the list of references to documents whose parent field will be set to the new document\n     *            reference\n     * @throws XWikiException in case of an error\n     * @since 2.3M2\n     */\n    public void rename(DocumentReference newReference, List<DocumentReference> backlinkDocumentNames,\n        List<DocumentReference> childDocumentNames) throws XWikiException\n    {\n        if (hasAccessLevel(\"delete\") && this.context.getWiki().checkAccess(\"edit\",\n            this.context.getWiki().getDocument(newReference, this.context), this.context)) {\n\n            // Every page given in childDocumentNames has it's parent changed whether it needs it or not.\n            // Let's make sure the user has edit permission on any page given which is not actually a child.\n            // Otherwise it would be embarrassing if a user called:\n            // $doc.rename(\"mynewpage\",$doc.getBacklinks(),$xwiki.searchDocuments(\"true\"))\n            int counter = childDocumentNames.size();\n            List<String> actuallyChildren = getChildren();\n            while (counter > 0) {\n                counter--;\n                if (!actuallyChildren.contains(childDocumentNames.get(counter))\n                    && !this.context.getWiki().checkAccess(\"edit\",\n                        this.context.getWiki().getDocument(childDocumentNames.get(counter), this.context),\n                        this.context)) {\n                    return;\n                }\n            }\n\n            this.getDoc().rename(newReference, backlinkDocumentNames, childDocumentNames, getXWikiContext());\n        }\n    }\n\n    /**\n     * Allow to easily access any revision of a document\n     *\n     * @param revision the version to access\n     * @return the document corresponding to the requested revision or {@code null} if the revision does not exist.\n     */\n    public Document getDocumentRevision(String revision)\n    {\n        try {\n            XWikiDocument documentRevision = getDocumentRevisionProvider().getRevision(this.doc, revision);\n\n            return documentRevision != null ? new Document(documentRevision, this.context) : null;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to load revision [{}] of document [{}]\", revision, getDocumentReferenceWithLocale(),\n                e);\n\n            return null;\n        }\n    }\n\n    /**\n     * Allow to easily access the previous revision of a document\n     *\n     * @return Document\n     * @throws XWikiException\n     */\n    public Document getPreviousDocument() throws XWikiException\n    {\n        return getDocumentRevision(getPreviousVersion());\n    }\n\n    /**\n     * @return is document most recent. false if and only if there are older versions of this document.\n     */\n    public boolean isMostRecent()\n    {\n        return this.doc.isMostRecent();\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.doc.toString();\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntaxId the syntax to convert to (eg \"xwiki/2.0\", \"xhtml/1.0\", etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public boolean convertSyntax(String targetSyntaxId) throws XWikiException\n    {\n        try {\n            getDoc().convertSyntax(targetSyntaxId, this.context);\n        } catch (Exception ex) {\n            LOGGER.error(\n                \"Failed to convert document [\" + getPrefixedFullName() + \"] to syntax [\" + targetSyntaxId + \"]\", ex);\n\n            return false;\n        } finally {\n            updateAuthor();\n            updateContentAuthor();\n        }\n\n        return true;\n    }\n\n    /**\n     * Indicates whether the document is 'hidden' or not, meaning that it should not be returned in public search\n     * results or appear in the User Interface in general.\n     *\n     * @return <code>true</code> if the document is hidden, <code>false</code> otherwise.\n     */\n    public boolean isHidden()\n    {\n        return this.doc.isHidden();\n    }\n\n    /**\n     * Indicates whether the document should be 'hidden' or not, meaning that it should not be returned in public search\n     * results or appear in the User Interface in general.\n     *\n     * @param hidden <code>true</code> if the document should be 'hidden', <code>false</code> otherwise.\n     */\n    public void setHidden(boolean hidden)\n    {\n        this.doc.setHidden(hidden);\n    }\n\n    /**\n     * Drop permissions for the remainder of the rendering cycle. After this is called:\n     * <ul>\n     * <li>1. {@link com.xpn.xwiki.api.Api#hasProgrammingRights()} will always return false.</li>\n     * <li>2. {@link com.xpn.xwiki.api.XWiki#getDocumentAsAuthor(org.xwiki.model.reference.DocumentReference)},\n     * {@link com.xpn.xwiki.api.XWiki#getDocumentAsAuthor(String)}, {@link com.xpn.xwiki.api.Document#saveAsAuthor()},\n     * {@link com.xpn.xwiki.api.Document#saveAsAuthor(String)},\n     * {@link com.xpn.xwiki.api.Document#saveAsAuthor(String, boolean)}, and\n     * {@link com.xpn.xwiki.api.Document#deleteAsAuthor()} will perform all of their actions as if the document's\n     * content author was the guest user (XWiki.XWikiGuest).</li>\n     * </ul>\n     * <p>\n     * This sandboxing will expire at the end of the rendering cycle and can be suspended by beginning a new rendering\n     * cycle. A rendering cycle can be begin by calling {@link #getRenderedContent(String)}, {@link #display(String)}\n     * (or variations thereof) or by invoking the include macro or using\n     * {@link com.xpn.xwiki.api.XWiki#includeTopic(String)}\n     * <p>\n     * NOTE: Even if you include the same document, permissions will be regained. What this does is sandbox the\n     * remainder of the code on the page because although it can temporarily suspend the permissions drop, it cannot get\n     * itself to be executed with permissions because if it calls itself, it will hit the drop function first.\n     * <p>\n     * If you are interested in a more secure sandboxing method where code is guaranteed not to have permissions for the\n     * remainder of the request, you should consider {@link com.xpn.xwiki.api.Context#dropPermissions()}.\n     * <p>\n     *\n     * @since 3.2M2\n     */\n    public void dropPermissions()\n    {\n        // Set the droppedPermissions key to the context so if the context is cloned and\n        // pushed, it will return false until it is popped again.\n        final ExecutionContext context = Utils.getComponent(Execution.class).getContext();\n        context.setProperty(XWikiConstant.DROPPED_PERMISSIONS, System.identityHashCode(context));\n    }\n\n    /**\n     * @return true if this document is a translation of the main document (i.e. returned by\n     *         {@link #getTranslatedDocument(String)}); false if this is actually the main document (i.e. returned by\n     *         {@link com.xpn.xwiki.api.XWiki#getDocument(DocumentReference)}.\n     * @since 6.2M2\n     */\n    public boolean isTranslation()\n    {\n        return 1 == this.getDoc().getTranslation();\n    }\n\n    /**\n     * @return the maximum authorized length for a document full name (see {@link #getFullName()}).\n     * @since 11.4RC1\n     */\n    public int getLocalReferenceMaxLength()\n    {\n        return this.doc.getLocalReferenceMaxLength();\n    }\n\n    /**\n     * @return the authors of the document.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public DocumentAuthors getAuthors()\n    {\n        if (this.hasAccess(Right.PROGRAM)) {\n            // We're using getDoc here to ensure to have a cloned doc\n            return getDoc().getAuthors();\n        } else {\n            // in this case we don't care if the doc is cloned or not since it's readonly\n            return new SafeDocumentAuthors(this.doc.getAuthors());\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.lang.ref.SoftReference;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.inject.Provider;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.ObjectUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.dom.DOMDocument;\nimport org.dom4j.io.DocumentResult;\nimport org.dom4j.io.OutputFormat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.diff.Diff;\nimport org.suigeneris.jrcs.diff.DifferentiationFailedException;\nimport org.suigeneris.jrcs.diff.Revision;\nimport org.suigeneris.jrcs.diff.delta.Delta;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.suigeneris.jrcs.util.ToString;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContextException;\nimport org.xwiki.context.ExecutionContextManager;\nimport org.xwiki.display.internal.DocumentDisplayer;\nimport org.xwiki.display.internal.DocumentDisplayerParameters;\nimport org.xwiki.filter.input.DefaultInputStreamInputSource;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.filter.input.StringInputSource;\nimport org.xwiki.filter.instance.input.DocumentInstanceInputProperties;\nimport org.xwiki.filter.instance.output.DocumentInstanceOutputProperties;\nimport org.xwiki.filter.output.DefaultOutputStreamOutputTarget;\nimport org.xwiki.filter.output.DefaultWriterOutputTarget;\nimport org.xwiki.filter.output.OutputTarget;\nimport org.xwiki.filter.xar.input.XARInputProperties;\nimport org.xwiki.filter.xar.output.XAROutputProperties;\nimport org.xwiki.filter.xml.output.DefaultResultOutputTarget;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.link.LinkException;\nimport org.xwiki.link.LinkStore;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.internal.document.DefaultDocumentAuthors;\nimport org.xwiki.model.internal.reference.DefaultSymbolScheme;\nimport org.xwiki.model.internal.reference.EntityReferenceFactory;\nimport org.xwiki.model.internal.reference.LocalStringEntityReferenceSerializer;\nimport org.xwiki.model.internal.reference.LocalUidStringEntityReferenceSerializer;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectPropertyReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.ObjectReferenceResolver;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.HeaderBlock;\nimport org.xwiki.rendering.block.MacroBlock;\nimport org.xwiki.rendering.block.SectionBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.block.match.MacroBlockMatcher;\nimport org.xwiki.rendering.internal.parser.LinkParser;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.parser.ContentParser;\nimport org.xwiki.rendering.parser.MissingParserException;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.parser.Parser;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.renderer.printer.DefaultWikiPrinter;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxRegistry;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.rendering.util.ErrorBlockGenerator;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.store.TemporaryAttachmentSessionsManager;\nimport org.xwiki.store.merge.MergeDocumentResult;\nimport org.xwiki.store.merge.MergeManager;\nimport org.xwiki.user.GuestUserReference;\nimport org.xwiki.user.UserConfiguration;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.user.UserReferenceSerializer;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.xar.internal.model.XarDocumentModel;\nimport org.xwiki.xml.XMLUtils;\nimport org.xwiki.xml.html.HTMLUtils;\n\nimport com.xpn.xwiki.CoreConfiguration;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiConstant;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.api.DocumentSection;\nimport com.xpn.xwiki.criteria.impl.RevisionCriteria;\nimport com.xpn.xwiki.doc.merge.MergeConfiguration;\nimport com.xpn.xwiki.doc.merge.MergeResult;\nimport com.xpn.xwiki.doc.rcs.XWikiRCSNodeInfo;\nimport com.xpn.xwiki.internal.cache.rendering.RenderingCache;\nimport com.xpn.xwiki.internal.doc.BaseObjects;\nimport com.xpn.xwiki.internal.doc.XWikiAttachmentList;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilterUtils;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.xml.DOMXMLWriter;\nimport com.xpn.xwiki.internal.xml.XMLWriter;\nimport com.xpn.xwiki.objects.BaseCollection;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseObjectReference;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.LargeStringProperty;\nimport com.xpn.xwiki.objects.ListProperty;\nimport com.xpn.xwiki.objects.ObjectDiff;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.ListClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.classes.StaticListClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateAttachmentStore;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.validation.XWikiValidationInterface;\nimport com.xpn.xwiki.validation.XWikiValidationStatus;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.ObjectAddForm;\nimport com.xpn.xwiki.web.ObjectPolicyType;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiRequest;\n\npublic class XWikiDocument implements DocumentModelBridge, Cloneable\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiDocument.class);\n\n    private static final String TM_FAILEDDOCUMENTPARSE = \"core.document.error.failedParse\";\n\n    private static final String CLOSE_HTML_MACRO = \"{{/html}}\";\n\n    /**\n     * An attachment waiting to be deleted at next document save.\n     *\n     * @version $Id$\n     * @since 5.2M1\n     */\n    public static class XWikiAttachmentToRemove\n    {\n        /**\n         * @see #getAttachment()\n         */\n        private XWikiAttachment attachment;\n\n        /**\n         * @see #isToRecycleBin()\n         */\n        private boolean toRecycleBin;\n\n        /**\n         * @param attachment the attachment to delete\n         * @param toRecycleBin true of the attachment should be moved to the recycle bin\n         */\n        public XWikiAttachmentToRemove(XWikiAttachment attachment, boolean toRecycleBin)\n        {\n            this.attachment = attachment;\n            this.toRecycleBin = toRecycleBin;\n        }\n\n        /**\n         * @return the attachment to delete\n         */\n        public XWikiAttachment getAttachment()\n        {\n            return this.attachment;\n        }\n\n        /**\n         * @return true of the attachment should be moved to the recycle bin\n         */\n        public boolean isToRecycleBin()\n        {\n            return this.toRecycleBin;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return this.attachment.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (obj instanceof XWikiAttachmentToRemove) {\n                return this.attachment.equals(((XWikiAttachmentToRemove) obj).getAttachment());\n            }\n\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return this.attachment.toString();\n        }\n    }\n\n    /**\n     * Regex Pattern to recognize if there's HTML code in a XWiki page.\n     */\n    private static final Pattern HTML_TAG_PATTERN = Pattern.compile(\n        \"</?+(html|img|a|i|br?|embed|script|form|input|textarea|object|font|li|[dou]l|table|center|hr|p) ?([^>]*+)>\");\n\n    public static final EntityReference COMMENTSCLASS_REFERENCE = new LocalDocumentReference(\"XWiki\", \"XWikiComments\");\n\n    public static final EntityReference SHEETCLASS_REFERENCE = new LocalDocumentReference(\"XWiki\", \"SheetClass\");\n\n    public static final int HAS_ATTACHMENTS = 1;\n\n    public static final int HAS_OBJECTS = 2;\n\n    public static final int HAS_CLASS = 4;\n\n    /**\n     * The name of the key in the XWikiContext which contains the document used to check for programming rights.\n     */\n    public static final String CKEY_SDOC = \"sdoc\";\n\n    /**\n     * Separator string between database name and space name.\n     */\n    public static final String DB_SPACE_SEP = \":\";\n\n    /**\n     * Separator string between space name and page name.\n     */\n    public static final String SPACE_NAME_SEP = \".\";\n\n    private static final LocalStringEntityReferenceSerializer LOCAL_REFERENCE_SERIALIZER =\n        new LocalStringEntityReferenceSerializer(new DefaultSymbolScheme());\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks.\n     */\n    private static DocumentReferenceResolver<String> getCurrentDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<ResourceReference> getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class, ResourceReference.class));\n    }\n\n    private static EntityReferenceResolver<String> getXClassEntityReferenceResolver()\n    {\n        return Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"xclass\");\n    }\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    private static DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private static DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n    }\n\n    /**\n     * Used to resolve parent references in the way they are stored externally (database, xml, etc), ie relative or\n     * absolute.\n     */\n    private static EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        return Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private static ObjectReferenceResolver<EntityReference> getCurrentReferenceObjectReferenceResolver()\n    {\n        return Utils.getComponent(ObjectReferenceResolver.TYPE_REFERENCE, \"current\");\n    }\n\n    /**\n     * Used to convert a syntax defined as String into a Syntax object.\n     */\n    private static SyntaxRegistry getSyntaxRegistry()\n    {\n        return Utils.getComponent(SyntaxRegistry.class);\n    }\n\n    /**\n     * Used to retrieve backlinks from an XDOM.\n     */\n    private static LinkParser getLinkParser() {\n        return Utils.getComponent(LinkParser.class);\n    }\n\n    /**\n     * @return the user module configuration, used for instance to determine where users are stored\n     */\n    private static UserConfiguration getUserConfiguration()\n    {\n        return Utils.getComponent(UserConfiguration.class);\n    }\n\n    private String title;\n\n    /**\n     * Reference to this document's parent.\n     * <p>\n     * Note that we're saving the parent reference as a relative reference instead of an absolute one because We want\n     * the ability (for example) to create a parent reference relative to the current space or wiki so that a copy of\n     * this XWikiDocument object would retain that relativity. This is for example useful when copying a Wiki into\n     * another Wiki so that the copied XWikiDcoument's parent reference points to the new wiki.\n     */\n    private EntityReference parentReference;\n\n    private DocumentReference documentReference;\n\n    private String content;\n\n    private String meta;\n\n    private String format;\n\n    private String customClass;\n\n    private Date contentUpdateDate;\n\n    private Date updateDate;\n\n    private Date creationDate;\n\n    protected Version version;\n\n    private long id = 0;\n\n    private boolean mostRecent = true;\n\n    private boolean isNew = true;\n\n    /**\n     * The reference to the document that is the template for the current document.\n     *\n     * @todo this field is not used yet since it's not currently saved in the database.\n     */\n    private DocumentReference templateDocumentReference;\n\n    private Locale locale;\n\n    private Locale defaultLocale;\n\n    /**\n     * Indicates whether the document is 'hidden', meaning that it should not be returned in public search results.\n     * WARNING: this is a temporary hack until the new data model is designed and implemented. No code should rely on or\n     * use this property, since it will be replaced with a generic metadata.\n     */\n    private boolean hidden = false;\n\n    /**\n     * Comment on the latest modification.\n     */\n    private String comment;\n\n    /**\n     * Wiki syntax supported by this document. This is used to support different syntaxes inside the same wiki. For\n     * example a page can use the MediaWiki 1.0 syntax while another one uses the XWiki 2.1 syntax.\n     */\n    private Syntax syntax;\n\n    /**\n     * Is latest modification a minor edit.\n     */\n    private boolean isMinorEdit = false;\n\n    /**\n     * Used to make sure the MetaData String is regenerated.\n     */\n    private boolean isContentDirty = true;\n\n    /**\n     * Used to make sure the MetaData String is regenerated.\n     */\n    private boolean isMetaDataDirty = true;\n\n    private int elements = HAS_OBJECTS | HAS_ATTACHMENTS;\n\n    // Meta Data\n    private BaseClass xClass;\n\n    private String xClassXML;\n\n    /**\n     * Map holding document objects indexed by XClass references (i.e. Document References since a XClass reference\n     * points to a document). The preserve index ordering (consistent sorted order for output to XML, rendering in\n     * velocity, etc.)\n     */\n    private Map<DocumentReference, BaseObjects> xObjects = new ConcurrentSkipListMap<>();\n\n    /**\n     * The publicly exposed Map.\n     */\n    private Map<DocumentReference, List<BaseObject>> publicXObjects = new Map<DocumentReference, List<BaseObject>>()\n    {\n        @Override\n        public List<BaseObject> put(DocumentReference key, List<BaseObject> value)\n        {\n            // Makes sure to always insert BaseObjects\n            return xObjects.put(key, value instanceof BaseObjects ? (BaseObjects) value : new BaseObjects(value));\n        }\n\n        @Override\n        public void putAll(Map<? extends DocumentReference, ? extends List<BaseObject>> m)\n        {\n            m.forEach(this::put);\n        }\n\n        @Override\n        public int size()\n        {\n            return xObjects.size();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return xObjects.isEmpty();\n        }\n\n        @Override\n        public boolean containsKey(Object key)\n        {\n            return xObjects.containsKey(key);\n        }\n\n        @Override\n        public boolean containsValue(Object value)\n        {\n            return xObjects.containsValue(value);\n        }\n\n        @Override\n        public List<BaseObject> get(Object key)\n        {\n            return xObjects.get(key);\n        }\n\n        @Override\n        public List<BaseObject> remove(Object key)\n        {\n            return xObjects.remove(key);\n        }\n\n        @Override\n        public void clear()\n        {\n            xObjects.clear();            \n        }\n\n        @Override\n        public Set<DocumentReference> keySet()\n        {\n            return xObjects.keySet();\n        }\n\n        @Override\n        public Collection<List<BaseObject>> values()\n        {\n            return (Collection) xObjects.values();\n        }\n\n        @Override\n        public Set<Entry<DocumentReference, List<BaseObject>>> entrySet()\n        {\n            return (Set) xObjects.entrySet();\n        }\n    };\n\n    private final XWikiAttachmentList attachmentList = new XWikiAttachmentList(XWikiDocument.this);\n\n    // Caching\n    private boolean fromCache = false;\n\n    private List<BaseObject> xObjectsToRemove = new ArrayList<BaseObject>();\n\n    private List<XWikiAttachmentToRemove> attachmentsToRemove = new ArrayList<XWikiAttachmentToRemove>();\n\n    /**\n     * The view template (vm file) to use. When not set the default view template is used.\n     *\n     * @see com.xpn.xwiki.web.ViewAction#render(XWikiContext)\n     */\n    private String defaultTemplate;\n\n    private String validationScript;\n\n    private Object wikiNode;\n\n    /**\n     * We are using a SoftReference which will allow the archive to be discarded by the Garbage collector as long as the\n     * context is closed (usually during the request)\n     */\n    private SoftReference<XWikiDocumentArchive> archive;\n\n    private XWikiStoreInterface store;\n\n    /**\n     * @see #getOriginalDocument()\n     */\n    private XWikiDocument originalDocument;\n\n    /**\n     * Used to display the title and the content of this document. Do not inject the component here to avoid any simple\n     * new XWikiDocument to cause many useless initialization, in particular, during initialization of the stub context\n     * and other fake documents in tests.\n     */\n    private DocumentDisplayer documentDisplayer;\n\n    /**\n     * @see #getDefaultEntityReferenceSerializer()\n     */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * @see #getExplicitDocumentReferenceResolver()\n     */\n    private DocumentReferenceResolver<String> explicitDocumentReferenceResolver;\n\n    /**\n     * @see #getExplicitReferenceDocumentReferenceResolver()\n     */\n    private DocumentReferenceResolver<EntityReference> explicitReferenceDocumentReferenceResolver;\n\n    /**\n     * @see #getPageReferenceResolver()\n     */\n    private PageReferenceResolver<EntityReference> pageReferenceResolver;\n\n    /**\n     * @see #getUidStringEntityReferenceSerializer()\n     */\n    private EntityReferenceSerializer<String> uidStringEntityReferenceSerializer;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private JobProgressManager progress;\n\n    private ContextualLocalizationManager localization;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private EntityReferenceFactory entityReferenceFactory;\n\n    /**\n     * The document structure expressed as a tree of Block objects. We store it for performance reasons since parsing is\n     * a costly operation that we don't want to repeat whenever some code ask for the XDOM information.\n     */\n    private XDOM xdomCache;\n\n    /**\n     * Use to store rendered documents in #getRenderedContent(). Do not inject the component here to avoid any simple\n     * new XWikiDocument to cause many useless initialization, in particular, during initialization of the stub context\n     * and other fake documents in tests.\n     */\n    private RenderingCache renderingCache;\n\n    /**\n     * Cache the parent reference resolved as an absolute reference for improved performance (so that we don't have to\n     * resolve the relative reference every time getParentReference() is called.\n     */\n    private DocumentReference parentReferenceCache;\n\n    /**\n     * Cache the document reference with locale resolved kept for improved performance (so that we don't have to resolve\n     * it every time getPageReference() is called.\n     */\n    private DocumentReference documentReferenceWithLocaleCache;\n\n    /**\n     * Cache the page reference resolved kept for improved performance (so that we don't have to resolve it every time\n     * getPageReference() is called.\n     */\n    private PageReference pageReferenceCache;\n\n    /**\n     * Cache the page reference with locale resolved kept for improved performance (so that we don't have to resolve it\n     * every time getPageReference() is called.\n     */\n    private PageReference pageReferenceWithLocaleCache;\n\n    /**\n     * @see #getKey()\n     */\n    private String keyCache;\n\n    /**\n     * @see #getLocalKey()\n     */\n    private String localKeyCache;\n\n    private RenderingContext renderingContext;\n\n    /**\n     * @see #getAuthors()\n     */\n    private final DefaultDocumentAuthors authors = new DefaultDocumentAuthors(this);\n\n    /**\n     * Create a document for the given reference, with the {@link Locale#ROOT} even if the reference contains a locale.\n     * If you want to create a document for another locale, use {@link #XWikiDocument(DocumentReference, Locale)}.\n     * @since 2.2M1\n     */\n    public XWikiDocument(DocumentReference reference)\n    {\n        init(reference);\n    }\n\n    /**\n     * @since 6.2\n     */\n    public XWikiDocument(DocumentReference reference, Locale locale)\n    {\n        init(reference);\n\n        this.locale = locale;\n    }\n\n    /**\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument()\n    {\n        this(null);\n    }\n\n    /**\n     * Constructor that specifies the local document identifier: space name, document name. {@link #setDatabase(String)}\n     * must be called afterwards to specify the wiki name.\n     *\n     * @param space the space this document belongs to\n     * @param name the name of the document\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument(String space, String name)\n    {\n        this(null, space, name);\n    }\n\n    /**\n     * Constructor that specifies the full document identifier: wiki name, space name, document name.\n     *\n     * @param wiki The wiki this document belongs to.\n     * @param space The space this document belongs to.\n     * @param name The name of the document (can contain either the page name or the space and page name)\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument(String wiki, String space, String name)\n    {\n        // We allow to specify the space in the name (eg name = \"space.page\"). In this case the passed space is\n        // ignored.\n\n        // Build an entity reference that will serve as a current context reference against which to resolve if the\n        // passed name doesn't contain a space.\n        EntityReference contextReference = null;\n        if (!StringUtils.isEmpty(space)) {\n            contextReference = new EntityReference(space, EntityType.SPACE);\n        }\n\n        DocumentReference reference = getCurrentDocumentReferenceResolver().resolve(name, contextReference);\n\n        if (!StringUtils.isEmpty(wiki)) {\n            reference = reference.replaceParent(reference.getWikiReference(), new WikiReference(wiki));\n        }\n\n        init(reference);\n    }\n\n    /**\n     * Used to resolve a string into a proper Document Reference.\n     */\n    private DocumentReferenceResolver<String> getExplicitDocumentReferenceResolver()\n    {\n        if (this.explicitDocumentReferenceResolver == null) {\n            this.explicitDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"explicit\");\n        }\n\n        return this.explicitDocumentReferenceResolver;\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private DocumentReferenceResolver<EntityReference> getExplicitReferenceDocumentReferenceResolver()\n    {\n        if (this.explicitReferenceDocumentReferenceResolver == null) {\n            this.explicitReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"explicit\");\n        }\n\n        return this.explicitReferenceDocumentReferenceResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getPageReferenceResolver()\n    {\n        if (this.pageReferenceResolver == null) {\n            this.pageReferenceResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE);\n        }\n\n        return this.pageReferenceResolver;\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (standard form).\n     */\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    /**\n     * Used to compute document identifier.\n     */\n    private EntityReferenceSerializer<String> getUidStringEntityReferenceSerializer()\n    {\n        if (this.uidStringEntityReferenceSerializer == null) {\n            this.uidStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"uid\");\n        }\n\n        return this.uidStringEntityReferenceSerializer;\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private EntityReferenceFactory getEntityReferenceFactory()\n    {\n        if (this.entityReferenceFactory == null && Utils.getRootComponentManager() != null) {\n            try {\n                this.entityReferenceFactory = Utils.getRootComponentManager().getInstance(EntityReferenceFactory.class);\n            } catch (ComponentLookupException e) {\n                // Not a big deal\n            }\n        }\n\n        return this.entityReferenceFactory;\n    }\n\n    private <E extends EntityReference> E intern(E reference)\n    {\n        EntityReferenceFactory factory = getEntityReferenceFactory();\n\n        return factory != null ? factory.getReference(reference) : reference;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    private UserReferenceSerializer<DocumentReference> getUserReferenceDocumentReferenceSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_DOCUMENT_REFERENCE, \"document\");\n    }\n\n    private UserReferenceResolver<DocumentReference> getUserReferenceDocumentReferenceResolver()\n    {\n        return Utils.getComponent(UserReferenceResolver.TYPE_DOCUMENT_REFERENCE, \"document\");\n    }\n\n    private UserReferenceSerializer<String> getUserReferenceStringSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_STRING);\n    }\n\n    private UserReferenceResolver<String> getUserReferenceStringResolver()\n    {\n        return Utils.getComponent(UserReferenceResolver.TYPE_STRING);\n    }\n\n    private UserReferenceSerializer<String> getUserReferenceCompactWikiSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_STRING, \"compactwiki/document\");\n    }\n\n    private LinkStore getLinkStore()\n    {\n        return Utils.getComponent(LinkStore.class);        \n    }\n\n    public XWikiStoreInterface getStore(XWikiContext context)\n    {\n        return context.getWiki().getStore();\n    }\n\n    /**\n     * @deprecated use {@link XWiki#getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated(since = \"9.9RC1\")\n    public XWikiAttachmentStoreInterface getAttachmentStore(XWikiContext context)\n    {\n        return context.getWiki().getAttachmentStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore(XWikiContext context)\n    {\n        return context.getWiki().getVersioningStore();\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    /**\n     * Helper to produce and cache a local uid serialization of this document reference, including the language. Only\n     * translated document will have language appended.\n     *\n     * @return a unique name (in a wiki) (5:space4:name2:lg)\n     */\n    private String getLocalKey()\n    {\n        if (this.localKeyCache == null) {\n            this.localKeyCache =\n                LocalUidStringEntityReferenceSerializer.INSTANCE.serialize(getDocumentReferenceWithLocale());\n        }\n\n        return this.localKeyCache;\n    }\n\n    /**\n     * Helper to produce and cache a uid serialization of this document reference, including the language. Only\n     * translated document will have language appended.\n     *\n     * @return a unique name (8:wikiname5:space4:name2:lg or 8:wikiname5:space4:name)\n     * @since 4.0M1\n     */\n    public String getKey()\n    {\n        if (this.keyCache == null) {\n            this.keyCache = getUidStringEntityReferenceSerializer().serialize(getDocumentReferenceWithLocale());\n        }\n\n        return this.keyCache;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int) Util.getHash(getLocalKey());\n    }\n\n    /**\n     * @return the unique id used to represent the document, as a number. This id is technical and is equivalent to the\n     *         Document Reference + the language of the Document. This technical id should only be used for the storage\n     *         layer and all user APIs should instead use Document Reference and language as they are model-related\n     *         while the id isn't (it's purely technical).\n     */\n    public long getId()\n    {\n        // TODO: Ensure uniqueness of the generated id\n        // The implementation doesn't guarantee a unique id since it uses a hashing method which never guarantee\n        // uniqueness. However, the hash algorithm is really unlikely to collide in a given wiki. This needs to be\n        // fixed to produce a real unique id since otherwise we can have clashes in the database.\n\n        // Note: We don't use the wiki name in the document id's computation. The main historical reason is so\n        // that all things saved in a given wiki's database are always stored relative to that wiki so that\n        // changing that wiki's name is simpler.\n\n        this.id = Util.getHash(getLocalKey());\n\n        return this.id;\n    }\n\n    /**\n     * @see #getId()\n     */\n    public void setId(long id)\n    {\n        this.id = id;\n    }\n\n    /**\n     * Return the full local space reference. For example a document located in sub-space <code>space11</code> of space\n     * <code>space1</code> will return <code>space1.space11</code>.\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the local reference the space of the document as String\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getSpace()\n    {\n        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference().getLastSpaceReference());\n    }\n\n    /**\n     * Set the full local space reference.\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @see #getSpace()\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setSpace(String spaces)\n    {\n        if (spaces != null) {\n            DocumentReference reference = getDocumentReference();\n            EntityReference spaceReference = getRelativeEntityReferenceResolver().resolve(spaces, EntityType.SPACE);\n            spaceReference = spaceReference.appendParent(getDocumentReference().getWikiReference());\n            setDocumentReferenceInternal(\n                new DocumentReference(reference.getName(), new SpaceReference(spaceReference)));\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the name of the space of the document\n     * @see #getSpace()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    public String getWeb()\n    {\n        return getSpace();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated\n    public void setWeb(String space)\n    {\n        setSpace(space);\n    }\n\n    @Override\n    public String getVersion()\n    {\n        return getRCSVersion().toString();\n    }\n\n    public void setVersion(String version)\n    {\n        if (!StringUtils.isEmpty(version)) {\n            this.version = new Version(version);\n        }\n    }\n\n    public Version getRCSVersion()\n    {\n        if (this.version == null) {\n            return new Version(\"1.1\");\n        }\n        return this.version;\n    }\n\n    public void setRCSVersion(Version version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * @return the copy of this XWikiDocument instance before any modification was made to it. This copy is used for\n     *         finding out differences made to this document (useful for example to send the correct notifications to\n     *         document change listeners).\n     */\n    @Override\n    public XWikiDocument getOriginalDocument()\n    {\n        return this.originalDocument;\n    }\n\n    /**\n     * @param originalDocument the original document representing this document instance before any change was made to\n     *            it, prior to the last time it was saved\n     * @see #getOriginalDocument()\n     */\n    public void setOriginalDocument(XWikiDocument originalDocument)\n    {\n        this.originalDocument = originalDocument;\n    }\n\n    /**\n     * @return the parent reference or null if the parent is not set\n     * @since 2.2M1\n     */\n    public DocumentReference getParentReference()\n    {\n        // Ensure we always return absolute document references for the parent since we always want well-constructed\n        // references and since we store the parent reference as relative internally.\n        if (this.parentReferenceCache == null && getRelativeParentReference() != null) {\n            this.parentReferenceCache = intern(getExplicitReferenceDocumentReferenceResolver()\n                .resolve(getRelativeParentReference(), getDocumentReference()));\n        }\n\n        return this.parentReferenceCache;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the parent reference stored in the database, which is relative to this document, or an empty string (\"\")\n     *         if the parent is not set\n     * @see #getParentReference()\n     * @deprecated use {@link #getParentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getParent()\n    {\n        String parentReferenceAsString;\n        if (getParentReference() != null) {\n            parentReferenceAsString = getDefaultEntityReferenceSerializer().serialize(getRelativeParentReference());\n        } else {\n            parentReferenceAsString = \"\";\n        }\n        return parentReferenceAsString;\n    }\n\n    /**\n     * @deprecated use {@link #getParentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument getParentDoc()\n    {\n        return new XWikiDocument(getParentReference());\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setParentReference(EntityReference parentReference)\n    {\n        if (!Objects.equals(getRelativeParentReference(), parentReference)) {\n            this.parentReference = intern(parentReference);\n\n            // Clean the absolute parent reference cache to rebuild it next time getParentReference is called.\n            this.parentReferenceCache = null;\n\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @param parent the reference of the parent relative to the document\n     * @deprecated use {@link #setParentReference(EntityReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setParent(String parent)\n    {\n        // If the passed parent is an empty string we also need to set the reference to null. The reason is that\n        // in the database we store \"\" when the parent is empty and thus when Hibernate loads this class it'll call\n        // setParent with \"\" if the parent had not been set when saved.\n        if (StringUtils.isEmpty(parent)) {\n            setParentReference((EntityReference) null);\n        } else {\n            setParentReference(getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT));\n        }\n    }\n\n    @Override\n    public String getContent()\n    {\n        return this.content;\n    }\n\n    public void setContent(String content)\n    {\n        if (content == null) {\n            content = \"\";\n        }\n\n        boolean notEqual = !content.equals(this.content);\n\n        this.content = content;\n\n        if (notEqual) {\n            // invalidate parsed xdom\n            this.xdomCache = null;\n            setContentDirty(true);\n            setWikiNode(null);\n        }\n    }\n\n    public void setContent(XDOM content) throws XWikiException\n    {\n        setContent(renderXDOM(content, getSyntax()));\n    }\n\n    /**\n     * @return the default rendering cache\n     */\n    private RenderingCache getRenderingCache()\n    {\n        if (this.renderingCache == null) {\n            this.renderingCache = Utils.getComponent((Type) RenderingCache.class);\n        }\n        return this.renderingCache;\n    }\n\n    /**\n     * @return the configured document displayer\n     */\n    private DocumentDisplayer getDocumentDisplayer()\n    {\n        if (this.documentDisplayer == null) {\n            this.documentDisplayer = Utils.getComponent((Type) DocumentDisplayer.class, \"configured\");\n        }\n        return this.documentDisplayer;\n    }\n\n    private Syntax getOutputSyntax()\n    {\n        return getRenderingContext().getTargetSyntax();\n    }\n\n    /**\n     * Parse, execute and render the document.\n     * \n     * @param targetSyntax the syntax to use to render the document\n     * @param executionContextIsolated see {@link DocumentDisplayerParameters#isExecutionContextIsolated()}\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param transformationContextRestricted see\n     *            {@link DocumentDisplayerParameters#isTransformationContextRestricted()}\n     * @param translate get translated content of the document\n     * @return the result of the document execution rendered in the passed syntax\n     * @throws XWikiException when failing to display the document\n     */\n    private String display(Syntax targetSyntax, boolean executionContextIsolated, boolean transformationContextIsolated,\n        boolean transformationContextRestricted, boolean translate) throws XWikiException\n    {\n        // Note: We are currently duplicating code from getRendered signature because some calling\n        // code is expecting that the rendering will happen in the calling document's context and not in this\n        // document's context. For example this is true for the Admin page, see\n        // https://jira.xwiki.org/browse/XWIKI-4274 for more details.\n\n        getProgress().startStep(this, \"document.progress.render\", \"Render document [{}] in syntax [{}]\",\n            getDocumentReference(), targetSyntax);\n\n        try {\n            getProgress().pushLevelProgress(3, getDocumentReference());\n\n            getProgress().startStep(getDocumentReference(), \"document.progress.render.translatedcontent\",\n                \"Get translated content\");\n\n            XWikiContext xcontext = getXWikiContext();\n\n            XWikiDocument tdoc = translate ? getTranslatedDocument(xcontext) : this;\n            String translatedContent = tdoc.getContent();\n\n            getProgress().startStep(getDocumentReference(), \"document.progress.render.cache\",\n                \"Try to get content from the cache\");\n\n            String renderedContent = getRenderingCache().getRenderedContent(tdoc.getDocumentReferenceWithLocale(),\n                translatedContent, xcontext);\n\n            if (renderedContent == null) {\n                getProgress().startStep(getDocumentReference(), \"document.progress.render.execute\", \"Execute content\");\n\n                // Configure display\n                DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();\n                parameters.setExecutionContextIsolated(executionContextIsolated);\n                parameters.setTransformationContextIsolated(transformationContextIsolated);\n                parameters.setTransformationContextRestricted(transformationContextRestricted);\n                // Render the translated content (matching the current language) using this document's syntax.\n                parameters.setContentTranslated(tdoc != this);\n                parameters.setTargetSyntax(targetSyntax);\n\n                // Execute display\n                XDOM contentXDOM = getDocumentDisplayer().display(this, parameters);\n\n                // Render the result\n                renderedContent = renderXDOM(contentXDOM, targetSyntax);\n\n                getRenderingCache().setRenderedContent(getDocumentReference(), translatedContent, renderedContent,\n                    xcontext);\n            }\n\n            return renderedContent;\n        } finally {\n            getProgress().popLevelProgress(getDocumentReference());\n            getProgress().endStep(this);\n        }\n    }\n\n    public String getRenderedContent(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, context);\n    }\n\n    /**\n     * @since 8.4RC1\n     */\n    public String getRenderedContent(boolean transformationContextIsolated, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(getOutputSyntax(), transformationContextIsolated, context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.3RC1\n     */\n    public String displayDocument(XWikiContext context) throws XWikiException\n    {\n        return displayDocument(getOutputSyntax(), context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param context  the XWiki Context object\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.5RC1\n     */\n    public String displayDocument(boolean restricted, XWikiContext context) throws XWikiException\n    {\n        return displayDocument(getOutputSyntax(), restricted, context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.3RC1\n     */\n    public String displayDocument(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, false, context, false);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param context  the XWiki Context object\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.5RC1\n     */\n    public String displayDocument(Syntax targetSyntax, boolean restricted, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, restricted, context, false);\n    }\n\n    /**\n     * Execute and render the document or its translation in the current context.\n     * The code is executed with right of this document (or the translation) content author.\n     * The translations are retrieved if they exist and based on XWiki preferences\n     * (see {@link #getTranslatedDocument(XWikiContext)}).\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     */\n    public String getRenderedContent(Syntax targetSyntax, boolean transformationContextIsolated, XWikiContext context)\n        throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, transformationContextIsolated, false, context, true);\n    }\n\n    /**\n     * Execute and render the document or its translation in the current context.\n     * The code is executed with right of this document (or the translation) content author.\n     *\n     * @param targetSyntax the syntax to use to render the document\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param transformationContextRestricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki Context object\n     * @param retrieveTranslation if true retrieve the translation of the document according to the preferences (see\n     *  {@link #getTranslatedDocument(XWikiContext)}). If false, render the current document.\n     * @return the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     */\n    private String getRenderedContent(Syntax targetSyntax, boolean transformationContextIsolated,\n        boolean transformationContextRestricted, XWikiContext context, boolean retrieveTranslation)\n        throws XWikiException\n    {\n        // Make sure the context secure document is the current document so that it's executed with its own\n        // rights\n        Object currentSdoc = context.get(\"sdoc\");\n        try {\n            XWikiDocument sdoc;\n\n            if (retrieveTranslation) {\n                sdoc = getTranslatedDocument(context);\n            } else {\n                sdoc = this;\n            }\n            context.put(\"sdoc\", sdoc);\n\n            return display(targetSyntax, false, transformationContextIsolated, transformationContextRestricted,\n                retrieveTranslation);\n        } finally {\n            context.put(\"sdoc\", currentSdoc);\n        }\n    }\n\n    public String getRenderedContent(XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(getOutputSyntax(), context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 1.6M1\n     */\n    public String getRenderedContent(String text, String syntaxId, XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContent(String text, String syntaxId, boolean restrictedTransformationContext,\n        XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), restrictedTransformationContext,\n            context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 8.3\n     */\n    public String getRenderedContent(String text, String syntaxId, boolean restrictedTransformationContext,\n        XWikiDocument sDocument, XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), restrictedTransformationContext,\n            sDocument, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 2.0M3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, targetSyntaxId, false, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, targetSyntaxId, restrictedTransformationContext, null, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 8.3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiDocument sDocument, XWikiContext context)\n    {\n        try {\n            return getRenderedContent(text, Syntax.valueOf(sourceSyntaxId), Syntax.valueOf(targetSyntaxId),\n                restrictedTransformationContext, sDocument, true, context);\n        } catch (ParseException e) {\n            // Failed to render for some reason. This method should normally throw an exception but this\n            // requires changing the signature of calling methods too.\n            LOGGER.warn(\"Failed to render content [{}]\", text, e);\n        }\n\n        return \"\";\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 13.0\n     */\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, XWikiDocument sDocument, boolean isolated,\n        XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), false, sDocument, isolated, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 14.10\n     * @since 14.4.7\n     * @since 13.10.11\n     */\n    @Unstable\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, boolean restrictedTransformationContext,\n        XWikiDocument sDocument, boolean isolated, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), restrictedTransformationContext, sDocument,\n            isolated, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 13.0\n     */\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, Syntax targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiDocument sDocument, boolean isolated, XWikiContext context)\n    {\n        Map<String, Object> backup = null;\n\n        getProgress().startStep(this, \"document.progress.renderText\",\n            \"Execute content [{}] in the context of document [{}]\",\n            StringUtils.substring(text, 0, 100) + (text.length() >= 100 ? \"...\" : \"\"), getDocumentReference());\n\n        XWikiDocument currentSDocument = (XWikiDocument) context.get(CKEY_SDOC);\n        try {\n            // We have to render the given text in the context of this document. Check if this document is already\n            // on the context (same Java object reference). We don't check if the document references are equal\n            // because this document can have temporary changes that are not present on the context document even if\n            // it has the same document reference.\n            if (isolated && context.getDoc() != this) {\n                backup = new HashMap<>();\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute the document with the right of the provided sdocument's author\n            if (sDocument != null) {\n                context.put(CKEY_SDOC, sDocument);\n            }\n\n            // Reuse this document's reference so that the Velocity macro name-space is computed based on it.\n            XWikiDocument fakeDocument = new XWikiDocument(getDocumentReference());\n            fakeDocument.setSyntax(sourceSyntaxId);\n            fakeDocument.setContent(text);\n\n            // We don't let displayer take care of the context isolation because we don't want the fake document to be\n            // context document\n            return fakeDocument.display(targetSyntaxId, false, isolated, restrictedTransformationContext,\n                false);\n        } catch (Exception e) {\n            // Failed to render for some reason. This method should normally throw an exception but this\n            // requires changing the signature of calling methods too.\n            LOGGER.warn(\"Failed to render content [{}]\", text, e);\n        } finally {\n            if (backup != null) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDocument);\n\n            getProgress().endStep(this);\n        }\n\n        return \"\";\n    }\n\n    public String getEscapedContent(XWikiContext context) throws XWikiException\n    {\n        return XMLUtils.escape(getTranslatedContent(context));\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getName()\n    {\n        return getDocumentReference().getName();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setName(String name)\n    {\n        if (name != null) {\n            DocumentReference reference = getDocumentReference();\n            // TODO: ensure that other parameters are copied properly\n            setDocumentReferenceInternal(\n                new DocumentReference(name, new SpaceReference(reference.getParent()), reference.getLocale()));\n        }\n    }\n\n    @Override\n    public DocumentReference getDocumentReference()\n    {\n        return this.documentReference;\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReference()\n    {\n        if (this.pageReferenceCache == null) {\n            this.pageReferenceCache = intern(getPageReferenceResolver().resolve(getDocumentReference()));\n        }\n\n        return this.pageReferenceCache;\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference} including the {@link Locale}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReferenceWithLocale()\n    {\n        if (this.pageReferenceWithLocaleCache == null) {\n            this.pageReferenceWithLocaleCache = intern(new PageReference(getPageReference(), getLocale()));\n        }\n\n        return this.pageReferenceWithLocaleCache;\n    }\n\n    /**\n     * @return the {@link DocumentReference} of the document also containing the document {@link Locale}\n     * @since 5.3M2\n     */\n    public DocumentReference getDocumentReferenceWithLocale()\n    {\n        if (this.documentReferenceWithLocaleCache == null) {\n            this.documentReferenceWithLocaleCache = intern(new DocumentReference(this.documentReference, getLocale()));\n        }\n\n        return this.documentReferenceWithLocaleCache;\n    }\n\n    /**\n     * @return the document's space + page name (eg \"space.page\")\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getFullName()\n    {\n        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference());\n    }\n\n    /**\n     * @return the docoument's wiki + space + page name (eg \"wiki:space.page\")\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getPrefixedFullName()\n    {\n        return getDefaultEntityReferenceSerializer().serialize(getDocumentReference());\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated don't change the reference of a document once it's been constructed. Instead you can\n     *             clone the doc, rename it or copy it.\n     */\n    @Deprecated(since = \"2.2.3\")\n    public void setDocumentReference(DocumentReference reference)\n    {\n        // Don't allow setting a null reference for now, ie. don't do anything to preserve backward compatibility\n        // with previous behavior (i.e. {@link #setFullName}.\n        if (reference != null) {\n            // Retro compatibility, make sure <code>this.documentReference</code> does not contain the Locale (for now)\n            DocumentReference referenceWithoutLocale =\n                reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference;\n\n            if (!referenceWithoutLocale.equals(getDocumentReference())) {\n                setDocumentReferenceInternal(referenceWithoutLocale);\n            }\n        }\n    }\n\n    private void setDocumentReferenceInternal(DocumentReference reference)\n    {\n        this.documentReference = intern(reference);\n\n        setMetaDataDirty(true);\n\n        // Clean various caches\n\n        this.keyCache = null;\n        this.localKeyCache = null;\n        this.parentReferenceCache = null;\n        this.documentReferenceWithLocaleCache = null;\n        this.pageReferenceCache = null;\n        this.pageReferenceWithLocaleCache = null;\n    }\n\n    /**\n     * @deprecated use {@link #setDocumentReference(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setFullName(String name)\n    {\n        setFullName(name, null);\n    }\n\n    /**\n     * @deprecated use {@link #setDocumentReference(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setFullName(String fullName, XWikiContext context)\n    {\n        // We ignore the passed full name if it's null to be backward compatible with previous behaviors and to be\n        // consistent with {@link #setName} and {@link #setSpace}.\n        if (fullName != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            setDocumentReference(getCurrentMixedDocumentReferenceResolver().resolve(fullName));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getWikiName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getWikiName()\n    {\n        return getDatabase();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getSpaceName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getSpaceName()\n    {\n        return this.getSpace();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getSpaceName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getPageName()\n    {\n        return this.getName();\n    }\n\n    @Override\n    public String getTitle()\n    {\n        return (this.title != null) ? this.title : \"\";\n    }\n\n    /**\n     * Get the rendered version of the document title. The title is extracted and then Velocity is applied on it and\n     * it's then rendered using the passed Syntax. The following logic is used to extract the title:\n     * <ul>\n     * <li>If a Sheet is specified for the document and this Sheet document contains a non empty title then it's\n     * used</li>\n     * <li>If not and the document's title is specified then it's used</li>\n     * <li>If not and if the title compatibility mode is turned on ({@code xwiki.title.compatibility=1} in\n     * {@code xwiki.cfg}) then an attempt is made to extract the title from the first heading found in the document's\n     * content</li>\n     * <li>If not, then at last resort the page name is returned</li>\n     * </ul>\n     *\n     * @param outputSyntax the syntax to render to; this is not taken into account for XWiki 1.0 syntax\n     * @param context the XWiki context\n     * @return the rendered version of the document title\n     */\n    public String getRenderedTitle(Syntax outputSyntax, XWikiContext context)\n    {\n        DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();\n        parameters.setTitleDisplayed(true);\n        parameters.setExecutionContextIsolated(true);\n        parameters.setTargetSyntax(outputSyntax);\n        try {\n            XDOM titleXDOM = getDocumentDisplayer().display(this, parameters);\n            return renderXDOM(titleXDOM, outputSyntax);\n        } catch (Exception e) {\n            // We've failed to extract the Document's title or to render it. We log an error but we use the page name\n            // as the returned title in order to not generate errors in lots of places in the wiki (e.g. Activity\n            // Stream, menus, etc). The title is used in a lots of places...\n            LOGGER.error(\"Failed to render title for [{}]\", getDocumentReference(), e);\n            return getDocumentReference().getName();\n        }\n    }\n\n    /**\n     * Similar to {@link #getRenderedTitle(Syntax, XWikiContext)} but the output Syntax used is XHTML 1.0 unless the\n     * current skin defines another output Syntax in which case it's the one used.\n     *\n     * @param context the XWiki context\n     * @return the rendered version of the document title\n     */\n    public String getRenderedTitle(XWikiContext context)\n    {\n        return getRenderedTitle(getOutputSyntax(), context);\n    }\n\n    public void setTitle(String title)\n    {\n        if (title != null && !title.equals(this.title)) {\n            // Document titles usually contain velocity script, so it is not enough to set the metadata dirty, since we\n            // want to content author to be updated for programming or script rights to be updated.\n            setContentDirty(true);\n        }\n        this.title = title;\n    }\n\n    public String getFormat()\n    {\n        return this.format != null ? this.format : \"\";\n    }\n\n    public void setFormat(String format)\n    {\n        if (!format.equals(this.format)) {\n            this.format = format;\n\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @param userString the user {@link String} to convert to {@link DocumentReference}\n     * @return the user as {@link DocumentReference}\n     */\n    private DocumentReference userStringToReference(String userString)\n    {\n        DocumentReference userReference;\n\n        if (StringUtils.isEmpty(userString)) {\n            userReference = null;\n        } else {\n            userReference = getExplicitReferenceDocumentReferenceResolver().resolve(\n                getXClassEntityReferenceResolver().resolve(userString, EntityType.DOCUMENT), getDocumentReference());\n\n            if (userReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                userReference = null;\n            }\n        }\n\n        return userReference;\n    }\n\n    /**\n     * @param userReference the user {@link DocumentReference} to convert to {@link String}\n     * @return the user as String\n     */\n    private String userReferenceToString(DocumentReference userReference)\n    {\n        String userString;\n\n        if (userReference != null) {\n            userString = getCompactWikiEntityReferenceSerializer().serialize(userReference, getDocumentReference());\n        } else {\n            userString = XWikiRightService.GUEST_USER_FULLNAME;\n        }\n\n        return userString;\n    }\n\n    /**\n     * @param userReference the user {@link DocumentReference} to convert to {@link String}\n     * @return the user as String\n     */\n    private String userReferenceToString(UserReference userReference)\n    {\n        // The user API is missing the concept of relative user references ATM so we're forced to check where the users\n        // are stored in order to make sure user references stored in the database are relative.\n        // See also XWIKI-19442: APIs to generate various String references from a UserReference\n        if (\"document\".equals(getUserConfiguration().getStoreHint())) {\n            // Users are stored as documents. We want the user references that are stored in the database to be relative\n            // as much as possible (because it makes the content portable). For this we omit the wiki reference when the\n            // user (profile document) reference is from the same wiki as this document.\n            return getUserReferenceCompactWikiSerializer().serialize(userReference, getDocumentReference());\n        } else {\n            return getUserReferenceStringSerializer().serialize(userReference);\n        }\n    }\n\n    /**\n     * @param userString the user {@link String} to convert to {@link UserReference}\n     * @return the user as {@link UserReference}\n     */\n    private UserReference userStringToUserReference(String userString)\n    {\n        // The user API is missing the concept of relative user references ATM so if we want to resolve (partial) user\n        // references that were stored in the database relative to this document then we need to check where the users\n        // are stored. See also XWIKI-19442: APIs to generate various String references from a UserReference\n        if (\"document\".equals(getUserConfiguration().getStoreHint())) {\n            return getUserReferenceStringResolver().resolve(userString, getDocumentReference().getWikiReference());\n        } else {\n            return getUserReferenceStringResolver().resolve(userString);\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getEffectiveMetadataAuthor()} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getAuthorReference()\n    {\n        UserReference effectiveMetadataAuthor = getAuthors().getEffectiveMetadataAuthor();\n        if (this.getAuthors().getEffectiveMetadataAuthor() != null\n            && effectiveMetadataAuthor != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(effectiveMetadataAuthor);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setEffectiveMetadataAuthor(UserReference)}\n     * instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setAuthorReference(DocumentReference authorReference)\n    {\n        if (authorReference == null) {\n            this.authors.setEffectiveMetadataAuthor(GuestUserReference.INSTANCE);\n        } else {\n            if (authorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(authorReference);\n            this.authors.setEffectiveMetadataAuthor(user);\n            // We also set the original metadata author for backward compatibility.\n            this.authors.setOriginalMetadataAuthor(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated since 3.0M3 use {@link #getAuthorReference()} instead\n     */\n    @Deprecated\n    public String getAuthor()\n    {\n        return userReferenceToString(getAuthorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setAuthorReference} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public void setAuthor(String author)\n    {\n        setAuthorReference(userStringToReference(author));\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getContentAuthor()} instead\n     */\n    @Override\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getContentAuthorReference()\n    {\n        UserReference contentAuthor = this.getAuthors().getContentAuthor();\n        if (contentAuthor != null && contentAuthor != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(contentAuthor);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setContentAuthor(UserReference)} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setContentAuthorReference(DocumentReference contentAuthorReference)\n    {\n        if (contentAuthorReference == null) {\n            this.authors.setContentAuthor(GuestUserReference.INSTANCE);\n        } else {\n            if (contentAuthorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(contentAuthorReference);\n            this.authors.setContentAuthor(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getContentAuthorReference()} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public String getContentAuthor()\n    {\n        return userReferenceToString(getContentAuthorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setContentAuthorReference} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public void setContentAuthor(String contentAuthor)\n    {\n        setContentAuthorReference(userStringToReference(contentAuthor));\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getCreator()} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getCreatorReference()\n    {\n        UserReference creator = this.getAuthors().getCreator();\n        if (creator != null && creator != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(creator);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setCreator(UserReference)} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setCreatorReference(DocumentReference creatorReference)\n    {\n        if (creatorReference == null) {\n            this.authors.setCreator(GuestUserReference.INSTANCE);\n        } else {\n            if (creatorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(creatorReference);\n            this.authors.setCreator(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getCreatorReference()} instead\n     */\n    @Deprecated(since = \"3.0M2\")\n    public String getCreator()\n    {\n        return userReferenceToString(getCreatorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setCreatorReference} instead\n     */\n    @Deprecated(since = \"3.0M2\")\n    public void setCreator(String creator)\n    {\n        setCreatorReference(userStringToReference(creator));\n    }\n\n    @Override\n    public Date getDate()\n    {\n        if (this.updateDate == null) {\n            return new Date();\n        } else {\n            return this.updateDate;\n        }\n    }\n\n    public void setDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.updateDate))) {\n            setMetaDataDirty(true);\n        }\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.updateDate = date;\n    }\n\n    @Override\n    public Date getCreationDate()\n    {\n        if (this.creationDate == null) {\n            return new Date();\n        } else {\n            return this.creationDate;\n        }\n    }\n\n    public void setCreationDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.creationDate))) {\n            setMetaDataDirty(true);\n        }\n\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.creationDate = date;\n    }\n\n    public Date getContentUpdateDate()\n    {\n        if (this.contentUpdateDate == null) {\n            return new Date();\n        } else {\n            return this.contentUpdateDate;\n        }\n    }\n\n    public void setContentUpdateDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.contentUpdateDate))) {\n            setMetaDataDirty(true);\n        }\n\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.contentUpdateDate = date;\n    }\n\n    public String getMeta()\n    {\n        return this.meta;\n    }\n\n    public void setMeta(String meta)\n    {\n        if (meta == null) {\n            if (this.meta != null) {\n                setMetaDataDirty(true);\n            }\n        } else if (!meta.equals(this.meta)) {\n            setMetaDataDirty(true);\n        }\n        this.meta = meta;\n    }\n\n    public void appendMeta(String meta)\n    {\n        StringBuilder buf = new StringBuilder(this.meta);\n        buf.append(meta);\n        buf.append(\"\\n\");\n        this.meta = buf.toString();\n        setMetaDataDirty(true);\n    }\n\n    public boolean isContentDirty()\n    {\n        return this.isContentDirty;\n    }\n\n    /**\n     * Increment the current document version.\n     * This method will use {@link #getNextVersion(Version, boolean)} to compute the new version.\n     */\n    public void incrementVersion()\n    {\n        this.version = getNextVersion(this.version, isMinorEdit());\n    }\n\n    /**\n     * This method computes the next version and returns it, but won't change the current version.\n     * In order to change the current version, see {@link #incrementVersion()}.\n     *\n     * @param version the based version from which to compute the next one.\n     * @param minorEdit true means it's a minor edition.\n     * @return the new version computed based on the current one.\n     * @since 11.2RC1\n     */\n    public static Version getNextVersion(Version version, boolean minorEdit)\n    {\n        if (version == null) {\n            return new Version(\"1.1\");\n        }\n        if (minorEdit) {\n            return version.next();\n        } else {\n            return version.getBranchPoint().next().newBranch(1);\n        }\n    }\n\n    public void setContentDirty(boolean contentDirty)\n    {\n        this.isContentDirty = contentDirty;\n    }\n\n    public boolean isMetaDataDirty()\n    {\n        return this.isMetaDataDirty;\n    }\n\n    public void setMetaDataDirty(boolean metaDataDirty)\n    {\n        this.isMetaDataDirty = metaDataDirty;\n    }\n\n    public String getAttachmentURL(String filename, XWikiContext context)\n    {\n        return getAttachmentURL(filename, \"download\", context);\n    }\n\n    public String getAttachmentURL(String filename, String action, XWikiContext context)\n    {\n        return getAttachmentURL(filename, action, null, context);\n    }\n\n    public String getExternalAttachmentURL(String filename, String action, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createAttachmentURL(filename, getSpace(), getName(), action, null,\n            getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getAttachmentURL(String filename, String action, String querystring, XWikiContext context)\n    {\n        // Attachment file name cannot be empty\n        if (StringUtils.isEmpty(filename)) {\n            return null;\n        }\n\n        return context.getWiki().getAttachmentURL(new AttachmentReference(filename, this.getDocumentReference()),\n            action, querystring, context);\n    }\n\n    public String getAttachmentRevisionURL(String filename, String revision, XWikiContext context)\n    {\n        return getAttachmentRevisionURL(filename, revision, null, context);\n    }\n\n    public String getAttachmentRevisionURL(String filename, String revision, String querystring, XWikiContext context)\n    {\n        // Attachment file name cannot be empty\n        if (StringUtils.isEmpty(filename)) {\n            return null;\n        }\n\n        return context.getWiki().getAttachmentRevisionURL(new AttachmentReference(filename, getDocumentReference()),\n            revision, querystring, context);\n    }\n\n    /**\n     * @param action the action, see the {@code struts-config.xml} file for a list of all existing action names\n     * @param params the URL query string\n     * @param redirect true if the URL is going to be used in {@link HttpServletResponse#sendRedirect(String)}\n     * @param context the XWiki context\n     * @return the URL\n     */\n    public String getURL(String action, String params, boolean redirect, XWikiContext context)\n    {\n        URL url =\n            context.getURLFactory().createURL(getSpace(), getName(), action, params, null, getDatabase(), context);\n\n        if (redirect && isRedirectAbsolute(context)) {\n            if (url == null) {\n                return null;\n            } else {\n                return url.toString();\n            }\n        } else {\n            return context.getURLFactory().getURL(url, context);\n        }\n    }\n\n    private boolean isRedirectAbsolute(XWikiContext context)\n    {\n        return StringUtils.equals(\"1\", context.getWiki().Param(\"xwiki.redirect.absoluteurl\"));\n    }\n\n    public String getURL(String action, boolean redirect, XWikiContext context)\n    {\n        return getURL(action, null, redirect, context);\n    }\n\n    public String getURL(String action, XWikiContext context)\n    {\n        return getURL(action, false, context);\n    }\n\n    public String getURL(String action, String querystring, XWikiContext context)\n    {\n        URL url =\n            context.getURLFactory().createURL(getSpace(), getName(), action, querystring, null, getDatabase(), context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getURL(String action, String querystring, String anchor, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createURL(getSpace(), getName(), action, querystring, anchor, getDatabase(),\n            context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getExternalURL(String action, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, null, null, getDatabase(),\n            context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String action, String querystring, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, querystring, null,\n            getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getParentURL(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getParentReference());\n        URL url = context.getURLFactory().createURL(doc.getSpace(), doc.getName(), \"view\", null, null, getDatabase(),\n            context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public XWikiDocumentArchive getDocumentArchive(XWikiContext context) throws XWikiException\n    {\n        loadArchive(context);\n        return getDocumentArchive();\n    }\n\n    /**\n     * Create a new protected {@link com.xpn.xwiki.api.Document} public API to access page information and actions from\n     * scripting.\n     *\n     * @param customClassName the name of the custom {@link com.xpn.xwiki.api.Document} class of the object to create.\n     * @param context the XWiki context.\n     * @return a wrapped version of an XWikiDocument. Prefer this function instead of new Document(XWikiDocument,\n     *         XWikiContext)\n     */\n    public com.xpn.xwiki.api.Document newDocument(String customClassName, XWikiContext context)\n    {\n        if (!((customClassName == null) || (customClassName.equals(\"\")))) {\n            try {\n                return newDocument(Class.forName(customClassName), context);\n            } catch (ClassNotFoundException e) {\n                LOGGER.error(\"Failed to get java Class object from class name\", e);\n            }\n        }\n\n        return new com.xpn.xwiki.api.Document(this, context);\n    }\n\n    /**\n     * Create a new protected {@link com.xpn.xwiki.api.Document} public API to access page information and actions from\n     * scripting.\n     *\n     * @param customClass the custom {@link com.xpn.xwiki.api.Document} class the object to create.\n     * @param context the XWiki context.\n     * @return a wrapped version of an XWikiDocument. Prefer this function instead of new Document(XWikiDocument,\n     *         XWikiContext)\n     */\n    public com.xpn.xwiki.api.Document newDocument(Class<?> customClass, XWikiContext context)\n    {\n        if (customClass != null) {\n            try {\n                Class<?>[] classes = new Class[] { XWikiDocument.class, XWikiContext.class };\n                Object[] args = new Object[] { this, context };\n\n                return (com.xpn.xwiki.api.Document) customClass.getConstructor(classes).newInstance(args);\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to create a custom Document object\", e);\n            }\n        }\n\n        return new com.xpn.xwiki.api.Document(this, context);\n    }\n\n    public com.xpn.xwiki.api.Document newDocument(XWikiContext context)\n    {\n        String customClass = getCustomClass();\n        return newDocument(customClass, context);\n    }\n\n    public void loadArchive(XWikiContext context) throws XWikiException\n    {\n        if ((this.archive == null || this.archive.get() == null)) {\n            XWikiDocumentArchive arch;\n            // A document not comming from the database cannot have an archive stored in the database\n            if (this.isNew()) {\n                arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n            } else {\n                arch = getVersioningStore(context).getXWikiDocumentArchive(this, context);\n            }\n            // We are using a SoftReference which will allow the archive to be\n            // discarded by the Garbage collector as long as the context is closed (usually during\n            // the request)\n            this.archive = new SoftReference<>(arch);\n        }\n    }\n\n    /**\n     * @return the {@link XWikiDocumentArchive} for this document. If it is not stored in the document, null is\n     *         returned.\n     */\n    public XWikiDocumentArchive getDocumentArchive()\n    {\n        // If there is a soft reference, return it.\n        if (this.archive != null) {\n            return this.archive.get();\n        }\n        // Some APIs are expecting the archive to be null for loading it\n        // (e.g. VersioningStore#loadXWikiDocumentArchive), so it's better to keep it null than to return an\n        // empty archive which would never be populated.\n        return null;\n    }\n\n    /**\n     * @return the {@link XWikiDocumentArchive} for this document. If it is not stored in the document, we get it using\n     *         the current context. If there is an exception, null is returned.\n     */\n    public XWikiDocumentArchive loadDocumentArchive()\n    {\n        XWikiDocumentArchive arch = getDocumentArchive();\n        if (arch != null) {\n            return arch;\n        }\n\n        // A document not comming from the database cannot have an archive stored in the database\n        if (this.isNew()) {\n            arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n            setDocumentArchive(arch);\n            return arch;\n        }\n\n        XWikiContext xcontext = getXWikiContext();\n\n        try {\n            arch = getVersioningStore(xcontext).getXWikiDocumentArchive(this, xcontext);\n\n            // Put a copy of the archive in the soft reference for later use if needed.\n            setDocumentArchive(arch);\n\n            return arch;\n        } catch (Exception e) {\n            // VersioningStore.getXWikiDocumentArchive may throw an XWikiException, and xcontext or VersioningStore\n            // may be null (tests)\n            // To maintain the behavior of this method we can't throw an exception.\n            // Formerly, null was returned if there was no SoftReference.\n            LOGGER.warn(\"Could not get document archive\", e);\n            return null;\n        }\n    }\n\n    public void setDocumentArchive(XWikiDocumentArchive arch)\n    {\n        // We are using a SoftReference which will allow the archive to be\n        // discarded by the Garbage collector as long as the context is closed (usually during the\n        // request)\n        if (arch != null) {\n            this.archive = new SoftReference<XWikiDocumentArchive>(arch);\n        } else {\n            // Some APIs are expecting the archive to be null for loading it\n            // (e.g. VersioningStore#loadXWikiDocumentArchive), so we allow setting it back to null.\n            this.archive = null;\n        }\n    }\n\n    public void setDocumentArchive(String sarch) throws XWikiException\n    {\n        XWikiDocumentArchive xda = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n        xda.setArchive(sarch);\n        setDocumentArchive(xda);\n    }\n\n    public Version[] getRevisions(XWikiContext context) throws XWikiException\n    {\n        return getVersioningStore(context).getXWikiDocVersions(this, context);\n    }\n\n    public String[] getRecentRevisions(int nb, XWikiContext context) throws XWikiException\n    {\n        try {\n            Version[] revisions = getVersioningStore(context).getXWikiDocVersions(this, context);\n            int length = nb;\n            // 0 means all revisions\n            if (nb == 0) {\n                length = revisions.length;\n            }\n\n            if (revisions.length < length) {\n                length = revisions.length;\n            }\n\n            String[] recentrevs = new String[length];\n            for (int i = 1; i <= length; i++) {\n                recentrevs[i - 1] = revisions[revisions.length - i].toString();\n            }\n            return recentrevs;\n        } catch (Exception e) {\n            return new String[0];\n        }\n    }\n\n    /**\n     * Get document versions matching criterias like author, minimum creation date, etc.\n     *\n     * @param criteria criteria used to match versions\n     * @return a list of matching versions\n     */\n    public List<String> getRevisions(RevisionCriteria criteria, XWikiContext context) throws XWikiException\n    {\n        List<String> results = new ArrayList<String>();\n\n        Version[] revisions = getRevisions(context);\n\n        XWikiRCSNodeInfo nextNodeinfo = null;\n        XWikiRCSNodeInfo nodeinfo;\n        for (Version revision : revisions) {\n            nodeinfo = nextNodeinfo;\n            nextNodeinfo = getRevisionInfo(revision.toString(), context);\n\n            if (nodeinfo == null) {\n                continue;\n            }\n\n            // Minor/Major version matching\n            if (criteria.getIncludeMinorVersions() || !nextNodeinfo.isMinorEdit()) {\n                // Author matching\n                if (criteria.getAuthor().equals(\"\") || criteria.getAuthor().equals(nodeinfo.getAuthor())) {\n                    // Date range matching\n                    Date versionDate = nodeinfo.getDate();\n                    if (versionDate.after(criteria.getMinDate()) && versionDate.before(criteria.getMaxDate())) {\n                        results.add(nodeinfo.getVersion().toString());\n                    }\n                }\n            }\n        }\n\n        nodeinfo = nextNodeinfo;\n        if (nodeinfo != null) {\n            if (criteria.getAuthor().equals(\"\") || criteria.getAuthor().equals(nodeinfo.getAuthor())) {\n                // Date range matching\n                Date versionDate = nodeinfo.getDate();\n                if (versionDate.after(criteria.getMinDate()) && versionDate.before(criteria.getMaxDate())) {\n                    results.add(nodeinfo.getVersion().toString());\n                }\n            }\n        }\n\n        return criteria.getRange().subList(results);\n    }\n\n    public XWikiRCSNodeInfo getRevisionInfo(String version, XWikiContext context) throws XWikiException\n    {\n        return getDocumentArchive(context).getNode(new Version(version));\n    }\n\n    /**\n     * @return Is this version the most recent one. False if and only if there are newer versions of this document in\n     *         the database.\n     */\n    public boolean isMostRecent()\n    {\n        return this.mostRecent;\n    }\n\n    /**\n     * must not be used unless in store system.\n     *\n     * @param mostRecent - mark document as most recent.\n     */\n    public void setMostRecent(boolean mostRecent)\n    {\n        this.mostRecent = mostRecent;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseClass getXClass()\n    {\n        if (this.xClass == null) {\n            BaseClass emptyClass = new BaseClass();\n            // Make sure not to cause any false document versions if this document is saved.\n            emptyClass.setDirty(false);\n\n            this.setXClass(emptyClass);\n        }\n        return this.xClass;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXClass(BaseClass xwikiClass)\n    {\n        xwikiClass.setOwnerDocument(this);\n\n        this.xClass = xwikiClass;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public Map<DocumentReference, List<BaseObject>> getXObjects()\n    {\n        return (Map) this.publicXObjects;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjects(Map<DocumentReference, List<BaseObject>> objects)\n    {\n        if (objects == null) {\n            // Make sure we don`t set a null objects map since we assume everywhere that it is not null when using it.\n            objects = new HashMap<>();\n        }\n\n        boolean isDirty = false;\n\n        for (List<BaseObject> objList : objects.values()) {\n            for (BaseObject obj : objList) {\n                obj.setOwnerDocument(this);\n                isDirty = true;\n            }\n        }\n\n        // This operation resulted in marking the current document dirty.\n        if (isDirty) {\n            setMetaDataDirty(true);\n        }\n\n        // Replace the current objects with the provided ones.\n        Map<DocumentReference, BaseObjects> objectsCopy = new ConcurrentSkipListMap<>();\n        objects.forEach((k, v) -> objectsCopy.put(k, new BaseObjects(v)));\n        this.xObjects = objectsCopy;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject()\n    {\n        return getXObject(getDocumentReference());\n    }\n\n    /**\n     * @deprecated use {@link #getXObject()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getxWikiObject()\n    {\n        return getXObject(getDocumentReference());\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public List<BaseClass> getXClasses(XWikiContext context)\n    {\n        List<BaseClass> list = new ArrayList<BaseClass>();\n\n        // getXObjects() is a TreeMap, with elements sorted by className reference\n        for (DocumentReference classReference : getXObjects().keySet()) {\n            BaseClass bclass = null;\n            List<BaseObject> objects = getXObjects(classReference);\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    bclass = obj.getXClass(context);\n                    if (bclass != null) {\n                        break;\n                    }\n                }\n            }\n            if (bclass != null) {\n                list.add(bclass);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Create and add a new object to the document with the provided class.\n     * <p>\n     * Note that absolute reference are not supported for xclasses which mean that the wiki part (whatever the wiki is)\n     * of the reference will be systematically removed.\n     *\n     * @param classReference the reference of the class\n     * @param context the XWiki context\n     * @return the index of teh newly created object\n     * @throws XWikiException error when creating the new object\n     * @since 2.2.3\n     */\n    public int createXObject(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        BaseObject object = BaseClass.newCustomClassInstance(absoluteClassReference, context);\n        object.setOwnerDocument(this);\n        object.setXClassReference(classReference);\n        BaseObjects objects = this.xObjects.get(absoluteClassReference);\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(absoluteClassReference, objects);\n        }\n        objects.add(object);\n        int nb = objects.size() - 1;\n        object.setNumber(nb);\n        setMetaDataDirty(true);\n        return nb;\n    }\n\n    /**\n     * @deprecated use {@link #createXObject(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public int createNewObject(String className, XWikiContext context) throws XWikiException\n    {\n        return createXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public int getXObjectSize(DocumentReference classReference)\n    {\n        try {\n            return getXObjects().get(classReference).size();\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n\n    /**\n     * @since 7.3M1\n     * @since 7.2.1\n     * @since 7.1.3\n     * @since 6.4.6\n     */\n    public int getXObjectSize(EntityReference classReference)\n    {\n        return getXObjectSize(resolveClassReference(classReference));\n    }\n\n    /**\n     * @deprecated use {@link #getXObjectSize(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public int getObjectNumbers(String className)\n    {\n        return getXObjectSize(resolveClassReference(className));\n    }\n\n    /**\n     * Retrieve and returns all objects corresponding to the given class reference, or an empty list if there's none.\n     * Be aware that some elements of this list might be null since all objects are in the list at their real index.\n     *\n     * @param classReference the reference of the xclass for which to retrieve the xobjects\n     * @return a list of xobjects and null elements (for deleted xobjects) corresponding to the given xclass\n     *          or an empty list.\n     * @since 2.2M1\n     */\n    public List<BaseObject> getXObjects(DocumentReference classReference)\n    {\n        List<BaseObject> xobjects = null;\n\n        if (classReference != null) {\n            xobjects = getXObjects().get(classReference);\n        }\n\n        return xobjects != null ? xobjects : Collections.emptyList();\n    }\n\n    /**\n     * Retrieve and returns all objects corresponding to the class reference corresponding to the resolution of the\n     * given entity reference, or an empty list if there's none.\n     * Be aware that some elements of this list might be null since all objects are in the list at their real index.\n     *\n     * @param reference the reference that is resolved to an xclass for retrieving the corresponding xobjects\n     * @return a list of xobjects and null elements (for deleted xobjects) corresponding to the given xclass\n     *           or an empty list.\n     * @since 3.3M1\n     */\n    public List<BaseObject> getXObjects(EntityReference reference)\n    {\n        if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObjects(\n                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * @deprecated use {@link #getXObjects(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public Vector<BaseObject> getObjects(String className)\n    {\n        List<BaseObject> result = this.xObjects.get(resolveClassReference(className));\n        return result == null ? null : new Vector<BaseObject>(result);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjects(DocumentReference classReference, List<BaseObject> objects)\n    {\n        // Remove existing objects\n        List<BaseObject> existingbjects = this.xObjects.get(classReference);\n        if (existingbjects != null) {\n            existingbjects.clear();\n        }\n\n        for (BaseObject obj : objects) {\n            obj.setOwnerDocument(this);\n        }\n\n        // Add new objects\n        this.xObjects.put(classReference, new BaseObjects(objects));\n\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @since 3.3M1\n     */\n    public BaseObject getXObject(EntityReference reference)\n    {\n        if (reference instanceof DocumentReference) {\n            return getXObject((DocumentReference) reference);\n        } else if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObject(\n                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n        } else if (reference.getType() == EntityType.OBJECT) {\n            // object reference\n            return getXObject(getCurrentReferenceObjectReferenceResolver().resolve(reference, getDocumentReference()));\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference)\n    {\n        BaseObject result = null;\n        List<BaseObject> objects = getXObjects().get(classReference);\n        if (objects != null) {\n            for (BaseObject object : objects) {\n                if (object != null) {\n                    result = object;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get an object of this document based on its reference.\n     *\n     * @param objectReference the reference of the object\n     * @return the XWiki object\n     * @since 3.2M1\n     */\n    public BaseObject getXObject(ObjectReference objectReference)\n    {\n        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);\n\n        // If the baseObjectReference has an object number, we return the object with this number,\n        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber\n        return baseObjectReference.getObjectNumber() == null ? this.getXObject(baseObjectReference.getXClassReference())\n            : getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber());\n    }\n\n    /**\n     * Get or create an object of this document based on its reference.\n     *\n     * @param objectReference The reference of the object.\n     * @param create If the object shall be created if missing.\n     * @param context The XWiki context for creating the object.\n     * @return The found or created objected.\n     * @throws XWikiException If object creation failed.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public BaseObject getXObject(ObjectReference objectReference, boolean create, XWikiContext context)\n        throws XWikiException\n    {\n        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);\n\n        // If the baseObjectReference has an object number, we return the object with this number,\n        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber\n        if (baseObjectReference.getObjectNumber() == null) {\n            return getXObject(baseObjectReference.getXClassReference(), create, context);\n        } else {\n            return getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber(), create,\n                context);\n        }\n    }\n\n    /**\n     * Convert the given {@link ObjectReference} into a {@link BaseObjectReference}.\n     */\n    private BaseObjectReference getBaseObjectReference(ObjectReference objectReference)\n    {\n        if (objectReference instanceof BaseObjectReference) {\n            return (BaseObjectReference) objectReference;\n        } else {\n            return new BaseObjectReference(objectReference);\n        }\n    }\n\n    /**\n     * Get an object property of this document based on its reference.\n     *\n     * @param objectPropertyReference the reference of the object property\n     * @return the object property\n     * @since 3.2M3\n     */\n    public BaseProperty<ObjectPropertyReference> getXObjectProperty(ObjectPropertyReference objectPropertyReference)\n    {\n        BaseObject object = getXObject((ObjectReference) objectPropertyReference.getParent());\n\n        if (object != null) {\n            return (BaseProperty<ObjectPropertyReference>) object.getField(objectPropertyReference.getName());\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className)\n    {\n        return getXObject(resolveClassReference(className));\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, int nb)\n    {\n        List<BaseObject> objects = getXObjects().get(classReference);\n\n        if (objects != null && objects.size() > nb) {\n            return objects.get(nb);\n        }\n\n        return null;\n    }\n\n    /**\n     * Get an xobject with the passed xclass at the passed location.\n     * <p>\n     * If <code>create</code> is true and the is no xobject at the passed located, it's created.\n     *\n     * @param classReference the xlcass of the object to retrieve\n     * @param number the location of the xobject\n     * @param create if true the xobject is created when it does not exist\n     * @param xcontext the XWiki context\n     * @return a {@link BaseObject} stored at passed location\n     * @throws XWikiException when failing to create new xobject instance\n     * @since 7.3M1\n     * @since 7.2.1\n     * @since 7.1.3\n     * @since 6.4.6\n     */\n    public BaseObject getXObject(EntityReference classReference, int number, boolean create, XWikiContext xcontext)\n        throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n\n        BaseObject xobject = getXObject(absoluteClassReference, number);\n\n        if (xobject == null && create) {\n            xobject = BaseClass.newCustomClassInstance(absoluteClassReference, xcontext);\n\n            setXObject(number, xobject);\n        }\n\n        return xobject;\n    }\n\n    /**\n     * @since 4.1M1\n     */\n    public BaseObject getXObject(EntityReference classReference, int nb)\n    {\n        return getXObject(\n            getCurrentReferenceDocumentReferenceResolver().resolve(classReference, getDocumentReference()), nb);\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, int)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, int nb)\n    {\n        return getXObject(resolveClassReference(className), nb);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, String key, String value)\n    {\n        return getXObject(classReference, key, value, false);\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, String key, String value)\n    {\n        return getObject(className, key, value, false);\n    }\n\n    /**\n     * @return 6.3M1\n     */\n    public BaseObject getXObject(EntityReference reference, String key, String value, boolean failover)\n    {\n        if (reference instanceof DocumentReference) {\n            return getXObject((DocumentReference) reference, key, value, failover);\n        } else if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObject(getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()),\n                key, value, failover);\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, String key, String value, boolean failover)\n    {\n        try {\n            if (value == null) {\n                if (failover) {\n                    return getXObject(classReference);\n                } else {\n                    return null;\n                }\n            }\n\n            List<BaseObject> objects = getXObjects().get(classReference);\n            if ((objects == null) || (objects.size() == 0)) {\n                return null;\n            }\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    if (value.equals(obj.getStringValue(key))) {\n                        return obj;\n                    }\n                }\n            }\n\n            if (failover) {\n                return getXObject(classReference);\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            if (failover) {\n                return getXObject(classReference);\n            }\n\n            LOGGER.warn(\"Exception while accessing objects for document [{}]: {}\", getDocumentReference(),\n                e.getMessage(), e);\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, String, String, boolean)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, String key, String value, boolean failover)\n    {\n        return getXObject(resolveClassReference(className), key, value, failover);\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated use {@link #addXObject(BaseObject)} instead\n     */\n    @Deprecated\n    public void addXObject(DocumentReference classReference, BaseObject object)\n    {\n        List<BaseObject> vobj = this.xObjects.get(classReference);\n        if (vobj == null) {\n            setXObject(classReference, 0, object);\n        } else {\n            setXObject(classReference, vobj.size(), object);\n        }\n    }\n\n    /**\n     * Add the object to the document.\n     *\n     * @param object the xobject to add\n     * @throws NullPointerException if the specified object is null because we need the get the class reference from the\n     *             object\n     * @since 2.2.3\n     */\n    public void addXObject(BaseObject object)\n    {\n        object.setOwnerDocument(this);\n\n        List<BaseObject> vobj = this.xObjects.get(object.getXClassReference());\n        if (vobj == null) {\n            setXObject(0, object);\n        } else {\n            setXObject(vobj.size(), object);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #addXObject(BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void addObject(String className, BaseObject object)\n    {\n        addXObject(resolveClassReference(className), object);\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated use {@link #setXObject(int, BaseObject)} instead\n     */\n    @Deprecated\n    public void setXObject(DocumentReference classReference, int nb, BaseObject object)\n    {\n        if (object != null) {\n            object.setOwnerDocument(this);\n            object.setNumber(nb);\n        }\n\n        BaseObjects objects = this.xObjects.get(classReference);\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(classReference, objects);\n        }\n        while (nb >= objects.size()) {\n            objects.add(null);\n        }\n        objects.set(nb, object);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * Replaces the object at the specified position and for the specified object's xclass.\n     *\n     * @param nb index of the element to replace\n     * @param object the xobject to insert\n     * @throws NullPointerException if the specified object is null because we need the get the class reference from the\n     *             object\n     * @since 2.2.3\n     */\n    public void setXObject(int nb, BaseObject object)\n    {\n        object.setOwnerDocument(this);\n        object.setNumber(nb);\n\n        BaseObjects objects = this.xObjects.get(object.getXClassReference());\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(object.getXClassReference(), objects);\n        }\n        while (nb >= objects.size()) {\n            objects.add(null);\n        }\n        objects.set(nb, object);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @deprecated use {@link #setXObject(DocumentReference, int, BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setObject(String className, int nb, BaseObject object)\n    {\n        setXObject(resolveClassReference(className), nb, object);\n    }\n\n    /**\n     * @return true if the document is a new one (i.e. it has never been saved) or false otherwise\n     */\n    public boolean isNew()\n    {\n        return this.isNew;\n    }\n\n    public void setNew(boolean aNew)\n    {\n        this.isNew = aNew;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void mergeXClass(XWikiDocument templatedoc)\n    {\n        BaseClass bclass = getXClass();\n        BaseClass tbclass = templatedoc.getXClass();\n        if (tbclass != null) {\n            if (bclass == null) {\n                setXClass(tbclass.clone());\n            } else {\n                getXClass().merge(tbclass.clone());\n            }\n        }\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @deprecated use {@link #mergeXClass(XWikiDocument)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void mergexWikiClass(XWikiDocument templatedoc)\n    {\n        mergeXClass(templatedoc);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void mergeXObjects(XWikiDocument templateDoc)\n    {\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : templateDoc.getXObjects().entrySet()) {\n            // Documents can't have objects of types defined in a different wiki so we make sure the class reference\n            // matches this document's wiki.\n            DocumentReference classReference = entry.getKey().replaceParent(entry.getKey().getWikiReference(),\n                getDocumentReference().getWikiReference());\n            // Copy the objects from the template document only if this document doesn't have them already.\n            //\n            // Note: this might be a bit misleading since it will not add objects from the template if some objects of\n            // that class already exist in the current document.\n            if (getXObjectSize(classReference) == 0) {\n                for (BaseObject object : entry.getValue()) {\n                    if (object != null) {\n                        addXObject(object.duplicate());\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #mergeXObjects(XWikiDocument)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void mergexWikiObjects(XWikiDocument templatedoc)\n    {\n        mergeXObjects(templatedoc);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void cloneXObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc, true);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void duplicateXObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc, false);\n    }\n\n    /**\n     * Copy specified document objects into current document.\n     *\n     * @param templatedoc the document to copy\n     * @param keepsIdentity if true it does an exact java copy, otherwise it duplicate objects with the new document\n     *            name (and new class names)\n     */\n    private void cloneXObjects(XWikiDocument templatedoc, boolean keepsIdentity)\n    {\n        // clean map\n        this.xObjects.clear();\n\n        // fill map\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : templatedoc.getXObjects().entrySet()) {\n            List<BaseObject> tobjects = entry.getValue();\n\n            // clone and insert xobjects\n            for (BaseObject otherObject : tobjects) {\n                if (otherObject != null) {\n                    if (keepsIdentity) {\n                        addXObject(otherObject.clone());\n                    } else {\n                        BaseObject newObject = otherObject.duplicate(getDocumentReference());\n                        setXObject(newObject.getNumber(), newObject);\n                    }\n                } else if (keepsIdentity) {\n                    // set null object to make sure to have exactly the same thing when cloning a document\n                    addXObject(entry.getKey(), null);\n                }\n            }\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public DocumentReference getTemplateDocumentReference()\n    {\n        return this.templateDocumentReference;\n    }\n\n    /**\n     * @deprecated use {@link #getTemplateDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getTemplate()\n    {\n        String templateReferenceAsString;\n        DocumentReference templateDocumentReference = getTemplateDocumentReference();\n        if (templateDocumentReference != null) {\n            templateReferenceAsString = LOCAL_REFERENCE_SERIALIZER.serialize(templateDocumentReference);\n        } else {\n            templateReferenceAsString = \"\";\n        }\n        return templateReferenceAsString;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setTemplateDocumentReference(DocumentReference templateDocumentReference)\n    {\n        if (!Objects.equals(getTemplateDocumentReference(), templateDocumentReference)) {\n            this.templateDocumentReference = templateDocumentReference;\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #setTemplateDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setTemplate(String template)\n    {\n        DocumentReference templateReference = null;\n        if (!StringUtils.isEmpty(template)) {\n            templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n        }\n        setTemplateDocumentReference(templateReference);\n    }\n\n    public String displayPrettyName(String fieldname, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, false, true, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, showMandatory, true, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            return displayPrettyName(fieldname, showMandatory, before, object, context);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayPrettyName(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, false, true, obj, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, BaseObject obj, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, showMandatory, true, obj, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, BaseObject obj,\n        XWikiContext context)\n    {\n        try {\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String dprettyName = \"\";\n            if (showMandatory) {\n                dprettyName = context.getWiki().addMandatory(context);\n            }\n            if (before) {\n                return dprettyName + pclass.getPrettyName(context);\n            } else {\n                return pclass.getPrettyName(context) + dprettyName;\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayTooltip(String fieldname, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            return displayTooltip(fieldname, object, context);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayTooltip(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String tooltip = pclass.getTooltip(context);\n            if ((tooltip != null) && (!tooltip.trim().equals(\"\"))) {\n                String img = \"<img src=\\\"\" + context.getWiki().getSkinFile(\"info.gif\", context)\n                    + \"\\\" class=\\\"tooltip_image\\\" align=\\\"middle\\\" />\";\n                result = context.getWiki().addTooltip(img, tooltip, context);\n            }\n        } catch (Exception e) {\n\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n\n            result = display(fieldname, object, context);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to display field [\" + fieldname + \"] of document [\"\n                + getDefaultEntityReferenceSerializer().serialize(getDocumentReference()) + \"]\", e);\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        String type = null;\n        try {\n            type = (String) context.get(\"display\");\n        } catch (Exception e) {\n        }\n\n        if (type == null) {\n            type = \"view\";\n        }\n\n        return display(fieldname, type, obj, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param mode the mode to use (\"view\", \"edit\", ...)\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String mode, XWikiContext context)\n    {\n        return display(fieldname, mode, \"\", context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, BaseObject obj, XWikiContext context)\n    {\n        return display(fieldname, type, obj, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     * @since 13.0\n     */\n    public String display(String fieldname, String type, BaseObject obj, boolean isolated, XWikiContext context)\n    {\n        return display(fieldname, type, \"\", obj, isolated, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param mode the mode to use (\"view\", \"edit\", ...)\n     * @param prefix the prefix to add in the field identifier in edit display for example\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String mode, String prefix, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            if (object == null) {\n                return \"\";\n            } else {\n                return display(fieldname, mode, prefix, object, context);\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, BaseObject obj, String wrappingSyntaxId, XWikiContext context)\n    {\n        return display(fieldname, type, \"\", obj, wrappingSyntaxId, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     * @since 13.0\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, boolean isolated,\n        XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj,\n            context.getWiki().getCurrentContentSyntaxId(getSyntaxId(), context), isolated, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj, wrappingSyntaxId, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument )context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String prefix = pref + LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference())\n                + \"_\" + obj.getNumber() + \"_\";\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html or { which could be part of an XWiki\n            // macro syntax since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId)\n                && (HTMLUtils.containsElementText(result) || result.indexOf(\"{\") != -1))\n            {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                // Escape closing HTML macro syntax.\n                int startIndex = 0;\n                // Start searching at the last match to avoid scanning the whole string again.\n                while ((startIndex = result.indexOf(CLOSE_HTML_MACRO, startIndex)) != -1) {\n                    result.replace(startIndex, startIndex + 2, \"&#123;&#123;\");\n                }\n                result.append(CLOSE_HTML_MACRO);\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, String header, String format, XWikiContext context)\n    {\n        return displayForm(classReference, header, format, true, context);\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, String, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, String header, String format, XWikiContext context)\n    {\n        return displayForm(className, header, format, true, context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, String header, String format, boolean linebreak,\n        XWikiContext context)\n    {\n        List<BaseObject> objects = getXObjects(classReference);\n        if (format.endsWith(\"\\\\n\")) {\n            linebreak = true;\n        }\n\n        BaseObject firstobject = null;\n        Iterator<BaseObject> foit = objects.iterator();\n        while ((firstobject == null) && foit.hasNext()) {\n            firstobject = foit.next();\n        }\n\n        if (firstobject == null) {\n            return \"\";\n        }\n\n        BaseClass bclass = firstobject.getXClass(context);\n        if (bclass.getPropertyList().size() == 0) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        VelocityContext vcontext;\n        try {\n            vcontext = getVelocityContextFactory().createContext();\n        } catch (XWikiVelocityException e) {\n            LOGGER.error(\"Failed to create a standard VelocityContext\", e);\n\n            vcontext = new XWikiVelocityContext();\n        }\n\n        for (String propertyName : bclass.getPropertyList()) {\n            PropertyClass pclass = (PropertyClass) bclass.getField(propertyName);\n            vcontext.put(pclass.getName(), pclass.getPrettyName());\n        }\n        result.append(evaluate(header, context.getDoc().getPrefixedFullName(), vcontext, context));\n        if (linebreak) {\n            result.append(\"\\n\");\n        }\n\n        // display each line\n        for (int i = 0; i < objects.size(); i++) {\n            vcontext.put(\"id\", Integer.valueOf(i + 1));\n            BaseObject object = objects.get(i);\n            if (object != null) {\n                for (String name : bclass.getPropertyList()) {\n                    vcontext.put(name, display(name, object, context));\n                }\n                result.append(evaluate(format, context.getDoc().getPrefixedFullName(), vcontext, context));\n                if (linebreak) {\n                    result.append(\"\\n\");\n                }\n            }\n        }\n        return result.toString();\n    }\n\n    private String evaluate(String content, String name, VelocityContext vcontext, XWikiContext context)\n    {\n        StringWriter writer = new StringWriter();\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            velocityManager.getVelocityEngine().evaluate(vcontext, writer, name, content);\n            return writer.toString();\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}]\", name, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, String, String, boolean, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, String header, String format, boolean linebreak, XWikiContext context)\n    {\n        return displayForm(resolveClassReference(className), header, format, linebreak, context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, XWikiContext context)\n    {\n        List<BaseObject> objects = getXObjects(classReference);\n        if (objects == null) {\n            return \"\";\n        }\n\n        BaseObject firstobject = null;\n        Iterator<BaseObject> foit = objects.iterator();\n        while ((firstobject == null) && foit.hasNext()) {\n            firstobject = foit.next();\n        }\n\n        if (firstobject == null) {\n            return \"\";\n        }\n\n        BaseClass bclass = firstobject.getXClass(context);\n        if (bclass.getPropertyList().size() == 0) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        result.append(\"{table}\\n\");\n        boolean first = true;\n        for (String propertyName : bclass.getPropertyList()) {\n            if (first == true) {\n                first = false;\n            } else {\n                result.append(\"|\");\n            }\n            PropertyClass pclass = (PropertyClass) bclass.getField(propertyName);\n            result.append(pclass.getPrettyName());\n        }\n        result.append(\"\\n\");\n        for (int i = 0; i < objects.size(); i++) {\n            BaseObject object = objects.get(i);\n            if (object != null) {\n                first = true;\n                for (String propertyName : bclass.getPropertyList()) {\n                    if (first == true) {\n                        first = false;\n                    } else {\n                        result.append(\"|\");\n                    }\n                    String data = display(propertyName, object, context);\n                    data = data.trim();\n                    data = data.replaceAll(\"\\n\", \" \");\n                    if (data.length() == 0) {\n                        result.append(\"&nbsp;\");\n                    } else {\n                        result.append(data);\n                    }\n                }\n                result.append(\"\\n\");\n            }\n        }\n        result.append(\"{table}\\n\");\n        return result.toString();\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, XWikiContext context)\n    {\n        return displayForm(resolveClassReference(className), context);\n    }\n\n    public boolean isFromCache()\n    {\n        return this.fromCache;\n    }\n\n    public void setFromCache(boolean fromCache)\n    {\n        this.fromCache = fromCache;\n    }\n\n    public void readDocMetaFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String defaultLanguage = eform.getDefaultLanguage();\n        if (defaultLanguage != null) {\n            setDefaultLanguage(defaultLanguage);\n        }\n\n        String defaultTemplate = eform.getDefaultTemplate();\n        if (defaultTemplate != null) {\n            setDefaultTemplate(defaultTemplate);\n        }\n\n        String creator = eform.getCreator();\n        if ((creator != null) && (!creator.equals(getCreator()))) {\n            if ((getCreatorReference().equals(context.getUserReference()))\n                || (context.getWiki().getRightService().hasAdminRights(context))) {\n                setCreator(creator);\n            }\n        }\n\n        String parent = eform.getParent();\n        if (parent != null) {\n            setParent(parent);\n        }\n\n        // Read the comment from the form\n        String comment = eform.getComment();\n        if (comment != null) {\n            setComment(comment);\n        }\n\n        // Read the minor edit checkbox from the form\n        setMinorEdit(eform.isMinorEdit());\n\n        String tags = eform.getTags();\n        if (!StringUtils.isEmpty(tags)) {\n            setTags(tags, context);\n        }\n\n        // Set the Syntax id if defined\n        String syntaxId = eform.getSyntaxId();\n        if (syntaxId != null) {\n            setSyntax(resolveSyntax(syntaxId));\n        }\n\n        // Read the hidden checkbox from the form\n        if (eform.getHidden() != null) {\n            setHidden(\"1\".equals(eform.getHidden()));\n        }\n    }\n\n    private Syntax resolveSyntax(String syntaxId)\n    {\n        Syntax syntax;\n        try {\n            syntax = getSyntaxRegistry().resolveSyntax(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntax();\n            LOGGER.warn(\"Failed to set syntax [{}] for [{}], setting syntax [{}] instead.\", syntaxId,\n                getDefaultEntityReferenceSerializer().serialize(getDocumentReference()), syntax.toIdString(), e);\n        }\n        return syntax;\n    }\n\n    /**\n     * add tags to the document.\n     */\n    public void setTags(String tagsStr, XWikiContext context) throws XWikiException\n    {\n        BaseClass tagsClass = context.getWiki().getTagClass(context);\n\n        StaticListClass tagProp = (StaticListClass) tagsClass.getField(XWikiConstant.TAG_CLASS_PROP_TAGS);\n\n        BaseObject tags = getObject(XWikiConstant.TAG_CLASS, true, context);\n\n        tags.safeput(XWikiConstant.TAG_CLASS_PROP_TAGS, tagProp.fromString(tagsStr));\n\n        setMetaDataDirty(true);\n    }\n\n    public String getTags(XWikiContext context)\n    {\n        ListProperty prop = (ListProperty) getTagProperty(context);\n\n        // I don't know why we need to XML-escape the list of tags but for backwards compatibility we need to keep doing\n        // this. When this method was added it was using ListProperty#getTextValue() which used to return\n        // ListProperty#toFormString() before we fixed it to return the unescaped value because we need to save the raw\n        // value in the database and ListProperty#getTextValue() is called when the list property is saved.\n        return prop != null ? prop.toFormString() : \"\";\n    }\n\n    public List<String> getTagsList(XWikiContext context)\n    {\n        List<String> tagList = null;\n\n        BaseProperty prop = getTagProperty(context);\n        if (prop != null) {\n            tagList = (List<String>) prop.getValue();\n        }\n\n        return tagList;\n    }\n\n    private BaseProperty getTagProperty(XWikiContext context)\n    {\n        BaseObject tags = getObject(XWikiConstant.TAG_CLASS);\n\n        return tags != null ? ((BaseProperty) tags.safeget(XWikiConstant.TAG_CLASS_PROP_TAGS)) : null;\n    }\n\n    public List<String> getTagsPossibleValues(XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            BaseClass tagsClass = context.getWiki().getTagClass(context);\n\n            String possibleValues =\n                ((StaticListClass) tagsClass.getField(XWikiConstant.TAG_CLASS_PROP_TAGS)).getValues();\n\n            return ListClass.getListFromString(possibleValues);\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to get tag class\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    public void readTranslationMetaFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String content = eform.getContent();\n        if (content != null) {\n            // Cleanup in case we use HTMLAREA\n            // content = context.getUtil().substitute(\"s/<br class=\\\\\\\"htmlarea\\\\\\\"\\\\/>/\\\\r\\\\n/g\",\n            // content);\n            content = context.getUtil().substitute(\"s/<br class=\\\"htmlarea\\\" \\\\/>/\\r\\n/g\", content);\n            setContent(content);\n        }\n        String title = eform.getTitle();\n        if (title != null) {\n            setTitle(title);\n        }\n    }\n\n    /**\n     * Updates properties of existing objects with the values from the given form.\n     *\n     * @param eform The form to read the values from\n     * @param context The context used for getting the classes of objects\n     * @throws XWikiException On errors\n     */\n    public void readObjectsFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        for (DocumentReference reference : getXObjects().keySet()) {\n            List<BaseObject> oldObjects = getXObjects(reference);\n            BaseObjects newObjects = new BaseObjects();\n            while (newObjects.size() < oldObjects.size()) {\n                newObjects.add(null);\n            }\n            for (int i = 0; i < oldObjects.size(); i++) {\n                BaseObject oldobject = oldObjects.get(i);\n                if (oldobject != null) {\n                    BaseClass baseclass = oldobject.getXClass(context);\n                    BaseObject newobject = (BaseObject) baseclass.fromMap(\n                        eform.getObject(\n                            LOCAL_REFERENCE_SERIALIZER.serialize(baseclass.getDocumentReference()) + \"_\" + i),\n                        oldobject);\n                    newobject.setNumber(oldobject.getNumber());\n                    newobject.setGuid(oldobject.getGuid());\n                    newobject.setOwnerDocument(this);\n                    newObjects.set(newobject.getNumber(), newobject);\n                }\n            }\n            getXObjects().put(reference, newObjects);\n        }\n    }\n\n    /**\n     * Create and/or update objects in a document given a list of HTTP parameters of the form {@code\n     * <spacename>.<classname>_<number>_<propertyname>}. If the object already exists, the field is replaced by the\n     * given value. If the object doesn't exist in the document, it is created and the property {@code <propertyname>}\n     * is initialized with the given value.\n     *\n     * @param eform is form information that contains all the query parameters\n     * @param context\n     * @throws XWikiException\n     * @since 7.1M1\n     */\n    public void readObjectsFromFormUpdateOrCreate(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        Map<String, SortedMap<Integer, Map<String, String[]>>> updateOrCreateMap = eform.getUpdateOrCreateMap();\n        for (Entry<String, SortedMap<Integer, Map<String, String[]>>> requestClassEntries : updateOrCreateMap\n            .entrySet()) {\n            String className = requestClassEntries.getKey();\n            DocumentReference requestClassReference = getCurrentDocumentReferenceResolver().resolve(className);\n\n            SortedMap<Integer, Map<String, String[]>> requestObjectMap = requestClassEntries.getValue();\n            for (Entry<Integer, Map<String, String[]>> requestObjectEntry : requestObjectMap.entrySet()) {\n                Integer requestObjectNumber = requestObjectEntry.getKey();\n                Map<String, String[]> requestObjectPropertyMap = requestObjectEntry.getValue();\n                List<String> properties = new ArrayList<>(requestObjectPropertyMap.keySet());\n                try {\n                    BaseClass xClass = context.getWiki().getDocument(requestClassReference, context).getXClass();\n\n                    // clean-up the properties that do not belong to the xclass\n                    for (String property : properties) {\n                        if (!xClass.getPropertyList().contains(property)) {\n                            requestObjectPropertyMap.remove(property);\n                        }\n                    }\n                } catch (XWikiException e) {\n                    // If the class page cannot be found, skip entirely the property update\n                    LOGGER.warn(\"Failed to load document [{}], ignoring properties update [{}]. Reason: [{}]\",\n                        requestClassReference, StringUtils.join(properties, \",\"),\n                        ExceptionUtils.getRootCauseMessage(e));\n                    continue;\n                }\n\n                if (!requestObjectPropertyMap.isEmpty()) {\n                    BaseObject oldObject = getXObject(requestClassReference, requestObjectNumber, true, context);\n                    BaseClass baseClass = oldObject.getXClass(context);\n                    BaseObject newObject = (BaseObject) baseClass.fromMap(requestObjectPropertyMap, oldObject);\n                    newObject.setNumber(oldObject.getNumber());\n                    newObject.setGuid(oldObject.getGuid());\n                    newObject.setOwnerDocument(this);\n                    setXObject(requestObjectNumber, newObject);\n                }\n            }\n        }\n    }\n\n    public void readFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        readDocMetaFromForm(eform, context);\n        readTranslationMetaFromForm(eform, context);\n\n        readAddedUpdatedAndRemovedObjectsFromForm(eform, context);\n        readTemporaryUploadedFiles(eform);\n    }\n\n    private TemporaryAttachmentSessionsManager getTemporaryAttachmentManager()\n    {\n        return Utils.getComponent(TemporaryAttachmentSessionsManager.class);\n    }\n\n    /**\n     * Read the list of attachment that should be added from {@link EditForm#getTemporaryUploadedFiles()} and attach\n     * them to the current document if they can be found in the {@link TemporaryAttachmentSessionsManager}.\n     *\n     * @param editForm the form from which to read the list of files.\n     * @since 14.3RC1\n     */\n    @Unstable\n    public void readTemporaryUploadedFiles(EditForm editForm)\n    {\n        getTemporaryAttachmentManager().attachTemporaryAttachmentsInDocument(this, editForm.getTemporaryUploadedFiles());\n    }\n\n    /**\n     * Adds objects, applies property updates and removes objects as specified in the form.\n     *\n     * @param eform The form from which the values shall be read.\n     * @param context The XWiki context.\n     * @throws XWikiException If an error occurs.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public void readAddedUpdatedAndRemovedObjectsFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        // We add the new objects that have been submitted in the form, before filling them with their values.\n        Map<String, List<Integer>> objectsToAdd = eform.getObjectsToAdd();\n        for (String className : objectsToAdd.keySet()) {\n            DocumentReference classReference = resolveClassReference(className);\n            List<Integer> classIds = objectsToAdd.get(className);\n            for (Integer classId : classIds) {\n                // we ensure that the object has not been added yet, for example because of the update or create.\n                getXObject(classReference, classId, true, context);\n            }\n        }\n\n        ObjectPolicyType objectPolicy = eform.getObjectPolicy();\n        if (objectPolicy == null || objectPolicy.equals(ObjectPolicyType.UPDATE)) {\n            readObjectsFromForm(eform, context);\n        } else if (objectPolicy.equals(ObjectPolicyType.UPDATE_OR_CREATE)) {\n            readObjectsFromFormUpdateOrCreate(eform, context);\n        }\n\n        // remove xobjects\n        Map<String, List<Integer>> objectsToRemove = eform.getObjectsToRemove();\n        for (String className : objectsToRemove.keySet()) {\n            DocumentReference classReference = resolveClassReference(className);\n            List<Integer> classIds = objectsToRemove.get(className);\n            for (Integer classId : classIds) {\n                BaseObject xObject = getXObject(classReference, classId);\n                if (xObject != null) {\n                    removeXObject(xObject);\n                }\n            }\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void readFromTemplate(DocumentReference templateDocumentReference, XWikiContext context)\n        throws XWikiException\n    {\n        if (templateDocumentReference != null) {\n            String content = getContent();\n            if (!content.equals(\"\\n\") && !content.equals(\"\") && !isNew()) {\n                Object[] args = { getDefaultEntityReferenceSerializer().serialize(getDocumentReference()) };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY,\n                    \"Cannot add a template to document {0} because it already has content\", null, args);\n            } else {\n                XWiki xwiki = context.getWiki();\n                XWikiDocument templatedoc = xwiki.getDocument(templateDocumentReference, context);\n                if (templatedoc.isNew()) {\n                    Object[] args = { getDefaultEntityReferenceSerializer().serialize(templateDocumentReference),\n                    getCompactEntityReferenceSerializer().serialize(getDocumentReference()) };\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                        XWikiException.ERROR_XWIKI_APP_TEMPLATE_DOES_NOT_EXIST,\n                        \"Template document {0} does not exist when adding to document {1}\", null, args);\n                } else {\n                    setTemplateDocumentReference(templateDocumentReference);\n                    setTitle(templatedoc.getTitle());\n                    setContent(templatedoc.getContent());\n\n                    // Set the new document syntax as the syntax of the template since the template content\n                    // is copied into the new document\n                    setSyntax(templatedoc.getSyntax());\n\n                    // If the parent is not set in the current document set the template parent as the parent.\n                    if (getParentReference() == null) {\n                        setParentReference(templatedoc.getRelativeParentReference());\n                    }\n\n                    if (isNew()) {\n                        // We might have received the objects from the cache and the template objects might have been\n                        // copied already we need to remove them\n                        setXObjects(new TreeMap<DocumentReference, List<BaseObject>>());\n                    }\n                    // Merge the external objects.\n                    // Currently the choice is not to merge the base class and object because it is not the preferred\n                    // way of using external classes and objects.\n                    mergeXObjects(templatedoc);\n\n                    // Copy the attachments from the template document, but don't overwrite existing attachments because\n                    // the user can add attachments from the WYSIWYG editor before the save button is clicked (and thus\n                    // before the template is applied).\n                    copyAttachments(templatedoc, false);\n                }\n            }\n        }\n    }\n\n    /**\n     * Use the document passed as parameter as the new identity for the current document.\n     *\n     * @param document the document containing the new identity\n     */\n    public void clone(XWikiDocument document)\n    {\n        this.id = document.id;\n\n        setDocumentReference(document.getDocumentReference());\n        setRCSVersion(document.getRCSVersion());\n        setDocumentArchive(document.getDocumentArchive());\n        setAuthorReference(document.getAuthorReference());\n        setContentAuthorReference(document.getContentAuthorReference());\n        setContent(document.getContent());\n        setCreationDate(document.getCreationDate());\n        setDate(document.getDate());\n        setCustomClass(document.getCustomClass());\n        setContentUpdateDate(document.getContentUpdateDate());\n        setTitle(document.getTitle());\n        setFormat(document.getFormat());\n        setFromCache(document.isFromCache());\n        setElements(document.getElements());\n        setMeta(document.getMeta());\n        setMostRecent(document.isMostRecent());\n        setNew(document.isNew());\n        setStore(document.getStore());\n        setTemplateDocumentReference(document.getTemplateDocumentReference());\n        setParentReference(document.getRelativeParentReference());\n        setCreatorReference(document.getCreatorReference());\n        setDefaultLocale(document.getDefaultLocale());\n        setDefaultTemplate(document.getDefaultTemplate());\n        setValidationScript(document.getValidationScript());\n        setLocale(document.getLocale());\n        setXClass(document.getXClass().clone());\n        setXClassXML(document.getXClassXML());\n        setComment(document.getComment());\n        setMinorEdit(document.isMinorEdit());\n        setSyntax(document.getSyntax());\n        setHidden(document.isHidden());\n\n        cloneXObjects(document);\n        cloneAttachments(document);\n\n        setContentDirty(document.isContentDirty());\n        setMetaDataDirty(document.isMetaDataDirty());\n\n        this.elements = document.elements;\n\n        this.originalDocument = document.originalDocument;\n    }\n\n    @Override\n    public XWikiDocument clone()\n    {\n        return cloneInternal(getDocumentReference(), true, false);\n    }\n\n    /**\n     * Duplicate this document and give it a new name.\n     *\n     * @since 2.2.3\n     */\n    public XWikiDocument duplicate(DocumentReference newDocumentReference)\n    {\n        return cloneInternal(newDocumentReference, false, false);\n    }\n\n    private void cloneDocumentArchive(XWikiDocument originalDocument) throws XWikiException\n    {\n        XWikiDocumentArchive documentArchive = originalDocument.getDocumentArchive();\n        if (documentArchive != null) {\n            this.setDocumentArchive(documentArchive.clone(this.getId(), getXWikiContext()));\n        }\n    }\n\n    private XWikiDocument cloneInternal(DocumentReference newDocumentReference,\n        boolean keepsIdentity,\n        boolean cloneArchive)\n    {\n        XWikiDocument doc = null;\n\n        try {\n            Constructor<? extends XWikiDocument> constructor = getClass().getConstructor(DocumentReference.class);\n            doc = constructor.newInstance(newDocumentReference);\n\n            // Make sure the coordinate of the document is fully accurate before any other manipulation\n            doc.setLocale(getLocale());\n\n            // use version field instead of getRCSVersion because it returns \"1.1\" if version==null.\n            doc.version = this.version;\n            doc.id = this.id;\n            if (cloneArchive) {\n                doc.cloneDocumentArchive(this);\n            } else {\n                // Without this explicit initialization, it is possible for the archive to be incorrectly initialized.\n                // For instance, with the archive of the cloned document.\n                // Here we guarantee that further calls of APIs to get the archive will properly populate the data.\n                doc.setDocumentArchive((XWikiDocumentArchive) null);\n            }\n            doc.getAuthors().copyAuthors(getAuthors());\n            doc.setContent(getContent());\n            doc.setCreationDate(getCreationDate());\n            doc.setDate(getDate());\n            doc.setCustomClass(getCustomClass());\n            doc.setContentUpdateDate(getContentUpdateDate());\n            doc.setTitle(getTitle());\n            doc.setFormat(getFormat());\n            doc.setFromCache(isFromCache());\n            doc.setElements(getElements());\n            doc.setMeta(getMeta());\n            doc.setMostRecent(isMostRecent());\n            doc.setNew(isNew());\n            doc.setStore(getStore());\n            doc.setTemplateDocumentReference(getTemplateDocumentReference());\n            doc.setParentReference(getRelativeParentReference());\n            doc.setDefaultLocale(getDefaultLocale());\n            doc.setDefaultTemplate(getDefaultTemplate());\n            doc.setValidationScript(getValidationScript());\n            doc.setComment(getComment());\n            doc.setMinorEdit(isMinorEdit());\n            doc.setSyntax(getSyntax());\n            doc.setHidden(isHidden());\n\n            if (this.xClass != null) {\n                doc.setXClass(this.xClass.clone());\n            }\n\n            if (keepsIdentity) {\n                doc.setXClassXML(getXClassXML());\n                doc.cloneXObjects(this);\n                doc.cloneAttachments(this);\n            } else {\n                doc.getXClass().setCustomMapping(null);\n                doc.duplicateXObjects(this);\n                doc.copyAttachments(this);\n            }\n\n            doc.setContentDirty(isContentDirty());\n            doc.setMetaDataDirty(isMetaDataDirty());\n\n            doc.elements = this.elements;\n\n            doc.originalDocument = this.originalDocument;\n        } catch (Exception e) {\n            // This should not happen\n            LOGGER.error(\"Exception while cloning document\", e);\n        }\n        return doc;\n    }\n\n    /**\n     * Clone attachments from another document. This implementation expects that this document is the same as the other\n     * document and thus attachments will be saved in the database in the same place as the ones which they are cloning.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     */\n    private void cloneAttachments(final XWikiDocument sourceDocument)\n    {\n        this.getAttachmentList().clear();\n        for (XWikiAttachment attach : sourceDocument.getAttachmentList()) {\n            XWikiAttachment newAttach = (XWikiAttachment) attach.clone();\n\n            setAttachment(newAttach);\n        }\n    }\n\n    /**\n     * Copy attachments from one document to another. This implementation expects that you are copying the attachment\n     * from one document to another and thus it should be saved separately from the original in the database.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     */\n    public void copyAttachments(XWikiDocument sourceDocument)\n    {\n        copyAttachments(sourceDocument, true);\n    }\n\n    /**\n     * Copy attachments from one document to another. This implementation expects that you are copying the attachment\n     * from one document to another and thus it should be saved separately from the original in the database.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     * @param overwrite whether to overwrite the existing attachments or not\n     * @since 8.4.6\n     * @since 9.6RC1\n     */\n    private void copyAttachments(XWikiDocument sourceDocument, boolean overwrite)\n    {\n        if (overwrite) {\n            // Note: when clearing the attachment list, we automatically mark the document's metadata as dirty.\n            getAttachmentList().clear();\n        }\n\n        for (XWikiAttachment attachment : sourceDocument.getAttachmentList()) {\n            if (overwrite || this.getAttachment(attachment.getFilename()) == null) {\n                try {\n                    copyAttachment(attachment, true);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"Cannot copy attachment [{}] from [{}] to [{}]. Root cause is [{}].\",\n                        attachment.getFilename(), sourceDocument.getDocumentReference(), this.getDocumentReference(),\n                        ExceptionUtils.getRootCauseMessage(e));\n                    // Skip this attachment because we cannot load its content.\n                    continue;\n                }\n            }\n        }\n    }\n\n    /**\n     * Copies the given attachment to this document.\n     * \n     * @param attachment the source attachment to be copied to this document\n     * @param reset whether to reset or not the attachment meta data that is specific to the source (version, author,\n     *            date)\n     * @throws XWikiException if loading the content of the given attachment fails\n     */\n    private void copyAttachment(XWikiAttachment attachment, boolean reset) throws XWikiException\n    {\n        XWikiContext xcontext = getXWikiContext();\n        XWikiAttachment newAttachment = attachment.clone();\n\n        // Make sure we copy the attachment content also, not just its meta data. For this we need to load\n        // the attachment content from the source document. Note that the owner document will be overwritten\n        // below when we call setAttachment().\n        newAttachment.setDoc(attachment.getDoc(), false);\n        newAttachment.loadAttachmentContent(xcontext);\n        // We need to set the content of the attachment to be dirty because the dirty bit is used to signal\n        // that there is a reason to save the copied attachment, otherwise the copied attachment will be\n        // empty since the original attachment content is not modified in this operation.\n        newAttachment.getAttachment_content().setContentDirty(true);\n\n        if (reset) {\n            // Reset the meta data that is specific to the original attachment (version, author, date).\n            newAttachment.setRCSVersion(null);\n            newAttachment.setAuthorReference(xcontext.getUserReference());\n            newAttachment.setDate(new Date());\n        }\n\n        // Add the attachment copy to the list of attachments of this document.\n        setAttachment(newAttachment);\n    }\n\n    /**\n     * Load attachment content from database.\n     *\n     * @param context the XWiki context\n     * @throws XWikiException when failing to load attachments\n     * @since 5.3M2\n     */\n    public void loadAttachmentsContent(XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            attachment.loadAttachmentContent(context);\n        }\n    }\n\n    /**\n     * Same as {@link #loadAttachmentContent(XWikiAttachment, XWikiContext)} but in some context we don't really care if\n     * an attachment content could not be loaded (we are going to overwrite or ignore it).\n     * \n     * @param context the XWiki context\n     * @since 10.1RC1\n     */\n    public void loadAttachmentsContentSafe(XWikiContext context)\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            try {\n                attachment.loadAttachmentContent(context);\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Failed to load attachment [{}]: {}\", attachment.getReference(),\n                    ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n    }\n\n    public void loadAttachments(XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            attachment.loadAttachmentContent(context);\n            attachment.loadArchive(context);\n        }\n    }\n\n    @Override\n    public boolean equals(Object object)\n    {\n        // Same Java object, they sure are equal\n        if (this == object) {\n            return true;\n        }\n\n        // Reference/language (document identifier)\n\n        XWikiDocument doc = (XWikiDocument) object;\n        if (!getDocumentReference().equals(doc.getDocumentReference())) {\n            return false;\n        }\n\n        if (!getDefaultLocale().equals(doc.getDefaultLocale())) {\n            return false;\n        }\n\n        if (!getLocale().equals(doc.getLocale())) {\n            return false;\n        }\n\n        if (getTranslation() != doc.getTranslation()) {\n            return false;\n        }\n\n        // Authors\n\n        if (ObjectUtils.notEqual(getAuthorReference(), doc.getAuthorReference())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getContentAuthorReference(), doc.getContentAuthorReference())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getCreatorReference(), doc.getCreatorReference())) {\n            return false;\n        }\n\n        // Version\n\n        if (!getVersion().equals(doc.getVersion())) {\n            return false;\n        }\n\n        if (getDate().getTime() != doc.getDate().getTime()) {\n            return false;\n        }\n\n        if (getContentUpdateDate().getTime() != doc.getContentUpdateDate().getTime()) {\n            return false;\n        }\n\n        if (getCreationDate().getTime() != doc.getCreationDate().getTime()) {\n            return false;\n        }\n\n        if (!getComment().equals(doc.getComment())) {\n            return false;\n        }\n\n        if (isMinorEdit() != doc.isMinorEdit()) {\n            return false;\n        }\n\n        // Datas\n\n        if (!equalsData(doc)) {\n            return false;\n        }\n\n        // We consider that 2 documents are still equal even when they have different original\n        // documents (see getOriginalDocument() for more details as to what is an original\n        // document).\n\n        return true;\n    }\n\n    /**\n     * Same as {@link #equals(Object)} but only for actual datas of the document.\n     * <p>\n     * The goal being to compare two versions of the same document this method skip every version/reference/author\n     * related information. For example it allows to compare a document comming from a another wiki and easily check if\n     * thoses actually are the same thing whatever the plumbing differences.\n     *\n     * @param otherDocument the document to compare\n     * @return true if bith documents have the same datas\n     * @since 4.1.1\n     */\n    public boolean equalsData(XWikiDocument otherDocument)\n    {\n        // Same Java object, they sure are equal\n        if (this == otherDocument) {\n            return true;\n        }\n\n        if (ObjectUtils.notEqual(getParentReference(), otherDocument.getParentReference())) {\n            return false;\n        }\n\n        if (!getFormat().equals(otherDocument.getFormat())) {\n            return false;\n        }\n\n        if (!getTitle().equals(otherDocument.getTitle())) {\n            return false;\n        }\n\n        if (!getContent().equals(otherDocument.getContent())) {\n            return false;\n        }\n\n        if (!getDefaultTemplate().equals(otherDocument.getDefaultTemplate())) {\n            return false;\n        }\n\n        if (!getValidationScript().equals(otherDocument.getValidationScript())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getSyntax(), otherDocument.getSyntax())) {\n            return false;\n        }\n\n        if (isHidden() != otherDocument.isHidden()) {\n            return false;\n        }\n\n        // XClass\n\n        if (!getXClass().equals(otherDocument.getXClass())) {\n            return false;\n        }\n\n        // XObjects\n\n        Set<DocumentReference> myObjectClassReferences = getXObjects().keySet();\n        Set<DocumentReference> otherObjectClassReferences = otherDocument.getXObjects().keySet();\n        if (!myObjectClassReferences.equals(otherObjectClassReferences)) {\n            return false;\n        }\n\n        for (DocumentReference reference : myObjectClassReferences) {\n            List<BaseObject> myObjects = getXObjects(reference);\n            List<BaseObject> otherObjects = otherDocument.getXObjects(reference);\n            if (myObjects.size() != otherObjects.size()) {\n                return false;\n            }\n            for (int i = 0; i < myObjects.size(); i++) {\n                if ((myObjects.get(i) == null && otherObjects.get(i) != null)\n                    || (myObjects.get(i) != null && otherObjects.get(i) == null)) {\n                    return false;\n                }\n                if (myObjects.get(i) == null && otherObjects.get(i) == null) {\n                    continue;\n                }\n                if (!myObjects.get(i).equals(otherObjects.get(i))) {\n                    return false;\n                }\n            }\n        }\n\n        // Attachments\n        List<XWikiAttachment> attachments = getAttachmentList();\n        List<XWikiAttachment> otherAttachments = otherDocument.getAttachmentList();\n        if (attachments.size() != otherAttachments.size()) {\n            return false;\n        }\n        for (XWikiAttachment attachment : attachments) {\n            XWikiAttachment otherAttachment = otherDocument.getAttachment(attachment.getFilename());\n            try {\n                if (otherAttachment == null || !attachment.equalsData(otherAttachment, null)) {\n                    return false;\n                }\n            } catch (XWikiException e) {\n                throw new RuntimeException(\n                    String.format(\"Failed to compare attachments with reference [%s]\", attachment.getReference()), e);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Retrieve the document in the current context language as an XML string. The rendrered document content and all\n     * XObjects are included. Document attachments and archived versions are excluded. You should prefer\n     * toXML(OutputStream, true, true, false, false, XWikiContext)} or toXML(com.xpn.xwiki.util.XMLWriter, true, true,\n     * false, false, XWikiContext) on the translated document when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document in the current context language\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String getXMLContent(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = getTranslatedDocument(context);\n        return tdoc.toXML(true, true, false, false, context);\n    }\n\n    /**\n     * Retrieve the document as an XML string. All XObject are included. Rendered content, attachments and archived\n     * version are excluded. You should prefer toXML(OutputStream, true, false, false, false, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, false, false, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String toXML(XWikiContext context) throws XWikiException\n    {\n        return toXML(true, false, false, false, context);\n    }\n\n    /**\n     * Retrieve the document as an XML string. All XObjects attachments and archived version are included. Rendered\n     * content is excluded. You should prefer toXML(OutputStream, true, false, true, true, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, true, true, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String toFullXML(XWikiContext context) throws XWikiException\n    {\n        return toXML(true, false, true, true, context);\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. All XObjects and attachments are\n     * included. Rendered content is excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param zipname the name of the new entry to create\n     * @param withVersions if true, also include archived version of the document\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.1M2\")\n    public void addToZip(ZipOutputStream zos, String zipname, boolean withVersions, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        ZipEntry zipentry = new ZipEntry(zipname);\n        zos.putNextEntry(zipentry);\n        toXML(zos, true, false, true, withVersions, context);\n        zos.closeEntry();\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. The new entry is named\n     * 'LastSpaceName/DocumentName'. All XObjects and attachments are included. Rendered content is excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param withVersions if true, also include archived version of the document\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.2M2\")\n    public void addToZip(ZipOutputStream zos, boolean withVersions, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        String zipname =\n            getDocumentReference().getLastSpaceReference().getName() + \"/\" + getDocumentReference().getName();\n        String language = getLanguage();\n        if (!StringUtils.isEmpty(language)) {\n            zipname += \".\" + language;\n        }\n        addToZip(zos, zipname, withVersions, context);\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. The new entry is named\n     * 'LastSpaceName/DocumentName'. All XObjects, attachments and archived versions are included. Rendered content is\n     * excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.1M2\")\n    public void addToZip(ZipOutputStream zos, XWikiContext context) throws XWikiException, IOException\n    {\n        addToZip(zos, true, context);\n    }\n\n    /**\n     * Serialize the document to an XML string. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to reduce memory load.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an errors occurs during wiki operations\n     */\n    public String toXML(boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException\n    {\n        StringWriter writer = new StringWriter();\n\n        toXML(new DefaultWriterOutputTarget(writer), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n\n        return writer.toString();\n    }\n\n    /**\n     * Serialize the document to an XML {@link DOMDocument}. All XObject are included. Rendered content, attachments and\n     * archived version are excluded. You should prefer toXML(OutputStream, true, false, false, false, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, false, false, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a {@link DOMDocument} containing the serialized document.\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public Document toXMLDocument(XWikiContext context) throws XWikiException\n    {\n        return toXMLDocument(true, false, false, false, context);\n    }\n\n    /**\n     * Serialize the document to an XML {@link DOMDocument}. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to reduce memory load.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @return a {@link DOMDocument} containing the serialized document.\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public Document toXMLDocument(boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException\n    {\n        Document doc = new DOMDocument();\n        DOMXMLWriter wr = new DOMXMLWriter(doc, new OutputFormat(\"\", true, context.getWiki().getEncoding()));\n\n        try {\n            toXML(wr, bWithObjects, bWithRendering, bWithAttachmentContent, bWithVersions, context);\n            return doc;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Serialize the document to a {@link com.xpn.xwiki.internal.xml.XMLWriter}.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @throws IOException when an errors occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public void toXML(XMLWriter wr, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException, IOException\n    {\n        // IMPORTANT: we don't use directly XMLWriter's SAX apis here because it's not really working well\n        DocumentResult domResult = new DocumentResult();\n\n        toXML(new DefaultResultOutputTarget(domResult), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n\n        wr.write(domResult.getDocument().getRootElement());\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @throws IOException when an errors occurs during streaming operations\n     * @since 2.3M2\n     */\n    public void toXML(OutputStream out, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException, IOException\n    {\n        toXML(new DefaultOutputStreamOutputTarget(out), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param out the output where to write the XML\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param format true if the XML should be formated\n     * @param encoding the encoding to use to write the XML\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @since 9.0RC1\n     */\n    public void toXML(OutputTarget out, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, boolean format, String encoding) throws XWikiException\n    {\n        // Input\n        DocumentInstanceInputProperties documentProperties = new DocumentInstanceInputProperties();\n        documentProperties.setWithWikiObjects(bWithObjects);\n        documentProperties.setWithWikiDocumentContentHTML(bWithRendering);\n        documentProperties.setWithWikiAttachmentsContent(bWithAttachmentContent);\n        documentProperties.setWithJRCSRevisions(bWithVersions);\n        documentProperties.setWithRevisions(false);\n\n        // Output\n        XAROutputProperties xarProperties = new XAROutputProperties();\n        xarProperties.setPreserveVersion(bWithVersions);\n        xarProperties.setEncoding(encoding);\n        xarProperties.setFormat(format);\n        xarProperties.setTarget(out);\n\n        toXML(documentProperties, xarProperties);\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param xarProperties the configuration of the output filter\n     * @param documentProperties the configuration of the input filter\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @since 13.8RC1\n     */\n    public void toXML(DocumentInstanceInputProperties documentProperties, XAROutputProperties xarProperties)\n        throws XWikiException\n    {\n        try {\n            Utils.getComponent(XWikiDocumentFilterUtils.class).exportEntity(this, xarProperties.getTarget(),\n                xarProperties, documentProperties);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_XWIKI_DOC_EXPORT,\n                \"Error serializing XML\", e, null);\n        }\n    }\n\n    protected String encodedXMLStringAsUTF8(String xmlString)\n    {\n        if (xmlString == null) {\n            return \"\";\n        }\n\n        int length = xmlString.length();\n        char character;\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            character = xmlString.charAt(i);\n            switch (character) {\n                case '&':\n                    result.append(\"&amp;\");\n                    break;\n                case '\"':\n                    result.append(\"&quot;\");\n                    break;\n                case '<':\n                    result.append(\"&lt;\");\n                    break;\n                case '>':\n                    result.append(\"&gt;\");\n                    break;\n                case '\\n':\n                    result.append(\"\\n\");\n                    break;\n                case '\\r':\n                    result.append(\"\\r\");\n                    break;\n                case '\\t':\n                    result.append(\"\\t\");\n                    break;\n                default:\n                    if (character < 0x20) {\n                    } else if (character > 0x7F) {\n                        result.append(\"&#x\");\n                        result.append(Integer.toHexString(character).toUpperCase());\n                        result.append(\";\");\n                    } else {\n                        result.append(character);\n                    }\n                    break;\n            }\n        }\n\n        return result.toString();\n    }\n\n    protected String getElement(Element docel, String name)\n    {\n        Element el = docel.element(name);\n        if (el == null) {\n            return \"\";\n        } else {\n            return el.getText();\n        }\n    }\n\n    public void fromXML(String xml) throws XWikiException\n    {\n        fromXML(xml, false);\n    }\n\n    public void fromXML(InputStream is) throws XWikiException\n    {\n        fromXML(is, false);\n    }\n\n    public void fromXML(InputSource source, boolean withArchive) throws XWikiException\n    {\n        // Output\n        DocumentInstanceOutputProperties documentProperties = new DocumentInstanceOutputProperties();\n        XWikiContext xcontext = getXWikiContext();\n        if (xcontext != null) {\n            documentProperties.setDefaultReference(getXWikiContext().getWikiReference());\n        }\n\n        // Input\n        XARInputProperties xarProperties = new XARInputProperties();\n        xarProperties.setWithHistory(withArchive);\n\n        try {\n            Utils.getComponent(XWikiDocumentFilterUtils.class).importEntity(XWikiDocument.class, this, source,\n                xarProperties, documentProperties);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error parsing xml\", e, null);\n        }\n\n        // We have been reading from XML so the document does not need a new version when saved\n        setMetaDataDirty(false);\n        setContentDirty(false);\n    }\n\n    public void fromXML(String source, boolean withArchive) throws XWikiException\n    {\n        fromXML(new StringInputSource(source), withArchive);\n    }\n\n    public void fromXML(InputStream source, boolean withArchive) throws XWikiException\n    {\n        fromXML(new DefaultInputStreamInputSource(source), withArchive);\n    }\n\n    /**\n     * @deprecated use {@link #fromXML(InputStream)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public void fromXML(Document domdoc, boolean withArchive) throws XWikiException\n    {\n        // Serialize the Document (could not find a way to convert a dom4j Document into a usable StAX source)\n        StringWriter writer = new StringWriter();\n        try {\n            org.dom4j.io.XMLWriter domWriter = new org.dom4j.io.XMLWriter(writer);\n            domWriter.write(domdoc);\n            domWriter.flush();\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error parsing xml\", e, null);\n        }\n\n        // Actually parse the XML\n        fromXML(writer.toString(), withArchive);\n    }\n\n    /**\n     * Check if provided xml document is a wiki document.\n     *\n     * @param domdoc the xml document.\n     * @return true if provided xml document is a wiki document.\n     */\n    public static boolean containsXMLWikiDocument(Document domdoc)\n    {\n        return domdoc.getRootElement().getName().equals(XarDocumentModel.ELEMENT_DOCUMENT);\n    }\n\n    public void setAttachmentList(List<XWikiAttachment> list)\n    {\n        // For backwards compatibility reasons (and in general), we need to allow callers to do something like\n        // setAttachmentList(getAttachmentList())\n        if (this.attachmentList != list) {\n            this.attachmentList.clear();\n            this.attachmentList.addAll(list);\n        }\n    }\n\n    public List<XWikiAttachment> getAttachmentList()\n    {\n        return this.attachmentList;\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAllAttachments(XWikiContext context) throws XWikiException\n    {\n        saveAllAttachments(true, true, context);\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAllAttachments(boolean updateParent, boolean transaction, XWikiContext context)\n        throws XWikiException\n    {\n        for (XWikiAttachment attachment : this.attachmentList) {\n            saveAttachmentContent(attachment, false, transaction, context);\n        }\n\n        // Save the document\n        if (updateParent) {\n            context.getWiki().saveDocument(this, context);\n        }\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentsContent(List<XWikiAttachment> attachments, XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : attachments) {\n            saveAttachmentContent(attachment, context);\n        }\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentContent(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        saveAttachmentContent(attachment, true, true, context);\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentContent(XWikiAttachment attachment, boolean updateParent, boolean transaction,\n        XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            // We might need to switch database to\n            // get the translated content\n            if (getDatabase() != null) {\n                context.setWikiId(getDatabase());\n            }\n\n            // Save the attachment\n            XWikiAttachmentStoreInterface store =\n                resolveXWikiAttachmentStoreInterface(attachment.getContentStore(), context);\n            store.saveAttachmentContent(attachment, false, context, transaction);\n\n            // We need to make sure there is a version upgrade\n            setMetaDataDirty(true);\n\n            // Save the document\n            if (updateParent) {\n                context.getWiki().saveDocument(this, context);\n            }\n        } catch (OutOfMemoryError e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_JAVA_HEAP_SPACE,\n                \"Out Of Memory Exception\");\n        } finally {\n            if (currentWiki != null) {\n                context.setWikiId(currentWiki);\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link XWikiAttachment#loadContent(XWikiContext)}\n     */\n    @Deprecated(since = \"9.9RC1\")\n    public void loadAttachmentContent(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        String database = context.getWikiId();\n        try {\n            // We might need to switch database to\n            // get the translated content\n            if (getDatabase() != null) {\n                context.setWikiId(getDatabase());\n            }\n\n            attachment.loadAttachmentContent(context);\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n        }\n    }\n\n    /**\n     * Remove the attachment from the document attachment list and put it in the list of attachments to remove for next\n     * document save.\n     * <p>\n     * The attachment will be move to recycle bin.\n     *\n     * @param attachment the attachment to remove\n     * @return the removed attachment, null if none could be found\n     * @since 5.2M1\n     */\n    public XWikiAttachment removeAttachment(XWikiAttachment attachment)\n    {\n        return removeAttachment(attachment, true);\n    }\n\n    /**\n     * Remove the attachment from the document attachment list and put it in the list of attachments to remove for next\n     * document save.\n     *\n     * @param attachmentToRemove the attachment to remove\n     * @param toRecycleBin indicate if the attachment should be moved to recycle bin\n     * @return the removed attachment, null if none could be found\n     * @since 5.2M1\n     */\n    public XWikiAttachment removeAttachment(XWikiAttachment attachmentToRemove, boolean toRecycleBin)\n    {\n        if (this.attachmentList.remove(attachmentToRemove)) {\n            this.attachmentsToRemove.add(new XWikiAttachmentToRemove(attachmentToRemove, toRecycleBin));\n            setMetaDataDirty(true);\n        } else {\n            attachmentToRemove = null;\n        }\n        return attachmentToRemove;\n    }\n\n    /**\n     * @return the attachment planned for removal\n     */\n    public List<XWikiAttachmentToRemove> getAttachmentsToRemove()\n    {\n        return this.attachmentsToRemove;\n    }\n\n    /**\n     * Clear the list of attachments planned for removal.\n     */\n    public void clearAttachmentsToRemove()\n    {\n        this.attachmentsToRemove.clear();\n    }\n\n    /**\n     * Get the wiki document references pointing to this document.\n     * <p>\n     * Theses links are stored in the Solr search core when the document is indexed. You can use \"backlinks\" in\n     * XWikiPreferences or \"xwiki.backlinks\" in xwiki.cfg file to enable links storage in the database.\n     * <p>\n     * Since 14.8RC1, this method return all backlinked documents and not just those located in the context wiki.\n     *\n     * @param context the XWiki context.\n     * @return the found wiki document references\n     * @throws XWikiException error when getting pages names from database.\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getBackLinkedReferences(XWikiContext context) throws XWikiException\n    {\n        Set<EntityReference> references;\n        try {\n            references = getLinkStore().resolveBackLinkedEntities(getDocumentReference());\n        } catch (LinkException e) {\n            throw new XWikiException(\"Failed to load backlinks for reference [\" + getDocumentReference() + \"]\", e);\n        }\n\n        Set<DocumentReference> documentReferences = new HashSet<>(references.size());\n        for (EntityReference entityReference : references) {\n            // Resolve the DOCUMENT reference\n            DocumentReference linkReference = context.getWiki().getDocumentReference(entityReference, context);\n\n            // Retro compatibility: remove the locale as it's what is expected of #getBackLinkedReferences(XWikicontext)\n            if (linkReference.getLocale() != null) {\n                linkReference = new DocumentReference(linkReference, (Locale) null);\n            }\n\n            // Add the reference\n            documentReferences.add(linkReference);\n        }\n\n        return new ArrayList<>(documentReferences);\n    }\n\n    /**\n     * @deprecated use {@link #getBackLinkedReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getBackLinkedPages(XWikiContext context) throws XWikiException\n    {\n        List<DocumentReference> references = getBackLinkedReferences(context);\n\n        EntityReferenceSerializer<String> serializer = getCompactWikiEntityReferenceSerializer();\n\n        List<String> documentNames = new ArrayList<>(references.size());\n        for (DocumentReference reference : references) {\n            // Serialize the reference\n            documentNames.add(serializer.serialize(reference));\n        }\n\n        return documentNames;\n    }\n\n    /**\n     * Get a list of unique links from this document to others documents.\n     * <ul>\n     * <li>xwiki/1.0 content: get the unique links associated to document from database. This is stored when the\n     * document is saved. You can use \"backlinks\" in XWikiPreferences or \"xwiki.backlinks\" in xwiki.cfg file to enable\n     * links storage in the database.</li>\n     * <li>Other content: call {@link #getUniqueLinkedPages(XWikiContext)} and generate the List.</li>\n     * </ul>\n     *\n     * @param context the XWiki context\n     * @return the found wiki links.\n     * @throws XWikiException error when getting links from database when xwiki/1.0 content.\n     * @since 1.9M2\n     */\n    public Set<XWikiLink> getUniqueWikiLinkedPages(XWikiContext context) throws XWikiException\n    {\n        Set<XWikiLink> links;\n\n        // We don't handle the links the same way in 1.0 syntax for retro-compatibility reason\n        // So here we explicitly get the link from the DB instead of looking inside the document.\n        if (is10Syntax()) {\n            links = new LinkedHashSet<>(getStore(context).loadLinks(getId(), context, true));\n        } else {\n            Set<String> linkedPages = getUniqueLinkedPages(context);\n            links = new LinkedHashSet<>(linkedPages.size());\n            for (String linkedPage : linkedPages) {\n                XWikiLink wikiLink = new XWikiLink();\n\n                wikiLink.setDocId(getId());\n                wikiLink.setFullName(LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference()));\n                wikiLink.setLink(linkedPage);\n\n                links.add(wikiLink);\n            }\n        }\n\n        return links;\n    }\n\n    /**\n     * Extract all the unique static (i.e. not generated by macros) wiki links (pointing to wiki page) from this\n     * xwiki/1.0 document's content to others documents.\n     *\n     * @param context the XWiki context.\n     * @return the document references for linked pages, if null an error append.\n     * @since 1.9M2\n     */\n    private Set<DocumentReference> getUniqueLinkedPages10(XWikiContext context)\n    {\n        Set<DocumentReference> pageNames;\n\n        try {\n            List<String> list = context.getUtil().getUniqueMatches(getContent(), \"\\\\[(.*?)\\\\]\", 1);\n            pageNames = new HashSet<DocumentReference>(list.size());\n\n            DocumentReference currentDocumentReference = getDocumentReference();\n            for (String name : list) {\n                int i1 = name.indexOf('>');\n                if (i1 != -1) {\n                    name = name.substring(i1 + 1);\n                }\n                i1 = name.indexOf(\"&gt;\");\n                if (i1 != -1) {\n                    name = name.substring(i1 + 4);\n                }\n                i1 = name.indexOf('#');\n                if (i1 != -1) {\n                    name = name.substring(0, i1);\n                }\n                i1 = name.indexOf('?');\n                if (i1 != -1) {\n                    name = name.substring(0, i1);\n                }\n\n                // Let's get rid of anything that's not a real link\n                if (name.trim().equals(\"\") || (name.indexOf('$') != -1) || (name.indexOf(\"://\") != -1)\n                    || (name.indexOf('\"') != -1) || (name.indexOf('\\'') != -1) || (name.indexOf(\"..\") != -1)\n                    || (name.indexOf(':') != -1) || (name.indexOf('=') != -1)) {\n                    continue;\n                }\n\n                // generate the link\n                String newname = StringUtils.replace(Util.noaccents(name), \" \", \"\");\n\n                // If it is a local link let's add the space\n                if (newname.indexOf('.') == -1) {\n                    newname = getSpace() + \".\" + name;\n                }\n                if (context.getWiki().exists(newname, context)) {\n                    name = newname;\n                } else {\n                    // If it is a local link let's add the space\n                    if (name.indexOf('.') == -1) {\n                        name = getSpace() + \".\" + name;\n                    }\n                }\n\n                // If the reference is empty, the link is an autolink\n                if (!StringUtils.isEmpty(name)) {\n                    // The reference may not have the space or even document specified (in case of an empty\n                    // string)\n                    // Thus we need to find the fully qualified document name\n                    DocumentReference documentReference = getCurrentDocumentReferenceResolver().resolve(name);\n\n                    // Verify that the link is not an autolink (i.e. a link to the current document)\n                    if (!documentReference.equals(currentDocumentReference)) {\n                        pageNames.add(documentReference);\n                    }\n                }\n            }\n\n            return pageNames;\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to get linked documents\", e);\n\n            return null;\n        }\n    }\n\n    /**\n     * Extract all the unique entity references found in the current document (they can be wiki links, macro\n     * parameters, etc) and pointing to entities specified in the passed {@code entityTypes} map (the keys represent\n     * the entity references that will be returned).\n     *\n     * @param context the XWiki context\n     * @param entityTypes the mapping of the types of references to return (and their corresponding resource types)\n     * @return the serialized entity references, and null if an error happened\n     * @since 14.2RC1\n     */\n    private Set<EntityReference> getUniqueLinkedEntityReferences(XWikiContext context,\n        Map<EntityType, Set<ResourceType>> entityTypes)\n    {\n        Set<EntityReference> references;\n\n        XWikiDocument contextDoc = context.getDoc();\n        WikiReference contextWikiReference = context.getWikiReference();\n\n        try {\n            // Make sure the right document is used as context document\n            context.setDoc(this);\n            // Make sure the right wiki is used as context document\n            context.setWikiReference(getDocumentReference().getWikiReference());\n\n            if (is10Syntax()) {\n                references = (Set) getUniqueLinkedPages10(context);\n            } else {\n                references = new LinkedHashSet<>();\n\n                // Document content\n                XDOM dom = getXDOM();\n                getUniqueLinkedEntityReferences(dom, entityTypes, references);\n\n                // XObjects\n                for (List<BaseObject> xobjects : getXObjects().values()) {\n                    xobjects.stream()\n                        .forEach(xobject -> getUniqueLinkedEntityReferences(xobject, entityTypes, references, context));\n                }\n            }\n        } finally {\n            context.setDoc(contextDoc);\n            context.setWikiReference(contextWikiReference);\n        }\n\n        return references;\n    }\n\n    private void getUniqueLinkedEntityReferences(BaseObject xobject, Map<EntityType, Set<ResourceType>> entityTypes,\n        Set<EntityReference> references, XWikiContext xcontext)\n    {\n        if (xobject == null) {\n            return;\n        }\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n\n        for (Object fieldClass : xclass.getProperties()) {\n            // Wiki content stored in xobjects\n            if (fieldClass instanceof TextAreaClass && ((TextAreaClass) fieldClass).isWikiContent()) {\n                TextAreaClass textAreaClass = (TextAreaClass) fieldClass;\n                PropertyInterface field = xobject.getField(textAreaClass.getName());\n\n                // Make sure the field is the right type (might happen while a document is being migrated)\n                if (field instanceof LargeStringProperty) {\n                    LargeStringProperty largeField = (LargeStringProperty) field;\n\n                    try {\n                        XDOM dom = parseContent(getSyntax(), largeField.getValue(), getDocumentReference());\n                        getUniqueLinkedEntityReferences(dom, entityTypes, references);\n                    } catch (XWikiException e) {\n                        LOGGER.warn(\"Failed to extract links from xobject property [{}], skipping it. Error: {}\",\n                            largeField.getReference(), ExceptionUtils.getRootCauseMessage(e));\n                    }\n                }\n            }\n        }\n    }\n\n    private void getUniqueLinkedEntityReferences(XDOM dom, Map<EntityType, Set<ResourceType>> entityTypes,\n        Set<EntityReference> references)\n    {\n        Set<EntityReference> uniqueLinkedEntityReferences =\n            getLinkParser().getUniqueLinkedEntityReferences(dom, entityTypes, getDocumentReference());\n        references.addAll(uniqueLinkedEntityReferences);\n    }\n\n    private Set<DocumentReference> toDocumentReferenceSet(Collection<? extends EntityReference> entityReferences,\n        DocumentReference baseReference)\n    {\n        Set<DocumentReference> documentReferences = new LinkedHashSet<>(entityReferences.size());\n\n        for (EntityReference entityRefefence : entityReferences) {\n            documentReferences.add(getCurrentReferenceDocumentReferenceResolver().resolve(entityRefefence,\n                EntityType.DOCUMENT, baseReference));\n        }\n\n        return documentReferences;\n    }\n\n    /**\n     * Extract all the unique entity references found in the current document (they can be wiki links, macro\n     * parameters, etc) and pointing to documents (either using a Document Reference or a Page Reference).\n     *\n     * @param context the XWiki context\n     * @return the serialized entity references, and null if an error happened\n     * @since 1.9M2\n     */\n    public Set<String> getUniqueLinkedPages(XWikiContext context)\n    {\n        // Only return document references.\n        Set<EntityReference> references = getUniqueLinkedEntityReferences(context, Map.of(\n            EntityType.DOCUMENT, Set.of(\n                ResourceType.SPACE,\n                ResourceType.DOCUMENT,\n                ResourceType.ATTACHMENT),\n            EntityType.PAGE, Set.of(\n                ResourceType.PAGE,\n                ResourceType.PAGE_ATTACHMENT)\n        ));\n        Set<String> documentNames = new LinkedHashSet<>(references.size());\n\n        XWikiDocument contextDoc = context.getDoc();\n        String contextWiki = context.getWikiId();\n        EntityReferenceSerializer<String> serializer;\n\n        try {\n            // Specify the right context information for using the compact wiki serializer properly\n            // Make sure the right document is used as context document\n            context.setDoc(this);\n            // Make sure the right wiki is used as context document\n            context.setWikiId(getDocumentReference().getWikiReference().getName());\n\n            // for retro-compatibility reason we don't use the same serializer for 1.0 syntax.\n            if (is10Syntax()) {\n                serializer = getCompactEntityReferenceSerializer();\n            } else {\n                serializer = getCompactWikiEntityReferenceSerializer();\n            }\n\n            for (EntityReference reference : references) {\n                // Get the reference of the document\n                DocumentReference linkDocumentReference = context.getWiki().getDocumentReference(reference, context);\n\n                // Serialize the reference\n                documentNames.add(serializer.serialize(linkDocumentReference));\n            }\n        } finally {\n            context.setDoc(contextDoc);\n            context.setWikiId(contextWiki);\n        }\n\n        return documentNames;\n    }\n\n    /**\n     * Extract all the unique static (i.e. not generated by macros) entity references pointed by wiki links (pointing\n     * to wiki document or attachments) for the current context document.\n     *\n     * @param context the XWiki context\n     * @return the entity references pointing to either document or attachments. If {@code null}, an error happened\n     * @since 14.2RC1\n     */\n    @Unstable\n    public Set<EntityReference> getUniqueLinkedEntities(XWikiContext context)\n    {\n        // Return both document and attachment references.\n        // Note that we return PAGE and PAGE_ATTACHMENT since it's not possible to convert them to DOCUMENT and\n        // ATTACHMENT since there's no way of knowing (without querying the DB) if they point to a terminal page or\n        // a non-terminal one (and thus the conversion would be wrong).\n        return getUniqueLinkedEntityReferences(context, Map.of(\n            EntityType.DOCUMENT, Set.of(\n                ResourceType.SPACE,\n                ResourceType.DOCUMENT),\n            EntityType.PAGE, Set.of(\n                ResourceType.PAGE),\n            EntityType.ATTACHMENT, Set.of(\n                ResourceType.ATTACHMENT),\n            EntityType.PAGE_ATTACHMENT, Set.of(\n                ResourceType.PAGE_ATTACHMENT)\n        ));\n    }\n\n    /**\n     * Returns a list of references of all documents which list this document as their parent, in the current wiki.\n     * {@link #getChildren(int, int, com.xpn.xwiki.XWikiContext)}\n     *\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getChildrenReferences(XWikiContext context) throws XWikiException\n    {\n        return getChildrenReferences(0, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #getChildrenReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getChildren(XWikiContext context) throws XWikiException\n    {\n        return getChildren(0, 0, context);\n    }\n\n    /**\n     * Returns a list of references of all documents which list this document as their parent, in the current wiki.\n     *\n     * @param nb The number of results to return.\n     * @param start The number of results to skip before we begin returning results.\n     * @param context The {@link com.xpn.xwiki.XWikiContext context}.\n     * @return the list of document references\n     * @throws XWikiException If there's an error querying the database.\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getChildrenReferences(int nb, int start, XWikiContext context) throws XWikiException\n    {\n        // Use cases:\n        // - the parent document reference saved in the database matches the reference of this document, in its fully\n        // serialized form (eg \"wiki:space.page\"). Note that this is normally not required since the wiki part\n        // isn't saved in the database when it matches the current wiki.\n        // - the parent document reference saved in the database matches the reference of this document, in its\n        // serialized form without the wiki part (eg \"space.page\"). The reason we don't need to specify the wiki\n        // part is because document parents saved in the database don't have the wiki part specified when it matches\n        // the current wiki.\n        // - the parent document reference saved in the database matches the page name part of this document's\n        // reference (eg \"page\") and the parent document's space is the same as this document's space.\n        List<DocumentReference> children = new ArrayList<DocumentReference>();\n\n        try {\n            Query query = getStore().getQueryManager()\n                .createQuery(\"select distinct doc.fullName from XWikiDocument doc where \"\n                    + \"doc.parent=:prefixedFullName or doc.parent=:fullName or (doc.parent=:name and doc.space=:space)\",\n                    Query.XWQL);\n            query.addFilter(Utils.getComponent(QueryFilter.class, \"hidden\"));\n            query.bindValue(\"prefixedFullName\",\n                getDefaultEntityReferenceSerializer().serialize(getDocumentReference()));\n            query.bindValue(\"fullName\", LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference()));\n            query.bindValue(\"name\", getDocumentReference().getName());\n            query.bindValue(\"space\",\n                LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference().getLastSpaceReference()));\n            query.setLimit(nb).setOffset(start);\n\n            List<String> queryResults = query.execute();\n            WikiReference wikiReference = this.getDocumentReference().getWikiReference();\n            for (String fullName : queryResults) {\n                children.add(getCurrentDocumentReferenceResolver().resolve(fullName, wikiReference));\n            }\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to retrieve children for document [%s]\", this.getDocumentReference()), e);\n        }\n\n        return children;\n    }\n\n    /**\n     * @deprecated use {@link #getChildrenReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getChildren(int nb, int start, XWikiContext context) throws XWikiException\n    {\n        List<String> childrenNames = new ArrayList<String>();\n        for (DocumentReference reference : getChildrenReferences(nb, start, context)) {\n            childrenNames.add(LOCAL_REFERENCE_SERIALIZER.serialize(reference));\n        }\n        return childrenNames;\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public void renameProperties(DocumentReference classReference, Map<String, String> fieldsToRename)\n    {\n        List<BaseObject> objects = this.xObjects.get(classReference);\n        if (objects == null) {\n            return;\n        }\n\n        boolean isDirty = false;\n        for (BaseObject bobject : objects) {\n            if (bobject == null) {\n                continue;\n            }\n            for (Map.Entry<String, String> entry : fieldsToRename.entrySet()) {\n                String origname = entry.getKey();\n                String newname = entry.getValue();\n                BaseProperty origprop = (BaseProperty) bobject.safeget(origname);\n                if (origprop != null) {\n                    BaseProperty prop = origprop.clone();\n                    bobject.removeField(origname);\n                    prop.setName(newname);\n                    bobject.addField(newname, prop);\n\n                    isDirty = true;\n                }\n            }\n        }\n\n        // If at least one property was renamed, mark the document dirty.\n        if (isDirty) {\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #renameProperties(DocumentReference, Map)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void renameProperties(String className, Map<String, String> fieldsToRename)\n    {\n        renameProperties(resolveClassReference(className), fieldsToRename);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void addXObjectToRemove(BaseObject object)\n    {\n        getXObjectsToRemove().add(object);\n        object.setOwnerDocument(null);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * Automatically add objects present in the old version, but not in the current document, to the list of objects\n     * marked for removal from the database.\n     *\n     * @param previousVersion the version of the document present in the database\n     * @since 3.3M2\n     */\n    public void addXObjectsToRemoveFromVersion(XWikiDocument previousVersion)\n    {\n        if (previousVersion == null) {\n            return;\n        }\n        for (List<BaseObject> objects : previousVersion.getXObjects().values()) {\n            for (BaseObject originalObj : objects) {\n                if (originalObj != null) {\n                    BaseObject newObj = getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                    if (newObj == null) {\n                        // The object was deleted.\n                        this.addXObjectToRemove(originalObj);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectToRemove(BaseObject)} )} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void addObjectsToRemove(BaseObject object)\n    {\n        addXObjectToRemove(object);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public List<BaseObject> getXObjectsToRemove()\n    {\n        return this.xObjectsToRemove;\n    }\n\n    /**\n     * @deprecated use {@link #getObjectsToRemove()} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public ArrayList<BaseObject> getObjectsToRemove()\n    {\n        return (ArrayList<BaseObject>) getXObjectsToRemove();\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjectsToRemove(List<BaseObject> objectsToRemove)\n    {\n        this.xObjectsToRemove = objectsToRemove;\n        setMetaDataDirty(true);\n    }\n\n    public List<String> getIncludedPages(XWikiContext context)\n    {\n        try {\n            return getIncludedPagesInternal(context);\n        } catch (Exception e) {\n            // If an error happens then we return an empty list of included pages. We don't want to fail by throwing an\n            // exception since it'll lead to several errors in the UI (such as in the Information Panel in edit mode).\n            LOGGER.error(\"Failed to get included pages for [{}]\", getDocumentReference(), e);\n            return Collections.emptyList();\n        }\n    }\n\n    private List<String> getIncludedPagesInternal(XWikiContext context)\n    {\n        if (is10Syntax()) {\n            return getIncludedPagesForXWiki10Syntax(getContent(), context);\n        } else {\n            // Find all include macros listed on the page\n            XDOM dom = getXDOM();\n\n            List<String> result = new ArrayList<String>();\n            List<MacroBlock> macroBlocks =\n                dom.getBlocks(new ClassBlockMatcher(MacroBlock.class), Block.Axes.DESCENDANT);\n            for (MacroBlock macroBlock : macroBlocks) {\n                // - Add each document pointed to by the include macro\n                // - Also add all the included pages found in the velocity macro when using the deprecated #include*\n                // macros\n                // This should be removed when we fully drop support for the XWiki Syntax 1.0 but for now we want to\n                // play nice with people migrating from 1.0 to 2.0 syntax\n\n                if (macroBlock.getId().equalsIgnoreCase(\"include\") || macroBlock.getId().equalsIgnoreCase(\"display\")) {\n                    String documentName = macroBlock.getParameters().get(\"reference\");\n                    if (StringUtils.isEmpty(documentName)) {\n                        documentName = macroBlock.getParameters().get(\"document\");\n                        if (StringUtils.isEmpty(documentName)) {\n                            continue;\n                        }\n                    }\n\n                    DocumentReference documentReference =\n                        getExplicitDocumentReferenceResolver().resolve(documentName, getDocumentReference());\n                    if (this.getDocumentReference().equals(documentReference)) {\n                        // Skip auto-includes since they are not allowed anyway.\n                        continue;\n                    }\n\n                    documentName = LOCAL_REFERENCE_SERIALIZER.serialize(documentReference);\n\n                    result.add(documentName);\n                } else if (macroBlock.getId().equalsIgnoreCase(\"velocity\")\n                    && !StringUtils.isEmpty(macroBlock.getContent())) {\n                    // Try to find matching content inside each velocity macro\n                    result.addAll(getIncludedPagesForXWiki10Syntax(macroBlock.getContent(), context));\n                }\n            }\n\n            return result;\n        }\n    }\n\n    private List<String> getIncludedPagesForXWiki10Syntax(String content, XWikiContext context)\n    {\n        try {\n            String pattern = \"#include(Topic|InContext|Form|Macros|parseGroovyFromPage)\\\\([\\\"'](.*?)[\\\"']\\\\)\";\n            List<String> list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, getSpace() + \".\" + name);\n                }\n            }\n\n            return list;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to extract include target from provided content [\" + content + \"]\", e);\n\n            return null;\n        }\n    }\n\n    public List<String> getIncludedMacros(XWikiContext context)\n    {\n        return context.getWiki().getIncludedMacros(getSpace(), getContent(), context);\n    }\n\n    public String displayRendered(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n        throws XWikiException\n    {\n        String result = pclass.displayView(pclass.getName(), prefix, object, context);\n        return getRenderedContent(result, Syntax.XWIKI_1_0.toIdString(), context);\n    }\n\n    public String displayView(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayView(pclass.getName(), prefix, object, context);\n    }\n\n    public String displayEdit(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayEdit(pclass.getName(), prefix, object, context);\n    }\n\n    public String displayHidden(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayHidden(pclass.getName(), prefix, object, context);\n    }\n\n    /**\n     * Return the first attachment of the attachment list either exactly matching the provided filename or that matches \n     * the provided filename with a n arbitrary extension (i.e., filename.ext). To get only attachments that exactly\n     * matches the provided filename use {@link #getExactAttachment(String)}.\n     * \n     * @param filename the file name of the attachment with or without the extension\n     * @return the {@link XWikiAttachment} corresponding to the file name, null if none can be found\n     * @see #getExactAttachment(String) \n     */\n    public XWikiAttachment getAttachment(String filename)\n    {\n        XWikiAttachment output = this.attachmentList.getByFilename(filename);\n        if (output != null) {\n            return output;\n        }\n\n        for (XWikiAttachment attach : getAttachmentList()) {\n            if (attach.getFilename().startsWith(filename + \".\")) {\n                return attach;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Return the attachment that exactly matches the provided file. To also get the first attachment that matches the\n     * provided filename with an arbitrary extension use {@link #getAttachment(String)}.\n     *\n     * @param filename the file name of the attachment\n     * @return the {@link XWikiAttachment} exactly corresponding to the file name, null if none can be found\n     * @since 14.1RC1\n     * @since 13.10.3\n     */\n    public XWikiAttachment getExactAttachment(String filename)\n    {\n        return this.attachmentList.getByFilename(filename);\n    }\n\n    /**\n     * Add passed attachment to the document.\n     *\n     * @param attachment the attachment to add\n     * @since 5.3M2\n     * @deprecated use {@link #setAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated(since = \"9.10RC1\")\n    public void addAttachment(XWikiAttachment attachment)\n    {\n        setAttachment(attachment);\n    }\n\n    /**\n     * Insert passed attachment in the document and return any pre-existing attachment with the same name.\n     * \n     * @param attachment the attachment to insert in the document\n     * @return the attachment replaced by the passed attachment\n     * @since 9.10RC1\n     */\n    public XWikiAttachment setAttachment(XWikiAttachment attachment)\n    {\n        return this.attachmentList.set(attachment);\n    }\n\n    /**\n     * @deprecated use {@link #setAttachment(String, InputStream, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiAttachment addAttachment(String fileName, byte[] content, XWikiContext context) throws XWikiException\n    {\n        try {\n            return setAttachment(fileName, new ByteArrayInputStream(content != null ? content : new byte[0]), context);\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to set Attachment content\", e);\n        }\n    }\n\n    /**\n     * @param fileName the name of the attachment\n     * @param content the content of the attachment\n     * @param context the XWiki context\n     * @return the new attachment\n     * @throws XWikiException never sent\n     * @throws IOException when failing to read the passed content\n     * @deprecated use {@link #setAttachment(String, InputStream, XWikiContext)} instead\n     */\n    @Deprecated(since = \"9.10RC1\")\n    public XWikiAttachment addAttachment(String fileName, InputStream content, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        return setAttachment(fileName, content, context);\n    }\n\n    /**\n     * Create or update attachment with the passed name with the passed content.\n     * \n     * @param fileName the name of the attachment\n     * @param content the content of the attachment\n     * @param context the XWiki context\n     * @return the new attachment\n     * @throws IOException when failing to read the passed content\n     * @since 9.10rc1\n     */\n    public XWikiAttachment setAttachment(String fileName, InputStream content, XWikiContext context) throws IOException\n    {\n        int i = fileName.indexOf('\\\\');\n        if (i == -1) {\n            i = fileName.indexOf('/');\n        }\n\n        String filename = fileName.substring(i + 1);\n\n        XWikiAttachment attachment = getExactAttachment(filename);\n        if (attachment == null) {\n            attachment = new XWikiAttachment(this, filename);\n\n            // Add the attachment in the current doc\n            setAttachment(attachment);\n        }\n\n        attachment.setContent(content);\n        attachment.setAuthorReference(context.getUserReference());\n\n        return attachment;\n    }\n\n    public BaseObject getFirstObject(String fieldname)\n    {\n        // Keeping this function with context null for compatibility reasons.\n        // It should not be used, since it would miss properties which are only defined in the class\n        // and not present in the object because the object was not updated\n        return getFirstObject(fieldname, null);\n    }\n\n    public BaseObject getFirstObject(String fieldname, XWikiContext context)\n    {\n        Collection<List<BaseObject>> objectscoll = getXObjects().values();\n        if (objectscoll == null) {\n            return null;\n        }\n\n        for (List<BaseObject> objects : objectscoll) {\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    BaseClass bclass = obj.getXClass(context);\n                    if (bclass != null) {\n                        Set<String> set = bclass.getPropertyList();\n                        if ((set != null) && set.contains(fieldname)) {\n                            return obj;\n                        }\n                    }\n                    Set<String> set = obj.getPropertyList();\n                    if ((set != null) && set.contains(fieldname)) {\n                        return obj;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setProperty(EntityReference classReference, String fieldName, BaseProperty value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.safeput(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setProperty(EntityReference, String, BaseProperty)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setProperty(String className, String fieldName, BaseProperty value)\n    {\n        setProperty(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public int getIntValue(DocumentReference classReference, String fieldName)\n    {\n        return getIntValue(classReference, fieldName, 0);\n    }\n\n    /**\n     * Retrieve the int value of the given property of the first object of the given class.\n     *\n     * @param classReference the reference of the object to find\n     * @param fieldName the property to get the value from\n     * @param defaultValue the default value to return if the object doesn't exist, or if the property is not set\n     * @return the retrieved value or the default value.\n     * @since 11.9RC1\n     */\n    public int getIntValue(DocumentReference classReference, String fieldName, int defaultValue)\n    {\n        BaseObject obj = getXObject(classReference, 0);\n        if (obj == null) {\n            return defaultValue;\n        }\n\n        return obj.getIntValue(fieldName, defaultValue);\n    }\n\n    /**\n     * @deprecated use {@link #getIntValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public int getIntValue(String className, String fieldName)\n    {\n        return getIntValue(resolveClassReference(className), fieldName);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public long getLongValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference, 0);\n        if (obj == null) {\n            return 0;\n        }\n\n        return obj.getLongValue(fieldName);\n    }\n\n    /**\n     * @deprecated use {@link #getLongValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public long getLongValue(String className, String fieldName)\n    {\n        return getLongValue(resolveClassReference(className), fieldName);\n    }\n\n    /**\n     * @since 6.2M1\n     */\n    public String getStringValue(EntityReference classReference, String fieldName)\n    {\n        return getStringValue(resolveClassReference(classReference), fieldName);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public String getStringValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference);\n        if (obj == null) {\n            return \"\";\n        }\n\n        String result = obj.getStringValue(fieldName);\n        if (result.equals(\" \")) {\n            return \"\";\n        } else {\n            return result;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getStringValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public String getStringValue(String className, String fieldName)\n    {\n        return getStringValue(resolveClassReference(className), fieldName);\n    }\n\n    public int getIntValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return 0;\n        } else {\n            return object.getIntValue(fieldName);\n        }\n    }\n\n    public long getLongValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return 0;\n        } else {\n            return object.getLongValue(fieldName);\n        }\n    }\n\n    public String getStringValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return \"\";\n        }\n\n        String result = object.getStringValue(fieldName);\n        if (result.equals(\" \")) {\n            return \"\";\n        } else {\n            return result;\n        }\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setStringValue(EntityReference classReference, String fieldName, String value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setStringValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setStringValue(EntityReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setStringValue(String className, String fieldName, String value)\n    {\n        setStringValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public List getListValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference);\n        if (obj == null) {\n            return new ArrayList();\n        }\n\n        return obj.getListValue(fieldName);\n    }\n\n    /**\n     * @deprecated use {@link #getListValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List getListValue(String className, String fieldName)\n    {\n        return getListValue(resolveClassReference(className), fieldName);\n    }\n\n    public List getListValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return new ArrayList();\n        }\n\n        return object.getListValue(fieldName);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setStringListValue(EntityReference classReference, String fieldName, List value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setStringListValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setStringListValue(EntityReference, String, List)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setStringListValue(String className, String fieldName, List value)\n    {\n        setStringListValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setDBStringListValue(EntityReference classReference, String fieldName, List value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setDBStringListValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setDBStringListValue(EntityReference, String, List)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setDBStringListValue(String className, String fieldName, List value)\n    {\n        setDBStringListValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setLargeStringValue(EntityReference classReference, String fieldName, String value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setLargeStringValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setLargeStringValue(EntityReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setLargeStringValue(String className, String fieldName, String value)\n    {\n        setLargeStringValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setIntValue(EntityReference classReference, String fieldName, int value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setIntValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setIntValue(EntityReference, String, int)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setIntValue(String className, String fieldName, int value)\n    {\n        setIntValue(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getDatabase()\n    {\n        return getDocumentReference().getWikiReference().getName();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setDatabase(String database)\n    {\n        if (database != null) {\n            DocumentReference reference = getDocumentReference();\n            WikiReference wiki = reference.getWikiReference();\n            WikiReference newWiki = new WikiReference(database);\n            if (!newWiki.equals(wiki)) {\n                setDocumentReferenceInternal(reference.replaceParent(wiki, newWiki));\n            }\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getLocale()} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public String getLanguage()\n    {\n        return getLocale().toString();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #setLocale(Locale)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public void setLanguage(String language)\n    {\n        setLocale(LocaleUtils.toLocale(Util.normalizeLanguage(language), Locale.ROOT));\n    }\n\n    /**\n     * @return the locale of the document\n     */\n    public Locale getLocale()\n    {\n        return this.locale != null ? this.locale : Locale.ROOT;\n    }\n\n    /**\n     * @param locale the locale of the document\n     */\n    public void setLocale(Locale locale)\n    {\n        this.locale = locale;\n\n        setMetaDataDirty(true);\n\n        // Clean various caches\n\n        this.keyCache = null;\n        this.localKeyCache = null;\n        this.documentReferenceWithLocaleCache = null;\n        this.pageReferenceWithLocaleCache = null;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDefaultLocale()} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public String getDefaultLanguage()\n    {\n        return getDefaultLocale().toString();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #setDefaultLocale(Locale)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public void setDefaultLanguage(String defaultLanguage)\n    {\n        setDefaultLocale(LocaleUtils.toLocale(defaultLanguage, Locale.ROOT));\n    }\n\n    public Locale getDefaultLocale()\n    {\n        return this.defaultLocale != null ? this.defaultLocale : Locale.ROOT;\n    }\n\n    public void setDefaultLocale(Locale defaultLocale)\n    {\n        this.defaultLocale = defaultLocale;\n\n        setMetaDataDirty(true);\n    }\n\n    public int getTranslation()\n    {\n        return getLocale().equals(Locale.ROOT) ? 0 : 1;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's called by Hibernate when loading a XWikiDocument.\n     *\n     * @deprecated stored in the database to speedup some queries (really ?) but in {@link XWikiDocument}\n     *             it's calculated based on the document locale\n     */\n    @Deprecated(since = \"5.4.6\")\n    public void setTranslation(int translation)\n    {\n        // Do nothing\n    }\n\n    public String getTranslatedContent(XWikiContext context) throws XWikiException\n    {\n        String language = context.getWiki().getLanguagePreference(context);\n\n        return getTranslatedContent(language, context);\n    }\n\n    public String getTranslatedContent(String locale, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = getTranslatedDocument(locale, context);\n        return tdoc.getContent();\n    }\n\n    public XWikiDocument getTranslatedDocument(XWikiContext context) throws XWikiException\n    {\n        String locale = context.getWiki().getLanguagePreference(context);\n        return getTranslatedDocument(locale, context);\n    }\n\n    /**\n     * Return the document in the provided language.\n     * <p>\n     * This method return this if the provided language does not exists. See\n     *\n     * @param language the language of the document to return\n     * @param context the XWiki Context\n     * @return the document in the provided language or this if the provided language does not exists\n     * @throws XWikiException error when loading the document\n     * @deprecated use {@link #getTranslatedDocument(Locale, XWikiContext)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public XWikiDocument getTranslatedDocument(String language, XWikiContext context) throws XWikiException\n    {\n        return getTranslatedDocument(LocaleUtils.toLocale(language, Locale.ROOT), context);\n    }\n\n    /**\n     * Return the document in the provided language.\n     * <p>\n     * This method return this if the provided language does not exists. See\n     *\n     * @param locale the locale of the document to return\n     * @param context the XWiki Context\n     * @return the document in the provided language or this if the provided language does not exists\n     * @throws XWikiException error when loading the document\n     */\n    public XWikiDocument getTranslatedDocument(Locale locale, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = this;\n\n        if (locale != null && !locale.equals(Locale.ROOT) && !locale.equals(getDefaultLocale())) {\n            try {\n                tdoc = context.getWiki().getDocument(new DocumentReference(getDocumentReference(), locale), context);\n\n                if (!tdoc.isNew()) {\n                    return tdoc;\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Error when loading document {} for locale {}\", getDocumentReference(), locale, e);\n            }\n\n            tdoc = getTranslatedDocument(LocaleUtils.getParentLocale(locale), context);\n        }\n\n        return tdoc;\n    }\n\n    /**\n     * @deprecated use {@link #getRealLocale()} instead\n     */\n    @Deprecated(since = \"4.3M1\")\n    public String getRealLanguage(XWikiContext context) throws XWikiException\n    {\n        return getRealLanguage();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see org.xwiki.bridge.DocumentModelBridge#getRealLanguage()\n     * @deprecated use {@link #getRealLocale()} instead\n     */\n    @Override\n    @Deprecated(since = \"4.3M1\")\n    public String getRealLanguage()\n    {\n        String lang = getLanguage();\n        if (lang.equals(\"\")) {\n            return getDefaultLanguage();\n        } else {\n            return lang;\n        }\n    }\n\n    /**\n     * @return the actual locale of the document\n     */\n    public Locale getRealLocale()\n    {\n        Locale locale = getLocale();\n        if (locale.equals(Locale.ROOT)) {\n            locale = getDefaultLocale();\n        }\n\n        return locale;\n    }\n\n    /**\n     * @deprecated use {@link #getTranslationLocales(XWikiContext)} instead\n     */\n    @Deprecated(since = \"5.1M2\")\n    public List<String> getTranslationList(XWikiContext context) throws XWikiException\n    {\n        // in few cases like accessing a deleted document, the store might be null.\n        if (getStore() != null) {\n            return getStore().getTranslationList(this, context);\n        } else {\n            return Collections.emptyList();\n        }\n\n    }\n\n    /**\n     * The locales of the translation of this document (the default locale is not included).\n     *\n     * @param context the XWiki context\n     * @return the locales of the translations\n     * @throws XWikiException if retriving the translations from the database failed\n     */\n    public List<Locale> getTranslationLocales(XWikiContext context) throws XWikiException\n    {\n        List<String> translations = getTranslationList(context);\n\n        List<Locale> locales = new ArrayList<Locale>(translations.size());\n        for (String translationString : translations) {\n            locales.add(LocaleUtils.toLocale(translationString));\n        }\n\n        return locales;\n    }\n\n    public List<Delta> getXMLDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        return getDeltas(\n            Diff.diff(ToString.stringToArray(fromDoc.toXML(context)), ToString.stringToArray(toDoc.toXML(context))));\n    }\n\n    public List<Delta> getContentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        return getDeltas(\n            Diff.diff(ToString.stringToArray(fromDoc.getContent()), ToString.stringToArray(toDoc.getContent())));\n    }\n\n    public List<Delta> getContentDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n        if (fromDoc == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                String.format(\"The revision [%s] cannot be found in [%s] for making diff.\", fromRev,\n                    this.getDocumentReference()));\n        }\n        if (toRev == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                String.format(\"The revision [%s] cannot be found in [%s] for making diff.\", toRev,\n                    this.getDocumentReference()));\n        }\n        return getContentDiff(fromDoc, toDoc, context);\n    }\n\n    public List<Delta> getContentDiff(String fromRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n        return getContentDiff(revdoc, this, context);\n    }\n\n    public List<Delta> getLastChanges(XWikiContext context) throws XWikiException, DifferentiationFailedException\n    {\n        Version version = getRCSVersion();\n        try {\n            String prev = getDocumentArchive(context).getPrevVersion(version).toString();\n            XWikiDocument prevDoc = context.getWiki().getDocument(this, prev, context);\n\n            return getDeltas(\n                Diff.diff(ToString.stringToArray(prevDoc.getContent()), ToString.stringToArray(getContent())));\n        } catch (Exception ex) {\n            LOGGER.debug(\"Exception getting differences from previous version: \" + ex.getMessage());\n        }\n\n        return new ArrayList<Delta>();\n    }\n\n    public List<Delta> getRenderedContentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        String originalContent = fromDoc.getRenderedContent(context);\n        String newContent = toDoc.getRenderedContent(context);\n\n        return getDeltas(Diff.diff(ToString.stringToArray(originalContent), ToString.stringToArray(newContent)));\n    }\n\n    public List<Delta> getRenderedContentDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getRenderedContentDiff(fromDoc, toDoc, context);\n    }\n\n    public List<Delta> getRenderedContentDiff(String fromRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getRenderedContentDiff(revdoc, this, context);\n    }\n\n    protected List<Delta> getDeltas(Revision rev)\n    {\n        List<Delta> list = new ArrayList<Delta>();\n        for (int i = 0; i < rev.size(); i++) {\n            list.add(rev.getDelta(i));\n        }\n\n        return list;\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(String fromRev, String toRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getMetaDataDiff(fromDoc, toDoc, context);\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(String fromRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getMetaDataDiff(revdoc, this, context);\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException\n    {\n        List<MetaDataDiff> list = new ArrayList<MetaDataDiff>();\n\n        if (fromDoc == null || toDoc == null) {\n            return list;\n        }\n\n        if (!fromDoc.getTitle().equals(toDoc.getTitle())) {\n            list.add(new MetaDataDiff(\"title\", fromDoc.getTitle(), toDoc.getTitle()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getRelativeParentReference(), toDoc.getRelativeParentReference())) {\n            list.add(new MetaDataDiff(\"parent\", fromDoc.getParent(), toDoc.getParent()));\n        }\n\n        UserReference fromDocOriginalAuthor = fromDoc.getAuthors().getOriginalMetadataAuthor();\n        UserReference toDocOriginalAuthor = toDoc.getAuthors().getOriginalMetadataAuthor();\n        if (ObjectUtils.notEqual(fromDocOriginalAuthor, toDocOriginalAuthor)) {\n            list.add(new MetaDataDiff(\"author\", userReferenceToString(fromDocOriginalAuthor),\n                userReferenceToString(toDocOriginalAuthor)));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getDocumentReference(), toDoc.getDocumentReference())) {\n            list.add(new MetaDataDiff(\"reference\", fromDoc.getDocumentReference(), toDoc.getDocumentReference()));\n        }\n\n        if (!fromDoc.getSpace().equals(toDoc.getSpace())) {\n            list.add(new MetaDataDiff(\"web\", fromDoc.getSpace(), toDoc.getSpace()));\n        }\n\n        if (!fromDoc.getName().equals(toDoc.getName())) {\n            list.add(new MetaDataDiff(\"name\", fromDoc.getName(), toDoc.getName()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getLocale(), toDoc.getLocale())) {\n            list.add(new MetaDataDiff(\"language\", fromDoc.getLanguage(), toDoc.getLanguage()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getDefaultLocale(), toDoc.getDefaultLocale())) {\n            list.add(new MetaDataDiff(\"defaultLanguage\", fromDoc.getDefaultLanguage(), toDoc.getDefaultLanguage()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getSyntax(), toDoc.getSyntax())) {\n            list.add(new MetaDataDiff(\"syntax\", fromDoc.getSyntax(), toDoc.getSyntax()));\n        }\n\n        if (fromDoc.isHidden() != toDoc.isHidden()) {\n            list.add(new MetaDataDiff(\"hidden\", fromDoc.isHidden(), toDoc.isHidden()));\n        }\n\n        return list;\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getObjectDiff(fromDoc, toDoc, context);\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(String fromRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getObjectDiff(revdoc, this, context);\n    }\n\n    /**\n     * Return the object differences between two document versions. There is no hard requirement on the order of the two\n     * versions, but the results are semantically correct only if the two versions are given in the right order.\n     *\n     * @param fromDoc The old ('before') version of the document.\n     * @param toDoc The new ('after') version of the document.\n     * @param context The {@link com.xpn.xwiki.XWikiContext context}.\n     * @return The object differences. The returned list's elements are other lists, one for each changed object. The\n     *         inner lists contain {@link ObjectDiff} elements, one object for each changed property of the object.\n     *         Additionally, if the object was added or removed, then the first entry in the list will be an\n     *         \"object-added\" or \"object-removed\" marker.\n     */\n    public List<List<ObjectDiff>> getObjectDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();\n\n        // Since objects could have been deleted or added, we iterate on both the old and the new\n        // object collections.\n        // First, iterate over the old objects.\n        for (List<BaseObject> objects : fromDoc.getXObjects().values()) {\n            for (BaseObject originalObj : objects) {\n                // This happens when objects are deleted, and the document is still in the cache\n                // storage.\n                if (originalObj != null) {\n                    BaseObject newObj = toDoc.getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                    List<ObjectDiff> dlist;\n                    if (newObj == null) {\n                        // The object was deleted.\n                        dlist = new BaseObject().getDiff(originalObj, context);\n                        ObjectDiff deleteMarker =\n                            new ObjectDiff(originalObj.getXClassReference(), originalObj.getNumber(),\n                                originalObj.getGuid(), ObjectDiff.ACTION_OBJECTREMOVED, \"\", \"\", \"\", \"\");\n                        dlist.add(0, deleteMarker);\n                    } else {\n                        // The object exists in both versions, but might have been changed.\n                        dlist = newObj.getDiff(originalObj, context);\n                    }\n                    if (!dlist.isEmpty()) {\n                        difflist.add(dlist);\n                    }\n                }\n            }\n        }\n\n        // Second, iterate over the objects which are only in the new version.\n        for (List<BaseObject> objects : toDoc.getXObjects().values()) {\n            for (BaseObject newObj : objects) {\n                // This happens when objects are deleted, and the document is still in the cache\n                // storage.\n                if (newObj != null) {\n                    BaseObject originalObj = fromDoc.getXObject(newObj.getXClassReference(), newObj.getNumber());\n                    if (originalObj == null) {\n                        // TODO: Refactor this so that getDiff() accepts null Object as input.\n                        // Only consider added objects, the other case was treated above.\n                        originalObj = new BaseObject();\n                        originalObj.setXClassReference(newObj.getRelativeXClassReference());\n                        originalObj.setNumber(newObj.getNumber());\n                        originalObj.setGuid(newObj.getGuid());\n                        List<ObjectDiff> dlist = newObj.getDiff(originalObj, context);\n                        ObjectDiff addMarker = new ObjectDiff(newObj.getXClassReference(), newObj.getNumber(),\n                            newObj.getGuid(), ObjectDiff.ACTION_OBJECTADDED, \"\", \"\", \"\", \"\");\n                        dlist.add(0, addMarker);\n                        if (!dlist.isEmpty()) {\n                            difflist.add(dlist);\n                        }\n                    }\n                }\n            }\n        }\n\n        return difflist;\n    }\n\n    public List<List<ObjectDiff>> getClassDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();\n        BaseClass oldClass = fromDoc.getXClass();\n        BaseClass newClass = toDoc.getXClass();\n\n        if ((newClass == null) && (oldClass == null)) {\n            return difflist;\n        }\n\n        List<ObjectDiff> dlist = newClass.getDiff(oldClass, context);\n        if (!dlist.isEmpty()) {\n            difflist.add(dlist);\n        }\n\n        return difflist;\n    }\n\n    /**\n     * @param fromDoc\n     * @param toDoc\n     * @param context\n     * @return\n     */\n    public List<AttachmentDiff> getAttachmentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<AttachmentDiff> difflist = new ArrayList<AttachmentDiff>();\n        for (XWikiAttachment origAttach : fromDoc.getAttachmentList()) {\n            String fileName = origAttach.getFilename();\n            XWikiAttachment newAttach = toDoc.getAttachment(fileName);\n            origAttach = retrieveDeletedAttachment(fromDoc, origAttach, context);\n            if (newAttach == null) {\n                difflist.add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.DELETE, origAttach, newAttach));\n            } else {\n                newAttach = retrieveDeletedAttachment(toDoc, newAttach, context);\n                try {\n                    if (!origAttach.equalsData(newAttach, context)) {\n                        difflist\n                            .add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.CHANGE, origAttach, newAttach));\n                    }\n                } catch (XWikiException e) {\n                    LOGGER.error(\"Failed to compare attachments [{}] and [{}]\", origAttach.getReference(),\n                        newAttach.getReference(), e);\n                }\n            }\n        }\n\n        for (XWikiAttachment newAttach : toDoc.getAttachmentList()) {\n            String fileName = newAttach.getFilename();\n            XWikiAttachment origAttach = fromDoc.getAttachment(fileName);\n            newAttach = retrieveDeletedAttachment(toDoc, newAttach, context);\n            if (origAttach == null) {\n                difflist.add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.INSERT, origAttach, newAttach));\n            }\n        }\n\n        return difflist;\n    }\n\n    private XWikiAttachment retrieveDeletedAttachment(XWikiDocument doc, XWikiAttachment attachment,\n        XWikiContext context)\n    {\n        XWikiAttachment result = null;\n\n        InputStream is = null;\n        try {\n            is = attachment.getContentInputStream(context);\n            if (is == null) {\n                AttachmentRecycleBinStore attachmentRecycleBinStore = context.getWiki().getAttachmentRecycleBinStore();\n                List<DeletedAttachment> allDeletedAttachments =\n                    attachmentRecycleBinStore.getAllDeletedAttachments(doc, context, true);\n\n                for (DeletedAttachment deletedAttachment : allDeletedAttachments) {\n                    XWikiAttachment restoredAttachment = deletedAttachment.restoreAttachment();\n                    if (restoredAttachment.getDate().before(attachment.getDate())) {\n                        break;\n                    }\n                    result = restoredAttachment;\n                }\n\n                if (result != null) {\n                    if (!Objects.equals(attachment.getVersion(), result.getVersion())) {\n                        result = result.getAttachmentRevision(attachment.getVersion(), context);\n                    }\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Error while trying to load deleted attachment [{}] for doc [{}]\", attachment, doc, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException ex) {\n\n                }\n            }\n        }\n\n        if (result == null) {\n            result = attachment;\n        } else {\n            result.setDoc(doc);\n        }\n        return result;\n    }\n\n    /**\n     * Rename the current document and all the backlinks leading to it. Will also change parent field in all documents\n     * which list the document we are renaming as their parent.\n     * <p>\n     * See {@link #rename(DocumentReference, List, List, XWikiContext)} for more details.\n     *\n     * @param newDocumentReference the new document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentReference, getBackLinkedReferences(context), context);\n    }\n\n    /**\n     * Rename the current document and all the links pointing to it in the list of passed backlink documents. The\n     * renaming algorithm takes into account the fact that there are several ways to write a link to a given page and\n     * all those forms need to be renamed. For example the following links all point to the same page:\n     * <ul>\n     * <li>[Page]</li>\n     * <li>[Page?param=1]</li>\n     * <li>[currentwiki:Page]</li>\n     * <li>[CurrentSpace.Page]</li>\n     * <li>[currentwiki:CurrentSpace.Page]</li>\n     * </ul>\n     * <p>\n     * Note: links without a space are renamed with the space added and all documents which have the document being\n     * renamed as parent have their parent field set to \"currentwiki:CurrentSpace.Page\".\n     * </p>\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentReference, backlinkDocumentReferences, getChildrenReferences(context), context);\n    }\n\n    /**\n     * Same as {@link #rename(DocumentReference, List, XWikiContext)} but the list of documents having the current\n     * document as their parent is passed in parameter.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context) throws XWikiException\n    {\n        // TODO: Do all this in a single DB transaction as otherwise the state will be unknown if\n        // something fails in the middle...\n\n        // TODO: Why do we verify if the document has just been created and not been saved.\n        // If the user is trying to rename to the same name... In that case, simply exits for efficiency.\n        if (isNew() || getDocumentReference().equals(newDocumentReference)) {\n            return;\n        }\n        context.getWiki().renameByCopyAndDelete(this,\n            newDocumentReference,\n            backlinkDocumentReferences,\n            childDocumentReferences, context);\n    }\n\n    /**\n     * Clone a document and change its reference.\n     *\n     * @param newDocumentReference the new reference of the cloned document.\n     * @param context the current context.\n     * @return a clone of the current document with a new reference.\n     * @throws XWikiException in case of problem during the clone operation.\n     * @since 12.5RC1\n     */\n    public XWikiDocument cloneRename(DocumentReference newDocumentReference, XWikiContext context) throws XWikiException\n    {\n        loadAttachments(context);\n        loadArchive(context);\n        return this.cloneInternal(newDocumentReference, true, true);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public XWikiDocument copyDocument(DocumentReference newDocumentReference, XWikiContext context)\n        throws XWikiException\n    {\n        return copyDocument(newDocumentReference, true, context);\n    }\n\n    /**\n     * @since 14.3RC1\n     */\n    public XWikiDocument copyDocument(DocumentReference newDocumentReference, boolean cloneArchive, XWikiContext context)\n        throws XWikiException\n    {\n        loadAttachments(context);\n        if (cloneArchive) {\n            loadArchive(context);\n        }\n\n        XWikiDocument newdoc = cloneInternal(newDocumentReference, false, cloneArchive);\n\n        // If the copied document has a title set to the original page name then set the new title to be the new page\n        // name.\n        if (StringUtils.equals(newdoc.getTitle(), getPrettyName(this.getDocumentReference()))) {\n            newdoc.setTitle(getPrettyName(newDocumentReference));\n        }\n\n        newdoc.setOriginalDocument(null);\n        newdoc.setContentDirty(true);\n        newdoc.setNew(true);\n\n        return newdoc;\n    }\n\n    /**\n     * Avoid the technical \"WebHome\" name.\n     *\n     * @param documentReference a document reference\n     * @return the last space name if the document is the home of a space, the document name otherwise\n     */\n    private String getPrettyName(DocumentReference documentReference)\n    {\n        EntityReferenceProvider defaultEntityReferenceProvider = Utils.getComponent(EntityReferenceProvider.class);\n        if (defaultEntityReferenceProvider.getDefaultReference(documentReference.getType()).getName()\n            .equals(documentReference.getName())) {\n            return documentReference.getLastSpaceReference().getName();\n        }\n        return documentReference.getName();\n    }\n\n    /**\n     * @deprecated use {@link #copyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument copyDocument(String newDocumentName, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(getCurrentMixedDocumentReferenceResolver().resolve(newDocumentName), context);\n    }\n\n    public XWikiLock getLock(XWikiContext context) throws XWikiException\n    {\n        XWikiLock theLock = getStore(context).loadLock(getId(), context, true);\n        if (theLock != null) {\n            int timeout = context.getWiki().getXWikiPreferenceAsInt(\"lock_Timeout\", 30 * 60, context);\n            if (theLock.getDate().getTime() + timeout * 1000 < new Date().getTime()) {\n                getStore(context).deleteLock(theLock, context, true);\n                theLock = null;\n            }\n        }\n\n        return theLock;\n    }\n\n    public void setLock(String userName, XWikiContext context) throws XWikiException\n    {\n        XWikiLock lock = new XWikiLock(getId(), userName);\n        getStore(context).saveLock(lock, context, true);\n    }\n\n    public void removeLock(XWikiContext context) throws XWikiException\n    {\n        XWikiLock lock = getStore(context).loadLock(getId(), context, true);\n        if (lock != null) {\n            getStore(context).deleteLock(lock, context, true);\n        }\n    }\n\n    public void insertText(String text, String marker, XWikiContext context) throws XWikiException\n    {\n        setContent(StringUtils.replaceOnce(getContent(), marker, text + marker));\n        context.getWiki().saveDocument(this, context);\n    }\n\n    public Object getWikiNode()\n    {\n        return this.wikiNode;\n    }\n\n    public void setWikiNode(Object wikiNode)\n    {\n        this.wikiNode = wikiNode;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String getXClassXML()\n    {\n        return this.xClassXML;\n    }\n\n    /**\n     * @deprecated use {@link #getXClassXML()} instead as Hibernate uses this through reflection. It cannot be\n     *             removed without altering hibernate.cfg.xml\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getxWikiClassXML()\n    {\n        return getXClassXML();\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXClassXML(String xClassXML)\n    {\n        this.xClassXML = xClassXML;\n    }\n\n    /**\n     * @deprecated use {@link #setXClassXML(String)} ()} instead as Hibernate uses this through reflection. It\n     *             cannot be removed without altering hibernate.cfg.xml\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setxWikiClassXML(String xClassXML)\n    {\n        setXClassXML(xClassXML);\n    }\n\n    public int getElements()\n    {\n        return this.elements;\n    }\n\n    public void setElements(int elements)\n    {\n        this.elements = elements;\n    }\n\n    public void setElement(int element, boolean toggle)\n    {\n        if (toggle) {\n            this.elements = this.elements | element;\n        } else {\n            this.elements = this.elements & (~element);\n        }\n    }\n\n    public boolean hasElement(int element)\n    {\n        return ((this.elements & element) == element);\n    }\n\n    /**\n     * Gets the default edit mode for this document. An edit mode (other than the default \"edit\") can be enforced by\n     * creating an {@code XWiki.EditModeClass} object in the current document, with the appropriate value for the\n     * defaultEditMode property, or by adding this object in a sheet included by the document. This function also falls\n     * back on the old {@code SheetClass}, deprecated since 3.1M2, which can be attached to included documents to\n     * specify that the current document should be edited inline.\n     *\n     * @return the default edit mode for this document (\"edit\" or \"inline\" usually)\n     * @param context the context of the request for this document\n     * @throws XWikiException since XWiki 6.3M1 it's not used anymore and \"edit\" is returned in case of error, with an\n     *             error log\n     */\n    public String getDefaultEditMode(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getDefaultEditModeInternal(context);\n        } catch (Exception e) {\n            // If an error happens then we default to the \"edit\" mode. We don't want to fail by throwing an exception\n            // since it'll lead to several errors in the UI (such as when evaluating contentview.vm for example).\n            LOGGER.error(\"Failed to get the default edit mode for [{}]\", getDocumentReference(), e);\n            return \"edit\";\n        }\n    }\n\n    private String getDefaultEditModeInternal(XWikiContext context) throws XWikiException\n    {\n        String editModeProperty = \"defaultEditMode\";\n        DocumentReference editModeClass =\n            getCurrentReferenceDocumentReferenceResolver().resolve(XWikiConstant.EDIT_MODE_CLASS);\n        // check if the current document has any edit mode class object attached to it, and read the edit mode from it\n        BaseObject editModeObject = this.getXObject(editModeClass);\n        if (editModeObject != null) {\n            String defaultEditMode = editModeObject.getStringValue(editModeProperty);\n            if (StringUtils.isEmpty(defaultEditMode)) {\n                return \"edit\";\n            } else {\n                return defaultEditMode;\n            }\n        }\n        // otherwise look for included documents\n        com.xpn.xwiki.XWiki xwiki = context.getWiki();\n        if (is10Syntax()) {\n            if (getContent().indexOf(\"includeForm(\") != -1) {\n                return \"inline\";\n            }\n        } else {\n            // Algorithm: look in all include macros and for all document included check if one of them\n            // has an EditModeClass object attached to it, or a SheetClass object (deprecated since 3.1M2) attached to\n            // it. If so then the edit mode is inline.\n\n            // Find all include macros and extract the document names\n            // TODO: Is there a good way not to hardcode the macro name? The macro itself shouldn't know\n            // its own name since it's a deployment time concern.\n            for (Block macroBlock : getXDOM().getBlocks(new MacroBlockMatcher(\"include\"), Axes.CHILD)) {\n                // Find the document reference to include by checking the macro's \"reference\" parameter.\n                // For backward-compatibility we also check for a \"document\" parameter since this is the parameter name\n                // that was used prior to XWiki 3.4M1 when the \"reference\" one was introduced and thus when the\n                // \"document\" one was deprecated.\n                String includedDocumentReference = macroBlock.getParameter(\"reference\");\n                if (includedDocumentReference == null) {\n                    includedDocumentReference = macroBlock.getParameter(\"document\");\n                }\n                if (includedDocumentReference != null) {\n                    // Resolve the document name into a valid Reference\n                    DocumentReference documentReference =\n                        getCurrentMixedDocumentReferenceResolver().resolve(includedDocumentReference);\n                    XWikiDocument includedDocument = xwiki.getDocument(documentReference, context);\n                    if (!includedDocument.isNew()) {\n                        // get the edit mode object, first the new class and then the deprecated class if new class\n                        // is not found\n                        editModeObject = includedDocument.getXObject(editModeClass);\n                        if (editModeObject == null) {\n                            editModeObject = includedDocument.getXObject(SHEETCLASS_REFERENCE);\n                        }\n                        if (editModeObject != null) {\n                            // Use the user-defined default edit mode if set.\n                            String defaultEditMode = editModeObject.getStringValue(editModeProperty);\n                            if (StringUtils.isBlank(defaultEditMode)) {\n                                // TODO: maybe here the real value should be returned if the object is edit mode class,\n                                // and inline only if the object is sheetclass\n                                return \"inline\";\n                            } else {\n                                return defaultEditMode;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return \"edit\";\n    }\n\n    public String getDefaultEditURL(XWikiContext context) throws XWikiException\n    {\n        String editMode = getDefaultEditMode(context);\n\n        if (\"inline\".equals(editMode)) {\n            return getEditURL(\"inline\", \"\", context);\n        } else {\n            com.xpn.xwiki.XWiki xwiki = context.getWiki();\n            String editor = xwiki.getEditorPreference(context);\n            return getEditURL(\"edit\", editor, context);\n        }\n    }\n\n    public String getEditURL(String action, String mode, XWikiContext context) throws XWikiException\n    {\n        com.xpn.xwiki.XWiki xwiki = context.getWiki();\n        String language = \"\";\n        XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n        String realLang = tdoc.getRealLanguage(context);\n        if ((xwiki.isMultiLingual(context) == true) && (!realLang.equals(\"\"))) {\n            language = realLang;\n        }\n\n        return getEditURL(action, mode, language, context);\n    }\n\n    public String getEditURL(String action, String mode, String language, XWikiContext context)\n    {\n        StringBuilder editparams = new StringBuilder();\n        if (!mode.equals(\"\")) {\n            editparams.append(\"xpage=\");\n            editparams.append(mode);\n        }\n\n        if (!language.equals(\"\")) {\n            if (!mode.equals(\"\")) {\n                editparams.append(\"&\");\n            }\n            editparams.append(\"language=\");\n            editparams.append(language);\n        }\n\n        return getURL(action, editparams.toString(), context);\n    }\n\n    public String getDefaultTemplate()\n    {\n        if (this.defaultTemplate == null) {\n            return \"\";\n        } else {\n            return this.defaultTemplate;\n        }\n    }\n\n    public void setDefaultTemplate(String defaultTemplate)\n    {\n        this.defaultTemplate = defaultTemplate;\n\n        setMetaDataDirty(true);\n    }\n\n    public Vector<BaseObject> getComments()\n    {\n        return getComments(true);\n    }\n\n    /**\n     * @return the syntax of the document\n     * @since 2.3M1\n     */\n    @Override\n    public Syntax getSyntax()\n    {\n        // Can't be initialized in the XWikiDocument constructor because #getDefaultDocumentSyntax() need to create a\n        // XWikiDocument object to get preferences from wiki preferences pages and would thus generate an infinite loop\n        if (isNew() && this.syntax == null) {\n            this.syntax = getDefaultDocumentSyntax();\n        }\n\n        return this.syntax;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     * </p>\n     *\n     * @see org.xwiki.bridge.DocumentModelBridge#getSyntaxId()\n     * @deprecated use {link #getSyntax()} instead\n     */\n    @Override\n    @Deprecated(since = \"2.3M1\")\n    public String getSyntaxId()\n    {\n        return getSyntax().toIdString();\n    }\n\n    /**\n     * @param syntax the new syntax to set for this document\n     * @see #getSyntax()\n     * @since 2.3M1\n     */\n    public void setSyntax(Syntax syntax)\n    {\n        if (ObjectUtils.notEqual(this.syntax, syntax)) {\n            this.syntax = syntax;\n            // invalidate parsed xdom\n            this.xdomCache = null;\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @param syntaxId the new syntax id to set (e.g. {@code xwiki/2.0}, {@code xwiki/2.1}, etc)\n     * @see #getSyntaxId()\n     * @deprecated use {link #setSyntax(Syntax)} instead\n     */\n    @Deprecated(since = \"2.3M1\")\n    public void setSyntaxId(String syntaxId)\n    {\n        Syntax syntax;\n\n        // In order to preserve backward-compatibility with previous versions of XWiki in which the notion of Syntax Id\n        // did not exist, we check the passed syntaxId parameter. Since this parameter comes from the database (it's\n        // called automatically by Hibernate) it can be NULL or empty. In this case we consider the document is in\n        // syntax/1.0 syntax.\n        if (StringUtils.isBlank(syntaxId)) {\n            syntax = Syntax.XWIKI_1_0;\n        } else {\n            syntax = resolveSyntax(syntaxId);\n        }\n\n        setSyntax(syntax);\n    }\n\n    public Vector<BaseObject> getComments(boolean asc)\n    {\n        List<BaseObject> list = getXObjects(COMMENTSCLASS_REFERENCE);\n        if (list == null) {\n            return null;\n        } else if (asc) {\n            return new Vector<BaseObject>(list);\n        } else {\n            Vector<BaseObject> newlist = new Vector<BaseObject>();\n            for (int i = list.size() - 1; i >= 0; i--) {\n                newlist.add(list.get(i));\n            }\n            return newlist;\n        }\n    }\n\n    public boolean isCurrentUserCreator(XWikiContext context)\n    {\n        return isCreator(context.getUserReference());\n    }\n\n    /**\n     * @deprecated use {@link #isCreator(DocumentReference)} instead\n     */\n    @Deprecated\n    public boolean isCreator(String username)\n    {\n        if (username.equals(XWikiRightService.GUEST_USER_FULLNAME)) {\n            return false;\n        }\n\n        return username.equals(getCreator());\n    }\n\n    public boolean isCreator(DocumentReference username)\n    {\n        if (username == null) {\n            return false;\n        }\n\n        return username.equals(getCreatorReference());\n    }\n\n    public boolean isCurrentUserPage(XWikiContext context)\n    {\n        DocumentReference userReference = context.getUserReference();\n        if (userReference == null) {\n            return false;\n        }\n\n        return userReference.equals(getDocumentReference());\n    }\n\n    public boolean isCurrentLocalUserPage(XWikiContext context)\n    {\n        final DocumentReference userRef = context.getUserReference();\n        return userRef != null && userRef.equals(this.getDocumentReference());\n    }\n\n    public void resetArchive(XWikiContext context) throws XWikiException\n    {\n        boolean hasVersioning = context.getWiki().hasVersioning(context);\n        if (hasVersioning) {\n            WikiReference currentWiki = context.getWikiReference();\n            try {\n                context.setWikiReference(getDocumentReference().getWikiReference());\n\n                getVersioningStore(context).resetRCSArchive(this, true, context);\n            } finally {\n                context.setWikiReference(currentWiki);\n            }\n        }\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(XWikiContext context) throws XWikiException\n    {\n        // Read info in object\n        ObjectAddForm form = new ObjectAddForm();\n        form.setRequest(context.getRequest());\n        form.readRequest();\n\n        EntityReference classReference = getXClassEntityReferenceResolver().resolve(form.getClassName(),\n            EntityType.DOCUMENT, getDocumentReference());\n        BaseObject object = newXObject(classReference, context);\n        BaseClass baseclass = object.getXClass(context);\n        baseclass.fromMap(form.getObject(LOCAL_REFERENCE_SERIALIZER.serialize(resolveClassReference(classReference))),\n            object);\n\n        return object;\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject addXObjectFromRequest(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, \"\", 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, \"\", 0, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(DocumentReference classReference, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, prefix, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(DocumentReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, String prefix, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, prefix, 0, context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2M2\n     */\n    public List<BaseObject> addXObjectsFromRequest(DocumentReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectsFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectsFromRequest(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> addObjectsFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return addObjectsFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2M2\n     */\n    public List<BaseObject> addXObjectsFromRequest(DocumentReference classReference, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String[]> map = context.getRequest().getParameterMap();\n        List<Integer> objectsNumberDone = new ArrayList<Integer>();\n        List<BaseObject> objects = new ArrayList<BaseObject>();\n        String start = pref + LOCAL_REFERENCE_SERIALIZER.serialize(classReference) + \"_\";\n\n        for (String name : map.keySet()) {\n            if (name.startsWith(start)) {\n                int pos = name.indexOf('_', start.length() + 1);\n                String prefix = name.substring(0, pos);\n                int num = Integer.decode(prefix.substring(prefix.lastIndexOf('_') + 1)).intValue();\n                if (!objectsNumberDone.contains(Integer.valueOf(num))) {\n                    objectsNumberDone.add(Integer.valueOf(num));\n                    objects.add(addXObjectFromRequest(classReference, pref, num, context));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectsFromRequest(DocumentReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> addObjectsFromRequest(String className, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectsFromRequest(resolveClassReference(className), pref, context);\n    }\n\n    /**\n     * Adds object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(DocumentReference classReference, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, \"\", num, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(DocumentReference, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, int num, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, \"\", num, context);\n    }\n\n    /**\n     * Adds object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject addXObjectFromRequest(EntityReference classReference, String prefix, int num,\n        XWikiContext context) throws XWikiException\n    {\n        BaseObject object = newXObject(classReference, context);\n        BaseClass baseclass = object.getXClass(context);\n        String newPrefix =\n            prefix + LOCAL_REFERENCE_SERIALIZER.serialize(resolveClassReference(classReference)) + \"_\" + num;\n        baseclass.fromMap(Util.getObject(context.getRequest(), newPrefix), object);\n\n        return object;\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(EntityReference, String, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, String prefix, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(resolveClassReference(className), prefix, num, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return updateObjectFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(classReference, prefix, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return updateObjectFromRequest(className, prefix, 0, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, String prefix, int num,\n        XWikiContext context) throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        int nb;\n        BaseObject oldobject = getXObject(absoluteClassReference, num);\n        if (oldobject == null) {\n            nb = createXObject(classReference, context);\n            oldobject = getXObject(absoluteClassReference, nb);\n        } else {\n            nb = oldobject.getNumber();\n        }\n        BaseClass baseclass = oldobject.getXClass(context);\n        String newPrefix = prefix + LOCAL_REFERENCE_SERIALIZER.serialize(absoluteClassReference) + \"_\" + nb;\n        BaseObject newobject =\n            (BaseObject) baseclass.fromMap(Util.getObject(context.getRequest(), newPrefix), oldobject);\n        newobject.setNumber(oldobject.getNumber());\n        newobject.setGuid(oldobject.getGuid());\n        setXObject(nb, newobject);\n\n        return newobject;\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, String, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, String prefix, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), prefix,\n            num, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public List<BaseObject> updateXObjectsFromRequest(EntityReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectsFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectsFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> updateObjectsFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return updateObjectsFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2.3\n     */\n    public List<BaseObject> updateXObjectsFromRequest(EntityReference classReference, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String[]> map = context.getRequest().getParameterMap();\n        List<Integer> objectsNumberDone = new ArrayList<Integer>();\n        List<BaseObject> objects = new ArrayList<BaseObject>();\n        String start = pref + LOCAL_REFERENCE_SERIALIZER.serialize(absoluteClassReference) + \"_\";\n\n        for (String name : map.keySet()) {\n            if (name.startsWith(start)) {\n                int pos = name.indexOf('_', start.length() + 1);\n                String prefix = name.substring(0, pos);\n                int num = Integer.decode(prefix.substring(prefix.lastIndexOf('_') + 1)).intValue();\n                if (!objectsNumberDone.contains(Integer.valueOf(num))) {\n                    objectsNumberDone.add(Integer.valueOf(num));\n                    objects.add(updateXObjectFromRequest(classReference, pref, num, context));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectsFromRequest(EntityReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> updateObjectsFromRequest(String className, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectsFromRequest(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), pref,\n            context);\n    }\n\n    public boolean isAdvancedContent()\n    {\n        String[] matches = { \"<%\", \"#set\", \"#include\", \"#if\", \"public class\", \"/* Advanced content */\",\n        \"## Advanced content\", \"/* Programmatic content */\", \"## Programmatic content\" };\n        String content2 = getContent().toLowerCase();\n        for (String match : matches) {\n            if (content2.indexOf(match.toLowerCase()) != -1) {\n                return true;\n            }\n        }\n\n        if (HTML_TAG_PATTERN.matcher(content2).find()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean isProgrammaticContent()\n    {\n        String[] matches = { \"<%\", \"\\\\$xwiki.xWiki\", \"$xcontext.context\", \"$doc.document\", \"$xwiki.getXWiki()\",\n        \"$xcontext.getContext()\", \"$doc.getDocument()\", \"WithProgrammingRights(\", \"/* Programmatic content */\",\n        \"## Programmatic content\", \"$xwiki.search(\", \"$xwiki.createUser\", \"$xwiki.createNewWiki\",\n        \"$xwiki.addToAllGroup\", \"$xwiki.sendMessage\", \"$xwiki.copyDocument\", \"$xwiki.copyWikiWeb\",\n        \"$xwiki.copySpaceBetweenWikis\", \"$xwiki.parseGroovyFromString\", \"$doc.toXML()\", \"$doc.toXMLDocument()\", };\n        String content2 = getContent().toLowerCase();\n        for (String match : matches) {\n            if (content2.indexOf(match.toLowerCase()) != -1) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     * @since 2.2M1\n     */\n    public boolean removeXObject(BaseObject object)\n    {\n        List<BaseObject> objects = this.xObjects.get(object.getXClassReference());\n        // No objects at all, nothing to remove\n        if (objects == null) {\n            return false;\n        }\n        // Sometimes the object vector is wrongly indexed, meaning that objects are not at the right position\n        // Check if the right object is in place\n        int objectPosition = object.getNumber();\n        if (objectPosition < objects.size()) {\n            BaseObject storedObject = objects.get(objectPosition);\n            if (storedObject == null || !storedObject.equals(object)) {\n                // Try to find the correct position\n                objectPosition = objects.indexOf(object);\n            }\n        } else {\n            // The object position is greater than the array, that's invalid!\n            objectPosition = -1;\n        }\n        // If the object is not in the document, simply ignore this request\n        if (objectPosition < 0) {\n            return false;\n        }\n        // We don't remove objects, but set null in their place, so that the object number corresponds to its position\n        // in the vector\n        objects.set(objectPosition, null);\n        // Schedule the object for removal from the storage\n        addXObjectToRemove(object);\n\n        return true;\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     * @deprecated use {@link #removeXObject(com.xpn.xwiki.objects.BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public boolean removeObject(BaseObject object)\n    {\n        return removeXObject(object);\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param classReference The XClass reference of the XObjects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @since 2.2M1\n     */\n    public boolean removeXObjects(DocumentReference classReference)\n    {\n        List<BaseObject> objects = this.xObjects.get(classReference);\n        // No objects at all, nothing to remove\n        if (objects == null) {\n            return false;\n        }\n        // Schedule the object for removal from the storage\n        for (BaseObject object : objects) {\n            if (object != null) {\n                addXObjectToRemove(object);\n            }\n        }\n        // Empty the vector, retaining its size\n        int currentSize = objects.size();\n        objects.clear();\n        for (int i = 0; i < currentSize; i++) {\n            objects.add(null);\n        }\n\n        return true;\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param reference The XClass reference of the XObjects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @since 5.0M1\n     */\n    public boolean removeXObjects(EntityReference reference)\n    {\n        return removeXObjects(\n            getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param className The class name of the objects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @deprecated use {@link #removeXObjects(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public boolean removeObjects(String className)\n    {\n        return removeXObjects(resolveClassReference(className));\n    }\n\n    /**\n     * Get the top sections contained in the document.\n     * <p>\n     * The section are filtered by xwiki.section.depth property on the maximum depth of the sections to return. This\n     * method is usually used to get \"editable\" sections.\n     *\n     * @return the sections in the current document\n     */\n    public List<DocumentSection> getSections() throws XWikiException\n    {\n        if (is10Syntax()) {\n            return getSections10();\n        } else {\n            List<DocumentSection> splitSections = new ArrayList<DocumentSection>();\n            List<HeaderBlock> headers = getFilteredHeaders();\n\n            int sectionNumber = 1;\n            for (HeaderBlock header : headers) {\n                // put -1 as index since there is no way to get the position of the header in the source\n                int documentSectionIndex = -1;\n\n                // Need to do the same thing than 1.0 content here\n                String documentSectionLevel = StringUtils.repeat(\"1.\", header.getLevel().getAsInt() - 1) + \"1\";\n\n                DocumentSection docSection = new DocumentSection(sectionNumber++, documentSectionIndex,\n                    documentSectionLevel, renderXDOM(new XDOM(header.getChildren()), getSyntax()));\n                splitSections.add(docSection);\n            }\n\n            return splitSections;\n        }\n    }\n\n    /**\n     * Get XWiki context from execution context.\n     *\n     * @return the XWiki context for the current thread\n     */\n    private XWikiContext getXWikiContext()\n    {\n        Provider<XWikiContext> xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n\n        if (xcontextProvider != null) {\n            return xcontextProvider.get();\n        }\n\n        return null;\n    }\n\n    /**\n     * Filter the headers from a document XDOM based on xwiki.section.depth property from xwiki.cfg file.\n     *\n     * @return the filtered headers\n     */\n    private List<HeaderBlock> getFilteredHeaders()\n    {\n        List<HeaderBlock> filteredHeaders = new ArrayList<HeaderBlock>();\n\n        // Get the maximum header level\n        int sectionDepth = 2;\n        XWikiContext context = getXWikiContext();\n        if (context != null) {\n            sectionDepth = (int) context.getWiki().getSectionEditingDepth();\n        }\n\n        // Get the headers.\n        //\n        // Note that we need to only take into account SectionBlock that are children of other SectionBlocks so that\n        // we are in sync with the section editing buttons added in xwiki.js. Being able to section edit any heading is\n        // too complex. For example if you have (in XWiki Syntax 2.0):\n        // = Heading1 =\n        // para1\n        // == Heading2 ==\n        // para2\n        // (((\n        // == Heading3 ==\n        // para3\n        // (((\n        // == Heading4 ==\n        // para4\n        // )))\n        // )))\n        // == Heading5 ==\n        // para5\n        //\n        // Then if we were to support editing \"Heading4\", its content would be:\n        // para4\n        // )))\n        // )))\n        //\n        // Which obviously is not correct...\n\n        final XDOM xdom = getXDOM();\n        if (!xdom.getChildren().isEmpty()) {\n            Block currentBlock = xdom.getChildren().get(0);\n            while (currentBlock != null) {\n                if (currentBlock instanceof SectionBlock) {\n                    // The next children block is a HeaderBlock but we check to be on the safe side...\n                    Block nextChildrenBlock = currentBlock.getChildren().get(0);\n                    if (nextChildrenBlock instanceof HeaderBlock) {\n                        HeaderBlock headerBlock = (HeaderBlock) nextChildrenBlock;\n                        if (headerBlock.getLevel().getAsInt() <= sectionDepth) {\n                            filteredHeaders.add(headerBlock);\n                        }\n                    }\n                    currentBlock = nextChildrenBlock;\n                } else {\n                    Block nextSibling = currentBlock.getNextSibling();\n                    if (nextSibling == null) {\n                        currentBlock = currentBlock.getParent();\n                        while (currentBlock != null) {\n                            if (currentBlock.getNextSibling() != null) {\n                                currentBlock = currentBlock.getNextSibling();\n                                break;\n                            }\n                            currentBlock = currentBlock.getParent();\n                        }\n                    } else {\n                        currentBlock = nextSibling;\n                    }\n                }\n            }\n        }\n\n        return filteredHeaders;\n    }\n\n    /**\n     * @return the sections in the current document\n     */\n    private List<DocumentSection> getSections10()\n    {\n        // Pattern to match the title. Matches only level 1 and level 2 headings.\n        Pattern headingPattern = Pattern.compile(\"^[ \\\\t]*+(1(\\\\.1){0,1}+)[ \\\\t]++(.++)$\", Pattern.MULTILINE);\n        Matcher matcher = headingPattern.matcher(getContent());\n        List<DocumentSection> splitSections = new ArrayList<DocumentSection>();\n        int sectionNumber = 0;\n        // find title to split\n        while (matcher.find()) {\n            ++sectionNumber;\n            String sectionLevel = matcher.group(1);\n            String sectionTitle = matcher.group(3);\n            int sectionIndex = matcher.start();\n            // Initialize a documentSection object.\n            DocumentSection docSection = new DocumentSection(sectionNumber, sectionIndex, sectionLevel, sectionTitle);\n            // Add the document section to list.\n            splitSections.add(docSection);\n        }\n\n        return splitSections;\n    }\n\n    /**\n     * Return a Document section with parameter is sectionNumber.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return\n     * @throws XWikiException error when extracting sections from document\n     */\n    public DocumentSection getDocumentSection(int sectionNumber) throws XWikiException\n    {\n        // return a document section according to section number\n        return getSections().get(sectionNumber - 1);\n    }\n\n    /**\n     * Return the content of a section.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return the content of a section or null if the section can't be found.\n     * @throws XWikiException error when trying to extract section content\n     */\n    public String getContentOfSection(int sectionNumber) throws XWikiException\n    {\n        String content = null;\n\n        if (is10Syntax()) {\n            content = getContentOfSection10(sectionNumber);\n        } else {\n            List<HeaderBlock> headers = getFilteredHeaders();\n\n            if (headers.size() >= sectionNumber) {\n                SectionBlock section = headers.get(sectionNumber - 1).getSection();\n                content = renderXDOM(new XDOM(Collections.<Block>singletonList(section)), getSyntax());\n            }\n        }\n\n        return content;\n    }\n\n    /**\n     * Return the content of a section.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return the content of a section\n     * @throws XWikiException error when trying to extract section content\n     */\n    private String getContentOfSection10(int sectionNumber) throws XWikiException\n    {\n        List<DocumentSection> splitSections = getSections();\n        int indexEnd = 0;\n        // get current section\n        DocumentSection section = splitSections.get(sectionNumber - 1);\n        int indexStart = section.getSectionIndex();\n        String sectionLevel = section.getSectionLevel();\n        // Determine where this section ends, which is at the start of the next section of the\n        // same or a higher level.\n        for (int i = sectionNumber; i < splitSections.size(); i++) {\n            DocumentSection nextSection = splitSections.get(i);\n            String nextLevel = nextSection.getSectionLevel();\n            if (sectionLevel.equals(nextLevel) || sectionLevel.length() > nextLevel.length()) {\n                indexEnd = nextSection.getSectionIndex();\n                break;\n            }\n        }\n        String sectionContent = null;\n        if (indexStart < 0) {\n            indexStart = 0;\n        }\n\n        if (indexEnd == 0) {\n            sectionContent = getContent().substring(indexStart);\n        } else {\n            sectionContent = getContent().substring(indexStart, indexEnd);\n        }\n\n        return sectionContent;\n    }\n\n    /**\n     * Update a section content in document.\n     *\n     * @param sectionNumber the index (starting at 1) of the section in the list of all sections in the document.\n     * @param newSectionContent the new section content.\n     * @return the new document content.\n     * @throws XWikiException error when updating content\n     */\n    public String updateDocumentSection(int sectionNumber, String newSectionContent) throws XWikiException\n    {\n        String content;\n        if (is10Syntax()) {\n            content = updateDocumentSection10(sectionNumber, newSectionContent);\n        } else {\n            // Get the current section block\n            HeaderBlock header = getFilteredHeaders().get(sectionNumber - 1);\n\n            XDOM xdom = (XDOM) header.getRoot();\n\n            // newSectionContent -> Blocks\n            List<Block> blocks = parseContent(newSectionContent).getChildren();\n            int sectionLevel = header.getLevel().getAsInt();\n            for (int level = 1; level < sectionLevel && blocks.size() == 1\n                && blocks.get(0) instanceof SectionBlock; ++level) {\n                blocks = blocks.get(0).getChildren();\n            }\n\n            // replace old current SectionBlock with new Blocks\n            Block section = header.getSection();\n            section.getParent().replaceChild(blocks, section);\n\n            // render back XDOM to document's content syntax\n            content = renderXDOM(xdom, getSyntax());\n        }\n\n        return content;\n    }\n\n    /**\n     * Update a section content in document.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @param newSectionContent the new section content.\n     * @return the new document content.\n     * @throws XWikiException error when updating document content with section content\n     */\n    private String updateDocumentSection10(int sectionNumber, String newSectionContent) throws XWikiException\n    {\n        StringBuilder newContent = new StringBuilder();\n        // get document section that will be edited\n        DocumentSection docSection = getDocumentSection(sectionNumber);\n        int numberOfSections = getSections().size();\n        int indexSection = docSection.getSectionIndex();\n        if (numberOfSections == 1) {\n            // there is only a sections in document\n            String contentBegin = getContent().substring(0, indexSection);\n            newContent = newContent.append(contentBegin).append(newSectionContent);\n            return newContent.toString();\n        } else if (sectionNumber == numberOfSections) {\n            // edit lastest section that doesn't contain subtitle\n            String contentBegin = getContent().substring(0, indexSection);\n            newContent = newContent.append(contentBegin).append(newSectionContent);\n            return newContent.toString();\n        } else {\n            String sectionLevel = docSection.getSectionLevel();\n            int nextSectionIndex = 0;\n            // get index of next section\n            for (int i = sectionNumber; i < numberOfSections; i++) {\n                DocumentSection nextSection = getDocumentSection(i + 1); // get next section\n                String nextSectionLevel = nextSection.getSectionLevel();\n                if (sectionLevel.equals(nextSectionLevel)) {\n                    nextSectionIndex = nextSection.getSectionIndex();\n                    break;\n                } else if (sectionLevel.length() > nextSectionLevel.length()) {\n                    nextSectionIndex = nextSection.getSectionIndex();\n                    break;\n                }\n            }\n\n            if (nextSectionIndex == 0) {// edit the last section\n                newContent = newContent.append(getContent().substring(0, indexSection)).append(newSectionContent);\n                return newContent.toString();\n            } else {\n                String contentAfter = getContent().substring(nextSectionIndex);\n                String contentBegin = getContent().substring(0, indexSection);\n                newContent = newContent.append(contentBegin).append(newSectionContent).append(contentAfter);\n            }\n\n            return newContent.toString();\n        }\n    }\n\n    /**\n     * Computes a document hash, taking into account all document data: content, objects, attachments, metadata... TODO:\n     * cache the hash value, update only on modification.\n     */\n    public String getVersionHashCode(XWikiContext context)\n    {\n        MessageDigest md5 = null;\n\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException ex) {\n            LOGGER.error(\"Cannot create MD5 object\", ex);\n            return hashCode() + \"\";\n        }\n\n        try {\n            String valueBeforeMD5 = toXML(true, false, true, false, context);\n            md5.update(valueBeforeMD5.getBytes());\n\n            byte[] array = md5.digest();\n            StringBuilder sb = new StringBuilder();\n            for (byte element : array) {\n                int b = element & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n\n            return sb.toString();\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while computing document hash\", ex);\n        }\n\n        return hashCode() + \"\";\n    }\n\n    public static String getInternalPropertyName(String propname, XWikiContext context)\n    {\n        ContextualLocalizationManager localizationManager = Utils.getComponent(ContextualLocalizationManager.class);\n        String cpropname = StringUtils.capitalize(propname);\n\n        return localizationManager == null ? cpropname : localizationManager.getTranslationPlain(cpropname);\n    }\n\n    public String getInternalProperty(String propname)\n    {\n        String methodName = \"get\" + StringUtils.capitalize(propname);\n        try {\n            Method method = getClass().getDeclaredMethod(methodName, (Class[]) null);\n            return (String) method.invoke(this, (Object[]) null);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String getCustomClass()\n    {\n        if (this.customClass == null) {\n            return \"\";\n        }\n\n        return this.customClass;\n    }\n\n    public void setCustomClass(String customClass)\n    {\n        this.customClass = customClass;\n        setMetaDataDirty(true);\n    }\n\n    public void setValidationScript(String validationScript)\n    {\n        this.validationScript = validationScript;\n\n        setMetaDataDirty(true);\n    }\n\n    public String getValidationScript()\n    {\n        if (this.validationScript == null) {\n            return \"\";\n        } else {\n            return this.validationScript;\n        }\n    }\n\n    public String getComment()\n    {\n        if (this.comment == null) {\n            return \"\";\n        }\n\n        return this.comment;\n    }\n\n    public void setComment(String comment)\n    {\n        this.comment = comment;\n    }\n\n    public boolean isMinorEdit()\n    {\n        return this.isMinorEdit;\n    }\n\n    public void setMinorEdit(boolean isMinor)\n    {\n        this.isMinorEdit = isMinor;\n    }\n\n    // methods for easy table update. It is need only for hibernate.\n    // when hibernate update old database without minorEdit field, hibernate will create field with\n    // null in despite of notnull in hbm.\n    // (http://opensource.atlassian.com/projects/hibernate/browse/HB-1151)\n    // so minorEdit will be null for old documents. But hibernate can't convert null to boolean.\n    // so we need convert Boolean to boolean\n    protected Boolean getMinorEdit1()\n    {\n        return Boolean.valueOf(isMinorEdit());\n    }\n\n    protected void setMinorEdit1(Boolean isMinor)\n    {\n        this.isMinorEdit = (isMinor != null && isMinor.booleanValue());\n    }\n\n    /**\n     * Create, add and return a new object with the provided class.\n     * <p>\n     * Note that absolute reference are not supported for xclasses which mean that the wiki part (whatever the wiki is)\n     * of the reference will be systematically removed.\n     *\n     * @param classReference the reference of the class\n     * @param context the XWiki context\n     * @return the newly created object\n     * @throws XWikiException error when creating the new object\n     * @since 2.2.3\n     */\n    public BaseObject newXObject(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        int nb = createXObject(classReference, context);\n        return getXObject(resolveClassReference(classReference), nb);\n    }\n\n    /**\n     * @deprecated use {@link #newXObject(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject newObject(String className, XWikiContext context) throws XWikiException\n    {\n        return newXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseObject getXObject(DocumentReference classReference, boolean create, XWikiContext context)\n    {\n        try {\n            BaseObject obj = getXObject(classReference);\n\n            if ((obj == null) && create) {\n                return newXObject(classReference, context);\n            }\n\n            if (obj == null) {\n                return null;\n            } else {\n                return obj;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.4M1\n     */\n    public BaseObject getXObject(EntityReference classReference, boolean create, XWikiContext context)\n    {\n        try {\n            BaseObject obj = getXObject(classReference);\n\n            if ((obj == null) && create) {\n                return newXObject(classReference, context);\n            }\n\n            if (obj == null) {\n                return null;\n            } else {\n                return obj;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, boolean, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject getObject(String className, boolean create, XWikiContext context)\n    {\n        return getXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), create,\n            context);\n    }\n\n    public boolean validate(XWikiContext context) throws XWikiException\n    {\n        return validate(null, context);\n    }\n\n    public boolean validate(String[] classNames, XWikiContext context) throws XWikiException\n    {\n        boolean isValid = true;\n        if ((classNames == null) || (classNames.length == 0)) {\n            for (DocumentReference classReference : getXObjects().keySet()) {\n                BaseClass bclass = context.getWiki().getXClass(classReference, context);\n                List<BaseObject> objects = getXObjects(classReference);\n                for (BaseObject obj : objects) {\n                    if (obj != null) {\n                        isValid &= bclass.validateObject(obj, context);\n                    }\n                }\n            }\n        } else {\n            for (String className : classNames) {\n                List<BaseObject> objects = getXObjects(getCurrentMixedDocumentReferenceResolver().resolve(className));\n                if (objects != null) {\n                    for (BaseObject obj : objects) {\n                        if (obj != null) {\n                            BaseClass bclass = obj.getXClass(context);\n                            isValid &= bclass.validateObject(obj, context);\n                        }\n                    }\n                }\n            }\n        }\n\n        String validationScript = \"\";\n        XWikiRequest req = context.getRequest();\n        if (req != null) {\n            validationScript = req.get(\"xvalidation\");\n        }\n\n        if ((validationScript == null) || (validationScript.trim().equals(\"\"))) {\n            validationScript = getValidationScript();\n        }\n\n        if ((validationScript != null) && (!validationScript.trim().equals(\"\"))) {\n            isValid &= executeValidationScript(context, validationScript);\n        }\n\n        return isValid;\n    }\n\n    public static void backupContext(Map<String, Object> backup, XWikiContext context)\n    {\n        // The XWiki Context isn't recreated when the Execution Context is cloned so we have to backup some of its data.\n        // Backup the current document on the XWiki Context.\n        backup.put(\"doc\", context.getDoc());\n\n        backup.put(\"cdoc\", context.get(\"cdoc\"));\n        backup.put(\"tdoc\", context.get(\"tdoc\"));\n\n        // Backup the secure document\n        backup.put(CKEY_SDOC, context.get(CKEY_SDOC));\n\n        // Clone the Execution Context to provide isolation. The clone will have a new Velocity and Script Context.\n        Execution execution = Utils.getComponent(Execution.class);\n        try {\n            execution.pushContext(Utils.getComponent(ExecutionContextManager.class).clone(execution.getContext()));\n        } catch (ExecutionContextException e) {\n            throw new RuntimeException(\"Failed to clone the Execution Context\", e);\n        }\n\n        // Bridge with old XWiki Context, required for legacy code.\n        execution.getContext().setProperty(XWikiContext.EXECUTIONCONTEXT_KEY, context);\n    }\n\n    public static void restoreContext(Map<String, Object> backup, XWikiContext context)\n    {\n        // Restore the Execution Context. This will also restore the previous Velocity and Script Context.\n        Execution execution = Utils.getComponent(Execution.class);\n        execution.popContext();\n\n        // Restore the current document on the XWiki Context.\n        context.setDoc((XWikiDocument) backup.get(\"doc\"));\n\n        context.put(\"cdoc\", backup.get(\"cdoc\"));\n        context.put(\"tdoc\", backup.get(\"tdoc\"));\n\n        // Restore the secure document\n        context.put(CKEY_SDOC, backup.get(CKEY_SDOC));\n    }\n\n    public void setAsContextDoc(XWikiContext context)\n    {\n        context.setDoc(this);\n        context.remove(\"cdoc\");\n        context.remove(\"tdoc\");\n\n        // Get rid of secure document (so that it fallback on context document)\n        context.remove(CKEY_SDOC);\n    }\n\n    /**\n     * @return the String representation of the previous version of this document or null if this is the first version.\n     */\n    public String getPreviousVersion()\n    {\n        XWikiDocumentArchive archive = loadDocumentArchive();\n        if (archive != null) {\n            Version prevVersion = archive.getPrevVersion(getRCSVersion());\n            if (prevVersion != null) {\n                return prevVersion.toString();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public String toString()\n    {\n        return getFullName();\n    }\n\n    /**\n     * Indicates whether the document should be 'hidden' or not, meaning that it should not be returned in public search\n     * results.\n     *\n     * @param hidden The new value of the {@link #hidden} property.\n     */\n    public void setHidden(Boolean hidden)\n    {\n        if (hidden == null) {\n            this.hidden = false;\n        } else {\n            this.hidden = hidden;\n        }\n    }\n\n    /**\n     * Indicates whether the document is 'hidden' or not, meaning that it should not be returned in public search\n     * results.\n     *\n     * @return <code>true</code> if the document is hidden and does not appear among the results of\n     *         {@link com.xpn.xwiki.api.XWiki#searchDocuments(String)}, <code>false</code> otherwise.\n     */\n    public Boolean isHidden()\n    {\n        return this.hidden;\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntaxId the syntax to convert to (e.g. {@code xwiki/2.0}, {@code xhtml/1.0}, etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public void convertSyntax(String targetSyntaxId, XWikiContext context) throws XWikiException\n    {\n        try {\n            convertSyntax(Syntax.valueOf(targetSyntaxId), context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntaxId + \"]\", e);\n        }\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntax the syntax to convert to (e.g. {@code xwiki/2.0}, {@code xhtml/1.0}, etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public void convertSyntax(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        // convert content\n        setContent(performSyntaxConversion(getContent(), getDocumentReference(), getSyntax(), targetSyntax));\n\n        // convert objects\n        Map<DocumentReference, List<BaseObject>> objectsByClass = getXObjects();\n\n        for (List<BaseObject> objects : objectsByClass.values()) {\n            for (BaseObject bobject : objects) {\n                if (bobject != null) {\n                    BaseClass bclass = bobject.getXClass(context);\n                    for (Object fieldClass : bclass.getProperties()) {\n                        if (fieldClass instanceof TextAreaClass && ((TextAreaClass) fieldClass).isWikiContent()) {\n                            TextAreaClass textAreaClass = (TextAreaClass) fieldClass;\n                            PropertyInterface field = bobject.getField(textAreaClass.getName());\n\n                            // Make sure the field is the right type (might happen while a document is being migrated)\n                            if (field instanceof LargeStringProperty) {\n                                LargeStringProperty largeField = (LargeStringProperty) field;\n\n                                largeField.setValue(performSyntaxConversion(largeField.getValue(),\n                                    getDocumentReference(), getSyntax(), targetSyntax));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // change syntax\n        setSyntax(targetSyntax);\n    }\n\n    /**\n     * NOTE: This method caches the XDOM and returns a clone that can be safely modified.\n     *\n     * @return the XDOM corresponding to the document's string content\n     */\n    @Override\n    public XDOM getXDOM()\n    {\n        if (this.xdomCache == null) {\n            try {\n                this.xdomCache = parseContent(getContent());\n            } catch (XWikiException e) {\n                ErrorBlockGenerator errorBlockGenerator = Utils.getComponent(ErrorBlockGenerator.class);\n                return new XDOM(errorBlockGenerator.generateErrorBlocks(false, TM_FAILEDDOCUMENTPARSE,\n                    \"Failed to parse document content\", null, e));\n            }\n        }\n\n        return this.xdomCache.clone();\n    }\n\n    /**\n     * @return true if the document has a xwiki/1.0 syntax content\n     */\n    public boolean is10Syntax()\n    {\n        return is10Syntax(getSyntaxId());\n    }\n\n    /**\n     * @return true if the document has a xwiki/1.0 syntax content\n     */\n    public boolean is10Syntax(String syntaxId)\n    {\n        return Syntax.XWIKI_1_0.toIdString().equalsIgnoreCase(syntaxId);\n    }\n\n    private void init(DocumentReference reference)\n    {\n        // if the passed reference is null consider it points to the default reference\n        if (reference == null) {\n            setDocumentReference(\n                Utils.<Provider<DocumentReference>>getComponent(DocumentReference.TYPE_PROVIDER).get());\n        } else {\n            setDocumentReference(reference);\n        }\n\n        this.updateDate = new Date();\n        this.updateDate.setTime((this.updateDate.getTime() / 1000) * 1000);\n        this.contentUpdateDate = new Date();\n        this.contentUpdateDate.setTime((this.contentUpdateDate.getTime() / 1000) * 1000);\n        this.creationDate = new Date();\n        this.creationDate.setTime((this.creationDate.getTime() / 1000) * 1000);\n        this.content = \"\";\n        this.format = \"\";\n        this.locale = Locale.ROOT;\n        this.defaultLocale = Locale.ROOT;\n        this.customClass = \"\";\n        this.comment = \"\";\n\n        // Note: As there's no notion of an Empty document we don't set the original document\n        // field. Thus getOriginalDocument() may return null.\n    }\n\n    private boolean executeValidationScript(XWikiContext context, String validationScript)\n    {\n        try {\n            ContextualAuthorizationManager authorization = Utils.getComponent(ContextualAuthorizationManager.class);\n            DocumentReference validationScriptReference =\n                getCurrentDocumentReferenceResolver().resolve(validationScript, getDocumentReference());\n\n            // Make sure target document is allowed to execute Groovy\n            // TODO: this check should probably be right in XWiki#parseGroovyFromPage\n            authorization.checkAccess(Right.PROGRAM, validationScriptReference);\n\n            XWikiValidationInterface validObject =\n                (XWikiValidationInterface) context.getWiki().parseGroovyFromPage(validationScript, context);\n\n            return validObject.validateDocument(this, context);\n        } catch (Throwable e) {\n            XWikiValidationStatus.addExceptionToContext(getFullName(), \"\", e, context);\n            return false;\n        }\n    }\n\n    /**\n     * Convert the passed content from the passed syntax to the passed new syntax.\n     *\n     * @param content the content to convert\n     * @param source the reference to where the content comes from (eg document reference)\n     * @param currentSyntaxId the syntax of the current content to convert\n     * @param targetSyntax the new syntax after the conversion\n     * @return the converted content in the new syntax\n     * @throws XWikiException if an exception occurred during the conversion process\n     * @since 2.4M2\n     */\n    private static String performSyntaxConversion(String content, DocumentReference source, Syntax currentSyntaxId,\n        Syntax targetSyntax) throws XWikiException\n    {\n        try {\n            XDOM dom = parseContent(currentSyntaxId, content, source);\n            return renderXDOM(dom, targetSyntax);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    /**\n     * Render provided XDOM into content of the provided syntax identifier.\n     *\n     * @param content the XDOM content to render\n     * @param targetSyntax the syntax identifier of the rendered content\n     * @return the rendered content\n     * @throws XWikiException if an exception occurred during the rendering process\n     */\n    protected static String renderXDOM(XDOM content, Syntax targetSyntax) throws XWikiException\n    {\n        try {\n            BlockRenderer renderer = Utils.getComponent(BlockRenderer.class, targetSyntax.toIdString());\n            WikiPrinter printer = new DefaultWikiPrinter();\n            renderer.render(content, printer);\n            return printer.toString();\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to render document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    private XDOM parseContent(String content) throws XWikiException\n    {\n        return parseContent(getSyntax(), content, getDocumentReference());\n    }\n\n    /**\n     * @param source the reference to where the content comes from (eg document reference)\n     */\n    private static XDOM parseContent(Syntax syntax, String content, DocumentReference source) throws XWikiException\n    {\n        ContentParser parser = Utils.getComponent(ContentParser.class);\n\n        try {\n            return parser.parse(content, syntax, source);\n        } catch (MissingParserException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to find a parser for syntax [\" + syntax.toIdString() + \"]\", e);\n        } catch (ParseException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to parse content of syntax [\" + syntax.toIdString() + \"]\", e);\n        }\n    }\n\n    /**\n     * If there's no parser available for the specified syntax default to the XWiki 2.1 syntax.\n     */\n    private Syntax getDefaultDocumentSyntax()\n    {\n        Syntax syntax = Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n\n        if (syntax == null || (!Utils.getComponentManager().hasComponent(Parser.class, syntax.toIdString())\n            && !Syntax.XWIKI_2_1.equals(syntax))) {\n            LOGGER.warn(\"Failed to find parser for the default syntax [{}]. Defaulting to xwiki/2.1 syntax.\", syntax);\n            syntax = Syntax.XWIKI_2_1;\n        }\n\n        return syntax;\n    }\n\n    /**\n     * Backward-compatibility method to use in order to resolve a class reference passed as a String into a\n     * DocumentReference proper.\n     *\n     * @return the resolved class reference but using this document's wiki if the passed String doesn't specify a wiki,\n     *         the \"XWiki\" space if the passed String doesn't specify a space and this document's page if the passed\n     *         String doesn't specify a page.\n     */\n    public DocumentReference resolveClassReference(String documentName)\n    {\n        DocumentReference defaultReference = new DocumentReference(getDocumentReference().getWikiReference().getName(),\n            XWiki.SYSTEM_SPACE, getDocumentReference().getName());\n        return getExplicitDocumentReferenceResolver().resolve(documentName, defaultReference);\n    }\n\n    /**\n     * Transforms a XClass reference relative to this document into an absolute reference.\n     */\n    private DocumentReference resolveClassReference(EntityReference reference)\n    {\n        if (reference instanceof DocumentReference) {\n            return (DocumentReference) reference;\n        } else if (reference instanceof LocalDocumentReference) {\n            return new DocumentReference((LocalDocumentReference) reference, getDocumentReference().getWikiReference());\n        } else {\n            DocumentReference defaultReference =\n                new DocumentReference(getDocumentReference().getWikiReference().getName(), XWiki.SYSTEM_SPACE,\n                    getDocumentReference().getName());\n            return getExplicitReferenceDocumentReferenceResolver().resolve(reference, defaultReference);\n        }\n    }\n\n    /**\n     * Return the reference of the parent document as it stored and passed to\n     * {@link #setParentReference(EntityReference)}.\n     * <p>\n     * You should use {@link #getParentReference()} reference if you want the complete parent reference.\n     *\n     * @return the relative parent reference\n     * @since 2.2.3\n     */\n    public EntityReference getRelativeParentReference()\n    {\n        return this.parentReference;\n    }\n\n    private BaseObject prepareXObject(EntityReference classReference)\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        BaseObject bobject = getXObject(absoluteClassReference);\n        if (bobject == null) {\n            bobject = new BaseObject();\n            bobject.setXClassReference(classReference);\n\n            addXObject(bobject);\n        }\n        bobject.setDocumentReference(getDocumentReference());\n        setMetaDataDirty(true);\n        return bobject;\n    }\n\n    /**\n     * Apply a 3 ways merge on the current document based on provided previous and new version of the document.\n     * <p>\n     * All 3 documents are supposed to have the same document reference and language already since that's what makes\n     * them uniques.\n     *\n     * @param previousDocument the previous version of the document\n     * @param newDocument the next version of the document\n     * @param configuration the configuration of the merge indicates how to deal with some conflicts use cases, etc.\n     * @param context the XWiki context\n     * @return a repport of what happen during the merge (errors, etc.)\n     * @since 3.2M1\n     * @deprecated use {@link MergeManager#mergeDocument(DocumentModelBridge, DocumentModelBridge, DocumentModelBridge,\n     *  MergeConfiguration)} instead\n     */\n    @Deprecated(since = \"11.8RC1\")\n    public MergeResult merge(XWikiDocument previousDocument, XWikiDocument newDocument,\n        MergeConfiguration configuration, XWikiContext context)\n    {\n        MergeManager mergeManager = Utils.getComponent(MergeManager.class);\n        MergeDocumentResult mergeDocumentResult =\n            mergeManager.mergeDocument(previousDocument, newDocument, this, configuration);\n\n        MergeResult mergeResult = new MergeResult();\n        mergeResult.getLog().addAll(mergeDocumentResult.getLog());\n        mergeResult.setModified(mergeResult.isModified() || mergeDocumentResult.isModified());\n\n        if (!configuration.isProvidedVersionsModifiables())\n        {\n            this.apply((XWikiDocument) mergeDocumentResult.getMergeResult());\n        }\n\n        return mergeResult;\n    }\n\n    /**\n     * Apply modification comming from provided document.\n     * <p>\n     * Thid method does not take into account versions and author related informations and the provided document should\n     * have the same reference. Like {@link #merge(XWikiDocument, XWikiDocument, MergeConfiguration, XWikiContext)},\n     * this method is dealing with \"real\" data and should not change anything related to version management and document\n     * identifier.\n     * <p>\n     * Important note: this method does not take care of attachments contents related operations and only remove\n     * attachments which need to be removed from the list. For memory handling reasons all attachments contents related\n     * operations should be done elsewhere.\n     *\n     * @param document the document to apply\n     * @return false is nothing changed\n     */\n    public boolean apply(XWikiDocument document)\n    {\n        return apply(document, true);\n    }\n\n    /**\n     * Apply modification comming from provided document.\n     * <p>\n     * Thid method does not take into account versions and author related informations and the provided document should\n     * have the same reference. Like {@link #merge(XWikiDocument, XWikiDocument, MergeConfiguration, XWikiContext)},\n     * this method is dealing with \"real\" data and should not change everything related to version management and\n     * document identifier.\n     *\n     * @param document the document to apply\n     * @return false is nothing changed\n     */\n    public boolean apply(XWikiDocument document, boolean clean)\n    {\n        boolean modified = false;\n\n        // /////////////////////////////////\n        // Document\n\n        if (!StringUtils.equals(getContent(), document.getContent())) {\n            setContent(document.getContent());\n            modified = true;\n        }\n        if (ObjectUtils.notEqual(getSyntax(), document.getSyntax())) {\n            setSyntax(document.getSyntax());\n            modified = true;\n        }\n\n        if (ObjectUtils.notEqual(getDefaultLocale(), document.getDefaultLocale())) {\n            setDefaultLocale(document.getDefaultLocale());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getTitle(), document.getTitle())) {\n            setTitle(document.getTitle());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getDefaultTemplate(), document.getDefaultTemplate())) {\n            setDefaultTemplate(document.getDefaultTemplate());\n            modified = true;\n        }\n        if (ObjectUtils.notEqual(getRelativeParentReference(), document.getRelativeParentReference())) {\n            setParentReference(document.getRelativeParentReference());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getCustomClass(), document.getCustomClass())) {\n            setCustomClass(document.getCustomClass());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getValidationScript(), document.getValidationScript())) {\n            setValidationScript(document.getValidationScript());\n            modified = true;\n        }\n\n        if (isHidden() != document.isHidden()) {\n            setHidden(document.isHidden());\n            modified = true;\n        }\n\n        // /////////////////////////////////\n        // XObjects\n\n        if (clean) {\n            // Delete objects that don't exist anymore\n            for (List<BaseObject> objects : getXObjects().values()) {\n                // Duplicate the list since we are potentially going to modify it\n                for (BaseObject originalObj : new ArrayList<BaseObject>(objects)) {\n                    if (originalObj != null) {\n                        BaseObject newObj =\n                            document.getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                        if (newObj == null) {\n                            // The object was deleted\n                            removeXObject(originalObj);\n                            modified = true;\n                        }\n                    }\n                }\n            }\n        }\n        // Add new objects or update existing objects\n        for (List<BaseObject> objects : document.getXObjects().values()) {\n            for (BaseObject newObj : objects) {\n                if (newObj != null) {\n                    BaseObject originalObj = getXObject(newObj.getXClassReference(), newObj.getNumber());\n                    if (originalObj == null) {\n                        // The object added or modified\n                        setXObject(newObj.getNumber(), newObj);\n                        modified = true;\n                    } else {\n                        // The object added or modified\n                        modified |= originalObj.apply(newObj, clean);\n                    }\n                }\n            }\n        }\n\n        // /////////////////////////////////\n        // XClass\n\n        modified |= getXClass().apply(document.getXClass(), clean);\n        if (ObjectUtils.notEqual(getXClassXML(), document.getXClassXML())) {\n            setXClassXML(document.getXClassXML());\n            modified = true;\n        }\n\n        // /////////////////////////////////\n        // Attachments\n\n        if (clean) {\n            // Delete attachments that don't exist anymore\n            for (XWikiAttachment attachment : new ArrayList<XWikiAttachment>(getAttachmentList())) {\n                if (document.getAttachment(attachment.getFilename()) == null) {\n                    removeAttachment(attachment);\n                }\n            }\n        }\n        // Add new attachments or update existing attachments\n        for (XWikiAttachment attachment : document.getAttachmentList()) {\n            XWikiAttachment originalAttachment = getAttachment(attachment.getFilename());\n            if (originalAttachment == null) {\n                addAttachment(attachment);\n            } else {\n                originalAttachment.apply(attachment);\n            }\n        }\n\n        return modified;\n    }\n\n    private XWikiAttachmentStoreInterface resolveXWikiAttachmentStoreInterface(String storeType, XWikiContext xcontext)\n    {\n        XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(storeType);\n\n        if (store != null) {\n            return store;\n        }\n\n        return xcontext.getWiki().getDefaultAttachmentContentStore();\n    }\n\n    private XWikiAttachmentStoreInterface getXWikiAttachmentStoreInterface(String storeType)\n    {\n        if (storeType != null && !storeType.equals(XWikiHibernateAttachmentStore.HINT)) {\n            try {\n                return Utils.getContextComponentManager().getInstance(XWikiAttachmentStoreInterface.class, storeType);\n            } catch (ComponentLookupException e) {\n                LOGGER.warn(\"Can't find attachment content store for type [{}]\", storeType, e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Compute and return the maximum authorized length for the full name (i.e. the serialized reference of the\n     * document) based on the current store limitation.\n     *\n     * @return the maximum authorized length for a document full name.\n     * @since 11.4RC1\n     */\n    public int getLocalReferenceMaxLength()\n    {\n        return getStore().getLimitSize(this.getXWikiContext(), this.getClass(), \"fullName\");\n    }\n\n    @Override\n    public DocumentAuthors getAuthors()\n    {\n        return this.authors;\n    }\n\n    /**\n     * This getter has been created for hibernate in order to properly fill the DB field, it's not meant to be used\n     * for other purpose. For getting the displayed author, rely on {@link #getAuthors()}.\n     *\n     * @return the serialization of the displayed author reference.\n     */\n    private String getOriginalMetadataAuthorReference()\n    {\n        if (this.getAuthors().getOriginalMetadataAuthor() == null\n            || this.getAuthors().getOriginalMetadataAuthor() == GuestUserReference.INSTANCE) {\n            return \"\";\n        } else {\n            return userReferenceToString(this.getAuthors().getOriginalMetadataAuthor());\n        }\n    }\n\n    /**\n     * This setter has been created for hibernate in order to properly create the XWikiDocument instance with the\n     * displayed author set, it's not meant to be used for other purpose.\n     *\n     * @param serializedUserReference the serialization of the displayed author reference.\n     */\n    private void setOriginalMetadataAuthorReference(String serializedUserReference)\n    {\n        if (!StringUtils.isEmpty(serializedUserReference)) {\n            UserReference userReference = userStringToUserReference(serializedUserReference);\n            this.authors.setOriginalMetadataAuthor(userReference);\n        }\n    }\n\n    /**\n     * Make sure any document metadata which may depend on configuration is initialized to its default value.\n     * \n     * @since 14.8RC1\n     * @since 14.4.4\n     * @since 13.10.10\n     */\n    @Unstable\n    public void initialize()\n    {\n        // There is no syntax by default in a new document and the default one is retrieved from the configuration\n        setSyntax(getSyntax());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.filter.output;\n\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.annotation.InstantiationStrategy;\nimport org.xwiki.component.descriptor.ComponentInstantiationStrategy;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.filter.FilterDescriptorManager;\nimport org.xwiki.filter.FilterEventParameters;\nimport org.xwiki.filter.FilterException;\nimport org.xwiki.filter.event.model.WikiDocumentFilter;\nimport org.xwiki.filter.event.xwiki.XWikiWikiDocumentFilter;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.localization.LocalizationContext;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.listener.WrappingListener;\nimport org.xwiki.rendering.renderer.PrintRendererFactory;\nimport org.xwiki.rendering.renderer.printer.DefaultWikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilter;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilterCollection;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\n\n/**\n * @version $Id$\n * @since 6.2M1\n */\n@Component\n@InstantiationStrategy(ComponentInstantiationStrategy.PER_LOOKUP)\npublic class XWikiDocumentOutputFilterStream extends AbstractEntityOutputFilterStream<XWikiDocument>\n    implements Initializable\n{\n    @Inject\n    private FilterDescriptorManager filterManager;\n\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Inject\n    private RenderingContext renderingContext;\n\n    @Inject\n    private LocalizationContext localizationContext;\n\n    @Inject\n    private EntityOutputFilterStream<XWikiAttachment> attachmentFilter;\n\n    @Inject\n    private EntityOutputFilterStream<BaseClass> classFilter;\n\n    @Inject\n    private EntityOutputFilterStream<BaseObject> objectFilter;\n\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    private WrappingListener contentListener = new WrappingListener();\n\n    private DefaultWikiPrinter currentWikiPrinter;\n\n    private Syntax previousTargetSyntax;\n\n    private Locale currentLocale;\n\n    private String currentVersion;\n\n    private FilterEventParameters currentLocaleParameters;\n\n    private Locale currentDefaultLocale;\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        initialize(this.attachmentFilter, this.classFilter, this.objectFilter);\n    }\n\n    @Override\n    protected Object createFilter()\n    {\n        List<XWikiDocumentFilter> filters = new ArrayList<>(this.children.size() + 1);\n        for (EntityOutputFilterStream<?> child : this.children) {\n            filters.add((XWikiDocumentFilter) child.getFilter());\n        }\n        filters.add(this);\n\n        this.filter = new XWikiDocumentFilterCollection(filters)\n        {\n            @Override\n            public void beginWikiClass(FilterEventParameters parameters) throws FilterException\n            {\n                if (!objectFilter.isEnabled()) {\n                    classFilter.enable();\n                }\n\n                super.beginWikiClass(parameters);\n            }\n\n            @Override\n            public void endWikiClass(FilterEventParameters parameters) throws FilterException\n            {\n                super.endWikiClass(parameters);\n\n                classFilter.disable();\n            }\n\n            @Override\n            public void beginWikiObject(String name, FilterEventParameters parameters) throws FilterException\n            {\n                objectFilter.enable();\n\n                super.beginWikiObject(name, parameters);\n            }\n\n            @Override\n            public void endWikiObject(String name, FilterEventParameters parameters) throws FilterException\n            {\n                super.endWikiObject(name, parameters);\n\n                objectFilter.disable();\n            }\n\n            @Override\n            public void onWikiAttachment(String name, InputStream content, Long size, FilterEventParameters parameters)\n                throws FilterException\n            {\n                attachmentFilter.enable();\n\n                super.onWikiAttachment(name, content, size, parameters);\n\n                attachmentFilter.disable();\n            }\n        };\n\n        if (this.contentListener != null) {\n            // Inject listener for the document content events\n            return this.filterManager.createCompositeFilter(this.contentListener, this.filter);\n        } else {\n            return this.filter;\n        }\n    }\n\n    private XWikiAttachmentOutputFilterStream getXWikiAttachmentOutputFilterStream()\n    {\n        return (XWikiAttachmentOutputFilterStream) this.attachmentFilter;\n    }\n\n    private BaseClassOutputFilterStream getBaseClassOutputFilterStream()\n    {\n        return (BaseClassOutputFilterStream) this.classFilter;\n    }\n\n    private BaseObjectOutputFilterStream getBaseObjectOutputFilterStream()\n    {\n        return (BaseObjectOutputFilterStream) this.objectFilter;\n    }\n\n    /**\n     * Optimization to disable any plumbing to support rendering events. To be used in case we know this kind of event\n     * won't be received or we want to ignore them. Should be called before {@link #getFilter()}.\n     */\n    public void disableRenderingEvents()\n    {\n        this.contentListener = null;\n    }\n\n    // Events\n\n    private EntityReference getDefaultDocumentReference()\n    {\n        if (this.properties != null && this.properties.getDefaultReference() != null) {\n            return this.properties.getDefaultReference();\n        }\n\n        if (this.entity != null) {\n            return this.entity.getDocumentReference();\n        }\n\n        return null;\n    }\n\n    private void begin(FilterEventParameters parameters) throws FilterException\n    {\n        DocumentReference documentReference =\n            this.documentEntityResolver.resolve(this.currentEntityReference, getDefaultDocumentReference());\n\n        if (this.entity == null) {\n            this.entity = new XWikiDocument(documentReference, this.currentLocale);\n        } else {\n            this.entity.setDocumentReference(documentReference);\n            this.entity.setLocale(this.currentLocale);\n        }\n\n        // Find default author\n        DocumentReference defaultAuthorDocumentReference;\n        // TODO: move to UserReference based APIs in DocumentInstanceOutputProperties\n        if (this.properties.isAuthorSet()) {\n            defaultAuthorDocumentReference = this.properties.getAuthor();\n        } else {\n            XWikiContext xcontext = xcontextProvider.get();\n            defaultAuthorDocumentReference = xcontext != null ? xcontext.getUserReference() : null;\n        }\n        UserReference defaultAuthorReference = this.userDocumentResolver.resolve(defaultAuthorDocumentReference);\n\n        this.entity\n            .setCreationDate(getDate(WikiDocumentFilter.PARAMETER_CREATION_DATE, this.currentLocaleParameters, null));\n\n        this.entity.getAuthors().setCreator(getUserReference(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR,\n            this.currentLocaleParameters, defaultAuthorReference));\n        this.entity.setDefaultLocale(this.currentDefaultLocale);\n\n        this.entity.setSyntax(getSyntax(WikiDocumentFilter.PARAMETER_SYNTAX, parameters, null));\n\n        this.entity.setParentReference(getEntityReference(WikiDocumentFilter.PARAMETER_PARENT, parameters, null));\n        this.entity.setCustomClass(getString(WikiDocumentFilter.PARAMETER_CUSTOMCLASS, parameters, null));\n        this.entity.setTitle(getString(WikiDocumentFilter.PARAMETER_TITLE, parameters, null));\n        this.entity.setDefaultTemplate(getString(WikiDocumentFilter.PARAMETER_DEFAULTTEMPLATE, parameters, null));\n        this.entity.setValidationScript(getString(WikiDocumentFilter.PARAMETER_VALIDATIONSCRIPT, parameters, null));\n        this.entity.setHidden(getBoolean(WikiDocumentFilter.PARAMETER_HIDDEN, parameters, false));\n\n        this.entity.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));\n\n        this.entity.getAuthors().setEffectiveMetadataAuthor(getUserReference(\n            WikiDocumentFilter.PARAMETER_REVISION_EFFECTIVEMETADATA_AUTHOR, parameters, defaultAuthorReference));\n        // Use effectuve metadata author as default as this value used to be used both both original and effective\n        // metadata authors\n        this.entity.getAuthors()\n            .setOriginalMetadataAuthor(getUserReference(WikiDocumentFilter.PARAMETER_REVISION_ORIGINALMETADATA_AUTHOR,\n                parameters, this.entity.getAuthors().getEffectiveMetadataAuthor()));\n\n        this.entity.getAuthors().setContentAuthor(\n            getUserReference(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, defaultAuthorReference));\n\n        String revisions =\n            getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, this.currentLocaleParameters, null);\n        if (revisions != null) {\n            try {\n                this.entity.setDocumentArchive(revisions);\n            } catch (XWikiException e) {\n                throw new FilterException(\"Failed to set document archive\", e);\n            }\n        }\n\n        if (this.currentVersion != null && this.properties.isVersionPreserved()) {\n            if (VALID_VERSION.matcher(this.currentVersion).matches()) {\n                this.entity.setVersion(this.currentVersion);\n            } else if (NumberUtils.isDigits(this.currentVersion)) {\n                this.entity.setVersion(this.currentVersion + \".1\");\n            } else {\n                // TODO: log something, probably a warning\n            }\n        }\n\n        this.entity.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));\n        this.entity.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, \"\"));\n\n        this.entity.setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));\n\n        // Content\n\n        if (this.contentListener != null) {\n            // Remember the current rendering context target syntax\n            this.previousTargetSyntax = this.renderingContext.getTargetSyntax();\n        }\n\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_CONTENT)) {\n            this.entity.setContent(getString(WikiDocumentFilter.PARAMETER_CONTENT, parameters, null));\n\n            if (this.contentListener != null) {\n                // Cancel any existing content listener\n                this.currentWikiPrinter = null;\n                this.contentListener.setWrappedListener(null);\n            }\n        } else if (this.contentListener != null) {\n            if (this.properties != null && this.properties.getDefaultSyntax() != null) {\n                this.entity.setSyntax(this.properties.getDefaultSyntax());\n            } else {\n                // Make sure to set the default syntax if none were provided\n                this.entity.setSyntax(this.entity.getSyntax());\n            }\n\n            ComponentManager componentManager = this.componentManagerProvider.get();\n\n            String syntaxString = this.entity.getSyntax().toIdString();\n            if (componentManager.hasComponent(PrintRendererFactory.class, syntaxString)) {\n                PrintRendererFactory rendererFactory;\n                try {\n                    rendererFactory = componentManager.getInstance(PrintRendererFactory.class, syntaxString);\n                } catch (ComponentLookupException e) {\n                    throw new FilterException(\n                        String.format(\"Failed to find PrintRendererFactory for syntax [%s]\", this.entity.getSyntax()),\n                        e);\n                }\n\n                this.currentWikiPrinter = new DefaultWikiPrinter();\n                ((MutableRenderingContext) this.renderingContext).setTargetSyntax(rendererFactory.getSyntax());\n                this.contentListener.setWrappedListener(rendererFactory.createRenderer(this.currentWikiPrinter));\n            }\n        }\n\n        // Initialize the class\n        getBaseClassOutputFilterStream().setEntity(this.entity.getXClass());\n    }\n\n    private void end(FilterEventParameters parameters)\n    {\n        // Set content\n        if (this.currentWikiPrinter != null) {\n            this.entity.setContent(this.currentWikiPrinter.getBuffer().toString());\n\n            this.contentListener.setWrappedListener(null);\n            this.currentWikiPrinter = null;\n        }\n\n        if (this.contentListener != null) {\n            // Reset\n            ((MutableRenderingContext) this.renderingContext).setTargetSyntax(this.previousTargetSyntax);\n        }\n    }\n\n    @Override\n    public void beginWikiDocument(String name, FilterEventParameters parameters) throws FilterException\n    {\n        super.beginWikiDocument(name, parameters);\n\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_LOCALE)) {\n            this.currentDefaultLocale = get(Locale.class, WikiDocumentFilter.PARAMETER_LOCALE, parameters, Locale.ROOT);\n        } else {\n            this.currentDefaultLocale = this.localizationContext.getCurrentLocale();\n        }\n\n        this.currentLocale = Locale.ROOT;\n        this.currentLocaleParameters = parameters;\n\n        begin(parameters);\n    }\n\n    @Override\n    public void endWikiDocument(String name, FilterEventParameters parameters) throws FilterException\n    {\n        end(parameters);\n\n        super.endWikiDocument(name, parameters);\n\n        // Reset\n        this.currentLocaleParameters = null;\n        this.currentLocale = null;\n        this.currentDefaultLocale = null;\n    }\n\n    @Override\n    public void beginWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws FilterException\n    {\n        this.currentLocale = locale;\n        this.currentLocaleParameters = parameters;\n\n        begin(parameters);\n    }\n\n    @Override\n    public void endWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws FilterException\n    {\n        end(parameters);\n\n        // Reset\n        this.currentLocale = null;\n        this.currentLocaleParameters = null;\n    }\n\n    @Override\n    public void beginWikiDocumentRevision(String version, FilterEventParameters parameters) throws FilterException\n    {\n        this.currentVersion = version;\n\n        begin(parameters);\n    }\n\n    @Override\n    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws FilterException\n    {\n        end(parameters);\n\n        // Reset\n        this.currentVersion = null;\n    }\n\n    @Override\n    public void endWikiClass(FilterEventParameters parameters) throws FilterException\n    {\n        getBaseClassOutputFilterStream().setEntity(null);\n    }\n\n    @Override\n    public void onWikiAttachment(String name, InputStream content, Long size, FilterEventParameters parameters)\n        throws FilterException\n    {\n        endAttachment();\n    }\n\n    @Override\n    public void endWikiDocumentAttachment(String name, InputSource content, Long size, FilterEventParameters parameters)\n        throws FilterException\n    {\n        endAttachment();\n    }\n\n    private void endAttachment()\n    {\n        this.entity.setAttachment(getXWikiAttachmentOutputFilterStream().getEntity());\n\n        // Reset attachment\n        getXWikiAttachmentOutputFilterStream().setEntity(null);\n    }\n\n    @Override\n    public void endWikiObject(String name, FilterEventParameters parameters) throws FilterException\n    {\n        super.endWikiObject(name, parameters);\n\n        BaseObject baseObject = getBaseObjectOutputFilterStream().getEntity();\n\n        if (baseObject.getNumber() < 0) {\n            this.entity.addXObject(baseObject);\n        } else {\n            this.entity.setXObject(baseObject.getNumber(), baseObject);\n        }\n\n        getBaseObjectOutputFilterStream().setEntity(null);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.store;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.hibernate.FlushMode;\nimport org.hibernate.HibernateException;\nimport org.hibernate.ObjectNotFoundException;\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.query.NativeQuery;\nimport org.hibernate.query.Query;\nimport org.slf4j.Logger;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.bridge.event.ActionExecutingEvent;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageAttachmentReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.store.UnexpectedException;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;\nimport com.xpn.xwiki.doc.XWikiLink;\nimport com.xpn.xwiki.doc.XWikiLock;\nimport com.xpn.xwiki.doc.XWikiSpace;\nimport com.xpn.xwiki.internal.store.hibernate.legacy.LegacySessionImplementor;\nimport com.xpn.xwiki.monitor.api.MonitorPlugin;\nimport com.xpn.xwiki.objects.BaseCollection;\nimport com.xpn.xwiki.objects.BaseElement;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.BaseStringProperty;\nimport com.xpn.xwiki.objects.LargeStringProperty;\nimport com.xpn.xwiki.objects.ListProperty;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.StringProperty;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.classes.StringClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.stats.impl.XWikiStats;\nimport com.xpn.xwiki.util.Util;\n\n/**\n * The XWiki Hibernate database driver.\n *\n * @version $Id$\n */\n@Component\n@Named(XWikiHibernateBaseStore.HINT)\n@Singleton\npublic class XWikiHibernateStore extends XWikiHibernateBaseStore implements XWikiStoreInterface, Initializable\n{\n    @Inject\n    private Logger logger;\n\n    /**\n     * QueryManager for this store.\n     */\n    @Inject\n    private QueryManager queryManager;\n\n    /** Needed so we can register an event to trap logout and delete held locks. */\n    @Inject\n    private ObservationManager observationManager;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    @Inject\n    private DocumentReferenceResolver<String> defaultDocumentReferenceResolver;\n\n    @Inject\n    @Named(\"current\")\n    private DocumentReferenceResolver<PageReference> currentPageReferenceDocumentReferenceResolver;\n\n    /**\n     * Used to convert a proper Document Reference to string (standard form).\n     */\n    @Inject\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part).\n     */\n    @Inject\n    @Named(\"compactwiki\")\n    private EntityReferenceSerializer<String> compactWikiEntityReferenceSerializer;\n\n    /**\n     * Used to convert a proper Document Reference to a string but without the wiki name.\n     */\n    @Inject\n    @Named(\"local\")\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;\n\n    @Inject\n    private ComponentManager componentManager;\n\n    @Inject\n    @Named(HINT)\n    private XWikiAttachmentStoreInterface attachmentContentStore;\n\n    @Inject\n    @Named(HINT)\n    private AttachmentVersioningStore attachmentArchiveStore;\n\n    @Inject\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private Map<String, String[]> validTypesMap = new HashMap<>();\n\n    /**\n     * This allows to initialize our storage engine. The hibernate config file path is taken from xwiki.cfg or directly\n     * in the WEB-INF directory.\n     *\n     * @param xwiki\n     * @param context\n     * @deprecated 1.6M1. Use ComponentManager.lookup(XWikiStoreInterface.class) instead.\n     */\n    @Deprecated\n    public XWikiHibernateStore(XWiki xwiki, XWikiContext context)\n    {\n        super(xwiki, context);\n        initValidColumTypes();\n    }\n\n    /**\n     * Initialize the storage engine with a specific path. This is used for tests.\n     *\n     * @param hibpath\n     * @deprecated 1.6M1. Use ComponentManager.lookup(XWikiStoreInterface.class) instead.\n     */\n    @Deprecated\n    public XWikiHibernateStore(String hibpath)\n    {\n        super(hibpath);\n        initValidColumTypes();\n    }\n\n    /**\n     * @see #XWikiHibernateStore(XWiki, XWikiContext)\n     * @deprecated 1.6M1. Use ComponentManager.lookup(XWikiStoreInterface.class) instead.\n     */\n    @Deprecated\n    public XWikiHibernateStore(XWikiContext context)\n    {\n        this(context.getWiki(), context);\n    }\n\n    /**\n     * Empty constructor needed for component manager.\n     */\n    public XWikiHibernateStore()\n    {\n        initValidColumTypes();\n    }\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        this.registerLogoutListener();\n    }\n\n    /**\n     * This initializes the valid custom types Used for Custom Mapping\n     */\n    private void initValidColumTypes()\n    {\n        String[] string_types = {\"string\", \"text\", \"clob\"};\n        String[] number_types =\n            {\"integer\", \"long\", \"float\", \"double\", \"big_decimal\", \"big_integer\", \"yes_no\", \"true_false\"};\n        String[] date_types = {\"date\", \"time\", \"timestamp\"};\n        String[] boolean_types = {\"boolean\", \"yes_no\", \"true_false\", \"integer\"};\n        this.validTypesMap = new HashMap<>();\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.StringClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.TextAreaClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.PasswordClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.NumberClass\", number_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.DateClass\", date_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.BooleanClass\", boolean_types);\n    }\n\n    @Override\n    public boolean isWikiNameAvailable(String wikiName, XWikiContext inputxcontext) throws XWikiException\n    {\n        try {\n            return !this.store.isWikiDatabaseExist(wikiName);\n        } catch (Exception e) {\n            Object[] args = {wikiName};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CHECK_EXISTS_DATABASE,\n                \"Exception while listing databases to search for {0}\", e, args);\n        }\n    }\n\n    @Override\n    public void createWiki(String wikiName, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, false);\n\n        boolean bTransaction = true;\n        String database = context.getWikiId();\n        AtomicReference<Statement> stmt = new AtomicReference<>(null);\n\n        bTransaction = beginTransaction(context);\n        try {\n            Session session = getSession(context);\n\n            session.doWork(connection -> {\n                stmt.set(connection.createStatement());\n                Statement statement = stmt.get();\n\n                String schema = getSchemaFromWikiName(wikiName, context);\n                String escapedSchema = escapeSchema(schema, context);\n\n                DatabaseProduct databaseProduct = getDatabaseProductName();\n                if (DatabaseProduct.ORACLE == databaseProduct) {\n                    // Notes:\n                    // - We use default tablespaces (which mean the USERS and TEMP tablespaces) to make it simple.\n                    // We also don't know which tablespace was used to create the main wiki and creating a new one\n                    // here would make things more complex (we would need to check if it exists already for example).\n                    // - We must specify a quota on the USERS tablespace so that the user can create objects (like\n                    // tables). Note that tables are created deferred by default so you'd think the user can create\n                    // them without quotas set but that's because tables are created deferred by default and thus\n                    // they'll fail when the first data is written in them.\n                    // See https://dba.stackexchange.com/a/254950\n                    // - Depending on how it's configured, the default users tablespace size might be too small. Thus\n                    // it's up to a DBA to make sure it's large enough.\n                    statement.execute(String.format(\"CREATE USER %s IDENTIFIED BY %s QUOTA UNLIMITED ON USERS\",\n                        escapedSchema, escapedSchema));\n                } else if (DatabaseProduct.DERBY == databaseProduct || DatabaseProduct.DB2 == databaseProduct\n                    || DatabaseProduct.H2 == databaseProduct) {\n                    statement.execute(\"CREATE SCHEMA \" + escapedSchema);\n                } else if (DatabaseProduct.HSQLDB == databaseProduct) {\n                    statement.execute(\"CREATE SCHEMA \" + escapedSchema + \" AUTHORIZATION DBA\");\n                } else if (DatabaseProduct.MYSQL == databaseProduct) {\n                    StringBuilder statementBuilder = new StringBuilder(\"create database \" + escapedSchema);\n                    String[] charsetAndCollation = getCharsetAndCollation(wikiName, session, context);\n                    statementBuilder.append(\" CHARACTER SET \");\n                    statementBuilder.append(charsetAndCollation[0]);\n                    statementBuilder.append(\" COLLATE \");\n                    statementBuilder.append(charsetAndCollation[1]);\n                    statement.execute(statementBuilder.toString());\n                } else if (DatabaseProduct.POSTGRESQL == databaseProduct) {\n                    if (isInSchemaMode()) {\n                        statement.execute(\"CREATE SCHEMA \" + escapedSchema);\n                    } else {\n                        this.logger.error(\"Creation of a new database is currently only supported in the schema mode, \"\n                            + \"see https://jira.xwiki.org/browse/XWIKI-8753\");\n                    }\n                } else {\n                    statement.execute(\"create database \" + escapedSchema);\n                }\n            });\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {wikiName};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CREATE_DATABASE, \"Exception while create wiki database {0}\",\n                e, args);\n        } finally {\n            context.setWikiId(database);\n            try {\n                Statement statement = stmt.get();\n                if (statement != null) {\n                    statement.close();\n                }\n            } catch (Exception e) {\n            }\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    /**\n     * @return the MySQL charset and collation to use when creating a new database. They are retrieved by finding the\n     *         ones used for the main wiki and if that fails, the {@code utf8mb4} charset and {@code utf8mb4_bin}\n     *         collation are used (We use {@code utf8mb4} and not {@code utf8} so that by default, users can insert\n     *         emojis in content).\n     */\n    private String[] getCharsetAndCollation(String wikiName, Session session, XWikiContext context)\n    {\n        String[] result = new String[2];\n        String charset = \"utf8mb4\";\n        String collation = \"utf8mb4_bin\";\n\n        // Get main wiki encoding\n        if (!context.isMainWiki(wikiName)) {\n            NativeQuery<Object[]> selectQuery = session.createNativeQuery(\n                \"select DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME from INFORMATION_SCHEMA.SCHEMATA\"\n                    + \" where SCHEMA_NAME='\" + getSchemaFromWikiName(context.getMainXWiki(), context) + \"'\");\n            Object[] queryResult = selectQuery.uniqueResult();\n            if (queryResult != null) {\n                charset = (String) queryResult[0];\n                collation = (String) queryResult[1];\n            }\n        }\n\n        result[0] = charset;\n        result[1] = collation;\n        return result;\n    }\n\n    @Override\n    public void deleteWiki(String wikiName, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, false);\n\n        String database = context.getWikiId();\n        AtomicReference<Statement> stmt = new AtomicReference<>(null);\n\n        boolean bTransaction = beginTransaction(context);\n        try {\n            Session session = getSession(context);\n            session.doWork(connection -> {\n                stmt.set(connection.createStatement());\n\n                String schema = getSchemaFromWikiName(wikiName, context);\n                String escapedSchema = escapeSchema(schema, context);\n\n                executeDeleteWikiStatement(stmt.get(), getDatabaseProductName(), escapedSchema);\n            });\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {wikiName};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETE_DATABASE, \"Exception while delete wiki database {0}\",\n                e, args);\n        } finally {\n            context.setWikiId(database);\n            try {\n                Statement statement = stmt.get();\n                if (statement != null) {\n                    statement.close();\n                }\n            } catch (Exception e) {\n            }\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    /**\n     * Execute the SQL statement on the database to remove a wiki.\n     *\n     * @param statement the statement object on which to execute the wiki deletion\n     * @param databaseProduct the database type\n     * @param escapedSchemaName the subwiki schema name being deleted\n     * @throws SQLException in case of an error while deleting the sub wiki\n     */\n    protected void executeDeleteWikiStatement(Statement statement, DatabaseProduct databaseProduct,\n        String escapedSchemaName) throws SQLException\n    {\n        if (DatabaseProduct.ORACLE == databaseProduct) {\n            statement.execute(\"DROP USER \" + escapedSchemaName + \" CASCADE\");\n        } else if (DatabaseProduct.DERBY == databaseProduct || DatabaseProduct.MYSQL == databaseProduct\n            || DatabaseProduct.H2 == databaseProduct) {\n            statement.execute(\"DROP SCHEMA \" + escapedSchemaName);\n        } else if (DatabaseProduct.HSQLDB == databaseProduct) {\n            statement.execute(\"DROP SCHEMA \" + escapedSchemaName + \" CASCADE\");\n        } else if (DatabaseProduct.DB2 == databaseProduct) {\n            statement.execute(\"DROP SCHEMA \" + escapedSchemaName + \" RESTRICT\");\n        } else if (DatabaseProduct.POSTGRESQL == databaseProduct) {\n            if (isInSchemaMode()) {\n                statement.execute(\"DROP SCHEMA \" + escapedSchemaName + \" CASCADE\");\n            } else {\n                this.logger.warn(\"Subwiki deletion not yet supported in Database mode for PostgreSQL\");\n            }\n        }\n    }\n\n    /**\n     * Verifies if a wiki document exists\n     */\n    @Override\n    public boolean exists(XWikiDocument doc, XWikiContext inputxcontext) throws XWikiException\n    {\n        // In order to avoid trying to issue any SQL query to the DB, we first check if the wiki containing the\n        // doc exists. If not, then the doc cannot exist for sure.\n        try {\n            if (!this.wikiDescriptorManager.exists(this.wikiDescriptorManager.getCurrentWikiId())) {\n                return false;\n            }\n        } catch (WikiManagerException e) {\n            // An error occurred while retrieving the wiki descriptors. This is an important problem and we shouldn't\n            // swallow it and instead we mist let it bubble up.\n            Object[] args = {this.wikiDescriptorManager.getCurrentWikiId()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CHECK_EXISTS_DOC,\n                \"Error while checking for existence of the [{0}] wiki\", e, args);\n        }\n\n        return executeRead(inputxcontext, session -> {\n            try {\n                String fullName = doc.getFullName();\n\n                String sql = \"select doc.fullName from XWikiDocument as doc where doc.fullName=:fullName\";\n                if (!doc.getLocale().equals(Locale.ROOT)) {\n                    sql += \" and doc.language=:language\";\n                }\n\n                Query<String> query = session.createQuery(sql);\n                query.setParameter(\"fullName\", fullName);\n                if (!doc.getLocale().equals(Locale.ROOT)) {\n                    query.setParameter(\"language\", doc.getLocale().toString());\n                }\n                Iterator<String> it = query.list().iterator();\n                while (it.hasNext()) {\n                    if (fullName.equals(it.next())) {\n                        return true;\n                    }\n                }\n\n                return false;\n            } catch (Exception e) {\n                Object[] args = {doc.getDocumentReferenceWithLocale()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CHECK_EXISTS_DOC, \"Exception while reading document {0}\",\n                    e, args);\n            }\n        });\n    }\n\n    @Override\n    public void saveXWikiDoc(XWikiDocument doc, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            MonitorPlugin monitor = Util.getMonitorPlugin(context);\n\n            try {\n                // Start monitoring timer\n                if (monitor != null) {\n                    monitor.startTimer(HINT);\n                }\n                doc.setStore(this);\n                // Make sure the database name is stored\n                doc.setDatabase(context.getWikiId());\n\n                // If the comment is larger than the max size supported by the Storage, then abbreviate it\n                String comment = doc.getComment();\n                if (comment != null && comment.length() > 1023) {\n                    doc.setComment(StringUtils.abbreviate(comment, 1023));\n                }\n\n                // Before starting the transaction, make sure any document metadata which might rely on configuration is\n                // initialized\n                doc.initialize();\n\n                if (bTransaction) {\n                    checkHibernate(context);\n                    SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                    bTransaction = beginTransaction(sfactory, context);\n                }\n\n                try {\n                    Session session = getSession(context);\n                    session.setHibernateFlushMode(FlushMode.COMMIT);\n\n                    // These informations will allow to not look for attachments and objects on loading\n                    doc.setElement(XWikiDocument.HAS_ATTACHMENTS, !doc.getAttachmentList().isEmpty());\n                    doc.setElement(XWikiDocument.HAS_OBJECTS, !doc.getXObjects().isEmpty());\n\n                    // Let's update the class XML since this is the new way to store it\n                    // TODO If all the properties are removed, the old xml stays?\n                    BaseClass bclass = doc.getXClass();\n                    if (bclass != null) {\n                        if (bclass.getFieldList().isEmpty()) {\n                            doc.setXClassXML(\"\");\n                        } else {\n                            // Don't format the XML to reduce the size of the stored data as much as possible\n                            doc.setXClassXML(bclass.toXMLString(false));\n                        }\n                        bclass.setDirty(false);\n                    }\n\n                    // Remove attachments planned for removal\n                    if (!doc.getAttachmentsToRemove().isEmpty()) {\n                        for (XWikiAttachmentToRemove attachmentToRemove : doc.getAttachmentsToRemove()) {\n                            XWikiAttachment attachment = attachmentToRemove.getAttachment();\n\n                            XWikiAttachment attachmentToAdd = doc.getAttachment(attachment.getFilename());\n                            if (attachmentToAdd != null && attachmentToAdd.getId() == attachment.getId()) {\n                                // Hibernate does not like when the \"same\" database entity (from identifier point of\n                                // view)\n                                // is manipulated through two different Java objects in the same session. But it also\n                                // refuse\n                                // to delete and insert the \"same\" entity (still from id point of view) in the same\n                                // sessions. So when we hit such a case we only remove the attachment history and let\n                                // the\n                                // saveAttachmentList code below update the current attachment content.\n                                AttachmentVersioningStore store = getAttachmentVersioningStore(attachment);\n                                store.deleteArchive(attachment, context, bTransaction);\n                                // Keep the same content store since we need to overwrite existing data\n                                attachmentToAdd.setContentStore(attachment.getContentStore());\n                            } else {\n                                XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(attachment);\n                                store.deleteXWikiAttachment(attachment, false, context, false);\n                            }\n                        }\n                    }\n                    // Update/add new attachments\n                    if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS)) {\n                        saveAttachmentList(doc, context);\n                    }\n                    // Reset the list of attachments to remove\n                    doc.clearAttachmentsToRemove();\n\n                    // Handle the latest text file\n                    if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                        Date ndate = new Date();\n                        doc.setDate(ndate);\n                        if (doc.isContentDirty()) {\n                            doc.setContentUpdateDate(ndate);\n                            DocumentAuthors authors = doc.getAuthors();\n                            authors.setContentAuthor(authors.getEffectiveMetadataAuthor());\n                        }\n                        doc.incrementVersion();\n                        if (context.getWiki().hasVersioning(context)) {\n                            context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                        }\n\n                        doc.setContentDirty(false);\n                        doc.setMetaDataDirty(false);\n                    } else {\n                        if (doc.getDocumentArchive() != null) {\n                            // A custom document archive has been provided, we assume it's right\n                            // (we also assume it's custom but that's another matter...)\n                            // Let's make sure we save the archive if we have one\n                            // This is especially needed if we load a document from XML\n                            if (context.getWiki().hasVersioning(context)) {\n                                context.getWiki().getVersioningStore().saveXWikiDocArchive(doc.getDocumentArchive(),\n                                    false, context);\n\n                                // If the version does not exist it means it's a new version so add it to the history\n                                if (!containsVersion(doc, doc.getRCSVersion(), context)) {\n                                    context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                                }\n                            }\n                        } else {\n                            // Make sure the getArchive call has been made once\n                            // with a valid context\n                            try {\n                                if (context.getWiki().hasVersioning(context)) {\n                                    doc.getDocumentArchive(context);\n\n                                    // If the version does not exist it means it's a new version so register it in the\n                                    // history\n                                    if (!containsVersion(doc, doc.getRCSVersion(), context)) {\n                                        context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false,\n                                            context);\n                                    }\n                                }\n                            } catch (XWikiException e) {\n                                // this is a non critical error\n                            }\n                        }\n                    }\n\n                    // Verify if the document already exists\n                    Query query = session\n                        .createQuery(\"select xwikidoc.id from XWikiDocument as xwikidoc where xwikidoc.id = :id\");\n                    query.setParameter(\"id\", doc.getId());\n                    if (query.uniqueResult() == null) {\n                        doc.setNew(true);\n                    }\n\n                    // Note: we don't use session.saveOrUpdate(doc) because it used to be slower in Hibernate than\n                    // calling\n                    // session.save() and session.update() separately.\n                    if (doc.isNew()) {\n                        if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                            // Reset the creationDate to reflect the date of the first save, not the date of the object\n                            // creation\n                            doc.setCreationDate(new Date());\n                        }\n                        session.save(doc);\n                    } else {\n                        session.update(doc);\n                    }\n\n                    // Remove objects planned for removal\n                    if (!doc.getXObjectsToRemove().isEmpty()) {\n                        for (BaseObject removedObject : doc.getXObjectsToRemove()) {\n                            deleteXWikiCollection(removedObject, context, false, false);\n                        }\n                        doc.setXObjectsToRemove(new ArrayList<BaseObject>());\n                    }\n\n                    if (bclass != null) {\n                        bclass.setDocumentReference(doc.getDocumentReference());\n                        // Store this XWikiClass in the context so that we can use it in case of recursive usage of\n                        // classes\n                        context.addBaseClass(bclass);\n                    }\n\n                    if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                        // TODO: Delete all objects for which we don't have a name in the Map\n                        for (List<BaseObject> objects : doc.getXObjects().values()) {\n                            for (BaseObject obj : objects) {\n                                if (obj != null) {\n                                    obj.setDocumentReference(doc.getDocumentReference());\n                                    /* If the object doesn't have a GUID, create it before saving */\n                                    if (StringUtils.isEmpty(obj.getGuid())) {\n                                        obj.setGuid(null);\n                                    }\n                                    saveXWikiCollection(obj, context, false);\n                                }\n                            }\n                        }\n                    }\n\n                    // Update space table\n                    updateXWikiSpaceTable(doc, session);\n\n                    if (bTransaction) {\n                        endTransaction(context, true);\n                    }\n\n                    doc.setNew(false);\n\n                    // We need to ensure that the saved document becomes the original document\n                    doc.setOriginalDocument(doc.clone());\n                } finally {\n                    if (bTransaction) {\n                        try {\n                            endTransaction(context, false);\n                        } catch (Exception e) {\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                Object[] args = {this.defaultEntityReferenceSerializer.serialize(doc.getDocumentReference())};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC, \"Exception while saving document {0}\", e,\n                    args);\n            } finally {\n                // End monitoring timer\n                if (monitor != null) {\n                    monitor.endTimer(HINT);\n                }\n            }\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    private void updateXWikiSpaceTable(XWikiDocument document, Session session)\n    {\n        if (document.getLocale().equals(Locale.ROOT)) {\n            // It's possible the space does not yet exist yet\n            maybeCreateSpace(document.getDocumentReference().getLastSpaceReference(), document.isHidden(), session);\n\n            if (!document.isNew()) {\n                // If the hidden state of an existing document did not changed there is nothing to do\n                if (document.isHidden() != document.getOriginalDocument().isHidden()) {\n                    if (document.isHidden()) {\n                        // If the document became hidden it's possible the space did too\n                        maybeMakeSpaceHidden(document.getDocumentReference().getLastSpaceReference(),\n                            document.getFullName(), session);\n                    } else {\n                        // If the document became visible then all its parents should be visible as well\n                        makeSpaceVisible(document.getDocumentReference().getLastSpaceReference(), session);\n                    }\n                }\n            }\n        }\n    }\n\n    private void insertXWikiSpace(XWikiSpace space, Session session)\n    {\n        // Insert the space\n        session.save(space);\n\n        // Update parent space\n        if (space.getSpaceReference().getParent() instanceof SpaceReference) {\n            maybeCreateSpace((SpaceReference) space.getSpaceReference().getParent(), space.isHidden(), session);\n        }\n    }\n\n    private void makeSpaceVisible(SpaceReference spaceReference, Session session)\n    {\n        XWikiSpace space = loadXWikiSpace(spaceReference, session);\n\n        makeSpaceVisible(space, session);\n    }\n\n    private void makeSpaceVisible(XWikiSpace space, Session session)\n    {\n        if (space.isHidden()) {\n            space.setHidden(false);\n\n            session.update(space);\n\n            // Update parent\n            if (space.getSpaceReference().getParent() instanceof SpaceReference) {\n                makeSpaceVisible((SpaceReference) space.getSpaceReference().getParent(), session);\n            }\n        }\n    }\n\n    private void maybeMakeSpaceHidden(SpaceReference spaceReference, String modifiedDocument, Session session)\n    {\n        XWikiSpace space = loadXWikiSpace(spaceReference, session);\n\n        // The space is supposed to exist\n        if (space == null) {\n            this.logger.warn(\n                \"Space [{}] does not exist. Usually means the spaces table is not in sync with the documents table.\",\n                spaceReference);\n\n            return;\n        }\n\n        // If the space is already hidden return\n        if (space.isHidden()) {\n            return;\n        }\n\n        if (calculateHiddenStatus(spaceReference, modifiedDocument, session)) {\n            // Make the space hidden\n            space.setHidden(true);\n            session.update(space);\n\n            // Update space parent\n            if (spaceReference.getParent() instanceof SpaceReference) {\n                maybeMakeSpaceHidden((SpaceReference) spaceReference.getParent(), modifiedDocument, session);\n            }\n        }\n    }\n\n    private void maybeCreateSpace(SpaceReference spaceReference, boolean hidden, Session session)\n    {\n        XWikiSpace space = loadXWikiSpace(spaceReference, session);\n\n        if (space != null) {\n            if (space.isHidden() && !hidden) {\n                makeSpaceVisible(space, session);\n            }\n        } else {\n            insertXWikiSpace(new XWikiSpace(spaceReference, hidden), session);\n        }\n    }\n\n    private boolean hasDocuments(SpaceReference spaceReference, Session session, String extraWhere,\n        Map<String, ?> parameters)\n    {\n        StringBuilder builder = new StringBuilder(\n            \"select distinct xwikidoc.space from XWikiDocument as xwikidoc where (space = :space OR space LIKE :like)\");\n\n        if (StringUtils.isNotEmpty(extraWhere)) {\n            builder.append(\" AND \");\n            builder.append('(');\n            builder.append(extraWhere);\n            builder.append(')');\n        }\n\n        Query<String> query = session.createQuery(builder.toString(), String.class);\n\n        String localSpaceReference = this.localEntityReferenceSerializer.serialize(spaceReference);\n        String localSpaceReferencePrefix = localSpaceReference + '.';\n\n        query.setParameter(\"space\", localSpaceReference);\n        query.setParameter(\"like\", localSpaceReferencePrefix + \"%\");\n\n        if (parameters != null) {\n            parameters.forEach(query::setParameter);\n        }\n\n        // Leading and trailing white spaces are not taken into account in SQL comparisons so we have to make sure the\n        // matched spaces really are the expected ones\n        for (String result : query.getResultList()) {\n            if (result.equals(localSpaceReference) || result.startsWith(localSpaceReferencePrefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Find hidden status of a space from its children.\n     */\n    private boolean calculateHiddenStatus(SpaceReference spaceReference, String documentToIngore, Session session)\n    {\n        // If there is at least one visible document then the space is visible\n        StringBuilder builder = new StringBuilder(\"(hidden = false OR hidden IS NULL)\");\n\n        Map<String, ?> parameters;\n        if (documentToIngore != null) {\n            builder.append(\" AND fullName <> :documentToIngore\");\n            parameters = Collections.singletonMap(\"documentToIngore\", documentToIngore);\n        } else {\n            parameters = null;\n        }\n\n        return !hasDocuments(spaceReference, session, builder.toString(), parameters);\n    }\n\n    private boolean containsVersion(XWikiDocument doc, Version targetversion, XWikiContext context)\n        throws XWikiException\n    {\n        for (Version version : doc.getRevisions(context)) {\n            if (version.equals(targetversion)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void saveXWikiDoc(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        saveXWikiDoc(doc, context, true);\n    }\n\n    /**\n     * {@inheritDoc} This implementation of rename relies on {@link #saveXWikiDoc(XWikiDocument, XWikiContext, boolean)}\n     * and {@link #deleteXWikiDoc(XWikiDocument, XWikiContext, boolean)}. The idea here is that the document reference\n     * has many impacts everywhere and it's actually safer to keep relying on existing save method. Now all the benefit\n     * of this rename, is to call those methods in the same transaction when both old and new reference belong to the\n     * same wiki (same database). If the references belong to different databases we are force to use two transactions.\n     */\n    @Override\n    public void renameXWikiDoc(XWikiDocument doc, DocumentReference newReference, XWikiContext inputxcontext)\n        throws XWikiException\n    {\n        WikiReference sourceWikiReference = doc.getDocumentReference().getWikiReference();\n        WikiReference targetWikiReference = newReference.getWikiReference();\n\n        // perform the change in same session only if the new and old reference belongs to same wiki (same database)\n        boolean sameSession = sourceWikiReference.equals(targetWikiReference);\n\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n        XWikiDocument newDocument = doc.cloneRename(newReference, context);\n        newDocument.setNew(true);\n        newDocument.setStore(this);\n        newDocument\n            .setComment(\"Renamed from \" + this.defaultEntityReferenceSerializer.serialize(doc.getDocumentReference()));\n\n        boolean copyPerformed = false;\n\n        try {\n            if (sameSession) {\n                // We execute the whole call with a commit at the end,\n                // but we ensure to not commit at each step (save and delete)\n                executeWrite(context, session -> {\n                    saveXWikiDoc(newDocument, context, false);\n\n                    // Since the save documment is called without a commit, the information are not flushed\n                    // in the session either. However we need the new information in the session for the delete\n                    // in particular to know the possible changes made in the spaces.\n                    session.flush();\n                    deleteXWikiDoc(doc, context, false);\n\n                    return true;\n                });\n            } else {\n                // Execute the save on the right DB with a commit at the end\n                context.setWikiReference(targetWikiReference);\n                executeWrite(context, session -> {\n                    saveXWikiDoc(newDocument, context, false);\n\n                    return true;\n                });\n\n                // to be able to rollback in case of problem during delete\n                copyPerformed = true;\n\n                // Execute the delete on the right DB with a commit at the end\n                context.setWikiReference(sourceWikiReference);\n                executeWrite(context, session -> {\n                    this.deleteXWikiDoc(doc, context, false);\n\n                    return true;\n                });\n            }\n        } catch (Exception e) {\n            // We only need to perform special actions in case of different sessions,\n            // and if the first step has been executed. In all other cases nothing should have been committed.\n            if (!sameSession && copyPerformed) {\n                // Ensure to delete the doc that has been copied already.\n                // Note that in case of problem there, the exception is directly thrown.\n                executeWrite(context, session -> {\n                    this.deleteXWikiDoc(newDocument, context, false);\n\n                    return true;\n                });\n            }\n\n            Object[] args = {doc.getDocumentReference(), newReference};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_RENAMING_DOC,\n                \"Exception while renaming document [{0}] to [{1}]\", e, args);\n        }\n    }\n\n    @Override\n    public XWikiDocument loadXWikiDoc(XWikiDocument defaultDocument, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        XWikiDocument doc = defaultDocument;\n        try {\n            boolean bTransaction = true;\n            MonitorPlugin monitor = Util.getMonitorPlugin(context);\n            try {\n                // Start monitoring timer\n                if (monitor != null) {\n                    monitor.startTimer(HINT);\n                }\n                checkHibernate(context);\n\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(defaultDocument, context);\n                bTransaction = bTransaction && beginTransaction(sfactory, context);\n                try {\n                    Session session = getSession(context);\n                    session.setHibernateFlushMode(FlushMode.MANUAL);\n\n                    doc = session.get(XWikiDocument.class, doc.getId());\n                    if (doc == null) {\n                        defaultDocument.setNew(true);\n\n                        // Make sure to always return a document with an original version, even for one that does not\n                        // exist.\n                        // Allow writing more generic code.\n                        defaultDocument.setOriginalDocument(\n                            new XWikiDocument(defaultDocument.getDocumentReference(), defaultDocument.getLocale()));\n\n                        return defaultDocument;\n                    }\n\n                    doc.setStore(this);\n                    doc.setNew(false);\n                    doc.setMostRecent(true);\n                    // Fix for XWIKI-1651\n                    doc.setDate(new Date(doc.getDate().getTime()));\n                    doc.setCreationDate(new Date(doc.getCreationDate().getTime()));\n                    doc.setContentUpdateDate(new Date(doc.getContentUpdateDate().getTime()));\n\n                    // Loading the attachment list\n                    if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS)) {\n                        loadAttachmentList(doc, context, false);\n                    }\n\n                    // TODO: handle the case where there are no xWikiClass and xWikiObject in the Database\n                    BaseClass bclass = new BaseClass();\n                    String cxml = doc.getXClassXML();\n                    if (cxml != null) {\n                        bclass.fromXML(cxml);\n                        doc.setXClass(bclass);\n                        bclass.setDirty(false);\n                    }\n\n                    // Store this XWikiClass in the context so that we can use it in case of recursive usage\n                    // of classes\n                    context.addBaseClass(bclass);\n\n                    if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                        Query<BaseObject> query = session.createQuery(\n                            \"from BaseObject as bobject where bobject.name = :name order by bobject.number\",\n                            BaseObject.class);\n                        query.setParameter(\"name\", doc.getFullName());\n\n                        Iterator<BaseObject> it = query.list().iterator();\n\n                        EntityReference localGroupEntityReference = new EntityReference(\"XWikiGroups\",\n                            EntityType.DOCUMENT, new EntityReference(\"XWiki\", EntityType.SPACE));\n                        DocumentReference groupsDocumentReference = new DocumentReference(context.getWikiId(),\n                            localGroupEntityReference.getParent().getName(), localGroupEntityReference.getName());\n\n                        boolean hasGroups = false;\n                        while (it.hasNext()) {\n                            BaseObject object = it.next();\n                            DocumentReference classReference = object.getXClassReference();\n\n                            if (classReference == null) {\n                                continue;\n                            }\n\n                            // It seems to search before is case insensitive. And this would break the loading if we get\n                            // an\n                            // object which doesn't really belong to this document\n                            if (!object.getDocumentReference().equals(doc.getDocumentReference())) {\n                                continue;\n                            }\n\n                            BaseObject newobject;\n                            if (classReference.equals(doc.getDocumentReference())) {\n                                newobject = bclass.newCustomClassInstance(true);\n                            } else {\n                                newobject = BaseClass.newCustomClassInstance(classReference, true, context);\n                            }\n                            if (newobject != null) {\n                                newobject.setId(object.getId());\n                                newobject.setXClassReference(object.getRelativeXClassReference());\n                                newobject.setDocumentReference(object.getDocumentReference());\n                                newobject.setNumber(object.getNumber());\n                                newobject.setGuid(object.getGuid());\n                                object = newobject;\n                            }\n\n                            if (classReference.equals(groupsDocumentReference)) {\n                                // Groups objects are handled differently.\n                                hasGroups = true;\n                            } else {\n                                loadXWikiCollectionInternal(object, doc, context, false, true);\n                            }\n                            doc.setXObject(object.getNumber(), object);\n                        }\n\n                        // AFAICT this was added as an emergency patch because loading of objects has proven\n                        // too slow and the objects which cause the most overhead are the XWikiGroups objects\n                        // as each group object (each group member) would otherwise cost 2 database queries.\n                        // This will do every group member in a single query.\n                        if (hasGroups) {\n                            Query<Object[]> query2 = session.createQuery(\n                                \"select bobject.number, prop.value from StringProperty as prop,\"\n                                    + \"BaseObject as bobject where bobject.name = :name and bobject.className='XWiki.XWikiGroups' \"\n                                    + \"and bobject.id=prop.id.id and prop.id.name='member' order by bobject.number\",\n                                Object[].class);\n                            query2.setParameter(\"name\", doc.getFullName());\n\n                            Iterator<Object[]> it2 = query2.list().iterator();\n                            while (it2.hasNext()) {\n                                Object[] result = it2.next();\n                                Integer number = (Integer) result[0];\n                                String member = (String) result[1];\n                                BaseObject obj =\n                                    BaseClass.newCustomClassInstance(groupsDocumentReference, true, context);\n                                obj.setDocumentReference(doc.getDocumentReference());\n                                obj.setXClassReference(localGroupEntityReference);\n                                obj.setNumber(number.intValue());\n                                obj.setStringValue(\"member\", member);\n                                doc.setXObject(obj.getNumber(), obj);\n                            }\n                        }\n                    }\n\n                    doc.setContentDirty(false);\n                    doc.setMetaDataDirty(false);\n\n                    // We need to ensure that the loaded document becomes the original document\n                    doc.setOriginalDocument(doc.clone());\n\n                    if (bTransaction) {\n                        endTransaction(context, false);\n                    }\n                } finally {\n                    if (bTransaction) {\n                        try {\n                            endTransaction(context, false);\n                        } catch (Exception e) {\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                Object[] args = {defaultDocument.getDocumentReferenceWithLocale()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_READING_DOC, \"Exception while reading document [{0}]\", e,\n                    args);\n            } finally {\n                // End monitoring timer\n                if (monitor != null) {\n                    monitor.endTimer(HINT);\n                }\n            }\n\n            this.logger.debug(\"Loaded XWikiDocument: [{}]\", doc.getDocumentReferenceWithLocale());\n\n            return doc;\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    @Override\n    public void deleteXWikiDoc(XWikiDocument doc, XWikiContext inputxcontext) throws XWikiException\n    {\n        deleteXWikiDoc(doc, inputxcontext, true);\n    }\n\n    private void deleteXWikiDoc(XWikiDocument doc, XWikiContext inputxcontext, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            MonitorPlugin monitor = Util.getMonitorPlugin(context);\n            try {\n                // Start monitoring timer\n                if (monitor != null) {\n                    monitor.startTimer(HINT);\n                }\n                checkHibernate(context);\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                if (bTransaction) {\n                    bTransaction = beginTransaction(sfactory, context);\n                }\n                try {\n                    Session session = getSession(context);\n                    session.setHibernateFlushMode(FlushMode.COMMIT);\n\n                    if (doc.getStore() == null) {\n                        Object[] args = {doc.getDocumentReference()};\n                        throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                            XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CANNOT_DELETE_UNLOADED_DOC,\n                            \"Impossible to delete document {0} if it is not loaded\", null, args);\n                    }\n\n                    // Let's delete any attachment this document might have\n                    for (XWikiAttachment attachment : doc.getAttachmentList()) {\n                        XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(attachment);\n                        store.deleteXWikiAttachment(attachment, false, context, false);\n                    }\n\n                    // deleting XWikiLinks\n                    if (context.getWiki().hasBacklinks(context)) {\n                        deleteLinks(doc.getId(), context, true);\n                    }\n\n                    // Find the list of classes for which we have an object\n                    // Remove properties planned for removal\n                    if (!doc.getXObjectsToRemove().isEmpty()) {\n                        for (BaseObject bobj : doc.getXObjectsToRemove()) {\n                            if (bobj != null) {\n                                deleteXWikiCollection(bobj, context, false, false);\n                            }\n                        }\n                        doc.setXObjectsToRemove(new ArrayList<BaseObject>());\n                    }\n                    for (List<BaseObject> objects : doc.getXObjects().values()) {\n                        for (BaseObject obj : objects) {\n                            if (obj != null) {\n                                deleteXWikiCollection(obj, context, false, false);\n                            }\n                        }\n                    }\n                    context.getWiki().getVersioningStore().deleteArchive(doc, false, context);\n\n                    session.delete(doc);\n\n                    // We need to ensure that the deleted document becomes the original document\n                    doc.setOriginalDocument(doc.clone());\n\n                    // Update space table if needed\n                    maybeDeleteXWikiSpace(doc, session);\n\n                    if (bTransaction) {\n                        endTransaction(context, true);\n                    }\n                } finally {\n                    if (bTransaction) {\n                        try {\n                            endTransaction(context, false);\n                        } catch (Exception e) {\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                Object[] args = {doc.getDocumentReference()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC, \"Exception while deleting document {0}\", e,\n                    args);\n            } finally {\n                // End monitoring timer\n                if (monitor != null) {\n                    monitor.endTimer(HINT);\n                }\n            }\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    private void maybeDeleteXWikiSpace(XWikiDocument deletedDocument, Session session)\n    {\n        if (deletedDocument.getLocale().equals(Locale.ROOT)) {\n            DocumentReference documentReference = deletedDocument.getDocumentReference();\n            maybeDeleteXWikiSpace(documentReference.getLastSpaceReference(),\n                this.localEntityReferenceSerializer.serialize(documentReference), session);\n        }\n    }\n\n    private void maybeDeleteXWikiSpace(SpaceReference spaceReference, String deletedDocument, Session session)\n    {\n        if (!hasDocuments(spaceReference, session,\n            \"fullName <> :deletedDocument AND (language IS NULL OR language = '')\",\n            Collections.singletonMap(\"deletedDocument\", deletedDocument))) {\n            // The document was the last document in the space\n            XWikiSpace space = new XWikiSpace(spaceReference, this);\n\n            session.delete(space);\n\n            // Update parent\n            if (spaceReference.getParent() instanceof SpaceReference) {\n                maybeDeleteXWikiSpace((SpaceReference) spaceReference.getParent(), deletedDocument, session);\n            }\n        } else {\n            // Update space hidden property if needed\n            maybeMakeSpaceHidden(spaceReference, deletedDocument, session);\n        }\n    }\n\n    private XWikiSpace loadXWikiSpace(SpaceReference spaceReference, Session session)\n    {\n        XWikiSpace space = session.get(XWikiSpace.class, XWikiSpace.getId(spaceReference));\n\n        if (space != null) {\n            space.setStore(this);\n        }\n        return space;\n    }\n\n    private void checkObjectClassIsLocal(BaseCollection object, XWikiContext context) throws XWikiException\n    {\n        DocumentReference xclass = object.getXClassReference();\n        WikiReference wikiReference = xclass.getWikiReference();\n        String db = context.getWikiId();\n        if (!wikiReference.getName().equals(db)) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_OBJECT,\n                \"XObject [{0}] is an instance of an external XClass and cannot be persisted in this wiki [{1}].\", null,\n                new Object[] {this.localEntityReferenceSerializer.serialize(object.getReference()), db});\n        }\n    }\n\n    /**\n     * @deprecated This is internal to XWikiHibernateStore and may be removed in the future.\n     */\n    @Deprecated\n    public void saveXWikiCollection(BaseCollection object, XWikiContext inputxcontext, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            if (object == null) {\n                return;\n            }\n            // We need a slightly different behavior here\n            boolean stats = (object instanceof XWikiStats);\n            if (!stats) {\n                checkObjectClassIsLocal(object, context);\n            }\n\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            try {\n                Session session = getSession(context);\n\n                // Verify if the property already exists\n                Query<Long> query;\n                if (stats) {\n                    query = session.createQuery(\n                        \"select obj.id from \" + object.getClass().getName() + \" as obj where obj.id = :id\", Long.class);\n                } else {\n                    query = session.createQuery(\"select obj.id from BaseObject as obj where obj.id = :id\", Long.class);\n                }\n                query.setParameter(\"id\", object.getId());\n                if (query.uniqueResult() == null) {\n                    if (stats) {\n                        session.save(object);\n                    } else {\n                        session.save(\"com.xpn.xwiki.objects.BaseObject\", object);\n                    }\n                } else {\n                    if (stats) {\n                        session.update(object);\n                    } else {\n                        session.update(\"com.xpn.xwiki.objects.BaseObject\", object);\n                    }\n                }\n                /*\n                 * if (stats) session.saveOrUpdate(object); else\n                 * session.saveOrUpdate((String)\"com.xpn.xwiki.objects.BaseObject\", (Object)object);\n                 */\n                BaseClass bclass = object.getXClass(context);\n                List<String> handledProps = new ArrayList<>();\n                if ((bclass != null) && (bclass.hasCustomMapping()) && context.getWiki().hasCustomMappings()) {\n                    // save object using the custom mapping\n                    Map<String, Object> objmap = object.getCustomMappingMap();\n                    handledProps = bclass.getCustomMappingPropertyList(context);\n                    query = session.createQuery(\"select obj.id from \" + bclass.getName() + \" as obj where obj.id = :id\",\n                        Long.class);\n                    query.setParameter(\"id\", object.getId());\n                    if (query.uniqueResult() == null) {\n                        session.save(bclass.getName(), objmap);\n                    } else {\n                        session.update(bclass.getName(), objmap);\n                    }\n\n                    // dynamicSession.saveOrUpdate((String) bclass.getName(), objmap);\n                }\n\n                if (object.getXClassReference() != null) {\n                    // Remove properties to remove\n                    if (!object.getFieldsToRemove().isEmpty()) {\n                        for (int i = 0; i < object.getFieldsToRemove().size(); i++) {\n                            BaseProperty prop = (BaseProperty) object.getFieldsToRemove().get(i);\n                            if (!handledProps.contains(prop.getName())) {\n                                session.delete(prop);\n                            }\n                        }\n                        object.setFieldsToRemove(new ArrayList<>());\n                    }\n\n                    // Add missing properties to the object\n                    BaseClass xclass = object.getXClass(context);\n                    if (xclass != null) {\n                        for (String key : xclass.getPropertyList()) {\n                            if (object.safeget(key) == null) {\n                                PropertyClass classProperty = (PropertyClass) xclass.getField(key);\n                                BaseProperty property = classProperty.newProperty();\n                                if (property != null) {\n                                    object.safeput(key, property);\n                                }\n                            }\n                        }\n                    }\n\n                    // Save properties\n                    Iterator<String> it = object.getPropertyList().iterator();\n                    while (it.hasNext()) {\n                        String key = it.next();\n                        BaseProperty prop = (BaseProperty) object.getField(key);\n                        if (!prop.getName().equals(key)) {\n                            Object[] args = {key, object.getName()};\n                            throw new XWikiException(XWikiException.MODULE_XWIKI_CLASSES,\n                                XWikiException.ERROR_XWIKI_CLASSES_FIELD_INVALID,\n                                \"Field {0} in object {1} has an invalid name\", null, args);\n                        }\n\n                        String pname = prop.getName();\n                        if (pname != null && !pname.trim().equals(\"\") && !handledProps.contains(pname)) {\n                            saveXWikiPropertyInternal(prop, context, false);\n                        }\n                    }\n                }\n\n                if (bTransaction) {\n                    endTransaction(context, true);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        endTransaction(context, true);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        } catch (XWikiException xe) {\n            throw xe;\n        } catch (Exception e) {\n            Object[] args = {object.getName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_OBJECT, \"Exception while saving object {0}\", e, args);\n\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    /**\n     * @deprecated This is internal to XWikiHibernateStore and may be removed in the future.\n     */\n    @Deprecated\n    public void loadXWikiCollection(BaseCollection object, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        loadXWikiCollectionInternal(object, context, bTransaction, false);\n    }\n\n    private void loadXWikiCollectionInternal(BaseCollection object, XWikiContext context, boolean bTransaction,\n        boolean alreadyLoaded) throws XWikiException\n    {\n        loadXWikiCollectionInternal(object, null, context, bTransaction, alreadyLoaded);\n    }\n\n    private void loadXWikiCollectionInternal(BaseCollection object1, XWikiDocument doc, XWikiContext inputxcontext,\n        boolean bTransaction, boolean alreadyLoaded) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        BaseCollection object = object1;\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            try {\n                Session session = getSession(context);\n\n                if (!alreadyLoaded) {\n                    try {\n                        session.load(object, object1.getId());\n                    } catch (ObjectNotFoundException e) {\n                        // There is no object data saved\n                        object = null;\n                        return;\n                    }\n                }\n\n                DocumentReference classReference = object.getXClassReference();\n\n                // If the class reference is null in the loaded object then skip loading properties\n                if (classReference != null) {\n\n                    BaseClass bclass = null;\n                    if (!classReference.equals(object.getDocumentReference())) {\n                        // Let's check if the class has a custom mapping\n                        bclass = object.getXClass(context);\n                    } else {\n                        // We need to get it from the document otherwise\n                        // we will go in an endless loop\n                        if (doc != null) {\n                            bclass = doc.getXClass();\n                        }\n                    }\n\n                    List<String> handledProps = new ArrayList<>();\n                    try {\n                        if ((bclass != null) && (bclass.hasCustomMapping()) && context.getWiki().hasCustomMappings()) {\n                            String className =\n                                this.localEntityReferenceSerializer.serialize(bclass.getDocumentReference());\n                            @SuppressWarnings(\"unchecked\")\n                            Map<String, ?> map = (Map<String, ?>) session.load(className, object.getId());\n                            // Let's make sure to look for null fields in the dynamic mapping\n                            bclass.fromValueMap(map, object);\n                            for (String prop : bclass.getCustomMappingPropertyList(context)) {\n                                if (map.get(prop) != null) {\n                                    handledProps.add(prop);\n                                }\n                            }\n                        }\n                    } catch (HibernateException e) {\n                        this.logger.error(\"Failed loading custom mapping for doc [{}], class [{}], nb [{}]\",\n                            object.getDocumentReference(), object.getXClassReference(), object.getNumber(), e);\n                    }\n\n                    // Load strings, integers, dates all at once\n\n                    Query<Object[]> query = session.createQuery(\n                        \"select prop.name, prop.classType from BaseProperty as prop where prop.id.id = :id\",\n                        Object[].class);\n                    query.setParameter(\"id\", object.getId());\n                    for (Object[] result : (List<Object[]>) query.list()) {\n                        String name = (String) result[0];\n                        // No need to load fields already loaded from\n                        // custom mapping\n                        if (handledProps.contains(name)) {\n                            continue;\n                        }\n                        String classType = (String) result[1];\n                        BaseProperty property = null;\n\n                        try {\n                            property = (BaseProperty) Class.forName(classType).newInstance();\n                            property.setObject(object);\n                            property.setName(name);\n                            loadXWikiProperty(property, context, false);\n                        } catch (Exception e) {\n                            // WORKAROUND IN CASE OF MIXMATCH BETWEEN STRING AND LARGESTRING\n                            try {\n                                if (property instanceof StringProperty) {\n                                    LargeStringProperty property2 = new LargeStringProperty();\n                                    property2.setObject(object);\n                                    property2.setName(name);\n                                    loadXWikiProperty(property2, context, false);\n                                    property.setValue(property2.getValue());\n\n                                    if (bclass != null) {\n                                        if (bclass.get(name) instanceof TextAreaClass) {\n                                            property = property2;\n                                        }\n                                    }\n\n                                } else if (property instanceof LargeStringProperty) {\n                                    StringProperty property2 = new StringProperty();\n                                    property2.setObject(object);\n                                    property2.setName(name);\n                                    loadXWikiProperty(property2, context, false);\n                                    property.setValue(property2.getValue());\n\n                                    if (bclass != null) {\n                                        if (bclass.get(name) instanceof StringClass) {\n                                            property = property2;\n                                        }\n                                    }\n                                } else {\n                                    throw e;\n                                }\n                            } catch (Throwable e2) {\n                                Object[] args = {object.getName(), object.getClass(),\n                                    Integer.valueOf(object.getNumber() + \"\"), name};\n                                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\n                                    \"Exception while loading object [{0}] of class [{1}], number [{2}] and property [{3}]\",\n                                    e, args);\n                            }\n                        }\n\n                        object.addField(name, property);\n                    }\n                }\n\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        endTransaction(context, false);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            Object[] args = {object.getName(), object.getClass(), object.getNumber()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\n                \"Exception while loading object [{0}] of class [{1}] and number [{2}]\", e, args);\n\n        } finally {\n            restoreExecutionXContext();\n        }\n\n    }\n\n    /**\n     * @deprecated This is internal to XWikiHibernateStore and may be removed in the future.\n     */\n    @Deprecated\n    public void deleteXWikiCollection(BaseCollection object, XWikiContext inputxcontext, boolean bTransaction,\n        boolean evict) throws XWikiException\n    {\n        if (object == null) {\n            return;\n        }\n\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            try {\n                Session session = getSession(context);\n\n                // Let's check if the class has a custom mapping\n                BaseClass bclass = object.getXClass(context);\n                List<String> handledProps = new ArrayList<>();\n                if ((bclass != null) && (bclass.hasCustomMapping()) && context.getWiki().hasCustomMappings()) {\n                    handledProps = bclass.getCustomMappingPropertyList(context);\n                    Object map = session.get(bclass.getName(), object.getId());\n                    if (map != null) {\n                        if (evict) {\n                            session.evict(map);\n                        }\n                        session.delete(map);\n                    }\n                }\n\n                if (object.getXClassReference() != null) {\n                    for (BaseElement property : (Collection<BaseElement>) object.getFieldList()) {\n                        if (!handledProps.contains(property.getName())) {\n                            if (evict) {\n                                session.evict(property);\n                            }\n                            if (session.get(property.getClass(), property) != null) {\n                                session.delete(property);\n                            }\n                        }\n                    }\n                }\n\n                // In case of custom class we need to force it as BaseObject to delete the xwikiobject row\n                if (!\"\".equals(bclass.getCustomClass())) {\n                    BaseObject cobject = new BaseObject();\n                    cobject.setDocumentReference(object.getDocumentReference());\n                    cobject.setClassName(object.getClassName());\n                    cobject.setNumber(object.getNumber());\n                    if (object instanceof BaseObject) {\n                        cobject.setGuid(((BaseObject) object).getGuid());\n                    }\n                    cobject.setId(object.getId());\n                    if (evict) {\n                        session.evict(cobject);\n                    }\n                    session.delete(cobject);\n                } else {\n                    if (evict) {\n                        session.evict(object);\n                    }\n                    session.delete(object);\n                }\n\n                if (bTransaction) {\n                    endTransaction(context, true);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        endTransaction(context, false);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            Object[] args = {object.getName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_OBJECT, \"Exception while deleting object {0}\", e,\n                args);\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    private void loadXWikiProperty(PropertyInterface property, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        executeRead(context, session -> {\n            try {\n                try {\n                    session.load(property, (Serializable) property);\n                    // In Oracle, empty string are converted to NULL. Since an undefined property is not found at all,\n                    // it is\n                    // safe to assume that a retrieved NULL value should actually be an empty string.\n                    if (property instanceof BaseStringProperty) {\n                        BaseStringProperty stringProperty = (BaseStringProperty) property;\n                        if (stringProperty.getValue() == null) {\n                            stringProperty.setValue(\"\");\n                        }\n                    }\n                    ((BaseProperty) property).setValueDirty(false);\n                } catch (ObjectNotFoundException e) {\n                    // Let's accept that there is no data in property tables but log it\n                    this.logger.error(\"No data for property [{}] of object id [{}]\", property.getName(),\n                        property.getId());\n                }\n\n                // TODO: understand why collections are lazy loaded\n                // Let's force reading lists if there is a list\n                // This seems to be an issue since Hibernate 3.0\n                // Without this test ViewEditTest.testUpdateAdvanceObjectProp fails\n                if (property instanceof ListProperty) {\n                    ((ListProperty) property).getList();\n                }\n            } catch (Exception e) {\n                BaseCollection obj = property.getObject();\n                Object[] args = {(obj != null) ? obj.getName() : \"unknown\", property.getName()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\n                    \"Exception while loading property {1} of object {0}\", e, args);\n\n            }\n\n            return null;\n        });\n    }\n\n    private void saveXWikiPropertyInternal(final PropertyInterface property, final XWikiContext context,\n        final boolean runInOwnTransaction) throws XWikiException\n    {\n        // Clone runInOwnTransaction so the value passed is not altered.\n        boolean bTransaction = runInOwnTransaction;\n        try {\n            if (bTransaction) {\n                this.checkHibernate(context);\n                bTransaction = this.beginTransaction(context);\n            }\n            try {\n                final Session session = this.getSession(context);\n\n                Query<String> query = session.createQuery(\n                    \"select prop.classType from BaseProperty as prop where prop.id.id = :id and prop.id.name= :name\",\n                    String.class);\n                query.setParameter(\"id\", property.getId());\n                query.setParameter(\"name\", property.getName());\n\n                String oldClassType = query.uniqueResult();\n                String newClassType = ((BaseProperty) property).getClassType();\n                if (oldClassType == null) {\n                    session.save(property);\n                } else if (oldClassType.equals(newClassType)) {\n                    session.update(property);\n                } else {\n                    // The property type has changed. We cannot simply update its value because the new value and the\n                    // old\n                    // value are stored in different tables (we're using joined-subclass to map different property\n                    // types).\n                    // We must delete the old property value before saving the new one and for this we must load the old\n                    // property from the table that corresponds to the old property type (we cannot delete and save the\n                    // new\n                    // property or delete a clone of the new property; loading the old property from the BaseProperty\n                    // table\n                    // doesn't work either).\n                    Query propQuery = session.createQuery(\n                        \"select prop from \" + oldClassType + \" as prop where prop.id.id = :id and prop.id.name= :name\");\n                    propQuery.setParameter(\"id\", property.getId());\n                    propQuery.setParameter(\"name\", property.getName());\n                    session.delete(propQuery.uniqueResult());\n                    session.save(property);\n                }\n\n                ((BaseProperty) property).setValueDirty(false);\n\n                if (bTransaction) {\n                    endTransaction(context, true);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        this.endTransaction(context, false);\n                    } catch (Exception ee) {\n                        // Not a lot we can do here if there was an exception committing and an exception rolling back.\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Something went wrong, collect some information.\n            final BaseCollection obj = property.getObject();\n            final Object[] args = {(obj != null) ? obj.getName() : \"unknown\", property.getName()};\n\n            // Throw the exception.\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\n                \"Exception while saving property {1} of object {0}\", e, args);\n        }\n    }\n\n    private void loadAttachmentList(XWikiDocument doc, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        executeRead(context, session -> {\n            try {\n                Query<XWikiAttachment> query = session\n                    .createQuery(\"from XWikiAttachment as attach where attach.docId=:docid\", XWikiAttachment.class);\n                query.setParameter(\"docid\", doc.getId());\n\n                List<XWikiAttachment> list = query.list();\n                for (XWikiAttachment attachment : list) {\n                    doc.setAttachment(attachment);\n                }\n\n                return null;\n            } catch (Exception e) {\n                this.logger.error(\"Failed to load attachments of document [{}]\", doc.getDocumentReference(), e);\n\n                Object[] args = {doc.getDocumentReference()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCHING_ATTACHMENT,\n                    \"Exception while searching attachments for documents {0}\", e, args);\n            }\n        });\n    }\n\n    private boolean isDeleted(XWikiAttachment attachment, XWikiDocument doc)\n    {\n        for (XWikiAttachmentToRemove attachmentToRemove : doc.getAttachmentsToRemove()) {\n            if (attachmentToRemove.getAttachment().getFilename().equals(attachment.getFilename())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private void saveAttachmentList(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        try {\n            List<XWikiAttachment> list = doc.getAttachmentList();\n            for (XWikiAttachment attachment : list) {\n                saveAttachment(attachment, isDeleted(attachment, doc), context);\n            }\n\n        } catch (Exception e) {\n            Object[] args = {doc.getDocumentReference()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_ATTACHMENT_LIST,\n                \"Exception while saving attachments attachment list of document {0}\", e, args);\n        }\n    }\n\n    private void saveAttachment(XWikiAttachment attachment, boolean deleted, XWikiContext context) throws XWikiException\n    {\n        try {\n            // If the comment is larger than the max size supported by the Storage, then abbreviate it\n            String comment = attachment.getComment();\n            if (comment != null && comment.length() > 1023) {\n                attachment.setComment(StringUtils.abbreviate(comment, 1023));\n            }\n\n            Session session = getSession(context);\n\n            Query<Long> query = session\n                .createQuery(\"select attach.id from XWikiAttachment as attach where attach.id = :id\", Long.class);\n            query.setParameter(\"id\", attachment.getId());\n            boolean exist = query.uniqueResult() != null;\n\n            boolean saveContent;\n            if (exist) {\n                // Don't update the history if the document was actually not supposed to exist\n                // Don't update the attachment version if document metadata dirty is forced false (any modification to\n                // the attachment automatically set document metadata dirty to true)\n                if (!deleted && attachment.isContentDirty() && attachment.getDoc().isMetaDataDirty()) {\n                    attachment.updateContentArchive(context);\n                }\n\n                session.update(attachment);\n\n                // Save the attachment content if it's marked as \"dirty\" (out of sync with the database).\n                saveContent = attachment.isContentDirty();\n            } else {\n                if (attachment.getContentStore() == null) {\n                    // Set content store\n                    attachment.setContentStore(getDefaultAttachmentContentStore(context));\n                }\n\n                if (attachment.getArchiveStore() == null) {\n                    // Set archive store\n                    attachment.setArchiveStore(getDefaultAttachmentArchiveStore(context));\n                }\n\n                session.save(attachment);\n\n                // Always save the content since it does not exist\n                saveContent = true;\n            }\n\n            if (saveContent) {\n                // updateParent and bTransaction must be false because the content should be saved in the same\n                // transaction as the attachment and if the parent doc needs to be updated, this function will do it.\n                XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(attachment);\n                store.saveAttachmentContent(attachment, false, context, false);\n            }\n\n            // Mark the attachment content and metadata as not dirty.\n            // Ideally this would only happen if the transaction is committed successfully but since an unsuccessful\n            // transaction will most likely be accompanied by an exception, the cache will not have a chance to save\n            // the copy of the document with erroneous information. If this is not set here, the cache will return\n            // a copy of the attachment which claims to be dirty although it isn't.\n            attachment.setMetaDataDirty(false);\n            if (attachment.isContentDirty()) {\n                attachment.getAttachment_content().setContentDirty(false);\n            }\n\n        } catch (Exception e) {\n            Object[] args = {attachment.getReference()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_ATTACHMENT, \"Exception while saving attachment [{0}]\",\n                e, args);\n        }\n    }\n\n    // ---------------------------------------\n    // Locks\n    // ---------------------------------------\n\n    @Override\n    public XWikiLock loadLock(long docId, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                XWikiLock lock = null;\n\n                Query<Long> query = session\n                    .createQuery(\"select lock.docId from XWikiLock as lock where lock.docId = :docId\", Long.class);\n                query.setParameter(\"docId\", docId);\n                if (query.uniqueResult() != null) {\n                    lock = new XWikiLock();\n                    session.load(lock, Long.valueOf(docId));\n                }\n\n                return lock;\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_LOCK, \"Exception while loading lock\", e);\n            }\n        });\n    }\n\n    @Override\n    public void saveLock(XWikiLock lock, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        executeWrite(inputxcontext, session -> {\n            try {\n                Query<Long> query = session\n                    .createQuery(\"select lock.docId from XWikiLock as lock where lock.docId = :docId\", Long.class);\n                query.setParameter(\"docId\", lock.getDocId());\n                if (query.uniqueResult() == null) {\n                    session.save(lock);\n                } else {\n                    session.update(lock);\n                }\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_LOCK,\n                    String.format(\"Exception while locking document for lock [%s]\", lock.toString()), e);\n            }\n\n            return null;\n        });\n    }\n\n    @Override\n    public void deleteLock(XWikiLock lock, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        executeWrite(inputxcontext, session -> {\n            try {\n                session.delete(lock);\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_LOCK, \"Exception while deleting lock\", e);\n            }\n\n            return null;\n        });\n    }\n\n    private void registerLogoutListener()\n    {\n        this.observationManager.addListener(new EventListener()\n        {\n            private final Event ev = new ActionExecutingEvent();\n\n            @Override\n            public String getName()\n            {\n                return \"deleteLocksOnLogoutListener\";\n            }\n\n            @Override\n            public List<Event> getEvents()\n            {\n                return Collections.<Event>singletonList(this.ev);\n            }\n\n            @Override\n            public void onEvent(Event event, Object source, Object data)\n            {\n                if (\"logout\".equals(((ActionExecutingEvent) event).getActionName())) {\n                    final XWikiContext ctx = (XWikiContext) data;\n                    if (ctx.getUserReference() != null) {\n                        releaseAllLocksForCurrentUser(ctx);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Release all of the locks held by the currently logged in user.\n     *\n     * @param ctx the XWikiContext, used to start the connection and get the user name.\n     */\n    private void releaseAllLocksForCurrentUser(final XWikiContext ctx)\n    {\n        try {\n            executeWrite(ctx, session -> {\n                final Query query = session.createQuery(\"delete from XWikiLock as lock where lock.userName=:userName\");\n                // Using deprecated getUser() because this is how locks are created.\n                // It would be a maintainibility disaster to use different code paths\n                // for calculating names when creating and removing.\n                query.setParameter(\"userName\", ctx.getUser());\n                query.executeUpdate();\n\n                return null;\n            });\n        } catch (Exception e) {\n            String msg = \"Error while deleting active locks held by user.\";\n            try {\n                this.endTransaction(ctx, false);\n            } catch (Exception utoh) {\n                msg += \" Failed to commit OR rollback [\" + utoh.getMessage() + \"]\";\n            }\n            throw new UnexpectedException(msg, e);\n        }\n\n        // If we're in a non-main wiki & the user is global,\n        // switch to the global wiki and delete locks held there.\n        if (!ctx.isMainWiki() && ctx.isMainWiki(ctx.getUserReference().getWikiReference().getName())) {\n            final String cdb = ctx.getWikiId();\n            try {\n                ctx.setWikiId(ctx.getMainXWiki());\n                this.releaseAllLocksForCurrentUser(ctx);\n            } finally {\n                ctx.setWikiId(cdb);\n            }\n        }\n    }\n\n    // ---------------------------------------\n    // Links\n    // ---------------------------------------\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public List<XWikiLink> loadLinks(long docId, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                Query<XWikiLink> query =\n                    session.createQuery(\" from XWikiLink as link where link.id.docId = :docId\", XWikiLink.class);\n                query.setParameter(\"docId\", docId);\n\n                return query.list();\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_LINKS, \"Exception while loading links\", e);\n            }\n        });\n    }\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public List<DocumentReference> loadBacklinks(DocumentReference documentReference, boolean bTransaction,\n        XWikiContext inputxcontext) throws XWikiException\n    {\n        return innerLoadBacklinks(inputxcontext, (Session session) -> {\n            // the select clause is compulsory to reach the fullName i.e. the page pointed\n            Query<String> query = session.createQuery(\n                \"select distinct backlink.fullName from XWikiLink as backlink where backlink.id.link = :backlink\",\n                String.class);\n\n            // if we are in the same wiki context, we should only get the local reference\n            // but if we are not, then we have to check the full reference, containing the wiki part since\n            // it's how the link are recorded.\n            // This should be changed once the refactoring to support backlinks properly has been done.\n            // See: XWIKI-16192\n            query.setParameter(\"backlink\", this.compactWikiEntityReferenceSerializer.serialize(documentReference));\n            return query;\n        });\n    }\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public List<DocumentReference> loadBacklinks(AttachmentReference attachmentReference, boolean bTransaction,\n        XWikiContext inputxcontext) throws XWikiException\n    {\n        return innerLoadBacklinks(inputxcontext, (Session session) -> {\n            // the select clause is compulsory to reach the fullName i.e. the page pointed\n            Query<String> query = session.createQuery(\n                \"select distinct backlink.fullName from XWikiLink as backlink \" + \"where backlink.id.link = :backlink \"\n                    + \"and backlink.id.type = :type \" + \"and backlink.attachmentName = :attachmentName\",\n                String.class);\n\n            // if we are in the same wiki context, we should only get the local reference\n            // but if we are not, then we have to check the full reference, containing the wiki part since\n            // it's how the link are recorded.\n            // This should be changed once the refactoring to support backlinks properly has been done.\n            // See: XWIKI-16192\n            query.setParameter(\"backlink\",\n                this.compactWikiEntityReferenceSerializer.serialize(attachmentReference.getDocumentReference()));\n            query.setParameter(\"type\", attachmentReference.getType().getLowerCase());\n            query.setParameter(\"attachmentName\", attachmentReference.getName());\n            return query;\n        });\n    }\n\n    private List<DocumentReference> innerLoadBacklinks(XWikiContext inputxcontext,\n        Function<Session, Query<String>> queryBuilder) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                // Note: Ideally the method should return a Set but it would break the current API.\n\n                // TODO: We use a Set here so that we don't get duplicates. In the future, when we can reference a page\n                // in\n                // another language using a syntax, we should modify this code to return one DocumentReference per\n                // language\n                // found. To implement this we need to be able to either serialize the reference with the language\n                // information\n                // or add some new column for the XWikiLink table in the database.\n                Set<DocumentReference> backlinkReferences = new HashSet<>();\n\n                Query<String> apply = queryBuilder.apply(session);\n                List<String> backlinkNames = apply.list();\n\n                // Convert strings into references\n                for (String backlinkName : backlinkNames) {\n                    DocumentReference backlinkreference =\n                        this.currentMixedDocumentReferenceResolver.resolve(backlinkName);\n                    backlinkReferences.add(backlinkreference);\n                }\n\n                return new ArrayList<>(backlinkReferences);\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_BACKLINKS, \"Exception while loading backlinks\",\n                    e);\n            }\n        });\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #loadBacklinks(DocumentReference, boolean, XWikiContext)}\n     */\n    @Deprecated\n    @Override\n    public List<String> loadBacklinks(String fullName, XWikiContext inputxcontext, boolean bTransaction)\n        throws XWikiException\n    {\n        List<String> backlinkNames = new ArrayList<>();\n        List<DocumentReference> backlinkReferences =\n            loadBacklinks(this.currentMixedDocumentReferenceResolver.resolve(fullName), bTransaction, inputxcontext);\n        for (DocumentReference backlinkReference : backlinkReferences) {\n            backlinkNames.add(this.localEntityReferenceSerializer.serialize(backlinkReference));\n        }\n        return backlinkNames;\n    }\n\n    private Set<XWikiLink> extractLinks(XWikiDocument doc, XWikiContext context)\n    {\n        Set<XWikiLink> links = new LinkedHashSet<>();\n\n        String fullName = this.localEntityReferenceSerializer.serialize(doc.getDocumentReference());\n\n        // Add entity references.\n        for (EntityReference entityReference : doc.getUniqueLinkedEntities(context)) {\n            XWikiLink wikiLink = new XWikiLink();\n\n            wikiLink.setDocId(doc.getId());\n            wikiLink.setFullName(fullName);\n\n            // getUniqueLinkedEntities() returns both DOCUMENT and PAGE references (and ATTACHMENT and\n            // PAGE_ATTACHMENT references). If the reference is a PageReference (or a PageAttachmentReference) then\n            // we can't know if it points to a terminal page or a non-terminal one, and thus we need to get the\n            // document to check if it exists, starting with the non-terminal one since \"[[page:test]]\" points\n            // first to the non-terminal page when it exists.\n            EntityReference documentReferenceToSerialize = convertToDocumentReference(entityReference);\n            wikiLink.setLink(this.compactWikiEntityReferenceSerializer.serialize(documentReferenceToSerialize));\n            boolean isAttachmentReference = false;\n            if (Objects.equals(entityReference.getType(), EntityType.ATTACHMENT)\n                || Objects.equals(entityReference.getType(), EntityType.PAGE_ATTACHMENT)) {\n                wikiLink.setAttachmentName(entityReference.getName());\n                isAttachmentReference = true;\n            }\n            wikiLink.setType(\n                isAttachmentReference ? EntityType.ATTACHMENT.getLowerCase() : EntityType.DOCUMENT.getLowerCase());\n\n            links.add(wikiLink);\n        }\n\n        // Add included pages.\n        List<String> includedPages = doc.getIncludedPages(context);\n        for (String includedPage : includedPages) {\n            XWikiLink wikiLink = new XWikiLink();\n\n            wikiLink.setDocId(doc.getId());\n            wikiLink.setFullName(fullName);\n            wikiLink.setLink(includedPage);\n            wikiLink.setType(EntityType.DOCUMENT.getLowerCase());\n            links.add(wikiLink);\n        }\n\n        return links;\n    }\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public void saveLinks(XWikiDocument doc, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        // Extract the links\n        Set<XWikiLink> links = extractLinks(doc, context);\n\n        // Save the links\n        executeWrite(context, session -> {\n            // We delete the existing links before saving the newly analyzed ones. Unless non exists yet.\n            if (countLinks(doc.getId(), context, false) > 0) {\n                deleteLinks(doc.getId(), context, false);\n            }\n\n            // necessary to blank links from doc\n            context.remove(\"links\");\n\n            if (!links.isEmpty()) {\n                // Get link size limit\n                int linkMaxSize = getLimitSize(context, XWikiLink.class, \"link\");\n\n                // Save the links.\n                for (XWikiLink wikiLink : links) {\n                    // Verify that the link reference isn't larger than the maximum size of the field since otherwise\n                    // that would lead to a DB error that would result in a fatal error, and the user would have a hard\n                    // time understanding why his page failed to be saved.\n                    if (wikiLink.getLink().length() <= linkMaxSize) {\n                        session.save(wikiLink);\n                    } else {\n                        this.logger.warn(\"Could not store backlink [{}] because the link reference [{}] is too big\",\n                            wikiLink, wikiLink.getLink());\n                    }\n                }\n            }\n\n            return null;\n        });\n    }\n\n    private EntityReference convertToDocumentReference(EntityReference entityReference)\n    {\n        // The passed entityReference can of type DOCUMENT, ATTACHMENT, PAGE or PAGE_ATTACHMENT.\n        EntityReference documentReference = entityReference;\n        if (documentReference instanceof PageAttachmentReference) {\n            documentReference = documentReference.extractReference(EntityType.PAGE);\n        }\n        if (documentReference instanceof PageReference) {\n            // If the reference is a PageReference then we can't know if it points to a terminal page or a\n            // non-terminal one, and thus we need to resolve it.\n            documentReference =\n                this.currentPageReferenceDocumentReferenceResolver.resolve((PageReference) documentReference);\n        } else {\n            documentReference = documentReference.extractReference(EntityType.DOCUMENT);\n        }\n        return documentReference;\n    }\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public void deleteLinks(long docId, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        executeWrite(inputxcontext, session -> {\n            try {\n                Query<?> query = session.createQuery(\"delete from XWikiLink as link where link.id.docId = :docId\");\n                query.setParameter(\"docId\", docId);\n                query.executeUpdate();\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_LINKS, \"Exception while deleting links\", e);\n            }\n\n            return null;\n        });\n    }\n\n    public void getContent(XWikiDocument doc, StringBuffer buf)\n    {\n        buf.append(doc.getContent());\n    }\n\n    @Override\n    public List<String> getClassList(XWikiContext inputxcontext) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                Query<String> query = session.createQuery(\"select doc.fullName from XWikiDocument as doc \"\n                    + \"where (doc.xWikiClassXML is not null and doc.xWikiClassXML like '<%')\", String.class);\n                List<String> list = new ArrayList<>();\n                list.addAll(query.list());\n\n                return list;\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH, \"Exception while searching class list\", e);\n            }\n        });\n    }\n\n    private <T> Query<T> createQuery(Session session, String statement, Collection<?> parameterValues)\n    {\n        Query<T> query = session.createQuery(statement);\n\n        injectParameterListToQuery(LegacySessionImplementor.containsLegacyOrdinalStatement(statement) ? 0 : 1, query,\n            parameterValues);\n\n        return query;\n    }\n\n    /**\n     * Add values into named query.\n     *\n     * @param parameterId the parameter id to increment.\n     * @param query the query to fill.\n     * @param parameterValues the values to add to query.\n     * @return the id of the next parameter to add.\n     */\n    private int injectParameterListToQuery(int parameterId, Query<?> query, Collection<?> parameterValues)\n    {\n        int index = parameterId;\n\n        if (parameterValues != null) {\n            for (Iterator<?> valueIt = parameterValues.iterator(); valueIt.hasNext(); ++index) {\n                injectParameterToQuery(index, query, valueIt.next());\n            }\n        }\n\n        return index;\n    }\n\n    /**\n     * Add value into named query.\n     *\n     * @param parameterId the parameter id to increment.\n     * @param query the query to fill.\n     * @param parameterValue the values to add to query.\n     */\n    private void injectParameterToQuery(int parameterId, Query<?> query, Object parameterValue)\n    {\n        query.setParameter(parameterId, parameterValue);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String parametrizedSqlClause, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocumentReferences(parametrizedSqlClause, 0, 0, parameterValues, context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String parametrizedSqlClause, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocumentsNames(parametrizedSqlClause, 0, 0, parameterValues, context);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String parametrizedSqlClause, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select distinct doc.fullName\", parametrizedSqlClause);\n        return searchDocumentReferencesInternal(sql, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select distinct doc.fullName\", parametrizedSqlClause);\n        return searchDocumentsNamesInternal(sql, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String wheresql, XWikiContext context) throws XWikiException\n    {\n        return searchDocumentReferences(wheresql, 0, 0, \"\", context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String wheresql, XWikiContext context) throws XWikiException\n    {\n        return searchDocumentsNames(wheresql, 0, 0, \"\", context);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String wheresql, int nb, int start, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocumentReferences(wheresql, nb, start, \"\", context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String wheresql, int nb, int start, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocumentsNames(wheresql, nb, start, \"\", context);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String wheresql, int nb, int start, String selectColumns,\n        XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select distinct doc.fullName\", wheresql);\n        return searchDocumentReferencesInternal(sql, nb, start, Collections.EMPTY_LIST, context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String wheresql, int nb, int start, String selectColumns,\n        XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select distinct doc.fullName\", wheresql);\n        return searchDocumentsNamesInternal(sql, nb, start, Collections.EMPTY_LIST, context);\n    }\n\n    @Override\n    public <T> List<T> search(String sql, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return search(sql, nb, start, (List<?>) null, context);\n    }\n\n    @Override\n    public <T> List<T> search(String sql, int nb, int start, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        return search(sql, nb, start, null, parameterValues, context);\n    }\n\n    @Override\n    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)\n        throws XWikiException\n    {\n        return search(sql, nb, start, whereParams, null, context);\n    }\n\n    @Override\n    public <T> List<T> search(final String sql, int nb, int start, Object[][] whereParams, List<?> parameterValues,\n        XWikiContext inputxcontext) throws XWikiException\n    {\n        if (sql == null) {\n            return null;\n        }\n\n        return executeRead(inputxcontext, session -> {\n            try {\n                boolean legacyOrdinal = LegacySessionImplementor.containsLegacyOrdinalStatement(sql);\n\n                String statement = sql;\n\n                if (whereParams != null) {\n                    statement += generateWhereStatement(whereParams,\n                        legacyOrdinal ? -1 : CollectionUtils.size(parameterValues.size()));\n                }\n\n                statement = filterSQL(statement);\n                Query<T> query = session.createQuery(statement);\n\n                injectParameterListToQuery(legacyOrdinal ? 0 : 1, query, parameterValues);\n\n                if (whereParams != null) {\n                    int parameterIndex = CollectionUtils.size(parameterValues);\n                    if (legacyOrdinal) {\n                        ++parameterIndex;\n                    }\n                    for (Object[] whereParam : whereParams) {\n                        query.setParameter(parameterIndex++, whereParam[1]);\n                    }\n                }\n\n                if (start > 0) {\n                    query.setFirstResult(start);\n                }\n                if (nb > 0) {\n                    query.setMaxResults(nb);\n                }\n                List<T> list = new ArrayList<>();\n                list.addAll(query.list());\n\n                return list;\n            } catch (Exception e) {\n                Object[] args = {sql};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                    \"Exception while searching documents with sql {0}\", e, args);\n            }\n        });\n    }\n\n    private String generateWhereStatement(Object[][] whereParams, int previousIndex)\n    {\n        StringBuilder str = new StringBuilder();\n\n        int index = previousIndex;\n\n        str.append(\" where \");\n        for (int i = 0; i < whereParams.length; i++) {\n            if (i > 0) {\n                if (whereParams[i - 1].length >= 4 && whereParams[i - 1][3] != \"\" && whereParams[i - 1][3] != null) {\n                    str.append(\" \");\n                    str.append(whereParams[i - 1][3]);\n                    str.append(\" \");\n                } else {\n                    str.append(\" and \");\n                }\n            }\n            str.append(whereParams[i][0]);\n            if (whereParams[i].length >= 3 && whereParams[i][2] != \"\" && whereParams[i][2] != null) {\n                str.append(\" \");\n                str.append(whereParams[i][2]);\n                str.append(\" \");\n            } else {\n                str.append(\" = \");\n            }\n            str.append(\" ?\");\n            if (index > -1) {\n                str.append(++index);\n            }\n        }\n\n        return str.toString();\n    }\n\n    public List search(Query query, int nb, int start, XWikiContext inputxcontext) throws XWikiException\n    {\n        if (query == null) {\n            return null;\n        }\n\n        return executeRead(inputxcontext, session -> {\n            try {\n                if (start > 0) {\n                    query.setFirstResult(start);\n                }\n                if (nb > 0) {\n                    query.setMaxResults(nb);\n                }\n                Iterator it = query.list().iterator();\n                List list = new ArrayList<>();\n                while (it.hasNext()) {\n                    list.add(it.next());\n                }\n\n                return list;\n            } catch (Exception e) {\n                Object[] args = {query.toString()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                    \"Exception while searching documents with sql {0}\", e, args);\n            }\n        });\n    }\n\n    @Override\n    public int countDocuments(String wheresql, XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select count(distinct doc.fullName)\", wheresql);\n        List<Number> l = search(sql, 0, 0, context);\n        return l.get(0).intValue();\n    }\n\n    @Override\n    public int countDocuments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        String sql = createSQLQuery(\"select count(distinct doc.fullName)\", parametrizedSqlClause);\n        List l = search(sql, 0, 0, parameterValues, context);\n        return ((Number) l.get(0)).intValue();\n    }\n\n    /**\n     * @deprecated since 2.2M1 used {@link #searchDocumentReferencesInternal(String, int, int, List, XWikiContext)}\n     */\n    @Deprecated\n    private List<String> searchDocumentsNamesInternal(String sql, int nb, int start, List parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        List<String> documentNames = new ArrayList<>();\n        for (DocumentReference reference : searchDocumentReferencesInternal(sql, nb, start, parameterValues, context)) {\n            documentNames.add(this.compactWikiEntityReferenceSerializer.serialize(reference));\n        }\n        return documentNames;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    private List<DocumentReference> searchDocumentReferencesInternal(String sql, int nb, int start,\n        List<?> parameterValues, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            List<DocumentReference> documentReferences = new ArrayList<>();\n\n            // Construct a reference, using the current wiki as the wiki reference name. This is because the wiki\n            // name is not stored in the database for document references.\n            WikiReference wikiReference = new WikiReference(context.getWikiId());\n            for (Object result : this.searchGenericInternal(sql, nb, start, parameterValues, context)) {\n                // The select always contains several elements in case of order by so we have to support both Object[]\n                // and\n                // String\n                String referenceString;\n                if (result instanceof String) {\n                    referenceString = (String) result;\n                } else {\n                    referenceString = (String) ((Object[]) result)[0];\n                }\n\n                DocumentReference reference =\n                    this.defaultDocumentReferenceResolver.resolve(referenceString, wikiReference);\n\n                documentReferences.add(reference);\n            }\n\n            return documentReferences;\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    private <T> List<T> searchGenericInternal(String sql, int nb, int start, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        return executeRead(context, session -> {\n            try {\n                Query query = createQuery(session, filterSQL(sql), parameterValues);\n\n                if (start > 0) {\n                    query.setFirstResult(start);\n                }\n                if (nb > 0) {\n                    query.setMaxResults(nb);\n                }\n                Iterator<T> it = query.list().iterator();\n                List<T> list = new ArrayList<>();\n                while (it.hasNext()) {\n                    list.add(it.next());\n                }\n\n                return list;\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                    \"Exception while searching documents with SQL [{0}]\", e, new Object[] {sql});\n            }\n        });\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        boolean checkRight, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, customMapping, checkRight, nb, start, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        boolean checkRight, int nb, int start, List<?> parameterValues, XWikiContext inputxcontext)\n        throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        // Search documents\n        List documentDatas = new ArrayList<>();\n        boolean bTransaction = true;\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            String sql;\n            if (distinctbylanguage) {\n                sql = createSQLQuery(\"select distinct doc.fullName, doc.language\", wheresql);\n            } else {\n                sql = createSQLQuery(\"select distinct doc.fullName\", wheresql);\n            }\n\n            // Start monitoring timer\n            if (monitor != null) {\n                monitor.startTimer(HINT, sql);\n            }\n\n            checkHibernate(context);\n            if (bTransaction) {\n                // Inject everything until we know what's needed\n                SessionFactory sfactory =\n                    customMapping ? injectCustomMappingsInSessionFactory(context) : getSessionFactory();\n                bTransaction = beginTransaction(sfactory, context);\n            }\n            try {\n                Session session = getSession(context);\n\n                Query query = createQuery(session, filterSQL(sql), parameterValues);\n\n                if (start > 0) {\n                    query.setFirstResult(start);\n                }\n                if (nb > 0) {\n                    query.setMaxResults(nb);\n                }\n                documentDatas.addAll(query.list());\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        endTransaction(context, false);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH, \"Exception while searching documents with SQL [{0}]\",\n                e, new Object[] {wheresql});\n        } finally {\n            restoreExecutionXContext();\n\n            // End monitoring timer\n            if (monitor != null) {\n                monitor.endTimer(HINT);\n            }\n        }\n\n        // Resolve documents. We use two separated sessions because rights service could need to switch database to\n        // check rights\n        List<XWikiDocument> documents = new ArrayList<>();\n        WikiReference currentWikiReference = new WikiReference(context.getWikiId());\n        for (Object result : documentDatas) {\n            String fullName;\n            String locale = null;\n            if (result instanceof String) {\n                fullName = (String) result;\n            } else {\n                fullName = (String) ((Object[]) result)[0];\n                if (distinctbylanguage) {\n                    locale = (String) ((Object[]) result)[1];\n                }\n            }\n\n            XWikiDocument doc =\n                new XWikiDocument(this.defaultDocumentReferenceResolver.resolve(fullName, currentWikiReference));\n            if (checkRight) {\n                if (!context.getWiki().getRightService().hasAccessLevel(\"view\", context.getUser(), doc.getFullName(),\n                    context)) {\n                    continue;\n                }\n            }\n\n            DocumentReference documentReference = doc.getDocumentReference();\n            if (distinctbylanguage) {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n                if (StringUtils.isEmpty(locale)) {\n                    documents.add(document);\n                } else {\n                    documents.add(document.getTranslatedDocument(locale, context));\n                }\n            } else {\n                documents.add(context.getWiki().getDocument(documentReference, context));\n            }\n        }\n\n        return documents;\n    }\n\n    /**\n     * @param queryPrefix the start of the SQL query (for example \"select distinct doc.space, doc.name\")\n     * @param whereSQL the where clause to append\n     * @return the full formed SQL query, to which the order by columns have been added as returned columns (this is\n     *         required for example for HSQLDB).\n     */\n    protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        StringBuilder sql = new StringBuilder(queryPrefix);\n\n        String normalizedWhereSQL;\n        if (StringUtils.isBlank(whereSQL)) {\n            normalizedWhereSQL = \"\";\n        } else {\n            normalizedWhereSQL = whereSQL.trim();\n        }\n\n        sql.append(getColumnsForSelectStatement(normalizedWhereSQL));\n        sql.append(\" from XWikiDocument as doc\");\n\n        if (!normalizedWhereSQL.equals(\"\")) {\n            if ((!normalizedWhereSQL.startsWith(\"where\")) && (!normalizedWhereSQL.startsWith(\",\"))) {\n                sql.append(\" where \");\n            } else {\n                sql.append(\" \");\n            }\n            sql.append(normalizedWhereSQL);\n        }\n\n        return sql.toString();\n    }\n\n    /**\n     * @param whereSQL the SQL where clause\n     * @return the list of columns to return in the select clause as a string starting with \", \" if there are columns or\n     *         an empty string otherwise. The returned columns are extracted from the where clause. One reason for doing\n     *         so is because HSQLDB only support SELECT DISTINCT SQL statements where the columns operated on are\n     *         returned from the query.\n     */\n    protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        StringBuilder columns = new StringBuilder();\n\n        int orderByPos = whereSQL.toLowerCase().indexOf(\"order by\");\n        if (orderByPos >= 0) {\n            String orderByStatement = whereSQL.substring(orderByPos + \"order by\".length() + 1);\n            StringTokenizer tokenizer = new StringTokenizer(orderByStatement, \",\");\n            while (tokenizer.hasMoreTokens()) {\n                String column = tokenizer.nextToken().trim();\n                // Remove \"desc\" or \"asc\" from the column found\n                column = StringUtils.removeEndIgnoreCase(column, \" desc\");\n                column = StringUtils.removeEndIgnoreCase(column, \" asc\");\n                columns.append(\", \").append(column.trim());\n            }\n        }\n\n        return columns.toString();\n    }\n\n    @Override\n    @Deprecated\n    public boolean isCustomMappingValid(BaseClass bclass, String custommapping1, XWikiContext context)\n    {\n        return isCustomMappingValid(bclass, custommapping1);\n    }\n\n    @Override\n    public boolean isCustomMappingValid(BaseClass bclass, String custommapping1)\n    {\n        try {\n            Metadata metadata = this.store.getMetadata(bclass.getName(), custommapping1, null);\n\n            return isValidCustomMapping(bclass, metadata);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private SessionFactory injectCustomMappingsInSessionFactory(XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        // If we haven't turned of dynamic custom mappings we should not inject them\n        if (!context.getWiki().hasDynamicCustomMappings()) {\n            return getSessionFactory();\n        }\n\n        boolean result = injectCustomMappings(doc, context);\n        if (!result) {\n            return getSessionFactory();\n        }\n\n        return getConfiguration().buildSessionFactory();\n    }\n\n    @Override\n    public void injectCustomMappings(XWikiContext context) throws XWikiException\n    {\n        injectCustomMappingsInSessionFactory(context);\n    }\n\n    @Override\n    public void injectUpdatedCustomMappings(XWikiContext context) throws XWikiException\n    {\n        Configuration config = getConfiguration();\n        injectInSessionFactory(config);\n    }\n\n    public SessionFactory injectCustomMappingsInSessionFactory(BaseClass bclass, XWikiContext context)\n        throws XWikiException\n    {\n        boolean result = injectCustomMapping(bclass, context);\n        if (result == false) {\n            return getSessionFactory();\n        }\n\n        Configuration config = getConfiguration();\n        return injectInSessionFactory(config);\n    }\n\n    private SessionFactory injectInSessionFactory(Configuration config) throws XWikiException\n    {\n        return config.buildSessionFactory();\n    }\n\n    public SessionFactory injectCustomMappingsInSessionFactory(XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            // If we haven't turned of dynamic custom mappings we should not inject them\n            if (context.getWiki().hasDynamicCustomMappings() == false) {\n                return getSessionFactory();\n            }\n\n            List<XWikiDocument> list;\n            list = searchDocuments(\" where (doc.xWikiClassXML is not null and doc.xWikiClassXML like '<%')\", true,\n                false, false, 0, 0, context);\n            boolean result = false;\n\n            for (XWikiDocument doc : list) {\n                if (!doc.getXClass().getFieldList().isEmpty()) {\n                    result |= injectCustomMapping(doc.getXClass(), context);\n                }\n            }\n\n            if (!result) {\n                return getSessionFactory();\n            }\n\n            Configuration config = getConfiguration();\n            return injectInSessionFactory(config);\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    @Override\n    public boolean injectCustomMappings(XWikiDocument doc, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            // If we haven't turned of dynamic custom mappings we should not inject them\n            if (context.getWiki().hasDynamicCustomMappings() == false) {\n                return false;\n            }\n\n            boolean result = false;\n            for (List<BaseObject> objectsOfType : doc.getXObjects().values()) {\n                for (BaseObject object : objectsOfType) {\n                    if (object != null) {\n                        result |= injectCustomMapping(object.getXClass(context), context);\n                        // Each class must be mapped only once\n                        break;\n                    }\n                }\n            }\n            return result;\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    /**\n     * @param className the name of the class to map\n     * @param customMapping the custom mapping to inject for this class\n     * @param inputxcontext the current XWikiContext\n     * @return a boolean indicating if the mapping has been added to the current hibernate configuration, and a reload\n     *         of the factory is required.\n     * @throws XWikiException if an error occurs\n     * @since 4.0M1\n     */\n    public boolean injectCustomMapping(String className, String customMapping, XWikiContext inputxcontext)\n        throws XWikiException\n    {\n        // If we haven't turned of dynamic custom mappings we should not inject them\n        if (!this.hibernateConfiguration.hasDynamicCustomMappings()) {\n            return false;\n        }\n\n        // Don't add a mapping that's already there\n        if (this.store.getConfigurationMetadata() != null\n            && this.store.getConfigurationMetadata().getEntityBinding(className) != null) {\n            return false;\n        }\n\n        this.store.getConfiguration().addInputStream(\n            new ByteArrayInputStream(makeMapping(className, customMapping).getBytes(StandardCharsets.UTF_8)));\n\n        // Rebuild to take into account the new mapping\n        this.store.build();\n\n        return true;\n    }\n\n    @Override\n    public boolean injectCustomMapping(BaseClass doc1class, XWikiContext inputxcontext) throws XWikiException\n    {\n        return injectCustomMapping(doc1class);\n    }\n\n    @Override\n    public boolean injectCustomMapping(BaseClass doc1class) throws XWikiException\n    {\n        if (!doc1class.hasExternalCustomMapping()) {\n            return false;\n        }\n\n        if (!isCustomMappingValid(doc1class, doc1class.getCustomMapping())) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_INVALID_MAPPING, \"Invalid Custom Mapping\");\n        }\n\n        return injectCustomMapping(doc1class.getName(), doc1class.getCustomMapping(), null);\n    }\n\n    private boolean isValidCustomMapping(BaseClass bclass, Metadata metadata)\n    {\n        PersistentClass mapping = metadata.getEntityBinding(bclass.getName());\n        if (mapping == null) {\n            return true;\n        }\n\n        Iterator<Property> it = mapping.getPropertyIterator();\n        while (it.hasNext()) {\n            Property hibprop = it.next();\n            String propname = hibprop.getName();\n            PropertyClass propclass = (PropertyClass) bclass.getField(propname);\n            if (propclass == null) {\n                this.logger.warn(\"Mapping contains invalid field name [{}]\", propname);\n                return false;\n            }\n\n            boolean result = isValidColumnType(hibprop.getValue().getType().getName(), propclass.getClassName());\n            if (!result) {\n                this.logger.warn(\"Mapping contains invalid type in field [{}]\", propname);\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public List<String> getCustomMappingPropertyList(BaseClass bclass)\n    {\n        List<String> list = new ArrayList<>();\n        Metadata metadata;\n        if (bclass.hasExternalCustomMapping()) {\n            metadata = this.store.getMetadata(bclass.getName(), bclass.getCustomMapping(), null);\n        } else {\n            metadata = this.store.getConfigurationMetadata();\n        }\n        PersistentClass mapping = metadata.getEntityBinding(bclass.getName());\n        if (mapping == null) {\n            return null;\n        }\n\n        Iterator<Property> it = mapping.getPropertyIterator();\n        while (it.hasNext()) {\n            Property hibprop = it.next();\n            String propname = hibprop.getName();\n            list.add(propname);\n        }\n        return list;\n    }\n\n    private boolean isValidColumnType(String name, String className)\n    {\n        String[] validtypes = this.validTypesMap.get(className);\n        if (validtypes == null) {\n            return true;\n        } else {\n            return ArrayUtils.contains(validtypes, name);\n        }\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocuments(wheresql, 0, 0, parameterValues, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, 0, 0, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, customMapping, 0, 0, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, int nb, int start, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocuments(wheresql, nb, start, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, int nb, int start, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, true, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, false, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, int nb, int start,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, nb, start, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, customMapping, nb, start, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        int nb, int start, List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, customMapping, true, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<String> getTranslationList(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        try {\n            return getTranslationList(doc.getDocumentReference());\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                \"Failed to retrieve the list of translations for [{0}]\", e, new Object[] {doc.getDocumentReference()});\n        }\n    }\n\n    private List<String> getTranslationList(DocumentReference documentReference) throws QueryException\n    {\n        // Note that the query is made to work with Oracle which treats empty strings as null.\n        String hql = \"select doc.language from XWikiDocument as doc where doc.space = :space and doc.name = :name \"\n            + \"and (doc.language <> '' or (doc.language is not null and '' is null))\";\n        org.xwiki.query.Query query = getQueryManager().createQuery(hql, org.xwiki.query.Query.HQL);\n        query.setWiki(documentReference.getWikiReference().getName());\n        query.bindValue(\"space\", this.localEntityReferenceSerializer.serialize(documentReference.getParent()));\n        query.bindValue(\"name\", documentReference.getName());\n        return query.execute();\n    }\n\n    @Override\n    public QueryManager getQueryManager()\n    {\n        return this.queryManager;\n    }\n\n    /**\n     * This is in response to the fact that Hibernate interprets backslashes differently from the database. Our solution\n     * is to simply replace all instances of \\ with \\\\ which makes the first backslash escape the second.\n     *\n     * @param sql the uncleaned sql.\n     * @return same as sql except it is guarenteed not to contain groups of odd numbers of backslashes.\n     * @since 2.4M1\n     */\n    private String filterSQL(String sql)\n    {\n        return StringUtils.replace(sql, \"\\\\\", \"\\\\\\\\\");\n    }\n\n    private String getDefaultAttachmentContentStore(XWikiContext xcontext)\n    {\n        XWikiAttachmentStoreInterface store = xcontext.getWiki().getDefaultAttachmentContentStore();\n\n        if (store != null && store != this.attachmentContentStore) {\n            return store.getHint();\n        }\n\n        return null;\n    }\n\n    private String getDefaultAttachmentArchiveStore(XWikiContext xcontext)\n    {\n        AttachmentVersioningStore store = xcontext.getWiki().getDefaultAttachmentArchiveStore();\n\n        if (store != null && store != this.attachmentArchiveStore) {\n            return store.getHint();\n        }\n\n        return null;\n    }\n\n    private XWikiAttachmentStoreInterface getXWikiAttachmentStoreInterface(XWikiAttachment attachment)\n        throws ComponentLookupException\n    {\n        String storeHint = attachment.getContentStore();\n\n        if (storeHint != null && !storeHint.equals(HINT)) {\n            return this.componentManager.getInstance(XWikiAttachmentStoreInterface.class, storeHint);\n        }\n\n        return this.attachmentContentStore;\n    }\n\n    private AttachmentVersioningStore getAttachmentVersioningStore(XWikiAttachment attachment)\n        throws ComponentLookupException\n    {\n        String storeHint = attachment.getArchiveStore();\n\n        if (storeHint != null && !storeHint.equals(HINT)) {\n            return this.componentManager.getInstance(AttachmentVersioningStore.class, storeHint);\n        }\n\n        return this.attachmentArchiveStore;\n    }\n\n    @Override\n    public int getLimitSize(XWikiContext context, Class<?> entityType, String propertyName)\n    {\n        return this.store.getLimitSize(entityType, propertyName);\n    }\n\n    private long countLinks(long docId, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                Query<Long> query =\n                    session.createQuery(\"select count(*) from XWikiLink as link where link.id.docId = :docId\")\n                        .setParameter(\"docId\", docId);\n                return query.getSingleResult();\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_BACKLINKS, \"Exception while count backlinks\", e);\n            }\n        });\n    }\n}\n", "# ---------------------------------------------------------------------------\n# See the NOTICE file distributed with this work for additional\n# information regarding copyright ownership.\n#\n# This is free software; you can redistribute it and/or modify it\n# under the terms of the GNU Lesser General Public License as\n# published by the Free Software Foundation; either version 2.1 of\n# the License, or (at your option) any later version.\n#\n# This software is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this software; if not, write to the Free\n# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n# ---------------------------------------------------------------------------\n\n###############################################################################\n# XWiki Core localization\n#\n# This contains the translations of the module in the default language\n# (generally English).\n# \n# See https://dev.xwiki.org/xwiki/bin/view/Community/L10N/Conventions/ for more details about about\n# translation key naming.\n#\n# Comments: it's possible to add some detail about a key to make easier to\n#   translate it by adding a comment before it. To make sure a comment is not\n#   assigned to the following key use at least three sharps (###) for the comment\n#   or after it.\n# \n# Deprecated keys:\n#   * when deleting a key it should be moved to deprecated section at the end\n#     of the file (between #@deprecatedstart and #@deprecatedend) and associated to the\n#     first version in which it started to be deprecated\n#   * when renaming a key, it should be moved to the same deprecated section\n#     and a comment should be added with the following syntax:\n#     #@deprecated new.key.name\n#     old.key.name=Some translation\n###############################################################################\n\n### Languages\nlanguage=Language\nlanguages=Languages\nchinese=Chinese\nenglish=English\nfrench=French\ngerman=German\nitalian=Italian\npolish=Polish\nrussian=Russian\nspanish=Spanish\n\n### User Page\nfirstname=First Name\nlastname=Last Name\ncountry=Country\n\n### View/Editing\nwikiweb=Space\nwikiname=Page\nparent=Parent\nwikicontent=Content\ndefaultlanguage=Default Language\ndefaulttemplate=Default Template\ncreator=Creator\nview=View\nraw=Code\nxml=XML\ndiff=History\nedit=Edit\neditcontent=Edit Content\nedithtmlcontent=Edit WYSIWYG\neditinline=Form\neditrights=Page Access Rights\neditobject=Objects\neditclass=Class\nwebrights=Space Access Rights\nxwikirights=Global Access Rights\nwebprefs=Space Preferences\nxwikiprefs=Global Preferences\nattach=Attach\nattachments=Attachments\nwebdaveditattachment=Edit\nsave=Save\ndelete=Delete\npreview=Preview\ncopy=Copy\nlogin=Log-in\nlogout=Log-out\nhomepage=User Profile\nstyles=Styles\ndefaultstyle=Default Style\naltstyle1=Alternate Style 1\naltstyle2=Alternate Style 2\naltstyle3=Alternate Style 3\npagemenu=Page Menu\nwebmenu=Space Menu\nxwikimenu=Space Menu\nusermenu=User Menu\nwebusermenu=Space Menu\nspace=Space Home\nclasseditor=Class Editor\nobjecteditor=Object Editor\ncancel=Cancel\nreleaselock=Release Lock\nversions=Versions\nversion=Version\nsize=Size\nauthor=Author\nlastauthor=Last Author\nfilename=Filename\nrights=Rights\nactions=Actions\ndefault=default\nconfirmobjectremove=Are you sure you want to remove this object?\nconfirmdelete=This action is irreversible. Are you sure you want to delete this page?\nconfirmdelete2=Are you sure you want to delete this attachment?\nbacklinkswarningdelete=There are pages that link here!\nconfirmdelattachment=Are you sure you want to delete this attachment?\ndeleted=The page has been deleted.\neditincludepagemsg=This page contains (an) included page(s). To edit this page, click on the following links:\nyouareediting=You are editing the following translation\nselectclass=Select a Class\nchangeclass=Change Class\nclassname=Class Name\npropname=Name\nselectproptype=Select a type\naddproperty=Add Property\nsaveclass=Save Class\nwelcometoclasseditor=Welcome to the class editor. Choose a field to edit or add a field to the class.\neditfield=Edit Field\naddobject=Add Object\naddobjectfromclass=Add Object from this Class\nwelcometoobjecteditor=Welcome to the objects editor. Choose an object to edit or add an object to the page.\nsaveobjects=Save Objects\nyoucan=You can\nremovethisobject=remove this object\nrightseditor=Access Rights Editor\naddrightentry=Add Access Right Entry\nwelcometorightseditor=Welcome to the Access Rights editor. Choose a right entry to edit or add a new right entry:\nremovethisrightentry=remove this right entry\nsaverights=Save Access Rights\naccountdisabled=Your account has been disabled. Please contact the administrator if you think this is a mistake.\naccountnotactive=Your account is not yet active, because your email has not yet been confirmed.\naccountnotactive_email=You should have received an email with a link to confirm your email address. You can also copy-paste the activation code in the same email in the following field.\nconfirmaccount=Confirm Account\nproblemoccured=A problem occurred while trying to process your request. Please contact the webmaster if this happens again.\ndetailedinformation=Detailed information\nnotallowed=You are not allowed to view this page or perform this action.\ndoyouwanttoreplace=Do you want to replace the filename with\nchoosetargetfilename=Choose the target file name\nchoosefiletoupload=Choose file to upload\nattachthisfile=Attach this file\nusername=Username\npassword=Password\nxwikidoc=Documentation\ndocumentation=Documentation\nxwikisyntax=XWiki Syntax\nhelpmenu=Help\nhelponsyntax=Help on the\ncomments=Comments\nnocomments=No comments for this page\naddcomment=Add Comment\nnewcomment=New Comment\nhighlight=Highlighted Text\nnocommentswithoutright=You need to have the 'comment' right to post a comment\nstatsmenu=Statistics Menu\npageviews=Page Views\nwebpageviews=Space Page Views\nxwikipageviews=XWiki Page Views\nxwikivisits=XWiki Visits\npagetopreferers=Top Referers\n#newinterface\npdf=PDF\nrtf=RTF\neditpage=Edit this Page\naddattachment=Add an attachment\nhistory=History\nmore=More Actions\nhello=Hello\nyesno_0=No\nyesno_1=Yes\ntruefalse_0=False\ntruefalse_1=True\nactive_0=Inactive\nactive_1=Active\nallow_0=Deny\nallow_1=Allow\nfrom=From\nto=To\neditedby=edited by\non=on\ncompare=Compare selected Versions\nallchanges=View all Changes\ndocumenthistory=Page History\ncannotreaddocumentversion=Cannot read page version\nparams=Parameters\nskin=Skin\npresentation=Presentation\nregistration=Registration\nmultilingual=Multilingual\ndefault_language=Default Language\ndateformat=Date format\nauthenticate_view=Prevent unregistered users from viewing pages, regardless of the page rights\nauthenticate_viewedit_savecomment=Change rights for unregistered users.\nauthenticate_edit=Prevent unregistered users from editing pages, regardless of the page rights\nbaseskin=Base Skin\nstylesheet=Default Stylesheet\nstylesheets=Other Stylesheets\ntitle=Browser Title Bar Text\ntitlefield=Title\nwebcopyright=Copyright notice\nmenu=Top Menu\nmeta=HTTP Meta Information\neditor=Default Editor to use\neditbox_width=Editor Box Width (characters)\neditbox_height=Editor Box Height (lines)\nuse_email_verification=Use email verification\nadmin_email=Admin email\nsmtp_server=Server\nsmtp_port=Port\nsmtp_server_username=SMTP Server Username (optional)\nsmtp_server_password=SMTP Server Password (optional)\njavamail_extra_props=Additional JavaMail properties\nvalidation_email_content=Validation e-Mail Content\nconfirmation_email_content=Confirmation e-Mail Content\npreferences=Preferences\nsaveprefs=Save Preferences\nsections=Sections\ncurrentobjects=Current Objects\ncurrentrights=Current Access Rights\ncurrentproperties=Current Properties\neditanotherclass=Edit another Class\nadmin=Administration\nhelp=Help\nsearch=Search\nrecentmenu=Recently Viewed\nwelcome=Welcome\ndate=Date\ndoclockedby=This page is currently locked by\nforcelock=Force editing\ninitialversion=Initial Version\nrollback=Rollback\nreadytorollback=Do you want to rollback to version\nreadonly=This server is currently in read-only mode\nrevisiondoesnotexist=This page does not exist in this version.\nnocommentwithnewdoc=You cannot comment on a page or article that does not exist.\nactiondoesnotexist=This action does not exist!\nthiswikidoesnotexist=This Wiki does not exist on this server.\nthispagedoesnotexist=The requested page could not be found.\nnosuchobject=The specified object does not exist\nthispagealreadyexists=This page already exists.\nattachmentdoesnotexist=The attachment does not exist.\nwikicontentcannotbeempty=The content of a wiki page is not allowed to be completely empty.\nfileuploadislarge=XWiki has a default limit of around 10Mb for attached files. This limit can be changed using the upload_maxsize parameter. Check the FAQ for more information.\njavaheapspace=Java Heap Space Out Of Memory Exception!\nnotsupportcharacters=File name does not support characters '\\\\' '/' ';'\nthistemplatedoesnotexist=This template does not exist\nmacros_languages=Macro Languages\nmacros_velocity=Velocity Macro Pages\nmacros_groovy=Groovy Macro Pages\nmacros_mapping=Macro Mapping\nnotification_pages=Notification Pages\ndocumentBundles=Internationalization Document Bundles\nadvanced=Advanced\nerrornotdefine=Error not defined in XWikiException!\naction.addClassProperty.error.invalidName=Property names must follow these naming rules: <br/>Names can contain letters, numbers, and the following characters: \"., -, _, :\" <br/>Names must not start with a number or punctuation character. <br/>Names must not start with the letters xml (or XML, or Xml, etc). <br/>Names cannot contain spaces.\naction.addClassProperty.error.alreadyExists=Property {0} already exists\n\nbacktoedit=Back To Edit\nbrowsernoncompatible=Browser is not compatible!\nwysiwygeditor=WYSIWYG Editor\nwikieditor=WIKI Editor\nmacro=Macro\nchoosemacro=Choose a macro:\n\nresetversions=Reset Versions\nconfirmresetversions=This action is irreversible. Are you sure you want to reset versions for this page?\nconfirmresetversions2=Please confirm if you want to reset versions for this page?\nresetversionsdone=The versions have been reset for this page.\nyes=Yes\nno=No\n\ndisabled=Disabled\nenabled=Enabled\n\ncreatedon=on\nlastmodifiedby=last modified by\nlastmodifiedon=on\nat=at\neditwiki=Wiki\neditvisual=WYSIWYG\neditform=Form\nchooseeditor=Choose editor:\nshow=Show\nshowcode=Wiki code\nshowxml=XML\nwatch=Watch\nnoattachments=No attachments for this page\ndownloadthisattachment=Download this attachment\nviewattachmenthistory=View attachment history\nregister=Register\ndoc=Documentation\nattributes=Attributes\nshowattributes=Show page attributes\nrememberme=This is a private computer, please remember me\ndontrememberme=This is a public/shared computer, do not remember me\nyouareeditingtranslation=You are editing the following translation\nyouareeditingoriginal=You are editing the original page\noriginallanguage=The original language of the page is\ntranslatedocin=Translate this page in\nothertranslations=Other translations\nexistingtranslations=Existing translations\nproptype=Type\nremovethiscomment=delete\nconfirmcommentremove=Are you sure you want to remove this comment?\nusefullinks=Useful links\n\nbold=Bold\nboldtext=Text in Bold\nitalics=Italics\nitalicstext=Text in Italics\nunderline=Underline\nunderlinetext=Text in Underline\nsecondleveltitle=Second Level Title\ntitletext=Title Text\nilink=Internal Link\nilinktext=Link Example\nelink=External Link (do not forget http://)\nelinktext=name of link>http://www.example.com\nhr=Horizontal ruler\nimg=Attached Image\nimgtext=example.jpg\nsign=Signature\n\n###\n### Model\n###\n\nTextArea_editor=Editor\nTextArea_editor_hint=Indicates which editor should be used to manipulate the content of the property. This setting overwrites the preferred editor configured in the user profile.\nTextArea_editor_PureText=Plain Text\nTextArea_editor_Text=Wiki\nTextArea_editor_Wysiwyg=WYSIWYG\n\nTextArea_contenttype=Content Type\nTextArea_contenttype_hint=Indicates what kind of content this field contains (wiki, plain text, etc.).\nTextArea_contenttype_PureText=Plain Text\nTextArea_contenttype_FullyRenderedText=Wiki Syntax\nTextArea_contenttype_VelocityCode=Velocity Code\n\nTextArea_restricted=Restricted\nTextArea_restricted_hint=Indicates if the content of the property should be executed in a restricted context.\n\nString_size_hint=The size of the corresponding form element in edit mode.\n\nStaticList_values_hint=Separated by '|'; Example: value1=Text displayed for value 1|value2=Text displayed for value 2|value3|value4\n\n###\n\ncore.edit.wikiToolbar.bold=Bold\ncore.edit.wikiToolbar.boldtext=Text in Bold\ncore.edit.wikiToolbar.italics=Italics\ncore.edit.wikiToolbar.italicstext=Text in Italics\ncore.edit.wikiToolbar.underline=Underline\ncore.edit.wikiToolbar.underlinetext=Text in Underline\ncore.edit.wikiToolbar.strikethrough=Strikethrough\ncore.edit.wikiToolbar.strikethroughtext=Strikethrough\ncore.edit.wikiToolbar.subscript=Subscript\ncore.edit.wikiToolbar.subscripttext=Text in subscript\ncore.edit.wikiToolbar.superscript=Superscript\ncore.edit.wikiToolbar.superscripttext=Text in superscript\ncore.edit.wikiToolbar.secondleveltitle=Second Level Title\ncore.edit.wikiToolbar.titletext=Title Text\ncore.edit.wikiToolbar.ilink=Internal Link\ncore.edit.wikiToolbar.ilinktext=Link Example\ncore.edit.wikiToolbar.elink=External Link (do not forget http://)\ncore.edit.wikiToolbar.elinktext=name of link>http://www.example.com\ncore.edit.wikiToolbar.elink20=External Link (do not forget http://)\ncore.edit.wikiToolbar.elink20text=name of link>>http://www.example.com\ncore.edit.wikiToolbar.hr=Horizontal ruler\ncore.edit.wikiToolbar.img=Attached Image\ncore.edit.wikiToolbar.imgtext=example.jpg\ncore.edit.wikiToolbar.sign=Signature\ncore.edit.wikiToolbar.h1=Heading 1\ncore.edit.wikiToolbar.h1text=Heading 1\ncore.edit.wikiToolbar.h2=Heading 2\ncore.edit.wikiToolbar.h2text=Heading 2\ncore.edit.wikiToolbar.h3=Heading 3\ncore.edit.wikiToolbar.h3text=Heading 3\ncore.edit.wikiToolbar.h4=Heading 4\ncore.edit.wikiToolbar.h4text=Heading 4\ncore.edit.wikiToolbar.ulist=Bulleted list\ncore.edit.wikiToolbar.ulisttext=List item\ncore.edit.wikiToolbar.olist=Numbered list\ncore.edit.wikiToolbar.olisttext=List item\ncore.edit.wikiToolbar.html=HTML code\ncore.edit.wikiToolbar.htmltext=<!-- Your HTML code here -->\ncore.edit.wikiToolbar.velocity=Velocity code\ncore.edit.wikiToolbar.velocitytext=#* Your velocity code here *#\ncore.edit.autosave=Autosave\ncore.edit.autosave.every=every\n\nnotice=Notice\nchangephoto=Changing photo for {0}\navatar=User photo\nError=Error\nerror=Error\nwarning=Warning\nWarning=Warning\nuploadavatarfile=Upload new user photo\nsetthisavatar=Set this photo\nnotauser=This is not a user!\nviewcode=Code\nviewxml=XML\nviewcomments=Comments\nviewattachments=Attachments\nviewhistory=History\nviewinformation=Information\nreveditor=Editor\nadminprefs=Preferences\nadminglobalrights=Global Rights\nadminspacerights=Space Rights\nadmingroups=Groups\nadminusers=Users\nadminusersandgroups=Users & Groups\nadminskin=Skin\ntype=Type:\ntoget=To get:\ndocdata=Page data\nnoskin=No skin is configured\nshowlinenumbers=Show Line Numbers\nhidelinenumbers=Hide Line numbers\nprint=Print\nwiki=Wiki\nWYSIWYG=WYSIWYG\ninvitation_email_content=Invitation email Content\nparentfield=Parent\n\neditingClass=Editing class\nproperties=Properties\nclassEditorIntro=Welcome to the Class Editor\nremembermeonthiscomp=Remember me\nsaveandcontinue=Save &amp; Continue\nsaveandview=Save &amp; View\n\nediting=Editing\neditWiki=Wiki\neditVisual=WYSIWYG\neditAttachments=Attachments\neditObject=Objects\neditClass=Class\neditRights=Access Rights\neditHistory=History\neditFullScreen=Full Screen\n\n###login\nnousername=No user name given\nnopassword=No password given\ninvalidcredentials=Invalid credentials\nloginfailed=Internal error\n\nswitchto=Switch to\nsectionEdit=Sectional Editing\n\nantispam=Antispam\nregistration_anonymous=Anonymous\nregistration_registered=Registered\nedit_anonymous=Anonymous\nedit_registered=Registered\ncomment_anonymous=Anonymous\ncomment_registered=Registered\ncomment=Comment\nconfirmcommentnotcorrect=Confirm to avoid spam robots. Please try again!\nvalidationerror=Field {0} is incorrect.\n\nmyaccount=My account\nnew=New\n\nattachedby=attached by\nlistofallexistspages=List of all existing pages\nlistofallattachments=List of all attachments\nlistofrecentlyviewedpages=List of recently viewed pages\nlistofrecentlymodifiedpages=List of recently modified pages\nwarningstartspluginisnotactivated=The stats plugin isn't activated. You have to activate stats plugin as default (xwiki.stats=1 in xwiki.cfg) to activate this function.\nlistofresultspages=List of result\nchoosespace=Choose space\ninspace=in\nnoattachmentsonthispage=There are no attachments on this page.\nnopagesatthemoment=There are no pages at the moment.\nEditing=Editing\nchooseassociatedtags=choose associated tags\n\nchangespace=Change Space\nadminspaceprefs=Space Prefs\neditprefsforspace=Editing preferences for space\neditrightsforspace=Editing access rights for space\n\ntarget=Target Window (_blank for a new window)\n\ncheckadvancedcontent=Your content contains HTML or special code that might be lost in the WYSIWYG Editor. Are you sure you want to switch editors?\nneedadminrights=Admin Rights are needed for this function\n\nexport=Export\nadminexport=Export\nexport_packagename=File name\nexport_description=Description\nexport_licence=Licence\nexport_author=Author\nexport_version=Version\nexport_addhistory=With history\nexport_backuppack=Backup package\n\nimport=Import\nadminimport=Import\nshowavailablefilestoimport=Show available files to import\nselectfiletoimport=Select the file you wish to import\navailablefilestoimport=Available files to import\navailabledocumentstoimport=Available pages to import\nuploadnewarchivetoimport=Upload a new archive to import\nselectdocumentstoimport=Click on the archive file you wish to import to get the list of available pages\nnodocstoimport=No pages found in the selected archive\nimporting=Importing\nimport_install_-1=Error while preparing importing\nimport_install_4=Error while importing\nimport_install_2=Import successful\nimport_install_1=Import could not overwrite\nimport_documentinstalled=Page(s) installed\nimport_documentskipped=Page(s) skipped\nimport_documenterrors=Page(s) with error\nimport_listofinstalledfiles=List of installed pages\nimport_listofskippedfiles=List of skipped pages\nimport_listoferrorfiles=List of erroneous pages\n\ncore.exporter.headings.officeFormats=Office Formats\ncore.exporter.headings.otherFormats=Other Formats\ncore.exporter.selectPages=Select the pages to export:\ncore.exporter.selectAll=select all\ncore.exporter.selectNone=none\ncore.exporter.selectChildren=Select all children\ncore.exporter.unselectChildren=Unselect all children\ncore.exporter.filter=Select from:\ncore.exporter.filter.installedExtensionDocument=Created pages\ncore.exporter.filter.installedExtensionDocument.hint=The pages created by the user or by XWiki extensions on behalf of the user.\ncore.exporter.filter.pristineInstalledExtensionDocument=Created and modified pages\ncore.exporter.filter.pristineInstalledExtensionDocument.hint=Includes modified extension pages (usually configuration pages).\ncore.exporter.filter.none=All pages\ncore.exporter.filter.none.hint=Includes unmodified extension pages.\ncore.exporter.legend=Legend:\ncore.exporter.legend.contentPage=Created Page\ncore.exporter.legend.contentPage.hint=Any page created by the user or by an XWiki extension on behalf of the user.\ncore.exporter.legend.customizedExtensionPage=Modified Extension Page\ncore.exporter.legend.customizedExtensionPage.hint=Any page that belongs to an installed extension and that has been modified.\ncore.exporter.legend.cleanExtensionPage=Clean Extension Page\ncore.exporter.legend.cleanExtensionPage.hint=Any page that belongs to an installed extension and that has not been modified.\n\ncore.exporter.formats.hint=Choose the export format from the list below:\ncore.exporter.formats.pdfFOP.hint=Export as Portable Document Format (PDF) using Apache Formatting Objects Processor (FOP)\ncore.exporter.formats.odt.hint=Export as Open Document Text (ODT) format using the Office Server\ncore.exporter.formats.rtf.hint=Export as Rich Text Format (RTF) using the Office Server\ncore.exporter.formats.html.hint=Export as HyperText Markup Language (HTML)\ncore.exporter.formats.xar.hint=Export as XWiki Archive (XAR)\ncore.exporter.exportAs=Export as {0}\n\ncore.importer.uploadPackage=Upload a new package\ncore.importer.availableDocuments=Package Content\ncore.importer.selectThisPackage=select this package\ncore.importer.availablePackages=Available packages\ncore.importer.noPackageAvailable=No package is available for import\ncore.importer.packageInformationExtract=Added by {0} on {1}\ncore.importer.import=Import\ncore.importer.selectionEmptyWarning=Please select at least one page to import\ncore.importer.importHistory=Import the history\ncore.importer.package=Package\ncore.importer.package.description=Description\ncore.importer.package.version=Version\ncore.importer.package.licence=Licence\ncore.importer.package.author=Author\ncore.importer.package.backup=Backup package\ncore.importer.documentSelected=page(s) selected\ncore.importer.whenDocumentAlreadyExists=When a page already exists in the wiki\ncore.importer.replaceDocumentHistory=Replace the page history with the history from the package\ncore.importer.addNewVersion=Add a new version to the existing page (if different)\ncore.importer.resetHistory=Reset history to version 1.1\ncore.importer.select=select\ncore.importer.selectAll=all\ncore.importer.selectNone=none\ncore.importer.saveDocumentComment=Imported from XAR\ncore.importer.securitySettingsChanged=Security settings have changed during the import. You will need <a href=\"{0}\">to authenticate</a> in order to continue to administrate the wiki.\ncore.importer.importAsBackup=Import as backup package\n\ncore.model.xclass.deleteClassProperty.versionSummary=Removed class property \"{0}\"\ncore.model.xclass.disableClassProperty.versionSummary=Disabled class property \"{0}\"\ncore.model.xclass.enableClassProperty.versionSummary=Enabled class property \"{0}\"\ncore.model.xclass.classProperty.error.missingProperty=Cannot change property: the specified property name does not exist in this class.\ncore.model.xclass.mandatoryUpdateProperty.versionSummary=Synced mandatory class property definitions to default values\ncore.model.xobject.synchronizeObjects.versionSummary=Synchronized object properties with their current classes\ncore.model.xobject.synchronizeObjects.error.missingObject=Cannot synchronize object: the specified object does not exist.\n\nregisterwelcome=Sign up here so you can edit pages and participate in the wiki.\nemail=e-Mail address\npasswordrepeat=Password (repeat)\nloginid=Login ID\niregister=Register\npasswordmismatch=Passwords are different or password is empty\nuseralreadyexists=User already exists\ninvalidusername=Invalid username provided. Please use only letters from the latin alphabet, numbers, and the underscore character.\nregisterfailed=Registration has failed\nregisterfailedcode=code\nregistersuccessful=Registration successful\n\nleftPanels=Left Panels\nrightPanels=Right Panels\nshowLeftPanels=Show Left Panels\nshowRightPanels=Show Right Panels\npageWidth=Page Width\ntags=Tags\n\nremovethisuserfromgroup=Remove this user from the group\nuserdeletioncannotbecanceled=Deletions cannot be cancelled.\naddusertogroup=Add a user to this group\n\npanelsavesuccess=The layout has been saved properly.\npanelsaveerror=An error occurred while trying to save the panel layout.\nspaceandname=Space and Page Name\ncreate=Create\ncreatepage=Page\ncreatespace=Space\ncreateevent=Event\ncreatepanel=Panel\n\n### Event calendar\neventCalendarTitle=Event Calendar\neventList=Event List\neventNew=New Event\neventTitle=Title\neventStartdate=Start date inclusive (dd/MM/yyyy)\neventEnddate=End date inclusive (dd/MM/yyyy)\neventLocation=Location\neventCategory=Category\neventURL=URL\neventDescription=Description\neventAdd=Add\n\ndtFrom=From\ndtTo=to\nmoreinfo=More information\n\n### Password change form\nchangepassword=Changing password for {0}\nnewpassword=New password\nreenterpassword=Reenter password\nsetthispassword=Save\ncancelpwd=Cancel\npasswordmissmatch=The two passwords do not match!\n\nplatform.core.profile.passwd.title=Changing password for {0}\nplatform.core.profile.passwd.instructionsPasswordLength=Your new password must be at least {0} characters long.\nplatform.core.profile.passwd.originalPassword=Current password\nplatform.core.profile.passwd.newPassword=New password\nplatform.core.profile.passwd.reenterPassword=Reenter password\nplatform.core.profile.passwd.submit=Save\nplatform.core.profile.passwd.cancel=Cancel and return to profile\nplatform.core.profile.passwd.passwordMissmatch=The two passwords do not match.\nplatform.core.profile.passwd.invalidOriginalPassword=Current password is invalid.\nplatform.core.profile.passwd.passwordTooShort=Your new password should be at least 6 characters long.\nplatform.core.profile.passwd.passwordCannotBeEmpty=The password cannot be empty.\nplatform.core.profile.passwd.notAllowed=You are not allowed to perform this action.\nplatform.core.profile.passwd.notaUser=This is not a user profile.\nplatform.core.profile.passwd.success=Your password has been successfully changed.\nplatform.core.profile.passwd.return=Click here to return to your profile.\nplatform.core.profile.passwd.passwordChanged=Changing user password.\nplatform.core.profile.passwd.passwordMustContainLowercase=The password must contain at least one lowercase character.\nplatform.core.profile.passwd.passwordMustContainUppercase=The password must contain at least one uppercase character.\nplatform.core.profile.passwd.passwordMustContainNumber=The password must contain at least one number.\nplatform.core.profile.passwd.passwordMustContainSymbol=The password must contain at least one symbol character.\n\n### User profile page\nplatform.core.profile.title=Profile of {0}\nplatform.core.profile.changePassword=Change password\nplatform.core.profile.changePhoto=Change photo\nplatform.core.profile.changePhoto.cancel=Cancel and return to profile\nplatform.core.profile.firstname=First name\nplatform.core.profile.lastname=Last name\nplatform.core.profile.blog=Blog\nplatform.core.profile.blogFeed=Blog Feed\nplatform.core.profile.email=Email\nplatform.core.profile.company=Company\nplatform.core.profile.city=City\nplatform.core.profile.country=Country\nplatform.core.profile.about=About\nplatform.core.profile.phone=Phone\nplatform.core.profile.address=Address\nplatform.core.profile.editor=Default editor to use\nplatform.core.profile.userType=User Type\nplatform.core.profile.enableAccessibility=Enable extra accessibility features\nplatform.core.profile.displayHiddenDocuments=Display hidden pages\nplatform.core.profile.timezone=Timezone\nplatform.core.profile.extensionConflictSetup=Enable extension conflict setup\n\nplatform.core.profile.category.settings=Settings\nplatform.core.profile.category.profile=Profile\nplatform.core.profile.category.profile.edit=Edit profile\nplatform.core.profile.category.preferences=Preferences\nplatform.core.profile.category.preferences.edit=Edit preferences\nplatform.core.profile.category.watchlist=Watchlist\nplatform.core.profile.category.watchlist.edit=Edit watchlist preferences\nplatform.core.profile.category.network=Network\nplatform.core.profile.category.dashboard=My dashboard\nplatform.core.profile.category.profile.disabled=This account is currently disabled.\nplatform.core.profile.category.profile.disableAccount=Disable this account\nplatform.core.profile.category.profile.enableAccount=Enable this account\n\nplatform.core.profile.section.security=Security\nplatform.core.profile.section.personal=Personal Information\nplatform.core.profile.section.contact=Contact Information\nplatform.core.profile.section.links=External Links\nplatform.core.profile.section.sendMessage=Send Message\nplatform.core.profile.section.activity=My Activity Stream\nplatform.core.profile.section.activityof=Activity stream of {0}\nplatform.core.profile.section.displayPreferences=Display Preferences\nplatform.core.profile.section.localizationPreferences=Localization Preferences\nplatform.core.profile.section.editorPreferences=Editor Preferences\nplatform.core.profile.section.extensionPreferences=Extensions Preferences\nplatform.core.profile.section.datePreferences=Date Preferences\nplatform.core.profile.section.passwordManagement=Password Management\nplatform.core.profile.section.watchlistManagement=Watchlist Preferences\nplatform.core.profile.section.watchlistElements=Watched elements\nplatform.core.profile.section.following=Followed users\nplatform.core.profile.section.following.none=You are not following the activity of any user.\nplatform.core.profile.section.networkActivity=Network activity\nplatform.core.profile.watchlist.notifier=Notifier\nplatform.core.profile.watchlist.unwatch=Remove from my watch list\n\ncore.footer.creation=Created by {0} on {1}\ncore.footer.translationCreation=Translated into {0} by {1} on {2}\ncore.footer.modification=Last modified by {0} on {1}\ncore.document.modificationWithVersion=Version {0} by {1} on {2}\n\ncore.document.error.failedParse=Failed to parse document content\n\ncore.footnotes.gotofootnote=Go to footnote {0}\ncore.footnotes.backtoref=Back to footnote reference\n\n### Keyboard shortcuts\ncore.shortcuts.view.edit=e\ncore.shortcuts.view.wiki=k\ncore.shortcuts.view.wysiwyg=g\ncore.shortcuts.view.inline=f\ncore.shortcuts.view.rights=r\ncore.shortcuts.view.objects=o\ncore.shortcuts.view.class=s\ncore.shortcuts.view.comments=c\ncore.shortcuts.view.attachments=a\ncore.shortcuts.view.history=h\ncore.shortcuts.view.information=i\ncore.shortcuts.view.code=d\ncore.shortcuts.view.annotations=n\ncore.shortcuts.view.delete=Delete\ncore.shortcuts.view.rename=F2\ncore.shortcuts.edit.cancel=Alt+C\ncore.shortcuts.edit.backtoedit=Alt+B\ncore.shortcuts.edit.preview=Alt+P\ncore.shortcuts.edit.save=Alt+Shift+S\ncore.shortcuts.edit.saveandview=Alt+S\n\n### Developer shortcuts\ncore.shortcuts.developer.user.type=x+x+x+a\ncore.shortcuts.developer.user.type.error=Unable to update the current user type\ncore.shortcuts.developer.user.displayHiddenDocs=x+x+x+h\ncore.shortcuts.developer.user.displayHiddenDocs.error=Unable to toggle the current user hidden documents property\ncore.shortcuts.developer.user.ajax.inprogress=Performing REST request...\ncore.shortcuts.developer.user.ajax.success=REST Request successful!\n\n### Create\ncore.create.pageTitle=Create Page\n\ncore.create.title=Title\ncore.create.title.hint=Title of the new page\ncore.create.locationPreview.label=Location\ncore.create.locationPreview.hint=Location in the page hierarchy where this new page will be created.\ncore.create.spaceReference.label=Parent\ncore.create.spaceReference.hint=Parent of the new page. Leave empty for top level non-terminal page.\ncore.create.spaceReference.placeholder=Path.To.Page\ncore.create.name.label=Name\ncore.create.name.hint=Name of the new page\ncore.create.name.placeholder=NewPage\n\ncore.create.template=Template\ncore.create.page.template.hint=Template to use for the new page\ncore.create.page.template.empty=Empty Wiki Page\ncore.create.template.allowedspaces=Pages created from the template [{0}] must be created in one of the following spaces: {1}\ncore.create.template.allowedspace=Pages created from the template [{0}] must be created in the space: {1}\ncore.create.template.allowedspaces.inline=Allowed spaces for ''{0}'': {1}\ncore.create.template.allowedspace.inline=Allowed space for ''{0}'': {1}\n\ncore.create.terminal.label=Terminal Page\ncore.create.terminal.hint=Advanced: Create a terminal page instead. This type of page will not be able to have children and is generally used in applications, development or in older versions of XWiki.\n\ncore.create.type=Type\ncore.create.type.hint=Select the kind of page that you want to create\ncore.create.type.default=Default\ncore.create.type.templates=Templates\ncore.create.type.blank=Blank page\ncore.create.type.blank.description=Standard empty page\n\ncore.create.popup.loading=Loading...\n\ncore.create.ajax.error=An error occurred, please refresh the page and try again\ncore.create.page.error.docalreadyexists=The page <a href=\"{1}\">{0}</a> already exists. You can fill in a new page name (or <a href=\"{2}\">edit {0}</a>).\ncore.create.space.error.docalreadyexists=The space {0} already exists. Please fill in a new space name.\ncore.create.page.error.docpathtoolong=The full path of the page you want to create is too long: {0} Paths are limited to {1} characters and the current length is {2} characters. Please change the name of your page or move it to another space.\n\n### Rename\ncore.rename.title=Rename <a href=\"{1}\">{0}</a>\ncore.rename.source.label=Source\ncore.rename.source.hint=The page that is going to be renamed\ncore.rename.children.label=Preserve children\ncore.rename.children.hint=Preserve the {0}{1} {1,choice,0#child pages|1#child page|1<child pages}{2} by updating their path and moving them to the new location\ncore.rename.children.hintWithoutParams=Preserve the child pages by updating their path and moving them to the new location\ncore.rename.links.label=Update links\ncore.rename.links.hint=Update the target of {0}{1} {1,choice,0#incoming links|1#incoming link|1<incoming links}{2} to this page and preserve the target of relative outgoing links from this page in the new location\ncore.rename.links.hintWithoutParams=Update the target of incoming links to this page and preserve the target of relative outgoing links from this page in the new location\ncore.rename.autoRedirect.label=Create an automatic redirect\ncore.rename.autoRedirect.hint=Redirect the user to the new page when accessing the old page. Select this option if you don't want to break external links to the old page.\ncore.rename.target.title.label=New Title\ncore.rename.target.title.hint=The new page title\ncore.rename.target.location.label=New Location\ncore.rename.target.location.hint=The location where to move the page\ncore.rename.target.wiki.label=Wiki\ncore.rename.target.wiki.hint=The wiki where to move the page\ncore.rename.target.parent.label=Parent\ncore.rename.target.parent.hint=The new parent. Leave empty if the new page should be a top level non-terminal page.\ncore.rename.target.name.label=Name\ncore.rename.target.name.hint=The new page name\ncore.rename.target.terminal.label=Rename as terminal page\ncore.rename.target.terminal.hint=This type of page cannot have children and is generally used in applications, development or in older versions of XWiki.\ncore.rename.submit=Rename\ncore.rename.emptyName=Please enter a valid page name!\ncore.rename.alreadyExists=A page with the given name (<a href=\"{1}\">{0}</a>) already exists. Please provide a different name.\ncore.rename.nonexistingDocument=This page does not exist.\ncore.rename.targetNotWritable=You don't have the right to create the target page.\ncore.rename.status.label=Rename Status\ncore.rename.status.hint=The following rename operation has been started by {0} on {1}\ncore.rename.status.success=Done.\ncore.rename.status.failure=Rename failed.\ncore.rename.status.notFound=The requested rename status could not be found.\nrename=Rename\ncore.rename.warningRenameUser=You are about to rename a page containing an user or a group but you don't have the programming rights: this could lead to some breakage in your wiki.\n\n### Copy\ncore.copy.title=Copy <a href=\"{1}\">{0}</a>\ncore.copy.source.label=Source\ncore.copy.source.hint=The page that is going to be copied\ncore.copy.target.title.label=Copy Title\ncore.copy.target.title.hint=The copy can have a different title than the source page\ncore.copy.target.location.label=Copy Location\ncore.copy.target.location.hint=The location where to copy the page\ncore.copy.target.wiki.label=Wiki\ncore.copy.target.wiki.hint=The wiki where to copy the page\ncore.copy.target.parent.label=Parent\ncore.copy.target.parent.hint=The parent of the copy. Leave empty if the copy should be a top level page.\ncore.copy.target.name.label=Name\ncore.copy.target.name.hint=The copy can have a different name than the source page\ncore.copy.target.terminal.label=Copy as terminal page\ncore.copy.target.terminal.hint=This type of page cannot have children and is generally used in applications, development or in older versions of XWiki.\ncore.copy.allTranslations=All Translations\ncore.copy.language.hint=Translation of the original page\ncore.copy.children.label=Preserve children\ncore.copy.children.hint=Copy also the {0}{1} {1,choice,0#children|1#child|1<children}{2} of the source page\ncore.copy.children.hintWithoutParams=Copy also the children of the source page\ncore.copy.submit=Copy\ncore.copy.cancel=Cancel\ncore.copy.alreadyExists=The page {0} already exists. Are you sure you want to overwrite it (all its content would be lost)?\ncore.copy.editRightsForbidden=You don''t have the appropriate rights to copy the page at the following target {0}.\ncore.copy.changeTarget=Change the target page\ncore.copy.status.label=Copy Status\ncore.copy.status.hint=The following copy operation has been started by {0} on {1}\ncore.copy.status.notFound=The requested copy status could not be found.\n\n### Document Picker\ncore.documentPicker.title=Select Page\ncore.documentPicker.select=Select\ncore.documentPicker.cancel=Cancel\n\n### Export\ncore.export.pdf.options.title=PDF Export Options\ncore.export.pdf.options.language.hint=Choose the translation you want to export.\ncore.export.pdf.options.currentLanguage=(Current language)\ncore.export.pdf.options.cover=Cover\ncore.export.pdf.options.cover.hint=Print the cover page, containing the page title, author and last modification date.\ncore.export.pdf.options.toc=Table of Contents\ncore.export.pdf.options.toc.hint=List headings at the beginning of the PDF document, usually right after the cover page.\ncore.export.pdf.options.header=Header\ncore.export.pdf.options.header.hint=Header displayed on each page\ncore.export.pdf.options.footer=Footer\ncore.export.pdf.options.footer.hint=Footer displayed on each page\ncore.export.pdf.options.comments=Comments\ncore.export.pdf.options.comments.hint=Include page comments at the end of the PDF document, usually before the image attachments.\ncore.export.pdf.options.images=Image attachments\ncore.export.pdf.options.images.hint=Print image attachments at the very end of the PDF document.\ncore.export.formatUnknown=Office server is not started or that export format is not supported.\n\n### Paging links\nweb.paging.pageNumberOf=Page {0} of {1}\nweb.paging.firstPage=&laquo; First\nweb.paging.previousPage=&lt; Previous\nweb.paging.nextPage=Next &gt;\nweb.paging.lastPage=Last &raquo;\n\ntempdirnotset=Temporary directory not set. Please follow the instructions on <a href=\"http://www.xwiki.org/xwiki/bin/view/FAQ/WhyAmIGettingANullPointerExceptionWhenUploadingFiles\">xwiki.org</a> on how to fix this.\n\n# Comments for history\n# Note: These keys should be moved to their domains.\n# For example the comment messages for the XAR importer are in core.importer.* keys.\n# TODO: Do the same for the other keys\n###\ncore.comment=Version summary\ncore.comment.details=(Enter a brief description of your changes)\ncore.comment.tooltip=Enter a brief description of your changes\ncore.comment.prompt=Enter a brief description of your changes\ncore.comment.addComment=Added comment\ncore.comment.editComment=Edited comment\ncore.comment.addObject=Added object\ncore.comment.updateObject=Updated object\ncore.comment.deleteObject=Deleted object\ncore.comment.addProperty=Added property\ncore.comment.updateProperty=Updated property\ncore.comment.updatePropertyName=Updated property name\ncore.comment.addClassProperty=Added class property\ncore.comment.updateClassProperty=Updated class property\ncore.comment.updateClassPropertyName=Updated class property name\ncore.comment.createdUser=Created user\ncore.comment.addedUserToGroup=Added user to group\ncore.comment.rollback=Rollback to version {0}\ncore.comment.updateContent=Update Content\ncore.comment.uploadAttachmentComment=Uploaded new attachment \"{0}\", version {1}\ncore.comment.uploadImageComment=Upload new image \"{0}\", version {1}\ncore.comment.deleteAttachmentComment=Deleted attachment \"{0}\"\ncore.comment.deleteImageComment=Deleted image \"{0}\"\ncore.comment.renameLink=Renamed links to {0} following the rename of that page\ncore.comment.renameParent=Changed parent to {0} following the rename of that page\ncore.comment.createdTemplate=Created {0} Template\ncore.comment.hint=Add summary...\n\ncore.minoredit=Minor edit\ncore.minoredit.show=Show minor edits\ncore.minoredit.hide=Hide minor edits\n\n### top menu\ncore.menu.main.title=General Actions:\ncore.menu.content.title=Page Actions:\ncore.menu.goto.wiki=Go to Wiki\ncore.menu.goto.space=Go to Space\ncore.menu.goto.page=Go to Page\ncore.menu.create=Create\ncore.menu.create.page=Page\ncore.menu.create.pageFromOffice=Page from Office\ncore.menu.create.space=Space\ncore.menu.create.wiki=Create wiki\ncore.menu.create.comment=Comment to Page\ncore.menu.create.attachment=Attachment to Page\ncore.menu.copy=Copy\ncore.menu.translate=Translate\ncore.menu.translate.hint=Translate this page in {0}\ncore.menu.translate.details=You''re viewing the {0} translation of this page (its original version) because this page has not been translated in {1} (the current locale) yet.\ncore.menu.edit=Edit\ncore.menu.edit.wiki=Wiki\ncore.menu.edit.wysiwyg=WYSIWYG\ncore.menu.edit.inline=Inline form\ncore.menu.edit.object=Objects\ncore.menu.edit.class=Class\ncore.menu.edit.rights=Access Rights\ncore.menu.edit.currentEditor=Edit{0}\ncore.menu.drawer=Drawer\ncore.menu.view.source=Source\ncore.menu.view.comments=Comments\ncore.menu.view.attachments=Attachments\ncore.menu.view.history=History\ncore.menu.view.information=Information\ncore.menu.print.preview=Print Preview\ncore.menu.delete=Delete\ncore.menu.rename=Move / Rename\ncore.menu.actions.label=More Actions\ncore.menu.actions.main=Manage\ncore.menu.actions.others=Actions\ncore.menu.actions.viewers=Viewers\ncore.menu.preview=Print Preview\ncore.menu.profile=Profile\ncore.menu.userPreferences=Preferences\ncore.menu.userDashboard=My dashboard\ncore.menu.network=Network\ncore.menu.export=Export\ncore.menu.watchlist.add=Watch\ncore.menu.watchlist.remove=Unwatch\ncore.menu.watchlist.add.document=Watch page\ncore.menu.watchlist.remove.document=Unwatch page\ncore.menu.watchlist.add.page=Watch Page\ncore.menu.watchlist.remove.page=Unwatch Page\ncore.menu.watchlist.add.space=Watch Space\ncore.menu.watchlist.remove.space=Unwatch Space\ncore.menu.watchlist.add.wiki=Watch Wiki\ncore.menu.watchlist.remove.wiki=Unwatch Wiki\ncore.menu.watchlist.management=Watchlist\ncore.menu.share=Share by Email\ncore.menu.admin=Administration\ncore.menu.admin.wiki=Administer Wiki\ncore.menu.admin.space=Administer Space\ncore.menu.admin.page=Administer Page\ncore.menu.admin.parent=Administer Parent\ncore.menu.editing=Editing\ncore.menu.type.home=Home\ncore.menu.type.wiki=Wiki\ncore.menu.type.space=Space\ncore.menu.type.page=Page\ncore.menu.type.profile=Profile\ncore.menu.wiki.documentindex=Page Index\ncore.menu.space.documentindex=Page Index\ncore.menu.space.delete=Delete\n### Translations used from web standard templates, not colibri\ncore.menu.view=View\ncore.menu.print=Print\ncore.menu.watch=Watch\ncore.menu.toggleSearch=Toggle search\ncore.menu.toggleNavigation=Toggle navigation\ncore.menu.toggleDropdown=Toggle dropdown\n\n### Messages for the various document viewers (history, attachments, info...)\ncore.viewers.content.doesnotexists.edittocreate=You can <a href=\"{0}\">edit this page</a> to create it.\n\ncore.viewers.comments.title=Comments on <a href=\"{1}\">{0}</a>\ncore.viewers.comments.permalink=Permalink\ncore.viewers.comments.permalink.goto=Go to permalink\ncore.viewers.comments.delete=Delete\ncore.viewers.comments.delete.confirm=Are you sure you want to remove this comment?\ncore.viewers.comments.delete.inProgress=Deleting...\ncore.viewers.comments.delete.done=Comment deleted\ncore.viewers.comments.delete.failed=Failed to delete comment:\ncore.viewers.comments.reply=Reply\ncore.viewers.comments.noComments=No comments for this page\ncore.viewers.comments.add.title=Add comment\ncore.viewers.comments.add.says=says:\ncore.viewers.comments.add.guestName.prompt=Author:\ncore.viewers.comments.add.guestName.default=Anonymous\ncore.viewers.comments.add.submit=Add comment\ncore.viewers.comments.add.cancel=Cancel\ncore.viewers.comments.add.comment.label=Comment\ncore.viewers.comments.add.inProgress=Sending comment...\ncore.viewers.comments.add.done=Comment posted\ncore.viewers.comments.add.failed=Failed to post comment:\ncore.viewers.comments.preview.button.preview=Preview\ncore.viewers.comments.preview.button.back=Back\ncore.viewers.comments.preview.failed=Failed to generate preview:\ncore.viewers.comments.preview.inProgress=Generating preview...\ncore.viewers.comments.commentDeleted=Deleted comment.\ncore.viewers.comments.deleteReplies.prompt=Also delete all replies to this comment?\ncore.viewers.comments.edit=Edit\ncore.viewers.comments.edit.save=Save comment\ncore.viewers.comments.edit.cancel=Cancel\ncore.viewers.comments.edit.notAllowed=You are not allowed to edit this comment\ncore.viewers.comments.edit.notFound=The requested comment does not exist\ncore.viewers.comments.edit.versionComment=Edited comment {0}\ncore.viewers.comments.editForm.fetch.inProgress=Retrieving comment source...\ncore.viewers.comments.editForm.fetch.failed=Failed to retrieve comment:\n### Deprecated:\ncore.viewers.comments.confirmDelete=Are you sure you want to remove this comment?\n\ncore.viewers.annotations.title=Annotations on {0}\n\ncore.viewers.attachments.title=Attachments for <a href=\"{1}\">{0}</a>\ncore.viewers.attachments.download=Download this attachment\ncore.viewers.attachments.delete=Delete\ncore.viewers.attachments.delete.confirm=Are you sure you want to delete this attachment?\ncore.viewers.attachments.delete.title=Delete this attachment\ncore.viewers.attachments.delete.inProgress=Deleting...\ncore.viewers.attachments.delete.done=Attachment deleted\ncore.viewers.attachments.delete.failed=Failed to delete attachment:\ncore.viewers.attachments.livetable.actions=Actions\ncore.viewers.attachments.livetable.author=Posted by\ncore.viewers.attachments.livetable.date=Date\ncore.viewers.attachments.livetable.filename=Name\ncore.viewers.attachments.livetable.filesize=File size\ncore.viewers.attachments.livetable.mimeType=Type\ncore.viewers.attachments.livetable.version=Version\ncore.viewers.attachments.webdavEdit=Edit\ncore.viewers.attachments.webdavEdit.title=Edit this attachment\ncore.viewers.attachments.officeView=Preview\ncore.viewers.attachments.officeView.title=Preview this attachment\ncore.viewers.attachments.move=Move\ncore.viewers.attachments.move.title=Move or rename this attachment\ncore.viewers.attachments.showHistory=View attachment history\ncore.viewers.attachments.author=Posted by {0}\ncore.viewers.attachments.date=on {0}\ncore.viewers.attachments.noAttachments=No attachments for this page\ncore.viewers.attachments.upload.title=Attach files to this page\ncore.viewers.attachments.upload.filename=Choose target filename:\ncore.viewers.attachments.upload.file=Choose file to upload:\ncore.viewers.attachments.upload.addFileInput=Add another file\ncore.viewers.attachments.upload.removeFileInput=Remove\ncore.viewers.attachments.upload.removeFileInput.title=Remove this file\ncore.viewers.attachments.upload.submit=Attach\ncore.viewers.attachments.upload.cancel=Cancel\ncore.viewers.attachments.upload.confirmReplace=Do you want to replace the filename with\ncore.viewers.attachments.revisions=The available versions of attachment ''{0}'' are:\n### MIME types\ncore.viewers.attachments.mime.audio=Audio\ncore.viewers.attachments.mime.image=Image\ncore.viewers.attachments.mime.text=Text\ncore.viewers.attachments.mime.video=Video\ncore.viewers.attachments.mime.flash=Flash\ncore.viewers.attachments.mime.svg=SVG\ncore.viewers.attachments.mime.html=HTML\ncore.viewers.attachments.mime.css=CSS\ncore.viewers.attachments.mime.xml=XML\n### Office\ncore.viewers.attachments.mime.office=Office Document\ncore.viewers.attachments.mime.document=Document\ncore.viewers.attachments.mime.presentation=Presentation\ncore.viewers.attachments.mime.spreadsheet=Spreadsheet\ncore.viewers.attachments.mime.odt=Office Template\ncore.viewers.attachments.mime.ps=PS\ncore.viewers.attachments.mime.pdf=PDF\n### Archives\ncore.viewers.attachments.mime.tar=TAR Archive\ncore.viewers.attachments.mime.bz=BZ Archive\ncore.viewers.attachments.mime.gz=GZ Archive\ncore.viewers.attachments.mime.zip=ZIP Archive\ncore.viewers.attachments.mime.rar=RAR Archive\ncore.viewers.attachments.mime.jar=JAR\n### Code\ncore.viewers.attachments.mime.sql=SQL Dump\ncore.viewers.attachments.mime.php=PHP Code\ncore.viewers.attachments.mime.c=C Code\ncore.viewers.attachments.mime.cpp=C++ Code\ncore.viewers.attachments.mime.cs=C# Code\ncore.viewers.attachments.mime.h=Header File\ncore.viewers.attachments.mime.ruby=Ruby Code\ncore.viewers.attachments.mime.java=Java Code\ncore.viewers.attachments.mime.js=JavaScript Code\ncore.viewers.attachments.mime.script=Shell Script\ncore.viewers.attachments.mime.vs=Visual Studio File\n### Misc.\ncore.viewers.attachments.mime.calendar=Calendar Data\ncore.viewers.attachments.mime.email=EMail\ncore.viewers.attachments.mime.vcard=vCard\ncore.viewers.attachments.mime.exe=Windows Executable\ncore.viewers.attachments.mime.attachment=Attachment\n\ncore.viewers.history.actions=Actions\ncore.viewers.history.title=History of <a href=\"{1}\">{0}</a>\ncore.viewers.history.summary=History of {0} &mdash; revisions from {1} to {2}\ncore.viewers.history.from=From\ncore.viewers.history.to=To\ncore.viewers.history.version=Version\ncore.viewers.history.author=Editor\ncore.viewers.history.date=Date\ncore.viewers.history.comment=Summary\ncore.viewers.history.currentVersion=Current version\ncore.viewers.history.rollback=Rollback\ncore.viewers.history.confirmRollback=Are you sure you wish to rollback to version {0}?\ncore.viewers.history.deleteSingle=Delete\ncore.viewers.history.confirmDeleteSingle=This action is not reversible. Are you sure you wish to delete version {0}?\ncore.viewers.history.compare=Compare selected versions\ncore.viewers.history.deleteRange=Delete selected version range\ncore.viewers.history.confirmDeleteRange=This action is not reversible. Are you sure you wish to delete versions from __rev1__ to __rev2__ inclusive?\ncore.viewers.history.showMinorEdits=Show minor edits\ncore.viewers.history.hideMinorEdits=Hide minor edits\ncore.viewers.history.extension.label={0}Version{1} coming from extension {2}{3} {4}{5}\ncore.viewers.history.empty=\"The history of this page is empty.\"\n\ncore.viewers.information.title=Information about <a href=\"{1}\">{0}</a>\ncore.viewers.information.locale=Locale\ncore.viewers.information.noLocale=None\ncore.viewers.information.originalLocale=Original locale\ncore.viewers.information.translations=Translations\ncore.viewers.information.syntax=Syntax\ncore.viewers.information.hidden=Hidden\ncore.viewers.information.includedPages=Included pages\ncore.viewers.information.noIncludedPages=No included pages\ncore.viewers.information.backlinks=Backlinks\ncore.viewers.information.noBacklinks=No backlinks\ncore.viewers.information.pageReference=Page reference\ncore.viewers.information.pageReference.copied=Reference copied to clipboard\ncore.viewers.information.pageReference.copyButton=Copy the reference to clipboard\ncore.viewers.information.pageReference.globalButton=Display the page reference for all wikis\ncore.viewers.information.pageReference.localButton=Display the page reference only for this wiki\ncore.viewers.information.pageReference.tips=Copy and paste this reference whenever a page reference or 'fullname' is required: when creating links to this page in the wiki syntax editor, when using this page as a parameter to wiki macro, etc.\n\ncore.viewers.code.title=Wiki source code of <a href=\"{1}\">{0}</a>\ncore.viewers.code.hideLineNumbers=Hide line numbers\ncore.viewers.code.showLineNumbers=Show line numbers\n\ncore.viewers.jump.dialog.content=Go to:\ncore.viewers.jump.shortcuts='Meta+G', 'Ctrl+G', 'Ctrl+/', 'Meta+/'\ncore.viewers.jump.dialog.input.tooltip=Path.to.Page\ncore.viewers.jump.dialog.actions.view=View\ncore.viewers.jump.dialog.actions.view.tooltip=View page (Enter)\ncore.viewers.jump.dialog.actions.view.shortcuts='Enter'\ncore.viewers.jump.dialog.actions.edit=Edit\ncore.viewers.jump.dialog.actions.edit.tooltip=Edit page in the default editor (Meta+E)\ncore.viewers.jump.dialog.actions.edit.shortcuts='Meta+E'\n\ncore.viewers.share.title=Share <a href=\"{1}\">{0}</a> by email\ncore.viewers.share.error.mustLogin=You must be logged in to use this feature\ncore.viewers.share.error.serverError=email server error\ncore.viewers.share.error.unknownEmail=unknown email address\ncore.viewers.share.error.missingRecipient=Please enter the recipient\ncore.viewers.share.send.success=The message has been sent to {0}.\ncore.viewers.share.send.error=The message could not be sent to {0}: {1}.\ncore.viewers.share.send.back=\\u00AB Go back to the {0} page\ncore.viewers.share.dialogTitle=Share this page\ncore.viewers.share.target=Send to\ncore.viewers.share.target.hint=XWiki user or email address\ncore.viewers.share.target.ccMe=Send me a copy\ncore.viewers.share.includeMethod=Include the current page\ncore.viewers.share.includeMethod.link=Only as a link\ncore.viewers.share.includeMethod.inline=Inline in the message\ncore.viewers.share.includeMethod.attachment=As an attached PDF\ncore.viewers.share.includeComments=Also include comments\ncore.viewers.share.messagePreviewLabel=The following message will be sent:\ncore.viewers.share.defaultMessage=I wanted to share this page with you.\ncore.viewers.share.recipientPlaceholder=&lt;recipient&gt;\ncore.viewers.share.submit=Send\ncore.viewers.share.cancel=Cancel\n\nplatform.web.editors.wiki.pageTitle=Editing {0} (wiki mode)\nplatform.web.editors.wysiwyg.pageTitle=Editing {0}\nplatform.web.editors.inline.pageTitle=Editing {0}\nplatform.web.editors.object.pageTitle=Editing objects of {0}\nplatform.web.editors.class.pageTitle=Editing class {0}\nplatform.web.editors.rights.pageTitle=Editing access rights for {0}\nplatform.web.editors.unknown.pageTitle=Editing {0}\n\ncore.editors.content.parentField.label=Parent\ncore.editors.content.parentField.edit=(edit)\ncore.editors.content.parentField.edit.title=Edit parent\ncore.editors.content.parentField.edit.hide=(hide)\ncore.editors.content.titleField.label=Title\ncore.editors.content.contentField.label=Content\ncore.editors.content.titleField.sectionEditingFormat={0} (\\u00A7{1}: {2})\n\n###full screen\ncore.editors.fullscreen.editFullScreen=Maximize\ncore.editors.fullscreen.editFullScreenTitle=Maximize\ncore.editors.fullscreen.exitFullScreen=Exit Full Screen\n\ncore.editors.object.title=Editing objects of <a href=\"{1}\">{0}</a>\ncore.editors.object.objectsForClass=Objects of type {0}\ncore.editors.object.noObject=The specified object does not exist\ncore.editors.object.add.label=New object\ncore.editors.object.add.selectClass=Select a Class\ncore.editors.object.add.submit=Add\ncore.editors.object.add.inProgress=Creating object...\ncore.editors.object.add.done=Object created\ncore.editors.object.add.failed=Failed:\ncore.editors.object.loadObject.inProgress=Loading object information...\ncore.editors.object.loadObject.done=Object loaded\ncore.editors.object.loadObject.failed=Object loading failed:\ncore.editors.object.add.invalidClassName=The class {0} does not exist\ncore.editors.object.newObjectForClass=New {0} object\ncore.editors.object.newObjectForClass.tooltip=New {0} object\ncore.editors.object.editAllObjects=\\u00ABEdit all the objects defined in this page\ncore.editors.object.editSingleObject=[Edit only this object]\ncore.editors.object.editSingleObject.tooltip=Edit only this object\ncore.editors.object.removeObject=[Remove this object]\ncore.editors.object.removeObject.tooltip=Remove this object\ncore.editors.object.invalidPropertyName=No such property: {0}\ncore.editors.object.delete.inProgress=Deleting object...\ncore.editors.object.delete.done=Object deleted\ncore.editors.object.delete.failed=Failed to delete object:\ncore.editors.object.delete.confirmJS=Are you sure you want to delete this object?\ncore.editors.object.invalidCSRF=Bad CSRF token, try to reload the page.\ncore.editors.object.badParameters=Bad request parameters.\n\ncore.editors.object.removeDeprecatedProperties.info=The following properties were deleted from the class {0} and are now deprecated:\ncore.editors.object.removeDeprecatedProperties.link=Remove deprecated properties\ncore.editors.object.removeDeprecatedProperties.link.tooltip=Remove deprecated properties\ncore.editors.object.removeDeprecatedProperties.all.info=Some objects from this page contain deprecated properties which were deleted from their respective classes.\ncore.editors.object.removeDeprecatedProperties.all.link=Remove all deprecated properties\ncore.editors.object.removeDeprecatedProperties.all.link.tooltip=Remove all deprecated properties\ncore.editors.object.removeDeprecatedProperties.inProgress=Removing deprecated properties...\ncore.editors.object.removeDeprecatedProperties.done=Deprecated properties were removed\ncore.editors.object.removeDeprecatedProperties.failed=Failed to remove deprecated properties\n\ncore.editors.class.title=Editing class <a href=\"{1}\">{0}</a>\ncore.editors.class.switchClass=Edit another class\ncore.editors.class.switchClass.confirm=Do you want to save this class before leaving the editor?\ncore.editors.class.addProperty.name.label=Add new property\ncore.editors.class.addProperty.type.label=Type\ncore.editors.class.addProperty.submit=Add\ncore.editors.class.addProperty.inProgress=Adding property...\ncore.editors.class.addProperty.done=Property added\ncore.editors.class.addProperty.failed=Failed:\n\ncore.editors.class.deleteProperty.text=delete\ncore.editors.class.deleteProperty.tooltip=Delete property {0}\ncore.editors.class.deleteProperty.confirm=Are you sure you want to delete this property?\ncore.editors.class.deleteProperty.inProgress=Deleting property...\ncore.editors.class.deleteProperty.done=Property deleted\ncore.editors.class.deleteProperty.failed=Failed to delete property:\n\ncore.editors.rights.title=Editing rights of <a href=\"{1}\">{0}</a>\n\ncore.editors.csrfCheckFailed=CSRF validation failed when saving.\ncore.editors.saveandcontinue.csrfCheckFailed=CSRF validation failed when saving. Try 'Save &amp; View' instead!\ncore.editors.saveandcontinue.exceptionWhileSaving=An error occured while saving: {0}.\ncore.editors.saveandcontinue.theDocumentWasNotSaved=The page was not saved!\ncore.editors.saveandcontinue.notification.inprogress=Saving...\ncore.editors.saveandcontinue.notification.done=Saved\ncore.editors.saveandcontinue.notification.doneWithMerge=Saved by merging changes\ncore.editors.saveandcontinue.notification.error=Failed to save the page. Reason: {0}\ncore.editors.savewithprogress.notification=Saving... __PROGRESS__%\n\ncore.editors.save.authorizationError.message=An authorization error occured when performing this action. Your might have been logged out since you started to edit this page.\ncore.editors.save.authorizationError.followLink=Click here to login in a new window.\n\ncore.editors.save.previewDiff.title=Version conflict\ncore.editors.save.previewDiff.description=Another version of the document has been saved since you started editing it and the merge cannot be performed automatically because some conflict occured. You can chose below what to do for saving the document, and check the differences between different versions of the document.\ncore.editors.save.previewDiff.latestVersion=Latest version saved\ncore.editors.save.previewDiff.modified=Modified by {0} the {1}\ncore.editors.save.previewDiff.reload.action=Reload the editor\ncore.editors.save.previewDiff.reload.label=Discard Changes\ncore.editors.save.previewDiff.reload.hint=Discards all your current changes and loads back the last saved changes. Be aware that you will lose all your current changes.\ncore.editors.save.previewDiff.forceSave.action=Force save your changes\ncore.editors.save.previewDiff.forceSave.hint=Creates a new version of the document with only your changes. Previous changes will be available in the history and may need to be manually merged.\ncore.editors.save.previewDiff.merge.action=Merge and fix conflicts with your changes\ncore.editors.save.previewDiff.merge.label=Recommended\ncore.editors.save.previewDiff.merge.hint=Merge your changes with the latest version saved of the documents and fix the conflicts by using your version of the document.\ncore.editors.save.previewDiff.custom.action=Fix each conflict individually\ncore.editors.save.previewDiff.custom.label=Advanced\ncore.editors.save.previewDiff.custom.hint=This allows you to take an individual decision for each conflict that needs to be solved.\ncore.editors.save.previewDiff.viewChanges=View changes\ncore.editors.save.previewDiff.versionToCompare.previous=before your changes\ncore.editors.save.previewDiff.versionToCompare.current=your current changes\ncore.editors.save.previewDiff.versionToCompare.next=latest version saved\ncore.editors.save.previewDiff.versionToCompare.merged=merged version\ncore.editors.save.previewDiff.versionToCompare.custom=custom version\ncore.editors.save.previewDiff.emptyDecisionValue=Remove inserted value.\n\ncore.space.recyclebin.confirm=This action will move ALL pages in space {0} to the Recycle Bin. Are you sure you wish to continue?\ncore.space.delete.confirm=This action will remove ALL pages in space {0} from your wiki. Are you sure you wish to continue?\ncore.space.recyclebin.done=Space {0} was moved to the Recycle Bin.\ncore.space.recyclebin.show=View the list of pages from this space that are currently present in the Recycle Bin \\u00BB\ncore.space.delete.done=All pages from space {0} were deleted from this wiki.\n\ncore.widgets.confirmationBox.defaultQuestion=Are you sure?\ncore.widgets.confirmationBox.button.yes=Yes\ncore.widgets.confirmationBox.button.no=No\ncore.widgets.confirmationBox.button.cancel=Cancel\ncore.widgets.confirmationBox.notification.inProgress=Sending request...\ncore.widgets.confirmationBox.notification.done=Done!\ncore.widgets.confirmationBox.notification.failed=Failed:\n\ncore.widgets.ajaxRequest.error.noServer=Server not responding\n\ncore.widgets.gallery.currentImage=Current image\ncore.widgets.gallery.previousImage=Show previous image\ncore.widgets.gallery.nextImage=Show next image\ncore.widgets.gallery.maximize=Maximize\ncore.widgets.gallery.minimize=Minimize\n\ncore.widgets.suggest.noResults=No results!\ncore.widgets.suggest.showResults=Go to search page\\u2026\ncore.widgets.suggest.valuePrefix=Value:\ncore.widgets.suggest.transportError=Failed to retrieve suggestions:\ncore.widgets.suggest.hide=hide suggestions\n\nweb.uicomponents.suggest.selectTypedText=Select {0} ...\nweb.uicomponents.suggest.attachments.upload=Upload a file ...\nweb.uicomponents.suggest.attachments.uploading=Uploading {0}\nweb.uicomponents.suggest.attachments.uploadDone={0} uploaded successfully\nweb.uicomponents.suggest.attachments.uploadFailed=Failed to upload {0}\n\ncore.widgets.html5upload.item.cancel=Cancel upload\ncore.widgets.html5upload.item.canceled=Canceled\ncore.widgets.html5upload.cancelAll=Cancel all pending uploads\ncore.widgets.html5upload.error.unknown=An error occurred while uploading {0}\ncore.widgets.html5upload.error.invalidType=The file {0} has an unsuported format\ncore.widgets.html5upload.error.invalidSize=The file {0} is too large. Please choose files under {1}\ncore.widgets.html5upload.error.aborted=The upload of {0} has been canceled\ncore.widgets.html5upload.status.finishing=Waiting for server confirmation for {0}...\ncore.widgets.html5upload.status.finished=Attachment uploaded: {0} ({1})\ncore.widgets.html5upload.hideStatus=Hide upload status\n\n### Watchlist (1.2M2)\nwatchlist=Watchlist\nwatchlist.title=Watchlist for {0}\nwatchlist.staytuned=Stay tuned\nwatchlist.staytuned.info=Receive notifications from your Watchlist\nwatchlist.staytuned.email=Email notifications\nwatchlist.staytuned.email.info=Please choose how often you would like to receive your email notifications\nwatchlist.staytuned.email.frequency=Frequency\nwatchlist.staytuned.email.frequency.save=Save\nwatchlist.staytuned.rss=RSS feed\nwatchlist.staytuned.rss.info=Last modifications feed for your watchlist\nwatchlist.elements=Elements in your watchlist\nwatchlist.pages=Pages\nwatchlist.pages.info=Pages you are currently following:\nwatchlist.spaces=Spaces\nwatchlist.spaces.info=Spaces you are currently following:\nwatchlist.page=Page\nwatchlist.space=Space\nwatchlist.actions=Actions\nwatchlist.delete=Remove from watchlist\nwatchlist.delete.tooltip=Remove from watchlist\nwatchlist.delete.ok={0} has been successfuly removed from watchlist\nwatchlist.delete.ko=An error occurred while removing {0} from watchlist\nwatchlist.create.object=Created WatchList storage object\nwatchlist.save.object=Updated WatchList\nwatchlist.event.create=On {0}, the page has been created by {1}\nwatchlist.event.delete=On {0}, the page has been deleted by {1}\nwatchlist.event.update=On {0}, the page has been modified by {1}\nwatchlist.event.update.multiple=Between {0} and {1}, the page has been modified {2} times, by {3} user{3,choice,0#s|1#|2#s}: {4}\nwatchlist.notification.email.greeting=Hello {0},\nwatchlist.notification.email.subject=XWiki updates, {0,choice,0#No|1#One|1<{0}} page{0,choice,0#s|1#|2#s} ha{0,choice,0#ve|1#s|1<ve} been modified since {1}\nwatchlist.notification.email.singleUpdate.subject=XWiki updates, 1 page has been modified since {0}\nwatchlist.notification.email.singleUpdate.intro=This message is sent by XWiki. Here is the page in your watchlist that has been modified since the last notification:\nwatchlist.notification.email.multipleUpdates.subject=XWiki updates, {0} pages have been modified since {1}\nwatchlist.notification.email.multipleUpdates.intro=This message is sent by XWiki. Here are the pages in your watchlist that have been modified since the last notification:\nwatchlist.notification.email.contents=Contents\nwatchlist.notification.tooltip=Notifications\nwatchlist.rss.author=XWiki\nwatchlist.rss.title=Your WatchList RSS feed\nwatchlist.rss.description=This RSS feed allows you to keep track of changes made to pages you added to your watchlist.\nwatchlist.job.hourly=Watchlist hourly email notifier\nwatchlist.job.daily=Watchlist daily email notifier\nwatchlist.job.weekly=Watchlist weekly email notifier\nwatchlist.preferences=Watchlist Preferences\nwatchlist.table.type=Type\nwatchlist.table.wiki=Wiki\nwatchlist.table.space=Space\nwatchlist.table.document=Page name\nwatchlist.table.allspaces=All spaces\nwatchlist.table.alldocuments=All pages\nwatchlist.table.actions=Actions\nwatchlist.diff.error=There was an error computing the difference. Please contact your administrator.\n\n### Activity stream, since 2.0RC1\nactivitystream.event.update=The page \"{0}\" has been modified\nactivitystream.event.update.rss.title=The page \"{0}\" has been modified\nactivitystream.event.update.rss.body=The page \"{0}\" has been modified\nactivitystream.event.create=The page \"{0}\" has been created\nactivitystream.event.create.rss.title=The page \"{0}\" has been created\nactivitystream.event.create.rss.body=The page \"{0}\" has been created\nactivitystream.event.delete=The page \"{0}\" has been deleted\nactivitystream.event.delete.rss.title=The page \"{0}\" has been deleted\nactivitystream.event.delete.rss.body=The page \"{0}\" has been deleted\n### Attachment events since XE 2.6RC1\nactivitystream.event.addAttachment=The attachment \"{1}\" has been added to the page \"{0}\"\nactivitystream.event.addAttachment.rss.title=The attachment \"{1}\" has been added to the page \"{0}\"\nactivitystream.event.addAttachment.rss.body=The attachment \"{1}\" has been added to the page \"{0}\"\nactivitystream.event.updateAttachment=The attachment \"{1}\" has been modified in the page \"{0}\"\nactivitystream.event.updateAttachment.rss.title=The attachment \"{1}\" has been modified in the page \"{0}\"\nactivitystream.event.updateAttachment.rss.body=The attachment \"{1}\" has been modified in the page \"{0}\"\nactivitystream.event.deleteAttachment=The attachment \"{1}\" has been deleted from the page \"{0}\"\nactivitystream.event.deleteAttachment.rss.title=The attachment \"{1}\" has been deleted from the page \"{0}\"\nactivitystream.event.deleteAttachment.rss.body=The attachment \"{1}\" has been deleted from the page \"{0}\"\n### Annotation events since XE 2.6RC1\nactivitystream.event.addAnnotation=An annotation has been added to the page \"{0}\"\nactivitystream.event.addAnnotation.rss.title=An annotation has been added to the page \"{0}\"\nactivitystream.event.addAnnotation.rss.body=An annotation has been added to the page \"{0}\"\nactivitystream.event.updateAnnotation=An annotation has been modified in the page \"{0}\"\nactivitystream.event.updateAnnotation.rss.title=An annotation has been modified in the page \"{0}\"\nactivitystream.event.updateAnnotation.rss.body=An annotation has been modified in the page \"{0}\"\nactivitystream.event.deleteAnnotation=An annotation has been deleted from the page \"{0}\"\nactivitystream.event.deleteAnnotation.rss.title=An annotation has been deleted from the page \"{0}\"\nactivitystream.event.deleteAnnotation.rss.body=An annotation has been deleted from the page \"{0}\"\n### Comment events since XE 2.6RC1\nactivitystream.event.addComment=A comment has been added to the page \"{0}\"\nactivitystream.event.addComment.rss.title=A comment has been added to the page \"{0}\"\nactivitystream.event.addComment.rss.body=A comment has been added to the page \"{0}\"\nactivitystream.event.updateComment=A comment has been modified in the page \"{0}\"\nactivitystream.event.updateComment.rss.title=A comment has been modified in the page \"{0}\"\nactivitystream.event.updateComment.rss.body=A comment has been modified in the page \"{0}\"\nactivitystream.event.deleteComment=A comment has been deleted from the page \"{0}\"\nactivitystream.event.deleteComment.rss.title=A comment has been deleted from the page \"{0}\"\nactivitystream.event.deleteComment.rss.body=A comment has been deleted from the page \"{0}\"\n\n### Deleting a page\ncore.delete=Delete\ncore.delete.title=Delete {0}\ncore.delete.orphansWarning=The following pages have this page specified as a parent:{0}After deleting this page, they will become orphaned.\ncore.delete.confirm=The deletion of a page is not reversible. Are you sure you wish to continue?\ncore.delete.confirmWithInlinks=In addition, the deletion of a page is not reversible. Are you sure you wish to continue?\ncore.delete.waitmessage=Please wait while the page is being deleted.\ncore.delete.success=The page has been deleted.\ncore.delete.error=Some errors happened:\ncore.delete.warningExtensions.title=You are about to delete pages that belong to extensions.\ncore.delete.warningExtensions.explanation=If you delete these pages, the extensions will not work anymore.\ncore.delete.warningExtensions.help=The recommended way of removing an extension is by uninstalling it with the {0}Extension Manager{1}.\ncore.delete.warningExtensions.confirm=Do you wish to continue?\ncore.delete.warningExtensions.tree.title=Pages to remove\ncore.delete.warningExtensions.tree.freePages=Pages that do not belong to any extension\ncore.delete.warningExtensions.tree.selectAll=select all\ncore.delete.warningExtensions.tree.selectNone=none\ncore.delete.warningExtensions.tree.paginationNode={0} more....\ncore.delete.warningExtensions.canceling=Canceling the delete action\ncore.delete.warningExtensions.canceled=Delete action canceled\ncore.delete.warningExtensions.timeout=The action has been canceled because we have not received any answer after 5 minutes.\ncore.delete.affectChildren=Affect children\ncore.delete.autoRedirect.hint=Redirect the user to the new page when accessing the old page. Select this option if you don't want to break external links to the deleted page.\ncore.delete.autoRedirect.label=Create an automatic redirect\ncore.delete.backlinks=Backlinks\ncore.delete.updateLinks.hint=Update the target of {0}{1} {1,choice,0#incoming links|1#incoming link|1<incoming links}{2} to this page.\ncore.delete.updateLinks.label=Update links\ncore.delete.backlinkTarget.hint=After deleting this page, the incoming links (internal and external) will point to an empty page. To avoid this, you can select an existing page as the new target. Leave empty for no action.\ncore.delete.backlinkTarget.label=New target\n\n### Restoring a page\ncore.restore.title=Restore {0}\ncore.restore.includeBatch=Include the batch of documents deleted at the same time\ncore.restore.batch.doc.name=Page\ncore.restore.batch.doc.location=Location\ncore.restore.batch._actions=Actions\ncore.restore.batch._actions.delete=Delete\ncore.restore.batch._actions.restore=Restore\ncore.restore.deleter=Deleted by:\ncore.restore.deleteDate=Deleted on:\ncore.restore.batchId=Deleted Batch ID\ncore.restore.confirm.yes=Restore\ncore.restore.confirm.no=Cancel\ncore.restore.waitmessage=Please wait while the restore operation is being performed.\ncore.restore.status.notFound=The requested restore status could not be found.\ncore.restore.status.success=Restore operation was successful.\ncore.restore.status.failure=Restore failed.\n\n## Children of a page\ncore.children.title=Children of {0}\ncore.children.warningParentChild=Note: this page does not display the children based on the parent/child mechanism.\ncore.children.terminalPage=This page is a terminal page that cannot have children.\ncore.children.parentChildDescription=Pages having this page as parent:\ncore.children.parentChildNoChild=This page does not have any child based on the parent/child mechanism.\n\n## Siblings of a document\ncore.siblings.title=Siblings of {0}\n\n## Backlinks\ncore.backlinks.title=Backlinks to {0}\ncore.backlinks.description=Pages having a link to this page:\ncore.backlinks.noBackLink=There is no backlink to this page.\n\n## Events\ncore.events.create.description=A new page is created\ncore.events.delete.description=A page is deleted\ncore.events.update.description=A page is modified\ncore.events.comment.description=A comment is posted\ncore.events.appName=Pages\n\ncore.recyclebin.showlistmsg=The following versions are in the recycle bin:\ncore.recyclebin.showListTerminalPagesMsg=The following versions of terminal pages are in the recycle bin:\ncore.recyclebin.deleter=Deleter\ncore.recyclebin.actions=Actions\ncore.recyclebin.deleteDate=Deletion Date\ncore.recyclebin.batchId=Deleted Batch ID\ncore.recyclebin.delete=Delete\ncore.recyclebin.restore=Restore\ncore.recyclebin.confirm=Are you sure you wish to move this page to the recycle bin?\ncore.recyclebin.confirmWithInlinks=Are you sure you wish to move this page to the recycle bin?\ncore.recyclebin.completelyDeleteConfirm=This action is not reversible. Are you sure you wish to continue?\ncore.recyclebin.invalidEntry=Invalid recycle bin entry.\ncore.recycleBin.shouldSkip.label=Are you sure you wish to delete this page?\ncore.recycleBin.shouldSkip.no=Delete and move to the recycle bin.\ncore.recycleBin.shouldSkip.yes=Permanently delete the page (it won't be put in the recycle bin).\n\ncore.versions.delete.single=Delete\ncore.versions.delete.many=Delete versions\ncore.versions.delete.confirm.single=This action is not reversible. Do you want to delete version {0}?\ncore.versions.delete.confirm.many=This action is not reversible. Are you sure you wish to delete versions from {0} to {1} inclusive?\ncore.versions.delete.needselect=You need to select \"from\" and \"to\" versions to delete\ncore.versions.delete.goback=go back\n\ncore.pdf.tableOfContents=Table of Contents\n\npanels.documentInformation.title=Page Information\npanels.documentInformation.syntax=Page syntax\npanels.documentInformation.includesCount={0,choice,0#No|1#One|1<{0}} included {0,choice,0#pages.|1#page:|1<pages:}\npanels.documentInformation.includesOne={0} included page:\npanels.documentInformation.includesMore={0} included pages:\npanels.documentInformation.editIncluded=Edit {0}\npanels.documentInformation.defaultLanguage=Default Language:\npanels.documentInformation.hiddenDocument=Hidden page\n\npanels.translation.title=Page Translations\npanels.translation.editingOriginal=You are editing the original page ({0}).\npanels.translation.editingTranslation=You are editing the following translation: {0}.\npanels.translation.editOriginalLanguage=The original language of the page is {0}.\npanels.translation.translate=Translate this page in:\npanels.translation.otherTranslations=Other translations:\npanels.translation.existingTranslations=Existing translations:\n\npanels.recentlyVisited.title=Recently Visited\npanels.recentlyModified.title=Recently Modified\npanels.recentlyCreated.title=Recently Created\n\npanels.applications.title=Applications\npanels.applications.more=More applications\n\npanelwizard.panelwizard=Panels\npanelwizard.placemanager=Place Manager\npanelwizard.notadmininplace=You are not admin on this place {0}.\npanelwizard.panellayoutupdate=Panel Layout Update\npanelwizard.nodirectaccess=This page is not supposed to be accessed directly. Please use the {0}.\npanelwizard.panellist=Panel List\npanelwizard.pagelayout=Page Layout\npanelwizard.nopanels=There are no panels from this category.\npanelwizard.panelColumns=Panel Columns\npanelwizard.choosepagelayout=Choose a page layout\npanelwizard.nosidecolumn=No side column\npanelwizard.leftcolumn=Left column\npanelwizard.rightcolumn=Right column\npanelwizard.bothcolumns=Both columns\npanelwizard.needadminright=You need to have administrative rights to use the Panel Wizard.\npanelwizard.paneleditor=Panel Editor\npanelwizard.tip=To drag a panel, use your mouse and click on the header of the panel. Keep your left mouse button down while you move your mouse and the panel at the same time. While you move the panel you will see in real-time where the panel will be dropped when you release your left mouse button.\npanelwizard.draganddrop=Drag and drop panels to rearrange them inside a column or between columns. To add or remove panels, drag them from the list of available panels to one of the columns or from the column into the list, respectively.\npanelwizard.save.versionComment=Updated panel layout\n\n#tooltip for fullscreen editing\nfullScreenTooltip=Edit in Full Screen\n\n### user registration\ncore.register=Register\ncore.register.title=Registration\ncore.register.welcome=Sign up here so you can edit pages and participate in the wiki.\ncore.register.passwordMismatch=Passwords are different or password is empty.\ncore.register.userAlreadyExists=User already exists.\ncore.register.invalidUsername=Invalid username provided. Please use only letters from the latin alphabet, numbers, and the underscore character '_'.\ncore.register.mailSenderWronglyConfigured=The user has been created but the validation email has not been sent. Please check the Mail Sending Configuration and consider recreating the user.\ncore.register.registerFailed=Registration has failed due to unknown reasons. (Error code: {0})\ncore.register.successful={0} ({1}): Registration successful.\ncore.register.firstName=First Name\ncore.register.lastName=Last Name\ncore.register.username=Username\ncore.register.password=Password\ncore.register.passwordRepeat=Confirm Password\ncore.register.email=Email Address\ncore.register.submit=Register\ncore.register.badCSRF=Bad CSRF token.\n\n# User account validation\ncore.users.activation.validationKey.label=Validation key:\n\n# Misc about users\ncore.users.unknownUser=Unknown User\ncore.users.disable.saveComment=Disable user account\ncore.users.enable.saveComment=Enable user account\n\n###Validation\ncore.validation.required=(Required)\ncore.validation.required.message=This field is required.\ncore.validation.required.message.terminal=This field is required for terminal pages.\ncore.validation.valid.message=Ok.\n\n# Captcha \ncore.captcha.captchaAnswerIsWrong=Incorrect answer, please try again.\ncore.captcha.instruction=Please validate the CAPTCHA to prove you are not a robot\n\n# History\nweb.history.changes.raw=Raw\nweb.history.changes.rendered=Rendered\nweb.history.changes.summary=Summary\nweb.history.changes.summary.documents=Showing {0}{1} changed {1,choice,1#page|1<pages}{2}\nweb.history.changes.summary.documentProperties=Page properties\nweb.history.changes.summary.attachments=Attachments\nweb.history.changes.summary.objects=Objects\nweb.history.changes.summary.classProperties=Class properties\nweb.history.changes.summary.modifiedAddedRemoved={0} modified, {1} added, {2} removed\nweb.history.changes.noChanges=No changes\nweb.history.changes.failedToCompute=Failed to compute the changes.\nweb.history.changes.details=Details\nweb.history.changes.document.title=Title\nweb.history.changes.document.parent=Parent\nweb.history.changes.document.hidden=Hidden\nweb.history.changes.document.defaultLocale=Default language\nweb.history.changes.document.syntax=Syntax\nweb.history.changes.document.content=Content\nweb.history.changes.attachment.size=Size\nweb.history.changes.attachment.content=Content\nweb.history.changes.attachment.noContentChanges=Either this is not a text file or the file is too large\nweb.history.changes.privateInformation=Private information\nweb.history.changes.attachment.notAvailable=The content diff is not available. One attachment might have been deleted from the recycle bin.\nweb.history.changes.showContext=Show context\nweb.history.changes.hideContext=Hide context\n\ncore.viewers.diff.title=Changes for page <a href=\"{1}\">{0}</a>\ncore.viewers.diff.from=From version {0}\ncore.viewers.diff.fromNew=From empty\ncore.viewers.diff.to=To version {0}\ncore.viewers.diff.editedBy=edited by {0}\ncore.viewers.diff.editedOn=on {0}\ncore.viewers.diff.editComment=Change comment:\ncore.viewers.diff.noEditComment=There is no comment for this version\ncore.viewers.diff.nextChange=Next change\ncore.viewers.diff.previousChange=Previous change\ncore.viewers.diff.nextVersion=Next version\ncore.viewers.diff.previousVersion=Previous version\n\ncore.viewers.code.showBlame=Show last authors\ncore.viewers.code.hideBlame=Hide last authors\n\n####################\n# Macros\n####################\n\nrendering.macroContent=Content\n\n### Macro Categories\nrendering.macroCategory.Development=Development\nrendering.macroCategory.Navigation=Navigation\nrendering.macroCategory.Content=Content\nrendering.macroCategory.Formatting=Formatting\nrendering.macroCategory.Layout=Layout\nrendering.macroCategory.Deprecated=Deprecated\nrendering.macroCategory.Internal=Internal\n\n### Macro Descriptors\nrendering.macro.groovy.name=Groovy\nrendering.macro.groovy.description=Execute a groovy script.\nrendering.macro.groovy.content.description=the groovy script to execute\nrendering.macro.groovy.parameter.jars.name=jars\nrendering.macro.groovy.parameter.jars.description=List of JARs to be added to the class loader used to execute this script. Example: \"attach:wiki:space.page@somefile.jar\", \"attach:somefile.jar\", \"attach:wiki:space.page\" (adds all JARs attached to the page) or URL to a JAR\nrendering.macro.groovy.parameter.output.name=output\nrendering.macro.groovy.parameter.output.description=Specifies whether or not the output result should be inserted back in the page.\nrendering.macro.groovy.parameter.wiki.name=wiki\nrendering.macro.groovy.parameter.wiki.description=Specifies whether or not the script output contains wiki markup.\nrendering.macro.python.name=Python\nrendering.macro.python.description=Executes a python script.\nrendering.macro.python.content.description=The python script to execute\nrendering.macro.python.parameter.jars.name=jars\nrendering.macro.python.parameter.jars.description=List of JARs to be added to the class loader used to execute this script. Example: \"attach:wiki:space.page@somefile.jar\", \"attach:somefile.jar\", \"attach:wiki:space.page\" (adds all JARs attached to the page) or URL to a JAR\nrendering.macro.python.parameter.output.name=output\nrendering.macro.python.parameter.output.description=Specifies whether the output result should be inserted back in the page\nrendering.macro.python.parameter.wiki.name=wiki\nrendering.macro.python.parameter.wiki.description=Specifies whether wiki syntax in the script execution result will be rendered or not\nrendering.macro.html.name=HTML\nrendering.macro.html.description=Inserts HTML or XHTML code into the page.\nrendering.macro.html.content.description=The HTML content to insert in the page.\nrendering.macro.html.parameter.clean.name=clean\nrendering.macro.html.parameter.clean.description=Indicate if the HTML should be transformed into valid XHTML or not.\nrendering.macro.html.parameter.wiki.name=wiki\nrendering.macro.html.parameter.wiki.description=Indicate if the wiki syntax in the macro will be interpreted or not.\nrendering.macro.script.name=Script\nrendering.macro.script.description=Execute script in provided script language.\nrendering.macro.script.content.description=the script to execute\nrendering.macro.script.parameter.jars.name=jars\nrendering.macro.script.parameter.jars.description=List of JARs to be added to the class loader used to execute this script. Example: \"attach:wiki:space.page@somefile.jar\", \"attach:somefile.jar\", \"attach:wiki:space.page\" (adds all JARs attached to the page) or URL to a JAR\nrendering.macro.script.parameter.language.name=language\nrendering.macro.script.parameter.language.description=The identifier of the script language (\"groovy\", \"python\", etc)\nrendering.macro.script.parameter.output.name=output\nrendering.macro.script.parameter.output.description=Specifies whether the output result should be inserted back in the page\nrendering.macro.script.parameter.wiki.name=wiki\nrendering.macro.script.parameter.wiki.description=Specifies whether wiki syntax in the script execution result will be rendered or not\nrendering.macro.velocity.name=Velocity\nrendering.macro.velocity.description=Executes a Velocity script.\nrendering.macro.velocity.content.description=the velocity script to execute\nrendering.macro.velocity.parameter.filter.name=filter\nrendering.macro.velocity.parameter.filter.description=indicate which filtering mode to use\nrendering.macro.velocity.parameter.jars.name=jars\nrendering.macro.velocity.parameter.jars.description=List of JARs to be added to the class loader used to execute this script. Example: \"attach:wiki:space.page@somefile.jar\", \"attach:somefile.jar\", \"attach:wiki:space.page\" (adds all JARs attached to the page) or URL to a JAR\nrendering.macro.velocity.parameter.output.name=output\nrendering.macro.velocity.parameter.output.description=Specifies whether the output result should be inserted back in the page\nrendering.macro.velocity.parameter.wiki.name=wiki\nrendering.macro.velocity.parameter.wiki.description=Specifies whether wiki syntax in the script execution result will be rendered or not\nrendering.macro.toc.name=Table of contents\nrendering.macro.toc.description=Generates a table of contents.\nrendering.macro.toc.parameter.depth.name=depth\nrendering.macro.toc.parameter.depth.description=the maximum section level. For example if 3 then all section levels from 4 will not be listed\nrendering.macro.toc.parameter.numbered.name=numbered\nrendering.macro.toc.parameter.numbered.description=if true the section title number is printed\nrendering.macro.toc.parameter.scope.name=scope\nrendering.macro.toc.parameter.scope.description=if local only section in the current scope will be listed. For example if the macro is written in a section, only subsections of this section will be listed\nrendering.macro.toc.parameter.scope.value.LOCAL=Local\nrendering.macro.toc.parameter.scope.value.PAGE=Page\nrendering.macro.toc.parameter.start.name=start\nrendering.macro.toc.parameter.start.description=the minimum section level. For example if 2 then level 1 sections will not be listed\nrendering.macro.toc.parameter.reference.name=reference\nrendering.macro.toc.parameter.reference.description=Reference to the document for which to generate the table of contents. Leave empty for the current page.\nrendering.macro.id.name=Id\nrendering.macro.id.description=Allows putting a reference/location in a page. In HTML for example this is called an Anchor. It allows pointing to that location, for example in links.\nrendering.macro.id.parameter.name.name=name\nrendering.macro.id.parameter.name.description=the identifier string\nrendering.macro.putFootnotes.name=Put Footnote\nrendering.macro.putFootnotes.description=Displays the footnotes defined so far. If missing, all footnotes are displayed by default at the end of the page.\nrendering.macro.formula.name=Formula\nrendering.macro.formula.description=Displays a mathematical formula.\nrendering.macro.formula.content.description=The mathematical formula, in LaTeX syntax\nrendering.macro.formula.parameter.fontSize.name=fontSize\nrendering.macro.formula.parameter.fontSize.description=adjust font size\nrendering.macro.formula.parameter.fontSize.value.TINY=Tiny\nrendering.macro.formula.parameter.fontSize.value.VERY_SMALL=Very small\nrendering.macro.formula.parameter.fontSize.value.SMALLER=Smaller\nrendering.macro.formula.parameter.fontSize.value.SMALL=Small\nrendering.macro.formula.parameter.fontSize.value.NORMAL=Normal\nrendering.macro.formula.parameter.fontSize.value.LARGE=Large\nrendering.macro.formula.parameter.fontSize.value.LARGER=Larger\nrendering.macro.formula.parameter.fontSize.value.VERY_LARGE=Very large\nrendering.macro.formula.parameter.fontSize.value.HUGE=Huge\nrendering.macro.formula.parameter.fontSize.value.EXTREMELY_HUGE=Extremely huge\nrendering.macro.formula.parameter.imageType.name=imageType\nrendering.macro.formula.parameter.imageType.description=resulting image type\nrendering.macro.formula.parameter.imageType.value.PNG=png\nrendering.macro.formula.parameter.imageType.value.GIF=gif\nrendering.macro.formula.parameter.imageType.value.JPEG=jpeg\nrendering.macro.footnote.name=Footnote\nrendering.macro.footnote.description=Generates a footnote to display at the end of the page.\nrendering.macro.footnote.content.description=the text to place in the footnote\nrendering.macro.rss.name=RSS\nrendering.macro.rss.description=Output latest feed entries from a RSS feed.\nrendering.macro.rss.parameter.content.name=content\nrendering.macro.rss.parameter.content.description=Display content for feed entries\nrendering.macro.rss.parameter.count.name=count\nrendering.macro.rss.parameter.count.description=The maximum number of feed items to display on the page.\nrendering.macro.rss.parameter.feed.name=feed\nrendering.macro.rss.parameter.feed.description=URL of the RSS feed\nrendering.macro.rss.parameter.image.name=image\nrendering.macro.rss.parameter.image.description=If the feeds has an image associated, display it?\nrendering.macro.rss.parameter.width.name=width\nrendering.macro.rss.parameter.width.description=The width, in px or %, of the box containing the RSS output (default is 30%)\nrendering.macro.rss.parameter.encoding.name=encoding\nrendering.macro.rss.parameter.encoding.description=The encoding to use when reading the RSS Feed (guessed by default)\nrendering.macro.useravatar.name=User Avatar\nrendering.macro.useravatar.description=Allows displaying the avatar for a specific user.\nrendering.macro.useravatar.parameter.height.name=height\nrendering.macro.useravatar.parameter.height.description=the image's height\nrendering.macro.useravatar.parameter.username.name=username\nrendering.macro.useravatar.parameter.username.description=the name of the user whose avatar is to be displayed\nrendering.macro.useravatar.parameter.width.name=width\nrendering.macro.useravatar.parameter.width.description=the image's width\nrendering.macro.chart.name=Chart\nrendering.macro.chart.description=Displays a graphical chart generated from miscellaneous data sources\nrendering.macro.chart.content.description=Input data for the chart macro (e.g. for 'inline' source mode)\nrendering.macro.chart.parameter.height.name=height\nrendering.macro.chart.parameter.height.description=The height of the generated chart image\nrendering.macro.chart.parameter.params.name=params\nrendering.macro.chart.parameter.params.description=Additional parameters for the data source\nrendering.macro.chart.parameter.source.name=source\nrendering.macro.chart.parameter.source.description=The string describing the type of input data source (e.g. xdom or inline)\nrendering.macro.chart.parameter.title.name=title\nrendering.macro.chart.parameter.title.description=The title of the chart (appears on top of the chart image)\nrendering.macro.chart.parameter.type.name=type\nrendering.macro.chart.parameter.type.description=The type of the chart (e.g. pie, line, area or bar)\nrendering.macro.chart.parameter.width.name=width\nrendering.macro.chart.parameter.width.description=The width of the generated chart image\nrendering.macro.info.name=Info Message\nrendering.macro.info.description=Displays an info message note.\nrendering.macro.info.content.description=The content to put in the box.\nrendering.macro.error.name=Error Message\nrendering.macro.error.description=Displays an error message note.\nrendering.macro.error.content.description=The content to put in the box.\nrendering.macro.warning.name=Warning Message\nrendering.macro.warning.description=Displays a warning message note.\nrendering.macro.warning.content.description=The content to put in the box.\nrendering.macro.success.name=Success Message\nrendering.macro.success.description=Displays a success message note.\nrendering.macro.success.content.description=The content to put in the box.\nrendering.macro.box.name=Box\nrendering.macro.box.description=Draw a box around provided content.\nrendering.macro.box.content.description=the content to put in the box\nrendering.macro.box.parameter.cssClass.name=cssClass\nrendering.macro.box.parameter.cssClass.description=A CSS class to add to the box element\nrendering.macro.box.parameter.image.name=image\nrendering.macro.box.parameter.image.description=the image which is to be displayed in the message box\nrendering.macro.box.parameter.title.name=title\nrendering.macro.box.parameter.title.description=the title which is to be displayed in the message box\nrendering.macro.box.parameter.width.name=width\nrendering.macro.box.parameter.width.description=An optional width for the box, expressed in px or %\nrendering.macro.code.name=Code\nrendering.macro.code.description=Highlights code snippets of various programming languages\nrendering.macro.code.content.description=the content to highlight\nrendering.macro.code.parameter.language.name=language\nrendering.macro.code.parameter.language.description=the language identifier (java, python, etc.)\nrendering.macro.code.parameter.layout.name=layout\nrendering.macro.code.parameter.layout.description=the layout format (plain or with line numbers)\nrendering.macro.code.parameter.source.name=source\nrendering.macro.code.parameter.source.description=the reference of the content to highlight (e.g. script:myvariable, entity:page:Page/SubPage)\nrendering.macro.code.parameter.cssClass.name=cssClass\nrendering.macro.code.parameter.cssClass.description=A CSS class to add to the box element\nrendering.macro.code.parameter.image.name=image\nrendering.macro.code.parameter.image.description=the image which is to be displayed in the message box\nrendering.macro.code.parameter.title.name=title\nrendering.macro.code.parameter.title.description=the title which is to be displayed in the message box\nrendering.macro.code.parameter.width.name=width\nrendering.macro.code.parameter.width.description=An optional width for the box, expressed in px or %\nrendering.macro.context.name=Context\nrendering.macro.context.description=Executes content in the context of the passed page\nrendering.macro.context.content.description=The content to execute\nrendering.macro.context.parameter.document.name=Page\nrendering.macro.context.parameter.document.description=The reference to the page the content will be executed in.\nrendering.macro.context.parameter.restricted.name=Restricted\nrendering.macro.context.parameter.restricted.description=Indicate if the content should be executed in a restricted context.\nrendering.macro.context.parameter.source.name=Source\nrendering.macro.context.parameter.source.description=the reference of the content to insert (e.g. string:**bold**, script:myvariable)\nrendering.macro.container.name=Container\nrendering.macro.container.description=A macro to enclose multiple groups and add decoration, such as layout.\nrendering.macro.container.content.description=The content to enclose in this container (wiki syntax). For the \"columns\" layout, a group should be added for each column.\nrendering.macro.container.parameter.layoutStyle.name=layout style\nrendering.macro.container.parameter.layoutStyle.description=The identifier of the container layout (e.g. \"columns\"). If no style is provided, the container content will be rendered as is.\nrendering.macro.container.parameter.justify.name=justify\nrendering.macro.container.parameter.justify.description=Flag specifying whether the content in this container is justified or not.\nrendering.macro.container.parameter.cssClass.name=CSS Class\nrendering.macro.container.parameter.cssClass.description=Value of the HTML class attribute to add to this container, used to style in CSS.\nrendering.macro.dashboard.name=Dashboard\nrendering.macro.dashboard.description=A macro to define a dashboard to fill with gadgets.\nrendering.macro.dashboard.parameter.layout.name=layout\nrendering.macro.dashboard.parameter.layout.description=The identifier of the layout to use for this dashboard (e.g. columns, etc). If none specified, columns will be used.\nrendering.macro.dashboard.parameter.style.name=Style\nrendering.macro.dashboard.parameter.style.description=The identifier of the style to be used for this dashboard. No style means that the gadgets will be rendered plain, as content of the page. \"panels\" style will render the gadgets the same as the panels. Note that this is used as the CSS class of the top level block of the dashboard, so you can pass any value to create your own dashboard style.\nrendering.macro.dashboard.parameter.source.name=Source\nrendering.macro.dashboard.parameter.source.description=The source of the dashboard macro, as a page reference, where the gadget configurations (objects) should be read from. By default the current page will be used. Example: Dashboard.WebHome.\nrendering.macro.gallery.name=Gallery\nrendering.macro.gallery.description=Displays the images found in the provided content using a slide-show view.\nrendering.macro.gallery.content.description=The images to be displayed in the gallery. All the images found in the provided wiki content are included. Images should be specified using the syntax of the current page. Example, for XWiki 2.0 syntax: image:Space.Page@alice.png image:http://www.example.com/path/to/bob.jpg\nrendering.macro.cache.name=Cache\nrendering.macro.cache.description=Caches content.\nrendering.macro.cache.content.description=The content to cache.\nrendering.macro.cache.parameter.id.name=id\nrendering.macro.cache.parameter.id.description=A unique id under which the content is cached.\nrendering.macro.cache.parameter.timeToLive.name=timeToLive\nrendering.macro.cache.parameter.timeToLive.description=The number of seconds to cache the content.\nrendering.macro.cache.parameter.maxEntries.name=maxEntries\nrendering.macro.cache.parameter.maxEntries.description=The maximum number of entries in the cache (Least Recently Used entries are ejected).\nrendering.macro.comment.name=Comment\nrendering.macro.comment.description=Allows putting comments in the source content. This macro doesn't output anything.\nrendering.macro.comment.content.description=Comments.\n### Wiki macros, distributed with XE -- TODO: remove these translations when localization tool will be ready to inject translations at .xar import time\nrendering.macro.spaces.name=Spaces\nrendering.macro.spaces.description=Displays all the spaces in this wiki.\nrendering.macro.tagcloud.name=Tag Cloud\nrendering.macro.tagcloud.description=Displays the cloud of tags in this wiki or in the specified space, if any.\nrendering.macro.tagcloud.parameter.space.name=space\nrendering.macro.tagcloud.parameter.space.description=The space to display the tag cloud for. If missing, the tags in the whole wiki will be displayed.\nrendering.macro.tagcloud.parameter.spaces.name=Spaces\nrendering.macro.tagcloud.parameter.spaces.description=Spaces to display the tag cloud for. Space names must be separated by comma \",\" and wrapped in single quotes \"'\". (i.e. 'Space1','Space2')\nrendering.macro.tagcloud.parameter.limit.name=Limit\nrendering.macro.tagcloud.parameter.limit.description=Maximum number of tags to be displayed in the cloud\nrendering.macro.activity.name=Activity\nrendering.macro.activity.description=The Activity Macro provides information about recent activities done by the users inside the XWiki instance. It lists the create, edit and delete events for pages, as well as comments, attachments and annotations.\nrendering.macro.activity.parameter.entries.name=entries\nrendering.macro.activity.parameter.entries.description=Number of entries to display the activity for.\nrendering.macro.activity.parameter.subentries.name=subentries\nrendering.macro.activity.parameter.subentries.description=Number of activities to show for each entry.\nrendering.macro.activity.parameter.wikis.name=wikis\nrendering.macro.activity.parameter.wikis.description=Comma separated list of wikis to display activity for.\nrendering.macro.activity.parameter.spaces.name=spaces\nrendering.macro.activity.parameter.spaces.description=Comma separated list of spaces to display the activity for.\nrendering.macro.activity.parameter.authors.name=authors\nrendering.macro.activity.parameter.authors.description=Comma separated list of authors whose modifications to show.\nrendering.macro.activity.parameter.tags.name=tags\nrendering.macro.activity.parameter.tags.description=Comma separated list of tags to display activity for.\nrendering.macro.activity.parameter.minor.name=minor\nrendering.macro.activity.parameter.minor.description=Whether to show modifications that create minor versions or not.\nrendering.macro.activity.parameter.rss.name=RSS\nrendering.macro.activity.parameter.rss.description=Whether to show activity RSS link or not.\nrendering.macro.spaceindex.name=Space Index\nrendering.macro.spaceindex.description=Lists the pages in a space.\nrendering.macro.spaceindex.parameter.count.name=count\nrendering.macro.spaceindex.parameter.count.description=The maximum number of pages to display. By default, up to 100 pages will be listed. If all pages should be displayed, pass 0.\nrendering.macro.spaceindex.parameter.space.name=space\nrendering.macro.spaceindex.parameter.space.description=The space to display the list of pages for. If missing, the current space will be used.\nrendering.macro.spaceindex.parameter.sort.name=sort\nrendering.macro.spaceindex.parameter.sort.description=Optional parameter to choose the sorting of the list of pages.\\nValid values are: 'creationDate': sort by creation date (default), 'modificationDate': sort by update date, or 'docName': sort alphabetically.\nrendering.macro.documents.name=Pages\nrendering.macro.documents.description=Displays a list of pages in a Livetable\nrendering.macro.documents.parameter.count.name=count\nrendering.macro.documents.parameter.count.description=Number of items to display by default\nrendering.macro.documents.parameter.actions.name=actions\nrendering.macro.documents.parameter.actions.description=Whether to show the actions columns or not\nrendering.macro.documents.parameter.space.name=space\nrendering.macro.documents.parameter.space.description=Only lists pages found in the passed space\nrendering.macro.documents.parameter.id.name=id\nrendering.macro.documents.parameter.id.description=Livetable id\nrendering.macro.documents.parameter.parent.name=parent\nrendering.macro.documents.parameter.parent.description=Only list pages having the specified parent\nrendering.macro.documents.parameter.columns.name=columns\nrendering.macro.documents.parameter.columns.description=Displays specified columns (e.g. \"doc.name,doc.author\"). The default value is \"doc.name,doc.space,doc.date,doc.author\".\nrendering.macro.attachmentSelector.name=Attachment Selector\nrendering.macro.attachmentSelector.description=A control to be used for object properties of the current page that are supposed to contain the name of an attachment from the current (or target) page. Allows uploading new attachments, and deleting attachments from the target page.  If no target page is specified, the current page will be used. Object properties are only saved to the current page.\nrendering.macro.attachmentSelector.parameter.classname.name=classname\nrendering.macro.attachmentSelector.parameter.classname.description=The full name of the page holding the XClass that contains the property associated with this picker.\nrendering.macro.attachmentSelector.parameter.property.name=property\nrendering.macro.attachmentSelector.parameter.property.description=The name of the property associated with the picker.\nrendering.macro.attachmentSelector.parameter.object.name=object\nrendering.macro.attachmentSelector.parameter.object.description=The identifier (number) of the object for which the property is displayed by this picker. If missing, the first instance of the class given by the parameter classname found in the page will be considered.\nrendering.macro.attachmentSelector.parameter.cssClass.description=A CSS class for the element surrounding the property value.\nrendering.macro.attachmentSelector.parameter.cssClass.name=cssClass\nrendering.macro.attachmentSelector.parameter.savemode.description=States how the property is updated. Accepted values: \"form\" (default)  meaning that the selected value is stored in an input that will be saved via an external form; \"direct\" means that the picker is responsible with updating the property value.\nrendering.macro.attachmentSelector.parameter.savemode.name=savemode\nrendering.macro.attachmentSelector.parameter.buttontext.description=Text of the button that triggers the picker. Defaults to $services.localization.render('xe.attachmentSelector.selectFile').\nrendering.macro.attachmentSelector.parameter.buttontext.name=buttontext\nrendering.macro.attachmentSelector.parameter.defaultValue.description=What attachment is displayed in view mode if the property is empty. Should either be empty or in the form of a wiki attachment reference (e.g. \"attachment.txt\", \"Another.Page@attachment.txt\").\nrendering.macro.attachmentSelector.parameter.defaultValue.name=defaultValue\nrendering.macro.attachmentSelector.parameter.filter.description=Comma separated list of file extensions accepted by the property (to become a comma separated list of mimetypes when XWiki will use HTML5). All files are accepted if this parameter is empty.\nrendering.macro.attachmentSelector.parameter.filter.name=filter\nrendering.macro.attachmentSelector.parameter.displayImage.description=States whether images are displayed or just their name is printed like for other attachments. Possible values: true, false (default).\nrendering.macro.attachmentSelector.parameter.displayImage.name=displayImage\nrendering.macro.attachmentSelector.parameter.width.description=The width of the displayed image, only taken into account if displayImage=true.\nrendering.macro.attachmentSelector.parameter.width.name=width\nrendering.macro.attachmentSelector.parameter.height.description=The height of the displayed image, only taken into account if displayImage=true.\nrendering.macro.attachmentSelector.parameter.height.name=height\nrendering.macro.attachmentSelector.parameter.alternateText.description=The alternate text of the displayed image, only taken into account if displayImage=true\nrendering.macro.attachmentSelector.parameter.alternateText.name=alternateText\nrendering.macro.attachmentSelector.parameter.link.description=States whether a link to the attachment is associated in view mode with the displayed attachment name/image. Possible values: true, false (default).\nrendering.macro.attachmentSelector.parameter.link.name=link\nrendering.macro.attachmentSelector.parameter.targetdocname.description=The target page name to save/list attachments from\nrendering.macro.attachmentSelector.parameter.targetdocname.name=targetdocname\nrendering.macro.messageSender.name=Message Sender\nrendering.macro.messageSender.description=A control that allows users to enter messages that are handled by the MessageStream module.\nrendering.macro.messageSender.parameter.visibility.name=visibility\nrendering.macro.messageSender.parameter.visibility.description=Default selected visibility when the macro is displayed.\\nIf not specified, it is determined automatically based on the page where the macro is used.\\nValid values are: 'everyone', 'followers', 'group' or 'user'.\nrendering.macro.messageSender.parameter.visibilityParameter.name=visibilityParameter\nrendering.macro.messageSender.parameter.visibilityParameter.description=Some visibility levels (like 'user' and 'group') accept a parameter. In the case of the 2 mentioned levels, the value can be a serialized reference of a user or a group page.\nrendering.macro.messageSender.parameter.visibilityOptions.name=visibilityOptions\nrendering.macro.messageSender.parameter.visibilityOptions.description=Comma separated list of visibility options that the macro should allow the user to choose from.\\nThis list should be a sublist of the default ones: 'everyone', 'followers', 'group', 'user'.\nrendering.macro.async.name=Async macro\nrendering.macro.async.description=Execute asynchronously and/or cache the macro content.\nrendering.macro.async.content.description=The wiki content to execute.\nrendering.macro.async.parameter.async.name=Async\nrendering.macro.async.parameter.async.description=Enable or disable asynchronous execution\nrendering.macro.async.parameter.cached.name=Cached\nrendering.macro.async.parameter.cached.description=Enable or disable caching of the result of the macro content execution\nrendering.macro.async.parameter.contextEntries.name=Context entries\nrendering.macro.async.parameter.contextEntries.description=The list of context elements needed for the execution (wiki, user, locale, request.base, doc.reference...)\nrendering.macro.async.parameter.id.name=Id override\nrendering.macro.async.parameter.id.description=A unique id is automatically generated by default but it's possible to provide a custom one if needed\n\n####################\n# Async\n####################\n\nrendering.async.context.entry.author=Author\nrendering.async.context.entry.doc.reference=Document\nrendering.async.context.entry.wiki=Wiki\nrendering.async.context.entry.secureDocument=Secure document\nrendering.async.context.entry.request.parameters=Request parameters\nrendering.async.context.entry.request.url=Request URL\nrendering.async.context.entry.request.base=Request base URL\nrendering.async.context.entry.request.wiki=Request wiki\nrendering.async.context.entry.request.contextpath=Request context path\nrendering.async.context.entry.locale=Language\nrendering.async.context.entry.action=Action\nrendering.async.context.entry.user=User\n\nrendering.async.error.failed=Failed to execute asynchronous content\n\n####################\n# Plugins\n####################\n\n### Tag plugin\nplugin.tag.editcomment.renamed=Renamed tag [{0}] to [{1}]\nplugin.tag.editcomment.added=Added tag [{0}]\nplugin.tag.editcomment.removed=Removed tag [{0}]\n\n####################\n# Applications\n####################\n\n### Rights manager (XWiki Enterprise wiki)\nrightsmanager.confirmdeleteuser=The user __name__ will be deleted and removed from all groups he belongs to. Are you sure you want to proceed?\nrightsmanager.confirmdeletegroup=The group __name__ will be deleted. Are you sure you want to proceed?\nrightsmanager.confirmdeletemember=This user will be removed from the current group. Are you sure you want to proceed?\nrightsmanager.duplicateuser=Some users already exist in the group\nrightsmanager.unregisteredusers=Unregistered Users\nrightsmanager.specialusers=Special Users\nrightsmanager.groups=Groups\nrightsmanager.users=Users\nrightsmanager.groupsorusers=Groups or Users\nrightsmanager.admin=Admin\nrightsmanager.programming=Program\nrightsmanager.edit=Edit\nrightsmanager.script=Script\nrightsmanager.view=View\nrightsmanager.delete=Delete\nrightsmanager.register=Register\nrightsmanager.createwiki=Create Wiki\nrightsmanager.comment=Comment\nrightsmanager.global=Global\nrightsmanager.local=Local\nrightsmanager.both=Both\nrightsmanager.edituserprofile=For more options to edit this user, please go to the\nrightsmanager.userprofile=user's profile\nrightsmanager.members=Members\nrightsmanager.manage=Manage\nrightsmanager.addnewuser=Create user\nrightsmanager.addnewgroup=Add group\nrightsmanager.createnewgroup=Create new group\nrightsmanager.creategroup=Create group\nrightsmanager.groupexist=__name__ cannot be used for the group name, as another page with this name already exists.\nrightsmanager.documentrequireviewrights=(*) Some pages require special rights to be viewed.\nrightsmanager.denyrightforuorg=You are about to deny the __right__ right for __name__. Continue?\nrightsmanager.clearrightforuorg=You are about to clear the __right__ right for __name__. Continue?\nrightsmanager.denyrightforcurrentuser=You are about to deny the __right__ right for yourself. Continue?\nrightsmanager.clearrightforcurrentuser=You are about to clear the __right__ right for yourself. Continue?\nrightsmanager.clearrightforcurrentuserinstead=Would you like to clear the __right__ right for yourself instead?\nrightsmanager.denyrightforgroup=You are about to deny the __right__ right for  __name__. This implies denying your own __right__ right, if you are part of this group. Continue?\nrightsmanager.clearrightforgroup=You are about to clear the __right__ right for __name__. This implies clearing your own __right__ right, if you are part of this group. Continue?\nrightsmanager.clearrightforgroupinstead=Would you like to clear the __right__ right for __name__ instead? This implies clearing your own __right__ right, if you are part of this group. Continue?\nrightsmanager.username=User Name\nrightsmanager.firstname=First Name\nrightsmanager.lastname=Last Name\nrightsmanager.groupname=Group Name\nrightsmanager.displayrows=Displaying rows\nrightsmanager.searchfilter=Search filter:\nrightsmanager.searchscope=Search scope:\nrightsmanager.guestcommentrequirescaptcha=Require unregistered users to solve a CAPTCHA when posting a comment on a page\n\nui.ajaxTable.outof=out of\nui.ajaxTable.loading=Loading...\n\nplatform.core.rightsManagement.editRightsForSpace=Editing access rights for space {0}\nplatform.core.rightsManagement.ajaxFailure=An error occurred while communicating with the server. Please check that the server is accessible, and you have the proper rights to perform the requested action.\nplatform.core.rightsManagement.saveFailure=An exception occurred while trying to save the current modifications. Please check if you have the proper rights to perform these modifications.\nplatform.core.rightsManagement.saveComment={0} {1} right for {2}\n### For accessibility concerns, needs to contain both the current state and the purpose.\nplatform.core.rightsManagement.allowed=Allowed. Click to deny.\n### For accessibility concerns, needs to contain both the current state and the purpose.\nplatform.core.rightsManagement.denied=Denied. Click to switch to undefined.\n### For accessibility concerns, needs to contain both the current state and the purpose.\nplatform.core.rightsManagement.undefined=Undefined. Click to allow.\n\nplatform.core.rendering.error.readTechnicalInformation=Read technical information related to this error\nplatform.core.rendering.noRendererForSectionEdit=This page's syntax doesn't support section editing!\n\nplatform.core.errorMessageType=Error\nplatform.core.noticeMessageType=Notice\nplatform.core.warningMessageType=Warning\nplatform.core.invalidUrl=This is not a valid URL\nplatform.core.action.objectRemove.noClassnameSpecified=No object type specified.\nplatform.core.action.objectRemove.noObjectSpecified=No object specified.\nplatform.core.action.objectRemove.invalidObject=Invalid object specified.\nplatform.core.action.deleteAttachment.noAttachment=This attachment does not exist.\ncore.action.deleteAttachment.failed=Failed to delete attachment {0}\ncore.action.upload.failure=Failed to upload {0,choice,0#files|1#one file|1<{0} files}.\ncore.action.upload.failure.title=Uploading files to <a href=\"{1}\">{0}</a>\ncore.action.upload.failure.failedFiles=Internal failure while attaching:\ncore.action.upload.failure.wrongFileNames=The following file names are not supported:\ncore.action.upload.failure.noFiles=No files to attach were found in the request.\n\n### XWikiExplorer JS Widget\nxwikiexplorer.page.hint=Located in\nxwikiexplorer.addpage.title=New page...\nxwikiexplorer.addpage.hint=New page in\nxwikiexplorer.attachments.title=Attachments\nxwikiexplorer.attachments.hint=Attachments of\nxwikiexplorer.attachment.hint=Attached to\nxwikiexplorer.addattachment.title=Upload file...\nxwikiexplorer.addattachment.hint=Upload file to\n\n\n### Tag application\nxe.tag.tags=Tags\nxe.tag.tagclass=XWiki Tag Class\nxe.tag.tagcloud=Tag Cloud\nxe.tag.notags=No page has been tagged yet\nxe.tag.notagsforspace=No tag has been added on this page or on its children\nxe.tag.tooltip={0,choice,1#1 page|1<{0} pages}\nxe.tag.alldocs=All pages tagged with {0}\nxe.tag.activity=Activity Stream for pages tagged with {0}\nxe.tag.rename=Rename\nxe.tag.rename.success=Tag {0} has been successfully renamed.\nxe.tag.rename.failure=Renaming of tag {0} to {1} failed.\nxe.tag.rename.renameto=Rename {0} to:\nxe.tag.rename.link=Rename\nxe.tag.delete=Delete tag {0}\nxe.tag.delete.success=Tag {0} has been successfully deleted.\nxe.tag.delete.failure=Deletion of tag {0} failed.\nxe.tag.delete.link=Delete\ncore.tags.list.label=Tags:\ncore.tags.add.tooltip=Add tags\ncore.tags.add.label=Comma separated tags:\ncore.tags.add.submit=Add\ncore.tags.add.cancel=Cancel\ncore.tags.add.error.alreadySet=This tag is already set\ncore.tags.add.error.notAllowed=You are not allowed to tag this page\ncore.tags.add.error.failed=Failed to add tag \"{0}\" due to an internal server error\ncore.tags.remove.tooltip=Delete this tag from the page\ncore.tags.remove.error.notFound=This tag is not set\ncore.tags.remove.error.notAllowed=You are not allowed to remove tags from this page\ncore.tags.remove.error.failed=Failed to remove tag \"{0}\" due to an internal server error\ncore.tags.adding=Adding tag...\ncore.tags.deleting=Deleting tag...\ncore.tags.fetchform=Fetching form...\nxe.tag.paramerror=Do not use \"space\" and \"spaces\" parameter in the same time\n\n### Page footer\ndocextra.annotations=Annotations\ndocextra.comments=Comments\ndocextra.children=Children\ndocextra.attachments=Attachments\ndocextra.history=History\ndocextra.information=Information\ndocextra.extranb=({0})\ndocextra.parent=Parent\ndocextra.backlinks=Backlinks\ndocextra.creation=Creation\ndocextra.createdby=by {0} on {1}\ndocextra.includedpages=Included pages\ndocextra.siblings=Siblings\ncore.tagedit.title=Tags\ntags.save=Save\ntags.save.success=Tags saved successfuly\ntags.save.error=An error occurred while saving tags\n\ncore.links.content=Content\n\n# Recent Members (XWiki Enterprise wiki)\nxe.recentmembers=Recent Members\n\n### Activity Macro (since XWiki Enterprise 2.6RC2)\nxe.activity=Activity Stream\nxe.activity.rssfeed=RSS feed\nxe.activity.noentries=There are no activities in the stream\n\nxe.activity.action.create=created the page\nxe.activity.action.delete=deleted the page\nxe.activity.action.update=edited the page\nxe.activity.action.BlogPostPublishedEvent=published a blog post\nxe.activity.action.addAnnotation=added an annotation\nxe.activity.action.deleteAnnotation=deleted an annotation\nxe.activity.action.updateAnnotation=edited an annotation\nxe.activity.action.addAttachment=added {0,choice,1#an attachment|1<{0} attachments}\nxe.activity.action.deleteAttachment=deleted an attachment\nxe.activity.action.updateAttachment=edited {0,choice,1#an attachment|1<{0} attachments}\nxe.activity.action.addComment=added a comment\nxe.activity.action.deleteComment=deleted a comment\nxe.activity.action.updateComment=edited a comment\nxe.activity.action.summary={0,choice,1#one change|1<{0} changes} by {1,choice,1#one user|1<{1} users}\nxe.activity.action.seechanges=see changes\nxe.activity.action.personalMessage=posted the message\nxe.activity.action.directMessage=says:\nxe.activity.action.groupMessage=posted the message\nxe.activity.action.publicMessage=posted the message\n\nxe.activity.messages.visibility=Visible to\nxe.activity.messages.visibility.targetName.tip=Name\nxe.activity.messages.submit=Share\nxe.activity.messages.submit.inProgress=Sending...\nxe.activity.messages.submit.failed=Failed to send message\nxe.activity.messages.submit.success=Message sent\nxe.activity.messages.follow=Follow\nxe.activity.messages.following=Following\nxe.activity.messages.unfollow=Unfollow\nxe.activity.messages.follow.inProgress=Updating...\nxe.activity.messages.follow.failed=Failed to add:\nxe.activity.messages.unfollow.confirm=Are you sure you wish to stop following {0}?\nxe.activity.messages.delete=Delete this message\nxe.activity.messages.delete.confirm=Are you sure you wish to delete this message?\nxe.activity.messages.delete.failed=Failed to delete the message\nxe.activity.messages.delete.success=Message deleted\nxe.activity.messages.error.loginToSendMessage=You need to [[log in>>{0}]] before sending messages.\nxe.activity.messages.inactive=The Message feature is currently turned off. You can turn it on from the [[administration>>{0}]].\n\n###timeAgo used by Recent Activity macro (XE 2.6RC1) and Activity macro\ntimeAgo.minutesAgo={0,choice,0#few seconds|1#one minute|1<{0} minutes} ago\ntimeAgo.hoursAgo={0,choice,0#less than one hour|1# one hour|1<{0} hours} ago\ntimeAgo.daysAgo={0,choice,0#less than one day|1# one day|1<{0} days} ago\ntimeAgo.monthsAgo={0,choice,0#less than month|1# one month|1<{0} months} ago\ntimeAgo.yearsAndMonthsAgo={0,choice,0#|1# one year|1<{0} years} {1,choice,0#|1#and one month|1<and {1} months} ago\ntimeAgo.today=Today\ntimeAgo.yesterday=Yesterday\n\n### Administration application\nadmin.main.title=Administration\nadmin.switchContext=Go\n\n### categories\nadmin.lf=Look & Feel\nadmin.lf.description=Change the aspect and layout of the wiki.\nadmin.usersgroups=Users & Rights\nadmin.usersgroups.description=Manage users, groups, and their access rights.\nadmin.content=Content\nadmin.content.description=Manipulate the content of the wiki.\nadmin.extensionmanager=Extensions\nadmin.extensionmanager.description=Search, add, upgrade and remove extensions.\n\n### sections\nadmin.editing=Edit Mode\nadmin.editing.description=Choose the default edit mode and configure its title and versioning parameters.\nadmin.localization=Localization\nadmin.localization.description=Language-related settings.\nadmin.programming=Programming\nadmin.programming.description=Settings related to programming in XWiki.\nadmin.ooserver=Office Server\nadmin.ooserver.options=Options\nadmin.ooserver.options.source=These options are configured on the server, in {0}.\nadmin.xwiki.officeimporteradmin.description=Configure the Office Server.\n\nadmin.presentation=Presentation\nadmin.presentation.description=Choose the page tabs that are visible and configure the page header and footer.\nadmin.panelwizard=Panel Wizard\nadmin.panels.panelwizard.description=Add and remove panels, change the page layout.\nadmin.colorthemes=Color Themes\nadmin.colorthemes.description=Settings for color themes customization.\nadmin.colorthemes.colibrithemes=Colibri Themes\nadmin.colorthemes.flamingothemes=Flamingo Themes\nadmin.colorthemes.invalidtheme=The current value ({0}) is invalid. The color theme might not exist.\nadmin.icontheme=Icon Theme\n\nadmin.users=Users\nadmin.users.description=Manage users of this wiki: add, remove, modify their profile information.\nadmin.groups=Groups\nadmin.groups.description=Manage user groups: add or remove groups, or change group members.\nadmin.registration=Registration\nadmin.registration.description=Manage user registration settings.\nadmin.rights=Rights\nadmin.rights.description=Manage groups and users rights: control who can view, edit and delete pages.\nadmin.pagerights=Rights: Page\nadmin.pagerights.description=Manage groups and users rights: control who can view, edit and delete the page. It does not affect the children.\nadmin.pagerights.info=These rights apply on this page only.\nadmin.pagerights.infoNonTerminalDoc=They do not affect the {0}children{1}.\nadmin.pageandchildrenrights=Rights: Page & Children\nadmin.pageandchildrenrights.description=Manage groups and users rights: control who can view, edit and delete the page. It affect their children.\nadmin.pageandchildrenrights.info=These rights apply on this page {0}and all {1}its children{2}{3}.\nadmin.userprofile=User Profile\nadmin.userprofile.description=Manage what information is displayed on the user profile of each user.\n\nadmin.import=Import\nadmin.import.description=Import pages or applications into the wiki.\nadmin.export=Export\nadmin.export.description=Export wiki pages into a XAR.\n\nadmin.xwiki.extensions.description=Search for new extensions to add to the wiki.\nadmin.xwiki.extensionhistory.description=See the history of the installed extensions.\nadmin.xwiki.extensionupdater.description=Check if there are any updates available for the installed extensions.\n\nadmin.globaladmin=Wiki Preferences\nadmin.spaceadmin=Space Preferences\nadmin.placetoadminister=Place to administer\nadmin.gotoglobaladministration=Edit Wiki Preferences:\nadmin.globaladministration=Wiki Administration\nadmin.gotospaceadministration=Edit Space Preferences:\nadmin.showsections=Show the available categories\nadmin.hidesections=Hide the available categories\nadmin.documentation=Help on this setting\nadmin.general=General settings\nadmin.authentification=Authentication\nadmin.docextra=Page Tabs\nadmin.language=Language\nadmin.date=Date / Time\nadmin.editor=Editor\nadmin.versioning=Versioning\nadmin.smtp=SMTP\nadmin.header=Header\nadmin.panels=Panels\nadmin.footer=Footer\nadmin.skin=Skin\nadmin.messagestream=Message Stream\nadmin.messagestream.description=Enable or disable the message stream in the wiki.\nadmin.colortheme=Color Theme\nadmin.colortheme.wikiSetting=The color theme configured at the wiki level is {0}.\nadmin.colortheme.manage=Manage color themes\\u00BB\nadmin.customize=Customize\nadmin.save=Save\nadmin.defaultwikinotinstalled_useflavor=Your wiki seems empty. You may want to {0}install a flavor{1}, it will bring you a lot of features: user profiles, recent activity, administration pages and many more.\nadmin.adminappnotinstalled=The administration application is not installed. Since XWiki Enterprise 1.5, the Administration is distributed as an application. You can download it from {0}.\nadmin.preferences.title=Preferences\n\n### Account validation\nxe.admin.accountvalidation.success=Your account has been activated. You can now <a href=\"{0}\">login</a>.\nxe.admin.accountvalidation.failure=There was a problem validating your account. Please contact an administrator.\n### Group management\nxe.admin.groups.member=Member\nxe.admin.groups.type=Type\nxe.admin.groups.type.user=User\nxe.admin.groups.type.group=Group\nxe.admin.groups.scope=Scope\nxe.admin.groups._actions=Actions\nxe.admin.groups._actions.delete=Remove\nxe.admin.groups.addUser=Users to add\nxe.admin.groups.addUser.submit=Add\nxe.admin.groups.addGroup=Subgroups to add\nxe.admin.groups.addSuccess=Members successfully added\nxe.admin.groups.addFailure=Failed to add members to group:\nxe.admin.groups.filter.groupName=Group name filter\nxe.admin.groups.filter.scope=Groups scope\nweb.groups.administration.groupsIgnored=Members successfully added but some groups have been ignored ({0})\n\nxe.admin.groups.loading=Loading...\nxe.admin.groups.name=Group Name\nxe.admin.groups.members=Members\nxe.admin.groups.manage=Manage\nxe.admin.groups.local=Local\nxe.admin.groups.global=Global\nxe.admin.groups.both=Both\nxe.admin.groups.create=Create a new group\nxe.admin.groups.create.inProgress=Creating the group...\nxe.admin.groups.create.done=Group created\nxe.admin.groups.create.failed=Failed to create the group\nxe.admin.groups.creategroup=Create group\nxe.admin.groups.editGroup=Edit group\nxe.admin.groups.deleteGroup=Delete group\nxe.admin.groups.delete.inProgress=Deleting the group...\nxe.admin.groups.delete.done=Group deleted\nxe.admin.groups.delete.failed=Failed to delete the group\nxe.admin.groups.currentgroups=Existing groups\nxe.admin.groups.administration=XWiki groups administration pages\n\nxe.admin.groups._avatar=Picture\nxe.admin.groups.email=Email\nxe.admin.groups.company=Company\nxe.admin.groups.phone=Phone\nxe.admin.groups.emptyvalue=-\n\n### User management\nxe.admin.users.loading=Loading...\nxe.admin.users=Users\nxe.admin.users.registernew=Register a new user\nxe.admin.users.existing=Existing user accounts\nxe.admin.users.administration=XWiki users administration pages\nxe.admin.users.sheet=User Sheet\nxe.admin.users.applyonusers=This stylesheet must be applied on a page containing a XWiki.XWikiUsers object.\nxe.admin.users.name=User\nxe.admin.users.first_name=First Name\nxe.admin.users.last_name=Last Name\nxe.admin.users.scope=Scope\nxe.admin.users._actions=Actions\nxe.admin.users._actions.disable=Disable\nxe.admin.users._actions.enable=Enable\nxe.admin.users.editUser=Edit user\nxe.admin.users.deleteUser=Delete user\nxe.admin.users.delete.inProgress=Deleting the user\\u2026\nxe.admin.users.delete.done=User deleted\nxe.admin.users.delete.failed=Failed to delete the user\nxe.admin.users.create.inProgress=Creating the user\\u2026\nxe.admin.users.create.done=User created\nxe.admin.users.create.failed=Failed to create the user\n\n### User profile management\nplatform.user.profileConfigureSectionsTitle=Displayed sections\nplatform.user.profileConfigureSectionsLabel=Section IDs\nplatform.user.profileConfigureSectionsHint=Space or newline separated list of section IDs to be displayed from the list of sections defined below.\nplatform.user.profileConfigureSectionsAllTitle=All sections\nplatform.user.profileConfigureSectionAddButtonLabel=Add\nplatform.user.profileConfigureSectionRemoveButtonLabel=Remove\nplatform.user.profileConfigureSectionIdLabel=Section ID\nplatform.user.profileConfigureSectionIdHint=Unique identifier of this section. Must not contain spaces.\nplatform.user.profileConfigureSectionNameLabel=Section Name\nplatform.user.profileConfigureSectionNameHint=Display name of this section. This can be a fixed string or a [[translation key>>{0}]] (Example: $services.localization.render(''key'')).\nplatform.user.profileConfigureSectionPropertiesLabel=Section Properties\nplatform.user.profileConfigureSectionPropertiesHint=Space or newline separated list of properties of the [[{0}]] class to display in this section. An optional [[microformats>>http://en.wikipedia.org/wiki/Microformat]] class can prefix the property name (Example: given-name:first_name family-name:last_name).\nplatform.user.profileConfigureSaveButtonLabel=Save\n\n### Skin\nxe.admin.skin=Skin\nxe.admin.skin.makeyourown=You can modify the existing look and feel and even create your own.\nxe.admin.skin.editskin=Edit this skin\nxe.admin.skin.testskin=Test this skin\n\n### Username recovery\nxe.admin.forgotUsername.loginMessage=Forgot your username?\nxe.admin.forgotUsername.title=Forgot your username?\nxe.admin.forgotUsername.instructions=Please enter the email address you provided when creating your account.\nxe.admin.forgotUsername.email.label=Email address\nxe.admin.forgotUsername.submit=Retrieve username\nxe.admin.forgotUsername.login=Login \\u00BB\nxe.admin.forgotUsername.error.retry=\\u00AB Try again using another email address\nxe.admin.forgotUsername.error.emailFailed=An unknown problem occurred while sending the forgot username email.\nxe.admin.forgotUsername.emailSent=If an account is registered with this email, you will receive the account information on {0}.\n\n### Password reset\nxe.admin.passwordReset.loginMessage=Forgot your password?\n\nxe.admin.passwordReset.title=Forgot your password?\nxe.admin.passwordReset.instructions=Please enter your username to start the password reset process.\nxe.admin.passwordReset.username.label=Username\nxe.admin.passwordReset.submit=Reset password\nxe.admin.passwordReset.emailSentToUsername=An e-mail was sent to the address configured for user \"{0}\". Please follow the instructions in that e-mail to complete the password reset procedure.\nxe.admin.passwordReset.login=Login \\u00BB\nxe.admin.passwordReset.error.noUser=The {0} user does not exist.\nxe.admin.passwordReset.error.ldapUser=The {0} user is an LDAP user. In that case the password has to be changed on the LDAP server.\nxe.admin.passwordReset.error.noEmail=Cannot reset password: email address not provided in the user profile.\nxe.admin.passwordReset.error.emailFailed=An unknown problem occurred while sending the reset email.\nxe.admin.passwordReset.error.retry=\\u00AB Retry username\nxe.admin.passwordReset.error.recoverUsername=Forgot your username?\nxe.admin.passwordReset.versionComment=Generated password reset token\nxe.admin.passwordReset.error.csrf=Bad CSRF token, you need to perform the procedure again.\n\nxe.admin.passwordReset.step2.title=Reset your password\nxe.admin.passwordReset.step2.newPassword.label=New password\nxe.admin.passwordReset.step2.newPasswordVerification.label=Re-enter new password\nxe.admin.passwordReset.step2.submit=Save\nxe.admin.passwordReset.step2.success=The password has been successfully set.\nxe.admin.passwordReset.step2.login=Please login to continue \\u00BB\nxe.admin.passwordReset.step2.backToStep1=Back to the password reset page \\u00BB\nxe.admin.passwordReset.step2.error.emptyPassword=The password cannot be empty.\nxe.admin.passwordReset.step2.error.verificationMismatch=The two passwords do not match.\nxe.admin.passwordReset.step2.error.wrongParameters=Wrong parameters! Another link was already sent or this one was already accessed!\nxe.admin.passwordReset.step2.error.noProgrammingRights=This page requires programming rights to work, which currently isn't the case. Please notify an administrator of this problem and try again later.\nxe.admin.passwordReset.step2.versionComment.passwordReset=Password was reset\nxe.admin.passwordReset.step2.versionComment.changeValidationKey=Refreshed password reset token\n\n### XWiki.Configurable - application configuration\nxe.admin.configurable.title=Custom configurable sections\nxe.admin.configurable.macros.title=Macros for custom configurable sections\nxe.admin.configurable.noPermissionThisApplication=You don't have permission to configure this application.\nxe.admin.configurable.applicationAuthorNoAdmin=This configuration cannot be displayed because it was last edited by [[{0}]] who doesn''t have permission to edit this page.\nxe.admin.configurable.cannotLockNoJavascript=This page cannot be locked for editing because Javascript is turned off. For page editing safety, please enable Javascript.\nxe.admin.configurable.configurationClassNonexistant=No class found by the name {0}, can''t display configuration.\nxe.admin.configurable.noObjectOfConfigurationClassFound=No object of class: {0} found in page {1}, can''t display configuration.\nxe.admin.configurable.sectionIconNoAccess=(No Access)\nxe.admin.configurable.sectionIconNoAccessTooltip=You don't have permission to configure this section.\nxe.admin.configurable.noViewAccessSomeApplications=Some sections may not be displayed because you do not have view access to some configurable applications including: {0}\n### XWiki.Registration\nxe.admin.registration.passwordTooShort=Please use a longer password.\nxe.admin.registration.passwordMismatch=The passwords do not match.\nxe.admin.registration.invalidEmail=Please enter a valid email address.\nxe.admin.registration.youCanConfigureRegistrationHere=You can configure this application by clicking here.\nxe.admin.registration.youCanConfigureRegistrationFieldsHere=You can add, remove and change fields in this form by clicking here.\nxe.admin.registration.fieldWithNoName=ERROR: Field with no name.\n\n### Attachment picker macro\nxe.attachmentSelector.gallery.title=Attachments\nxe.attachmentSelector.upload.title=Add\nxe.attachmentSelector.upload.hint=Accepted formats: {0}\nxe.attachmentSelector.upload.submit=Upload and select\nxe.attachmentSelector.selectFile=Choose an attachment\nxe.attachmentSelector.default=Default\nxe.attachmentSelector.supportedFormats=Accepted formats: {0}\nxe.attachmentSelector.actions.select=Select\nxe.attachmentSelector.actions.delete=Delete\nxe.attachmentSelector.actions.view=View\nxe.attachmentSelector.actions.download=Download\nxe.attachmentSelector.upload.error.noFile=Please choose a file to upload\nxe.attachmentSelector.upload.error.badExtension=Unsupported file format\nxe.attachmentSelector.upload.inProgress=Uploading...\nxe.attachmentSelector.cancel=Cancel and return to page\nxe.attachmentSelector.postUpload.comment=Update field {0}\n\n### Users Directory\nxe.userdirectory.title=User Directory\nxe.userdirectory.customizeSaveButtonLabel=Save\nxe.userdirectory.customizeResetButtonLabel=Reset to default\nxe.userdirectory.customizePreviewTitle=Preview\nxe.userdirectory.isCustomizedWarning=You are viewing a customized user directory. You can [[reset it to default>>{0}||queryString=\"{1}\"]] or [[customize>>{2}||queryString=\"{3}\"]] it further.\nxe.userdirectory.canCustomizeInfo=The user directory can be [[customized>>{0}||queryString=\"{1}\"]] to display the columns you wish to see.\nxe.userdirectory.canCustomizeInfoGuest=The user directory can be customized to display the columns you wish to see, but you need to [[log in>>{0}]] first.\nxe.userdirectory._avatar=Picture\nxe.userdirectory.doc.name=User ID\nxe.userdirectory.emptyvalue=\nadmin.userdirectory=User Directory\nadmin.userdirectory.description=Customize the user directory live table.\n\n####################\n# Translations for Invitation Application\n####################\n\n### Invitation section of administration interface.\nadmin.invitation=Invitation\nadmin.invitation.description=Configure the Invitation Application\nxe.invitation.heading=Invitation Messenger\nxe.invitation.userIsReportedSpammer=A message which you sent was reported as spam and your privilege to send mail has been suspended pending investigation, we apologize for the inconvenience.\nxe.invitation.internalDocument=This page is used by the [[invitation application>>{0}]]\nxe.invitation.onlyMembersCanSendMail=Sorry, only members of this wiki can send mail.\nxe.invitation.youAreAMemberOfOtherWiki=You seem to be a member of {0} which is a different wiki.\nxe.invitation.toLabel=To:\nxe.invitation.subjectLabel=Subject:\nxe.invitation.contentLabel=Message:\nxe.invitation.previewLabel=Preview:\nxe.invitation.errorWhileSending=An error has occurred while sending the message.\nxe.invitation.successSending=Your message has been sent.\nxe.invitation.messageSentLogEntry=Message sent\nxe.invitation.noValidMessagesToSend=Your message could not be sent because there were no valid email addresses to send to.\nxe.invitation.noMessageFound=No message found by that id.\nxe.invitation.guestsCanNotJoin=Invitations can not be accepted because this wiki is closed. To allow invitees to join, save [[{0}]] as a user with Programming Rights.\nxe.invitation.failedToCreateDocuments=Failed to create pages necessary for Invitation application to function.\n\nxe.invitation.emailContent.subjectLine={0} has invited you to join {1} {2}\nxe.invitation.emailContent.userHasInvitedYouToJoinWiki=You have received this mail because {0} has invited you to join {1}.\nxe.invitation.emailContent.joinLink=Accept the invitation and join\nxe.invitation.emailContent.declineLink=Decline\n### reportMessage expects the opening link tag to be passed as the parameter.\nxe.invitation.emailContent.reportMessage=If this message looks like abuse of our system, please {0}report it{1}\n\nxe.invitation.sendMail.addMessageSaveComment=Added Email Message(s).\n\nxe.invitation.displayOldMessage.heading=Inspect sent message\nxe.invitation.displayOldMessage.noMessageFound=No message by this id was found.\nxe.invitation.displayOldMessage.reportedAsSpam=Reported as spam\nxe.invitation.displayOldMessage.waitingToBeInvestigated=Waiting to be investigated\nxe.invitation.displayOldMessage.viewMessage=View Message\nxe.invitation.displayOldMessage.sentBy=Sent by:\nxe.invitation.displayOldMessage.markThisMessageAsInvestigated=Mark this message as investigated.\n\nxe.invitation.displayAllOldMessages.status=Message Status\nxe.invitation.displayAllOldMessages.viewMessagesSentByUsers=View messages sent by users\nxe.invitation.displayAllOldMessages.sender=Sender\nxe.invitation.displayAllOldMessages.subject=Subject\nxe.invitation.displayAllOldMessages.memo=Notes:\n\nxe.invitation.displayMessageTable.sentDate=Date\nxe.invitation.displayMessageTable.sendingUser=Sender\nxe.invitation.displayMessageTable.subjectLine=Subject\nxe.invitation.displayMessageTable.status=Status\nxe.invitation.displayMessageTable.memo=Memo\nxe.invitation.displayMessageTable.recipient=Email\nxe.invitation.displayMessageTable.history=Message History\nxe.invitation.displayMessageTable.showHistory=Show History\nxe.invitation.displayMessageTable.multipleRecipients={0} Recipients\nxe.invitation.displayMessageTable.various=<various>\nxe.invitation.displayMessageTable.noMessages=No messages to display\n\nxe.invitation.displayMessageTableInForm.buttonLabel.cancel=Rescind Invitation\nxe.invitation.displayMessageTableInForm.buttonLabel.notSpam=Mark as not spam\n\nxe.invitation.doAction.confirmLabel=Confirm\nxe.invitation.doAction.lackingPermission=You do not have permission to do this action.\nxe.invitation.doAction.invitationCanceledMemo={0} left you this message when rescinding the invitation.\nxe.invitation.doAction.invalidStatus=This request cannot be processed because the status of this invitation is {0}.\n\nxe.invitation.doAction.reportSpam.heading=Report Abuse\nxe.invitation.doAction.reportSpam.noMessageFound=There was no message found by the given ID. Maybe an administrator deleted the message from our system.\nxe.invitation.doAction.reportSpam.success=Your report has been logged and the situation will be investigated as soon as possible, we apologize for the inconvenience.\nxe.invitation.doAction.reportSpam.reportSaveComment=Reported message as spam.\nxe.invitation.doAction.reportSpam.areYouSure=Are you sure you would like to report this message as abuse?\nxe.invitation.doAction.reportSpam.memoLabel=Note to the administrator who investigates this report (optional)\n\nxe.invitation.doAction.accept.heading=Accept invitation\nxe.invitation.doAction.accept.saveComment=Invitation accepted.\nxe.invitation.doAction.accept.noMessageFound=No message was found by the given ID. It might have been deleted or maybe the system is experiencing difficulties.\nxe.invitation.doAction.accept.invitationCanceled=We're sorry but this invitation has been rescinded.\nxe.invitation.doAction.accept.alreadyReportedAsSpam=This invitation has been reported as spam and is no longer valid.\nxe.invitation.doAction.accept.alreadyDeclined=This invitation has been declined and cannot be accepted now.\nxe.invitation.doAction.accept.alreadyAccepted=This invitation has already been accepted and the offer is no longer valid.\nxe.invitation.doAction.accept.improperConfiguration=This invitation cannot be accepted because the wiki is not configured to allow new users.\n\nxe.invitation.doAction.decline.heading=Decline invitation\nxe.invitation.doAction.decline.memoLabel=Message to {0} (optional)\nxe.invitation.doAction.decline.confirmLabel=Decline invitation\nxe.invitation.doAction.decline.saveComment=Invitation Declined\nxe.invitation.doAction.decline.alreadyReportedAsSpam=This invitation has already been reported as spam and thus cannot be declined.\nxe.invitation.doAction.decline.invitationCanceled=This invitation has been rescinded and thus cannot be declined.\nxe.invitation.doAction.decline.alreadyDeclined=This invitation has already been declined and cannot be declined again.\nxe.invitation.doAction.decline.alreadyAccepted=This invitation has already been accepted and now cannot be declined.\nxe.invitation.doAction.decline.noMessageFound=No invitation was found by the given ID. It might have been deleted or maybe the system is experiencing difficulties.\nxe.invitation.doAction.decline.success=This invitation has successfully been declined.\n\nxe.invitation.doUserActionOnMultipleMessages.notPossibleOnMultipleMessages=This action is not possible on multiple messages.\nxe.invitation.doUserActionOnMultipleMessages.confirmLabel=Confirm\nxe.invitation.doUserActionOnMultipleMessages.noMessagesFound=No messages were found for the provided IDs.\nxe.invitation.doUserActionOnMultipleMessages.noMessagesAffected=This action cannot be carried out because all of the messages selected are of the wrong status.\n\nxe.invitation.doUserActionOnMultipleMessages.notSpam.successMessage=Invitation successfully marked as not spam. Log entry: {0}\nxe.invitation.doUserActionOnMultipleMessages.notSpam.heading=Mark message as not spam or situation handled.\nxe.invitation.doUserActionOnMultipleMessages.notSpam.memoLabel=Synopsis of findings and/or action taken\nxe.invitation.doUserActionOnMultipleMessages.notSpam.confirmLabel=Return email privilege\nxe.invitation.doUserActionOnMultipleMessages.notSpam.reportHandledSaveComment={0} investigated spam report.\n\nxe.invitation.doUserActionOnMultipleMessages.cancel.heading=Rescind invitations\nxe.invitation.doUserActionOnMultipleMessages.cancel.saveComment={0} invitations were rescinded by {1}\nxe.invitation.doUserActionOnMultipleMessages.cancel.success=Invitation successfully rescinded.\nxe.invitation.doUserActionOnMultipleMessages.cancel.memoLabel=Leave a message in case the invitee(s) try to register.\nxe.invitation.doUserActionOnMultipleMessages.cancel.someMessagesNotFound={0} of the {1} invitations to rescind could not be found.\nxe.invitation.doUserActionOnMultipleMessages.cancel.areYouSure.OneMessage=Are you sure you want to rescind this invitation?\nxe.invitation.doUserActionOnMultipleMessages.cancel.areYouSure.OneMessagePerGroup=Are you sure you want to rescind these {0} invitations?\nxe.invitation.doUserActionOnMultipleMessages.cancel.areYouSure.multipleMessagesMultipleGroups=Are you sure you want to rescind these {0} invitations to {1} recipients?\n\nxe.invitation.displayMessage.anAddressesIsInvalid=One of the given email addresses is invalid and will not receive a message.\nxe.invitation.displayMessage.someAddressesAreInvalid={0} of the given email addresses are invalid and will not receive a message.\nxe.invitation.displayMessage.theAddressIsInvalid=The email address given is invalid and will not receive a message.\nxe.invitation.displayForm.sendMail=Send Mail\nxe.invitation.displayForm.backToEdit=Back To Edit\nxe.invitation.displayForm.preview=Preview\n\nxe.invitation.tools.heading=Tools\nxe.invitation.tools.myInvitationsLink=My Invitations\nxe.invitation.tools.invitationsInGroup=Invitations in this Message Group\nxe.invitation.tools.invitationHistory=History of this Invitation\nxe.invitation.tools.senderLink=Send Invitations\n\nxe.invitation.adminTools.heading=Administrative Tools\nxe.invitation.adminTools.configureLink=Configure the Invitation Application\nxe.invitation.adminTools.allInvitationsLink=All Invitations\n\nxe.invitation.configuration.smtpHeading=SMTP Settings\n\nxe.invitation.setMessageStatus=Message status set to {0} by user {1}. Log: {2}\nxe.invitation.displayMessageHistory.messageStatusSetTo=Message status set to\nxe.invitation.displayMessageHistory.setByUser=By user\nxe.invitation.displayMessageHistory.logEntry=Log Entry\nxe.invitation.inspectMessages.lastEntryInfoBox={0} with message: {1}\n\nxe.invitation.messageStatus.unsent=Unsent\nxe.invitation.messageStatus.pending=Pending\nxe.invitation.messageStatus.accepted=Accepted\nxe.invitation.messageStatus.declined=Declined\nxe.invitation.messageStatus.canceled=Rescinded\nxe.invitation.messageStatus.reported=Reported as spam\nxe.invitation.messageStatus.investigated=Spam report investigated\nxe.invitation.messageStatus.unknown=Unknown status ({0})\nxe.invitation.messageStatus.sendingFailed=Failed to send message\n\n### Office importer application\nxe.officeimporter.notallowed=Guests are not allowed to view the contents of this page.\nxe.officeimporter.error.normaluser=This application requires an active Office Server which we could not locate. Please contact your administrator to resolve this issue.\nxe.officeimporter.error.adminuser=You need to setup an Office Server to make the Office Importer application available to your users. Please look at the Office Importer {0}documentation{1} for instructions on how to setup and configure an Office Server.\nxe.officeimporter.import.title=Office Importer\nxe.officeimporter.import.document=Office document\nxe.officeimporter.import.target=Target page\nxe.officeimporter.import.filterstyles=Filter styles\nxe.officeimporter.import.help.styles=Strip out unnecessary styling information from the result.\nxe.officeimporter.import.splitting.splitdocument=Split document\nxe.officeimporter.import.help.splitting=Create multiple pages from a single office document.\nxe.officeimporter.import.splitting.headinglevels=Heading levels to split\nxe.officeimporter.import.splitting.heading=Heading\nxe.officeimporter.import.splitting.naming=Child pages naming\nxe.officeimporter.import.splitting.naming.headingnames=Heading names\nxe.officeimporter.import.splitting.naming.mainpagenameandheading=Main page name and heading\nxe.officeimporter.import.splitting.naming.mainpagenameandnumbering=Main page name and numbering\nxe.officeimporter.import.import=Import\nxe.officeimporter.results.title=Office Importer Results\nxe.officeimporter.results.goback=Go back\nxe.officeimporter.results.missingfile=Missing input file. Please {0} and correct it.\nxe.officeimporter.results.result=result\nxe.officeimporter.results.success=Conversion succeeded. You can view the {0}, or you can {1} to convert another document.\nxe.officeimporter.openoffice.parameter=Parameter\nxe.officeimporter.openoffice.value=Value\nxe.officeimporter.openoffice.yes=Yes\nxe.officeimporter.openoffice.no=No\nxe.officeimporter.openoffice.servertype=Server type\nxe.officeimporter.openoffice.servertype.internal=Internally managed (local)\nxe.officeimporter.openoffice.servertype.external=Externally managed (local)\nxe.officeimporter.openoffice.servertype.remote=Externally managed (remote)\nxe.officeimporter.openoffice.serverport=Server port\nxe.officeimporter.openoffice.autostart=Auto start\nxe.officeimporter.openoffice.autoconnect=Auto connect\nxe.officeimporter.openoffice.serverpath=Server path\nxe.officeimporter.openoffice.serverprofile=Server profile\nxe.officeimporter.openoffice.serverprofile.default=Default profile\nxe.officeimporter.openoffice.serverstate=Server state\nxe.officeimporter.openoffice.actions=Actions\nxe.officeimporter.openoffice.actions.start=Start server (connect)\nxe.officeimporter.openoffice.actions.connect=Connect\nxe.officeimporter.openoffice.actions.stop=Stop server (disconnect)\nxe.officeimporter.openoffice.actions.disconnect=Disconnect\nxe.officeimporter.openoffice.actions.restart=Restart server\nxe.officeimporter.openoffice.update=Update\nxe.officeimporter.openoffice.limitedcontrol=The Office Server can only be controlled from the main wiki.\noffice.configuration.serverpath.error.notSetNotAutodetected=Not set / Not autodetected\n\n### Panels application\nxe.panels.classedit.youare=You are editing\nxe.panels.classedit.chooseproperty=Choose a property to edit or add a property to the class.\nxe.panels.classedit.editother=Edit another class\nxe.panels.classedit.unsavedchanges=Unsaved changes will be lost when switching to another class.\nxe.panels.switchclass=Switch class\nxe.panels.create.panel=Create new panel:\nxe.panels.create.title=Panel Title\nxe.panels.rights.welcomeglobal=Welcome to the global rights editor.\nxe.panels.rights.space=Rights applied to a space replace rights applied to the whole wiki.\nxe.panels.rights.warning=Warning:\nxe.panels.rights.noauthentication=Without any authentication forcing and any rights specified a Wiki is public for viewing and editing by default.\nxe.panels.document.information=XWiki page information\nxe.panels.includedDocs.title=Included pages\nxe.panels.includedDocs.count={0,choice,0#No|1#One|1<{0}} included {0,choice,0#pages.|1#page:|1<pages:}\nxe.panels.last.members=Last Members\nxe.panels.members.name=Name\nxe.panels.members.photo=Photo\nxe.panels.members.viewall=View All\nxe.panels.modifications.my=My Recent Modifications\nxe.panels.navigation=Navigation\nxe.panels.new.itemType=Type of the item\nxe.panels.new.page=New Page (current space)\nxe.panels.new.space=New Space\nxe.panels.new.name=Name\nxe.panels.orphaned=Orphaned Pages\nxe.panels.wizard.savenew=Save\nxe.panels.wizard.revert=Reset\nxe.panels.wizard.homepage=Go to Panels\nxe.panels.edit=(Edit this panel)\nxe.panels.quicklinks=Quick Links\nxe.panels.quicklinks.dashboard=Dashboard\nxe.panels.quicklinks.index=Page Index\nxe.panels.quicklinks.sandbox=Sandbox\nxe.panels.quicklinks.userdirectory=User Index\nxe.panels.rights.welcome=Welcome to the rights editor.\nxe.panels.rights.explanation=Rights applied to a page replace rights applied to a space and rights applied to the whole wiki.\nxe.panels.rights.help=Rights editor help\nxe.panels.rights.users=Users\nxe.panels.rights.usersexplanation=This field should contain the wikiname of each user you want to apply the rights to. For example <em>XWiki.JohnDoe</em>. <em>XWiki.XWikiGuest</em> should be used for unidentified users.\nxe.panels.rights.groups=Groups\nxe.panels.rights.groupsexplanation=This field should contain the wikinames of groups you want to apply the rights to. <em>XWiki.XWikiAllGroup</em> represents the group of all logged-in users with an account on your Wiki.\nxe.panels.rights.groupsvirtualexplanation=<em>xwiki:XWiki.XWikiAllGroup</em> represents the group of all logged-in users using a global account.\nxe.panels.rights.accesslevels=Access levels\nxe.panels.rights.accesslevelsexplanation=This field should contain a list of access levels that you want to apply to the users and groups specified. Available access levels are: admin, programming, register, edit, view and comment. To protect your wiki in view and edit mode use \"view, edit\". To protect adding comments use \"comment\".\nxe.panels.rights.allowdeny=Allow/Deny\nxe.panels.rights.allowdenyexplanation=This field should contain <em>Allow</em> to specify that this is an allow right, and <em>Deny</em> to specify a deny right. An <em>allow</em> right means: \"this wiki, space or page is *only* visible or editable to the users or groups specified\".\nxe.panels.rights.openwiki=To open a Wiki for editing by the public:\nxe.panels.rights.opengroups=Groups: XWiki.XWikiAllGroup, xwiki:XWiki.XWikiAllGroup\nxe.panels.rights.openusers=Users: XWiki.XWikiGuest\nxe.panels.rights.openaccess=Access Levels: \"view, edit\" for a public Wiki for viewing and editing.\nxe.panels.rights.openallow=Allow/Deny: Allow\nxe.panels.rights.protectedwiki=To protect a Wiki or Space by allowing only logged-in users using an account created on your Wiki use:\nxe.panels.rights.protectedgroups=Groups: XWiki.XWikiAllGroup\nxe.panels.rights.protectedusers=Users:\nxe.panels.rights.protectedaccess=Access Levels: \"edit\" for a private wiki for editing, \"view, edit\" for a private Wiki for viewing and editing.\nxe.panels.rights.protectedallow=Allow/Deny: Allow\nxe.panels.rights.bannedgroup=To protect a Wiki or Space by disallowing banned users to edit pages use:\nxe.panels.rights.banedgroups=Groups: XWiki.XWikiBannedGroup\nxe.panels.rights.bannedusers=Users:\nxe.panels.rights.bannedaccess=Access Levels: \"edit\"\nxe.panels.rights.banneddeny=Allow/Deny: Deny\nxe.panels.rights.tips=Rights editor tips\nxe.panels.rights.publicwiki=Public wiki\nxe.panels.rights.authenticate=Authenticate on view/edit\nxe.panels.rights.banned=Banned users\nxe.panels.tagcloud.title=Tag Cloud\nxe.panels.shortcuts=Shortcuts\nxe.panels.spaces=Spaces\nxe.panels.syntax.help=XWiki Syntax Help\nxe.panels=Panels\nxe.panels.create=Create a new panel\nxe.panels.customize=You can customize the side column(s) using the\nxe.panels.welcome.xwiki=Welcome to this XWiki!\n\n### Scheduler application\nxe.scheduler.jobscheduled=Job {0} scheduled. Next fire time: {1}\nxe.scheduler.paused=Job {0} paused\nxe.scheduler.resumed=Job {0} resumed. Next fire time: {1}\nxe.scheduler.unscheduled=Job {0} unscheduled\nxe.scheduler.triggered=Job {0} triggered\nxe.scheduler=Job Scheduler\nxe.scheduler.welcome=Welcome to the Job Scheduler. This application allows you to create administration scripts that can be triggered periodically.\nxe.scheduler.jobs.list=List of existing jobs\nxe.scheduler.jobs.actions=Actions\nxe.scheduler.jobs.actions.access=Access:\nxe.scheduler.jobs.actions.view=View\nxe.scheduler.jobs.actions.edit=Edit\nxe.scheduler.jobs.actions.manage=Manage:\nxe.scheduler.jobs.actions.schedule=Schedule\nxe.scheduler.jobs.actions.pause=Pause\nxe.scheduler.jobs.actions.unschedule=Unschedule\nxe.scheduler.jobs.actions.resume=Resume\nxe.scheduler.jobs.actions.delete=Delete\nxe.scheduler.jobs.actions.trigger=Trigger\nxe.scheduler.jobs.next=Next Fire Time\nxe.scheduler.jobs.next.undefined=N/A\nxe.scheduler.jobs.status=Job Status\nxe.scheduler.jobs.name=Job Name\nxe.scheduler.job=Job\nxe.scheduler.jobs.create=Create a new job\nxe.scheduler.jobs.create.nameTip=Job name\nxe.scheduler.jobs.create.submit=Add\nxe.scheduler.jobs.explaincreate=Enter below the name of the page that will hold your job. The job will be created in the current Scheduler space.\nxe.scheduler.jobs.warning=Job creation is reserved for programmers and you don't have programming rights for the Scheduler space.\nxe.scheduler.jobs.pagename=Job page name\nxe.scheduler.job.scriptexplanation=The script is the code that will be executed when the job is triggered by the scheduler. It should be written in the Groovy language. The XWiki API is available through the **xwiki** and **context** pre-defined variables.\nxe.scheduler.job.backtolist=Back to the job list\nxe.scheduler.job.object=This sheet must be applied to a page that holds a scheduler job object.\nxe.scheduler.updateJobClassComment=Created/Updated Scheduler Job Class definition\n\n### Statistics application\nxe.statistics.activity=Activity Statistics\nxe.statistics.edits=Edits\nxe.statistics.views=Views\nxe.statistics.current.week=Current week activity\nxe.statistics.current.week.caps=Current Week Activity\nxe.statistics.current.month=Current month activity\nxe.statistics.current.month.caps=Current Month Activity\nxe.statistics.current.year=Current year activity\nxe.statistics.current.year.caps=Current Year Activity\nxe.statistics.alltime=All time activity\nxe.statistics.alltime.caps=All Time Activity\nxe.statistics.bestreferrers=Best Referrers\nxe.statistics.document=Page Statistics\nxe.statistics.contributors.leastactive=Least Active Contributors\nxe.statistics.homepage=statistics home page\nxe.statistics.disabled=The statistics module is disabled by default for improved performances. For more details, see {0}\nxe.statistics.notrecorded=No statistics recorded\nxe.statistics.referrer=Referrer\nxe.statistics.sources=Sources\nxe.statistics.user=User\nxe.statistics.changes=Changes\nxe.statistics.space=Space\nxe.statistics.hits=Hits\nxe.statistics.page=Page\nxe.statistics.contributors.mostactive=Most Active Contributors\nxe.statistics.pages.mostedited=Most Edited Pages\nxe.statistics.spaces.mostedited=Most Edited Spaces\nxe.statistics.pages.mostreferred=Most Referred Pages\nxe.statistics.pages.mostviewed=Most Viewed Pages\nxe.statistics.spaces.mostviewed=Most Viewed Spaces\nxe.statistics.referrerstats=Referrer Statistics\nxe.statistics.visit=Visit Statistics\nxe.statistics=Statistics\nxe.statistics.more=For more statistics, please give a look at:\nxe.statistics.module.disabled=The statistics module is disabled by default for improved performances.\nxe.statistics.to=to\nxe.statistics.module.settingvalue=It can be globally activated by setting the value of\nxe.statistics.inthe=in the\nxe.statistics.moredetails=configuration file. For more details, see\nxe.statistics.module.activating=Activating the statistics module makes the following information available to you:\nxe.statistics.module.muchmore=and much more!\n\n### Webdav application\nxe.webdav.initialize.activex=Could not initialize a required ActiveX object.\nxe.webdav.initialize.error=Error while initializing the share point editor.\nxe.webdav.install.foxwiki=A Firefox extension is required to perform this action, install it?\nxe.webdav.error=Ooops! Something went wrong... Please try again.\nxe.webdav.sorry=Sorry, to use this feature you need either Firefox or Internet Explorer.\nxe.webdav.info=This is a hosting page for webdav related functions.\n\n####################\n# Index Module\n####################\n\nplatform.index.documents=Pages on this Wiki\nplatform.index=Index\nplatform.index.tree=Tree\nplatform.index.orphaned=Orphaned Pages\nplatform.index.orphanedResults=Orphaned Pages JSON Service\nplatform.index.attachments=Attachments\nplatform.index.attachmentsResults=Attachments JSON Service\n\n### Livetable Column Labels (translationPrefix == \"platform.index.\")\nplatform.index.doc.name=Page\nplatform.index.doc.location=Location\nplatform.index.doc.space=Space\nplatform.index.doc.date=Date\nplatform.index.doc.author=Last Author\nplatform.index.doc.title=Title\nplatform.index.doc.fullName=Page\nplatform.index.doc.objectCount=Object Count\nplatform.index._actions=Actions\nplatform.index.emptyvalue=\nplatform.index._likes=Likes\n\n### Livetable Column Labels (translationPrefix == \"platform.index.attachments.\")\nplatform.index.attachments.filename=Name\nplatform.index.attachments.doc.fullName=Location\nplatform.index.attachments.date=Date\nplatform.index.attachments.author=Author\nplatform.index.attachments.mimeType=Type\nplatform.index.attachments.filesize=Size\nplatform.index.attachments.emptyvalue=\n\nplatform.index.documentsTrash=Deleted Pages\nplatform.index.trashDocumentsEmpty=No deleted pages\n\n### Livetable Column Labels (translationPrefix == \"platform.index.trashDocuments.\")\nplatform.index.trashDocuments.ddoc.fullName=Page\nplatform.index.trashDocuments.ddoc.title=Title\nplatform.index.trashDocuments.ddoc.date=Deleted on\nplatform.index.trashDocuments.ddoc.deleter=Deleted by\nplatform.index.trashDocuments.ddoc.batchId=Deleted Batch ID\nplatform.index.trashDocuments.actions=Actions\n\nplatform.index.trashDocumentsActionsRestoreTooltip=Restore page\nplatform.index.trashDocumentsActionsRestoreText=restore\nplatform.index.trashDocumentsActionsReplaceTooltip=Replace the page that has been created at the original location\nplatform.index.trashDocumentsActionsReplaceText=replace\nplatform.index.trashDocumentsActionsCannotRestoreTooltip=The page cannot be restored to its original location because it has been recreated.\nplatform.index.trashDocumentsActionsCannotRestoreText=cannot restore\nplatform.index.trashDocumentsActionsCannotRestoreCausesOrphanedTranslationTooltip=The translation can not be restored to its original location before its original page is restored or re-created.\nplatform.index.trashDocumentsActionsDeleteTooltip=Permanently delete page\nplatform.index.trashDocumentsActionsDeleteText=delete\nplatform.index.trashDocumentsDeleteInProgress=Permanently deleting page...\nplatform.index.trashDocumentsDeleteDone=Page permanently deleted\nplatform.index.trashDocumentsDeleteFailed=Failed to delete:\nplatform.index.trashDocumentsDeleteInformation=Deleted by {0} on {1}\nplatform.index.trashDocumentsReplacePageFailed=Failed to replace\nplatform.index.trashDocumentsReplacePageText=The deleted page was recreated, possibly for adding a redirect to another document. Are you sure you want to replace it with the old page?\nplatform.index.trashDocumentsReplacePageTitle=Replace existing page\n\nplatform.index.attachmentsTrash=Deleted Attachments\nplatform.index.trashAttachmentsEmpty=No deleted attachments\n\n### Livetable Column Labels (translationPrefix == \"platform.index.trashAttachments.\")\nplatform.index.trashAttachments.datt.filename=Attachment\nplatform.index.trashAttachments.datt.docName=Page\nplatform.index.trashAttachments.datt.date=Deleted on\nplatform.index.trashAttachments.datt.deleter=Deleted by\nplatform.index.trashAttachments.actions=Actions\n\nplatform.index.trashAttachmentsActionsRestoreTooltip=Restore attachment\nplatform.index.trashAttachmentsActionsRestoreText=[restore]\nplatform.index.trashAttachmentsActionsCannotRestoreTooltip=The attachment cannot be restored to its original location because another file with the same name has been attached.\nplatform.index.trashAttachmentsActionsCannotRestoreText=[cannot restore]\nplatform.index.trashAttachmentsActionsDeleteTooltip=Permanently delete attachment\nplatform.index.trashAttachmentsActionsDeleteText=[delete]\nplatform.index.trashAttachmentsDeleteInProgress=Permanently deleting attachment...\nplatform.index.trashAttachmentsDeleteDone=Attachment permanently deleted\nplatform.index.trashAttachmentsDeleteFailed=Failed to delete:\n\n### Space Index Page\nplatform.index.spaceIndex=Space Index\nplatform.index.spaceIndexDescription=Pages in the {0} space:\nplatform.index.spaceIndexDocumentListCreate=Create a new page\n\n####################\n# Livetable Module\n####################\n\nplatform.livetable.results=Livetable Results\nplatform.livetable.resultsMacros=Livetable Results Macros\nplatform.livetable._actions.delete=delete\nplatform.livetable._actions.rename=rename\nplatform.livetable._actions.rights=rights\nplatform.livetable._actions.copy=copy\nplatform.livetable._actions.edit=edit\nplatform.livetable.asyncActionInProgress=In progress...\nplatform.livetable.asyncActionDone=Done\nplatform.livetable.asyncActionFailed=Failed\nplatform.livetable.filtersTitle=Filter for the {0} column\nplatform.livetable.loading=Loading...\nplatform.livetable.tagsHelp=Click on one or more tags to filter the list\nplatform.livetable.tagsHelpCancel=and click again on a tag to cancel the filter\nplatform.livetable.environmentCannotLoadTableMessage=The environment prevents the table from loading data.\nplatform.livetable.docTitleComputedHint=Some pages have a computed title. Filtering and sorting by title will not work as expected for these pages.\nplatform.livetable.docNotViewable=N/A\nplatform.livetable.pagesizeLabel=per page of\nplatform.livetable.selectAll=All\nplatform.livetable.paginationPage=Page\nplatform.livetable.paginationPageTitle=Go to page {0}\nplatform.livetable.paginationPagePrevious=&#171; previous page\nplatform.livetable.paginationPagePrevTitle=Previous Page\nplatform.livetable.paginationPageNext=next page &#187;\nplatform.livetable.paginationPageNextTitle=Next Page\nplatform.livetable.paginationResultsNone=No results\nplatform.livetable.paginationResultsOne=One result\nplatform.livetable.paginationResultsSingle=Result <span class=\"currentResultsNo\">{0}</span> of <span class=\"totalResultsNo\">{1}</span>\nplatform.livetable.paginationResultsMany=Results <span class=\"currentResultsNo\">{0} - {1}</span> of <span class=\"totalResultsNo\">{2}</span>\nplatform.livetable.paginationResults=Results\nplatform.livetable.paginationResultsOf=out of\n\n####################\n# Daterange picker\n####################\n\ndaterange.apply=Apply\ndaterange.clear=Clear\ndaterange.customRange=Custom Range\ndaterange.from=From\ndaterange.to=To\ndaterange.today=Today\ndaterange.yesterday=Yesterday\ndaterange.lastSevenDays=Last 7 Days\ndaterange.lastThirtyDays=Last 30 Days\ndaterange.thisMonth=This Month\ndaterange.lastMonth=Last Month\n\n####################\n# XWiki Enterprise Module\n####################\n\nxe.document.copy=Copy a page\nxe.document.copying=Copying page {0} to {1}\nxe.document.copy.source=Source Page:\nxe.document.copy.target=Target Page:\nxe.document.copy.language=Language:\nxe.document.copy.do=Copy\n\n### Color themes\nxe.themes.current=Current theme\nxe.themes.others=Other available themes\nxe.themes.useTheme=Use this theme\nxe.themes.themeSet=Color theme set to {0}.\nxe.themes.create=Create new theme\nxe.themes.create.nameLabel=Theme name:\nxe.themes.create.nameTip=Theme name...\n### Page titles\nxe.themes.colors.title=Color Themes\nxe.themes.colors.sheet.title=Sheet for color themes\nxe.themes.colors.class.title=Class for defining skin color themes\nxe.themes.colors.template.title=Template page for skin color themes\nxe.themes.colors.mapping.title=Color theme wizard property mapping\nxe.themes.colors.webColors.title=Default color palette for the scriptless wizard\n### Wizard\nxe.themes.colors.wizard.choose=Choose\nxe.themes.colors.wizard.mainMenu=Main Menu\nxe.themes.colors.wizard.logo=Wiki Logo\nxe.themes.colors.wizard.panel=Panel\nxe.themes.colors.wizard.panel.text=Panel Text\nxe.themes.colors.wizard.panel.link=Panel Link\nxe.themes.colors.wizard.panel.collapsed=Collapsed Panel\nxe.themes.colors.wizard.menu=Content Menu\nxe.themes.colors.wizard.menuEntry=entry\nxe.themes.colors.wizard.title=Title\nxe.themes.colors.wizard.informativeText=Informative Text\nxe.themes.colors.wizard.detailsText=Details Text\nxe.themes.colors.wizard.text=Content Text\nxe.themes.colors.wizard.link=Content Link\nxe.themes.colors.wizard.highlightedText=Highlighted Text\nxe.themes.colors.wizard.messageBox=Message Box\nxe.themes.colors.wizard.table=Table\nxe.themes.colors.wizard.table.data=data\nxe.themes.colors.wizard.button=Button\nxe.themes.colors.wizard.secondaryButton=Secondary action button\nxe.themes.colors.wizard.tab=tab\nxe.themes.colors.wizard.tab.text=Text\nxe.themes.colors.wizard.reset=Reset\nxe.themes.colors.wizard.close=Close\nxe.themes.colors.wizard.undo=Undo\n\nxe.xwiki.administration=Administration application\nxe.xwiki.administration.install=This page and its children contain internal content used by XWiki for its own use. It also currently contains the User Profile pages. You can administer your wiki through the {0}.\n\n### Monitor\nxe.monitor=XWiki Requests Status\nxe.monitor.url=URL:\nxe.monitor.startdate=StartDate:\nxe.monitor.state=State:\nxe.monitor.alive=Alive:\nxe.monitor.interrupt=Interrupting\nxe.monitor.consolidateddata=Consolidated Data\nxe.monitor.duration=Duration:\nxe.monitor.requests=Requests:\nxe.monitor.duration.small=duration:\nxe.monitor.calls=Calls:\nxe.monitor.average=Average:\nxe.monitor.ms=ms\nxe.monitor.requests.active=Active requests\nxe.monitor.requests.currentlyrunning=Currently running requests. There is always at least the request for this page.\nxe.monitor.requests.size=Active requests size:\nxe.monitor.requests.page=Page:\nxe.monitor.thread=Thread:\nxe.monitor.requests.unfinished=Latest unfinished requests\nxe.monitor.requests.unfinished.description=These are requests that didn't reach \"endRequest\", but where cleaned-up by a reuse of threads. Maximum 32 requests are kept in memory.\nxe.monitor.requests.active.size=Active requests size:\nxe.monitor.requests.latest=Latest requests\nxe.monitor.requests.latest.description=Latest requests that finished properly. Only {0} requests max are kept in memory.\nxe.monitor.enddate=EndDate:\nxe.monitor.requests.number=Number of requests displayed:\nxe.monitor.disabled=The Monitor plugin is disabled. Please enable it by setting <tt>xwiki.monitor=1</tt> in your <tt>xwiki.cfg</tt> configuration file.\n\nxe.templateprovider.name=Provider Name\nxe.templateprovider.name.example=Example: My Template Provider\nxe.templateprovider.templatename=Template Name\nxe.templateprovider.templatename.example=Example: My Template\nxe.templateprovider.templatename.info=You can fill in a translation key to allow internationalization of this template name.\nxe.templateprovider.template=Template to use\nxe.templateprovider.template.edit=Edit\nxe.templateprovider.template.example=Example: XWiki.MyTemplate\nxe.templateprovider.spaces=List of locations where the template must be available\nxe.templateprovider.spaces.all=The template is available from any location\nxe.templateprovider.spaces.info=If no location is selected, the template will be available from any location\nxe.templateprovider.backtoadmin=See all templates\nxe.templateprovider.action=Action on create\nxe.templateprovider.action.info=The action to execute when the create button is pushed, you can configure here whether the new page is saved before it is opened for edition or not.\nxe.templateprovider.terminal=Terminal Page\nxe.templateprovider.terminal.hint=Whether or not to create terminal documents by default when using this template provider.\n\nxe.welcome.edit=Edit welcome message\n\nXWiki.TemplateProviderClass_type_page=Page\nXWiki.TemplateProviderClass_type_space=Space homepage\nXWiki.TemplateProviderClass_action_edit=Edit\nXWiki.TemplateProviderClass_action_saveandedit=Save and Edit\nXWiki.TemplateProviderClass_action_saveandview=Save and View\n\nadmin.templates=Page Templates\nadmin.templates.description=Settings for the creation of page templates.\nadmin.templates.providerslist=Available Template Providers\nadmin.templates.createprovider=Create a Template Provider\nadmin.templates.createprovider.space=Space:\nadmin.templates.createprovider.page=Page:\nadmin.templates.createprovider.defaultdocname=MyTemplateProvider\nadmin.templates.createprovider.create=Create\n\n####################\n# XWiki Classes\n####################\n\n### Blog.BlogClass (blog application)\nBlog.BlogClass_title=Blog title\nBlog.BlogClass_description=Description\nBlog.BlogClass_displayType=Index display\nBlog.BlogClass_itemsPerPage=Items per page (only in the Paginated display mode)\nBlog.BlogClass_blogType=Blog type\nBlog.BlogClass_blogType_local=Space blog (aggregates posts from its space only)\nBlog.BlogClass_blogType_global=Global blog (aggregates posts from the entire wiki)\nBlog.BlogPostClass_displayType_paginated=Paginated\nBlog.BlogPostClass_displayType_weekly=Group posts weekly\nBlog.BlogPostClass_displayType_monthly=Group posts monthly\nBlog.BlogPostClass_displayType_all=Show all posts\nBlog.BlogPostClass_title=Title\nBlog.BlogPostClass_content=Content\nBlog.BlogPostClass_extract=Extract\nBlog.BlogPostClass_category=Category\nBlog.BlogPostClass_hidden=Is hidden\nBlog.BlogPostClass_published=Is published\nBlog.BlogPostClass_publishDate=Publish date\nBlog.CategoryClass_name=Name\nBlog.CategoryClass_description=Description\n\n### Panels.PanelClass (panel application)\nPanels.PanelClass_name=Name\nPanels.PanelClass_type=Panel type\nPanels.PanelClass_description=Description\nPanels.PanelClass_content=Content\nPanels.PanelClass_category=Category\nPanels.PanelClass_async_enabled=Asynchronous rendering\nPanels.PanelClass_async_cached=Cached\nPanels.PanelClass_async_context=Context elements\n\n### XWiki.AggregatorURLClass (watch application)\nXWiki.AggregatorURLClass_name=Name\nXWiki.AggregatorURLClass_url=URL\nXWiki.AggregatorURLClass_imgurl=Image URL\nXWiki.AggregatorURLClass_date=date\nXWiki.AggregatorURLClass_nb=nb\n\n### XWiki.FeedEntryClass (watch application)\nXWiki.FeedEntryClass_title=Title\nXWiki.FeedEntryClass_author=Author\nXWiki.FeedEntryClass_feedurl=Feed URL\nXWiki.FeedEntryClass_feedname=Feed Name\nXWiki.FeedEntryClass_url=URL\nXWiki.FeedEntryClass_category=Category\nXWiki.FeedEntryClass_content=Content\nXWiki.FeedEntryClass_fullContent=Full Content\nXWiki.FeedEntryClass_xml=XML\nXWiki.FeedEntryClass_date=Date\nXWiki.FeedEntryClass_flag=Flag\nXWiki.FeedEntryClass_read=Read\nXWiki.FeedEntryClass_tags=Tags\n\n### XWiki.JavaScriptExtension (skinx plugin)\nXWiki.JavaScriptExtension_name=Name\nXWiki.JavaScriptExtension_code=Code\nXWiki.JavaScriptExtension_use=Use this extension\nXWiki.JavaScriptExtension_parse=Parse content\nXWiki.JavaScriptExtension_cache=Caching policy\n\n### XWiki.MessageStreamConfig (XE)\nXWiki.MessageStreamConfig_active=Enable the message stream\nXWiki.MessageStreamConfig_active.hint=Whether the message stream is active or not.\nXWiki.MessageStreamConfig_visibilityLevel_everyone=Everyone\nXWiki.MessageStreamConfig_visibilityLevel_followers=Followers\nXWiki.MessageStreamConfig_visibilityLevel_group=Group\nXWiki.MessageStreamConfig_visibilityLevel_user=User\n\n### XWiki.StyleSheetExtension (skinx plugin)\nXWiki.StyleSheetExtension_name=Name\nXWiki.StyleSheetExtension_code=Code\nXWiki.StyleSheetExtension_use=Use this extension\nXWiki.StyleSheetExtension_parse=Parse content\nXWiki.StyleSheetExtension_cache=Caching policy\n\n### XWiki.Mail (mailsender plugin)\nXWiki.Mail_subject=Subject\nXWiki.Mail_language=Language\nXWiki.Mail_text=Text\nXWiki.Mail_html=HTML\n\n### XWiki.ResetPasswordRequestClass (administration application)\nXWiki.ResetPasswordRequestClass_verification=Request verification string\n\n### XWiki.SchedulerJobClass (scheduler plugin)\nXWiki.SchedulerJobClass_jobName=Job Name\nXWiki.SchedulerJobClass_jobClass=Job Class\nXWiki.SchedulerJobClass_status=Status\nXWiki.SchedulerJobClass_cron=Cron Expression\nXWiki.SchedulerJobClass_script=Job Script\nXWiki.SchedulerJobClass_jobDescription=Job Description\n\n### XWiki.TagClass (core)\nXWiki.TagClass_tags=Tags\n\n### XWiki.WatchListClass (watchlist plugin)\nXWiki.WatchListClass_interval=Email notifications interval\nXWiki.WatchListClass_spaces=Space list, comma separated\nXWiki.WatchListClass_documents=Page list, comma separated\nXWiki.WatchListClass_query=Query (HQL)\nXWiki.WatchListClass_automaticwatch=Automatic page watching\nXWiki.WatchListClass_automaticwatch_default=Default\nXWiki.WatchListClass_automaticwatch_NONE=Disabled\nXWiki.WatchListClass_automaticwatch_ALL=Any modification\nXWiki.WatchListClass_automaticwatch_MAJOR=Major modifications\nXWiki.WatchListClass_automaticwatch_NEW=New pages\n\n### XWiki.XWikiComments (core)\nXWiki.XWikiComments_author=Author\nXWiki.XWikiComments_highlight=Highlighted Text\nXWiki.XWikiComments_date=Date\nXWiki.XWikiComments_comment=Comment\nXWiki.XWikiComments_replyto=Reply To\n\n### XWiki.XWikiGlobalRights (core)\nXWiki.XWikiGlobalRights_allow=Allow/Deny\nXWiki.XWikiGlobalRights_groups=Groups\nXWiki.XWikiGlobalRights_levels=Levels\nXWiki.XWikiGlobalRights_users=Users\n\n### XWiki.XWikiGroups (core)\nXWiki.XWikiGroups_member=Member\n\n### XWiki.XWikiPreferences (core)\nXWiki.XWikiPreferences_skin=Skin\nXWiki.XWikiPreferences_colorTheme=Color theme\nXWiki.XWikiPreferences_accessibility=Enable extra accessibility features\nXWiki.XWikiPreferences_authenticate_view=Authenticated View\nXWiki.XWikiPreferences_webcopyright=Copyright\nXWiki.XWikiPreferences_plugins=Plugins\nXWiki.XWikiPreferences_authenticate_edit=Authenticate On Edit\nXWiki.XWikiPreferences_meta=HTTP Meta Info\nXWiki.XWikiPreferences_title=Title\nXWiki.XWikiPreferences_version=Version\nXWiki.XWikiPreferences_validation_email_content=Validation email Content\nXWiki.XWikiPreferences_confirmation_email_content=Confirmation email Content\nXWiki.XWikiPreferences_stylesheet=Stylesheet\nXWiki.XWikiPreferences_stylesheets=Stylesheets\nXWiki.XWikiPreferences_multilingual=Multilingual\nXWiki.XWikiPreferences_default_language=Default Language\nXWiki.XWikiPreferences_editor=Default Editor\nXWiki.XWikiPreferences_core.defaultDocumentSyntax=Default page syntax\nXWiki.XWikiPreferences_use_email_verification=Use email Verification\nXWiki.XWikiPreferences_backlinks=Backlinks\nXWiki.XWikiPreferences_invitation_email_content=Invitation email content\nXWiki.XWikiPreferences_registration_anonymous=Anonymous\nXWiki.XWikiPreferences_registration_registered=Registered\nXWiki.XWikiPreferences_edit_anonymous=Anonymous\nXWiki.XWikiPreferences_edit_registered=Registered\nXWiki.XWikiPreferences_comment_anonymous=Anonymous\nXWiki.XWikiPreferences_comment_registered=Registered\nXWiki.XWikiPreferences_leftPanels=Panels displayed on the left\nXWiki.XWikiPreferences_leftPanels.hint=A comma separated list of panels to display on the left column. E.g.: Panels.Applications, Panels.Navigation\nXWiki.XWikiPreferences_rightPanels=Panels displayed on the right\nXWiki.XWikiPreferences_rightPanels.hint=A comma separated list of panels to display on the right column.\nXWiki.XWikiPreferences_showLeftPanels=Display the left panel column\nXWiki.XWikiPreferences_showRightPanels=Display the right panel column\nXWiki.XWikiPreferences_leftPanelsWidth=Width of the left panel column\nXWiki.XWikiPreferences_leftPanelsWidth.hint=Choose the size of the left panel column.\nXWiki.XWikiPreferences_rightPanelsWidth=Width of the right panel column\nXWiki.XWikiPreferences_rightPanelsWidth.hint=Choose the size of the right panel column.\nXWiki.XWikiPreferences_leftPanelsWidth_Small=Small\nXWiki.XWikiPreferences_leftPanelsWidth_Medium=Medium\nXWiki.XWikiPreferences_leftPanelsWidth_Large=Large\nXWiki.XWikiPreferences_rightPanelsWidth_Small=Small\nXWiki.XWikiPreferences_rightPanelsWidth_Medium=Medium\nXWiki.XWikiPreferences_rightPanelsWidth_Large=Large\nXWiki.XWikiPreferences_languages=Supported languages\nXWiki.XWikiPreferences_tags=Activate the tagging\nXWiki.XWikiPreferences_parent=Parent space\nXWiki.XWikiPreferences_documentBundles=Internationalization Document Bundles\nXWiki.XWikiPreferences_upload_maxsize=Maximum Upload Size\nXWiki.XWikiPreferences_xwiki.title.mandatory=Make page title field mandatory\nXWiki.XWikiPreferences_showannotations=Show page annotations\nXWiki.XWikiPreferences_showcomments=Show page comments\nXWiki.XWikiPreferences_showattachments=Show page attachments\nXWiki.XWikiPreferences_showhistory=Show page history\nXWiki.XWikiPreferences_showinformation=Show page information\nXWiki.XWikiPreferences_editcomment=Enable version summaries\nXWiki.XWikiPreferences_editcomment_mandatory=Make version summaries mandatory\nXWiki.XWikiPreferences_minoredit=Enable minor edits\nXWiki.XWikiPreferences_ldap=Ldap\nXWiki.XWikiPreferences_ldap.hint=Enable or not LDAP authentication for this wiki. If enabled and configured properly, a local user will be created whenever a LDAP user visit this wiki for the first time.\nXWiki.XWikiPreferences_ldap_server=Ldap server address\nXWiki.XWikiPreferences_ldap_port=Ldap server port\nXWiki.XWikiPreferences_ldap_bind_DN=Ldap login matching\nXWiki.XWikiPreferences_ldap_bind_DN.hint=LDAP login. Leave empty for anonymous access, otherwise specify full dn. {0} is replaced with the user name, {1} with the password.\nXWiki.XWikiPreferences_ldap_bind_pass=Ldap password matching\nXWiki.XWikiPreferences_ldap_bind_pass.hint=Ldap password matching. Use in combination with Ldap login matching.\nXWiki.XWikiPreferences_ldap_validate_password=Validate Ldap user/password\nXWiki.XWikiPreferences_ldap_user_group=Restrict to group\nXWiki.XWikiPreferences_ldap_user_group.hint=Only members of the following group will be verified in the directory. If you leave empty, all users that are found after searching starting from the base_DN will be verified.\nXWiki.XWikiPreferences_ldap_exclude_group=Ldap group to exclude\nXWiki.XWikiPreferences_ldap_exclude_group.hint=If not empty, the mentionned group will never be verified against in the directory.\nXWiki.XWikiPreferences_ldap_base_DN=Ldap base DN\nXWiki.XWikiPreferences_ldap_UID_attr=Ldap UID attribute name\nXWiki.XWikiPreferences_ldap_UID_attr.hint=Specifies the LDAP attribute containing the identifier to be used as the XWiki name. The default is \"cn\".\nXWiki.XWikiPreferences_ldap_fields_mapping=Ldap user fields mapping\nXWiki.XWikiPreferences_ldap_update_user=Update user from LDAP after login\nXWiki.XWikiPreferences_ldap_update_user.hint=If not, the mapped attributes from LDAP to XWiki will be updated only when the user is created when login for the first time.\nXWiki.XWikiPreferences_ldap_update_photo=Update user photo from LDAP\nXWiki.XWikiPreferences_ldap_update_photo.hint=If enabled xwiki avatar will be synchronized with LDAP\nXWiki.XWikiPreferences_ldap_photo_attachment_name=Attachment name used to save LDAP photo\nXWiki.XWikiPreferences_ldap_photo_attachment_name.hint=Filename of LDAP photo that will be used in xwiki profile\nXWiki.XWikiPreferences_ldap_photo_attribute=Ldap photo attribute name\nXWiki.XWikiPreferences_ldap_photo_attribute.hint=Specifies the LDAP attribute containing photo image\nXWiki.XWikiPreferences_ldap_group_mapping=Ldap groups mapping\nXWiki.XWikiPreferences_ldap_groupcache_expiration=LDAP groups cache expiration\nXWiki.XWikiPreferences_ldap_groupcache_expiration.hint=Time in seconds after which the list of members in a group is refreshed from LDAP. The default is 21600 (6 hours).\nXWiki.XWikiPreferences_ldap_mode_group_sync=When to synchronize LDAP groups\nXWiki.XWikiPreferences_ldap_mode_group_sync_always=At each authentication of a user\nXWiki.XWikiPreferences_ldap_mode_group_sync_create=Upon creation of a user\nXWiki.XWikiPreferences_ldap_trylocal=Try local login\nXWiki.XWikiPreferences_ldap_trylocal.hint=If LDAP authentication fails, try XWiki DB authentication with the same credentials. Default is Yes.\nXWiki.XWikiPreferences_dateformat=Date format\nXWiki.XWikiPreferences_guest_comment_requires_captcha=Enable CAPTCHA in comments for unregistered users\nXWiki.XWikiPreferences_timezone=Timezone\nXWiki.XWikiPreferences_timezone_default=System Default\n\n### XWiki.XWikiRights (core)\nXWiki.XWikiRights_allow=Allow/Deny\nXWiki.XWikiRights_groups=Groups\nXWiki.XWikiRights_levels=Levels\nXWiki.XWikiRights_users=Users\n\n### XWiki.XWikiUsers (core)\nXWiki.XWikiUsers_active=Active\nXWiki.XWikiUsers_password=Password\nXWiki.XWikiUsers_email=Email\nXWiki.XWikiUsers_comment=About\nXWiki.XWikiUsers_first_name=First Name\nXWiki.XWikiUsers_last_name=Last Name\nXWiki.XWikiUsers_fullname=Full Name\nXWiki.XWikiUsers_validkey=Validation Key\nXWiki.XWikiUsers_default_language=Default Language\nXWiki.XWikiUsers_company=Company\nXWiki.XWikiUsers_blog=Blog\nXWiki.XWikiUsers_blogfeed=Blog Feed\nXWiki.XWikiUsers_imtype=IM Type\nXWiki.XWikiUsers_imaccount=IM Account\nXWiki.XWikiUsers_city=City\nXWiki.XWikiUsers_country=Country\nXWiki.XWikiUsers_editor=Default Editor\nXWiki.XWikiUsers_skin=Skin\nXWiki.XWikiUsers_pageWidth=Preferred page width\nXWiki.XWikiUsers_avatar=Avatar\nXWiki.XWikiUsers_usertype=User Type\nXWiki.XWikiUsers_usertype_Simple=Simple\nXWiki.XWikiUsers_usertype_Advanced=Advanced\nXWiki.XWikiUsers_phone=Phone\nXWiki.XWikiUsers_address=Address\nXWiki.XWikiUsers_extensionConflictSetup=Enable extension conflict setup\n\n### XWiki.XWikiSkins (core)\nXWiki.XWikiSkins_name=Name\nXWiki.XWikiSkins_style.css=Style\nXWiki.XWikiSkins_header.vm=Header\nXWiki.XWikiSkins_footer.vm=Footer\nXWiki.XWikiSkins_view.vm=View\nXWiki.XWikiSkins_viewheader.vm=View Header\nXWiki.XWikiSkins_pagemenu.vm=Page Menu\nXWiki.XWikiSkins_comments2.vm=Comments\nXWiki.XWikiSkins_edit.vm=Edit\nXWiki.XWikiSkins_baseskin=Base Skin\nXWiki.XWikiSkins_logo=Logo\n\n### XWiki.Registration (administration application)\nXWiki.Registration_heading=Registration page heading\nXWiki.Registration_welcomeMessage=Welcome message\nXWiki.Registration_liveValidation_enabled=Enable Javascript field validation\nXWiki.Registration_liveValidation_defaultFieldOkMessage=Default field okay message\nXWiki.Registration_loginButton_enabled=Enable login button\nXWiki.Registration_loginButton_autoLogin_enabled=Enable automatic login\nXWiki.Registration_defaultRedirect=Redirect here after registration\nXWiki.Registration_requireCaptcha=Require CAPTCHA to register\nXWiki.Registration_registrationSuccessMessage=Registration Successful Message\n\n### XWiki.InvitationMail (Invitation Application) Email XObject\nInvitation.InvitationMailClass_messageID=Email message identifier\nInvitation.InvitationMailClass_messageGroupID=Message group identifier\nInvitation.InvitationMailClass_recipient=Email address which this message was sent to\nInvitation.InvitationMailClass_sendingUser=User who sent the message\nInvitation.InvitationMailClass_subjectLine=Subject line\nInvitation.InvitationMailClass_messageBody=Message content\nInvitation.InvitationMailClass_status=Number indicating the message status\nInvitation.InvitationMailClass_sentDate=Date message was sent\nInvitation.InvitationMailClass_memo=Memo attached to this message\nInvitation.InvitationMailClass_history=Activity history for this invitation\nInvitation.InvitationMailClass_messageBodyPlain=Plain message for non HTML email clients\n\n### XWiki.WebHome (Invitation application) Configuration\nInvitation.WebHome_from_address=Email \"from\" address\nInvitation.WebHome_smtp_server_password=Smtp password\nInvitation.WebHome_smtp_server_username=Smtp username\nInvitation.WebHome_smtp_port=Smtp port\nInvitation.WebHome_smtp_server=Smtp server host name\nInvitation.WebHome_javamail_extra_props=Javamail extra properties\nInvitation.WebHome_subjectLineTemplate=Email subject line template\nInvitation.WebHome_messageBodyTemplate=Email message body HTML template\nInvitation.WebHome_messageBodyTemplatePlain=Message body plain text template\nInvitation.WebHome_emailClass=Email message XClass\nInvitation.WebHome_emailContainer=Page containing email XObjects\nInvitation.WebHome_emailRegex=Regular expression for validating email addresses\nInvitation.WebHome_allowUsersOfOtherWikis=Let users of other wikis send\nInvitation.WebHome_usersMayPersonalizeMessage=Let users personalize messages\nInvitation.WebHome_usersMaySendToMultiple=Let users send to multiple addresses\n\n### XWiki.WysiwygEditorConfigClass (administration application)\nXWiki.WysiwygEditorConfigClass_sourceEditorEnabled=Source editor enabled\nXWiki.WysiwygEditorConfigClass_plugins=Plugins\nXWiki.WysiwygEditorConfigClass_menuBar=Menu Bar\nXWiki.WysiwygEditorConfigClass_toolBar=Tool Bar\nXWiki.WysiwygEditorConfigClass_cleanPaste=Clean paste content automatically\nXWiki.WysiwygEditorConfigClass_attachmentSelectionLimited=Attachment selection limited\nXWiki.WysiwygEditorConfigClass_externalImages=External images\nXWiki.WysiwygEditorConfigClass_imageSelectionLimited=Image selection limited\nXWiki.WysiwygEditorConfigClass_colorPalette=Color palette\nXWiki.WysiwygEditorConfigClass_colorsPerRow=Colors per row\nXWiki.WysiwygEditorConfigClass_fontNames=Font names\nXWiki.WysiwygEditorConfigClass_fontSizes=Font sizes\nXWiki.WysiwygEditorConfigClass_styleNames=Style names\n\n####################\n# XWiki Classes End\n####################\n\n###Dashboard translations\ndashboard.gadget.actions.delete.confirm=Are you sure you want to delete this gadget?\ndashboard.gadget.actions.delete.inProgress=Deleting gadget...\ndashboard.gadget.actions.delete.done=Gadget deleted\ndashboard.gadget.actions.delete.failed=Failed to delete gadget:\ndashboard.gadget.actions.delete.tooltip=Remove this gadget from the dashboard\ndashboard.gadget.actions.edit.tooltip=Edit this gadget's parameters\ndashboard.gadget.actions.edit.error.notmacro=The parameters of this gadget cannot be edited using this visual editor, please use the object editor to edit this gadget.\ndashboard.gadget.actions.edit.error.notmacro.title=Edit gadget parameters\ndashboard.gadget.actions.drop=You can drop gadgets here\ndashboard.gadget.actions.edit.loading=Saving gadget configuration...\ndashboard.gadget.actions.edit.failed=Failed to save gadget configuration:\ndashboard.actions.save.loading=Saving dashboard changes...\ndashboard.actions.edit.failed=Failed to save dashboard configuration:\ndashboard.actions.edit.differentsource.information=You are editing a dashboard defined in a different page,\ndashboard.actions.edit.differentsource.warning=. Your changes will impact all the pages using that dashboard configuration. If you want to customize only this page, edit this page in WYSIWYG mode and configure the dashboard macro with an empty source parameter.\ndashboard.actions.add.button=Add Gadget\ndashboard.actions.add.tooltip=Add a new gadget to this dashboard\ndashboard.actions.add.loading=Adding the gadget...\ndashboard.actions.add.failed=Failed to add gadget:\ndashboard.actions.columns.add.button=Add column\ndashboard.actions.columns.add.tooltip=Add a new column in this dashboard, at the end\n\n### Search application resources\nadmin.searchsuggest=Search Suggest\nadmin.searchsuggest.description=Configure the search suggest options.\nadmin.search=Search\nadmin.search.description=Choose the default search engine or configure the search index.\nsearch.admin.title=Search\nsearch.admin.configuration.seexwikicfg=See xwiki.cfg file for more configurations options.\nsearch.admin.configuration.button=Save\nsearch.extension.title.database=Database\nsearch.extension.title.solr=Solr\nXWiki.SearchConfigClass_engine=Default search engine\nsearch.page.title.query=Search: {0}\nsearch.page.title.noquery=Search\nsearch.page.bar.spaces.title=Location\nsearch.page.bar.wikis.all=All wikis\nsearch.page.bar.query.tip=search...\nsearch.page.bar.query.title=Enter your search query\nsearch.page.bar.querytip=e.g. xwiki* AND \"search query\"\nsearch.page.bar.submit=Search\nsearch.page.bar.submit.title=Search query\nsearch.page.database.title.query=Database Search: {0}\nsearch.page.database.title.noquery=Database Search\nsearch.page.results=Results\nsearch.page.results.page=Page\nsearch.page.results.space=Space\nsearch.page.results.wiki=Wiki\nsearch.page.results.date=Date\nsearch.page.results.author=Last Author\nsearch.page.results.score=Score\nsearch.page.results.actions=Actions\nsearch.page.results.newcomment=- 1 new comment\nsearch.page.results.noResults=Your search did not match any pages.\nsearch.page.noimplementation=There's no Search UI Extension available in your wiki. Please contact your Administrator.\nsearch.item.locatedIn=Located in\nsearch.item.modified=Modified by <span class=\"itemAuthor\">{0}</span> on <span class=\"itemDate\">{1}</span>\nsearch.item.posted=Posted by <span class=\"itemAuthor\">{0}</span> on <span class=\"itemDate\">{1}</span>\nsearch.item.rating.title=Rating\nsearch.item.relevance.title=Relevance\nsearch.item.type.comment.title=Comment\nsearch.item.type.attachment.title=Attachment\nsearch.item.type.author.title=Author\nsearch.item.type.page.title=Page\nsearch.item.type.wiki.title=Wiki\nsearch.item.type.space.title=Space\nsearch.rss=RSS feed for search on {0}\nplatform.search.suggestSources=Sources\nplatform.search.suggestSources.hint=Search suggest results are aggregated from multiple sources. The sources are grouped by the search engine they use. Each source is configured to match a specific thing (e.g. the page name). Only the sources that are active and that use the current search engine contribute results to the search suggest.\nplatform.search.suggestAddNewSource=Add a new source\nplatform.search.suggestNewSourceName=New Source\nplatform.search.suggestSourceDocumentTitle=Page titles\nplatform.search.suggestSourceDocumentContent=Page content\nplatform.search.suggestSourceAttachmentName=Attachment names\nplatform.search.suggestSourceAttachmentContent=Attachment content\nplatform.search.suggestSourceBlogPost=Blog posts\nplatform.search.suggestSourceWikis=Wikis\nplatform.search.suggestSourceUsers=Users\nplatform.search.suggestConfigSaveComment=Updated the search suggest configuration from the Administration\nplatform.search.suggestResultLocatedIn=in\n\nXWiki.SearchSuggestConfig_activated=Activated\nXWiki.SearchSuggestConfig_activated.hint=Whether the search suggest is active or not.\n\nXWiki.SearchSuggestSourceClass_name=Name\nXWiki.SearchSuggestSourceClass_name.hint=The name used to group search results taken from this source. It can be a translation key.\nXWiki.SearchSuggestSourceClass_engine=Engine\nXWiki.SearchSuggestSourceClass_engine.hint=The search engine used to retrieve the results. This source is ignored if the current wiki is configured to use a different search engine.\nXWiki.SearchSuggestSourceClass_url=Service\nXWiki.SearchSuggestSourceClass_url.hint=The search suggest service. It can be either a page reference or an external URL.\nXWiki.SearchSuggestSourceClass_query=Query\nXWiki.SearchSuggestSourceClass_query.hint=The query that is passed to the search suggest service. It must contain a __INPUT__ placeholder for the searched text.\nXWiki.SearchSuggestSourceClass_resultsNumber=Limit\nXWiki.SearchSuggestSourceClass_resultsNumber.hint=The maximum number of search results taken from this source.\nXWiki.SearchSuggestSourceClass_icon=Icon\nXWiki.SearchSuggestSourceClass_icon.hint=The icon used to mark search results taken from this source. E.g. icon:user\nXWiki.SearchSuggestSourceClass_highlight=Highlight\nXWiki.SearchSuggestSourceClass_highlight.hint=Highlight the searched text in the search suggest results.\nXWiki.SearchSuggestSourceClass_activated=Activated\nXWiki.SearchSuggestSourceClass_activated.hint=Whether this source is used or not (as long as the source search engine matches the search engine used by the current wiki).\n\n### CSRFToken resources\ncsrf.confirmation=<p>This request contains an invalid authentication information.</p><p>This might happen in the following situations:</p><ul><li>You left the editor open in another window/tab and logged off and on again</li><li>Your authentication token expired after a long period of inactivity</li><li>Somebody tried to perform a CSRF attack</li></ul><p>If you are sure that none of these situations apply in your case, you might have found a bug. We are sorry about that, please report it on <a href=\"http://jira.xwiki.org/\">XWiki JIRA</a></p><p>Do you want to resend the request? If unsure, say <strong>No</strong>.</p>\n\n### Extension Manager application resources\nadmin.extensions=Extension Manager\n\n### WYSIWYG content editor administration section resources\nadmin.wysiwyg=WYSIWYG Editor\nwysiwyg.config.title=WYSIWYG Editor Configuration Panel\nwysiwyg.config.class.title=WYSIWYG Editor Configuration Class\nwysiwyg.config.sheet.title=WYSIWYG Editor Configuration Class Sheet\nwysiwyg.config.template.title=WYSIWYG Editor Configuration Template\nwysiwyg.admin.general=General settings\nwysiwyg.admin.sourceEditorEnabled.hint=Enable or disable the WYSIWYG/Source tabs.\nwysiwyg.admin.plugins.hint=The list of plugins that are loaded by the WYSIWYG editor. You can change the order in which they are loaded by drag and drop. You can also add new plugins to the list or remove existing ones.\nwysiwyg.admin.plugins.add.hint=Add plugin..\nwysiwyg.admin.menuBar.hint=The list of entries on the WYSIWYG editor menu bar. You can change their order by drag and drop. You can also add new entries on the menu bar or remove existing ones. Each menu bar entry is provided by a plugin and is displayed only if that plugin is loaded.\nwysiwyg.admin.menuBar.add.hint=Add entry..\nwysiwyg.admin.toolBar.hint=The list of features available on the WYSIWYG editor tool bar. You can change their order by drag and drop. You can also add new features on the tool bar or remove existing ones. Each tool bar feature is provided by a plugin and is displayed only if that plugin is loaded.\nwysiwyg.admin.toolBar.add.hint=Add feature..\nwysiwyg.admin.plugin.settings.hint=The following settings are taken into account only if the {0} plugin is loaded.\nwysiwyg.admin.cleanPaste.hint=Enable if you want the content that is pasted into the rich text area to be cleaned automatically. The cleaning process implies fixing HTML validity (e.g. by removing elements that are custom to some office document formats) and also filtering text styles like font, color, alignment or margins. Content structure like heading levels, paragraphs, list or tables are preserved. Semantic text styles like strong, emphasize, underline or strikethrough are also preserved. You can still clean the paste content when this option is disabled if you have the paste icon on the tool bar, but you have to trigger the clean manually.\nwysiwyg.admin.link=Link settings\nwysiwyg.admin.attachmentSelectionLimited.hint=When creating a link to an attachment allow the user to choose only from the attachments of the edited page.\nwysiwyg.admin.image=Image settings\nwysiwyg.admin.externalImages.hint=Allow users to insert external images, i.e. images that are not attached to a wiki page.\nwysiwyg.admin.imageSelectionLimited.hint=When inserting an image allow the user to choose only from the list of images attached to the edited page.\nwysiwyg.admin.color=Color settings\nwysiwyg.admin.colorsPerRow.hint=The number of colors to display per row in the color picker.\nwysiwyg.admin.colorPalette.hint=The colors available in the color picker. You can change any color by clicking on it.\nwysiwyg.admin.font=Font settings\nwysiwyg.admin.fontNames.hint=The list of font names available in the font picker. You can add new font names or remove existing ones.\nwysiwyg.admin.fontNames.add.hint=Add font name..\nwysiwyg.admin.fontSizes.hint=The list of font sizes available in the font picker. You can change their order by drag and drop. You can also add new font sizes or remove existing ones.\nwysiwyg.admin.fontSizes.add.hint=Add font size..\nwysiwyg.admin.style=Style settings\nwysiwyg.admin.styleNames.hint=The list of style names available in the style picker. You can also add new style names or remove/edit existing ones.\nwysiwyg.admin.widgets.sortableList.hint=Drag and drop to change the order\nwysiwyg.admin.widgets.sortableList.add=Add\nwysiwyg.admin.widgets.sortableList.delete=Delete\nwysiwyg.admin.widgets.colorPaletteEditor.hint=Click to change the color\nwysiwyg.admin.widgets.colorPaletteEditor.rows=Rows\nwysiwyg.admin.widgets.colorPaletteEditor.columns=Columns\nwysiwyg.admin.widgets.colorPaletteEditor.refresh=Refresh\nwysiwyg.admin.widgets.listBox.add=Add\nwysiwyg.admin.widgets.listBox.delete=Delete\nwysiwyg.admin.widgets.styleNamesEditor.blockStyles=Block Styles\nwysiwyg.admin.widgets.styleNamesEditor.inlineStyles=Inline Styles\nwysiwyg.admin.widgets.styleNamesEditor.styleName=Style name\nwysiwyg.admin.widgets.styleNamesEditor.styleLabel=Style label\nwysiwyg.admin.widgets.styleNamesEditor.styleInline=Inline style\nwysiwyg.admin.widgets.styleNamesEditor.add=Add\nwysiwyg.admin.saveComment=Updated the WYSIWYG Editor configuration from the Administration\n\n### Link Checker Application Resources\nplatform.linkchecker.indexTab=External Links\nplatform.linkchecker.livetable.link=Link\nplatform.linkchecker.livetable.page=Page\nplatform.linkchecker.livetable.code=State\nplatform.linkchecker.livetable.date=Last Checked\n\n### Dashboard Application Resources\nplatform.dashboard.user.preferences=Dashboard preferences\nplatform.dashboard.user.displayOnMainPage=Replace the default dashboard with my custom dashboard\nplatform.dashboard.wiki=Dashboard\nplatform.dashboard.wiki.pages=Pages\nplatform.dashboard.wiki.tagcloud=Tags\nplatform.dashboard.wiki.activity=Activity Stream\nplatform.dashboard.wiki.messageSender=Send Message\nplatform.dashboard.wiki.personal.empty.edit=edit the dashboard section in your profile\nplatform.dashboard.wiki.personal.empty=Your dashboard is currently empty. You can {0} to configure it. In the mean time, the default dashboard is displayed below.\nplatform.dashboard.space=Dashboard for space {0}\nplatform.dashboard.space.activity=Activity Stream for {0}\nplatform.dashboard.space.documents=Pages in {0}\nplatform.dashboard.space.remainingDocumentsInSpace=and {0} {0,choice,1#more page|1<more pages} in space {1}\nplatform.dashboard.space.visitSpaceIndex=visit the Space Index to see the full list\nplatform.dashboard.space.tagcloud=Tags for {0}\nplatform.dashboard.space.templateName=Dashboard\n\n### Extension Manager\nextensions.actions.showDetails=Show details\nextensions.actions.hideDetails=Hide details\nextensions.actions.install=Install\nextensions.actions.uninstall=Uninstall\nextensions.actions.upgrade=Upgrade\nextensions.actions.downgrade=Downgrade\nextensions.actions.installGlobally=Install on farm\nextensions.actions.uninstallGlobally=Uninstall from farm\nextensions.actions.upgradeGlobally=Upgrade on farm\nextensions.actions.downgradeGlobally=Downgrade on farm\nextensions.actions.back=Back to list\nextensions.actions.continue=Continue\nextensions.actions.diff=Show changes\nextensions.actions.repairXAR=Repair\nextensions.actions.repairXAR.hint=Mark this XAR extension as installed without importing its wiki pages\nextensions.actions.diffXAR=Compute changes\nextensions.actions.diffXAR.hint=Compute the changes made to the extension pages\nextensions.actions.repair=Repair\nextensions.actions.repairGlobally=Repair on farm\nextensions.install.title=Installing {0}\nextensions.install.error.installFailure=Failed to install extension with id {0} and version {1}:\nextensions.install.error.prepareFailure=Can''t resolve extension with id {0} and version {1}:\nextensions.install.error.alreadyInstalled=This extension is already installed.\nextensions.install.error.diffXarFailure=Failed to compute the changes made to the extension pages.\nextensions.install.list.install=The following new extensions will be installed:\nextensions.install.list.upgrade=The following extensions will be upgraded:\nextensions.install.list.downgrade=The following extensions will be downgraded:\nextensions.install.list.uninstall=The following extensions will be removed:\nextensions.install.list.repair=The following extensions will be repaired:\nextensions.install.list.top=The following extensions dependencies will be made top level:\nextensions.upgrade.mergeConflict.label=Merge conflict\nextensions.upgrade.mergeConflict.hint=The page {0} has changes that could be overwritten during the upgrade.\nextensions.upgrade.mergeConflict.versionToKeep.next=Keep the new version of the page (all your changes will be overwritten)\nextensions.upgrade.mergeConflict.versionToKeep.merged=Keep the merged version of the page (some of your changes could be overwritten)\nextensions.upgrade.mergeConflict.versionToKeep.current=Keep the current version of the page (the extension might not work properly after the upgrade)\nextensions.upgrade.mergeConflict.autoResolve=Resolve automatically\nextensions.upgrade.mergeConflict.autoResolve.hint=Resolve all the remaining merge conflicts automatically by choosing the same page version as now.\nextensions.upgrade.mergeConflict.changes.title=Changes for page {0}\nextensions.upgrade.mergeConflict.changes.original=Compare\nextensions.upgrade.mergeConflict.changes.revised=with\nextensions.upgrade.mergeConflict.changes.versionToCompare.previous=Previous version\nextensions.upgrade.mergeConflict.changes.versionToCompare.current=Current version\nextensions.upgrade.mergeConflict.changes.versionToCompare.next=New version\nextensions.upgrade.mergeConflict.changes.versionToCompare.merged=Merged version\nextensions.uninstall.title=Uninstalling {0}\nextensions.uninstall.error.uninstallFailure=Failed to uninstall extension with id {0} and version {1}:\nextensions.uninstall.error.prepareFailure=Failed to prepare uninstalling extension with id {0} and version {1}:\nextensions.uninstall.error.notInstalled=This extension is not installed.\nextensions.uninstall.cleanPages.label=Delete unused wiki pages?\nextensions.uninstall.cleanPages.hint=The following wiki pages are not needed any more so it should be safe to delete them. Unselect the ones that you wish to keep. The wiki pages that have modifications are left unselected so that you don't loose your changes. Select them if those changes are not important.\nextensions.uninstall.cleanPages.selectedCount={0} / {1} pages selected\nextensions.search.submit=Search\nextensions.search.tip=search extension...\nextensions.search.all.label=All Extensions\nextensions.search.more.label=More\nextensions.search.recommended.label=Recommended only\nextensions.search.recommended.tooltip=Only show extensions explicitly recommended by the XWiki community.\nextensions.search.recommended.fallback=No recommended extension could be found matching ''{0}'', displaying results of the search in all extensions.\nextensions.search.recommended.all.label=All recommended extensions\nextensions.search.recommended.disclaimer=This result only includes recommended extensions.\nextensions.search.indexed.label=Indexed\nextensions.search.indexed.tooltip=Search extensions in the local index or directly on the configured extensions repositories.\nextensions.search.indexed.disclaimer=This only includes indexed extensions.\nextensions.search.indexed.started=Index started on {0}. Any modification made after that to a remote extension won''t appear.\nextensions.search.indexed.on=Indexed on {0}. Any modification made after that to a remote extension won''t appear.\nextensions.search.indexed.nojob=Could not find any previous indexation processing.\nextensions.search.indexed.reindex=Reindex\nextensions.search.indexed.refresh=Refresh\nextensions.search.compatible.label=Compatible only\nextensions.search.compatible.tooltip=Only show extension which can be installed in the current wiki.\nextensions.search.compatible.all.label=All compatible extensions\nextensions.search.compatiblerecommended.disclaimer=This result only includes compatible recommended extensions.\nextensions.search.repository.remote.label=Available Extensions\nextensions.search.repository.core.label=Core extensions\nextensions.search.repository.core.empty=There are no core extensions.\nextensions.search.repository.installed.label=Installed extensions\nextensions.search.repository.installed.empty=There are no extensions installed.\nextensions.search.repository.local.label=Local extensions\nextensions.search.repository.local.empty=There are no local extensions.\nextensions.search.noResults=There were no extensions found matching ''{0}''. Try different keywords.\\nAlternatively, if you know the identifier and the version of the extension you''re looking for, you can use the Advanced Search form above.\nextensions.advancedSearch.title=Advanced search\nextensions.advancedSearch.id.label=Extension ID\nextensions.advancedSearch.version.label=Version\nextensions.advancedSearch.actions.submit=Search\nextensions.advancedSearch.actions.cancel=Cancel\nextensions.advancedSearch.noResults=We couldn''t find any extension with id ''{0}'' and version ''{1}''. Make sure you have the right extension repositories configured.\nextensions.info.authors=by:\nextensions.info.recommended=Recommended\nextensions.info.authors.xwikiorg=XWiki Development Team\nextensions.info.category.description=Description\nextensions.info.category.releaseNotes=Release Notes\nextensions.info.category.dependencies=Dependencies\nextensions.info.category.changes=Changes\nextensions.info.category.progress=Progress\nextensions.info.id=Id\nextensions.info.type=Type\nextensions.info.license={0,choice,0#Unknown license|1#License|1<Licenses}\nextensions.info.features={0,choice,0#No features|1#Feature|1<Features}\nextensions.info.components={0,choice,0#No component|1#Component|1<Components}\nextensions.info.repository=Repository\nextensions.info.website=Website\nextensions.info.scm=Sources\nextensions.info.issueManagement=Issues\nextensions.info.globalNamespace=global namespace\nextensions.info.namespaces.global=Installed globally\nextensions.info.namespaces.list=Installed on the following namespaces\nextensions.info.installedBy=Installed by {0} on {1}\nextensions.info.installedGloballyBy=Installed globally by {0} on {1}\nextensions.info.installedOnNamespaceBy={0}, by {1} on {2}\nextensions.info.dependencies.directDependencies={0,choice,0#|0<This extension depends on:}\nextensions.info.dependencies.backwardDependencies={0,choice,0#|0<This extension is required by:}\nextensions.info.dependency.wiki=(in wiki {0})\nextensions.info.fetch.failed=Failed to retrieve extension data.\nextensions.info.fetch.unauthorized=Unauthorized request. Your session has expired or you lost rights while installing or uninstalling an extension. You need to re-login in order to continue. Do you wish to proceed?\nextensions.info.status.core=Provided\nextensions.info.status.installed=Installed\nextensions.info.status.installed-dependency=Installed as dependency\nextensions.info.status.installed-invalid=Installed but not valid\nextensions.info.status.remote-core=Version {0} is provided\nextensions.info.status.remote-core-incompatible=Incompatible with provided version {0}\nextensions.info.status.remote-installed=Version {0} is installed\nextensions.info.status.remote-installed-dependency=Version {0} is installed as dependency\nextensions.info.status.remote-installed-incompatible=Incompatible with installed version {0}\nextensions.info.status.remote-installed-invalid=Installed version {0} is not valid\nextensions.info.stableVersions.linkLabel=List stable versions\nextensions.info.stableVersions.label=Stable Versions\nextensions.info.stableVersions.noResults=There are no stable versions available.\nextensions.applicationsPanel.install=Install new applications\nextensions.xar.changes.reset.button=Reset\nextension.rendering.macro.error.unknownMacro.followingMacros=This macro is provided by the following compatible extensions:\njob.log.label.install=Install log\njob.log.label.installplan=Install plan log\njob.log.label.uninstall=Uninstall log\njob.log.label.uninstallplan=Uninstall plan log\n\nplatform.extension.info.error.versionNotCompatible=This version is not compatible with your installation.\nplatform.extension.info.error.versionNotCompatibleHint=Search for a compatible version by going through the list of \"Stable Versions\" located in the extension's \"Description\" tab.\n\nplatform.extension.updater.checkForUpdates=Check for updates\nplatform.extension.updater.checkForUpdatesGlobally=Check for updates on farm\nplatform.extension.updater.lastCheckDate=The last time you checked for updates was on {0}.\nplatform.extension.updater.loading=Checking for updates...\nplatform.extension.updater.noUpdatesAvailable=All extensions are up to date.\nplatform.extension.updater.createUpgradePlanFailure=Failed to create the upgrade plan.\nplatform.extension.updater.invalidExtensionsLabel=Invalid extensions\nplatform.extension.updater.invalidExtensionsHint=The following extensions from {0} have to be upgraded or downgraded in order to work with your current distribution:\nplatform.extension.updater.outdatedExtensionsLabel=Outdated extensions\nplatform.extension.updater.outdatedExtensionsHint=The following extensions from {0} can be upgraded:\nplatform.extension.updater.pagingrestart=The list of extensions has been changed; showing first page of the changed list.\n\nplatform.extension.distributionWizard.stepHeading={0,choice,0#|0<Step {0} - } {1}\nplatform.extension.distributionWizard.unknownStepError=Unknown step\nplatform.extension.distributionWizard.continueLabel=Continue\nplatform.extension.distributionWizard.skipLabel=Later\nplatform.extension.distributionWizard.skipHint=Ask me again after XWiki is restarted\nplatform.extension.distributionWizard.replayLabel=Replay recorded actions\nplatform.extension.distributionWizard.replayHint=Upload an extension history file and replay the recorded actions\nplatform.extension.distributionWizard.cancelLabel=Never\nplatform.extension.distributionWizard.cancelHint=I can do this by myself, I don't want to use the wizard\nplatform.extension.distributionWizard.cancelConfirmation=Are you sure you don't want to use the wizard? If you don't know how to do this by yourself then you should continue with the wizard. You won't be able to get back the wizard easily otherwise.\n\nplatform.extension.distributionWizard.welcomeStepTitle=Distribution Wizard\nplatform.extension.distributionWizard.welcomeStepDescription=This wizard will guide you through the process of installing, upgrading or downgrading the XWiki distribution. You are seeing this wizard for one of the following reasons:{0}the default wiki pages recommended for the current version of the XWiki runtime are not installed{1}the version of the XWiki runtime has changed.\nplatform.extension.distributionWizard.welcomeStepStepsHint=The following steps are required in order to complete the XWiki installation:\nplatform.extension.distributionWizard.welcomeStepActionsHint=If you haven't finished configuring XWiki then you can choose to do the installation later. The wizard will reappear after the XWiki runtime is restarted. Although we don't recommend it, you can also do the installation by yourself, but note that you won't be able to get the wizard back easily if you choose to do so. Continue to the next step if you wish to perform the install now. Whatever you choose, after the wizard is closed you will be redirected back to the page you have requested.\n\nplatform.extension.distributionWizard.reportStepTitle=Report\nplatform.extension.distributionWizard.reportStepDescription=The installation is now finished. Here is a report of what happened during the process.\nplatform.extension.distributionWizard.reportStepDocumentsDescription=Various steps of the Distribution Wizard are modifying pages of the wikis. The following tree contains all the pages that have been created, modified or deleted page during the installation.\nplatform.extension.distributionWizard.reportStepDocumentsTitle=Pages\nplatform.extension.distributionWizard.reportStepDocumentsNoChange=No pages were modified during this Distribution Wizard.\nplatform.extension.distributionWizard.reportStepDocumentsDefaultLanguage=Default language\nplatform.extension.distributionWizard.reportStepDocumentDeletedSuccess=Successfully deleted page {0}\nplatform.extension.distributionWizard.reportStepDocumentRestoredSuccess=Successfully restored page {0}\nplatform.extension.distributionWizard.reportStepDocumentRollbackedSuccess=Successfully rollbacked page {0} to version {1}\n\nplatform.extension.distributionWizard.firstadminuserStepTitle=Admin user\nplatform.extension.distributionWizard.firstadminuserStepSummary=Make sure to create a user with administrative right\nplatform.extension.distributionWizard.firstadminuserStepDescription=You need a user with administrative right to install the wiki. This step will help you register and authenticate one for you.\nplatform.extension.distributionWizard.firstadminuser.registerAndLogin=Register and login\nplatform.extension.distributionWizard.firstadminuser.success.connected=You are connected with user {0}.\nplatform.extension.distributionWizard.firstadminuser.error.emptyUserName=Empty user name is not allowed.\nplatform.extension.distributionWizard.firstadminuser.error.emptyPassword=Empty password is not allowed.\nplatform.extension.distributionWizard.firstadminuser.error.passwordMismatch=The passwords do not match.\n\nplatform.extension.distributionWizard.extension.defaultuiStepTitle=User Interface\nplatform.extension.distributionWizard.extension.defaultuiStepSummary=Install the default set of wiki pages recommended for the current version of the XWiki runtime\nplatform.extension.distributionWizard.uiStepNoStateError=Can't get any information about the distribution.\nplatform.extension.distributionWizard.uiStepDescription=The user interface is a set of wiki pages that provide high level features on top of the XWiki runtime. These wiki pages are grouped by features into applications such as blog, activity stream, dashboard. Applications are packaged as extensions installable with the Extension Manager.\nplatform.extension.distributionWizard.uiStepDistributionLabel=Distribution\nplatform.extension.distributionWizard.uiStepDistributionHint=The following distribution has been detected:\nplatform.extension.distributionWizard.uiStepUILabel=User Interface\nplatform.extension.distributionWizard.uiStepUIHint=The following user interface is recommended for your distribution:\nplatform.extension.distributionWizard.uiStepInternetAccessWarning=The installation process requires internet access and it might take a few minutes to complete depending on the internet bandwidth and the load of the remote extension repository. Thank you for your patience.\nplatform.extension.distributionWizard.uiStepUIUnspecifiedError=The detected distribution doesn't specify a default user interface.\n\nplatform.extension.distributionWizard.uiStepPreviousUIUpgradeQuestion=Are you performing an upgrade? There are currently {0} pages in the database which indicates this is not a new install. Unfortunately we couldn''t determine what version of the user interface was previously installed, most probably because you are upgrading from an old version that didn''t have the distribution manager available.\nplatform.extension.distributionWizard.uiStepPreviousUIUpgradeYesLabel=Yes, this is an upgrade\nplatform.extension.distributionWizard.uiStepPreviousUIUpgradeNoLabel=No, this is a new install\nplatform.extension.distributionWizard.uiStepPreviousUIFormHint=Do you know what version of the user interface was previously installed? This would allow us to merge automatically the pages from your database with those from the new version of the user interface. You can still perform the upgrade even if you don't know the previous version but you may have to manually resolve a lot of merge conflicts.\nplatform.extension.distributionWizard.uiStepPreviousUIIdLabel=Previous user interface id\nplatform.extension.distributionWizard.uiStepPreviousUIIdHint=The id should normally have the following format: groupId:artifactId where the group id and the artifact id correspond to the Maven project that generated the XAR. Example: {0}\nplatform.extension.distributionWizard.uiStepPreviousUIVersionLabel=Previous version\nplatform.extension.distributionWizard.uiStepPreviousUIVersionListHint=Select the version from the following list. If your version is not in the list then click on the pencil icon to type your version.\nplatform.extension.distributionWizard.uiStepPreviousUIVersionHint=Examples:\nplatform.extension.distributionWizard.uiStepPreviousUIAdvancedInputHint=Edit\nplatform.extension.distributionWizard.uiStepPreviousUISubmitLabel=Yes, this is it\nplatform.extension.distributionWizard.uiStepPreviousUICancelLabel=I don't know\nplatform.extension.distributionWizard.uiStepPreviousUIRequestFailed=Request failed.\nplatform.extension.distributionWizard.uiStepPreviousUIHint=You indicated the following user interface as being previously installed:\nplatform.extension.distributionWizard.uiStepPreviousUIRepairLabel=Repair\nplatform.extension.distributionWizard.uiStepPreviousUIRepairHint=Register this XAR extension in the installed extensions index\n\nplatform.extension.distributionWizard.extension.defaultui.wikisStepTitle=Wikis\nplatform.extension.distributionWizard.extension.defaultui.wikisStepSummary=Update the default set of wiki pages on each of the existing wikis (except for the main wiki which is handled in the first step).\nplatform.extension.distributionWizard.wikisStepDescription=The following wikis have been detected. You can update the default set of wiki pages on all of them now by installing the user interface version recommended below, or you can do this later by accessing each wiki separately.\n\nplatform.extension.distributionWizard.extension.flavorStepTitle=Flavor\nplatform.extension.distributionWizard.extension.flavorStepSummary=Install or update the flavor of this wiki\nplatform.extension.distributionWizard.flavorStepDescription=The flavor is a set of wiki pages that provide high level features on top of the XWiki runtime. These wiki pages are grouped by features into applications such as blog, activity stream, dashboard. Applications are packaged as extensions installable with the Extension Manager.\nplatform.extension.distributionWizard.flavorStepDistributionLabel=Distribution\nplatform.extension.distributionWizard.flavorStepDistributionHint=The following distribution has been detected:\nplatform.extension.distributionWizard.flavorStepCurrentFlavorLabel=The currently installed flavor\nplatform.extension.distributionWizard.flavorStepCurrentFlavorHint=This is the flavor that was chosen during the previous install (or upgrade). It often need to be upgraded to be in sync with the new distribution.\nplatform.extension.distributionWizard.flavorStepCurrentFlavorInvalidError=The current flavor is not compatible with the current distribution.\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorUpgradeLabel=Try to find a valid version\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorUpgradeHint=Let's try to find a different version of the same flavor that would be compatible with the current distribution.\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorOrInstallNewLabel=Or install a new flavor\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorOrInstallNewHint=If you want to use a different flavor or the current flavor is not maintained anymore and don't have more compatible candidate you can select one of the available flavors.\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorInstallNewLabel=Install a new flavor\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorInstallNewHint=Choose one of the valid flavors found in the configured repositories\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorNoUpgradeError=Could not find any valid version for flavor \"{0}\".\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorUpgradeKnownLabel=Upgrade the flavor\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorUpgradeKnownHint=Here is the version of the current flavor corresponding to the current distribution.\nplatform.extension.distributionWizard.flavorStepNewFlavorLabel=Install a new flavor\nplatform.extension.distributionWizard.flavorStepSelectOtherFlavor=Select other flavor\nplatform.extension.distributionWizard.flavorStepConfirm=You are about to install the following flavor, please confirm or select an other flavor.\nplatform.extension.distributionWizard.flavorStepNoFlavorConfirm=You have chosen to let the wiki be empty, please confirm or go back.\nplatform.extension.distributionWizard.flavorStepNoFlavorBack=Back and select a flavor\nplatform.extension.distributionWizard.flavorStep=\n\nplatform.extension.distributionWizard.extension.flavor.wikisStepTitle=Wikis\nplatform.extension.distributionWizard.extension.flavor.wikisStepSummary=Update the flavor on each of the existing wikis that needs it (except for the main wiki which is handled in the first step).\nplatform.extension.distributionWizard.wikiflavorsStepDescription=The following wikis have been detected. You can update the flavor on all of them now or you can do this later by accessing each wiki separately.\n\nplatform.extension.distributionWizard.extension.outdatedextensionsStepTitle=Extensions\nplatform.extension.distributionWizard.extension.outdatedextensionsStepSummary=Update the installed extensions\nplatform.extension.distributionWizard.extensionsStepDescription=Extensions provide additional features on top of the XWiki runtime. They are commonly distributed as XARs (e.g. {0}XWiki applications{1}, {2}wiki macros{3}, {4}color themes{5}) and JARs (server side code including especially {6}components{7} and {8}script services{9}).\n\nplatform.extension.distributionWizard.extension.cleanStepTitle=Orphaned dependencies\nplatform.extension.distributionWizard.extension.cleanStepSummary=Make sure orphaned extension dependencies are either removed or made top level.\nplatform.extension.distributionWizard.extension.cleanStep.noOrphaned=No orphaned dependency could be found in that instance.\nplatform.extension.distributionWizard.extension.cleanStep.orphaned=The following extensions have been installed as dependencies and are no longer required. You can either uninstall them (checked) or make them top level extensions if you still need them (unchecked).\nplatform.extension.distributionWizard.extension.cleanStep.button.cleanapply=Continue\nplatform.extension.distributionWizard.extension.cleanStep.button.cleanapplyfinalize=Continue\nplatform.extension.distributionWizard.extension.cleanStep.button.cleanapplyreport=Continue\nplatform.extension.distributionWizard.extension.cleanStep.button.back=Back\nplatform.extension.distributionWizard.extension.cleanStep.apply.title=Apply\nplatform.extension.distributionWizard.extension.cleanStep.report.uninstalled=The following extensions have been uninstalled:\nplatform.extension.distributionWizard.extension.cleanStep.report.top=The following extensions have been made top level:\nplatform.extension.distributionWizard.extension.cleanStep.uninstall.finish.error=Failed to uninstall orphaned extensions\nplatform.extension.distributionWizard.extension.cleanStep.uninstall.finish.warning=The orphaned extensions have been successfully uninstalled but unexpected errors where logged during the process\nplatform.extension.distributionWizard.extension.cleanStep.uninstall.finish.success=The orphaned extensions have been successfully uninstalled\n\n### Logging Application Resources\nadmin.logging=Logging\nadmin.logging.description=Review and modify the log level associated to a registered logger.\nlogging.admin.intro=Here you can review and modify the log level associated to a registered logger. <default> or empty log level means that the logger inherits from its parent logger which is the package prefix when it's a package or the default level in the logger implementation configuration if there is no parent.\nlogging.admin.livetable.actions.set=Set\nlogging.admin.livetable.logger=Logger\nlogging.admin.livetable.level=Level\nlogging.admin.livetable.actions=Actions\n\n## Login Form\nplaform.web.login.forgotUserNameOrPassword=Forgot your {0}username{1} or {2}password{3}?\n\n## Initialization\nplatform.web.init.message.initializing=XWiki is initializing ({0}%)...\nplatform.web.init.message.initializationFailure=XWiki initialization failed!\nplatform.web.init.message.initializationSuccess=XWiki is initialized, you will be redirected shortly\nplatform.web.init.message.wiki.initializing=Wiki [{0}] is initializing ({1}%)...\nplatform.web.init.message.wiki.initializationFailure=Wiki [{0}] initialization failed!\nplatform.web.init.message.wiki.initializationSuccess=Wiki [{0}] is initialized, you will be redirected shortly\n\nrating.one-star=Poor\nrating.two-stars=Satisfactory\nrating.three-stars=Good\nrating.four-stars=Very good\nrating.five-stars=Excellent\nrating.votes=Votes\n\n## Hierarchy\nweb.hierarchy.error=Failed to get the full hierarchy.\n\n## XWiki Select Widget\nweb.widgets.select.filter=Filter\nweb.widgets.select.filter.placeholder=Type to filter...\nweb.widgets.select.filter.noResults=No matching result...\n\n## Syntax Picker\nweb.widgets.syntaxPicker.configureSyntaxes=Configure more syntaxes\nweb.widgets.syntaxPicker.conversionConfirmation.title=Syntax Conversion\nweb.widgets.syntaxPicker.conversionConfirmation.message=Do you want to also convert the page content and meta data from the previous {0} syntax to the selected {1} syntax? Choosing ''No'' will only change the syntax identifier, without modifying the page content.\nweb.widgets.syntaxPicker.conversion.inProgress=Converting syntax...\nweb.widgets.syntaxPicker.conversion.done=Syntax converted\nweb.widgets.syntaxPicker.conversion.failed=Syntax conversion failed\nweb.widgets.syntaxPicker.contentUpdate.inProgress=Updating content...\nweb.widgets.syntaxPicker.contentUpdate.done=Content updated\nweb.widgets.syntaxPicker.contentUpdate.failed=Content update failed\nweb.widgets.syntaxPicker.conversionUnsupported.message=The automatic conversion from {0} to {1} syntax is not yet supported. This will change the syntax identifier but you''ll have to do the syntax conversion yourself.\nweb.widgets.syntaxPicker.conversionUnsupported.acknowledge=OK\n\n## Editable Property (in-place editing of properties)\nweb.editableProperty.editFailed=Failed to edit property.\nweb.editableProperty.viewFailed=Failed to view property.\n\n## Drawer\ncore.drawer.global=Global\n\n## Notifications\nnotifications.events.update.description=edited the page\nnotifications.events.update.description.by.1user=edited by {0}\nnotifications.events.update.description.by.users=edited by {0} users\nnotifications.events.addComment.description=commented the page\nnotifications.events.addComment.description.by.1user=commented by {0}\nnotifications.events.addComment.description.by.users=commented by {0} users\nnotifications.events.create.description=created the page\nnotifications.events.create.description.by.1user=created by {0}\nnotifications.events.create.description.by.users=created by {0} users\nnotifications.events.delete.description=deleted the page\nnotifications.events.delete.description.by.1user=deleted by {0}\nnotifications.events.delete.description.by.users=deleted by {0} users\n\n## Templates\n\ntemplate.error.requirement.action=Action [{0}] does not match action requirement [{1}].\n\n###############################################################################\n## Deprecated\n## Note: each element should be removed when the last branch using it is no longer supported\n###############################################################################\n\n## Used to indicate where deprecated keys start\n#@deprecatedstart\n\n#######################################\n## until 14.9\n#######################################\n\nadmin.analytics=Google Analytics\\u2122\nadmin.analytics.description=Configure the Google Analytics\\u2122 account.\nadmin.analytics.account.description=To enable page view tracking in Google Analytics\\u2122, enter your Google Analytics\\u2122 account here. You may enter more accounts (space separated) to track pages in multiple accounts.\nadmin.analytics.method.description=The tracking method you selected when you created the account.\nadmin.analytics.notrunning=Google Analytics\\u2122 is not running.\nadmin.analytics.running=Google Analytics\\u2122 is running.\nadmin.analytics.noscript=The application is unable to retrieve the script required to execute Google Analytics\\u2122.\nXWiki.GoogleAnalyticsCode_method=Tracking Method\nXWiki.GoogleAnalyticsCode_method_universal=Universal Analytics\nXWiki.GoogleAnalyticsCode_method_classic=Classic Analytics\nXWiki.GoogleAnalyticsCode_account=Account\n\n#######################################\n## until 14.6\n#######################################\n\nplatform.extension.distributionWizard.eventmigrationStepTitle=Events migration\nplatform.extension.distributionWizard.eventmigrationStepSummary=Copy events from the legacy event store to the new one\nplatform.extension.distributionWizard.eventmigrationStepDescription=XWiki switched to a new store for events (notifications) in 12.6. Since copying events can be a long process for old wikis with a lot of events and keeping them is not always desired the choice of doing it is left to the wiki administrator. Not copying them imply that any previous notification will seems to have disappeared. The migration is executed in the background and you don't need to wait for it to be finished before going to the next step.\nplatform.extension.distributionWizard.eventmigration.alltime=All time\nplatform.extension.distributionWizard.eventmigration.since=Since\nplatform.extension.distributionWizard.eventmigration.startMigration=Start migration\n\n#######################################\n## until 12.10\n#######################################\n\n#@deprecated extensions.search.all.label\nextensions.search.repository.all.label=All Extensions\n#@deprecated extensions.search.recommended.label\nextensions.search.repository.recommended.label=Recommended Extensions\n#@deprecated extensions.search.recommended.disclaimer\nextensions.search.repository.recommended.disclaimer=This only includes recommended extensions.\n#@deprecated extensions.search.recommended.fallback\nextensions.search.repository.recommended.fallback=No recommended extension could be found matching ''{0}'', displaying results of the search in {1}.\n\n#######################################\n## until 10.1\n#######################################\n\njob.log.label.refactoring/rename=Rename log\njob.log.label.refactoring/copyAs=Copy log\n\n#######################################\n## until 2.3\n#######################################\n\nxe.search.lucene.try=You can also try the new experimental {0}. It adds scoring, searching into attachments and search paging. Please let us know what you think about it.\nxe.search.rebuild.started=Started index rebuild. This will take some time depending on the number of pages/attachments.\nxe.search.rebuild.rights=You must have administrator rights to rebuild the index.\nxe.search.rebuild.inprogress=Another rebuild is in progress.\nxe.search.rebuild.failed=Index rebuild failed.\nxe.search.index.rebuild=Rebuild the Lucene index\nxe.search.default.engine=default search engine\nxe.search.lucene.experimental=This is the new experimental Lucene search engine. You can still use the XWiki {0}.\npanels.search.title=Search\npanels.search.query=Search query\npanels.search.inputLabel=Search\npanels.search.inputText=search...\npanels.search.submit=Go\npanels.search.advanced=Advanced search\n### Search\nxe.search.query=Query\nxe.search.in.space=in space\nxe.search.in.wikis=in wikis\nxe.search.results.one=One result:\nxe.search.results=Results\nxe.search.of=of\nxe.search.page.previous=previous page\nxe.search.page.next=next page\nxe.search.plugin.notfound=Lucene plugin not found. Make sure it's defined in your xwiki.cfg file.\nxe.search.plugin.notenabled=The Lucene plugin is not enabled. You can use the XWiki {0}.\nxe.search.go=Search\nxe.search.web=Search\nxe.search.web.results=Search: {0}\nxe.search.lucene=Lucene Search\nxe.search.lucene.results=Lucene Search: {0}\nxe.search.rss=RSS feed for search on {0}\nxe.search.title=Search\nxe.search.bar.query.tip=search...\nxe.search.bar.query.title=Enter your search query\nxe.search.bar.wikis.all=All wikis\nxe.search.bar.wikis.title=Select wiki\nxe.search.bar.spaces.title=Select spaces\nxe.search.bar.spaces.all=All spaces\nxe.search.bar.submit=Search\nxe.search.bar.submit.title=Search query\nxe.search.bar.queryTip=e.g. xwiki* AND \"search query\"\nxe.search.bar.advanced=Advanced\n### Search results list\nxe.search.item.location=Located in <a href=\"{1}\">{0}</a> &#187; <a href=\"{3}\">{2}</a> &#187; <a href=\"{5}\">{4}</a>\nxe.search.item.modified=Modified by <span class=\"itemAuthor\">{0}</span> on <span class=\"itemDate\">{1}</span>\nxe.search.item.posted=Posted by <span class=\"itemAuthor\">{0}</span> on <span class=\"itemDate\">{1}</span>\nxe.search.item.rating.title=Rating\nxe.search.item.relevance.title=Relevance\nxe.search.item.type.comment.title=Comment\nxe.search.item.type.attachment.title=Attachment\nxe.search.item.type.author.title=Author\nxe.search.item.type.page.title=Page\nxe.search.item.type.wiki.title=Wiki\nxe.search.item.type.space.title=Space\nxe.search.index.uptodate=Lucene index is up to date.\nxe.search.rebuild.currently=Lucene is currently building its index, {0} documents in queue.\n### Results\nxe.results.page=Page\nxe.results.space=Space\nxe.results.wiki=Wiki\nxe.results.date=Date\nxe.results.author=Last Author\nxe.results.score=Score\nxe.results.actions=Actions\nxe.results.newcomment=- 1 new comment\nxe.results.guest=Guest\nxe.results.copy=Copy\nxe.results.delete=Delete\nxe.results.rename=Rename\nxe.results.rights=Rights\n\n#######################################\n## until 2.6 RC2\n#######################################\n\n### Recent Activity Macro\nxe.recentactivity=Recent Activity\nxe.recentactivity.rssfeed=RSS feed\nxe.recentactivity.noentries=There is no recent activity\n\nxe.recentactivity.action.create=created the page\nxe.recentactivity.action.delete=deleted the page\nxe.recentactivity.action.update=edited the page\nxe.recentactivity.action.addAnnotation=added an annotation\nxe.recentactivity.action.deleteAnnotation=deleted an annotation\nxe.recentactivity.action.updateAnnotation=edited an annotation\nxe.recentactivity.action.addAttachment=added {0,choice,1#an attachment|1<{0} attachments}\nxe.recentactivity.action.deleteAttachment=deleted an attachment\nxe.recentactivity.action.updateAttachment=edited {0,choice,1#an attachment|1<{0} attachments}\nxe.recentactivity.action.addComment=added a comment\nxe.recentactivity.action.deleteComment=deleted a comment\nxe.recentactivity.action.updateComment=edited a comment\nxe.recentactivity.action.summary={0,choice,1#one change|1<{0} changes} by {1,choice,1#one user|1<{1} users}\nxe.recentactivity.action.seechanges=see changes\n\n### Wiki and space dashboard (XWiki Enterprise wiki)\nxe.dashboard.wiki.recentactivity=Recent Activity\nxe.dashboard.space.recentactivity=Recent Activity for space {0}\n\n### User profile page\nplatform.core.profile.section.recentactivity=My Recent Activity\n\n### Tag application\nxe.tag.recentactivity=Recent activity in documents tagged with {0}\n\n#######################################\n## until 2.6 RC1\n#######################################\n\n### Recent Changes (XWiki Enterprise wiki)\nxe.recentchanges=Recent Changes\nxe.recentchanges.rssfeed=RSS feed\nxe.recentchanges.summary=This table lists recent changes brought to documents of this wiki, sorted by date (more recent changes come first). Each line contains all the aggregated changes done on a single day and by a given user. For each line, the user's name and avatar are displayed, along with the list of documents modified by that user.\nxe.recentchanges.showminor=Show minor edits\nxe.recentchanges.hideminor=Hide minor edits\nxe.recentchanges.column.authoranddate=Author and date\nxe.recentchanges.column.changes=Changes\nxe.recentchanges.entry.new=new!\nxe.recentchanges.entry.page.seemodifications=See modifications\nxe.recentchanges.entry.page.seemodifications.title=Modifications for {0}\nxe.recentchanges.entry.page.tooltip=Version {0}. Last modification {1}.\nxe.recentchanges.entry.comment.tooltip=Posted at {0}\nxe.recentchanges.entry.comment=comment\nxe.recentchanges.entry.comment.show=show\nxe.recentchanges.entry.comment.hide=hide\nxe.recentchanges.entry.comment.seediscussion=See discussion\n\n### Wiki and space dashboard (XWiki Enterprise wiki)\nxe.dashboard.wiki.recentchanges=Recent Changes\nxe.dashboard.space.recentchanges=Recent Changes for space {0}\n\n### User profile page\nplatform.core.profile.section.recentChanges=Recent Changes\n\n### Tag application\nxe.tag.recentchanges=Recent changes in documents tagged with {0}\n\n#######################################\n## until 2.7\n#######################################\n\n### Validation Messages\nxe.admin.registration.fieldMandatory=This field is mandatory.\nxe.admin.registration.fieldOkay=Ok.\ncore.create.validation.valid=OK\ncore.create.validation.mandatoryfield=Mandatory field\ncore.editors.validation.mandatoryField=This field is mandatory\n\n### Forgot Username (Administration application)\nxe.admin.passwordreset.forgotusername=Forgot your username?\nxe.admin.passwordreset.enteremail=Please enter the email address you provided when creating your account.\nxe.admin.passwordreset.email=Email:\nxe.admin.passwordreset.retrieve=Retrieve username\nxe.admin.passwordreset.noaccountregistered=No account is registered using this email address.\nxe.admin.passwordreset.differentaddress=Try again using another email address\nxe.admin.passwordreset.login=Login\nxe.admin.passwordreset.usernameis=Your username is:\nxe.admin.passwordreset.multipleusernames=The following usernames are registered with this email address:\nxe.admin.passwordreset.forgotpassword=Forgot your password?\nxe.admin.passwordreset.startprocess=Please enter your username to start the password recovery process.\nxe.admin.passwordreset.username=Username:\nxe.admin.passwordreset.resetpassword=Reset password\nxe.admin.passwordreset.nouser=The ~~{0}~~ user does not exist.\nxe.admin.passwordreset.ldapuser=The ~~{0}~~ user is an LDAP user. In that case the password has to be changed on the LDAP server.\nxe.admin.passwordreset.cannotreset=Cannot reset password: email address not provided in the user profile.\nxe.admin.passwordreset.emailsent=An e-mail was sent to <tt>{0}</tt>. Please follow the instructions in that e-mail to complete the password reset procedure.\nxe.admin.passwordreset.reseterror=An unknown problem occurred while sending the reset email.\nxe.admin.passwordreset.retry=Retry\nxe.admin.passwordreset.noprogrammingrights=This page requires programming rights to work, which currently isn't the case. Please notify an administrator of this problem and try again later.\nxe.admin.passwordreset.resetfor=Reset password for ~~{0}~~\nxe.admin.passwordreset.emptystring=The password cannot be an empty string.\nxe.admin.passwordreset.nomatch=The two passwords do not match.\nxe.admin.passwordreset.newpassword=New password:\nxe.admin.passwordreset.reenterpassword=Re-enter new password:\nxe.admin.passwordreset.save=Save\nxe.admin.passwordreset.notempty=The password cannot be empty.\nxe.admin.passwordreset.success=The password has been successfully set. Please\nxe.admin.passwordreset.loginsmall=login\nxe.admin.passwordreset.successend=to continue.\nxe.admin.passwordreset.wrongparameters=Wrong parameters.\nxe.admin.passwordreset.backtoreset=Back to the password reset page\n\npanels.documentInformation.parent=Parent:\n\n#######################################\n## until 3.0M2 \n#######################################\ncore.copy.copydoc=Copy Page\ncore.copy.sourcedoc=Source page\ncore.copy.sourcedoc.hint=Location of the original page\ncore.copy.targetdoc=Target page\ncore.copy.targetdoc.hint=Desired location for the copied page\n\n#######################################\n## until 3.0M3\n#######################################\nadmin.general.description=General settings of the wiki.\nadmin.admin=Administrator\nyoucanclicktoedit=You can <a href=\"${doc.getURL('create')}\">edit this page</a> to create it.\n\n#######################################\n## until 3.0\n#######################################\nXWiki.XWikiPreferences_webbgcolor=Space Background Color\nXWiki.XWikiPreferences_menu=Menu\nXWiki.XWikiPreferences_editbox_width=Editbox Width\nXWiki.XWikiPreferences_editbox_height=Editbox Height\nXWiki.XWikiPreferences_ad_clientid=Advertisement Client ID\nXWiki.XWikiPreferences_macros_languages=Macros Languages\nXWiki.XWikiPreferences_macros_velocity=Macros for Velocity\nXWiki.XWikiPreferences_macros_groovy=Macros for Groovy\nXWiki.XWikiPreferences_macros_wiki2=Macros for new wiki Parser\nXWiki.XWikiPreferences_macros_mapping=Macros Mapping\nXWiki.XWikiPreferences_macros_wiki=Macros for the wiki Parser\nXWiki.XWikiPreferences_notification_pages=Notification Pages\nXWiki.XWikiPreferences_renderXWikiVelocityRenderer=Render velocity code\nXWiki.XWikiPreferences_renderXWikiGroovyRenderer=Render Groovy code\nXWiki.XWikiPreferences_renderXWikiRadeoxRenderer=Render Wiki syntax\nXWiki.XWikiPreferences_pageWidth=Preferred page width\nXWiki.XWikiPreferences_convertmail=convert email type\n\n#######################################\n## until 3.2M3\n#######################################\nxe.scheduler.jobs.infos=Infos\nxe.scheduler.jobs.add=Add\nxe.index.attachments.doc.date=Date\nxe.index.attachments.doc.author=Author\n\n#######################################\n## until 3.3M1\n#######################################\nplatform.core.profile.dashboard.displayOnMainPage=Display my dashboard on the wiki home when I'm logged in (instead of the default dashboard)\nplatform.core.profile.section.dashboard.preferences=Dashboard preferences\nxe.dashboard.wiki=Dashboard\nxe.dashboard.wiki.spaces=Spaces\nxe.dashboard.wiki.tagcloud=Tags\nxe.dashboard.wiki.activity=Activity Stream\nxe.dashboard.wiki.welcome=Welcome to your wiki\nxe.dashboard.wiki.personal.empty.edit=edit the dashboard section in your profile\nxe.dashboard.wiki.personal.empty=Your dashboard is currently empty. You can {0} to configure it. In the mean time, the default dashboard is displayed below.\nxe.dashboard.space=Dashboard for space {0}\nxe.dashboard.space.activity=Activity Stream for space {0}\nxe.dashboard.space.documents=Documents in space {0}\nxe.dashboard.space.remainingDocumentsInSpace=and {0} {0,choice,1#more document|1<more documents} in space {1}\nxe.dashboard.space.visitSpaceIndex=visit the Space Index to see the full list\n\n#######################################\n## until 3.4M1\n#######################################\ncore.create.template.empty=Empty Wiki Page\n\n#######################################\n## until 3.5\n#######################################\n\n#@deprecated platform.livetable.results\nxe.livetable.results=Livetable Results\n\n#@deprecated platform.livetable.resultsMacros\nxe.livetable.resultsmacros=Livetable Results Macros\n\n#@deprecated platform.livetable._actions.delete\nxe.livetable._actions.delete=delete\n\n#@deprecated platform.livetable._actions.rename\nxe.livetable._actions.rename=rename\n\n#@deprecated platform.livetable._actions.rights\nxe.livetable._actions.rights=rights\n\n#@deprecated platform.livetable._actions.copy\nxe.livetable._actions.copy=copy\n\n#@deprecated platform.livetable.filtersTitle\nxe.livetable.filters.title=Filter for the {0} column\n\n#@deprecated platform.livetable.loading\nxe.livetable.loading=Loading...\n\n#@deprecated platform.livetable.tagsHelp\nxe.livetable.tags.help=Click on one or more tags to filter the list\n\n#@deprecated platform.livetable.tagsHelpCancel\nxe.livetable.tags.help.cancel=and click again on a tag to cancel the filter\n\n#@deprecated platform.livetable.environmentCannotLoadTableMessage\nxe.livetable.environmentCannotLoadTableMessage=The environment prevents the table from loading data.\n\n#@deprecated platform.livetable.pagesizeLabel\nxe.livetable.pagesize.label=per page of\n\n#@deprecated platform.livetable.selectAll\nxe.livetable.select.all=All\n\n#@deprecated platform.livetable.paginationPage\nxe.pagination.page=Page\n\n#@deprecated platform.livetable.paginationPageTitle\nxe.pagination.page.title=Go to page {0}\n\n#@deprecated platform.livetable.paginationPagePrevious\nxe.pagination.page.previous=&#171; previous page\n\n#@deprecated platform.livetable.paginationPagePrevTitle\nxe.pagination.page.prev.title=Previous Page\n\n#@deprecated platform.livetable.paginationPageNext\nxe.pagination.page.next=next page &#187;\n\n#@deprecated platform.livetable.paginationPageNextTitle\nxe.pagination.page.next.title=Next Page\n\n#@deprecated platform.livetable.paginationResultsNone\nxe.pagination.results.none=No results\n\n#@deprecated platform.livetable.paginationResultsOne\nxe.pagination.results.one=One result\n\n#@deprecated platform.livetable.paginationResultsSingle\nxe.pagination.results.single=Result <span class=\"currentResultsNo\">{0}</span> of <span class=\"totalResultsNo\">{1}</span>\n\n#@deprecated platform.livetable.paginationResultsMany\nxe.pagination.results.many=Results <span class=\"currentResultsNo\">{0} - {1}</span> of <span class=\"totalResultsNo\">{2}</span>\n\n#@deprecated platform.livetable.paginationResults\nxe.pagination.results=Results\n\n#@deprecated platform.livetable.paginationResultsOf\nxe.pagination.results.of=out of\n\n#@deprecated platform.index.documents\nxe.index.documents=Documents on this Wiki\n\n#@deprecated platform.index\nxe.index=Index\n\n#@deprecated platform.index.tree\nxe.index.tree=Tree\n\n#@deprecated platform.index.orphaned\nxe.index.orphaned=Orphaned Pages\n\n#@deprecated platform.index.orphanedResults\nxe.index.orphaned.results=Orphaned Pages JSON Service\n\n#@deprecated platform.index.attachments\nxe.index.attachments=Attachments\n\n#@deprecated platform.index.attachmentsResults\nxe.index.attachments.results=Attachments JSON Service\n\n#@deprecated platform.index.doc.name\nxe.index.doc.name=Page\n\n#@deprecated platform.index.doc.space\nxe.index.doc.space=Space\n\n#@deprecated platform.index.doc.date\nxe.index.doc.date=Date\n\n#@deprecated platform.index.doc.author\nxe.index.doc.author=Last Author\n\n#@deprecated platform.index._actions\nxe.index._actions=Actions\n\n#@deprecated platform.index.emptyvalue\nxe.index.emptyvalue=\n\n#@deprecated platform.index.attachments.filename\nxe.index.attachments.filename=Filename\n\n#@deprecated platform.index.attachments.doc.name\nxe.index.attachments.doc.name=Page\n\n#@deprecated platform.index.attachments.doc.space\nxe.index.attachments.doc.space=Space\n\n#@deprecated platform.index.attachments.date\nxe.index.attachments.date=Date\n\n#@deprecated platform.index.attachments.author\nxe.index.attachments.author=Author\n\n#@deprecated platform.index.attachments.type\nxe.index.attachments.type=Type\n\n#@deprecated platform.index.attachments.emptyvalue\nxe.index.attachments.emptyvalue=\n\n#@deprecated platform.index.documentsTrash\nxe.index.documentsTrash=Deleted Documents\n\n#@deprecated platform.index.trashDocumentsEmpty\nxe.index.trash.documents.empty=No deleted documents\n\n#@deprecated platform.index.trashDocuments.ddoc.fullName\nxe.index.trash.documents.ddoc.fullName=Document\n\n#@deprecated platform.index.trashDocuments.ddoc.title\nxe.index.trash.documents.ddoc.title=Title\n\n#@deprecated platform.index.trashDocuments.ddoc.date\nxe.index.trash.documents.ddoc.date=Deleted on\n\n#@deprecated platform.index.trashDocuments.ddoc.deleter\nxe.index.trash.documents.ddoc.deleter=Deleted by\n\n#@deprecated platform.index.trashDocuments.actions\nxe.index.trash.documents.actions=\n\n#@deprecated platform.index.trashDocumentsActionsRestoreTooltip\nxe.index.trash.documents.actions.restore.tooltip=Restore document\n\n#@deprecated platform.index.trashDocumentsActionsRestoreText\nxe.index.trash.documents.actions.restore.text=[restore]\n\n#@deprecated platform.index.trashDocumentsActionsCannotRestoreTooltip\nxe.index.trash.documents.actions.cannotRestore.tooltip=The document cannot be restored to its original location because it has been recreated\n\n#@deprecated platform.index.trashDocumentsActionsCannotRestoreText\nxe.index.trash.documents.actions.cannotRestore.text=[cannot restore]\n\n#@deprecated platform.index.trashDocumentsActionsDeleteTooltip\nxe.index.trash.documents.actions.delete.tooltip=Permanently delete document\n\n#@deprecated platform.index.trashDocumentsActionsDeleteText\nxe.index.trash.documents.actions.delete.text=[delete]\n\n#@deprecated platform.index.trashDocumentsDeleteInProgress\nxe.index.trash.documents.delete.inProgress=Permanently deleting document...\n\n#@deprecated platform.index.trashDocumentsDeleteDone\nxe.index.trash.documents.delete.done=Document permanently deleted\n\n#@deprecated platform.index.trashDocumentsDeleteFailed\nxe.index.trash.documents.delete.failed=Failed to delete:\n\n#@deprecated platform.index.trashDocumentsDeleteInformation\nxe.index.trash.documents.deleteInformation=Deleted by {0} on {1}\n\n#@deprecated platform.index.attachmentsTrash\nxe.index.attachmentsTrash=Deleted Attachments\n\n#@deprecated platform.index.trashAttachmentsEmpty\nxe.index.trash.attachments.empty=No deleted attachments\n\n#@deprecated platform.index.trashAttachments.datt.filename\nxe.index.trash.attachments.datt.filename=Attachment\n\n#@deprecated platform.index.trashAttachments.datt.docName\nxe.index.trash.attachments.datt.docName=Document\n\n#@deprecated platform.index.trashAttachments.datt.date\nxe.index.trash.attachments.datt.date=Deleted on\n\n#@deprecated platform.index.trashAttachments.datt.deleter\nxe.index.trash.attachments.datt.deleter=Deleted by\n\n#@deprecated platform.index.trashAttachments.actions\nxe.index.trash.attachments.actions=\n\n#@deprecated platform.index.trashAttachmentsActionsRestoreTooltip\nxe.index.trash.attachments.actions.restore.tooltip=Restore attachment\n\n#@deprecated platform.index.trashAttachmentsActionsRestoreText\nxe.index.trash.attachments.actions.restore.text=[restore]\n\n#@deprecated platform.index.trashAttachmentsActionsCannotRestoreTooltip\nxe.index.trash.attachments.actions.cannotRestore.tooltip=The attachment cannot be restored to its original location because another file with the same name has been attached.\n\n#@deprecated platform.index.trashAttachmentsActionsCannotRestoreText\nxe.index.trash.attachments.actions.cannotRestore.text=[cannot restore]\n\n#@deprecated platform.index.trashAttachmentsActionsDeleteTooltip\nxe.index.trash.attachments.actions.delete.tooltip=Permanently delete attachment\n\n#@deprecated platform.index.trashAttachmentsActionsDeleteText\nxe.index.trash.attachments.actions.delete.text=[delete]\n\n#@deprecated platform.index.trashAttachmentsDeleteInProgress\nxe.index.trash.attachments.delete.inProgress=Permanently deleting attachment...\n\n#@deprecated platform.index.trashAttachmentsDeleteDone\nxe.index.trash.attachments.delete.done=Attachment permanently deleted\n\n#@deprecated platform.index.trashAttachmentsDeleteFailed\nxe.index.trash.attachments.delete.failed=Failed to delete:\n\n#@deprecated platform.index.spaceIndex\nxe.space.index=Space Index\n\n#@deprecated platform.index.spaceIndexDescription\nxe.space.index.description=Pages in the {0} space:\n\n#@deprecated platform.index.spaceIndexDocumentListCreate\nxe.spaceIndex.documentList.create=Create a new page\n\n#######################################\n## until 4.1M1\n#######################################\n\n#@deprecated core.viewers.diff.class.changed\ncore.viewers.diff.class.changes=Changed property {0}\n\n#######################################\n## until 4.1RC1\n#######################################\ncore.viewers.diff.summary=Show changes done between selected versions\ncore.viewers.diff.property=Property\ncore.viewers.diff.oldValue=Previous value\ncore.viewers.diff.newValue=New value\ncore.viewers.diff.attachment.filename=Filename\ncore.viewers.diff.attachment.action=Action\n\n#######################################\n## until 4.2M1\n#######################################\nextensions.advancedSearch.wiki.label=The wiki where to install\n#@deprecated extensions.install.list.install\nextensions.install.list.new=The following new extensions will be installed:\nextensions.install.list.suggested=Suggested:\nextensions.install.list.conflict=Conflict with core extensions:\nextensions.install.error.conflictingExtension=extension {0} is needed in version {1} but core extension has version {2}\nextensions.install.error.installFailure.onWiki=Failed to install extension with id {0} and version {1} on wiki {2}:\n\n#######################################\n## until 4.3M1\n#######################################\nxe.officeimporter.results.missingspace=Missing target space name. Please {0} and correct it.\nxe.officeimporter.results.missingpage=Missing target page name. Please {0} and correct it.\nextensions.uninstall.list=The following extensions will be removed:\n\n#@deprecated platform.extension.distributionWizard.welcomeStepTitle\nextensions.distribution.wizardTitle=Distribution Wizard\n\n#@deprecated platform.extension.distributionWizard.uiStepNoStateError\nextensions.distribution.error.noState=Can't get any information about the distribution.\n\n#@deprecated platform.extension.distributionWizard.uiStepDistributionHint\nextensions.distribution.hint=The following distribution has been detected:\n\n#@deprecated platform.extension.distributionWizard.uiStepUIHint\nextensions.distribution.uiHint=The following user interface is recommended for your distribution:\n\n#@deprecated platform.extension.distributionWizard.uiStepUIUnspecifiedError\nextensions.distribution.error.noUI=The detected distribution doesn't specify a default user interface.\n\n#@deprecated platform.extension.distributionWizard.extensionsStepUpToDate\nextensions.distribution.upToDate=All extensions are up to date.\n\n#@deprecated platform.extension.distributionWizard.extensionsStepInvalidExtensionsLabel\nextensions.distribution.list.invalid.label=Invalid extensions\n\n#@deprecated platform.extension.distributionWizard.extensionsStepInvalidExtensionsHint\nextensions.distribution.list.invalid.hint=The following extensions have to be upgraded or downgraded in order to work with your current distribution:\n\n#@deprecated platform.extension.distributionWizard.extensionsStepOutdatedExtensionsLabel\nextensions.distribution.list.outdated.label=Outdated extensions\n\n#@deprecated platform.extension.distributionWizard.extensionsStepOutdatedExtensionsHint\nextensions.distribution.list.outdated.hint=The following extensions can be upgraded:\n\n#@deprecated platform.extension.distributionWizard.extensionsStepPrepareUpgradeFailure\nextensions.distribution.error.prepareUpgradeFailure=Failed to create upgrade plan.\n\n#@deprecated platform.extension.distributionWizard.continueLabel\nextensions.distribution.stepAction.complete=Continue\n\n#@deprecated platform.extension.distributionWizard.skipLabel\nextensions.distribution.stepAction.skip=Skip\n\n#@deprecated platform.extension.distributionWizard.skipHint\nextensions.distribution.stepAction.skip.hint=Ask me again after XWiki is restarted\n\n#@deprecated platform.extension.distributionWizard.cancelLabel\nextensions.distribution.stepAction.cancel=Cancel\n\n#@deprecated platform.extension.distributionWizard.cancelHint\nextensions.distribution.stepAction.cancel.hint=Let me complete the installation manually\n\n#######################################\n## until 4.3M2\n#######################################\nxe.admin.local=Local\nxe.admin.groups.addGroup.submit=Add\nxe.admin.groups.addUser.duplicate=The user is already a member of this group\nxe.admin.groups.addGroup.duplicate=The group is already a subgroup\n\n#######################################\n## until 4.4RC1\n#######################################\n\n#@deprecated action.addClassProperty.error.invalidName\npropertynamenotcorrect=Property names must follow these naming rules: <br/>Names can contain letters, numbers, and the following characters: \"., -, _, :\" <br/>Names must not start with a number or punctuation character. <br/>Names must not start with the letters xml (or XML, or Xml, etc). <br/>Names cannot contain spaces.\n\n#######################################\n## until 4.5\n#######################################\nextensions.info.dependency=Installed as a dependency needed by another extension\nextensions.install.actions.submit=Apply\nextensions.install.actions.cancel=Cancel\nextensions.uninstall.actions.submit=Apply\nextensions.uninstall.actions.cancel=Cancel\n\n#######################################\n## until 5.0M2\n#######################################\n## Translations should not contain velocity code\neditpageTitle=Editing $services.localization.render($editor) for $tdoc.displayTitle\n\n#######################################\n## until 5.0RC1\n#######################################\navailableversionsattachment=The available versions of file '$attachment.filename' are:\nplatform.extension.distributionWizard.experimentalWarning=This feature is currently experimental. It has some rough edges which we hope to fix in the next versions. Please report any {0}issues{1} you may encounter while using the distribution wizard.\n\n#@deprecated platform.extension.distributionWizard.extension.defaultuiStepTitle\nplatform.extension.distributionWizard.uiStepTitle=User Interface\n\n#@deprecated platform.extension.distributionWizard.extension.defaultuiStepSummary\nplatform.extension.distributionWizard.uiStepSummary=Install the default set of wiki pages recommended for the current version of the XWiki runtime\n\n#@deprecated platform.extension.distributionWizard.extension.outdatedextensionsStepTitle\nplatform.extension.distributionWizard.extensionsStepTitle=Extensions\n\n#@deprecated platform.extension.distributionWizard.extension.outdatedextensionsStepSummary\nplatform.extension.distributionWizard.extensionsStepSummary=Update the installed extensions\n\n#@deprecated platform.extension.updater.noUpdatesAvailable\nplatform.extension.distributionWizard.extensionsStepUpToDate=All extensions are up to date.\n\n#@deprecated platform.extension.updater.invalidExtensionsLabel\nplatform.extension.distributionWizard.extensionsStepInvalidExtensionsLabel=Invalid extensions\n\n#@deprecated platform.extension.updater.invalidExtensionsHint\nplatform.extension.distributionWizard.extensionsStepInvalidExtensionsHint=The following extensions from {0} have to be upgraded or downgraded in order to work with your current distribution:\n\n#@deprecated platform.extension.updater.outdatedExtensionsLabel\nplatform.extension.distributionWizard.extensionsStepOutdatedExtensionsLabel=Outdated extensions\n\n#@deprecated platform.extension.updater.outdatedExtensionsHint\nplatform.extension.distributionWizard.extensionsStepOutdatedExtensionsHint=The following extensions from {0} can be upgraded:\n\n#@deprecated platform.extension.updater.createUpgradePlanFailure\nplatform.extension.distributionWizard.extensionsStepPrepareUpgradeFailure=Failed to create upgrade plan.\n\n#@deprecated platform.extension.updater.loading\nplatform.extension.distributionWizard.extensionsStepLoading=Please wait a few minutes for the upgrade plan to be computed...\n\n#@deprecated platform.extension.updater.reloadHint\nplatform.extension.distributionWizard.extensionsStepReloadHint=In case this information is outdated you can {0}recompute{1} the upgrade plan.\n\nannotations.title=Annotations\nannotations.menu.loading=Loading annotations settings\nannotations.menu.loaderror=Failed:\nannotations.tab.info.noannotations=No annotations for this document\nannotations.settings.display=Show annotations\nannotations.settings.error.wrongsyntax=Annotations are not available for documents in XWiki/1.0 syntax.\nannotations.settings.error.notarget=No document specified to get annotations settings for.\nannotations.annotated.loading=Loading annotated document\nannotations.annotated.loaderror=Failed:\nannotations.annotated.loaderror.wrongresponse=Wrongly formatted server response\nannotations.annotated.error.noannotatedelement=Annotations could not be loaded because the content is not available.\nannotations.annotated.error.wrongsyntax=Annotations are not available for documents in XWiki/1.0 syntax.\nannotations.action.edit.text=[Edit]\nannotations.action.edit.tooltip=Edit this annotation\nannotations.action.edit.submit.text=Update\nannotations.action.edit.cancel.text=Cancel\nannotations.action.edit.success=Annotation has been successfully updated.\nannotations.action.edit.loaderror=Failed:\nannotations.action.edit.error.notfound=This annotation does not exist anymore. Please refresh the page for an updated view.\nannotations.action.delete.text=[Delete]\nannotations.action.delete.tooltip=Delete this annotation\nannotations.action.delete.confirm=Are you sure you want to delete this annotation?\nannotations.action.delete.inProgress=Deleting annotation...\nannotations.action.delete.done=Annotation deleted\nannotations.action.delete.failed=Failed to delete annotation:\nannotations.action.create.submit.text=Add annotation\nannotations.action.create.cancel.text=Cancel\nannotations.action.create.selection.invalid=Please select a nonempty text in the document content.\nannotations.action.create.form.loaderror=Failed:\nannotations.action.create.success=Annotation has been successfully added\nannotations.action.create.loaderror=Failed:\nannotations.action.create.error.unauthorized=You are not authorized to add annotations on this document.\nannotations.action.create.error.unauthorizedguest=You are not authorized to add annotations on this document. Try to login first.\nannotations.action.create.helpmessage=To annotate a piece of text, select it and hit {0}.\nannotations.action.create.error.wrongsyntax=Annotations are not available for documents in XWiki/1.0 syntax.\nannotations.action.create.error.notarget=Unspecified target (document) to create annotations for.\nannotations.action.view.hide.text=hide\nannotations.action.view.form.loaderror=Failed:\nannotations.action.view.error.notfound=This annotation does not exist anymore. Please refresh the page for an updated view.\nannotations.altered.text=This annotation could not be displayed because the annotated text was not found in the document:\nannotations.updated.text=This annotation was automatically repositioned after an update of the document. Originally:\nannotations.action.validate.text=[Validate]\nannotations.action.validate.tooltip=Validate the automatic update of the selected text of this annotation\nannotations.action.validate.success=Annotation has been successfully validated.\nannotations.action.validate.loaderror=Failed:\nannotations.filters.show=Refine the display criteria\nannotations.filters.nooption=There are no values to filter for \"{0}\"\nannotations.filters.anyvalue=any value\nannotations.filters.clearvalue=clear\nannotations.config.title=Annotations configuration panel\nannotations.config.display.title=Annotation display settings\nannotations.config.type.title=Annotation type settings\nannotations.config.activate.title=Annotation activation settings\nannotations.config.activate.explanation=The following two settings allow you to configure in which spaces are annotations active. The first setting specifies the general rule, while the second list specifies the spaces for which the rule shouldn't apply. For example, activated \"yes\" and exception spaces \"XWiki\" and \"Main\" means that annotations will be active on all spaces except for \"XWiki\" and \"Main\", while activated \"no\" and exception spaces \"Documents\" means that annotations will be active only for the \"Documents\" space.\nannotations.config.type.explanation=Add properties to this class if you want extra properties for your annotations.\nadmin.annotations=Annotations\n\n#######################################\n## until 5.1RC1\n#######################################\n\n#@deprecated admin.analytics.account.description\nadmin.analytics.sectiondesc=To enable page view tracking in Google Analytics\\u2122, enter your Google Analytics\\u2122 account here. You may enter more accounts (space separated) to track pages in multiple accounts.\n\ndashboard.gadget.actions.tooltip=Gadget settings\n\n#######################################\n## until 5.1\n#######################################\nadmin.sender=Default sender email address\n\n#######################################\n## until 5.2M2\n#######################################\npanels.translation.originalLanguage=The original language of the document is <a href=\"{0}\">{1}</a>.\n\n#######################################\n## until 5.2M2\n#######################################\nxe.tag.rss.tag.title=RSS feed for tag: {0}\nxe.tag.rss.tag.description=RSS feed for all pages containing tag: {0}\nxe.tag.rss.tags.title=RSS feed for tagged pages\nxe.tag.rss.tags.description=RSS feed for all pages containing tags\nxe.rss.space.description=RSS feed for document changes on space \"{0}\"\n\n#######################################\n## until 5.4RC1\n#######################################\nplatform.extension.distributionWizard.upgrademodeStepTitle=Upgrade Mode\nplatform.extension.distributionWizard.upgrademodeStepSummary=Choose whether to upgrade the entire farm or just the main wiki\nplatform.extension.distributionWizard.upgradeStepModeLabel=Upgrade mode\nplatform.extension.distributionWizard.upgradeStepModeHint=Choose carefully because the upgrade process may involve fixing merge conflicts and thus it's recommended to leave this to the person that knows best how to fix them.\nplatform.extension.distributionWizard.upgradeStep.mode.WIKI.label=Upgrade only the current wiki. Choose this option if each wiki is administrated by a separate entity. In this case it's best if each wiki is upgraded by its owner.\nplatform.extension.distributionWizard.upgradeStep.mode.ALLINONE.label=Upgrade all wikis. Choose this option if all wikis are administrated by the same entity.\n\n#######################################\n## until 6.0M1\n#######################################\nxe.panels.viewer=Viewer panels\nxe.panels.editor=Editor panels\n\n#######################################\n## until 6.0M2\n#######################################\nplatform.extension.updater.reloadHint=In case this information is outdated you can {0}recompute{1} the upgrade plan.\n\n#######################################\n## until 6.1M1\n#######################################\nxe.userdirectory.doc.fullName=User ID\n\n#######################################\n## until 6.2M1\n#######################################\nextensions.info.jobLog=Job log\n\n#@deprecated job.log.label.install\nextensions.info.jobLog.install=Install log\n#@deprecated job.log.label.installplan\nextensions.info.jobLog.installplan=Install plan log\n#@deprecated job.log.label.uninstall\nextensions.info.jobLog.uninstall=Uninstall log\n#@deprecated job.log.label.uninstallplan\nextensions.info.jobLog.uninstallplan=Uninstall plan log\n\n#######################################\n## until 6.3\n#######################################\neditincludepagemsgone=$pages.size() included document\neditincludepagemsgmore=$pages.size() included documents\nsimpleedittoolbardesc=Click on a button to get a sample text\nsimpleedittoolbardesc2=Enter the text that you wish to format. It will be shown to be copy-pasted.\\\\nExample:\\\\n$1\\\\nwill become:\\\\n$2\nmyhomepage=$xwiki.getDocument($context.user).display(\"first_name\", \"view\", $xwiki.getDocument($context.user).getObject(\"XWiki.XWikiUsers\", 0))'s profile\nviewcodetitle=Wiki code for <em>$doc.displayTitle</em>\nviewcommentstitle=Comments for <em>$doc.displayTitle</em>\nviewattachmentstitle=Attachments for <em>$doc.displayTitle</em>\nviewhistorytitle=History of <em>$doc.displayTitle</em>\nviewinformationtitle=Information about <em>$doc.displayTitle</em>\neditgroupsredirect=You can currently edit groups using the wiki on <a href=\"$xwiki.getURL(\"XWiki.XWikiGroups\")\">the groups page</a>.\neditusersredirect=You can currently edit users using the wiki on <a href=\"$xwiki.getURL(\"XWiki.XWikiUsers\")\">the users page</a>.\n\n#######################################\n## until 6.4M2\n#######################################\nplatform.appwithinminutes.liveTableEditorIconHint=You need to provide a reference to a 16x16px icon, you can pick a name from our <a href=\"{0}\" target=\"_blank\">default icons set</a> and use the **icon:** prefix. For example: **icon:application**.\nadmin.email=Email\nadmin.email.description=Configure the email sending process.\nXWiki.XWikiPreferences_smtp_server=Server\nXWiki.XWikiPreferences_smtp_port=Port\nXWiki.XWikiPreferences_smtp_server_username=Server username (optional)\nXWiki.XWikiPreferences_smtp_server_password=Server password (optional)\nXWiki.XWikiPreferences_javamail_extra_props=Additional JavaMail properties\nXWiki.XWikiPreferences_admin_email=Admin email\nXWiki.XWikiPreferences_admin_email.hint=The default email address used to send notification emails from\nXWiki.XWikiPreferences_obfuscateEmailAddresses=Obfuscate Email Addresses\nXWiki.XWikiPreferences_obfuscateEmailAddresses.hint=This affects only the email addresses stored in object properties of type Email, as long as the default custom displayer for the Email property type is not overwritten. Example: a...@domain.org\n\n#######################################\n## until 7.0M1\n#######################################\nplatform.appwithinminutes.classEditorDatePickerMonthNames=January, February, March, April, May, June, July, August, September, October, November, December\nplatform.appwithinminutes.classEditorDatePickerWeekDayNames=Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday\nplatform.appwithinminutes.classEditorDatePickerFirstWeekDay=0\n\n#######################################\n## until 7.0M2\n#######################################\n\n### RSS\nxe.rss.feeds=RSS Feeds\nxe.rss.feeds.description=There are currently 4 types of RSS feeds available on this wiki. You can subscribe to each of them by clicking on their name or on the icon next to them.\nxe.rss.search=Search RSS feeds:\nxe.rss.search.description=RSS feed on a specific search query term. To generate such a feed, go to the {0} page, run a search on a keyword and then click on the RSS icon.\nxe.rss.tags=Tags RSS feeds:\nxe.rss.tags.feed=Tags RSS Feed\nxe.rss.tags.description=RSS feed on documents tagged with a specific term or all documents with a tag. To generate such a feed, go to the {0} page and click on the RSS feed icon you wish to use.\nxe.rss.blog=Blog RSS feed:\nxe.rss.blog.feed=Blog RSS Feed\nxe.rss.blog.description=RSS feed of blog posts from all blogs.\nxe.rss.global=Global RSS feed:\nxe.rss.global.description=RSS feed of page activity.\nxe.rss.icon=rss icon\nxe.rss.version=Version\nxe.rss.editedby=edited by\nxe.rss.on=on\n\n#######################################\n## until 7.0RC1\n#######################################\n\n### Spaces (XWiki Enterprise wiki)\nxe.spaces=Spaces\nxe.spaces.createspace=Create a new space\nxe.spaces.createspace.defaultname=Space name\nxe.spaces.createspace.submit=Create\nxe.spaces.action.index=See space index\nxe.spaces.action.index.alt=Space index\nxe.spaces.action.admin=See space administration\nxe.spaces.action.admin.alt=Administer space\nxe.spaces.action.delete.alt=Delete space\nxe.spaces.deleteSpace.deleted=Space \\u00AB{0}\\u00BB deleted.\n\n### RSS\nxe.rss.pages.modified=Modified Pages RSS Feed\nxe.rss.feed.description=RSS feed for document changes\nxe.rss.feed.tags.description=RSS feed for documents tagged with \"{0}\"\nxe.rss.feed.spaces.description=RSS feed for documents in space(s) \"{0}\"\nxe.rss.feed.tagsAndSpaces.description=RSS feed for documents tagged with \"{0}\" in space(s) \"{1}\"\n\n### History\ncore.viewers.diff.tag.tags=Tags\ncore.viewers.diff.contentChanges=Content changes\ncore.viewers.diff.attachmentChanges=Attachment changes\ncore.viewers.diff.attachment.added=Attachment has been added\ncore.viewers.diff.attachment.deleted=Attachment has been deleted\ncore.viewers.diff.attachment.updated=Attachment has been updated from version <a href=\"{1}\">{0}</a> to version <a href=\"{3}\">{2}</a>\ncore.viewers.diff.commentChanges=Comment changes\ncore.viewers.diff.comment.added=Comment number {0} added\ncore.viewers.diff.comment.deleted=Comment number {0} deleted\ncore.viewers.diff.comment.updated=Comment number {0} modified\ncore.viewers.diff.comment.author=Author\ncore.viewers.diff.comment.date=Date\ncore.viewers.diff.comment.comment=Comment content\ncore.viewers.diff.comment.highlight=Highlighted text\ncore.viewers.diff.comment.replyto=Reply to\ncore.viewers.diff.comment.target=Comment target\ncore.viewers.diff.comment.state=Comment state\ncore.viewers.diff.comment.selection=Selection\ncore.viewers.diff.comment.originalSelection=Original selection\ncore.viewers.diff.comment.selectionLeftContext=Selection left context\ncore.viewers.diff.comment.selectionRightContext=Selection right context\ncore.viewers.diff.objectChanges=Object changes\ncore.viewers.diff.object.added=Object number {0} of type {1} added\ncore.viewers.diff.object.deleted=Object number {0} of type {1} deleted\ncore.viewers.diff.object.updated=Object number {0} of type {1} modified\ncore.viewers.diff.classChanges=Class changes\ncore.viewers.diff.class.added=Added property {0}\ncore.viewers.diff.class.removed=Removed property {0}\ncore.viewers.diff.class.changed=Changed property {0}\n\n### Old History (should have been deprecated long time ago)\nchanges.changesofpage=Changes\nchanges.in=in\nchanges.space=space\nchanges.from=From\nchanges.to=To\nchanges.comment=Change comment\nchanges.nocomment=There is no comment for this version\nchanges.version=Version\nchanges.editedby=edited by\nchanges.on=on\nchanges.metadatachanges=Metadata changes\nchanges.property=Property\nchanges.nometadatachanges=There are no metadata changes\nchanges.contentchanges=Content changes\nchanges.nocontentchanges=There are no content changes\nchanges.attachmentchanges=Attachment changes\nchanges.noattachmentchanges=There are no attachment changes\nchanges.filename=Filename\nchanges.action=Action\nchanges.commentchanges=Comment changes\nchanges.nocommentchanges=There are no comment changes\nchanges.metadata.parent=Parent\nchanges.metadata.web=Space\nchanges.metadata.name=Page Name\nchanges.metadata.author=Author\nchanges.metadata.language=Language\nchanges.metadata.defaultLanguage=Default Language\nchanges.attachmentadded=Attachment has been added\nchanges.attachmentdeleted=Attachment has been deleted\nchanges.attachmentupdatedfromversion=Attachment has been updated from version\nchanges.toversion=to version\nchanges.commentchange=Comment change\nchanges.commentAdded=Comment number {0} added\nchanges.commentRemoved=Comment number {0} removed\nchanges.comment.property=Property\nchanges.comment.previousvalue=Previous value\nchanges.comment.newvalue=New value\nchanges.comment.author=Author\nchanges.comment.date=Date\nchanges.comment.comment=Comment\nchanges.comment.highlight=Highlighted text\nchanges.comment.replyto=Reply to\nchanges.blog.title=Title\nchanges.blog.extract=Extract\nchanges.blog.category=Categories\nchanges.blog.editcategories=Edit categories\nchanges.blog.addnewcategory=Add a category\nchanges.tag.tags=Tags\nchanges.objectchanges=Object Changes\nchanges.objectAdded=Object added\nchanges.objectRemoved=Object removed\nchanges.ofclass=of class\nchanges.noobjectchanges=No Object Changes\nchanges.classeschanges=Class Changes\nchanges.noclasseschanges=No Class Changes\n\n#######################################\n## until 7.1M1\n#######################################\n\nsearch.page.bar.query.label=Query\nplatform.appwithinminutes.appHomePageTitle={0} Home\n\n### History\nweb.history.changes.attachment.author=Author\nweb.history.changes.lineEndings=Only the line endings have changed\n\n#@deprecated web.history.changes.document.title\ncore.viewers.diff.metadata.title=Title\n#@deprecated web.history.changes.document.parent\ncore.viewers.diff.metadata.parent=Parent\n#@deprecated web.history.changes.document.hidden\ncore.viewers.diff.metadata.hidden=Hidden\n#@deprecated web.history.changes.document.defaultLocale\ncore.viewers.diff.metadata.defaultLanguage=Default language\n#@deprecated web.history.changes.document.syntax\ncore.viewers.diff.metadata.syntax=Syntax\n\ncore.viewers.diff.metadata.author=Author\ncore.viewers.diff.metadata.language=Language\ncore.viewers.diff.metadata.name=Name\ncore.viewers.diff.metadata.web=Space\ncore.viewers.diff.metadata.space=Space\n\n#######################################\n## until 7.2M1\n#######################################\n\n### Create UI\ncore.create.spaceTitle=Create Space\ncore.create.space=Space Name\ncore.create.space.hint=Name of the new space\ncore.create.space.template.hint=Template to use for the homepage of the new space\ncore.create.space.template.empty=Blank Homepage\ncore.create.page.space.hint=Containing space for the new page\n\n#######################################\n## until 7.2M2\n#######################################\n\n### Create UI\ncore.create.page=Page Name\ncore.create.page.hint=Name of the new page\ncore.create.pageText=NewPage\n\n### Copy UI\ncore.copy.sourcewiki=Source Wiki\ncore.copy.sourcewiki.hint=Location of the original wiki\ncore.copy.sourcespace=Source Space\ncore.copy.sourcespace.hint=Location of the original space\ncore.copy.sourcepage=Source Page\ncore.copy.sourcepage.hint=Location of the original page\ncore.copy.targetwiki=Target Wiki\ncore.copy.targetwiki.hint=Desired wiki location for the copied page\ncore.copy.targetspace=Target Space\ncore.copy.targetspace.hint=Desired space location for the copied page\ncore.copy.targetpage=Target Page\ncore.copy.targetpage.hint=Desired page location for the copied page\n\n### Rename UI\ncore.rename.title.newName=New document name\ncore.rename.title.updateDocs=Documents having backlinks to modify\ncore.rename.title.updateChildren=Documents having this document as their parent\ncore.rename.inputPrompt=<new document name>\ncore.rename.sourcespace=Source Space\ncore.rename.sourcespace.hint=Location of the original space\ncore.rename.sourcepage=Source Page\ncore.rename.sourcepage.hint=Location of the original page\ncore.rename.newspace=New space\ncore.rename.newspace.hint=Containing space for the renamed page\ncore.rename.newpage=New page\ncore.rename.newpage.hint=Name of the renamed page\n\n#######################################\n## until 7.2M3\n#######################################\n\nplatform.dashboard.wiki.spaces=Spaces\n\n#######################################\n## until 7.3RC1\n#######################################\n\n## Replaced with the more generic admin.preferences.title key used for all WebPreferences page titles.\nxe.xwiki.space.preferences=XWiki Space Preferences\n\n## The restrictions on the class name have been dropped. \nplatform.appwithinminutes.appNameInvalidClassNameError=We can't extract a valid class name from the application name you entered. Make sure you include letters in the application name besides digits and punctuation signs.\n\n## The \"type\" property has been removed and data migrated to the new \"terminal\" property.\nxe.templateprovider.templatetype=Template type\nxe.templateprovider.templatetype.info=Whether this template should be used for creating generic pages or is specific to space homepages\n\n#######################################\n## until 7.4M1\n#######################################\n\n## We don't need this key any more because the page that is going to be created is specified by the location picker.\ncore.create.newPageTitle=Create Page: {0}\n\n## The database search UI doesn't use these keys any more.\nsearch.item.location=Located in <a href=\"{1}\">{0}</a> &#187; <a href=\"{3}\">{2}</a> &#187; <a href=\"{5}\">{4}</a>\nsearch.page.bar.spaces.all=All spaces\nsearch.page.results.copy=Copy\nsearch.page.results.delete=Delete\nsearch.page.results.rename=Rename\nsearch.page.results.rights=Rights\nsearch.page.results.guest=Guest\n\n#######################################\n## until 7.4\n#######################################\n\ncore.rename.success=Successfully renamed page {0} in space {3} to page <a href=\"{2}\">{1}</a> in space {4}\ncore.copy.copyingdoc=Page {0} successfully copied to {1}\n\n#######################################\n## until 7.4.3 / 8.0RC1\n#######################################\n\ncore.rename.children.labelWithoutParams=Affect the child pages\ncore.rename.links.labelWithoutParams=Update the wiki links\n\n#######################################\n## until 8.1M1\n#######################################\n\ncore.viewers.jump.quickLinksText=Jump to any page in the wiki (Meta+G)\n\n#######################################\n## until 8.2M2\n#######################################\n\n# Home\nxe.home.title=Home\n\n#######################################\n## until 8.2RC1\n#######################################\n\nplatform.dashboard.wiki.welcome=Welcome to your wiki\n\n#######################################\n## until 8.3M1\n#######################################\n\nplatform.ldap.missingLdapService=LDAP service is not available. Please verify your installation.\nplatform.ldap.ldapAuthenticationIsNotEnabledWarning=LDAP authentication is not enabled. Please set LDAP as authentication service in ##xwiki.cfg##\nplatform.ldap.ldapGroupTip=LDAP group...\nplatform.ldap.xwikiGroupTip=XWiki group...\nplatform.ldap.ldapUserField=LDAP field...\nplatform.ldap.xwikiUserField=XWiki user property...\nplatform.ldap.adminHeadingConfiguration=Configuration\nplatform.ldap.adminHeadingMiscellaneous=Miscellaneous\nplatform.ldap.resetGroupCacheSuccess=Groups cache has been reset\nplatform.ldap.resetGroupCacheButton=Reset group cache\n\n#######################################\n## until 8.3\n#######################################\n\nxe.xwiki.space=XWiki\n\n#######################################\n## until 8.4RC1\n#######################################\n\n#@deprecated platform.web.init.message.initializing\nplatform.web.init.message.intializing=XWiki is initializing ({0}%)...\n#@deprecated platform.web.init.message.initializationFailure\nplatform.web.init.message.intializationFailure=XWiki initialization failed!\n#@deprecated platform.web.init.message.initializationSuccess\nplatform.web.init.message.intializationSuccess=XWiki is initialized, you will be redirected shortly\n\n#######################################\n## until 9.1.2\n#######################################\n\nadmin.section.title=Administration: {0}\nxe.admin.global=Global\nadmin.xwiki.addextensions=Add Extensions\n#@deprecated admin.xwiki.extensions.description\nadmin.xwiki.addextensions.description=Search for new extensions to add to the wiki.\nadmin.xwiki.installedextensions=Installed Extensions\nadmin.xwiki.installedextensions.description=See the list of already installed extensions, which you can upgrade or uninstall.\nadmin.xwiki.coreextensions=Core Extensions\nadmin.xwiki.coreextensions.description=See what extensions make up the core of XWiki.\n#@deprecated extension.updater\nadmin.xwiki.extensionupdater=Extension Updater\nadmin.translations=Translations\nexport_authorpreserved=Author preserved\nadmin.applications=Applications\nadmin.applications.description=Various settings for pluggable applications.\nadmin.configuration=Configuration\nadmin.configuration.description=General configuration of the wiki.\nadmin.elements=Page Elements\nadmin.elements.description=Choose what to display in the titlebar and page footer, and which side panels and page metadata tabs to display.\n\nsearch.admin.configuration.title=Configuration\n\nsearch.admin.lucene.title=Lucene search administration\nsearch.admin.lucene.status.title=Status\nsearch.admin.lucene.status.infotitle=Info\nsearch.admin.lucene.status.valuetitle=Value\nsearch.admin.lucene.status.indexed=Number of indexed elements\nsearch.admin.lucene.status.indexing=Number of elements in indexing queue\nsearch.admin.lucene.indexing.title=Indexing\nsearch.admin.lucene.indexing.description=Tools to control Lucene index.\nsearch.admin.lucene.indexing.action.indexfarm=Index the whole farm\nsearch.admin.lucene.indexing.action.indexcurrentwiki=Index the wiki\nsearch.admin.lucene.indexing.action.indexcustom=Custom index\nsearch.admin.lucene.indexing.action.indexcustom.wikis=Wikis\nsearch.admin.lucene.indexing.action.indexcustom.wikis.title=Comma separated list of wiki identifiers\nsearch.admin.lucene.indexing.action.indexcustom.hqlfilter=An HQL based filter query\nsearch.admin.lucene.indexing.action.indexcustom.hqlfilter.title=Same as in searchDocument() methods\nsearch.admin.lucene.indexing.action.indexcustom.clearindex=Clear the index\nsearch.admin.lucene.indexing.action.indexcustom.clearindex.title=The index is cleaned before starting to scan database\nsearch.admin.lucene.indexing.action.indexcustom.onlynew=Only index elements not already indexed\nsearch.admin.lucene.indexing.action.indexcustom.onlynew.title=A page is loaded and scanned only if it is not already in the Lucene index\nsearch.admin.lucene.indexing.message.started=Started index rebuild.\nsearch.admin.lucene.indexing.message.alreadystarted=Another rebuild is in progress.\nsearch.admin.lucene.indexing.button=Start indexing\nsearch.extension.title.lucene=Lucene\nsearch.page.lucene.title.query=Lucene Search: {0}\nsearch.page.lucene.title.noquery=Lucene Search\nsearch.page.lucene.rebuilding=Lucene is currently building its index, {0} pages in queue.\nsearch.lucene.plugin.notfound=Lucene plugin not found. Make sure it's defined in your xwiki.cfg file.\n\n#######################################\n## until 9.3-rc-1\n#######################################\ncreateblogpost=Blog post\n\nxe.panels.quicklinks.blog=Blog\n\n### Blog application\nxe.blog.archive.paneltitle=Blog Archive\nxe.blog.archive.noarticle=No articles yet...\nxe.blog.archive.postsyear=Blog posts for {0}\nxe.blog.archive.unpublished=(unpublished)\nxe.blog.archive.hidden=(hidden)\nxe.blog.archive.noarticlesyear=No articles in this year...\nxe.blog.archive.postsfor=Blog posts for\nxe.blog.archive.noarticlesmonth=No articles in this month...\nxe.blog.code.blogsheet=Blog sheet\nxe.blog.code.sheetexplanation=This sheet should be used to display blog pages.\nxe.blog.code.notblog=This is not a blog page!\nxe.blog.code.published=This blog post is not published yet.\nxe.blog.code.hidden=This blog post is hidden.\nxe.blog.code.notpublished=This blog post is not published yet. Publish it.\nxe.blog.code.madevisible=Entry has been made visible.\nxe.blog.code.hid=Hidden entry\nxe.blog.code.makevisible=This blog post is not visible to other users. Make it visible.\nxe.blog.code.hide=Hide this blog post from other users.\nxe.blog.code.loading=Loading...\nxe.blog.code.failedToChangeBlogPostVisibility=Failed to change blog post visibility.\nxe.blog.code.editpost=Edit this blog post\nxe.blog.code.deletepost=Delete this blog post\nxe.blog.code.readpost=Read the full entry\nxe.blog.code.postedby=Posted by\nxe.blog.code.createdby=Created by\nxe.blog.code.modifiedby=Modified by\nxe.blog.code.comments=Comments\nxe.blog.code.permalink=Permalink\nxe.blog.code.categories=Categories:\nxe.blog.code.in=in\nxe.blog.code.previousweek=Previous week\nxe.blog.code.nextweek=Next week\nxe.blog.code.previousmonth=Previous month\nxe.blog.code.nextmonth=Next month\nxe.blog.code.olderposts=Older posts\nxe.blog.code.newerposts=Newer posts\nxe.blog.code.blogcategories=Blog categories\nxe.blog.code.description.category=Most recent blog posts in the {0} category\nxe.blog.code.description.space=Most recent blog posts in the {0} space\nxe.blog.code.description.wiki=Most recent blog posts in the wiki\nxe.blog.code.title=Blog\nxe.blog.code.warning=Warning:\nxe.blog.sheet.notpost=This is not a blog post!\nxe.blog.sheet.category=Category:\nxe.blog.sheet.summary=Summary (optional):\nxe.blog.sheet.content=Content:\nxe.blog.sheet.title=Title:\nxe.blog.sheet.publicationdate=This article was published on {0}\nxe.blog.sheet.hidearticle=Hide article {0}\nxe.blog.sheet.notpublished=This article is not published yet.\nxe.blog.sheet.publish=Publish\nxe.blog.sheet.setdate=Set the publication date to:\nxe.blog.category.created=The {0} category has been created.\nxe.blog.category.exists=The {0} category already exists.\nxe.blog.categories.paneltitle=Blog Categories\nxe.blog.categories.name=Name:\nxe.blog.categories.parentcategory=Parent category:\nxe.blog.categories.description=Description:\nxe.blog.categories.add=Add\nxe.blog.categories.new=New category:\nxe.blog.categories.newName=New category name:\nxe.blog.categories.parent=Parent:\nxe.blog.categories.none=None\nxe.blog.categories.remove=Remove deleted category\nxe.blog.categories.edit=Edit Categories\nxe.blog.categories.subcategories=Subcategories\nxe.blog.categories.addsubcategory=Add new subcategory\nxe.blog.categories.articles=Articles from this category\nxe.blog.categories.sheet=Category sheet\nxe.blog.categories.sheetmessage=This sheet should be used to display blog categories.\nxe.blog.categories.notcategory=This is not a blog category!\nxe.blog.categories.noentries=No entries in this category\nxe.blog.manageCategories.title=Manage blog categories\nxe.blog.manageCategories.create.error.emptyName=Please enter a valid category name\nxe.blog.manageCategories.create.error.alreadyExists=Target page already exists, please choose a different name\nxe.blog.manageCategories.create.error.notExists=The requested page could not be found.\nxe.blog.manageCategories.create.error.targetNotWritable=You don't have the right to create the target page.\nxe.blog.manageCategories.rename.error.emptyName=Please enter a valid category name\nxe.blog.manageCategories.js.fetchingForm=Fetching form...\nxe.blog.manageCategories.js.error.noServer=Server not responding\nxe.blog.manageCategories.js.rename.inProgress=Renaming category...\nxe.blog.manageCategories.js.rename.error.403=You are not allowed to create the target page\nxe.blog.manageCategories.js.rename.error.404=Invalid category, please refresh the page to update the category tree\nxe.blog.manageCategories.js.rename.error.409=Target page already exists, please choose a different name\nxe.blog.manageCategories.js.add.inProgress=Adding category...\nxe.blog.manageCategories.js.add.error.401=You have been logged out, please refresh and log in\nxe.blog.manageCategories.js.add.error.403=You are not allowed to create the target page\nxe.blog.manageCategories.js.add.error.409=Target page already exists, please choose a different name\nxe.blog.manageCategories.js.delete.confirm=Are you sure you want to delete this category? This action is not reversible.\nxe.blog.manageCategories.js.delete.inProgress=Deleting category...\nxe.blog.manageCategories.js.delete.done=Deleted\nxe.blog.manageCategories.js.delete.failed=Failed to delete category\nxe.blog.manageCategories.comment.updatedParent=Updated category parent\nxe.blog.manageCategories.comment.removedDeletedCategory=Removed deleted category\nxe.blog.manageCategories.comment.updatedRenamedCategory=Updated renamed category\nxe.blog.manageCategories.comment.updatedCategory=Updated category name\nxe.blog.post.createpost=Create a new post\nxe.blog.post.title=Post title\nxe.blog.post.titleEmptyError=The post title should not be empty!\nxe.blog.post.create=Create\nxe.blog.categories.existingcategories=Existing categories\nxe.blog.categories.addcategory=Add a category\nxe.blog.categories.deleteselected=Delete selected categories\nxe.blog.manage.existing=Existing blogs\nxe.blog.manage.createnew=Create a new blog\nxe.blog.manage.nospace=No space provided. Please enter a valid space where the blog should be created.\nxe.blog.manage.space=Space:\nxe.blog.manage.title=Title:\nxe.blog.manage.blogtitle=Blog title\nxe.blog.manage.blogtype=Blog type:\nxe.blog.manage.inside=blog inside an existing space\nxe.blog.manage.main=blog as the main content of a space\nxe.blog.manage.create=Create\nxe.blog.migration.migrated=Migrated old blog article to the new blog application\nxe.blog.migration.updated=Updated\nxe.blog.migration.inspace=in space\nxe.blog.migration.skipping=Skipping protected page\nxe.blog.migration.done=Done.\nxe.blog.migration.backtoblog=Back to the blog\nxe.blog.migration.pleaseconfirm=Please confirm if you want to migrate old articles to the new blog application:\nxe.blog.migration.confirm=Confirm\nxe.blog.publisher.published=Published article\nxe.blog.recentposts.paneltitle=Recent Blog Posts\nxe.blog.unpublished.entries=Unpublished articles\nxe.blog.unpublished.viewall=View all\n\n#######################################\n## until 9.4-rc-1\n#######################################\ncore.menu.actions=Actions\ncore.menu.moreactions=More actions\n\n#######################################\n## until 9.5-rc-1\n#######################################\ncore.delete.confirm.yes=Yes, please delete this page\ncore.delete.confirm.no=No, take me back!\n\n#######################################\n## until 9.7-rc-1\n#######################################\n\n# Attachment Index\nplatform.index.attachments.doc.name=Page\nplatform.index.attachments.doc.space=Space\n#@deprecated platform.index.attachments.mimeType\nplatform.index.attachments.type=Type\n\n####################\n# Wiki Macro Bridge Module\n####################\n\nxe.wikimacrobridge.wikiMacros=Existing wiki macro definitions\nxe.wikimacrobridge.macroName=Name\nxe.wikimacrobridge.macroId=id\nxe.wikimacrobridge.macroDescription=Description\nxe.wikimacrobridge.macroVisibility=Visibility\nxe.wikimacrobridge.macroPage=Macro page\nxe.wikimacrobridge.noWikiMacro=There are no wiki macro defined in this wiki yet.\n\n#######################################\n## until 10.6-rc-1\n#######################################\ncore.shortcuts.edit.saveandcontinue=Alt+Shift+S\nxe.scheduler.job.name=Job name:\nxe.scheduler.job.description=Job description:\nxe.scheduler.job.expression=Job cron expression:\nxe.scheduler.job.script=Job script:\n\n#######################################\n## until 10.6\n#######################################\ncore.viewers.comments.permalink.hide=Hide\n\n#######################################\n## until 10.8-rc-1\n#######################################\nadmin.defaultwikinotinstalled=Your wiki seems empty. You may want to import the default XWiki Enterprise wiki which contains a set of useful pages: user profiles, recent activity, administration pages and many more. This wiki is distributed as a XAR file, you can download it from {0}.\n\n### Image captcha\ncore.captcha.image.label=Verification image\ncore.captcha.image.instruction=Please type in the word shown above\ncore.captcha.image.alternateText=There is supposed to be an image captcha here, you could refresh the page or press the {0} button to try getting another image.\n\n#######################################\n## until 10.8\n#######################################\n\n### Groups Administration Section\n#@deprecated xe.admin.groups.name\nxe.admin.groups.groupname=Group Name\n\n### Users Administration Section\nxe.admin.users.manage=Manage\nxe.admin.users.username=Username\nxe.admin.users.filter.username=Username filter\n#@deprecated xe.admin.users.first_name\nxe.admin.users.firstname=First name\nxe.admin.users.filter.firstname=First name filter\n#@deprecated xe.admin.users.last_name\nxe.admin.users.lastname=Last name\nxe.admin.users.filter.lastname=Last name filter\n\n#######################################\n## until 11.1-rc-1\n#######################################\nplatform.search.suggestSourceDocumentName=Page names\n\n#######################################\n## until 11.1\n#######################################\ncore.editors.class.switchClass.submit=Edit\ncore.editors.class.switchClass.warning=Unsaved changes will be lost when switching to another class.\n\n#######################################\n## until 11.4-rc-1\n#######################################\ncore.editors.save.conflictversion.rollbackmessage=The document has been modified since you last saved it. Please copy your changes and reload the page to get the latest version and reapply your changes.\ncore.editors.save.conflictversion.previousVersion=Your version of the document:\ncore.editors.save.conflictversion.latestVersion=Latest version of the document:\ncore.editors.save.conflictversion.diffLink=Click here to check out the changes made on the latest version since you started editing it.\n\n#######################################\n## until 11.6-rc-1\n#######################################\nauth_active_check=Check Active fields for user authentication\nXWiki.XWikiPreferences_auth_active_check=Authentication Active Check\n\n#######################################\n## until 11.8-rc-1\n#######################################\nxe.userdirectory.customizeColumnsTitle=Customize the columns to display\nxe.userdirectory.customizeAvailableColumnsLabel=Available columns\nxe.userdirectory.customizeAvailableColumnsHint=Columns that can be displayed in the user directory for each user.\nxe.userdirectory.customizeAddColumnButtonLabel=Add\nxe.userdirectory.customizeSelectedColumnsLabel=Selected columns\nxe.userdirectory.customizeSelectedColumnsHint=Space or newline separated list of columns, corresponding to properties of the [[XWiki.XWikiUsers]] class, to be displayed in the user directory. Duplicate columns are ignored.\n\n#######################################\n## until 11.9-rc-1\n#######################################\nplatform.core.profile.passwd.instructions=Your new password must be at least 6 characters long.\n\n#######################################\n## until 12.3-rc-1\n#######################################\ncore.viewers.information.parent=Parent\ncore.viewers.information.noParent=No parent\ncore.viewers.information.children=Children\ncore.viewers.information.noChildren=No children\ncore.viewers.information.creation=Created\ncore.viewers.information.creationData=by {0} on {1}\ncore.viewers.information.translationCreation=Translated into {0}\ncore.viewers.information.translationCreationData=by {0} on {1}\n\n#######################################\n## until 12.4-rc-1\n#######################################\ncore.editors.object.delete.confirm=Are you sure you want to delete this object? Canceling the modifications will not restore deleted objects.\n\n#######################################\n## until 12.10, 12.6.5, 11.10.12\n#######################################\ncore.viewers.jump.dialog.invalidNameError=Invalid page name. Valid names have the following format: Space.Page\ncore.viewers.jump.suggest.noResults=No pages found\n\n#######################################\n## until 13.2-rc-1\n#######################################\ncore.widgets.suggestPicker.deleteAll=Clear selection\ncore.widgets.suggestPicker.deleteAll.tooltip=Clear the list of selected items\ncore.widgets.suggestPicker.delete.tooltip=Remove this item from the list of selected items\n\ncore.widgets.userPicker.noResults=User not found\ncore.widgets.userPicker.scopeHint=Click to toggle between local and global scope\ncore.widgets.groupPicker.noResults=Group not found\n\n#######################################\n## until 12.10.5, 13.2RC1\n#######################################\n\nxe.admin.forgotUsername.result=Your username is: {0}\nxe.admin.forgotUsername.multipleResults=The following usernames are registered with this email address:\nxe.admin.forgotUsername.error.noAccount=No account is registered using this email address.\n\n#######################################\n## until 12.10.9, 13.6RC1, 13.4.1\n#######################################\nxe.admin.passwordReset.emailSent=An e-mail was sent to {0}. Please follow the instructions in that e-mail to complete the password reset procedure.\n\n#######################################\n## until 14.4.2, 14.5\n#######################################\ncore.delete.backlinksWarning=The following pages contain links to the current page:{0}After deleting this page, those links will point to an empty page.\n\n#######################################\n## until 14.9\n#######################################\ncore.action.upload.failure.maxSize=The wiki administrators have set a limit of {0} for attached files. Please make sure the size of the files you are trying to attach does not exceed this limit.\n\n#######################################\n## until 14.10\n#######################################\ncore.menu.export.pdf=Export as PDF\ncore.menu.export.odt=Export as ODT\ncore.menu.export.rtf=Export as RTF\ncore.menu.export.html=Export as HTML\ncore.menu.export.xar=Export as XAR\n\n#######################################\n## until 14.4.8, 14.10.2, 15.0RC1\n#######################################\ncore.delete.backlinksInfo=After deleting this page, the {0,choice,0#incoming links|1#incoming link|1<incoming links} will point to an empty page. To avoid this, you can select a new target.\n\n#######################################\n## until 14.10.2, 15.0RC1\n#######################################\nxe.officeimporter.import.targetspace=Target space\nxe.officeimporter.import.targetpage=Target page\nxe.officeimporter.import.styles=Styles\nxe.officeimporter.import.splitting=Splitting\nxe.officeimporter.import.help.target=Key-in target space and page name. Select \"Append result\" to append the result to an existing wiki page.\nxe.officeimporter.import.appendresult=Append result\nplatform.office.importDocumentOverwriteConfirmation=The target document exists. Are you sure you want to overwrite its content?\n\n## Used to indicate where deprecated keys end\n#@deprecatedend\n\n###############################################################################\n## Old but critical deprecated\n## translation keys that kept\n## for backward compatibility\n## (with custom skins generally)\n###############################################################################\n\n## Used to indicate where keys that does not need to be translated starts\n## l10n wiki used that to not import them for example\nnotranslationsmarker=notranslationsmarker\n\nhrtext=\nsigntext=\ncore.edit.wikiToolbar.signtext=\ncore.edit.wikiToolbar.hrtext=\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayInputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Named;\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.io.IOUtils;\nimport org.dom4j.Document;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.link.LinkException;\nimport org.xwiki.link.LinkStore;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.user.UserConfiguration;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.user.UserReferenceSerializer;\n\nimport com.xpn.xwiki.XWikiConstant;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.internal.doc.XWikiAttachmentList;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.StringProperty;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.component.XWikiDocumentFilterUtilsComponentList;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\nimport com.xpn.xwiki.validation.XWikiValidationInterface;\nimport com.xpn.xwiki.web.EditForm;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link XWikiDocument}.\n * \n * @version $Id$\n */\n@OldcoreTest\n@ReferenceComponentList\n@XWikiDocumentFilterUtilsComponentList\npublic class XWikiDocumentMockitoTest\n{\n    private static final String DOCWIKI = \"wiki\";\n\n    private static final String DOCSPACE = \"space\";\n\n    private static final String DOCNAME = \"page\";\n\n    private static final DocumentReference DOCUMENT_REFERENCE = new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME);\n\n    private static final DocumentReference CLASS_REFERENCE = DOCUMENT_REFERENCE;\n\n    @MockComponent\n    @Named(\"document\")\n    private UserReferenceSerializer<DocumentReference> documentReferenceUserReferenceSerializer;\n\n    @MockComponent\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> userReferenceDocumentReferenceResolver;\n\n    @MockComponent\n    private UserConfiguration userConfiguration;\n\n    @MockComponent\n    @Named(\"compactwiki/document\")\n    private UserReferenceSerializer<String> compactWikiUserReferenceSerializer;\n\n    @MockComponent\n    private LinkStore linkStore;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    /**\n     * The object being tested.\n     */\n    private XWikiDocument document;\n\n    private BaseClass baseClass;\n\n    private BaseObject baseObject;\n\n    private BaseObject baseObject2;\n\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    private List<XWikiAttachment> attachmentList;\n\n    @BeforeEach\n    void beforeEach() throws Exception\n    {\n        // Activate programming rights in order to be able to call com.xpn.xwiki.api.Document#getDocument().\n        when(this.oldcore.getMockRightService().hasProgrammingRights(this.oldcore.getXWikiContext())).thenReturn(true);\n\n        this.document = new XWikiDocument(DOCUMENT_REFERENCE);\n        this.document.setSyntax(Syntax.PLAIN_1_0);\n        this.attachmentList = this.document.getAttachmentList();\n        this.baseClass = this.document.getXClass();\n        this.baseClass.addTextField(\"string\", \"String\", 30);\n        this.baseClass.addTextAreaField(\"area\", \"Area\", 10, 10);\n        this.baseClass.addTextAreaField(\"puretextarea\", \"Pure text area\", 10, 10);\n        // set the text areas an non interpreted content\n        ((TextAreaClass) this.baseClass.getField(\"puretextarea\")).setContentType(\"puretext\");\n        this.baseClass.addPasswordField(\"passwd\", \"Password\", 30);\n        this.baseClass.addBooleanField(\"boolean\", \"Boolean\", \"yesno\");\n        this.baseClass.addNumberField(\"int\", \"Int\", 10, \"integer\");\n        this.baseClass.addStaticListField(\"stringlist\", \"StringList\", 1, true, \"value1, value2\");\n\n        this.baseObject = this.document.newXObject(CLASS_REFERENCE, this.oldcore.getXWikiContext());\n        this.baseObject.setStringValue(\"string\", \"string\");\n        this.baseObject.setLargeStringValue(\"area\", \"area\");\n        this.baseObject.setLargeStringValue(\"puretextarea\", \"puretextarea\");\n        this.baseObject.setStringValue(\"passwd\", \"passwd\");\n        this.baseObject.setIntValue(\"boolean\", 1);\n        this.baseObject.setIntValue(\"int\", 42);\n        this.baseObject.setStringListValue(\"stringlist\", Arrays.asList(\"VALUE1\", \"VALUE2\"));\n\n        this.baseObject2 = this.baseObject.clone();\n        this.document.addXObject(this.baseObject2);\n\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        this.defaultEntityReferenceSerializer =\n            this.oldcore.getMocker().getInstance(EntityReferenceSerializer.TYPE_STRING);\n\n        this.oldcore.getXWikiContext().setWikiId(DOCWIKI);\n\n        // Reset the cached (static) MetaClass instance because it may have been initialized during the execution of the\n        // previous test classes, so before the StaticListMetaClass component needed by this test class was loaded.\n        MetaClass.setMetaClass(null);\n\n        when(this.userConfiguration.getStoreHint()).thenReturn(\"document\");\n    }\n\n    @Test\n    void getChildrenReferences() throws Exception\n    {\n        Query query = mock(Query.class);\n        when(this.oldcore.getQueryManager().createQuery(any(), eq(Query.XWQL))).thenReturn(query);\n\n        QueryFilter hiddenFilter = this.oldcore.getMocker().registerMockComponent(QueryFilter.class, \"hidden\");\n\n        when(query.setLimit(7)).thenReturn(query);\n\n        List<String> result = Arrays.asList(\"X.y\", \"A.b\");\n        when(query.<String>execute()).thenReturn(result);\n\n        List<DocumentReference> childrenReferences =\n            document.getChildrenReferences(7, 3, this.oldcore.getXWikiContext());\n\n        verify(query).addFilter(hiddenFilter);\n        verify(query).setLimit(7);\n        verify(query).setOffset(3);\n\n        assertEquals(2, childrenReferences.size());\n        assertEquals(new DocumentReference(\"wiki\", \"X\", \"y\"), childrenReferences.get(0));\n        assertEquals(new DocumentReference(\"wiki\", \"A\", \"b\"), childrenReferences.get(1));\n    }\n\n    /**\n     * Generate a fake map for the request used in the tests of {@link #readObjectsFromForm()} and\n     * {@link #readObjectsFromFormUpdateOrCreate()}.\n     * \n     * @return Map of fake parameters which should test every cases\n     */\n    private Map<String, String[]> generateFakeRequestMap()\n    {\n        Map<String, String[]> parameters = new HashMap<>();\n        // Testing update of values in existing object with existing properties\n        String[] string1 = {\"bloublou\"};\n        parameters.put(\"space.page_0_string\", string1);\n        String[] int1 = {\"7\"};\n        parameters.put(\"space.page_1_int\", int1);\n        // Testing creation and update of an object's properties when object\n        // doesn't exist\n        String[] string2 = {\"blabla\"};\n        String[] int2 = {\"13\"};\n        parameters.put(\"space.page_3_string\", string2);\n        parameters.put(\"space.page_3_int\", int2);\n        // Testing that objects with non-following number is not created\n        parameters.put(\"space.page_42_string\", string1);\n        parameters.put(\"space.page_42_int\", int1);\n        // Testing that invalid parameter are ignored\n        parameters.put(\"invalid\", new String[] {\"whatever\"});\n        // Testing that invalid xclass page are ignored\n        parameters.put(\"InvalidSpace.InvalidPage_0_string\", new String[] {\"whatever\"});\n        // Testing that an invalid number is ignored (first should be ignored by\n        // regexp parser, second by an exception)\n        parameters.put(\"space.page_notANumber_string\", new String[] {\"whatever\"});\n        parameters.put(\"space.page_9999999999_string\", new String[] {\"whatever\"});\n        return parameters;\n    }\n\n    /**\n     * Generate the fake class that is used for the test of {@link #readObjectsFromForm()} and\n     * {@link #readObjectsFromFormUpdateOrCreate()}.\n     * \n     * @return The fake BaseClass\n     */\n    private BaseClass generateFakeClass()\n    {\n        BaseClass baseClass = this.document.getXClass();\n        baseClass.addTextField(\"string\", \"String\", 30);\n        baseClass.addTextAreaField(\"area\", \"Area\", 10, 10);\n        baseClass.addTextAreaField(\"puretextarea\", \"Pure text area\", 10, 10);\n        // set the text areas an non interpreted content\n        ((TextAreaClass) baseClass.getField(\"puretextarea\")).setContentType(\"puretext\");\n        baseClass.addPasswordField(\"passwd\", \"Password\", 30);\n        baseClass.addBooleanField(\"boolean\", \"Boolean\", \"yesno\");\n        baseClass.addNumberField(\"int\", \"Int\", 10, \"integer\");\n        baseClass.addStaticListField(\"stringlist\", \"StringList\", \"value1, value2\");\n\n        return baseClass;\n    }\n\n    /**\n     * Generate 2 clones of a fake object in the document\n     * \n     * @return Return the reference of the first clone\n     */\n    private void generateFakeObjects()\n    {\n        BaseObject baseObject = null, baseObject2 = null, baseObject3 = null;\n        try {\n            baseObject = this.document.newXObject(this.document.getDocumentReference(), this.oldcore.getXWikiContext());\n            baseObject2 =\n                this.document.newXObject(this.document.getDocumentReference(), this.oldcore.getXWikiContext());\n            baseObject3 =\n                this.document.newXObject(this.document.getDocumentReference(), this.oldcore.getXWikiContext());\n        } catch (XWikiException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            return;\n        }\n        baseObject.setStringValue(\"string\", \"string\");\n        baseObject.setIntValue(\"int\", 42);\n        baseObject2.setStringValue(\"string\", \"string2\");\n        baseObject2.setIntValue(\"int\", 42);\n        baseObject3.setStringValue(\"string\", \"string3\");\n        baseObject3.setIntValue(\"int\", 42);\n    }\n\n    /**\n     * Unit test for {@link XWikiDocument#readObjectsFromForm(EditForm, XWikiContext)}.\n     */\n    @Test\n    void readObjectsFromForm() throws Exception\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        MockitoComponentManager mocker = this.oldcore.getMocker();\n        XWikiContext context = this.oldcore.getXWikiContext();\n        DocumentReferenceResolver<String> documentReferenceResolverString =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        // Entity Reference resolver is used in <BaseObject>.getXClass()\n        DocumentReferenceResolver<EntityReference> documentReferenceResolverEntity =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n        EntityReferenceSerializer<String> entityReferenceResolver =\n            mocker.registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n\n        Map<String, String[]> parameters = generateFakeRequestMap();\n        BaseClass baseClass = generateFakeClass();\n        generateFakeObjects();\n\n        when(request.getParameterMap()).thenReturn(parameters);\n\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"space\", \"page\");\n        // This entity resolver with this 'resolve' method is used in\n        // <BaseCollection>.getXClassReference()\n        when(documentReferenceResolverEntity.resolve(any(EntityReference.class), any(DocumentReference.class)))\n            .thenReturn(this.document.getDocumentReference());\n        when(documentReferenceResolverString.resolve(\"space.page\")).thenReturn(documentReference);\n        when(entityReferenceResolver.serialize(any(EntityReference.class))).thenReturn(\"space.page\");\n\n        EditForm eform = new EditForm();\n        eform.setRequest(request);\n        document.readObjectsFromForm(eform, context);\n\n        assertEquals(3, this.document.getXObjectSize(baseClass.getDocumentReference()));\n        assertEquals(\"string\", this.document.getXObject(baseClass.getDocumentReference(), 0).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 0).getIntValue(\"int\"));\n        assertEquals(\"string2\", this.document.getXObject(baseClass.getDocumentReference(), 1).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 1).getIntValue(\"int\"));\n        assertEquals(\"string3\", this.document.getXObject(baseClass.getDocumentReference(), 2).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 2).getIntValue(\"int\"));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 3));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 42));\n    }\n\n    /**\n     * Unit test for {@link XWikiDocument#readObjectsFromFormUpdateOrCreate(EditForm, XWikiContext)} .\n     */\n    @Test\n    void readObjectsFromFormUpdateOrCreate() throws Exception\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        MockitoComponentManager mocker = this.oldcore.getMocker();\n        XWikiContext context = this.oldcore.getXWikiContext();\n        DocumentReferenceResolver<String> documentReferenceResolverString =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        // Entity Reference resolver is used in <BaseObject>.getXClass()\n        DocumentReferenceResolver<EntityReference> documentReferenceResolverEntity =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n\n        Map<String, String[]> parameters = generateFakeRequestMap();\n        BaseClass baseClass = generateFakeClass();\n        generateFakeObjects();\n        EditForm eform = new EditForm();\n\n        when(request.getParameter(\"objectPolicy\")).thenReturn(\"updateOrCreate\");\n        when(request.getParameterMap()).thenReturn(parameters);\n        when(documentReferenceResolverString.resolve(\"space.page\")).thenReturn(this.document.getDocumentReference());\n        when(documentReferenceResolverString.resolve(\"InvalidSpace.InvalidPage\"))\n            .thenReturn(new DocumentReference(\"wiki\", \"InvalidSpace\", \"InvalidPage\"));\n        // This entity resolver with this 'resolve' method is used in\n        // <BaseCollection>.getXClassReference()\n        when(documentReferenceResolverEntity.resolve(any(EntityReference.class), any(DocumentReference.class)))\n            .thenReturn(this.document.getDocumentReference());\n        doReturn(this.document).when(this.oldcore.getSpyXWiki()).getDocument(this.document.getDocumentReference(),\n            context);\n\n        eform.setRequest(request);\n        eform.readRequest();\n        this.document.readObjectsFromFormUpdateOrCreate(eform, context);\n\n        assertEquals(43, this.document.getXObjectSize(baseClass.getDocumentReference()));\n        assertEquals(\"bloublou\",\n            this.document.getXObject(baseClass.getDocumentReference(), 0).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 0).getIntValue(\"int\"));\n        assertEquals(\"string2\", this.document.getXObject(baseClass.getDocumentReference(), 1).getStringValue(\"string\"));\n        assertEquals(7, this.document.getXObject(baseClass.getDocumentReference(), 1).getIntValue(\"int\"));\n        assertEquals(\"string3\", this.document.getXObject(baseClass.getDocumentReference(), 2).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 2).getIntValue(\"int\"));\n        assertNotNull(this.document.getXObject(baseClass.getDocumentReference(), 3));\n        assertEquals(\"blabla\", this.document.getXObject(baseClass.getDocumentReference(), 3).getStringValue(\"string\"));\n        assertEquals(13, this.document.getXObject(baseClass.getDocumentReference(), 3).getIntValue(\"int\"));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 4));\n        assertNotNull(this.document.getXObject(baseClass.getDocumentReference(), 42));\n        assertEquals(\"bloublou\",\n            this.document.getXObject(baseClass.getDocumentReference(), 42).getStringValue(\"string\"));\n        assertEquals(7, this.document.getXObject(baseClass.getDocumentReference(), 42).getIntValue(\"int\"));\n    }\n\n    /**\n     * Unit test for {@link XWikiDocument#readAddedUpdatedAndRemovedObjectsFromForm(EditForm, XWikiContext)}.\n     */\n    @Test\n    void readAddedUpdatedAndRemovedObjectsFromForm() throws Exception\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        MockitoComponentManager mocker = this.oldcore.getMocker();\n        XWikiContext context = this.oldcore.getXWikiContext();\n        DocumentReferenceResolver<String> documentReferenceResolverString =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        // Entity Reference resolver is used in <BaseObject>.getXClass()\n        DocumentReferenceResolver<EntityReference> documentReferenceResolverEntity =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n\n        Map<String, String[]> parameters = generateFakeRequestMap();\n        BaseClass baseClass = generateFakeClass();\n        generateFakeObjects();\n        EditForm eform = new EditForm();\n\n        when(request.getParameterValues(\"addedObjects\")).thenReturn(new String[] {\"space.page_1\", \"space.page_42\"});\n        when(request.getParameterValues(\"deletedObjects\")).thenReturn(new String[] {\"space.page_2\"});\n        when(request.getParameterMap()).thenReturn(parameters);\n        when(documentReferenceResolverString.resolve(\"space.page\")).thenReturn(this.document.getDocumentReference());\n        when(documentReferenceResolverString.resolve(\"InvalidSpace.InvalidPage\"))\n            .thenReturn(new DocumentReference(\"wiki\", \"InvalidSpace\", \"InvalidPage\"));\n        // This entity resolver with this 'resolve' method is used in\n        // <BaseCollection>.getXClassReference()\n        when(documentReferenceResolverEntity.resolve(any(EntityReference.class), any(DocumentReference.class)))\n            .thenReturn(this.document.getDocumentReference());\n        doReturn(this.document).when(this.oldcore.getSpyXWiki()).getDocument(this.document.getDocumentReference(),\n            context);\n\n        eform.setRequest(request);\n        eform.readRequest();\n        this.document.readAddedUpdatedAndRemovedObjectsFromForm(eform, context);\n\n        assertEquals(43, this.document.getXObjectSize(baseClass.getDocumentReference()));\n        assertEquals(\"bloublou\",\n            this.document.getXObject(baseClass.getDocumentReference(), 0).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 0).getIntValue(\"int\"));\n        assertEquals(\"string2\", this.document.getXObject(baseClass.getDocumentReference(), 1).getStringValue(\"string\"));\n        assertEquals(7, this.document.getXObject(baseClass.getDocumentReference(), 1).getIntValue(\"int\"));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 2));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 3));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 4));\n        assertNotNull(this.document.getXObject(baseClass.getDocumentReference(), 42));\n        assertEquals(\"bloublou\",\n            this.document.getXObject(baseClass.getDocumentReference(), 42).getStringValue(\"string\"));\n        assertEquals(7, this.document.getXObject(baseClass.getDocumentReference(), 42).getIntValue(\"int\"));\n    }\n\n    @Test\n    void testDeprecatedConstructors()\n    {\n        DocumentReference defaultReference = new DocumentReference(\"xwiki\", \"Main\", \"WebHome\");\n\n        XWikiDocument doc = new XWikiDocument(null);\n        assertEquals(defaultReference, doc.getDocumentReference());\n\n        doc = new XWikiDocument();\n        assertEquals(defaultReference, doc.getDocumentReference());\n\n        doc = new XWikiDocument(\"notused\", \"space.page\");\n        assertEquals(\"space\", doc.getSpaceName());\n        assertEquals(\"page\", doc.getPageName());\n        assertEquals(this.oldcore.getXWikiContext().getWikiId(), doc.getWikiName());\n\n        doc = new XWikiDocument(\"space\", \"page\");\n        assertEquals(\"space\", doc.getSpaceName());\n        assertEquals(\"page\", doc.getPageName());\n        assertEquals(this.oldcore.getXWikiContext().getWikiId(), doc.getWikiName());\n\n        doc = new XWikiDocument(\"wiki2\", \"space\", \"page\");\n        assertEquals(\"space\", doc.getSpaceName());\n        assertEquals(\"page\", doc.getPageName());\n        assertEquals(\"wiki2\", doc.getWikiName());\n\n        doc = new XWikiDocument(\"wiki2\", \"notused\", \"notused:space.page\");\n        assertEquals(\"space\", doc.getSpaceName());\n        assertEquals(\"page\", doc.getPageName());\n        assertEquals(\"wiki2\", doc.getWikiName());\n    }\n\n    @Test\n    void testMinorMajorVersions()\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n\n        // there is no version in doc yet, so 1.1\n        assertEquals(\"1.1\", this.document.getVersion());\n\n        this.document.setMinorEdit(false);\n        this.document.incrementVersion();\n        // no version => incrementVersion sets 1.1\n        assertEquals(\"1.1\", this.document.getVersion());\n\n        this.document.setMinorEdit(false);\n        this.document.incrementVersion();\n        // increment major version\n        assertEquals(\"2.1\", this.document.getVersion());\n\n        this.document.setMinorEdit(true);\n        this.document.incrementVersion();\n        // increment minor version\n        assertEquals(\"2.2\", this.document.getVersion());\n    }\n\n    @Test\n    void testGetPreviousVersion() throws XWikiException\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n\n        Date now = new Date();\n        XWikiDocumentArchive archiveDoc = new XWikiDocumentArchive(this.document.getId());\n        this.document.setDocumentArchive(archiveDoc);\n\n        assertEquals(\"1.1\", this.document.getVersion());\n        assertNull(this.document.getPreviousVersion());\n\n        this.document.incrementVersion();\n        archiveDoc.updateArchive(this.document, \"Admin\", now, \"\", this.document.getRCSVersion(),\n            this.oldcore.getXWikiContext());\n        assertEquals(\"1.1\", this.document.getVersion());\n        assertNull(this.document.getPreviousVersion());\n\n        this.document.setMinorEdit(true);\n        this.document.incrementVersion();\n        archiveDoc.updateArchive(this.document, \"Admin\", now, \"\", this.document.getRCSVersion(),\n            this.oldcore.getXWikiContext());\n        assertEquals(\"1.2\", this.document.getVersion());\n        assertEquals(\"1.1\", this.document.getPreviousVersion());\n\n        this.document.setMinorEdit(false);\n        this.document.incrementVersion();\n        archiveDoc.updateArchive(this.document, \"Admin\", now, \"\", this.document.getRCSVersion(),\n            this.oldcore.getXWikiContext());\n        assertEquals(\"2.1\", this.document.getVersion());\n        assertEquals(\"1.2\", this.document.getPreviousVersion());\n\n        this.document.setMinorEdit(true);\n        this.document.incrementVersion();\n        archiveDoc.updateArchive(this.document, \"Admin\", now, \"\", this.document.getRCSVersion(),\n            this.oldcore.getXWikiContext());\n        assertEquals(\"2.2\", this.document.getVersion());\n        assertEquals(\"2.1\", this.document.getPreviousVersion());\n\n        archiveDoc.resetArchive();\n\n        assertEquals(\"2.2\", this.document.getVersion());\n        assertNull(this.document.getPreviousVersion());\n    }\n\n    @Test\n    void testCloneNullObjects()\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"wiki\", DOCSPACE, DOCNAME));\n\n        EntityReference relativeClassReference =\n            new EntityReference(DOCNAME, EntityType.DOCUMENT, new EntityReference(DOCSPACE, EntityType.SPACE));\n        DocumentReference classReference = new DocumentReference(\"wiki\", DOCSPACE, DOCNAME);\n        DocumentReference duplicatedClassReference = new DocumentReference(\"otherwiki\", DOCSPACE, DOCNAME);\n\n        // no object\n        XWikiDocument clonedDocument = document.clone();\n        assertTrue(clonedDocument.getXObjects().isEmpty());\n\n        XWikiDocument duplicatedDocument = document.duplicate(new DocumentReference(\"otherwiki\", DOCSPACE, DOCNAME));\n        assertTrue(duplicatedDocument.getXObjects().isEmpty());\n\n        // 1 null object\n\n        document.addXObject(classReference, null);\n\n        clonedDocument = document.clone();\n        assertEquals(1, clonedDocument.getXObjects(classReference).size());\n        assertEquals(document.getXObjects(classReference), clonedDocument.getXObjects(classReference));\n\n        duplicatedDocument = document.duplicate(new DocumentReference(\"otherwiki\", DOCSPACE, DOCNAME));\n        assertTrue(duplicatedDocument.getXObjects().isEmpty());\n\n        // 1 null object and 1 object\n\n        BaseObject object = new BaseObject();\n        object.setXClassReference(relativeClassReference);\n        document.addXObject(object);\n\n        clonedDocument = document.clone();\n        assertEquals(2, clonedDocument.getXObjects(classReference).size());\n        assertEquals(document.getXObjects(classReference), clonedDocument.getXObjects(classReference));\n\n        duplicatedDocument = document.duplicate(new DocumentReference(\"otherwiki\", DOCSPACE, DOCNAME));\n        assertEquals(2, duplicatedDocument.getXObjects(duplicatedClassReference).size());\n    }\n\n    @Test\n    void testToStringReturnsFullName()\n    {\n        assertEquals(\"space.page\", this.document.toString());\n        assertEquals(\"Main.WebHome\", new XWikiDocument().toString());\n    }\n\n    @Test\n    void testCloneSaveVersions()\n    {\n        XWikiDocument doc1 = new XWikiDocument(new DocumentReference(\"qwe\", \"qwe\", \"qwe\"));\n        XWikiDocument doc2 = doc1.clone();\n        doc1.incrementVersion();\n        doc2.incrementVersion();\n        assertEquals(doc1.getVersion(), doc2.getVersion());\n    }\n\n    @Test\n    void testAddObject() throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"test\", \"test\", \"document\"));\n        BaseObject object = BaseClass.newCustomClassInstance(\"XWiki.XWikiUsers\", this.oldcore.getXWikiContext());\n        doc.addObject(\"XWiki.XWikiUsers\", object);\n        assertEquals(doc.getFullName(), object.getName(), \"XWikiDocument.addObject does not set the object's name\");\n    }\n\n    @Test\n    void testObjectNumbersAfterXMLRoundrip() throws XWikiException\n    {\n        String wiki = oldcore.getXWikiContext().getWikiId();\n\n        XWikiDocument tagDocument = new XWikiDocument(new DocumentReference(wiki, \"XWiki\", \"TagClass\"));\n        BaseClass tagClass = tagDocument.getXClass();\n        tagClass.addStaticListField(XWikiConstant.TAG_CLASS_PROP_TAGS, \"Tags\", 30, true, \"\", \"checkbox\");\n        this.oldcore.getSpyXWiki().saveDocument(tagDocument, this.oldcore.getXWikiContext());\n\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(wiki, \"test\", \"document\"));\n        doReturn(\"iso-8859-1\").when(this.oldcore.getSpyXWiki()).getEncoding();\n\n        BaseObject object1 = doc.newXObject(tagDocument.getDocumentReference(), this.oldcore.getXWikiContext());\n        BaseObject object2 = doc.newXObject(tagDocument.getDocumentReference(), this.oldcore.getXWikiContext());\n        BaseObject object3 = doc.newXObject(tagDocument.getDocumentReference(), this.oldcore.getXWikiContext());\n\n        // Remove first object\n        doc.removeXObject(object1);\n\n        String docXML = doc.toXML(this.oldcore.getXWikiContext());\n        XWikiDocument docFromXML = new XWikiDocument(doc.getDocumentReference());\n        docFromXML.fromXML(docXML);\n\n        List<BaseObject> objects = doc.getXObjects(tagDocument.getDocumentReference());\n        List<BaseObject> objectsFromXML = docFromXML.getXObjects(tagDocument.getDocumentReference());\n\n        assertNotNull(objects);\n        assertNotNull(objectsFromXML);\n\n        assertTrue(objects.size() == objectsFromXML.size());\n\n        for (int i = 0; i < objects.size(); i++) {\n            if (objects.get(i) == null) {\n                assertNull(objectsFromXML.get(i));\n            } else {\n                assertTrue(objects.get(i).getNumber() == objectsFromXML.get(i).getNumber());\n            }\n        }\n    }\n\n    @Test\n    void testGetXObjectWithObjectReference()\n    {\n        assertSame(this.baseObject, this.document.getXObject(this.baseObject.getReference()));\n\n        assertSame(this.baseObject,\n            this.document.getXObject(new ObjectReference(\n                this.defaultEntityReferenceSerializer.serialize(this.baseObject.getXClassReference()),\n                this.document.getDocumentReference())));\n    }\n\n    @Test\n    void testGetXObjectWithNumber()\n    {\n        assertSame(this.baseObject, this.document.getXObject(CLASS_REFERENCE, this.baseObject.getNumber()));\n        assertSame(this.baseObject2, this.document.getXObject(CLASS_REFERENCE, this.baseObject2.getNumber()));\n        assertSame(this.baseObject,\n            this.document.getXObject((EntityReference) CLASS_REFERENCE, this.baseObject.getNumber()));\n        assertSame(this.baseObject2,\n            this.document.getXObject((EntityReference) CLASS_REFERENCE, this.baseObject2.getNumber()));\n    }\n\n    @Test\n    void testGetXObjectCreateWithNumber() throws XWikiException\n    {\n        assertSame(this.baseObject, this.document.getXObject(CLASS_REFERENCE, this.baseObject.getNumber(), true,\n            this.oldcore.getXWikiContext()));\n        assertSame(this.baseObject2, this.document.getXObject(CLASS_REFERENCE, this.baseObject2.getNumber(), true,\n            this.oldcore.getXWikiContext()));\n        assertSame(this.baseObject, this.document.getXObject((EntityReference) CLASS_REFERENCE,\n            this.baseObject.getNumber(), true, this.oldcore.getXWikiContext()));\n        assertSame(this.baseObject2, this.document.getXObject((EntityReference) CLASS_REFERENCE,\n            this.baseObject2.getNumber(), true, this.oldcore.getXWikiContext()));\n\n        BaseObject newObject = this.document.getXObject(CLASS_REFERENCE, 42, true, this.oldcore.getXWikiContext());\n        assertNotSame(this.baseObject, newObject);\n        assertNotSame(this.baseObject2, newObject);\n        assertEquals(42, newObject.getNumber());\n        assertSame(newObject, this.document.getXObject(CLASS_REFERENCE, newObject.getNumber()));\n    }\n\n    @Test\n    void testGetXObjectsWhenClassDoesNotExist()\n    {\n        assertEquals(Collections.emptyList(),\n            this.document.getXObjects(new DocumentReference(\"not\", \"existing\", \"class\")));\n    }\n\n    @Test\n    void testSetXObjectswithPreviousObject()\n    {\n        BaseObject object = new BaseObject();\n        object.setXClassReference(this.baseObject.getXClassReference());\n        this.document.addXObject(object);\n\n        this.document.setXObjects(this.baseObject.getXClassReference(), Arrays.asList(object));\n\n        assertEquals(Arrays.asList(object), this.document.getXObjects(this.baseObject.getXClassReference()));\n    }\n\n    @Test\n    void testSetXObjectWhithNoPreviousObject()\n    {\n        XWikiDocument document = new XWikiDocument(this.document.getDocumentReference());\n\n        document.setXObject(this.baseObject.getXClassReference(), 0, this.baseObject);\n\n        assertEquals(Arrays.asList(this.baseObject), document.getXObjects(this.baseObject.getXClassReference()));\n    }\n\n    /**\n     * Test that the parent remain the same relative value whatever the context.\n     */\n    @Test\n    void testGetParent()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n\n        assertEquals(\"\", doc.getParent());\n        doc.setParent(null);\n        assertEquals(\"\", doc.getParent());\n\n        doc.setParent(\"page\");\n        assertEquals(\"page\", doc.getParent());\n\n        this.oldcore.getXWikiContext().setWikiId(\"otherwiki\");\n        assertEquals(\"page\", doc.getParent());\n\n        doc.setDocumentReference(new DocumentReference(\"otherwiki\", \"otherspace\", \"otherpage\"));\n        assertEquals(\"page\", doc.getParent());\n    }\n\n    @Test\n    void testGetParentReference()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n\n        assertNull(doc.getParentReference());\n\n        doc.setParent(\"parentpage\");\n\n        // ////////////////////////////////////////////////////////////////\n        // The following tests are checking that document reference cache is properly cleaned something could make the\n        // parent change\n\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace\", \"parentpage\"), doc.getParentReference());\n\n        doc.setName(\"docpage2\");\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace\", \"parentpage\"), doc.getParentReference());\n\n        doc.setSpace(\"docspace2\");\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace2\", \"parentpage\"), doc.getParentReference());\n\n        doc.setDatabase(\"docwiki2\");\n        assertEquals(new DocumentReference(\"docwiki2\", \"docspace2\", \"parentpage\"), doc.getParentReference());\n\n        doc.setDocumentReference(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace\", \"parentpage\"), doc.getParentReference());\n\n        doc.setFullName(\"docwiki2:docspace2.docpage2\", this.oldcore.getXWikiContext());\n        assertEquals(new DocumentReference(\"docwiki2\", \"docspace2\", \"parentpage\"), doc.getParentReference());\n\n        doc.setParent(\"parentpage2\");\n        assertEquals(new DocumentReference(\"docwiki2\", \"docspace2\", \"parentpage2\"), doc.getParentReference());\n    }\n\n    @Test\n    void testSetRelativeParentReference()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n\n        doc.setParentReference(new EntityReference(\"docpage2\", EntityType.DOCUMENT));\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace\", \"docpage2\"), doc.getParentReference());\n        assertEquals(\"docpage2\", doc.getParent());\n    }\n\n    /**\n     * Verify that setting a new creator will create a new revision (we verify that that metadata dirty flag is set to\n     * true).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetCreatorReferenceSetsMetadataDirtyFlag()\n    {\n        // Make sure we set the flag to false to verify it's changed\n        this.document.setMetaDataDirty(false);\n\n        DocumentReference creator = new DocumentReference(\"Wiki\", \"XWiki\", \"Creator\");\n        when(this.userReferenceDocumentReferenceResolver.resolve(creator)).thenReturn(mock(UserReference.class));\n        this.document.setCreatorReference(creator);\n\n        assertEquals(true, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new creator that is the same as the currenet creator doesn't create a new revision (we\n     * verify that the metadata dirty flag is not set).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetCreatorReferenceWithSameCreatorDoesntSetMetadataDirtyFlag()\n    {\n        // Make sure we set the metadata dirty flag to false to verify it's not changed thereafter\n        DocumentReference creator = new DocumentReference(\"Wiki\", \"XWiki\", \"Creator\");\n        this.document.setCreatorReference(creator);\n        this.document.setMetaDataDirty(false);\n\n        // Set the creator with the same reference to verify it doesn't change the flag\n        this.document.setCreatorReference(new DocumentReference(\"Wiki\", \"XWiki\", \"Creator\"));\n\n        assertEquals(false, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new author will create a new revision (we verify that that metadata dirty flag is set to\n     * true).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetAuthorReferenceSetsMetadataDirtyFlag()\n    {\n        // Make sure we set the flag to false to verify it's changed\n        this.document.setMetaDataDirty(false);\n\n        DocumentReference author = new DocumentReference(\"Wiki\", \"XWiki\", \"Author\");\n        when(this.userReferenceDocumentReferenceResolver.resolve(author)).thenReturn(mock(UserReference.class));\n        this.document.setAuthorReference(author);\n\n        assertEquals(true, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new author that is the same as the currenet creator doesn't create a new revision (we\n     * verify that the metadata dirty flag is not set).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetAuthorReferenceWithSameAuthorDoesntSetMetadataDirtyFlag()\n    {\n        // Make sure we set the metadata dirty flag to false to verify it's not changed thereafter\n        DocumentReference author = new DocumentReference(\"Wiki\", \"XWiki\", \"Author\");\n        UserReference userReference = mock(UserReference.class);\n        when(this.documentReferenceUserReferenceSerializer.serialize(userReference)).thenReturn(author);\n        when(this.userReferenceDocumentReferenceResolver.resolve(author)).thenReturn(userReference);\n        this.document.setAuthorReference(author);\n        this.document.setMetaDataDirty(false);\n\n        // Set the author with the same reference to verify it doesn't change the flag\n        this.document.setAuthorReference(new DocumentReference(\"Wiki\", \"XWiki\", \"Author\"));\n\n        assertEquals(false, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new content author will create a new revision (we verify that that metadata dirty flag is\n     * set to true).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetContentAuthorReferenceSetsMetadataDirtyFlag()\n    {\n        // Make sure we set the flag to false to verify it's changed\n        this.document.setMetaDataDirty(false);\n\n        DocumentReference contentAuthor = new DocumentReference(\"Wiki\", \"XWiki\", \"ContentAuthor\");\n        when(this.userReferenceDocumentReferenceResolver.resolve(contentAuthor)).thenReturn(mock(UserReference.class));\n        this.document.setContentAuthorReference(contentAuthor);\n\n        assertEquals(true, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new content author that is the same as the currenet creator doesn't create a new revision\n     * (we verify that the metadata dirty flag is not set).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetContentAuthorReferenceWithSameContentAuthorDoesntSetMetadataDirtyFlag()\n    {\n        // Make sure we set the metadata dirty flag to false to verify it's not changed thereafter\n        DocumentReference contentAuthor = new DocumentReference(\"Wiki\", \"XWiki\", \"ContentAuthor\");\n        this.document.setContentAuthorReference(contentAuthor);\n        this.document.setMetaDataDirty(false);\n\n        // Set the content author with the same reference to verify it doesn't change the flag\n        this.document.setContentAuthorReference(new DocumentReference(\"Wiki\", \"XWiki\", \"ContentAuthor\"));\n\n        assertEquals(false, this.document.isMetaDataDirty());\n    }\n\n    @Test\n    void testSetContentSetsContentDirtyFlag()\n    {\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        this.document.setContent(\"something\");\n\n        assertTrue(this.document.isContentDirty());\n        assertFalse(this.document.isMetaDataDirty());\n    }\n\n    @Test\n    void testSetSameContentDoesNotSetContentDirtyFlag()\n    {\n        this.document.setContent(\"something\");\n        // Make sure we set the flag to false to verify it's changed\n        this.document.setContentDirty(false);\n\n        // Set the same content again.\n        this.document.setContent(\"something\");\n\n        assertFalse(this.document.isContentDirty());\n    }\n\n    @Test\n    void testModifyObjectsSetsOnlyMetadataDirtyFlag() throws Exception\n    {\n        DocumentReference classReference = this.document.getDocumentReference();\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // New objects.\n        BaseObject object = this.document.newXObject(classReference, this.oldcore.getXWikiContext());\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Set/add objects.\n        this.document.setXObject(0, object);\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Remove objects\n        this.document.removeXObject(object);\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n    }\n\n    @Test\n    void testModifyAttachmentsSetsOnlyMetadataDirtyFlag() throws Exception\n    {\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Add attachments.\n        XWikiAttachment attachment =\n            document.addAttachment(\"file\", new ByteArrayInputStream(new byte[] {}), this.oldcore.getXWikiContext());\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n        // Add attachments (2).\n        XWikiAttachment attachment2 =\n            document.addAttachment(\"file2\", new ByteArrayInputStream(new byte[] {}), this.oldcore.getXWikiContext());\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Modify attachment.\n        attachment.setContent(new ByteArrayInputStream(new byte[] {1, 2, 3}));\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Remove objects\n        this.document.removeAttachment(attachment);\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n    }\n\n    @Test\n    void testEqualsDatas()\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"wiki\", \"space\", \"page\"));\n        XWikiDocument otherDocument = document.clone();\n\n        assertTrue(document.equals(otherDocument));\n        assertTrue(document.equalsData(otherDocument));\n\n        otherDocument.setAuthorReference(new DocumentReference(\"wiki\", \"space\", \"otherauthor\"));\n        otherDocument.setContentAuthorReference(otherDocument.getAuthorReference());\n        otherDocument.setCreatorReference(otherDocument.getAuthorReference());\n        otherDocument.setVersion(\"42.0\");\n        otherDocument.setComment(\"other comment\");\n        otherDocument.setMinorEdit(true);\n\n        document.setMinorEdit(false);\n\n        assertFalse(document.equals(otherDocument));\n        assertTrue(document.equalsData(otherDocument));\n    }\n\n    @Test\n    void testEqualsAttachments() throws XWikiException\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"wiki\", \"space\", \"page\"));\n        XWikiDocument otherDocument = document.clone();\n\n        XWikiAttachment attachment = document.addAttachment(\"file\", new byte[] {1, 2}, this.oldcore.getXWikiContext());\n        XWikiAttachment otherAttachment =\n            otherDocument.addAttachment(\"file\", new byte[] {1, 2}, this.oldcore.getXWikiContext());\n\n        assertTrue(document.equals(otherDocument));\n        assertTrue(document.equalsData(otherDocument));\n\n        otherAttachment.setContent(new byte[] {1, 2, 3});\n\n        assertFalse(document.equals(otherDocument));\n        assertFalse(document.equalsData(otherDocument));\n    }\n\n    @Test\n    void testSetMetadataDirtyWhenAttachmenListChanges() throws XWikiException\n    {\n        XWikiDocument document = new XWikiDocument();\n\n        XWikiAttachment attachment = document.addAttachment(\"file\", new byte[] {1, 2}, this.oldcore.getXWikiContext());\n\n        // Force the metadata not dirty.\n        document.setMetaDataDirty(false);\n\n        List<XWikiAttachment> attachments = document.getAttachmentList();\n        // Modify (clear) the attachments list)\n        attachments.clear();\n\n        // Check that the the metadata is now dirty as a result.\n        assertTrue(document.isMetaDataDirty());\n\n        // Check adding to list\n        document.setMetaDataDirty(false);\n        attachments.add(new XWikiAttachment());\n        assertTrue(document.isMetaDataDirty());\n\n        // Check removing from the list\n        document.setMetaDataDirty(false);\n        attachments.remove(0);\n        assertTrue(document.isMetaDataDirty());\n    }\n\n    /**\n     * XWIKI-8463: Backwards compatibility issue with setting the same attachment list to a document\n     */\n    @Test\n    void testSetGetAttachmentList() throws Exception\n    {\n        String attachmentName1 = \"someFile.txt\";\n        String attachmentName2 = \"someOtherFile.txt\";\n        this.document.addAttachment(attachmentName1, new byte[0], this.oldcore.getXWikiContext());\n        this.document.addAttachment(attachmentName2, new byte[0], this.oldcore.getXWikiContext());\n\n        List<String> attachmentNames = new ArrayList<String>();\n\n        assertEquals(2, this.document.getAttachmentList().size());\n        for (XWikiAttachment attachment : this.document.getAttachmentList()) {\n            attachmentNames.add(attachment.getFilename());\n        }\n        assertTrue(attachmentNames.contains(attachmentName1));\n        assertTrue(attachmentNames.contains(attachmentName2));\n\n        // Set back the same list returned by the getter.\n        this.document.setAttachmentList(this.document.getAttachmentList());\n\n        // The result needs to stay the same.\n        assertEquals(2, this.document.getAttachmentList().size());\n        attachmentNames.clear();\n        for (XWikiAttachment attachment : this.document.getAttachmentList()) {\n            attachmentNames.add(attachment.getFilename());\n        }\n        assertTrue(attachmentNames.contains(attachmentName1));\n        assertTrue(attachmentNames.contains(attachmentName2));\n    }\n\n    /**\n     * Unit test for {@link XWikiDocument#readFromTemplate(DocumentReference, XWikiContext)}.\n     */\n    @Test\n    void testReadFromTemplate() throws Exception\n    {\n        XWikiContext xcontext = this.oldcore.getXWikiContext();\n\n        SpaceReference spaceReference = new SpaceReference(\"Space\", new WikiReference(\"wiki\"));\n        XWikiDocument template = new XWikiDocument(new DocumentReference(\"Template\", spaceReference));\n        template.setParentReference(new EntityReference(\"Parent\", EntityType.DOCUMENT, spaceReference));\n        template.setTitle(\"Enter title here\");\n        template.setSyntax(Syntax.XWIKI_2_0);\n        template.setContent(\"Enter content here\");\n\n        DocumentReference templateAuthor = new DocumentReference(\"test\", \"Users\", \"John\");\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"dd/MM/yyyy\");\n\n        XWikiAttachment aliceAttachment = new XWikiAttachment(template, \"alice.png\");\n        aliceAttachment.setContent(new ByteArrayInputStream(\"alice content\".getBytes()));\n        aliceAttachment.setVersion(\"2.3\");\n        aliceAttachment.setDate(simpleDateFormat.parse(\"12/03/2018\"));\n        aliceAttachment.setAuthorReference(templateAuthor);\n        template.setAttachment(aliceAttachment);\n\n        XWikiAttachment bobAttachment = new XWikiAttachment(template, \"bob.png\");\n        bobAttachment.setVersion(\"5.3\");\n        bobAttachment.setDate(simpleDateFormat.parse(\"25/5/2019\"));\n        bobAttachment.setAuthorReference(templateAuthor);\n        template.setAttachment(bobAttachment);\n\n        // Verify that the attachment content is loaded before being copied.\n        XWikiAttachmentStoreInterface attachmentContentStore = mock(XWikiAttachmentStoreInterface.class);\n        xcontext.getWiki().setDefaultAttachmentContentStore(attachmentContentStore);\n        doAnswer(invocation -> {\n            XWikiAttachment attachment = invocation.getArgument(0);\n            if (\"bob.png\".equals(attachment.getFilename())) {\n                XWikiAttachmentContent attachmentContent = new XWikiAttachmentContent(attachment);\n                attachmentContent.setContent(new ByteArrayInputStream(\"bob content\".getBytes()));\n                attachment.setAttachment_content(attachmentContent);\n            }\n            return null;\n        }).when(attachmentContentStore).loadAttachmentContent(any(XWikiAttachment.class), eq(xcontext), eq(true));\n\n        this.oldcore.getSpyXWiki().saveDocument(template, xcontext);\n\n        XWikiDocument target = new XWikiDocument(new DocumentReference(\"Page\", spaceReference));\n\n        DocumentReference targetAuthor = new DocumentReference(\"test\", \"Users\", \"Denis\");\n        xcontext.setUserReference(targetAuthor);\n\n        XWikiAttachment aliceModifiedAttachment = new XWikiAttachment(target, \"alice.png\");\n        aliceModifiedAttachment.setContent(new ByteArrayInputStream(\"alice modified content\".getBytes()));\n        aliceModifiedAttachment.setVersion(\"1.2\");\n        aliceModifiedAttachment.setDate(simpleDateFormat.parse(\"07/10/2020\"));\n        aliceModifiedAttachment.setAuthorReference(targetAuthor);\n        target.setAttachment(aliceModifiedAttachment);\n\n        XWikiAttachment carolAttachment = new XWikiAttachment(target, \"carol.png\");\n        carolAttachment.setContent(new ByteArrayInputStream(\"carol content\".getBytes()));\n        carolAttachment.setVersion(\"3.1\");\n        carolAttachment.setDate(simpleDateFormat.parse(\"13/11/2020\"));\n        carolAttachment.setAuthorReference(targetAuthor);\n        target.setAttachment(carolAttachment);\n\n        target.readFromTemplate(template.getDocumentReference(), xcontext);\n\n        assertEquals(template.getDocumentReference(), target.getTemplateDocumentReference());\n        assertEquals(template.getParentReference(), target.getParentReference());\n        assertEquals(template.getTitle(), target.getTitle());\n        assertEquals(template.getSyntax(), target.getSyntax());\n        assertEquals(template.getContent(), target.getContent());\n\n        assertEquals(3, target.getAttachmentList().size());\n        assertAttachment(\"alice modified content\", \"1.2\", targetAuthor, simpleDateFormat.parse(\"07/10/2020\"),\n            target.getAttachment(\"alice.png\"));\n        assertAttachment(\"bob content\", \"1.1\", targetAuthor, null, target.getAttachment(\"bob.png\"));\n        assertAttachment(\"carol content\", \"3.1\", targetAuthor, simpleDateFormat.parse(\"13/11/2020\"),\n            target.getAttachment(\"carol.png\"));\n    }\n\n    private void assertAttachment(String expectedContent, String expectedVersion,\n        DocumentReference expectedAuthorReference, Date expectedDate, XWikiAttachment actualAttachment) throws Exception\n    {\n        XWikiContext xcontext = this.oldcore.getXWikiContext();\n        assertEquals(expectedContent, IOUtils.toString(actualAttachment.getContentInputStream(xcontext), \"UTF-8\"));\n        assertEquals(expectedVersion, actualAttachment.getVersion());\n        assertEquals(expectedAuthorReference, actualAttachment.getAuthorReference());\n        if (expectedDate != null) {\n            assertEquals(expectedDate, actualAttachment.getDate());\n        } else {\n            // The expected date is pretty recent (no more than 5 seconds ago).\n            long delta = new Date().getTime() - actualAttachment.getDate().getTime();\n            assertTrue(delta < 5000);\n        }\n    }\n\n    @Test\n    void testResolveClassReference() throws Exception\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n\n        DocumentReference expected1 = new DocumentReference(\"docwiki\", \"XWiki\", \"docpage\");\n        assertEquals(expected1, doc.resolveClassReference(\"\"));\n\n        DocumentReference expected2 = new DocumentReference(\"docwiki\", \"XWiki\", \"page\");\n        assertEquals(expected2, doc.resolveClassReference(\"page\"));\n\n        DocumentReference expected3 = new DocumentReference(\"docwiki\", \"space\", \"page\");\n        assertEquals(expected3, doc.resolveClassReference(\"space.page\"));\n\n        DocumentReference expected4 = new DocumentReference(\"wiki\", \"space\", \"page\");\n        assertEquals(expected4, doc.resolveClassReference(\"wiki:space.page\"));\n    }\n\n    /**\n     * Verify that cloning objects modify their references to point to the document in which they are cloned into.\n     */\n    @Test\n    void testCloneObjectsHaveCorrectReference()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"somewiki\", \"somespace\", \"somepage\"));\n        doc.cloneXObjects(this.document);\n        assertTrue(doc.getXObjects().size() > 0);\n\n        // Verify that the object references point to the doc in which it's cloned.\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : doc.getXObjects().entrySet()) {\n            for (BaseObject baseObject : entry.getValue()) {\n                assertEquals(doc.getDocumentReference(), baseObject.getDocumentReference());\n            }\n        }\n    }\n\n    /**\n     * Verify that merging objects modify their references to point to the document in which they are cloned into and\n     * that GUID for merged objects are different from the original GUIDs.\n     */\n    @Test\n    void testMergeObjectsHaveCorrectReferenceAndDifferentGuids()\n    {\n        List<String> originalGuids = new ArrayList<String>();\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : this.document.getXObjects().entrySet()) {\n            for (BaseObject baseObject : entry.getValue()) {\n                originalGuids.add(baseObject.getGuid());\n            }\n        }\n\n        // Use a document from a different wiki to see if the class reference of the merged objects is adjusted:\n        // documents can't have objects of types defined in a different wiki.\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"somewiki\", \"somespace\", \"somepage\"));\n        doc.mergeXObjects(this.document);\n\n        assertTrue(doc.getXObjects().size() > 0);\n\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : doc.getXObjects().entrySet()) {\n            // Verify that the class reference and the target document reference have the same wiki component.\n            assertEquals(doc.getDocumentReference().getWikiReference(), entry.getKey().getWikiReference());\n            for (BaseObject baseObject : entry.getValue()) {\n                // Verify that the object references point to the doc in which it's cloned.\n                assertEquals(doc.getDocumentReference(), baseObject.getDocumentReference());\n                // Verify that GUIDs are not the same as the original ones\n                assertFalse(originalGuids.contains(baseObject.getGuid()), \"Non unique object GUID found!\");\n            }\n        }\n    }\n\n    /**\n     * Tests that objects are not copied again when {@link XWikiDocument#mergeXObjects(XWikiDocument)} is called twice.\n     */\n    @Test\n    void testMergeObjectsTwice()\n    {\n        // Make sure the target document and the template document are from different wikis.\n        XWikiDocument targetDoc = new XWikiDocument(new DocumentReference(\"someWiki\", \"someSpace\", \"somePage\"));\n\n        // Merge the objects.\n        targetDoc.mergeXObjects(this.document);\n\n        assertEquals(1, targetDoc.getXObjects().size());\n        assertEquals(0, targetDoc.getXObjectSize(CLASS_REFERENCE));\n        DocumentReference classReference = CLASS_REFERENCE.replaceParent(CLASS_REFERENCE.getWikiReference(),\n            targetDoc.getDocumentReference().getWikiReference());\n        assertEquals(2, targetDoc.getXObjectSize(classReference));\n\n        // Try to merge the objects again.\n        targetDoc.mergeXObjects(this.document);\n\n        // Check that the object from the template document was not copied again.\n        assertEquals(2, targetDoc.getXObjectSize(classReference));\n    }\n\n    /** Check that a new empty document has empty content (used to have a new line before 2.5). */\n    @Test\n    void testInitialContent()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"somewiki\", \"somespace\", \"somepage\"));\n        assertEquals(\"\", doc.getContent());\n    }\n\n    @Test\n    void testAuthorAfterDocumentCopy() throws XWikiException\n    {\n        DocumentReference author = new DocumentReference(\"Wiki\", \"XWiki\", \"Albatross\");\n        UserReference userReference = mock(UserReference.class);\n        when(this.documentReferenceUserReferenceSerializer.serialize(userReference)).thenReturn(author);\n        when(this.userReferenceDocumentReferenceResolver.resolve(author)).thenReturn(userReference);\n        this.document.setAuthorReference(author);\n        XWikiDocument copy =\n            this.document.copyDocument(this.document.getName() + \" Copy\", this.oldcore.getXWikiContext());\n\n        assertEquals(author, copy.getAuthorReference());\n    }\n\n    @Test\n    void testCreatorAfterDocumentCopy() throws XWikiException\n    {\n        UserReference userReference = mock(UserReference.class);\n        DocumentReference creator = new DocumentReference(\"Wiki\", \"XWiki\", \"Condor\");\n        when(this.userReferenceDocumentReferenceResolver.resolve(creator)).thenReturn(userReference);\n        when(this.documentReferenceUserReferenceSerializer.serialize(userReference)).thenReturn(creator);\n        this.document.setCreatorReference(creator);\n        XWikiDocument copy =\n            this.document.copyDocument(this.document.getName() + \" Copy\", this.oldcore.getXWikiContext());\n\n        assertEquals(creator, copy.getCreatorReference());\n    }\n\n    @Test\n    void testCreationDateAfterDocumentCopy() throws Exception\n    {\n        Date sourceCreationDate = this.document.getCreationDate();\n        Thread.sleep(1000);\n        XWikiDocument copy =\n            this.document.copyDocument(this.document.getName() + \" Copy\", this.oldcore.getXWikiContext());\n\n        assertEquals(sourceCreationDate, copy.getCreationDate());\n    }\n\n    @Test\n    void testObjectGuidsAfterDocumentCopy() throws Exception\n    {\n        assertTrue(this.document.getXObjects().size() > 0);\n\n        List<String> originalGuids = new ArrayList<String>();\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : this.document.getXObjects().entrySet()) {\n            for (BaseObject baseObject : entry.getValue()) {\n                originalGuids.add(baseObject.getGuid());\n            }\n        }\n\n        XWikiDocument copy =\n            this.document.copyDocument(this.document.getName() + \" Copy\", this.oldcore.getXWikiContext());\n\n        // Verify that the cloned objects have different GUIDs\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : copy.getXObjects().entrySet()) {\n            for (BaseObject baseObject : entry.getValue()) {\n                assertFalse(originalGuids.contains(baseObject.getGuid()), \"Non unique object GUID found!\");\n            }\n        }\n    }\n\n    @Test\n    void testRelativeObjectReferencesAfterDocumentCopy() throws Exception\n    {\n        XWikiDocument copy = this.document.copyDocument(new DocumentReference(\"copywiki\", \"copyspace\", \"copypage\"),\n            this.oldcore.getXWikiContext());\n\n        // Verify that the XObject's XClass reference points to the target wiki and not the old wiki.\n        // This tests the XObject cache.\n        DocumentReference targetXClassReference = new DocumentReference(\"copywiki\", DOCSPACE, DOCNAME);\n        assertNotNull(copy.getXObject(targetXClassReference));\n\n        // Also verify that actual XObject's reference (not from the cache).\n        assertEquals(1, copy.getXObjects().size());\n        BaseObject bobject = copy.getXObjects().get(copy.getXObjects().keySet().iterator().next()).get(0);\n        assertEquals(new DocumentReference(\"copywiki\", DOCSPACE, DOCNAME), bobject.getXClassReference());\n    }\n\n    @Test\n    void testCustomMappingAfterDocumentCopy() throws Exception\n    {\n        this.document.getXClass().setCustomMapping(\"internal\");\n\n        XWikiDocument copy = this.document.copyDocument(new DocumentReference(\"copywiki\", \"copyspace\", \"copypage\"),\n            this.oldcore.getXWikiContext());\n\n        assertEquals(\"\", copy.getXClass().getCustomMapping());\n    }\n\n    /**\n     * Normally the xobject vector has the Nth object on the Nth position, but in case an object gets misplaced, trying\n     * to remove it should indeed remove that object, and no other.\n     */\n    @Test\n    void testRemovingObjectWithWrongObjectVector()\n    {\n        // Setup: Create a document and two xobjects\n        BaseObject o1 = new BaseObject();\n        BaseObject o2 = new BaseObject();\n        o1.setXClassReference(CLASS_REFERENCE);\n        o2.setXClassReference(CLASS_REFERENCE);\n\n        // Test: put the second xobject on the third position\n        // addObject creates the object vector and configures the objects\n        // o1 is added at position 0\n        // o2 is added at position 1\n        XWikiDocument doc = new XWikiDocument(DOCUMENT_REFERENCE);\n        doc.addXObject(o1);\n        doc.addXObject(o2);\n\n        // Modify the o2 object's position to ensure it can still be found and removed by the removeObject method.\n        assertEquals(1, o2.getNumber());\n        o2.setNumber(0);\n        // Set a field on o1 so that when comparing it with o2 they are different. This is needed so that the remove\n        // will pick the right object to remove (since we've voluntarily set a wrong number of o2 it would pick o1\n        // if they were equals).\n        o1.addField(\"somefield\", new StringProperty());\n\n        // Call the tested method, removing o2 from position 2 which is set to null\n        boolean result = doc.removeXObject(o2);\n\n        // Check the correct behavior:\n        assertTrue(result);\n        List<BaseObject> objects = doc.getXObjects(CLASS_REFERENCE);\n        assertTrue(objects.contains(o1));\n        assertFalse(objects.contains(o2));\n        assertNull(objects.get(1));\n\n        // Second test: swap the two objects, so that the first object is in the position the second should have\n        // Start over, re-adding the two objects\n        doc = new XWikiDocument(DOCUMENT_REFERENCE);\n        doc.addXObject(o1);\n        doc.addXObject(o2);\n    }\n\n    @Test\n    void testCopyDocument() throws XWikiException\n    {\n        DocumentReference oldReference =\n            new DocumentReference(CLASS_REFERENCE.getWikiReference().getName(), \"space1\", \"document1\");\n        DocumentReference newReference =\n            new DocumentReference(CLASS_REFERENCE.getWikiReference().getName(), \"space2\", \"document2\");\n\n        XWikiDocument doc = new XWikiDocument(oldReference);\n        doc.setTitle(\"Some title\");\n        BaseObject o = new BaseObject();\n        o.setXClassReference(CLASS_REFERENCE);\n        doc.addXObject(o);\n        doc.setLocale(Locale.ENGLISH);\n        doc.setNew(false);\n\n        XWikiDocument newDoc = doc.copyDocument(newReference, this.oldcore.getXWikiContext());\n        BaseObject newO = newDoc.getXObject(CLASS_REFERENCE);\n\n        assertNotSame(o, newDoc.getXObject(CLASS_REFERENCE));\n        assertFalse(newO.getGuid().equals(o.getGuid()));\n        // Verify that the title is copied\n        assertEquals(\"Some title\", newDoc.getTitle());\n        assertEquals(Locale.ENGLISH, newDoc.getLocale());\n        assertEquals(newReference, newDoc.getDocumentReference());\n        assertEquals(new DocumentReference(newReference, Locale.ENGLISH), newDoc.getDocumentReferenceWithLocale());\n        assertTrue(newDoc.isNew());\n    }\n\n    /**\n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-6743\">XWIKI-6743</a>\n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-12349\">XWIKI-12349</a>\n     */\n    @Test\n    void testCopyDocumentSetsTitleToNewDocNameIfPreviouslySetToDocName() throws XWikiException\n    {\n        copyDocumentAndAssertTitle(new DocumentReference(\"wiki1\", \"space1\", \"page1\"), \"page1\",\n            new DocumentReference(\"wiki2\", \"space2\", \"page2\"), \"page2\");\n\n        copyDocumentAndAssertTitle(new DocumentReference(\"wiki1\", \"space1\", \"WebHome\"), \"space1\",\n            new DocumentReference(\"wiki2\", \"space2\", \"page2\"), \"page2\");\n\n        copyDocumentAndAssertTitle(new DocumentReference(\"wiki1\", \"space1\", \"WebHome\"), \"space1\",\n            new DocumentReference(\"wiki2\", \"space2\", \"WebHome\"), \"space2\");\n    }\n\n    private void copyDocumentAndAssertTitle(DocumentReference oldReference, String oldTitle,\n        DocumentReference newReference, String expectedNewTitle) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(oldReference);\n        doc.setTitle(oldTitle);\n\n        XWikiDocument newDoc = doc.copyDocument(newReference, this.oldcore.getXWikiContext());\n\n        // Verify that we get the expected title.\n        assertEquals(expectedNewTitle, newDoc.getTitle());\n    }\n\n    @Test\n    void testValidate() throws XWikiException, AccessDeniedException\n    {\n        this.document.setValidationScript(\"validationScript\");\n        this.baseClass.setValidationScript(\"validationScript\");\n\n        doReturn(new XWikiValidationInterface()\n        {\n            @Override\n            public boolean validateObject(BaseObject object, XWikiContext context)\n            {\n                return true;\n            }\n\n            @Override\n            public boolean validateDocument(XWikiDocument doc, XWikiContext context)\n            {\n                return true;\n            }\n        }).when(this.oldcore.getSpyXWiki()).parseGroovyFromPage(\"validationScript\", this.oldcore.getXWikiContext());\n\n        // With PR\n\n        assertTrue(this.document.validate(this.oldcore.getXWikiContext()));\n        assertTrue(this.baseClass.validateObject(this.baseObject, this.oldcore.getXWikiContext()));\n\n        // Without PR\n\n        doThrow(AccessDeniedException.class).when(this.oldcore.getMockContextualAuthorizationManager())\n            .checkAccess(Right.PROGRAM, new DocumentReference(\"wiki\", \"space\", \"validationScript\"));\n\n        assertFalse(this.document.validate(this.oldcore.getXWikiContext()));\n        assertFalse(this.baseClass.validateObject(this.baseObject, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    void tofromXMLDocument() throws XWikiException\n    {\n        // equals won't work on password fields because of https://jira.xwiki.org/browse/XWIKI-12561\n        this.baseClass.removeField(\"passwd\");\n        this.baseObject.removeField(\"passwd\");\n        this.baseObject2.removeField(\"passwd\");\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        Document document = this.document.toXMLDocument(this.oldcore.getXWikiContext());\n\n        XWikiDocument newDocument = new XWikiDocument(this.document.getDocumentReference());\n        newDocument.fromXML(document, false);\n\n        assertEquals(this.document, newDocument);\n    }\n\n    @Test\n    void getAttachmentWithNullFilename() throws XWikiException\n    {\n        assertNull(this.document.getAttachment(null));\n    }\n\n    @Test\n    void listAdd() throws XWikiException\n    {\n        // reset\n        attachmentList.clear();\n        // add without index\n        XWikiAttachment attachment = new XWikiAttachment(this.document, \"testAttachment\");\n        attachmentList.add(attachment);\n        assertTrue(this.document.getAttachmentList().contains(attachment));\n        assertTrue(this.document.getAttachment(\"testAttachment\") == attachment);\n        assertTrue(((XWikiAttachmentList) (attachmentList)).getByFilename(\"testAttachment\") == attachment);\n        assertFalse(attachmentList.add(attachment));\n        assertTrue(attachmentList.size() == 1);\n\n        // add using index\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"testAttachment2\");\n        attachmentList.add(0, attachment2);\n        assertTrue(this.document.getAttachmentList().contains(attachment2));\n        assertTrue(this.document.getAttachment(\"testAttachment2\") == attachment2);\n        assertTrue(((XWikiAttachmentList) (attachmentList)).getByFilename(\"testAttachment2\") == attachment2);\n    }\n\n    @Test\n    void listMaintainsOrder() throws XWikiException\n    {\n        XWikiAttachment attachment1 = new XWikiAttachment(this.document, \"attachmentA\");\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"attachmentB\");\n        XWikiAttachment attachment3 = new XWikiAttachment(this.document, \"attachmentC\");\n        attachmentList.add(attachment3);\n        attachmentList.add(attachment1);\n        attachmentList.add(attachment2);\n        List<XWikiAttachment> list = new ArrayList<XWikiAttachment>();\n        list.add(attachment1);\n        list.add(attachment2);\n        list.add(attachment3);\n        assertEquals(this.document.getAttachmentList(), list);\n    }\n\n    @Test\n    void listClear() throws XWikiException\n    {\n        attachmentList.clear();\n        assertTrue(attachmentList.isEmpty());\n    }\n\n    @Test\n    void listRemove() throws XWikiException\n    {\n        // remove through object parameter\n        XWikiAttachment attachment = new XWikiAttachment(this.document, \"remove\");\n        attachmentList.add(attachment);\n        attachmentList.remove(attachment);\n        assertFalse(attachmentList.contains(attachment));\n\n        // remove through index parameter\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"remove\");\n        attachmentList.add(attachment2);\n        attachmentList.remove(0);\n        assertFalse(attachmentList.contains(attachment2));\n\n        // remove attachment that is not in the list\n        assertFalse(attachmentList.remove(attachment));\n\n    }\n\n    @Test\n    void listSet() throws XWikiException\n    {\n        XWikiAttachment attachment = new XWikiAttachment(this.document, \"testAttachment\");\n        attachmentList.set(0, attachment);\n        assertTrue(this.document.getAttachmentList().contains(attachment));\n        assertTrue(this.document.getAttachment(\"testAttachment\") == attachment);\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"testAttachment\");\n        attachmentList.set(0, attachment2);\n        assertTrue(this.document.getAttachmentList().contains(attachment2));\n        assertFalse(this.document.getAttachmentList().contains(attachment));\n        assertFalse(this.document.getAttachment(\"testAttachment\") == attachment);\n        assertTrue(this.document.getAttachment(\"testAttachment\") == attachment2);\n    }\n\n    @Test\n    void listAddAll() throws XWikiException\n    {\n        ArrayList<XWikiAttachment> list = new ArrayList<XWikiAttachment>();\n        XWikiAttachment attachment1 = new XWikiAttachment(this.document, \"attachmentA\");\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"attachmentB\");\n        XWikiAttachment attachment3 = new XWikiAttachment(this.document, \"attachmentC\");\n        list.add(attachment1);\n        list.add(attachment2);\n        list.add(attachment3);\n        attachmentList.addAll(list);\n        assertTrue(attachmentList.contains(attachment1));\n        assertTrue(attachmentList.contains(attachment2));\n        assertTrue(attachmentList.contains(attachment3));\n\n        // reset\n        attachmentList.clear();\n        attachmentList.addAll(0, list);\n        assertTrue(attachmentList.contains(attachment1));\n        assertTrue(attachmentList.contains(attachment2));\n        assertTrue(attachmentList.contains(attachment3));\n\n    }\n\n    @Test\n    void listRemoveAll() throws XWikiException\n    {\n        ArrayList<XWikiAttachment> list = new ArrayList<XWikiAttachment>();\n        XWikiAttachment attachment1 = new XWikiAttachment(this.document, \"attachmentA\");\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"attachmentB\");\n        XWikiAttachment attachment3 = new XWikiAttachment(this.document, \"attachmentC\");\n        XWikiAttachment attachment4 = new XWikiAttachment(this.document, \"attachmentD\");\n        list.add(attachment1);\n        list.add(attachment2);\n        list.add(attachment3);\n        attachmentList.addAll(list);\n        attachmentList.add(attachment4);\n        attachmentList.removeAll(list);\n        assertFalse(attachmentList.contains(attachment1));\n        assertFalse(attachmentList.contains(attachment2));\n        assertFalse(attachmentList.contains(attachment3));\n        assertTrue(attachmentList.contains(attachment4));\n    }\n\n    @Test\n    void listRetainAll() throws XWikiException\n    {\n        ArrayList<XWikiAttachment> list = new ArrayList<XWikiAttachment>();\n        XWikiAttachment attachment1 = new XWikiAttachment(this.document, \"attachmentA\");\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"attachmentB\");\n        XWikiAttachment attachment3 = new XWikiAttachment(this.document, \"attachmentC\");\n        XWikiAttachment attachment4 = new XWikiAttachment(this.document, \"attachmentD\");\n        list.add(attachment1);\n        list.add(attachment2);\n        list.add(attachment3);\n        attachmentList.addAll(list);\n        attachmentList.add(attachment4);\n        attachmentList.retainAll(list);\n        assertTrue(attachmentList.contains(attachment1));\n        assertTrue(attachmentList.contains(attachment2));\n        assertTrue(attachmentList.contains(attachment3));\n        assertFalse(attachmentList.contains(attachment4));\n    }\n\n    @Test\n    void modifyAttachmentName()\n    {\n        XWikiAttachment attachment = new XWikiAttachment();\n\n        this.document.getAttachmentList().add(attachment);\n\n        assertSame(1, this.document.getAttachmentList().size());\n        assertSame(attachment, this.document.getAttachmentList().get(0));\n\n        attachment.setFilename(\"attachment\");\n\n        assertSame(1, this.document.getAttachmentList().size());\n        assertSame(attachment, this.document.getAttachmentList().get(0));\n        assertSame(attachment, this.document.getAttachment(\"attachment\"));\n\n        attachment.setFilename(\"attachment2\");\n\n        assertSame(1, this.document.getAttachmentList().size());\n        assertSame(attachment, this.document.getAttachmentList().get(0));\n        assertNull(this.document.getAttachment(\"attachment\"));\n        assertSame(attachment, this.document.getAttachment(\"attachment2\"));\n    }\n\n    @Test\n    void getMetaDataDiff() throws Exception\n    {\n        XWikiDocument prevDoc = new XWikiDocument(DOCUMENT_REFERENCE);\n        XWikiDocument nextDoc = new XWikiDocument(DOCUMENT_REFERENCE);\n        XWikiDocument thisDoc = new XWikiDocument(DOCUMENT_REFERENCE);\n\n        List<MetaDataDiff> diff = thisDoc.getMetaDataDiff(prevDoc, nextDoc, this.oldcore.getXWikiContext());\n        assertEquals(0, diff.size());\n\n        UserReference alice = mock(UserReference.class, \"alice\");\n        prevDoc.getAuthors().setOriginalMetadataAuthor(alice);\n\n        UserReference bob = mock(UserReference.class, \"bob\");\n        nextDoc.getAuthors().setOriginalMetadataAuthor(bob);\n\n        when(this.compactWikiUserReferenceSerializer.serialize(alice, DOCUMENT_REFERENCE)).thenReturn(\"XWiki.alice\");\n        when(this.compactWikiUserReferenceSerializer.serialize(bob, DOCUMENT_REFERENCE)).thenReturn(\"XWiki.bob\");\n\n        diff = thisDoc.getMetaDataDiff(prevDoc, nextDoc, this.oldcore.getXWikiContext());\n        assertEquals(1, diff.size());\n        assertEquals(\"author\", diff.get(0).getField());\n        assertEquals(\"XWiki.alice\", diff.get(0).getPrevValue());\n        assertEquals(\"XWiki.bob\", diff.get(0).getNewValue());\n    }\n\n    @Test\n    void getBackLinkedReferences() throws XWikiException, LinkException\n    {\n        XWikiDocument doc = new XWikiDocument(DOCUMENT_REFERENCE);\n\n        DocumentReference backlink1 = new DocumentReference(\"wiki\", \"space\", \"page1\");\n        DocumentReference backlink21 = new DocumentReference(\"wiki\", \"space\", \"page2\", Locale.ENGLISH);\n        DocumentReference backlink22 = new DocumentReference(\"wiki\", \"space\", \"page2\", Locale.FRENCH);\n\n        assertEquals(Set.of(), new HashSet<>(doc.getBackLinkedReferences(this.oldcore.getXWikiContext())));\n\n        when(this.linkStore.resolveBackLinkedEntities(DOCUMENT_REFERENCE))\n            .thenReturn(Set.of(backlink1, backlink21, backlink22));\n\n        assertEquals(Set.of(backlink1, backlink21.withoutLocale()),\n            new HashSet<>(doc.getBackLinkedReferences(this.oldcore.getXWikiContext())));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.Reader;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.Properties;\n\nimport org.apache.velocity.VelocityContext;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.display.internal.DisplayConfiguration;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.test.annotation.AllComponents;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.velocity.VelocityEngine;\nimport org.xwiki.velocity.VelocityFactory;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.api.Document;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link XWikiDocument}'s rendering methods\n * ({@code getRenderedTitle()} and {@code getRenderedContent()}).\n *\n * @version $Id$\n */\n@OldcoreTest\n@AllComponents\npublic class XWikiDocumentRenderingTest\n{\n    private static final String DOCWIKI = \"xwiki\";\n\n    private static final String DOCSPACE = \"Space\";\n\n    private static final String DOCNAME = \"Page\";\n\n    private static final String DOCFULLNAME = DOCSPACE + \".\" + DOCNAME;\n\n    private static final String CLASSNAME = DOCFULLNAME;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    @InjectComponentManager\n    private MockitoComponentManager componentManager;\n\n    private DisplayConfiguration displayConfiguration;\n\n    private XWikiDocument document;\n\n    private BaseClass baseClass;\n\n    private BaseObject baseObject;\n\n    private XWiki xwiki;\n\n    @BeforeEach\n    public void setupComponents() throws Exception\n    {\n        // Setup display configuration.\n        this.displayConfiguration = this.componentManager.registerMockComponent(DisplayConfiguration.class);\n        when(this.displayConfiguration.getDocumentDisplayerHint()).thenReturn(\"default\");\n        when(this.displayConfiguration.getTitleHeadingDepth()).thenReturn(2);\n    }\n\n    @BeforeEach\n    public void setup() throws Exception\n    {\n        this.xwiki = this.oldcore.getSpyXWiki();\n\n        DocumentReference documentReference = new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME);\n        this.document = new XWikiDocument(documentReference);\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n        this.document.setNew(false);\n\n        this.oldcore.getXWikiContext().setDoc(this.document);\n\n        this.baseClass = this.document.getXClass();\n        this.baseClass.addTextField(\"string\", \"String\", 30);\n        this.baseClass.addTextAreaField(\"area\", \"Area\", 10, 10);\n        this.baseClass.addTextAreaField(\"puretextarea\", \"Pure text area\", 10, 10);\n        // set the text areas an non interpreted content\n        ((TextAreaClass) this.baseClass.getField(\"puretextarea\")).setContentType(\"puretext\");\n        this.baseClass.addPasswordField(\"passwd\", \"Password\", 30);\n        this.baseClass.addBooleanField(\"boolean\", \"Boolean\", \"yesno\");\n        this.baseClass.addNumberField(\"int\", \"Int\", 10, \"integer\");\n        this.baseClass.addStaticListField(\"stringlist\", \"StringList\", \"value1, value2\");\n\n        doReturn(this.baseClass).when(this.xwiki).getXClass(any(), any());\n\n        this.baseObject = this.document.newObject(CLASSNAME, this.oldcore.getXWikiContext());\n        this.baseObject.setStringValue(\"string\", \"string\");\n        this.baseObject.setLargeStringValue(\"area\", \"area\");\n        this.baseObject.setStringValue(\"passwd\", \"passwd\");\n        this.baseObject.setIntValue(\"boolean\", 1);\n        this.baseObject.setIntValue(\"int\", 42);\n        this.baseObject.setStringListValue(\"stringlist\", Arrays.asList(\"VALUE1\", \"VALUE2\"));\n\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);\n\n        when(this.oldcore.getMockAuthorizationManager().hasAccess(any(), any(), any())).thenReturn(true);\n        when(this.oldcore.getMockContextualAuthorizationManager().hasAccess(any())).thenReturn(true);\n        when(this.xwiki.getRightService().hasProgrammingRights(any())).thenReturn(true);\n\n        this.componentManager\n            .registerComponent(ConfigurationSource.class, \"xwikicfg\", this.oldcore.getConfigurationSource());\n    }\n\n    @Test\n    public void getRenderedContentWithCurrentDocumentVariableIsInjectedBeforeRendering() throws Exception\n    {\n        // Verifies we can access the doc variable from a groovy macro.\n        this.document.setContent(\"{{groovy}}print(doc);{{/groovy}}\");\n\n        assertEquals(\"<p>Space.Page</p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleWhenTitleIsSet()\n    {\n        // Plain title\n        this.document.setTitle(\"title\");\n        assertEquals(\"title\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        // Title with wiki syntax that should not be evaluated\n        this.document.setTitle(\"**title**\");\n        assertEquals(\"**title**\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        // Title with HTML syntax that should not be evaluated\n        this.document.setTitle(\"<strong>ti<em>tle</strong>\");\n        // The title is parsed as plain text after the Velocity code is evaluated so the HTML have no meaning.\n        assertEquals(\"&lt;strong&gt;ti&lt;em&gt;tle&lt;/strong&gt;\",\n            this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n        assertEquals(\"<strong>ti<em>tle</strong>\",\n            this.document.getRenderedTitle(Syntax.PLAIN_1_0, this.oldcore.getXWikiContext()));\n\n        // Title with velocity that should be evaluated\n        this.document.setTitle(\"#set($key = \\\"title\\\")$key\");\n        assertEquals(\"title\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleInHTMLWhenExtractedFromContent()\n    {\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"header 1\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\n            \"content not in section\\n\" + \"= **header 1**=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"<strong>header 1</strong>\",\n            this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\n            \"content not in section\\n\" + \"= [[Space.Page]]=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"<span class=\\\"wikiexternallink\\\"><a href=\\\"Space.Page\\\">\"\n                + \"<span class=\\\"wikigeneratedlinkcontent\\\">Space.Page</span></a></span>\",\n            this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"content not in section\\n\" + \"= #set($var ~= \\\"value\\\")=\\nheader 1 content\\n\"\n            + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"#set($var = \\\"value\\\")\",\n            this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"content not in section\\n\"\n            + \"= {{groovy}}print \\\"value\\\"{{/groovy}}=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"value\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"content not in section\\n=== header 3===\");\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleInPlainWhenExtractedFromContent()\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= **header 1**=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.PLAIN_1_0, this.oldcore.getXWikiContext()));\n\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n\n        this.document.setContent(\n            \"content not in section\\n\" + \"= **header 1**=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"header 1\", this.document.getRenderedTitle(Syntax.PLAIN_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"content not in section\\n\"\n            + \"= {{groovy}}print \\\"value\\\"{{/groovy}}=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"value\", this.document.getRenderedTitle(Syntax.PLAIN_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleWhenNoTitleAndNoContentSet()\n    {\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * Make sure title extracted from content is protected from cycles\n     */\n    @Test\n    public void getRenderedTitleWhenRecursive()\n    {\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n\n        this.document.setContent(\"= {{groovy}}print doc.getDisplayTitle(){{/groovy}}\");\n\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleWhenMatchingTitleHeaderDepth()\n    {\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n\n        this.document.setContent(\"=== level3\");\n\n        // Overwrite the title heading depth.\n        when(this.displayConfiguration.getTitleHeadingDepth()).thenReturn(3);\n\n        assertEquals(\"level3\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleWhenNotMatchingTitleHeaderDepth()\n    {\n        this.document.setContent(\"=== level3\");\n\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * See XWIKI-5277 for details.\n     */\n    @Test\n    public void getRenderedContentCleansVelocityMacroCache() throws Exception\n    {\n        // Make sure we start not in the rendering engine since this is what happens in real: a document is\n        // called by a template thus outside of the rendering engine.\n        this.oldcore.getXWikiContext().remove(\"isInRenderingEngine\");\n\n        // We display a text area since we know that rendering a text area will call getRenderedContent inside our top\n        // level getRenderedContent call, thus testing that velocity macros are not removed during nested calls to\n        // getRenderedContent.\n        this.baseObject.setLargeStringValue(\"area\", \"{{velocity}}#macro(testmacrocache)ok#end{{/velocity}}\");\n        this.document.setContent(\"{{velocity}}$doc.display(\\\"area\\\")#testmacrocache{{/velocity}}\");\n\n        // We need to put the current doc in the Velocity Context since it's normally set before the rendering is\n        // called in the execution flow.\n        VelocityManager originalVelocityManager = this.componentManager.getInstance(VelocityManager.class);\n        VelocityContext vcontext = originalVelocityManager.getVelocityContext();\n        vcontext.put(\"doc\", new Document(this.document, this.oldcore.getXWikiContext()));\n\n        // Register a Mock for the VelocityManager to bypass skin APIs that we would need to mock otherwise.\n        VelocityManager velocityManager = this.componentManager.registerMockComponent(VelocityManager.class);\n        when(velocityManager.getCurrentVelocityContext()).thenReturn(vcontext);\n\n        VelocityFactory velocityFactory = this.componentManager.getInstance(VelocityFactory.class);\n        VelocityEngine vengine = velocityFactory.createVelocityEngine(\"default\", new Properties());\n        when(velocityManager.getVelocityEngine()).thenReturn(vengine);\n        when(velocityManager.evaluate(any(), any(), any()))\n            .thenAnswer(invocation -> vengine.evaluate(vcontext, invocation.getArgument(0),\n                invocation.getArgument(1), (Reader) invocation.getArgument(2)));\n\n        // Verify that the macro located inside the TextArea has been taken into account when executing the doc's\n        // content.\n        assertEquals(\"<p>ok</p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentWithAndWithoutTranslations() throws Exception\n    {\n        this.document.setContent(\"**bold**\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        // Check the content from the default document\n        assertEquals(\"<p><strong>bold</strong></p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n\n        // Create a translation and set the current language to be that of the translation to verify that the rendered\n        // content is that of the translated document\n        // Note that this also verifies that the translation can have a different syntax than the default doc.\n        XWikiDocument translatedDocument = new XWikiDocument(this.document.getDocumentReference(), Locale.FRENCH);\n        translatedDocument.setContent(\"//italic//\");\n        translatedDocument.setSyntax(Syntax.XWIKI_1_0);\n        translatedDocument.setNew(false);\n\n        doReturn(Locale.FRENCH.toString()).when(this.xwiki).getLanguagePreference(any());\n        doReturn(translatedDocument).when(this.xwiki).getDocument(\n            eq(new DocumentReference(translatedDocument.getDocumentReference(), translatedDocument.getLocale())),\n            any());\n        assertEquals(\"<p><em>italic</em></p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p><strong>bold</strong></p>\", this.document.displayDocument(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentIsForcingCurrentDocumentAsTheSecurityDocument() throws Exception\n    {\n        // Remove whatever security document there is, to prove that a new security document is forced (it's set as\n        // the current document).\n        this.oldcore.getXWikiContext().remove(\"sdoc\");\n\n        this.document.setContent(\"{{velocity}}$xcontext.sdoc{{/velocity}}\");\n\n        // Verifies that a security document is always set,  independently of what was set before the execution of\n        // getRenderedContent().\n        assertEquals(\"<p>Space.Page</p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentTextWithSourceSyntaxSpecified()\n    {\n        this.document.setSyntax(Syntax.XWIKI_1_0);\n\n        assertEquals(\"<p><strong>bold</strong></p>\",\n            this.document.getRenderedContent(\"**bold**\", \"xwiki/2.0\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentTextRights() throws Exception\n    {\n        XWikiDocument otherDocument = new XWikiDocument(new DocumentReference(\"otherwiki\", \"otherspace\", \"otherpage\"));\n        otherDocument.setContentAuthorReference(new DocumentReference(\"otherwiki\", \"XWiki\", \"othercontentauthor\"));\n        XWikiDocument sdoc = new XWikiDocument(new DocumentReference(\"callerwiki\", \"callerspace\", \"callerpage\"));\n        sdoc.setContentAuthorReference(new DocumentReference(\"callerwiki\", \"XWiki\", \"calleruser\"));\n        Document apiDocument = this.document.newDocument(this.oldcore.getXWikiContext());\n\n        this.oldcore.getXWikiContext().setDoc(null);\n\n        String content =\n            \"{{velocity}}$xcontext.sdoc.contentAuthorReference $xcontext.doc $xcontext.doc.contentAuthorReference\"\n                + \"{{/velocity}}\";\n\n        this.document.setContentAuthorReference(new DocumentReference(\"authorwiki\", \"XWiki\", \"contentauthor\"));\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), Syntax.XHTML_1_0.toIdString()));\n\n        assertEquals(\"<p>otherwiki:XWiki.othercontentauthor Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), false, otherDocument,\n                this.oldcore.getXWikiContext()));\n\n        this.oldcore.getXWikiContext().setDoc(otherDocument);\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>otherwiki:XWiki.othercontentauthor Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        assertEquals(\"<p>otherwiki:XWiki.othercontentauthor Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), Syntax.XHTML_1_0.toIdString()));\n\n        this.oldcore.getXWikiContext().put(\"sdoc\", sdoc);\n        this.oldcore.getXWikiContext().setDoc(this.document);\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), Syntax.XHTML_1_0.toIdString()));\n\n        this.oldcore.getXWikiContext().setDoc(otherDocument);\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), Syntax.XHTML_1_0.toIdString()));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.test;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.inject.Provider;\nimport javax.script.ScriptContext;\nimport javax.servlet.ServletContext;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.hibernate.cfg.Configuration;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.component.descriptor.DefaultComponentDescriptor;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.configuration.internal.MemoryConfigurationSource;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.context.ExecutionContextManager;\nimport org.xwiki.environment.Environment;\nimport org.xwiki.environment.internal.ServletEnvironment;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.internal.reference.EntityReferenceFactory;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.refactoring.internal.ModelBridge;\nimport org.xwiki.refactoring.internal.ReferenceUpdater;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.script.internal.CloneableSimpleScriptContext;\nimport org.xwiki.script.internal.ScriptExecutionContextInitializer;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.test.XWikiTempDirUtil;\nimport org.xwiki.test.annotation.AllComponents;\nimport org.xwiki.test.internal.MockConfigurationSource;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.url.URLConfiguration;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.user.UserReferenceSerializer;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\n\nimport com.xpn.xwiki.CoreConfiguration;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.doc.rcs.XWikiRCSNodeInfo;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilterUtils;\nimport com.xpn.xwiki.internal.store.hibernate.HibernateStore;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.store.AttachmentVersioningStore;\nimport com.xpn.xwiki.store.XWikiHibernateBaseStore;\nimport com.xpn.xwiki.store.XWikiHibernateStore;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiAuthService;\nimport com.xpn.xwiki.user.api.XWikiGroupService;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.util.XWikiStubContextProvider;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\n\nimport static com.xpn.xwiki.test.mockito.OldcoreMatchers.anyXWikiContext;\nimport static com.xpn.xwiki.test.mockito.OldcoreMatchers.anyXWikiDocument;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyBoolean;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.doNothing;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.when;\n\n/**\n * Test setup to initialize and manipulate various oldcore APIs.\n * \n * @version $Id$\n * @since 10.2\n */\npublic class MockitoOldcore\n{\n    public static final LocalDocumentReference USER_CLASS = new LocalDocumentReference(\"XWiki\", \"XWikiUsers\");\n\n    public static final LocalDocumentReference GROUP_CLASS = new LocalDocumentReference(\"XWiki\", \"XWikiGroups\");\n\n    public static final LocalDocumentReference RIGHTS_CLASS = new LocalDocumentReference(\"XWiki\", \"XWikiRights\");\n\n    public static final LocalDocumentReference GLOBAL_RIGHTS_CLASS =\n        new LocalDocumentReference(\"XWiki\", \"XWikiGlobalRights\");\n\n    private final MockitoComponentManager componentManager;\n\n    private XWikiContext context;\n\n    private XWiki spyXWiki;\n\n    protected File permanentDirectory;\n\n    protected File temporaryDirectory;\n\n    private HibernateStore mockHibernateStore;\n\n    private XWikiHibernateStore mockXWikiHibernateStore;\n\n    private XWikiVersioningStoreInterface mockVersioningStore;\n\n    private AttachmentVersioningStore mockAttachmentVersioningStore;\n\n    private XWikiRightService mockRightService;\n\n    private XWikiAuthService mockAuthService;\n\n    private XWikiGroupService mockGroupService;\n\n    private AuthorizationManager mockAuthorizationManager;\n\n    private ContextualAuthorizationManager mockContextualAuthorizationManager;\n\n    private QueryManager queryManager;\n\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    protected Map<DocumentReference, XWikiDocument> documents = new ConcurrentHashMap<>();\n\n    protected Map<DocumentReference, XWikiDocumentArchive> documentArchives = new ConcurrentHashMap<>();\n\n    private boolean notifyDocumentCreatedEvent;\n\n    private boolean notifyDocumentUpdatedEvent;\n\n    private boolean notifyDocumentDeletedEvent;\n\n    private MemoryConfigurationSource configurationSource;\n\n    private MemoryConfigurationSource xwikicfgConfigurationSource;\n\n    private MemoryConfigurationSource wikiConfigurationSource;\n\n    private MemoryConfigurationSource spaceConfigurationSource;\n\n    private ScriptContext scriptContext;\n\n    private Environment environment;\n\n    private DocumentAccessBridge documentAccessBridge;\n\n    private boolean mockXWiki = true;\n\n    public MockitoOldcore(MockitoComponentManager componentManager)\n    {\n        this.componentManager = componentManager;\n    }\n\n    public MockitoComponentManager getMocker()\n    {\n        return this.componentManager;\n    }\n\n    public void notifyDocumentCreatedEvent(boolean notifyDocumentCreatedEvent)\n    {\n        this.notifyDocumentCreatedEvent = notifyDocumentCreatedEvent;\n    }\n\n    public void notifyDocumentUpdatedEvent(boolean notifyDocumentUpdatedEvent)\n    {\n        this.notifyDocumentUpdatedEvent = notifyDocumentUpdatedEvent;\n    }\n\n    public void notifyDocumentDeletedEvent(boolean notifyDocumentDeletedEvent)\n    {\n        this.notifyDocumentDeletedEvent = notifyDocumentDeletedEvent;\n    }\n\n    public void mockXWiki(boolean mockXWiki)\n    {\n        this.mockXWiki = mockXWiki;\n    }\n\n    /**\n     * Enabled notification of component descriptor registration/unregistration.\n     * \n     * @throws ComponentLookupException when failing to lookup {@link ObservationManager} component\n     */\n    public void notifyComponentDescriptorEvent() throws ComponentLookupException\n    {\n        getMocker().notifyComponentDescriptorEvent();\n    }\n\n    public void before(Class<?> testClass) throws Exception\n    {\n        // Statically store the component manager in {@link Utils} to be able to access it without\n        // the context.\n        Utils.setComponentManager(getMocker());\n\n        this.context = new XWikiContext();\n\n        getXWikiContext().setWikiId(\"xwiki\");\n        getXWikiContext().setMainXWiki(\"xwiki\");\n\n        this.spyXWiki = spy(new XWiki());\n        getXWikiContext().setWiki(this.spyXWiki);\n\n        this.mockHibernateStore = getMocker().registerMockComponent(HibernateStore.class);\n        this.mockXWikiHibernateStore = mock(XWikiHibernateStore.class);\n        getMocker().registerComponent(XWikiStoreInterface.class, XWikiHibernateBaseStore.HINT,\n            this.mockXWikiHibernateStore);\n        this.mockVersioningStore =\n            getMocker().registerMockComponent(XWikiVersioningStoreInterface.class, XWikiHibernateBaseStore.HINT);\n        this.mockAttachmentVersioningStore =\n            getMocker().registerMockComponent(AttachmentVersioningStore.class, XWikiHibernateBaseStore.HINT);\n        this.mockRightService = mock(XWikiRightService.class);\n        this.mockGroupService = mock(XWikiGroupService.class);\n        this.mockAuthService = mock(XWikiAuthService.class);\n\n        doReturn(new Configuration()).when(this.mockHibernateStore).getConfiguration();\n\n        this.spyXWiki.setStore(this.mockXWikiHibernateStore);\n        this.spyXWiki.setVersioningStore(this.mockVersioningStore);\n        this.spyXWiki.setDefaultAttachmentArchiveStore(this.mockAttachmentVersioningStore);\n        this.spyXWiki.setRightService(this.mockRightService);\n        this.spyXWiki.setAuthService(this.mockAuthService);\n        this.spyXWiki.setGroupService(this.mockGroupService);\n        this.spyXWiki.setPluginManager(new XWikiPluginManager());\n\n        // We need to initialize the Component Manager so that the components can be looked up\n        getXWikiContext().put(ComponentManager.class.getName(), getMocker());\n\n        if (testClass.getAnnotation(AllComponents.class) != null) {\n            // If @AllComponents is enabled force mocking AuthorizationManager and ContextualAuthorizationManager if not\n            // already mocked\n            this.mockAuthorizationManager = getMocker().registerMockComponent(AuthorizationManager.class, false);\n            this.mockContextualAuthorizationManager =\n                getMocker().registerMockComponent(ContextualAuthorizationManager.class, false);\n        } else {\n            // Make sure an AuthorizationManager and a ContextualAuthorizationManager is available\n            if (!getMocker().hasComponent(AuthorizationManager.class)) {\n                this.mockAuthorizationManager = getMocker().registerMockComponent(AuthorizationManager.class);\n            }\n            if (!getMocker().hasComponent(ContextualAuthorizationManager.class)) {\n                this.mockContextualAuthorizationManager =\n                    getMocker().registerMockComponent(ContextualAuthorizationManager.class);\n            }\n        }\n\n        // Make sure to provide a EntityReferenceFactory\n        if (!getMocker().hasComponent(EntityReferenceFactory.class)) {\n            EntityReferenceFactory factory = getMocker().registerMockComponent(EntityReferenceFactory.class);\n            when(factory.getReference(any())).thenAnswer((invocation) -> invocation.getArgument(0));\n        }\n\n        // Make sure a default ConfigurationSource is available\n        if (!getMocker().hasComponent(ConfigurationSource.class)) {\n            this.configurationSource = getMocker().registerMemoryConfigurationSource();\n        }\n\n        // Make sure a \"xwikicfg\" ConfigurationSource is available\n        if (!getMocker().hasComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT)) {\n            this.xwikicfgConfigurationSource = new MockConfigurationSource();\n            getMocker().registerComponent(MockConfigurationSource.getDescriptor(XWikiCfgConfigurationSource.ROLEHINT),\n                this.xwikicfgConfigurationSource);\n        }\n        // Make sure a \"wiki\" ConfigurationSource is available\n        if (!getMocker().hasComponent(ConfigurationSource.class, \"wiki\")) {\n            this.wikiConfigurationSource = new MockConfigurationSource();\n            getMocker().registerComponent(MockConfigurationSource.getDescriptor(\"wiki\"), this.wikiConfigurationSource);\n        }\n\n        // Make sure a \"space\" ConfigurationSource is available\n        if (!getMocker().hasComponent(ConfigurationSource.class, \"space\")) {\n            this.spaceConfigurationSource = new MockConfigurationSource();\n            getMocker().registerComponent(MockConfigurationSource.getDescriptor(\"space\"),\n                this.spaceConfigurationSource);\n        }\n\n        // Since the oldcore module draws the Servlet Environment in its dependencies we need to ensure it's set up\n        // correctly with a Servlet Context.\n        if (getMocker().hasComponent(Environment.class)) {\n            if (getMocker().getInstance(Environment.class) instanceof ServletEnvironment) {\n                ServletEnvironment servletEnvironment = getMocker().getInstance(Environment.class);\n\n                ServletContext servletContextMock = mock(ServletContext.class);\n                servletEnvironment.setServletContext(servletContextMock);\n                when(servletContextMock.getAttribute(\"javax.servlet.context.tempdir\"))\n                    .thenReturn(new File(System.getProperty(\"java.io.tmpdir\")));\n\n                initEnvironmentDirectories();\n\n                servletEnvironment.setTemporaryDirectory(this.temporaryDirectory);\n                servletEnvironment.setPermanentDirectory(this.permanentDirectory);\n\n                this.environment = servletEnvironment;\n            }\n        } else {\n            // Automatically register an Environment when none is available since it's a very common need\n            registerMockEnvironment();\n        }\n\n        // Initialize XWikiContext provider\n        if (!this.componentManager.hasComponent(XWikiContext.TYPE_PROVIDER)) {\n            Provider<XWikiContext> xcontextProvider =\n                this.componentManager.registerMockComponent(XWikiContext.TYPE_PROVIDER);\n            when(xcontextProvider.get()).thenReturn(getXWikiContext());\n        } else {\n            Provider<XWikiContext> xcontextProvider = this.componentManager.getInstance(XWikiContext.TYPE_PROVIDER);\n            if (MockUtil.isMock(xcontextProvider)) {\n                when(xcontextProvider.get()).thenReturn(getXWikiContext());\n            }\n        }\n\n        // Initialize readonly XWikiContext provider\n        if (!this.componentManager.hasComponent(XWikiContext.TYPE_PROVIDER, \"readonly\")) {\n            Provider<XWikiContext> xcontextProvider =\n                this.componentManager.registerMockComponent(XWikiContext.TYPE_PROVIDER, \"readonly\");\n            when(xcontextProvider.get()).thenReturn(getXWikiContext());\n        } else {\n            Provider<XWikiContext> xcontextProvider = this.componentManager.getInstance(XWikiContext.TYPE_PROVIDER);\n            if (MockUtil.isMock(xcontextProvider)) {\n                when(xcontextProvider.get()).thenReturn(getXWikiContext());\n            }\n        }\n\n        // Initialize the Execution Context\n        if (this.componentManager.hasComponent(ExecutionContextManager.class)) {\n            ExecutionContextManager ecm = this.componentManager.getInstance(ExecutionContextManager.class);\n            ExecutionContext ec = new ExecutionContext();\n            ecm.initialize(ec);\n        }\n\n        // Bridge with old XWiki Context, required for old code.\n        Execution execution;\n        if (this.componentManager.hasComponent(Execution.class)) {\n            execution = this.componentManager.getInstance(Execution.class);\n        } else {\n            execution = this.componentManager.registerMockComponent(Execution.class);\n        }\n        ExecutionContext econtext;\n        if (MockUtil.isMock(execution)) {\n            econtext = new ExecutionContext();\n            when(execution.getContext()).thenReturn(econtext);\n        } else {\n            econtext = execution.getContext();\n        }\n\n        // Set a few standard things in the ExecutionContext\n        econtext.setProperty(XWikiContext.EXECUTIONCONTEXT_KEY, getXWikiContext());\n        this.scriptContext = (ScriptContext) econtext.getProperty(ScriptExecutionContextInitializer.SCRIPT_CONTEXT_ID);\n        if (this.scriptContext == null) {\n            this.scriptContext = new CloneableSimpleScriptContext();\n            econtext.setProperty(ScriptExecutionContextInitializer.SCRIPT_CONTEXT_ID, this.scriptContext);\n        }\n\n        if (!this.componentManager.hasComponent(ScriptContextManager.class)) {\n            ScriptContextManager scriptContextManager =\n                this.componentManager.registerMockComponent(ScriptContextManager.class);\n            when(scriptContextManager.getCurrentScriptContext()).thenReturn(this.scriptContext);\n            when(scriptContextManager.getScriptContext()).thenReturn(this.scriptContext);\n        }\n\n        // Initialize the initial context in the stub context provider (which is then used for all calls to\n        // createStubContext() in the stub context provider). This is to simulate an XWiki runtime, where this is\n        // initialized on the first HTTP request.\n        if (this.componentManager.hasComponent(XWikiStubContextProvider.class)) {\n            XWikiStubContextProvider stubContextProvider =\n                this.componentManager.getInstance(XWikiStubContextProvider.class);\n            if (!MockUtil.isMock(stubContextProvider)) {\n                // TODO: Since we create the XWikiContext in this method and since no request has been set into it at\n                // this point, the initial context in XWikiStubContextProvider would normally be initialized with an\n                // empty request which would lead to some NPE when ServletRequest is used later on, for example. Thus\n                // we force a request in the context here before the call to stubContextProvider.initialize().\n                // Note that this needs to be refactored to let the test control what to initialize in the initial\n                // context (i.e. before stubContextProvider.initialize() is called).\n                // Also note that setting a non null request forces us to set a non null URL as otherwise it would lead\n                // to another NPE...\n                XWikiRequest originalRequest = getXWikiContext().getRequest();\n                if (getXWikiContext().getRequest() == null) {\n                    getXWikiContext().setRequest(new XWikiServletRequestStub());\n                }\n                URL originalURL = getXWikiContext().getURL();\n                if (getXWikiContext().getURL() == null) {\n                    getXWikiContext().setURL(new URL(\"http://localhost:8080\"));\n                }\n                stubContextProvider.initialize(getXWikiContext());\n                // Make sure we leave the XWikiContext unchanged (since we just temporarily modified the URL and\n                // request to set up the initial context in XWikiStubContextProvider).\n                getXWikiContext().setURL(originalURL);\n                getXWikiContext().setRequest(originalRequest);\n            }\n        }\n\n        // Make sure to have a mocked CoreConfiguration (even if one already exist)\n        if (!this.componentManager.hasComponent(CoreConfiguration.class)) {\n            CoreConfiguration coreConfigurationMock =\n                this.componentManager.registerMockComponent(CoreConfiguration.class);\n            when(coreConfigurationMock.getDefaultDocumentSyntax()).thenReturn(Syntax.XWIKI_2_1);\n        } else {\n            CoreConfiguration coreConfiguration =\n                this.componentManager.registerMockComponent(CoreConfiguration.class, false);\n            if (MockUtil.isMock(coreConfiguration)) {\n                when(coreConfiguration.getDefaultDocumentSyntax()).thenReturn(Syntax.XWIKI_2_1);\n            }\n        }\n\n        // Set a context ComponentManager if none exist\n        if (!this.componentManager.hasComponent(ComponentManager.class, \"context\")) {\n            DefaultComponentDescriptor<ComponentManager> componentManagerDescriptor =\n                new DefaultComponentDescriptor<>();\n            componentManagerDescriptor.setRoleHint(\"context\");\n            componentManagerDescriptor.setRoleType(ComponentManager.class);\n            this.componentManager.registerComponent(componentManagerDescriptor, this.componentManager);\n        }\n\n        // Register mock components for refactoring listener components\n        if (!this.componentManager.hasComponent(ModelBridge.class)) {\n            this.componentManager.registerMockComponent(ModelBridge.class);\n        }\n\n        if (!this.componentManager.hasComponent(ReferenceUpdater.class)) {\n            this.componentManager.registerMockComponent(ReferenceUpdater.class);\n        }\n\n        // Make sure to a have an URLConfiguration component.\n        if (!this.componentManager.hasComponent(URLConfiguration.class)) {\n            URLConfiguration mockUrlConfigComponent =\n                this.componentManager.registerMockComponent(URLConfiguration.class);\n            when(mockUrlConfigComponent.getURLFormatId()).thenReturn(\"standard\");\n        }\n\n        if (!this.componentManager.hasComponent(EntityNameValidationManager.class)) {\n            this.componentManager.registerMockComponent(EntityNameValidationManager.class);\n        }\n        if (!this.componentManager.hasComponent(EntityNameValidationConfiguration.class)) {\n            this.componentManager.registerMockComponent(EntityNameValidationConfiguration.class);\n        }\n\n        boolean supportRevisionStore = this.componentManager.hasComponent(XWikiDocumentFilterUtils.class);\n\n        // Mock getting document revisions using DocumentRevisionProvider.\n        if (supportRevisionStore && !this.componentManager.hasComponent(DocumentRevisionProvider.class, \"database\")) {\n            DocumentRevisionProvider documentRevisionProvider =\n                this.componentManager.registerMockComponent(DocumentRevisionProvider.class, \"database\");\n\n            when(documentRevisionProvider.getRevision(any(DocumentReference.class), anyString()))\n                .then(invocation -> {\n                    DocumentReference reference = invocation.getArgument(0);\n                    String revision = invocation.getArgument(1);\n                    XWikiDocument document = getSpyXWiki().getDocument(reference, this.context);\n\n                    return documentRevisionProvider.getRevision(document, revision);\n                });\n\n            when(documentRevisionProvider.getRevision(anyXWikiDocument(), anyString()))\n                .then(invocation -> {\n                        XWikiDocument baseDocument = invocation.getArgument(0);\n                        String revision = invocation.getArgument(1);\n                        return getMockVersioningStore().loadXWikiDoc(baseDocument, revision, this.context);\n                    }\n                );\n        }\n\n        // Set the default revision provider to the database-one when missing as this covers most cases.\n        if (supportRevisionStore && !this.componentManager.hasComponent(DocumentRevisionProvider.class)) {\n            DocumentRevisionProvider databaseRevisionProvider =\n                this.componentManager.getInstance(DocumentRevisionProvider.class, \"database\");\n            this.componentManager.registerComponent(DocumentRevisionProvider.class, databaseRevisionProvider);\n        }\n\n        getXWikiContext().setLocale(Locale.ENGLISH);\n\n        // XWikiStoreInterface\n\n        when(getMockStore().getTranslationList(anyXWikiDocument(), anyXWikiContext())).then(new Answer<List<String>>()\n        {\n            @Override\n            public List<String> answer(InvocationOnMock invocation) throws Throwable\n            {\n                XWikiDocument document = invocation.getArgument(0);\n\n                List<String> translations = new ArrayList<String>();\n\n                for (XWikiDocument storedDocument : documents.values()) {\n                    Locale storedLocale = storedDocument.getLocale();\n                    if (!storedLocale.equals(Locale.ROOT)\n                        && storedDocument.getDocumentReference().equals(document.getDocumentReference())) {\n                        translations.add(storedLocale.toString());\n                    }\n                }\n\n                return translations;\n            }\n        });\n        when(getMockStore().loadXWikiDoc(anyXWikiDocument(), anyXWikiContext())).then(new Answer<XWikiDocument>()\n        {\n            @Override\n            public XWikiDocument answer(InvocationOnMock invocation) throws Throwable\n            {\n                // The store is based on the contex for the wiki\n                DocumentReference reference = invocation.<XWikiDocument>getArgument(0).getDocumentReferenceWithLocale();\n                XWikiContext xcontext = invocation.getArgument(1);\n                if (!xcontext.getWikiReference().equals(reference.getWikiReference())) {\n                    reference = reference.setWikiReference(xcontext.getWikiReference());\n                }\n\n                XWikiDocument document = documents.get(reference);\n\n                if (document == null) {\n                    document = new XWikiDocument(reference, reference.getLocale());\n                    document.setSyntax(Syntax.PLAIN_1_0);\n                    document.setOriginalDocument(document.clone());\n                }\n\n                return document;\n            }\n        });\n        when(getMockStore().exists(anyXWikiDocument(), anyXWikiContext())).then(new Answer<Boolean>()\n        {\n            @Override\n            public Boolean answer(InvocationOnMock invocation) throws Throwable\n            {\n                // The store is based on the context for the wiki\n                DocumentReference reference = invocation.<XWikiDocument>getArgument(0).getDocumentReferenceWithLocale();\n                XWikiContext xcontext = invocation.getArgument(1);\n                if (!xcontext.getWikiReference().equals(reference.getWikiReference())) {\n                    reference = reference.setWikiReference(xcontext.getWikiReference());\n                }\n\n                return documents.containsKey(reference);\n            }\n        });\n        doAnswer(new Answer<Void>()\n        {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable\n            {\n                // The store is based on the context for the wiki\n                DocumentReference reference = invocation.<XWikiDocument>getArgument(0).getDocumentReferenceWithLocale();\n                XWikiContext xcontext = invocation.getArgument(1);\n                if (!xcontext.getWikiReference().equals(reference.getWikiReference())) {\n                    reference = reference.setWikiReference(xcontext.getWikiReference());\n                }\n\n                documents.remove(reference);\n                documentArchives.remove(reference);\n\n                return null;\n            }\n        }).when(getMockStore()).deleteXWikiDoc(anyXWikiDocument(), anyXWikiContext());\n        doAnswer(new Answer<Void>()\n        {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable\n            {\n                XWikiDocument document = invocation.getArgument(0);\n\n                // The store is based on the context for the wiki\n                DocumentReference reference = document.getDocumentReferenceWithLocale();\n                XWikiContext xcontext = invocation.getArgument(1);\n                if (!xcontext.getWikiReference().equals(reference.getWikiReference())) {\n                    reference = reference.setWikiReference(xcontext.getWikiReference());\n                }\n\n                if (document.isContentDirty() || document.isMetaDataDirty()) {\n                    document.setDate(new Date());\n                    if (document.isContentDirty()) {\n                        document.setContentUpdateDate(new Date());\n                        document.setContentAuthorReference(document.getAuthorReference());\n                    }\n                    document.incrementVersion();\n\n                    document.setContentDirty(false);\n                    document.setMetaDataDirty(false);\n\n                    if (supportRevisionStore) {\n                        // Save the document in the document archive.\n                        getMockVersioningStore().updateXWikiDocArchive(document, true, xcontext);\n                    }\n                }\n                document.setNew(false);\n                document.setStore(getMockStore());\n\n                XWikiDocument savedDocument = document.clone();\n\n                documents.put(document.getDocumentReferenceWithLocale(), savedDocument);\n\n\n                // Set the document as it's original document\n                savedDocument.setOriginalDocument(savedDocument.clone());\n\n                return null;\n            }\n        }).when(getMockStore()).saveXWikiDoc(anyXWikiDocument(), anyXWikiContext());\n        when(getMockStore().getLimitSize(any(), any(), any())).thenReturn(255);\n\n        // XWikiVersioningStoreInterface\n\n        when(getMockVersioningStore().getXWikiDocumentArchive(anyXWikiDocument(), anyXWikiContext()))\n            .then(new Answer<XWikiDocumentArchive>()\n            {\n                @Override\n                public XWikiDocumentArchive answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = invocation.getArgument(0);\n\n                    // The store is based on the context for the wiki\n                    DocumentReference reference = document.getDocumentReferenceWithLocale();\n\n                    XWikiDocumentArchive archiveDoc = documentArchives.get(reference);\n\n                    if (archiveDoc == null) {\n                        XWikiContext xcontext = invocation.getArgument(1);\n                        String db = xcontext.getWikiId();\n                        try {\n                            if (reference.getWikiReference().getName() != null) {\n                                xcontext.setWikiId(reference.getWikiReference().getName());\n                            }\n                            archiveDoc = new XWikiDocumentArchive(document.getId());\n                            document.setDocumentArchive(archiveDoc);\n                            documentArchives.put(reference, archiveDoc);\n                        } finally {\n                            xcontext.setWikiId(db);\n                        }\n                    }\n\n                    return archiveDoc;\n                }\n            });\n        when(getMockVersioningStore().getXWikiDocVersions(anyXWikiDocument(), anyXWikiContext()))\n            .then(new Answer<Version[]>()\n            {\n                @Override\n                public Version[] answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocumentArchive archive = getMockVersioningStore()\n                        .getXWikiDocumentArchive(invocation.getArgument(0), invocation.getArgument(1));\n\n                    if (archive == null) {\n                        return new Version[0];\n                    }\n                    Collection<XWikiRCSNodeInfo> nodes = archive.getNodes();\n                    Version[] versions = new Version[nodes.size()];\n                    Iterator<XWikiRCSNodeInfo> it = nodes.iterator();\n                    for (int i = 0; i < versions.length; i++) {\n                        XWikiRCSNodeInfo node = it.next();\n                        versions[versions.length - 1 - i] = node.getId().getVersion();\n                    }\n\n                    return versions;\n                }\n            });\n        doAnswer(new Answer<Void>()\n        {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable\n            {\n                XWikiDocument document = invocation.getArgument(0);\n                XWikiContext xcontext = invocation.getArgument(2);\n\n                XWikiDocumentArchive archiveDoc = getMockVersioningStore().getXWikiDocumentArchive(document, xcontext);\n                archiveDoc.updateArchive(document, document.getAuthor(), document.getDate(), document.getComment(),\n                    document.getRCSVersion(), xcontext);\n                document.setRCSVersion(archiveDoc.getLatestVersion());\n\n                return null;\n            }\n        }).when(getMockVersioningStore()).updateXWikiDocArchive(any(), anyBoolean(), any());\n\n        doAnswer(invocation -> {\n            XWikiDocument baseDocument = invocation.getArgument(0);\n            String revision = invocation.getArgument(1);\n            XWikiContext xContext = invocation.getArgument(2);\n\n            XWikiDocumentArchive archive = getMockVersioningStore().getXWikiDocumentArchive(baseDocument, xContext);\n            Version version = new Version(revision);\n\n            XWikiDocument doc = archive.loadDocument(version, xContext);\n            if (doc == null) {\n                Object[] args = { baseDocument.getDocumentReferenceWithLocale(), version.toString() };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_UNEXISTANT_VERSION,\n                    \"Version {1} does not exist while reading document {0}\", null, args);\n            }\n\n            doc.setStore(baseDocument.getStore());\n\n            // Make sure the attachment of the revision document have the right store\n            for (XWikiAttachment revisionAttachment : doc.getAttachmentList()) {\n                XWikiAttachment attachment = baseDocument.getAttachment(revisionAttachment.getFilename());\n\n                if (attachment != null) {\n                    revisionAttachment.setContentStore(attachment.getContentStore());\n                    revisionAttachment.setArchiveStore(attachment.getArchiveStore());\n                }\n            }\n\n            return doc;\n        }).when(getMockVersioningStore()).loadXWikiDoc(anyXWikiDocument(), anyString(), anyXWikiContext());\n\n        // XWiki\n\n        if (this.mockXWiki) {\n            if (!supportRevisionStore) {\n                doAnswer((Answer<XWikiDocument>) invocation -> {\n                    XWikiDocument doc = invocation.getArgument(0);\n                    String revision = invocation.getArgument(1);\n\n                    if (StringUtils.equals(revision, doc.getVersion())) {\n                        return doc;\n                    }\n\n                    return new XWikiDocument(doc.getDocumentReference());\n                }).when(getSpyXWiki()).getDocument(anyXWikiDocument(), any(), anyXWikiContext());\n            }\n            doAnswer(new Answer<XWikiDocument>()\n            {\n                @Override\n                public XWikiDocument answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = invocation.getArgument(0);\n\n                    String currentWiki = getXWikiContext().getWikiId();\n                    try {\n                        getXWikiContext().setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n                        return getMockStore().loadXWikiDoc(document, getXWikiContext());\n                    } finally {\n                        getXWikiContext().setWikiId(currentWiki);\n                    }\n                }\n            }).when(getSpyXWiki()).getDocument(anyXWikiDocument(), any(XWikiContext.class));\n            doAnswer(new Answer<Void>()\n            {\n                @Override\n                public Void answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = invocation.getArgument(0);\n                    String comment = invocation.getArgument(1);\n                    boolean minorEdit = invocation.getArgument(2);\n                    XWikiContext xcontext = invocation.getArgument(3);\n\n                    boolean isNew = document.isNew();\n\n                    document.setComment(StringUtils.defaultString(comment));\n                    document.setMinorEdit(minorEdit);\n\n                    if (document.isContentDirty() || document.isMetaDataDirty()) {\n                        Date ndate = new Date();\n                        document.setDate(ndate);\n                        if (document.isContentDirty()) {\n                            document.setContentUpdateDate(ndate);\n                            DocumentAuthors authors = document.getAuthors();\n                            authors.setContentAuthor(authors.getEffectiveMetadataAuthor());\n                        }\n                        document.incrementVersion();\n\n                        document.setContentDirty(false);\n                        document.setMetaDataDirty(false);\n\n                        // Save the document in the document archive.\n                        if (supportRevisionStore) {\n                            getMockVersioningStore().updateXWikiDocArchive(document, true, xcontext);\n                        }\n                    }\n                    document.setNew(false);\n                    document.setStore(getMockStore());\n\n                    XWikiDocument previousDocument = documents.get(document.getDocumentReferenceWithLocale());\n\n                    if (previousDocument != null && previousDocument != document) {\n                        for (XWikiAttachment attachment : document.getAttachmentList()) {\n                            if (!attachment.isContentDirty()) {\n                                attachment.setAttachment_content(\n                                    previousDocument.getAttachment(attachment.getFilename()).getAttachment_content());\n                            }\n                        }\n                    }\n\n                    XWikiDocument originalDocument = document.getOriginalDocument();\n                    if (originalDocument == null) {\n                        originalDocument =\n                            spyXWiki.getDocument(document.getDocumentReferenceWithLocale(), getXWikiContext());\n                        document.setOriginalDocument(originalDocument);\n                    }\n\n                    XWikiDocument savedDocument = document.clone();\n                    documents.put(document.getDocumentReferenceWithLocale(), savedDocument);\n\n                    if (isNew) {\n                        if (notifyDocumentCreatedEvent) {\n                            getObservationManager().notify(new DocumentCreatedEvent(document.getDocumentReference()),\n                                document, getXWikiContext());\n                        }\n                    } else {\n                        if (notifyDocumentUpdatedEvent) {\n                            getObservationManager().notify(new DocumentUpdatedEvent(document.getDocumentReference()),\n                                document, getXWikiContext());\n                        }\n                    }\n\n                    // Set the document as it's original document\n                    savedDocument.setOriginalDocument(savedDocument.clone());\n\n                    return null;\n                }\n            }).when(getSpyXWiki()).saveDocument(anyXWikiDocument(), any(String.class), anyBoolean(), anyXWikiContext());\n            doNothing().when(getSpyXWiki()).checkSavingDocument(any(DocumentReference.class), anyXWikiDocument(),\n                any(String.class), anyBoolean(), anyXWikiContext());\n            doAnswer(new Answer<Void>()\n            {\n                @Override\n                public Void answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = invocation.getArgument(0);\n\n                    String currentWiki = null;\n\n                    currentWiki = getXWikiContext().getWikiId();\n                    try {\n                        getXWikiContext().setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n                        getMockStore().deleteXWikiDoc(document, getXWikiContext());\n\n                        if (notifyDocumentDeletedEvent) {\n                            getObservationManager().notify(new DocumentDeletedEvent(document.getDocumentReference()),\n                                document, getXWikiContext());\n                        }\n                    } finally {\n                        getXWikiContext().setWikiId(currentWiki);\n                    }\n\n                    return null;\n                }\n            }).when(getSpyXWiki()).deleteDocument(anyXWikiDocument(), any(Boolean.class), anyXWikiContext());\n            doNothing().when(getSpyXWiki()).checkDeletingDocument(any(DocumentReference.class), anyXWikiDocument(),\n                anyXWikiContext());\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    return getSpyXWiki()\n                        .getDocument((DocumentReference) invocation.getArguments()[0], invocation.getArgument(1))\n                        .getXClass();\n                }\n            }).when(getSpyXWiki()).getXClass(any(DocumentReference.class), anyXWikiContext());\n            doAnswer(new Answer<String>()\n            {\n                @Override\n                public String answer(InvocationOnMock invocation) throws Throwable\n                {\n                    return getXWikiContext().getLanguage();\n                }\n            }).when(getSpyXWiki()).getLanguagePreference(anyXWikiContext());\n\n            // Users\n\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiContext xcontext = invocation.getArgument(0);\n\n                    XWikiDocument userDocument = getSpyXWiki().getDocument(\n                        new DocumentReference(USER_CLASS, new WikiReference(xcontext.getWikiId())), xcontext);\n\n                    final BaseClass userClass = userDocument.getXClass();\n\n                    if (userDocument.isNew()) {\n                        userClass.addTextField(\"first_name\", \"First Name\", 30);\n                        userClass.addTextField(\"last_name\", \"Last Name\", 30);\n                        userClass.addEmailField(\"email\", \"e-Mail\", 30);\n                        userClass.addPasswordField(\"password\", \"Password\", 10);\n                        userClass.addBooleanField(\"active\", \"Active\", \"active\");\n                        userClass.addTextAreaField(\"comment\", \"Comment\", 40, 5);\n                        userClass.addTextField(\"avatar\", \"Avatar\", 30);\n                        userClass.addTextField(\"phone\", \"Phone\", 30);\n                        userClass.addTextAreaField(\"address\", \"Address\", 40, 3);\n\n                        getSpyXWiki().saveDocument(userDocument, xcontext);\n                    }\n\n                    return userClass;\n                }\n            }).when(getSpyXWiki()).getUserClass(anyXWikiContext());\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiContext xcontext = invocation.getArgument(0);\n\n                    XWikiDocument groupDocument = getSpyXWiki().getDocument(\n                        new DocumentReference(GROUP_CLASS, new WikiReference(xcontext.getWikiId())), xcontext);\n\n                    final BaseClass groupClass = groupDocument.getXClass();\n\n                    if (groupDocument.isNew()) {\n                        groupClass.addTextField(\"member\", \"Member\", 30);\n\n                        getSpyXWiki().saveDocument(groupDocument, xcontext);\n                    }\n\n                    return groupClass;\n                }\n            }).when(getSpyXWiki()).getGroupClass(anyXWikiContext());\n\n            // RightsClass\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiContext xcontext = invocation.getArgument(0);\n\n                    XWikiDocument rightDocument = getSpyXWiki().getDocument(\n                        new DocumentReference(RIGHTS_CLASS, new WikiReference(xcontext.getWikiId())), xcontext);\n\n                    final BaseClass rightClass = rightDocument.getXClass();\n\n                    if (rightDocument.isNew()) {\n                        rightClass.addTextField(\"groups\", \"groups\", 80);\n                        rightClass.addTextField(\"levels\", \"Access Levels\", 80);\n                        rightClass.addTextField(\"users\", \"Users\", 80);\n                        rightClass.addBooleanField(\"allow\", \"Allow/Deny\", \"allow\");\n                        getSpyXWiki().saveDocument(rightDocument, xcontext);\n                    }\n\n                    return rightClass;\n                }\n            }).when(getSpyXWiki()).getRightsClass(anyXWikiContext());\n\n            // GlobalRightsClass\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiContext xcontext = invocation.getArgument(0);\n\n                    XWikiDocument globalRightDocument = getSpyXWiki().getDocument(\n                        new DocumentReference(GLOBAL_RIGHTS_CLASS, new WikiReference(xcontext.getWikiId())), xcontext);\n\n                    final BaseClass globalRightClass = globalRightDocument.getXClass();\n\n                    if (globalRightDocument.isNew()) {\n                        globalRightClass.addTextField(\"groups\", \"groups\", 80);\n                        globalRightClass.addTextField(\"levels\", \"Access Levels\", 80);\n                        globalRightClass.addTextField(\"users\", \"Users\", 80);\n                        globalRightClass.addBooleanField(\"allow\", \"Allow/Deny\", \"allow\");\n                        getSpyXWiki().saveDocument(globalRightDocument, xcontext);\n                    }\n\n                    return globalRightClass;\n                }\n            }).when(getSpyXWiki()).getGlobalRightsClass(anyXWikiContext());\n        }\n\n        // DocumentAccessBridge\n        if (!this.componentManager.hasComponent(DocumentAccessBridge.class)) {\n            this.documentAccessBridge = this.componentManager.registerMockComponent(DocumentAccessBridge.class);\n        } else {\n            this.documentAccessBridge = this.componentManager.getInstance(DocumentAccessBridge.class);\n        }\n        if (MockUtil.isMock(this.documentAccessBridge)) {\n            when(this.documentAccessBridge.exists(any(DocumentReference.class))).thenAnswer(new Answer<Boolean>()\n            {\n                @Override\n                public Boolean answer(InvocationOnMock invocation) throws Throwable\n                {\n                    DocumentReference documentReference = invocation.getArgument(0);\n\n                    return spyXWiki.exists(documentReference, context);\n                }\n            });\n        }\n\n        // Query Manager\n        // If there's already a Query Manager registered, use it instead.\n        // This allows, for example, using @ComponentList to use the real Query Manager, in integration tests.\n        if (!this.componentManager.hasComponent(QueryManager.class)) {\n            mockQueryManager();\n        }\n        when(getMockStore().getQueryManager()).then(new Answer<QueryManager>()\n        {\n\n            @Override\n            public QueryManager answer(InvocationOnMock invocation) throws Throwable\n            {\n                return getQueryManager();\n            }\n        });\n\n        // WikiDescriptorManager\n        // If there's already a WikiDescriptorManager registered, use it instead.\n        // This allows, for example, using @ComponentList to use the real WikiDescriptorManager, in integration tests.\n        if (!this.componentManager.hasComponent(WikiDescriptorManager.class)) {\n            this.wikiDescriptorManager = getMocker().registerMockComponent(WikiDescriptorManager.class);\n            when(this.wikiDescriptorManager.getMainWikiId()).then(new Answer<String>()\n            {\n                @Override\n                public String answer(InvocationOnMock invocation) throws Throwable\n                {\n                    return getXWikiContext().getMainXWiki();\n                }\n            });\n            when(this.wikiDescriptorManager.getCurrentWikiId()).then(new Answer<String>()\n            {\n                @Override\n                public String answer(InvocationOnMock invocation) throws Throwable\n                {\n                    return getXWikiContext().getWikiId();\n                }\n            });\n        }\n\n        DefaultParameterizedType userReferenceDocumentReferenceResolverType =\n            new DefaultParameterizedType(null, UserReferenceResolver.class, DocumentReference.class);\n        if (!this.componentManager.hasComponent(userReferenceDocumentReferenceResolverType, \"document\")) {\n            UserReferenceResolver<DocumentReference> userReferenceResolver =\n                getMocker().registerMockComponent(userReferenceDocumentReferenceResolverType, \"document\");\n\n            DefaultParameterizedType userReferenceDocumentReferenceSerializer =\n                new DefaultParameterizedType(null, UserReferenceSerializer.class, DocumentReference.class);\n            UserReferenceSerializer<DocumentReference> documentReferenceUserReferenceSerializer;\n            if (!this.componentManager.hasComponent(userReferenceDocumentReferenceSerializer, \"document\")) {\n                documentReferenceUserReferenceSerializer =\n                    getMocker().registerMockComponent(userReferenceDocumentReferenceSerializer, \"document\");\n            } else {\n                documentReferenceUserReferenceSerializer =\n                    getMocker().getInstance(userReferenceDocumentReferenceSerializer, \"document\");\n            }\n\n            // we ensure that when trying to resolve a DocumentReference to UserReference, then the returned mock\n            // will return the original DocumentReference when resolved back to DocumentReference.\n            when(userReferenceResolver.resolve(any())).then(invocationOnMock -> {\n                UserReference userReference = mock(UserReference.class);\n                when(documentReferenceUserReferenceSerializer.serialize(userReference))\n                    .thenReturn(invocationOnMock.getArgument(0));\n                return userReference;\n            });\n        }\n    }\n\n    protected DocumentReference resolveDocument(String documentName) throws ComponentLookupException\n    {\n        DocumentReferenceResolver<String> resolver =\n            getMocker().getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");\n\n        return resolver.resolve(documentName);\n    }\n\n    public void after() throws Exception\n    {\n        Utils.setComponentManager(null);\n\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.removeContext();\n    }\n\n    public XWikiContext getXWikiContext()\n    {\n        return this.context;\n    }\n\n    /**\n     * @since 7.3RC1\n     */\n    public XWiki getSpyXWiki()\n    {\n        return this.spyXWiki;\n    }\n\n    /**\n     * @deprecated since 7.3RC1, use {@link #getSpyXWiki()} instead\n     */\n    @Deprecated\n    public XWiki getMockXWiki()\n    {\n        return getSpyXWiki();\n    }\n\n    public File getPermanentDirectory()\n    {\n        return this.permanentDirectory;\n    }\n\n    public File getTemporaryDirectory()\n    {\n        return this.temporaryDirectory;\n    }\n\n    /**\n     * @since 15.0RC1\n     * @since 14.10.2\n     */\n    public DocumentAccessBridge getDocumentAccessBridge()\n    {\n        return this.documentAccessBridge;\n    }\n\n    public XWikiRightService getMockRightService()\n    {\n        return this.mockRightService;\n    }\n\n    public XWikiAuthService getMockAuthService()\n    {\n        return this.mockAuthService;\n    }\n\n    public XWikiGroupService getMockGroupService()\n    {\n        return this.mockGroupService;\n    }\n\n    public AuthorizationManager getMockAuthorizationManager()\n    {\n        return this.mockAuthorizationManager;\n    }\n\n    public ContextualAuthorizationManager getMockContextualAuthorizationManager()\n    {\n        return this.mockContextualAuthorizationManager;\n    }\n\n    public XWikiStoreInterface getMockStore()\n    {\n        return this.mockXWikiHibernateStore;\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public XWikiVersioningStoreInterface getMockVersioningStore()\n    {\n        return this.mockVersioningStore;\n    }\n\n    /**\n     * @since 6.0RC1\n     */\n    public ExecutionContext getExecutionContext() throws ComponentLookupException\n    {\n        return this.componentManager.<Execution>getInstance(Execution.class).getContext();\n    }\n\n    /**\n     * @since 8.3M1\n     */\n    public ScriptContext getScriptContext()\n    {\n        return this.scriptContext;\n    }\n\n    /**\n     * @since 6.1M2\n     */\n    public Map<DocumentReference, XWikiDocument> getDocuments()\n    {\n        return this.documents;\n    }\n\n    /**\n     * @since 6.1M2\n     */\n    public ObservationManager getObservationManager() throws ComponentLookupException\n    {\n        return getMocker().getInstance(ObservationManager.class);\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    public QueryManager getQueryManager() throws ComponentLookupException\n    {\n        if (this.queryManager == null) {\n            this.queryManager = this.componentManager.getInstance(QueryManager.class);\n        }\n\n        return this.queryManager;\n    }\n\n    /**\n     * Force mocking query manager.\n     * \n     * @return 7.2M1\n     */\n    public QueryManager mockQueryManager() throws Exception\n    {\n        this.queryManager = getMocker().registerMockComponent(QueryManager.class);\n\n        return this.queryManager;\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public WikiDescriptorManager getWikiDescriptorManager() throws ComponentLookupException\n    {\n        if (this.wikiDescriptorManager == null) {\n            // Avoid initializing it if not needed\n            if (this.componentManager.hasComponent(WikiDescriptorManager.class)) {\n                this.wikiDescriptorManager = this.componentManager.getInstance(WikiDescriptorManager.class);\n            }\n        }\n\n        return this.wikiDescriptorManager;\n    }\n\n    /**\n     * Return the default configuration, which is also registered for xwikiproperties.\n     * @since 7.1M1\n     */\n    public MemoryConfigurationSource getConfigurationSource()\n    {\n        return this.configurationSource;\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public MemoryConfigurationSource getMockXWikiCfg()\n    {\n        return this.xwikicfgConfigurationSource;\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public MemoryConfigurationSource getMockWikiConfigurationSource()\n    {\n        return this.wikiConfigurationSource;\n    }\n\n    private void initEnvironmentDirectories()\n    {\n        File testDirectory = XWikiTempDirUtil.createTemporaryDirectory();\n\n        this.temporaryDirectory = new File(testDirectory, \"temporary\");\n        this.permanentDirectory = new File(testDirectory, \"permanent-dir\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void registerMockEnvironment() throws Exception\n    {\n        this.environment = getMocker().registerMockComponent(Environment.class);\n\n        initEnvironmentDirectories();\n\n        when(this.environment.getTemporaryDirectory()).thenReturn(this.temporaryDirectory);\n        when(this.environment.getPermanentDirectory()).thenReturn(this.permanentDirectory);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.internal.macro.context;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.rendering.async.internal.AbstractExecutedContentMacro;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererConfiguration;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.macro.MacroExecutionException;\nimport org.xwiki.rendering.macro.context.ContextMacroParameters;\nimport org.xwiki.rendering.macro.context.TransformationContextMode;\nimport org.xwiki.rendering.macro.descriptor.DefaultContentDescriptor;\nimport org.xwiki.rendering.macro.source.MacroContentWikiSource;\nimport org.xwiki.rendering.macro.source.MacroContentWikiSourceFactory;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.MacroTransformationContext;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationManager;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\n/**\n * Execute the macro's content in the context of another document's reference.\n * \n * @version $Id$\n * @since 3.0M1\n */\n@Component\n@Named(\"context\")\n@Singleton\npublic class ContextMacro extends AbstractExecutedContentMacro<ContextMacroParameters>\n{\n    /**\n     * The description of the macro.\n     */\n    private static final String DESCRIPTION = \"Executes content in the context of the passed document\";\n\n    /**\n     * The description of the macro content.\n     */\n    private static final String CONTENT_DESCRIPTION = \"The content to execute\";\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private TransformationManager transformationManager;\n\n    @Inject\n    private MacroContentWikiSourceFactory contentFactory;\n\n    @Inject\n    @Named(\"macro\")\n    private DocumentReferenceResolver<String> macroReferenceResolver;\n\n    /**\n     * Create and initialize the descriptor of the macro.\n     */\n    public ContextMacro()\n    {\n        super(\"Context\", DESCRIPTION, new DefaultContentDescriptor(CONTENT_DESCRIPTION, false, Block.LIST_BLOCK_TYPE),\n            ContextMacroParameters.class);\n\n        setDefaultCategories(Set.of(DEFAULT_CATEGORY_DEVELOPMENT));\n    }\n\n    private void checkAccess(DocumentReference currentAuthor, DocumentReference referencedDocReference)\n        throws MacroExecutionException\n    {\n        // Current author must have view right on the target document to use it as context document\n        try {\n            this.authorizationManager.checkAccess(Right.VIEW, currentAuthor, referencedDocReference);\n        } catch (AccessDeniedException e) {\n            throw new MacroExecutionException(\"Author [\" + currentAuthor\n                + \"] is not allowed to access target document [\" + referencedDocReference + \"]\", e);\n        }\n    }\n\n    @Override\n    public List<Block> execute(ContextMacroParameters parameters, String macroContent,\n        MacroTransformationContext context) throws MacroExecutionException\n    {\n        MetaData metadata;\n        if (parameters.getDocument() != null) {\n            metadata = new MetaData();\n            metadata.addMetaData(MetaData.SOURCE, parameters.getDocument());\n            metadata.addMetaData(MetaData.BASE, parameters.getDocument());\n        } else {\n            metadata = null;\n        }\n        String content = macroContent;\n        Syntax syntax = null;\n        if (parameters.getSource() != null) {\n            MacroContentWikiSource wikiSource = this.contentFactory.getContent(parameters.getSource(), context);\n            syntax = wikiSource.getSyntax();\n            content = wikiSource.getContent();\n        }\n\n        XDOM xdom = this.parser.parse(content, syntax, context, false, metadata, context.isInline());\n\n        if (xdom.getChildren().isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Block> blocks;\n        if (parameters.isRestricted() || parameters.getTransformationContext() == TransformationContextMode.DOCUMENT\n            || parameters.getTransformationContext() == TransformationContextMode.TRANSFORMATIONS) {\n            // Execute the content in the context of the target document\n            blocks = executeContext(xdom, parameters, context);\n        } else {\n            // The content will be executed in the current context\n            blocks = xdom.getChildren();\n        }\n\n        // Keep metadata so that the result stay associated to context properties when inserted in the parent\n        // XDOM\n        return Arrays.asList(new MetaDataBlock(blocks, xdom.getMetaData()));\n    }\n\n    private List<Block> executeContext(XDOM xdom, ContextMacroParameters parameters, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        DocumentReference referencedDocReference;\n        if (parameters.getDocument() != null) {\n            referencedDocReference =\n                this.macroReferenceResolver.resolve(parameters.getDocument(), context.getCurrentMacroBlock());\n            DocumentReference currentAuthor = this.documentAccessBridge.getCurrentAuthorReference();\n\n            // Make sure the author is allowed to use the target document\n            checkAccess(currentAuthor, referencedDocReference);\n        } else {\n            referencedDocReference = null;\n        }\n\n        // Reuse the very generic async rendering framework (even if we don't do async and caching) since it's\n        // taking\n        // care of many other things\n        BlockAsyncRendererConfiguration configuration = createBlockAsyncRendererConfiguration(null, xdom, context);\n        configuration.setAsyncAllowed(false);\n        configuration.setCacheAllowed(false);\n\n        if (parameters.isRestricted()) {\n            configuration.setResricted(true);\n        }\n\n        Map<String, Object> backupObjects = null;\n        try {\n            if (referencedDocReference != null) {\n                backupObjects = new HashMap<>();\n\n                // Switch the context document\n                this.documentAccessBridge.pushDocumentInContext(backupObjects, referencedDocReference);\n\n                // Apply the transformations but with a Transformation Context having the XDOM of the passed\n                // document so that macros execute on the passed document's XDOM (e.g. the TOC macro will generate\n                // the toc for the passed document instead of the current document).\n                DocumentModelBridge referencedDoc =\n                    this.documentAccessBridge.getTranslatedDocumentInstance(referencedDocReference);\n                XDOM referencedXDOM = referencedDoc.getXDOM();\n\n                if (parameters.getTransformationContext() == TransformationContextMode.TRANSFORMATIONS) {\n                    // Get the XDOM from the referenced doc but with Transformations applied so that all macro are\n                    // executed and contribute XDOM elements.\n                    // IMPORTANT: This can be dangerous since it means executing macros, and thus also script macros\n                    // defined in the referenced document. To be used with caution.\n                    TransformationContext referencedTxContext =\n                        new TransformationContext(referencedXDOM, referencedDoc.getSyntax());\n                    this.transformationManager.performTransformations(referencedXDOM, referencedTxContext);\n                }\n\n                // Configure the Transformation Context XDOM depending on the mode asked.\n                configuration.setXDOM(referencedXDOM);\n            }\n\n            // Execute the content\n            Block result = this.executor.execute(configuration);\n\n            return result.getChildren();\n        } catch (Exception e) {\n            throw new MacroExecutionException(\"Failed start the execution of the macro\", e);\n        } finally {\n            if (backupObjects != null) {\n                // Restore the context document\n                this.documentAccessBridge.popDocumentFromContext(backupObjects);\n            }\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.security.authorization.internal;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.internal.XWikiConstants;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\n/**\n * Default implementation of the {@link ContextualAuthorizationManager}.\n *\n * @version $Id$\n * @since 6.1RC1\n */\n@Component\n@Singleton\npublic class DefaultContextualAuthorizationManager implements ContextualAuthorizationManager\n{\n    /**\n     * Rights to be checked for the content author instead of the current user.\n     */\n    private static final Set<Right> CONTENT_AUTHOR_RIGHTS =\n        new HashSet<Right>(Arrays.asList(Right.SCRIPT, Right.PROGRAM));\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private RenderingContext renderingContext;\n\n    @Inject\n    @Named(\"current\")\n    private EntityReferenceResolver<EntityReference> resolver;\n\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    @Override\n    public void checkAccess(Right right) throws AccessDeniedException\n    {\n        if (CONTENT_AUTHOR_RIGHTS.contains(right)) {\n            checkAccess(right, getCurrentUser(right, null), getCurrentAuthorDocumentReference(right));\n        } else {\n            checkAccess(right, getCurrentEntity());\n        }\n    }\n\n    @Override\n    public void checkAccess(Right right, EntityReference entity) throws AccessDeniedException\n    {\n        DocumentReference user = getCurrentUser(right, entity);\n\n        checkAccess(right, user, entity);\n    }\n\n    private void checkAccess(Right right, DocumentReference user, EntityReference entity) throws AccessDeniedException\n    {\n        if (!checkPreAccess(right)) {\n            throw new AccessDeniedException(right, user, entity);\n        }\n\n        this.authorizationManager.checkAccess(right, user, getFullReference(entity));\n    }\n\n    @Override\n    public boolean hasAccess(Right right)\n    {\n        if (CONTENT_AUTHOR_RIGHTS.contains(right)) {\n            return hasAccess(right, getCurrentUser(right, null), getCurrentAuthorDocumentReference(right));\n        }\n\n        return hasAccess(right, getCurrentEntity());\n    }\n\n    @Override\n    public boolean hasAccess(Right right, EntityReference entity)\n    {\n        DocumentReference user = getCurrentUser(right, entity);\n\n        return hasAccess(right, user, entity);\n    }\n\n    private boolean hasAccess(Right right, DocumentReference user, EntityReference entity)\n    {\n        return checkPreAccess(right) && this.authorizationManager.hasAccess(right, user, getFullReference(entity));\n    }\n\n    private EntityReference getFullReference(EntityReference reference)\n    {\n        return reference != null ? this.resolver.resolve(reference, reference.getType()) : null;\n    }\n\n    /**\n     * Check pre-condition for access.\n     *\n     * @param right the right being checked.\n     * @return true if pre-condition are fulfilled.\n     */\n    private boolean checkPreAccess(Right right)\n    {\n        if (CONTENT_AUTHOR_RIGHTS.contains(right)) {\n            if (this.renderingContext.isRestricted()) {\n                return false;\n            } else if (right == Right.PROGRAM && this.xcontextProvider.get().hasDroppedPermissions()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private DocumentReference getCurrentUser(Right right, EntityReference entity)\n    {\n        // Backward compatibility for the old way of assigning programming right.\n        if (CONTENT_AUTHOR_RIGHTS.contains(right)) {\n            XWikiDocument doc = entity == null ? getProgrammingDocument() : getDocument(entity);\n            if (doc != null) {\n                return getContentAuthor(doc);\n            }\n        }\n\n        return this.xcontextProvider.get().getUserReference();\n    }\n\n    private DocumentReference getCurrentAuthorDocumentReference(Right right)\n    {\n        if (right == Right.PROGRAM) {\n            // Defaults to the main wiki reference.\n            return null;\n        }\n\n        XWikiDocument doc = getProgrammingDocument();\n\n        return doc != null ? doc.getDocumentReference() : null;\n    }\n\n    private XWikiDocument getDocument(EntityReference entity)\n    {\n        if (entity == null) {\n            return null;\n        }\n\n        EntityReference docEntity = entity.extractReference(EntityType.DOCUMENT);\n        if (docEntity == null) {\n            return null;\n        }\n\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        try {\n            return xcontext.getWiki().getDocument(new DocumentReference(docEntity), xcontext);\n        } catch (Exception e) {\n            // Ignored\n        }\n\n        return null;\n    }\n\n    /**\n     * @param doc a document.\n     * @return the content author reference of that document.\n     */\n    private DocumentReference getContentAuthor(XWikiDocument doc)\n    {\n        DocumentReference user = doc.getContentAuthorReference();\n\n        if (user != null && XWikiConstants.GUEST_USER.equals(user.getName())) {\n            // Public users (not logged in) should be passed as null in the new API. It may happen that badly\n            // design code, and poorly written API does not take care, so we prevent security issue here.\n            user = null;\n        }\n\n        return user;\n    }\n\n    /**\n     * Get the current entity from context.\n     *\n     * @return the current sdoc or doc document reference, or the current wiki reference if no doc available.\n     */\n    private EntityReference getCurrentEntity()\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n        XWikiDocument doc = xcontext.getDoc();\n\n        if (doc != null) {\n            return doc.getDocumentReference();\n        }\n\n        return null;\n    }\n\n    /**\n     * Get the document used to test programming right.\n     *\n     * @return the current sdoc or doc document, null if no doc available.\n     */\n    private XWikiDocument getProgrammingDocument()\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        XWikiDocument document = (XWikiDocument) xcontext.get(XWikiDocument.CKEY_SDOC);\n        if (document == null) {\n            document = xcontext.getDoc();\n        }\n\n        return document;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.security.authorization.internal;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.ArgumentMatchers.same;\nimport static org.mockito.Mockito.verify;\n\n/**\n * Validate {@link DefaultContextualAuthorizationManager}.\n * \n * @version $Id$\n */\n@ReferenceComponentList\n@OldcoreTest\nclass DefaultContextualAuthorizationManagerTest\n{\n    @MockComponent\n    private AuthorizationManager authorizationManager;\n\n    @InjectMockComponents\n    private DefaultContextualAuthorizationManager contextualAuthorizationManager;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    private WikiReference currentWikiReference;\n\n    @BeforeEach\n    public void before() throws Exception\n    {\n        this.currentWikiReference = new WikiReference(\"wiki\");\n        this.oldcore.getXWikiContext().setWikiId(this.currentWikiReference.getName());\n    }\n\n    // Tests\n\n    @Test\n    void checkAccess() throws Exception\n    {\n        LocalDocumentReference localReference = new LocalDocumentReference(\"space\", \"page\");\n\n        this.contextualAuthorizationManager.checkAccess(Right.VIEW, localReference);\n\n        verify(this.authorizationManager).checkAccess(same(Right.VIEW), isNull(),\n            eq(new DocumentReference(localReference, this.currentWikiReference)));\n    }\n\n    @Test\n    void hasAccess()\n    {\n        LocalDocumentReference localReference = new LocalDocumentReference(\"space\", \"page\");\n\n        this.contextualAuthorizationManager.hasAccess(Right.VIEW, localReference);\n\n        verify(this.authorizationManager).hasAccess(same(Right.VIEW), isNull(),\n            eq(new DocumentReference(localReference, this.currentWikiReference)));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.test.ui.po;\n\nimport java.util.List;\n\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.NoSuchElementException;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.FindBy;\n\n/**\n * Represents the actions possible on the History Pane at the bottom of a page.\n * \n * @version $Id$\n * @since 3.2M3\n */\npublic class HistoryPane extends BaseElement\n{\n    @FindBy(id = \"historycontent\")\n    private WebElement pane;\n\n    public boolean isOpened()\n    {\n        return this.pane.isDisplayed();\n    }\n\n    public boolean hasVersionWithSummary(String summary)\n    {\n        List<WebElement> tableEntries = pane.findElements(By.xpath(\".//table/tbody/tr\"));\n        By commentVersionXPath;\n        try {\n            pane.findElement(By.xpath(\".//tr[2]/td/input\"));\n            commentVersionXPath = By.xpath(\".//td[6]\");\n        } catch (NoSuchElementException e) {\n            commentVersionXPath = By.xpath(\".//td[4]\");\n        }\n        for (WebElement tableEntry : tableEntries) {\n            try {\n                WebElement cell = tableEntry.findElement(commentVersionXPath);\n                if (cell.getText().trim().contentEquals(summary)) {\n                    return true;\n                }\n            } catch (NoSuchElementException e) {\n                // Ignore, better luck next time.\n            }\n        }\n        return false;\n    }\n\n    public String getCurrentVersion()\n    {\n        return getCurrentItemInTable(\"td[3]/a\", \"td[1]/a\");\n    }\n\n    public String getCurrentVersionComment()\n    {\n        return getCurrentItemInTable(\"td[6]\", \"td[4]\");\n    }\n\n    public String getCurrentAuthor()\n    {\n        return getCurrentItemInTable(\"td[4]\", \"td[2]\");\n    }\n\n    private String getCurrentItemInTable(String xpathFragment1, String xpathFragment2)\n    {\n        try {\n            // Try to find a radio button. This will mean there are several revisions in the table\n            // and we'll find the version written down in the 3rd column\n            getDriver().findElementWithoutWaiting(this.pane, By.xpath(\".//tr[2]/td/input\"));\n            return getDriver().findElementWithoutWaiting(this.pane,\n                By.xpath(\".//*[contains(@class, 'currentversion')]/\" + xpathFragment1)).getText();\n        } catch (NoSuchElementException e) {\n            // If we couldn't find the radio button, there is less columns displayed and the version will be\n            // in the first column\n            return getDriver().findElementWithoutWaiting(this.pane,\n                By.xpath(\".//*[contains(@class, 'currentversion')]/\" + xpathFragment2)).getText();\n        }\n    }\n\n    /**\n     * IMPORTANT: this method isn't blocking and doesn't wait for the page to be loaded (after the confirmation popup\n     *            has been accepted).\n     */\n    public ViewPage rollbackToVersion(String version)\n    {\n        getDriver().makeConfirmDialogSilent(true);\n\n        pane.findElement(\n            By.xpath(\".//table//tr[contains(., '\" + version\n                + \"')]//td[@class='xwikibuttonlink']/a[contains(.,'Rollback')]\")).click();\n\n        // A new page is loaded after the dialog is accepted, thus we need to wait that it's loaded before returning\n        // as otherwise following actions may be performed on the current page and not on the new page.\n        // TODO: Find a generic way to test for this condition. Right now users of this method need to perform their\n        // own wait.\n\n        return new ViewPage();\n    }\n\n    public HistoryPane deleteVersion(String version)\n    {\n        getDriver().makeConfirmDialogSilent(true);\n\n        pane.findElement(\n            By.xpath(\".//table//tr[contains(., '\" + version\n                + \"')]//td[@class='xwikibuttonlink']/a[contains(.,'Delete')]\")).click();\n\n        return new HistoryPane();\n    }\n\n    /**\n     * Clicks on the 'Show Minor Edits' button.\n     * \n     * @return the new history pane that includes the minor edits\n     */\n    public HistoryPane showMinorEdits()\n    {\n        getDriver().findElementWithoutWaiting(pane, By.name(\"viewMinorVersions\")).click();\n        return new HistoryPane();\n    }\n\n\n    private void selectVersions(String fromVersion, String toVersion)\n    {\n        String versionXPath = \".//input[@name = 'rev%s' and @value = '%s']\";\n        getDriver().findElementWithoutWaiting(pane, By.xpath(String.format(versionXPath, 1, fromVersion))).click();\n        getDriver().findElementWithoutWaiting(pane, By.xpath(String.format(versionXPath, 2, toVersion))).click();\n    }\n\n    public HistoryPane deleteRangeVersions(String fromVersion, String toVersion)\n    {\n        getDriver().makeConfirmDialogSilent(true);\n        this.selectVersions(fromVersion, toVersion);\n        getDriver().findElementWithoutWaiting(pane, By.xpath(\".//input[@name = 'deleteVersions']\")).click();\n\n        return new HistoryPane();\n    }\n\n    /**\n     * Selects the specified document versions and clicks the button to compare them.\n     * \n     * @param fromVersion the from version\n     * @param toVersion the to version\n     * @return the page that shows the differences between the selected pages\n     */\n    public ComparePage compare(String fromVersion, String toVersion)\n    {\n        this.selectVersions(fromVersion, toVersion);\n        getDriver().findElementWithoutWaiting(pane, By.xpath(\".//input[@accesskey = 'c']\")).click();\n        return new ComparePage();\n    }\n}\n", "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n#template('diff_macros.vm')\n##\n## Preamble: which versions are being compared\n##\n\n#if (\"$!previousOrigdocVersion\" != '')\n  #set ($changesLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${previousOrigdocVersion}&rev2=${rev2}\")})\n  #set ($changesTitle = $services.localization.render('core.viewers.diff.previousVersion'))\n  #set ($previousOrigdocLink = \"<a class='changes-arrow' href='$changesLink' title='$changesTitle'>&lt;</a>\")\n#end\n#if (\"$!nextOrigdocVersion\" != '')\n  #set ($changesLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${nextOrigdocVersion}&rev2=${rev2}\")})\n  #set ($changesTitle = $services.localization.render('core.viewers.diff.nextVersion'))\n  #set ($nextOrigdocLink = \"<a class='changes-arrow' href='$changesLink' title='$changesTitle'>&gt;</a>\")\n#end\n#if (\"$!previousNewdocVersion\" != '')\n  #set ($changesLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${rev1}&rev2=${previousNewdocVersion}\")})\n  #set ($changesTitle = $services.localization.render('core.viewers.diff.previousVersion'))\n  #set ($previousNewdocLink = \"<a class='changes-arrow' href='$changesLink' title='$changesTitle'>&lt;</a>\")\n#end\n#if (\"$!nextNewdocVersion\" != '')\n  #set ($changesLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${rev1}&rev2=${nextNewdocVersion}\")})\n  #set ($changesTitle = $services.localization.render('core.viewers.diff.nextVersion'))\n  #set ($nextNewdocLink = \"<a class='changes-arrow' href='$changesLink' title='$changesTitle'>&gt;</a>\")\n#end\n## Display the previous change arrow only if there is a previous version of the original document and there is no extension version\n#if (\"$!previousOrigdocVersion\" != '' && \"$!previousNewdocVersion\" != '')\n  ## Keep the reverse navigation order in case the original document version is greater than the version of the new document\n  #if ($origdoc.RCSVersion.isLessOrEqualThan($newdoc.RCSVersion))\n    #set ($previousLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${previousOrigdocVersion}&rev2=${rev1}\")})\n  #else\n    #set ($previousLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${rev2}&rev2=${previousNewdocVersion}\")})\n  #end\n#end\n## Display the next change arrow only if there is a next version of the new document and there is no extension version\n#if (\"$!nextOrigdocVersion\" != '' && \"$!nextNewdocVersion\" != '')\n  ## Keep the reverse navigation order in case the original document version is greater than the version of the new document\n  #if ($origdoc.RCSVersion.isLessOrEqualThan($newdoc.RCSVersion))\n    #set ($nextLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${rev2}&rev2=${nextNewdocVersion}\")})\n  #else\n    #set ($nextLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${nextOrigdocVersion}&rev2=${rev1}\")})\n  #end\n#end\n\n#set ($from = {\n  'doc': $origdoc,\n  'version': $rev1,\n  'previousVersionLink': $previousOrigdocLink,\n  'nextVersionLink': $nextOrigdocLink,\n  'previousLink': $previousLink\n})\n#set ($to = {\n  'doc': $newdoc,\n  'version': $rev2,\n  'previousVersionLink': $previousNewdocLink,\n  'nextVersionLink': $nextNewdocLink,\n  'nextLink': $nextLink\n})\n#displayDocumentChangesHeader($from $to)\n\n##\n## Changes\n##\n#set ($includes = $request.getParameterValues('include'))\n#if (!$includes)\n  #set ($includes = ['rawChanges'])\n#end\n<div class=\"changes-body\">\n  <div class=\"changes-body-header\">\n    <div class=\"row\">\n      <div class=\"col-xs-12 col-sm-6\">\n        <ul class=\"nav nav-pills\" role=\"tablist\">\n          <li role=\"presentation\" class=\"active\">\n            <a href=\"#rawChanges\" aria-controls=\"rawChanges\" role=\"tab\" data-toggle=\"pill\" data-hint=\"raw\">\n              $escapetool.xml($services.localization.render('web.history.changes.raw'))\n            </a>\n          </li>\n          <li role=\"presentation\">\n            <a href=\"#renderedChanges\" aria-controls=\"renderedChanges\" role=\"tab\" data-toggle=\"pill\" data-hint=\"rendered\">\n              $escapetool.xml($services.localization.render('web.history.changes.rendered'))\n            </a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"col-xs-12 col-md-6\">\n        <div class=\"changes-actions raw active\"></div>\n        <div class=\"changes-actions rendered\">\n          <a href=\"#toggleRenderedDiffContext\" class=\"html-diff-context-toggle html-diff-context-toggle-show hidden\">\n            <span class=\"html-diff-context-show\">\n              $services.icon.renderHTML('plus-square')\n              $escapetool.xml($services.localization.render('web.history.changes.showContext'))\n            </span>\n            <span class=\"html-diff-context-hide\">\n              $services.icon.renderHTML('minus-square')\n              $escapetool.xml($services.localization.render('web.history.changes.hideContext'))\n            </span>\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"tab-content\">\n    <div role=\"tabpanel\" class=\"tab-pane active\" id=\"rawChanges\">\n      #if ($includes.contains('rawChanges'))\n        #displayDocumentRawChanges($origdoc $newdoc)\n      #end\n    </div>\n    <div role=\"tabpanel\" class=\"tab-pane html-diff\" id=\"renderedChanges\">\n      #if ($includes.contains('renderedChanges'))\n        #set ($htmlDiff = $services.diff.html.unified($origdoc.renderedContent, $newdoc.renderedContent))\n        #if ($htmlDiff == '')\n          <div class=\"infomessage\">\n            $escapetool.xml($services.localization.render('web.history.changes.noChanges'))\n          </div>\n        #elseif (\"$!htmlDiff\" == '')\n          <div class=\"errormessage\">\n            $escapetool.xml($services.localization.render('web.history.changes.failedToCompute'))\n          </div>\n        #else\n          $htmlDiff\n        #end\n      #end\n    </div>\n  </div>\n</div>\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.bridge;\n\nimport java.util.Date;\n\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.stability.Unstable;\n\n/**\n * Exposes methods for accessing Documents. This is temporary until we remodel the Model classes and the Document\n * services. The implementation is actually the XWikiDocument class, so this is just a light interface that hides the\n * old xwiki-core.\n * \n * @version $Id$\n * @since 1.6M1\n */\npublic interface DocumentModelBridge\n{    \n    /**\n     * Retrieve the full name of the document, in the <code>Space.Name</code> format, for example {@code Main.WebHome}.\n     * \n     * @return A <code>String</code> representation of the document's full name.\n     * @deprecated use {@link #getDocumentReference} instead\n     */\n    @Deprecated\n    String getFullName();\n\n    /**\n     * @return the document's reference (without the document locale)\n     * @since 2.2M1\n     */\n    DocumentReference getDocumentReference();\n\n    /**\n     * Retrieve the actual language of the document variant. If this is a translation, then it is the language of the\n     * translation. If this is the original variant of the document, then it it is the default language of the document.\n     * \n     * @return The document's language in a 2-letter code.\n     */\n    String getRealLanguage();\n\n    /**\n     * Retrieves the textual content of the document.\n     * \n     * @return The document's content.\n     */\n    String getContent();\n\n    /**\n     * Retrieves a copy of the document before it was changed.\n     * \n     * @return the copy of this Document instance before any modification was made to it.\n     */\n    DocumentModelBridge getOriginalDocument();\n    \n    /**\n     * @return the Syntax id representing the syntax used for the current document. For example \"xwiki/1.0\" represents\n     *         the first version XWiki syntax while \"xwiki/2.0\" represents version 2.0 of the XWiki Syntax.\n     * @deprecated since 3.0M1 use {@link #getSyntax()} instead\n     */\n    @Deprecated\n    String getSyntaxId();\n\n    /**\n     * @return the Syntax id representing the syntax used for the current document. For example \"xwiki/1.0\" represents\n     *         the first version XWiki syntax while \"xwiki/2.0\" represents version 2.0 of the XWiki Syntax.\n     * @since 3.0M1\n     */\n    Syntax getSyntax();\n\n    /**\n     * @return the page to which the document belongs to (eg \"WebHome\")\n     * @deprecated since 2.2M1 use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    String getPageName();\n    \n    /**\n     * Return the full local space reference. For example a document located in sub-space <code>space11</code> of space\n     * <code>space1</code> will return <code>space1.space11</code>.\n     * \n     * @return the space to which the document belongs to (eg \"Main\")\n     * @deprecated since 2.2M1 use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    String getSpaceName();\n\n    /**\n     * Retrieve the name of the virtual wiki this document belongs to.\n     *\n     * @return A <code>String</code> representation of the document's wiki name.\n     * @deprecated since 2.2M1 use {@link #getDocumentReference()}  instead\n     */\n    @Deprecated\n    String getWikiName();\n\n    /**\n     * @return the document's title or null if not set\n     */\n    String getTitle();\n\n    /**\n     * @return a string identifying the current version of this document\n     */\n    String getVersion();\n\n    /**\n     * @return the XDOM for the document\n     * @since 3.0M3\n     */\n    XDOM getXDOM();\n\n    /**\n     * @return the document's content author user reference\n     * @since 7.2M1\n     * @deprecated since 14.0RC1 rely on {@link #getAuthors()}.\n     */\n    @Deprecated\n    DocumentReference getContentAuthorReference();\n\n    /**\n     * @return the various authors information of a document.\n     * @since 14.0RC1\n     */\n    @Unstable\n    default DocumentAuthors getAuthors()\n    {\n        return null;\n    }\n\n    /**\n     * @return the creation date of the current document.\n     * @since 12.8RC1\n     * @since 12.6.3\n     */\n    default Date getCreationDate()\n    {\n        return null;\n    }\n\n    /**\n     * @return {@code true} if the document is hidden.\n     * @since 13.1\n     * @since 12.10.5\n     * @since 12.6.8\n     */\n    default Boolean isHidden()\n    {\n        return false;\n    }\n\n    /**\n     * @return the last save date of the current document.\n     * @since 14.0RC1\n     */\n    @Unstable\n    default Date getDate()\n    {\n        return null;\n    }\n\n    /**\n     * @return {@code true} if the document is restricted, i.e., transformations should be executed in restricted mode\n     * @since 15.2RC1\n     * @since 14.10.7\n     */\n    @Unstable\n    default boolean isRestricted()\n    {\n        return false;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.display.internal;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.ModelContext;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.parser.Parser;\nimport org.xwiki.rendering.util.ParserUtils;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.velocity.VelocityEngine;\nimport org.xwiki.velocity.VelocityManager;\n\n/**\n * Displays the title of a document.\n *\n * @version $Id$\n * @since 3.2M3\n */\npublic abstract class AbstractDocumentTitleDisplayer implements DocumentDisplayer\n{\n    /**\n     * The key used to store on the XWiki context map the stack of references to documents whose titles are currently\n     * being evaluated (in the current execution context). This stack is used to prevent infinite recursion, which can\n     * happen if the title displayer is called on the current document from the title field or from a script within the\n     * first content heading.\n     */\n    private static final String DOCUMENT_REFERENCE_STACK_KEY = \"internal.displayer.title.documentReferenceStack\";\n\n    /**\n     * The object used for logging.\n     */\n    @Inject\n    private Logger logger;\n\n    /**\n     * The component used to parse the rendered title into an XDOM.\n     */\n    @Inject\n    @Named(\"plain/1.0\")\n    private Parser plainTextParser;\n\n    /**\n     * The component used to get the Velocity Engine and the Velocity Context needed to evaluate the Velocity script\n     * from the document title.\n     */\n    @Inject\n    private VelocityManager velocityManager;\n\n    /**\n     * The component used to get the current document reference.\n     */\n    @Inject\n    private DocumentAccessBridge documentAccessBridge;\n\n    /**\n     * The component used to serialize entity references.\n     */\n    @Inject\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Execution context handler, needed for accessing the XWiki context map.\n     */\n    @Inject\n    private Execution execution;\n\n    @Inject\n    @Named(\"xwikicfg\")\n    private ConfigurationSource xwikicfg;\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    /**\n     * Used to get the default document reference, which normally is used to represent the home page of a space.\n     *\n     * @see #getStaticTitle(DocumentModelBridge)\n     */\n    @Inject\n    private EntityReferenceProvider defaultEntityReferenceProvider;\n\n    @Inject\n    private ModelContext modelContext;\n\n    /**\n     * Used to emulate an in-line parsing.\n     */\n    private ParserUtils parserUtils = new ParserUtils();\n\n    @Override\n    public XDOM display(DocumentModelBridge document, DocumentDisplayerParameters parameters)\n    {\n        // Protect against infinite recursion which can happen for instance if the document title displayer is called on\n        // the current document from the title field or from a script within the first content heading.\n        Deque<DocumentReference> documentReferenceStack = getDocumentReferenceDeque();\n\n        if (documentReferenceStack.contains(document.getDocumentReference())) {\n            this.logger.warn(\n                \"Infinite recursion detected while displaying the title of [{}]. Using the document name as title.\",\n                document.getDocumentReference());\n\n            return getStaticTitle(document);\n        }\n\n        documentReferenceStack.push(document.getDocumentReference());\n        try {\n            return displayTitle(document, parameters);\n        } finally {\n            documentReferenceStack.pop();\n        }\n    }\n\n    private Deque<DocumentReference> getDocumentReferenceDeque()\n    {\n        ExecutionContext econtext = this.execution.getContext();\n\n        Deque<DocumentReference> documentReferenceStack =\n            (Deque<DocumentReference>) econtext.getProperty(DOCUMENT_REFERENCE_STACK_KEY);\n\n        if (documentReferenceStack == null) {\n            documentReferenceStack = new LinkedList<>();\n            econtext.newProperty(DOCUMENT_REFERENCE_STACK_KEY).inherited().initial(documentReferenceStack).declare();\n        }\n\n        return documentReferenceStack;\n    }\n\n    private XDOM displayTitle(DocumentModelBridge document, DocumentDisplayerParameters parameters)\n    {\n        // 1. Try to use the title provided by the user.\n        String rawTitle = document.getTitle();\n        if (!StringUtils.isEmpty(rawTitle)) {\n            try {\n                String title = rawTitle;\n                // Evaluate the title only if the document is not restricted and its content's author has script\n                // right, otherwise use the raw title.\n                if (!document.isRestricted() && this.authorizationManager.hasAccess(Right.SCRIPT,\n                    document.getContentAuthorReference(), document.getDocumentReference()))\n                {\n                    title = evaluateTitle(rawTitle, document, parameters);\n                }\n                return parseTitle(title);\n            } catch (Exception e) {\n                logger.warn(\"Failed to interpret title of document [{}].\", document.getDocumentReference(), e);\n            }\n        }\n\n        // 2. Try to extract the title from the document content.\n        if (\"1\".equals(this.xwikicfg.getProperty(\"xwiki.title.compatibility\", \"0\"))) {\n            try {\n                XDOM title = extractTitleFromContent(document, parameters);\n                if (title != null) {\n                    return title;\n                }\n            } catch (Exception e) {\n                logger.warn(\"Failed to extract title from content of document [{}].\", document.getDocumentReference(),\n                    e);\n            }\n        }\n\n        // 3. The title was not specified or its evaluation failed. Use the document name as a fall-back.\n        return getStaticTitle(document);\n    }\n\n    /**\n     * Parses the given title as plain text and returns the generated XDOM.\n     *\n     * @param title the title to be parsed\n     * @return the XDOM generated from parsing the title as plain text\n     */\n    protected XDOM parseTitle(String title)\n    {\n        try {\n            XDOM xdom = plainTextParser.parse(new StringReader(title));\n            parserUtils.removeTopLevelParagraph(xdom.getChildren());\n            return xdom;\n        } catch (ParseException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Evaluates the Velocity script from the specified title.\n     *\n     * @param title the title to evaluate\n     * @param documentReference a reference to the document whose title is evaluated\n     * @param parameters display parameters\n     * @return the result of evaluating the Velocity script from the given title\n     */\n    protected String evaluateTitle(String title, DocumentModelBridge document,\n        DocumentDisplayerParameters parameters)\n    {\n        StringWriter writer = new StringWriter();\n        String namespace = defaultEntityReferenceSerializer.serialize(parameters.isTransformationContextIsolated()\n            ? document.getDocumentReference() : documentAccessBridge.getCurrentDocumentReference());\n\n        // Get the velocity engine\n        VelocityEngine velocityEngine;\n        try {\n            velocityEngine = this.velocityManager.getVelocityEngine();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        // Execute Velocity code\n        Map<String, Object> backupObjects = null;\n        boolean canPop = false;\n        EntityReference currentWikiReference = this.modelContext.getCurrentEntityReference();\n        try {\n            if (parameters.isExecutionContextIsolated()) {\n                backupObjects = new HashMap<>();\n                // The following method call also clones the execution context.\n                documentAccessBridge.pushDocumentInContext(backupObjects, document);\n                // Pop the document from the context only if the push was successful!\n                canPop = true;\n                // Make sure to synchronize the context wiki with the context document's wiki.\n                modelContext.setCurrentEntityReference(document.getDocumentReference().getWikiReference());\n            }\n            velocityEngine.evaluate(velocityManager.getVelocityContext(), writer, namespace, title);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (canPop) {\n                documentAccessBridge.popDocumentFromContext(backupObjects);\n                // Also restore the context wiki.\n                this.modelContext.setCurrentEntityReference(currentWikiReference);\n            }\n        }\n        return writer.toString();\n    }\n\n    /**\n     * Extracts the title from the document content.\n     *\n     * @param document the document to extract the title from\n     * @param parameters display parameters\n     * @return the title XDOM\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    protected abstract XDOM extractTitleFromContent(DocumentModelBridge document,\n        DocumentDisplayerParameters parameters);\n\n    /**\n     * @param document an XWiki document\n     * @return the title used as a fall-back when the dynamic title cannot be evaluated\n     */\n    private XDOM getStaticTitle(DocumentModelBridge document)\n    {\n        String documentName = document.getDocumentReference().getName();\n        if (defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName().equals(documentName)) {\n            // This document represents a space (it is the home page of a space). Use the space name instead.\n            documentName = document.getDocumentReference().getParent().getName();\n        }\n        return parseTitle(documentName);\n    }\n\n    /**\n     * @return the object used for logging\n     */\n    protected Logger getLogger()\n    {\n        return logger;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.display.internal;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.inject.Inject;\n\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.rendering.RenderingException;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.async.internal.AsyncProperties;\nimport org.xwiki.rendering.async.internal.block.AbstractBlockAsyncRenderer;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.syntax.Syntax;\n\n/**\n * Default implementation of DocumentContentAsyncRenderer.\n * \n * @version $Id$\n * @since 11.8RC1\n */\n@Component(roles = DocumentContentAsyncRenderer.class)\npublic class DocumentContentAsyncRenderer extends AbstractBlockAsyncRenderer\n{\n    @Inject\n    private DocumentContentAsyncExecutor executor;\n\n    @Inject\n    private AsyncContext asyncContext;\n\n    @Inject\n    private DocumentAccessBridge documentAccessBridge;\n\n    @Inject\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    @Inject\n    private DocumentContentAsyncParser asyncParser;\n\n    private DocumentDisplayerParameters parameters;\n\n    private AsyncProperties asyncProperties;\n\n    private DocumentReference documentReference;\n\n    private List<String> id;\n\n    /**\n     * @param document the document to execute\n     * @param parameters display parameters\n     * @return the context elements required during the execution\n     */\n    public Set<String> initialize(DocumentModelBridge document, DocumentDisplayerParameters parameters)\n    {\n        this.parameters = parameters;\n\n        // Make sure the restricted property of the document is properly taken into account.\n        if (document.isRestricted()) {\n            parameters.setTransformationContextRestricted(true);\n        }\n\n        this.asyncProperties = this.asyncParser.getAsyncProperties(document);\n\n        String transformationId = this.defaultEntityReferenceSerializer\n            .serialize(parameters.isContentTransformed() && parameters.isTransformationContextIsolated()\n                ? document.getDocumentReference() : this.documentAccessBridge.getCurrentDocumentReference());\n\n        this.documentReference = document.getDocumentReference();\n\n        if (this.asyncProperties.isAsyncAllowed() || this.asyncProperties.isCacheAllowed()) {\n            this.id = createId(\"display\", \"document\", \"content\",\n                this.defaultEntityReferenceSerializer.serialize(this.documentReference), this.parameters.getSectionId(),\n                this.parameters.getTargetSyntax() != null ? this.parameters.getTargetSyntax().toIdString() : \"\",\n                transformationId, this.parameters.isContentTransformed(),\n                this.parameters.isTransformationContextRestricted(), this.parameters.isTransformationContextIsolated());\n        }\n\n        this.executor.initialize(transformationId, document, parameters);\n\n        return this.asyncProperties.getContextElements();\n    }\n\n    @Override\n    public Block execute(boolean async, boolean cached) throws RenderingException\n    {\n        // Register the known involved references\n        this.asyncContext.useEntity(this.documentReference);\n\n        return this.executor.execute(async);\n    }\n\n    @Override\n    public List<String> getId()\n    {\n        return this.id;\n    }\n\n    @Override\n    public boolean isAsyncAllowed()\n    {\n        return this.asyncProperties.isAsyncAllowed();\n    }\n\n    @Override\n    public boolean isCacheAllowed()\n    {\n        return this.asyncProperties.isCacheAllowed();\n    }\n\n    @Override\n    public boolean isInline()\n    {\n        return false;\n    }\n\n    @Override\n    public Syntax getTargetSyntax()\n    {\n        return this.parameters.getTargetSyntax();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.display.internal;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.HeaderBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationException;\nimport org.xwiki.rendering.transformation.TransformationManager;\n\n/**\n * Displays the title of a document. If the title is not specified, extracts the document title from the first heading\n * in the document content that has the level less than or equal to {@link DisplayConfiguration#getTitleHeadingDepth()}.\n * \n * @version $Id$\n * @since 3.2M3\n */\n@Component\n@Named(\"title\")\n@Singleton\npublic class DocumentTitleDisplayer extends AbstractDocumentTitleDisplayer\n{\n    /**\n     * The component used to perform the rendering transformations on the title extracted from the document content.\n     */\n    @Inject\n    private TransformationManager transformationManager;\n\n    /**\n     * The display configuration.\n     */\n    @Inject\n    private DisplayConfiguration displayConfiguration;\n\n    @Override\n    protected XDOM extractTitleFromContent(DocumentModelBridge document, DocumentDisplayerParameters parameters)\n    {\n        // Note: Ideally we should apply transformations on the document's returned XDOM here since macros could\n        // generate headings for example or some other transformations could modify headings. However we don't do this\n        // at the moment since it would be too costly to do so. In the future we will even probably remove the feature\n        // of generating the title from the content.\n        List<HeaderBlock> blocks =\n            document.getXDOM().getBlocks(new ClassBlockMatcher(HeaderBlock.class), Block.Axes.DESCENDANT);\n        if (!blocks.isEmpty()) {\n            HeaderBlock heading = blocks.get(0);\n            // Check the heading depth after which we should return null if no heading was found.\n            if (heading.getLevel().getAsInt() <= displayConfiguration.getTitleHeadingDepth()) {\n                XDOM headingXDOM = new XDOM(Collections.<Block> singletonList(heading));\n                try {\n                    TransformationContext txContext =\n                        new TransformationContext(headingXDOM, document.getSyntax(),\n                            parameters.isTransformationContextRestricted() || document.isRestricted());\n                    txContext.setTargetSyntax(parameters.getTargetSyntax());\n                    transformationManager.performTransformations(headingXDOM, txContext);\n\n                    Block headingBlock = headingXDOM.getChildren().size() > 0 ? headingXDOM.getChildren().get(0) : null;\n                    if (headingBlock instanceof HeaderBlock) {\n                        return new XDOM(headingBlock.getChildren());\n                    }\n                } catch (TransformationException e) {\n                    getLogger().warn(\"Failed to extract title from document content.\");\n                }\n            }\n        }\n        return null;\n    }\n}\n", "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n<div class=\"row document-header\">\n  <div class=\"document-info col-xs-12 #if($displayContentMenu)col-md-7#end\">\n    ## --------------------------------------------------------\n    ## Display UI Extensions before the title element\n    ## --------------------------------------------------------\n    #foreach ($uix in $services.uix.getExtensions('org.xwiki.platform.template.title.before'))\n      $services.rendering.render($uix.execute(), 'xhtml/1.0')\n    #end\n    <div id=\"document-title\"><h1>$titleToDisplay</h1></div>\n    #if (!$doc.isNew())\n      ## Note that this serialization step is mandatory and we cannot count on the UserReferenceConverter here\n      ## because UserReference#toString does not rely on the serializer so it's not the expected format for\n      ## XWiki#getUserName(String).\n      #set ($authorName = $services.user.serialize($tdoc.authors.originalMetadataAuthor))\n      <div class=\"xdocLastModification\">\n        #if (!$doc.isMostRecent())\n          $services.localization.render(\n            'core.document.modificationWithVersion',\n            [\"<a href='$tdoc.getURL('view', \"\"rev=$tdoc.version\"\")'>$tdoc.version</a>\",\n            $xwiki.getUserName($authorName),\n            $xwiki.formatDate($tdoc.date)\n          ])\n        #else\n          $services.localization.render('core.footer.modification', [$xwiki.getUserName($authorName), $xwiki.formatDate($tdoc.date)])\n        #end\n      </div>\n    #end\n  </div>\n  #if($displayContentMenu)\n    <div class=\"document-menu col-xs-12 col-md-5\">\n      #template(\"menus_content.vm\")\n    </div>\n  #end\n</div>\n## Display a warning regarding restricted mode for advanced users or when there is an actual error to not to confuse\n## simple users. Also, only display the warning for the content viewer as other viewers shouldn't display\n## rendered content of old revisions and this would thus only confuse users.\n#if ($viewer == 'content' && $doc.isRestricted()\n  && ($isAdvancedUser || $stringtool.contains($renderedContent, 'xwikirenderingerror')))\n  #warning($escapetool.xml($services.localization.render('core.document.restrictedInfo')))\n#end\n<hr/>\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.flamingo.test.docker;\n\nimport java.io.File;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsPane;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsViewPage;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.test.docker.junit5.TestConfiguration;\nimport org.xwiki.test.docker.junit5.TestReference;\nimport org.xwiki.test.docker.junit5.UITest;\nimport org.xwiki.test.ui.TestUtils;\nimport org.xwiki.test.ui.po.DeletePageOutcomePage;\nimport org.xwiki.test.ui.po.DeletedPageEntry;\nimport org.xwiki.test.ui.po.DeletingPage;\nimport org.xwiki.test.ui.po.HistoryPane;\nimport org.xwiki.test.ui.po.ViewPage;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.startsWith;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Functional tests related to recycle bin operations.\n *\n * @version $Id$\n * @since 13.10.4\n * @since 14.2RC1\n */\n@UITest\nclass RecycleBinIT\n{\n    /**\n     * @see \"XWIKI-9421: Attachment version is incremented when a document is restored from recycle bin\"\n     */\n    @Test\n    @Order(1)\n    void restore(TestUtils setup, TestReference testReference, TestConfiguration testConfiguration) throws Exception\n    {\n        setup.loginAsSuperAdmin();\n\n        // Clean up.\n        setup.rest().deletePage(testReference.getLastSpaceReference().getName(), testReference.getName());\n\n        // Create a new page.\n        ViewPage page = setup.createPage(testReference, \"Once upon a time..\", \"A story\");\n\n        // Add an attachment.\n        new AttachmentsViewPage().openAttachmentsDocExtraPane().setFileToUpload(\n            new File(testConfiguration.getBrowser().getTestResourcesPath(),\n                \"RecycleBinIT/SmallAttachment.txt\").getAbsolutePath());\n\n        // Delete the page.\n        page.delete().clickYes();\n        DeletingPage deletingPage = new DeletingPage();\n        deletingPage.waitUntilFinished();\n\n        DeletePageOutcomePage deletePageOutcomePage = deletingPage.getDeletePageOutcomePage();\n\n        // Open the page in preview mode (by clicking on the link of the second column), and check that the content is\n        // the one expected.\n        ViewPage viewPage = deletePageOutcomePage.clickViewDocument(1);\n        assertEquals(\"A story\", viewPage.getDocumentTitle());\n        assertEquals(\"Once upon a time..\", viewPage.getContent());\n\n        // Goes back to the previous page to continue the page restoration.\n        setup.getDriver().navigate().back();\n\n        // Restore the page.\n        page = deletePageOutcomePage.clickRestore();\n\n        // Check the page title and content.\n        assertEquals(\"A story\", page.getDocumentTitle());\n        assertEquals(\"Once upon a time..\", page.getContent());\n\n        // Check document version/history.\n        HistoryPane historyPane = page.openHistoryDocExtraPane();\n        assertEquals(\"2.1\", historyPane.getCurrentVersion());\n\n        // Check the attachment.\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(\"SmallAttachment.txt\"));\n\n        // Check the attachment content.\n        attachmentsPane.getAttachmentLink(\"SmallAttachment.txt\").click();\n        assertEquals(\"This is a small attachment.\", setup.getDriver().findElement(By.tagName(\"html\")).getText());\n    }\n\n    /**\n     * Check that viewing a terminal deleted page works and that rights are properly checked for viewing a deleted page.\n     */\n    @Test\n    @Order(2)\n    void viewDeletedPage(TestUtils testUtils, TestReference parentReference)\n    {\n        /*\n        Fixture:\n          * 3 pages:\n            - ParentSpace\n              - Page1.WebHome\n              - Page1 -> terminal\n          * 2 users\n            - viewDeletedPageUser1: allow edit, delete, view -> deleter of the pages\n            - viewDeletedPageUser2: denied edit, allowed view on the space\n            - viewDeletedPageUser3: denied view / edit on the space\n         */\n\n        String testUserPrefix = parentReference.getName();\n        String user1 = testUserPrefix + \"User1\";\n        String user2 = testUserPrefix + \"User2\";\n        String user3 = testUserPrefix + \"User3\";\n\n        testUtils.loginAsSuperAdmin();\n        testUtils.createUser(user1, user1, null);\n        testUtils.createUser(user2, user2, null);\n        testUtils.createUser(user3, user3, null);\n\n        testUtils.createPage(parentReference, \"Parent space\");\n\n        DocumentReference page1 =\n            new DocumentReference(\"WebHome\", new SpaceReference(\"Page1\", parentReference.getLastSpaceReference()));\n        DocumentReference page1Terminal = new DocumentReference(\"Page1\", parentReference.getLastSpaceReference());\n        DocumentReference page2 =\n            new DocumentReference(\"WebHome\", new SpaceReference(\"Page2\", parentReference.getLastSpaceReference()));\n\n        testUtils.createPage(page1, \"Page 1 non terminal page content\", \"Page 1 Non Terminal\");\n        testUtils.createPage(page1Terminal, \"Page 1 **terminal** page content\", \"Page 1 Terminal\");\n        testUtils.createPage(page2, \"Page 2 content\", \"Page 2\");\n\n        testUtils.setRightsOnSpace(parentReference.getLastSpaceReference(), \"\",\n            String.format(\"XWiki.%s\", user1), \"delete\", true);\n        testUtils.setRightsOnSpace(parentReference.getLastSpaceReference(), \"\",\n            String.format(\"XWiki.%s,XWiki.%s\", user2, user3), \"edit\", false);\n        testUtils.setRightsOnSpace(parentReference.getLastSpaceReference(), \"\",\n            String.format(\"XWiki.%s\", user3), \"view\", false);\n\n        testUtils.login(user3, user3);\n        ViewPage viewPage = testUtils.gotoPage(page1);\n        assertTrue(viewPage.isForbidden());\n\n        viewPage = testUtils.gotoPage(page1Terminal);\n        assertTrue(viewPage.isForbidden());\n\n        viewPage = testUtils.gotoPage(page2);\n        assertTrue(viewPage.isForbidden());\n\n        // Delete all 3 pages\n        testUtils.login(user1, user1);\n\n        viewPage = testUtils.gotoPage(page1);\n        viewPage.deletePage().confirmDeletePage().waitUntilFinished();\n\n        viewPage = testUtils.gotoPage(page1Terminal);\n        viewPage.deletePage().confirmDeletePage().waitUntilFinished();\n\n        viewPage = testUtils.gotoPage(page2);\n        viewPage.deletePage().confirmDeletePage().waitUntilFinished();\n\n        // Check view deleted page with User2\n        testUtils.login(user2, user2);\n        testUtils.gotoPage(page1);\n\n        DeletePageOutcomePage recycleBinPage1 = new DeletePageOutcomePage();\n        List<DeletedPageEntry> deletedPagesEntries = recycleBinPage1.getDeletedPagesEntries();\n        List<DeletedPageEntry> deletedTerminalPagesEntries = recycleBinPage1.getDeletedTerminalPagesEntries();\n\n        // Check that both Page1 and Page1 terminal are shown\n        assertEquals(1, deletedPagesEntries.size());\n        assertEquals(1, deletedTerminalPagesEntries.size());\n\n        assertEquals(user1, deletedPagesEntries.get(0).getDeleter());\n        assertEquals(user1, deletedTerminalPagesEntries.get(0).getDeleter());\n\n        // Check that the user cannot view the page as it's not the deleter\n        assertFalse(deletedPagesEntries.get(0).canBeViewed());\n        assertFalse(deletedTerminalPagesEntries.get(0).canBeViewed());\n\n        // Check that however other actions are not possible\n        assertFalse(deletedPagesEntries.get(0).canBeDeleted());\n        assertFalse(deletedTerminalPagesEntries.get(0).canBeDeleted());\n\n        // Check that however other actions are not possible\n        assertFalse(deletedPagesEntries.get(0).canBeRestored());\n        assertFalse(deletedTerminalPagesEntries.get(0).canBeRestored());\n\n        // Check view deleted page with User1\n        testUtils.login(user1, user1);\n        testUtils.gotoPage(page1);\n\n        recycleBinPage1 = new DeletePageOutcomePage();\n        deletedPagesEntries = recycleBinPage1.getDeletedPagesEntries();\n        deletedTerminalPagesEntries = recycleBinPage1.getDeletedTerminalPagesEntries();\n\n        // Check that both Page1 and Page1 terminal are shown\n        assertEquals(1, deletedPagesEntries.size());\n        assertEquals(1, deletedTerminalPagesEntries.size());\n\n        assertEquals(user1, deletedPagesEntries.get(0).getDeleter());\n        assertEquals(user1, deletedTerminalPagesEntries.get(0).getDeleter());\n\n        // Check that both are viewable by the user\n        assertTrue(deletedPagesEntries.get(0).canBeViewed());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeViewed());\n\n        // Check that permanently delete is not possible\n        assertFalse(deletedPagesEntries.get(0).canBeDeleted());\n        assertFalse(deletedTerminalPagesEntries.get(0).canBeDeleted());\n\n        // Check that restore is also possible\n        assertTrue(deletedPagesEntries.get(0).canBeRestored());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeRestored());\n\n        // View content of the deleted terminal page\n        viewPage = deletedTerminalPagesEntries.get(0).clickView();\n\n        // Keep track of the URL to try accessing it later on\n        String terminalPageDeletedViewUrl = testUtils.getDriver().getCurrentUrl();\n\n        assertEquals(\"Page 1 Terminal\", viewPage.getDocumentTitle());\n        assertEquals(\"Page 1 terminal page content\", viewPage.getContent());\n\n        // Check view deleted page with User3\n        testUtils.login(user3, user3);\n        viewPage = testUtils.gotoPage(page1);\n\n        assertTrue(viewPage.isForbidden());\n\n        // Try to access the deleted revision\n        testUtils.gotoPage(terminalPageDeletedViewUrl);\n        viewPage = new ViewPage();\n\n        assertTrue(viewPage.isForbidden());\n\n        // Also try access the deleted revision with user2\n        testUtils.login(user2, user2);\n        testUtils.gotoPage(terminalPageDeletedViewUrl);\n        viewPage = new ViewPage();\n\n        assertTrue(viewPage.isForbidden());\n\n        // Check view deleted page with superadmin\n        testUtils.loginAsSuperAdmin();\n        viewPage = testUtils.gotoPage(page1);\n\n        recycleBinPage1 = new DeletePageOutcomePage();\n        deletedPagesEntries = recycleBinPage1.getDeletedPagesEntries();\n        deletedTerminalPagesEntries = recycleBinPage1.getDeletedTerminalPagesEntries();\n\n        // Check that both Page1 and Page1 terminal are shown\n        assertEquals(1, deletedPagesEntries.size());\n        assertEquals(1, deletedTerminalPagesEntries.size());\n\n        // Check that all actions are possible\n        assertTrue(deletedPagesEntries.get(0).canBeViewed());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeViewed());\n\n        assertTrue(deletedPagesEntries.get(0).canBeDeleted());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeDeleted());\n\n        assertTrue(deletedPagesEntries.get(0).canBeRestored());\n        assertTrue(deletedTerminalPagesEntries.get(0).canBeRestored());\n    }\n\n    @Test\n    @Order(3)\n    void deletedDocumentIsRestricted(TestUtils testUtils, TestReference testReference)\n    {\n        testUtils.loginAsSuperAdmin();\n\n        ViewPage viewPage = testUtils.createPage(testReference, \"{{velocity}}Velocity content{{/velocity}}\", \"Title\");\n        // Make sure the Velocity macro is executed normally.\n        assertEquals(\"Velocity content\", viewPage.getContent());\n\n        viewPage.deletePage().confirmDeletePage().waitUntilFinished();\n\n        testUtils.gotoPage(testReference);\n        DeletePageOutcomePage recycleBinPage = new DeletePageOutcomePage();\n\n        List<DeletedPageEntry> deletedPageEntries = recycleBinPage.getDeletedPagesEntries();\n        assertFalse(deletedPageEntries.isEmpty());\n        viewPage = deletedPageEntries.get(0).clickView();\n\n        assertEquals(\"Title\", viewPage.getDocumentTitle());\n        // In the preview the Velocity macro should be forbidden.\n        assertThat(viewPage.getContent(), startsWith(\"Failed to execute the [velocity] macro.\"));\n\n        testUtils.gotoPage(testReference);\n        recycleBinPage = new DeletePageOutcomePage();\n        viewPage = recycleBinPage.getDeletedPagesEntries().get(0).clickRestore();\n        // Assert that in the restored document, scripts are allowed again.\n        assertEquals(\"Velocity content\", viewPage.getContent());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.flamingo.test.docker;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsPane;\nimport org.xwiki.flamingo.skin.test.po.AttachmentsViewPage;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.test.docker.junit5.TestReference;\nimport org.xwiki.test.docker.junit5.UITest;\nimport org.xwiki.test.ui.TestUtils;\nimport org.xwiki.test.ui.po.HistoryPane;\nimport org.xwiki.test.ui.po.ViewPage;\nimport org.xwiki.test.ui.po.editor.WikiEditPage;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.startsWith;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Verify versioning features of documents and attachments.\n * \n * @version $Id$\n */\n@UITest(properties = {\n    // Add the FileUploadPlugin which is needed by the test to upload attachment files\n    \"xwikiCfgPlugins=com.xpn.xwiki.plugin.fileupload.FileUploadPlugin\"})\nclass VersionIT\n{\n    private static final String TITLE = \"Page Title\";\n\n    private static final String CONTENT1 = \"First version of Content\";\n\n    private static final String CONTENT2 = \"Second version of Content\";\n\n    @BeforeAll\n    void setup(TestUtils setup)\n    {\n        setup.loginAsSuperAdmin();\n    }\n\n    @Test\n    @Order(1)\n    void testRollbackToFirstVersion(TestUtils utils, TestReference testReference) throws Exception\n    {\n        utils.rest().delete(testReference);\n\n        // Create first version of the page\n        ViewPage vp = utils.createPage(testReference, CONTENT1, TITLE);\n\n        // Adds second version\n        WikiEditPage wikiEditPage = vp.editWiki();\n        wikiEditPage.setContent(CONTENT2);\n        wikiEditPage.clickSaveAndView();\n\n        // TODO: Remove when XWIKI-6688 (Possible race condition when clicking on a tab at the bottom of a page in\n        // view mode) is fixed.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        // Verify that we can rollback to the first version\n        HistoryPane historyTab = vp.openHistoryDocExtraPane();\n        vp = historyTab.rollbackToVersion(\"1.1\");\n\n        // Rollback doesn't wait...\n        // Wait for the comment tab to be selected since we're currently on the history tab and rolling\n        // back is going to load a new page and make the focus active on the comments tab.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        assertEquals(\"First version of Content\", vp.getContent());\n\n        historyTab = vp.openHistoryDocExtraPane();\n        assertEquals(\"Rollback to version 1.1\", historyTab.getCurrentVersionComment());\n        assertEquals(\"superadmin\", historyTab.getCurrentAuthor());\n    }\n\n    /**\n     * See XWIKI-8781 & XWIKI-20589\n     */\n    @Test\n    @Order(2)\n    void testDeleteLatestVersion(TestUtils setup, TestReference testReference) throws Exception\n    {\n        setup.rest().delete(testReference);\n\n        // Create first version of the page, as superadmin\n        setup.createPage(testReference, CONTENT1, TITLE);\n\n        // Log as another user having admin permissions (to be able to delete a revision)\n        setup.createAdminUser();\n\n        // Adds second version, as Admin\n        ViewPage vp = setup.gotoPage(testReference);\n        vp.edit();\n        WikiEditPage wikiEditPage = new WikiEditPage();\n        wikiEditPage.setContent(CONTENT2);\n        wikiEditPage.clickSaveAndView();\n\n        // TODO: Remove when XWIKI-6688 (Possible race condition when clicking on a tab at the bottom of a page in\n        // view mode) is fixed.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        // Verify and delete the latest version.\n        HistoryPane historyTab = vp.openHistoryDocExtraPane();\n        assertEquals(\"2.1\", historyTab.getCurrentVersion());\n        historyTab = historyTab.deleteVersion(\"2.1\");\n\n        // Verify that the current version is now the previous one.\n        assertEquals(\"1.1\", historyTab.getCurrentVersion());\n        assertEquals(\"superadmin\", historyTab.getCurrentAuthor());\n\n        // Verify that the last modified author of the page is the author from revision 1.1\n        assertTrue(vp.getLastModifiedText().startsWith(\"Last modified by superadmin\"));\n    }\n\n    @Test\n    @Order(3)\n    void rollbackAttachments(TestUtils utils, TestReference testReference) throws Exception\n    {\n        utils.rest().delete(testReference);\n\n        // Create empty page\n        utils.rest().savePage(testReference);\n\n        // Add attachment\n        AttachmentReference attachmentReference = new AttachmentReference(\"file.txt\", testReference);\n        utils.rest().attachFile(attachmentReference, \"attachment1\".getBytes(), true);\n\n        // Add a second version of the attachment\n        utils.rest().attachFile(attachmentReference, \"attachment2\".getBytes(), false);\n\n        // Load page\n        ViewPage vp = utils.gotoPage(testReference);\n\n        // Make sure expected attachment is there\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.2\", attachmentsPane.getLatestVersionOfAttachment(attachmentReference.getName()));\n\n        // Revert to 1.1 (empty page)\n        vp = vp.openHistoryDocExtraPane().rollbackToVersion(\"1.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(0, attachmentsPane.getNumberOfAttachments());\n\n        // Revert to 3.1 (second update of the attachment)\n        vp = vp.openHistoryDocExtraPane().rollbackToVersion(\"3.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.2\", attachmentsPane.getLatestVersionOfAttachment(attachmentReference.getName()));\n        attachmentsPane.getAttachmentLink(attachmentReference.getName()).click();\n        assertEquals(\"attachment2\", utils.getDriver().findElement(By.tagName(\"html\")).getText());\n\n        // Revert to 2.1 (first update of the attachment)\n        vp = utils.gotoPage(testReference).openHistoryDocExtraPane().rollbackToVersion(\"2.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.3\", attachmentsPane.getLatestVersionOfAttachment(attachmentReference.getName()));\n        attachmentsPane.getAttachmentLink(attachmentReference.getName()).click();\n        assertEquals(\"attachment1\", utils.getDriver().findElement(By.tagName(\"html\")).getText());\n\n        // Back to empty page again\n        vp = utils.gotoPage(testReference).openHistoryDocExtraPane().rollbackToVersion(\"1.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(0, attachmentsPane.getNumberOfAttachments());\n\n        // Revert to 2.1 (first update of the attachment)\n        vp = vp.openHistoryDocExtraPane().rollbackToVersion(\"2.1\");\n\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertEquals(1, attachmentsPane.getNumberOfAttachments());\n        assertEquals(\"1.3\", attachmentsPane.getLatestVersionOfAttachment(attachmentReference.getName()));\n        attachmentsPane.getAttachmentLink(attachmentReference.getName()).click();\n        assertEquals(\"attachment1\", utils.getDriver().findElement(By.tagName(\"html\")).getText());\n    }\n\n    /**\n     * Ensure that a previous deleted attachment with same name and version than an existing one is properly restored\n     * after a rollback of a page version.\n     */\n    @Test\n    @Order(4)\n    void rollbackAttachmentWithSameNameAndVersion(TestUtils utils, TestReference testReference) throws Exception\n    {\n        utils.rest().delete(testReference);\n\n        // Create empty page (1.1)\n        utils.createPage(testReference, \"\");\n\n        // Add attachment (2.1)\n        AttachmentReference attachmentReference = new AttachmentReference(\"file.txt\", testReference);\n        utils.rest().attachFile(attachmentReference, \"1\".getBytes(), true);\n\n        // Delete attachment (3.1)\n        utils.rest().deleteAttachement(attachmentReference);\n\n        // Make sure those two attachments are not saved at during the same second since the granularity is the second\n        // in some databases\n        Thread.sleep(1000);\n\n        // Add a new attachment with the same name (4.1)\n        utils.rest().attachFile(attachmentReference, \"2\".getBytes(), true);\n\n        ViewPage viewPage = utils.gotoPage(testReference);\n        AttachmentsPane attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(\"file.txt\"));\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(\"file.txt\"));\n\n        // Revert to first attachment (2.1)\n        viewPage = utils.gotoPage(testReference);\n        HistoryPane historyPane = viewPage.openHistoryDocExtraPane();\n\n        viewPage = historyPane.rollbackToVersion(\"2.1\");\n        attachmentsPane = new AttachmentsViewPage().openAttachmentsDocExtraPane();\n        assertTrue(attachmentsPane.attachmentExistsByFileName(\"file.txt\"));\n        assertEquals(\"1.1\", attachmentsPane.getLatestVersionOfAttachment(\"file.txt\"));\n        attachmentsPane.getAttachmentLink(\"file.txt\").click();\n        assertEquals(\"1\", utils.getDriver().findElement(By.tagName(\"html\")).getText());\n    }\n\n    @Test\n    @Order(5)\n    void oldRevisionsAreRestricted(TestUtils utils, TestReference testReference) throws Exception\n    {\n        utils.loginAsSuperAdmin();\n\n        utils.rest().delete(testReference);\n\n        // Create first version of the page\n        ViewPage vp = utils.createPage(testReference, \"{{velocity}}\" + CONTENT1 + \"{{/velocity}}\", TITLE);\n        assertEquals(CONTENT1, vp.getContent());\n\n        // Adds second version\n        WikiEditPage wikiEditPage = vp.editWiki();\n        wikiEditPage.setContent(\"{{velocity}}\" + CONTENT2 + \"{{velocity}}\");\n        vp = wikiEditPage.clickSaveAndView();\n\n        assertEquals(CONTENT2, vp.getContent());\n\n        // TODO: Remove when XWIKI-6688 (Possible race condition when clicking on a tab at the bottom of a page in\n        // view mode) is fixed.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        HistoryPane historyTab = vp.openHistoryDocExtraPane();\n        vp = historyTab.viewVersion(\"1.1\");\n\n        // In the preview the Velocity macro should be forbidden.\n        assertThat(vp.getContent(), startsWith(\"Failed to execute the [velocity] macro.\"));\n\n        // TODO: Remove when XWIKI-6688 (Possible race condition when clicking on a tab at the bottom of a page in\n        // view mode) is fixed.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        historyTab = vp.openHistoryDocExtraPane();\n        vp = historyTab.rollbackToVersion(\"1.1\");\n\n        // Rollback doesn't wait...\n        // Wait for the comment tab to be selected since we're currently on the history tab and rolling\n        // back is going to load a new page and make the focus active on the comments tab.\n        vp.waitForDocExtraPaneActive(\"comments\");\n\n        // Assert that scripts are executed again after restoring the version.\n        assertEquals(CONTENT1, vp.getContent());\n    }\n\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.dom4j.Document;\nimport org.dom4j.io.OutputFormat;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.HeaderBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.listener.HeaderLevel;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationManager;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.api.DocumentSection;\nimport com.xpn.xwiki.internal.xml.XMLWriter;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.plugin.query.XWikiCriteria;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Add a backward compatibility layer to the {@link com.xpn.xwiki.doc.XWikiDocument} class.\n *\n * @version $Id$\n */\nprivileged public aspect XWikiDocumentCompatibilityAspect\n{\n    /**\n     * @deprecated since 3.0M3 use {@code Syntax.XWIKI_1_0} instead\n     */\n    @Deprecated\n    public static final String XWikiDocument.XWIKI10_SYNTAXID = Syntax.XWIKI_1_0.toIdString();\n\n    /**\n     * @deprecated since 3.0M3 use {@code Syntax.XWIKI_2_0} instead\n     */\n    @Deprecated\n    public static final String XWikiDocument.XWIKI20_SYNTAXID = Syntax.XWIKI_2_0.toIdString();\n\n    /**\n     * @deprecated use setStringListValue or setDBStringListProperty\n     */\n    @Deprecated\n    public void XWikiDocument.setListValue(String className, String fieldName, List value)\n    {\n        BaseObject bobject = getObject(className);\n        if (bobject == null) {\n            bobject = new BaseObject();\n            addObject(className, bobject);\n        }\n        bobject.setName(getFullName());\n        bobject.setClassName(className);\n        bobject.setListValue(fieldName, value);\n        setMetaDataDirty(true);\n    }\n    \n    /**\n     * This method to split section according to title.\n     * \n     * @return the sections in the current document\n     * @throws XWikiException\n     * @deprecated use {@link #getSections()} instead, since 1.6M1\n     */\n    @Deprecated\n    public List<DocumentSection> XWikiDocument.getSplitSectionsAccordingToTitle() throws XWikiException\n    {\n        return getSections();\n    }\n    \n    /**\n     * @deprecated use {@link #getUniqueLinkedPages(XWikiContext)}\n     */\n    @Deprecated\n    public List<String> XWikiDocument.getLinkedPages(XWikiContext context)\n    {\n        return new ArrayList<String>(getUniqueLinkedPages(context));\n    }\n    \n    /**\n     * @deprecated use {@link #getUniqueWikiLinkedPages(XWikiContext)} instead\n     */\n    @Deprecated\n    public List<XWikiLink> XWikiDocument.getLinks(XWikiContext context) throws XWikiException\n    {\n        return getWikiLinkedPages(context);\n    }\n\n    /**\n     * @deprecated use {@link #getUniqueWikiLinkedPages(XWikiContext)} instead\n     */\n    @Deprecated\n    public List<XWikiLink> XWikiDocument.getWikiLinkedPages(XWikiContext context) throws XWikiException\n    {\n        return new ArrayList<XWikiLink>(getUniqueWikiLinkedPages(context));\n    }\n    \n    /**\n     * @deprecated use {@link #getBackLinkedPages(XWikiContext)} instead\n     */\n    @Deprecated\n    public List<String> XWikiDocument.getBacklinks(XWikiContext context) throws XWikiException\n    {\n        return getBackLinkedPages(context);\n    }\n    \n    /**\n     * @param text the text to render\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document\n     * @deprecated since 1.6M1 use {@link #getRenderedContent(String, String, com.xpn.xwiki.XWikiContext)}\n     */\n    @Deprecated\n    public String XWikiDocument.getRenderedContent(String text, XWikiContext context)\n    {\n        return getRenderedContent(text, Syntax.XWIKI_1_0.toIdString(), context);\n    }\n\n    @Deprecated\n    public String XWikiDocument.displaySearch(PropertyClass pclass, String prefix, XWikiCriteria criteria, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displaySearch(pclass.getName(), prefix, criteria, context);\n    }\n\n    /**\n     * @param context the XWiki context used to get access to the com.xpn.xwiki.render.XWikiRenderingEngine object\n     * @return the document title. If a title has not been provided, look for a section title in the document's content\n     *         and if not found return the page name. The returned title is also interpreted which means it's allowed to\n     *         use Velocity, Groovy, etc syntax within a title.\n     * @deprecated use {@link #getRenderedTitle(Syntax, XWikiContext)} instead\n     */\n    @Deprecated\n    public String XWikiDocument.getDisplayTitle(XWikiContext context)\n    {\n        return getRenderedTitle(Syntax.XHTML_1_0, context);\n    }\n\n    /**\n     * @deprecated since 2.2M1, use {@link #getXClass()} instead\n     */\n    @Deprecated\n    public BaseClass XWikiDocument.getxWikiClass()\n    {\n        return getXClass();\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #addXObjectFromRequest(XWikiContext)}\n     */\n    @Deprecated\n    public BaseObject XWikiDocument.addObjectFromRequest(XWikiContext context) throws XWikiException\n    {\n        return addXObjectFromRequest(context);\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #setXObjectsToRemove(List)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setObjectsToRemove(ArrayList<BaseObject> objectsToRemove)\n    {\n        setXObjectsToRemove(objectsToRemove);\n    }\n\n    /**\n     * @deprecated since 2.2M1, use {@link #setXClass(BaseClass)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setxWikiClass(BaseClass xwikiClass)\n    {\n        setXClass(xwikiClass);\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #getXObjects()} instead. Warning: if you used to modify the returned Map note\n     *             that since 2.2M1 this will no longer work and you'll need to call the setXObject methods instead (or\n     *             setxWikiObjects()). Obviously the best is to move to the new API.\n     */\n    @Deprecated\n    public Map<String, Vector<BaseObject>> XWikiDocument.getxWikiObjects()\n    {\n        // Use a liked hash map to ensure we keep the order stored from the internal objects map.\n        Map<String, Vector<BaseObject>> objects = new LinkedHashMap<String, Vector<BaseObject>>();\n\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : getXObjects().entrySet()) {\n            objects.put(getCompactWikiEntityReferenceSerializer().serialize(entry.getKey()), new Vector<BaseObject>(\n                entry.getValue()));\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #setXObjects(Map)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setxWikiObjects(Map<String, Vector<BaseObject>> objects)\n    {\n        // Use a liked hash map to ensure we keep the order stored from the internal objects map.\n        Map<DocumentReference, List<BaseObject>> newObjects = new LinkedHashMap<DocumentReference, List<BaseObject>>();\n\n        for (Map.Entry<String, Vector<BaseObject>> entry : objects.entrySet()) {\n            newObjects.put(resolveClassReference(entry.getKey()), new ArrayList<BaseObject>(entry.getValue()));\n        }\n\n        setXObjects(newObjects);\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #getXClasses(XWikiContext)} instead\n     */\n    @Deprecated\n    public List<BaseClass> XWikiDocument.getxWikiClasses(XWikiContext context)\n    {\n        return getXClasses(context);\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #setXObjects(DocumentReference, List)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setObjects(String className, Vector<BaseObject> objects)\n    {\n        setXObjects(resolveClassReference(className), new ArrayList<BaseObject>(objects));\n    }\n\n    /**\n     * @deprecated since 3.2M3, use {@link #getRenderedTitle(Syntax, XWikiContext)} instead\n     */\n    @Deprecated\n    public String XWikiDocument.extractTitle()\n    {\n        String title = \"\";\n\n        try {\n            if (is10Syntax()) {\n                title = extractTitle10();\n            } else {\n                List<HeaderBlock> blocks =\n                    getXDOM().getBlocks(new ClassBlockMatcher(HeaderBlock.class), Block.Axes.DESCENDANT);\n                if (!blocks.isEmpty()) {\n                    HeaderBlock header = blocks.get(0);\n                    if (header.getLevel().compareTo(HeaderLevel.LEVEL2) <= 0) {\n                        XDOM headerXDOM = new XDOM(Collections.<Block> singletonList(header));\n\n                        // transform\n                        TransformationContext context =\n                            new TransformationContext(headerXDOM, getSyntax(), isRestricted());\n                        Utils.getComponent(TransformationManager.class).performTransformations(headerXDOM, context);\n\n                        // render\n                        Block headerBlock = headerXDOM.getChildren().get(0);\n                        if (headerBlock instanceof HeaderBlock) {\n                            title = renderXDOM(new XDOM(headerBlock.getChildren()), Syntax.XHTML_1_0);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Don't stop when there's a problem rendering the title.\n        }\n\n        return title;\n    }\n\n    /**\n     * Regex for finding the first level 1 or 2 heading in the document title, to be used as the document title.\n     * \n     * @deprecated since 3.2M3\n     **/\n    @Deprecated\n    private static final Pattern HEADING_PATTERN_10 = Pattern.compile(\"^\\\\s*+1(?:\\\\.1)?\\\\s++(.++)$\", Pattern.MULTILINE);\n\n    /**\n     * @return the first level 1 or level 1.1 title text in the document's content or \"\" if none are found\n     * @deprecated since 3.2M3\n     */\n    @Deprecated\n    private String XWikiDocument.extractTitle10()\n    {\n        String content = getContent();\n        Matcher m = HEADING_PATTERN_10.matcher(content);\n        if (m.find()) {\n            return m.group(1).trim();\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Convert a {@link Document} into an XML string. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to avoid memory load.\n     * \n     * @param doc the {@link Document} to convert to a String\n     * @param context current XWikiContext\n     * @return an XML representation of the {@link Document}\n     * @deprecated this method has nothing to do here and is apparently unused\n     */\n    @Deprecated\n    public String XWikiDocument.toXML(Document doc, XWikiContext context)\n    {\n        String encoding = context.getWiki().getEncoding();\n\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        try {\n            XMLWriter wr = new XMLWriter(os, new OutputFormat(\"\", true, encoding));\n            wr.write(doc);\n            return os.toString(encoding);\n        } catch (IOException e) {\n            LOGGER.error(\"Exception while doc.toXML\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #cloneXObjects(XWikiDocument)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.clonexWikiObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc);\n    }\n    \n    /**\n     * @deprecated since 5.2M1 use {@link #removeAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.deleteAttachment(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        deleteAttachment(attachment, true, context);\n    }\n\n    /**\n     * @deprecated since 5.2M1 use {@link #removeAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.deleteAttachment(XWikiAttachment attachment, boolean toRecycleBin, XWikiContext context)\n        throws XWikiException\n    {\n        deleteAttachment(attachment, true, toRecycleBin, context);\n    }\n\n    /**\n     * @deprecated since 5.2M1 use {@link #removeAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated\n    private void XWikiDocument.deleteAttachment(XWikiAttachment attachment, boolean saveDocument, boolean toRecycleBin,\n        XWikiContext context) throws XWikiException\n    {\n        removeAttachment(attachment, toRecycleBin);\n\n        if (saveDocument) {\n            // Save the document\n            context.getWiki().saveDocument(this, \"Deleted attachment [\" + attachment.getFilename() + \"]\", context);\n        }\n    }\n\n    private String XWikiDocument.serializeReference(DocumentReference reference, EntityReferenceSerializer<String> serializer,\n        DocumentReference defaultReference)\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        String originalWikiName = xcontext.getWikiId();\n        XWikiDocument originalCurentDocument = xcontext.getDoc();\n        try {\n            xcontext.setWikiId(defaultReference.getWikiReference().getName());\n            xcontext.setDoc(new XWikiDocument(defaultReference));\n\n            return serializer.serialize(reference);\n        } finally {\n            xcontext.setDoc(originalCurentDocument);\n            xcontext.setWikiId(originalWikiName);\n        }\n    }\n\n    /**\n     * Convert a full document reference into the proper relative document reference (wiki part is removed if it's the\n     * same as document wiki) to store as parent.\n     * \n     * @deprecated since 2.2.3 use {@link #setParentReference(org.xwiki.model.reference.EntityReference)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.setParentReference(DocumentReference parentReference)\n    {\n        if (parentReference != null) {\n            setParent(serializeReference(parentReference, getCompactWikiEntityReferenceSerializer(),\n                getDocumentReference()));\n        } else {\n            setParentReference((EntityReference) null);\n        }\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #rename(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public void XWikiDocument.rename(String newDocumentName, XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentName, getBackLinkedPages(context), context);\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #rename(DocumentReference, java.util.List, com.xpn.xwiki.XWikiContext)}\n     */\n    @Deprecated\n    public void XWikiDocument.rename(String newDocumentName, List<String> backlinkDocumentNames, XWikiContext context)\n        throws XWikiException\n    {\n        rename(newDocumentName, backlinkDocumentNames, getChildren(context), context);\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #rename(DocumentReference, List, List, com.xpn.xwiki.XWikiContext)}\n     */\n    @Deprecated\n    public void XWikiDocument.rename(String newDocumentName, List<String> backlinkDocumentNames,\n        List<String> childDocumentNames, XWikiContext context) throws XWikiException\n    {\n        List<DocumentReference> backlinkDocumentReferences = new ArrayList<DocumentReference>();\n        for (String backlinkDocumentName : backlinkDocumentNames) {\n            backlinkDocumentReferences.add(getCurrentMixedDocumentReferenceResolver().resolve(backlinkDocumentName));\n        }\n\n        List<DocumentReference> childDocumentReferences = new ArrayList<DocumentReference>();\n        for (String childDocumentName : childDocumentNames) {\n            childDocumentReferences.add(getCurrentMixedDocumentReferenceResolver().resolve(childDocumentName));\n        }\n\n        rename(getCurrentMixedDocumentReferenceResolver().resolve(newDocumentName), backlinkDocumentReferences,\n            childDocumentReferences, context);\n    }\n\n    /**\n     * Read the document data from the template without performing permission check on the template.\n     *\n     * @param eform the form containing a template information.\n     * @param context current context\n     * @throws XWikiException in case of problem to read the information.\n     * @deprecated Since 14.1RC1 prefer using {@link #readFromTemplate(DocumentReference, XWikiContext)} and be careful\n     *             to check the template rights before.\n     */\n    @Deprecated\n    public void XWikiDocument.readFromTemplate(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String template = eform.getTemplate();\n        readFromTemplate(template, context);\n    }\n\n    /**\n     * @deprecated since 2.2M1 use {@link #readFromTemplate(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public void XWikiDocument.readFromTemplate(String template, XWikiContext context) throws XWikiException\n    {\n        // Keep the same behavior for backward compatibility\n        DocumentReference templateDocumentReference = null;\n        if (StringUtils.isNotEmpty(template)) {\n            templateDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n        }\n        readFromTemplate(templateDocumentReference, context);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.diff.DifferentiationFailedException;\nimport org.suigeneris.jrcs.diff.delta.Delta;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.display.internal.DocumentDisplayerParameters;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.internal.document.SafeDocumentAuthors;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiConstant;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.criteria.impl.Period;\nimport com.xpn.xwiki.criteria.impl.PeriodFactory;\nimport com.xpn.xwiki.criteria.impl.Range;\nimport com.xpn.xwiki.criteria.impl.RangeFactory;\nimport com.xpn.xwiki.criteria.impl.RevisionCriteria;\nimport com.xpn.xwiki.criteria.impl.Scope;\nimport com.xpn.xwiki.criteria.impl.ScopeFactory;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MetaDataDiff;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.doc.XWikiLink;\nimport com.xpn.xwiki.doc.XWikiLock;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.ObjectDiff;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.DocumentStats;\nimport com.xpn.xwiki.stats.impl.RefererStats;\nimport com.xpn.xwiki.util.TOCGenerator;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * This class represents a document or page in the wiki. This is a security and usability wrapper which wraps\n * {@link com.xpn.xwiki.doc.XWikiDocument} In scripting, an object representing the document in which the script resides\n * will be bound to a variable called doc.\n *\n * @version $Id$\n */\npublic class Document extends Api\n{\n    /** Logging helper object. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(Document.class);\n\n    /**\n     * The XWikiDocument object wrapped by this API.\n     */\n    protected XWikiDocument initialDoc;\n\n    /**\n     * The XWikiDocument object wrapped by this API.\n     */\n    protected XWikiDocument doc;\n\n    /**\n     * Convenience object used by object related methods.\n     */\n    protected Object currentObj;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    /**\n     * Used to convert a proper Document Reference to string (standard form).\n     */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to convert a proper Document Reference to a string but without the wiki name.\n     */\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private ConfigurationSource configuration;\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    private EntityReferenceSerializer<String> getLocalEntityReferenceSerializer()\n    {\n        if (this.localEntityReferenceSerializer == null) {\n            this.localEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localEntityReferenceSerializer;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private ConfigurationSource getConfiguration()\n    {\n        if (this.configuration == null) {\n            this.configuration = Utils.getComponent(ConfigurationSource.class);\n        }\n\n        return this.configuration;\n    }\n\n    /**\n     * Document constructor.\n     *\n     * @param doc The XWikiDocument object to wrap.\n     * @param context The current request context.\n     */\n    public Document(XWikiDocument doc, XWikiContext context)\n    {\n        super(context);\n\n        this.initialDoc = doc;\n        this.doc = this.initialDoc;\n    }\n\n    /**\n     * Get the XWikiDocument wrapped by this API. This function is accessible only if you have the programming rights\n     * give access to the priviledged API of the Document.\n     *\n     * @return The XWikiDocument wrapped by this API.\n     */\n    public XWikiDocument getDocument()\n    {\n        if (hasProgrammingRights()) {\n            return this.doc;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a clone of the XWikiDocument wrapped by this API.\n     *\n     * @return A clone of the XWikiDocument wrapped by this API.\n     */\n    protected XWikiDocument getDoc()\n    {\n        if (this.initialDoc == this.doc) {\n            this.doc = this.initialDoc.clone();\n        }\n\n        return this.doc;\n    }\n\n    /**\n     * return the ID of the document. this ID is unique across the wiki.\n     *\n     * @return the id of the document.\n     */\n    public long getId()\n    {\n        return this.doc.getId();\n    }\n\n    /**\n     * returns the DocumentReference for the current document\n     *\n     * @return the DocumentReference of the current document\n     * @since 2.3M1\n     */\n    public DocumentReference getDocumentReference()\n    {\n        return this.doc.getDocumentReference();\n    }\n\n    /**\n     * @return the {@link DocumentReference} of the document also containing the document {@link Locale}\n     * @since 9.3RC1\n     */\n    public DocumentReference getDocumentReferenceWithLocale()\n    {\n        return this.doc.getDocumentReferenceWithLocale();\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference} without the {@link Locale}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReference()\n    {\n        return this.doc.getPageReference();\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference} including the {@link Locale}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReferenceWithLocale()\n    {\n        return this.doc.getPageReferenceWithLocale();\n    }\n\n    /**\n     * @return the last part of the document's reference. For example if the reference of a document is\n     *         {@code MySpace.Mydoc}, the returned name is {@code MyDoc}. For a nested document, the last part of the\n     *         reference is always {@code WebHome} and thus the returned name is {@code Webhome}. It's better to use\n     *         {@link #getPageReference()} or {@link #getDocumentReference()}, e.g. with\n     *         {@code getPageReference().getName()} or {@code getDocumentReference().getName()}. To get the space name\n     *         of the nested document you can use {@code getPageReference().getName()} or\n     *         {@code getDocumentReference().getParent().getName()}.\n     * @see #getPageReference()\n     * @see #getDocumentReference()\n     * @deprecated since 11.0, use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    public String getName()\n{\n    return this.doc.getDocumentReference().getName();\n}\n\n    /**\n     * Return the full local space reference of the Document. For example a document located in sub-space\n     * <code>space11</code> of space <code>space1</code> will return <code>space1.space11</code>.\n     *\n     * @return the name of the spaces of the document\n     */\n    public String getSpace()\n    {\n        return this.doc.getSpace();\n    }\n\n    /**\n     * Get the name wiki where the document is stored.\n     *\n     * @return The name of the wiki where this document is stored.\n     * @since 1.1.2\n     * @since 1.2M2\n     */\n    public String getWiki()\n    {\n        return this.doc.getDocumentReference().getWikiReference().getName();\n    }\n\n    /**\n     * Get the fullName of the document. If a document is named \"MyDoc\" in space \"MySpace\", the fullname is\n     * \"MySpace.MyDoc\". In a wiki, all the documents have a different fullName.\n     *\n     * @return fullName of the document.\n     */\n    public String getFullName()\n    {\n        return getLocalEntityReferenceSerializer().serialize(this.doc.getDocumentReference());\n    }\n\n    /**\n     * Get the complete fullName of the document. The real full name of the document containing the name of the wiki\n     * where the document is stored. For a document stored in the wiki \"xwiki\", in space \"MySpace\", named \"MyDoc\", its\n     * complete full name is \"xwiki:MySpace.MyDoc\".\n     *\n     * @return The complete fullName of the document.\n     * @since 1.1.2\n     * @since 1.2M2\n     */\n    public String getPrefixedFullName()\n    {\n        return getDefaultEntityReferenceSerializer().serialize(this.doc.getDocumentReference());\n    }\n\n    /**\n     * Get a Version object representing the current version of the document.\n     *\n     * @return A Version object representing the current version of the document\n     */\n    public Version getRCSVersion()\n    {\n        return this.doc.getRCSVersion();\n    }\n\n    /**\n     * Get a string representing the current version of the document.\n     *\n     * @return A string representing the current version of the document.\n     */\n    public String getVersion()\n    {\n        return this.doc.getVersion();\n    }\n\n    /**\n     * Get a string representing the previous version of the document.\n     *\n     * @return A string representing the previous version of the document. If this is the first version then it returns\n     *         null.\n     */\n    public String getPreviousVersion()\n    {\n        return this.doc.getPreviousVersion();\n    }\n\n    /**\n     * Get the value of the title field of the document.\n     *\n     * @return The value of the title field of the document.\n     */\n    public String getTitle()\n    {\n        return this.doc.getTitle();\n    }\n\n    /**\n     * Get document title. If a title has not been provided through the title field, it looks for a section title in the\n     * document's content and if not found return the page name. The returned title is also interpreted which means it's\n     * allowed to use Velocity, Groovy, etc syntax within a title.\n     *\n     * @return The document title as XHTML\n     */\n    public String getDisplayTitle()\n    {\n        return this.doc.getRenderedTitle(getXWikiContext());\n    }\n\n    /**\n     * Returns the document title as plain text\n     *\n     * @return the document title as plain text (all markup removed)\n     * @since 3.0M1\n     */\n    public String getPlainTitle()\n    {\n        return this.doc.getRenderedTitle(Syntax.PLAIN_1_0, getXWikiContext());\n    }\n\n    /**\n     * Returns the title of the document rendered through wiki syntax and velocity\n     *\n     * @return the title rendered through wiki syntax and velocity\n     * @see XWikiDocument#getRenderedTitle(Syntax, XWikiContext)\n     */\n    public String getRenderedTitle(String syntaxId) throws XWikiException\n    {\n        try {\n            return this.doc.getRenderedTitle(Syntax.valueOf(syntaxId), getXWikiContext());\n        } catch (ParseException e) {\n            LOGGER.error(\"Failed to parse provided syntax identifier [\" + syntaxId + \"]\", e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to parse syntax identifier [\" + syntaxId + \"]\", e);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to render document [\" + getPrefixedFullName() + \"] title content\", e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to render document [\" + getPrefixedFullName() + \"] content title\", e);\n        }\n    }\n\n    /**\n     * TODO document this or mark it deprecated\n     */\n    public String getFormat()\n    {\n        return this.doc.getFormat();\n    }\n\n    /**\n     * Get fullName of the profile document of the author of the current version of the document. Example: XWiki.Admin.\n     *\n     * @return The fullName of the profile document of the effective metadata author of the current version of the\n     *         document.\n     */\n    public String getAuthor()\n    {\n        return this.doc.getAuthor();\n    }\n\n    /**\n     * @return the document author reference\n     * @since 6.4RC1\n     */\n    public DocumentReference getAuthorReference()\n    {\n        return this.doc.getAuthorReference();\n    }\n\n    /**\n     * Get fullName of the profile document of the author of the content modification of this document version. Example:\n     * XWiki.Admin.\n     *\n     * @return The fullName of the profile document of the author of the content modification in this document version.\n     */\n    public String getContentAuthor()\n    {\n        return this.doc.getContentAuthor();\n    }\n\n    /**\n     * @return the document content author reference\n     * @since 6.4RC1\n     */\n    public DocumentReference getContentAuthorReference()\n    {\n        return this.doc.getContentAuthorReference();\n    }\n\n    /**\n     * @return The date when this document version has been modified.\n     */\n    public Date getDate()\n    {\n        return this.doc.getDate();\n    }\n\n    /**\n     * Get the date when the content modification has been done on this document version. A content update excludes\n     * modifications to meta data fields or comments of the document.\n     *\n     * @return The date where the content modification has been done on this document version.\n     */\n    public Date getContentUpdateDate()\n    {\n        return this.doc.getContentUpdateDate();\n    }\n\n    /**\n     * @return the original creation date of the document.\n     */\n    public Date getCreationDate()\n    {\n        return this.doc.getCreationDate();\n    }\n\n    /**\n     * Get the name of the parent of this document.\n     *\n     * @return The name of the parent of this document.\n     */\n    public String getParent()\n    {\n        return this.doc.getParent();\n    }\n\n    /**\n     * @return the parent reference or null if the parent is not set\n     * @since 7.3M1\n     */\n    public DocumentReference getParentReference()\n    {\n        return this.doc.getParentReference();\n    }\n\n    /**\n     * Get fullName of the profile document of the document creator.\n     *\n     * @return The fullName of the profile document of the document creator.\n     */\n    public String getCreator()\n    {\n        return this.doc.getCreator();\n    }\n\n    /**\n     * @return the document creator reference\n     * @since 6.4RC1\n     */\n    public DocumentReference getCreatorReference()\n    {\n        return this.doc.getCreatorReference();\n    }\n\n    /**\n     * Get raw content of the document, i.e. the content that is visible through the wiki editor.\n     *\n     * @return The raw content of the document.\n     */\n    public String getContent()\n    {\n        return this.doc.getContent();\n    }\n\n    /**\n     * NOTE: This method caches the XDOM and returns a clone that can be safely modified.\n     *\n     * @return the XDOM corresponding to the document's string content\n     * @since 7.0RC1\n     */\n    public XDOM getXDOM()\n    {\n        return this.doc.getXDOM();\n    }\n\n    /**\n     * @return The syntax representing the syntax used for the document's content\n     * @since 2.3M1\n     */\n    public Syntax getSyntax()\n    {\n        return this.doc.getSyntax();\n    }\n\n    /**\n     * Get the Syntax id representing the syntax used for the document. For example \"xwiki/1.0\" represents the first\n     * version XWiki syntax while \"xwiki/2.0\" represents version 2.0 of the XWiki Syntax.\n     *\n     * @return The syntax id representing the syntax used for the document.\n     * @deprecated since 2.3M1 use {@link #getSyntax()} instead\n     */\n    @Deprecated\n    public String getSyntaxId()\n    {\n        return this.doc.getSyntax().toIdString();\n    }\n\n    /**\n     * Same as {@link #getLocale()} but as String.\n     *\n     * @return the locale of the document.\n     * @deprecated since 5.4M1 use {@link #getLocale()} instead\n     */\n    @Deprecated\n    public String getLanguage()\n    {\n        return this.doc.getLanguage();\n    }\n\n    /**\n     * Get the locale of the document. If the document is a translation it returns the locale set for it, otherwise, it\n     * returns the root locale.\n     *\n     * @return the locale of the document\n     * @since 5.4M1\n     */\n    public Locale getLocale()\n    {\n        return this.doc.getLocale();\n    }\n\n    /**\n     * TODO document this or mark it deprecated\n     */\n    public String getTemplate()\n    {\n        String templateReferenceAsString = \"\";\n        DocumentReference templateDocumentReference = this.doc.getTemplateDocumentReference();\n        if (templateDocumentReference != null) {\n            templateReferenceAsString = getLocalEntityReferenceSerializer().serialize(templateDocumentReference);\n        }\n        return templateReferenceAsString;\n    }\n\n    /**\n     * Same as {@link #getRealLocale()} but as String.\n     *\n     * @return the real locale\n     * @deprecated since 8.0M1, use {@link #getRealLocale()} instead\n     */\n    @Deprecated\n    public String getRealLanguage() throws XWikiException\n    {\n        return this.doc.getRealLanguage(getXWikiContext());\n    }\n\n    /**\n     * Gets the real locale of the document. The real locale is either the default locale field when the locale field is\n     * empty (when the document is the default document) or the locale field otherwise when the document is a\n     * translation document\n     * \n     * @return the actual locale of the document\n     * @since 8.0M1\n     */\n    public Locale getRealLocale()\n    {\n        return this.doc.getRealLocale();\n    }\n\n    /**\n     * Same as {@link #getDefaultLocale()} but as String.\n     * \n     * @return the locale of the default document\n     * @deprecated since 8.0M1, use {@link #getDefaultLocale()} instead\n     */\n    @Deprecated\n    public String getDefaultLanguage()\n    {\n        return this.doc.getDefaultLanguage();\n    }\n\n    /**\n     * @return the Locale of the default version of the document (usually {@link Locale#ROOT} or {@link Locale#ENGLISH})\n     * @since 8.0M1\n     */\n    public Locale getDefaultLocale()\n    {\n        return this.doc.getDefaultLocale();\n    }\n\n    /**\n     * @param defaultLocale the locale content in the default document version\n     * @since 11.9RC1\n     */\n    public void setDefaultLocale(Locale defaultLocale)\n    {\n        this.doc.setDefaultLocale(defaultLocale);\n    }\n\n    /**\n     * TODO document this or mark it deprecated\n     */\n    public String getDefaultTemplate()\n    {\n        return this.doc.getDefaultTemplate();\n    }\n\n    /**\n     * @return the comment of of the document version\n     */\n    public String getComment()\n    {\n        return this.doc.getComment();\n    }\n\n    /**\n     * @return true if the this document version was a minor edit.\n     */\n    public boolean isMinorEdit()\n    {\n        return this.doc.isMinorEdit();\n    }\n\n    /**\n     * @return the list of locales for which this document has a translation; the original (default) locale is not\n     *         included\n     * @throws XWikiException if retrieving the document translations from the database fails\n     * @since 12.4RC1\n     */\n    public List<Locale> getTranslationLocales() throws XWikiException\n    {\n        return this.doc.getTranslationLocales(getXWikiContext());\n    }\n\n    /**\n     * @return the translated document's content if the wiki is multilingual, the locale is first checked in the URL,\n     *         the cookie, the user profile and finally the wiki configuration if not, the locale is the one on the wiki\n     *         configuration.\n     */\n    public String getTranslatedContent() throws XWikiException\n    {\n        return this.doc.getTranslatedContent(getXWikiContext());\n    }\n\n    /**\n     * @return the translated content in the given locale\n     */\n    public String getTranslatedContent(String locale) throws XWikiException\n    {\n        return this.doc.getTranslatedContent(locale, getXWikiContext());\n    }\n\n    /**\n     * @return the translated document in the given locale\n     */\n    public Document getTranslatedDocument(String locale) throws XWikiException\n    {\n        return this.doc.getTranslatedDocument(locale, getXWikiContext()).newDocument(getXWikiContext());\n    }\n\n    /**\n     * @return the tranlated Document if the wiki is multilingual, the locale is first checked in the URL, the cookie,\n     *         the user profile and finally the wiki configuration if not, the locale is the one on the wiki\n     *         configuration.\n     */\n    public Document getTranslatedDocument() throws XWikiException\n    {\n        return this.doc.getTranslatedDocument(getXWikiContext()).newDocument(getXWikiContext());\n    }\n\n    /**\n     * @param targetSyntax the syntax in which to render the document content\n     * @return the content of the current document rendered.\n     * @since 11.3RC1\n     */\n    public String displayDocument(Syntax targetSyntax) throws XWikiException\n    {\n        return this.doc.displayDocument(targetSyntax, getXWikiContext());\n    }\n\n    /**\n     * @param targetSyntax the syntax in which to render the document content\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return the content of the current document rendered.\n     * @since 11.5RC1\n     */\n    public String displayDocument(Syntax targetSyntax, boolean restricted) throws XWikiException\n    {\n        return this.doc.displayDocument(targetSyntax, restricted, getXWikiContext());\n    }\n\n    /**\n     * @return the content of the current document rendered.\n     * @since 11.3RC1\n     */\n    public String displayDocument() throws XWikiException\n    {\n        return this.doc.displayDocument(getXWikiContext());\n    }\n\n    /**\n     * @return the content of the current document rendered.\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @since 11.5RC1\n     */\n    public String displayDocument(boolean restricted) throws XWikiException\n    {\n        return this.doc.displayDocument(restricted, getXWikiContext());\n    }\n\n    /**\n     * @return the content of the document or its translations rendered.\n     */\n    public String getRenderedContent() throws XWikiException\n    {\n        return this.doc.getRenderedContent(getXWikiContext());\n    }\n\n    /**\n     * Execute and render the document in the current context.\n     * <p>\n     * The code is executed with right of this document content author.\n     * \n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @return the result\n     * @throws XWikiException when failing to display the document\n     * @since 8.4RC1\n     */\n    public String getRenderedContent(boolean transformationContextIsolated) throws XWikiException\n    {\n        return this.doc.getRenderedContent(transformationContextIsolated, getXWikiContext());\n    }\n\n    /**\n     * @param text the text to render\n     * @return the given text rendered in the context of this document\n     * @deprecated since 1.6M1 use {@link #getRenderedContent(String, String)}\n     */\n    @Deprecated\n    public String getRenderedContent(String text) throws XWikiException\n    {\n        return getRenderedContent(text, Syntax.XWIKI_1_0.toIdString());\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (for example: \"xwiki/1.0\")\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 1.6M1\n     */\n    public String getRenderedContent(String text, String syntaxId) throws XWikiException\n    {\n        return getRenderedContent(text, syntaxId, false);\n    }\n\n    /**\n     * Render a text in a restricted mode, where script macros are completely disabled.\n     *\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (for example: \"xwiki/1.0\")\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContentRestricted(String text, String syntaxId) throws XWikiException\n    {\n        return getRenderedContent(text, syntaxId, true);\n    }\n\n    /**\n     * Render a text in a restricted mode, where script macros are completely disabled.\n     *\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (for example: \"xwiki/1.0\")\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return the given text rendered in the context of this document using the passed Syntax\n     */\n    private String getRenderedContent(String text, String syntaxId, boolean restricted) throws XWikiException\n    {\n        // Make sure we keep using current author as passed content author\n        return this.doc.getRenderedContent(text, syntaxId, restricted, getCallerDocument(getXWikiContext()),\n            getXWikiContext());\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (for example: \"xwiki/1.0\")\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 2.0M3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId) throws XWikiException\n    {\n        // Make sure we keep using current author as passed content author\n        return this.doc.getRenderedContent(text, sourceSyntaxId, targetSyntaxId, false,\n            getCallerDocument(getXWikiContext()), getXWikiContext());\n    }\n\n    private XWikiDocument getCallerDocument(XWikiContext xcontext)\n    {\n        XWikiDocument sdoc = (XWikiDocument) xcontext.get(\"sdoc\");\n        if (sdoc == null) {\n            sdoc = xcontext.getDoc();\n        }\n\n        return sdoc;\n    }\n\n    /**\n     * @param targetSyntax the syntax in which to render the document content\n     * @return the rendered content\n     * @throws XWikiException error when rendering content\n     */\n    public String getRenderedContent(Syntax targetSyntax) throws XWikiException\n    {\n        return this.doc.getRenderedContent(targetSyntax, getXWikiContext());\n    }\n\n    /**\n     * Get the document's content XML-escaped.\n     *\n     * @return an XML-escaped version of the content of this document.\n     */\n    public String getEscapedContent() throws XWikiException\n    {\n        return this.doc.getEscapedContent(getXWikiContext());\n    }\n\n    /**\n     * @return the archive of this document's history in string format\n     */\n    public String getArchive() throws XWikiException\n    {\n        return this.doc.getDocumentArchive(getXWikiContext()).getArchive(getXWikiContext());\n    }\n\n    /**\n     * Get the archive of this document's history. This function is accessible only if you have the programming rights.\n     *\n     * @return the archive of this document's history as an {@link XWikiDocumentArchive}.\n     */\n    public XWikiDocumentArchive getDocumentArchive() throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.doc.getDocumentArchive(getXWikiContext());\n        }\n        return null;\n    }\n\n    /**\n     * @return true if the document is a new one (ie it has never been saved) or false otherwise\n     */\n    public boolean isNew()\n    {\n        return this.doc.isNew();\n    }\n\n    /**\n     * Return the relative URL of download for the the given attachment name.\n     *\n     * @param filename the name of the attachment\n     * @return A String with the URL or null if the file name is empty\n     */\n    public String getAttachmentURL(String filename)\n    {\n        return this.doc.getAttachmentURL(filename, getXWikiContext());\n    }\n\n    /**\n     * Get the relative URL of the given action for the the given attachment name.\n     *\n     * @param filename the name of the attachment.\n     * @param action what to do to the file for example \"delattachment\", \"download\" or \"downloadrev\".\n     * @return a string representation of a URL to do the given operation or null if the file name is empty\n     */\n    public String getAttachmentURL(String filename, String action)\n    {\n        return this.doc.getAttachmentURL(filename, action, getXWikiContext());\n    }\n\n    /**\n     * Get the relative URL of an action on an attachment. the given action for the the given attachment name with\n     * \"queryString\" parameters\n     *\n     * @param filename the name of the attachment.\n     * @param action what to do to the file for example \"delattachment\", \"download\" or \"downloadrev\"\n     * @param queryString parameters added to the URL, the \"rev\" parameter is used to specify a revision if using the\n     *            \"downloadrev\" action. The query string must not begin with an ? character.\n     * @return a string representation of a URL to do the given operation or null if the file name is empty\n     */\n    public String getAttachmentURL(String filename, String action, String queryString)\n    {\n        return this.doc.getAttachmentURL(filename, action, queryString, getXWikiContext());\n    }\n\n    /**\n     * Get an old revision of an attachment.\n     *\n     * @param filename the name of the attachment.\n     * @param version a revision number such as \"1.1\" or \"1.2\".\n     * @return the URL for accessing to the archive of the attachment \"filename\" at the version \"version\" or null if the\n     *         file name is empty\n     */\n    public String getAttachmentRevisionURL(String filename, String version)\n    {\n        return this.doc.getAttachmentRevisionURL(filename, version, getXWikiContext());\n    }\n\n    /**\n     * Get an old revision of an attachment.\n     *\n     * @param filename the name of the attachment.\n     * @param version a revision number such as \"1.1\" or \"1.2\".\n     * @param queryString additional query parameters to pass in the request.\n     * @return the URL for accessing to the archive of the attachment \"filename\" at the version \"version\" with the given\n     *         queryString parameters or null if the file name is empty\n     */\n    public String getAttachmentRevisionURL(String filename, String version, String queryString)\n    {\n        return this.doc.getAttachmentRevisionURL(filename, version, queryString, getXWikiContext());\n    }\n\n    /**\n     * Get the URL of this document.\n     *\n     * @return the URL to view this document, this will be a relative URL for example: /xwiki/bin/view/Main/WebHome\n     * @see #getExternalURL() for an absolute URL which can used outside of the site.\n     */\n    public String getURL()\n    {\n        return this.doc.getURL(\"view\", getXWikiContext());\n    }\n\n    /**\n     * Get the URL to do a given action on this document.\n     *\n     * @param action what to do to the document for example \"view\", \"edit\" or \"inline\".\n     * @return the URL of this document with the given action.\n     * @see #getExternalURL(String) for an absolute URL which can used outside of the site.\n     */\n    public String getURL(String action)\n    {\n        return this.doc.getURL(action, getXWikiContext());\n    }\n\n    /**\n     * Get the URL to do a given action on this document.\n     *\n     * @param action what to do to the document for example \"view\", \"edit\" or \"inline\".\n     * @param queryString parameters to pass in the request eg: {@code paramA=value1&paramB=value2}\n     * @return the URL of this document with the given action and queryString as parameters.\n     * @see #getExternalURL(String, String) for an absolute URL which can used outside of the site.\n     */\n    public String getURL(String action, String queryString)\n    {\n        return this.doc.getURL(action, queryString, getXWikiContext());\n    }\n\n    /**\n     * Get the external URL to do a given action on this document.\n     *\n     * @return the full URL of the document, sutable for use at external websites for example:\n     *         http://www.xwiki.org/xwiki/bin/view/Main/WebHome\n     * @see #getURL() for a relative URL which can only be used inside of the site.\n     */\n    public String getExternalURL()\n    {\n        return this.doc.getExternalURL(\"view\", getXWikiContext());\n    }\n\n    /**\n     * Get the external URL to do a given action on this document.\n     *\n     * @param action what to do to the document for example \"view\", \"edit\" or \"inline\".\n     * @return the URL of this document with the given action.\n     * @see #getURL() for a relative URL which can only be used inside of the site.\n     */\n    public String getExternalURL(String action)\n    {\n        return this.doc.getExternalURL(action, getXWikiContext());\n    }\n\n    /**\n     * Get the URL to do a given action on this document.\n     *\n     * @param action what to do to the document for example \"view\", \"edit\" or \"inline\".\n     * @param queryString parameters to pass in the request eg: {@code paramA=value1&paramB=value2}\n     * @return the URL of this document with the given action and queryString as parameters.\n     * @see #getURL() for a relative URL which can only be used inside of the site.\n     */\n    public String getExternalURL(String action, String queryString)\n    {\n        return this.doc.getExternalURL(action, queryString, getXWikiContext());\n    }\n\n    /**\n     * @return the relative URL of the parent document of this document\n     */\n    public String getParentURL() throws XWikiException\n    {\n        return this.doc.getParentURL(getXWikiContext());\n    }\n\n    /**\n     * @return the XClass associated to this document when the document represents an XWiki Class\n     */\n    public Class getxWikiClass()\n    {\n        BaseClass bclass = this.getDoc().getXClass();\n        if (bclass == null) {\n            return null;\n        } else {\n            return new Class(bclass, getXWikiContext());\n        }\n    }\n\n    /**\n     * @return the array of XClasses representing the objects of this document\n     */\n    public Class[] getxWikiClasses()\n    {\n        List<BaseClass> list = this.getDoc().getXClasses(getXWikiContext());\n        if (list == null) {\n            return null;\n        }\n        Class[] result = new Class[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            result[i] = new Class(list.get(i), getXWikiContext());\n        }\n        return result;\n    }\n\n    /**\n     * Creates a New XWiki Object of the given classname\n     *\n     * @param classname the classname used\n     * @return the number of the object created\n     */\n    public int createNewObject(String classname) throws XWikiException\n    {\n        int index = getDoc().createNewObject(classname, getXWikiContext());\n\n        updateAuthor();\n\n        return index;\n    }\n\n    /**\n     * Creates a New XWiki Object of the given classname\n     *\n     * @param classname the classname used\n     * @return the object created\n     */\n    public Object newObject(String classname) throws XWikiException\n    {\n        int nb = createNewObject(classname);\n        return getObject(classname, nb);\n    }\n\n    /**\n     * @return true of the document has been loaded from cache\n     */\n    public boolean isFromCache()\n    {\n        return this.doc.isFromCache();\n    }\n\n    /**\n     * @param classname the classname used\n     * @return the number of objects available for a given classname\n     */\n    public int getObjectNumbers(String classname)\n    {\n        return this.doc.getObjectNumbers(classname);\n    }\n\n    /**\n     * Get the list of all objects available in this document organized in a Map by classname\n     *\n     * @return the map of objects\n     */\n    public Map<String, Vector<Object>> getxWikiObjects()\n    {\n        Map<DocumentReference, List<BaseObject>> map = this.getDoc().getXObjects();\n        Map<String, Vector<Object>> resultmap = new HashMap<String, Vector<Object>>();\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : map.entrySet()) {\n            List<BaseObject> objects = entry.getValue();\n            if (objects != null) {\n                resultmap.put(getLocalEntityReferenceSerializer().serialize(entry.getKey()), getXObjects(objects));\n            }\n        }\n        return resultmap;\n    }\n\n    protected Vector<Object> getXObjects(List<BaseObject> objects)\n    {\n        if (objects == null) {\n            return new Vector<Object>(0);\n        }\n        Vector<Object> result = new Vector<Object>(objects.size());\n        for (BaseObject bobj : objects) {\n            if (bobj != null) {\n                result.add(newObjectApi(bobj, getXWikiContext()));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the list of objects for a given classname classname\n     *\n     * @return the vector of objects\n     */\n    public Vector<Object> getObjects(String className)\n    {\n        List<BaseObject> objects = this.getDoc().getXObjects(this.doc.resolveClassReference(className));\n        return getXObjects(objects);\n    }\n\n    /**\n     * Get the first object that contains the given fieldname\n     *\n     * @param fieldname name of the field to find in the object\n     * @return the XWiki Object\n     */\n    public Object getFirstObject(String fieldname)\n    {\n        try {\n            BaseObject obj = this.getDoc().getFirstObject(fieldname, getXWikiContext());\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the first object of a given classname that has a field name matching the given value\n     *\n     * @param classname name of the class of the object to look for\n     * @param key name of the field to find in the object\n     * @param value value of the field to find in the object\n     * @param failover true if the first object will be given when none found\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname, String key, String value, boolean failover)\n    {\n        try {\n            BaseObject obj = this.getDoc().getObject(classname, key, value, failover);\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Select a subset of objects from a given class, filtered on a \"key = value\" criteria.\n     *\n     * @param classname The type of objects to return.\n     * @param key The name of the property used for filtering.\n     * @param value The required value.\n     * @return A Vector of {@link Object objects} matching the criteria. If no objects are found, or if the key is an\n     *         empty String, then an empty vector is returned.\n     */\n    public Vector<Object> getObjects(String classname, String key, String value)\n    {\n        Vector<Object> result = new Vector<Object>();\n        if (StringUtils.isBlank(key) || value == null) {\n            return getObjects(classname);\n        }\n        try {\n            Vector<BaseObject> allObjects = this.getDoc().getObjects(classname);\n            if (allObjects == null || allObjects.size() == 0) {\n                return result;\n            } else {\n                for (BaseObject obj : allObjects) {\n                    if (obj != null) {\n                        BaseProperty prop = (BaseProperty) obj.get(key);\n                        if (prop == null || prop.getValue() == null) {\n                            continue;\n                        }\n                        if (value.equals(prop.getValue().toString())) {\n                            result.add(newObjectApi(obj, getXWikiContext()));\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n        return result;\n    }\n\n    /**\n     * Get the first object of a given classname that has a field name matching the given value When none found this\n     * method will return null\n     *\n     * @param classname name of the class of the object to look for\n     * @param key name of the field to find in the object\n     * @param value value of the field to find in the object\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname, String key, String value)\n    {\n        try {\n            BaseObject obj = this.getDoc().getObject(classname, key, value);\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the first object matching the given classname\n     *\n     * @param classname name of the class of the object to look for\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname)\n    {\n        return getObject(classname, false);\n    }\n\n    /**\n     * get the object of the given className. If there is no object of this className and the create parameter at true,\n     * the object is created.\n     *\n     * @param classname name of the class of the object to look for\n     * @param create true of the object should be created when it does not exist\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname, boolean create)\n    {\n        try {\n            BaseObject obj = getDoc().getObject(classname, create, getXWikiContext());\n\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get the object matching the given classname and given object number\n     *\n     * @param classname name of the class of the object\n     * @param nb number of the object\n     * @return the XWiki Object\n     */\n    public Object getObject(String classname, int nb)\n    {\n        try {\n            BaseObject obj = this.getDoc().getObject(classname, nb);\n            if (obj == null) {\n                return null;\n            } else {\n                return newObjectApi(obj, getXWikiContext());\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @param objectReference the object reference\n     * @return the XWiki object from this document that matches the specified object reference\n     * @since 12.3RC1\n     */\n    public Object getObject(ObjectReference objectReference)\n    {\n        try {\n            BaseObject obj = this.getDoc().getXObject(objectReference);\n            return obj == null ? null : newObjectApi(obj, getXWikiContext());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @param objectReference the object reference\n     * @param create if true, the object will be created when missing\n     * @return the XWiki object from this document that matches the specified object reference\n     * @since 14.0RC1\n     */\n    @Unstable\n    public Object getObject(ObjectReference objectReference, boolean create)\n    {\n        try {\n            BaseObject obj = this.getDoc().getXObject(objectReference, create, getXWikiContext());\n            return obj == null ? null : newObjectApi(obj, getXWikiContext());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private Object newObjectApi(BaseObject obj, XWikiContext context)\n    {\n        return obj.newObjectApi(obj, context);\n    }\n\n    public String getXMLContent() throws XWikiException\n    {\n        String xml = this.doc.getXMLContent(getXWikiContext());\n        return getXWikiContext().getUtil().substitute(\"s/<email>.*?<\\\\/email>/<email>********<\\\\/email>/goi\",\n            getXWikiContext().getUtil().substitute(\"s/<password>.*?<\\\\/password>/<password>********<\\\\/password>/goi\",\n                xml));\n    }\n\n    public String toXML() throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.doc.toXML(getXWikiContext());\n        } else {\n            return \"\";\n        }\n    }\n\n    public org.dom4j.Document toXMLDocument() throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.doc.toXMLDocument(getXWikiContext());\n        } else {\n            return null;\n        }\n    }\n\n    public Version[] getRevisions() throws XWikiException\n    {\n        return this.doc.getRevisions(getXWikiContext());\n    }\n\n    public String[] getRecentRevisions() throws XWikiException\n    {\n        return this.doc.getRecentRevisions(5, getXWikiContext());\n    }\n\n    public String[] getRecentRevisions(int nb) throws XWikiException\n    {\n        return this.doc.getRecentRevisions(nb, getXWikiContext());\n    }\n\n    /**\n     * Get document versions matching criterias like author, minimum creation date, etc.\n     *\n     * @param criteria criteria used to match versions\n     * @return a list of matching versions\n     */\n    public List<String> getRevisions(RevisionCriteria criteria) throws XWikiException\n    {\n        return this.doc.getRevisions(criteria, this.context);\n    }\n\n    /**\n     * Get information about a document version : author, date, etc.\n     *\n     * @param version the version you want to get information about\n     * @return a new RevisionInfo object\n     */\n    public RevisionInfo getRevisionInfo(String version) throws XWikiException\n    {\n        return new RevisionInfo(this.doc.getRevisionInfo(version, getXWikiContext()), getXWikiContext());\n    }\n\n    public List<Attachment> getAttachmentList()\n    {\n        List<Attachment> apis = new ArrayList<Attachment>();\n        for (XWikiAttachment attachment : this.getDoc().getAttachmentList()) {\n            apis.add(new Attachment(this, attachment, getXWikiContext()));\n        }\n        return apis;\n    }\n\n    public Vector<Object> getComments()\n    {\n        return getComments(true);\n    }\n\n    public Vector<Object> getComments(boolean asc)\n    {\n        return getXObjects(this.getDoc().getComments(asc));\n    }\n\n    /**\n     * Setting the current object to the given object. Following calls to display() will use this object as the\n     * reference for finding properties.\n     *\n     * @param object Object to use as a reference for further display calls\n     */\n    public void use(Object object)\n    {\n        this.currentObj = object;\n    }\n\n    /**\n     * Setting the current object to the first object of the given class name. Following calls to display() will use\n     * this object as the reference for finding properties.\n     *\n     * @param className class used to find the first object to use as the reference for display calls\n     */\n    public void use(String className)\n    {\n        this.currentObj = getObject(className);\n    }\n\n    /**\n     * Setting the current object to the object of the given class name and the given number. Following calls to\n     * display() will use this object as the reference for finding properties.\n     *\n     * @param className class used to find the object to use as the reference for display calls\n     * @param nb number of the object to use as the reference for display calls\n     */\n    public void use(String className, int nb)\n    {\n        this.currentObj = getObject(className, nb);\n    }\n\n    /**\n     * @return the className of the current active object use for display calls.\n     */\n    public String getActiveClass()\n    {\n        if (this.currentObj == null) {\n            return null;\n        } else {\n            return this.currentObj.getName();\n        }\n    }\n\n    /**\n     * Displays the pretty name of the given field. This function uses the active object or will find the first object\n     * that has the given field.\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname)\n    {\n        if (this.currentObj == null) {\n            return this.doc.displayPrettyName(fieldname, getXWikiContext());\n        } else {\n            return this.doc.displayPrettyName(fieldname, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the pretty name of the given field of the given object.\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param obj Object to find the class to display the pretty name of\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.displayPrettyName(fieldname, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the pretty name of the given field. This function uses the active object or will find the first object\n     * that has the given field. with the optional addition of a mandatory field.\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param showMandatory true to display a mandatory sign\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, boolean showMandatory)\n    {\n        if (this.currentObj == null) {\n            return this.doc.displayPrettyName(fieldname, showMandatory, getXWikiContext());\n        } else {\n            return this.doc.displayPrettyName(fieldname, showMandatory, this.currentObj.getBaseObject(),\n                getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the pretty name of the given field of the given object. with the optional addition of a mandatory field.\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param obj Object to find the class to display the pretty name of\n     * @param showMandatory true to display a mandatory sign\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, boolean showMandatory, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.displayPrettyName(fieldname, showMandatory, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the pretty name of the given field. This function uses the active object or will find the first object\n     * that has the given field. with the optional addition of a mandatory field before or after the field\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param showMandatory true to display a mandatory sign\n     * @param before true if the mandatory sign should be before the field\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before)\n    {\n        if (this.currentObj == null) {\n            return this.doc.displayPrettyName(fieldname, showMandatory, before, getXWikiContext());\n        } else {\n            return this.doc.displayPrettyName(fieldname, showMandatory, before, this.currentObj.getBaseObject(),\n                getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the pretty name of the given field of the given object. with the optional addition of a mandatory field\n     * before or after the field\n     *\n     * @param fieldname fieldname to display the pretty name of\n     * @param showMandatory true to display a mandatory sign\n     * @param before true if the mandatory sign should be before the field\n     * @param obj Object to find the class to display the pretty name of\n     * @return the pretty name display of the field.\n     */\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.displayPrettyName(fieldname, showMandatory, before, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the tooltip of the given field. This function uses the active object or will find the first object that\n     * has the given field.\n     *\n     * @param fieldname fieldname to display the tooltip of\n     * @return the tooltip display of the field.\n     */\n    public String displayTooltip(String fieldname)\n    {\n        if (this.currentObj == null) {\n            return this.doc.displayTooltip(fieldname, getXWikiContext());\n        } else {\n            return this.doc.displayTooltip(fieldname, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the tooltip of the given field of the given object.\n     *\n     * @param fieldname fieldname to display the tooltip of\n     * @param obj Object to find the class to display the tooltip of\n     * @return the tooltip display of the field.\n     */\n    public String displayTooltip(String fieldname, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.displayTooltip(fieldname, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the given field. The display mode will be decided depending on page context (edit or inline context will\n     * display in edit, view context in view) This function uses the active object or will find the first object that\n     * has the given field. This function can return html inside and html macro\n     *\n     * @param fieldname fieldname to display\n     * @return the display of the field.\n     */\n    public String display(String fieldname)\n    {\n        if (this.currentObj == null) {\n            return this.doc.display(fieldname, getXWikiContext());\n        } else {\n            return this.doc.display(fieldname, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the given field in the given mode. This function uses the active object or will find the first object\n     * that has the given field. This function can return html inside and html macro\n     *\n     * @param fieldname fieldname to display\n     * @param mode display mode to use (view, edit, hidden, search)\n     * @return the display of the field.\n     */\n    public String display(String fieldname, String mode)\n    {\n        if (this.currentObj == null) {\n            return this.doc.display(fieldname, mode, getXWikiContext());\n        } else {\n            return this.doc.display(fieldname, mode, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the given field in the given mode. This function uses the active object or will find the first object\n     * that has the given field. This function can return html inside and html macro A given prefix is added to the\n     * field names when these are forms.\n     *\n     * @param fieldname fieldname to display\n     * @param mode display mode to use (view, edit, hidden, search)\n     * @param prefix prefix to use for the form names\n     * @return the display of the field.\n     */\n    public String display(String fieldname, String mode, String prefix)\n    {\n        if (this.currentObj == null) {\n            return this.doc.display(fieldname, mode, prefix, getXWikiContext());\n        } else {\n            return this.doc.display(fieldname, mode, prefix, this.currentObj.getBaseObject(), getSyntaxId(),\n                getXWikiContext());\n        }\n    }\n\n    /**\n     * Displays the given field of the given object The display mode will be decided depending on page context (edit or\n     * inline context will display in edit, view context in view) This function can return html inside and html macro\n     *\n     * @param fieldname fieldname to display\n     * @param obj object from which to take the field\n     * @return the display of the field.\n     */\n    public String display(String fieldname, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.display(fieldname, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the given field of the given object using the given mode and syntax rendering The display mode will be\n     * decided depending on page context (edit or inline context will display in edit, view context in view) This\n     * function can return html inside and html macro\n     *\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, Object obj, String wrappingSyntaxId)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.display(fieldname, type, obj.getBaseObject(), wrappingSyntaxId, getXWikiContext());\n    }\n\n    /**\n     * Displays the given field of the given object in the given mode. This function can return html inside and html\n     * macro\n     *\n     * @param fieldname fieldname to display\n     * @param mode display mode to use (view, edit, hidden, search)\n     * @param obj the object containing the field to display\n     * @return the display of the field.\n     */\n    public String display(String fieldname, String mode, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.display(fieldname, mode, obj.getBaseObject(), getXWikiContext());\n    }\n\n    /**\n     * Displays the given field of the given object in the given mode. This function can return html inside and html\n     * macro A given prefix is added to the field names when these are forms.\n     *\n     * @param fieldname fieldname to display\n     * @param mode display mode to use (view, edit, hidden, search)\n     * @param prefix prefix to use for the form names\n     * @param obj the object containing the field to display\n     * @return the display of the field.\n     */\n    public String display(String fieldname, String mode, String prefix, Object obj)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n        return this.doc.display(fieldname, mode, prefix, obj.getBaseObject(), getSyntaxId(), getXWikiContext());\n    }\n\n    public String displayForm(String className, String header, String format)\n    {\n        return this.doc.displayForm(className, header, format, getXWikiContext());\n    }\n\n    public String displayForm(String className, String header, String format, boolean linebreak)\n    {\n        return this.doc.displayForm(className, header, format, linebreak, getXWikiContext());\n    }\n\n    public String displayForm(String className)\n    {\n        return this.doc.displayForm(className, getXWikiContext());\n    }\n\n    public String displayRendered(com.xpn.xwiki.api.PropertyClass pclass, String prefix, Collection object)\n        throws XWikiException\n    {\n        if ((pclass == null) || (object == null)) {\n            return \"\";\n        }\n        return this.doc.displayRendered(pclass.getBasePropertyClass(), prefix, object.getCollection(),\n            getXWikiContext());\n    }\n\n    public String displayView(com.xpn.xwiki.api.PropertyClass pclass, String prefix, Collection object)\n    {\n        if ((pclass == null) || (object == null)) {\n            return \"\";\n        }\n        return this.doc.displayView(pclass.getBasePropertyClass(), prefix, object.getCollection(), getXWikiContext());\n    }\n\n    public String displayEdit(com.xpn.xwiki.api.PropertyClass pclass, String prefix, Collection object)\n    {\n        if ((pclass == null) || (object == null)) {\n            return \"\";\n        }\n        return this.doc.displayEdit(pclass.getBasePropertyClass(), prefix, object.getCollection(), getXWikiContext());\n    }\n\n    public String displayHidden(com.xpn.xwiki.api.PropertyClass pclass, String prefix, Collection object)\n    {\n        if ((pclass == null) || (object == null)) {\n            return \"\";\n        }\n        return this.doc.displayHidden(pclass.getBasePropertyClass(), prefix, object.getCollection(), getXWikiContext());\n    }\n\n    public List<String> getIncludedPages()\n    {\n        return this.doc.getIncludedPages(getXWikiContext());\n    }\n\n    public List<String> getIncludedMacros()\n    {\n        return this.doc.getIncludedMacros(getXWikiContext());\n    }\n\n    public List<String> getLinkedPages()\n    {\n        return new ArrayList<String>(this.doc.getUniqueLinkedPages(getXWikiContext()));\n    }\n\n    public Attachment getAttachment(String filename)\n    {\n        XWikiAttachment attach = this.getDoc().getAttachment(filename);\n        if (attach == null) {\n            return null;\n        } else {\n            return new Attachment(this, attach, getXWikiContext());\n        }\n    }\n\n    public List<Delta> getContentDiff(Document origdoc, Document newdoc)\n        throws XWikiException, DifferentiationFailedException\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getContentDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getContentDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getContentDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                    \"Error while making content diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<Delta> getXMLDiff(Document origdoc, Document newdoc)\n        throws XWikiException, DifferentiationFailedException\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getXMLDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getXMLDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getXMLDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_XML_ERROR,\n                    \"Error while making xml diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<Delta> getRenderedContentDiff(Document origdoc, Document newdoc)\n        throws XWikiException, DifferentiationFailedException\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getRenderedContentDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getRenderedContentDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getRenderedContentDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_RENDERED_ERROR,\n                    \"Error while making rendered diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(Document origdoc, Document newdoc) throws XWikiException\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getMetaDataDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getMetaDataDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getMetaDataDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_METADATA_ERROR,\n                    \"Error while making meta data diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(Document origdoc, Document newdoc)\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getObjectDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getObjectDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getObjectDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_OBJECT_ERROR,\n                    \"Error while making meta object diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<List<ObjectDiff>> getClassDiff(Document origdoc, Document newdoc)\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return this.doc.getClassDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,\n                    getXWikiContext());\n            }\n            if (newdoc == null) {\n                return this.doc.getClassDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),\n                    getXWikiContext());\n            }\n\n            return this.doc.getClassDiff(origdoc.doc, newdoc.doc, getXWikiContext());\n        } catch (Exception e) {\n            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CLASS_ERROR,\n                    \"Error while making class diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    public List<AttachmentDiff> getAttachmentDiff(Document origdoc, Document newdoc)\n    {\n        try {\n            if ((origdoc == null) && (newdoc == null)) {\n                return Collections.emptyList();\n            }\n            if (origdoc == null) {\n                return wrapAttachmentDiff(this.doc.getAttachmentDiff(new XWikiDocument(newdoc.getDocumentReference()),\n                    newdoc.doc, getXWikiContext()));\n            }\n            if (newdoc == null) {\n                return wrapAttachmentDiff(this.doc.getAttachmentDiff(origdoc.doc,\n                    new XWikiDocument(origdoc.getDocumentReference()), getXWikiContext()));\n            }\n\n            return wrapAttachmentDiff(this.doc.getAttachmentDiff(origdoc.doc, newdoc.doc, getXWikiContext()));\n        } catch (Exception e) {\n            java.lang.Object[] args = { (origdoc != null) ? origdoc.getFullName() : null,\n            (origdoc != null) ? origdoc.getVersion() : null, (newdoc != null) ? newdoc.getVersion() : null };\n            List list = new ArrayList();\n            XWikiException xe =\n                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_ATTACHMENT_ERROR,\n                    \"Error while making attachment diff of {0} between version {1} and version {2}\", e, args);\n            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());\n            list.add(errormsg);\n            return list;\n        }\n    }\n\n    private List<AttachmentDiff> wrapAttachmentDiff(List<com.xpn.xwiki.doc.AttachmentDiff> diffs)\n    {\n        List<AttachmentDiff> safeAttachmentDiffs = new ArrayList<>();\n        for (com.xpn.xwiki.doc.AttachmentDiff diff : diffs) {\n            safeAttachmentDiffs.add(new AttachmentDiff(diff, getXWikiContext()));\n        }\n        return safeAttachmentDiffs;\n    }\n\n    public List<Delta> getLastChanges() throws XWikiException, DifferentiationFailedException\n    {\n        return this.doc.getLastChanges(getXWikiContext());\n    }\n\n    /**\n     * Get statistics about the number of request for the current page during the current month.\n     *\n     * @param action the type of request for which to retrieve statistics: view, edit...\n     * @return the statistics object holding information for this document and the current month\n     */\n    public DocumentStats getCurrentMonthPageStats(String action)\n    {\n        Scope scope = ScopeFactory.createPageScope(this.getFullName());\n        Range range = RangeFactory.ALL;\n        Period period = PeriodFactory.getCurrentMonth();\n        XWikiStatsService statisticsService = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        List<DocumentStats> stats = statisticsService.getDocumentStatistics(action, scope, period, range, this.context);\n        if (stats.size() > 0) {\n            return stats.get(0);\n        }\n        return new DocumentStats();\n    }\n\n    /**\n     * Get statistics about the number of request for the current space during the current month.\n     *\n     * @param action the type of request for which to retrieve statistics: view, edit...\n     * @return the statistics object holding information for the document's space and the current month\n     */\n    public DocumentStats getCurrentMonthSpaceStats(String action)\n    {\n        Scope scope = ScopeFactory.createSpaceScope(this.doc.getSpace(), false);\n        Range range = RangeFactory.ALL;\n        Period period = PeriodFactory.getCurrentMonth();\n        XWikiStatsService statisticsService = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        List<DocumentStats> stats = statisticsService.getDocumentStatistics(action, scope, period, range, this.context);\n        if (stats.size() > 0) {\n            return stats.get(0);\n        }\n        return new DocumentStats();\n    }\n\n    /**\n     * Get referer statistics for the current document during the current month.\n     *\n     * @return a list of referer statistics for the document's space\n     */\n    public List<RefererStats> getCurrentMonthRefStats()\n    {\n        Scope scope = ScopeFactory.createPageScope(this.getFullName());\n        Range range = RangeFactory.ALL;\n        Period period = PeriodFactory.getCurrentMonth();\n        XWikiStatsService statisticsService = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        List<RefererStats> stats = statisticsService.getRefererStatistics(\"\", scope, period, range, this.context);\n        return stats;\n    }\n\n    public boolean checkAccess(String right)\n    {\n        try {\n            return getXWikiContext().getWiki().checkAccess(right, this.doc, getXWikiContext());\n        } catch (XWikiException e) {\n            return false;\n        }\n    }\n\n    public boolean hasAccessLevel(String level)\n    {\n        try {\n            return getXWikiContext().getWiki().getRightService().hasAccessLevel(level, getXWikiContext().getUser(),\n                this.getPrefixedFullName(), getXWikiContext());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    @Override\n    public boolean hasAccessLevel(String level, String user)\n    {\n        try {\n            return getXWikiContext().getWiki().getRightService().hasAccessLevel(level, user, this.getPrefixedFullName(),\n                getXWikiContext());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * Verifies if the user identified by {@code userReference} has the access identified by {@code right} on this\n     * document.\n     * Note that this method does not override {@link Api#hasAccess(Right, DocumentReference)}: they share same\n     * signature but on the {@code Api} one the {@link DocumentReference} parameter is about the entity where to check\n     * the right, while here it's about the user to check right for.\n     * \n     * @param right the right to check\n     * @param userReference the user to check the right for\n     * @return {@code true} if the user has the specified right on this document, {@code false} otherwise\n     * @since 10.6RC1\n     */\n    public boolean hasAccess(Right right, DocumentReference userReference)\n    {\n        return getAuthorizationManager().hasAccess(right, userReference, getDocumentReference());\n    }\n\n    /**\n     * Verifies if the context user has the access identified by {@code right} on the current context document.\n     * @param right the right to check\n     * @return {@code true} if the user has the specified right on this document, {@code false} otherwise\n     * @since 14.10\n     * @since 14.4.7\n     */\n    @Unstable\n    public boolean hasAccess(Right right)\n    {\n        return hasAccess(right, getXWikiContext().getUserReference());\n    }\n\n    public boolean getLocked()\n    {\n        try {\n            XWikiLock lock = this.doc.getLock(getXWikiContext());\n            if (lock != null && !getXWikiContext().getUser().equals(lock.getUserName())) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public String getLockingUser()\n    {\n        try {\n            XWikiLock lock = this.doc.getLock(getXWikiContext());\n            if (lock != null && !getXWikiContext().getUser().equals(lock.getUserName())) {\n                return lock.getUserName();\n            } else {\n                return \"\";\n            }\n        } catch (XWikiException e) {\n            return \"\";\n        }\n    }\n\n    public Date getLockingDate()\n    {\n        try {\n            XWikiLock lock = this.doc.getLock(getXWikiContext());\n            if (lock != null && !getXWikiContext().getUser().equals(lock.getUserName())) {\n                return lock.getDate();\n            } else {\n                return null;\n            }\n        } catch (XWikiException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Renders the passed xproperty as HTML. Note that if you need the raw value, you should call \n     * {@link #getValue(String)} instead. \n     *\n     * @param classOrFieldName the xproperty (aka field) name to render or an xclass reference\n     * @return the rendered xproperty as HTML if an xobject exists with that xproperty. Otherwise considers that the\n     *         passed parameter is an xclass reference and return the xobject for it or null if none exist\n     * @see #getValue(String) \n     * @see #getValue(String, Object) \n     */\n    public java.lang.Object get(String classOrFieldName)\n    {\n        if (this.currentObj != null) {\n            return this.doc.display(classOrFieldName, this.currentObj.getBaseObject(), getXWikiContext());\n        }\n        BaseObject object = this.doc.getFirstObject(classOrFieldName, getXWikiContext());\n        if (object != null) {\n            return this.doc.display(classOrFieldName, object, getXWikiContext());\n        }\n        return this.getDoc().getObject(classOrFieldName);\n    }\n\n    /**\n     * @param fieldName the xproperty (aka field) name for which to get the value\n     * @return the raw value of the passed xproperty found in the current xobject or in the first xobject containing\n     *         such a field\n     * @see #getValue(String, Object) \n     */\n    public java.lang.Object getValue(String fieldName)\n    {\n        Object object;\n        if (this.currentObj == null) {\n            object = new Object(this.getDoc().getFirstObject(fieldName, getXWikiContext()), getXWikiContext());\n        } else {\n            object = this.currentObj;\n        }\n        return getValue(fieldName, object);\n    }\n\n    /**\n     * @param fieldName the xproperty (aka field) name for which to get the value\n     * @param object the specific xobject from which to get the xproperty value\n     * @return the raw value of the passed xproperty\n     * @see #getValue(String)\n     */\n    public java.lang.Object getValue(String fieldName, Object object)\n    {\n        if (object != null) {\n            return object.getValue(fieldName);\n        }\n\n        return null;\n    }\n\n    public String getTextArea()\n    {\n        return com.xpn.xwiki.XWiki.getTextArea(this.doc.getContent(), getXWikiContext());\n    }\n\n    /**\n     * Returns data needed for a generation of Table of Content for this document.\n     *\n     * @param init an intial level where the TOC generation should start at\n     * @param max maximum level TOC is generated for\n     * @param numbered if should generate numbering for headings\n     * @return a map where an heading (title) ID is the key and value is another map with two keys: text, level and\n     *         numbering\n     */\n    public Map<String, Map<String, java.lang.Object>> getTOC(int init, int max, boolean numbered)\n    {\n        getXWikiContext().put(\"tocNumbered\", new Boolean(numbered));\n        return TOCGenerator.generateTOC(getContent(), init, max, numbered, getXWikiContext());\n    }\n\n    public String getTags()\n    {\n        return this.doc.getTags(getXWikiContext());\n    }\n\n    public List<String> getTagList()\n    {\n        return this.getDoc().getTagsList(getXWikiContext());\n    }\n\n    public List<String> getTagsPossibleValues()\n    {\n        return this.doc.getTagsPossibleValues(getXWikiContext());\n    }\n\n    public void insertText(String text, String marker) throws XWikiException\n    {\n        if (hasAccessLevel(\"edit\")) {\n            getDoc().insertText(text, marker, getXWikiContext());\n\n            updateAuthor();\n            updateContentAuthor();\n        }\n    }\n\n    @Override\n    public boolean equals(java.lang.Object arg0)\n    {\n        if (!(arg0 instanceof Document)) {\n            return false;\n        }\n        Document d = (Document) arg0;\n        return d.getXWikiContext().equals(getXWikiContext()) && this.doc.equals(d.doc);\n    }\n\n    /**\n     * Check if the passed one is the one wrapped by this {@link Document}.\n     * \n     * @param document the document to compare\n     * @return true if passed document is the wrapped one\n     * @since 8.3M1\n     */\n    public boolean same(XWikiDocument document)\n    {\n        return document == this.doc || document == this.initialDoc;\n    }\n\n    public List<String> getBacklinks() throws XWikiException\n    {\n        return this.doc.getBackLinkedPages(getXWikiContext());\n    }\n\n    /**\n     * Retrieve the references of the page containing a link to the current page.\n     *\n     * @return a list of references of the page containing a link to the current page.\n     * @throws XWikiException in case of problem to perform the query.\n     * @since 12.5RC1\n     */\n    public List<DocumentReference> getBackLinkedReferences() throws XWikiException\n    {\n        return this.doc.getBackLinkedReferences(getXWikiContext());\n    }\n\n    public List<XWikiLink> getLinks() throws XWikiException\n    {\n        return new ArrayList<XWikiLink>(this.doc.getUniqueWikiLinkedPages(getXWikiContext()));\n    }\n\n    /**\n     * Get the top sections contained in the document.\n     * <p>\n     * The section are filtered by xwiki.section.depth property on the maximum depth of the sections to return. This\n     * method is usually used to get \"editable\" sections.\n     *\n     * @return the sections in the current document\n     */\n    public List<DocumentSection> getSections() throws XWikiException\n    {\n        return this.doc.getSections();\n    }\n\n    /**\n     * Get document children. Children are documents with the current document as parent.\n     *\n     * @return The list of children for the current document.\n     * @since 1.8 Milestone 2\n     */\n    public List<String> getChildren() throws XWikiException\n    {\n        return this.doc.getChildren(getXWikiContext());\n    }\n\n    /**\n     * Get document children references. Children are documents with the current document as parent.\n     * @return The list of children for the current document.\n     * @throws XWikiException in case of problem to query the children.\n     * @since 12.5RC1\n     */\n    public List<DocumentReference> getChildrenReferences() throws XWikiException\n    {\n        return this.doc.getChildrenReferences(getXWikiContext());\n    }\n\n    /**\n     * Get document children. Children are documents with the current document as parent. Where a document has a large\n     * number of children, one may desire to return a certain number of children (nb) and skip some number (start) of\n     * the first results.\n     *\n     * @param nb The number of results to return.\n     * @param start The number of results to skip before we begin returning results.\n     * @return The list of children for the current document.\n     */\n    public List<String> getChildren(int nb, int start) throws XWikiException\n    {\n        return this.doc.getChildren(nb, start, getXWikiContext());\n    }\n\n    /**\n     * Gets the default edit mode for this document. An edit mode (other than the default \"edit\") can be enforced by\n     * creating an {@code XWiki.EditModeClass} object in the current document, with the appropriate value for the\n     * defaultEditMode property, or by adding this object in a sheet included by the document. This function also falls\n     * back on the old {@code SheetClass}, deprecated since 3.1M2, which can be attached to included documents to\n     * specify that the current document should be edited inline.\n     *\n     * @return the default edit mode for this document (\"edit\" or \"inline\" usually)\n     * @throws XWikiException since XWiki 6.3M1 it's not used anymore and \"edit\" is returned in case of error, with an\n     *             error log\n     */\n    public String getDefaultEditMode() throws XWikiException\n    {\n        return this.doc.getDefaultEditMode(getXWikiContext());\n    }\n\n    public String getDefaultEditURL() throws XWikiException\n    {\n        return this.doc.getDefaultEditURL(getXWikiContext());\n    }\n\n    public String getEditURL(String action, String mode) throws XWikiException\n    {\n        return this.doc.getEditURL(action, mode, getXWikiContext());\n    }\n\n    public String getEditURL(String action, String mode, String locale)\n    {\n        return this.doc.getEditURL(action, mode, locale, getXWikiContext());\n    }\n\n    public boolean isCurrentUserCreator()\n    {\n        return this.doc.isCurrentUserCreator(getXWikiContext());\n    }\n\n    public boolean isCurrentUserPage()\n    {\n        return this.doc.isCurrentUserPage(getXWikiContext());\n    }\n\n    public boolean isCurrentLocalUserPage()\n    {\n        return this.doc.isCurrentLocalUserPage(getXWikiContext());\n    }\n\n    public boolean isCreator(String username)\n    {\n        return this.doc.isCreator(username);\n    }\n\n    public void set(String fieldname, java.lang.Object value)\n    {\n        Object obj;\n        if (this.currentObj != null) {\n            obj = this.currentObj;\n        } else {\n            obj = getFirstObject(fieldname);\n        }\n        set(fieldname, value, obj);\n    }\n\n    public void set(String fieldname, java.lang.Object value, Object obj)\n    {\n        if (obj == null) {\n            return;\n        }\n        obj.set(fieldname, value);\n    }\n\n    public void setTitle(String title)\n    {\n        getDoc().setTitle(title);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    public void setCustomClass(String customClass)\n    {\n        getDoc().setCustomClass(customClass);\n\n        updateAuthor();\n    }\n\n    public void setParent(String parent)\n    {\n        getDoc().setParent(parent);\n\n        updateAuthor();\n    }\n\n    private void updateContentAuthor()\n    {\n        // Temporary set as content author of the document the current script author (until the document is saved)\n        XWikiContext xcontext = getXWikiContext();\n        getDoc().setContentAuthorReference(xcontext.getAuthorReference());\n    }\n\n    private void updateAuthor()\n    {\n        // Temporary set as author of the document the current script author (until the document is saved)\n        XWikiContext xcontext = getXWikiContext();\n        getDoc().setAuthorReference(xcontext.getAuthorReference());\n    }\n\n    public void setContent(String content)\n    {\n        getDoc().setContent(content);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    /**\n     * @param content the content as XDOM\n     * @throws XWikiException when failing to convert the XDOM to String content\n     * @since 7.0RC1\n     */\n    public void setContent(XDOM content) throws XWikiException\n    {\n        getDoc().setContent(content);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    /**\n     * @param syntax the Syntax representing the syntax used for the current document's content.\n     * @since 2.3M1\n     */\n    public void setSyntax(Syntax syntax)\n    {\n        getDoc().setSyntax(syntax);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    /**\n     * @param syntaxId the Syntax id representing the syntax used for the current document. For example \"xwiki/1.0\"\n     *            represents the first version XWiki syntax while \"xwiki/2.0\" represents version 2.0 of the XWiki\n     *            Syntax.\n     */\n    public void setSyntaxId(String syntaxId)\n    {\n        getDoc().setSyntaxId(syntaxId);\n\n        updateAuthor();\n        updateContentAuthor();\n    }\n\n    public void setDefaultTemplate(String dtemplate)\n    {\n        getDoc().setDefaultTemplate(dtemplate);\n\n        updateAuthor();\n    }\n\n    public void setComment(String comment)\n    {\n        getDoc().setComment(comment);\n    }\n\n    public void setMinorEdit(boolean isMinor)\n    {\n        getDoc().setMinorEdit(isMinor);\n    }\n\n    public void save() throws XWikiException\n    {\n        save(\"\", false);\n    }\n\n    public void save(String comment) throws XWikiException\n    {\n        save(comment, false);\n    }\n\n    private UserReferenceResolver<CurrentUserReference> getCurrentUserReferenceResolver()\n    {\n        return Utils.getComponent(new DefaultParameterizedType(null, UserReferenceResolver.class,\n                CurrentUserReference.class));\n    }\n\n    public void save(String comment, boolean minorEdit) throws XWikiException\n    {\n        if (hasAccessLevel(\"edit\")) {\n\n            DocumentAuthors authors = getDoc().getAuthors();\n            authors.setOriginalMetadataAuthor(getCurrentUserReferenceResolver().resolve(CurrentUserReference.INSTANCE));\n            // If the current author does not have PR don't let it set current user as author of the saved document\n            // since it can lead to right escalation\n            if (hasProgrammingRights() || !getConfiguration().getProperty(\"security.script.save.checkAuthor\", true)) {\n                saveDocument(comment, minorEdit);\n            } else {\n                saveAsAuthor(comment, minorEdit);\n            }\n        } else {\n            java.lang.Object[] args = {getDefaultEntityReferenceSerializer().serialize(getDocumentReference())};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied in edit mode on document {0}\", null, args);\n        }\n    }\n\n    public void saveWithProgrammingRights() throws XWikiException\n    {\n        saveWithProgrammingRights(\"\", false);\n    }\n\n    public void saveWithProgrammingRights(String comment) throws XWikiException\n    {\n        saveWithProgrammingRights(comment, false);\n    }\n\n    public void saveWithProgrammingRights(String comment, boolean minorEdit) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            // The rights check above is generic, but the current method is a save operation, thus it should not be\n            // performed if the document's wiki is in read only mode.\n            XWikiContext context = getXWikiContext();\n            String currentWikiId = context.getWikiId();\n            try {\n                // Make sure we check the current document's wiki and not the current context's wiki.\n                context.setWikiId(getWiki());\n\n                if (!context.getWiki().isReadOnly()) {\n                    saveDocument(comment, minorEdit, false);\n                } else {\n                    java.lang.Object[] args =\n                        { getDefaultEntityReferenceSerializer().serialize(getDocumentReference()), getWiki() };\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        \"Access denied in edit mode on document [{0}]. The wiki [{1}] is in read only mode.\", null,\n                        args);\n                }\n            } finally {\n                // Restore the context wiki.\n                context.setWikiId(currentWikiId);\n            }\n        } else {\n            java.lang.Object[] args = { this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied with no programming rights document {0}\", null, args);\n        }\n    }\n\n    /**\n     * Save the document if the current author of the script calling this method has permission to do so. The author of\n     * this document is also set to the said author.\n     *\n     * @throws XWikiException if script author is not allowed to save the document or if save operation fails.\n     * @since 2.3M2\n     */\n    public void saveAsAuthor() throws XWikiException\n    {\n        saveAsAuthor(\"\", false);\n    }\n\n    /**\n     * Save the document if the current author of the script calling this method has permission to do so. The author of\n     * this document is also set to the said author.\n     *\n     * @param comment The comment to display in document history (what did you change in the document)\n     * @throws XWikiException if script author is not allowed to save the document or if save operation fails.\n     * @since 2.3M2\n     */\n    public void saveAsAuthor(String comment) throws XWikiException\n    {\n        saveAsAuthor(comment, false);\n    }\n\n    /**\n     * Save the document if the current author of the script calling this method has permission to do so. The author of\n     * this document is also set to the said author.\n     *\n     * @param comment The comment to display in document history (what did you change in the document)\n     * @param minorEdit Set true to advance the document version number by 0.1 or false to advance version to the next\n     *            integer + 0.1 eg: 25.1\n     * @throws XWikiException if script author is not allowed to save the document or if save operation fails.\n     * @since 2.3M2\n     */\n    public void saveAsAuthor(String comment, boolean minorEdit) throws XWikiException\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        getDoc().getAuthors()\n            .setOriginalMetadataAuthor(getCurrentUserReferenceResolver().resolve(CurrentUserReference.INSTANCE));\n        DocumentReference author = getEffectiveAuthorReference();\n        if (hasAccess(Right.EDIT, author)) {\n            DocumentReference currentUser = xcontext.getUserReference();\n            try {\n                xcontext.setUserReference(author);\n\n                saveDocument(comment, minorEdit);\n            } finally {\n                xcontext.setUserReference(currentUser);\n            }\n        } else {\n            java.lang.Object[] args = { author, xcontext.getDoc(), getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied; user {0}, acting through script in document {1} cannot save document {2}\", null, args);\n        }\n    }\n\n    protected void saveDocument(String comment, boolean minorEdit) throws XWikiException\n    {\n        saveDocument(comment, minorEdit, true);\n    }\n\n    private void saveDocument(String comment, boolean minorEdit, boolean checkSaving) throws XWikiException\n    {\n        XWikiDocument doc = getDoc();\n\n        UserReference currentUserReference = getCurrentUserReferenceResolver().resolve(CurrentUserReference.INSTANCE);\n        doc.getAuthors().setEffectiveMetadataAuthor(currentUserReference);\n\n        if (doc.isNew()) {\n            doc.getAuthors().setCreator(currentUserReference);\n        }\n\n        if (checkSaving) {\n            // Make sure the user is allowed to make this modification\n            getXWikiContext().getWiki().checkSavingDocument(doc.getAuthorReference(), doc, comment, minorEdit,\n                getXWikiContext());\n        }\n\n        getXWikiContext().getWiki().saveDocument(doc, comment, minorEdit, getXWikiContext());\n        this.initialDoc = this.doc;\n    }\n\n    public com.xpn.xwiki.api.Object addObjectFromRequest() throws XWikiException\n    {\n        // Call to getDoc() ensures that we are working on a clone()\n        com.xpn.xwiki.api.Object obj =\n            new com.xpn.xwiki.api.Object(getDoc().addXObjectFromRequest(getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public com.xpn.xwiki.api.Object addObjectFromRequest(String className) throws XWikiException\n    {\n        com.xpn.xwiki.api.Object obj = new com.xpn.xwiki.api.Object(\n            getDoc().addObjectFromRequest(className, getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public List<Object> addObjectsFromRequest(String className) throws XWikiException\n    {\n        return addObjectsFromRequest(className, \"\");\n    }\n\n    public com.xpn.xwiki.api.Object addObjectFromRequest(String className, String prefix) throws XWikiException\n    {\n        com.xpn.xwiki.api.Object obj = new com.xpn.xwiki.api.Object(\n            getDoc().addObjectFromRequest(className, prefix, getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public List<Object> addObjectsFromRequest(String className, String prefix) throws XWikiException\n    {\n        List<BaseObject> objs = getDoc().addObjectsFromRequest(className, prefix, getXWikiContext());\n        List<Object> wrapped = new ArrayList<Object>();\n        for (BaseObject object : objs) {\n            wrapped.add(new com.xpn.xwiki.api.Object(object, getXWikiContext()));\n        }\n\n        updateAuthor();\n\n        return wrapped;\n    }\n\n    public com.xpn.xwiki.api.Object updateObjectFromRequest(String className) throws XWikiException\n    {\n        com.xpn.xwiki.api.Object obj = new com.xpn.xwiki.api.Object(\n            getDoc().updateObjectFromRequest(className, getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public List<Object> updateObjectsFromRequest(String className) throws XWikiException\n    {\n        return updateObjectsFromRequest(className, \"\");\n    }\n\n    public com.xpn.xwiki.api.Object updateObjectFromRequest(String className, String prefix) throws XWikiException\n    {\n        com.xpn.xwiki.api.Object obj = new com.xpn.xwiki.api.Object(\n            getDoc().updateObjectFromRequest(className, prefix, getXWikiContext()), getXWikiContext());\n\n        updateAuthor();\n\n        return obj;\n    }\n\n    public List<Object> updateObjectsFromRequest(String className, String prefix) throws XWikiException\n    {\n        List<BaseObject> objs = getDoc().updateObjectsFromRequest(className, prefix, getXWikiContext());\n        List<Object> wrapped = new ArrayList<Object>();\n        for (BaseObject object : objs) {\n            wrapped.add(new com.xpn.xwiki.api.Object(object, getXWikiContext()));\n        }\n\n        updateAuthor();\n\n        return wrapped;\n    }\n\n    public boolean isAdvancedContent()\n    {\n        return this.doc.isAdvancedContent();\n    }\n\n    public boolean isProgrammaticContent()\n    {\n        return this.doc.isProgrammaticContent();\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     */\n    public boolean removeObject(Object object)\n    {\n        return getDoc().removeObject(object.getBaseObject());\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param className The class name of the objects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     */\n    public boolean removeObjects(String className)\n    {\n        return getDoc().removeObjects(className);\n    }\n\n    /**\n     * Remove document from the wiki. Reinit <code>cloned</code>.\n     *\n     * @throws XWikiException\n     */\n    protected void deleteDocument() throws XWikiException\n    {\n        getXWikiContext().getWiki().deleteDocument(this.doc, getXWikiContext());\n        this.initialDoc = this.doc;\n    }\n\n    public void delete() throws XWikiException\n    {\n        if (hasAccessLevel(\"delete\")) {\n            deleteDocument();\n        } else {\n            java.lang.Object[] args = { this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied in edit mode on document {0}\", null, args);\n        }\n    }\n\n    /**\n     * Delete the document if the {@link #getContentAuthor content author} of the script calling this method has\n     * permission to do so. The deleter is also set to the said content author.\n     *\n     * @throws XWikiException if script author is not allowed to delete the document or if save operation fails.\n     * @since 2.3M2\n     */\n    public void deleteAsAuthor() throws XWikiException\n    {\n        XWikiContext xcontext = getXWikiContext();\n\n        DocumentReference author = getEffectiveAuthorReference();\n        if (hasAccess(Right.DELETE, author)) {\n            DocumentReference currentUser = xcontext.getUserReference();\n            try {\n                xcontext.setUserReference(author);\n\n                deleteDocument();\n            } finally {\n                xcontext.setUserReference(currentUser);\n            }\n        } else {\n            java.lang.Object[] args = { author, xcontext.getDoc(), this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied; user {0}, acting through script in document {1} cannot delete document {2}\", null,\n                args);\n        }\n    }\n\n    public void deleteWithProgrammingRights() throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            deleteDocument();\n        } else {\n            java.lang.Object[] args = { this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied with no programming rights document {0}\", null, args);\n        }\n    }\n\n    public String getVersionHashCode()\n    {\n        return this.doc.getVersionHashCode(getXWikiContext());\n    }\n\n    public int addAttachments() throws XWikiException\n    {\n        return addAttachments(null);\n    }\n\n    public int addAttachments(String fieldName) throws XWikiException\n    {\n        if (!hasAccessLevel(\"edit\")) {\n            java.lang.Object[] args = { this.getFullName() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied in edit mode on document {0}\", null, args);\n        }\n        XWiki xwiki = getXWikiContext().getWiki();\n        FileUploadPlugin fileupload = (FileUploadPlugin) xwiki.getPlugin(\"fileupload\", getXWikiContext());\n        List<FileItem> fileuploadlist = fileupload.getFileItems(getXWikiContext());\n        List<XWikiAttachment> attachments = new ArrayList<XWikiAttachment>();\n        // adding attachment list to context so we find the names\n        this.context.put(\"addedAttachments\", attachments);\n        int nb = 0;\n\n        if (fileuploadlist == null) {\n            return 0;\n        }\n\n        for (FileItem item : fileuploadlist) {\n            String name = item.getFieldName();\n            if (fieldName != null && !fieldName.equals(name)) {\n                continue;\n            }\n            if (item.isFormField()) {\n                continue;\n            }\n            byte[] data = fileupload.getFileItemData(name, getXWikiContext());\n            String filename;\n            String fname = fileupload.getFileName(name, getXWikiContext());\n            int i = fname.lastIndexOf(\"\\\\\");\n            if (i == -1) {\n                i = fname.lastIndexOf(\"/\");\n            }\n            filename = fname.substring(i + 1);\n            filename = filename.replaceAll(\"\\\\+\", \" \");\n\n            if ((data != null) && (data.length > 0)) {\n                XWikiAttachment attachment = this.getDoc().addAttachment(filename, data, getXWikiContext());\n                getDoc().saveAttachmentContent(attachment, getXWikiContext());\n                // commenting because this was already done by addAttachment\n                // getDoc().getAttachmentList().add(attachment);\n                attachments.add(attachment);\n                nb++;\n            }\n        }\n\n        if (nb > 0) {\n            getXWikiContext().getWiki().saveDocument(getDoc(), getXWikiContext());\n            this.initialDoc = this.doc;\n        }\n\n        return nb;\n    }\n\n    public Attachment addAttachment(String fileName, InputStream iStream)\n    {\n        try {\n            return new Attachment(this, this.getDoc().setAttachment(fileName, iStream, getXWikiContext()),\n                getXWikiContext());\n        } catch (IOException e) {\n            // TODO Log the error and let the user know about it\n        } finally {\n            updateAuthor();\n        }\n\n        return null;\n    }\n\n    public Attachment addAttachment(String fileName, byte[] data)\n    {\n        try {\n            return new Attachment(this, this.getDoc().addAttachment(fileName, data, getXWikiContext()),\n                getXWikiContext());\n        } catch (XWikiException e) {\n            // TODO Log the error and let the user know about it\n        } finally {\n            updateAuthor();\n        }\n\n        return null;\n    }\n\n    public boolean validate() throws XWikiException\n    {\n        return this.doc.validate(getXWikiContext());\n    }\n\n    public boolean validate(String[] classNames) throws XWikiException\n    {\n        return this.doc.validate(classNames, getXWikiContext());\n    }\n\n    /**\n     * Retrieves the validation script associated with this document, a Velocity script that is executed when validating\n     * the document data.\n     *\n     * @return A <code>String</code> representation of the validation script, or an empty string if there is no such\n     *         script.\n     */\n    public String getValidationScript()\n    {\n        return getDoc().getValidationScript();\n    }\n\n    /**\n     * Sets a new validation script for this document, a Velocity script that is executed when validating the document\n     * data.\n     *\n     * @param validationScript The new validation script, which can be an empty string or <code>null</code> if the\n     *            script should be removed.\n     */\n    public void setValidationScript(String validationScript)\n    {\n        getDoc().setValidationScript(validationScript);\n\n        updateAuthor();\n    }\n\n    /**\n     * Rename the current document and all the backlinks leading to it. Will also change parent field in all documents\n     * which list the document we are renaming as their parent. See\n     * {@link #rename(String, java.util.List, java.util.List)} for more details.\n     *\n     * @param newReference the reference to the new document\n     * @throws XWikiException in case of an error\n     * @since 2.3M2\n     */\n    public void rename(DocumentReference newReference) throws XWikiException\n    {\n        if (hasAccessLevel(\"delete\") && this.context.getWiki().checkAccess(\"edit\",\n            this.context.getWiki().getDocument(newReference, this.context), this.context)) {\n            this.getDoc().rename(newReference, getXWikiContext());\n        }\n    }\n\n    /**\n     * Rename the current document and all the links pointing to it in the list of passed backlink documents. The\n     * renaming algorithm takes into account the fact that there are several ways to write a link to a given page and\n     * all those forms need to be renamed. For example the following links all point to the same page:\n     * <ul>\n     * <li>[Page]</li>\n     * <li>[Page?param=1]</li>\n     * <li>[currentwiki:Page]</li>\n     * <li>[currentwiki:CurrentSpace.Page]</li>\n     * </ul>\n     * <p>\n     * Note: links without a space are renamed with the space added and all documents which have the document being\n     * renamed as parent have their parent field set to \"currentwiki:CurrentSpace.Page\".\n     * </p>\n     *\n     * @param newDocumentName the new document name. If the space is not specified then defaults to the current space.\n     * @param backlinkDocumentNames the list of documents to parse and for which links will be modified to point to the\n     *            new renamed document.\n     * @throws XWikiException in case of an error\n     */\n    public void rename(String newDocumentName, List<String> backlinkDocumentNames) throws XWikiException\n    {\n        rename(newDocumentName, backlinkDocumentNames, Collections.emptyList());\n    }\n\n    /**\n     * Same as {@link #rename(String, List)} but the list of documents having the current document as their parent is\n     * passed in parameter.\n     *\n     * @param newDocumentName the new document name. If the space is not specified then defaults to the current space.\n     * @param backlinkDocumentNames the list of documents to parse and for which links will be modified to point to the\n     *            new renamed document.\n     * @param childDocumentNames the list of documents whose parent field will be set to the new document name.\n     * @throws XWikiException in case of an error\n     */\n    public void rename(String newDocumentName, List<String> backlinkDocumentNames, List<String> childDocumentNames)\n        throws XWikiException\n    {\n        List<DocumentReference> backlinkDocumentReferences = new ArrayList<DocumentReference>();\n        for (String backlinkDocumentName : backlinkDocumentNames) {\n            backlinkDocumentReferences.add(getCurrentMixedDocumentReferenceResolver().resolve(backlinkDocumentName));\n        }\n\n        List<DocumentReference> childDocumentReferences = new ArrayList<DocumentReference>();\n        for (String childDocumentName : childDocumentNames) {\n            childDocumentReferences.add(getCurrentMixedDocumentReferenceResolver().resolve(childDocumentName));\n        }\n\n        rename(getCurrentMixedDocumentReferenceResolver().resolve(newDocumentName), backlinkDocumentReferences,\n            childDocumentReferences);\n    }\n\n    /**\n     * Same as {@link #rename(String, List)} but the list of documents having the current document as their parent is\n     * passed in parameter.\n     *\n     * @param newReference the reference to the new document\n     * @param backlinkDocumentNames the list of reference to documents to parse and for which links will be modified to\n     *            point to the new renamed document\n     * @param childDocumentNames the list of references to documents whose parent field will be set to the new document\n     *            reference\n     * @throws XWikiException in case of an error\n     * @since 2.3M2\n     */\n    public void rename(DocumentReference newReference, List<DocumentReference> backlinkDocumentNames,\n        List<DocumentReference> childDocumentNames) throws XWikiException\n    {\n        if (hasAccessLevel(\"delete\") && this.context.getWiki().checkAccess(\"edit\",\n            this.context.getWiki().getDocument(newReference, this.context), this.context)) {\n\n            // Every page given in childDocumentNames has it's parent changed whether it needs it or not.\n            // Let's make sure the user has edit permission on any page given which is not actually a child.\n            // Otherwise it would be embarrassing if a user called:\n            // $doc.rename(\"mynewpage\",$doc.getBacklinks(),$xwiki.searchDocuments(\"true\"))\n            int counter = childDocumentNames.size();\n            List<String> actuallyChildren = getChildren();\n            while (counter > 0) {\n                counter--;\n                if (!actuallyChildren.contains(childDocumentNames.get(counter))\n                    && !this.context.getWiki().checkAccess(\"edit\",\n                        this.context.getWiki().getDocument(childDocumentNames.get(counter), this.context),\n                        this.context)) {\n                    return;\n                }\n            }\n\n            this.getDoc().rename(newReference, backlinkDocumentNames, childDocumentNames, getXWikiContext());\n        }\n    }\n\n    /**\n     * Allow to easily access any revision of a document\n     *\n     * @param revision the version to access\n     * @return the document corresponding to the requested revision or {@code null} if the revision does not exist.\n     */\n    public Document getDocumentRevision(String revision)\n    {\n        try {\n            XWikiDocument documentRevision = getDocumentRevisionProvider().getRevision(this.doc, revision);\n\n            return documentRevision != null ? new Document(documentRevision, this.context) : null;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to load revision [{}] of document [{}]\", revision, getDocumentReferenceWithLocale(),\n                e);\n\n            return null;\n        }\n    }\n\n    /**\n     * Allow to easily access the previous revision of a document\n     *\n     * @return Document\n     * @throws XWikiException\n     */\n    public Document getPreviousDocument() throws XWikiException\n    {\n        return getDocumentRevision(getPreviousVersion());\n    }\n\n    /**\n     * @return is document most recent. false if and only if there are older versions of this document.\n     */\n    public boolean isMostRecent()\n    {\n        return this.doc.isMostRecent();\n    }\n\n    /**\n     * @return if rendering transformations shall be executed in restricted mode and the title not be executed\n     * @since 14.10.7\n     * @since 15.2RC1\n     */\n    @Unstable\n    public boolean isRestricted()\n    {\n        return this.doc.isRestricted();\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.doc.toString();\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntaxId the syntax to convert to (eg \"xwiki/2.0\", \"xhtml/1.0\", etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public boolean convertSyntax(String targetSyntaxId) throws XWikiException\n    {\n        try {\n            getDoc().convertSyntax(targetSyntaxId, this.context);\n        } catch (Exception ex) {\n            LOGGER.error(\n                \"Failed to convert document [\" + getPrefixedFullName() + \"] to syntax [\" + targetSyntaxId + \"]\", ex);\n\n            return false;\n        } finally {\n            updateAuthor();\n            updateContentAuthor();\n        }\n\n        return true;\n    }\n\n    /**\n     * Indicates whether the document is 'hidden' or not, meaning that it should not be returned in public search\n     * results or appear in the User Interface in general.\n     *\n     * @return <code>true</code> if the document is hidden, <code>false</code> otherwise.\n     */\n    public boolean isHidden()\n    {\n        return this.doc.isHidden();\n    }\n\n    /**\n     * Indicates whether the document should be 'hidden' or not, meaning that it should not be returned in public search\n     * results or appear in the User Interface in general.\n     *\n     * @param hidden <code>true</code> if the document should be 'hidden', <code>false</code> otherwise.\n     */\n    public void setHidden(boolean hidden)\n    {\n        this.doc.setHidden(hidden);\n    }\n\n    /**\n     * Drop permissions for the remainder of the rendering cycle. After this is called:\n     * <ul>\n     * <li>1. {@link com.xpn.xwiki.api.Api#hasProgrammingRights()} will always return false.</li>\n     * <li>2. {@link com.xpn.xwiki.api.XWiki#getDocumentAsAuthor(org.xwiki.model.reference.DocumentReference)},\n     * {@link com.xpn.xwiki.api.XWiki#getDocumentAsAuthor(String)}, {@link com.xpn.xwiki.api.Document#saveAsAuthor()},\n     * {@link com.xpn.xwiki.api.Document#saveAsAuthor(String)},\n     * {@link com.xpn.xwiki.api.Document#saveAsAuthor(String, boolean)}, and\n     * {@link com.xpn.xwiki.api.Document#deleteAsAuthor()} will perform all of their actions as if the document's\n     * content author was the guest user (XWiki.XWikiGuest).</li>\n     * </ul>\n     * <p>\n     * This sandboxing will expire at the end of the rendering cycle and can be suspended by beginning a new rendering\n     * cycle. A rendering cycle can be begin by calling {@link #getRenderedContent(String)}, {@link #display(String)}\n     * (or variations thereof) or by invoking the include macro or using\n     * {@link com.xpn.xwiki.api.XWiki#includeTopic(String)}\n     * <p>\n     * NOTE: Even if you include the same document, permissions will be regained. What this does is sandbox the\n     * remainder of the code on the page because although it can temporarily suspend the permissions drop, it cannot get\n     * itself to be executed with permissions because if it calls itself, it will hit the drop function first.\n     * <p>\n     * If you are interested in a more secure sandboxing method where code is guaranteed not to have permissions for the\n     * remainder of the request, you should consider {@link com.xpn.xwiki.api.Context#dropPermissions()}.\n     * <p>\n     *\n     * @since 3.2M2\n     */\n    public void dropPermissions()\n    {\n        // Set the droppedPermissions key to the context so if the context is cloned and\n        // pushed, it will return false until it is popped again.\n        final ExecutionContext context = Utils.getComponent(Execution.class).getContext();\n        context.setProperty(XWikiConstant.DROPPED_PERMISSIONS, System.identityHashCode(context));\n    }\n\n    /**\n     * @return true if this document is a translation of the main document (i.e. returned by\n     *         {@link #getTranslatedDocument(String)}); false if this is actually the main document (i.e. returned by\n     *         {@link com.xpn.xwiki.api.XWiki#getDocument(DocumentReference)}.\n     * @since 6.2M2\n     */\n    public boolean isTranslation()\n    {\n        return 1 == this.getDoc().getTranslation();\n    }\n\n    /**\n     * @return the maximum authorized length for a document full name (see {@link #getFullName()}).\n     * @since 11.4RC1\n     */\n    public int getLocalReferenceMaxLength()\n    {\n        return this.doc.getLocalReferenceMaxLength();\n    }\n\n    /**\n     * @return the authors of the document.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public DocumentAuthors getAuthors()\n    {\n        if (this.hasAccess(Right.PROGRAM)) {\n            // We're using getDoc here to ensure to have a cloned doc\n            return getDoc().getAuthors();\n        } else {\n            // in this case we don't care if the doc is cloned or not since it's readonly\n            return new SafeDocumentAuthors(this.doc.getAuthors());\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.lang.ref.SoftReference;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.inject.Provider;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.ObjectUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.dom.DOMDocument;\nimport org.dom4j.io.DocumentResult;\nimport org.dom4j.io.OutputFormat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.diff.Diff;\nimport org.suigeneris.jrcs.diff.DifferentiationFailedException;\nimport org.suigeneris.jrcs.diff.Revision;\nimport org.suigeneris.jrcs.diff.delta.Delta;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.suigeneris.jrcs.util.ToString;\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContextException;\nimport org.xwiki.context.ExecutionContextManager;\nimport org.xwiki.display.internal.DocumentDisplayer;\nimport org.xwiki.display.internal.DocumentDisplayerParameters;\nimport org.xwiki.filter.input.DefaultInputStreamInputSource;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.filter.input.StringInputSource;\nimport org.xwiki.filter.instance.input.DocumentInstanceInputProperties;\nimport org.xwiki.filter.instance.output.DocumentInstanceOutputProperties;\nimport org.xwiki.filter.output.DefaultOutputStreamOutputTarget;\nimport org.xwiki.filter.output.DefaultWriterOutputTarget;\nimport org.xwiki.filter.output.OutputTarget;\nimport org.xwiki.filter.xar.input.XARInputProperties;\nimport org.xwiki.filter.xar.output.XAROutputProperties;\nimport org.xwiki.filter.xml.output.DefaultResultOutputTarget;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.link.LinkException;\nimport org.xwiki.link.LinkStore;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.internal.document.DefaultDocumentAuthors;\nimport org.xwiki.model.internal.reference.DefaultSymbolScheme;\nimport org.xwiki.model.internal.reference.EntityReferenceFactory;\nimport org.xwiki.model.internal.reference.LocalStringEntityReferenceSerializer;\nimport org.xwiki.model.internal.reference.LocalUidStringEntityReferenceSerializer;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectPropertyReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.ObjectReferenceResolver;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.HeaderBlock;\nimport org.xwiki.rendering.block.MacroBlock;\nimport org.xwiki.rendering.block.SectionBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.ClassBlockMatcher;\nimport org.xwiki.rendering.block.match.MacroBlockMatcher;\nimport org.xwiki.rendering.internal.parser.LinkParser;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.parser.ContentParser;\nimport org.xwiki.rendering.parser.MissingParserException;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.parser.Parser;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.renderer.printer.DefaultWikiPrinter;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxRegistry;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.rendering.util.ErrorBlockGenerator;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.store.TemporaryAttachmentSessionsManager;\nimport org.xwiki.store.merge.MergeDocumentResult;\nimport org.xwiki.store.merge.MergeManager;\nimport org.xwiki.user.GuestUserReference;\nimport org.xwiki.user.UserConfiguration;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.user.UserReferenceSerializer;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.xar.internal.model.XarDocumentModel;\nimport org.xwiki.xml.XMLUtils;\nimport org.xwiki.xml.html.HTMLUtils;\n\nimport com.xpn.xwiki.CoreConfiguration;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiConstant;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.api.DocumentSection;\nimport com.xpn.xwiki.criteria.impl.RevisionCriteria;\nimport com.xpn.xwiki.doc.merge.MergeConfiguration;\nimport com.xpn.xwiki.doc.merge.MergeResult;\nimport com.xpn.xwiki.doc.rcs.XWikiRCSNodeInfo;\nimport com.xpn.xwiki.internal.cache.rendering.RenderingCache;\nimport com.xpn.xwiki.internal.doc.BaseObjects;\nimport com.xpn.xwiki.internal.doc.XWikiAttachmentList;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilterUtils;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.xml.DOMXMLWriter;\nimport com.xpn.xwiki.internal.xml.XMLWriter;\nimport com.xpn.xwiki.objects.BaseCollection;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseObjectReference;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.LargeStringProperty;\nimport com.xpn.xwiki.objects.ListProperty;\nimport com.xpn.xwiki.objects.ObjectDiff;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.ListClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.classes.StaticListClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateAttachmentStore;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.validation.XWikiValidationInterface;\nimport com.xpn.xwiki.validation.XWikiValidationStatus;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.ObjectAddForm;\nimport com.xpn.xwiki.web.ObjectPolicyType;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiRequest;\n\npublic class XWikiDocument implements DocumentModelBridge, Cloneable\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiDocument.class);\n\n    private static final String TM_FAILEDDOCUMENTPARSE = \"core.document.error.failedParse\";\n\n    private static final String CLOSE_HTML_MACRO = \"{{/html}}\";\n\n    /**\n     * An attachment waiting to be deleted at next document save.\n     *\n     * @version $Id$\n     * @since 5.2M1\n     */\n    public static class XWikiAttachmentToRemove\n    {\n        /**\n         * @see #getAttachment()\n         */\n        private XWikiAttachment attachment;\n\n        /**\n         * @see #isToRecycleBin()\n         */\n        private boolean toRecycleBin;\n\n        /**\n         * @param attachment the attachment to delete\n         * @param toRecycleBin true of the attachment should be moved to the recycle bin\n         */\n        public XWikiAttachmentToRemove(XWikiAttachment attachment, boolean toRecycleBin)\n        {\n            this.attachment = attachment;\n            this.toRecycleBin = toRecycleBin;\n        }\n\n        /**\n         * @return the attachment to delete\n         */\n        public XWikiAttachment getAttachment()\n        {\n            return this.attachment;\n        }\n\n        /**\n         * @return true of the attachment should be moved to the recycle bin\n         */\n        public boolean isToRecycleBin()\n        {\n            return this.toRecycleBin;\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return this.attachment.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (obj instanceof XWikiAttachmentToRemove) {\n                return this.attachment.equals(((XWikiAttachmentToRemove) obj).getAttachment());\n            }\n\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return this.attachment.toString();\n        }\n    }\n\n    /**\n     * Regex Pattern to recognize if there's HTML code in a XWiki page.\n     */\n    private static final Pattern HTML_TAG_PATTERN = Pattern.compile(\n        \"</?+(html|img|a|i|br?|embed|script|form|input|textarea|object|font|li|[dou]l|table|center|hr|p) ?([^>]*+)>\");\n\n    public static final EntityReference COMMENTSCLASS_REFERENCE = new LocalDocumentReference(\"XWiki\", \"XWikiComments\");\n\n    public static final EntityReference SHEETCLASS_REFERENCE = new LocalDocumentReference(\"XWiki\", \"SheetClass\");\n\n    public static final int HAS_ATTACHMENTS = 1;\n\n    public static final int HAS_OBJECTS = 2;\n\n    public static final int HAS_CLASS = 4;\n\n    /**\n     * The name of the key in the XWikiContext which contains the document used to check for programming rights.\n     */\n    public static final String CKEY_SDOC = \"sdoc\";\n\n    /**\n     * Separator string between database name and space name.\n     */\n    public static final String DB_SPACE_SEP = \":\";\n\n    /**\n     * Separator string between space name and page name.\n     */\n    public static final String SPACE_NAME_SEP = \".\";\n\n    private static final LocalStringEntityReferenceSerializer LOCAL_REFERENCE_SERIALIZER =\n        new LocalStringEntityReferenceSerializer(new DefaultSymbolScheme());\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks.\n     */\n    private static DocumentReferenceResolver<String> getCurrentDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<ResourceReference> getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class, ResourceReference.class));\n    }\n\n    private static EntityReferenceResolver<String> getXClassEntityReferenceResolver()\n    {\n        return Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"xclass\");\n    }\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    private static DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private static DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n    }\n\n    /**\n     * Used to resolve parent references in the way they are stored externally (database, xml, etc), ie relative or\n     * absolute.\n     */\n    private static EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        return Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private static ObjectReferenceResolver<EntityReference> getCurrentReferenceObjectReferenceResolver()\n    {\n        return Utils.getComponent(ObjectReferenceResolver.TYPE_REFERENCE, \"current\");\n    }\n\n    /**\n     * Used to convert a syntax defined as String into a Syntax object.\n     */\n    private static SyntaxRegistry getSyntaxRegistry()\n    {\n        return Utils.getComponent(SyntaxRegistry.class);\n    }\n\n    /**\n     * Used to retrieve backlinks from an XDOM.\n     */\n    private static LinkParser getLinkParser() {\n        return Utils.getComponent(LinkParser.class);\n    }\n\n    /**\n     * @return the user module configuration, used for instance to determine where users are stored\n     */\n    private static UserConfiguration getUserConfiguration()\n    {\n        return Utils.getComponent(UserConfiguration.class);\n    }\n\n    private String title;\n\n    /**\n     * Reference to this document's parent.\n     * <p>\n     * Note that we're saving the parent reference as a relative reference instead of an absolute one because We want\n     * the ability (for example) to create a parent reference relative to the current space or wiki so that a copy of\n     * this XWikiDocument object would retain that relativity. This is for example useful when copying a Wiki into\n     * another Wiki so that the copied XWikiDcoument's parent reference points to the new wiki.\n     */\n    private EntityReference parentReference;\n\n    private DocumentReference documentReference;\n\n    private String content;\n\n    private String meta;\n\n    private String format;\n\n    private String customClass;\n\n    private Date contentUpdateDate;\n\n    private Date updateDate;\n\n    private Date creationDate;\n\n    protected Version version;\n\n    private long id = 0;\n\n    private boolean mostRecent = true;\n\n    private boolean isNew = true;\n\n    /**\n     * The reference to the document that is the template for the current document.\n     *\n     * @todo this field is not used yet since it's not currently saved in the database.\n     */\n    private DocumentReference templateDocumentReference;\n\n    private Locale locale;\n\n    private Locale defaultLocale;\n\n    /**\n     * Indicates whether the document is 'hidden', meaning that it should not be returned in public search results.\n     * WARNING: this is a temporary hack until the new data model is designed and implemented. No code should rely on or\n     * use this property, since it will be replaced with a generic metadata.\n     */\n    private boolean hidden = false;\n\n    /**\n     * Comment on the latest modification.\n     */\n    private String comment;\n\n    /**\n     * Wiki syntax supported by this document. This is used to support different syntaxes inside the same wiki. For\n     * example a page can use the MediaWiki 1.0 syntax while another one uses the XWiki 2.1 syntax.\n     */\n    private Syntax syntax;\n\n    /**\n     * Is latest modification a minor edit.\n     */\n    private boolean isMinorEdit = false;\n\n    /**\n     * Used to make sure the MetaData String is regenerated.\n     */\n    private boolean isContentDirty = true;\n\n    /**\n     * Used to make sure the MetaData String is regenerated.\n     */\n    private boolean isMetaDataDirty = true;\n\n    private int elements = HAS_OBJECTS | HAS_ATTACHMENTS;\n\n    // Meta Data\n    private BaseClass xClass;\n\n    private String xClassXML;\n\n    /**\n     * Map holding document objects indexed by XClass references (i.e. Document References since a XClass reference\n     * points to a document). The preserve index ordering (consistent sorted order for output to XML, rendering in\n     * velocity, etc.)\n     */\n    private Map<DocumentReference, BaseObjects> xObjects = new ConcurrentSkipListMap<>();\n\n    /**\n     * The publicly exposed Map.\n     */\n    private Map<DocumentReference, List<BaseObject>> publicXObjects = new Map<DocumentReference, List<BaseObject>>()\n    {\n        @Override\n        public List<BaseObject> put(DocumentReference key, List<BaseObject> value)\n        {\n            // Makes sure to always insert BaseObjects\n            return xObjects.put(key, value instanceof BaseObjects ? (BaseObjects) value : new BaseObjects(value));\n        }\n\n        @Override\n        public void putAll(Map<? extends DocumentReference, ? extends List<BaseObject>> m)\n        {\n            m.forEach(this::put);\n        }\n\n        @Override\n        public int size()\n        {\n            return xObjects.size();\n        }\n\n        @Override\n        public boolean isEmpty()\n        {\n            return xObjects.isEmpty();\n        }\n\n        @Override\n        public boolean containsKey(Object key)\n        {\n            return xObjects.containsKey(key);\n        }\n\n        @Override\n        public boolean containsValue(Object value)\n        {\n            return xObjects.containsValue(value);\n        }\n\n        @Override\n        public List<BaseObject> get(Object key)\n        {\n            return xObjects.get(key);\n        }\n\n        @Override\n        public List<BaseObject> remove(Object key)\n        {\n            return xObjects.remove(key);\n        }\n\n        @Override\n        public void clear()\n        {\n            xObjects.clear();            \n        }\n\n        @Override\n        public Set<DocumentReference> keySet()\n        {\n            return xObjects.keySet();\n        }\n\n        @Override\n        public Collection<List<BaseObject>> values()\n        {\n            return (Collection) xObjects.values();\n        }\n\n        @Override\n        public Set<Entry<DocumentReference, List<BaseObject>>> entrySet()\n        {\n            return (Set) xObjects.entrySet();\n        }\n    };\n\n    private final XWikiAttachmentList attachmentList = new XWikiAttachmentList(XWikiDocument.this);\n\n    // Caching\n    private boolean fromCache = false;\n\n    private List<BaseObject> xObjectsToRemove = new ArrayList<BaseObject>();\n\n    private List<XWikiAttachmentToRemove> attachmentsToRemove = new ArrayList<XWikiAttachmentToRemove>();\n\n    /**\n     * The view template (vm file) to use. When not set the default view template is used.\n     *\n     * @see com.xpn.xwiki.web.ViewAction#render(XWikiContext)\n     */\n    private String defaultTemplate;\n\n    private String validationScript;\n\n    private Object wikiNode;\n\n    /**\n     * We are using a SoftReference which will allow the archive to be discarded by the Garbage collector as long as the\n     * context is closed (usually during the request)\n     */\n    private SoftReference<XWikiDocumentArchive> archive;\n\n    private XWikiStoreInterface store;\n\n    /**\n     * @see #getOriginalDocument()\n     */\n    private XWikiDocument originalDocument;\n\n    /**\n     * If the document should always be rendered in restricted mode.\n     */\n    private boolean restricted;\n\n    /**\n     * Used to display the title and the content of this document. Do not inject the component here to avoid any simple\n     * new XWikiDocument to cause many useless initialization, in particular, during initialization of the stub context\n     * and other fake documents in tests.\n     */\n    private DocumentDisplayer documentDisplayer;\n\n    /**\n     * @see #getDefaultEntityReferenceSerializer()\n     */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * @see #getExplicitDocumentReferenceResolver()\n     */\n    private DocumentReferenceResolver<String> explicitDocumentReferenceResolver;\n\n    /**\n     * @see #getExplicitReferenceDocumentReferenceResolver()\n     */\n    private DocumentReferenceResolver<EntityReference> explicitReferenceDocumentReferenceResolver;\n\n    /**\n     * @see #getPageReferenceResolver()\n     */\n    private PageReferenceResolver<EntityReference> pageReferenceResolver;\n\n    /**\n     * @see #getUidStringEntityReferenceSerializer()\n     */\n    private EntityReferenceSerializer<String> uidStringEntityReferenceSerializer;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private JobProgressManager progress;\n\n    private ContextualLocalizationManager localization;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private EntityReferenceFactory entityReferenceFactory;\n\n    /**\n     * The document structure expressed as a tree of Block objects. We store it for performance reasons since parsing is\n     * a costly operation that we don't want to repeat whenever some code ask for the XDOM information.\n     */\n    private XDOM xdomCache;\n\n    /**\n     * Use to store rendered documents in #getRenderedContent(). Do not inject the component here to avoid any simple\n     * new XWikiDocument to cause many useless initialization, in particular, during initialization of the stub context\n     * and other fake documents in tests.\n     */\n    private RenderingCache renderingCache;\n\n    /**\n     * Cache the parent reference resolved as an absolute reference for improved performance (so that we don't have to\n     * resolve the relative reference every time getParentReference() is called.\n     */\n    private DocumentReference parentReferenceCache;\n\n    /**\n     * Cache the document reference with locale resolved kept for improved performance (so that we don't have to resolve\n     * it every time getPageReference() is called.\n     */\n    private DocumentReference documentReferenceWithLocaleCache;\n\n    /**\n     * Cache the page reference resolved kept for improved performance (so that we don't have to resolve it every time\n     * getPageReference() is called.\n     */\n    private PageReference pageReferenceCache;\n\n    /**\n     * Cache the page reference with locale resolved kept for improved performance (so that we don't have to resolve it\n     * every time getPageReference() is called.\n     */\n    private PageReference pageReferenceWithLocaleCache;\n\n    /**\n     * @see #getKey()\n     */\n    private String keyCache;\n\n    /**\n     * @see #getLocalKey()\n     */\n    private String localKeyCache;\n\n    private RenderingContext renderingContext;\n\n    /**\n     * @see #getAuthors()\n     */\n    private final DefaultDocumentAuthors authors = new DefaultDocumentAuthors(this);\n\n    /**\n     * Create a document for the given reference, with the {@link Locale#ROOT} even if the reference contains a locale.\n     * If you want to create a document for another locale, use {@link #XWikiDocument(DocumentReference, Locale)}.\n     * @since 2.2M1\n     */\n    public XWikiDocument(DocumentReference reference)\n    {\n        init(reference);\n    }\n\n    /**\n     * @since 6.2\n     */\n    public XWikiDocument(DocumentReference reference, Locale locale)\n    {\n        init(reference);\n\n        this.locale = locale;\n    }\n\n    /**\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument()\n    {\n        this(null);\n    }\n\n    /**\n     * Constructor that specifies the local document identifier: space name, document name. {@link #setDatabase(String)}\n     * must be called afterwards to specify the wiki name.\n     *\n     * @param space the space this document belongs to\n     * @param name the name of the document\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument(String space, String name)\n    {\n        this(null, space, name);\n    }\n\n    /**\n     * Constructor that specifies the full document identifier: wiki name, space name, document name.\n     *\n     * @param wiki The wiki this document belongs to.\n     * @param space The space this document belongs to.\n     * @param name The name of the document (can contain either the page name or the space and page name)\n     * @deprecated use {@link #XWikiDocument(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument(String wiki, String space, String name)\n    {\n        // We allow to specify the space in the name (eg name = \"space.page\"). In this case the passed space is\n        // ignored.\n\n        // Build an entity reference that will serve as a current context reference against which to resolve if the\n        // passed name doesn't contain a space.\n        EntityReference contextReference = null;\n        if (!StringUtils.isEmpty(space)) {\n            contextReference = new EntityReference(space, EntityType.SPACE);\n        }\n\n        DocumentReference reference = getCurrentDocumentReferenceResolver().resolve(name, contextReference);\n\n        if (!StringUtils.isEmpty(wiki)) {\n            reference = reference.replaceParent(reference.getWikiReference(), new WikiReference(wiki));\n        }\n\n        init(reference);\n    }\n\n    /**\n     * Used to resolve a string into a proper Document Reference.\n     */\n    private DocumentReferenceResolver<String> getExplicitDocumentReferenceResolver()\n    {\n        if (this.explicitDocumentReferenceResolver == null) {\n            this.explicitDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"explicit\");\n        }\n\n        return this.explicitDocumentReferenceResolver;\n    }\n\n    /**\n     * Used to normalize references.\n     */\n    private DocumentReferenceResolver<EntityReference> getExplicitReferenceDocumentReferenceResolver()\n    {\n        if (this.explicitReferenceDocumentReferenceResolver == null) {\n            this.explicitReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"explicit\");\n        }\n\n        return this.explicitReferenceDocumentReferenceResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getPageReferenceResolver()\n    {\n        if (this.pageReferenceResolver == null) {\n            this.pageReferenceResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE);\n        }\n\n        return this.pageReferenceResolver;\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (standard form).\n     */\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    /**\n     * Used to compute document identifier.\n     */\n    private EntityReferenceSerializer<String> getUidStringEntityReferenceSerializer()\n    {\n        if (this.uidStringEntityReferenceSerializer == null) {\n            this.uidStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"uid\");\n        }\n\n        return this.uidStringEntityReferenceSerializer;\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private EntityReferenceFactory getEntityReferenceFactory()\n    {\n        if (this.entityReferenceFactory == null && Utils.getRootComponentManager() != null) {\n            try {\n                this.entityReferenceFactory = Utils.getRootComponentManager().getInstance(EntityReferenceFactory.class);\n            } catch (ComponentLookupException e) {\n                // Not a big deal\n            }\n        }\n\n        return this.entityReferenceFactory;\n    }\n\n    private <E extends EntityReference> E intern(E reference)\n    {\n        EntityReferenceFactory factory = getEntityReferenceFactory();\n\n        return factory != null ? factory.getReference(reference) : reference;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    private UserReferenceSerializer<DocumentReference> getUserReferenceDocumentReferenceSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_DOCUMENT_REFERENCE, \"document\");\n    }\n\n    private UserReferenceResolver<DocumentReference> getUserReferenceDocumentReferenceResolver()\n    {\n        return Utils.getComponent(UserReferenceResolver.TYPE_DOCUMENT_REFERENCE, \"document\");\n    }\n\n    private UserReferenceSerializer<String> getUserReferenceStringSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_STRING);\n    }\n\n    private UserReferenceResolver<String> getUserReferenceStringResolver()\n    {\n        return Utils.getComponent(UserReferenceResolver.TYPE_STRING);\n    }\n\n    private UserReferenceSerializer<String> getUserReferenceCompactWikiSerializer()\n    {\n        return Utils.getComponent(UserReferenceSerializer.TYPE_STRING, \"compactwiki/document\");\n    }\n\n    private LinkStore getLinkStore()\n    {\n        return Utils.getComponent(LinkStore.class);        \n    }\n\n    public XWikiStoreInterface getStore(XWikiContext context)\n    {\n        return context.getWiki().getStore();\n    }\n\n    /**\n     * @deprecated use {@link XWiki#getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated(since = \"9.9RC1\")\n    public XWikiAttachmentStoreInterface getAttachmentStore(XWikiContext context)\n    {\n        return context.getWiki().getAttachmentStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore(XWikiContext context)\n    {\n        return context.getWiki().getVersioningStore();\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    /**\n     * Helper to produce and cache a local uid serialization of this document reference, including the language. Only\n     * translated document will have language appended.\n     *\n     * @return a unique name (in a wiki) (5:space4:name2:lg)\n     */\n    private String getLocalKey()\n    {\n        if (this.localKeyCache == null) {\n            this.localKeyCache =\n                LocalUidStringEntityReferenceSerializer.INSTANCE.serialize(getDocumentReferenceWithLocale());\n        }\n\n        return this.localKeyCache;\n    }\n\n    /**\n     * Helper to produce and cache a uid serialization of this document reference, including the language. Only\n     * translated document will have language appended.\n     *\n     * @return a unique name (8:wikiname5:space4:name2:lg or 8:wikiname5:space4:name)\n     * @since 4.0M1\n     */\n    public String getKey()\n    {\n        if (this.keyCache == null) {\n            this.keyCache = getUidStringEntityReferenceSerializer().serialize(getDocumentReferenceWithLocale());\n        }\n\n        return this.keyCache;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int) Util.getHash(getLocalKey());\n    }\n\n    /**\n     * @return the unique id used to represent the document, as a number. This id is technical and is equivalent to the\n     *         Document Reference + the language of the Document. This technical id should only be used for the storage\n     *         layer and all user APIs should instead use Document Reference and language as they are model-related\n     *         while the id isn't (it's purely technical).\n     */\n    public long getId()\n    {\n        // TODO: Ensure uniqueness of the generated id\n        // The implementation doesn't guarantee a unique id since it uses a hashing method which never guarantee\n        // uniqueness. However, the hash algorithm is really unlikely to collide in a given wiki. This needs to be\n        // fixed to produce a real unique id since otherwise we can have clashes in the database.\n\n        // Note: We don't use the wiki name in the document id's computation. The main historical reason is so\n        // that all things saved in a given wiki's database are always stored relative to that wiki so that\n        // changing that wiki's name is simpler.\n\n        this.id = Util.getHash(getLocalKey());\n\n        return this.id;\n    }\n\n    /**\n     * @see #getId()\n     */\n    public void setId(long id)\n    {\n        this.id = id;\n    }\n\n    /**\n     * Return the full local space reference. For example a document located in sub-space <code>space11</code> of space\n     * <code>space1</code> will return <code>space1.space11</code>.\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the local reference the space of the document as String\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getSpace()\n    {\n        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference().getLastSpaceReference());\n    }\n\n    /**\n     * Set the full local space reference.\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @see #getSpace()\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setSpace(String spaces)\n    {\n        if (spaces != null) {\n            DocumentReference reference = getDocumentReference();\n            EntityReference spaceReference = getRelativeEntityReferenceResolver().resolve(spaces, EntityType.SPACE);\n            spaceReference = spaceReference.appendParent(getDocumentReference().getWikiReference());\n            setDocumentReferenceInternal(\n                new DocumentReference(reference.getName(), new SpaceReference(spaceReference)));\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the name of the space of the document\n     * @see #getSpace()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated\n    public String getWeb()\n    {\n        return getSpace();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated\n    public void setWeb(String space)\n    {\n        setSpace(space);\n    }\n\n    @Override\n    public String getVersion()\n    {\n        return getRCSVersion().toString();\n    }\n\n    public void setVersion(String version)\n    {\n        if (!StringUtils.isEmpty(version)) {\n            this.version = new Version(version);\n        }\n    }\n\n    public Version getRCSVersion()\n    {\n        if (this.version == null) {\n            return new Version(\"1.1\");\n        }\n        return this.version;\n    }\n\n    public void setRCSVersion(Version version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * @return the copy of this XWikiDocument instance before any modification was made to it. This copy is used for\n     *         finding out differences made to this document (useful for example to send the correct notifications to\n     *         document change listeners).\n     */\n    @Override\n    public XWikiDocument getOriginalDocument()\n    {\n        return this.originalDocument;\n    }\n\n    /**\n     * @param originalDocument the original document representing this document instance before any change was made to\n     *            it, prior to the last time it was saved\n     * @see #getOriginalDocument()\n     */\n    public void setOriginalDocument(XWikiDocument originalDocument)\n    {\n        this.originalDocument = originalDocument;\n    }\n\n    /**\n     * @return the parent reference or null if the parent is not set\n     * @since 2.2M1\n     */\n    public DocumentReference getParentReference()\n    {\n        // Ensure we always return absolute document references for the parent since we always want well-constructed\n        // references and since we store the parent reference as relative internally.\n        if (this.parentReferenceCache == null && getRelativeParentReference() != null) {\n            this.parentReferenceCache = intern(getExplicitReferenceDocumentReferenceResolver()\n                .resolve(getRelativeParentReference(), getDocumentReference()));\n        }\n\n        return this.parentReferenceCache;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @return the parent reference stored in the database, which is relative to this document, or an empty string (\"\")\n     *         if the parent is not set\n     * @see #getParentReference()\n     * @deprecated use {@link #getParentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getParent()\n    {\n        String parentReferenceAsString;\n        if (getParentReference() != null) {\n            parentReferenceAsString = getDefaultEntityReferenceSerializer().serialize(getRelativeParentReference());\n        } else {\n            parentReferenceAsString = \"\";\n        }\n        return parentReferenceAsString;\n    }\n\n    /**\n     * @deprecated use {@link #getParentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument getParentDoc()\n    {\n        return new XWikiDocument(getParentReference());\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setParentReference(EntityReference parentReference)\n    {\n        if (!Objects.equals(getRelativeParentReference(), parentReference)) {\n            this.parentReference = intern(parentReference);\n\n            // Clean the absolute parent reference cache to rebuild it next time getParentReference is called.\n            this.parentReferenceCache = null;\n\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @param parent the reference of the parent relative to the document\n     * @deprecated use {@link #setParentReference(EntityReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setParent(String parent)\n    {\n        // If the passed parent is an empty string we also need to set the reference to null. The reason is that\n        // in the database we store \"\" when the parent is empty and thus when Hibernate loads this class it'll call\n        // setParent with \"\" if the parent had not been set when saved.\n        if (StringUtils.isEmpty(parent)) {\n            setParentReference((EntityReference) null);\n        } else {\n            setParentReference(getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT));\n        }\n    }\n\n    @Override\n    public String getContent()\n    {\n        return this.content;\n    }\n\n    public void setContent(String content)\n    {\n        if (content == null) {\n            content = \"\";\n        }\n\n        boolean notEqual = !content.equals(this.content);\n\n        this.content = content;\n\n        if (notEqual) {\n            // invalidate parsed xdom\n            this.xdomCache = null;\n            setContentDirty(true);\n            setWikiNode(null);\n        }\n    }\n\n    public void setContent(XDOM content) throws XWikiException\n    {\n        setContent(renderXDOM(content, getSyntax()));\n    }\n\n    /**\n     * @return the default rendering cache\n     */\n    private RenderingCache getRenderingCache()\n    {\n        if (this.renderingCache == null) {\n            this.renderingCache = Utils.getComponent((Type) RenderingCache.class);\n        }\n        return this.renderingCache;\n    }\n\n    /**\n     * @return the configured document displayer\n     */\n    private DocumentDisplayer getDocumentDisplayer()\n    {\n        if (this.documentDisplayer == null) {\n            this.documentDisplayer = Utils.getComponent((Type) DocumentDisplayer.class, \"configured\");\n        }\n        return this.documentDisplayer;\n    }\n\n    private Syntax getOutputSyntax()\n    {\n        return getRenderingContext().getTargetSyntax();\n    }\n\n    /**\n     * Parse, execute and render the document.\n     * \n     * @param targetSyntax the syntax to use to render the document\n     * @param executionContextIsolated see {@link DocumentDisplayerParameters#isExecutionContextIsolated()}\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param transformationContextRestricted see\n     *            {@link DocumentDisplayerParameters#isTransformationContextRestricted()}\n     * @param translate get translated content of the document\n     * @return the result of the document execution rendered in the passed syntax\n     * @throws XWikiException when failing to display the document\n     */\n    private String display(Syntax targetSyntax, boolean executionContextIsolated, boolean transformationContextIsolated,\n        boolean transformationContextRestricted, boolean translate) throws XWikiException\n    {\n        // Note: We are currently duplicating code from getRendered signature because some calling\n        // code is expecting that the rendering will happen in the calling document's context and not in this\n        // document's context. For example this is true for the Admin page, see\n        // https://jira.xwiki.org/browse/XWIKI-4274 for more details.\n\n        getProgress().startStep(this, \"document.progress.render\", \"Render document [{}] in syntax [{}]\",\n            getDocumentReference(), targetSyntax);\n\n        try {\n            getProgress().pushLevelProgress(3, getDocumentReference());\n\n            getProgress().startStep(getDocumentReference(), \"document.progress.render.translatedcontent\",\n                \"Get translated content\");\n\n            XWikiContext xcontext = getXWikiContext();\n\n            XWikiDocument tdoc = translate ? getTranslatedDocument(xcontext) : this;\n            String translatedContent = tdoc.getContent();\n\n            getProgress().startStep(getDocumentReference(), \"document.progress.render.cache\",\n                \"Try to get content from the cache\");\n\n            String renderedContent = getRenderingCache().getRenderedContent(tdoc.getDocumentReferenceWithLocale(),\n                translatedContent, xcontext);\n\n            if (renderedContent == null) {\n                getProgress().startStep(getDocumentReference(), \"document.progress.render.execute\", \"Execute content\");\n\n                // Configure display\n                DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();\n                parameters.setExecutionContextIsolated(executionContextIsolated);\n                parameters.setTransformationContextIsolated(transformationContextIsolated);\n                // Don't consider isRestricted() here as this could invoke a sheet.\n                parameters.setTransformationContextRestricted(transformationContextRestricted);\n                // Render the translated content (matching the current language) using this document's syntax.\n                parameters.setContentTranslated(tdoc != this);\n                parameters.setTargetSyntax(targetSyntax);\n\n                // Execute display\n                XDOM contentXDOM = getDocumentDisplayer().display(this, parameters);\n\n                // Render the result\n                renderedContent = renderXDOM(contentXDOM, targetSyntax);\n\n                getRenderingCache().setRenderedContent(getDocumentReference(), translatedContent, renderedContent,\n                    xcontext);\n            }\n\n            return renderedContent;\n        } finally {\n            getProgress().popLevelProgress(getDocumentReference());\n            getProgress().endStep(this);\n        }\n    }\n\n    public String getRenderedContent(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, context);\n    }\n\n    /**\n     * @since 8.4RC1\n     */\n    public String getRenderedContent(boolean transformationContextIsolated, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(getOutputSyntax(), transformationContextIsolated, context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.3RC1\n     */\n    public String displayDocument(XWikiContext context) throws XWikiException\n    {\n        return displayDocument(getOutputSyntax(), context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param context  the XWiki Context object\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.5RC1\n     */\n    public String displayDocument(boolean restricted, XWikiContext context) throws XWikiException\n    {\n        return displayDocument(getOutputSyntax(), restricted, context);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.3RC1\n     */\n    public String displayDocument(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, false, context, false);\n    }\n\n    /**\n     * Execute and render the current document in the current context.\n     * The code is executed with right of this document content author.\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param context  the XWiki Context object\n     * @param restricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     * @since 11.5RC1\n     */\n    public String displayDocument(Syntax targetSyntax, boolean restricted, XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, true, restricted, context, false);\n    }\n\n    /**\n     * Execute and render the document or its translation in the current context.\n     * The code is executed with right of this document (or the translation) content author.\n     * The translations are retrieved if they exist and based on XWiki preferences\n     * (see {@link #getTranslatedDocument(XWikiContext)}).\n     *\n     * @param targetSyntax  the syntax to use to render the document\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param context  the XWiki Context object\n     * @return  the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     */\n    public String getRenderedContent(Syntax targetSyntax, boolean transformationContextIsolated, XWikiContext context)\n        throws XWikiException\n    {\n        return getRenderedContent(targetSyntax, transformationContextIsolated, false, context, true);\n    }\n\n    /**\n     * Execute and render the document or its translation in the current context.\n     * The code is executed with right of this document (or the translation) content author.\n     *\n     * @param targetSyntax the syntax to use to render the document\n     * @param transformationContextIsolated see {@link DocumentDisplayerParameters#isTransformationContextIsolated()}\n     * @param transformationContextRestricted see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki Context object\n     * @param retrieveTranslation if true retrieve the translation of the document according to the preferences (see\n     *  {@link #getTranslatedDocument(XWikiContext)}). If false, render the current document.\n     * @return the rendered content of the document or its translation.\n     * @throws XWikiException in case of error during the rendering.\n     */\n    private String getRenderedContent(Syntax targetSyntax, boolean transformationContextIsolated,\n        boolean transformationContextRestricted, XWikiContext context, boolean retrieveTranslation)\n        throws XWikiException\n    {\n        // Make sure the context secure document is the current document so that it's executed with its own\n        // rights\n        Object currentSdoc = context.get(\"sdoc\");\n        try {\n            XWikiDocument sdoc;\n\n            if (retrieveTranslation) {\n                sdoc = getTranslatedDocument(context);\n            } else {\n                sdoc = this;\n            }\n            context.put(\"sdoc\", sdoc);\n\n            return display(targetSyntax, false, transformationContextIsolated, transformationContextRestricted,\n                retrieveTranslation);\n        } finally {\n            context.put(\"sdoc\", currentSdoc);\n        }\n    }\n\n    public String getRenderedContent(XWikiContext context) throws XWikiException\n    {\n        return getRenderedContent(getOutputSyntax(), context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 1.6M1\n     */\n    public String getRenderedContent(String text, String syntaxId, XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContent(String text, String syntaxId, boolean restrictedTransformationContext,\n        XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), restrictedTransformationContext,\n            context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param syntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param context the XWiki Context object\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 8.3\n     */\n    public String getRenderedContent(String text, String syntaxId, boolean restrictedTransformationContext,\n        XWikiDocument sDocument, XWikiContext context)\n    {\n        return getRenderedContent(text, syntaxId, getOutputSyntax().toIdString(), restrictedTransformationContext,\n            sDocument, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 2.0M3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, targetSyntaxId, false, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 4.2M1\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, targetSyntaxId, restrictedTransformationContext, null, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 8.3\n     */\n    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiDocument sDocument, XWikiContext context)\n    {\n        try {\n            return getRenderedContent(text, Syntax.valueOf(sourceSyntaxId), Syntax.valueOf(targetSyntaxId),\n                restrictedTransformationContext, sDocument, true, context);\n        } catch (ParseException e) {\n            // Failed to render for some reason. This method should normally throw an exception but this\n            // requires changing the signature of calling methods too.\n            LOGGER.warn(\"Failed to render content [{}]\", text, e);\n        }\n\n        return \"\";\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 13.0\n     */\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, XWikiDocument sDocument, boolean isolated,\n        XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), false, sDocument, isolated, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 14.10\n     * @since 14.4.7\n     * @since 13.10.11\n     */\n    @Unstable\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, boolean restrictedTransformationContext,\n        XWikiDocument sDocument, boolean isolated, XWikiContext context)\n    {\n        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), restrictedTransformationContext, sDocument,\n            isolated, context);\n    }\n\n    /**\n     * @param text the text to render\n     * @param sourceSyntaxId the id of the Syntax used by the passed text (e.g. {@code xwiki/2.1})\n     * @param targetSyntaxId the id of the syntax in which to render the document content\n     * @param restrictedTransformationContext see {@link DocumentDisplayerParameters#isTransformationContextRestricted}.\n     * @param sDocument the {@link XWikiDocument} to use as secure document, if null keep the current one\n     * @param isolated true of the content should be executed in this document's context\n     * @param context the XWiki context\n     * @return the given text rendered in the context of this document using the passed Syntax\n     * @since 13.0\n     */\n    public String getRenderedContent(String text, Syntax sourceSyntaxId, Syntax targetSyntaxId,\n        boolean restrictedTransformationContext, XWikiDocument sDocument, boolean isolated, XWikiContext context)\n    {\n        Map<String, Object> backup = null;\n\n        getProgress().startStep(this, \"document.progress.renderText\",\n            \"Execute content [{}] in the context of document [{}]\",\n            StringUtils.substring(text, 0, 100) + (text.length() >= 100 ? \"...\" : \"\"), getDocumentReference());\n\n        XWikiDocument currentSDocument = (XWikiDocument) context.get(CKEY_SDOC);\n        try {\n            // We have to render the given text in the context of this document. Check if this document is already\n            // on the context (same Java object reference). We don't check if the document references are equal\n            // because this document can have temporary changes that are not present on the context document even if\n            // it has the same document reference.\n            if (isolated && context.getDoc() != this) {\n                backup = new HashMap<>();\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute the document with the right of the provided sdocument's author\n            if (sDocument != null) {\n                context.put(CKEY_SDOC, sDocument);\n            }\n\n            // Reuse this document's reference so that the Velocity macro name-space is computed based on it.\n            XWikiDocument fakeDocument = new XWikiDocument(getDocumentReference());\n            fakeDocument.setSyntax(sourceSyntaxId);\n            fakeDocument.setContent(text);\n            fakeDocument.setRestricted(sDocument != null && sDocument.isRestricted());\n\n            // We don't let displayer take care of the context isolation because we don't want the fake document to be\n            // context document\n            return fakeDocument.display(targetSyntaxId, false, isolated, restrictedTransformationContext,\n                false);\n        } catch (Exception e) {\n            // Failed to render for some reason. This method should normally throw an exception but this\n            // requires changing the signature of calling methods too.\n            LOGGER.warn(\"Failed to render content [{}]\", text, e);\n        } finally {\n            if (backup != null) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDocument);\n\n            getProgress().endStep(this);\n        }\n\n        return \"\";\n    }\n\n    public String getEscapedContent(XWikiContext context) throws XWikiException\n    {\n        return XMLUtils.escape(getTranslatedContent(context));\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getName()\n    {\n        return getDocumentReference().getName();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setName(String name)\n    {\n        if (name != null) {\n            DocumentReference reference = getDocumentReference();\n            // TODO: ensure that other parameters are copied properly\n            setDocumentReferenceInternal(\n                new DocumentReference(name, new SpaceReference(reference.getParent()), reference.getLocale()));\n        }\n    }\n\n    @Override\n    public DocumentReference getDocumentReference()\n    {\n        return this.documentReference;\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReference()\n    {\n        if (this.pageReferenceCache == null) {\n            this.pageReferenceCache = intern(getPageReferenceResolver().resolve(getDocumentReference()));\n        }\n\n        return this.pageReferenceCache;\n    }\n\n    /**\n     * @return the reference of the document as {@link PageReference} including the {@link Locale}\n     * @since 10.6RC1\n     */\n    public PageReference getPageReferenceWithLocale()\n    {\n        if (this.pageReferenceWithLocaleCache == null) {\n            this.pageReferenceWithLocaleCache = intern(new PageReference(getPageReference(), getLocale()));\n        }\n\n        return this.pageReferenceWithLocaleCache;\n    }\n\n    /**\n     * @return the {@link DocumentReference} of the document also containing the document {@link Locale}\n     * @since 5.3M2\n     */\n    public DocumentReference getDocumentReferenceWithLocale()\n    {\n        if (this.documentReferenceWithLocaleCache == null) {\n            this.documentReferenceWithLocaleCache = intern(new DocumentReference(this.documentReference, getLocale()));\n        }\n\n        return this.documentReferenceWithLocaleCache;\n    }\n\n    /**\n     * @return the document's space + page name (eg \"space.page\")\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getFullName()\n    {\n        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference());\n    }\n\n    /**\n     * @return the docoument's wiki + space + page name (eg \"wiki:space.page\")\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getPrefixedFullName()\n    {\n        return getDefaultEntityReferenceSerializer().serialize(getDocumentReference());\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated don't change the reference of a document once it's been constructed. Instead you can\n     *             clone the doc, rename it or copy it.\n     */\n    @Deprecated(since = \"2.2.3\")\n    public void setDocumentReference(DocumentReference reference)\n    {\n        // Don't allow setting a null reference for now, ie. don't do anything to preserve backward compatibility\n        // with previous behavior (i.e. {@link #setFullName}.\n        if (reference != null) {\n            // Retro compatibility, make sure <code>this.documentReference</code> does not contain the Locale (for now)\n            DocumentReference referenceWithoutLocale =\n                reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference;\n\n            if (!referenceWithoutLocale.equals(getDocumentReference())) {\n                setDocumentReferenceInternal(referenceWithoutLocale);\n            }\n        }\n    }\n\n    private void setDocumentReferenceInternal(DocumentReference reference)\n    {\n        this.documentReference = intern(reference);\n\n        setMetaDataDirty(true);\n\n        // Clean various caches\n\n        this.keyCache = null;\n        this.localKeyCache = null;\n        this.parentReferenceCache = null;\n        this.documentReferenceWithLocaleCache = null;\n        this.pageReferenceCache = null;\n        this.pageReferenceWithLocaleCache = null;\n    }\n\n    /**\n     * @deprecated use {@link #setDocumentReference(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setFullName(String name)\n    {\n        setFullName(name, null);\n    }\n\n    /**\n     * @deprecated use {@link #setDocumentReference(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setFullName(String fullName, XWikiContext context)\n    {\n        // We ignore the passed full name if it's null to be backward compatible with previous behaviors and to be\n        // consistent with {@link #setName} and {@link #setSpace}.\n        if (fullName != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            setDocumentReference(getCurrentMixedDocumentReferenceResolver().resolve(fullName));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getWikiName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getWikiName()\n    {\n        return getDatabase();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getSpaceName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getSpaceName()\n    {\n        return this.getSpace();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see DocumentModelBridge#getSpaceName()\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    @Override\n    public String getPageName()\n    {\n        return this.getName();\n    }\n\n    @Override\n    public String getTitle()\n    {\n        return (this.title != null) ? this.title : \"\";\n    }\n\n    /**\n     * Get the rendered version of the document title. The title is extracted and then Velocity is applied on it and\n     * it's then rendered using the passed Syntax. The following logic is used to extract the title:\n     * <ul>\n     * <li>If a Sheet is specified for the document and this Sheet document contains a non empty title then it's\n     * used</li>\n     * <li>If not and the document's title is specified then it's used</li>\n     * <li>If not and if the title compatibility mode is turned on ({@code xwiki.title.compatibility=1} in\n     * {@code xwiki.cfg}) then an attempt is made to extract the title from the first heading found in the document's\n     * content</li>\n     * <li>If not, then at last resort the page name is returned</li>\n     * </ul>\n     *\n     * @param outputSyntax the syntax to render to; this is not taken into account for XWiki 1.0 syntax\n     * @param context the XWiki context\n     * @return the rendered version of the document title\n     */\n    public String getRenderedTitle(Syntax outputSyntax, XWikiContext context)\n    {\n        DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();\n        parameters.setTitleDisplayed(true);\n        parameters.setExecutionContextIsolated(true);\n        parameters.setTargetSyntax(outputSyntax);\n        try {\n            XDOM titleXDOM = getDocumentDisplayer().display(this, parameters);\n            return renderXDOM(titleXDOM, outputSyntax);\n        } catch (Exception e) {\n            // We've failed to extract the Document's title or to render it. We log an error but we use the page name\n            // as the returned title in order to not generate errors in lots of places in the wiki (e.g. Activity\n            // Stream, menus, etc). The title is used in a lots of places...\n            LOGGER.error(\"Failed to render title for [{}]\", getDocumentReference(), e);\n            return getDocumentReference().getName();\n        }\n    }\n\n    /**\n     * Similar to {@link #getRenderedTitle(Syntax, XWikiContext)} but the output Syntax used is XHTML 1.0 unless the\n     * current skin defines another output Syntax in which case it's the one used.\n     *\n     * @param context the XWiki context\n     * @return the rendered version of the document title\n     */\n    public String getRenderedTitle(XWikiContext context)\n    {\n        return getRenderedTitle(getOutputSyntax(), context);\n    }\n\n    public void setTitle(String title)\n    {\n        if (title != null && !title.equals(this.title)) {\n            // Document titles usually contain velocity script, so it is not enough to set the metadata dirty, since we\n            // want to content author to be updated for programming or script rights to be updated.\n            setContentDirty(true);\n        }\n        this.title = title;\n    }\n\n    public String getFormat()\n    {\n        return this.format != null ? this.format : \"\";\n    }\n\n    public void setFormat(String format)\n    {\n        if (!format.equals(this.format)) {\n            this.format = format;\n\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @param userString the user {@link String} to convert to {@link DocumentReference}\n     * @return the user as {@link DocumentReference}\n     */\n    private DocumentReference userStringToReference(String userString)\n    {\n        DocumentReference userReference;\n\n        if (StringUtils.isEmpty(userString)) {\n            userReference = null;\n        } else {\n            userReference = getExplicitReferenceDocumentReferenceResolver().resolve(\n                getXClassEntityReferenceResolver().resolve(userString, EntityType.DOCUMENT), getDocumentReference());\n\n            if (userReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                userReference = null;\n            }\n        }\n\n        return userReference;\n    }\n\n    /**\n     * @param userReference the user {@link DocumentReference} to convert to {@link String}\n     * @return the user as String\n     */\n    private String userReferenceToString(DocumentReference userReference)\n    {\n        String userString;\n\n        if (userReference != null) {\n            userString = getCompactWikiEntityReferenceSerializer().serialize(userReference, getDocumentReference());\n        } else {\n            userString = XWikiRightService.GUEST_USER_FULLNAME;\n        }\n\n        return userString;\n    }\n\n    /**\n     * @param userReference the user {@link DocumentReference} to convert to {@link String}\n     * @return the user as String\n     */\n    private String userReferenceToString(UserReference userReference)\n    {\n        // The user API is missing the concept of relative user references ATM so we're forced to check where the users\n        // are stored in order to make sure user references stored in the database are relative.\n        // See also XWIKI-19442: APIs to generate various String references from a UserReference\n        if (\"document\".equals(getUserConfiguration().getStoreHint())) {\n            // Users are stored as documents. We want the user references that are stored in the database to be relative\n            // as much as possible (because it makes the content portable). For this we omit the wiki reference when the\n            // user (profile document) reference is from the same wiki as this document.\n            return getUserReferenceCompactWikiSerializer().serialize(userReference, getDocumentReference());\n        } else {\n            return getUserReferenceStringSerializer().serialize(userReference);\n        }\n    }\n\n    /**\n     * @param userString the user {@link String} to convert to {@link UserReference}\n     * @return the user as {@link UserReference}\n     */\n    private UserReference userStringToUserReference(String userString)\n    {\n        // The user API is missing the concept of relative user references ATM so if we want to resolve (partial) user\n        // references that were stored in the database relative to this document then we need to check where the users\n        // are stored. See also XWIKI-19442: APIs to generate various String references from a UserReference\n        if (\"document\".equals(getUserConfiguration().getStoreHint())) {\n            return getUserReferenceStringResolver().resolve(userString, getDocumentReference().getWikiReference());\n        } else {\n            return getUserReferenceStringResolver().resolve(userString);\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getEffectiveMetadataAuthor()} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getAuthorReference()\n    {\n        UserReference effectiveMetadataAuthor = getAuthors().getEffectiveMetadataAuthor();\n        if (this.getAuthors().getEffectiveMetadataAuthor() != null\n            && effectiveMetadataAuthor != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(effectiveMetadataAuthor);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setEffectiveMetadataAuthor(UserReference)}\n     * instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setAuthorReference(DocumentReference authorReference)\n    {\n        if (authorReference == null) {\n            this.authors.setEffectiveMetadataAuthor(GuestUserReference.INSTANCE);\n        } else {\n            if (authorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(authorReference);\n            this.authors.setEffectiveMetadataAuthor(user);\n            // We also set the original metadata author for backward compatibility.\n            this.authors.setOriginalMetadataAuthor(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated since 3.0M3 use {@link #getAuthorReference()} instead\n     */\n    @Deprecated\n    public String getAuthor()\n    {\n        return userReferenceToString(getAuthorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setAuthorReference} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public void setAuthor(String author)\n    {\n        setAuthorReference(userStringToReference(author));\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getContentAuthor()} instead\n     */\n    @Override\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getContentAuthorReference()\n    {\n        UserReference contentAuthor = this.getAuthors().getContentAuthor();\n        if (contentAuthor != null && contentAuthor != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(contentAuthor);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setContentAuthor(UserReference)} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setContentAuthorReference(DocumentReference contentAuthorReference)\n    {\n        if (contentAuthorReference == null) {\n            this.authors.setContentAuthor(GuestUserReference.INSTANCE);\n        } else {\n            if (contentAuthorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(contentAuthorReference);\n            this.authors.setContentAuthor(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getContentAuthorReference()} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public String getContentAuthor()\n    {\n        return userReferenceToString(getContentAuthorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setContentAuthorReference} instead\n     */\n    @Deprecated(since = \"3.0M3\")\n    public void setContentAuthor(String contentAuthor)\n    {\n        setContentAuthorReference(userStringToReference(contentAuthor));\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#getCreator()} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public DocumentReference getCreatorReference()\n    {\n        UserReference creator = this.getAuthors().getCreator();\n        if (creator != null && creator != GuestUserReference.INSTANCE) {\n            return this.getUserReferenceDocumentReferenceSerializer().serialize(creator);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.0M3\n     * @deprecated use {@link #getAuthors()} and then {@link DocumentAuthors#setCreator(UserReference)} instead\n     */\n    @Deprecated(since = \"14.0RC1\")\n    public void setCreatorReference(DocumentReference creatorReference)\n    {\n        if (creatorReference == null) {\n            this.authors.setCreator(GuestUserReference.INSTANCE);\n        } else {\n            if (creatorReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(creatorReference);\n            this.authors.setCreator(user);\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getCreatorReference()} instead\n     */\n    @Deprecated(since = \"3.0M2\")\n    public String getCreator()\n    {\n        return userReferenceToString(getCreatorReference());\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setCreatorReference} instead\n     */\n    @Deprecated(since = \"3.0M2\")\n    public void setCreator(String creator)\n    {\n        setCreatorReference(userStringToReference(creator));\n    }\n\n    @Override\n    public Date getDate()\n    {\n        if (this.updateDate == null) {\n            return new Date();\n        } else {\n            return this.updateDate;\n        }\n    }\n\n    public void setDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.updateDate))) {\n            setMetaDataDirty(true);\n        }\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.updateDate = date;\n    }\n\n    @Override\n    public Date getCreationDate()\n    {\n        if (this.creationDate == null) {\n            return new Date();\n        } else {\n            return this.creationDate;\n        }\n    }\n\n    public void setCreationDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.creationDate))) {\n            setMetaDataDirty(true);\n        }\n\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.creationDate = date;\n    }\n\n    public Date getContentUpdateDate()\n    {\n        if (this.contentUpdateDate == null) {\n            return new Date();\n        } else {\n            return this.contentUpdateDate;\n        }\n    }\n\n    public void setContentUpdateDate(Date date)\n    {\n        if ((date != null) && (!date.equals(this.contentUpdateDate))) {\n            setMetaDataDirty(true);\n        }\n\n        // Make sure we drop milliseconds for consistency with the database\n        if (date != null) {\n            date.setTime((date.getTime() / 1000) * 1000);\n        }\n        this.contentUpdateDate = date;\n    }\n\n    public String getMeta()\n    {\n        return this.meta;\n    }\n\n    public void setMeta(String meta)\n    {\n        if (meta == null) {\n            if (this.meta != null) {\n                setMetaDataDirty(true);\n            }\n        } else if (!meta.equals(this.meta)) {\n            setMetaDataDirty(true);\n        }\n        this.meta = meta;\n    }\n\n    public void appendMeta(String meta)\n    {\n        StringBuilder buf = new StringBuilder(this.meta);\n        buf.append(meta);\n        buf.append(\"\\n\");\n        this.meta = buf.toString();\n        setMetaDataDirty(true);\n    }\n\n    public boolean isContentDirty()\n    {\n        return this.isContentDirty;\n    }\n\n    /**\n     * Increment the current document version.\n     * This method will use {@link #getNextVersion(Version, boolean)} to compute the new version.\n     */\n    public void incrementVersion()\n    {\n        this.version = getNextVersion(this.version, isMinorEdit());\n    }\n\n    /**\n     * This method computes the next version and returns it, but won't change the current version.\n     * In order to change the current version, see {@link #incrementVersion()}.\n     *\n     * @param version the based version from which to compute the next one.\n     * @param minorEdit true means it's a minor edition.\n     * @return the new version computed based on the current one.\n     * @since 11.2RC1\n     */\n    public static Version getNextVersion(Version version, boolean minorEdit)\n    {\n        if (version == null) {\n            return new Version(\"1.1\");\n        }\n        if (minorEdit) {\n            return version.next();\n        } else {\n            return version.getBranchPoint().next().newBranch(1);\n        }\n    }\n\n    public void setContentDirty(boolean contentDirty)\n    {\n        this.isContentDirty = contentDirty;\n    }\n\n    public boolean isMetaDataDirty()\n    {\n        return this.isMetaDataDirty;\n    }\n\n    public void setMetaDataDirty(boolean metaDataDirty)\n    {\n        this.isMetaDataDirty = metaDataDirty;\n    }\n\n    public String getAttachmentURL(String filename, XWikiContext context)\n    {\n        return getAttachmentURL(filename, \"download\", context);\n    }\n\n    public String getAttachmentURL(String filename, String action, XWikiContext context)\n    {\n        return getAttachmentURL(filename, action, null, context);\n    }\n\n    public String getExternalAttachmentURL(String filename, String action, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createAttachmentURL(filename, getSpace(), getName(), action, null,\n            getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getAttachmentURL(String filename, String action, String querystring, XWikiContext context)\n    {\n        // Attachment file name cannot be empty\n        if (StringUtils.isEmpty(filename)) {\n            return null;\n        }\n\n        return context.getWiki().getAttachmentURL(new AttachmentReference(filename, this.getDocumentReference()),\n            action, querystring, context);\n    }\n\n    public String getAttachmentRevisionURL(String filename, String revision, XWikiContext context)\n    {\n        return getAttachmentRevisionURL(filename, revision, null, context);\n    }\n\n    public String getAttachmentRevisionURL(String filename, String revision, String querystring, XWikiContext context)\n    {\n        // Attachment file name cannot be empty\n        if (StringUtils.isEmpty(filename)) {\n            return null;\n        }\n\n        return context.getWiki().getAttachmentRevisionURL(new AttachmentReference(filename, getDocumentReference()),\n            revision, querystring, context);\n    }\n\n    /**\n     * @param action the action, see the {@code struts-config.xml} file for a list of all existing action names\n     * @param params the URL query string\n     * @param redirect true if the URL is going to be used in {@link HttpServletResponse#sendRedirect(String)}\n     * @param context the XWiki context\n     * @return the URL\n     */\n    public String getURL(String action, String params, boolean redirect, XWikiContext context)\n    {\n        URL url =\n            context.getURLFactory().createURL(getSpace(), getName(), action, params, null, getDatabase(), context);\n\n        if (redirect && isRedirectAbsolute(context)) {\n            if (url == null) {\n                return null;\n            } else {\n                return url.toString();\n            }\n        } else {\n            return context.getURLFactory().getURL(url, context);\n        }\n    }\n\n    private boolean isRedirectAbsolute(XWikiContext context)\n    {\n        return StringUtils.equals(\"1\", context.getWiki().Param(\"xwiki.redirect.absoluteurl\"));\n    }\n\n    public String getURL(String action, boolean redirect, XWikiContext context)\n    {\n        return getURL(action, null, redirect, context);\n    }\n\n    public String getURL(String action, XWikiContext context)\n    {\n        return getURL(action, false, context);\n    }\n\n    public String getURL(String action, String querystring, XWikiContext context)\n    {\n        URL url =\n            context.getURLFactory().createURL(getSpace(), getName(), action, querystring, null, getDatabase(), context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getURL(String action, String querystring, String anchor, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createURL(getSpace(), getName(), action, querystring, anchor, getDatabase(),\n            context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getExternalURL(String action, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, null, null, getDatabase(),\n            context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String action, String querystring, XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, querystring, null,\n            getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getParentURL(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getParentReference());\n        URL url = context.getURLFactory().createURL(doc.getSpace(), doc.getName(), \"view\", null, null, getDatabase(),\n            context);\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public XWikiDocumentArchive getDocumentArchive(XWikiContext context) throws XWikiException\n    {\n        loadArchive(context);\n        return getDocumentArchive();\n    }\n\n    /**\n     * Create a new protected {@link com.xpn.xwiki.api.Document} public API to access page information and actions from\n     * scripting.\n     *\n     * @param customClassName the name of the custom {@link com.xpn.xwiki.api.Document} class of the object to create.\n     * @param context the XWiki context.\n     * @return a wrapped version of an XWikiDocument. Prefer this function instead of new Document(XWikiDocument,\n     *         XWikiContext)\n     */\n    public com.xpn.xwiki.api.Document newDocument(String customClassName, XWikiContext context)\n    {\n        if (!((customClassName == null) || (customClassName.equals(\"\")))) {\n            try {\n                return newDocument(Class.forName(customClassName), context);\n            } catch (ClassNotFoundException e) {\n                LOGGER.error(\"Failed to get java Class object from class name\", e);\n            }\n        }\n\n        return new com.xpn.xwiki.api.Document(this, context);\n    }\n\n    /**\n     * Create a new protected {@link com.xpn.xwiki.api.Document} public API to access page information and actions from\n     * scripting.\n     *\n     * @param customClass the custom {@link com.xpn.xwiki.api.Document} class the object to create.\n     * @param context the XWiki context.\n     * @return a wrapped version of an XWikiDocument. Prefer this function instead of new Document(XWikiDocument,\n     *         XWikiContext)\n     */\n    public com.xpn.xwiki.api.Document newDocument(Class<?> customClass, XWikiContext context)\n    {\n        if (customClass != null) {\n            try {\n                Class<?>[] classes = new Class[] { XWikiDocument.class, XWikiContext.class };\n                Object[] args = new Object[] { this, context };\n\n                return (com.xpn.xwiki.api.Document) customClass.getConstructor(classes).newInstance(args);\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to create a custom Document object\", e);\n            }\n        }\n\n        return new com.xpn.xwiki.api.Document(this, context);\n    }\n\n    public com.xpn.xwiki.api.Document newDocument(XWikiContext context)\n    {\n        String customClass = getCustomClass();\n        return newDocument(customClass, context);\n    }\n\n    public void loadArchive(XWikiContext context) throws XWikiException\n    {\n        if ((this.archive == null || this.archive.get() == null)) {\n            XWikiDocumentArchive arch;\n            // A document not comming from the database cannot have an archive stored in the database\n            if (this.isNew()) {\n                arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n            } else {\n                arch = getVersioningStore(context).getXWikiDocumentArchive(this, context);\n            }\n            // We are using a SoftReference which will allow the archive to be\n            // discarded by the Garbage collector as long as the context is closed (usually during\n            // the request)\n            this.archive = new SoftReference<>(arch);\n        }\n    }\n\n    /**\n     * @return the {@link XWikiDocumentArchive} for this document. If it is not stored in the document, null is\n     *         returned.\n     */\n    public XWikiDocumentArchive getDocumentArchive()\n    {\n        // If there is a soft reference, return it.\n        if (this.archive != null) {\n            return this.archive.get();\n        }\n        // Some APIs are expecting the archive to be null for loading it\n        // (e.g. VersioningStore#loadXWikiDocumentArchive), so it's better to keep it null than to return an\n        // empty archive which would never be populated.\n        return null;\n    }\n\n    /**\n     * @return the {@link XWikiDocumentArchive} for this document. If it is not stored in the document, we get it using\n     *         the current context. If there is an exception, null is returned.\n     */\n    public XWikiDocumentArchive loadDocumentArchive()\n    {\n        XWikiDocumentArchive arch = getDocumentArchive();\n        if (arch != null) {\n            return arch;\n        }\n\n        // A document not comming from the database cannot have an archive stored in the database\n        if (this.isNew()) {\n            arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n            setDocumentArchive(arch);\n            return arch;\n        }\n\n        XWikiContext xcontext = getXWikiContext();\n\n        try {\n            arch = getVersioningStore(xcontext).getXWikiDocumentArchive(this, xcontext);\n\n            // Put a copy of the archive in the soft reference for later use if needed.\n            setDocumentArchive(arch);\n\n            return arch;\n        } catch (Exception e) {\n            // VersioningStore.getXWikiDocumentArchive may throw an XWikiException, and xcontext or VersioningStore\n            // may be null (tests)\n            // To maintain the behavior of this method we can't throw an exception.\n            // Formerly, null was returned if there was no SoftReference.\n            LOGGER.warn(\"Could not get document archive\", e);\n            return null;\n        }\n    }\n\n    public void setDocumentArchive(XWikiDocumentArchive arch)\n    {\n        // We are using a SoftReference which will allow the archive to be\n        // discarded by the Garbage collector as long as the context is closed (usually during the\n        // request)\n        if (arch != null) {\n            this.archive = new SoftReference<XWikiDocumentArchive>(arch);\n        } else {\n            // Some APIs are expecting the archive to be null for loading it\n            // (e.g. VersioningStore#loadXWikiDocumentArchive), so we allow setting it back to null.\n            this.archive = null;\n        }\n    }\n\n    public void setDocumentArchive(String sarch) throws XWikiException\n    {\n        XWikiDocumentArchive xda = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());\n        xda.setArchive(sarch);\n        setDocumentArchive(xda);\n    }\n\n    public Version[] getRevisions(XWikiContext context) throws XWikiException\n    {\n        return getVersioningStore(context).getXWikiDocVersions(this, context);\n    }\n\n    public String[] getRecentRevisions(int nb, XWikiContext context) throws XWikiException\n    {\n        try {\n            Version[] revisions = getVersioningStore(context).getXWikiDocVersions(this, context);\n            int length = nb;\n            // 0 means all revisions\n            if (nb == 0) {\n                length = revisions.length;\n            }\n\n            if (revisions.length < length) {\n                length = revisions.length;\n            }\n\n            String[] recentrevs = new String[length];\n            for (int i = 1; i <= length; i++) {\n                recentrevs[i - 1] = revisions[revisions.length - i].toString();\n            }\n            return recentrevs;\n        } catch (Exception e) {\n            return new String[0];\n        }\n    }\n\n    /**\n     * Get document versions matching criterias like author, minimum creation date, etc.\n     *\n     * @param criteria criteria used to match versions\n     * @return a list of matching versions\n     */\n    public List<String> getRevisions(RevisionCriteria criteria, XWikiContext context) throws XWikiException\n    {\n        List<String> results = new ArrayList<String>();\n\n        Version[] revisions = getRevisions(context);\n\n        XWikiRCSNodeInfo nextNodeinfo = null;\n        XWikiRCSNodeInfo nodeinfo;\n        for (Version revision : revisions) {\n            nodeinfo = nextNodeinfo;\n            nextNodeinfo = getRevisionInfo(revision.toString(), context);\n\n            if (nodeinfo == null) {\n                continue;\n            }\n\n            // Minor/Major version matching\n            if (criteria.getIncludeMinorVersions() || !nextNodeinfo.isMinorEdit()) {\n                // Author matching\n                if (criteria.getAuthor().equals(\"\") || criteria.getAuthor().equals(nodeinfo.getAuthor())) {\n                    // Date range matching\n                    Date versionDate = nodeinfo.getDate();\n                    if (versionDate.after(criteria.getMinDate()) && versionDate.before(criteria.getMaxDate())) {\n                        results.add(nodeinfo.getVersion().toString());\n                    }\n                }\n            }\n        }\n\n        nodeinfo = nextNodeinfo;\n        if (nodeinfo != null) {\n            if (criteria.getAuthor().equals(\"\") || criteria.getAuthor().equals(nodeinfo.getAuthor())) {\n                // Date range matching\n                Date versionDate = nodeinfo.getDate();\n                if (versionDate.after(criteria.getMinDate()) && versionDate.before(criteria.getMaxDate())) {\n                    results.add(nodeinfo.getVersion().toString());\n                }\n            }\n        }\n\n        return criteria.getRange().subList(results);\n    }\n\n    public XWikiRCSNodeInfo getRevisionInfo(String version, XWikiContext context) throws XWikiException\n    {\n        return getDocumentArchive(context).getNode(new Version(version));\n    }\n\n    /**\n     * @return Is this version the most recent one. False if and only if there are newer versions of this document in\n     *         the database.\n     */\n    public boolean isMostRecent()\n    {\n        return this.mostRecent;\n    }\n\n    /**\n     * must not be used unless in store system.\n     *\n     * @param mostRecent - mark document as most recent.\n     */\n    public void setMostRecent(boolean mostRecent)\n    {\n        this.mostRecent = mostRecent;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseClass getXClass()\n    {\n        if (this.xClass == null) {\n            BaseClass emptyClass = new BaseClass();\n            // Make sure not to cause any false document versions if this document is saved.\n            emptyClass.setDirty(false);\n\n            this.setXClass(emptyClass);\n        }\n        return this.xClass;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXClass(BaseClass xwikiClass)\n    {\n        xwikiClass.setOwnerDocument(this);\n\n        this.xClass = xwikiClass;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public Map<DocumentReference, List<BaseObject>> getXObjects()\n    {\n        return (Map) this.publicXObjects;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjects(Map<DocumentReference, List<BaseObject>> objects)\n    {\n        if (objects == null) {\n            // Make sure we don`t set a null objects map since we assume everywhere that it is not null when using it.\n            objects = new HashMap<>();\n        }\n\n        boolean isDirty = false;\n\n        for (List<BaseObject> objList : objects.values()) {\n            for (BaseObject obj : objList) {\n                obj.setOwnerDocument(this);\n                isDirty = true;\n            }\n        }\n\n        // This operation resulted in marking the current document dirty.\n        if (isDirty) {\n            setMetaDataDirty(true);\n        }\n\n        // Replace the current objects with the provided ones.\n        Map<DocumentReference, BaseObjects> objectsCopy = new ConcurrentSkipListMap<>();\n        objects.forEach((k, v) -> objectsCopy.put(k, new BaseObjects(v)));\n        this.xObjects = objectsCopy;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject()\n    {\n        return getXObject(getDocumentReference());\n    }\n\n    /**\n     * @deprecated use {@link #getXObject()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getxWikiObject()\n    {\n        return getXObject(getDocumentReference());\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public List<BaseClass> getXClasses(XWikiContext context)\n    {\n        List<BaseClass> list = new ArrayList<BaseClass>();\n\n        // getXObjects() is a TreeMap, with elements sorted by className reference\n        for (DocumentReference classReference : getXObjects().keySet()) {\n            BaseClass bclass = null;\n            List<BaseObject> objects = getXObjects(classReference);\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    bclass = obj.getXClass(context);\n                    if (bclass != null) {\n                        break;\n                    }\n                }\n            }\n            if (bclass != null) {\n                list.add(bclass);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Create and add a new object to the document with the provided class.\n     * <p>\n     * Note that absolute reference are not supported for xclasses which mean that the wiki part (whatever the wiki is)\n     * of the reference will be systematically removed.\n     *\n     * @param classReference the reference of the class\n     * @param context the XWiki context\n     * @return the index of teh newly created object\n     * @throws XWikiException error when creating the new object\n     * @since 2.2.3\n     */\n    public int createXObject(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        BaseObject object = BaseClass.newCustomClassInstance(absoluteClassReference, context);\n        object.setOwnerDocument(this);\n        object.setXClassReference(classReference);\n        BaseObjects objects = this.xObjects.get(absoluteClassReference);\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(absoluteClassReference, objects);\n        }\n        objects.add(object);\n        int nb = objects.size() - 1;\n        object.setNumber(nb);\n        setMetaDataDirty(true);\n        return nb;\n    }\n\n    /**\n     * @deprecated use {@link #createXObject(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public int createNewObject(String className, XWikiContext context) throws XWikiException\n    {\n        return createXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public int getXObjectSize(DocumentReference classReference)\n    {\n        try {\n            return getXObjects().get(classReference).size();\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n\n    /**\n     * @since 7.3M1\n     * @since 7.2.1\n     * @since 7.1.3\n     * @since 6.4.6\n     */\n    public int getXObjectSize(EntityReference classReference)\n    {\n        return getXObjectSize(resolveClassReference(classReference));\n    }\n\n    /**\n     * @deprecated use {@link #getXObjectSize(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public int getObjectNumbers(String className)\n    {\n        return getXObjectSize(resolveClassReference(className));\n    }\n\n    /**\n     * Retrieve and returns all objects corresponding to the given class reference, or an empty list if there's none.\n     * Be aware that some elements of this list might be null since all objects are in the list at their real index.\n     *\n     * @param classReference the reference of the xclass for which to retrieve the xobjects\n     * @return a list of xobjects and null elements (for deleted xobjects) corresponding to the given xclass\n     *          or an empty list.\n     * @since 2.2M1\n     */\n    public List<BaseObject> getXObjects(DocumentReference classReference)\n    {\n        List<BaseObject> xobjects = null;\n\n        if (classReference != null) {\n            xobjects = getXObjects().get(classReference);\n        }\n\n        return xobjects != null ? xobjects : Collections.emptyList();\n    }\n\n    /**\n     * Retrieve and returns all objects corresponding to the class reference corresponding to the resolution of the\n     * given entity reference, or an empty list if there's none.\n     * Be aware that some elements of this list might be null since all objects are in the list at their real index.\n     *\n     * @param reference the reference that is resolved to an xclass for retrieving the corresponding xobjects\n     * @return a list of xobjects and null elements (for deleted xobjects) corresponding to the given xclass\n     *           or an empty list.\n     * @since 3.3M1\n     */\n    public List<BaseObject> getXObjects(EntityReference reference)\n    {\n        if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObjects(\n                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * @deprecated use {@link #getXObjects(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public Vector<BaseObject> getObjects(String className)\n    {\n        List<BaseObject> result = this.xObjects.get(resolveClassReference(className));\n        return result == null ? null : new Vector<BaseObject>(result);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjects(DocumentReference classReference, List<BaseObject> objects)\n    {\n        // Remove existing objects\n        List<BaseObject> existingbjects = this.xObjects.get(classReference);\n        if (existingbjects != null) {\n            existingbjects.clear();\n        }\n\n        for (BaseObject obj : objects) {\n            obj.setOwnerDocument(this);\n        }\n\n        // Add new objects\n        this.xObjects.put(classReference, new BaseObjects(objects));\n\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @since 3.3M1\n     */\n    public BaseObject getXObject(EntityReference reference)\n    {\n        if (reference instanceof DocumentReference) {\n            return getXObject((DocumentReference) reference);\n        } else if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObject(\n                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n        } else if (reference.getType() == EntityType.OBJECT) {\n            // object reference\n            return getXObject(getCurrentReferenceObjectReferenceResolver().resolve(reference, getDocumentReference()));\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference)\n    {\n        BaseObject result = null;\n        List<BaseObject> objects = getXObjects().get(classReference);\n        if (objects != null) {\n            for (BaseObject object : objects) {\n                if (object != null) {\n                    result = object;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get an object of this document based on its reference.\n     *\n     * @param objectReference the reference of the object\n     * @return the XWiki object\n     * @since 3.2M1\n     */\n    public BaseObject getXObject(ObjectReference objectReference)\n    {\n        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);\n\n        // If the baseObjectReference has an object number, we return the object with this number,\n        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber\n        return baseObjectReference.getObjectNumber() == null ? this.getXObject(baseObjectReference.getXClassReference())\n            : getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber());\n    }\n\n    /**\n     * Get or create an object of this document based on its reference.\n     *\n     * @param objectReference The reference of the object.\n     * @param create If the object shall be created if missing.\n     * @param context The XWiki context for creating the object.\n     * @return The found or created objected.\n     * @throws XWikiException If object creation failed.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public BaseObject getXObject(ObjectReference objectReference, boolean create, XWikiContext context)\n        throws XWikiException\n    {\n        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);\n\n        // If the baseObjectReference has an object number, we return the object with this number,\n        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber\n        if (baseObjectReference.getObjectNumber() == null) {\n            return getXObject(baseObjectReference.getXClassReference(), create, context);\n        } else {\n            return getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber(), create,\n                context);\n        }\n    }\n\n    /**\n     * Convert the given {@link ObjectReference} into a {@link BaseObjectReference}.\n     */\n    private BaseObjectReference getBaseObjectReference(ObjectReference objectReference)\n    {\n        if (objectReference instanceof BaseObjectReference) {\n            return (BaseObjectReference) objectReference;\n        } else {\n            return new BaseObjectReference(objectReference);\n        }\n    }\n\n    /**\n     * Get an object property of this document based on its reference.\n     *\n     * @param objectPropertyReference the reference of the object property\n     * @return the object property\n     * @since 3.2M3\n     */\n    public BaseProperty<ObjectPropertyReference> getXObjectProperty(ObjectPropertyReference objectPropertyReference)\n    {\n        BaseObject object = getXObject((ObjectReference) objectPropertyReference.getParent());\n\n        if (object != null) {\n            return (BaseProperty<ObjectPropertyReference>) object.getField(objectPropertyReference.getName());\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className)\n    {\n        return getXObject(resolveClassReference(className));\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, int nb)\n    {\n        List<BaseObject> objects = getXObjects().get(classReference);\n\n        if (objects != null && objects.size() > nb) {\n            return objects.get(nb);\n        }\n\n        return null;\n    }\n\n    /**\n     * Get an xobject with the passed xclass at the passed location.\n     * <p>\n     * If <code>create</code> is true and the is no xobject at the passed located, it's created.\n     *\n     * @param classReference the xlcass of the object to retrieve\n     * @param number the location of the xobject\n     * @param create if true the xobject is created when it does not exist\n     * @param xcontext the XWiki context\n     * @return a {@link BaseObject} stored at passed location\n     * @throws XWikiException when failing to create new xobject instance\n     * @since 7.3M1\n     * @since 7.2.1\n     * @since 7.1.3\n     * @since 6.4.6\n     */\n    public BaseObject getXObject(EntityReference classReference, int number, boolean create, XWikiContext xcontext)\n        throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n\n        BaseObject xobject = getXObject(absoluteClassReference, number);\n\n        if (xobject == null && create) {\n            xobject = BaseClass.newCustomClassInstance(absoluteClassReference, xcontext);\n\n            setXObject(number, xobject);\n        }\n\n        return xobject;\n    }\n\n    /**\n     * @since 4.1M1\n     */\n    public BaseObject getXObject(EntityReference classReference, int nb)\n    {\n        return getXObject(\n            getCurrentReferenceDocumentReferenceResolver().resolve(classReference, getDocumentReference()), nb);\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, int)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, int nb)\n    {\n        return getXObject(resolveClassReference(className), nb);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, String key, String value)\n    {\n        return getXObject(classReference, key, value, false);\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, String key, String value)\n    {\n        return getObject(className, key, value, false);\n    }\n\n    /**\n     * @return 6.3M1\n     */\n    public BaseObject getXObject(EntityReference reference, String key, String value, boolean failover)\n    {\n        if (reference instanceof DocumentReference) {\n            return getXObject((DocumentReference) reference, key, value, failover);\n        } else if (reference.getType() == EntityType.DOCUMENT) {\n            // class reference\n            return getXObject(getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()),\n                key, value, failover);\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public BaseObject getXObject(DocumentReference classReference, String key, String value, boolean failover)\n    {\n        try {\n            if (value == null) {\n                if (failover) {\n                    return getXObject(classReference);\n                } else {\n                    return null;\n                }\n            }\n\n            List<BaseObject> objects = getXObjects().get(classReference);\n            if ((objects == null) || (objects.size() == 0)) {\n                return null;\n            }\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    if (value.equals(obj.getStringValue(key))) {\n                        return obj;\n                    }\n                }\n            }\n\n            if (failover) {\n                return getXObject(classReference);\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            if (failover) {\n                return getXObject(classReference);\n            }\n\n            LOGGER.warn(\"Exception while accessing objects for document [{}]: {}\", getDocumentReference(),\n                e.getMessage(), e);\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, String, String, boolean)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public BaseObject getObject(String className, String key, String value, boolean failover)\n    {\n        return getXObject(resolveClassReference(className), key, value, failover);\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated use {@link #addXObject(BaseObject)} instead\n     */\n    @Deprecated\n    public void addXObject(DocumentReference classReference, BaseObject object)\n    {\n        List<BaseObject> vobj = this.xObjects.get(classReference);\n        if (vobj == null) {\n            setXObject(classReference, 0, object);\n        } else {\n            setXObject(classReference, vobj.size(), object);\n        }\n    }\n\n    /**\n     * Add the object to the document.\n     *\n     * @param object the xobject to add\n     * @throws NullPointerException if the specified object is null because we need the get the class reference from the\n     *             object\n     * @since 2.2.3\n     */\n    public void addXObject(BaseObject object)\n    {\n        object.setOwnerDocument(this);\n\n        List<BaseObject> vobj = this.xObjects.get(object.getXClassReference());\n        if (vobj == null) {\n            setXObject(0, object);\n        } else {\n            setXObject(vobj.size(), object);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #addXObject(BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void addObject(String className, BaseObject object)\n    {\n        addXObject(resolveClassReference(className), object);\n    }\n\n    /**\n     * @since 2.2M1\n     * @deprecated use {@link #setXObject(int, BaseObject)} instead\n     */\n    @Deprecated\n    public void setXObject(DocumentReference classReference, int nb, BaseObject object)\n    {\n        if (object != null) {\n            object.setOwnerDocument(this);\n            object.setNumber(nb);\n        }\n\n        BaseObjects objects = this.xObjects.get(classReference);\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(classReference, objects);\n        }\n        while (nb >= objects.size()) {\n            objects.add(null);\n        }\n        objects.set(nb, object);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * Replaces the object at the specified position and for the specified object's xclass.\n     *\n     * @param nb index of the element to replace\n     * @param object the xobject to insert\n     * @throws NullPointerException if the specified object is null because we need the get the class reference from the\n     *             object\n     * @since 2.2.3\n     */\n    public void setXObject(int nb, BaseObject object)\n    {\n        object.setOwnerDocument(this);\n        object.setNumber(nb);\n\n        BaseObjects objects = this.xObjects.get(object.getXClassReference());\n        if (objects == null) {\n            objects = new BaseObjects();\n            this.xObjects.put(object.getXClassReference(), objects);\n        }\n        while (nb >= objects.size()) {\n            objects.add(null);\n        }\n        objects.set(nb, object);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @deprecated use {@link #setXObject(DocumentReference, int, BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setObject(String className, int nb, BaseObject object)\n    {\n        setXObject(resolveClassReference(className), nb, object);\n    }\n\n    /**\n     * @return true if the document is a new one (i.e. it has never been saved) or false otherwise\n     */\n    public boolean isNew()\n    {\n        return this.isNew;\n    }\n\n    public void setNew(boolean aNew)\n    {\n        this.isNew = aNew;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void mergeXClass(XWikiDocument templatedoc)\n    {\n        BaseClass bclass = getXClass();\n        BaseClass tbclass = templatedoc.getXClass();\n        if (tbclass != null) {\n            if (bclass == null) {\n                setXClass(tbclass.clone());\n            } else {\n                getXClass().merge(tbclass.clone());\n            }\n        }\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * @deprecated use {@link #mergeXClass(XWikiDocument)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void mergexWikiClass(XWikiDocument templatedoc)\n    {\n        mergeXClass(templatedoc);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void mergeXObjects(XWikiDocument templateDoc)\n    {\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : templateDoc.getXObjects().entrySet()) {\n            // Documents can't have objects of types defined in a different wiki so we make sure the class reference\n            // matches this document's wiki.\n            DocumentReference classReference = entry.getKey().replaceParent(entry.getKey().getWikiReference(),\n                getDocumentReference().getWikiReference());\n            // Copy the objects from the template document only if this document doesn't have them already.\n            //\n            // Note: this might be a bit misleading since it will not add objects from the template if some objects of\n            // that class already exist in the current document.\n            if (getXObjectSize(classReference) == 0) {\n                for (BaseObject object : entry.getValue()) {\n                    if (object != null) {\n                        addXObject(object.duplicate());\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #mergeXObjects(XWikiDocument)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void mergexWikiObjects(XWikiDocument templatedoc)\n    {\n        mergeXObjects(templatedoc);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void cloneXObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc, true);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void duplicateXObjects(XWikiDocument templatedoc)\n    {\n        cloneXObjects(templatedoc, false);\n    }\n\n    /**\n     * Copy specified document objects into current document.\n     *\n     * @param templatedoc the document to copy\n     * @param keepsIdentity if true it does an exact java copy, otherwise it duplicate objects with the new document\n     *            name (and new class names)\n     */\n    private void cloneXObjects(XWikiDocument templatedoc, boolean keepsIdentity)\n    {\n        // clean map\n        this.xObjects.clear();\n\n        // fill map\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : templatedoc.getXObjects().entrySet()) {\n            List<BaseObject> tobjects = entry.getValue();\n\n            // clone and insert xobjects\n            for (BaseObject otherObject : tobjects) {\n                if (otherObject != null) {\n                    if (keepsIdentity) {\n                        addXObject(otherObject.clone());\n                    } else {\n                        BaseObject newObject = otherObject.duplicate(getDocumentReference());\n                        setXObject(newObject.getNumber(), newObject);\n                    }\n                } else if (keepsIdentity) {\n                    // set null object to make sure to have exactly the same thing when cloning a document\n                    addXObject(entry.getKey(), null);\n                }\n            }\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public DocumentReference getTemplateDocumentReference()\n    {\n        return this.templateDocumentReference;\n    }\n\n    /**\n     * @deprecated use {@link #getTemplateDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getTemplate()\n    {\n        String templateReferenceAsString;\n        DocumentReference templateDocumentReference = getTemplateDocumentReference();\n        if (templateDocumentReference != null) {\n            templateReferenceAsString = LOCAL_REFERENCE_SERIALIZER.serialize(templateDocumentReference);\n        } else {\n            templateReferenceAsString = \"\";\n        }\n        return templateReferenceAsString;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setTemplateDocumentReference(DocumentReference templateDocumentReference)\n    {\n        if (!Objects.equals(getTemplateDocumentReference(), templateDocumentReference)) {\n            this.templateDocumentReference = templateDocumentReference;\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #setTemplateDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setTemplate(String template)\n    {\n        DocumentReference templateReference = null;\n        if (!StringUtils.isEmpty(template)) {\n            templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n        }\n        setTemplateDocumentReference(templateReference);\n    }\n\n    public String displayPrettyName(String fieldname, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, false, true, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, showMandatory, true, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            return displayPrettyName(fieldname, showMandatory, before, object, context);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayPrettyName(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, false, true, obj, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, BaseObject obj, XWikiContext context)\n    {\n        return displayPrettyName(fieldname, showMandatory, true, obj, context);\n    }\n\n    public String displayPrettyName(String fieldname, boolean showMandatory, boolean before, BaseObject obj,\n        XWikiContext context)\n    {\n        try {\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String dprettyName = \"\";\n            if (showMandatory) {\n                dprettyName = context.getWiki().addMandatory(context);\n            }\n            if (before) {\n                return dprettyName + pclass.getPrettyName(context);\n            } else {\n                return pclass.getPrettyName(context) + dprettyName;\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayTooltip(String fieldname, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            return displayTooltip(fieldname, object, context);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String displayTooltip(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String tooltip = pclass.getTooltip(context);\n            if ((tooltip != null) && (!tooltip.trim().equals(\"\"))) {\n                String img = \"<img src=\\\"\" + context.getWiki().getSkinFile(\"info.gif\", context)\n                    + \"\\\" class=\\\"tooltip_image\\\" align=\\\"middle\\\" />\";\n                result = context.getWiki().addTooltip(img, tooltip, context);\n            }\n        } catch (Exception e) {\n\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n\n            result = display(fieldname, object, context);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to display field [\" + fieldname + \"] of document [\"\n                + getDefaultEntityReferenceSerializer().serialize(getDocumentReference()) + \"]\", e);\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, BaseObject obj, XWikiContext context)\n    {\n        String type = null;\n        try {\n            type = (String) context.get(\"display\");\n        } catch (Exception e) {\n        }\n\n        if (type == null) {\n            type = \"view\";\n        }\n\n        return display(fieldname, type, obj, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param mode the mode to use (\"view\", \"edit\", ...)\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String mode, XWikiContext context)\n    {\n        return display(fieldname, mode, \"\", context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, BaseObject obj, XWikiContext context)\n    {\n        return display(fieldname, type, obj, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     * @since 13.0\n     */\n    public String display(String fieldname, String type, BaseObject obj, boolean isolated, XWikiContext context)\n    {\n        return display(fieldname, type, \"\", obj, isolated, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param mode the mode to use (\"view\", \"edit\", ...)\n     * @param prefix the prefix to add in the field identifier in edit display for example\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String mode, String prefix, XWikiContext context)\n    {\n        try {\n            BaseObject object = getXObject();\n            if (object == null) {\n                object = getFirstObject(fieldname, context);\n            }\n            if (object == null) {\n                return \"\";\n            } else {\n                return display(fieldname, mode, prefix, object, context);\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, BaseObject obj, String wrappingSyntaxId, XWikiContext context)\n    {\n        return display(fieldname, type, \"\", obj, wrappingSyntaxId, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     * @since 13.0\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, boolean isolated,\n        XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj,\n            context.getWiki().getCurrentContentSyntaxId(getSyntaxId(), context), isolated, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        XWikiContext context)\n    {\n        return display(fieldname, type, pref, obj, wrappingSyntaxId, true, context);\n    }\n\n    /**\n     * @param fieldname the name of the field to display\n     * @param type the type of the field to display\n     * @param pref the prefix to add in the field identifier in edit display for example\n     * @param obj the object containing the field to display\n     * @param wrappingSyntaxId the syntax of the content in which the result will be included. This to take care of some\n     *            escaping depending of the syntax.\n     * @param isolated true if the property should be displayed in it's own document context\n     * @param context the XWiki context\n     * @return the rendered field\n     */\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument )context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String prefix = pref + LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference())\n                + \"_\" + obj.getNumber() + \"_\";\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html or { which could be part of an XWiki\n            // macro syntax since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId)\n                && (HTMLUtils.containsElementText(result) || result.indexOf(\"{\") != -1))\n            {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                // Escape closing HTML macro syntax.\n                int startIndex = 0;\n                // Start searching at the last match to avoid scanning the whole string again.\n                while ((startIndex = result.indexOf(CLOSE_HTML_MACRO, startIndex)) != -1) {\n                    result.replace(startIndex, startIndex + 2, \"&#123;&#123;\");\n                }\n                result.append(CLOSE_HTML_MACRO);\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, String header, String format, XWikiContext context)\n    {\n        return displayForm(classReference, header, format, true, context);\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, String, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, String header, String format, XWikiContext context)\n    {\n        return displayForm(className, header, format, true, context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, String header, String format, boolean linebreak,\n        XWikiContext context)\n    {\n        List<BaseObject> objects = getXObjects(classReference);\n        if (format.endsWith(\"\\\\n\")) {\n            linebreak = true;\n        }\n\n        BaseObject firstobject = null;\n        Iterator<BaseObject> foit = objects.iterator();\n        while ((firstobject == null) && foit.hasNext()) {\n            firstobject = foit.next();\n        }\n\n        if (firstobject == null) {\n            return \"\";\n        }\n\n        BaseClass bclass = firstobject.getXClass(context);\n        if (bclass.getPropertyList().size() == 0) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        VelocityContext vcontext;\n        try {\n            vcontext = getVelocityContextFactory().createContext();\n        } catch (XWikiVelocityException e) {\n            LOGGER.error(\"Failed to create a standard VelocityContext\", e);\n\n            vcontext = new XWikiVelocityContext();\n        }\n\n        for (String propertyName : bclass.getPropertyList()) {\n            PropertyClass pclass = (PropertyClass) bclass.getField(propertyName);\n            vcontext.put(pclass.getName(), pclass.getPrettyName());\n        }\n        result.append(evaluate(header, context.getDoc().getPrefixedFullName(), vcontext, context));\n        if (linebreak) {\n            result.append(\"\\n\");\n        }\n\n        // display each line\n        for (int i = 0; i < objects.size(); i++) {\n            vcontext.put(\"id\", Integer.valueOf(i + 1));\n            BaseObject object = objects.get(i);\n            if (object != null) {\n                for (String name : bclass.getPropertyList()) {\n                    vcontext.put(name, display(name, object, context));\n                }\n                result.append(evaluate(format, context.getDoc().getPrefixedFullName(), vcontext, context));\n                if (linebreak) {\n                    result.append(\"\\n\");\n                }\n            }\n        }\n        return result.toString();\n    }\n\n    private String evaluate(String content, String name, VelocityContext vcontext, XWikiContext context)\n    {\n        StringWriter writer = new StringWriter();\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            velocityManager.getVelocityEngine().evaluate(vcontext, writer, name, content);\n            return writer.toString();\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}]\", name, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, String, String, boolean, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, String header, String format, boolean linebreak, XWikiContext context)\n    {\n        return displayForm(resolveClassReference(className), header, format, linebreak, context);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String displayForm(DocumentReference classReference, XWikiContext context)\n    {\n        List<BaseObject> objects = getXObjects(classReference);\n        if (objects == null) {\n            return \"\";\n        }\n\n        BaseObject firstobject = null;\n        Iterator<BaseObject> foit = objects.iterator();\n        while ((firstobject == null) && foit.hasNext()) {\n            firstobject = foit.next();\n        }\n\n        if (firstobject == null) {\n            return \"\";\n        }\n\n        BaseClass bclass = firstobject.getXClass(context);\n        if (bclass.getPropertyList().size() == 0) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        result.append(\"{table}\\n\");\n        boolean first = true;\n        for (String propertyName : bclass.getPropertyList()) {\n            if (first == true) {\n                first = false;\n            } else {\n                result.append(\"|\");\n            }\n            PropertyClass pclass = (PropertyClass) bclass.getField(propertyName);\n            result.append(pclass.getPrettyName());\n        }\n        result.append(\"\\n\");\n        for (int i = 0; i < objects.size(); i++) {\n            BaseObject object = objects.get(i);\n            if (object != null) {\n                first = true;\n                for (String propertyName : bclass.getPropertyList()) {\n                    if (first == true) {\n                        first = false;\n                    } else {\n                        result.append(\"|\");\n                    }\n                    String data = display(propertyName, object, context);\n                    data = data.trim();\n                    data = data.replaceAll(\"\\n\", \" \");\n                    if (data.length() == 0) {\n                        result.append(\"&nbsp;\");\n                    } else {\n                        result.append(data);\n                    }\n                }\n                result.append(\"\\n\");\n            }\n        }\n        result.append(\"{table}\\n\");\n        return result.toString();\n    }\n\n    /**\n     * @deprecated use {@link #displayForm(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String displayForm(String className, XWikiContext context)\n    {\n        return displayForm(resolveClassReference(className), context);\n    }\n\n    public boolean isFromCache()\n    {\n        return this.fromCache;\n    }\n\n    public void setFromCache(boolean fromCache)\n    {\n        this.fromCache = fromCache;\n    }\n\n    public void readDocMetaFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String defaultLanguage = eform.getDefaultLanguage();\n        if (defaultLanguage != null) {\n            setDefaultLanguage(defaultLanguage);\n        }\n\n        String defaultTemplate = eform.getDefaultTemplate();\n        if (defaultTemplate != null) {\n            setDefaultTemplate(defaultTemplate);\n        }\n\n        String creator = eform.getCreator();\n        if ((creator != null) && (!creator.equals(getCreator()))) {\n            if ((getCreatorReference().equals(context.getUserReference()))\n                || (context.getWiki().getRightService().hasAdminRights(context))) {\n                setCreator(creator);\n            }\n        }\n\n        String parent = eform.getParent();\n        if (parent != null) {\n            setParent(parent);\n        }\n\n        // Read the comment from the form\n        String comment = eform.getComment();\n        if (comment != null) {\n            setComment(comment);\n        }\n\n        // Read the minor edit checkbox from the form\n        setMinorEdit(eform.isMinorEdit());\n\n        String tags = eform.getTags();\n        if (!StringUtils.isEmpty(tags)) {\n            setTags(tags, context);\n        }\n\n        // Set the Syntax id if defined\n        String syntaxId = eform.getSyntaxId();\n        if (syntaxId != null) {\n            setSyntax(resolveSyntax(syntaxId));\n        }\n\n        // Read the hidden checkbox from the form\n        if (eform.getHidden() != null) {\n            setHidden(\"1\".equals(eform.getHidden()));\n        }\n    }\n\n    private Syntax resolveSyntax(String syntaxId)\n    {\n        Syntax syntax;\n        try {\n            syntax = getSyntaxRegistry().resolveSyntax(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntax();\n            LOGGER.warn(\"Failed to set syntax [{}] for [{}], setting syntax [{}] instead.\", syntaxId,\n                getDefaultEntityReferenceSerializer().serialize(getDocumentReference()), syntax.toIdString(), e);\n        }\n        return syntax;\n    }\n\n    /**\n     * add tags to the document.\n     */\n    public void setTags(String tagsStr, XWikiContext context) throws XWikiException\n    {\n        BaseClass tagsClass = context.getWiki().getTagClass(context);\n\n        StaticListClass tagProp = (StaticListClass) tagsClass.getField(XWikiConstant.TAG_CLASS_PROP_TAGS);\n\n        BaseObject tags = getObject(XWikiConstant.TAG_CLASS, true, context);\n\n        tags.safeput(XWikiConstant.TAG_CLASS_PROP_TAGS, tagProp.fromString(tagsStr));\n\n        setMetaDataDirty(true);\n    }\n\n    public String getTags(XWikiContext context)\n    {\n        ListProperty prop = (ListProperty) getTagProperty(context);\n\n        // I don't know why we need to XML-escape the list of tags but for backwards compatibility we need to keep doing\n        // this. When this method was added it was using ListProperty#getTextValue() which used to return\n        // ListProperty#toFormString() before we fixed it to return the unescaped value because we need to save the raw\n        // value in the database and ListProperty#getTextValue() is called when the list property is saved.\n        return prop != null ? prop.toFormString() : \"\";\n    }\n\n    public List<String> getTagsList(XWikiContext context)\n    {\n        List<String> tagList = null;\n\n        BaseProperty prop = getTagProperty(context);\n        if (prop != null) {\n            tagList = (List<String>) prop.getValue();\n        }\n\n        return tagList;\n    }\n\n    private BaseProperty getTagProperty(XWikiContext context)\n    {\n        BaseObject tags = getObject(XWikiConstant.TAG_CLASS);\n\n        return tags != null ? ((BaseProperty) tags.safeget(XWikiConstant.TAG_CLASS_PROP_TAGS)) : null;\n    }\n\n    public List<String> getTagsPossibleValues(XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            BaseClass tagsClass = context.getWiki().getTagClass(context);\n\n            String possibleValues =\n                ((StaticListClass) tagsClass.getField(XWikiConstant.TAG_CLASS_PROP_TAGS)).getValues();\n\n            return ListClass.getListFromString(possibleValues);\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to get tag class\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    public void readTranslationMetaFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        String content = eform.getContent();\n        if (content != null) {\n            // Cleanup in case we use HTMLAREA\n            // content = context.getUtil().substitute(\"s/<br class=\\\\\\\"htmlarea\\\\\\\"\\\\/>/\\\\r\\\\n/g\",\n            // content);\n            content = context.getUtil().substitute(\"s/<br class=\\\"htmlarea\\\" \\\\/>/\\r\\n/g\", content);\n            setContent(content);\n        }\n        String title = eform.getTitle();\n        if (title != null) {\n            setTitle(title);\n        }\n    }\n\n    /**\n     * Updates properties of existing objects with the values from the given form.\n     *\n     * @param eform The form to read the values from\n     * @param context The context used for getting the classes of objects\n     * @throws XWikiException On errors\n     */\n    public void readObjectsFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        for (DocumentReference reference : getXObjects().keySet()) {\n            List<BaseObject> oldObjects = getXObjects(reference);\n            BaseObjects newObjects = new BaseObjects();\n            while (newObjects.size() < oldObjects.size()) {\n                newObjects.add(null);\n            }\n            for (int i = 0; i < oldObjects.size(); i++) {\n                BaseObject oldobject = oldObjects.get(i);\n                if (oldobject != null) {\n                    BaseClass baseclass = oldobject.getXClass(context);\n                    BaseObject newobject = (BaseObject) baseclass.fromMap(\n                        eform.getObject(\n                            LOCAL_REFERENCE_SERIALIZER.serialize(baseclass.getDocumentReference()) + \"_\" + i),\n                        oldobject);\n                    newobject.setNumber(oldobject.getNumber());\n                    newobject.setGuid(oldobject.getGuid());\n                    newobject.setOwnerDocument(this);\n                    newObjects.set(newobject.getNumber(), newobject);\n                }\n            }\n            getXObjects().put(reference, newObjects);\n        }\n    }\n\n    /**\n     * Create and/or update objects in a document given a list of HTTP parameters of the form {@code\n     * <spacename>.<classname>_<number>_<propertyname>}. If the object already exists, the field is replaced by the\n     * given value. If the object doesn't exist in the document, it is created and the property {@code <propertyname>}\n     * is initialized with the given value.\n     *\n     * @param eform is form information that contains all the query parameters\n     * @param context\n     * @throws XWikiException\n     * @since 7.1M1\n     */\n    public void readObjectsFromFormUpdateOrCreate(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        Map<String, SortedMap<Integer, Map<String, String[]>>> updateOrCreateMap = eform.getUpdateOrCreateMap();\n        for (Entry<String, SortedMap<Integer, Map<String, String[]>>> requestClassEntries : updateOrCreateMap\n            .entrySet()) {\n            String className = requestClassEntries.getKey();\n            DocumentReference requestClassReference = getCurrentDocumentReferenceResolver().resolve(className);\n\n            SortedMap<Integer, Map<String, String[]>> requestObjectMap = requestClassEntries.getValue();\n            for (Entry<Integer, Map<String, String[]>> requestObjectEntry : requestObjectMap.entrySet()) {\n                Integer requestObjectNumber = requestObjectEntry.getKey();\n                Map<String, String[]> requestObjectPropertyMap = requestObjectEntry.getValue();\n                List<String> properties = new ArrayList<>(requestObjectPropertyMap.keySet());\n                try {\n                    BaseClass xClass = context.getWiki().getDocument(requestClassReference, context).getXClass();\n\n                    // clean-up the properties that do not belong to the xclass\n                    for (String property : properties) {\n                        if (!xClass.getPropertyList().contains(property)) {\n                            requestObjectPropertyMap.remove(property);\n                        }\n                    }\n                } catch (XWikiException e) {\n                    // If the class page cannot be found, skip entirely the property update\n                    LOGGER.warn(\"Failed to load document [{}], ignoring properties update [{}]. Reason: [{}]\",\n                        requestClassReference, StringUtils.join(properties, \",\"),\n                        ExceptionUtils.getRootCauseMessage(e));\n                    continue;\n                }\n\n                if (!requestObjectPropertyMap.isEmpty()) {\n                    BaseObject oldObject = getXObject(requestClassReference, requestObjectNumber, true, context);\n                    BaseClass baseClass = oldObject.getXClass(context);\n                    BaseObject newObject = (BaseObject) baseClass.fromMap(requestObjectPropertyMap, oldObject);\n                    newObject.setNumber(oldObject.getNumber());\n                    newObject.setGuid(oldObject.getGuid());\n                    newObject.setOwnerDocument(this);\n                    setXObject(requestObjectNumber, newObject);\n                }\n            }\n        }\n    }\n\n    public void readFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        readDocMetaFromForm(eform, context);\n        readTranslationMetaFromForm(eform, context);\n\n        readAddedUpdatedAndRemovedObjectsFromForm(eform, context);\n        readTemporaryUploadedFiles(eform);\n    }\n\n    private TemporaryAttachmentSessionsManager getTemporaryAttachmentManager()\n    {\n        return Utils.getComponent(TemporaryAttachmentSessionsManager.class);\n    }\n\n    /**\n     * Read the list of attachment that should be added from {@link EditForm#getTemporaryUploadedFiles()} and attach\n     * them to the current document if they can be found in the {@link TemporaryAttachmentSessionsManager}.\n     *\n     * @param editForm the form from which to read the list of files.\n     * @since 14.3RC1\n     */\n    @Unstable\n    public void readTemporaryUploadedFiles(EditForm editForm)\n    {\n        getTemporaryAttachmentManager().attachTemporaryAttachmentsInDocument(this, editForm.getTemporaryUploadedFiles());\n    }\n\n    /**\n     * Adds objects, applies property updates and removes objects as specified in the form.\n     *\n     * @param eform The form from which the values shall be read.\n     * @param context The XWiki context.\n     * @throws XWikiException If an error occurs.\n     * @since 14.0RC1\n     */\n    @Unstable\n    public void readAddedUpdatedAndRemovedObjectsFromForm(EditForm eform, XWikiContext context) throws XWikiException\n    {\n        // We add the new objects that have been submitted in the form, before filling them with their values.\n        Map<String, List<Integer>> objectsToAdd = eform.getObjectsToAdd();\n        for (String className : objectsToAdd.keySet()) {\n            DocumentReference classReference = resolveClassReference(className);\n            List<Integer> classIds = objectsToAdd.get(className);\n            for (Integer classId : classIds) {\n                // we ensure that the object has not been added yet, for example because of the update or create.\n                getXObject(classReference, classId, true, context);\n            }\n        }\n\n        ObjectPolicyType objectPolicy = eform.getObjectPolicy();\n        if (objectPolicy == null || objectPolicy.equals(ObjectPolicyType.UPDATE)) {\n            readObjectsFromForm(eform, context);\n        } else if (objectPolicy.equals(ObjectPolicyType.UPDATE_OR_CREATE)) {\n            readObjectsFromFormUpdateOrCreate(eform, context);\n        }\n\n        // remove xobjects\n        Map<String, List<Integer>> objectsToRemove = eform.getObjectsToRemove();\n        for (String className : objectsToRemove.keySet()) {\n            DocumentReference classReference = resolveClassReference(className);\n            List<Integer> classIds = objectsToRemove.get(className);\n            for (Integer classId : classIds) {\n                BaseObject xObject = getXObject(classReference, classId);\n                if (xObject != null) {\n                    removeXObject(xObject);\n                }\n            }\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void readFromTemplate(DocumentReference templateDocumentReference, XWikiContext context)\n        throws XWikiException\n    {\n        if (templateDocumentReference != null) {\n            String content = getContent();\n            if (!content.equals(\"\\n\") && !content.equals(\"\") && !isNew()) {\n                Object[] args = { getDefaultEntityReferenceSerializer().serialize(getDocumentReference()) };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY,\n                    \"Cannot add a template to document {0} because it already has content\", null, args);\n            } else {\n                XWiki xwiki = context.getWiki();\n                XWikiDocument templatedoc = xwiki.getDocument(templateDocumentReference, context);\n                if (templatedoc.isNew()) {\n                    Object[] args = { getDefaultEntityReferenceSerializer().serialize(templateDocumentReference),\n                    getCompactEntityReferenceSerializer().serialize(getDocumentReference()) };\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                        XWikiException.ERROR_XWIKI_APP_TEMPLATE_DOES_NOT_EXIST,\n                        \"Template document {0} does not exist when adding to document {1}\", null, args);\n                } else {\n                    setTemplateDocumentReference(templateDocumentReference);\n                    setTitle(templatedoc.getTitle());\n                    setContent(templatedoc.getContent());\n\n                    // Set the new document syntax as the syntax of the template since the template content\n                    // is copied into the new document\n                    setSyntax(templatedoc.getSyntax());\n\n                    // If the parent is not set in the current document set the template parent as the parent.\n                    if (getParentReference() == null) {\n                        setParentReference(templatedoc.getRelativeParentReference());\n                    }\n\n                    if (isNew()) {\n                        // We might have received the objects from the cache and the template objects might have been\n                        // copied already we need to remove them\n                        setXObjects(new TreeMap<DocumentReference, List<BaseObject>>());\n                    }\n                    // Merge the external objects.\n                    // Currently the choice is not to merge the base class and object because it is not the preferred\n                    // way of using external classes and objects.\n                    mergeXObjects(templatedoc);\n\n                    // Copy the attachments from the template document, but don't overwrite existing attachments because\n                    // the user can add attachments from the WYSIWYG editor before the save button is clicked (and thus\n                    // before the template is applied).\n                    copyAttachments(templatedoc, false);\n                }\n            }\n        }\n    }\n\n    /**\n     * Use the document passed as parameter as the new identity for the current document.\n     *\n     * @param document the document containing the new identity\n     */\n    public void clone(XWikiDocument document)\n    {\n        this.id = document.id;\n\n        setDocumentReference(document.getDocumentReference());\n        setRCSVersion(document.getRCSVersion());\n        setDocumentArchive(document.getDocumentArchive());\n        setAuthorReference(document.getAuthorReference());\n        setContentAuthorReference(document.getContentAuthorReference());\n        setContent(document.getContent());\n        setCreationDate(document.getCreationDate());\n        setDate(document.getDate());\n        setCustomClass(document.getCustomClass());\n        setContentUpdateDate(document.getContentUpdateDate());\n        setTitle(document.getTitle());\n        setFormat(document.getFormat());\n        setFromCache(document.isFromCache());\n        setElements(document.getElements());\n        setMeta(document.getMeta());\n        setMostRecent(document.isMostRecent());\n        setNew(document.isNew());\n        setStore(document.getStore());\n        setTemplateDocumentReference(document.getTemplateDocumentReference());\n        setParentReference(document.getRelativeParentReference());\n        setCreatorReference(document.getCreatorReference());\n        setDefaultLocale(document.getDefaultLocale());\n        setDefaultTemplate(document.getDefaultTemplate());\n        setValidationScript(document.getValidationScript());\n        setLocale(document.getLocale());\n        setXClass(document.getXClass().clone());\n        setXClassXML(document.getXClassXML());\n        setComment(document.getComment());\n        setMinorEdit(document.isMinorEdit());\n        setSyntax(document.getSyntax());\n        setHidden(document.isHidden());\n\n        cloneXObjects(document);\n        cloneAttachments(document);\n\n        setContentDirty(document.isContentDirty());\n        setMetaDataDirty(document.isMetaDataDirty());\n\n        this.elements = document.elements;\n\n        this.originalDocument = document.originalDocument;\n    }\n\n    @Override\n    public XWikiDocument clone()\n    {\n        return cloneInternal(getDocumentReference(), true, false);\n    }\n\n    /**\n     * Duplicate this document and give it a new name.\n     *\n     * @since 2.2.3\n     */\n    public XWikiDocument duplicate(DocumentReference newDocumentReference)\n    {\n        return cloneInternal(newDocumentReference, false, false);\n    }\n\n    private void cloneDocumentArchive(XWikiDocument originalDocument) throws XWikiException\n    {\n        XWikiDocumentArchive documentArchive = originalDocument.getDocumentArchive();\n        if (documentArchive != null) {\n            this.setDocumentArchive(documentArchive.clone(this.getId(), getXWikiContext()));\n        }\n    }\n\n    private XWikiDocument cloneInternal(DocumentReference newDocumentReference,\n        boolean keepsIdentity,\n        boolean cloneArchive)\n    {\n        XWikiDocument doc = null;\n\n        try {\n            Constructor<? extends XWikiDocument> constructor = getClass().getConstructor(DocumentReference.class);\n            doc = constructor.newInstance(newDocumentReference);\n\n            // Make sure the coordinate of the document is fully accurate before any other manipulation\n            doc.setLocale(getLocale());\n\n            // use version field instead of getRCSVersion because it returns \"1.1\" if version==null.\n            doc.version = this.version;\n            doc.id = this.id;\n            if (cloneArchive) {\n                doc.cloneDocumentArchive(this);\n            } else {\n                // Without this explicit initialization, it is possible for the archive to be incorrectly initialized.\n                // For instance, with the archive of the cloned document.\n                // Here we guarantee that further calls of APIs to get the archive will properly populate the data.\n                doc.setDocumentArchive((XWikiDocumentArchive) null);\n            }\n            doc.getAuthors().copyAuthors(getAuthors());\n            doc.setContent(getContent());\n            doc.setCreationDate(getCreationDate());\n            doc.setDate(getDate());\n            doc.setCustomClass(getCustomClass());\n            doc.setContentUpdateDate(getContentUpdateDate());\n            doc.setTitle(getTitle());\n            doc.setFormat(getFormat());\n            doc.setFromCache(isFromCache());\n            doc.setElements(getElements());\n            doc.setMeta(getMeta());\n            doc.setMostRecent(isMostRecent());\n            doc.setNew(isNew());\n            doc.setStore(getStore());\n            doc.setTemplateDocumentReference(getTemplateDocumentReference());\n            doc.setParentReference(getRelativeParentReference());\n            doc.setDefaultLocale(getDefaultLocale());\n            doc.setDefaultTemplate(getDefaultTemplate());\n            doc.setValidationScript(getValidationScript());\n            doc.setComment(getComment());\n            doc.setMinorEdit(isMinorEdit());\n            doc.setSyntax(getSyntax());\n            doc.setHidden(isHidden());\n            doc.setRestricted(isRestricted());\n\n            if (this.xClass != null) {\n                doc.setXClass(this.xClass.clone());\n            }\n\n            if (keepsIdentity) {\n                doc.setXClassXML(getXClassXML());\n                doc.cloneXObjects(this);\n                doc.cloneAttachments(this);\n            } else {\n                doc.getXClass().setCustomMapping(null);\n                doc.duplicateXObjects(this);\n                doc.copyAttachments(this);\n            }\n\n            doc.setContentDirty(isContentDirty());\n            doc.setMetaDataDirty(isMetaDataDirty());\n\n            doc.elements = this.elements;\n\n            doc.originalDocument = this.originalDocument;\n        } catch (Exception e) {\n            // This should not happen\n            LOGGER.error(\"Exception while cloning document\", e);\n        }\n        return doc;\n    }\n\n    /**\n     * Clone attachments from another document. This implementation expects that this document is the same as the other\n     * document and thus attachments will be saved in the database in the same place as the ones which they are cloning.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     */\n    private void cloneAttachments(final XWikiDocument sourceDocument)\n    {\n        this.getAttachmentList().clear();\n        for (XWikiAttachment attach : sourceDocument.getAttachmentList()) {\n            XWikiAttachment newAttach = (XWikiAttachment) attach.clone();\n\n            setAttachment(newAttach);\n        }\n    }\n\n    /**\n     * Copy attachments from one document to another. This implementation expects that you are copying the attachment\n     * from one document to another and thus it should be saved separately from the original in the database.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     */\n    public void copyAttachments(XWikiDocument sourceDocument)\n    {\n        copyAttachments(sourceDocument, true);\n    }\n\n    /**\n     * Copy attachments from one document to another. This implementation expects that you are copying the attachment\n     * from one document to another and thus it should be saved separately from the original in the database.\n     *\n     * @param sourceDocument an XWikiDocument to copy attachments from\n     * @param overwrite whether to overwrite the existing attachments or not\n     * @since 8.4.6\n     * @since 9.6RC1\n     */\n    private void copyAttachments(XWikiDocument sourceDocument, boolean overwrite)\n    {\n        if (overwrite) {\n            // Note: when clearing the attachment list, we automatically mark the document's metadata as dirty.\n            getAttachmentList().clear();\n        }\n\n        for (XWikiAttachment attachment : sourceDocument.getAttachmentList()) {\n            if (overwrite || this.getAttachment(attachment.getFilename()) == null) {\n                try {\n                    copyAttachment(attachment, true);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"Cannot copy attachment [{}] from [{}] to [{}]. Root cause is [{}].\",\n                        attachment.getFilename(), sourceDocument.getDocumentReference(), this.getDocumentReference(),\n                        ExceptionUtils.getRootCauseMessage(e));\n                    // Skip this attachment because we cannot load its content.\n                    continue;\n                }\n            }\n        }\n    }\n\n    /**\n     * Copies the given attachment to this document.\n     * \n     * @param attachment the source attachment to be copied to this document\n     * @param reset whether to reset or not the attachment meta data that is specific to the source (version, author,\n     *            date)\n     * @throws XWikiException if loading the content of the given attachment fails\n     */\n    private void copyAttachment(XWikiAttachment attachment, boolean reset) throws XWikiException\n    {\n        XWikiContext xcontext = getXWikiContext();\n        XWikiAttachment newAttachment = attachment.clone();\n\n        // Make sure we copy the attachment content also, not just its meta data. For this we need to load\n        // the attachment content from the source document. Note that the owner document will be overwritten\n        // below when we call setAttachment().\n        newAttachment.setDoc(attachment.getDoc(), false);\n        newAttachment.loadAttachmentContent(xcontext);\n        // We need to set the content of the attachment to be dirty because the dirty bit is used to signal\n        // that there is a reason to save the copied attachment, otherwise the copied attachment will be\n        // empty since the original attachment content is not modified in this operation.\n        newAttachment.getAttachment_content().setContentDirty(true);\n\n        if (reset) {\n            // Reset the meta data that is specific to the original attachment (version, author, date).\n            newAttachment.setRCSVersion(null);\n            newAttachment.setAuthorReference(xcontext.getUserReference());\n            newAttachment.setDate(new Date());\n        }\n\n        // Add the attachment copy to the list of attachments of this document.\n        setAttachment(newAttachment);\n    }\n\n    /**\n     * Load attachment content from database.\n     *\n     * @param context the XWiki context\n     * @throws XWikiException when failing to load attachments\n     * @since 5.3M2\n     */\n    public void loadAttachmentsContent(XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            attachment.loadAttachmentContent(context);\n        }\n    }\n\n    /**\n     * Same as {@link #loadAttachmentContent(XWikiAttachment, XWikiContext)} but in some context we don't really care if\n     * an attachment content could not be loaded (we are going to overwrite or ignore it).\n     * \n     * @param context the XWiki context\n     * @since 10.1RC1\n     */\n    public void loadAttachmentsContentSafe(XWikiContext context)\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            try {\n                attachment.loadAttachmentContent(context);\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Failed to load attachment [{}]: {}\", attachment.getReference(),\n                    ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n    }\n\n    public void loadAttachments(XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : getAttachmentList()) {\n            attachment.loadAttachmentContent(context);\n            attachment.loadArchive(context);\n        }\n    }\n\n    /**\n     * Indicates whether some other document is \"equal to\" this one.\n     * <p>\n     * This ignores the {@link #isRestricted()} property as it is not considered to be part of the data.\n     *\n     * @param object the document to compare to\n     * @return {@code true} if this document is the same as the object argument; {@code false} otherwise\n     */\n    @Override\n    public boolean equals(Object object)\n    {\n        // Same Java object, they sure are equal\n        if (this == object) {\n            return true;\n        }\n\n        // Reference/language (document identifier)\n\n        XWikiDocument doc = (XWikiDocument) object;\n        if (!getDocumentReference().equals(doc.getDocumentReference())) {\n            return false;\n        }\n\n        if (!getDefaultLocale().equals(doc.getDefaultLocale())) {\n            return false;\n        }\n\n        if (!getLocale().equals(doc.getLocale())) {\n            return false;\n        }\n\n        if (getTranslation() != doc.getTranslation()) {\n            return false;\n        }\n\n        // Authors\n\n        if (ObjectUtils.notEqual(getAuthorReference(), doc.getAuthorReference())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getContentAuthorReference(), doc.getContentAuthorReference())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getCreatorReference(), doc.getCreatorReference())) {\n            return false;\n        }\n\n        // Version\n\n        if (!getVersion().equals(doc.getVersion())) {\n            return false;\n        }\n\n        if (getDate().getTime() != doc.getDate().getTime()) {\n            return false;\n        }\n\n        if (getContentUpdateDate().getTime() != doc.getContentUpdateDate().getTime()) {\n            return false;\n        }\n\n        if (getCreationDate().getTime() != doc.getCreationDate().getTime()) {\n            return false;\n        }\n\n        if (!getComment().equals(doc.getComment())) {\n            return false;\n        }\n\n        if (isMinorEdit() != doc.isMinorEdit()) {\n            return false;\n        }\n\n        // Datas\n\n        if (!equalsData(doc)) {\n            return false;\n        }\n\n        // We consider that 2 documents are still equal even when they have different original\n        // documents (see getOriginalDocument() for more details as to what is an original\n        // document).\n\n        return true;\n    }\n\n    /**\n     * Same as {@link #equals(Object)} but only for actual datas of the document.\n     * <p>\n     * The goal being to compare two versions of the same document this method skip every version/reference/author\n     * related information. For example it allows to compare a document comming from a another wiki and easily check if\n     * thoses actually are the same thing whatever the plumbing differences.\n     *\n     * @param otherDocument the document to compare\n     * @return true if bith documents have the same datas\n     * @since 4.1.1\n     */\n    public boolean equalsData(XWikiDocument otherDocument)\n    {\n        // Same Java object, they sure are equal\n        if (this == otherDocument) {\n            return true;\n        }\n\n        if (ObjectUtils.notEqual(getParentReference(), otherDocument.getParentReference())) {\n            return false;\n        }\n\n        if (!getFormat().equals(otherDocument.getFormat())) {\n            return false;\n        }\n\n        if (!getTitle().equals(otherDocument.getTitle())) {\n            return false;\n        }\n\n        if (!getContent().equals(otherDocument.getContent())) {\n            return false;\n        }\n\n        if (!getDefaultTemplate().equals(otherDocument.getDefaultTemplate())) {\n            return false;\n        }\n\n        if (!getValidationScript().equals(otherDocument.getValidationScript())) {\n            return false;\n        }\n\n        if (ObjectUtils.notEqual(getSyntax(), otherDocument.getSyntax())) {\n            return false;\n        }\n\n        if (isHidden() != otherDocument.isHidden()) {\n            return false;\n        }\n\n        // XClass\n\n        if (!getXClass().equals(otherDocument.getXClass())) {\n            return false;\n        }\n\n        // XObjects\n\n        Set<DocumentReference> myObjectClassReferences = getXObjects().keySet();\n        Set<DocumentReference> otherObjectClassReferences = otherDocument.getXObjects().keySet();\n        if (!myObjectClassReferences.equals(otherObjectClassReferences)) {\n            return false;\n        }\n\n        for (DocumentReference reference : myObjectClassReferences) {\n            List<BaseObject> myObjects = getXObjects(reference);\n            List<BaseObject> otherObjects = otherDocument.getXObjects(reference);\n            if (myObjects.size() != otherObjects.size()) {\n                return false;\n            }\n            for (int i = 0; i < myObjects.size(); i++) {\n                if ((myObjects.get(i) == null && otherObjects.get(i) != null)\n                    || (myObjects.get(i) != null && otherObjects.get(i) == null)) {\n                    return false;\n                }\n                if (myObjects.get(i) == null && otherObjects.get(i) == null) {\n                    continue;\n                }\n                if (!myObjects.get(i).equals(otherObjects.get(i))) {\n                    return false;\n                }\n            }\n        }\n\n        // Attachments\n        List<XWikiAttachment> attachments = getAttachmentList();\n        List<XWikiAttachment> otherAttachments = otherDocument.getAttachmentList();\n        if (attachments.size() != otherAttachments.size()) {\n            return false;\n        }\n        for (XWikiAttachment attachment : attachments) {\n            XWikiAttachment otherAttachment = otherDocument.getAttachment(attachment.getFilename());\n            try {\n                if (otherAttachment == null || !attachment.equalsData(otherAttachment, null)) {\n                    return false;\n                }\n            } catch (XWikiException e) {\n                throw new RuntimeException(\n                    String.format(\"Failed to compare attachments with reference [%s]\", attachment.getReference()), e);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Retrieve the document in the current context language as an XML string. The rendrered document content and all\n     * XObjects are included. Document attachments and archived versions are excluded. You should prefer\n     * toXML(OutputStream, true, true, false, false, XWikiContext)} or toXML(com.xpn.xwiki.util.XMLWriter, true, true,\n     * false, false, XWikiContext) on the translated document when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document in the current context language\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String getXMLContent(XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = getTranslatedDocument(context);\n        return tdoc.toXML(true, true, false, false, context);\n    }\n\n    /**\n     * Retrieve the document as an XML string. All XObject are included. Rendered content, attachments and archived\n     * version are excluded. You should prefer toXML(OutputStream, true, false, false, false, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, false, false, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String toXML(XWikiContext context) throws XWikiException\n    {\n        return toXML(true, false, false, false, context);\n    }\n\n    /**\n     * Retrieve the document as an XML string. All XObjects attachments and archived version are included. Rendered\n     * content is excluded. You should prefer toXML(OutputStream, true, false, true, true, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, true, true, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an error occurs during wiki operation\n     */\n    public String toFullXML(XWikiContext context) throws XWikiException\n    {\n        return toXML(true, false, true, true, context);\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. All XObjects and attachments are\n     * included. Rendered content is excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param zipname the name of the new entry to create\n     * @param withVersions if true, also include archived version of the document\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.1M2\")\n    public void addToZip(ZipOutputStream zos, String zipname, boolean withVersions, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        ZipEntry zipentry = new ZipEntry(zipname);\n        zos.putNextEntry(zipentry);\n        toXML(zos, true, false, true, withVersions, context);\n        zos.closeEntry();\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. The new entry is named\n     * 'LastSpaceName/DocumentName'. All XObjects and attachments are included. Rendered content is excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param withVersions if true, also include archived version of the document\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.2M2\")\n    public void addToZip(ZipOutputStream zos, boolean withVersions, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        String zipname =\n            getDocumentReference().getLastSpaceReference().getName() + \"/\" + getDocumentReference().getName();\n        String language = getLanguage();\n        if (!StringUtils.isEmpty(language)) {\n            zipname += \".\" + language;\n        }\n        addToZip(zos, zipname, withVersions, context);\n    }\n\n    /**\n     * Serialize the document into a new entry of an ZipOutputStream in XML format. The new entry is named\n     * 'LastSpaceName/DocumentName'. All XObjects, attachments and archived versions are included. Rendered content is\n     * excluded.\n     *\n     * @param zos the ZipOutputStream to write to\n     * @param context current XWikiContext\n     * @throws XWikiException when an error occurs during xwiki operations\n     * @throws IOException when an error occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated\n     */\n    @Deprecated(since = \"4.1M2\")\n    public void addToZip(ZipOutputStream zos, XWikiContext context) throws XWikiException, IOException\n    {\n        addToZip(zos, true, context);\n    }\n\n    /**\n     * Serialize the document to an XML string. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to reduce memory load.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @return a string containing an XML representation of the document\n     * @throws XWikiException when an errors occurs during wiki operations\n     */\n    public String toXML(boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException\n    {\n        StringWriter writer = new StringWriter();\n\n        toXML(new DefaultWriterOutputTarget(writer), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n\n        return writer.toString();\n    }\n\n    /**\n     * Serialize the document to an XML {@link DOMDocument}. All XObject are included. Rendered content, attachments and\n     * archived version are excluded. You should prefer toXML(OutputStream, true, false, false, false, XWikiContext)} or\n     * toXML(com.xpn.xwiki.util.XMLWriter, true, false, false, false, XWikiContext) when possible to reduce memory load.\n     *\n     * @param context current XWikiContext\n     * @return a {@link DOMDocument} containing the serialized document.\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public Document toXMLDocument(XWikiContext context) throws XWikiException\n    {\n        return toXMLDocument(true, false, false, false, context);\n    }\n\n    /**\n     * Serialize the document to an XML {@link DOMDocument}. You should prefer\n     * {@link #toXML(OutputStream, boolean, boolean, boolean, boolean, XWikiContext)} or\n     * {@link #toXML(com.xpn.xwiki.internal.xml.XMLWriter, boolean, boolean, boolean, boolean, XWikiContext)} when\n     * possible to reduce memory load.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @return a {@link DOMDocument} containing the serialized document.\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public Document toXMLDocument(boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException\n    {\n        Document doc = new DOMDocument();\n        DOMXMLWriter wr = new DOMXMLWriter(doc, new OutputFormat(\"\", true, context.getWiki().getEncoding()));\n\n        try {\n            toXML(wr, bWithObjects, bWithRendering, bWithAttachmentContent, bWithVersions, context);\n            return doc;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Serialize the document to a {@link com.xpn.xwiki.internal.xml.XMLWriter}.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @throws IOException when an errors occurs during streaming operations\n     * @since 2.3M2\n     * @deprecated use {@link #toXML(OutputTarget, boolean, boolean, boolean, boolean, boolean, String)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public void toXML(XMLWriter wr, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException, IOException\n    {\n        // IMPORTANT: we don't use directly XMLWriter's SAX apis here because it's not really working well\n        DocumentResult domResult = new DocumentResult();\n\n        toXML(new DefaultResultOutputTarget(domResult), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n\n        wr.write(domResult.getDocument().getRootElement());\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param context current XWikiContext\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @throws IOException when an errors occurs during streaming operations\n     * @since 2.3M2\n     */\n    public void toXML(OutputStream out, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, XWikiContext context) throws XWikiException, IOException\n    {\n        toXML(new DefaultOutputStreamOutputTarget(out), bWithObjects, bWithRendering, bWithAttachmentContent,\n            bWithVersions, true, context != null ? context.getWiki().getEncoding() : StandardCharsets.UTF_8.name());\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param out the output where to write the XML\n     * @param bWithObjects include XObjects\n     * @param bWithRendering include the rendered content\n     * @param bWithAttachmentContent include attachments content\n     * @param bWithVersions include archived versions\n     * @param format true if the XML should be formated\n     * @param encoding the encoding to use to write the XML\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @since 9.0RC1\n     */\n    public void toXML(OutputTarget out, boolean bWithObjects, boolean bWithRendering, boolean bWithAttachmentContent,\n        boolean bWithVersions, boolean format, String encoding) throws XWikiException\n    {\n        // Input\n        DocumentInstanceInputProperties documentProperties = new DocumentInstanceInputProperties();\n        documentProperties.setWithWikiObjects(bWithObjects);\n        documentProperties.setWithWikiDocumentContentHTML(bWithRendering);\n        documentProperties.setWithWikiAttachmentsContent(bWithAttachmentContent);\n        documentProperties.setWithJRCSRevisions(bWithVersions);\n        documentProperties.setWithRevisions(false);\n\n        // Output\n        XAROutputProperties xarProperties = new XAROutputProperties();\n        xarProperties.setPreserveVersion(bWithVersions);\n        xarProperties.setEncoding(encoding);\n        xarProperties.setFormat(format);\n        xarProperties.setTarget(out);\n\n        toXML(documentProperties, xarProperties);\n    }\n\n    /**\n     * Serialize the document to an OutputStream.\n     *\n     * @param xarProperties the configuration of the output filter\n     * @param documentProperties the configuration of the input filter\n     * @throws XWikiException when an errors occurs during wiki operations\n     * @since 13.8RC1\n     */\n    public void toXML(DocumentInstanceInputProperties documentProperties, XAROutputProperties xarProperties)\n        throws XWikiException\n    {\n        try {\n            Utils.getComponent(XWikiDocumentFilterUtils.class).exportEntity(this, xarProperties.getTarget(),\n                xarProperties, documentProperties);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_XWIKI_DOC_EXPORT,\n                \"Error serializing XML\", e, null);\n        }\n    }\n\n    protected String encodedXMLStringAsUTF8(String xmlString)\n    {\n        if (xmlString == null) {\n            return \"\";\n        }\n\n        int length = xmlString.length();\n        char character;\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            character = xmlString.charAt(i);\n            switch (character) {\n                case '&':\n                    result.append(\"&amp;\");\n                    break;\n                case '\"':\n                    result.append(\"&quot;\");\n                    break;\n                case '<':\n                    result.append(\"&lt;\");\n                    break;\n                case '>':\n                    result.append(\"&gt;\");\n                    break;\n                case '\\n':\n                    result.append(\"\\n\");\n                    break;\n                case '\\r':\n                    result.append(\"\\r\");\n                    break;\n                case '\\t':\n                    result.append(\"\\t\");\n                    break;\n                default:\n                    if (character < 0x20) {\n                    } else if (character > 0x7F) {\n                        result.append(\"&#x\");\n                        result.append(Integer.toHexString(character).toUpperCase());\n                        result.append(\";\");\n                    } else {\n                        result.append(character);\n                    }\n                    break;\n            }\n        }\n\n        return result.toString();\n    }\n\n    protected String getElement(Element docel, String name)\n    {\n        Element el = docel.element(name);\n        if (el == null) {\n            return \"\";\n        } else {\n            return el.getText();\n        }\n    }\n\n    public void fromXML(String xml) throws XWikiException\n    {\n        fromXML(xml, false);\n    }\n\n    public void fromXML(InputStream is) throws XWikiException\n    {\n        fromXML(is, false);\n    }\n\n    public void fromXML(InputSource source, boolean withArchive) throws XWikiException\n    {\n        // Output\n        DocumentInstanceOutputProperties documentProperties = new DocumentInstanceOutputProperties();\n        XWikiContext xcontext = getXWikiContext();\n        if (xcontext != null) {\n            documentProperties.setDefaultReference(getXWikiContext().getWikiReference());\n        }\n\n        // Input\n        XARInputProperties xarProperties = new XARInputProperties();\n        xarProperties.setWithHistory(withArchive);\n\n        try {\n            Utils.getComponent(XWikiDocumentFilterUtils.class).importEntity(XWikiDocument.class, this, source,\n                xarProperties, documentProperties);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error parsing xml\", e, null);\n        }\n\n        // We have been reading from XML so the document does not need a new version when saved\n        setMetaDataDirty(false);\n        setContentDirty(false);\n    }\n\n    public void fromXML(String source, boolean withArchive) throws XWikiException\n    {\n        fromXML(new StringInputSource(source), withArchive);\n    }\n\n    public void fromXML(InputStream source, boolean withArchive) throws XWikiException\n    {\n        fromXML(new DefaultInputStreamInputSource(source), withArchive);\n    }\n\n    /**\n     * @deprecated use {@link #fromXML(InputStream)} instead\n     */\n    @Deprecated(since = \"9.0RC1\")\n    public void fromXML(Document domdoc, boolean withArchive) throws XWikiException\n    {\n        // Serialize the Document (could not find a way to convert a dom4j Document into a usable StAX source)\n        StringWriter writer = new StringWriter();\n        try {\n            org.dom4j.io.XMLWriter domWriter = new org.dom4j.io.XMLWriter(writer);\n            domWriter.write(domdoc);\n            domWriter.flush();\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error parsing xml\", e, null);\n        }\n\n        // Actually parse the XML\n        fromXML(writer.toString(), withArchive);\n    }\n\n    /**\n     * Check if provided xml document is a wiki document.\n     *\n     * @param domdoc the xml document.\n     * @return true if provided xml document is a wiki document.\n     */\n    public static boolean containsXMLWikiDocument(Document domdoc)\n    {\n        return domdoc.getRootElement().getName().equals(XarDocumentModel.ELEMENT_DOCUMENT);\n    }\n\n    public void setAttachmentList(List<XWikiAttachment> list)\n    {\n        // For backwards compatibility reasons (and in general), we need to allow callers to do something like\n        // setAttachmentList(getAttachmentList())\n        if (this.attachmentList != list) {\n            this.attachmentList.clear();\n            this.attachmentList.addAll(list);\n        }\n    }\n\n    public List<XWikiAttachment> getAttachmentList()\n    {\n        return this.attachmentList;\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAllAttachments(XWikiContext context) throws XWikiException\n    {\n        saveAllAttachments(true, true, context);\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAllAttachments(boolean updateParent, boolean transaction, XWikiContext context)\n        throws XWikiException\n    {\n        for (XWikiAttachment attachment : this.attachmentList) {\n            saveAttachmentContent(attachment, false, transaction, context);\n        }\n\n        // Save the document\n        if (updateParent) {\n            context.getWiki().saveDocument(this, context);\n        }\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentsContent(List<XWikiAttachment> attachments, XWikiContext context) throws XWikiException\n    {\n        for (XWikiAttachment attachment : attachments) {\n            saveAttachmentContent(attachment, context);\n        }\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentContent(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        saveAttachmentContent(attachment, true, true, context);\n    }\n\n    /**\n     * @deprecated should not be used, save the document instead\n     */\n    @Deprecated\n    public void saveAttachmentContent(XWikiAttachment attachment, boolean updateParent, boolean transaction,\n        XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            // We might need to switch database to\n            // get the translated content\n            if (getDatabase() != null) {\n                context.setWikiId(getDatabase());\n            }\n\n            // Save the attachment\n            XWikiAttachmentStoreInterface store =\n                resolveXWikiAttachmentStoreInterface(attachment.getContentStore(), context);\n            store.saveAttachmentContent(attachment, false, context, transaction);\n\n            // We need to make sure there is a version upgrade\n            setMetaDataDirty(true);\n\n            // Save the document\n            if (updateParent) {\n                context.getWiki().saveDocument(this, context);\n            }\n        } catch (OutOfMemoryError e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_JAVA_HEAP_SPACE,\n                \"Out Of Memory Exception\");\n        } finally {\n            if (currentWiki != null) {\n                context.setWikiId(currentWiki);\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link XWikiAttachment#loadContent(XWikiContext)}\n     */\n    @Deprecated(since = \"9.9RC1\")\n    public void loadAttachmentContent(XWikiAttachment attachment, XWikiContext context) throws XWikiException\n    {\n        String database = context.getWikiId();\n        try {\n            // We might need to switch database to\n            // get the translated content\n            if (getDatabase() != null) {\n                context.setWikiId(getDatabase());\n            }\n\n            attachment.loadAttachmentContent(context);\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n        }\n    }\n\n    /**\n     * Remove the attachment from the document attachment list and put it in the list of attachments to remove for next\n     * document save.\n     * <p>\n     * The attachment will be move to recycle bin.\n     *\n     * @param attachment the attachment to remove\n     * @return the removed attachment, null if none could be found\n     * @since 5.2M1\n     */\n    public XWikiAttachment removeAttachment(XWikiAttachment attachment)\n    {\n        return removeAttachment(attachment, true);\n    }\n\n    /**\n     * Remove the attachment from the document attachment list and put it in the list of attachments to remove for next\n     * document save.\n     *\n     * @param attachmentToRemove the attachment to remove\n     * @param toRecycleBin indicate if the attachment should be moved to recycle bin\n     * @return the removed attachment, null if none could be found\n     * @since 5.2M1\n     */\n    public XWikiAttachment removeAttachment(XWikiAttachment attachmentToRemove, boolean toRecycleBin)\n    {\n        if (this.attachmentList.remove(attachmentToRemove)) {\n            this.attachmentsToRemove.add(new XWikiAttachmentToRemove(attachmentToRemove, toRecycleBin));\n            setMetaDataDirty(true);\n        } else {\n            attachmentToRemove = null;\n        }\n        return attachmentToRemove;\n    }\n\n    /**\n     * @return the attachment planned for removal\n     */\n    public List<XWikiAttachmentToRemove> getAttachmentsToRemove()\n    {\n        return this.attachmentsToRemove;\n    }\n\n    /**\n     * Clear the list of attachments planned for removal.\n     */\n    public void clearAttachmentsToRemove()\n    {\n        this.attachmentsToRemove.clear();\n    }\n\n    /**\n     * Get the wiki document references pointing to this document.\n     * <p>\n     * Theses links are stored in the Solr search core when the document is indexed. You can use \"backlinks\" in\n     * XWikiPreferences or \"xwiki.backlinks\" in xwiki.cfg file to enable links storage in the database.\n     * <p>\n     * Since 14.8RC1, this method return all backlinked documents and not just those located in the context wiki.\n     *\n     * @param context the XWiki context.\n     * @return the found wiki document references\n     * @throws XWikiException error when getting pages names from database.\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getBackLinkedReferences(XWikiContext context) throws XWikiException\n    {\n        Set<EntityReference> references;\n        try {\n            references = getLinkStore().resolveBackLinkedEntities(getDocumentReference());\n        } catch (LinkException e) {\n            throw new XWikiException(\"Failed to load backlinks for reference [\" + getDocumentReference() + \"]\", e);\n        }\n\n        Set<DocumentReference> documentReferences = new HashSet<>(references.size());\n        for (EntityReference entityReference : references) {\n            // Resolve the DOCUMENT reference\n            DocumentReference linkReference = context.getWiki().getDocumentReference(entityReference, context);\n\n            // Retro compatibility: remove the locale as it's what is expected of #getBackLinkedReferences(XWikicontext)\n            if (linkReference.getLocale() != null) {\n                linkReference = new DocumentReference(linkReference, (Locale) null);\n            }\n\n            // Add the reference\n            documentReferences.add(linkReference);\n        }\n\n        return new ArrayList<>(documentReferences);\n    }\n\n    /**\n     * @deprecated use {@link #getBackLinkedReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getBackLinkedPages(XWikiContext context) throws XWikiException\n    {\n        List<DocumentReference> references = getBackLinkedReferences(context);\n\n        EntityReferenceSerializer<String> serializer = getCompactWikiEntityReferenceSerializer();\n\n        List<String> documentNames = new ArrayList<>(references.size());\n        for (DocumentReference reference : references) {\n            // Serialize the reference\n            documentNames.add(serializer.serialize(reference));\n        }\n\n        return documentNames;\n    }\n\n    /**\n     * Get a list of unique links from this document to others documents.\n     * <ul>\n     * <li>xwiki/1.0 content: get the unique links associated to document from database. This is stored when the\n     * document is saved. You can use \"backlinks\" in XWikiPreferences or \"xwiki.backlinks\" in xwiki.cfg file to enable\n     * links storage in the database.</li>\n     * <li>Other content: call {@link #getUniqueLinkedPages(XWikiContext)} and generate the List.</li>\n     * </ul>\n     *\n     * @param context the XWiki context\n     * @return the found wiki links.\n     * @throws XWikiException error when getting links from database when xwiki/1.0 content.\n     * @since 1.9M2\n     */\n    public Set<XWikiLink> getUniqueWikiLinkedPages(XWikiContext context) throws XWikiException\n    {\n        Set<XWikiLink> links;\n\n        // We don't handle the links the same way in 1.0 syntax for retro-compatibility reason\n        // So here we explicitly get the link from the DB instead of looking inside the document.\n        if (is10Syntax()) {\n            links = new LinkedHashSet<>(getStore(context).loadLinks(getId(), context, true));\n        } else {\n            Set<String> linkedPages = getUniqueLinkedPages(context);\n            links = new LinkedHashSet<>(linkedPages.size());\n            for (String linkedPage : linkedPages) {\n                XWikiLink wikiLink = new XWikiLink();\n\n                wikiLink.setDocId(getId());\n                wikiLink.setFullName(LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference()));\n                wikiLink.setLink(linkedPage);\n\n                links.add(wikiLink);\n            }\n        }\n\n        return links;\n    }\n\n    /**\n     * Extract all the unique static (i.e. not generated by macros) wiki links (pointing to wiki page) from this\n     * xwiki/1.0 document's content to others documents.\n     *\n     * @param context the XWiki context.\n     * @return the document references for linked pages, if null an error append.\n     * @since 1.9M2\n     */\n    private Set<DocumentReference> getUniqueLinkedPages10(XWikiContext context)\n    {\n        Set<DocumentReference> pageNames;\n\n        try {\n            List<String> list = context.getUtil().getUniqueMatches(getContent(), \"\\\\[(.*?)\\\\]\", 1);\n            pageNames = new HashSet<DocumentReference>(list.size());\n\n            DocumentReference currentDocumentReference = getDocumentReference();\n            for (String name : list) {\n                int i1 = name.indexOf('>');\n                if (i1 != -1) {\n                    name = name.substring(i1 + 1);\n                }\n                i1 = name.indexOf(\"&gt;\");\n                if (i1 != -1) {\n                    name = name.substring(i1 + 4);\n                }\n                i1 = name.indexOf('#');\n                if (i1 != -1) {\n                    name = name.substring(0, i1);\n                }\n                i1 = name.indexOf('?');\n                if (i1 != -1) {\n                    name = name.substring(0, i1);\n                }\n\n                // Let's get rid of anything that's not a real link\n                if (name.trim().equals(\"\") || (name.indexOf('$') != -1) || (name.indexOf(\"://\") != -1)\n                    || (name.indexOf('\"') != -1) || (name.indexOf('\\'') != -1) || (name.indexOf(\"..\") != -1)\n                    || (name.indexOf(':') != -1) || (name.indexOf('=') != -1)) {\n                    continue;\n                }\n\n                // generate the link\n                String newname = StringUtils.replace(Util.noaccents(name), \" \", \"\");\n\n                // If it is a local link let's add the space\n                if (newname.indexOf('.') == -1) {\n                    newname = getSpace() + \".\" + name;\n                }\n                if (context.getWiki().exists(newname, context)) {\n                    name = newname;\n                } else {\n                    // If it is a local link let's add the space\n                    if (name.indexOf('.') == -1) {\n                        name = getSpace() + \".\" + name;\n                    }\n                }\n\n                // If the reference is empty, the link is an autolink\n                if (!StringUtils.isEmpty(name)) {\n                    // The reference may not have the space or even document specified (in case of an empty\n                    // string)\n                    // Thus we need to find the fully qualified document name\n                    DocumentReference documentReference = getCurrentDocumentReferenceResolver().resolve(name);\n\n                    // Verify that the link is not an autolink (i.e. a link to the current document)\n                    if (!documentReference.equals(currentDocumentReference)) {\n                        pageNames.add(documentReference);\n                    }\n                }\n            }\n\n            return pageNames;\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to get linked documents\", e);\n\n            return null;\n        }\n    }\n\n    /**\n     * Extract all the unique entity references found in the current document (they can be wiki links, macro\n     * parameters, etc) and pointing to entities specified in the passed {@code entityTypes} map (the keys represent\n     * the entity references that will be returned).\n     *\n     * @param context the XWiki context\n     * @param entityTypes the mapping of the types of references to return (and their corresponding resource types)\n     * @return the serialized entity references, and null if an error happened\n     * @since 14.2RC1\n     */\n    private Set<EntityReference> getUniqueLinkedEntityReferences(XWikiContext context,\n        Map<EntityType, Set<ResourceType>> entityTypes)\n    {\n        Set<EntityReference> references;\n\n        XWikiDocument contextDoc = context.getDoc();\n        WikiReference contextWikiReference = context.getWikiReference();\n\n        try {\n            // Make sure the right document is used as context document\n            context.setDoc(this);\n            // Make sure the right wiki is used as context document\n            context.setWikiReference(getDocumentReference().getWikiReference());\n\n            if (is10Syntax()) {\n                references = (Set) getUniqueLinkedPages10(context);\n            } else {\n                references = new LinkedHashSet<>();\n\n                // Document content\n                XDOM dom = getXDOM();\n                getUniqueLinkedEntityReferences(dom, entityTypes, references);\n\n                // XObjects\n                for (List<BaseObject> xobjects : getXObjects().values()) {\n                    xobjects.stream()\n                        .forEach(xobject -> getUniqueLinkedEntityReferences(xobject, entityTypes, references, context));\n                }\n            }\n        } finally {\n            context.setDoc(contextDoc);\n            context.setWikiReference(contextWikiReference);\n        }\n\n        return references;\n    }\n\n    private void getUniqueLinkedEntityReferences(BaseObject xobject, Map<EntityType, Set<ResourceType>> entityTypes,\n        Set<EntityReference> references, XWikiContext xcontext)\n    {\n        if (xobject == null) {\n            return;\n        }\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n\n        for (Object fieldClass : xclass.getProperties()) {\n            // Wiki content stored in xobjects\n            if (fieldClass instanceof TextAreaClass && ((TextAreaClass) fieldClass).isWikiContent()) {\n                TextAreaClass textAreaClass = (TextAreaClass) fieldClass;\n                PropertyInterface field = xobject.getField(textAreaClass.getName());\n\n                // Make sure the field is the right type (might happen while a document is being migrated)\n                if (field instanceof LargeStringProperty) {\n                    LargeStringProperty largeField = (LargeStringProperty) field;\n\n                    try {\n                        XDOM dom = parseContent(getSyntax(), largeField.getValue(), getDocumentReference());\n                        getUniqueLinkedEntityReferences(dom, entityTypes, references);\n                    } catch (XWikiException e) {\n                        LOGGER.warn(\"Failed to extract links from xobject property [{}], skipping it. Error: {}\",\n                            largeField.getReference(), ExceptionUtils.getRootCauseMessage(e));\n                    }\n                }\n            }\n        }\n    }\n\n    private void getUniqueLinkedEntityReferences(XDOM dom, Map<EntityType, Set<ResourceType>> entityTypes,\n        Set<EntityReference> references)\n    {\n        Set<EntityReference> uniqueLinkedEntityReferences =\n            getLinkParser().getUniqueLinkedEntityReferences(dom, entityTypes, getDocumentReference());\n        references.addAll(uniqueLinkedEntityReferences);\n    }\n\n    private Set<DocumentReference> toDocumentReferenceSet(Collection<? extends EntityReference> entityReferences,\n        DocumentReference baseReference)\n    {\n        Set<DocumentReference> documentReferences = new LinkedHashSet<>(entityReferences.size());\n\n        for (EntityReference entityRefefence : entityReferences) {\n            documentReferences.add(getCurrentReferenceDocumentReferenceResolver().resolve(entityRefefence,\n                EntityType.DOCUMENT, baseReference));\n        }\n\n        return documentReferences;\n    }\n\n    /**\n     * Extract all the unique entity references found in the current document (they can be wiki links, macro\n     * parameters, etc) and pointing to documents (either using a Document Reference or a Page Reference).\n     *\n     * @param context the XWiki context\n     * @return the serialized entity references, and null if an error happened\n     * @since 1.9M2\n     */\n    public Set<String> getUniqueLinkedPages(XWikiContext context)\n    {\n        // Only return document references.\n        Set<EntityReference> references = getUniqueLinkedEntityReferences(context, Map.of(\n            EntityType.DOCUMENT, Set.of(\n                ResourceType.SPACE,\n                ResourceType.DOCUMENT,\n                ResourceType.ATTACHMENT),\n            EntityType.PAGE, Set.of(\n                ResourceType.PAGE,\n                ResourceType.PAGE_ATTACHMENT)\n        ));\n        Set<String> documentNames = new LinkedHashSet<>(references.size());\n\n        XWikiDocument contextDoc = context.getDoc();\n        String contextWiki = context.getWikiId();\n        EntityReferenceSerializer<String> serializer;\n\n        try {\n            // Specify the right context information for using the compact wiki serializer properly\n            // Make sure the right document is used as context document\n            context.setDoc(this);\n            // Make sure the right wiki is used as context document\n            context.setWikiId(getDocumentReference().getWikiReference().getName());\n\n            // for retro-compatibility reason we don't use the same serializer for 1.0 syntax.\n            if (is10Syntax()) {\n                serializer = getCompactEntityReferenceSerializer();\n            } else {\n                serializer = getCompactWikiEntityReferenceSerializer();\n            }\n\n            for (EntityReference reference : references) {\n                // Get the reference of the document\n                DocumentReference linkDocumentReference = context.getWiki().getDocumentReference(reference, context);\n\n                // Serialize the reference\n                documentNames.add(serializer.serialize(linkDocumentReference));\n            }\n        } finally {\n            context.setDoc(contextDoc);\n            context.setWikiId(contextWiki);\n        }\n\n        return documentNames;\n    }\n\n    /**\n     * Extract all the unique static (i.e. not generated by macros) entity references pointed by wiki links (pointing\n     * to wiki document or attachments) for the current context document.\n     *\n     * @param context the XWiki context\n     * @return the entity references pointing to either document or attachments. If {@code null}, an error happened\n     * @since 14.2RC1\n     */\n    @Unstable\n    public Set<EntityReference> getUniqueLinkedEntities(XWikiContext context)\n    {\n        // Return both document and attachment references.\n        // Note that we return PAGE and PAGE_ATTACHMENT since it's not possible to convert them to DOCUMENT and\n        // ATTACHMENT since there's no way of knowing (without querying the DB) if they point to a terminal page or\n        // a non-terminal one (and thus the conversion would be wrong).\n        return getUniqueLinkedEntityReferences(context, Map.of(\n            EntityType.DOCUMENT, Set.of(\n                ResourceType.SPACE,\n                ResourceType.DOCUMENT),\n            EntityType.PAGE, Set.of(\n                ResourceType.PAGE),\n            EntityType.ATTACHMENT, Set.of(\n                ResourceType.ATTACHMENT),\n            EntityType.PAGE_ATTACHMENT, Set.of(\n                ResourceType.PAGE_ATTACHMENT)\n        ));\n    }\n\n    /**\n     * Returns a list of references of all documents which list this document as their parent, in the current wiki.\n     * {@link #getChildren(int, int, com.xpn.xwiki.XWikiContext)}\n     *\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getChildrenReferences(XWikiContext context) throws XWikiException\n    {\n        return getChildrenReferences(0, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #getChildrenReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getChildren(XWikiContext context) throws XWikiException\n    {\n        return getChildren(0, 0, context);\n    }\n\n    /**\n     * Returns a list of references of all documents which list this document as their parent, in the current wiki.\n     *\n     * @param nb The number of results to return.\n     * @param start The number of results to skip before we begin returning results.\n     * @param context The {@link com.xpn.xwiki.XWikiContext context}.\n     * @return the list of document references\n     * @throws XWikiException If there's an error querying the database.\n     * @since 2.2M2\n     */\n    public List<DocumentReference> getChildrenReferences(int nb, int start, XWikiContext context) throws XWikiException\n    {\n        // Use cases:\n        // - the parent document reference saved in the database matches the reference of this document, in its fully\n        // serialized form (eg \"wiki:space.page\"). Note that this is normally not required since the wiki part\n        // isn't saved in the database when it matches the current wiki.\n        // - the parent document reference saved in the database matches the reference of this document, in its\n        // serialized form without the wiki part (eg \"space.page\"). The reason we don't need to specify the wiki\n        // part is because document parents saved in the database don't have the wiki part specified when it matches\n        // the current wiki.\n        // - the parent document reference saved in the database matches the page name part of this document's\n        // reference (eg \"page\") and the parent document's space is the same as this document's space.\n        List<DocumentReference> children = new ArrayList<DocumentReference>();\n\n        try {\n            Query query = getStore().getQueryManager()\n                .createQuery(\"select distinct doc.fullName from XWikiDocument doc where \"\n                    + \"doc.parent=:prefixedFullName or doc.parent=:fullName or (doc.parent=:name and doc.space=:space)\",\n                    Query.XWQL);\n            query.addFilter(Utils.getComponent(QueryFilter.class, \"hidden\"));\n            query.bindValue(\"prefixedFullName\",\n                getDefaultEntityReferenceSerializer().serialize(getDocumentReference()));\n            query.bindValue(\"fullName\", LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference()));\n            query.bindValue(\"name\", getDocumentReference().getName());\n            query.bindValue(\"space\",\n                LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference().getLastSpaceReference()));\n            query.setLimit(nb).setOffset(start);\n\n            List<String> queryResults = query.execute();\n            WikiReference wikiReference = this.getDocumentReference().getWikiReference();\n            for (String fullName : queryResults) {\n                children.add(getCurrentDocumentReferenceResolver().resolve(fullName, wikiReference));\n            }\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                String.format(\"Failed to retrieve children for document [%s]\", this.getDocumentReference()), e);\n        }\n\n        return children;\n    }\n\n    /**\n     * @deprecated use {@link #getChildrenReferences(XWikiContext)}\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<String> getChildren(int nb, int start, XWikiContext context) throws XWikiException\n    {\n        List<String> childrenNames = new ArrayList<String>();\n        for (DocumentReference reference : getChildrenReferences(nb, start, context)) {\n            childrenNames.add(LOCAL_REFERENCE_SERIALIZER.serialize(reference));\n        }\n        return childrenNames;\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public void renameProperties(DocumentReference classReference, Map<String, String> fieldsToRename)\n    {\n        List<BaseObject> objects = this.xObjects.get(classReference);\n        if (objects == null) {\n            return;\n        }\n\n        boolean isDirty = false;\n        for (BaseObject bobject : objects) {\n            if (bobject == null) {\n                continue;\n            }\n            for (Map.Entry<String, String> entry : fieldsToRename.entrySet()) {\n                String origname = entry.getKey();\n                String newname = entry.getValue();\n                BaseProperty origprop = (BaseProperty) bobject.safeget(origname);\n                if (origprop != null) {\n                    BaseProperty prop = origprop.clone();\n                    bobject.removeField(origname);\n                    prop.setName(newname);\n                    bobject.addField(newname, prop);\n\n                    isDirty = true;\n                }\n            }\n        }\n\n        // If at least one property was renamed, mark the document dirty.\n        if (isDirty) {\n            setMetaDataDirty(true);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #renameProperties(DocumentReference, Map)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void renameProperties(String className, Map<String, String> fieldsToRename)\n    {\n        renameProperties(resolveClassReference(className), fieldsToRename);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void addXObjectToRemove(BaseObject object)\n    {\n        getXObjectsToRemove().add(object);\n        object.setOwnerDocument(null);\n        setMetaDataDirty(true);\n    }\n\n    /**\n     * Automatically add objects present in the old version, but not in the current document, to the list of objects\n     * marked for removal from the database.\n     *\n     * @param previousVersion the version of the document present in the database\n     * @since 3.3M2\n     */\n    public void addXObjectsToRemoveFromVersion(XWikiDocument previousVersion)\n    {\n        if (previousVersion == null) {\n            return;\n        }\n        for (List<BaseObject> objects : previousVersion.getXObjects().values()) {\n            for (BaseObject originalObj : objects) {\n                if (originalObj != null) {\n                    BaseObject newObj = getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                    if (newObj == null) {\n                        // The object was deleted.\n                        this.addXObjectToRemove(originalObj);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectToRemove(BaseObject)} )} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void addObjectsToRemove(BaseObject object)\n    {\n        addXObjectToRemove(object);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public List<BaseObject> getXObjectsToRemove()\n    {\n        return this.xObjectsToRemove;\n    }\n\n    /**\n     * @deprecated use {@link #getObjectsToRemove()} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public ArrayList<BaseObject> getObjectsToRemove()\n    {\n        return (ArrayList<BaseObject>) getXObjectsToRemove();\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXObjectsToRemove(List<BaseObject> objectsToRemove)\n    {\n        this.xObjectsToRemove = objectsToRemove;\n        setMetaDataDirty(true);\n    }\n\n    public List<String> getIncludedPages(XWikiContext context)\n    {\n        try {\n            return getIncludedPagesInternal(context);\n        } catch (Exception e) {\n            // If an error happens then we return an empty list of included pages. We don't want to fail by throwing an\n            // exception since it'll lead to several errors in the UI (such as in the Information Panel in edit mode).\n            LOGGER.error(\"Failed to get included pages for [{}]\", getDocumentReference(), e);\n            return Collections.emptyList();\n        }\n    }\n\n    private List<String> getIncludedPagesInternal(XWikiContext context)\n    {\n        if (is10Syntax()) {\n            return getIncludedPagesForXWiki10Syntax(getContent(), context);\n        } else {\n            // Find all include macros listed on the page\n            XDOM dom = getXDOM();\n\n            List<String> result = new ArrayList<String>();\n            List<MacroBlock> macroBlocks =\n                dom.getBlocks(new ClassBlockMatcher(MacroBlock.class), Block.Axes.DESCENDANT);\n            for (MacroBlock macroBlock : macroBlocks) {\n                // - Add each document pointed to by the include macro\n                // - Also add all the included pages found in the velocity macro when using the deprecated #include*\n                // macros\n                // This should be removed when we fully drop support for the XWiki Syntax 1.0 but for now we want to\n                // play nice with people migrating from 1.0 to 2.0 syntax\n\n                if (macroBlock.getId().equalsIgnoreCase(\"include\") || macroBlock.getId().equalsIgnoreCase(\"display\")) {\n                    String documentName = macroBlock.getParameters().get(\"reference\");\n                    if (StringUtils.isEmpty(documentName)) {\n                        documentName = macroBlock.getParameters().get(\"document\");\n                        if (StringUtils.isEmpty(documentName)) {\n                            continue;\n                        }\n                    }\n\n                    DocumentReference documentReference =\n                        getExplicitDocumentReferenceResolver().resolve(documentName, getDocumentReference());\n                    if (this.getDocumentReference().equals(documentReference)) {\n                        // Skip auto-includes since they are not allowed anyway.\n                        continue;\n                    }\n\n                    documentName = LOCAL_REFERENCE_SERIALIZER.serialize(documentReference);\n\n                    result.add(documentName);\n                } else if (macroBlock.getId().equalsIgnoreCase(\"velocity\")\n                    && !StringUtils.isEmpty(macroBlock.getContent())) {\n                    // Try to find matching content inside each velocity macro\n                    result.addAll(getIncludedPagesForXWiki10Syntax(macroBlock.getContent(), context));\n                }\n            }\n\n            return result;\n        }\n    }\n\n    private List<String> getIncludedPagesForXWiki10Syntax(String content, XWikiContext context)\n    {\n        try {\n            String pattern = \"#include(Topic|InContext|Form|Macros|parseGroovyFromPage)\\\\([\\\"'](.*?)[\\\"']\\\\)\";\n            List<String> list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, getSpace() + \".\" + name);\n                }\n            }\n\n            return list;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to extract include target from provided content [\" + content + \"]\", e);\n\n            return null;\n        }\n    }\n\n    public List<String> getIncludedMacros(XWikiContext context)\n    {\n        return context.getWiki().getIncludedMacros(getSpace(), getContent(), context);\n    }\n\n    public String displayRendered(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n        throws XWikiException\n    {\n        String result = pclass.displayView(pclass.getName(), prefix, object, context);\n        return getRenderedContent(result, Syntax.XWIKI_1_0.toIdString(), context);\n    }\n\n    public String displayView(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayView(pclass.getName(), prefix, object, context);\n    }\n\n    public String displayEdit(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayEdit(pclass.getName(), prefix, object, context);\n    }\n\n    public String displayHidden(PropertyClass pclass, String prefix, BaseCollection object, XWikiContext context)\n    {\n        return (pclass == null) ? \"\" : pclass.displayHidden(pclass.getName(), prefix, object, context);\n    }\n\n    /**\n     * Return the first attachment of the attachment list either exactly matching the provided filename or that matches \n     * the provided filename with a n arbitrary extension (i.e., filename.ext). To get only attachments that exactly\n     * matches the provided filename use {@link #getExactAttachment(String)}.\n     * \n     * @param filename the file name of the attachment with or without the extension\n     * @return the {@link XWikiAttachment} corresponding to the file name, null if none can be found\n     * @see #getExactAttachment(String) \n     */\n    public XWikiAttachment getAttachment(String filename)\n    {\n        XWikiAttachment output = this.attachmentList.getByFilename(filename);\n        if (output != null) {\n            return output;\n        }\n\n        for (XWikiAttachment attach : getAttachmentList()) {\n            if (attach.getFilename().startsWith(filename + \".\")) {\n                return attach;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Return the attachment that exactly matches the provided file. To also get the first attachment that matches the\n     * provided filename with an arbitrary extension use {@link #getAttachment(String)}.\n     *\n     * @param filename the file name of the attachment\n     * @return the {@link XWikiAttachment} exactly corresponding to the file name, null if none can be found\n     * @since 14.1RC1\n     * @since 13.10.3\n     */\n    public XWikiAttachment getExactAttachment(String filename)\n    {\n        return this.attachmentList.getByFilename(filename);\n    }\n\n    /**\n     * Add passed attachment to the document.\n     *\n     * @param attachment the attachment to add\n     * @since 5.3M2\n     * @deprecated use {@link #setAttachment(XWikiAttachment)} instead\n     */\n    @Deprecated(since = \"9.10RC1\")\n    public void addAttachment(XWikiAttachment attachment)\n    {\n        setAttachment(attachment);\n    }\n\n    /**\n     * Insert passed attachment in the document and return any pre-existing attachment with the same name.\n     * \n     * @param attachment the attachment to insert in the document\n     * @return the attachment replaced by the passed attachment\n     * @since 9.10RC1\n     */\n    public XWikiAttachment setAttachment(XWikiAttachment attachment)\n    {\n        return this.attachmentList.set(attachment);\n    }\n\n    /**\n     * @deprecated use {@link #setAttachment(String, InputStream, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiAttachment addAttachment(String fileName, byte[] content, XWikiContext context) throws XWikiException\n    {\n        try {\n            return setAttachment(fileName, new ByteArrayInputStream(content != null ? content : new byte[0]), context);\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to set Attachment content\", e);\n        }\n    }\n\n    /**\n     * @param fileName the name of the attachment\n     * @param content the content of the attachment\n     * @param context the XWiki context\n     * @return the new attachment\n     * @throws XWikiException never sent\n     * @throws IOException when failing to read the passed content\n     * @deprecated use {@link #setAttachment(String, InputStream, XWikiContext)} instead\n     */\n    @Deprecated(since = \"9.10RC1\")\n    public XWikiAttachment addAttachment(String fileName, InputStream content, XWikiContext context)\n        throws XWikiException, IOException\n    {\n        return setAttachment(fileName, content, context);\n    }\n\n    /**\n     * Create or update attachment with the passed name with the passed content.\n     * \n     * @param fileName the name of the attachment\n     * @param content the content of the attachment\n     * @param context the XWiki context\n     * @return the new attachment\n     * @throws IOException when failing to read the passed content\n     * @since 9.10rc1\n     */\n    public XWikiAttachment setAttachment(String fileName, InputStream content, XWikiContext context) throws IOException\n    {\n        int i = fileName.indexOf('\\\\');\n        if (i == -1) {\n            i = fileName.indexOf('/');\n        }\n\n        String filename = fileName.substring(i + 1);\n\n        XWikiAttachment attachment = getExactAttachment(filename);\n        if (attachment == null) {\n            attachment = new XWikiAttachment(this, filename);\n\n            // Add the attachment in the current doc\n            setAttachment(attachment);\n        }\n\n        attachment.setContent(content);\n        attachment.setAuthorReference(context.getUserReference());\n\n        return attachment;\n    }\n\n    public BaseObject getFirstObject(String fieldname)\n    {\n        // Keeping this function with context null for compatibility reasons.\n        // It should not be used, since it would miss properties which are only defined in the class\n        // and not present in the object because the object was not updated\n        return getFirstObject(fieldname, null);\n    }\n\n    public BaseObject getFirstObject(String fieldname, XWikiContext context)\n    {\n        Collection<List<BaseObject>> objectscoll = getXObjects().values();\n        if (objectscoll == null) {\n            return null;\n        }\n\n        for (List<BaseObject> objects : objectscoll) {\n            for (BaseObject obj : objects) {\n                if (obj != null) {\n                    BaseClass bclass = obj.getXClass(context);\n                    if (bclass != null) {\n                        Set<String> set = bclass.getPropertyList();\n                        if ((set != null) && set.contains(fieldname)) {\n                            return obj;\n                        }\n                    }\n                    Set<String> set = obj.getPropertyList();\n                    if ((set != null) && set.contains(fieldname)) {\n                        return obj;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setProperty(EntityReference classReference, String fieldName, BaseProperty value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.safeput(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setProperty(EntityReference, String, BaseProperty)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setProperty(String className, String fieldName, BaseProperty value)\n    {\n        setProperty(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public int getIntValue(DocumentReference classReference, String fieldName)\n    {\n        return getIntValue(classReference, fieldName, 0);\n    }\n\n    /**\n     * Retrieve the int value of the given property of the first object of the given class.\n     *\n     * @param classReference the reference of the object to find\n     * @param fieldName the property to get the value from\n     * @param defaultValue the default value to return if the object doesn't exist, or if the property is not set\n     * @return the retrieved value or the default value.\n     * @since 11.9RC1\n     */\n    public int getIntValue(DocumentReference classReference, String fieldName, int defaultValue)\n    {\n        BaseObject obj = getXObject(classReference, 0);\n        if (obj == null) {\n            return defaultValue;\n        }\n\n        return obj.getIntValue(fieldName, defaultValue);\n    }\n\n    /**\n     * @deprecated use {@link #getIntValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public int getIntValue(String className, String fieldName)\n    {\n        return getIntValue(resolveClassReference(className), fieldName);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public long getLongValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference, 0);\n        if (obj == null) {\n            return 0;\n        }\n\n        return obj.getLongValue(fieldName);\n    }\n\n    /**\n     * @deprecated use {@link #getLongValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public long getLongValue(String className, String fieldName)\n    {\n        return getLongValue(resolveClassReference(className), fieldName);\n    }\n\n    /**\n     * @since 6.2M1\n     */\n    public String getStringValue(EntityReference classReference, String fieldName)\n    {\n        return getStringValue(resolveClassReference(classReference), fieldName);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public String getStringValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference);\n        if (obj == null) {\n            return \"\";\n        }\n\n        String result = obj.getStringValue(fieldName);\n        if (result.equals(\" \")) {\n            return \"\";\n        } else {\n            return result;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getStringValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public String getStringValue(String className, String fieldName)\n    {\n        return getStringValue(resolveClassReference(className), fieldName);\n    }\n\n    public int getIntValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return 0;\n        } else {\n            return object.getIntValue(fieldName);\n        }\n    }\n\n    public long getLongValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return 0;\n        } else {\n            return object.getLongValue(fieldName);\n        }\n    }\n\n    public String getStringValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return \"\";\n        }\n\n        String result = object.getStringValue(fieldName);\n        if (result.equals(\" \")) {\n            return \"\";\n        } else {\n            return result;\n        }\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setStringValue(EntityReference classReference, String fieldName, String value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setStringValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setStringValue(EntityReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setStringValue(String className, String fieldName, String value)\n    {\n        setStringValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public List getListValue(DocumentReference classReference, String fieldName)\n    {\n        BaseObject obj = getXObject(classReference);\n        if (obj == null) {\n            return new ArrayList();\n        }\n\n        return obj.getListValue(fieldName);\n    }\n\n    /**\n     * @deprecated use {@link #getListValue(DocumentReference, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List getListValue(String className, String fieldName)\n    {\n        return getListValue(resolveClassReference(className), fieldName);\n    }\n\n    public List getListValue(String fieldName)\n    {\n        BaseObject object = getFirstObject(fieldName, null);\n        if (object == null) {\n            return new ArrayList();\n        }\n\n        return object.getListValue(fieldName);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setStringListValue(EntityReference classReference, String fieldName, List value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setStringListValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setStringListValue(EntityReference, String, List)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setStringListValue(String className, String fieldName, List value)\n    {\n        setStringListValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setDBStringListValue(EntityReference classReference, String fieldName, List value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setDBStringListValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setDBStringListValue(EntityReference, String, List)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setDBStringListValue(String className, String fieldName, List value)\n    {\n        setDBStringListValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setLargeStringValue(EntityReference classReference, String fieldName, String value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setLargeStringValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setLargeStringValue(EntityReference, String, String)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setLargeStringValue(String className, String fieldName, String value)\n    {\n        setLargeStringValue(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * @since 2.2.3\n     */\n    public void setIntValue(EntityReference classReference, String fieldName, int value)\n    {\n        BaseObject bobject = prepareXObject(classReference);\n        bobject.setIntValue(fieldName, value);\n    }\n\n    /**\n     * @deprecated use {@link #setIntValue(EntityReference, String, int)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public void setIntValue(String className, String fieldName, int value)\n    {\n        setIntValue(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            fieldName, value);\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDocumentReference()} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getDatabase()\n    {\n        return getDocumentReference().getWikiReference().getName();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for loading a XWikiDocument.\n     *\n     * @deprecated use {@link #setDocumentReference(DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setDatabase(String database)\n    {\n        if (database != null) {\n            DocumentReference reference = getDocumentReference();\n            WikiReference wiki = reference.getWikiReference();\n            WikiReference newWiki = new WikiReference(database);\n            if (!newWiki.equals(wiki)) {\n                setDocumentReferenceInternal(reference.replaceParent(wiki, newWiki));\n            }\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getLocale()} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public String getLanguage()\n    {\n        return getLocale().toString();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #setLocale(Locale)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public void setLanguage(String language)\n    {\n        setLocale(LocaleUtils.toLocale(Util.normalizeLanguage(language), Locale.ROOT));\n    }\n\n    /**\n     * @return the locale of the document\n     */\n    public Locale getLocale()\n    {\n        return this.locale != null ? this.locale : Locale.ROOT;\n    }\n\n    /**\n     * @param locale the locale of the document\n     */\n    public void setLocale(Locale locale)\n    {\n        this.locale = locale;\n\n        setMetaDataDirty(true);\n\n        // Clean various caches\n\n        this.keyCache = null;\n        this.localKeyCache = null;\n        this.documentReferenceWithLocaleCache = null;\n        this.pageReferenceWithLocaleCache = null;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #getDefaultLocale()} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public String getDefaultLanguage()\n    {\n        return getDefaultLocale().toString();\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @deprecated use {@link #setDefaultLocale(Locale)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public void setDefaultLanguage(String defaultLanguage)\n    {\n        setDefaultLocale(LocaleUtils.toLocale(defaultLanguage, Locale.ROOT));\n    }\n\n    public Locale getDefaultLocale()\n    {\n        return this.defaultLocale != null ? this.defaultLocale : Locale.ROOT;\n    }\n\n    public void setDefaultLocale(Locale defaultLocale)\n    {\n        this.defaultLocale = defaultLocale;\n\n        setMetaDataDirty(true);\n    }\n\n    public int getTranslation()\n    {\n        return getLocale().equals(Locale.ROOT) ? 0 : 1;\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's called by Hibernate when loading a XWikiDocument.\n     *\n     * @deprecated stored in the database to speedup some queries (really ?) but in {@link XWikiDocument}\n     *             it's calculated based on the document locale\n     */\n    @Deprecated(since = \"5.4.6\")\n    public void setTranslation(int translation)\n    {\n        // Do nothing\n    }\n\n    public String getTranslatedContent(XWikiContext context) throws XWikiException\n    {\n        String language = context.getWiki().getLanguagePreference(context);\n\n        return getTranslatedContent(language, context);\n    }\n\n    public String getTranslatedContent(String locale, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = getTranslatedDocument(locale, context);\n        return tdoc.getContent();\n    }\n\n    public XWikiDocument getTranslatedDocument(XWikiContext context) throws XWikiException\n    {\n        String locale = context.getWiki().getLanguagePreference(context);\n        return getTranslatedDocument(locale, context);\n    }\n\n    /**\n     * Return the document in the provided language.\n     * <p>\n     * This method return this if the provided language does not exists. See\n     *\n     * @param language the language of the document to return\n     * @param context the XWiki Context\n     * @return the document in the provided language or this if the provided language does not exists\n     * @throws XWikiException error when loading the document\n     * @deprecated use {@link #getTranslatedDocument(Locale, XWikiContext)} instead\n     */\n    @Deprecated(since = \"4.3M2\")\n    public XWikiDocument getTranslatedDocument(String language, XWikiContext context) throws XWikiException\n    {\n        return getTranslatedDocument(LocaleUtils.toLocale(language, Locale.ROOT), context);\n    }\n\n    /**\n     * Return the document in the provided language.\n     * <p>\n     * This method return this if the provided language does not exists. See\n     *\n     * @param locale the locale of the document to return\n     * @param context the XWiki Context\n     * @return the document in the provided language or this if the provided language does not exists\n     * @throws XWikiException error when loading the document\n     */\n    public XWikiDocument getTranslatedDocument(Locale locale, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument tdoc = this;\n\n        if (locale != null && !locale.equals(Locale.ROOT) && !locale.equals(getDefaultLocale())) {\n            try {\n                tdoc = context.getWiki().getDocument(new DocumentReference(getDocumentReference(), locale), context);\n\n                if (!tdoc.isNew()) {\n                    return tdoc;\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Error when loading document {} for locale {}\", getDocumentReference(), locale, e);\n            }\n\n            tdoc = getTranslatedDocument(LocaleUtils.getParentLocale(locale), context);\n        }\n\n        return tdoc;\n    }\n\n    /**\n     * @deprecated use {@link #getRealLocale()} instead\n     */\n    @Deprecated(since = \"4.3M1\")\n    public String getRealLanguage(XWikiContext context) throws XWikiException\n    {\n        return getRealLanguage();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @see org.xwiki.bridge.DocumentModelBridge#getRealLanguage()\n     * @deprecated use {@link #getRealLocale()} instead\n     */\n    @Override\n    @Deprecated(since = \"4.3M1\")\n    public String getRealLanguage()\n    {\n        String lang = getLanguage();\n        if (lang.equals(\"\")) {\n            return getDefaultLanguage();\n        } else {\n            return lang;\n        }\n    }\n\n    /**\n     * @return the actual locale of the document\n     */\n    public Locale getRealLocale()\n    {\n        Locale locale = getLocale();\n        if (locale.equals(Locale.ROOT)) {\n            locale = getDefaultLocale();\n        }\n\n        return locale;\n    }\n\n    /**\n     * @deprecated use {@link #getTranslationLocales(XWikiContext)} instead\n     */\n    @Deprecated(since = \"5.1M2\")\n    public List<String> getTranslationList(XWikiContext context) throws XWikiException\n    {\n        // in few cases like accessing a deleted document, the store might be null.\n        if (getStore() != null) {\n            return getStore().getTranslationList(this, context);\n        } else {\n            return Collections.emptyList();\n        }\n\n    }\n\n    /**\n     * The locales of the translation of this document (the default locale is not included).\n     *\n     * @param context the XWiki context\n     * @return the locales of the translations\n     * @throws XWikiException if retriving the translations from the database failed\n     */\n    public List<Locale> getTranslationLocales(XWikiContext context) throws XWikiException\n    {\n        List<String> translations = getTranslationList(context);\n\n        List<Locale> locales = new ArrayList<Locale>(translations.size());\n        for (String translationString : translations) {\n            locales.add(LocaleUtils.toLocale(translationString));\n        }\n\n        return locales;\n    }\n\n    public List<Delta> getXMLDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        return getDeltas(\n            Diff.diff(ToString.stringToArray(fromDoc.toXML(context)), ToString.stringToArray(toDoc.toXML(context))));\n    }\n\n    public List<Delta> getContentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        return getDeltas(\n            Diff.diff(ToString.stringToArray(fromDoc.getContent()), ToString.stringToArray(toDoc.getContent())));\n    }\n\n    public List<Delta> getContentDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n        if (fromDoc == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                String.format(\"The revision [%s] cannot be found in [%s] for making diff.\", fromRev,\n                    this.getDocumentReference()));\n        }\n        if (toRev == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_CONTENT_ERROR,\n                String.format(\"The revision [%s] cannot be found in [%s] for making diff.\", toRev,\n                    this.getDocumentReference()));\n        }\n        return getContentDiff(fromDoc, toDoc, context);\n    }\n\n    public List<Delta> getContentDiff(String fromRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n        return getContentDiff(revdoc, this, context);\n    }\n\n    public List<Delta> getLastChanges(XWikiContext context) throws XWikiException, DifferentiationFailedException\n    {\n        Version version = getRCSVersion();\n        try {\n            String prev = getDocumentArchive(context).getPrevVersion(version).toString();\n            XWikiDocument prevDoc = context.getWiki().getDocument(this, prev, context);\n\n            return getDeltas(\n                Diff.diff(ToString.stringToArray(prevDoc.getContent()), ToString.stringToArray(getContent())));\n        } catch (Exception ex) {\n            LOGGER.debug(\"Exception getting differences from previous version: \" + ex.getMessage());\n        }\n\n        return new ArrayList<Delta>();\n    }\n\n    public List<Delta> getRenderedContentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        String originalContent = fromDoc.getRenderedContent(context);\n        String newContent = toDoc.getRenderedContent(context);\n\n        return getDeltas(Diff.diff(ToString.stringToArray(originalContent), ToString.stringToArray(newContent)));\n    }\n\n    public List<Delta> getRenderedContentDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getRenderedContentDiff(fromDoc, toDoc, context);\n    }\n\n    public List<Delta> getRenderedContentDiff(String fromRev, XWikiContext context)\n        throws XWikiException, DifferentiationFailedException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getRenderedContentDiff(revdoc, this, context);\n    }\n\n    protected List<Delta> getDeltas(Revision rev)\n    {\n        List<Delta> list = new ArrayList<Delta>();\n        for (int i = 0; i < rev.size(); i++) {\n            list.add(rev.getDelta(i));\n        }\n\n        return list;\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(String fromRev, String toRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getMetaDataDiff(fromDoc, toDoc, context);\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(String fromRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getMetaDataDiff(revdoc, this, context);\n    }\n\n    public List<MetaDataDiff> getMetaDataDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n        throws XWikiException\n    {\n        List<MetaDataDiff> list = new ArrayList<MetaDataDiff>();\n\n        if (fromDoc == null || toDoc == null) {\n            return list;\n        }\n\n        if (!fromDoc.getTitle().equals(toDoc.getTitle())) {\n            list.add(new MetaDataDiff(\"title\", fromDoc.getTitle(), toDoc.getTitle()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getRelativeParentReference(), toDoc.getRelativeParentReference())) {\n            list.add(new MetaDataDiff(\"parent\", fromDoc.getParent(), toDoc.getParent()));\n        }\n\n        UserReference fromDocOriginalAuthor = fromDoc.getAuthors().getOriginalMetadataAuthor();\n        UserReference toDocOriginalAuthor = toDoc.getAuthors().getOriginalMetadataAuthor();\n        if (ObjectUtils.notEqual(fromDocOriginalAuthor, toDocOriginalAuthor)) {\n            list.add(new MetaDataDiff(\"author\", userReferenceToString(fromDocOriginalAuthor),\n                userReferenceToString(toDocOriginalAuthor)));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getDocumentReference(), toDoc.getDocumentReference())) {\n            list.add(new MetaDataDiff(\"reference\", fromDoc.getDocumentReference(), toDoc.getDocumentReference()));\n        }\n\n        if (!fromDoc.getSpace().equals(toDoc.getSpace())) {\n            list.add(new MetaDataDiff(\"web\", fromDoc.getSpace(), toDoc.getSpace()));\n        }\n\n        if (!fromDoc.getName().equals(toDoc.getName())) {\n            list.add(new MetaDataDiff(\"name\", fromDoc.getName(), toDoc.getName()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getLocale(), toDoc.getLocale())) {\n            list.add(new MetaDataDiff(\"language\", fromDoc.getLanguage(), toDoc.getLanguage()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getDefaultLocale(), toDoc.getDefaultLocale())) {\n            list.add(new MetaDataDiff(\"defaultLanguage\", fromDoc.getDefaultLanguage(), toDoc.getDefaultLanguage()));\n        }\n\n        if (ObjectUtils.notEqual(fromDoc.getSyntax(), toDoc.getSyntax())) {\n            list.add(new MetaDataDiff(\"syntax\", fromDoc.getSyntax(), toDoc.getSyntax()));\n        }\n\n        if (fromDoc.isHidden() != toDoc.isHidden()) {\n            list.add(new MetaDataDiff(\"hidden\", fromDoc.isHidden(), toDoc.isHidden()));\n        }\n\n        return list;\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(String fromRev, String toRev, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument fromDoc = context.getWiki().getDocument(this, fromRev, context);\n        XWikiDocument toDoc = context.getWiki().getDocument(this, toRev, context);\n\n        return getObjectDiff(fromDoc, toDoc, context);\n    }\n\n    public List<List<ObjectDiff>> getObjectDiff(String fromRev, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);\n\n        return getObjectDiff(revdoc, this, context);\n    }\n\n    /**\n     * Return the object differences between two document versions. There is no hard requirement on the order of the two\n     * versions, but the results are semantically correct only if the two versions are given in the right order.\n     *\n     * @param fromDoc The old ('before') version of the document.\n     * @param toDoc The new ('after') version of the document.\n     * @param context The {@link com.xpn.xwiki.XWikiContext context}.\n     * @return The object differences. The returned list's elements are other lists, one for each changed object. The\n     *         inner lists contain {@link ObjectDiff} elements, one object for each changed property of the object.\n     *         Additionally, if the object was added or removed, then the first entry in the list will be an\n     *         \"object-added\" or \"object-removed\" marker.\n     */\n    public List<List<ObjectDiff>> getObjectDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();\n\n        // Since objects could have been deleted or added, we iterate on both the old and the new\n        // object collections.\n        // First, iterate over the old objects.\n        for (List<BaseObject> objects : fromDoc.getXObjects().values()) {\n            for (BaseObject originalObj : objects) {\n                // This happens when objects are deleted, and the document is still in the cache\n                // storage.\n                if (originalObj != null) {\n                    BaseObject newObj = toDoc.getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                    List<ObjectDiff> dlist;\n                    if (newObj == null) {\n                        // The object was deleted.\n                        dlist = new BaseObject().getDiff(originalObj, context);\n                        ObjectDiff deleteMarker =\n                            new ObjectDiff(originalObj.getXClassReference(), originalObj.getNumber(),\n                                originalObj.getGuid(), ObjectDiff.ACTION_OBJECTREMOVED, \"\", \"\", \"\", \"\");\n                        dlist.add(0, deleteMarker);\n                    } else {\n                        // The object exists in both versions, but might have been changed.\n                        dlist = newObj.getDiff(originalObj, context);\n                    }\n                    if (!dlist.isEmpty()) {\n                        difflist.add(dlist);\n                    }\n                }\n            }\n        }\n\n        // Second, iterate over the objects which are only in the new version.\n        for (List<BaseObject> objects : toDoc.getXObjects().values()) {\n            for (BaseObject newObj : objects) {\n                // This happens when objects are deleted, and the document is still in the cache\n                // storage.\n                if (newObj != null) {\n                    BaseObject originalObj = fromDoc.getXObject(newObj.getXClassReference(), newObj.getNumber());\n                    if (originalObj == null) {\n                        // TODO: Refactor this so that getDiff() accepts null Object as input.\n                        // Only consider added objects, the other case was treated above.\n                        originalObj = new BaseObject();\n                        originalObj.setXClassReference(newObj.getRelativeXClassReference());\n                        originalObj.setNumber(newObj.getNumber());\n                        originalObj.setGuid(newObj.getGuid());\n                        List<ObjectDiff> dlist = newObj.getDiff(originalObj, context);\n                        ObjectDiff addMarker = new ObjectDiff(newObj.getXClassReference(), newObj.getNumber(),\n                            newObj.getGuid(), ObjectDiff.ACTION_OBJECTADDED, \"\", \"\", \"\", \"\");\n                        dlist.add(0, addMarker);\n                        if (!dlist.isEmpty()) {\n                            difflist.add(dlist);\n                        }\n                    }\n                }\n            }\n        }\n\n        return difflist;\n    }\n\n    public List<List<ObjectDiff>> getClassDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();\n        BaseClass oldClass = fromDoc.getXClass();\n        BaseClass newClass = toDoc.getXClass();\n\n        if ((newClass == null) && (oldClass == null)) {\n            return difflist;\n        }\n\n        List<ObjectDiff> dlist = newClass.getDiff(oldClass, context);\n        if (!dlist.isEmpty()) {\n            difflist.add(dlist);\n        }\n\n        return difflist;\n    }\n\n    /**\n     * @param fromDoc\n     * @param toDoc\n     * @param context\n     * @return\n     */\n    public List<AttachmentDiff> getAttachmentDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)\n    {\n        List<AttachmentDiff> difflist = new ArrayList<AttachmentDiff>();\n        for (XWikiAttachment origAttach : fromDoc.getAttachmentList()) {\n            String fileName = origAttach.getFilename();\n            XWikiAttachment newAttach = toDoc.getAttachment(fileName);\n            origAttach = retrieveDeletedAttachment(fromDoc, origAttach, context);\n            if (newAttach == null) {\n                difflist.add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.DELETE, origAttach, newAttach));\n            } else {\n                newAttach = retrieveDeletedAttachment(toDoc, newAttach, context);\n                try {\n                    if (!origAttach.equalsData(newAttach, context)) {\n                        difflist\n                            .add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.CHANGE, origAttach, newAttach));\n                    }\n                } catch (XWikiException e) {\n                    LOGGER.error(\"Failed to compare attachments [{}] and [{}]\", origAttach.getReference(),\n                        newAttach.getReference(), e);\n                }\n            }\n        }\n\n        for (XWikiAttachment newAttach : toDoc.getAttachmentList()) {\n            String fileName = newAttach.getFilename();\n            XWikiAttachment origAttach = fromDoc.getAttachment(fileName);\n            newAttach = retrieveDeletedAttachment(toDoc, newAttach, context);\n            if (origAttach == null) {\n                difflist.add(new AttachmentDiff(fileName, org.xwiki.diff.Delta.Type.INSERT, origAttach, newAttach));\n            }\n        }\n\n        return difflist;\n    }\n\n    private XWikiAttachment retrieveDeletedAttachment(XWikiDocument doc, XWikiAttachment attachment,\n        XWikiContext context)\n    {\n        XWikiAttachment result = null;\n\n        InputStream is = null;\n        try {\n            is = attachment.getContentInputStream(context);\n            if (is == null) {\n                AttachmentRecycleBinStore attachmentRecycleBinStore = context.getWiki().getAttachmentRecycleBinStore();\n                List<DeletedAttachment> allDeletedAttachments =\n                    attachmentRecycleBinStore.getAllDeletedAttachments(doc, context, true);\n\n                for (DeletedAttachment deletedAttachment : allDeletedAttachments) {\n                    XWikiAttachment restoredAttachment = deletedAttachment.restoreAttachment();\n                    if (restoredAttachment.getDate().before(attachment.getDate())) {\n                        break;\n                    }\n                    result = restoredAttachment;\n                }\n\n                if (result != null) {\n                    if (!Objects.equals(attachment.getVersion(), result.getVersion())) {\n                        result = result.getAttachmentRevision(attachment.getVersion(), context);\n                    }\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Error while trying to load deleted attachment [{}] for doc [{}]\", attachment, doc, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException ex) {\n\n                }\n            }\n        }\n\n        if (result == null) {\n            result = attachment;\n        } else {\n            result.setDoc(doc);\n        }\n        return result;\n    }\n\n    /**\n     * Rename the current document and all the backlinks leading to it. Will also change parent field in all documents\n     * which list the document we are renaming as their parent.\n     * <p>\n     * See {@link #rename(DocumentReference, List, List, XWikiContext)} for more details.\n     *\n     * @param newDocumentReference the new document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentReference, getBackLinkedReferences(context), context);\n    }\n\n    /**\n     * Rename the current document and all the links pointing to it in the list of passed backlink documents. The\n     * renaming algorithm takes into account the fact that there are several ways to write a link to a given page and\n     * all those forms need to be renamed. For example the following links all point to the same page:\n     * <ul>\n     * <li>[Page]</li>\n     * <li>[Page?param=1]</li>\n     * <li>[currentwiki:Page]</li>\n     * <li>[CurrentSpace.Page]</li>\n     * <li>[currentwiki:CurrentSpace.Page]</li>\n     * </ul>\n     * <p>\n     * Note: links without a space are renamed with the space added and all documents which have the document being\n     * renamed as parent have their parent field set to \"currentwiki:CurrentSpace.Page\".\n     * </p>\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        rename(newDocumentReference, backlinkDocumentReferences, getChildrenReferences(context), context);\n    }\n\n    /**\n     * Same as {@link #rename(DocumentReference, List, XWikiContext)} but the list of documents having the current\n     * document as their parent is passed in parameter.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 2.2M2\n     * @deprecated use\n     *     {@link XWiki#renameDocument(DocumentReference, DocumentReference, boolean, List, List, XWikiContext)} instead\n     */\n    @Deprecated(since = \"12.5RC1\")\n    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context) throws XWikiException\n    {\n        // TODO: Do all this in a single DB transaction as otherwise the state will be unknown if\n        // something fails in the middle...\n\n        // TODO: Why do we verify if the document has just been created and not been saved.\n        // If the user is trying to rename to the same name... In that case, simply exits for efficiency.\n        if (isNew() || getDocumentReference().equals(newDocumentReference)) {\n            return;\n        }\n        context.getWiki().renameByCopyAndDelete(this,\n            newDocumentReference,\n            backlinkDocumentReferences,\n            childDocumentReferences, context);\n    }\n\n    /**\n     * Clone a document and change its reference.\n     *\n     * @param newDocumentReference the new reference of the cloned document.\n     * @param context the current context.\n     * @return a clone of the current document with a new reference.\n     * @throws XWikiException in case of problem during the clone operation.\n     * @since 12.5RC1\n     */\n    public XWikiDocument cloneRename(DocumentReference newDocumentReference, XWikiContext context) throws XWikiException\n    {\n        loadAttachments(context);\n        loadArchive(context);\n        return this.cloneInternal(newDocumentReference, true, true);\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public XWikiDocument copyDocument(DocumentReference newDocumentReference, XWikiContext context)\n        throws XWikiException\n    {\n        return copyDocument(newDocumentReference, true, context);\n    }\n\n    /**\n     * @since 14.3RC1\n     */\n    public XWikiDocument copyDocument(DocumentReference newDocumentReference, boolean cloneArchive, XWikiContext context)\n        throws XWikiException\n    {\n        loadAttachments(context);\n        if (cloneArchive) {\n            loadArchive(context);\n        }\n\n        XWikiDocument newdoc = cloneInternal(newDocumentReference, false, cloneArchive);\n\n        // If the copied document has a title set to the original page name then set the new title to be the new page\n        // name.\n        if (StringUtils.equals(newdoc.getTitle(), getPrettyName(this.getDocumentReference()))) {\n            newdoc.setTitle(getPrettyName(newDocumentReference));\n        }\n\n        newdoc.setOriginalDocument(null);\n        newdoc.setContentDirty(true);\n        newdoc.setNew(true);\n\n        return newdoc;\n    }\n\n    /**\n     * Avoid the technical \"WebHome\" name.\n     *\n     * @param documentReference a document reference\n     * @return the last space name if the document is the home of a space, the document name otherwise\n     */\n    private String getPrettyName(DocumentReference documentReference)\n    {\n        EntityReferenceProvider defaultEntityReferenceProvider = Utils.getComponent(EntityReferenceProvider.class);\n        if (defaultEntityReferenceProvider.getDefaultReference(documentReference.getType()).getName()\n            .equals(documentReference.getName())) {\n            return documentReference.getLastSpaceReference().getName();\n        }\n        return documentReference.getName();\n    }\n\n    /**\n     * @deprecated use {@link #copyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public XWikiDocument copyDocument(String newDocumentName, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(getCurrentMixedDocumentReferenceResolver().resolve(newDocumentName), context);\n    }\n\n    public XWikiLock getLock(XWikiContext context) throws XWikiException\n    {\n        XWikiLock theLock = getStore(context).loadLock(getId(), context, true);\n        if (theLock != null) {\n            int timeout = context.getWiki().getXWikiPreferenceAsInt(\"lock_Timeout\", 30 * 60, context);\n            if (theLock.getDate().getTime() + timeout * 1000 < new Date().getTime()) {\n                getStore(context).deleteLock(theLock, context, true);\n                theLock = null;\n            }\n        }\n\n        return theLock;\n    }\n\n    public void setLock(String userName, XWikiContext context) throws XWikiException\n    {\n        XWikiLock lock = new XWikiLock(getId(), userName);\n        getStore(context).saveLock(lock, context, true);\n    }\n\n    public void removeLock(XWikiContext context) throws XWikiException\n    {\n        XWikiLock lock = getStore(context).loadLock(getId(), context, true);\n        if (lock != null) {\n            getStore(context).deleteLock(lock, context, true);\n        }\n    }\n\n    public void insertText(String text, String marker, XWikiContext context) throws XWikiException\n    {\n        setContent(StringUtils.replaceOnce(getContent(), marker, text + marker));\n        context.getWiki().saveDocument(this, context);\n    }\n\n    public Object getWikiNode()\n    {\n        return this.wikiNode;\n    }\n\n    public void setWikiNode(Object wikiNode)\n    {\n        this.wikiNode = wikiNode;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public String getXClassXML()\n    {\n        return this.xClassXML;\n    }\n\n    /**\n     * @deprecated use {@link #getXClassXML()} instead as Hibernate uses this through reflection. It cannot be\n     *             removed without altering hibernate.cfg.xml\n     */\n    @Deprecated(since = \"2.2M1\")\n    public String getxWikiClassXML()\n    {\n        return getXClassXML();\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    public void setXClassXML(String xClassXML)\n    {\n        this.xClassXML = xClassXML;\n    }\n\n    /**\n     * @deprecated use {@link #setXClassXML(String)} ()} instead as Hibernate uses this through reflection. It\n     *             cannot be removed without altering hibernate.cfg.xml\n     */\n    @Deprecated(since = \"2.2M1\")\n    public void setxWikiClassXML(String xClassXML)\n    {\n        setXClassXML(xClassXML);\n    }\n\n    public int getElements()\n    {\n        return this.elements;\n    }\n\n    public void setElements(int elements)\n    {\n        this.elements = elements;\n    }\n\n    public void setElement(int element, boolean toggle)\n    {\n        if (toggle) {\n            this.elements = this.elements | element;\n        } else {\n            this.elements = this.elements & (~element);\n        }\n    }\n\n    public boolean hasElement(int element)\n    {\n        return ((this.elements & element) == element);\n    }\n\n    /**\n     * Gets the default edit mode for this document. An edit mode (other than the default \"edit\") can be enforced by\n     * creating an {@code XWiki.EditModeClass} object in the current document, with the appropriate value for the\n     * defaultEditMode property, or by adding this object in a sheet included by the document. This function also falls\n     * back on the old {@code SheetClass}, deprecated since 3.1M2, which can be attached to included documents to\n     * specify that the current document should be edited inline.\n     *\n     * @return the default edit mode for this document (\"edit\" or \"inline\" usually)\n     * @param context the context of the request for this document\n     * @throws XWikiException since XWiki 6.3M1 it's not used anymore and \"edit\" is returned in case of error, with an\n     *             error log\n     */\n    public String getDefaultEditMode(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getDefaultEditModeInternal(context);\n        } catch (Exception e) {\n            // If an error happens then we default to the \"edit\" mode. We don't want to fail by throwing an exception\n            // since it'll lead to several errors in the UI (such as when evaluating contentview.vm for example).\n            LOGGER.error(\"Failed to get the default edit mode for [{}]\", getDocumentReference(), e);\n            return \"edit\";\n        }\n    }\n\n    private String getDefaultEditModeInternal(XWikiContext context) throws XWikiException\n    {\n        String editModeProperty = \"defaultEditMode\";\n        DocumentReference editModeClass =\n            getCurrentReferenceDocumentReferenceResolver().resolve(XWikiConstant.EDIT_MODE_CLASS);\n        // check if the current document has any edit mode class object attached to it, and read the edit mode from it\n        BaseObject editModeObject = this.getXObject(editModeClass);\n        if (editModeObject != null) {\n            String defaultEditMode = editModeObject.getStringValue(editModeProperty);\n            if (StringUtils.isEmpty(defaultEditMode)) {\n                return \"edit\";\n            } else {\n                return defaultEditMode;\n            }\n        }\n        // otherwise look for included documents\n        com.xpn.xwiki.XWiki xwiki = context.getWiki();\n        if (is10Syntax()) {\n            if (getContent().indexOf(\"includeForm(\") != -1) {\n                return \"inline\";\n            }\n        } else {\n            // Algorithm: look in all include macros and for all document included check if one of them\n            // has an EditModeClass object attached to it, or a SheetClass object (deprecated since 3.1M2) attached to\n            // it. If so then the edit mode is inline.\n\n            // Find all include macros and extract the document names\n            // TODO: Is there a good way not to hardcode the macro name? The macro itself shouldn't know\n            // its own name since it's a deployment time concern.\n            for (Block macroBlock : getXDOM().getBlocks(new MacroBlockMatcher(\"include\"), Axes.CHILD)) {\n                // Find the document reference to include by checking the macro's \"reference\" parameter.\n                // For backward-compatibility we also check for a \"document\" parameter since this is the parameter name\n                // that was used prior to XWiki 3.4M1 when the \"reference\" one was introduced and thus when the\n                // \"document\" one was deprecated.\n                String includedDocumentReference = macroBlock.getParameter(\"reference\");\n                if (includedDocumentReference == null) {\n                    includedDocumentReference = macroBlock.getParameter(\"document\");\n                }\n                if (includedDocumentReference != null) {\n                    // Resolve the document name into a valid Reference\n                    DocumentReference documentReference =\n                        getCurrentMixedDocumentReferenceResolver().resolve(includedDocumentReference);\n                    XWikiDocument includedDocument = xwiki.getDocument(documentReference, context);\n                    if (!includedDocument.isNew()) {\n                        // get the edit mode object, first the new class and then the deprecated class if new class\n                        // is not found\n                        editModeObject = includedDocument.getXObject(editModeClass);\n                        if (editModeObject == null) {\n                            editModeObject = includedDocument.getXObject(SHEETCLASS_REFERENCE);\n                        }\n                        if (editModeObject != null) {\n                            // Use the user-defined default edit mode if set.\n                            String defaultEditMode = editModeObject.getStringValue(editModeProperty);\n                            if (StringUtils.isBlank(defaultEditMode)) {\n                                // TODO: maybe here the real value should be returned if the object is edit mode class,\n                                // and inline only if the object is sheetclass\n                                return \"inline\";\n                            } else {\n                                return defaultEditMode;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return \"edit\";\n    }\n\n    public String getDefaultEditURL(XWikiContext context) throws XWikiException\n    {\n        String editMode = getDefaultEditMode(context);\n\n        if (\"inline\".equals(editMode)) {\n            return getEditURL(\"inline\", \"\", context);\n        } else {\n            com.xpn.xwiki.XWiki xwiki = context.getWiki();\n            String editor = xwiki.getEditorPreference(context);\n            return getEditURL(\"edit\", editor, context);\n        }\n    }\n\n    public String getEditURL(String action, String mode, XWikiContext context) throws XWikiException\n    {\n        com.xpn.xwiki.XWiki xwiki = context.getWiki();\n        String language = \"\";\n        XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n        String realLang = tdoc.getRealLanguage(context);\n        if ((xwiki.isMultiLingual(context) == true) && (!realLang.equals(\"\"))) {\n            language = realLang;\n        }\n\n        return getEditURL(action, mode, language, context);\n    }\n\n    public String getEditURL(String action, String mode, String language, XWikiContext context)\n    {\n        StringBuilder editparams = new StringBuilder();\n        if (!mode.equals(\"\")) {\n            editparams.append(\"xpage=\");\n            editparams.append(mode);\n        }\n\n        if (!language.equals(\"\")) {\n            if (!mode.equals(\"\")) {\n                editparams.append(\"&\");\n            }\n            editparams.append(\"language=\");\n            editparams.append(language);\n        }\n\n        return getURL(action, editparams.toString(), context);\n    }\n\n    public String getDefaultTemplate()\n    {\n        if (this.defaultTemplate == null) {\n            return \"\";\n        } else {\n            return this.defaultTemplate;\n        }\n    }\n\n    public void setDefaultTemplate(String defaultTemplate)\n    {\n        this.defaultTemplate = defaultTemplate;\n\n        setMetaDataDirty(true);\n    }\n\n    public Vector<BaseObject> getComments()\n    {\n        return getComments(true);\n    }\n\n    /**\n     * @return the syntax of the document\n     * @since 2.3M1\n     */\n    @Override\n    public Syntax getSyntax()\n    {\n        // Can't be initialized in the XWikiDocument constructor because #getDefaultDocumentSyntax() need to create a\n        // XWikiDocument object to get preferences from wiki preferences pages and would thus generate an infinite loop\n        if (isNew() && this.syntax == null) {\n            this.syntax = getDefaultDocumentSyntax();\n        }\n\n        return this.syntax;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     * </p>\n     *\n     * @see org.xwiki.bridge.DocumentModelBridge#getSyntaxId()\n     * @deprecated use {link #getSyntax()} instead\n     */\n    @Override\n    @Deprecated(since = \"2.3M1\")\n    public String getSyntaxId()\n    {\n        return getSyntax().toIdString();\n    }\n\n    /**\n     * @param syntax the new syntax to set for this document\n     * @see #getSyntax()\n     * @since 2.3M1\n     */\n    public void setSyntax(Syntax syntax)\n    {\n        if (ObjectUtils.notEqual(this.syntax, syntax)) {\n            this.syntax = syntax;\n            // invalidate parsed xdom\n            this.xdomCache = null;\n        }\n    }\n\n    /**\n     * Note that this method cannot be removed for now since it's used by Hibernate for saving a XWikiDocument.\n     *\n     * @param syntaxId the new syntax id to set (e.g. {@code xwiki/2.0}, {@code xwiki/2.1}, etc)\n     * @see #getSyntaxId()\n     * @deprecated use {link #setSyntax(Syntax)} instead\n     */\n    @Deprecated(since = \"2.3M1\")\n    public void setSyntaxId(String syntaxId)\n    {\n        Syntax syntax;\n\n        // In order to preserve backward-compatibility with previous versions of XWiki in which the notion of Syntax Id\n        // did not exist, we check the passed syntaxId parameter. Since this parameter comes from the database (it's\n        // called automatically by Hibernate) it can be NULL or empty. In this case we consider the document is in\n        // syntax/1.0 syntax.\n        if (StringUtils.isBlank(syntaxId)) {\n            syntax = Syntax.XWIKI_1_0;\n        } else {\n            syntax = resolveSyntax(syntaxId);\n        }\n\n        setSyntax(syntax);\n    }\n\n    public Vector<BaseObject> getComments(boolean asc)\n    {\n        List<BaseObject> list = getXObjects(COMMENTSCLASS_REFERENCE);\n        if (list == null) {\n            return null;\n        } else if (asc) {\n            return new Vector<BaseObject>(list);\n        } else {\n            Vector<BaseObject> newlist = new Vector<BaseObject>();\n            for (int i = list.size() - 1; i >= 0; i--) {\n                newlist.add(list.get(i));\n            }\n            return newlist;\n        }\n    }\n\n    public boolean isCurrentUserCreator(XWikiContext context)\n    {\n        return isCreator(context.getUserReference());\n    }\n\n    /**\n     * @deprecated use {@link #isCreator(DocumentReference)} instead\n     */\n    @Deprecated\n    public boolean isCreator(String username)\n    {\n        if (username.equals(XWikiRightService.GUEST_USER_FULLNAME)) {\n            return false;\n        }\n\n        return username.equals(getCreator());\n    }\n\n    public boolean isCreator(DocumentReference username)\n    {\n        if (username == null) {\n            return false;\n        }\n\n        return username.equals(getCreatorReference());\n    }\n\n    public boolean isCurrentUserPage(XWikiContext context)\n    {\n        DocumentReference userReference = context.getUserReference();\n        if (userReference == null) {\n            return false;\n        }\n\n        return userReference.equals(getDocumentReference());\n    }\n\n    public boolean isCurrentLocalUserPage(XWikiContext context)\n    {\n        final DocumentReference userRef = context.getUserReference();\n        return userRef != null && userRef.equals(this.getDocumentReference());\n    }\n\n    public void resetArchive(XWikiContext context) throws XWikiException\n    {\n        boolean hasVersioning = context.getWiki().hasVersioning(context);\n        if (hasVersioning) {\n            WikiReference currentWiki = context.getWikiReference();\n            try {\n                context.setWikiReference(getDocumentReference().getWikiReference());\n\n                getVersioningStore(context).resetRCSArchive(this, true, context);\n            } finally {\n                context.setWikiReference(currentWiki);\n            }\n        }\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(XWikiContext context) throws XWikiException\n    {\n        // Read info in object\n        ObjectAddForm form = new ObjectAddForm();\n        form.setRequest(context.getRequest());\n        form.readRequest();\n\n        EntityReference classReference = getXClassEntityReferenceResolver().resolve(form.getClassName(),\n            EntityType.DOCUMENT, getDocumentReference());\n        BaseObject object = newXObject(classReference, context);\n        BaseClass baseclass = object.getXClass(context);\n        baseclass.fromMap(form.getObject(LOCAL_REFERENCE_SERIALIZER.serialize(resolveClassReference(classReference))),\n            object);\n\n        return object;\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject addXObjectFromRequest(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, \"\", 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, \"\", 0, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(DocumentReference classReference, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, prefix, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(DocumentReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, String prefix, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, prefix, 0, context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2M2\n     */\n    public List<BaseObject> addXObjectsFromRequest(DocumentReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectsFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectsFromRequest(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> addObjectsFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return addObjectsFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2M2\n     */\n    public List<BaseObject> addXObjectsFromRequest(DocumentReference classReference, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String[]> map = context.getRequest().getParameterMap();\n        List<Integer> objectsNumberDone = new ArrayList<Integer>();\n        List<BaseObject> objects = new ArrayList<BaseObject>();\n        String start = pref + LOCAL_REFERENCE_SERIALIZER.serialize(classReference) + \"_\";\n\n        for (String name : map.keySet()) {\n            if (name.startsWith(start)) {\n                int pos = name.indexOf('_', start.length() + 1);\n                String prefix = name.substring(0, pos);\n                int num = Integer.decode(prefix.substring(prefix.lastIndexOf('_') + 1)).intValue();\n                if (!objectsNumberDone.contains(Integer.valueOf(num))) {\n                    objectsNumberDone.add(Integer.valueOf(num));\n                    objects.add(addXObjectFromRequest(classReference, pref, num, context));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectsFromRequest(DocumentReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> addObjectsFromRequest(String className, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectsFromRequest(resolveClassReference(className), pref, context);\n    }\n\n    /**\n     * Adds object from an new object creation form.\n     *\n     * @since 2.2M2\n     */\n    public BaseObject addXObjectFromRequest(DocumentReference classReference, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(classReference, \"\", num, context);\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(DocumentReference, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, int num, XWikiContext context) throws XWikiException\n    {\n        return addObjectFromRequest(className, \"\", num, context);\n    }\n\n    /**\n     * Adds object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject addXObjectFromRequest(EntityReference classReference, String prefix, int num,\n        XWikiContext context) throws XWikiException\n    {\n        BaseObject object = newXObject(classReference, context);\n        BaseClass baseclass = object.getXClass(context);\n        String newPrefix =\n            prefix + LOCAL_REFERENCE_SERIALIZER.serialize(resolveClassReference(classReference)) + \"_\" + num;\n        baseclass.fromMap(Util.getObject(context.getRequest(), newPrefix), object);\n\n        return object;\n    }\n\n    /**\n     * @deprecated use {@link #addXObjectFromRequest(EntityReference, String, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject addObjectFromRequest(String className, String prefix, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return addXObjectFromRequest(resolveClassReference(className), prefix, num, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return updateObjectFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(classReference, prefix, 0, context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, String prefix, XWikiContext context)\n        throws XWikiException\n    {\n        return updateObjectFromRequest(className, prefix, 0, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public BaseObject updateXObjectFromRequest(EntityReference classReference, String prefix, int num,\n        XWikiContext context) throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        int nb;\n        BaseObject oldobject = getXObject(absoluteClassReference, num);\n        if (oldobject == null) {\n            nb = createXObject(classReference, context);\n            oldobject = getXObject(absoluteClassReference, nb);\n        } else {\n            nb = oldobject.getNumber();\n        }\n        BaseClass baseclass = oldobject.getXClass(context);\n        String newPrefix = prefix + LOCAL_REFERENCE_SERIALIZER.serialize(absoluteClassReference) + \"_\" + nb;\n        BaseObject newobject =\n            (BaseObject) baseclass.fromMap(Util.getObject(context.getRequest(), newPrefix), oldobject);\n        newobject.setNumber(oldobject.getNumber());\n        newobject.setGuid(oldobject.getGuid());\n        setXObject(nb, newobject);\n\n        return newobject;\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectFromRequest(EntityReference, String, int, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject updateObjectFromRequest(String className, String prefix, int num, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectFromRequest(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), prefix,\n            num, context);\n    }\n\n    /**\n     * Adds an object from an new object creation form.\n     *\n     * @since 2.2.3\n     */\n    public List<BaseObject> updateXObjectsFromRequest(EntityReference classReference, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectsFromRequest(classReference, \"\", context);\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectsFromRequest(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> updateObjectsFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        return updateObjectsFromRequest(className, \"\", context);\n    }\n\n    /**\n     * Adds multiple objects from an new objects creation form.\n     *\n     * @since 2.2.3\n     */\n    public List<BaseObject> updateXObjectsFromRequest(EntityReference classReference, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, String[]> map = context.getRequest().getParameterMap();\n        List<Integer> objectsNumberDone = new ArrayList<Integer>();\n        List<BaseObject> objects = new ArrayList<BaseObject>();\n        String start = pref + LOCAL_REFERENCE_SERIALIZER.serialize(absoluteClassReference) + \"_\";\n\n        for (String name : map.keySet()) {\n            if (name.startsWith(start)) {\n                int pos = name.indexOf('_', start.length() + 1);\n                String prefix = name.substring(0, pos);\n                int num = Integer.decode(prefix.substring(prefix.lastIndexOf('_') + 1)).intValue();\n                if (!objectsNumberDone.contains(Integer.valueOf(num))) {\n                    objectsNumberDone.add(Integer.valueOf(num));\n                    objects.add(updateXObjectFromRequest(classReference, pref, num, context));\n                }\n            }\n        }\n\n        return objects;\n    }\n\n    /**\n     * @deprecated use {@link #updateXObjectsFromRequest(EntityReference, String, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public List<BaseObject> updateObjectsFromRequest(String className, String pref, XWikiContext context)\n        throws XWikiException\n    {\n        return updateXObjectsFromRequest(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), pref,\n            context);\n    }\n\n    public boolean isAdvancedContent()\n    {\n        String[] matches = { \"<%\", \"#set\", \"#include\", \"#if\", \"public class\", \"/* Advanced content */\",\n        \"## Advanced content\", \"/* Programmatic content */\", \"## Programmatic content\" };\n        String content2 = getContent().toLowerCase();\n        for (String match : matches) {\n            if (content2.indexOf(match.toLowerCase()) != -1) {\n                return true;\n            }\n        }\n\n        if (HTML_TAG_PATTERN.matcher(content2).find()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean isProgrammaticContent()\n    {\n        String[] matches = { \"<%\", \"\\\\$xwiki.xWiki\", \"$xcontext.context\", \"$doc.document\", \"$xwiki.getXWiki()\",\n        \"$xcontext.getContext()\", \"$doc.getDocument()\", \"WithProgrammingRights(\", \"/* Programmatic content */\",\n        \"## Programmatic content\", \"$xwiki.search(\", \"$xwiki.createUser\", \"$xwiki.createNewWiki\",\n        \"$xwiki.addToAllGroup\", \"$xwiki.sendMessage\", \"$xwiki.copyDocument\", \"$xwiki.copyWikiWeb\",\n        \"$xwiki.copySpaceBetweenWikis\", \"$xwiki.parseGroovyFromString\", \"$doc.toXML()\", \"$doc.toXMLDocument()\", };\n        String content2 = getContent().toLowerCase();\n        for (String match : matches) {\n            if (content2.indexOf(match.toLowerCase()) != -1) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     * @since 2.2M1\n     */\n    public boolean removeXObject(BaseObject object)\n    {\n        List<BaseObject> objects = this.xObjects.get(object.getXClassReference());\n        // No objects at all, nothing to remove\n        if (objects == null) {\n            return false;\n        }\n        // Sometimes the object vector is wrongly indexed, meaning that objects are not at the right position\n        // Check if the right object is in place\n        int objectPosition = object.getNumber();\n        if (objectPosition < objects.size()) {\n            BaseObject storedObject = objects.get(objectPosition);\n            if (storedObject == null || !storedObject.equals(object)) {\n                // Try to find the correct position\n                objectPosition = objects.indexOf(object);\n            }\n        } else {\n            // The object position is greater than the array, that's invalid!\n            objectPosition = -1;\n        }\n        // If the object is not in the document, simply ignore this request\n        if (objectPosition < 0) {\n            return false;\n        }\n        // We don't remove objects, but set null in their place, so that the object number corresponds to its position\n        // in the vector\n        objects.set(objectPosition, null);\n        // Schedule the object for removal from the storage\n        addXObjectToRemove(object);\n\n        return true;\n    }\n\n    /**\n     * Remove an XObject from the document. The changes are not persisted until the document is saved.\n     *\n     * @param object the object to remove\n     * @return {@code true} if the object was successfully removed, {@code false} if the object was not found in the\n     *         current document.\n     * @deprecated use {@link #removeXObject(com.xpn.xwiki.objects.BaseObject)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public boolean removeObject(BaseObject object)\n    {\n        return removeXObject(object);\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param classReference The XClass reference of the XObjects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @since 2.2M1\n     */\n    public boolean removeXObjects(DocumentReference classReference)\n    {\n        List<BaseObject> objects = this.xObjects.get(classReference);\n        // No objects at all, nothing to remove\n        if (objects == null) {\n            return false;\n        }\n        // Schedule the object for removal from the storage\n        for (BaseObject object : objects) {\n            if (object != null) {\n                addXObjectToRemove(object);\n            }\n        }\n        // Empty the vector, retaining its size\n        int currentSize = objects.size();\n        objects.clear();\n        for (int i = 0; i < currentSize; i++) {\n            objects.add(null);\n        }\n\n        return true;\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param reference The XClass reference of the XObjects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @since 5.0M1\n     */\n    public boolean removeXObjects(EntityReference reference)\n    {\n        return removeXObjects(\n            getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));\n    }\n\n    /**\n     * Remove all the objects of a given type (XClass) from the document. The object counter is left unchanged, so that\n     * future objects will have new (different) numbers. However, on some storage engines the counter will be reset if\n     * the document is removed from the cache and reloaded from the persistent storage.\n     *\n     * @param className The class name of the objects to be removed.\n     * @return {@code true} if the objects were successfully removed, {@code false} if no object from the target class\n     *         was in the current document.\n     * @deprecated use {@link #removeXObjects(org.xwiki.model.reference.DocumentReference)} instead\n     */\n    @Deprecated(since = \"2.2M1\")\n    public boolean removeObjects(String className)\n    {\n        return removeXObjects(resolveClassReference(className));\n    }\n\n    /**\n     * Get the top sections contained in the document.\n     * <p>\n     * The section are filtered by xwiki.section.depth property on the maximum depth of the sections to return. This\n     * method is usually used to get \"editable\" sections.\n     *\n     * @return the sections in the current document\n     */\n    public List<DocumentSection> getSections() throws XWikiException\n    {\n        if (is10Syntax()) {\n            return getSections10();\n        } else {\n            List<DocumentSection> splitSections = new ArrayList<DocumentSection>();\n            List<HeaderBlock> headers = getFilteredHeaders();\n\n            int sectionNumber = 1;\n            for (HeaderBlock header : headers) {\n                // put -1 as index since there is no way to get the position of the header in the source\n                int documentSectionIndex = -1;\n\n                // Need to do the same thing than 1.0 content here\n                String documentSectionLevel = StringUtils.repeat(\"1.\", header.getLevel().getAsInt() - 1) + \"1\";\n\n                DocumentSection docSection = new DocumentSection(sectionNumber++, documentSectionIndex,\n                    documentSectionLevel, renderXDOM(new XDOM(header.getChildren()), getSyntax()));\n                splitSections.add(docSection);\n            }\n\n            return splitSections;\n        }\n    }\n\n    /**\n     * Get XWiki context from execution context.\n     *\n     * @return the XWiki context for the current thread\n     */\n    private XWikiContext getXWikiContext()\n    {\n        Provider<XWikiContext> xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n\n        if (xcontextProvider != null) {\n            return xcontextProvider.get();\n        }\n\n        return null;\n    }\n\n    /**\n     * Filter the headers from a document XDOM based on xwiki.section.depth property from xwiki.cfg file.\n     *\n     * @return the filtered headers\n     */\n    private List<HeaderBlock> getFilteredHeaders()\n    {\n        List<HeaderBlock> filteredHeaders = new ArrayList<HeaderBlock>();\n\n        // Get the maximum header level\n        int sectionDepth = 2;\n        XWikiContext context = getXWikiContext();\n        if (context != null) {\n            sectionDepth = (int) context.getWiki().getSectionEditingDepth();\n        }\n\n        // Get the headers.\n        //\n        // Note that we need to only take into account SectionBlock that are children of other SectionBlocks so that\n        // we are in sync with the section editing buttons added in xwiki.js. Being able to section edit any heading is\n        // too complex. For example if you have (in XWiki Syntax 2.0):\n        // = Heading1 =\n        // para1\n        // == Heading2 ==\n        // para2\n        // (((\n        // == Heading3 ==\n        // para3\n        // (((\n        // == Heading4 ==\n        // para4\n        // )))\n        // )))\n        // == Heading5 ==\n        // para5\n        //\n        // Then if we were to support editing \"Heading4\", its content would be:\n        // para4\n        // )))\n        // )))\n        //\n        // Which obviously is not correct...\n\n        final XDOM xdom = getXDOM();\n        if (!xdom.getChildren().isEmpty()) {\n            Block currentBlock = xdom.getChildren().get(0);\n            while (currentBlock != null) {\n                if (currentBlock instanceof SectionBlock) {\n                    // The next children block is a HeaderBlock but we check to be on the safe side...\n                    Block nextChildrenBlock = currentBlock.getChildren().get(0);\n                    if (nextChildrenBlock instanceof HeaderBlock) {\n                        HeaderBlock headerBlock = (HeaderBlock) nextChildrenBlock;\n                        if (headerBlock.getLevel().getAsInt() <= sectionDepth) {\n                            filteredHeaders.add(headerBlock);\n                        }\n                    }\n                    currentBlock = nextChildrenBlock;\n                } else {\n                    Block nextSibling = currentBlock.getNextSibling();\n                    if (nextSibling == null) {\n                        currentBlock = currentBlock.getParent();\n                        while (currentBlock != null) {\n                            if (currentBlock.getNextSibling() != null) {\n                                currentBlock = currentBlock.getNextSibling();\n                                break;\n                            }\n                            currentBlock = currentBlock.getParent();\n                        }\n                    } else {\n                        currentBlock = nextSibling;\n                    }\n                }\n            }\n        }\n\n        return filteredHeaders;\n    }\n\n    /**\n     * @return the sections in the current document\n     */\n    private List<DocumentSection> getSections10()\n    {\n        // Pattern to match the title. Matches only level 1 and level 2 headings.\n        Pattern headingPattern = Pattern.compile(\"^[ \\\\t]*+(1(\\\\.1){0,1}+)[ \\\\t]++(.++)$\", Pattern.MULTILINE);\n        Matcher matcher = headingPattern.matcher(getContent());\n        List<DocumentSection> splitSections = new ArrayList<DocumentSection>();\n        int sectionNumber = 0;\n        // find title to split\n        while (matcher.find()) {\n            ++sectionNumber;\n            String sectionLevel = matcher.group(1);\n            String sectionTitle = matcher.group(3);\n            int sectionIndex = matcher.start();\n            // Initialize a documentSection object.\n            DocumentSection docSection = new DocumentSection(sectionNumber, sectionIndex, sectionLevel, sectionTitle);\n            // Add the document section to list.\n            splitSections.add(docSection);\n        }\n\n        return splitSections;\n    }\n\n    /**\n     * Return a Document section with parameter is sectionNumber.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return\n     * @throws XWikiException error when extracting sections from document\n     */\n    public DocumentSection getDocumentSection(int sectionNumber) throws XWikiException\n    {\n        // return a document section according to section number\n        return getSections().get(sectionNumber - 1);\n    }\n\n    /**\n     * Return the content of a section.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return the content of a section or null if the section can't be found.\n     * @throws XWikiException error when trying to extract section content\n     */\n    public String getContentOfSection(int sectionNumber) throws XWikiException\n    {\n        String content = null;\n\n        if (is10Syntax()) {\n            content = getContentOfSection10(sectionNumber);\n        } else {\n            List<HeaderBlock> headers = getFilteredHeaders();\n\n            if (headers.size() >= sectionNumber) {\n                SectionBlock section = headers.get(sectionNumber - 1).getSection();\n                content = renderXDOM(new XDOM(Collections.<Block>singletonList(section)), getSyntax());\n            }\n        }\n\n        return content;\n    }\n\n    /**\n     * Return the content of a section.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @return the content of a section\n     * @throws XWikiException error when trying to extract section content\n     */\n    private String getContentOfSection10(int sectionNumber) throws XWikiException\n    {\n        List<DocumentSection> splitSections = getSections();\n        int indexEnd = 0;\n        // get current section\n        DocumentSection section = splitSections.get(sectionNumber - 1);\n        int indexStart = section.getSectionIndex();\n        String sectionLevel = section.getSectionLevel();\n        // Determine where this section ends, which is at the start of the next section of the\n        // same or a higher level.\n        for (int i = sectionNumber; i < splitSections.size(); i++) {\n            DocumentSection nextSection = splitSections.get(i);\n            String nextLevel = nextSection.getSectionLevel();\n            if (sectionLevel.equals(nextLevel) || sectionLevel.length() > nextLevel.length()) {\n                indexEnd = nextSection.getSectionIndex();\n                break;\n            }\n        }\n        String sectionContent = null;\n        if (indexStart < 0) {\n            indexStart = 0;\n        }\n\n        if (indexEnd == 0) {\n            sectionContent = getContent().substring(indexStart);\n        } else {\n            sectionContent = getContent().substring(indexStart, indexEnd);\n        }\n\n        return sectionContent;\n    }\n\n    /**\n     * Update a section content in document.\n     *\n     * @param sectionNumber the index (starting at 1) of the section in the list of all sections in the document.\n     * @param newSectionContent the new section content.\n     * @return the new document content.\n     * @throws XWikiException error when updating content\n     */\n    public String updateDocumentSection(int sectionNumber, String newSectionContent) throws XWikiException\n    {\n        String content;\n        if (is10Syntax()) {\n            content = updateDocumentSection10(sectionNumber, newSectionContent);\n        } else {\n            // Get the current section block\n            HeaderBlock header = getFilteredHeaders().get(sectionNumber - 1);\n\n            XDOM xdom = (XDOM) header.getRoot();\n\n            // newSectionContent -> Blocks\n            List<Block> blocks = parseContent(newSectionContent).getChildren();\n            int sectionLevel = header.getLevel().getAsInt();\n            for (int level = 1; level < sectionLevel && blocks.size() == 1\n                && blocks.get(0) instanceof SectionBlock; ++level) {\n                blocks = blocks.get(0).getChildren();\n            }\n\n            // replace old current SectionBlock with new Blocks\n            Block section = header.getSection();\n            section.getParent().replaceChild(blocks, section);\n\n            // render back XDOM to document's content syntax\n            content = renderXDOM(xdom, getSyntax());\n        }\n\n        return content;\n    }\n\n    /**\n     * Update a section content in document.\n     *\n     * @param sectionNumber the index (+1) of the section in the list of all sections in the document.\n     * @param newSectionContent the new section content.\n     * @return the new document content.\n     * @throws XWikiException error when updating document content with section content\n     */\n    private String updateDocumentSection10(int sectionNumber, String newSectionContent) throws XWikiException\n    {\n        StringBuilder newContent = new StringBuilder();\n        // get document section that will be edited\n        DocumentSection docSection = getDocumentSection(sectionNumber);\n        int numberOfSections = getSections().size();\n        int indexSection = docSection.getSectionIndex();\n        if (numberOfSections == 1) {\n            // there is only a sections in document\n            String contentBegin = getContent().substring(0, indexSection);\n            newContent = newContent.append(contentBegin).append(newSectionContent);\n            return newContent.toString();\n        } else if (sectionNumber == numberOfSections) {\n            // edit lastest section that doesn't contain subtitle\n            String contentBegin = getContent().substring(0, indexSection);\n            newContent = newContent.append(contentBegin).append(newSectionContent);\n            return newContent.toString();\n        } else {\n            String sectionLevel = docSection.getSectionLevel();\n            int nextSectionIndex = 0;\n            // get index of next section\n            for (int i = sectionNumber; i < numberOfSections; i++) {\n                DocumentSection nextSection = getDocumentSection(i + 1); // get next section\n                String nextSectionLevel = nextSection.getSectionLevel();\n                if (sectionLevel.equals(nextSectionLevel)) {\n                    nextSectionIndex = nextSection.getSectionIndex();\n                    break;\n                } else if (sectionLevel.length() > nextSectionLevel.length()) {\n                    nextSectionIndex = nextSection.getSectionIndex();\n                    break;\n                }\n            }\n\n            if (nextSectionIndex == 0) {// edit the last section\n                newContent = newContent.append(getContent().substring(0, indexSection)).append(newSectionContent);\n                return newContent.toString();\n            } else {\n                String contentAfter = getContent().substring(nextSectionIndex);\n                String contentBegin = getContent().substring(0, indexSection);\n                newContent = newContent.append(contentBegin).append(newSectionContent).append(contentAfter);\n            }\n\n            return newContent.toString();\n        }\n    }\n\n    /**\n     * Computes a document hash, taking into account all document data: content, objects, attachments, metadata... TODO:\n     * cache the hash value, update only on modification.\n     */\n    public String getVersionHashCode(XWikiContext context)\n    {\n        MessageDigest md5 = null;\n\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException ex) {\n            LOGGER.error(\"Cannot create MD5 object\", ex);\n            return hashCode() + \"\";\n        }\n\n        try {\n            String valueBeforeMD5 = toXML(true, false, true, false, context);\n            md5.update(valueBeforeMD5.getBytes());\n\n            byte[] array = md5.digest();\n            StringBuilder sb = new StringBuilder();\n            for (byte element : array) {\n                int b = element & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n\n            return sb.toString();\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while computing document hash\", ex);\n        }\n\n        return hashCode() + \"\";\n    }\n\n    public static String getInternalPropertyName(String propname, XWikiContext context)\n    {\n        ContextualLocalizationManager localizationManager = Utils.getComponent(ContextualLocalizationManager.class);\n        String cpropname = StringUtils.capitalize(propname);\n\n        return localizationManager == null ? cpropname : localizationManager.getTranslationPlain(cpropname);\n    }\n\n    public String getInternalProperty(String propname)\n    {\n        String methodName = \"get\" + StringUtils.capitalize(propname);\n        try {\n            Method method = getClass().getDeclaredMethod(methodName, (Class[]) null);\n            return (String) method.invoke(this, (Object[]) null);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String getCustomClass()\n    {\n        if (this.customClass == null) {\n            return \"\";\n        }\n\n        return this.customClass;\n    }\n\n    public void setCustomClass(String customClass)\n    {\n        this.customClass = customClass;\n        setMetaDataDirty(true);\n    }\n\n    public void setValidationScript(String validationScript)\n    {\n        this.validationScript = validationScript;\n\n        setMetaDataDirty(true);\n    }\n\n    public String getValidationScript()\n    {\n        if (this.validationScript == null) {\n            return \"\";\n        } else {\n            return this.validationScript;\n        }\n    }\n\n    public String getComment()\n    {\n        if (this.comment == null) {\n            return \"\";\n        }\n\n        return this.comment;\n    }\n\n    public void setComment(String comment)\n    {\n        this.comment = comment;\n    }\n\n    public boolean isMinorEdit()\n    {\n        return this.isMinorEdit;\n    }\n\n    public void setMinorEdit(boolean isMinor)\n    {\n        this.isMinorEdit = isMinor;\n    }\n\n    // methods for easy table update. It is need only for hibernate.\n    // when hibernate update old database without minorEdit field, hibernate will create field with\n    // null in despite of notnull in hbm.\n    // (http://opensource.atlassian.com/projects/hibernate/browse/HB-1151)\n    // so minorEdit will be null for old documents. But hibernate can't convert null to boolean.\n    // so we need convert Boolean to boolean\n    protected Boolean getMinorEdit1()\n    {\n        return Boolean.valueOf(isMinorEdit());\n    }\n\n    protected void setMinorEdit1(Boolean isMinor)\n    {\n        this.isMinorEdit = (isMinor != null && isMinor.booleanValue());\n    }\n\n    /**\n     * Create, add and return a new object with the provided class.\n     * <p>\n     * Note that absolute reference are not supported for xclasses which mean that the wiki part (whatever the wiki is)\n     * of the reference will be systematically removed.\n     *\n     * @param classReference the reference of the class\n     * @param context the XWiki context\n     * @return the newly created object\n     * @throws XWikiException error when creating the new object\n     * @since 2.2.3\n     */\n    public BaseObject newXObject(EntityReference classReference, XWikiContext context) throws XWikiException\n    {\n        int nb = createXObject(classReference, context);\n        return getXObject(resolveClassReference(classReference), nb);\n    }\n\n    /**\n     * @deprecated use {@link #newXObject(EntityReference, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject newObject(String className, XWikiContext context) throws XWikiException\n    {\n        return newXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseObject getXObject(DocumentReference classReference, boolean create, XWikiContext context)\n    {\n        try {\n            BaseObject obj = getXObject(classReference);\n\n            if ((obj == null) && create) {\n                return newXObject(classReference, context);\n            }\n\n            if (obj == null) {\n                return null;\n            } else {\n                return obj;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @since 3.4M1\n     */\n    public BaseObject getXObject(EntityReference classReference, boolean create, XWikiContext context)\n    {\n        try {\n            BaseObject obj = getXObject(classReference);\n\n            if ((obj == null) && create) {\n                return newXObject(classReference, context);\n            }\n\n            if (obj == null) {\n                return null;\n            } else {\n                return obj;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * @deprecated use {@link #getXObject(DocumentReference, boolean, XWikiContext)} instead\n     */\n    @Deprecated(since = \"2.2M2\")\n    public BaseObject getObject(String className, boolean create, XWikiContext context)\n    {\n        return getXObject(\n            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()), create,\n            context);\n    }\n\n    public boolean validate(XWikiContext context) throws XWikiException\n    {\n        return validate(null, context);\n    }\n\n    public boolean validate(String[] classNames, XWikiContext context) throws XWikiException\n    {\n        boolean isValid = true;\n        if ((classNames == null) || (classNames.length == 0)) {\n            for (DocumentReference classReference : getXObjects().keySet()) {\n                BaseClass bclass = context.getWiki().getXClass(classReference, context);\n                List<BaseObject> objects = getXObjects(classReference);\n                for (BaseObject obj : objects) {\n                    if (obj != null) {\n                        isValid &= bclass.validateObject(obj, context);\n                    }\n                }\n            }\n        } else {\n            for (String className : classNames) {\n                List<BaseObject> objects = getXObjects(getCurrentMixedDocumentReferenceResolver().resolve(className));\n                if (objects != null) {\n                    for (BaseObject obj : objects) {\n                        if (obj != null) {\n                            BaseClass bclass = obj.getXClass(context);\n                            isValid &= bclass.validateObject(obj, context);\n                        }\n                    }\n                }\n            }\n        }\n\n        String validationScript = \"\";\n        XWikiRequest req = context.getRequest();\n        if (req != null) {\n            validationScript = req.get(\"xvalidation\");\n        }\n\n        if ((validationScript == null) || (validationScript.trim().equals(\"\"))) {\n            validationScript = getValidationScript();\n        }\n\n        if ((validationScript != null) && (!validationScript.trim().equals(\"\"))) {\n            isValid &= executeValidationScript(context, validationScript);\n        }\n\n        return isValid;\n    }\n\n    public static void backupContext(Map<String, Object> backup, XWikiContext context)\n    {\n        // The XWiki Context isn't recreated when the Execution Context is cloned so we have to backup some of its data.\n        // Backup the current document on the XWiki Context.\n        backup.put(\"doc\", context.getDoc());\n\n        backup.put(\"cdoc\", context.get(\"cdoc\"));\n        backup.put(\"tdoc\", context.get(\"tdoc\"));\n\n        // Backup the secure document\n        backup.put(CKEY_SDOC, context.get(CKEY_SDOC));\n\n        // Clone the Execution Context to provide isolation. The clone will have a new Velocity and Script Context.\n        Execution execution = Utils.getComponent(Execution.class);\n        try {\n            execution.pushContext(Utils.getComponent(ExecutionContextManager.class).clone(execution.getContext()));\n        } catch (ExecutionContextException e) {\n            throw new RuntimeException(\"Failed to clone the Execution Context\", e);\n        }\n\n        // Bridge with old XWiki Context, required for legacy code.\n        execution.getContext().setProperty(XWikiContext.EXECUTIONCONTEXT_KEY, context);\n    }\n\n    public static void restoreContext(Map<String, Object> backup, XWikiContext context)\n    {\n        // Restore the Execution Context. This will also restore the previous Velocity and Script Context.\n        Execution execution = Utils.getComponent(Execution.class);\n        execution.popContext();\n\n        // Restore the current document on the XWiki Context.\n        context.setDoc((XWikiDocument) backup.get(\"doc\"));\n\n        context.put(\"cdoc\", backup.get(\"cdoc\"));\n        context.put(\"tdoc\", backup.get(\"tdoc\"));\n\n        // Restore the secure document\n        context.put(CKEY_SDOC, backup.get(CKEY_SDOC));\n    }\n\n    public void setAsContextDoc(XWikiContext context)\n    {\n        context.setDoc(this);\n        context.remove(\"cdoc\");\n        context.remove(\"tdoc\");\n\n        // Get rid of secure document (so that it fallback on context document)\n        context.remove(CKEY_SDOC);\n    }\n\n    /**\n     * @return the String representation of the previous version of this document or null if this is the first version.\n     */\n    public String getPreviousVersion()\n    {\n        XWikiDocumentArchive archive = loadDocumentArchive();\n        if (archive != null) {\n            Version prevVersion = archive.getPrevVersion(getRCSVersion());\n            if (prevVersion != null) {\n                return prevVersion.toString();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public String toString()\n    {\n        return getFullName();\n    }\n\n    /**\n     * Indicates whether the document should be 'hidden' or not, meaning that it should not be returned in public search\n     * results.\n     *\n     * @param hidden The new value of the {@link #hidden} property.\n     */\n    public void setHidden(Boolean hidden)\n    {\n        if (hidden == null) {\n            this.hidden = false;\n        } else {\n            this.hidden = hidden;\n        }\n    }\n\n    /**\n     * Indicates whether the document is 'hidden' or not, meaning that it should not be returned in public search\n     * results.\n     *\n     * @return <code>true</code> if the document is hidden and does not appear among the results of\n     *         {@link com.xpn.xwiki.api.XWiki#searchDocuments(String)}, <code>false</code> otherwise.\n     */\n    public Boolean isHidden()\n    {\n        return this.hidden;\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntaxId the syntax to convert to (e.g. {@code xwiki/2.0}, {@code xhtml/1.0}, etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public void convertSyntax(String targetSyntaxId, XWikiContext context) throws XWikiException\n    {\n        try {\n            convertSyntax(Syntax.valueOf(targetSyntaxId), context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntaxId + \"]\", e);\n        }\n    }\n\n    /**\n     * Convert the current document content from its current syntax to the new syntax passed as parameter.\n     *\n     * @param targetSyntax the syntax to convert to (e.g. {@code xwiki/2.0}, {@code xhtml/1.0}, etc)\n     * @throws XWikiException if an exception occurred during the conversion process\n     */\n    public void convertSyntax(Syntax targetSyntax, XWikiContext context) throws XWikiException\n    {\n        // convert content\n        setContent(performSyntaxConversion(getContent(), getDocumentReference(), getSyntax(), targetSyntax));\n\n        // convert objects\n        Map<DocumentReference, List<BaseObject>> objectsByClass = getXObjects();\n\n        for (List<BaseObject> objects : objectsByClass.values()) {\n            for (BaseObject bobject : objects) {\n                if (bobject != null) {\n                    BaseClass bclass = bobject.getXClass(context);\n                    for (Object fieldClass : bclass.getProperties()) {\n                        if (fieldClass instanceof TextAreaClass && ((TextAreaClass) fieldClass).isWikiContent()) {\n                            TextAreaClass textAreaClass = (TextAreaClass) fieldClass;\n                            PropertyInterface field = bobject.getField(textAreaClass.getName());\n\n                            // Make sure the field is the right type (might happen while a document is being migrated)\n                            if (field instanceof LargeStringProperty) {\n                                LargeStringProperty largeField = (LargeStringProperty) field;\n\n                                largeField.setValue(performSyntaxConversion(largeField.getValue(),\n                                    getDocumentReference(), getSyntax(), targetSyntax));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // change syntax\n        setSyntax(targetSyntax);\n    }\n\n    /**\n     * NOTE: This method caches the XDOM and returns a clone that can be safely modified.\n     *\n     * @return the XDOM corresponding to the document's string content\n     */\n    @Override\n    public XDOM getXDOM()\n    {\n        if (this.xdomCache == null) {\n            try {\n                this.xdomCache = parseContent(getContent());\n            } catch (XWikiException e) {\n                ErrorBlockGenerator errorBlockGenerator = Utils.getComponent(ErrorBlockGenerator.class);\n                return new XDOM(errorBlockGenerator.generateErrorBlocks(false, TM_FAILEDDOCUMENTPARSE,\n                    \"Failed to parse document content\", null, e));\n            }\n        }\n\n        return this.xdomCache.clone();\n    }\n\n    /**\n     * @return true if the document has a xwiki/1.0 syntax content\n     */\n    public boolean is10Syntax()\n    {\n        return is10Syntax(getSyntaxId());\n    }\n\n    /**\n     * @return true if the document has a xwiki/1.0 syntax content\n     */\n    public boolean is10Syntax(String syntaxId)\n    {\n        return Syntax.XWIKI_1_0.toIdString().equalsIgnoreCase(syntaxId);\n    }\n\n    private void init(DocumentReference reference)\n    {\n        // if the passed reference is null consider it points to the default reference\n        if (reference == null) {\n            setDocumentReference(\n                Utils.<Provider<DocumentReference>>getComponent(DocumentReference.TYPE_PROVIDER).get());\n        } else {\n            setDocumentReference(reference);\n        }\n\n        this.updateDate = new Date();\n        this.updateDate.setTime((this.updateDate.getTime() / 1000) * 1000);\n        this.contentUpdateDate = new Date();\n        this.contentUpdateDate.setTime((this.contentUpdateDate.getTime() / 1000) * 1000);\n        this.creationDate = new Date();\n        this.creationDate.setTime((this.creationDate.getTime() / 1000) * 1000);\n        this.content = \"\";\n        this.format = \"\";\n        this.locale = Locale.ROOT;\n        this.defaultLocale = Locale.ROOT;\n        this.customClass = \"\";\n        this.comment = \"\";\n\n        // Note: As there's no notion of an Empty document we don't set the original document\n        // field. Thus getOriginalDocument() may return null.\n    }\n\n    private boolean executeValidationScript(XWikiContext context, String validationScript)\n    {\n        try {\n            ContextualAuthorizationManager authorization = Utils.getComponent(ContextualAuthorizationManager.class);\n            DocumentReference validationScriptReference =\n                getCurrentDocumentReferenceResolver().resolve(validationScript, getDocumentReference());\n\n            // Make sure target document is allowed to execute Groovy\n            // TODO: this check should probably be right in XWiki#parseGroovyFromPage\n            authorization.checkAccess(Right.PROGRAM, validationScriptReference);\n\n            XWikiValidationInterface validObject =\n                (XWikiValidationInterface) context.getWiki().parseGroovyFromPage(validationScript, context);\n\n            return validObject.validateDocument(this, context);\n        } catch (Throwable e) {\n            XWikiValidationStatus.addExceptionToContext(getFullName(), \"\", e, context);\n            return false;\n        }\n    }\n\n    /**\n     * Convert the passed content from the passed syntax to the passed new syntax.\n     *\n     * @param content the content to convert\n     * @param source the reference to where the content comes from (eg document reference)\n     * @param currentSyntaxId the syntax of the current content to convert\n     * @param targetSyntax the new syntax after the conversion\n     * @return the converted content in the new syntax\n     * @throws XWikiException if an exception occurred during the conversion process\n     * @since 2.4M2\n     */\n    private static String performSyntaxConversion(String content, DocumentReference source, Syntax currentSyntaxId,\n        Syntax targetSyntax) throws XWikiException\n    {\n        try {\n            XDOM dom = parseContent(currentSyntaxId, content, source);\n            return renderXDOM(dom, targetSyntax);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to convert document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    /**\n     * Render provided XDOM into content of the provided syntax identifier.\n     *\n     * @param content the XDOM content to render\n     * @param targetSyntax the syntax identifier of the rendered content\n     * @return the rendered content\n     * @throws XWikiException if an exception occurred during the rendering process\n     */\n    protected static String renderXDOM(XDOM content, Syntax targetSyntax) throws XWikiException\n    {\n        try {\n            BlockRenderer renderer = Utils.getComponent(BlockRenderer.class, targetSyntax.toIdString());\n            WikiPrinter printer = new DefaultWikiPrinter();\n            renderer.render(content, printer);\n            return printer.toString();\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to render document to syntax [\" + targetSyntax + \"]\", e);\n        }\n    }\n\n    private XDOM parseContent(String content) throws XWikiException\n    {\n        return parseContent(getSyntax(), content, getDocumentReference());\n    }\n\n    /**\n     * @param source the reference to where the content comes from (eg document reference)\n     */\n    private static XDOM parseContent(Syntax syntax, String content, DocumentReference source) throws XWikiException\n    {\n        ContentParser parser = Utils.getComponent(ContentParser.class);\n\n        try {\n            return parser.parse(content, syntax, source);\n        } catch (MissingParserException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to find a parser for syntax [\" + syntax.toIdString() + \"]\", e);\n        } catch (ParseException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to parse content of syntax [\" + syntax.toIdString() + \"]\", e);\n        }\n    }\n\n    /**\n     * If there's no parser available for the specified syntax default to the XWiki 2.1 syntax.\n     */\n    private Syntax getDefaultDocumentSyntax()\n    {\n        Syntax syntax = Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n\n        if (syntax == null || (!Utils.getComponentManager().hasComponent(Parser.class, syntax.toIdString())\n            && !Syntax.XWIKI_2_1.equals(syntax))) {\n            LOGGER.warn(\"Failed to find parser for the default syntax [{}]. Defaulting to xwiki/2.1 syntax.\", syntax);\n            syntax = Syntax.XWIKI_2_1;\n        }\n\n        return syntax;\n    }\n\n    /**\n     * Backward-compatibility method to use in order to resolve a class reference passed as a String into a\n     * DocumentReference proper.\n     *\n     * @return the resolved class reference but using this document's wiki if the passed String doesn't specify a wiki,\n     *         the \"XWiki\" space if the passed String doesn't specify a space and this document's page if the passed\n     *         String doesn't specify a page.\n     */\n    public DocumentReference resolveClassReference(String documentName)\n    {\n        DocumentReference defaultReference = new DocumentReference(getDocumentReference().getWikiReference().getName(),\n            XWiki.SYSTEM_SPACE, getDocumentReference().getName());\n        return getExplicitDocumentReferenceResolver().resolve(documentName, defaultReference);\n    }\n\n    /**\n     * Transforms a XClass reference relative to this document into an absolute reference.\n     */\n    private DocumentReference resolveClassReference(EntityReference reference)\n    {\n        if (reference instanceof DocumentReference) {\n            return (DocumentReference) reference;\n        } else if (reference instanceof LocalDocumentReference) {\n            return new DocumentReference((LocalDocumentReference) reference, getDocumentReference().getWikiReference());\n        } else {\n            DocumentReference defaultReference =\n                new DocumentReference(getDocumentReference().getWikiReference().getName(), XWiki.SYSTEM_SPACE,\n                    getDocumentReference().getName());\n            return getExplicitReferenceDocumentReferenceResolver().resolve(reference, defaultReference);\n        }\n    }\n\n    /**\n     * Return the reference of the parent document as it stored and passed to\n     * {@link #setParentReference(EntityReference)}.\n     * <p>\n     * You should use {@link #getParentReference()} reference if you want the complete parent reference.\n     *\n     * @return the relative parent reference\n     * @since 2.2.3\n     */\n    public EntityReference getRelativeParentReference()\n    {\n        return this.parentReference;\n    }\n\n    private BaseObject prepareXObject(EntityReference classReference)\n    {\n        DocumentReference absoluteClassReference = resolveClassReference(classReference);\n        BaseObject bobject = getXObject(absoluteClassReference);\n        if (bobject == null) {\n            bobject = new BaseObject();\n            bobject.setXClassReference(classReference);\n\n            addXObject(bobject);\n        }\n        bobject.setDocumentReference(getDocumentReference());\n        setMetaDataDirty(true);\n        return bobject;\n    }\n\n    /**\n     * Apply a 3 ways merge on the current document based on provided previous and new version of the document.\n     * <p>\n     * All 3 documents are supposed to have the same document reference and language already since that's what makes\n     * them uniques.\n     *\n     * @param previousDocument the previous version of the document\n     * @param newDocument the next version of the document\n     * @param configuration the configuration of the merge indicates how to deal with some conflicts use cases, etc.\n     * @param context the XWiki context\n     * @return a repport of what happen during the merge (errors, etc.)\n     * @since 3.2M1\n     * @deprecated use {@link MergeManager#mergeDocument(DocumentModelBridge, DocumentModelBridge, DocumentModelBridge,\n     *  MergeConfiguration)} instead\n     */\n    @Deprecated(since = \"11.8RC1\")\n    public MergeResult merge(XWikiDocument previousDocument, XWikiDocument newDocument,\n        MergeConfiguration configuration, XWikiContext context)\n    {\n        MergeManager mergeManager = Utils.getComponent(MergeManager.class);\n        MergeDocumentResult mergeDocumentResult =\n            mergeManager.mergeDocument(previousDocument, newDocument, this, configuration);\n\n        MergeResult mergeResult = new MergeResult();\n        mergeResult.getLog().addAll(mergeDocumentResult.getLog());\n        mergeResult.setModified(mergeResult.isModified() || mergeDocumentResult.isModified());\n\n        if (!configuration.isProvidedVersionsModifiables())\n        {\n            this.apply((XWikiDocument) mergeDocumentResult.getMergeResult());\n        }\n\n        return mergeResult;\n    }\n\n    /**\n     * Apply modification comming from provided document.\n     * <p>\n     * Thid method does not take into account versions and author related informations and the provided document should\n     * have the same reference. Like {@link #merge(XWikiDocument, XWikiDocument, MergeConfiguration, XWikiContext)},\n     * this method is dealing with \"real\" data and should not change anything related to version management and document\n     * identifier.\n     * <p>\n     * Important note: this method does not take care of attachments contents related operations and only remove\n     * attachments which need to be removed from the list. For memory handling reasons all attachments contents related\n     * operations should be done elsewhere.\n     *\n     * @param document the document to apply\n     * @return false is nothing changed\n     */\n    public boolean apply(XWikiDocument document)\n    {\n        return apply(document, true);\n    }\n\n    /**\n     * Apply modification comming from provided document.\n     * <p>\n     * Thid method does not take into account versions and author related informations and the provided document should\n     * have the same reference. Like {@link #merge(XWikiDocument, XWikiDocument, MergeConfiguration, XWikiContext)},\n     * this method is dealing with \"real\" data and should not change everything related to version management and\n     * document identifier.\n     *\n     * @param document the document to apply\n     * @return false is nothing changed\n     */\n    public boolean apply(XWikiDocument document, boolean clean)\n    {\n        boolean modified = false;\n\n        // /////////////////////////////////\n        // Document\n\n        if (!StringUtils.equals(getContent(), document.getContent())) {\n            setContent(document.getContent());\n            modified = true;\n        }\n        if (ObjectUtils.notEqual(getSyntax(), document.getSyntax())) {\n            setSyntax(document.getSyntax());\n            modified = true;\n        }\n\n        if (ObjectUtils.notEqual(getDefaultLocale(), document.getDefaultLocale())) {\n            setDefaultLocale(document.getDefaultLocale());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getTitle(), document.getTitle())) {\n            setTitle(document.getTitle());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getDefaultTemplate(), document.getDefaultTemplate())) {\n            setDefaultTemplate(document.getDefaultTemplate());\n            modified = true;\n        }\n        if (ObjectUtils.notEqual(getRelativeParentReference(), document.getRelativeParentReference())) {\n            setParentReference(document.getRelativeParentReference());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getCustomClass(), document.getCustomClass())) {\n            setCustomClass(document.getCustomClass());\n            modified = true;\n        }\n\n        if (!StringUtils.equals(getValidationScript(), document.getValidationScript())) {\n            setValidationScript(document.getValidationScript());\n            modified = true;\n        }\n\n        if (isHidden() != document.isHidden()) {\n            setHidden(document.isHidden());\n            modified = true;\n        }\n\n        // /////////////////////////////////\n        // XObjects\n\n        if (clean) {\n            // Delete objects that don't exist anymore\n            for (List<BaseObject> objects : getXObjects().values()) {\n                // Duplicate the list since we are potentially going to modify it\n                for (BaseObject originalObj : new ArrayList<BaseObject>(objects)) {\n                    if (originalObj != null) {\n                        BaseObject newObj =\n                            document.getXObject(originalObj.getXClassReference(), originalObj.getNumber());\n                        if (newObj == null) {\n                            // The object was deleted\n                            removeXObject(originalObj);\n                            modified = true;\n                        }\n                    }\n                }\n            }\n        }\n        // Add new objects or update existing objects\n        for (List<BaseObject> objects : document.getXObjects().values()) {\n            for (BaseObject newObj : objects) {\n                if (newObj != null) {\n                    BaseObject originalObj = getXObject(newObj.getXClassReference(), newObj.getNumber());\n                    if (originalObj == null) {\n                        // The object added or modified\n                        setXObject(newObj.getNumber(), newObj);\n                        modified = true;\n                    } else {\n                        // The object added or modified\n                        modified |= originalObj.apply(newObj, clean);\n                    }\n                }\n            }\n        }\n\n        // /////////////////////////////////\n        // XClass\n\n        modified |= getXClass().apply(document.getXClass(), clean);\n        if (ObjectUtils.notEqual(getXClassXML(), document.getXClassXML())) {\n            setXClassXML(document.getXClassXML());\n            modified = true;\n        }\n\n        // /////////////////////////////////\n        // Attachments\n\n        if (clean) {\n            // Delete attachments that don't exist anymore\n            for (XWikiAttachment attachment : new ArrayList<XWikiAttachment>(getAttachmentList())) {\n                if (document.getAttachment(attachment.getFilename()) == null) {\n                    removeAttachment(attachment);\n                }\n            }\n        }\n        // Add new attachments or update existing attachments\n        for (XWikiAttachment attachment : document.getAttachmentList()) {\n            XWikiAttachment originalAttachment = getAttachment(attachment.getFilename());\n            if (originalAttachment == null) {\n                addAttachment(attachment);\n            } else {\n                originalAttachment.apply(attachment);\n            }\n        }\n\n        return modified;\n    }\n\n    private XWikiAttachmentStoreInterface resolveXWikiAttachmentStoreInterface(String storeType, XWikiContext xcontext)\n    {\n        XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(storeType);\n\n        if (store != null) {\n            return store;\n        }\n\n        return xcontext.getWiki().getDefaultAttachmentContentStore();\n    }\n\n    private XWikiAttachmentStoreInterface getXWikiAttachmentStoreInterface(String storeType)\n    {\n        if (storeType != null && !storeType.equals(XWikiHibernateAttachmentStore.HINT)) {\n            try {\n                return Utils.getContextComponentManager().getInstance(XWikiAttachmentStoreInterface.class, storeType);\n            } catch (ComponentLookupException e) {\n                LOGGER.warn(\"Can't find attachment content store for type [{}]\", storeType, e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Compute and return the maximum authorized length for the full name (i.e. the serialized reference of the\n     * document) based on the current store limitation.\n     *\n     * @return the maximum authorized length for a document full name.\n     * @since 11.4RC1\n     */\n    public int getLocalReferenceMaxLength()\n    {\n        return getStore().getLimitSize(this.getXWikiContext(), this.getClass(), \"fullName\");\n    }\n\n    @Override\n    public DocumentAuthors getAuthors()\n    {\n        return this.authors;\n    }\n\n    /**\n     * This getter has been created for hibernate in order to properly fill the DB field, it's not meant to be used\n     * for other purpose. For getting the displayed author, rely on {@link #getAuthors()}.\n     *\n     * @return the serialization of the displayed author reference.\n     */\n    private String getOriginalMetadataAuthorReference()\n    {\n        if (this.getAuthors().getOriginalMetadataAuthor() == null\n            || this.getAuthors().getOriginalMetadataAuthor() == GuestUserReference.INSTANCE) {\n            return \"\";\n        } else {\n            return userReferenceToString(this.getAuthors().getOriginalMetadataAuthor());\n        }\n    }\n\n    /**\n     * This setter has been created for hibernate in order to properly create the XWikiDocument instance with the\n     * displayed author set, it's not meant to be used for other purpose.\n     *\n     * @param serializedUserReference the serialization of the displayed author reference.\n     */\n    private void setOriginalMetadataAuthorReference(String serializedUserReference)\n    {\n        if (!StringUtils.isEmpty(serializedUserReference)) {\n            UserReference userReference = userStringToUserReference(serializedUserReference);\n            this.authors.setOriginalMetadataAuthor(userReference);\n        }\n    }\n\n    /**\n     * Make sure any document metadata which may depend on configuration is initialized to its default value.\n     * \n     * @since 14.8RC1\n     * @since 14.4.4\n     * @since 13.10.10\n     */\n    @Unstable\n    public void initialize()\n    {\n        // There is no syntax by default in a new document and the default one is retrieved from the configuration\n        setSyntax(getSyntax());\n    }\n\n    /**\n     * @return if rendering transformations shall be executed in restricted mode and the title not be executed\n     * @since 14.10.7\n     * @since 15.2RC1\n     */\n    @Override\n    @Unstable\n    public boolean isRestricted()\n    {\n        return this.restricted;\n    }\n\n    /**\n     * Set the restricted property that disables scripts and other dangerous content.\n     * <p>\n     * This property is not stored in the database as it is only supposed to be {@code true} on documents that do not\n     * correspond to the current version of the document.\n     *\n     * @param restricted if rendering transformations shall be executed in restricted mode and the title not be executed\n     * @since 14.10.7\n     * @since 15.2RC1\n     */\n    @Unstable\n    public void setRestricted(boolean restricted)\n    {\n        this.restricted = restricted;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.filter.output;\n\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.annotation.InstantiationStrategy;\nimport org.xwiki.component.descriptor.ComponentInstantiationStrategy;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.filter.FilterDescriptorManager;\nimport org.xwiki.filter.FilterEventParameters;\nimport org.xwiki.filter.FilterException;\nimport org.xwiki.filter.event.model.WikiDocumentFilter;\nimport org.xwiki.filter.event.xwiki.XWikiWikiDocumentFilter;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.localization.LocalizationContext;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.listener.WrappingListener;\nimport org.xwiki.rendering.renderer.PrintRendererFactory;\nimport org.xwiki.rendering.renderer.printer.DefaultWikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilter;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilterCollection;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\n\n/**\n * @version $Id$\n * @since 6.2M1\n */\n@Component\n@InstantiationStrategy(ComponentInstantiationStrategy.PER_LOOKUP)\npublic class XWikiDocumentOutputFilterStream extends AbstractEntityOutputFilterStream<XWikiDocument>\n    implements Initializable\n{\n    @Inject\n    private FilterDescriptorManager filterManager;\n\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Inject\n    private RenderingContext renderingContext;\n\n    @Inject\n    private LocalizationContext localizationContext;\n\n    @Inject\n    private EntityOutputFilterStream<XWikiAttachment> attachmentFilter;\n\n    @Inject\n    private EntityOutputFilterStream<BaseClass> classFilter;\n\n    @Inject\n    private EntityOutputFilterStream<BaseObject> objectFilter;\n\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    private WrappingListener contentListener = new WrappingListener();\n\n    private DefaultWikiPrinter currentWikiPrinter;\n\n    private Syntax previousTargetSyntax;\n\n    private Locale currentLocale;\n\n    private String currentVersion;\n\n    private FilterEventParameters currentLocaleParameters;\n\n    private Locale currentDefaultLocale;\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        initialize(this.attachmentFilter, this.classFilter, this.objectFilter);\n    }\n\n    @Override\n    protected Object createFilter()\n    {\n        List<XWikiDocumentFilter> filters = new ArrayList<>(this.children.size() + 1);\n        for (EntityOutputFilterStream<?> child : this.children) {\n            filters.add((XWikiDocumentFilter) child.getFilter());\n        }\n        filters.add(this);\n\n        this.filter = new XWikiDocumentFilterCollection(filters)\n        {\n            @Override\n            public void beginWikiClass(FilterEventParameters parameters) throws FilterException\n            {\n                if (!objectFilter.isEnabled()) {\n                    classFilter.enable();\n                }\n\n                super.beginWikiClass(parameters);\n            }\n\n            @Override\n            public void endWikiClass(FilterEventParameters parameters) throws FilterException\n            {\n                super.endWikiClass(parameters);\n\n                classFilter.disable();\n            }\n\n            @Override\n            public void beginWikiObject(String name, FilterEventParameters parameters) throws FilterException\n            {\n                objectFilter.enable();\n\n                super.beginWikiObject(name, parameters);\n            }\n\n            @Override\n            public void endWikiObject(String name, FilterEventParameters parameters) throws FilterException\n            {\n                super.endWikiObject(name, parameters);\n\n                objectFilter.disable();\n            }\n\n            @Override\n            public void onWikiAttachment(String name, InputStream content, Long size, FilterEventParameters parameters)\n                throws FilterException\n            {\n                attachmentFilter.enable();\n\n                super.onWikiAttachment(name, content, size, parameters);\n\n                attachmentFilter.disable();\n            }\n        };\n\n        if (this.contentListener != null) {\n            // Inject listener for the document content events\n            return this.filterManager.createCompositeFilter(this.contentListener, this.filter);\n        } else {\n            return this.filter;\n        }\n    }\n\n    private XWikiAttachmentOutputFilterStream getXWikiAttachmentOutputFilterStream()\n    {\n        return (XWikiAttachmentOutputFilterStream) this.attachmentFilter;\n    }\n\n    private BaseClassOutputFilterStream getBaseClassOutputFilterStream()\n    {\n        return (BaseClassOutputFilterStream) this.classFilter;\n    }\n\n    private BaseObjectOutputFilterStream getBaseObjectOutputFilterStream()\n    {\n        return (BaseObjectOutputFilterStream) this.objectFilter;\n    }\n\n    /**\n     * Optimization to disable any plumbing to support rendering events. To be used in case we know this kind of event\n     * won't be received or we want to ignore them. Should be called before {@link #getFilter()}.\n     */\n    public void disableRenderingEvents()\n    {\n        this.contentListener = null;\n    }\n\n    // Events\n\n    private EntityReference getDefaultDocumentReference()\n    {\n        if (this.properties != null && this.properties.getDefaultReference() != null) {\n            return this.properties.getDefaultReference();\n        }\n\n        if (this.entity != null) {\n            return this.entity.getDocumentReference();\n        }\n\n        return null;\n    }\n\n    private void begin(FilterEventParameters parameters) throws FilterException\n    {\n        DocumentReference documentReference =\n            this.documentEntityResolver.resolve(this.currentEntityReference, getDefaultDocumentReference());\n\n        if (this.entity == null) {\n            this.entity = new XWikiDocument(documentReference, this.currentLocale);\n        } else {\n            this.entity.setDocumentReference(documentReference);\n            this.entity.setLocale(this.currentLocale);\n        }\n\n        // Mark the document as restricted to avoid that any scripts are executed as scripts should only be executed\n        // on the current, saved version, see https://jira.xwiki.org/browse/XWIKI-20594\n        this.entity.setRestricted(true);\n\n        // Find default author\n        DocumentReference defaultAuthorDocumentReference;\n        // TODO: move to UserReference based APIs in DocumentInstanceOutputProperties\n        if (this.properties.isAuthorSet()) {\n            defaultAuthorDocumentReference = this.properties.getAuthor();\n        } else {\n            XWikiContext xcontext = xcontextProvider.get();\n            defaultAuthorDocumentReference = xcontext != null ? xcontext.getUserReference() : null;\n        }\n        UserReference defaultAuthorReference = this.userDocumentResolver.resolve(defaultAuthorDocumentReference);\n\n        this.entity\n            .setCreationDate(getDate(WikiDocumentFilter.PARAMETER_CREATION_DATE, this.currentLocaleParameters, null));\n\n        this.entity.getAuthors().setCreator(getUserReference(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR,\n            this.currentLocaleParameters, defaultAuthorReference));\n        this.entity.setDefaultLocale(this.currentDefaultLocale);\n\n        this.entity.setSyntax(getSyntax(WikiDocumentFilter.PARAMETER_SYNTAX, parameters, null));\n\n        this.entity.setParentReference(getEntityReference(WikiDocumentFilter.PARAMETER_PARENT, parameters, null));\n        this.entity.setCustomClass(getString(WikiDocumentFilter.PARAMETER_CUSTOMCLASS, parameters, null));\n        this.entity.setTitle(getString(WikiDocumentFilter.PARAMETER_TITLE, parameters, null));\n        this.entity.setDefaultTemplate(getString(WikiDocumentFilter.PARAMETER_DEFAULTTEMPLATE, parameters, null));\n        this.entity.setValidationScript(getString(WikiDocumentFilter.PARAMETER_VALIDATIONSCRIPT, parameters, null));\n        this.entity.setHidden(getBoolean(WikiDocumentFilter.PARAMETER_HIDDEN, parameters, false));\n\n        this.entity.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));\n\n        this.entity.getAuthors().setEffectiveMetadataAuthor(getUserReference(\n            WikiDocumentFilter.PARAMETER_REVISION_EFFECTIVEMETADATA_AUTHOR, parameters, defaultAuthorReference));\n        // Use effectuve metadata author as default as this value used to be used both both original and effective\n        // metadata authors\n        this.entity.getAuthors()\n            .setOriginalMetadataAuthor(getUserReference(WikiDocumentFilter.PARAMETER_REVISION_ORIGINALMETADATA_AUTHOR,\n                parameters, this.entity.getAuthors().getEffectiveMetadataAuthor()));\n\n        this.entity.getAuthors().setContentAuthor(\n            getUserReference(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, defaultAuthorReference));\n\n        String revisions =\n            getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, this.currentLocaleParameters, null);\n        if (revisions != null) {\n            try {\n                this.entity.setDocumentArchive(revisions);\n            } catch (XWikiException e) {\n                throw new FilterException(\"Failed to set document archive\", e);\n            }\n        }\n\n        if (this.currentVersion != null && this.properties.isVersionPreserved()) {\n            if (VALID_VERSION.matcher(this.currentVersion).matches()) {\n                this.entity.setVersion(this.currentVersion);\n            } else if (NumberUtils.isDigits(this.currentVersion)) {\n                this.entity.setVersion(this.currentVersion + \".1\");\n            } else {\n                // TODO: log something, probably a warning\n            }\n        }\n\n        this.entity.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));\n        this.entity.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, \"\"));\n\n        this.entity.setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));\n\n        // Content\n\n        if (this.contentListener != null) {\n            // Remember the current rendering context target syntax\n            this.previousTargetSyntax = this.renderingContext.getTargetSyntax();\n        }\n\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_CONTENT)) {\n            this.entity.setContent(getString(WikiDocumentFilter.PARAMETER_CONTENT, parameters, null));\n\n            if (this.contentListener != null) {\n                // Cancel any existing content listener\n                this.currentWikiPrinter = null;\n                this.contentListener.setWrappedListener(null);\n            }\n        } else if (this.contentListener != null) {\n            if (this.properties != null && this.properties.getDefaultSyntax() != null) {\n                this.entity.setSyntax(this.properties.getDefaultSyntax());\n            } else {\n                // Make sure to set the default syntax if none were provided\n                this.entity.setSyntax(this.entity.getSyntax());\n            }\n\n            ComponentManager componentManager = this.componentManagerProvider.get();\n\n            String syntaxString = this.entity.getSyntax().toIdString();\n            if (componentManager.hasComponent(PrintRendererFactory.class, syntaxString)) {\n                PrintRendererFactory rendererFactory;\n                try {\n                    rendererFactory = componentManager.getInstance(PrintRendererFactory.class, syntaxString);\n                } catch (ComponentLookupException e) {\n                    throw new FilterException(\n                        String.format(\"Failed to find PrintRendererFactory for syntax [%s]\", this.entity.getSyntax()),\n                        e);\n                }\n\n                this.currentWikiPrinter = new DefaultWikiPrinter();\n                ((MutableRenderingContext) this.renderingContext).setTargetSyntax(rendererFactory.getSyntax());\n                this.contentListener.setWrappedListener(rendererFactory.createRenderer(this.currentWikiPrinter));\n            }\n        }\n\n        // Initialize the class\n        getBaseClassOutputFilterStream().setEntity(this.entity.getXClass());\n    }\n\n    private void end(FilterEventParameters parameters)\n    {\n        // Set content\n        if (this.currentWikiPrinter != null) {\n            this.entity.setContent(this.currentWikiPrinter.getBuffer().toString());\n\n            this.contentListener.setWrappedListener(null);\n            this.currentWikiPrinter = null;\n        }\n\n        if (this.contentListener != null) {\n            // Reset\n            ((MutableRenderingContext) this.renderingContext).setTargetSyntax(this.previousTargetSyntax);\n        }\n    }\n\n    @Override\n    public void beginWikiDocument(String name, FilterEventParameters parameters) throws FilterException\n    {\n        super.beginWikiDocument(name, parameters);\n\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_LOCALE)) {\n            this.currentDefaultLocale = get(Locale.class, WikiDocumentFilter.PARAMETER_LOCALE, parameters, Locale.ROOT);\n        } else {\n            this.currentDefaultLocale = this.localizationContext.getCurrentLocale();\n        }\n\n        this.currentLocale = Locale.ROOT;\n        this.currentLocaleParameters = parameters;\n\n        begin(parameters);\n    }\n\n    @Override\n    public void endWikiDocument(String name, FilterEventParameters parameters) throws FilterException\n    {\n        end(parameters);\n\n        super.endWikiDocument(name, parameters);\n\n        // Reset\n        this.currentLocaleParameters = null;\n        this.currentLocale = null;\n        this.currentDefaultLocale = null;\n    }\n\n    @Override\n    public void beginWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws FilterException\n    {\n        this.currentLocale = locale;\n        this.currentLocaleParameters = parameters;\n\n        begin(parameters);\n    }\n\n    @Override\n    public void endWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws FilterException\n    {\n        end(parameters);\n\n        // Reset\n        this.currentLocale = null;\n        this.currentLocaleParameters = null;\n    }\n\n    @Override\n    public void beginWikiDocumentRevision(String version, FilterEventParameters parameters) throws FilterException\n    {\n        this.currentVersion = version;\n\n        begin(parameters);\n    }\n\n    @Override\n    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws FilterException\n    {\n        end(parameters);\n\n        // Reset\n        this.currentVersion = null;\n    }\n\n    @Override\n    public void endWikiClass(FilterEventParameters parameters) throws FilterException\n    {\n        getBaseClassOutputFilterStream().setEntity(null);\n    }\n\n    @Override\n    public void onWikiAttachment(String name, InputStream content, Long size, FilterEventParameters parameters)\n        throws FilterException\n    {\n        endAttachment();\n    }\n\n    @Override\n    public void endWikiDocumentAttachment(String name, InputSource content, Long size, FilterEventParameters parameters)\n        throws FilterException\n    {\n        endAttachment();\n    }\n\n    private void endAttachment()\n    {\n        this.entity.setAttachment(getXWikiAttachmentOutputFilterStream().getEntity());\n\n        // Reset attachment\n        getXWikiAttachmentOutputFilterStream().setEntity(null);\n    }\n\n    @Override\n    public void endWikiObject(String name, FilterEventParameters parameters) throws FilterException\n    {\n        super.endWikiObject(name, parameters);\n\n        BaseObject baseObject = getBaseObjectOutputFilterStream().getEntity();\n\n        if (baseObject.getNumber() < 0) {\n            this.entity.addXObject(baseObject);\n        } else {\n            this.entity.setXObject(baseObject.getNumber(), baseObject);\n        }\n\n        getBaseObjectOutputFilterStream().setEntity(null);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.store;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.hibernate.FlushMode;\nimport org.hibernate.HibernateException;\nimport org.hibernate.ObjectNotFoundException;\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.query.NativeQuery;\nimport org.hibernate.query.Query;\nimport org.slf4j.Logger;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.bridge.event.ActionExecutingEvent;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageAttachmentReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.store.UnexpectedException;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;\nimport com.xpn.xwiki.doc.XWikiLink;\nimport com.xpn.xwiki.doc.XWikiLock;\nimport com.xpn.xwiki.doc.XWikiSpace;\nimport com.xpn.xwiki.internal.store.hibernate.legacy.LegacySessionImplementor;\nimport com.xpn.xwiki.monitor.api.MonitorPlugin;\nimport com.xpn.xwiki.objects.BaseCollection;\nimport com.xpn.xwiki.objects.BaseElement;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.BaseProperty;\nimport com.xpn.xwiki.objects.BaseStringProperty;\nimport com.xpn.xwiki.objects.LargeStringProperty;\nimport com.xpn.xwiki.objects.ListProperty;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.StringProperty;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.classes.StringClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.stats.impl.XWikiStats;\nimport com.xpn.xwiki.util.Util;\n\n/**\n * The XWiki Hibernate database driver.\n *\n * @version $Id$\n */\n@Component\n@Named(XWikiHibernateBaseStore.HINT)\n@Singleton\npublic class XWikiHibernateStore extends XWikiHibernateBaseStore implements XWikiStoreInterface, Initializable\n{\n    @Inject\n    private Logger logger;\n\n    /**\n     * QueryManager for this store.\n     */\n    @Inject\n    private QueryManager queryManager;\n\n    /** Needed so we can register an event to trap logout and delete held locks. */\n    @Inject\n    private ObservationManager observationManager;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    @Inject\n    private DocumentReferenceResolver<String> defaultDocumentReferenceResolver;\n\n    @Inject\n    @Named(\"current\")\n    private DocumentReferenceResolver<PageReference> currentPageReferenceDocumentReferenceResolver;\n\n    /**\n     * Used to convert a proper Document Reference to string (standard form).\n     */\n    @Inject\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part).\n     */\n    @Inject\n    @Named(\"compactwiki\")\n    private EntityReferenceSerializer<String> compactWikiEntityReferenceSerializer;\n\n    /**\n     * Used to convert a proper Document Reference to a string but without the wiki name.\n     */\n    @Inject\n    @Named(\"local\")\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;\n\n    @Inject\n    private ComponentManager componentManager;\n\n    @Inject\n    @Named(HINT)\n    private XWikiAttachmentStoreInterface attachmentContentStore;\n\n    @Inject\n    @Named(HINT)\n    private AttachmentVersioningStore attachmentArchiveStore;\n\n    @Inject\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private Map<String, String[]> validTypesMap = new HashMap<>();\n\n    /**\n     * This allows to initialize our storage engine. The hibernate config file path is taken from xwiki.cfg or directly\n     * in the WEB-INF directory.\n     *\n     * @param xwiki\n     * @param context\n     * @deprecated 1.6M1. Use ComponentManager.lookup(XWikiStoreInterface.class) instead.\n     */\n    @Deprecated\n    public XWikiHibernateStore(XWiki xwiki, XWikiContext context)\n    {\n        super(xwiki, context);\n        initValidColumTypes();\n    }\n\n    /**\n     * Initialize the storage engine with a specific path. This is used for tests.\n     *\n     * @param hibpath\n     * @deprecated 1.6M1. Use ComponentManager.lookup(XWikiStoreInterface.class) instead.\n     */\n    @Deprecated\n    public XWikiHibernateStore(String hibpath)\n    {\n        super(hibpath);\n        initValidColumTypes();\n    }\n\n    /**\n     * @see #XWikiHibernateStore(XWiki, XWikiContext)\n     * @deprecated 1.6M1. Use ComponentManager.lookup(XWikiStoreInterface.class) instead.\n     */\n    @Deprecated\n    public XWikiHibernateStore(XWikiContext context)\n    {\n        this(context.getWiki(), context);\n    }\n\n    /**\n     * Empty constructor needed for component manager.\n     */\n    public XWikiHibernateStore()\n    {\n        initValidColumTypes();\n    }\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        this.registerLogoutListener();\n    }\n\n    /**\n     * This initializes the valid custom types Used for Custom Mapping\n     */\n    private void initValidColumTypes()\n    {\n        String[] string_types = {\"string\", \"text\", \"clob\"};\n        String[] number_types =\n            {\"integer\", \"long\", \"float\", \"double\", \"big_decimal\", \"big_integer\", \"yes_no\", \"true_false\"};\n        String[] date_types = {\"date\", \"time\", \"timestamp\"};\n        String[] boolean_types = {\"boolean\", \"yes_no\", \"true_false\", \"integer\"};\n        this.validTypesMap = new HashMap<>();\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.StringClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.TextAreaClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.PasswordClass\", string_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.NumberClass\", number_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.DateClass\", date_types);\n        this.validTypesMap.put(\"com.xpn.xwiki.objects.classes.BooleanClass\", boolean_types);\n    }\n\n    @Override\n    public boolean isWikiNameAvailable(String wikiName, XWikiContext inputxcontext) throws XWikiException\n    {\n        try {\n            return !this.store.isWikiDatabaseExist(wikiName);\n        } catch (Exception e) {\n            Object[] args = {wikiName};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CHECK_EXISTS_DATABASE,\n                \"Exception while listing databases to search for {0}\", e, args);\n        }\n    }\n\n    @Override\n    public void createWiki(String wikiName, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, false);\n\n        boolean bTransaction = true;\n        String database = context.getWikiId();\n        AtomicReference<Statement> stmt = new AtomicReference<>(null);\n\n        bTransaction = beginTransaction(context);\n        try {\n            Session session = getSession(context);\n\n            session.doWork(connection -> {\n                stmt.set(connection.createStatement());\n                Statement statement = stmt.get();\n\n                String schema = getSchemaFromWikiName(wikiName, context);\n                String escapedSchema = escapeSchema(schema, context);\n\n                DatabaseProduct databaseProduct = getDatabaseProductName();\n                if (DatabaseProduct.ORACLE == databaseProduct) {\n                    // Notes:\n                    // - We use default tablespaces (which mean the USERS and TEMP tablespaces) to make it simple.\n                    // We also don't know which tablespace was used to create the main wiki and creating a new one\n                    // here would make things more complex (we would need to check if it exists already for example).\n                    // - We must specify a quota on the USERS tablespace so that the user can create objects (like\n                    // tables). Note that tables are created deferred by default so you'd think the user can create\n                    // them without quotas set but that's because tables are created deferred by default and thus\n                    // they'll fail when the first data is written in them.\n                    // See https://dba.stackexchange.com/a/254950\n                    // - Depending on how it's configured, the default users tablespace size might be too small. Thus\n                    // it's up to a DBA to make sure it's large enough.\n                    statement.execute(String.format(\"CREATE USER %s IDENTIFIED BY %s QUOTA UNLIMITED ON USERS\",\n                        escapedSchema, escapedSchema));\n                } else if (DatabaseProduct.DERBY == databaseProduct || DatabaseProduct.DB2 == databaseProduct\n                    || DatabaseProduct.H2 == databaseProduct) {\n                    statement.execute(\"CREATE SCHEMA \" + escapedSchema);\n                } else if (DatabaseProduct.HSQLDB == databaseProduct) {\n                    statement.execute(\"CREATE SCHEMA \" + escapedSchema + \" AUTHORIZATION DBA\");\n                } else if (DatabaseProduct.MYSQL == databaseProduct) {\n                    StringBuilder statementBuilder = new StringBuilder(\"create database \" + escapedSchema);\n                    String[] charsetAndCollation = getCharsetAndCollation(wikiName, session, context);\n                    statementBuilder.append(\" CHARACTER SET \");\n                    statementBuilder.append(charsetAndCollation[0]);\n                    statementBuilder.append(\" COLLATE \");\n                    statementBuilder.append(charsetAndCollation[1]);\n                    statement.execute(statementBuilder.toString());\n                } else if (DatabaseProduct.POSTGRESQL == databaseProduct) {\n                    if (isInSchemaMode()) {\n                        statement.execute(\"CREATE SCHEMA \" + escapedSchema);\n                    } else {\n                        this.logger.error(\"Creation of a new database is currently only supported in the schema mode, \"\n                            + \"see https://jira.xwiki.org/browse/XWIKI-8753\");\n                    }\n                } else {\n                    statement.execute(\"create database \" + escapedSchema);\n                }\n            });\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {wikiName};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CREATE_DATABASE, \"Exception while create wiki database {0}\",\n                e, args);\n        } finally {\n            context.setWikiId(database);\n            try {\n                Statement statement = stmt.get();\n                if (statement != null) {\n                    statement.close();\n                }\n            } catch (Exception e) {\n            }\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    /**\n     * @return the MySQL charset and collation to use when creating a new database. They are retrieved by finding the\n     *         ones used for the main wiki and if that fails, the {@code utf8mb4} charset and {@code utf8mb4_bin}\n     *         collation are used (We use {@code utf8mb4} and not {@code utf8} so that by default, users can insert\n     *         emojis in content).\n     */\n    private String[] getCharsetAndCollation(String wikiName, Session session, XWikiContext context)\n    {\n        String[] result = new String[2];\n        String charset = \"utf8mb4\";\n        String collation = \"utf8mb4_bin\";\n\n        // Get main wiki encoding\n        if (!context.isMainWiki(wikiName)) {\n            NativeQuery<Object[]> selectQuery = session.createNativeQuery(\n                \"select DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME from INFORMATION_SCHEMA.SCHEMATA\"\n                    + \" where SCHEMA_NAME='\" + getSchemaFromWikiName(context.getMainXWiki(), context) + \"'\");\n            Object[] queryResult = selectQuery.uniqueResult();\n            if (queryResult != null) {\n                charset = (String) queryResult[0];\n                collation = (String) queryResult[1];\n            }\n        }\n\n        result[0] = charset;\n        result[1] = collation;\n        return result;\n    }\n\n    @Override\n    public void deleteWiki(String wikiName, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, false);\n\n        String database = context.getWikiId();\n        AtomicReference<Statement> stmt = new AtomicReference<>(null);\n\n        boolean bTransaction = beginTransaction(context);\n        try {\n            Session session = getSession(context);\n            session.doWork(connection -> {\n                stmt.set(connection.createStatement());\n\n                String schema = getSchemaFromWikiName(wikiName, context);\n                String escapedSchema = escapeSchema(schema, context);\n\n                executeDeleteWikiStatement(stmt.get(), getDatabaseProductName(), escapedSchema);\n            });\n\n            if (bTransaction) {\n                endTransaction(context, true);\n            }\n        } catch (Exception e) {\n            Object[] args = {wikiName};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETE_DATABASE, \"Exception while delete wiki database {0}\",\n                e, args);\n        } finally {\n            context.setWikiId(database);\n            try {\n                Statement statement = stmt.get();\n                if (statement != null) {\n                    statement.close();\n                }\n            } catch (Exception e) {\n            }\n            try {\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    /**\n     * Execute the SQL statement on the database to remove a wiki.\n     *\n     * @param statement the statement object on which to execute the wiki deletion\n     * @param databaseProduct the database type\n     * @param escapedSchemaName the subwiki schema name being deleted\n     * @throws SQLException in case of an error while deleting the sub wiki\n     */\n    protected void executeDeleteWikiStatement(Statement statement, DatabaseProduct databaseProduct,\n        String escapedSchemaName) throws SQLException\n    {\n        if (DatabaseProduct.ORACLE == databaseProduct) {\n            statement.execute(\"DROP USER \" + escapedSchemaName + \" CASCADE\");\n        } else if (DatabaseProduct.DERBY == databaseProduct || DatabaseProduct.MYSQL == databaseProduct\n            || DatabaseProduct.H2 == databaseProduct) {\n            statement.execute(\"DROP SCHEMA \" + escapedSchemaName);\n        } else if (DatabaseProduct.HSQLDB == databaseProduct) {\n            statement.execute(\"DROP SCHEMA \" + escapedSchemaName + \" CASCADE\");\n        } else if (DatabaseProduct.DB2 == databaseProduct) {\n            statement.execute(\"DROP SCHEMA \" + escapedSchemaName + \" RESTRICT\");\n        } else if (DatabaseProduct.POSTGRESQL == databaseProduct) {\n            if (isInSchemaMode()) {\n                statement.execute(\"DROP SCHEMA \" + escapedSchemaName + \" CASCADE\");\n            } else {\n                this.logger.warn(\"Subwiki deletion not yet supported in Database mode for PostgreSQL\");\n            }\n        }\n    }\n\n    /**\n     * Verifies if a wiki document exists\n     */\n    @Override\n    public boolean exists(XWikiDocument doc, XWikiContext inputxcontext) throws XWikiException\n    {\n        // In order to avoid trying to issue any SQL query to the DB, we first check if the wiki containing the\n        // doc exists. If not, then the doc cannot exist for sure.\n        try {\n            if (!this.wikiDescriptorManager.exists(this.wikiDescriptorManager.getCurrentWikiId())) {\n                return false;\n            }\n        } catch (WikiManagerException e) {\n            // An error occurred while retrieving the wiki descriptors. This is an important problem and we shouldn't\n            // swallow it and instead we mist let it bubble up.\n            Object[] args = {this.wikiDescriptorManager.getCurrentWikiId()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CHECK_EXISTS_DOC,\n                \"Error while checking for existence of the [{0}] wiki\", e, args);\n        }\n\n        return executeRead(inputxcontext, session -> {\n            try {\n                String fullName = doc.getFullName();\n\n                String sql = \"select doc.fullName from XWikiDocument as doc where doc.fullName=:fullName\";\n                if (!doc.getLocale().equals(Locale.ROOT)) {\n                    sql += \" and doc.language=:language\";\n                }\n\n                Query<String> query = session.createQuery(sql);\n                query.setParameter(\"fullName\", fullName);\n                if (!doc.getLocale().equals(Locale.ROOT)) {\n                    query.setParameter(\"language\", doc.getLocale().toString());\n                }\n                Iterator<String> it = query.list().iterator();\n                while (it.hasNext()) {\n                    if (fullName.equals(it.next())) {\n                        return true;\n                    }\n                }\n\n                return false;\n            } catch (Exception e) {\n                Object[] args = {doc.getDocumentReferenceWithLocale()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CHECK_EXISTS_DOC, \"Exception while reading document {0}\",\n                    e, args);\n            }\n        });\n    }\n\n    @Override\n    public void saveXWikiDoc(XWikiDocument doc, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            MonitorPlugin monitor = Util.getMonitorPlugin(context);\n\n            try {\n                // Start monitoring timer\n                if (monitor != null) {\n                    monitor.startTimer(HINT);\n                }\n                doc.setStore(this);\n                // Make sure the database name is stored\n                doc.setDatabase(context.getWikiId());\n\n                // If the comment is larger than the max size supported by the Storage, then abbreviate it\n                String comment = doc.getComment();\n                if (comment != null && comment.length() > 1023) {\n                    doc.setComment(StringUtils.abbreviate(comment, 1023));\n                }\n\n                // Before starting the transaction, make sure any document metadata which might rely on configuration is\n                // initialized\n                doc.initialize();\n\n                if (bTransaction) {\n                    checkHibernate(context);\n                    SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                    bTransaction = beginTransaction(sfactory, context);\n                }\n\n                try {\n                    Session session = getSession(context);\n                    session.setHibernateFlushMode(FlushMode.COMMIT);\n\n                    // These informations will allow to not look for attachments and objects on loading\n                    doc.setElement(XWikiDocument.HAS_ATTACHMENTS, !doc.getAttachmentList().isEmpty());\n                    doc.setElement(XWikiDocument.HAS_OBJECTS, !doc.getXObjects().isEmpty());\n\n                    // Let's update the class XML since this is the new way to store it\n                    // TODO If all the properties are removed, the old xml stays?\n                    BaseClass bclass = doc.getXClass();\n                    if (bclass != null) {\n                        if (bclass.getFieldList().isEmpty()) {\n                            doc.setXClassXML(\"\");\n                        } else {\n                            // Don't format the XML to reduce the size of the stored data as much as possible\n                            doc.setXClassXML(bclass.toXMLString(false));\n                        }\n                        bclass.setDirty(false);\n                    }\n\n                    // Remove attachments planned for removal\n                    if (!doc.getAttachmentsToRemove().isEmpty()) {\n                        for (XWikiAttachmentToRemove attachmentToRemove : doc.getAttachmentsToRemove()) {\n                            XWikiAttachment attachment = attachmentToRemove.getAttachment();\n\n                            XWikiAttachment attachmentToAdd = doc.getAttachment(attachment.getFilename());\n                            if (attachmentToAdd != null && attachmentToAdd.getId() == attachment.getId()) {\n                                // Hibernate does not like when the \"same\" database entity (from identifier point of\n                                // view)\n                                // is manipulated through two different Java objects in the same session. But it also\n                                // refuse\n                                // to delete and insert the \"same\" entity (still from id point of view) in the same\n                                // sessions. So when we hit such a case we only remove the attachment history and let\n                                // the\n                                // saveAttachmentList code below update the current attachment content.\n                                AttachmentVersioningStore store = getAttachmentVersioningStore(attachment);\n                                store.deleteArchive(attachment, context, bTransaction);\n                                // Keep the same content store since we need to overwrite existing data\n                                attachmentToAdd.setContentStore(attachment.getContentStore());\n                            } else {\n                                XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(attachment);\n                                store.deleteXWikiAttachment(attachment, false, context, false);\n                            }\n                        }\n                    }\n                    // Update/add new attachments\n                    if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS)) {\n                        saveAttachmentList(doc, context);\n                    }\n                    // Reset the list of attachments to remove\n                    doc.clearAttachmentsToRemove();\n\n                    // Handle the latest text file\n                    if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                        Date ndate = new Date();\n                        doc.setDate(ndate);\n                        if (doc.isContentDirty()) {\n                            doc.setContentUpdateDate(ndate);\n                            DocumentAuthors authors = doc.getAuthors();\n                            authors.setContentAuthor(authors.getEffectiveMetadataAuthor());\n                        }\n                        doc.incrementVersion();\n                        if (context.getWiki().hasVersioning(context)) {\n                            context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                        }\n\n                        doc.setContentDirty(false);\n                        doc.setMetaDataDirty(false);\n                    } else {\n                        if (doc.getDocumentArchive() != null) {\n                            // A custom document archive has been provided, we assume it's right\n                            // (we also assume it's custom but that's another matter...)\n                            // Let's make sure we save the archive if we have one\n                            // This is especially needed if we load a document from XML\n                            if (context.getWiki().hasVersioning(context)) {\n                                context.getWiki().getVersioningStore().saveXWikiDocArchive(doc.getDocumentArchive(),\n                                    false, context);\n\n                                // If the version does not exist it means it's a new version so add it to the history\n                                if (!containsVersion(doc, doc.getRCSVersion(), context)) {\n                                    context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false, context);\n                                }\n                            }\n                        } else {\n                            // Make sure the getArchive call has been made once\n                            // with a valid context\n                            try {\n                                if (context.getWiki().hasVersioning(context)) {\n                                    doc.getDocumentArchive(context);\n\n                                    // If the version does not exist it means it's a new version so register it in the\n                                    // history\n                                    if (!containsVersion(doc, doc.getRCSVersion(), context)) {\n                                        context.getWiki().getVersioningStore().updateXWikiDocArchive(doc, false,\n                                            context);\n                                    }\n                                }\n                            } catch (XWikiException e) {\n                                // this is a non critical error\n                            }\n                        }\n                    }\n\n                    // Verify if the document already exists\n                    Query query = session\n                        .createQuery(\"select xwikidoc.id from XWikiDocument as xwikidoc where xwikidoc.id = :id\");\n                    query.setParameter(\"id\", doc.getId());\n                    if (query.uniqueResult() == null) {\n                        doc.setNew(true);\n                    }\n\n                    // Note: we don't use session.saveOrUpdate(doc) because it used to be slower in Hibernate than\n                    // calling\n                    // session.save() and session.update() separately.\n                    if (doc.isNew()) {\n                        if (doc.isContentDirty() || doc.isMetaDataDirty()) {\n                            // Reset the creationDate to reflect the date of the first save, not the date of the object\n                            // creation\n                            doc.setCreationDate(new Date());\n                        }\n                        session.save(doc);\n                    } else {\n                        session.update(doc);\n                    }\n\n                    // Remove objects planned for removal\n                    if (!doc.getXObjectsToRemove().isEmpty()) {\n                        for (BaseObject removedObject : doc.getXObjectsToRemove()) {\n                            deleteXWikiCollection(removedObject, context, false, false);\n                        }\n                        doc.setXObjectsToRemove(new ArrayList<BaseObject>());\n                    }\n\n                    if (bclass != null) {\n                        bclass.setDocumentReference(doc.getDocumentReference());\n                        // Store this XWikiClass in the context so that we can use it in case of recursive usage of\n                        // classes\n                        context.addBaseClass(bclass);\n                    }\n\n                    if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                        // TODO: Delete all objects for which we don't have a name in the Map\n                        for (List<BaseObject> objects : doc.getXObjects().values()) {\n                            for (BaseObject obj : objects) {\n                                if (obj != null) {\n                                    obj.setDocumentReference(doc.getDocumentReference());\n                                    /* If the object doesn't have a GUID, create it before saving */\n                                    if (StringUtils.isEmpty(obj.getGuid())) {\n                                        obj.setGuid(null);\n                                    }\n                                    saveXWikiCollection(obj, context, false);\n                                }\n                            }\n                        }\n                    }\n\n                    // Update space table\n                    updateXWikiSpaceTable(doc, session);\n\n                    if (bTransaction) {\n                        endTransaction(context, true);\n                    }\n\n                    doc.setNew(false);\n\n                    // Make sure that properly saved documents aren't restricted.\n                    doc.setRestricted(false);\n\n                    // We need to ensure that the saved document becomes the original document\n                    doc.setOriginalDocument(doc.clone());\n                } finally {\n                    if (bTransaction) {\n                        try {\n                            endTransaction(context, false);\n                        } catch (Exception e) {\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                Object[] args = {this.defaultEntityReferenceSerializer.serialize(doc.getDocumentReference())};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC, \"Exception while saving document {0}\", e,\n                    args);\n            } finally {\n                // End monitoring timer\n                if (monitor != null) {\n                    monitor.endTimer(HINT);\n                }\n            }\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    private void updateXWikiSpaceTable(XWikiDocument document, Session session)\n    {\n        if (document.getLocale().equals(Locale.ROOT)) {\n            // It's possible the space does not yet exist yet\n            maybeCreateSpace(document.getDocumentReference().getLastSpaceReference(), document.isHidden(), session);\n\n            if (!document.isNew()) {\n                // If the hidden state of an existing document did not changed there is nothing to do\n                if (document.isHidden() != document.getOriginalDocument().isHidden()) {\n                    if (document.isHidden()) {\n                        // If the document became hidden it's possible the space did too\n                        maybeMakeSpaceHidden(document.getDocumentReference().getLastSpaceReference(),\n                            document.getFullName(), session);\n                    } else {\n                        // If the document became visible then all its parents should be visible as well\n                        makeSpaceVisible(document.getDocumentReference().getLastSpaceReference(), session);\n                    }\n                }\n            }\n        }\n    }\n\n    private void insertXWikiSpace(XWikiSpace space, Session session)\n    {\n        // Insert the space\n        session.save(space);\n\n        // Update parent space\n        if (space.getSpaceReference().getParent() instanceof SpaceReference) {\n            maybeCreateSpace((SpaceReference) space.getSpaceReference().getParent(), space.isHidden(), session);\n        }\n    }\n\n    private void makeSpaceVisible(SpaceReference spaceReference, Session session)\n    {\n        XWikiSpace space = loadXWikiSpace(spaceReference, session);\n\n        makeSpaceVisible(space, session);\n    }\n\n    private void makeSpaceVisible(XWikiSpace space, Session session)\n    {\n        if (space.isHidden()) {\n            space.setHidden(false);\n\n            session.update(space);\n\n            // Update parent\n            if (space.getSpaceReference().getParent() instanceof SpaceReference) {\n                makeSpaceVisible((SpaceReference) space.getSpaceReference().getParent(), session);\n            }\n        }\n    }\n\n    private void maybeMakeSpaceHidden(SpaceReference spaceReference, String modifiedDocument, Session session)\n    {\n        XWikiSpace space = loadXWikiSpace(spaceReference, session);\n\n        // The space is supposed to exist\n        if (space == null) {\n            this.logger.warn(\n                \"Space [{}] does not exist. Usually means the spaces table is not in sync with the documents table.\",\n                spaceReference);\n\n            return;\n        }\n\n        // If the space is already hidden return\n        if (space.isHidden()) {\n            return;\n        }\n\n        if (calculateHiddenStatus(spaceReference, modifiedDocument, session)) {\n            // Make the space hidden\n            space.setHidden(true);\n            session.update(space);\n\n            // Update space parent\n            if (spaceReference.getParent() instanceof SpaceReference) {\n                maybeMakeSpaceHidden((SpaceReference) spaceReference.getParent(), modifiedDocument, session);\n            }\n        }\n    }\n\n    private void maybeCreateSpace(SpaceReference spaceReference, boolean hidden, Session session)\n    {\n        XWikiSpace space = loadXWikiSpace(spaceReference, session);\n\n        if (space != null) {\n            if (space.isHidden() && !hidden) {\n                makeSpaceVisible(space, session);\n            }\n        } else {\n            insertXWikiSpace(new XWikiSpace(spaceReference, hidden), session);\n        }\n    }\n\n    private boolean hasDocuments(SpaceReference spaceReference, Session session, String extraWhere,\n        Map<String, ?> parameters)\n    {\n        StringBuilder builder = new StringBuilder(\n            \"select distinct xwikidoc.space from XWikiDocument as xwikidoc where (space = :space OR space LIKE :like)\");\n\n        if (StringUtils.isNotEmpty(extraWhere)) {\n            builder.append(\" AND \");\n            builder.append('(');\n            builder.append(extraWhere);\n            builder.append(')');\n        }\n\n        Query<String> query = session.createQuery(builder.toString(), String.class);\n\n        String localSpaceReference = this.localEntityReferenceSerializer.serialize(spaceReference);\n        String localSpaceReferencePrefix = localSpaceReference + '.';\n\n        query.setParameter(\"space\", localSpaceReference);\n        query.setParameter(\"like\", localSpaceReferencePrefix + \"%\");\n\n        if (parameters != null) {\n            parameters.forEach(query::setParameter);\n        }\n\n        // Leading and trailing white spaces are not taken into account in SQL comparisons so we have to make sure the\n        // matched spaces really are the expected ones\n        for (String result : query.getResultList()) {\n            if (result.equals(localSpaceReference) || result.startsWith(localSpaceReferencePrefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Find hidden status of a space from its children.\n     */\n    private boolean calculateHiddenStatus(SpaceReference spaceReference, String documentToIngore, Session session)\n    {\n        // If there is at least one visible document then the space is visible\n        StringBuilder builder = new StringBuilder(\"(hidden = false OR hidden IS NULL)\");\n\n        Map<String, ?> parameters;\n        if (documentToIngore != null) {\n            builder.append(\" AND fullName <> :documentToIngore\");\n            parameters = Collections.singletonMap(\"documentToIngore\", documentToIngore);\n        } else {\n            parameters = null;\n        }\n\n        return !hasDocuments(spaceReference, session, builder.toString(), parameters);\n    }\n\n    private boolean containsVersion(XWikiDocument doc, Version targetversion, XWikiContext context)\n        throws XWikiException\n    {\n        for (Version version : doc.getRevisions(context)) {\n            if (version.equals(targetversion)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void saveXWikiDoc(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        saveXWikiDoc(doc, context, true);\n    }\n\n    /**\n     * {@inheritDoc} This implementation of rename relies on {@link #saveXWikiDoc(XWikiDocument, XWikiContext, boolean)}\n     * and {@link #deleteXWikiDoc(XWikiDocument, XWikiContext, boolean)}. The idea here is that the document reference\n     * has many impacts everywhere and it's actually safer to keep relying on existing save method. Now all the benefit\n     * of this rename, is to call those methods in the same transaction when both old and new reference belong to the\n     * same wiki (same database). If the references belong to different databases we are force to use two transactions.\n     */\n    @Override\n    public void renameXWikiDoc(XWikiDocument doc, DocumentReference newReference, XWikiContext inputxcontext)\n        throws XWikiException\n    {\n        WikiReference sourceWikiReference = doc.getDocumentReference().getWikiReference();\n        WikiReference targetWikiReference = newReference.getWikiReference();\n\n        // perform the change in same session only if the new and old reference belongs to same wiki (same database)\n        boolean sameSession = sourceWikiReference.equals(targetWikiReference);\n\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n        XWikiDocument newDocument = doc.cloneRename(newReference, context);\n        newDocument.setNew(true);\n        newDocument.setStore(this);\n        newDocument\n            .setComment(\"Renamed from \" + this.defaultEntityReferenceSerializer.serialize(doc.getDocumentReference()));\n\n        boolean copyPerformed = false;\n\n        try {\n            if (sameSession) {\n                // We execute the whole call with a commit at the end,\n                // but we ensure to not commit at each step (save and delete)\n                executeWrite(context, session -> {\n                    saveXWikiDoc(newDocument, context, false);\n\n                    // Since the save documment is called without a commit, the information are not flushed\n                    // in the session either. However we need the new information in the session for the delete\n                    // in particular to know the possible changes made in the spaces.\n                    session.flush();\n                    deleteXWikiDoc(doc, context, false);\n\n                    return true;\n                });\n            } else {\n                // Execute the save on the right DB with a commit at the end\n                context.setWikiReference(targetWikiReference);\n                executeWrite(context, session -> {\n                    saveXWikiDoc(newDocument, context, false);\n\n                    return true;\n                });\n\n                // to be able to rollback in case of problem during delete\n                copyPerformed = true;\n\n                // Execute the delete on the right DB with a commit at the end\n                context.setWikiReference(sourceWikiReference);\n                executeWrite(context, session -> {\n                    this.deleteXWikiDoc(doc, context, false);\n\n                    return true;\n                });\n            }\n        } catch (Exception e) {\n            // We only need to perform special actions in case of different sessions,\n            // and if the first step has been executed. In all other cases nothing should have been committed.\n            if (!sameSession && copyPerformed) {\n                // Ensure to delete the doc that has been copied already.\n                // Note that in case of problem there, the exception is directly thrown.\n                executeWrite(context, session -> {\n                    this.deleteXWikiDoc(newDocument, context, false);\n\n                    return true;\n                });\n            }\n\n            Object[] args = {doc.getDocumentReference(), newReference};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_RENAMING_DOC,\n                \"Exception while renaming document [{0}] to [{1}]\", e, args);\n        }\n    }\n\n    @Override\n    public XWikiDocument loadXWikiDoc(XWikiDocument defaultDocument, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        XWikiDocument doc = defaultDocument;\n        try {\n            boolean bTransaction = true;\n            MonitorPlugin monitor = Util.getMonitorPlugin(context);\n            try {\n                // Start monitoring timer\n                if (monitor != null) {\n                    monitor.startTimer(HINT);\n                }\n                checkHibernate(context);\n\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(defaultDocument, context);\n                bTransaction = bTransaction && beginTransaction(sfactory, context);\n                try {\n                    Session session = getSession(context);\n                    session.setHibernateFlushMode(FlushMode.MANUAL);\n\n                    doc = session.get(XWikiDocument.class, doc.getId());\n                    if (doc == null) {\n                        defaultDocument.setNew(true);\n\n                        // Make sure to always return a document with an original version, even for one that does not\n                        // exist.\n                        // Allow writing more generic code.\n                        defaultDocument.setOriginalDocument(\n                            new XWikiDocument(defaultDocument.getDocumentReference(), defaultDocument.getLocale()));\n\n                        return defaultDocument;\n                    }\n\n                    doc.setStore(this);\n                    doc.setNew(false);\n                    doc.setMostRecent(true);\n                    // Fix for XWIKI-1651\n                    doc.setDate(new Date(doc.getDate().getTime()));\n                    doc.setCreationDate(new Date(doc.getCreationDate().getTime()));\n                    doc.setContentUpdateDate(new Date(doc.getContentUpdateDate().getTime()));\n\n                    // Loading the attachment list\n                    if (doc.hasElement(XWikiDocument.HAS_ATTACHMENTS)) {\n                        loadAttachmentList(doc, context, false);\n                    }\n\n                    // TODO: handle the case where there are no xWikiClass and xWikiObject in the Database\n                    BaseClass bclass = new BaseClass();\n                    String cxml = doc.getXClassXML();\n                    if (cxml != null) {\n                        bclass.fromXML(cxml);\n                        doc.setXClass(bclass);\n                        bclass.setDirty(false);\n                    }\n\n                    // Store this XWikiClass in the context so that we can use it in case of recursive usage\n                    // of classes\n                    context.addBaseClass(bclass);\n\n                    if (doc.hasElement(XWikiDocument.HAS_OBJECTS)) {\n                        Query<BaseObject> query = session.createQuery(\n                            \"from BaseObject as bobject where bobject.name = :name order by bobject.number\",\n                            BaseObject.class);\n                        query.setParameter(\"name\", doc.getFullName());\n\n                        Iterator<BaseObject> it = query.list().iterator();\n\n                        EntityReference localGroupEntityReference = new EntityReference(\"XWikiGroups\",\n                            EntityType.DOCUMENT, new EntityReference(\"XWiki\", EntityType.SPACE));\n                        DocumentReference groupsDocumentReference = new DocumentReference(context.getWikiId(),\n                            localGroupEntityReference.getParent().getName(), localGroupEntityReference.getName());\n\n                        boolean hasGroups = false;\n                        while (it.hasNext()) {\n                            BaseObject object = it.next();\n                            DocumentReference classReference = object.getXClassReference();\n\n                            if (classReference == null) {\n                                continue;\n                            }\n\n                            // It seems to search before is case insensitive. And this would break the loading if we get\n                            // an\n                            // object which doesn't really belong to this document\n                            if (!object.getDocumentReference().equals(doc.getDocumentReference())) {\n                                continue;\n                            }\n\n                            BaseObject newobject;\n                            if (classReference.equals(doc.getDocumentReference())) {\n                                newobject = bclass.newCustomClassInstance(true);\n                            } else {\n                                newobject = BaseClass.newCustomClassInstance(classReference, true, context);\n                            }\n                            if (newobject != null) {\n                                newobject.setId(object.getId());\n                                newobject.setXClassReference(object.getRelativeXClassReference());\n                                newobject.setDocumentReference(object.getDocumentReference());\n                                newobject.setNumber(object.getNumber());\n                                newobject.setGuid(object.getGuid());\n                                object = newobject;\n                            }\n\n                            if (classReference.equals(groupsDocumentReference)) {\n                                // Groups objects are handled differently.\n                                hasGroups = true;\n                            } else {\n                                loadXWikiCollectionInternal(object, doc, context, false, true);\n                            }\n                            doc.setXObject(object.getNumber(), object);\n                        }\n\n                        // AFAICT this was added as an emergency patch because loading of objects has proven\n                        // too slow and the objects which cause the most overhead are the XWikiGroups objects\n                        // as each group object (each group member) would otherwise cost 2 database queries.\n                        // This will do every group member in a single query.\n                        if (hasGroups) {\n                            Query<Object[]> query2 = session.createQuery(\n                                \"select bobject.number, prop.value from StringProperty as prop,\"\n                                    + \"BaseObject as bobject where bobject.name = :name and bobject.className='XWiki.XWikiGroups' \"\n                                    + \"and bobject.id=prop.id.id and prop.id.name='member' order by bobject.number\",\n                                Object[].class);\n                            query2.setParameter(\"name\", doc.getFullName());\n\n                            Iterator<Object[]> it2 = query2.list().iterator();\n                            while (it2.hasNext()) {\n                                Object[] result = it2.next();\n                                Integer number = (Integer) result[0];\n                                String member = (String) result[1];\n                                BaseObject obj =\n                                    BaseClass.newCustomClassInstance(groupsDocumentReference, true, context);\n                                obj.setDocumentReference(doc.getDocumentReference());\n                                obj.setXClassReference(localGroupEntityReference);\n                                obj.setNumber(number.intValue());\n                                obj.setStringValue(\"member\", member);\n                                doc.setXObject(obj.getNumber(), obj);\n                            }\n                        }\n                    }\n\n                    doc.setContentDirty(false);\n                    doc.setMetaDataDirty(false);\n\n                    // We need to ensure that the loaded document becomes the original document\n                    doc.setOriginalDocument(doc.clone());\n\n                    if (bTransaction) {\n                        endTransaction(context, false);\n                    }\n                } finally {\n                    if (bTransaction) {\n                        try {\n                            endTransaction(context, false);\n                        } catch (Exception e) {\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                Object[] args = {defaultDocument.getDocumentReferenceWithLocale()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_READING_DOC, \"Exception while reading document [{0}]\", e,\n                    args);\n            } finally {\n                // End monitoring timer\n                if (monitor != null) {\n                    monitor.endTimer(HINT);\n                }\n            }\n\n            this.logger.debug(\"Loaded XWikiDocument: [{}]\", doc.getDocumentReferenceWithLocale());\n\n            return doc;\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    @Override\n    public void deleteXWikiDoc(XWikiDocument doc, XWikiContext inputxcontext) throws XWikiException\n    {\n        deleteXWikiDoc(doc, inputxcontext, true);\n    }\n\n    private void deleteXWikiDoc(XWikiDocument doc, XWikiContext inputxcontext, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            MonitorPlugin monitor = Util.getMonitorPlugin(context);\n            try {\n                // Start monitoring timer\n                if (monitor != null) {\n                    monitor.startTimer(HINT);\n                }\n                checkHibernate(context);\n                SessionFactory sfactory = injectCustomMappingsInSessionFactory(doc, context);\n                if (bTransaction) {\n                    bTransaction = beginTransaction(sfactory, context);\n                }\n                try {\n                    Session session = getSession(context);\n                    session.setHibernateFlushMode(FlushMode.COMMIT);\n\n                    if (doc.getStore() == null) {\n                        Object[] args = {doc.getDocumentReference()};\n                        throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                            XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CANNOT_DELETE_UNLOADED_DOC,\n                            \"Impossible to delete document {0} if it is not loaded\", null, args);\n                    }\n\n                    // Let's delete any attachment this document might have\n                    for (XWikiAttachment attachment : doc.getAttachmentList()) {\n                        XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(attachment);\n                        store.deleteXWikiAttachment(attachment, false, context, false);\n                    }\n\n                    // deleting XWikiLinks\n                    if (context.getWiki().hasBacklinks(context)) {\n                        deleteLinks(doc.getId(), context, true);\n                    }\n\n                    // Find the list of classes for which we have an object\n                    // Remove properties planned for removal\n                    if (!doc.getXObjectsToRemove().isEmpty()) {\n                        for (BaseObject bobj : doc.getXObjectsToRemove()) {\n                            if (bobj != null) {\n                                deleteXWikiCollection(bobj, context, false, false);\n                            }\n                        }\n                        doc.setXObjectsToRemove(new ArrayList<BaseObject>());\n                    }\n                    for (List<BaseObject> objects : doc.getXObjects().values()) {\n                        for (BaseObject obj : objects) {\n                            if (obj != null) {\n                                deleteXWikiCollection(obj, context, false, false);\n                            }\n                        }\n                    }\n                    context.getWiki().getVersioningStore().deleteArchive(doc, false, context);\n\n                    session.delete(doc);\n\n                    // We need to ensure that the deleted document becomes the original document\n                    doc.setOriginalDocument(doc.clone());\n\n                    // Update space table if needed\n                    maybeDeleteXWikiSpace(doc, session);\n\n                    if (bTransaction) {\n                        endTransaction(context, true);\n                    }\n                } finally {\n                    if (bTransaction) {\n                        try {\n                            endTransaction(context, false);\n                        } catch (Exception e) {\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                Object[] args = {doc.getDocumentReference()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC, \"Exception while deleting document {0}\", e,\n                    args);\n            } finally {\n                // End monitoring timer\n                if (monitor != null) {\n                    monitor.endTimer(HINT);\n                }\n            }\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    private void maybeDeleteXWikiSpace(XWikiDocument deletedDocument, Session session)\n    {\n        if (deletedDocument.getLocale().equals(Locale.ROOT)) {\n            DocumentReference documentReference = deletedDocument.getDocumentReference();\n            maybeDeleteXWikiSpace(documentReference.getLastSpaceReference(),\n                this.localEntityReferenceSerializer.serialize(documentReference), session);\n        }\n    }\n\n    private void maybeDeleteXWikiSpace(SpaceReference spaceReference, String deletedDocument, Session session)\n    {\n        if (!hasDocuments(spaceReference, session,\n            \"fullName <> :deletedDocument AND (language IS NULL OR language = '')\",\n            Collections.singletonMap(\"deletedDocument\", deletedDocument))) {\n            // The document was the last document in the space\n            XWikiSpace space = new XWikiSpace(spaceReference, this);\n\n            session.delete(space);\n\n            // Update parent\n            if (spaceReference.getParent() instanceof SpaceReference) {\n                maybeDeleteXWikiSpace((SpaceReference) spaceReference.getParent(), deletedDocument, session);\n            }\n        } else {\n            // Update space hidden property if needed\n            maybeMakeSpaceHidden(spaceReference, deletedDocument, session);\n        }\n    }\n\n    private XWikiSpace loadXWikiSpace(SpaceReference spaceReference, Session session)\n    {\n        XWikiSpace space = session.get(XWikiSpace.class, XWikiSpace.getId(spaceReference));\n\n        if (space != null) {\n            space.setStore(this);\n        }\n        return space;\n    }\n\n    private void checkObjectClassIsLocal(BaseCollection object, XWikiContext context) throws XWikiException\n    {\n        DocumentReference xclass = object.getXClassReference();\n        WikiReference wikiReference = xclass.getWikiReference();\n        String db = context.getWikiId();\n        if (!wikiReference.getName().equals(db)) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_OBJECT,\n                \"XObject [{0}] is an instance of an external XClass and cannot be persisted in this wiki [{1}].\", null,\n                new Object[] {this.localEntityReferenceSerializer.serialize(object.getReference()), db});\n        }\n    }\n\n    /**\n     * @deprecated This is internal to XWikiHibernateStore and may be removed in the future.\n     */\n    @Deprecated\n    public void saveXWikiCollection(BaseCollection object, XWikiContext inputxcontext, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            if (object == null) {\n                return;\n            }\n            // We need a slightly different behavior here\n            boolean stats = (object instanceof XWikiStats);\n            if (!stats) {\n                checkObjectClassIsLocal(object, context);\n            }\n\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            try {\n                Session session = getSession(context);\n\n                // Verify if the property already exists\n                Query<Long> query;\n                if (stats) {\n                    query = session.createQuery(\n                        \"select obj.id from \" + object.getClass().getName() + \" as obj where obj.id = :id\", Long.class);\n                } else {\n                    query = session.createQuery(\"select obj.id from BaseObject as obj where obj.id = :id\", Long.class);\n                }\n                query.setParameter(\"id\", object.getId());\n                if (query.uniqueResult() == null) {\n                    if (stats) {\n                        session.save(object);\n                    } else {\n                        session.save(\"com.xpn.xwiki.objects.BaseObject\", object);\n                    }\n                } else {\n                    if (stats) {\n                        session.update(object);\n                    } else {\n                        session.update(\"com.xpn.xwiki.objects.BaseObject\", object);\n                    }\n                }\n                /*\n                 * if (stats) session.saveOrUpdate(object); else\n                 * session.saveOrUpdate((String)\"com.xpn.xwiki.objects.BaseObject\", (Object)object);\n                 */\n                BaseClass bclass = object.getXClass(context);\n                List<String> handledProps = new ArrayList<>();\n                if ((bclass != null) && (bclass.hasCustomMapping()) && context.getWiki().hasCustomMappings()) {\n                    // save object using the custom mapping\n                    Map<String, Object> objmap = object.getCustomMappingMap();\n                    handledProps = bclass.getCustomMappingPropertyList(context);\n                    query = session.createQuery(\"select obj.id from \" + bclass.getName() + \" as obj where obj.id = :id\",\n                        Long.class);\n                    query.setParameter(\"id\", object.getId());\n                    if (query.uniqueResult() == null) {\n                        session.save(bclass.getName(), objmap);\n                    } else {\n                        session.update(bclass.getName(), objmap);\n                    }\n\n                    // dynamicSession.saveOrUpdate((String) bclass.getName(), objmap);\n                }\n\n                if (object.getXClassReference() != null) {\n                    // Remove properties to remove\n                    if (!object.getFieldsToRemove().isEmpty()) {\n                        for (int i = 0; i < object.getFieldsToRemove().size(); i++) {\n                            BaseProperty prop = (BaseProperty) object.getFieldsToRemove().get(i);\n                            if (!handledProps.contains(prop.getName())) {\n                                session.delete(prop);\n                            }\n                        }\n                        object.setFieldsToRemove(new ArrayList<>());\n                    }\n\n                    // Add missing properties to the object\n                    BaseClass xclass = object.getXClass(context);\n                    if (xclass != null) {\n                        for (String key : xclass.getPropertyList()) {\n                            if (object.safeget(key) == null) {\n                                PropertyClass classProperty = (PropertyClass) xclass.getField(key);\n                                BaseProperty property = classProperty.newProperty();\n                                if (property != null) {\n                                    object.safeput(key, property);\n                                }\n                            }\n                        }\n                    }\n\n                    // Save properties\n                    Iterator<String> it = object.getPropertyList().iterator();\n                    while (it.hasNext()) {\n                        String key = it.next();\n                        BaseProperty prop = (BaseProperty) object.getField(key);\n                        if (!prop.getName().equals(key)) {\n                            Object[] args = {key, object.getName()};\n                            throw new XWikiException(XWikiException.MODULE_XWIKI_CLASSES,\n                                XWikiException.ERROR_XWIKI_CLASSES_FIELD_INVALID,\n                                \"Field {0} in object {1} has an invalid name\", null, args);\n                        }\n\n                        String pname = prop.getName();\n                        if (pname != null && !pname.trim().equals(\"\") && !handledProps.contains(pname)) {\n                            saveXWikiPropertyInternal(prop, context, false);\n                        }\n                    }\n                }\n\n                if (bTransaction) {\n                    endTransaction(context, true);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        endTransaction(context, true);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        } catch (XWikiException xe) {\n            throw xe;\n        } catch (Exception e) {\n            Object[] args = {object.getName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_OBJECT, \"Exception while saving object {0}\", e, args);\n\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    /**\n     * @deprecated This is internal to XWikiHibernateStore and may be removed in the future.\n     */\n    @Deprecated\n    public void loadXWikiCollection(BaseCollection object, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        loadXWikiCollectionInternal(object, context, bTransaction, false);\n    }\n\n    private void loadXWikiCollectionInternal(BaseCollection object, XWikiContext context, boolean bTransaction,\n        boolean alreadyLoaded) throws XWikiException\n    {\n        loadXWikiCollectionInternal(object, null, context, bTransaction, alreadyLoaded);\n    }\n\n    private void loadXWikiCollectionInternal(BaseCollection object1, XWikiDocument doc, XWikiContext inputxcontext,\n        boolean bTransaction, boolean alreadyLoaded) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        BaseCollection object = object1;\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            try {\n                Session session = getSession(context);\n\n                if (!alreadyLoaded) {\n                    try {\n                        session.load(object, object1.getId());\n                    } catch (ObjectNotFoundException e) {\n                        // There is no object data saved\n                        object = null;\n                        return;\n                    }\n                }\n\n                DocumentReference classReference = object.getXClassReference();\n\n                // If the class reference is null in the loaded object then skip loading properties\n                if (classReference != null) {\n\n                    BaseClass bclass = null;\n                    if (!classReference.equals(object.getDocumentReference())) {\n                        // Let's check if the class has a custom mapping\n                        bclass = object.getXClass(context);\n                    } else {\n                        // We need to get it from the document otherwise\n                        // we will go in an endless loop\n                        if (doc != null) {\n                            bclass = doc.getXClass();\n                        }\n                    }\n\n                    List<String> handledProps = new ArrayList<>();\n                    try {\n                        if ((bclass != null) && (bclass.hasCustomMapping()) && context.getWiki().hasCustomMappings()) {\n                            String className =\n                                this.localEntityReferenceSerializer.serialize(bclass.getDocumentReference());\n                            @SuppressWarnings(\"unchecked\")\n                            Map<String, ?> map = (Map<String, ?>) session.load(className, object.getId());\n                            // Let's make sure to look for null fields in the dynamic mapping\n                            bclass.fromValueMap(map, object);\n                            for (String prop : bclass.getCustomMappingPropertyList(context)) {\n                                if (map.get(prop) != null) {\n                                    handledProps.add(prop);\n                                }\n                            }\n                        }\n                    } catch (HibernateException e) {\n                        this.logger.error(\"Failed loading custom mapping for doc [{}], class [{}], nb [{}]\",\n                            object.getDocumentReference(), object.getXClassReference(), object.getNumber(), e);\n                    }\n\n                    // Load strings, integers, dates all at once\n\n                    Query<Object[]> query = session.createQuery(\n                        \"select prop.name, prop.classType from BaseProperty as prop where prop.id.id = :id\",\n                        Object[].class);\n                    query.setParameter(\"id\", object.getId());\n                    for (Object[] result : (List<Object[]>) query.list()) {\n                        String name = (String) result[0];\n                        // No need to load fields already loaded from\n                        // custom mapping\n                        if (handledProps.contains(name)) {\n                            continue;\n                        }\n                        String classType = (String) result[1];\n                        BaseProperty property = null;\n\n                        try {\n                            property = (BaseProperty) Class.forName(classType).newInstance();\n                            property.setObject(object);\n                            property.setName(name);\n                            loadXWikiProperty(property, context, false);\n                        } catch (Exception e) {\n                            // WORKAROUND IN CASE OF MIXMATCH BETWEEN STRING AND LARGESTRING\n                            try {\n                                if (property instanceof StringProperty) {\n                                    LargeStringProperty property2 = new LargeStringProperty();\n                                    property2.setObject(object);\n                                    property2.setName(name);\n                                    loadXWikiProperty(property2, context, false);\n                                    property.setValue(property2.getValue());\n\n                                    if (bclass != null) {\n                                        if (bclass.get(name) instanceof TextAreaClass) {\n                                            property = property2;\n                                        }\n                                    }\n\n                                } else if (property instanceof LargeStringProperty) {\n                                    StringProperty property2 = new StringProperty();\n                                    property2.setObject(object);\n                                    property2.setName(name);\n                                    loadXWikiProperty(property2, context, false);\n                                    property.setValue(property2.getValue());\n\n                                    if (bclass != null) {\n                                        if (bclass.get(name) instanceof StringClass) {\n                                            property = property2;\n                                        }\n                                    }\n                                } else {\n                                    throw e;\n                                }\n                            } catch (Throwable e2) {\n                                Object[] args = {object.getName(), object.getClass(),\n                                    Integer.valueOf(object.getNumber() + \"\"), name};\n                                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\n                                    \"Exception while loading object [{0}] of class [{1}], number [{2}] and property [{3}]\",\n                                    e, args);\n                            }\n                        }\n\n                        object.addField(name, property);\n                    }\n                }\n\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        endTransaction(context, false);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            Object[] args = {object.getName(), object.getClass(), object.getNumber()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\n                \"Exception while loading object [{0}] of class [{1}] and number [{2}]\", e, args);\n\n        } finally {\n            restoreExecutionXContext();\n        }\n\n    }\n\n    /**\n     * @deprecated This is internal to XWikiHibernateStore and may be removed in the future.\n     */\n    @Deprecated\n    public void deleteXWikiCollection(BaseCollection object, XWikiContext inputxcontext, boolean bTransaction,\n        boolean evict) throws XWikiException\n    {\n        if (object == null) {\n            return;\n        }\n\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            if (bTransaction) {\n                checkHibernate(context);\n                bTransaction = beginTransaction(context);\n            }\n            try {\n                Session session = getSession(context);\n\n                // Let's check if the class has a custom mapping\n                BaseClass bclass = object.getXClass(context);\n                List<String> handledProps = new ArrayList<>();\n                if ((bclass != null) && (bclass.hasCustomMapping()) && context.getWiki().hasCustomMappings()) {\n                    handledProps = bclass.getCustomMappingPropertyList(context);\n                    Object map = session.get(bclass.getName(), object.getId());\n                    if (map != null) {\n                        if (evict) {\n                            session.evict(map);\n                        }\n                        session.delete(map);\n                    }\n                }\n\n                if (object.getXClassReference() != null) {\n                    for (BaseElement property : (Collection<BaseElement>) object.getFieldList()) {\n                        if (!handledProps.contains(property.getName())) {\n                            if (evict) {\n                                session.evict(property);\n                            }\n                            if (session.get(property.getClass(), property) != null) {\n                                session.delete(property);\n                            }\n                        }\n                    }\n                }\n\n                // In case of custom class we need to force it as BaseObject to delete the xwikiobject row\n                if (!\"\".equals(bclass.getCustomClass())) {\n                    BaseObject cobject = new BaseObject();\n                    cobject.setDocumentReference(object.getDocumentReference());\n                    cobject.setClassName(object.getClassName());\n                    cobject.setNumber(object.getNumber());\n                    if (object instanceof BaseObject) {\n                        cobject.setGuid(((BaseObject) object).getGuid());\n                    }\n                    cobject.setId(object.getId());\n                    if (evict) {\n                        session.evict(cobject);\n                    }\n                    session.delete(cobject);\n                } else {\n                    if (evict) {\n                        session.evict(object);\n                    }\n                    session.delete(object);\n                }\n\n                if (bTransaction) {\n                    endTransaction(context, true);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        endTransaction(context, false);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            Object[] args = {object.getName()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_OBJECT, \"Exception while deleting object {0}\", e,\n                args);\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    private void loadXWikiProperty(PropertyInterface property, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        executeRead(context, session -> {\n            try {\n                try {\n                    session.load(property, (Serializable) property);\n                    // In Oracle, empty string are converted to NULL. Since an undefined property is not found at all,\n                    // it is\n                    // safe to assume that a retrieved NULL value should actually be an empty string.\n                    if (property instanceof BaseStringProperty) {\n                        BaseStringProperty stringProperty = (BaseStringProperty) property;\n                        if (stringProperty.getValue() == null) {\n                            stringProperty.setValue(\"\");\n                        }\n                    }\n                    ((BaseProperty) property).setValueDirty(false);\n                } catch (ObjectNotFoundException e) {\n                    // Let's accept that there is no data in property tables but log it\n                    this.logger.error(\"No data for property [{}] of object id [{}]\", property.getName(),\n                        property.getId());\n                }\n\n                // TODO: understand why collections are lazy loaded\n                // Let's force reading lists if there is a list\n                // This seems to be an issue since Hibernate 3.0\n                // Without this test ViewEditTest.testUpdateAdvanceObjectProp fails\n                if (property instanceof ListProperty) {\n                    ((ListProperty) property).getList();\n                }\n            } catch (Exception e) {\n                BaseCollection obj = property.getObject();\n                Object[] args = {(obj != null) ? obj.getName() : \"unknown\", property.getName()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\n                    \"Exception while loading property {1} of object {0}\", e, args);\n\n            }\n\n            return null;\n        });\n    }\n\n    private void saveXWikiPropertyInternal(final PropertyInterface property, final XWikiContext context,\n        final boolean runInOwnTransaction) throws XWikiException\n    {\n        // Clone runInOwnTransaction so the value passed is not altered.\n        boolean bTransaction = runInOwnTransaction;\n        try {\n            if (bTransaction) {\n                this.checkHibernate(context);\n                bTransaction = this.beginTransaction(context);\n            }\n            try {\n                final Session session = this.getSession(context);\n\n                Query<String> query = session.createQuery(\n                    \"select prop.classType from BaseProperty as prop where prop.id.id = :id and prop.id.name= :name\",\n                    String.class);\n                query.setParameter(\"id\", property.getId());\n                query.setParameter(\"name\", property.getName());\n\n                String oldClassType = query.uniqueResult();\n                String newClassType = ((BaseProperty) property).getClassType();\n                if (oldClassType == null) {\n                    session.save(property);\n                } else if (oldClassType.equals(newClassType)) {\n                    session.update(property);\n                } else {\n                    // The property type has changed. We cannot simply update its value because the new value and the\n                    // old\n                    // value are stored in different tables (we're using joined-subclass to map different property\n                    // types).\n                    // We must delete the old property value before saving the new one and for this we must load the old\n                    // property from the table that corresponds to the old property type (we cannot delete and save the\n                    // new\n                    // property or delete a clone of the new property; loading the old property from the BaseProperty\n                    // table\n                    // doesn't work either).\n                    Query propQuery = session.createQuery(\n                        \"select prop from \" + oldClassType + \" as prop where prop.id.id = :id and prop.id.name= :name\");\n                    propQuery.setParameter(\"id\", property.getId());\n                    propQuery.setParameter(\"name\", property.getName());\n                    session.delete(propQuery.uniqueResult());\n                    session.save(property);\n                }\n\n                ((BaseProperty) property).setValueDirty(false);\n\n                if (bTransaction) {\n                    endTransaction(context, true);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        this.endTransaction(context, false);\n                    } catch (Exception ee) {\n                        // Not a lot we can do here if there was an exception committing and an exception rolling back.\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Something went wrong, collect some information.\n            final BaseCollection obj = property.getObject();\n            final Object[] args = {(obj != null) ? obj.getName() : \"unknown\", property.getName()};\n\n            // Throw the exception.\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\n                \"Exception while saving property {1} of object {0}\", e, args);\n        }\n    }\n\n    private void loadAttachmentList(XWikiDocument doc, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        executeRead(context, session -> {\n            try {\n                Query<XWikiAttachment> query = session\n                    .createQuery(\"from XWikiAttachment as attach where attach.docId=:docid\", XWikiAttachment.class);\n                query.setParameter(\"docid\", doc.getId());\n\n                List<XWikiAttachment> list = query.list();\n                for (XWikiAttachment attachment : list) {\n                    doc.setAttachment(attachment);\n                }\n\n                return null;\n            } catch (Exception e) {\n                this.logger.error(\"Failed to load attachments of document [{}]\", doc.getDocumentReference(), e);\n\n                Object[] args = {doc.getDocumentReference()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCHING_ATTACHMENT,\n                    \"Exception while searching attachments for documents {0}\", e, args);\n            }\n        });\n    }\n\n    private boolean isDeleted(XWikiAttachment attachment, XWikiDocument doc)\n    {\n        for (XWikiAttachmentToRemove attachmentToRemove : doc.getAttachmentsToRemove()) {\n            if (attachmentToRemove.getAttachment().getFilename().equals(attachment.getFilename())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private void saveAttachmentList(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        try {\n            List<XWikiAttachment> list = doc.getAttachmentList();\n            for (XWikiAttachment attachment : list) {\n                saveAttachment(attachment, isDeleted(attachment, doc), context);\n            }\n\n        } catch (Exception e) {\n            Object[] args = {doc.getDocumentReference()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_ATTACHMENT_LIST,\n                \"Exception while saving attachments attachment list of document {0}\", e, args);\n        }\n    }\n\n    private void saveAttachment(XWikiAttachment attachment, boolean deleted, XWikiContext context) throws XWikiException\n    {\n        try {\n            // If the comment is larger than the max size supported by the Storage, then abbreviate it\n            String comment = attachment.getComment();\n            if (comment != null && comment.length() > 1023) {\n                attachment.setComment(StringUtils.abbreviate(comment, 1023));\n            }\n\n            Session session = getSession(context);\n\n            Query<Long> query = session\n                .createQuery(\"select attach.id from XWikiAttachment as attach where attach.id = :id\", Long.class);\n            query.setParameter(\"id\", attachment.getId());\n            boolean exist = query.uniqueResult() != null;\n\n            boolean saveContent;\n            if (exist) {\n                // Don't update the history if the document was actually not supposed to exist\n                // Don't update the attachment version if document metadata dirty is forced false (any modification to\n                // the attachment automatically set document metadata dirty to true)\n                if (!deleted && attachment.isContentDirty() && attachment.getDoc().isMetaDataDirty()) {\n                    attachment.updateContentArchive(context);\n                }\n\n                session.update(attachment);\n\n                // Save the attachment content if it's marked as \"dirty\" (out of sync with the database).\n                saveContent = attachment.isContentDirty();\n            } else {\n                if (attachment.getContentStore() == null) {\n                    // Set content store\n                    attachment.setContentStore(getDefaultAttachmentContentStore(context));\n                }\n\n                if (attachment.getArchiveStore() == null) {\n                    // Set archive store\n                    attachment.setArchiveStore(getDefaultAttachmentArchiveStore(context));\n                }\n\n                session.save(attachment);\n\n                // Always save the content since it does not exist\n                saveContent = true;\n            }\n\n            if (saveContent) {\n                // updateParent and bTransaction must be false because the content should be saved in the same\n                // transaction as the attachment and if the parent doc needs to be updated, this function will do it.\n                XWikiAttachmentStoreInterface store = getXWikiAttachmentStoreInterface(attachment);\n                store.saveAttachmentContent(attachment, false, context, false);\n            }\n\n            // Mark the attachment content and metadata as not dirty.\n            // Ideally this would only happen if the transaction is committed successfully but since an unsuccessful\n            // transaction will most likely be accompanied by an exception, the cache will not have a chance to save\n            // the copy of the document with erroneous information. If this is not set here, the cache will return\n            // a copy of the attachment which claims to be dirty although it isn't.\n            attachment.setMetaDataDirty(false);\n            if (attachment.isContentDirty()) {\n                attachment.getAttachment_content().setContentDirty(false);\n            }\n\n        } catch (Exception e) {\n            Object[] args = {attachment.getReference()};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_ATTACHMENT, \"Exception while saving attachment [{0}]\",\n                e, args);\n        }\n    }\n\n    // ---------------------------------------\n    // Locks\n    // ---------------------------------------\n\n    @Override\n    public XWikiLock loadLock(long docId, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                XWikiLock lock = null;\n\n                Query<Long> query = session\n                    .createQuery(\"select lock.docId from XWikiLock as lock where lock.docId = :docId\", Long.class);\n                query.setParameter(\"docId\", docId);\n                if (query.uniqueResult() != null) {\n                    lock = new XWikiLock();\n                    session.load(lock, Long.valueOf(docId));\n                }\n\n                return lock;\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_LOCK, \"Exception while loading lock\", e);\n            }\n        });\n    }\n\n    @Override\n    public void saveLock(XWikiLock lock, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        executeWrite(inputxcontext, session -> {\n            try {\n                Query<Long> query = session\n                    .createQuery(\"select lock.docId from XWikiLock as lock where lock.docId = :docId\", Long.class);\n                query.setParameter(\"docId\", lock.getDocId());\n                if (query.uniqueResult() == null) {\n                    session.save(lock);\n                } else {\n                    session.update(lock);\n                }\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_LOCK,\n                    String.format(\"Exception while locking document for lock [%s]\", lock.toString()), e);\n            }\n\n            return null;\n        });\n    }\n\n    @Override\n    public void deleteLock(XWikiLock lock, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        executeWrite(inputxcontext, session -> {\n            try {\n                session.delete(lock);\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_LOCK, \"Exception while deleting lock\", e);\n            }\n\n            return null;\n        });\n    }\n\n    private void registerLogoutListener()\n    {\n        this.observationManager.addListener(new EventListener()\n        {\n            private final Event ev = new ActionExecutingEvent();\n\n            @Override\n            public String getName()\n            {\n                return \"deleteLocksOnLogoutListener\";\n            }\n\n            @Override\n            public List<Event> getEvents()\n            {\n                return Collections.<Event>singletonList(this.ev);\n            }\n\n            @Override\n            public void onEvent(Event event, Object source, Object data)\n            {\n                if (\"logout\".equals(((ActionExecutingEvent) event).getActionName())) {\n                    final XWikiContext ctx = (XWikiContext) data;\n                    if (ctx.getUserReference() != null) {\n                        releaseAllLocksForCurrentUser(ctx);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Release all of the locks held by the currently logged in user.\n     *\n     * @param ctx the XWikiContext, used to start the connection and get the user name.\n     */\n    private void releaseAllLocksForCurrentUser(final XWikiContext ctx)\n    {\n        try {\n            executeWrite(ctx, session -> {\n                final Query query = session.createQuery(\"delete from XWikiLock as lock where lock.userName=:userName\");\n                // Using deprecated getUser() because this is how locks are created.\n                // It would be a maintainibility disaster to use different code paths\n                // for calculating names when creating and removing.\n                query.setParameter(\"userName\", ctx.getUser());\n                query.executeUpdate();\n\n                return null;\n            });\n        } catch (Exception e) {\n            String msg = \"Error while deleting active locks held by user.\";\n            try {\n                this.endTransaction(ctx, false);\n            } catch (Exception utoh) {\n                msg += \" Failed to commit OR rollback [\" + utoh.getMessage() + \"]\";\n            }\n            throw new UnexpectedException(msg, e);\n        }\n\n        // If we're in a non-main wiki & the user is global,\n        // switch to the global wiki and delete locks held there.\n        if (!ctx.isMainWiki() && ctx.isMainWiki(ctx.getUserReference().getWikiReference().getName())) {\n            final String cdb = ctx.getWikiId();\n            try {\n                ctx.setWikiId(ctx.getMainXWiki());\n                this.releaseAllLocksForCurrentUser(ctx);\n            } finally {\n                ctx.setWikiId(cdb);\n            }\n        }\n    }\n\n    // ---------------------------------------\n    // Links\n    // ---------------------------------------\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public List<XWikiLink> loadLinks(long docId, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                Query<XWikiLink> query =\n                    session.createQuery(\" from XWikiLink as link where link.id.docId = :docId\", XWikiLink.class);\n                query.setParameter(\"docId\", docId);\n\n                return query.list();\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_LINKS, \"Exception while loading links\", e);\n            }\n        });\n    }\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public List<DocumentReference> loadBacklinks(DocumentReference documentReference, boolean bTransaction,\n        XWikiContext inputxcontext) throws XWikiException\n    {\n        return innerLoadBacklinks(inputxcontext, (Session session) -> {\n            // the select clause is compulsory to reach the fullName i.e. the page pointed\n            Query<String> query = session.createQuery(\n                \"select distinct backlink.fullName from XWikiLink as backlink where backlink.id.link = :backlink\",\n                String.class);\n\n            // if we are in the same wiki context, we should only get the local reference\n            // but if we are not, then we have to check the full reference, containing the wiki part since\n            // it's how the link are recorded.\n            // This should be changed once the refactoring to support backlinks properly has been done.\n            // See: XWIKI-16192\n            query.setParameter(\"backlink\", this.compactWikiEntityReferenceSerializer.serialize(documentReference));\n            return query;\n        });\n    }\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public List<DocumentReference> loadBacklinks(AttachmentReference attachmentReference, boolean bTransaction,\n        XWikiContext inputxcontext) throws XWikiException\n    {\n        return innerLoadBacklinks(inputxcontext, (Session session) -> {\n            // the select clause is compulsory to reach the fullName i.e. the page pointed\n            Query<String> query = session.createQuery(\n                \"select distinct backlink.fullName from XWikiLink as backlink \" + \"where backlink.id.link = :backlink \"\n                    + \"and backlink.id.type = :type \" + \"and backlink.attachmentName = :attachmentName\",\n                String.class);\n\n            // if we are in the same wiki context, we should only get the local reference\n            // but if we are not, then we have to check the full reference, containing the wiki part since\n            // it's how the link are recorded.\n            // This should be changed once the refactoring to support backlinks properly has been done.\n            // See: XWIKI-16192\n            query.setParameter(\"backlink\",\n                this.compactWikiEntityReferenceSerializer.serialize(attachmentReference.getDocumentReference()));\n            query.setParameter(\"type\", attachmentReference.getType().getLowerCase());\n            query.setParameter(\"attachmentName\", attachmentReference.getName());\n            return query;\n        });\n    }\n\n    private List<DocumentReference> innerLoadBacklinks(XWikiContext inputxcontext,\n        Function<Session, Query<String>> queryBuilder) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                // Note: Ideally the method should return a Set but it would break the current API.\n\n                // TODO: We use a Set here so that we don't get duplicates. In the future, when we can reference a page\n                // in\n                // another language using a syntax, we should modify this code to return one DocumentReference per\n                // language\n                // found. To implement this we need to be able to either serialize the reference with the language\n                // information\n                // or add some new column for the XWikiLink table in the database.\n                Set<DocumentReference> backlinkReferences = new HashSet<>();\n\n                Query<String> apply = queryBuilder.apply(session);\n                List<String> backlinkNames = apply.list();\n\n                // Convert strings into references\n                for (String backlinkName : backlinkNames) {\n                    DocumentReference backlinkreference =\n                        this.currentMixedDocumentReferenceResolver.resolve(backlinkName);\n                    backlinkReferences.add(backlinkreference);\n                }\n\n                return new ArrayList<>(backlinkReferences);\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_BACKLINKS, \"Exception while loading backlinks\",\n                    e);\n            }\n        });\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #loadBacklinks(DocumentReference, boolean, XWikiContext)}\n     */\n    @Deprecated\n    @Override\n    public List<String> loadBacklinks(String fullName, XWikiContext inputxcontext, boolean bTransaction)\n        throws XWikiException\n    {\n        List<String> backlinkNames = new ArrayList<>();\n        List<DocumentReference> backlinkReferences =\n            loadBacklinks(this.currentMixedDocumentReferenceResolver.resolve(fullName), bTransaction, inputxcontext);\n        for (DocumentReference backlinkReference : backlinkReferences) {\n            backlinkNames.add(this.localEntityReferenceSerializer.serialize(backlinkReference));\n        }\n        return backlinkNames;\n    }\n\n    private Set<XWikiLink> extractLinks(XWikiDocument doc, XWikiContext context)\n    {\n        Set<XWikiLink> links = new LinkedHashSet<>();\n\n        String fullName = this.localEntityReferenceSerializer.serialize(doc.getDocumentReference());\n\n        // Add entity references.\n        for (EntityReference entityReference : doc.getUniqueLinkedEntities(context)) {\n            XWikiLink wikiLink = new XWikiLink();\n\n            wikiLink.setDocId(doc.getId());\n            wikiLink.setFullName(fullName);\n\n            // getUniqueLinkedEntities() returns both DOCUMENT and PAGE references (and ATTACHMENT and\n            // PAGE_ATTACHMENT references). If the reference is a PageReference (or a PageAttachmentReference) then\n            // we can't know if it points to a terminal page or a non-terminal one, and thus we need to get the\n            // document to check if it exists, starting with the non-terminal one since \"[[page:test]]\" points\n            // first to the non-terminal page when it exists.\n            EntityReference documentReferenceToSerialize = convertToDocumentReference(entityReference);\n            wikiLink.setLink(this.compactWikiEntityReferenceSerializer.serialize(documentReferenceToSerialize));\n            boolean isAttachmentReference = false;\n            if (Objects.equals(entityReference.getType(), EntityType.ATTACHMENT)\n                || Objects.equals(entityReference.getType(), EntityType.PAGE_ATTACHMENT)) {\n                wikiLink.setAttachmentName(entityReference.getName());\n                isAttachmentReference = true;\n            }\n            wikiLink.setType(\n                isAttachmentReference ? EntityType.ATTACHMENT.getLowerCase() : EntityType.DOCUMENT.getLowerCase());\n\n            links.add(wikiLink);\n        }\n\n        // Add included pages.\n        List<String> includedPages = doc.getIncludedPages(context);\n        for (String includedPage : includedPages) {\n            XWikiLink wikiLink = new XWikiLink();\n\n            wikiLink.setDocId(doc.getId());\n            wikiLink.setFullName(fullName);\n            wikiLink.setLink(includedPage);\n            wikiLink.setType(EntityType.DOCUMENT.getLowerCase());\n            links.add(wikiLink);\n        }\n\n        return links;\n    }\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public void saveLinks(XWikiDocument doc, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        // Extract the links\n        Set<XWikiLink> links = extractLinks(doc, context);\n\n        // Save the links\n        executeWrite(context, session -> {\n            // We delete the existing links before saving the newly analyzed ones. Unless non exists yet.\n            if (countLinks(doc.getId(), context, false) > 0) {\n                deleteLinks(doc.getId(), context, false);\n            }\n\n            // necessary to blank links from doc\n            context.remove(\"links\");\n\n            if (!links.isEmpty()) {\n                // Get link size limit\n                int linkMaxSize = getLimitSize(context, XWikiLink.class, \"link\");\n\n                // Save the links.\n                for (XWikiLink wikiLink : links) {\n                    // Verify that the link reference isn't larger than the maximum size of the field since otherwise\n                    // that would lead to a DB error that would result in a fatal error, and the user would have a hard\n                    // time understanding why his page failed to be saved.\n                    if (wikiLink.getLink().length() <= linkMaxSize) {\n                        session.save(wikiLink);\n                    } else {\n                        this.logger.warn(\"Could not store backlink [{}] because the link reference [{}] is too big\",\n                            wikiLink, wikiLink.getLink());\n                    }\n                }\n            }\n\n            return null;\n        });\n    }\n\n    private EntityReference convertToDocumentReference(EntityReference entityReference)\n    {\n        // The passed entityReference can of type DOCUMENT, ATTACHMENT, PAGE or PAGE_ATTACHMENT.\n        EntityReference documentReference = entityReference;\n        if (documentReference instanceof PageAttachmentReference) {\n            documentReference = documentReference.extractReference(EntityType.PAGE);\n        }\n        if (documentReference instanceof PageReference) {\n            // If the reference is a PageReference then we can't know if it points to a terminal page or a\n            // non-terminal one, and thus we need to resolve it.\n            documentReference =\n                this.currentPageReferenceDocumentReferenceResolver.resolve((PageReference) documentReference);\n        } else {\n            documentReference = documentReference.extractReference(EntityType.DOCUMENT);\n        }\n        return documentReference;\n    }\n\n    @Override\n    @Deprecated(since = \"14.8RC1\")\n    public void deleteLinks(long docId, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        executeWrite(inputxcontext, session -> {\n            try {\n                Query<?> query = session.createQuery(\"delete from XWikiLink as link where link.id.docId = :docId\");\n                query.setParameter(\"docId\", docId);\n                query.executeUpdate();\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_LINKS, \"Exception while deleting links\", e);\n            }\n\n            return null;\n        });\n    }\n\n    public void getContent(XWikiDocument doc, StringBuffer buf)\n    {\n        buf.append(doc.getContent());\n    }\n\n    @Override\n    public List<String> getClassList(XWikiContext inputxcontext) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                Query<String> query = session.createQuery(\"select doc.fullName from XWikiDocument as doc \"\n                    + \"where (doc.xWikiClassXML is not null and doc.xWikiClassXML like '<%')\", String.class);\n                List<String> list = new ArrayList<>();\n                list.addAll(query.list());\n\n                return list;\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH, \"Exception while searching class list\", e);\n            }\n        });\n    }\n\n    private <T> Query<T> createQuery(Session session, String statement, Collection<?> parameterValues)\n    {\n        Query<T> query = session.createQuery(statement);\n\n        injectParameterListToQuery(LegacySessionImplementor.containsLegacyOrdinalStatement(statement) ? 0 : 1, query,\n            parameterValues);\n\n        return query;\n    }\n\n    /**\n     * Add values into named query.\n     *\n     * @param parameterId the parameter id to increment.\n     * @param query the query to fill.\n     * @param parameterValues the values to add to query.\n     * @return the id of the next parameter to add.\n     */\n    private int injectParameterListToQuery(int parameterId, Query<?> query, Collection<?> parameterValues)\n    {\n        int index = parameterId;\n\n        if (parameterValues != null) {\n            for (Iterator<?> valueIt = parameterValues.iterator(); valueIt.hasNext(); ++index) {\n                injectParameterToQuery(index, query, valueIt.next());\n            }\n        }\n\n        return index;\n    }\n\n    /**\n     * Add value into named query.\n     *\n     * @param parameterId the parameter id to increment.\n     * @param query the query to fill.\n     * @param parameterValue the values to add to query.\n     */\n    private void injectParameterToQuery(int parameterId, Query<?> query, Object parameterValue)\n    {\n        query.setParameter(parameterId, parameterValue);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String parametrizedSqlClause, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocumentReferences(parametrizedSqlClause, 0, 0, parameterValues, context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String parametrizedSqlClause, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocumentsNames(parametrizedSqlClause, 0, 0, parameterValues, context);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String parametrizedSqlClause, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select distinct doc.fullName\", parametrizedSqlClause);\n        return searchDocumentReferencesInternal(sql, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select distinct doc.fullName\", parametrizedSqlClause);\n        return searchDocumentsNamesInternal(sql, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String wheresql, XWikiContext context) throws XWikiException\n    {\n        return searchDocumentReferences(wheresql, 0, 0, \"\", context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String wheresql, XWikiContext context) throws XWikiException\n    {\n        return searchDocumentsNames(wheresql, 0, 0, \"\", context);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String wheresql, int nb, int start, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocumentReferences(wheresql, nb, start, \"\", context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String wheresql, int nb, int start, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocumentsNames(wheresql, nb, start, \"\", context);\n    }\n\n    @Override\n    public List<DocumentReference> searchDocumentReferences(String wheresql, int nb, int start, String selectColumns,\n        XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select distinct doc.fullName\", wheresql);\n        return searchDocumentReferencesInternal(sql, nb, start, Collections.EMPTY_LIST, context);\n    }\n\n    @Override\n    public List<String> searchDocumentsNames(String wheresql, int nb, int start, String selectColumns,\n        XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select distinct doc.fullName\", wheresql);\n        return searchDocumentsNamesInternal(sql, nb, start, Collections.EMPTY_LIST, context);\n    }\n\n    @Override\n    public <T> List<T> search(String sql, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return search(sql, nb, start, (List<?>) null, context);\n    }\n\n    @Override\n    public <T> List<T> search(String sql, int nb, int start, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        return search(sql, nb, start, null, parameterValues, context);\n    }\n\n    @Override\n    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)\n        throws XWikiException\n    {\n        return search(sql, nb, start, whereParams, null, context);\n    }\n\n    @Override\n    public <T> List<T> search(final String sql, int nb, int start, Object[][] whereParams, List<?> parameterValues,\n        XWikiContext inputxcontext) throws XWikiException\n    {\n        if (sql == null) {\n            return null;\n        }\n\n        return executeRead(inputxcontext, session -> {\n            try {\n                boolean legacyOrdinal = LegacySessionImplementor.containsLegacyOrdinalStatement(sql);\n\n                String statement = sql;\n\n                if (whereParams != null) {\n                    statement += generateWhereStatement(whereParams,\n                        legacyOrdinal ? -1 : CollectionUtils.size(parameterValues.size()));\n                }\n\n                statement = filterSQL(statement);\n                Query<T> query = session.createQuery(statement);\n\n                injectParameterListToQuery(legacyOrdinal ? 0 : 1, query, parameterValues);\n\n                if (whereParams != null) {\n                    int parameterIndex = CollectionUtils.size(parameterValues);\n                    if (legacyOrdinal) {\n                        ++parameterIndex;\n                    }\n                    for (Object[] whereParam : whereParams) {\n                        query.setParameter(parameterIndex++, whereParam[1]);\n                    }\n                }\n\n                if (start > 0) {\n                    query.setFirstResult(start);\n                }\n                if (nb > 0) {\n                    query.setMaxResults(nb);\n                }\n                List<T> list = new ArrayList<>();\n                list.addAll(query.list());\n\n                return list;\n            } catch (Exception e) {\n                Object[] args = {sql};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                    \"Exception while searching documents with sql {0}\", e, args);\n            }\n        });\n    }\n\n    private String generateWhereStatement(Object[][] whereParams, int previousIndex)\n    {\n        StringBuilder str = new StringBuilder();\n\n        int index = previousIndex;\n\n        str.append(\" where \");\n        for (int i = 0; i < whereParams.length; i++) {\n            if (i > 0) {\n                if (whereParams[i - 1].length >= 4 && whereParams[i - 1][3] != \"\" && whereParams[i - 1][3] != null) {\n                    str.append(\" \");\n                    str.append(whereParams[i - 1][3]);\n                    str.append(\" \");\n                } else {\n                    str.append(\" and \");\n                }\n            }\n            str.append(whereParams[i][0]);\n            if (whereParams[i].length >= 3 && whereParams[i][2] != \"\" && whereParams[i][2] != null) {\n                str.append(\" \");\n                str.append(whereParams[i][2]);\n                str.append(\" \");\n            } else {\n                str.append(\" = \");\n            }\n            str.append(\" ?\");\n            if (index > -1) {\n                str.append(++index);\n            }\n        }\n\n        return str.toString();\n    }\n\n    public List search(Query query, int nb, int start, XWikiContext inputxcontext) throws XWikiException\n    {\n        if (query == null) {\n            return null;\n        }\n\n        return executeRead(inputxcontext, session -> {\n            try {\n                if (start > 0) {\n                    query.setFirstResult(start);\n                }\n                if (nb > 0) {\n                    query.setMaxResults(nb);\n                }\n                Iterator it = query.list().iterator();\n                List list = new ArrayList<>();\n                while (it.hasNext()) {\n                    list.add(it.next());\n                }\n\n                return list;\n            } catch (Exception e) {\n                Object[] args = {query.toString()};\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                    \"Exception while searching documents with sql {0}\", e, args);\n            }\n        });\n    }\n\n    @Override\n    public int countDocuments(String wheresql, XWikiContext context) throws XWikiException\n    {\n        String sql = createSQLQuery(\"select count(distinct doc.fullName)\", wheresql);\n        List<Number> l = search(sql, 0, 0, context);\n        return l.get(0).intValue();\n    }\n\n    @Override\n    public int countDocuments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        String sql = createSQLQuery(\"select count(distinct doc.fullName)\", parametrizedSqlClause);\n        List l = search(sql, 0, 0, parameterValues, context);\n        return ((Number) l.get(0)).intValue();\n    }\n\n    /**\n     * @deprecated since 2.2M1 used {@link #searchDocumentReferencesInternal(String, int, int, List, XWikiContext)}\n     */\n    @Deprecated\n    private List<String> searchDocumentsNamesInternal(String sql, int nb, int start, List parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        List<String> documentNames = new ArrayList<>();\n        for (DocumentReference reference : searchDocumentReferencesInternal(sql, nb, start, parameterValues, context)) {\n            documentNames.add(this.compactWikiEntityReferenceSerializer.serialize(reference));\n        }\n        return documentNames;\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    private List<DocumentReference> searchDocumentReferencesInternal(String sql, int nb, int start,\n        List<?> parameterValues, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            List<DocumentReference> documentReferences = new ArrayList<>();\n\n            // Construct a reference, using the current wiki as the wiki reference name. This is because the wiki\n            // name is not stored in the database for document references.\n            WikiReference wikiReference = new WikiReference(context.getWikiId());\n            for (Object result : this.searchGenericInternal(sql, nb, start, parameterValues, context)) {\n                // The select always contains several elements in case of order by so we have to support both Object[]\n                // and\n                // String\n                String referenceString;\n                if (result instanceof String) {\n                    referenceString = (String) result;\n                } else {\n                    referenceString = (String) ((Object[]) result)[0];\n                }\n\n                DocumentReference reference =\n                    this.defaultDocumentReferenceResolver.resolve(referenceString, wikiReference);\n\n                documentReferences.add(reference);\n            }\n\n            return documentReferences;\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    /**\n     * @since 2.2M1\n     */\n    private <T> List<T> searchGenericInternal(String sql, int nb, int start, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        return executeRead(context, session -> {\n            try {\n                Query query = createQuery(session, filterSQL(sql), parameterValues);\n\n                if (start > 0) {\n                    query.setFirstResult(start);\n                }\n                if (nb > 0) {\n                    query.setMaxResults(nb);\n                }\n                Iterator<T> it = query.list().iterator();\n                List<T> list = new ArrayList<>();\n                while (it.hasNext()) {\n                    list.add(it.next());\n                }\n\n                return list;\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                    \"Exception while searching documents with SQL [{0}]\", e, new Object[] {sql});\n            }\n        });\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        boolean checkRight, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, customMapping, checkRight, nb, start, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        boolean checkRight, int nb, int start, List<?> parameterValues, XWikiContext inputxcontext)\n        throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        // Search documents\n        List documentDatas = new ArrayList<>();\n        boolean bTransaction = true;\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\n        try {\n            String sql;\n            if (distinctbylanguage) {\n                sql = createSQLQuery(\"select distinct doc.fullName, doc.language\", wheresql);\n            } else {\n                sql = createSQLQuery(\"select distinct doc.fullName\", wheresql);\n            }\n\n            // Start monitoring timer\n            if (monitor != null) {\n                monitor.startTimer(HINT, sql);\n            }\n\n            checkHibernate(context);\n            if (bTransaction) {\n                // Inject everything until we know what's needed\n                SessionFactory sfactory =\n                    customMapping ? injectCustomMappingsInSessionFactory(context) : getSessionFactory();\n                bTransaction = beginTransaction(sfactory, context);\n            }\n            try {\n                Session session = getSession(context);\n\n                Query query = createQuery(session, filterSQL(sql), parameterValues);\n\n                if (start > 0) {\n                    query.setFirstResult(start);\n                }\n                if (nb > 0) {\n                    query.setMaxResults(nb);\n                }\n                documentDatas.addAll(query.list());\n                if (bTransaction) {\n                    endTransaction(context, false);\n                }\n            } finally {\n                if (bTransaction) {\n                    try {\n                        endTransaction(context, false);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH, \"Exception while searching documents with SQL [{0}]\",\n                e, new Object[] {wheresql});\n        } finally {\n            restoreExecutionXContext();\n\n            // End monitoring timer\n            if (monitor != null) {\n                monitor.endTimer(HINT);\n            }\n        }\n\n        // Resolve documents. We use two separated sessions because rights service could need to switch database to\n        // check rights\n        List<XWikiDocument> documents = new ArrayList<>();\n        WikiReference currentWikiReference = new WikiReference(context.getWikiId());\n        for (Object result : documentDatas) {\n            String fullName;\n            String locale = null;\n            if (result instanceof String) {\n                fullName = (String) result;\n            } else {\n                fullName = (String) ((Object[]) result)[0];\n                if (distinctbylanguage) {\n                    locale = (String) ((Object[]) result)[1];\n                }\n            }\n\n            XWikiDocument doc =\n                new XWikiDocument(this.defaultDocumentReferenceResolver.resolve(fullName, currentWikiReference));\n            if (checkRight) {\n                if (!context.getWiki().getRightService().hasAccessLevel(\"view\", context.getUser(), doc.getFullName(),\n                    context)) {\n                    continue;\n                }\n            }\n\n            DocumentReference documentReference = doc.getDocumentReference();\n            if (distinctbylanguage) {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n                if (StringUtils.isEmpty(locale)) {\n                    documents.add(document);\n                } else {\n                    documents.add(document.getTranslatedDocument(locale, context));\n                }\n            } else {\n                documents.add(context.getWiki().getDocument(documentReference, context));\n            }\n        }\n\n        return documents;\n    }\n\n    /**\n     * @param queryPrefix the start of the SQL query (for example \"select distinct doc.space, doc.name\")\n     * @param whereSQL the where clause to append\n     * @return the full formed SQL query, to which the order by columns have been added as returned columns (this is\n     *         required for example for HSQLDB).\n     */\n    protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        StringBuilder sql = new StringBuilder(queryPrefix);\n\n        String normalizedWhereSQL;\n        if (StringUtils.isBlank(whereSQL)) {\n            normalizedWhereSQL = \"\";\n        } else {\n            normalizedWhereSQL = whereSQL.trim();\n        }\n\n        sql.append(getColumnsForSelectStatement(normalizedWhereSQL));\n        sql.append(\" from XWikiDocument as doc\");\n\n        if (!normalizedWhereSQL.equals(\"\")) {\n            if ((!normalizedWhereSQL.startsWith(\"where\")) && (!normalizedWhereSQL.startsWith(\",\"))) {\n                sql.append(\" where \");\n            } else {\n                sql.append(\" \");\n            }\n            sql.append(normalizedWhereSQL);\n        }\n\n        return sql.toString();\n    }\n\n    /**\n     * @param whereSQL the SQL where clause\n     * @return the list of columns to return in the select clause as a string starting with \", \" if there are columns or\n     *         an empty string otherwise. The returned columns are extracted from the where clause. One reason for doing\n     *         so is because HSQLDB only support SELECT DISTINCT SQL statements where the columns operated on are\n     *         returned from the query.\n     */\n    protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        StringBuilder columns = new StringBuilder();\n\n        int orderByPos = whereSQL.toLowerCase().indexOf(\"order by\");\n        if (orderByPos >= 0) {\n            String orderByStatement = whereSQL.substring(orderByPos + \"order by\".length() + 1);\n            StringTokenizer tokenizer = new StringTokenizer(orderByStatement, \",\");\n            while (tokenizer.hasMoreTokens()) {\n                String column = tokenizer.nextToken().trim();\n                // Remove \"desc\" or \"asc\" from the column found\n                column = StringUtils.removeEndIgnoreCase(column, \" desc\");\n                column = StringUtils.removeEndIgnoreCase(column, \" asc\");\n                columns.append(\", \").append(column.trim());\n            }\n        }\n\n        return columns.toString();\n    }\n\n    @Override\n    @Deprecated\n    public boolean isCustomMappingValid(BaseClass bclass, String custommapping1, XWikiContext context)\n    {\n        return isCustomMappingValid(bclass, custommapping1);\n    }\n\n    @Override\n    public boolean isCustomMappingValid(BaseClass bclass, String custommapping1)\n    {\n        try {\n            Metadata metadata = this.store.getMetadata(bclass.getName(), custommapping1, null);\n\n            return isValidCustomMapping(bclass, metadata);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private SessionFactory injectCustomMappingsInSessionFactory(XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        // If we haven't turned of dynamic custom mappings we should not inject them\n        if (!context.getWiki().hasDynamicCustomMappings()) {\n            return getSessionFactory();\n        }\n\n        boolean result = injectCustomMappings(doc, context);\n        if (!result) {\n            return getSessionFactory();\n        }\n\n        return getConfiguration().buildSessionFactory();\n    }\n\n    @Override\n    public void injectCustomMappings(XWikiContext context) throws XWikiException\n    {\n        injectCustomMappingsInSessionFactory(context);\n    }\n\n    @Override\n    public void injectUpdatedCustomMappings(XWikiContext context) throws XWikiException\n    {\n        Configuration config = getConfiguration();\n        injectInSessionFactory(config);\n    }\n\n    public SessionFactory injectCustomMappingsInSessionFactory(BaseClass bclass, XWikiContext context)\n        throws XWikiException\n    {\n        boolean result = injectCustomMapping(bclass, context);\n        if (result == false) {\n            return getSessionFactory();\n        }\n\n        Configuration config = getConfiguration();\n        return injectInSessionFactory(config);\n    }\n\n    private SessionFactory injectInSessionFactory(Configuration config) throws XWikiException\n    {\n        return config.buildSessionFactory();\n    }\n\n    public SessionFactory injectCustomMappingsInSessionFactory(XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            // If we haven't turned of dynamic custom mappings we should not inject them\n            if (context.getWiki().hasDynamicCustomMappings() == false) {\n                return getSessionFactory();\n            }\n\n            List<XWikiDocument> list;\n            list = searchDocuments(\" where (doc.xWikiClassXML is not null and doc.xWikiClassXML like '<%')\", true,\n                false, false, 0, 0, context);\n            boolean result = false;\n\n            for (XWikiDocument doc : list) {\n                if (!doc.getXClass().getFieldList().isEmpty()) {\n                    result |= injectCustomMapping(doc.getXClass(), context);\n                }\n            }\n\n            if (!result) {\n                return getSessionFactory();\n            }\n\n            Configuration config = getConfiguration();\n            return injectInSessionFactory(config);\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    @Override\n    public boolean injectCustomMappings(XWikiDocument doc, XWikiContext inputxcontext) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            // If we haven't turned of dynamic custom mappings we should not inject them\n            if (context.getWiki().hasDynamicCustomMappings() == false) {\n                return false;\n            }\n\n            boolean result = false;\n            for (List<BaseObject> objectsOfType : doc.getXObjects().values()) {\n                for (BaseObject object : objectsOfType) {\n                    if (object != null) {\n                        result |= injectCustomMapping(object.getXClass(context), context);\n                        // Each class must be mapped only once\n                        break;\n                    }\n                }\n            }\n            return result;\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    /**\n     * @param className the name of the class to map\n     * @param customMapping the custom mapping to inject for this class\n     * @param inputxcontext the current XWikiContext\n     * @return a boolean indicating if the mapping has been added to the current hibernate configuration, and a reload\n     *         of the factory is required.\n     * @throws XWikiException if an error occurs\n     * @since 4.0M1\n     */\n    public boolean injectCustomMapping(String className, String customMapping, XWikiContext inputxcontext)\n        throws XWikiException\n    {\n        // If we haven't turned of dynamic custom mappings we should not inject them\n        if (!this.hibernateConfiguration.hasDynamicCustomMappings()) {\n            return false;\n        }\n\n        // Don't add a mapping that's already there\n        if (this.store.getConfigurationMetadata() != null\n            && this.store.getConfigurationMetadata().getEntityBinding(className) != null) {\n            return false;\n        }\n\n        this.store.getConfiguration().addInputStream(\n            new ByteArrayInputStream(makeMapping(className, customMapping).getBytes(StandardCharsets.UTF_8)));\n\n        // Rebuild to take into account the new mapping\n        this.store.build();\n\n        return true;\n    }\n\n    @Override\n    public boolean injectCustomMapping(BaseClass doc1class, XWikiContext inputxcontext) throws XWikiException\n    {\n        return injectCustomMapping(doc1class);\n    }\n\n    @Override\n    public boolean injectCustomMapping(BaseClass doc1class) throws XWikiException\n    {\n        if (!doc1class.hasExternalCustomMapping()) {\n            return false;\n        }\n\n        if (!isCustomMappingValid(doc1class, doc1class.getCustomMapping())) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_INVALID_MAPPING, \"Invalid Custom Mapping\");\n        }\n\n        return injectCustomMapping(doc1class.getName(), doc1class.getCustomMapping(), null);\n    }\n\n    private boolean isValidCustomMapping(BaseClass bclass, Metadata metadata)\n    {\n        PersistentClass mapping = metadata.getEntityBinding(bclass.getName());\n        if (mapping == null) {\n            return true;\n        }\n\n        Iterator<Property> it = mapping.getPropertyIterator();\n        while (it.hasNext()) {\n            Property hibprop = it.next();\n            String propname = hibprop.getName();\n            PropertyClass propclass = (PropertyClass) bclass.getField(propname);\n            if (propclass == null) {\n                this.logger.warn(\"Mapping contains invalid field name [{}]\", propname);\n                return false;\n            }\n\n            boolean result = isValidColumnType(hibprop.getValue().getType().getName(), propclass.getClassName());\n            if (!result) {\n                this.logger.warn(\"Mapping contains invalid type in field [{}]\", propname);\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public List<String> getCustomMappingPropertyList(BaseClass bclass)\n    {\n        List<String> list = new ArrayList<>();\n        Metadata metadata;\n        if (bclass.hasExternalCustomMapping()) {\n            metadata = this.store.getMetadata(bclass.getName(), bclass.getCustomMapping(), null);\n        } else {\n            metadata = this.store.getConfigurationMetadata();\n        }\n        PersistentClass mapping = metadata.getEntityBinding(bclass.getName());\n        if (mapping == null) {\n            return null;\n        }\n\n        Iterator<Property> it = mapping.getPropertyIterator();\n        while (it.hasNext()) {\n            Property hibprop = it.next();\n            String propname = hibprop.getName();\n            list.add(propname);\n        }\n        return list;\n    }\n\n    private boolean isValidColumnType(String name, String className)\n    {\n        String[] validtypes = this.validTypesMap.get(className);\n        if (validtypes == null) {\n            return true;\n        } else {\n            return ArrayUtils.contains(validtypes, name);\n        }\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocuments(wheresql, 0, 0, parameterValues, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, 0, 0, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, customMapping, 0, 0, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, int nb, int start, XWikiContext context)\n        throws XWikiException\n    {\n        return searchDocuments(wheresql, nb, start, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, int nb, int start, List<?> parameterValues,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, true, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, false, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, int nb, int start,\n        XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, nb, start, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, customMapping, nb, start, null, context);\n    }\n\n    @Override\n    public List<XWikiDocument> searchDocuments(String wheresql, boolean distinctbylanguage, boolean customMapping,\n        int nb, int start, List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        return searchDocuments(wheresql, distinctbylanguage, customMapping, true, nb, start, parameterValues, context);\n    }\n\n    @Override\n    public List<String> getTranslationList(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        try {\n            return getTranslationList(doc.getDocumentReference());\n        } catch (QueryException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SEARCH,\n                \"Failed to retrieve the list of translations for [{0}]\", e, new Object[] {doc.getDocumentReference()});\n        }\n    }\n\n    private List<String> getTranslationList(DocumentReference documentReference) throws QueryException\n    {\n        // Note that the query is made to work with Oracle which treats empty strings as null.\n        String hql = \"select doc.language from XWikiDocument as doc where doc.space = :space and doc.name = :name \"\n            + \"and (doc.language <> '' or (doc.language is not null and '' is null))\";\n        org.xwiki.query.Query query = getQueryManager().createQuery(hql, org.xwiki.query.Query.HQL);\n        query.setWiki(documentReference.getWikiReference().getName());\n        query.bindValue(\"space\", this.localEntityReferenceSerializer.serialize(documentReference.getParent()));\n        query.bindValue(\"name\", documentReference.getName());\n        return query.execute();\n    }\n\n    @Override\n    public QueryManager getQueryManager()\n    {\n        return this.queryManager;\n    }\n\n    /**\n     * This is in response to the fact that Hibernate interprets backslashes differently from the database. Our solution\n     * is to simply replace all instances of \\ with \\\\ which makes the first backslash escape the second.\n     *\n     * @param sql the uncleaned sql.\n     * @return same as sql except it is guarenteed not to contain groups of odd numbers of backslashes.\n     * @since 2.4M1\n     */\n    private String filterSQL(String sql)\n    {\n        return StringUtils.replace(sql, \"\\\\\", \"\\\\\\\\\");\n    }\n\n    private String getDefaultAttachmentContentStore(XWikiContext xcontext)\n    {\n        XWikiAttachmentStoreInterface store = xcontext.getWiki().getDefaultAttachmentContentStore();\n\n        if (store != null && store != this.attachmentContentStore) {\n            return store.getHint();\n        }\n\n        return null;\n    }\n\n    private String getDefaultAttachmentArchiveStore(XWikiContext xcontext)\n    {\n        AttachmentVersioningStore store = xcontext.getWiki().getDefaultAttachmentArchiveStore();\n\n        if (store != null && store != this.attachmentArchiveStore) {\n            return store.getHint();\n        }\n\n        return null;\n    }\n\n    private XWikiAttachmentStoreInterface getXWikiAttachmentStoreInterface(XWikiAttachment attachment)\n        throws ComponentLookupException\n    {\n        String storeHint = attachment.getContentStore();\n\n        if (storeHint != null && !storeHint.equals(HINT)) {\n            return this.componentManager.getInstance(XWikiAttachmentStoreInterface.class, storeHint);\n        }\n\n        return this.attachmentContentStore;\n    }\n\n    private AttachmentVersioningStore getAttachmentVersioningStore(XWikiAttachment attachment)\n        throws ComponentLookupException\n    {\n        String storeHint = attachment.getArchiveStore();\n\n        if (storeHint != null && !storeHint.equals(HINT)) {\n            return this.componentManager.getInstance(AttachmentVersioningStore.class, storeHint);\n        }\n\n        return this.attachmentArchiveStore;\n    }\n\n    @Override\n    public int getLimitSize(XWikiContext context, Class<?> entityType, String propertyName)\n    {\n        return this.store.getLimitSize(entityType, propertyName);\n    }\n\n    private long countLinks(long docId, XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(inputxcontext, session -> {\n            try {\n                Query<Long> query =\n                    session.createQuery(\"select count(*) from XWikiLink as link where link.id.docId = :docId\")\n                        .setParameter(\"docId\", docId);\n                return query.getSingleResult();\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_BACKLINKS, \"Exception while count backlinks\", e);\n            }\n        });\n    }\n}\n", "# ---------------------------------------------------------------------------\n# See the NOTICE file distributed with this work for additional\n# information regarding copyright ownership.\n#\n# This is free software; you can redistribute it and/or modify it\n# under the terms of the GNU Lesser General Public License as\n# published by the Free Software Foundation; either version 2.1 of\n# the License, or (at your option) any later version.\n#\n# This software is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this software; if not, write to the Free\n# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n# ---------------------------------------------------------------------------\n\n###############################################################################\n# XWiki Core localization\n#\n# This contains the translations of the module in the default language\n# (generally English).\n# \n# See https://dev.xwiki.org/xwiki/bin/view/Community/L10N/Conventions/ for more details about about\n# translation key naming.\n#\n# Comments: it's possible to add some detail about a key to make easier to\n#   translate it by adding a comment before it. To make sure a comment is not\n#   assigned to the following key use at least three sharps (###) for the comment\n#   or after it.\n# \n# Deprecated keys:\n#   * when deleting a key it should be moved to deprecated section at the end\n#     of the file (between #@deprecatedstart and #@deprecatedend) and associated to the\n#     first version in which it started to be deprecated\n#   * when renaming a key, it should be moved to the same deprecated section\n#     and a comment should be added with the following syntax:\n#     #@deprecated new.key.name\n#     old.key.name=Some translation\n###############################################################################\n\n### Languages\nlanguage=Language\nlanguages=Languages\nchinese=Chinese\nenglish=English\nfrench=French\ngerman=German\nitalian=Italian\npolish=Polish\nrussian=Russian\nspanish=Spanish\n\n### User Page\nfirstname=First Name\nlastname=Last Name\ncountry=Country\n\n### View/Editing\nwikiweb=Space\nwikiname=Page\nparent=Parent\nwikicontent=Content\ndefaultlanguage=Default Language\ndefaulttemplate=Default Template\ncreator=Creator\nview=View\nraw=Code\nxml=XML\ndiff=History\nedit=Edit\neditcontent=Edit Content\nedithtmlcontent=Edit WYSIWYG\neditinline=Form\neditrights=Page Access Rights\neditobject=Objects\neditclass=Class\nwebrights=Space Access Rights\nxwikirights=Global Access Rights\nwebprefs=Space Preferences\nxwikiprefs=Global Preferences\nattach=Attach\nattachments=Attachments\nwebdaveditattachment=Edit\nsave=Save\ndelete=Delete\npreview=Preview\ncopy=Copy\nlogin=Log-in\nlogout=Log-out\nhomepage=User Profile\nstyles=Styles\ndefaultstyle=Default Style\naltstyle1=Alternate Style 1\naltstyle2=Alternate Style 2\naltstyle3=Alternate Style 3\npagemenu=Page Menu\nwebmenu=Space Menu\nxwikimenu=Space Menu\nusermenu=User Menu\nwebusermenu=Space Menu\nspace=Space Home\nclasseditor=Class Editor\nobjecteditor=Object Editor\ncancel=Cancel\nreleaselock=Release Lock\nversions=Versions\nversion=Version\nsize=Size\nauthor=Author\nlastauthor=Last Author\nfilename=Filename\nrights=Rights\nactions=Actions\ndefault=default\nconfirmobjectremove=Are you sure you want to remove this object?\nconfirmdelete=This action is irreversible. Are you sure you want to delete this page?\nconfirmdelete2=Are you sure you want to delete this attachment?\nbacklinkswarningdelete=There are pages that link here!\nconfirmdelattachment=Are you sure you want to delete this attachment?\ndeleted=The page has been deleted.\neditincludepagemsg=This page contains (an) included page(s). To edit this page, click on the following links:\nyouareediting=You are editing the following translation\nselectclass=Select a Class\nchangeclass=Change Class\nclassname=Class Name\npropname=Name\nselectproptype=Select a type\naddproperty=Add Property\nsaveclass=Save Class\nwelcometoclasseditor=Welcome to the class editor. Choose a field to edit or add a field to the class.\neditfield=Edit Field\naddobject=Add Object\naddobjectfromclass=Add Object from this Class\nwelcometoobjecteditor=Welcome to the objects editor. Choose an object to edit or add an object to the page.\nsaveobjects=Save Objects\nyoucan=You can\nremovethisobject=remove this object\nrightseditor=Access Rights Editor\naddrightentry=Add Access Right Entry\nwelcometorightseditor=Welcome to the Access Rights editor. Choose a right entry to edit or add a new right entry:\nremovethisrightentry=remove this right entry\nsaverights=Save Access Rights\naccountdisabled=Your account has been disabled. Please contact the administrator if you think this is a mistake.\naccountnotactive=Your account is not yet active, because your email has not yet been confirmed.\naccountnotactive_email=You should have received an email with a link to confirm your email address. You can also copy-paste the activation code in the same email in the following field.\nconfirmaccount=Confirm Account\nproblemoccured=A problem occurred while trying to process your request. Please contact the webmaster if this happens again.\ndetailedinformation=Detailed information\nnotallowed=You are not allowed to view this page or perform this action.\ndoyouwanttoreplace=Do you want to replace the filename with\nchoosetargetfilename=Choose the target file name\nchoosefiletoupload=Choose file to upload\nattachthisfile=Attach this file\nusername=Username\npassword=Password\nxwikidoc=Documentation\ndocumentation=Documentation\nxwikisyntax=XWiki Syntax\nhelpmenu=Help\nhelponsyntax=Help on the\ncomments=Comments\nnocomments=No comments for this page\naddcomment=Add Comment\nnewcomment=New Comment\nhighlight=Highlighted Text\nnocommentswithoutright=You need to have the 'comment' right to post a comment\nstatsmenu=Statistics Menu\npageviews=Page Views\nwebpageviews=Space Page Views\nxwikipageviews=XWiki Page Views\nxwikivisits=XWiki Visits\npagetopreferers=Top Referers\n#newinterface\npdf=PDF\nrtf=RTF\neditpage=Edit this Page\naddattachment=Add an attachment\nhistory=History\nmore=More Actions\nhello=Hello\nyesno_0=No\nyesno_1=Yes\ntruefalse_0=False\ntruefalse_1=True\nactive_0=Inactive\nactive_1=Active\nallow_0=Deny\nallow_1=Allow\nfrom=From\nto=To\neditedby=edited by\non=on\ncompare=Compare selected Versions\nallchanges=View all Changes\ndocumenthistory=Page History\ncannotreaddocumentversion=Cannot read page version\nparams=Parameters\nskin=Skin\npresentation=Presentation\nregistration=Registration\nmultilingual=Multilingual\ndefault_language=Default Language\ndateformat=Date format\nauthenticate_view=Prevent unregistered users from viewing pages, regardless of the page rights\nauthenticate_viewedit_savecomment=Change rights for unregistered users.\nauthenticate_edit=Prevent unregistered users from editing pages, regardless of the page rights\nbaseskin=Base Skin\nstylesheet=Default Stylesheet\nstylesheets=Other Stylesheets\ntitle=Browser Title Bar Text\ntitlefield=Title\nwebcopyright=Copyright notice\nmenu=Top Menu\nmeta=HTTP Meta Information\neditor=Default Editor to use\neditbox_width=Editor Box Width (characters)\neditbox_height=Editor Box Height (lines)\nuse_email_verification=Use email verification\nadmin_email=Admin email\nsmtp_server=Server\nsmtp_port=Port\nsmtp_server_username=SMTP Server Username (optional)\nsmtp_server_password=SMTP Server Password (optional)\njavamail_extra_props=Additional JavaMail properties\nvalidation_email_content=Validation e-Mail Content\nconfirmation_email_content=Confirmation e-Mail Content\npreferences=Preferences\nsaveprefs=Save Preferences\nsections=Sections\ncurrentobjects=Current Objects\ncurrentrights=Current Access Rights\ncurrentproperties=Current Properties\neditanotherclass=Edit another Class\nadmin=Administration\nhelp=Help\nsearch=Search\nrecentmenu=Recently Viewed\nwelcome=Welcome\ndate=Date\ndoclockedby=This page is currently locked by\nforcelock=Force editing\ninitialversion=Initial Version\nrollback=Rollback\nreadytorollback=Do you want to rollback to version\nreadonly=This server is currently in read-only mode\nrevisiondoesnotexist=This page does not exist in this version.\nnocommentwithnewdoc=You cannot comment on a page or article that does not exist.\nactiondoesnotexist=This action does not exist!\nthiswikidoesnotexist=This Wiki does not exist on this server.\nthispagedoesnotexist=The requested page could not be found.\nnosuchobject=The specified object does not exist\nthispagealreadyexists=This page already exists.\nattachmentdoesnotexist=The attachment does not exist.\nwikicontentcannotbeempty=The content of a wiki page is not allowed to be completely empty.\nfileuploadislarge=XWiki has a default limit of around 10Mb for attached files. This limit can be changed using the upload_maxsize parameter. Check the FAQ for more information.\njavaheapspace=Java Heap Space Out Of Memory Exception!\nnotsupportcharacters=File name does not support characters '\\\\' '/' ';'\nthistemplatedoesnotexist=This template does not exist\nmacros_languages=Macro Languages\nmacros_velocity=Velocity Macro Pages\nmacros_groovy=Groovy Macro Pages\nmacros_mapping=Macro Mapping\nnotification_pages=Notification Pages\ndocumentBundles=Internationalization Document Bundles\nadvanced=Advanced\nerrornotdefine=Error not defined in XWikiException!\naction.addClassProperty.error.invalidName=Property names must follow these naming rules: <br/>Names can contain letters, numbers, and the following characters: \"., -, _, :\" <br/>Names must not start with a number or punctuation character. <br/>Names must not start with the letters xml (or XML, or Xml, etc). <br/>Names cannot contain spaces.\naction.addClassProperty.error.alreadyExists=Property {0} already exists\n\nbacktoedit=Back To Edit\nbrowsernoncompatible=Browser is not compatible!\nwysiwygeditor=WYSIWYG Editor\nwikieditor=WIKI Editor\nmacro=Macro\nchoosemacro=Choose a macro:\n\nresetversions=Reset Versions\nconfirmresetversions=This action is irreversible. Are you sure you want to reset versions for this page?\nconfirmresetversions2=Please confirm if you want to reset versions for this page?\nresetversionsdone=The versions have been reset for this page.\nyes=Yes\nno=No\n\ndisabled=Disabled\nenabled=Enabled\n\ncreatedon=on\nlastmodifiedby=last modified by\nlastmodifiedon=on\nat=at\neditwiki=Wiki\neditvisual=WYSIWYG\neditform=Form\nchooseeditor=Choose editor:\nshow=Show\nshowcode=Wiki code\nshowxml=XML\nwatch=Watch\nnoattachments=No attachments for this page\ndownloadthisattachment=Download this attachment\nviewattachmenthistory=View attachment history\nregister=Register\ndoc=Documentation\nattributes=Attributes\nshowattributes=Show page attributes\nrememberme=This is a private computer, please remember me\ndontrememberme=This is a public/shared computer, do not remember me\nyouareeditingtranslation=You are editing the following translation\nyouareeditingoriginal=You are editing the original page\noriginallanguage=The original language of the page is\ntranslatedocin=Translate this page in\nothertranslations=Other translations\nexistingtranslations=Existing translations\nproptype=Type\nremovethiscomment=delete\nconfirmcommentremove=Are you sure you want to remove this comment?\nusefullinks=Useful links\n\nbold=Bold\nboldtext=Text in Bold\nitalics=Italics\nitalicstext=Text in Italics\nunderline=Underline\nunderlinetext=Text in Underline\nsecondleveltitle=Second Level Title\ntitletext=Title Text\nilink=Internal Link\nilinktext=Link Example\nelink=External Link (do not forget http://)\nelinktext=name of link>http://www.example.com\nhr=Horizontal ruler\nimg=Attached Image\nimgtext=example.jpg\nsign=Signature\n\n###\n### Model\n###\n\nTextArea_editor=Editor\nTextArea_editor_hint=Indicates which editor should be used to manipulate the content of the property. This setting overwrites the preferred editor configured in the user profile.\nTextArea_editor_PureText=Plain Text\nTextArea_editor_Text=Wiki\nTextArea_editor_Wysiwyg=WYSIWYG\n\nTextArea_contenttype=Content Type\nTextArea_contenttype_hint=Indicates what kind of content this field contains (wiki, plain text, etc.).\nTextArea_contenttype_PureText=Plain Text\nTextArea_contenttype_FullyRenderedText=Wiki Syntax\nTextArea_contenttype_VelocityCode=Velocity Code\n\nTextArea_restricted=Restricted\nTextArea_restricted_hint=Indicates if the content of the property should be executed in a restricted context.\n\nString_size_hint=The size of the corresponding form element in edit mode.\n\nStaticList_values_hint=Separated by '|'; Example: value1=Text displayed for value 1|value2=Text displayed for value 2|value3|value4\n\n###\n\ncore.edit.wikiToolbar.bold=Bold\ncore.edit.wikiToolbar.boldtext=Text in Bold\ncore.edit.wikiToolbar.italics=Italics\ncore.edit.wikiToolbar.italicstext=Text in Italics\ncore.edit.wikiToolbar.underline=Underline\ncore.edit.wikiToolbar.underlinetext=Text in Underline\ncore.edit.wikiToolbar.strikethrough=Strikethrough\ncore.edit.wikiToolbar.strikethroughtext=Strikethrough\ncore.edit.wikiToolbar.subscript=Subscript\ncore.edit.wikiToolbar.subscripttext=Text in subscript\ncore.edit.wikiToolbar.superscript=Superscript\ncore.edit.wikiToolbar.superscripttext=Text in superscript\ncore.edit.wikiToolbar.secondleveltitle=Second Level Title\ncore.edit.wikiToolbar.titletext=Title Text\ncore.edit.wikiToolbar.ilink=Internal Link\ncore.edit.wikiToolbar.ilinktext=Link Example\ncore.edit.wikiToolbar.elink=External Link (do not forget http://)\ncore.edit.wikiToolbar.elinktext=name of link>http://www.example.com\ncore.edit.wikiToolbar.elink20=External Link (do not forget http://)\ncore.edit.wikiToolbar.elink20text=name of link>>http://www.example.com\ncore.edit.wikiToolbar.hr=Horizontal ruler\ncore.edit.wikiToolbar.img=Attached Image\ncore.edit.wikiToolbar.imgtext=example.jpg\ncore.edit.wikiToolbar.sign=Signature\ncore.edit.wikiToolbar.h1=Heading 1\ncore.edit.wikiToolbar.h1text=Heading 1\ncore.edit.wikiToolbar.h2=Heading 2\ncore.edit.wikiToolbar.h2text=Heading 2\ncore.edit.wikiToolbar.h3=Heading 3\ncore.edit.wikiToolbar.h3text=Heading 3\ncore.edit.wikiToolbar.h4=Heading 4\ncore.edit.wikiToolbar.h4text=Heading 4\ncore.edit.wikiToolbar.ulist=Bulleted list\ncore.edit.wikiToolbar.ulisttext=List item\ncore.edit.wikiToolbar.olist=Numbered list\ncore.edit.wikiToolbar.olisttext=List item\ncore.edit.wikiToolbar.html=HTML code\ncore.edit.wikiToolbar.htmltext=<!-- Your HTML code here -->\ncore.edit.wikiToolbar.velocity=Velocity code\ncore.edit.wikiToolbar.velocitytext=#* Your velocity code here *#\ncore.edit.autosave=Autosave\ncore.edit.autosave.every=every\n\nnotice=Notice\nchangephoto=Changing photo for {0}\navatar=User photo\nError=Error\nerror=Error\nwarning=Warning\nWarning=Warning\nuploadavatarfile=Upload new user photo\nsetthisavatar=Set this photo\nnotauser=This is not a user!\nviewcode=Code\nviewxml=XML\nviewcomments=Comments\nviewattachments=Attachments\nviewhistory=History\nviewinformation=Information\nreveditor=Editor\nadminprefs=Preferences\nadminglobalrights=Global Rights\nadminspacerights=Space Rights\nadmingroups=Groups\nadminusers=Users\nadminusersandgroups=Users & Groups\nadminskin=Skin\ntype=Type:\ntoget=To get:\ndocdata=Page data\nnoskin=No skin is configured\nshowlinenumbers=Show Line Numbers\nhidelinenumbers=Hide Line numbers\nprint=Print\nwiki=Wiki\nWYSIWYG=WYSIWYG\ninvitation_email_content=Invitation email Content\nparentfield=Parent\n\neditingClass=Editing class\nproperties=Properties\nclassEditorIntro=Welcome to the Class Editor\nremembermeonthiscomp=Remember me\nsaveandcontinue=Save &amp; Continue\nsaveandview=Save &amp; View\n\nediting=Editing\neditWiki=Wiki\neditVisual=WYSIWYG\neditAttachments=Attachments\neditObject=Objects\neditClass=Class\neditRights=Access Rights\neditHistory=History\neditFullScreen=Full Screen\n\n###login\nnousername=No user name given\nnopassword=No password given\ninvalidcredentials=Invalid credentials\nloginfailed=Internal error\n\nswitchto=Switch to\nsectionEdit=Sectional Editing\n\nantispam=Antispam\nregistration_anonymous=Anonymous\nregistration_registered=Registered\nedit_anonymous=Anonymous\nedit_registered=Registered\ncomment_anonymous=Anonymous\ncomment_registered=Registered\ncomment=Comment\nconfirmcommentnotcorrect=Confirm to avoid spam robots. Please try again!\nvalidationerror=Field {0} is incorrect.\n\nmyaccount=My account\nnew=New\n\nattachedby=attached by\nlistofallexistspages=List of all existing pages\nlistofallattachments=List of all attachments\nlistofrecentlyviewedpages=List of recently viewed pages\nlistofrecentlymodifiedpages=List of recently modified pages\nwarningstartspluginisnotactivated=The stats plugin isn't activated. You have to activate stats plugin as default (xwiki.stats=1 in xwiki.cfg) to activate this function.\nlistofresultspages=List of result\nchoosespace=Choose space\ninspace=in\nnoattachmentsonthispage=There are no attachments on this page.\nnopagesatthemoment=There are no pages at the moment.\nEditing=Editing\nchooseassociatedtags=choose associated tags\n\nchangespace=Change Space\nadminspaceprefs=Space Prefs\neditprefsforspace=Editing preferences for space\neditrightsforspace=Editing access rights for space\n\ntarget=Target Window (_blank for a new window)\n\ncheckadvancedcontent=Your content contains HTML or special code that might be lost in the WYSIWYG Editor. Are you sure you want to switch editors?\nneedadminrights=Admin Rights are needed for this function\n\nexport=Export\nadminexport=Export\nexport_packagename=File name\nexport_description=Description\nexport_licence=Licence\nexport_author=Author\nexport_version=Version\nexport_addhistory=With history\nexport_backuppack=Backup package\n\nimport=Import\nadminimport=Import\nshowavailablefilestoimport=Show available files to import\nselectfiletoimport=Select the file you wish to import\navailablefilestoimport=Available files to import\navailabledocumentstoimport=Available pages to import\nuploadnewarchivetoimport=Upload a new archive to import\nselectdocumentstoimport=Click on the archive file you wish to import to get the list of available pages\nnodocstoimport=No pages found in the selected archive\nimporting=Importing\nimport_install_-1=Error while preparing importing\nimport_install_4=Error while importing\nimport_install_2=Import successful\nimport_install_1=Import could not overwrite\nimport_documentinstalled=Page(s) installed\nimport_documentskipped=Page(s) skipped\nimport_documenterrors=Page(s) with error\nimport_listofinstalledfiles=List of installed pages\nimport_listofskippedfiles=List of skipped pages\nimport_listoferrorfiles=List of erroneous pages\n\ncore.exporter.headings.officeFormats=Office Formats\ncore.exporter.headings.otherFormats=Other Formats\ncore.exporter.selectPages=Select the pages to export:\ncore.exporter.selectAll=select all\ncore.exporter.selectNone=none\ncore.exporter.selectChildren=Select all children\ncore.exporter.unselectChildren=Unselect all children\ncore.exporter.filter=Select from:\ncore.exporter.filter.installedExtensionDocument=Created pages\ncore.exporter.filter.installedExtensionDocument.hint=The pages created by the user or by XWiki extensions on behalf of the user.\ncore.exporter.filter.pristineInstalledExtensionDocument=Created and modified pages\ncore.exporter.filter.pristineInstalledExtensionDocument.hint=Includes modified extension pages (usually configuration pages).\ncore.exporter.filter.none=All pages\ncore.exporter.filter.none.hint=Includes unmodified extension pages.\ncore.exporter.legend=Legend:\ncore.exporter.legend.contentPage=Created Page\ncore.exporter.legend.contentPage.hint=Any page created by the user or by an XWiki extension on behalf of the user.\ncore.exporter.legend.customizedExtensionPage=Modified Extension Page\ncore.exporter.legend.customizedExtensionPage.hint=Any page that belongs to an installed extension and that has been modified.\ncore.exporter.legend.cleanExtensionPage=Clean Extension Page\ncore.exporter.legend.cleanExtensionPage.hint=Any page that belongs to an installed extension and that has not been modified.\n\ncore.exporter.formats.hint=Choose the export format from the list below:\ncore.exporter.formats.pdfFOP.hint=Export as Portable Document Format (PDF) using Apache Formatting Objects Processor (FOP)\ncore.exporter.formats.odt.hint=Export as Open Document Text (ODT) format using the Office Server\ncore.exporter.formats.rtf.hint=Export as Rich Text Format (RTF) using the Office Server\ncore.exporter.formats.html.hint=Export as HyperText Markup Language (HTML)\ncore.exporter.formats.xar.hint=Export as XWiki Archive (XAR)\ncore.exporter.exportAs=Export as {0}\n\ncore.importer.uploadPackage=Upload a new package\ncore.importer.availableDocuments=Package Content\ncore.importer.selectThisPackage=select this package\ncore.importer.availablePackages=Available packages\ncore.importer.noPackageAvailable=No package is available for import\ncore.importer.packageInformationExtract=Added by {0} on {1}\ncore.importer.import=Import\ncore.importer.selectionEmptyWarning=Please select at least one page to import\ncore.importer.importHistory=Import the history\ncore.importer.package=Package\ncore.importer.package.description=Description\ncore.importer.package.version=Version\ncore.importer.package.licence=Licence\ncore.importer.package.author=Author\ncore.importer.package.backup=Backup package\ncore.importer.documentSelected=page(s) selected\ncore.importer.whenDocumentAlreadyExists=When a page already exists in the wiki\ncore.importer.replaceDocumentHistory=Replace the page history with the history from the package\ncore.importer.addNewVersion=Add a new version to the existing page (if different)\ncore.importer.resetHistory=Reset history to version 1.1\ncore.importer.select=select\ncore.importer.selectAll=all\ncore.importer.selectNone=none\ncore.importer.saveDocumentComment=Imported from XAR\ncore.importer.securitySettingsChanged=Security settings have changed during the import. You will need <a href=\"{0}\">to authenticate</a> in order to continue to administrate the wiki.\ncore.importer.importAsBackup=Import as backup package\n\ncore.model.xclass.deleteClassProperty.versionSummary=Removed class property \"{0}\"\ncore.model.xclass.disableClassProperty.versionSummary=Disabled class property \"{0}\"\ncore.model.xclass.enableClassProperty.versionSummary=Enabled class property \"{0}\"\ncore.model.xclass.classProperty.error.missingProperty=Cannot change property: the specified property name does not exist in this class.\ncore.model.xclass.mandatoryUpdateProperty.versionSummary=Synced mandatory class property definitions to default values\ncore.model.xobject.synchronizeObjects.versionSummary=Synchronized object properties with their current classes\ncore.model.xobject.synchronizeObjects.error.missingObject=Cannot synchronize object: the specified object does not exist.\n\nregisterwelcome=Sign up here so you can edit pages and participate in the wiki.\nemail=e-Mail address\npasswordrepeat=Password (repeat)\nloginid=Login ID\niregister=Register\npasswordmismatch=Passwords are different or password is empty\nuseralreadyexists=User already exists\ninvalidusername=Invalid username provided. Please use only letters from the latin alphabet, numbers, and the underscore character.\nregisterfailed=Registration has failed\nregisterfailedcode=code\nregistersuccessful=Registration successful\n\nleftPanels=Left Panels\nrightPanels=Right Panels\nshowLeftPanels=Show Left Panels\nshowRightPanels=Show Right Panels\npageWidth=Page Width\ntags=Tags\n\nremovethisuserfromgroup=Remove this user from the group\nuserdeletioncannotbecanceled=Deletions cannot be cancelled.\naddusertogroup=Add a user to this group\n\npanelsavesuccess=The layout has been saved properly.\npanelsaveerror=An error occurred while trying to save the panel layout.\nspaceandname=Space and Page Name\ncreate=Create\ncreatepage=Page\ncreatespace=Space\ncreateevent=Event\ncreatepanel=Panel\n\n### Event calendar\neventCalendarTitle=Event Calendar\neventList=Event List\neventNew=New Event\neventTitle=Title\neventStartdate=Start date inclusive (dd/MM/yyyy)\neventEnddate=End date inclusive (dd/MM/yyyy)\neventLocation=Location\neventCategory=Category\neventURL=URL\neventDescription=Description\neventAdd=Add\n\ndtFrom=From\ndtTo=to\nmoreinfo=More information\n\n### Password change form\nchangepassword=Changing password for {0}\nnewpassword=New password\nreenterpassword=Reenter password\nsetthispassword=Save\ncancelpwd=Cancel\npasswordmissmatch=The two passwords do not match!\n\nplatform.core.profile.passwd.title=Changing password for {0}\nplatform.core.profile.passwd.instructionsPasswordLength=Your new password must be at least {0} characters long.\nplatform.core.profile.passwd.originalPassword=Current password\nplatform.core.profile.passwd.newPassword=New password\nplatform.core.profile.passwd.reenterPassword=Reenter password\nplatform.core.profile.passwd.submit=Save\nplatform.core.profile.passwd.cancel=Cancel and return to profile\nplatform.core.profile.passwd.passwordMissmatch=The two passwords do not match.\nplatform.core.profile.passwd.invalidOriginalPassword=Current password is invalid.\nplatform.core.profile.passwd.passwordTooShort=Your new password should be at least 6 characters long.\nplatform.core.profile.passwd.passwordCannotBeEmpty=The password cannot be empty.\nplatform.core.profile.passwd.notAllowed=You are not allowed to perform this action.\nplatform.core.profile.passwd.notaUser=This is not a user profile.\nplatform.core.profile.passwd.success=Your password has been successfully changed.\nplatform.core.profile.passwd.return=Click here to return to your profile.\nplatform.core.profile.passwd.passwordChanged=Changing user password.\nplatform.core.profile.passwd.passwordMustContainLowercase=The password must contain at least one lowercase character.\nplatform.core.profile.passwd.passwordMustContainUppercase=The password must contain at least one uppercase character.\nplatform.core.profile.passwd.passwordMustContainNumber=The password must contain at least one number.\nplatform.core.profile.passwd.passwordMustContainSymbol=The password must contain at least one symbol character.\n\n### User profile page\nplatform.core.profile.title=Profile of {0}\nplatform.core.profile.changePassword=Change password\nplatform.core.profile.changePhoto=Change photo\nplatform.core.profile.changePhoto.cancel=Cancel and return to profile\nplatform.core.profile.firstname=First name\nplatform.core.profile.lastname=Last name\nplatform.core.profile.blog=Blog\nplatform.core.profile.blogFeed=Blog Feed\nplatform.core.profile.email=Email\nplatform.core.profile.company=Company\nplatform.core.profile.city=City\nplatform.core.profile.country=Country\nplatform.core.profile.about=About\nplatform.core.profile.phone=Phone\nplatform.core.profile.address=Address\nplatform.core.profile.editor=Default editor to use\nplatform.core.profile.userType=User Type\nplatform.core.profile.enableAccessibility=Enable extra accessibility features\nplatform.core.profile.displayHiddenDocuments=Display hidden pages\nplatform.core.profile.timezone=Timezone\nplatform.core.profile.extensionConflictSetup=Enable extension conflict setup\n\nplatform.core.profile.category.settings=Settings\nplatform.core.profile.category.profile=Profile\nplatform.core.profile.category.profile.edit=Edit profile\nplatform.core.profile.category.preferences=Preferences\nplatform.core.profile.category.preferences.edit=Edit preferences\nplatform.core.profile.category.watchlist=Watchlist\nplatform.core.profile.category.watchlist.edit=Edit watchlist preferences\nplatform.core.profile.category.network=Network\nplatform.core.profile.category.dashboard=My dashboard\nplatform.core.profile.category.profile.disabled=This account is currently disabled.\nplatform.core.profile.category.profile.disableAccount=Disable this account\nplatform.core.profile.category.profile.enableAccount=Enable this account\n\nplatform.core.profile.section.security=Security\nplatform.core.profile.section.personal=Personal Information\nplatform.core.profile.section.contact=Contact Information\nplatform.core.profile.section.links=External Links\nplatform.core.profile.section.sendMessage=Send Message\nplatform.core.profile.section.activity=My Activity Stream\nplatform.core.profile.section.activityof=Activity stream of {0}\nplatform.core.profile.section.displayPreferences=Display Preferences\nplatform.core.profile.section.localizationPreferences=Localization Preferences\nplatform.core.profile.section.editorPreferences=Editor Preferences\nplatform.core.profile.section.extensionPreferences=Extensions Preferences\nplatform.core.profile.section.datePreferences=Date Preferences\nplatform.core.profile.section.passwordManagement=Password Management\nplatform.core.profile.section.watchlistManagement=Watchlist Preferences\nplatform.core.profile.section.watchlistElements=Watched elements\nplatform.core.profile.section.following=Followed users\nplatform.core.profile.section.following.none=You are not following the activity of any user.\nplatform.core.profile.section.networkActivity=Network activity\nplatform.core.profile.watchlist.notifier=Notifier\nplatform.core.profile.watchlist.unwatch=Remove from my watch list\n\ncore.footer.creation=Created by {0} on {1}\ncore.footer.translationCreation=Translated into {0} by {1} on {2}\ncore.footer.modification=Last modified by {0} on {1}\ncore.document.modificationWithVersion=Version {0} by {1} on {2}\ncore.document.restrictedInfo=For security reasons, the document is displayed in restricted mode as it is not the \\\n  current version. There may be differences and errors due to this.\n\ncore.document.error.failedParse=Failed to parse document content\n\ncore.footnotes.gotofootnote=Go to footnote {0}\ncore.footnotes.backtoref=Back to footnote reference\n\n### Keyboard shortcuts\ncore.shortcuts.view.edit=e\ncore.shortcuts.view.wiki=k\ncore.shortcuts.view.wysiwyg=g\ncore.shortcuts.view.inline=f\ncore.shortcuts.view.rights=r\ncore.shortcuts.view.objects=o\ncore.shortcuts.view.class=s\ncore.shortcuts.view.comments=c\ncore.shortcuts.view.attachments=a\ncore.shortcuts.view.history=h\ncore.shortcuts.view.information=i\ncore.shortcuts.view.code=d\ncore.shortcuts.view.annotations=n\ncore.shortcuts.view.delete=Delete\ncore.shortcuts.view.rename=F2\ncore.shortcuts.edit.cancel=Alt+C\ncore.shortcuts.edit.backtoedit=Alt+B\ncore.shortcuts.edit.preview=Alt+P\ncore.shortcuts.edit.save=Alt+Shift+S\ncore.shortcuts.edit.saveandview=Alt+S\n\n### Developer shortcuts\ncore.shortcuts.developer.user.type=x+x+x+a\ncore.shortcuts.developer.user.type.error=Unable to update the current user type\ncore.shortcuts.developer.user.displayHiddenDocs=x+x+x+h\ncore.shortcuts.developer.user.displayHiddenDocs.error=Unable to toggle the current user hidden documents property\ncore.shortcuts.developer.user.ajax.inprogress=Performing REST request...\ncore.shortcuts.developer.user.ajax.success=REST Request successful!\n\n### Create\ncore.create.pageTitle=Create Page\n\ncore.create.title=Title\ncore.create.title.hint=Title of the new page\ncore.create.locationPreview.label=Location\ncore.create.locationPreview.hint=Location in the page hierarchy where this new page will be created.\ncore.create.spaceReference.label=Parent\ncore.create.spaceReference.hint=Parent of the new page. Leave empty for top level non-terminal page.\ncore.create.spaceReference.placeholder=Path.To.Page\ncore.create.name.label=Name\ncore.create.name.hint=Name of the new page\ncore.create.name.placeholder=NewPage\n\ncore.create.template=Template\ncore.create.page.template.hint=Template to use for the new page\ncore.create.page.template.empty=Empty Wiki Page\ncore.create.template.allowedspaces=Pages created from the template [{0}] must be created in one of the following spaces: {1}\ncore.create.template.allowedspace=Pages created from the template [{0}] must be created in the space: {1}\ncore.create.template.allowedspaces.inline=Allowed spaces for ''{0}'': {1}\ncore.create.template.allowedspace.inline=Allowed space for ''{0}'': {1}\n\ncore.create.terminal.label=Terminal Page\ncore.create.terminal.hint=Advanced: Create a terminal page instead. This type of page will not be able to have children and is generally used in applications, development or in older versions of XWiki.\n\ncore.create.type=Type\ncore.create.type.hint=Select the kind of page that you want to create\ncore.create.type.default=Default\ncore.create.type.templates=Templates\ncore.create.type.blank=Blank page\ncore.create.type.blank.description=Standard empty page\n\ncore.create.popup.loading=Loading...\n\ncore.create.ajax.error=An error occurred, please refresh the page and try again\ncore.create.page.error.docalreadyexists=The page <a href=\"{1}\">{0}</a> already exists. You can fill in a new page name (or <a href=\"{2}\">edit {0}</a>).\ncore.create.space.error.docalreadyexists=The space {0} already exists. Please fill in a new space name.\ncore.create.page.error.docpathtoolong=The full path of the page you want to create is too long: {0} Paths are limited to {1} characters and the current length is {2} characters. Please change the name of your page or move it to another space.\n\n### Rename\ncore.rename.title=Rename <a href=\"{1}\">{0}</a>\ncore.rename.source.label=Source\ncore.rename.source.hint=The page that is going to be renamed\ncore.rename.children.label=Preserve children\ncore.rename.children.hint=Preserve the {0}{1} {1,choice,0#child pages|1#child page|1<child pages}{2} by updating their path and moving them to the new location\ncore.rename.children.hintWithoutParams=Preserve the child pages by updating their path and moving them to the new location\ncore.rename.links.label=Update links\ncore.rename.links.hint=Update the target of {0}{1} {1,choice,0#incoming links|1#incoming link|1<incoming links}{2} to this page and preserve the target of relative outgoing links from this page in the new location\ncore.rename.links.hintWithoutParams=Update the target of incoming links to this page and preserve the target of relative outgoing links from this page in the new location\ncore.rename.autoRedirect.label=Create an automatic redirect\ncore.rename.autoRedirect.hint=Redirect the user to the new page when accessing the old page. Select this option if you don't want to break external links to the old page.\ncore.rename.target.title.label=New Title\ncore.rename.target.title.hint=The new page title\ncore.rename.target.location.label=New Location\ncore.rename.target.location.hint=The location where to move the page\ncore.rename.target.wiki.label=Wiki\ncore.rename.target.wiki.hint=The wiki where to move the page\ncore.rename.target.parent.label=Parent\ncore.rename.target.parent.hint=The new parent. Leave empty if the new page should be a top level non-terminal page.\ncore.rename.target.name.label=Name\ncore.rename.target.name.hint=The new page name\ncore.rename.target.terminal.label=Rename as terminal page\ncore.rename.target.terminal.hint=This type of page cannot have children and is generally used in applications, development or in older versions of XWiki.\ncore.rename.submit=Rename\ncore.rename.emptyName=Please enter a valid page name!\ncore.rename.alreadyExists=A page with the given name (<a href=\"{1}\">{0}</a>) already exists. Please provide a different name.\ncore.rename.nonexistingDocument=This page does not exist.\ncore.rename.targetNotWritable=You don't have the right to create the target page.\ncore.rename.status.label=Rename Status\ncore.rename.status.hint=The following rename operation has been started by {0} on {1}\ncore.rename.status.success=Done.\ncore.rename.status.failure=Rename failed.\ncore.rename.status.notFound=The requested rename status could not be found.\nrename=Rename\ncore.rename.warningRenameUser=You are about to rename a page containing an user or a group but you don't have the programming rights: this could lead to some breakage in your wiki.\n\n### Copy\ncore.copy.title=Copy <a href=\"{1}\">{0}</a>\ncore.copy.source.label=Source\ncore.copy.source.hint=The page that is going to be copied\ncore.copy.target.title.label=Copy Title\ncore.copy.target.title.hint=The copy can have a different title than the source page\ncore.copy.target.location.label=Copy Location\ncore.copy.target.location.hint=The location where to copy the page\ncore.copy.target.wiki.label=Wiki\ncore.copy.target.wiki.hint=The wiki where to copy the page\ncore.copy.target.parent.label=Parent\ncore.copy.target.parent.hint=The parent of the copy. Leave empty if the copy should be a top level page.\ncore.copy.target.name.label=Name\ncore.copy.target.name.hint=The copy can have a different name than the source page\ncore.copy.target.terminal.label=Copy as terminal page\ncore.copy.target.terminal.hint=This type of page cannot have children and is generally used in applications, development or in older versions of XWiki.\ncore.copy.allTranslations=All Translations\ncore.copy.language.hint=Translation of the original page\ncore.copy.children.label=Preserve children\ncore.copy.children.hint=Copy also the {0}{1} {1,choice,0#children|1#child|1<children}{2} of the source page\ncore.copy.children.hintWithoutParams=Copy also the children of the source page\ncore.copy.submit=Copy\ncore.copy.cancel=Cancel\ncore.copy.alreadyExists=The page {0} already exists. Are you sure you want to overwrite it (all its content would be lost)?\ncore.copy.editRightsForbidden=You don''t have the appropriate rights to copy the page at the following target {0}.\ncore.copy.changeTarget=Change the target page\ncore.copy.status.label=Copy Status\ncore.copy.status.hint=The following copy operation has been started by {0} on {1}\ncore.copy.status.notFound=The requested copy status could not be found.\n\n### Document Picker\ncore.documentPicker.title=Select Page\ncore.documentPicker.select=Select\ncore.documentPicker.cancel=Cancel\n\n### Export\ncore.export.pdf.options.title=PDF Export Options\ncore.export.pdf.options.language.hint=Choose the translation you want to export.\ncore.export.pdf.options.currentLanguage=(Current language)\ncore.export.pdf.options.cover=Cover\ncore.export.pdf.options.cover.hint=Print the cover page, containing the page title, author and last modification date.\ncore.export.pdf.options.toc=Table of Contents\ncore.export.pdf.options.toc.hint=List headings at the beginning of the PDF document, usually right after the cover page.\ncore.export.pdf.options.header=Header\ncore.export.pdf.options.header.hint=Header displayed on each page\ncore.export.pdf.options.footer=Footer\ncore.export.pdf.options.footer.hint=Footer displayed on each page\ncore.export.pdf.options.comments=Comments\ncore.export.pdf.options.comments.hint=Include page comments at the end of the PDF document, usually before the image attachments.\ncore.export.pdf.options.images=Image attachments\ncore.export.pdf.options.images.hint=Print image attachments at the very end of the PDF document.\ncore.export.formatUnknown=Office server is not started or that export format is not supported.\n\n### Paging links\nweb.paging.pageNumberOf=Page {0} of {1}\nweb.paging.firstPage=&laquo; First\nweb.paging.previousPage=&lt; Previous\nweb.paging.nextPage=Next &gt;\nweb.paging.lastPage=Last &raquo;\n\ntempdirnotset=Temporary directory not set. Please follow the instructions on <a href=\"http://www.xwiki.org/xwiki/bin/view/FAQ/WhyAmIGettingANullPointerExceptionWhenUploadingFiles\">xwiki.org</a> on how to fix this.\n\n# Comments for history\n# Note: These keys should be moved to their domains.\n# For example the comment messages for the XAR importer are in core.importer.* keys.\n# TODO: Do the same for the other keys\n###\ncore.comment=Version summary\ncore.comment.details=(Enter a brief description of your changes)\ncore.comment.tooltip=Enter a brief description of your changes\ncore.comment.prompt=Enter a brief description of your changes\ncore.comment.addComment=Added comment\ncore.comment.editComment=Edited comment\ncore.comment.addObject=Added object\ncore.comment.updateObject=Updated object\ncore.comment.deleteObject=Deleted object\ncore.comment.addProperty=Added property\ncore.comment.updateProperty=Updated property\ncore.comment.updatePropertyName=Updated property name\ncore.comment.addClassProperty=Added class property\ncore.comment.updateClassProperty=Updated class property\ncore.comment.updateClassPropertyName=Updated class property name\ncore.comment.createdUser=Created user\ncore.comment.addedUserToGroup=Added user to group\ncore.comment.rollback=Rollback to version {0}\ncore.comment.updateContent=Update Content\ncore.comment.uploadAttachmentComment=Uploaded new attachment \"{0}\", version {1}\ncore.comment.uploadImageComment=Upload new image \"{0}\", version {1}\ncore.comment.deleteAttachmentComment=Deleted attachment \"{0}\"\ncore.comment.deleteImageComment=Deleted image \"{0}\"\ncore.comment.renameLink=Renamed links to {0} following the rename of that page\ncore.comment.renameParent=Changed parent to {0} following the rename of that page\ncore.comment.createdTemplate=Created {0} Template\ncore.comment.hint=Add summary...\n\ncore.minoredit=Minor edit\ncore.minoredit.show=Show minor edits\ncore.minoredit.hide=Hide minor edits\n\n### top menu\ncore.menu.main.title=General Actions:\ncore.menu.content.title=Page Actions:\ncore.menu.goto.wiki=Go to Wiki\ncore.menu.goto.space=Go to Space\ncore.menu.goto.page=Go to Page\ncore.menu.create=Create\ncore.menu.create.page=Page\ncore.menu.create.pageFromOffice=Page from Office\ncore.menu.create.space=Space\ncore.menu.create.wiki=Create wiki\ncore.menu.create.comment=Comment to Page\ncore.menu.create.attachment=Attachment to Page\ncore.menu.copy=Copy\ncore.menu.translate=Translate\ncore.menu.translate.hint=Translate this page in {0}\ncore.menu.translate.details=You''re viewing the {0} translation of this page (its original version) because this page has not been translated in {1} (the current locale) yet.\ncore.menu.edit=Edit\ncore.menu.edit.wiki=Wiki\ncore.menu.edit.wysiwyg=WYSIWYG\ncore.menu.edit.inline=Inline form\ncore.menu.edit.object=Objects\ncore.menu.edit.class=Class\ncore.menu.edit.rights=Access Rights\ncore.menu.edit.currentEditor=Edit{0}\ncore.menu.drawer=Drawer\ncore.menu.view.source=Source\ncore.menu.view.comments=Comments\ncore.menu.view.attachments=Attachments\ncore.menu.view.history=History\ncore.menu.view.information=Information\ncore.menu.print.preview=Print Preview\ncore.menu.delete=Delete\ncore.menu.rename=Move / Rename\ncore.menu.actions.label=More Actions\ncore.menu.actions.main=Manage\ncore.menu.actions.others=Actions\ncore.menu.actions.viewers=Viewers\ncore.menu.preview=Print Preview\ncore.menu.profile=Profile\ncore.menu.userPreferences=Preferences\ncore.menu.userDashboard=My dashboard\ncore.menu.network=Network\ncore.menu.export=Export\ncore.menu.watchlist.add=Watch\ncore.menu.watchlist.remove=Unwatch\ncore.menu.watchlist.add.document=Watch page\ncore.menu.watchlist.remove.document=Unwatch page\ncore.menu.watchlist.add.page=Watch Page\ncore.menu.watchlist.remove.page=Unwatch Page\ncore.menu.watchlist.add.space=Watch Space\ncore.menu.watchlist.remove.space=Unwatch Space\ncore.menu.watchlist.add.wiki=Watch Wiki\ncore.menu.watchlist.remove.wiki=Unwatch Wiki\ncore.menu.watchlist.management=Watchlist\ncore.menu.share=Share by Email\ncore.menu.admin=Administration\ncore.menu.admin.wiki=Administer Wiki\ncore.menu.admin.space=Administer Space\ncore.menu.admin.page=Administer Page\ncore.menu.admin.parent=Administer Parent\ncore.menu.editing=Editing\ncore.menu.type.home=Home\ncore.menu.type.wiki=Wiki\ncore.menu.type.space=Space\ncore.menu.type.page=Page\ncore.menu.type.profile=Profile\ncore.menu.wiki.documentindex=Page Index\ncore.menu.space.documentindex=Page Index\ncore.menu.space.delete=Delete\n### Translations used from web standard templates, not colibri\ncore.menu.view=View\ncore.menu.print=Print\ncore.menu.watch=Watch\ncore.menu.toggleSearch=Toggle search\ncore.menu.toggleNavigation=Toggle navigation\ncore.menu.toggleDropdown=Toggle dropdown\n\n### Messages for the various document viewers (history, attachments, info...)\ncore.viewers.content.doesnotexists.edittocreate=You can <a href=\"{0}\">edit this page</a> to create it.\n\ncore.viewers.comments.title=Comments on <a href=\"{1}\">{0}</a>\ncore.viewers.comments.permalink=Permalink\ncore.viewers.comments.permalink.goto=Go to permalink\ncore.viewers.comments.delete=Delete\ncore.viewers.comments.delete.confirm=Are you sure you want to remove this comment?\ncore.viewers.comments.delete.inProgress=Deleting...\ncore.viewers.comments.delete.done=Comment deleted\ncore.viewers.comments.delete.failed=Failed to delete comment:\ncore.viewers.comments.reply=Reply\ncore.viewers.comments.noComments=No comments for this page\ncore.viewers.comments.add.title=Add comment\ncore.viewers.comments.add.says=says:\ncore.viewers.comments.add.guestName.prompt=Author:\ncore.viewers.comments.add.guestName.default=Anonymous\ncore.viewers.comments.add.submit=Add comment\ncore.viewers.comments.add.cancel=Cancel\ncore.viewers.comments.add.comment.label=Comment\ncore.viewers.comments.add.inProgress=Sending comment...\ncore.viewers.comments.add.done=Comment posted\ncore.viewers.comments.add.failed=Failed to post comment:\ncore.viewers.comments.preview.button.preview=Preview\ncore.viewers.comments.preview.button.back=Back\ncore.viewers.comments.preview.failed=Failed to generate preview:\ncore.viewers.comments.preview.inProgress=Generating preview...\ncore.viewers.comments.commentDeleted=Deleted comment.\ncore.viewers.comments.deleteReplies.prompt=Also delete all replies to this comment?\ncore.viewers.comments.edit=Edit\ncore.viewers.comments.edit.save=Save comment\ncore.viewers.comments.edit.cancel=Cancel\ncore.viewers.comments.edit.notAllowed=You are not allowed to edit this comment\ncore.viewers.comments.edit.notFound=The requested comment does not exist\ncore.viewers.comments.edit.versionComment=Edited comment {0}\ncore.viewers.comments.editForm.fetch.inProgress=Retrieving comment source...\ncore.viewers.comments.editForm.fetch.failed=Failed to retrieve comment:\n### Deprecated:\ncore.viewers.comments.confirmDelete=Are you sure you want to remove this comment?\n\ncore.viewers.annotations.title=Annotations on {0}\n\ncore.viewers.attachments.title=Attachments for <a href=\"{1}\">{0}</a>\ncore.viewers.attachments.download=Download this attachment\ncore.viewers.attachments.delete=Delete\ncore.viewers.attachments.delete.confirm=Are you sure you want to delete this attachment?\ncore.viewers.attachments.delete.title=Delete this attachment\ncore.viewers.attachments.delete.inProgress=Deleting...\ncore.viewers.attachments.delete.done=Attachment deleted\ncore.viewers.attachments.delete.failed=Failed to delete attachment:\ncore.viewers.attachments.livetable.actions=Actions\ncore.viewers.attachments.livetable.author=Posted by\ncore.viewers.attachments.livetable.date=Date\ncore.viewers.attachments.livetable.filename=Name\ncore.viewers.attachments.livetable.filesize=File size\ncore.viewers.attachments.livetable.mimeType=Type\ncore.viewers.attachments.livetable.version=Version\ncore.viewers.attachments.webdavEdit=Edit\ncore.viewers.attachments.webdavEdit.title=Edit this attachment\ncore.viewers.attachments.officeView=Preview\ncore.viewers.attachments.officeView.title=Preview this attachment\ncore.viewers.attachments.move=Move\ncore.viewers.attachments.move.title=Move or rename this attachment\ncore.viewers.attachments.showHistory=View attachment history\ncore.viewers.attachments.author=Posted by {0}\ncore.viewers.attachments.date=on {0}\ncore.viewers.attachments.noAttachments=No attachments for this page\ncore.viewers.attachments.upload.title=Attach files to this page\ncore.viewers.attachments.upload.filename=Choose target filename:\ncore.viewers.attachments.upload.file=Choose file to upload:\ncore.viewers.attachments.upload.addFileInput=Add another file\ncore.viewers.attachments.upload.removeFileInput=Remove\ncore.viewers.attachments.upload.removeFileInput.title=Remove this file\ncore.viewers.attachments.upload.submit=Attach\ncore.viewers.attachments.upload.cancel=Cancel\ncore.viewers.attachments.upload.confirmReplace=Do you want to replace the filename with\ncore.viewers.attachments.revisions=The available versions of attachment ''{0}'' are:\n### MIME types\ncore.viewers.attachments.mime.audio=Audio\ncore.viewers.attachments.mime.image=Image\ncore.viewers.attachments.mime.text=Text\ncore.viewers.attachments.mime.video=Video\ncore.viewers.attachments.mime.flash=Flash\ncore.viewers.attachments.mime.svg=SVG\ncore.viewers.attachments.mime.html=HTML\ncore.viewers.attachments.mime.css=CSS\ncore.viewers.attachments.mime.xml=XML\n### Office\ncore.viewers.attachments.mime.office=Office Document\ncore.viewers.attachments.mime.document=Document\ncore.viewers.attachments.mime.presentation=Presentation\ncore.viewers.attachments.mime.spreadsheet=Spreadsheet\ncore.viewers.attachments.mime.odt=Office Template\ncore.viewers.attachments.mime.ps=PS\ncore.viewers.attachments.mime.pdf=PDF\n### Archives\ncore.viewers.attachments.mime.tar=TAR Archive\ncore.viewers.attachments.mime.bz=BZ Archive\ncore.viewers.attachments.mime.gz=GZ Archive\ncore.viewers.attachments.mime.zip=ZIP Archive\ncore.viewers.attachments.mime.rar=RAR Archive\ncore.viewers.attachments.mime.jar=JAR\n### Code\ncore.viewers.attachments.mime.sql=SQL Dump\ncore.viewers.attachments.mime.php=PHP Code\ncore.viewers.attachments.mime.c=C Code\ncore.viewers.attachments.mime.cpp=C++ Code\ncore.viewers.attachments.mime.cs=C# Code\ncore.viewers.attachments.mime.h=Header File\ncore.viewers.attachments.mime.ruby=Ruby Code\ncore.viewers.attachments.mime.java=Java Code\ncore.viewers.attachments.mime.js=JavaScript Code\ncore.viewers.attachments.mime.script=Shell Script\ncore.viewers.attachments.mime.vs=Visual Studio File\n### Misc.\ncore.viewers.attachments.mime.calendar=Calendar Data\ncore.viewers.attachments.mime.email=EMail\ncore.viewers.attachments.mime.vcard=vCard\ncore.viewers.attachments.mime.exe=Windows Executable\ncore.viewers.attachments.mime.attachment=Attachment\n\ncore.viewers.history.actions=Actions\ncore.viewers.history.title=History of <a href=\"{1}\">{0}</a>\ncore.viewers.history.summary=History of {0} &mdash; revisions from {1} to {2}\ncore.viewers.history.from=From\ncore.viewers.history.to=To\ncore.viewers.history.version=Version\ncore.viewers.history.author=Editor\ncore.viewers.history.date=Date\ncore.viewers.history.comment=Summary\ncore.viewers.history.currentVersion=Current version\ncore.viewers.history.rollback=Rollback\ncore.viewers.history.confirmRollback=Are you sure you wish to rollback to version {0}?\ncore.viewers.history.deleteSingle=Delete\ncore.viewers.history.confirmDeleteSingle=This action is not reversible. Are you sure you wish to delete version {0}?\ncore.viewers.history.compare=Compare selected versions\ncore.viewers.history.deleteRange=Delete selected version range\ncore.viewers.history.confirmDeleteRange=This action is not reversible. Are you sure you wish to delete versions from __rev1__ to __rev2__ inclusive?\ncore.viewers.history.showMinorEdits=Show minor edits\ncore.viewers.history.hideMinorEdits=Hide minor edits\ncore.viewers.history.extension.label={0}Version{1} coming from extension {2}{3} {4}{5}\ncore.viewers.history.empty=\"The history of this page is empty.\"\n\ncore.viewers.information.title=Information about <a href=\"{1}\">{0}</a>\ncore.viewers.information.locale=Locale\ncore.viewers.information.noLocale=None\ncore.viewers.information.originalLocale=Original locale\ncore.viewers.information.translations=Translations\ncore.viewers.information.syntax=Syntax\ncore.viewers.information.hidden=Hidden\ncore.viewers.information.includedPages=Included pages\ncore.viewers.information.noIncludedPages=No included pages\ncore.viewers.information.backlinks=Backlinks\ncore.viewers.information.noBacklinks=No backlinks\ncore.viewers.information.pageReference=Page reference\ncore.viewers.information.pageReference.copied=Reference copied to clipboard\ncore.viewers.information.pageReference.copyButton=Copy the reference to clipboard\ncore.viewers.information.pageReference.globalButton=Display the page reference for all wikis\ncore.viewers.information.pageReference.localButton=Display the page reference only for this wiki\ncore.viewers.information.pageReference.tips=Copy and paste this reference whenever a page reference or 'fullname' is required: when creating links to this page in the wiki syntax editor, when using this page as a parameter to wiki macro, etc.\n\ncore.viewers.code.title=Wiki source code of <a href=\"{1}\">{0}</a>\ncore.viewers.code.hideLineNumbers=Hide line numbers\ncore.viewers.code.showLineNumbers=Show line numbers\n\ncore.viewers.jump.dialog.content=Go to:\ncore.viewers.jump.shortcuts='Meta+G', 'Ctrl+G', 'Ctrl+/', 'Meta+/'\ncore.viewers.jump.dialog.input.tooltip=Path.to.Page\ncore.viewers.jump.dialog.actions.view=View\ncore.viewers.jump.dialog.actions.view.tooltip=View page (Enter)\ncore.viewers.jump.dialog.actions.view.shortcuts='Enter'\ncore.viewers.jump.dialog.actions.edit=Edit\ncore.viewers.jump.dialog.actions.edit.tooltip=Edit page in the default editor (Meta+E)\ncore.viewers.jump.dialog.actions.edit.shortcuts='Meta+E'\n\ncore.viewers.share.title=Share <a href=\"{1}\">{0}</a> by email\ncore.viewers.share.error.mustLogin=You must be logged in to use this feature\ncore.viewers.share.error.serverError=email server error\ncore.viewers.share.error.unknownEmail=unknown email address\ncore.viewers.share.error.missingRecipient=Please enter the recipient\ncore.viewers.share.send.success=The message has been sent to {0}.\ncore.viewers.share.send.error=The message could not be sent to {0}: {1}.\ncore.viewers.share.send.back=\\u00AB Go back to the {0} page\ncore.viewers.share.dialogTitle=Share this page\ncore.viewers.share.target=Send to\ncore.viewers.share.target.hint=XWiki user or email address\ncore.viewers.share.target.ccMe=Send me a copy\ncore.viewers.share.includeMethod=Include the current page\ncore.viewers.share.includeMethod.link=Only as a link\ncore.viewers.share.includeMethod.inline=Inline in the message\ncore.viewers.share.includeMethod.attachment=As an attached PDF\ncore.viewers.share.includeComments=Also include comments\ncore.viewers.share.messagePreviewLabel=The following message will be sent:\ncore.viewers.share.defaultMessage=I wanted to share this page with you.\ncore.viewers.share.recipientPlaceholder=&lt;recipient&gt;\ncore.viewers.share.submit=Send\ncore.viewers.share.cancel=Cancel\n\nplatform.web.editors.wiki.pageTitle=Editing {0} (wiki mode)\nplatform.web.editors.wysiwyg.pageTitle=Editing {0}\nplatform.web.editors.inline.pageTitle=Editing {0}\nplatform.web.editors.object.pageTitle=Editing objects of {0}\nplatform.web.editors.class.pageTitle=Editing class {0}\nplatform.web.editors.rights.pageTitle=Editing access rights for {0}\nplatform.web.editors.unknown.pageTitle=Editing {0}\n\ncore.editors.content.parentField.label=Parent\ncore.editors.content.parentField.edit=(edit)\ncore.editors.content.parentField.edit.title=Edit parent\ncore.editors.content.parentField.edit.hide=(hide)\ncore.editors.content.titleField.label=Title\ncore.editors.content.contentField.label=Content\ncore.editors.content.titleField.sectionEditingFormat={0} (\\u00A7{1}: {2})\n\n###full screen\ncore.editors.fullscreen.editFullScreen=Maximize\ncore.editors.fullscreen.editFullScreenTitle=Maximize\ncore.editors.fullscreen.exitFullScreen=Exit Full Screen\n\ncore.editors.object.title=Editing objects of <a href=\"{1}\">{0}</a>\ncore.editors.object.objectsForClass=Objects of type {0}\ncore.editors.object.noObject=The specified object does not exist\ncore.editors.object.add.label=New object\ncore.editors.object.add.selectClass=Select a Class\ncore.editors.object.add.submit=Add\ncore.editors.object.add.inProgress=Creating object...\ncore.editors.object.add.done=Object created\ncore.editors.object.add.failed=Failed:\ncore.editors.object.loadObject.inProgress=Loading object information...\ncore.editors.object.loadObject.done=Object loaded\ncore.editors.object.loadObject.failed=Object loading failed:\ncore.editors.object.add.invalidClassName=The class {0} does not exist\ncore.editors.object.newObjectForClass=New {0} object\ncore.editors.object.newObjectForClass.tooltip=New {0} object\ncore.editors.object.editAllObjects=\\u00ABEdit all the objects defined in this page\ncore.editors.object.editSingleObject=[Edit only this object]\ncore.editors.object.editSingleObject.tooltip=Edit only this object\ncore.editors.object.removeObject=[Remove this object]\ncore.editors.object.removeObject.tooltip=Remove this object\ncore.editors.object.invalidPropertyName=No such property: {0}\ncore.editors.object.delete.inProgress=Deleting object...\ncore.editors.object.delete.done=Object deleted\ncore.editors.object.delete.failed=Failed to delete object:\ncore.editors.object.delete.confirmJS=Are you sure you want to delete this object?\ncore.editors.object.invalidCSRF=Bad CSRF token, try to reload the page.\ncore.editors.object.badParameters=Bad request parameters.\n\ncore.editors.object.removeDeprecatedProperties.info=The following properties were deleted from the class {0} and are now deprecated:\ncore.editors.object.removeDeprecatedProperties.link=Remove deprecated properties\ncore.editors.object.removeDeprecatedProperties.link.tooltip=Remove deprecated properties\ncore.editors.object.removeDeprecatedProperties.all.info=Some objects from this page contain deprecated properties which were deleted from their respective classes.\ncore.editors.object.removeDeprecatedProperties.all.link=Remove all deprecated properties\ncore.editors.object.removeDeprecatedProperties.all.link.tooltip=Remove all deprecated properties\ncore.editors.object.removeDeprecatedProperties.inProgress=Removing deprecated properties...\ncore.editors.object.removeDeprecatedProperties.done=Deprecated properties were removed\ncore.editors.object.removeDeprecatedProperties.failed=Failed to remove deprecated properties\n\ncore.editors.class.title=Editing class <a href=\"{1}\">{0}</a>\ncore.editors.class.switchClass=Edit another class\ncore.editors.class.switchClass.confirm=Do you want to save this class before leaving the editor?\ncore.editors.class.addProperty.name.label=Add new property\ncore.editors.class.addProperty.type.label=Type\ncore.editors.class.addProperty.submit=Add\ncore.editors.class.addProperty.inProgress=Adding property...\ncore.editors.class.addProperty.done=Property added\ncore.editors.class.addProperty.failed=Failed:\n\ncore.editors.class.deleteProperty.text=delete\ncore.editors.class.deleteProperty.tooltip=Delete property {0}\ncore.editors.class.deleteProperty.confirm=Are you sure you want to delete this property?\ncore.editors.class.deleteProperty.inProgress=Deleting property...\ncore.editors.class.deleteProperty.done=Property deleted\ncore.editors.class.deleteProperty.failed=Failed to delete property:\n\ncore.editors.rights.title=Editing rights of <a href=\"{1}\">{0}</a>\n\ncore.editors.csrfCheckFailed=CSRF validation failed when saving.\ncore.editors.saveandcontinue.csrfCheckFailed=CSRF validation failed when saving. Try 'Save &amp; View' instead!\ncore.editors.saveandcontinue.exceptionWhileSaving=An error occured while saving: {0}.\ncore.editors.saveandcontinue.theDocumentWasNotSaved=The page was not saved!\ncore.editors.saveandcontinue.notification.inprogress=Saving...\ncore.editors.saveandcontinue.notification.done=Saved\ncore.editors.saveandcontinue.notification.doneWithMerge=Saved by merging changes\ncore.editors.saveandcontinue.notification.error=Failed to save the page. Reason: {0}\ncore.editors.savewithprogress.notification=Saving... __PROGRESS__%\n\ncore.editors.save.authorizationError.message=An authorization error occured when performing this action. Your might have been logged out since you started to edit this page.\ncore.editors.save.authorizationError.followLink=Click here to login in a new window.\n\ncore.editors.save.previewDiff.title=Version conflict\ncore.editors.save.previewDiff.description=Another version of the document has been saved since you started editing it and the merge cannot be performed automatically because some conflict occured. You can chose below what to do for saving the document, and check the differences between different versions of the document.\ncore.editors.save.previewDiff.latestVersion=Latest version saved\ncore.editors.save.previewDiff.modified=Modified by {0} the {1}\ncore.editors.save.previewDiff.reload.action=Reload the editor\ncore.editors.save.previewDiff.reload.label=Discard Changes\ncore.editors.save.previewDiff.reload.hint=Discards all your current changes and loads back the last saved changes. Be aware that you will lose all your current changes.\ncore.editors.save.previewDiff.forceSave.action=Force save your changes\ncore.editors.save.previewDiff.forceSave.hint=Creates a new version of the document with only your changes. Previous changes will be available in the history and may need to be manually merged.\ncore.editors.save.previewDiff.merge.action=Merge and fix conflicts with your changes\ncore.editors.save.previewDiff.merge.label=Recommended\ncore.editors.save.previewDiff.merge.hint=Merge your changes with the latest version saved of the documents and fix the conflicts by using your version of the document.\ncore.editors.save.previewDiff.custom.action=Fix each conflict individually\ncore.editors.save.previewDiff.custom.label=Advanced\ncore.editors.save.previewDiff.custom.hint=This allows you to take an individual decision for each conflict that needs to be solved.\ncore.editors.save.previewDiff.viewChanges=View changes\ncore.editors.save.previewDiff.versionToCompare.previous=before your changes\ncore.editors.save.previewDiff.versionToCompare.current=your current changes\ncore.editors.save.previewDiff.versionToCompare.next=latest version saved\ncore.editors.save.previewDiff.versionToCompare.merged=merged version\ncore.editors.save.previewDiff.versionToCompare.custom=custom version\ncore.editors.save.previewDiff.emptyDecisionValue=Remove inserted value.\n\ncore.space.recyclebin.confirm=This action will move ALL pages in space {0} to the Recycle Bin. Are you sure you wish to continue?\ncore.space.delete.confirm=This action will remove ALL pages in space {0} from your wiki. Are you sure you wish to continue?\ncore.space.recyclebin.done=Space {0} was moved to the Recycle Bin.\ncore.space.recyclebin.show=View the list of pages from this space that are currently present in the Recycle Bin \\u00BB\ncore.space.delete.done=All pages from space {0} were deleted from this wiki.\n\ncore.widgets.confirmationBox.defaultQuestion=Are you sure?\ncore.widgets.confirmationBox.button.yes=Yes\ncore.widgets.confirmationBox.button.no=No\ncore.widgets.confirmationBox.button.cancel=Cancel\ncore.widgets.confirmationBox.notification.inProgress=Sending request...\ncore.widgets.confirmationBox.notification.done=Done!\ncore.widgets.confirmationBox.notification.failed=Failed:\n\ncore.widgets.ajaxRequest.error.noServer=Server not responding\n\ncore.widgets.gallery.currentImage=Current image\ncore.widgets.gallery.previousImage=Show previous image\ncore.widgets.gallery.nextImage=Show next image\ncore.widgets.gallery.maximize=Maximize\ncore.widgets.gallery.minimize=Minimize\n\ncore.widgets.suggest.noResults=No results!\ncore.widgets.suggest.showResults=Go to search page\\u2026\ncore.widgets.suggest.valuePrefix=Value:\ncore.widgets.suggest.transportError=Failed to retrieve suggestions:\ncore.widgets.suggest.hide=hide suggestions\n\nweb.uicomponents.suggest.selectTypedText=Select {0} ...\nweb.uicomponents.suggest.attachments.upload=Upload a file ...\nweb.uicomponents.suggest.attachments.uploading=Uploading {0}\nweb.uicomponents.suggest.attachments.uploadDone={0} uploaded successfully\nweb.uicomponents.suggest.attachments.uploadFailed=Failed to upload {0}\n\ncore.widgets.html5upload.item.cancel=Cancel upload\ncore.widgets.html5upload.item.canceled=Canceled\ncore.widgets.html5upload.cancelAll=Cancel all pending uploads\ncore.widgets.html5upload.error.unknown=An error occurred while uploading {0}\ncore.widgets.html5upload.error.invalidType=The file {0} has an unsuported format\ncore.widgets.html5upload.error.invalidSize=The file {0} is too large. Please choose files under {1}\ncore.widgets.html5upload.error.aborted=The upload of {0} has been canceled\ncore.widgets.html5upload.status.finishing=Waiting for server confirmation for {0}...\ncore.widgets.html5upload.status.finished=Attachment uploaded: {0} ({1})\ncore.widgets.html5upload.hideStatus=Hide upload status\n\n### Watchlist (1.2M2)\nwatchlist=Watchlist\nwatchlist.title=Watchlist for {0}\nwatchlist.staytuned=Stay tuned\nwatchlist.staytuned.info=Receive notifications from your Watchlist\nwatchlist.staytuned.email=Email notifications\nwatchlist.staytuned.email.info=Please choose how often you would like to receive your email notifications\nwatchlist.staytuned.email.frequency=Frequency\nwatchlist.staytuned.email.frequency.save=Save\nwatchlist.staytuned.rss=RSS feed\nwatchlist.staytuned.rss.info=Last modifications feed for your watchlist\nwatchlist.elements=Elements in your watchlist\nwatchlist.pages=Pages\nwatchlist.pages.info=Pages you are currently following:\nwatchlist.spaces=Spaces\nwatchlist.spaces.info=Spaces you are currently following:\nwatchlist.page=Page\nwatchlist.space=Space\nwatchlist.actions=Actions\nwatchlist.delete=Remove from watchlist\nwatchlist.delete.tooltip=Remove from watchlist\nwatchlist.delete.ok={0} has been successfuly removed from watchlist\nwatchlist.delete.ko=An error occurred while removing {0} from watchlist\nwatchlist.create.object=Created WatchList storage object\nwatchlist.save.object=Updated WatchList\nwatchlist.event.create=On {0}, the page has been created by {1}\nwatchlist.event.delete=On {0}, the page has been deleted by {1}\nwatchlist.event.update=On {0}, the page has been modified by {1}\nwatchlist.event.update.multiple=Between {0} and {1}, the page has been modified {2} times, by {3} user{3,choice,0#s|1#|2#s}: {4}\nwatchlist.notification.email.greeting=Hello {0},\nwatchlist.notification.email.subject=XWiki updates, {0,choice,0#No|1#One|1<{0}} page{0,choice,0#s|1#|2#s} ha{0,choice,0#ve|1#s|1<ve} been modified since {1}\nwatchlist.notification.email.singleUpdate.subject=XWiki updates, 1 page has been modified since {0}\nwatchlist.notification.email.singleUpdate.intro=This message is sent by XWiki. Here is the page in your watchlist that has been modified since the last notification:\nwatchlist.notification.email.multipleUpdates.subject=XWiki updates, {0} pages have been modified since {1}\nwatchlist.notification.email.multipleUpdates.intro=This message is sent by XWiki. Here are the pages in your watchlist that have been modified since the last notification:\nwatchlist.notification.email.contents=Contents\nwatchlist.notification.tooltip=Notifications\nwatchlist.rss.author=XWiki\nwatchlist.rss.title=Your WatchList RSS feed\nwatchlist.rss.description=This RSS feed allows you to keep track of changes made to pages you added to your watchlist.\nwatchlist.job.hourly=Watchlist hourly email notifier\nwatchlist.job.daily=Watchlist daily email notifier\nwatchlist.job.weekly=Watchlist weekly email notifier\nwatchlist.preferences=Watchlist Preferences\nwatchlist.table.type=Type\nwatchlist.table.wiki=Wiki\nwatchlist.table.space=Space\nwatchlist.table.document=Page name\nwatchlist.table.allspaces=All spaces\nwatchlist.table.alldocuments=All pages\nwatchlist.table.actions=Actions\nwatchlist.diff.error=There was an error computing the difference. Please contact your administrator.\n\n### Activity stream, since 2.0RC1\nactivitystream.event.update=The page \"{0}\" has been modified\nactivitystream.event.update.rss.title=The page \"{0}\" has been modified\nactivitystream.event.update.rss.body=The page \"{0}\" has been modified\nactivitystream.event.create=The page \"{0}\" has been created\nactivitystream.event.create.rss.title=The page \"{0}\" has been created\nactivitystream.event.create.rss.body=The page \"{0}\" has been created\nactivitystream.event.delete=The page \"{0}\" has been deleted\nactivitystream.event.delete.rss.title=The page \"{0}\" has been deleted\nactivitystream.event.delete.rss.body=The page \"{0}\" has been deleted\n### Attachment events since XE 2.6RC1\nactivitystream.event.addAttachment=The attachment \"{1}\" has been added to the page \"{0}\"\nactivitystream.event.addAttachment.rss.title=The attachment \"{1}\" has been added to the page \"{0}\"\nactivitystream.event.addAttachment.rss.body=The attachment \"{1}\" has been added to the page \"{0}\"\nactivitystream.event.updateAttachment=The attachment \"{1}\" has been modified in the page \"{0}\"\nactivitystream.event.updateAttachment.rss.title=The attachment \"{1}\" has been modified in the page \"{0}\"\nactivitystream.event.updateAttachment.rss.body=The attachment \"{1}\" has been modified in the page \"{0}\"\nactivitystream.event.deleteAttachment=The attachment \"{1}\" has been deleted from the page \"{0}\"\nactivitystream.event.deleteAttachment.rss.title=The attachment \"{1}\" has been deleted from the page \"{0}\"\nactivitystream.event.deleteAttachment.rss.body=The attachment \"{1}\" has been deleted from the page \"{0}\"\n### Annotation events since XE 2.6RC1\nactivitystream.event.addAnnotation=An annotation has been added to the page \"{0}\"\nactivitystream.event.addAnnotation.rss.title=An annotation has been added to the page \"{0}\"\nactivitystream.event.addAnnotation.rss.body=An annotation has been added to the page \"{0}\"\nactivitystream.event.updateAnnotation=An annotation has been modified in the page \"{0}\"\nactivitystream.event.updateAnnotation.rss.title=An annotation has been modified in the page \"{0}\"\nactivitystream.event.updateAnnotation.rss.body=An annotation has been modified in the page \"{0}\"\nactivitystream.event.deleteAnnotation=An annotation has been deleted from the page \"{0}\"\nactivitystream.event.deleteAnnotation.rss.title=An annotation has been deleted from the page \"{0}\"\nactivitystream.event.deleteAnnotation.rss.body=An annotation has been deleted from the page \"{0}\"\n### Comment events since XE 2.6RC1\nactivitystream.event.addComment=A comment has been added to the page \"{0}\"\nactivitystream.event.addComment.rss.title=A comment has been added to the page \"{0}\"\nactivitystream.event.addComment.rss.body=A comment has been added to the page \"{0}\"\nactivitystream.event.updateComment=A comment has been modified in the page \"{0}\"\nactivitystream.event.updateComment.rss.title=A comment has been modified in the page \"{0}\"\nactivitystream.event.updateComment.rss.body=A comment has been modified in the page \"{0}\"\nactivitystream.event.deleteComment=A comment has been deleted from the page \"{0}\"\nactivitystream.event.deleteComment.rss.title=A comment has been deleted from the page \"{0}\"\nactivitystream.event.deleteComment.rss.body=A comment has been deleted from the page \"{0}\"\n\n### Deleting a page\ncore.delete=Delete\ncore.delete.title=Delete {0}\ncore.delete.orphansWarning=The following pages have this page specified as a parent:{0}After deleting this page, they will become orphaned.\ncore.delete.confirm=The deletion of a page is not reversible. Are you sure you wish to continue?\ncore.delete.confirmWithInlinks=In addition, the deletion of a page is not reversible. Are you sure you wish to continue?\ncore.delete.waitmessage=Please wait while the page is being deleted.\ncore.delete.success=The page has been deleted.\ncore.delete.error=Some errors happened:\ncore.delete.warningExtensions.title=You are about to delete pages that belong to extensions.\ncore.delete.warningExtensions.explanation=If you delete these pages, the extensions will not work anymore.\ncore.delete.warningExtensions.help=The recommended way of removing an extension is by uninstalling it with the {0}Extension Manager{1}.\ncore.delete.warningExtensions.confirm=Do you wish to continue?\ncore.delete.warningExtensions.tree.title=Pages to remove\ncore.delete.warningExtensions.tree.freePages=Pages that do not belong to any extension\ncore.delete.warningExtensions.tree.selectAll=select all\ncore.delete.warningExtensions.tree.selectNone=none\ncore.delete.warningExtensions.tree.paginationNode={0} more....\ncore.delete.warningExtensions.canceling=Canceling the delete action\ncore.delete.warningExtensions.canceled=Delete action canceled\ncore.delete.warningExtensions.timeout=The action has been canceled because we have not received any answer after 5 minutes.\ncore.delete.affectChildren=Affect children\ncore.delete.autoRedirect.hint=Redirect the user to the new page when accessing the old page. Select this option if you don't want to break external links to the deleted page.\ncore.delete.autoRedirect.label=Create an automatic redirect\ncore.delete.backlinks=Backlinks\ncore.delete.updateLinks.hint=Update the target of {0}{1} {1,choice,0#incoming links|1#incoming link|1<incoming links}{2} to this page.\ncore.delete.updateLinks.label=Update links\ncore.delete.backlinkTarget.hint=After deleting this page, the incoming links (internal and external) will point to an empty page. To avoid this, you can select an existing page as the new target. Leave empty for no action.\ncore.delete.backlinkTarget.label=New target\n\n### Restoring a page\ncore.restore.title=Restore {0}\ncore.restore.includeBatch=Include the batch of documents deleted at the same time\ncore.restore.batch.doc.name=Page\ncore.restore.batch.doc.location=Location\ncore.restore.batch._actions=Actions\ncore.restore.batch._actions.delete=Delete\ncore.restore.batch._actions.restore=Restore\ncore.restore.deleter=Deleted by:\ncore.restore.deleteDate=Deleted on:\ncore.restore.batchId=Deleted Batch ID\ncore.restore.confirm.yes=Restore\ncore.restore.confirm.no=Cancel\ncore.restore.waitmessage=Please wait while the restore operation is being performed.\ncore.restore.status.notFound=The requested restore status could not be found.\ncore.restore.status.success=Restore operation was successful.\ncore.restore.status.failure=Restore failed.\n\n## Children of a page\ncore.children.title=Children of {0}\ncore.children.warningParentChild=Note: this page does not display the children based on the parent/child mechanism.\ncore.children.terminalPage=This page is a terminal page that cannot have children.\ncore.children.parentChildDescription=Pages having this page as parent:\ncore.children.parentChildNoChild=This page does not have any child based on the parent/child mechanism.\n\n## Siblings of a document\ncore.siblings.title=Siblings of {0}\n\n## Backlinks\ncore.backlinks.title=Backlinks to {0}\ncore.backlinks.description=Pages having a link to this page:\ncore.backlinks.noBackLink=There is no backlink to this page.\n\n## Events\ncore.events.create.description=A new page is created\ncore.events.delete.description=A page is deleted\ncore.events.update.description=A page is modified\ncore.events.comment.description=A comment is posted\ncore.events.appName=Pages\n\ncore.recyclebin.showlistmsg=The following versions are in the recycle bin:\ncore.recyclebin.showListTerminalPagesMsg=The following versions of terminal pages are in the recycle bin:\ncore.recyclebin.deleter=Deleter\ncore.recyclebin.actions=Actions\ncore.recyclebin.deleteDate=Deletion Date\ncore.recyclebin.batchId=Deleted Batch ID\ncore.recyclebin.delete=Delete\ncore.recyclebin.restore=Restore\ncore.recyclebin.confirm=Are you sure you wish to move this page to the recycle bin?\ncore.recyclebin.confirmWithInlinks=Are you sure you wish to move this page to the recycle bin?\ncore.recyclebin.completelyDeleteConfirm=This action is not reversible. Are you sure you wish to continue?\ncore.recyclebin.invalidEntry=Invalid recycle bin entry.\ncore.recycleBin.shouldSkip.label=Are you sure you wish to delete this page?\ncore.recycleBin.shouldSkip.no=Delete and move to the recycle bin.\ncore.recycleBin.shouldSkip.yes=Permanently delete the page (it won't be put in the recycle bin).\n\ncore.versions.delete.single=Delete\ncore.versions.delete.many=Delete versions\ncore.versions.delete.confirm.single=This action is not reversible. Do you want to delete version {0}?\ncore.versions.delete.confirm.many=This action is not reversible. Are you sure you wish to delete versions from {0} to {1} inclusive?\ncore.versions.delete.needselect=You need to select \"from\" and \"to\" versions to delete\ncore.versions.delete.goback=go back\n\ncore.pdf.tableOfContents=Table of Contents\n\npanels.documentInformation.title=Page Information\npanels.documentInformation.syntax=Page syntax\npanels.documentInformation.includesCount={0,choice,0#No|1#One|1<{0}} included {0,choice,0#pages.|1#page:|1<pages:}\npanels.documentInformation.includesOne={0} included page:\npanels.documentInformation.includesMore={0} included pages:\npanels.documentInformation.editIncluded=Edit {0}\npanels.documentInformation.defaultLanguage=Default Language:\npanels.documentInformation.hiddenDocument=Hidden page\n\npanels.translation.title=Page Translations\npanels.translation.editingOriginal=You are editing the original page ({0}).\npanels.translation.editingTranslation=You are editing the following translation: {0}.\npanels.translation.editOriginalLanguage=The original language of the page is {0}.\npanels.translation.translate=Translate this page in:\npanels.translation.otherTranslations=Other translations:\npanels.translation.existingTranslations=Existing translations:\n\npanels.recentlyVisited.title=Recently Visited\npanels.recentlyModified.title=Recently Modified\npanels.recentlyCreated.title=Recently Created\n\npanels.applications.title=Applications\npanels.applications.more=More applications\n\npanelwizard.panelwizard=Panels\npanelwizard.placemanager=Place Manager\npanelwizard.notadmininplace=You are not admin on this place {0}.\npanelwizard.panellayoutupdate=Panel Layout Update\npanelwizard.nodirectaccess=This page is not supposed to be accessed directly. Please use the {0}.\npanelwizard.panellist=Panel List\npanelwizard.pagelayout=Page Layout\npanelwizard.nopanels=There are no panels from this category.\npanelwizard.panelColumns=Panel Columns\npanelwizard.choosepagelayout=Choose a page layout\npanelwizard.nosidecolumn=No side column\npanelwizard.leftcolumn=Left column\npanelwizard.rightcolumn=Right column\npanelwizard.bothcolumns=Both columns\npanelwizard.needadminright=You need to have administrative rights to use the Panel Wizard.\npanelwizard.paneleditor=Panel Editor\npanelwizard.tip=To drag a panel, use your mouse and click on the header of the panel. Keep your left mouse button down while you move your mouse and the panel at the same time. While you move the panel you will see in real-time where the panel will be dropped when you release your left mouse button.\npanelwizard.draganddrop=Drag and drop panels to rearrange them inside a column or between columns. To add or remove panels, drag them from the list of available panels to one of the columns or from the column into the list, respectively.\npanelwizard.save.versionComment=Updated panel layout\n\n#tooltip for fullscreen editing\nfullScreenTooltip=Edit in Full Screen\n\n### user registration\ncore.register=Register\ncore.register.title=Registration\ncore.register.welcome=Sign up here so you can edit pages and participate in the wiki.\ncore.register.passwordMismatch=Passwords are different or password is empty.\ncore.register.userAlreadyExists=User already exists.\ncore.register.invalidUsername=Invalid username provided. Please use only letters from the latin alphabet, numbers, and the underscore character '_'.\ncore.register.mailSenderWronglyConfigured=The user has been created but the validation email has not been sent. Please check the Mail Sending Configuration and consider recreating the user.\ncore.register.registerFailed=Registration has failed due to unknown reasons. (Error code: {0})\ncore.register.successful={0} ({1}): Registration successful.\ncore.register.firstName=First Name\ncore.register.lastName=Last Name\ncore.register.username=Username\ncore.register.password=Password\ncore.register.passwordRepeat=Confirm Password\ncore.register.email=Email Address\ncore.register.submit=Register\ncore.register.badCSRF=Bad CSRF token.\n\n# User account validation\ncore.users.activation.validationKey.label=Validation key:\n\n# Misc about users\ncore.users.unknownUser=Unknown User\ncore.users.disable.saveComment=Disable user account\ncore.users.enable.saveComment=Enable user account\n\n###Validation\ncore.validation.required=(Required)\ncore.validation.required.message=This field is required.\ncore.validation.required.message.terminal=This field is required for terminal pages.\ncore.validation.valid.message=Ok.\n\n# Captcha \ncore.captcha.captchaAnswerIsWrong=Incorrect answer, please try again.\ncore.captcha.instruction=Please validate the CAPTCHA to prove you are not a robot\n\n# History\nweb.history.changes.raw=Raw\nweb.history.changes.rendered=Rendered\nweb.history.changes.summary=Summary\nweb.history.changes.summary.documents=Showing {0}{1} changed {1,choice,1#page|1<pages}{2}\nweb.history.changes.summary.documentProperties=Page properties\nweb.history.changes.summary.attachments=Attachments\nweb.history.changes.summary.objects=Objects\nweb.history.changes.summary.classProperties=Class properties\nweb.history.changes.summary.modifiedAddedRemoved={0} modified, {1} added, {2} removed\nweb.history.changes.noChanges=No changes\nweb.history.changes.failedToCompute=Failed to compute the changes.\nweb.history.changes.details=Details\nweb.history.changes.document.title=Title\nweb.history.changes.document.parent=Parent\nweb.history.changes.document.hidden=Hidden\nweb.history.changes.document.defaultLocale=Default language\nweb.history.changes.document.syntax=Syntax\nweb.history.changes.document.content=Content\nweb.history.changes.attachment.size=Size\nweb.history.changes.attachment.content=Content\nweb.history.changes.attachment.noContentChanges=Either this is not a text file or the file is too large\nweb.history.changes.privateInformation=Private information\nweb.history.changes.attachment.notAvailable=The content diff is not available. One attachment might have been deleted from the recycle bin.\nweb.history.changes.showContext=Show context\nweb.history.changes.hideContext=Hide context\nweb.history.changes.restrictedInfo=For security reasons, at least one of the compared documents is displayed in \\\n  restricted mode as it is not the current version. There may be differences and errors due to this.\n\ncore.viewers.diff.title=Changes for page <a href=\"{1}\">{0}</a>\ncore.viewers.diff.from=From version {0}\ncore.viewers.diff.fromNew=From empty\ncore.viewers.diff.to=To version {0}\ncore.viewers.diff.editedBy=edited by {0}\ncore.viewers.diff.editedOn=on {0}\ncore.viewers.diff.editComment=Change comment:\ncore.viewers.diff.noEditComment=There is no comment for this version\ncore.viewers.diff.nextChange=Next change\ncore.viewers.diff.previousChange=Previous change\ncore.viewers.diff.nextVersion=Next version\ncore.viewers.diff.previousVersion=Previous version\n\ncore.viewers.code.showBlame=Show last authors\ncore.viewers.code.hideBlame=Hide last authors\n\n####################\n# Macros\n####################\n\nrendering.macroContent=Content\n\n### Macro Categories\nrendering.macroCategory.Development=Development\nrendering.macroCategory.Navigation=Navigation\nrendering.macroCategory.Content=Content\nrendering.macroCategory.Formatting=Formatting\nrendering.macroCategory.Layout=Layout\nrendering.macroCategory.Deprecated=Deprecated\nrendering.macroCategory.Internal=Internal\n\n### Macro Descriptors\nrendering.macro.groovy.name=Groovy\nrendering.macro.groovy.description=Execute a groovy script.\nrendering.macro.groovy.content.description=the groovy script to execute\nrendering.macro.groovy.parameter.jars.name=jars\nrendering.macro.groovy.parameter.jars.description=List of JARs to be added to the class loader used to execute this script. Example: \"attach:wiki:space.page@somefile.jar\", \"attach:somefile.jar\", \"attach:wiki:space.page\" (adds all JARs attached to the page) or URL to a JAR\nrendering.macro.groovy.parameter.output.name=output\nrendering.macro.groovy.parameter.output.description=Specifies whether or not the output result should be inserted back in the page.\nrendering.macro.groovy.parameter.wiki.name=wiki\nrendering.macro.groovy.parameter.wiki.description=Specifies whether or not the script output contains wiki markup.\nrendering.macro.python.name=Python\nrendering.macro.python.description=Executes a python script.\nrendering.macro.python.content.description=The python script to execute\nrendering.macro.python.parameter.jars.name=jars\nrendering.macro.python.parameter.jars.description=List of JARs to be added to the class loader used to execute this script. Example: \"attach:wiki:space.page@somefile.jar\", \"attach:somefile.jar\", \"attach:wiki:space.page\" (adds all JARs attached to the page) or URL to a JAR\nrendering.macro.python.parameter.output.name=output\nrendering.macro.python.parameter.output.description=Specifies whether the output result should be inserted back in the page\nrendering.macro.python.parameter.wiki.name=wiki\nrendering.macro.python.parameter.wiki.description=Specifies whether wiki syntax in the script execution result will be rendered or not\nrendering.macro.html.name=HTML\nrendering.macro.html.description=Inserts HTML or XHTML code into the page.\nrendering.macro.html.content.description=The HTML content to insert in the page.\nrendering.macro.html.parameter.clean.name=clean\nrendering.macro.html.parameter.clean.description=Indicate if the HTML should be transformed into valid XHTML or not.\nrendering.macro.html.parameter.wiki.name=wiki\nrendering.macro.html.parameter.wiki.description=Indicate if the wiki syntax in the macro will be interpreted or not.\nrendering.macro.script.name=Script\nrendering.macro.script.description=Execute script in provided script language.\nrendering.macro.script.content.description=the script to execute\nrendering.macro.script.parameter.jars.name=jars\nrendering.macro.script.parameter.jars.description=List of JARs to be added to the class loader used to execute this script. Example: \"attach:wiki:space.page@somefile.jar\", \"attach:somefile.jar\", \"attach:wiki:space.page\" (adds all JARs attached to the page) or URL to a JAR\nrendering.macro.script.parameter.language.name=language\nrendering.macro.script.parameter.language.description=The identifier of the script language (\"groovy\", \"python\", etc)\nrendering.macro.script.parameter.output.name=output\nrendering.macro.script.parameter.output.description=Specifies whether the output result should be inserted back in the page\nrendering.macro.script.parameter.wiki.name=wiki\nrendering.macro.script.parameter.wiki.description=Specifies whether wiki syntax in the script execution result will be rendered or not\nrendering.macro.velocity.name=Velocity\nrendering.macro.velocity.description=Executes a Velocity script.\nrendering.macro.velocity.content.description=the velocity script to execute\nrendering.macro.velocity.parameter.filter.name=filter\nrendering.macro.velocity.parameter.filter.description=indicate which filtering mode to use\nrendering.macro.velocity.parameter.jars.name=jars\nrendering.macro.velocity.parameter.jars.description=List of JARs to be added to the class loader used to execute this script. Example: \"attach:wiki:space.page@somefile.jar\", \"attach:somefile.jar\", \"attach:wiki:space.page\" (adds all JARs attached to the page) or URL to a JAR\nrendering.macro.velocity.parameter.output.name=output\nrendering.macro.velocity.parameter.output.description=Specifies whether the output result should be inserted back in the page\nrendering.macro.velocity.parameter.wiki.name=wiki\nrendering.macro.velocity.parameter.wiki.description=Specifies whether wiki syntax in the script execution result will be rendered or not\nrendering.macro.toc.name=Table of contents\nrendering.macro.toc.description=Generates a table of contents.\nrendering.macro.toc.parameter.depth.name=depth\nrendering.macro.toc.parameter.depth.description=the maximum section level. For example if 3 then all section levels from 4 will not be listed\nrendering.macro.toc.parameter.numbered.name=numbered\nrendering.macro.toc.parameter.numbered.description=if true the section title number is printed\nrendering.macro.toc.parameter.scope.name=scope\nrendering.macro.toc.parameter.scope.description=if local only section in the current scope will be listed. For example if the macro is written in a section, only subsections of this section will be listed\nrendering.macro.toc.parameter.scope.value.LOCAL=Local\nrendering.macro.toc.parameter.scope.value.PAGE=Page\nrendering.macro.toc.parameter.start.name=start\nrendering.macro.toc.parameter.start.description=the minimum section level. For example if 2 then level 1 sections will not be listed\nrendering.macro.toc.parameter.reference.name=reference\nrendering.macro.toc.parameter.reference.description=Reference to the document for which to generate the table of contents. Leave empty for the current page.\nrendering.macro.id.name=Id\nrendering.macro.id.description=Allows putting a reference/location in a page. In HTML for example this is called an Anchor. It allows pointing to that location, for example in links.\nrendering.macro.id.parameter.name.name=name\nrendering.macro.id.parameter.name.description=the identifier string\nrendering.macro.putFootnotes.name=Put Footnote\nrendering.macro.putFootnotes.description=Displays the footnotes defined so far. If missing, all footnotes are displayed by default at the end of the page.\nrendering.macro.formula.name=Formula\nrendering.macro.formula.description=Displays a mathematical formula.\nrendering.macro.formula.content.description=The mathematical formula, in LaTeX syntax\nrendering.macro.formula.parameter.fontSize.name=fontSize\nrendering.macro.formula.parameter.fontSize.description=adjust font size\nrendering.macro.formula.parameter.fontSize.value.TINY=Tiny\nrendering.macro.formula.parameter.fontSize.value.VERY_SMALL=Very small\nrendering.macro.formula.parameter.fontSize.value.SMALLER=Smaller\nrendering.macro.formula.parameter.fontSize.value.SMALL=Small\nrendering.macro.formula.parameter.fontSize.value.NORMAL=Normal\nrendering.macro.formula.parameter.fontSize.value.LARGE=Large\nrendering.macro.formula.parameter.fontSize.value.LARGER=Larger\nrendering.macro.formula.parameter.fontSize.value.VERY_LARGE=Very large\nrendering.macro.formula.parameter.fontSize.value.HUGE=Huge\nrendering.macro.formula.parameter.fontSize.value.EXTREMELY_HUGE=Extremely huge\nrendering.macro.formula.parameter.imageType.name=imageType\nrendering.macro.formula.parameter.imageType.description=resulting image type\nrendering.macro.formula.parameter.imageType.value.PNG=png\nrendering.macro.formula.parameter.imageType.value.GIF=gif\nrendering.macro.formula.parameter.imageType.value.JPEG=jpeg\nrendering.macro.footnote.name=Footnote\nrendering.macro.footnote.description=Generates a footnote to display at the end of the page.\nrendering.macro.footnote.content.description=the text to place in the footnote\nrendering.macro.rss.name=RSS\nrendering.macro.rss.description=Output latest feed entries from a RSS feed.\nrendering.macro.rss.parameter.content.name=content\nrendering.macro.rss.parameter.content.description=Display content for feed entries\nrendering.macro.rss.parameter.count.name=count\nrendering.macro.rss.parameter.count.description=The maximum number of feed items to display on the page.\nrendering.macro.rss.parameter.feed.name=feed\nrendering.macro.rss.parameter.feed.description=URL of the RSS feed\nrendering.macro.rss.parameter.image.name=image\nrendering.macro.rss.parameter.image.description=If the feeds has an image associated, display it?\nrendering.macro.rss.parameter.width.name=width\nrendering.macro.rss.parameter.width.description=The width, in px or %, of the box containing the RSS output (default is 30%)\nrendering.macro.rss.parameter.encoding.name=encoding\nrendering.macro.rss.parameter.encoding.description=The encoding to use when reading the RSS Feed (guessed by default)\nrendering.macro.useravatar.name=User Avatar\nrendering.macro.useravatar.description=Allows displaying the avatar for a specific user.\nrendering.macro.useravatar.parameter.height.name=height\nrendering.macro.useravatar.parameter.height.description=the image's height\nrendering.macro.useravatar.parameter.username.name=username\nrendering.macro.useravatar.parameter.username.description=the name of the user whose avatar is to be displayed\nrendering.macro.useravatar.parameter.width.name=width\nrendering.macro.useravatar.parameter.width.description=the image's width\nrendering.macro.chart.name=Chart\nrendering.macro.chart.description=Displays a graphical chart generated from miscellaneous data sources\nrendering.macro.chart.content.description=Input data for the chart macro (e.g. for 'inline' source mode)\nrendering.macro.chart.parameter.height.name=height\nrendering.macro.chart.parameter.height.description=The height of the generated chart image\nrendering.macro.chart.parameter.params.name=params\nrendering.macro.chart.parameter.params.description=Additional parameters for the data source\nrendering.macro.chart.parameter.source.name=source\nrendering.macro.chart.parameter.source.description=The string describing the type of input data source (e.g. xdom or inline)\nrendering.macro.chart.parameter.title.name=title\nrendering.macro.chart.parameter.title.description=The title of the chart (appears on top of the chart image)\nrendering.macro.chart.parameter.type.name=type\nrendering.macro.chart.parameter.type.description=The type of the chart (e.g. pie, line, area or bar)\nrendering.macro.chart.parameter.width.name=width\nrendering.macro.chart.parameter.width.description=The width of the generated chart image\nrendering.macro.info.name=Info Message\nrendering.macro.info.description=Displays an info message note.\nrendering.macro.info.content.description=The content to put in the box.\nrendering.macro.error.name=Error Message\nrendering.macro.error.description=Displays an error message note.\nrendering.macro.error.content.description=The content to put in the box.\nrendering.macro.warning.name=Warning Message\nrendering.macro.warning.description=Displays a warning message note.\nrendering.macro.warning.content.description=The content to put in the box.\nrendering.macro.success.name=Success Message\nrendering.macro.success.description=Displays a success message note.\nrendering.macro.success.content.description=The content to put in the box.\nrendering.macro.box.name=Box\nrendering.macro.box.description=Draw a box around provided content.\nrendering.macro.box.content.description=the content to put in the box\nrendering.macro.box.parameter.cssClass.name=cssClass\nrendering.macro.box.parameter.cssClass.description=A CSS class to add to the box element\nrendering.macro.box.parameter.image.name=image\nrendering.macro.box.parameter.image.description=the image which is to be displayed in the message box\nrendering.macro.box.parameter.title.name=title\nrendering.macro.box.parameter.title.description=the title which is to be displayed in the message box\nrendering.macro.box.parameter.width.name=width\nrendering.macro.box.parameter.width.description=An optional width for the box, expressed in px or %\nrendering.macro.code.name=Code\nrendering.macro.code.description=Highlights code snippets of various programming languages\nrendering.macro.code.content.description=the content to highlight\nrendering.macro.code.parameter.language.name=language\nrendering.macro.code.parameter.language.description=the language identifier (java, python, etc.)\nrendering.macro.code.parameter.layout.name=layout\nrendering.macro.code.parameter.layout.description=the layout format (plain or with line numbers)\nrendering.macro.code.parameter.source.name=source\nrendering.macro.code.parameter.source.description=the reference of the content to highlight (e.g. script:myvariable, entity:page:Page/SubPage)\nrendering.macro.code.parameter.cssClass.name=cssClass\nrendering.macro.code.parameter.cssClass.description=A CSS class to add to the box element\nrendering.macro.code.parameter.image.name=image\nrendering.macro.code.parameter.image.description=the image which is to be displayed in the message box\nrendering.macro.code.parameter.title.name=title\nrendering.macro.code.parameter.title.description=the title which is to be displayed in the message box\nrendering.macro.code.parameter.width.name=width\nrendering.macro.code.parameter.width.description=An optional width for the box, expressed in px or %\nrendering.macro.context.name=Context\nrendering.macro.context.description=Executes content in the context of the passed page\nrendering.macro.context.content.description=The content to execute\nrendering.macro.context.parameter.document.name=Page\nrendering.macro.context.parameter.document.description=The reference to the page the content will be executed in.\nrendering.macro.context.parameter.restricted.name=Restricted\nrendering.macro.context.parameter.restricted.description=Indicate if the content should be executed in a restricted context.\nrendering.macro.context.parameter.source.name=Source\nrendering.macro.context.parameter.source.description=the reference of the content to insert (e.g. string:**bold**, script:myvariable)\nrendering.macro.container.name=Container\nrendering.macro.container.description=A macro to enclose multiple groups and add decoration, such as layout.\nrendering.macro.container.content.description=The content to enclose in this container (wiki syntax). For the \"columns\" layout, a group should be added for each column.\nrendering.macro.container.parameter.layoutStyle.name=layout style\nrendering.macro.container.parameter.layoutStyle.description=The identifier of the container layout (e.g. \"columns\"). If no style is provided, the container content will be rendered as is.\nrendering.macro.container.parameter.justify.name=justify\nrendering.macro.container.parameter.justify.description=Flag specifying whether the content in this container is justified or not.\nrendering.macro.container.parameter.cssClass.name=CSS Class\nrendering.macro.container.parameter.cssClass.description=Value of the HTML class attribute to add to this container, used to style in CSS.\nrendering.macro.dashboard.name=Dashboard\nrendering.macro.dashboard.description=A macro to define a dashboard to fill with gadgets.\nrendering.macro.dashboard.parameter.layout.name=layout\nrendering.macro.dashboard.parameter.layout.description=The identifier of the layout to use for this dashboard (e.g. columns, etc). If none specified, columns will be used.\nrendering.macro.dashboard.parameter.style.name=Style\nrendering.macro.dashboard.parameter.style.description=The identifier of the style to be used for this dashboard. No style means that the gadgets will be rendered plain, as content of the page. \"panels\" style will render the gadgets the same as the panels. Note that this is used as the CSS class of the top level block of the dashboard, so you can pass any value to create your own dashboard style.\nrendering.macro.dashboard.parameter.source.name=Source\nrendering.macro.dashboard.parameter.source.description=The source of the dashboard macro, as a page reference, where the gadget configurations (objects) should be read from. By default the current page will be used. Example: Dashboard.WebHome.\nrendering.macro.gallery.name=Gallery\nrendering.macro.gallery.description=Displays the images found in the provided content using a slide-show view.\nrendering.macro.gallery.content.description=The images to be displayed in the gallery. All the images found in the provided wiki content are included. Images should be specified using the syntax of the current page. Example, for XWiki 2.0 syntax: image:Space.Page@alice.png image:http://www.example.com/path/to/bob.jpg\nrendering.macro.cache.name=Cache\nrendering.macro.cache.description=Caches content.\nrendering.macro.cache.content.description=The content to cache.\nrendering.macro.cache.parameter.id.name=id\nrendering.macro.cache.parameter.id.description=A unique id under which the content is cached.\nrendering.macro.cache.parameter.timeToLive.name=timeToLive\nrendering.macro.cache.parameter.timeToLive.description=The number of seconds to cache the content.\nrendering.macro.cache.parameter.maxEntries.name=maxEntries\nrendering.macro.cache.parameter.maxEntries.description=The maximum number of entries in the cache (Least Recently Used entries are ejected).\nrendering.macro.comment.name=Comment\nrendering.macro.comment.description=Allows putting comments in the source content. This macro doesn't output anything.\nrendering.macro.comment.content.description=Comments.\n### Wiki macros, distributed with XE -- TODO: remove these translations when localization tool will be ready to inject translations at .xar import time\nrendering.macro.spaces.name=Spaces\nrendering.macro.spaces.description=Displays all the spaces in this wiki.\nrendering.macro.tagcloud.name=Tag Cloud\nrendering.macro.tagcloud.description=Displays the cloud of tags in this wiki or in the specified space, if any.\nrendering.macro.tagcloud.parameter.space.name=space\nrendering.macro.tagcloud.parameter.space.description=The space to display the tag cloud for. If missing, the tags in the whole wiki will be displayed.\nrendering.macro.tagcloud.parameter.spaces.name=Spaces\nrendering.macro.tagcloud.parameter.spaces.description=Spaces to display the tag cloud for. Space names must be separated by comma \",\" and wrapped in single quotes \"'\". (i.e. 'Space1','Space2')\nrendering.macro.tagcloud.parameter.limit.name=Limit\nrendering.macro.tagcloud.parameter.limit.description=Maximum number of tags to be displayed in the cloud\nrendering.macro.activity.name=Activity\nrendering.macro.activity.description=The Activity Macro provides information about recent activities done by the users inside the XWiki instance. It lists the create, edit and delete events for pages, as well as comments, attachments and annotations.\nrendering.macro.activity.parameter.entries.name=entries\nrendering.macro.activity.parameter.entries.description=Number of entries to display the activity for.\nrendering.macro.activity.parameter.subentries.name=subentries\nrendering.macro.activity.parameter.subentries.description=Number of activities to show for each entry.\nrendering.macro.activity.parameter.wikis.name=wikis\nrendering.macro.activity.parameter.wikis.description=Comma separated list of wikis to display activity for.\nrendering.macro.activity.parameter.spaces.name=spaces\nrendering.macro.activity.parameter.spaces.description=Comma separated list of spaces to display the activity for.\nrendering.macro.activity.parameter.authors.name=authors\nrendering.macro.activity.parameter.authors.description=Comma separated list of authors whose modifications to show.\nrendering.macro.activity.parameter.tags.name=tags\nrendering.macro.activity.parameter.tags.description=Comma separated list of tags to display activity for.\nrendering.macro.activity.parameter.minor.name=minor\nrendering.macro.activity.parameter.minor.description=Whether to show modifications that create minor versions or not.\nrendering.macro.activity.parameter.rss.name=RSS\nrendering.macro.activity.parameter.rss.description=Whether to show activity RSS link or not.\nrendering.macro.spaceindex.name=Space Index\nrendering.macro.spaceindex.description=Lists the pages in a space.\nrendering.macro.spaceindex.parameter.count.name=count\nrendering.macro.spaceindex.parameter.count.description=The maximum number of pages to display. By default, up to 100 pages will be listed. If all pages should be displayed, pass 0.\nrendering.macro.spaceindex.parameter.space.name=space\nrendering.macro.spaceindex.parameter.space.description=The space to display the list of pages for. If missing, the current space will be used.\nrendering.macro.spaceindex.parameter.sort.name=sort\nrendering.macro.spaceindex.parameter.sort.description=Optional parameter to choose the sorting of the list of pages.\\nValid values are: 'creationDate': sort by creation date (default), 'modificationDate': sort by update date, or 'docName': sort alphabetically.\nrendering.macro.documents.name=Pages\nrendering.macro.documents.description=Displays a list of pages in a Livetable\nrendering.macro.documents.parameter.count.name=count\nrendering.macro.documents.parameter.count.description=Number of items to display by default\nrendering.macro.documents.parameter.actions.name=actions\nrendering.macro.documents.parameter.actions.description=Whether to show the actions columns or not\nrendering.macro.documents.parameter.space.name=space\nrendering.macro.documents.parameter.space.description=Only lists pages found in the passed space\nrendering.macro.documents.parameter.id.name=id\nrendering.macro.documents.parameter.id.description=Livetable id\nrendering.macro.documents.parameter.parent.name=parent\nrendering.macro.documents.parameter.parent.description=Only list pages having the specified parent\nrendering.macro.documents.parameter.columns.name=columns\nrendering.macro.documents.parameter.columns.description=Displays specified columns (e.g. \"doc.name,doc.author\"). The default value is \"doc.name,doc.space,doc.date,doc.author\".\nrendering.macro.attachmentSelector.name=Attachment Selector\nrendering.macro.attachmentSelector.description=A control to be used for object properties of the current page that are supposed to contain the name of an attachment from the current (or target) page. Allows uploading new attachments, and deleting attachments from the target page.  If no target page is specified, the current page will be used. Object properties are only saved to the current page.\nrendering.macro.attachmentSelector.parameter.classname.name=classname\nrendering.macro.attachmentSelector.parameter.classname.description=The full name of the page holding the XClass that contains the property associated with this picker.\nrendering.macro.attachmentSelector.parameter.property.name=property\nrendering.macro.attachmentSelector.parameter.property.description=The name of the property associated with the picker.\nrendering.macro.attachmentSelector.parameter.object.name=object\nrendering.macro.attachmentSelector.parameter.object.description=The identifier (number) of the object for which the property is displayed by this picker. If missing, the first instance of the class given by the parameter classname found in the page will be considered.\nrendering.macro.attachmentSelector.parameter.cssClass.description=A CSS class for the element surrounding the property value.\nrendering.macro.attachmentSelector.parameter.cssClass.name=cssClass\nrendering.macro.attachmentSelector.parameter.savemode.description=States how the property is updated. Accepted values: \"form\" (default)  meaning that the selected value is stored in an input that will be saved via an external form; \"direct\" means that the picker is responsible with updating the property value.\nrendering.macro.attachmentSelector.parameter.savemode.name=savemode\nrendering.macro.attachmentSelector.parameter.buttontext.description=Text of the button that triggers the picker. Defaults to $services.localization.render('xe.attachmentSelector.selectFile').\nrendering.macro.attachmentSelector.parameter.buttontext.name=buttontext\nrendering.macro.attachmentSelector.parameter.defaultValue.description=What attachment is displayed in view mode if the property is empty. Should either be empty or in the form of a wiki attachment reference (e.g. \"attachment.txt\", \"Another.Page@attachment.txt\").\nrendering.macro.attachmentSelector.parameter.defaultValue.name=defaultValue\nrendering.macro.attachmentSelector.parameter.filter.description=Comma separated list of file extensions accepted by the property (to become a comma separated list of mimetypes when XWiki will use HTML5). All files are accepted if this parameter is empty.\nrendering.macro.attachmentSelector.parameter.filter.name=filter\nrendering.macro.attachmentSelector.parameter.displayImage.description=States whether images are displayed or just their name is printed like for other attachments. Possible values: true, false (default).\nrendering.macro.attachmentSelector.parameter.displayImage.name=displayImage\nrendering.macro.attachmentSelector.parameter.width.description=The width of the displayed image, only taken into account if displayImage=true.\nrendering.macro.attachmentSelector.parameter.width.name=width\nrendering.macro.attachmentSelector.parameter.height.description=The height of the displayed image, only taken into account if displayImage=true.\nrendering.macro.attachmentSelector.parameter.height.name=height\nrendering.macro.attachmentSelector.parameter.alternateText.description=The alternate text of the displayed image, only taken into account if displayImage=true\nrendering.macro.attachmentSelector.parameter.alternateText.name=alternateText\nrendering.macro.attachmentSelector.parameter.link.description=States whether a link to the attachment is associated in view mode with the displayed attachment name/image. Possible values: true, false (default).\nrendering.macro.attachmentSelector.parameter.link.name=link\nrendering.macro.attachmentSelector.parameter.targetdocname.description=The target page name to save/list attachments from\nrendering.macro.attachmentSelector.parameter.targetdocname.name=targetdocname\nrendering.macro.messageSender.name=Message Sender\nrendering.macro.messageSender.description=A control that allows users to enter messages that are handled by the MessageStream module.\nrendering.macro.messageSender.parameter.visibility.name=visibility\nrendering.macro.messageSender.parameter.visibility.description=Default selected visibility when the macro is displayed.\\nIf not specified, it is determined automatically based on the page where the macro is used.\\nValid values are: 'everyone', 'followers', 'group' or 'user'.\nrendering.macro.messageSender.parameter.visibilityParameter.name=visibilityParameter\nrendering.macro.messageSender.parameter.visibilityParameter.description=Some visibility levels (like 'user' and 'group') accept a parameter. In the case of the 2 mentioned levels, the value can be a serialized reference of a user or a group page.\nrendering.macro.messageSender.parameter.visibilityOptions.name=visibilityOptions\nrendering.macro.messageSender.parameter.visibilityOptions.description=Comma separated list of visibility options that the macro should allow the user to choose from.\\nThis list should be a sublist of the default ones: 'everyone', 'followers', 'group', 'user'.\nrendering.macro.async.name=Async macro\nrendering.macro.async.description=Execute asynchronously and/or cache the macro content.\nrendering.macro.async.content.description=The wiki content to execute.\nrendering.macro.async.parameter.async.name=Async\nrendering.macro.async.parameter.async.description=Enable or disable asynchronous execution\nrendering.macro.async.parameter.cached.name=Cached\nrendering.macro.async.parameter.cached.description=Enable or disable caching of the result of the macro content execution\nrendering.macro.async.parameter.contextEntries.name=Context entries\nrendering.macro.async.parameter.contextEntries.description=The list of context elements needed for the execution (wiki, user, locale, request.base, doc.reference...)\nrendering.macro.async.parameter.id.name=Id override\nrendering.macro.async.parameter.id.description=A unique id is automatically generated by default but it's possible to provide a custom one if needed\n\n####################\n# Async\n####################\n\nrendering.async.context.entry.author=Author\nrendering.async.context.entry.doc.reference=Document\nrendering.async.context.entry.wiki=Wiki\nrendering.async.context.entry.secureDocument=Secure document\nrendering.async.context.entry.request.parameters=Request parameters\nrendering.async.context.entry.request.url=Request URL\nrendering.async.context.entry.request.base=Request base URL\nrendering.async.context.entry.request.wiki=Request wiki\nrendering.async.context.entry.request.contextpath=Request context path\nrendering.async.context.entry.locale=Language\nrendering.async.context.entry.action=Action\nrendering.async.context.entry.user=User\n\nrendering.async.error.failed=Failed to execute asynchronous content\n\n####################\n# Plugins\n####################\n\n### Tag plugin\nplugin.tag.editcomment.renamed=Renamed tag [{0}] to [{1}]\nplugin.tag.editcomment.added=Added tag [{0}]\nplugin.tag.editcomment.removed=Removed tag [{0}]\n\n####################\n# Applications\n####################\n\n### Rights manager (XWiki Enterprise wiki)\nrightsmanager.confirmdeleteuser=The user __name__ will be deleted and removed from all groups he belongs to. Are you sure you want to proceed?\nrightsmanager.confirmdeletegroup=The group __name__ will be deleted. Are you sure you want to proceed?\nrightsmanager.confirmdeletemember=This user will be removed from the current group. Are you sure you want to proceed?\nrightsmanager.duplicateuser=Some users already exist in the group\nrightsmanager.unregisteredusers=Unregistered Users\nrightsmanager.specialusers=Special Users\nrightsmanager.groups=Groups\nrightsmanager.users=Users\nrightsmanager.groupsorusers=Groups or Users\nrightsmanager.admin=Admin\nrightsmanager.programming=Program\nrightsmanager.edit=Edit\nrightsmanager.script=Script\nrightsmanager.view=View\nrightsmanager.delete=Delete\nrightsmanager.register=Register\nrightsmanager.createwiki=Create Wiki\nrightsmanager.comment=Comment\nrightsmanager.global=Global\nrightsmanager.local=Local\nrightsmanager.both=Both\nrightsmanager.edituserprofile=For more options to edit this user, please go to the\nrightsmanager.userprofile=user's profile\nrightsmanager.members=Members\nrightsmanager.manage=Manage\nrightsmanager.addnewuser=Create user\nrightsmanager.addnewgroup=Add group\nrightsmanager.createnewgroup=Create new group\nrightsmanager.creategroup=Create group\nrightsmanager.groupexist=__name__ cannot be used for the group name, as another page with this name already exists.\nrightsmanager.documentrequireviewrights=(*) Some pages require special rights to be viewed.\nrightsmanager.denyrightforuorg=You are about to deny the __right__ right for __name__. Continue?\nrightsmanager.clearrightforuorg=You are about to clear the __right__ right for __name__. Continue?\nrightsmanager.denyrightforcurrentuser=You are about to deny the __right__ right for yourself. Continue?\nrightsmanager.clearrightforcurrentuser=You are about to clear the __right__ right for yourself. Continue?\nrightsmanager.clearrightforcurrentuserinstead=Would you like to clear the __right__ right for yourself instead?\nrightsmanager.denyrightforgroup=You are about to deny the __right__ right for  __name__. This implies denying your own __right__ right, if you are part of this group. Continue?\nrightsmanager.clearrightforgroup=You are about to clear the __right__ right for __name__. This implies clearing your own __right__ right, if you are part of this group. Continue?\nrightsmanager.clearrightforgroupinstead=Would you like to clear the __right__ right for __name__ instead? This implies clearing your own __right__ right, if you are part of this group. Continue?\nrightsmanager.username=User Name\nrightsmanager.firstname=First Name\nrightsmanager.lastname=Last Name\nrightsmanager.groupname=Group Name\nrightsmanager.displayrows=Displaying rows\nrightsmanager.searchfilter=Search filter:\nrightsmanager.searchscope=Search scope:\nrightsmanager.guestcommentrequirescaptcha=Require unregistered users to solve a CAPTCHA when posting a comment on a page\n\nui.ajaxTable.outof=out of\nui.ajaxTable.loading=Loading...\n\nplatform.core.rightsManagement.editRightsForSpace=Editing access rights for space {0}\nplatform.core.rightsManagement.ajaxFailure=An error occurred while communicating with the server. Please check that the server is accessible, and you have the proper rights to perform the requested action.\nplatform.core.rightsManagement.saveFailure=An exception occurred while trying to save the current modifications. Please check if you have the proper rights to perform these modifications.\nplatform.core.rightsManagement.saveComment={0} {1} right for {2}\n### For accessibility concerns, needs to contain both the current state and the purpose.\nplatform.core.rightsManagement.allowed=Allowed. Click to deny.\n### For accessibility concerns, needs to contain both the current state and the purpose.\nplatform.core.rightsManagement.denied=Denied. Click to switch to undefined.\n### For accessibility concerns, needs to contain both the current state and the purpose.\nplatform.core.rightsManagement.undefined=Undefined. Click to allow.\n\nplatform.core.rendering.error.readTechnicalInformation=Read technical information related to this error\nplatform.core.rendering.noRendererForSectionEdit=This page's syntax doesn't support section editing!\n\nplatform.core.errorMessageType=Error\nplatform.core.noticeMessageType=Notice\nplatform.core.warningMessageType=Warning\nplatform.core.invalidUrl=This is not a valid URL\nplatform.core.action.objectRemove.noClassnameSpecified=No object type specified.\nplatform.core.action.objectRemove.noObjectSpecified=No object specified.\nplatform.core.action.objectRemove.invalidObject=Invalid object specified.\nplatform.core.action.deleteAttachment.noAttachment=This attachment does not exist.\ncore.action.deleteAttachment.failed=Failed to delete attachment {0}\ncore.action.upload.failure=Failed to upload {0,choice,0#files|1#one file|1<{0} files}.\ncore.action.upload.failure.title=Uploading files to <a href=\"{1}\">{0}</a>\ncore.action.upload.failure.failedFiles=Internal failure while attaching:\ncore.action.upload.failure.wrongFileNames=The following file names are not supported:\ncore.action.upload.failure.noFiles=No files to attach were found in the request.\n\n### XWikiExplorer JS Widget\nxwikiexplorer.page.hint=Located in\nxwikiexplorer.addpage.title=New page...\nxwikiexplorer.addpage.hint=New page in\nxwikiexplorer.attachments.title=Attachments\nxwikiexplorer.attachments.hint=Attachments of\nxwikiexplorer.attachment.hint=Attached to\nxwikiexplorer.addattachment.title=Upload file...\nxwikiexplorer.addattachment.hint=Upload file to\n\n\n### Tag application\nxe.tag.tags=Tags\nxe.tag.tagclass=XWiki Tag Class\nxe.tag.tagcloud=Tag Cloud\nxe.tag.notags=No page has been tagged yet\nxe.tag.notagsforspace=No tag has been added on this page or on its children\nxe.tag.tooltip={0,choice,1#1 page|1<{0} pages}\nxe.tag.alldocs=All pages tagged with {0}\nxe.tag.activity=Activity Stream for pages tagged with {0}\nxe.tag.rename=Rename\nxe.tag.rename.success=Tag {0} has been successfully renamed.\nxe.tag.rename.failure=Renaming of tag {0} to {1} failed.\nxe.tag.rename.renameto=Rename {0} to:\nxe.tag.rename.link=Rename\nxe.tag.delete=Delete tag {0}\nxe.tag.delete.success=Tag {0} has been successfully deleted.\nxe.tag.delete.failure=Deletion of tag {0} failed.\nxe.tag.delete.link=Delete\ncore.tags.list.label=Tags:\ncore.tags.add.tooltip=Add tags\ncore.tags.add.label=Comma separated tags:\ncore.tags.add.submit=Add\ncore.tags.add.cancel=Cancel\ncore.tags.add.error.alreadySet=This tag is already set\ncore.tags.add.error.notAllowed=You are not allowed to tag this page\ncore.tags.add.error.failed=Failed to add tag \"{0}\" due to an internal server error\ncore.tags.remove.tooltip=Delete this tag from the page\ncore.tags.remove.error.notFound=This tag is not set\ncore.tags.remove.error.notAllowed=You are not allowed to remove tags from this page\ncore.tags.remove.error.failed=Failed to remove tag \"{0}\" due to an internal server error\ncore.tags.adding=Adding tag...\ncore.tags.deleting=Deleting tag...\ncore.tags.fetchform=Fetching form...\nxe.tag.paramerror=Do not use \"space\" and \"spaces\" parameter in the same time\n\n### Page footer\ndocextra.annotations=Annotations\ndocextra.comments=Comments\ndocextra.children=Children\ndocextra.attachments=Attachments\ndocextra.history=History\ndocextra.information=Information\ndocextra.extranb=({0})\ndocextra.parent=Parent\ndocextra.backlinks=Backlinks\ndocextra.creation=Creation\ndocextra.createdby=by {0} on {1}\ndocextra.includedpages=Included pages\ndocextra.siblings=Siblings\ncore.tagedit.title=Tags\ntags.save=Save\ntags.save.success=Tags saved successfuly\ntags.save.error=An error occurred while saving tags\n\ncore.links.content=Content\n\n# Recent Members (XWiki Enterprise wiki)\nxe.recentmembers=Recent Members\n\n### Activity Macro (since XWiki Enterprise 2.6RC2)\nxe.activity=Activity Stream\nxe.activity.rssfeed=RSS feed\nxe.activity.noentries=There are no activities in the stream\n\nxe.activity.action.create=created the page\nxe.activity.action.delete=deleted the page\nxe.activity.action.update=edited the page\nxe.activity.action.BlogPostPublishedEvent=published a blog post\nxe.activity.action.addAnnotation=added an annotation\nxe.activity.action.deleteAnnotation=deleted an annotation\nxe.activity.action.updateAnnotation=edited an annotation\nxe.activity.action.addAttachment=added {0,choice,1#an attachment|1<{0} attachments}\nxe.activity.action.deleteAttachment=deleted an attachment\nxe.activity.action.updateAttachment=edited {0,choice,1#an attachment|1<{0} attachments}\nxe.activity.action.addComment=added a comment\nxe.activity.action.deleteComment=deleted a comment\nxe.activity.action.updateComment=edited a comment\nxe.activity.action.summary={0,choice,1#one change|1<{0} changes} by {1,choice,1#one user|1<{1} users}\nxe.activity.action.seechanges=see changes\nxe.activity.action.personalMessage=posted the message\nxe.activity.action.directMessage=says:\nxe.activity.action.groupMessage=posted the message\nxe.activity.action.publicMessage=posted the message\n\nxe.activity.messages.visibility=Visible to\nxe.activity.messages.visibility.targetName.tip=Name\nxe.activity.messages.submit=Share\nxe.activity.messages.submit.inProgress=Sending...\nxe.activity.messages.submit.failed=Failed to send message\nxe.activity.messages.submit.success=Message sent\nxe.activity.messages.follow=Follow\nxe.activity.messages.following=Following\nxe.activity.messages.unfollow=Unfollow\nxe.activity.messages.follow.inProgress=Updating...\nxe.activity.messages.follow.failed=Failed to add:\nxe.activity.messages.unfollow.confirm=Are you sure you wish to stop following {0}?\nxe.activity.messages.delete=Delete this message\nxe.activity.messages.delete.confirm=Are you sure you wish to delete this message?\nxe.activity.messages.delete.failed=Failed to delete the message\nxe.activity.messages.delete.success=Message deleted\nxe.activity.messages.error.loginToSendMessage=You need to [[log in>>{0}]] before sending messages.\nxe.activity.messages.inactive=The Message feature is currently turned off. You can turn it on from the [[administration>>{0}]].\n\n###timeAgo used by Recent Activity macro (XE 2.6RC1) and Activity macro\ntimeAgo.minutesAgo={0,choice,0#few seconds|1#one minute|1<{0} minutes} ago\ntimeAgo.hoursAgo={0,choice,0#less than one hour|1# one hour|1<{0} hours} ago\ntimeAgo.daysAgo={0,choice,0#less than one day|1# one day|1<{0} days} ago\ntimeAgo.monthsAgo={0,choice,0#less than month|1# one month|1<{0} months} ago\ntimeAgo.yearsAndMonthsAgo={0,choice,0#|1# one year|1<{0} years} {1,choice,0#|1#and one month|1<and {1} months} ago\ntimeAgo.today=Today\ntimeAgo.yesterday=Yesterday\n\n### Administration application\nadmin.main.title=Administration\nadmin.switchContext=Go\n\n### categories\nadmin.lf=Look & Feel\nadmin.lf.description=Change the aspect and layout of the wiki.\nadmin.usersgroups=Users & Rights\nadmin.usersgroups.description=Manage users, groups, and their access rights.\nadmin.content=Content\nadmin.content.description=Manipulate the content of the wiki.\nadmin.extensionmanager=Extensions\nadmin.extensionmanager.description=Search, add, upgrade and remove extensions.\n\n### sections\nadmin.editing=Edit Mode\nadmin.editing.description=Choose the default edit mode and configure its title and versioning parameters.\nadmin.localization=Localization\nadmin.localization.description=Language-related settings.\nadmin.programming=Programming\nadmin.programming.description=Settings related to programming in XWiki.\nadmin.ooserver=Office Server\nadmin.ooserver.options=Options\nadmin.ooserver.options.source=These options are configured on the server, in {0}.\nadmin.xwiki.officeimporteradmin.description=Configure the Office Server.\n\nadmin.presentation=Presentation\nadmin.presentation.description=Choose the page tabs that are visible and configure the page header and footer.\nadmin.panelwizard=Panel Wizard\nadmin.panels.panelwizard.description=Add and remove panels, change the page layout.\nadmin.colorthemes=Color Themes\nadmin.colorthemes.description=Settings for color themes customization.\nadmin.colorthemes.colibrithemes=Colibri Themes\nadmin.colorthemes.flamingothemes=Flamingo Themes\nadmin.colorthemes.invalidtheme=The current value ({0}) is invalid. The color theme might not exist.\nadmin.icontheme=Icon Theme\n\nadmin.users=Users\nadmin.users.description=Manage users of this wiki: add, remove, modify their profile information.\nadmin.groups=Groups\nadmin.groups.description=Manage user groups: add or remove groups, or change group members.\nadmin.registration=Registration\nadmin.registration.description=Manage user registration settings.\nadmin.rights=Rights\nadmin.rights.description=Manage groups and users rights: control who can view, edit and delete pages.\nadmin.pagerights=Rights: Page\nadmin.pagerights.description=Manage groups and users rights: control who can view, edit and delete the page. It does not affect the children.\nadmin.pagerights.info=These rights apply on this page only.\nadmin.pagerights.infoNonTerminalDoc=They do not affect the {0}children{1}.\nadmin.pageandchildrenrights=Rights: Page & Children\nadmin.pageandchildrenrights.description=Manage groups and users rights: control who can view, edit and delete the page. It affect their children.\nadmin.pageandchildrenrights.info=These rights apply on this page {0}and all {1}its children{2}{3}.\nadmin.userprofile=User Profile\nadmin.userprofile.description=Manage what information is displayed on the user profile of each user.\n\nadmin.import=Import\nadmin.import.description=Import pages or applications into the wiki.\nadmin.export=Export\nadmin.export.description=Export wiki pages into a XAR.\n\nadmin.xwiki.extensions.description=Search for new extensions to add to the wiki.\nadmin.xwiki.extensionhistory.description=See the history of the installed extensions.\nadmin.xwiki.extensionupdater.description=Check if there are any updates available for the installed extensions.\n\nadmin.globaladmin=Wiki Preferences\nadmin.spaceadmin=Space Preferences\nadmin.placetoadminister=Place to administer\nadmin.gotoglobaladministration=Edit Wiki Preferences:\nadmin.globaladministration=Wiki Administration\nadmin.gotospaceadministration=Edit Space Preferences:\nadmin.showsections=Show the available categories\nadmin.hidesections=Hide the available categories\nadmin.documentation=Help on this setting\nadmin.general=General settings\nadmin.authentification=Authentication\nadmin.docextra=Page Tabs\nadmin.language=Language\nadmin.date=Date / Time\nadmin.editor=Editor\nadmin.versioning=Versioning\nadmin.smtp=SMTP\nadmin.header=Header\nadmin.panels=Panels\nadmin.footer=Footer\nadmin.skin=Skin\nadmin.messagestream=Message Stream\nadmin.messagestream.description=Enable or disable the message stream in the wiki.\nadmin.colortheme=Color Theme\nadmin.colortheme.wikiSetting=The color theme configured at the wiki level is {0}.\nadmin.colortheme.manage=Manage color themes\\u00BB\nadmin.customize=Customize\nadmin.save=Save\nadmin.defaultwikinotinstalled_useflavor=Your wiki seems empty. You may want to {0}install a flavor{1}, it will bring you a lot of features: user profiles, recent activity, administration pages and many more.\nadmin.adminappnotinstalled=The administration application is not installed. Since XWiki Enterprise 1.5, the Administration is distributed as an application. You can download it from {0}.\nadmin.preferences.title=Preferences\n\n### Account validation\nxe.admin.accountvalidation.success=Your account has been activated. You can now <a href=\"{0}\">login</a>.\nxe.admin.accountvalidation.failure=There was a problem validating your account. Please contact an administrator.\n### Group management\nxe.admin.groups.member=Member\nxe.admin.groups.type=Type\nxe.admin.groups.type.user=User\nxe.admin.groups.type.group=Group\nxe.admin.groups.scope=Scope\nxe.admin.groups._actions=Actions\nxe.admin.groups._actions.delete=Remove\nxe.admin.groups.addUser=Users to add\nxe.admin.groups.addUser.submit=Add\nxe.admin.groups.addGroup=Subgroups to add\nxe.admin.groups.addSuccess=Members successfully added\nxe.admin.groups.addFailure=Failed to add members to group:\nxe.admin.groups.filter.groupName=Group name filter\nxe.admin.groups.filter.scope=Groups scope\nweb.groups.administration.groupsIgnored=Members successfully added but some groups have been ignored ({0})\n\nxe.admin.groups.loading=Loading...\nxe.admin.groups.name=Group Name\nxe.admin.groups.members=Members\nxe.admin.groups.manage=Manage\nxe.admin.groups.local=Local\nxe.admin.groups.global=Global\nxe.admin.groups.both=Both\nxe.admin.groups.create=Create a new group\nxe.admin.groups.create.inProgress=Creating the group...\nxe.admin.groups.create.done=Group created\nxe.admin.groups.create.failed=Failed to create the group\nxe.admin.groups.creategroup=Create group\nxe.admin.groups.editGroup=Edit group\nxe.admin.groups.deleteGroup=Delete group\nxe.admin.groups.delete.inProgress=Deleting the group...\nxe.admin.groups.delete.done=Group deleted\nxe.admin.groups.delete.failed=Failed to delete the group\nxe.admin.groups.currentgroups=Existing groups\nxe.admin.groups.administration=XWiki groups administration pages\n\nxe.admin.groups._avatar=Picture\nxe.admin.groups.email=Email\nxe.admin.groups.company=Company\nxe.admin.groups.phone=Phone\nxe.admin.groups.emptyvalue=-\n\n### User management\nxe.admin.users.loading=Loading...\nxe.admin.users=Users\nxe.admin.users.registernew=Register a new user\nxe.admin.users.existing=Existing user accounts\nxe.admin.users.administration=XWiki users administration pages\nxe.admin.users.sheet=User Sheet\nxe.admin.users.applyonusers=This stylesheet must be applied on a page containing a XWiki.XWikiUsers object.\nxe.admin.users.name=User\nxe.admin.users.first_name=First Name\nxe.admin.users.last_name=Last Name\nxe.admin.users.scope=Scope\nxe.admin.users._actions=Actions\nxe.admin.users._actions.disable=Disable\nxe.admin.users._actions.enable=Enable\nxe.admin.users.editUser=Edit user\nxe.admin.users.deleteUser=Delete user\nxe.admin.users.delete.inProgress=Deleting the user\\u2026\nxe.admin.users.delete.done=User deleted\nxe.admin.users.delete.failed=Failed to delete the user\nxe.admin.users.create.inProgress=Creating the user\\u2026\nxe.admin.users.create.done=User created\nxe.admin.users.create.failed=Failed to create the user\n\n### User profile management\nplatform.user.profileConfigureSectionsTitle=Displayed sections\nplatform.user.profileConfigureSectionsLabel=Section IDs\nplatform.user.profileConfigureSectionsHint=Space or newline separated list of section IDs to be displayed from the list of sections defined below.\nplatform.user.profileConfigureSectionsAllTitle=All sections\nplatform.user.profileConfigureSectionAddButtonLabel=Add\nplatform.user.profileConfigureSectionRemoveButtonLabel=Remove\nplatform.user.profileConfigureSectionIdLabel=Section ID\nplatform.user.profileConfigureSectionIdHint=Unique identifier of this section. Must not contain spaces.\nplatform.user.profileConfigureSectionNameLabel=Section Name\nplatform.user.profileConfigureSectionNameHint=Display name of this section. This can be a fixed string or a [[translation key>>{0}]] (Example: $services.localization.render(''key'')).\nplatform.user.profileConfigureSectionPropertiesLabel=Section Properties\nplatform.user.profileConfigureSectionPropertiesHint=Space or newline separated list of properties of the [[{0}]] class to display in this section. An optional [[microformats>>http://en.wikipedia.org/wiki/Microformat]] class can prefix the property name (Example: given-name:first_name family-name:last_name).\nplatform.user.profileConfigureSaveButtonLabel=Save\n\n### Skin\nxe.admin.skin=Skin\nxe.admin.skin.makeyourown=You can modify the existing look and feel and even create your own.\nxe.admin.skin.editskin=Edit this skin\nxe.admin.skin.testskin=Test this skin\n\n### Username recovery\nxe.admin.forgotUsername.loginMessage=Forgot your username?\nxe.admin.forgotUsername.title=Forgot your username?\nxe.admin.forgotUsername.instructions=Please enter the email address you provided when creating your account.\nxe.admin.forgotUsername.email.label=Email address\nxe.admin.forgotUsername.submit=Retrieve username\nxe.admin.forgotUsername.login=Login \\u00BB\nxe.admin.forgotUsername.error.retry=\\u00AB Try again using another email address\nxe.admin.forgotUsername.error.emailFailed=An unknown problem occurred while sending the forgot username email.\nxe.admin.forgotUsername.emailSent=If an account is registered with this email, you will receive the account information on {0}.\n\n### Password reset\nxe.admin.passwordReset.loginMessage=Forgot your password?\n\nxe.admin.passwordReset.title=Forgot your password?\nxe.admin.passwordReset.instructions=Please enter your username to start the password reset process.\nxe.admin.passwordReset.username.label=Username\nxe.admin.passwordReset.submit=Reset password\nxe.admin.passwordReset.emailSentToUsername=An e-mail was sent to the address configured for user \"{0}\". Please follow the instructions in that e-mail to complete the password reset procedure.\nxe.admin.passwordReset.login=Login \\u00BB\nxe.admin.passwordReset.error.noUser=The {0} user does not exist.\nxe.admin.passwordReset.error.ldapUser=The {0} user is an LDAP user. In that case the password has to be changed on the LDAP server.\nxe.admin.passwordReset.error.noEmail=Cannot reset password: email address not provided in the user profile.\nxe.admin.passwordReset.error.emailFailed=An unknown problem occurred while sending the reset email.\nxe.admin.passwordReset.error.retry=\\u00AB Retry username\nxe.admin.passwordReset.error.recoverUsername=Forgot your username?\nxe.admin.passwordReset.versionComment=Generated password reset token\nxe.admin.passwordReset.error.csrf=Bad CSRF token, you need to perform the procedure again.\n\nxe.admin.passwordReset.step2.title=Reset your password\nxe.admin.passwordReset.step2.newPassword.label=New password\nxe.admin.passwordReset.step2.newPasswordVerification.label=Re-enter new password\nxe.admin.passwordReset.step2.submit=Save\nxe.admin.passwordReset.step2.success=The password has been successfully set.\nxe.admin.passwordReset.step2.login=Please login to continue \\u00BB\nxe.admin.passwordReset.step2.backToStep1=Back to the password reset page \\u00BB\nxe.admin.passwordReset.step2.error.emptyPassword=The password cannot be empty.\nxe.admin.passwordReset.step2.error.verificationMismatch=The two passwords do not match.\nxe.admin.passwordReset.step2.error.wrongParameters=Wrong parameters! Another link was already sent or this one was already accessed!\nxe.admin.passwordReset.step2.error.noProgrammingRights=This page requires programming rights to work, which currently isn't the case. Please notify an administrator of this problem and try again later.\nxe.admin.passwordReset.step2.versionComment.passwordReset=Password was reset\nxe.admin.passwordReset.step2.versionComment.changeValidationKey=Refreshed password reset token\n\n### XWiki.Configurable - application configuration\nxe.admin.configurable.title=Custom configurable sections\nxe.admin.configurable.macros.title=Macros for custom configurable sections\nxe.admin.configurable.noPermissionThisApplication=You don't have permission to configure this application.\nxe.admin.configurable.applicationAuthorNoAdmin=This configuration cannot be displayed because it was last edited by [[{0}]] who doesn''t have permission to edit this page.\nxe.admin.configurable.cannotLockNoJavascript=This page cannot be locked for editing because Javascript is turned off. For page editing safety, please enable Javascript.\nxe.admin.configurable.configurationClassNonexistant=No class found by the name {0}, can''t display configuration.\nxe.admin.configurable.noObjectOfConfigurationClassFound=No object of class: {0} found in page {1}, can''t display configuration.\nxe.admin.configurable.sectionIconNoAccess=(No Access)\nxe.admin.configurable.sectionIconNoAccessTooltip=You don't have permission to configure this section.\nxe.admin.configurable.noViewAccessSomeApplications=Some sections may not be displayed because you do not have view access to some configurable applications including: {0}\n### XWiki.Registration\nxe.admin.registration.passwordTooShort=Please use a longer password.\nxe.admin.registration.passwordMismatch=The passwords do not match.\nxe.admin.registration.invalidEmail=Please enter a valid email address.\nxe.admin.registration.youCanConfigureRegistrationHere=You can configure this application by clicking here.\nxe.admin.registration.youCanConfigureRegistrationFieldsHere=You can add, remove and change fields in this form by clicking here.\nxe.admin.registration.fieldWithNoName=ERROR: Field with no name.\n\n### Attachment picker macro\nxe.attachmentSelector.gallery.title=Attachments\nxe.attachmentSelector.upload.title=Add\nxe.attachmentSelector.upload.hint=Accepted formats: {0}\nxe.attachmentSelector.upload.submit=Upload and select\nxe.attachmentSelector.selectFile=Choose an attachment\nxe.attachmentSelector.default=Default\nxe.attachmentSelector.supportedFormats=Accepted formats: {0}\nxe.attachmentSelector.actions.select=Select\nxe.attachmentSelector.actions.delete=Delete\nxe.attachmentSelector.actions.view=View\nxe.attachmentSelector.actions.download=Download\nxe.attachmentSelector.upload.error.noFile=Please choose a file to upload\nxe.attachmentSelector.upload.error.badExtension=Unsupported file format\nxe.attachmentSelector.upload.inProgress=Uploading...\nxe.attachmentSelector.cancel=Cancel and return to page\nxe.attachmentSelector.postUpload.comment=Update field {0}\n\n### Users Directory\nxe.userdirectory.title=User Directory\nxe.userdirectory.customizeSaveButtonLabel=Save\nxe.userdirectory.customizeResetButtonLabel=Reset to default\nxe.userdirectory.customizePreviewTitle=Preview\nxe.userdirectory.isCustomizedWarning=You are viewing a customized user directory. You can [[reset it to default>>{0}||queryString=\"{1}\"]] or [[customize>>{2}||queryString=\"{3}\"]] it further.\nxe.userdirectory.canCustomizeInfo=The user directory can be [[customized>>{0}||queryString=\"{1}\"]] to display the columns you wish to see.\nxe.userdirectory.canCustomizeInfoGuest=The user directory can be customized to display the columns you wish to see, but you need to [[log in>>{0}]] first.\nxe.userdirectory._avatar=Picture\nxe.userdirectory.doc.name=User ID\nxe.userdirectory.emptyvalue=\nadmin.userdirectory=User Directory\nadmin.userdirectory.description=Customize the user directory live table.\n\n####################\n# Translations for Invitation Application\n####################\n\n### Invitation section of administration interface.\nadmin.invitation=Invitation\nadmin.invitation.description=Configure the Invitation Application\nxe.invitation.heading=Invitation Messenger\nxe.invitation.userIsReportedSpammer=A message which you sent was reported as spam and your privilege to send mail has been suspended pending investigation, we apologize for the inconvenience.\nxe.invitation.internalDocument=This page is used by the [[invitation application>>{0}]]\nxe.invitation.onlyMembersCanSendMail=Sorry, only members of this wiki can send mail.\nxe.invitation.youAreAMemberOfOtherWiki=You seem to be a member of {0} which is a different wiki.\nxe.invitation.toLabel=To:\nxe.invitation.subjectLabel=Subject:\nxe.invitation.contentLabel=Message:\nxe.invitation.previewLabel=Preview:\nxe.invitation.errorWhileSending=An error has occurred while sending the message.\nxe.invitation.successSending=Your message has been sent.\nxe.invitation.messageSentLogEntry=Message sent\nxe.invitation.noValidMessagesToSend=Your message could not be sent because there were no valid email addresses to send to.\nxe.invitation.noMessageFound=No message found by that id.\nxe.invitation.guestsCanNotJoin=Invitations can not be accepted because this wiki is closed. To allow invitees to join, save [[{0}]] as a user with Programming Rights.\nxe.invitation.failedToCreateDocuments=Failed to create pages necessary for Invitation application to function.\n\nxe.invitation.emailContent.subjectLine={0} has invited you to join {1} {2}\nxe.invitation.emailContent.userHasInvitedYouToJoinWiki=You have received this mail because {0} has invited you to join {1}.\nxe.invitation.emailContent.joinLink=Accept the invitation and join\nxe.invitation.emailContent.declineLink=Decline\n### reportMessage expects the opening link tag to be passed as the parameter.\nxe.invitation.emailContent.reportMessage=If this message looks like abuse of our system, please {0}report it{1}\n\nxe.invitation.sendMail.addMessageSaveComment=Added Email Message(s).\n\nxe.invitation.displayOldMessage.heading=Inspect sent message\nxe.invitation.displayOldMessage.noMessageFound=No message by this id was found.\nxe.invitation.displayOldMessage.reportedAsSpam=Reported as spam\nxe.invitation.displayOldMessage.waitingToBeInvestigated=Waiting to be investigated\nxe.invitation.displayOldMessage.viewMessage=View Message\nxe.invitation.displayOldMessage.sentBy=Sent by:\nxe.invitation.displayOldMessage.markThisMessageAsInvestigated=Mark this message as investigated.\n\nxe.invitation.displayAllOldMessages.status=Message Status\nxe.invitation.displayAllOldMessages.viewMessagesSentByUsers=View messages sent by users\nxe.invitation.displayAllOldMessages.sender=Sender\nxe.invitation.displayAllOldMessages.subject=Subject\nxe.invitation.displayAllOldMessages.memo=Notes:\n\nxe.invitation.displayMessageTable.sentDate=Date\nxe.invitation.displayMessageTable.sendingUser=Sender\nxe.invitation.displayMessageTable.subjectLine=Subject\nxe.invitation.displayMessageTable.status=Status\nxe.invitation.displayMessageTable.memo=Memo\nxe.invitation.displayMessageTable.recipient=Email\nxe.invitation.displayMessageTable.history=Message History\nxe.invitation.displayMessageTable.showHistory=Show History\nxe.invitation.displayMessageTable.multipleRecipients={0} Recipients\nxe.invitation.displayMessageTable.various=<various>\nxe.invitation.displayMessageTable.noMessages=No messages to display\n\nxe.invitation.displayMessageTableInForm.buttonLabel.cancel=Rescind Invitation\nxe.invitation.displayMessageTableInForm.buttonLabel.notSpam=Mark as not spam\n\nxe.invitation.doAction.confirmLabel=Confirm\nxe.invitation.doAction.lackingPermission=You do not have permission to do this action.\nxe.invitation.doAction.invitationCanceledMemo={0} left you this message when rescinding the invitation.\nxe.invitation.doAction.invalidStatus=This request cannot be processed because the status of this invitation is {0}.\n\nxe.invitation.doAction.reportSpam.heading=Report Abuse\nxe.invitation.doAction.reportSpam.noMessageFound=There was no message found by the given ID. Maybe an administrator deleted the message from our system.\nxe.invitation.doAction.reportSpam.success=Your report has been logged and the situation will be investigated as soon as possible, we apologize for the inconvenience.\nxe.invitation.doAction.reportSpam.reportSaveComment=Reported message as spam.\nxe.invitation.doAction.reportSpam.areYouSure=Are you sure you would like to report this message as abuse?\nxe.invitation.doAction.reportSpam.memoLabel=Note to the administrator who investigates this report (optional)\n\nxe.invitation.doAction.accept.heading=Accept invitation\nxe.invitation.doAction.accept.saveComment=Invitation accepted.\nxe.invitation.doAction.accept.noMessageFound=No message was found by the given ID. It might have been deleted or maybe the system is experiencing difficulties.\nxe.invitation.doAction.accept.invitationCanceled=We're sorry but this invitation has been rescinded.\nxe.invitation.doAction.accept.alreadyReportedAsSpam=This invitation has been reported as spam and is no longer valid.\nxe.invitation.doAction.accept.alreadyDeclined=This invitation has been declined and cannot be accepted now.\nxe.invitation.doAction.accept.alreadyAccepted=This invitation has already been accepted and the offer is no longer valid.\nxe.invitation.doAction.accept.improperConfiguration=This invitation cannot be accepted because the wiki is not configured to allow new users.\n\nxe.invitation.doAction.decline.heading=Decline invitation\nxe.invitation.doAction.decline.memoLabel=Message to {0} (optional)\nxe.invitation.doAction.decline.confirmLabel=Decline invitation\nxe.invitation.doAction.decline.saveComment=Invitation Declined\nxe.invitation.doAction.decline.alreadyReportedAsSpam=This invitation has already been reported as spam and thus cannot be declined.\nxe.invitation.doAction.decline.invitationCanceled=This invitation has been rescinded and thus cannot be declined.\nxe.invitation.doAction.decline.alreadyDeclined=This invitation has already been declined and cannot be declined again.\nxe.invitation.doAction.decline.alreadyAccepted=This invitation has already been accepted and now cannot be declined.\nxe.invitation.doAction.decline.noMessageFound=No invitation was found by the given ID. It might have been deleted or maybe the system is experiencing difficulties.\nxe.invitation.doAction.decline.success=This invitation has successfully been declined.\n\nxe.invitation.doUserActionOnMultipleMessages.notPossibleOnMultipleMessages=This action is not possible on multiple messages.\nxe.invitation.doUserActionOnMultipleMessages.confirmLabel=Confirm\nxe.invitation.doUserActionOnMultipleMessages.noMessagesFound=No messages were found for the provided IDs.\nxe.invitation.doUserActionOnMultipleMessages.noMessagesAffected=This action cannot be carried out because all of the messages selected are of the wrong status.\n\nxe.invitation.doUserActionOnMultipleMessages.notSpam.successMessage=Invitation successfully marked as not spam. Log entry: {0}\nxe.invitation.doUserActionOnMultipleMessages.notSpam.heading=Mark message as not spam or situation handled.\nxe.invitation.doUserActionOnMultipleMessages.notSpam.memoLabel=Synopsis of findings and/or action taken\nxe.invitation.doUserActionOnMultipleMessages.notSpam.confirmLabel=Return email privilege\nxe.invitation.doUserActionOnMultipleMessages.notSpam.reportHandledSaveComment={0} investigated spam report.\n\nxe.invitation.doUserActionOnMultipleMessages.cancel.heading=Rescind invitations\nxe.invitation.doUserActionOnMultipleMessages.cancel.saveComment={0} invitations were rescinded by {1}\nxe.invitation.doUserActionOnMultipleMessages.cancel.success=Invitation successfully rescinded.\nxe.invitation.doUserActionOnMultipleMessages.cancel.memoLabel=Leave a message in case the invitee(s) try to register.\nxe.invitation.doUserActionOnMultipleMessages.cancel.someMessagesNotFound={0} of the {1} invitations to rescind could not be found.\nxe.invitation.doUserActionOnMultipleMessages.cancel.areYouSure.OneMessage=Are you sure you want to rescind this invitation?\nxe.invitation.doUserActionOnMultipleMessages.cancel.areYouSure.OneMessagePerGroup=Are you sure you want to rescind these {0} invitations?\nxe.invitation.doUserActionOnMultipleMessages.cancel.areYouSure.multipleMessagesMultipleGroups=Are you sure you want to rescind these {0} invitations to {1} recipients?\n\nxe.invitation.displayMessage.anAddressesIsInvalid=One of the given email addresses is invalid and will not receive a message.\nxe.invitation.displayMessage.someAddressesAreInvalid={0} of the given email addresses are invalid and will not receive a message.\nxe.invitation.displayMessage.theAddressIsInvalid=The email address given is invalid and will not receive a message.\nxe.invitation.displayForm.sendMail=Send Mail\nxe.invitation.displayForm.backToEdit=Back To Edit\nxe.invitation.displayForm.preview=Preview\n\nxe.invitation.tools.heading=Tools\nxe.invitation.tools.myInvitationsLink=My Invitations\nxe.invitation.tools.invitationsInGroup=Invitations in this Message Group\nxe.invitation.tools.invitationHistory=History of this Invitation\nxe.invitation.tools.senderLink=Send Invitations\n\nxe.invitation.adminTools.heading=Administrative Tools\nxe.invitation.adminTools.configureLink=Configure the Invitation Application\nxe.invitation.adminTools.allInvitationsLink=All Invitations\n\nxe.invitation.configuration.smtpHeading=SMTP Settings\n\nxe.invitation.setMessageStatus=Message status set to {0} by user {1}. Log: {2}\nxe.invitation.displayMessageHistory.messageStatusSetTo=Message status set to\nxe.invitation.displayMessageHistory.setByUser=By user\nxe.invitation.displayMessageHistory.logEntry=Log Entry\nxe.invitation.inspectMessages.lastEntryInfoBox={0} with message: {1}\n\nxe.invitation.messageStatus.unsent=Unsent\nxe.invitation.messageStatus.pending=Pending\nxe.invitation.messageStatus.accepted=Accepted\nxe.invitation.messageStatus.declined=Declined\nxe.invitation.messageStatus.canceled=Rescinded\nxe.invitation.messageStatus.reported=Reported as spam\nxe.invitation.messageStatus.investigated=Spam report investigated\nxe.invitation.messageStatus.unknown=Unknown status ({0})\nxe.invitation.messageStatus.sendingFailed=Failed to send message\n\n### Office importer application\nxe.officeimporter.notallowed=Guests are not allowed to view the contents of this page.\nxe.officeimporter.error.normaluser=This application requires an active Office Server which we could not locate. Please contact your administrator to resolve this issue.\nxe.officeimporter.error.adminuser=You need to setup an Office Server to make the Office Importer application available to your users. Please look at the Office Importer {0}documentation{1} for instructions on how to setup and configure an Office Server.\nxe.officeimporter.import.title=Office Importer\nxe.officeimporter.import.document=Office document\nxe.officeimporter.import.target=Target page\nxe.officeimporter.import.filterstyles=Filter styles\nxe.officeimporter.import.help.styles=Strip out unnecessary styling information from the result.\nxe.officeimporter.import.splitting.splitdocument=Split document\nxe.officeimporter.import.help.splitting=Create multiple pages from a single office document.\nxe.officeimporter.import.splitting.headinglevels=Heading levels to split\nxe.officeimporter.import.splitting.heading=Heading\nxe.officeimporter.import.splitting.naming=Child pages naming\nxe.officeimporter.import.splitting.naming.headingnames=Heading names\nxe.officeimporter.import.splitting.naming.mainpagenameandheading=Main page name and heading\nxe.officeimporter.import.splitting.naming.mainpagenameandnumbering=Main page name and numbering\nxe.officeimporter.import.import=Import\nxe.officeimporter.results.title=Office Importer Results\nxe.officeimporter.results.goback=Go back\nxe.officeimporter.results.missingfile=Missing input file. Please {0} and correct it.\nxe.officeimporter.results.result=result\nxe.officeimporter.results.success=Conversion succeeded. You can view the {0}, or you can {1} to convert another document.\nxe.officeimporter.openoffice.parameter=Parameter\nxe.officeimporter.openoffice.value=Value\nxe.officeimporter.openoffice.yes=Yes\nxe.officeimporter.openoffice.no=No\nxe.officeimporter.openoffice.servertype=Server type\nxe.officeimporter.openoffice.servertype.internal=Internally managed (local)\nxe.officeimporter.openoffice.servertype.external=Externally managed (local)\nxe.officeimporter.openoffice.servertype.remote=Externally managed (remote)\nxe.officeimporter.openoffice.serverport=Server port\nxe.officeimporter.openoffice.autostart=Auto start\nxe.officeimporter.openoffice.autoconnect=Auto connect\nxe.officeimporter.openoffice.serverpath=Server path\nxe.officeimporter.openoffice.serverprofile=Server profile\nxe.officeimporter.openoffice.serverprofile.default=Default profile\nxe.officeimporter.openoffice.serverstate=Server state\nxe.officeimporter.openoffice.actions=Actions\nxe.officeimporter.openoffice.actions.start=Start server (connect)\nxe.officeimporter.openoffice.actions.connect=Connect\nxe.officeimporter.openoffice.actions.stop=Stop server (disconnect)\nxe.officeimporter.openoffice.actions.disconnect=Disconnect\nxe.officeimporter.openoffice.actions.restart=Restart server\nxe.officeimporter.openoffice.update=Update\nxe.officeimporter.openoffice.limitedcontrol=The Office Server can only be controlled from the main wiki.\noffice.configuration.serverpath.error.notSetNotAutodetected=Not set / Not autodetected\n\n### Panels application\nxe.panels.classedit.youare=You are editing\nxe.panels.classedit.chooseproperty=Choose a property to edit or add a property to the class.\nxe.panels.classedit.editother=Edit another class\nxe.panels.classedit.unsavedchanges=Unsaved changes will be lost when switching to another class.\nxe.panels.switchclass=Switch class\nxe.panels.create.panel=Create new panel:\nxe.panels.create.title=Panel Title\nxe.panels.rights.welcomeglobal=Welcome to the global rights editor.\nxe.panels.rights.space=Rights applied to a space replace rights applied to the whole wiki.\nxe.panels.rights.warning=Warning:\nxe.panels.rights.noauthentication=Without any authentication forcing and any rights specified a Wiki is public for viewing and editing by default.\nxe.panels.document.information=XWiki page information\nxe.panels.includedDocs.title=Included pages\nxe.panels.includedDocs.count={0,choice,0#No|1#One|1<{0}} included {0,choice,0#pages.|1#page:|1<pages:}\nxe.panels.last.members=Last Members\nxe.panels.members.name=Name\nxe.panels.members.photo=Photo\nxe.panels.members.viewall=View All\nxe.panels.modifications.my=My Recent Modifications\nxe.panels.navigation=Navigation\nxe.panels.new.itemType=Type of the item\nxe.panels.new.page=New Page (current space)\nxe.panels.new.space=New Space\nxe.panels.new.name=Name\nxe.panels.orphaned=Orphaned Pages\nxe.panels.wizard.savenew=Save\nxe.panels.wizard.revert=Reset\nxe.panels.wizard.homepage=Go to Panels\nxe.panels.edit=(Edit this panel)\nxe.panels.quicklinks=Quick Links\nxe.panels.quicklinks.dashboard=Dashboard\nxe.panels.quicklinks.index=Page Index\nxe.panels.quicklinks.sandbox=Sandbox\nxe.panels.quicklinks.userdirectory=User Index\nxe.panels.rights.welcome=Welcome to the rights editor.\nxe.panels.rights.explanation=Rights applied to a page replace rights applied to a space and rights applied to the whole wiki.\nxe.panels.rights.help=Rights editor help\nxe.panels.rights.users=Users\nxe.panels.rights.usersexplanation=This field should contain the wikiname of each user you want to apply the rights to. For example <em>XWiki.JohnDoe</em>. <em>XWiki.XWikiGuest</em> should be used for unidentified users.\nxe.panels.rights.groups=Groups\nxe.panels.rights.groupsexplanation=This field should contain the wikinames of groups you want to apply the rights to. <em>XWiki.XWikiAllGroup</em> represents the group of all logged-in users with an account on your Wiki.\nxe.panels.rights.groupsvirtualexplanation=<em>xwiki:XWiki.XWikiAllGroup</em> represents the group of all logged-in users using a global account.\nxe.panels.rights.accesslevels=Access levels\nxe.panels.rights.accesslevelsexplanation=This field should contain a list of access levels that you want to apply to the users and groups specified. Available access levels are: admin, programming, register, edit, view and comment. To protect your wiki in view and edit mode use \"view, edit\". To protect adding comments use \"comment\".\nxe.panels.rights.allowdeny=Allow/Deny\nxe.panels.rights.allowdenyexplanation=This field should contain <em>Allow</em> to specify that this is an allow right, and <em>Deny</em> to specify a deny right. An <em>allow</em> right means: \"this wiki, space or page is *only* visible or editable to the users or groups specified\".\nxe.panels.rights.openwiki=To open a Wiki for editing by the public:\nxe.panels.rights.opengroups=Groups: XWiki.XWikiAllGroup, xwiki:XWiki.XWikiAllGroup\nxe.panels.rights.openusers=Users: XWiki.XWikiGuest\nxe.panels.rights.openaccess=Access Levels: \"view, edit\" for a public Wiki for viewing and editing.\nxe.panels.rights.openallow=Allow/Deny: Allow\nxe.panels.rights.protectedwiki=To protect a Wiki or Space by allowing only logged-in users using an account created on your Wiki use:\nxe.panels.rights.protectedgroups=Groups: XWiki.XWikiAllGroup\nxe.panels.rights.protectedusers=Users:\nxe.panels.rights.protectedaccess=Access Levels: \"edit\" for a private wiki for editing, \"view, edit\" for a private Wiki for viewing and editing.\nxe.panels.rights.protectedallow=Allow/Deny: Allow\nxe.panels.rights.bannedgroup=To protect a Wiki or Space by disallowing banned users to edit pages use:\nxe.panels.rights.banedgroups=Groups: XWiki.XWikiBannedGroup\nxe.panels.rights.bannedusers=Users:\nxe.panels.rights.bannedaccess=Access Levels: \"edit\"\nxe.panels.rights.banneddeny=Allow/Deny: Deny\nxe.panels.rights.tips=Rights editor tips\nxe.panels.rights.publicwiki=Public wiki\nxe.panels.rights.authenticate=Authenticate on view/edit\nxe.panels.rights.banned=Banned users\nxe.panels.tagcloud.title=Tag Cloud\nxe.panels.shortcuts=Shortcuts\nxe.panels.spaces=Spaces\nxe.panels.syntax.help=XWiki Syntax Help\nxe.panels=Panels\nxe.panels.create=Create a new panel\nxe.panels.customize=You can customize the side column(s) using the\nxe.panels.welcome.xwiki=Welcome to this XWiki!\n\n### Scheduler application\nxe.scheduler.jobscheduled=Job {0} scheduled. Next fire time: {1}\nxe.scheduler.paused=Job {0} paused\nxe.scheduler.resumed=Job {0} resumed. Next fire time: {1}\nxe.scheduler.unscheduled=Job {0} unscheduled\nxe.scheduler.triggered=Job {0} triggered\nxe.scheduler=Job Scheduler\nxe.scheduler.welcome=Welcome to the Job Scheduler. This application allows you to create administration scripts that can be triggered periodically.\nxe.scheduler.jobs.list=List of existing jobs\nxe.scheduler.jobs.actions=Actions\nxe.scheduler.jobs.actions.access=Access:\nxe.scheduler.jobs.actions.view=View\nxe.scheduler.jobs.actions.edit=Edit\nxe.scheduler.jobs.actions.manage=Manage:\nxe.scheduler.jobs.actions.schedule=Schedule\nxe.scheduler.jobs.actions.pause=Pause\nxe.scheduler.jobs.actions.unschedule=Unschedule\nxe.scheduler.jobs.actions.resume=Resume\nxe.scheduler.jobs.actions.delete=Delete\nxe.scheduler.jobs.actions.trigger=Trigger\nxe.scheduler.jobs.next=Next Fire Time\nxe.scheduler.jobs.next.undefined=N/A\nxe.scheduler.jobs.status=Job Status\nxe.scheduler.jobs.name=Job Name\nxe.scheduler.job=Job\nxe.scheduler.jobs.create=Create a new job\nxe.scheduler.jobs.create.nameTip=Job name\nxe.scheduler.jobs.create.submit=Add\nxe.scheduler.jobs.explaincreate=Enter below the name of the page that will hold your job. The job will be created in the current Scheduler space.\nxe.scheduler.jobs.warning=Job creation is reserved for programmers and you don't have programming rights for the Scheduler space.\nxe.scheduler.jobs.pagename=Job page name\nxe.scheduler.job.scriptexplanation=The script is the code that will be executed when the job is triggered by the scheduler. It should be written in the Groovy language. The XWiki API is available through the **xwiki** and **context** pre-defined variables.\nxe.scheduler.job.backtolist=Back to the job list\nxe.scheduler.job.object=This sheet must be applied to a page that holds a scheduler job object.\nxe.scheduler.updateJobClassComment=Created/Updated Scheduler Job Class definition\n\n### Statistics application\nxe.statistics.activity=Activity Statistics\nxe.statistics.edits=Edits\nxe.statistics.views=Views\nxe.statistics.current.week=Current week activity\nxe.statistics.current.week.caps=Current Week Activity\nxe.statistics.current.month=Current month activity\nxe.statistics.current.month.caps=Current Month Activity\nxe.statistics.current.year=Current year activity\nxe.statistics.current.year.caps=Current Year Activity\nxe.statistics.alltime=All time activity\nxe.statistics.alltime.caps=All Time Activity\nxe.statistics.bestreferrers=Best Referrers\nxe.statistics.document=Page Statistics\nxe.statistics.contributors.leastactive=Least Active Contributors\nxe.statistics.homepage=statistics home page\nxe.statistics.disabled=The statistics module is disabled by default for improved performances. For more details, see {0}\nxe.statistics.notrecorded=No statistics recorded\nxe.statistics.referrer=Referrer\nxe.statistics.sources=Sources\nxe.statistics.user=User\nxe.statistics.changes=Changes\nxe.statistics.space=Space\nxe.statistics.hits=Hits\nxe.statistics.page=Page\nxe.statistics.contributors.mostactive=Most Active Contributors\nxe.statistics.pages.mostedited=Most Edited Pages\nxe.statistics.spaces.mostedited=Most Edited Spaces\nxe.statistics.pages.mostreferred=Most Referred Pages\nxe.statistics.pages.mostviewed=Most Viewed Pages\nxe.statistics.spaces.mostviewed=Most Viewed Spaces\nxe.statistics.referrerstats=Referrer Statistics\nxe.statistics.visit=Visit Statistics\nxe.statistics=Statistics\nxe.statistics.more=For more statistics, please give a look at:\nxe.statistics.module.disabled=The statistics module is disabled by default for improved performances.\nxe.statistics.to=to\nxe.statistics.module.settingvalue=It can be globally activated by setting the value of\nxe.statistics.inthe=in the\nxe.statistics.moredetails=configuration file. For more details, see\nxe.statistics.module.activating=Activating the statistics module makes the following information available to you:\nxe.statistics.module.muchmore=and much more!\n\n### Webdav application\nxe.webdav.initialize.activex=Could not initialize a required ActiveX object.\nxe.webdav.initialize.error=Error while initializing the share point editor.\nxe.webdav.install.foxwiki=A Firefox extension is required to perform this action, install it?\nxe.webdav.error=Ooops! Something went wrong... Please try again.\nxe.webdav.sorry=Sorry, to use this feature you need either Firefox or Internet Explorer.\nxe.webdav.info=This is a hosting page for webdav related functions.\n\n####################\n# Index Module\n####################\n\nplatform.index.documents=Pages on this Wiki\nplatform.index=Index\nplatform.index.tree=Tree\nplatform.index.orphaned=Orphaned Pages\nplatform.index.orphanedResults=Orphaned Pages JSON Service\nplatform.index.attachments=Attachments\nplatform.index.attachmentsResults=Attachments JSON Service\n\n### Livetable Column Labels (translationPrefix == \"platform.index.\")\nplatform.index.doc.name=Page\nplatform.index.doc.location=Location\nplatform.index.doc.space=Space\nplatform.index.doc.date=Date\nplatform.index.doc.author=Last Author\nplatform.index.doc.title=Title\nplatform.index.doc.fullName=Page\nplatform.index.doc.objectCount=Object Count\nplatform.index._actions=Actions\nplatform.index.emptyvalue=\nplatform.index._likes=Likes\n\n### Livetable Column Labels (translationPrefix == \"platform.index.attachments.\")\nplatform.index.attachments.filename=Name\nplatform.index.attachments.doc.fullName=Location\nplatform.index.attachments.date=Date\nplatform.index.attachments.author=Author\nplatform.index.attachments.mimeType=Type\nplatform.index.attachments.filesize=Size\nplatform.index.attachments.emptyvalue=\n\nplatform.index.documentsTrash=Deleted Pages\nplatform.index.trashDocumentsEmpty=No deleted pages\n\n### Livetable Column Labels (translationPrefix == \"platform.index.trashDocuments.\")\nplatform.index.trashDocuments.ddoc.fullName=Page\nplatform.index.trashDocuments.ddoc.title=Title\nplatform.index.trashDocuments.ddoc.date=Deleted on\nplatform.index.trashDocuments.ddoc.deleter=Deleted by\nplatform.index.trashDocuments.ddoc.batchId=Deleted Batch ID\nplatform.index.trashDocuments.actions=Actions\n\nplatform.index.trashDocumentsActionsRestoreTooltip=Restore page\nplatform.index.trashDocumentsActionsRestoreText=restore\nplatform.index.trashDocumentsActionsReplaceTooltip=Replace the page that has been created at the original location\nplatform.index.trashDocumentsActionsReplaceText=replace\nplatform.index.trashDocumentsActionsCannotRestoreTooltip=The page cannot be restored to its original location because it has been recreated.\nplatform.index.trashDocumentsActionsCannotRestoreText=cannot restore\nplatform.index.trashDocumentsActionsCannotRestoreCausesOrphanedTranslationTooltip=The translation can not be restored to its original location before its original page is restored or re-created.\nplatform.index.trashDocumentsActionsDeleteTooltip=Permanently delete page\nplatform.index.trashDocumentsActionsDeleteText=delete\nplatform.index.trashDocumentsDeleteInProgress=Permanently deleting page...\nplatform.index.trashDocumentsDeleteDone=Page permanently deleted\nplatform.index.trashDocumentsDeleteFailed=Failed to delete:\nplatform.index.trashDocumentsDeleteInformation=Deleted by {0} on {1}\nplatform.index.trashDocumentsReplacePageFailed=Failed to replace\nplatform.index.trashDocumentsReplacePageText=The deleted page was recreated, possibly for adding a redirect to another document. Are you sure you want to replace it with the old page?\nplatform.index.trashDocumentsReplacePageTitle=Replace existing page\n\nplatform.index.attachmentsTrash=Deleted Attachments\nplatform.index.trashAttachmentsEmpty=No deleted attachments\n\n### Livetable Column Labels (translationPrefix == \"platform.index.trashAttachments.\")\nplatform.index.trashAttachments.datt.filename=Attachment\nplatform.index.trashAttachments.datt.docName=Page\nplatform.index.trashAttachments.datt.date=Deleted on\nplatform.index.trashAttachments.datt.deleter=Deleted by\nplatform.index.trashAttachments.actions=Actions\n\nplatform.index.trashAttachmentsActionsRestoreTooltip=Restore attachment\nplatform.index.trashAttachmentsActionsRestoreText=[restore]\nplatform.index.trashAttachmentsActionsCannotRestoreTooltip=The attachment cannot be restored to its original location because another file with the same name has been attached.\nplatform.index.trashAttachmentsActionsCannotRestoreText=[cannot restore]\nplatform.index.trashAttachmentsActionsDeleteTooltip=Permanently delete attachment\nplatform.index.trashAttachmentsActionsDeleteText=[delete]\nplatform.index.trashAttachmentsDeleteInProgress=Permanently deleting attachment...\nplatform.index.trashAttachmentsDeleteDone=Attachment permanently deleted\nplatform.index.trashAttachmentsDeleteFailed=Failed to delete:\n\n### Space Index Page\nplatform.index.spaceIndex=Space Index\nplatform.index.spaceIndexDescription=Pages in the {0} space:\nplatform.index.spaceIndexDocumentListCreate=Create a new page\n\n####################\n# Livetable Module\n####################\n\nplatform.livetable.results=Livetable Results\nplatform.livetable.resultsMacros=Livetable Results Macros\nplatform.livetable._actions.delete=delete\nplatform.livetable._actions.rename=rename\nplatform.livetable._actions.rights=rights\nplatform.livetable._actions.copy=copy\nplatform.livetable._actions.edit=edit\nplatform.livetable.asyncActionInProgress=In progress...\nplatform.livetable.asyncActionDone=Done\nplatform.livetable.asyncActionFailed=Failed\nplatform.livetable.filtersTitle=Filter for the {0} column\nplatform.livetable.loading=Loading...\nplatform.livetable.tagsHelp=Click on one or more tags to filter the list\nplatform.livetable.tagsHelpCancel=and click again on a tag to cancel the filter\nplatform.livetable.environmentCannotLoadTableMessage=The environment prevents the table from loading data.\nplatform.livetable.docTitleComputedHint=Some pages have a computed title. Filtering and sorting by title will not work as expected for these pages.\nplatform.livetable.docNotViewable=N/A\nplatform.livetable.pagesizeLabel=per page of\nplatform.livetable.selectAll=All\nplatform.livetable.paginationPage=Page\nplatform.livetable.paginationPageTitle=Go to page {0}\nplatform.livetable.paginationPagePrevious=&#171; previous page\nplatform.livetable.paginationPagePrevTitle=Previous Page\nplatform.livetable.paginationPageNext=next page &#187;\nplatform.livetable.paginationPageNextTitle=Next Page\nplatform.livetable.paginationResultsNone=No results\nplatform.livetable.paginationResultsOne=One result\nplatform.livetable.paginationResultsSingle=Result <span class=\"currentResultsNo\">{0}</span> of <span class=\"totalResultsNo\">{1}</span>\nplatform.livetable.paginationResultsMany=Results <span class=\"currentResultsNo\">{0} - {1}</span> of <span class=\"totalResultsNo\">{2}</span>\nplatform.livetable.paginationResults=Results\nplatform.livetable.paginationResultsOf=out of\n\n####################\n# Daterange picker\n####################\n\ndaterange.apply=Apply\ndaterange.clear=Clear\ndaterange.customRange=Custom Range\ndaterange.from=From\ndaterange.to=To\ndaterange.today=Today\ndaterange.yesterday=Yesterday\ndaterange.lastSevenDays=Last 7 Days\ndaterange.lastThirtyDays=Last 30 Days\ndaterange.thisMonth=This Month\ndaterange.lastMonth=Last Month\n\n####################\n# XWiki Enterprise Module\n####################\n\nxe.document.copy=Copy a page\nxe.document.copying=Copying page {0} to {1}\nxe.document.copy.source=Source Page:\nxe.document.copy.target=Target Page:\nxe.document.copy.language=Language:\nxe.document.copy.do=Copy\n\n### Color themes\nxe.themes.current=Current theme\nxe.themes.others=Other available themes\nxe.themes.useTheme=Use this theme\nxe.themes.themeSet=Color theme set to {0}.\nxe.themes.create=Create new theme\nxe.themes.create.nameLabel=Theme name:\nxe.themes.create.nameTip=Theme name...\n### Page titles\nxe.themes.colors.title=Color Themes\nxe.themes.colors.sheet.title=Sheet for color themes\nxe.themes.colors.class.title=Class for defining skin color themes\nxe.themes.colors.template.title=Template page for skin color themes\nxe.themes.colors.mapping.title=Color theme wizard property mapping\nxe.themes.colors.webColors.title=Default color palette for the scriptless wizard\n### Wizard\nxe.themes.colors.wizard.choose=Choose\nxe.themes.colors.wizard.mainMenu=Main Menu\nxe.themes.colors.wizard.logo=Wiki Logo\nxe.themes.colors.wizard.panel=Panel\nxe.themes.colors.wizard.panel.text=Panel Text\nxe.themes.colors.wizard.panel.link=Panel Link\nxe.themes.colors.wizard.panel.collapsed=Collapsed Panel\nxe.themes.colors.wizard.menu=Content Menu\nxe.themes.colors.wizard.menuEntry=entry\nxe.themes.colors.wizard.title=Title\nxe.themes.colors.wizard.informativeText=Informative Text\nxe.themes.colors.wizard.detailsText=Details Text\nxe.themes.colors.wizard.text=Content Text\nxe.themes.colors.wizard.link=Content Link\nxe.themes.colors.wizard.highlightedText=Highlighted Text\nxe.themes.colors.wizard.messageBox=Message Box\nxe.themes.colors.wizard.table=Table\nxe.themes.colors.wizard.table.data=data\nxe.themes.colors.wizard.button=Button\nxe.themes.colors.wizard.secondaryButton=Secondary action button\nxe.themes.colors.wizard.tab=tab\nxe.themes.colors.wizard.tab.text=Text\nxe.themes.colors.wizard.reset=Reset\nxe.themes.colors.wizard.close=Close\nxe.themes.colors.wizard.undo=Undo\n\nxe.xwiki.administration=Administration application\nxe.xwiki.administration.install=This page and its children contain internal content used by XWiki for its own use. It also currently contains the User Profile pages. You can administer your wiki through the {0}.\n\n### Monitor\nxe.monitor=XWiki Requests Status\nxe.monitor.url=URL:\nxe.monitor.startdate=StartDate:\nxe.monitor.state=State:\nxe.monitor.alive=Alive:\nxe.monitor.interrupt=Interrupting\nxe.monitor.consolidateddata=Consolidated Data\nxe.monitor.duration=Duration:\nxe.monitor.requests=Requests:\nxe.monitor.duration.small=duration:\nxe.monitor.calls=Calls:\nxe.monitor.average=Average:\nxe.monitor.ms=ms\nxe.monitor.requests.active=Active requests\nxe.monitor.requests.currentlyrunning=Currently running requests. There is always at least the request for this page.\nxe.monitor.requests.size=Active requests size:\nxe.monitor.requests.page=Page:\nxe.monitor.thread=Thread:\nxe.monitor.requests.unfinished=Latest unfinished requests\nxe.monitor.requests.unfinished.description=These are requests that didn't reach \"endRequest\", but where cleaned-up by a reuse of threads. Maximum 32 requests are kept in memory.\nxe.monitor.requests.active.size=Active requests size:\nxe.monitor.requests.latest=Latest requests\nxe.monitor.requests.latest.description=Latest requests that finished properly. Only {0} requests max are kept in memory.\nxe.monitor.enddate=EndDate:\nxe.monitor.requests.number=Number of requests displayed:\nxe.monitor.disabled=The Monitor plugin is disabled. Please enable it by setting <tt>xwiki.monitor=1</tt> in your <tt>xwiki.cfg</tt> configuration file.\n\nxe.templateprovider.name=Provider Name\nxe.templateprovider.name.example=Example: My Template Provider\nxe.templateprovider.templatename=Template Name\nxe.templateprovider.templatename.example=Example: My Template\nxe.templateprovider.templatename.info=You can fill in a translation key to allow internationalization of this template name.\nxe.templateprovider.template=Template to use\nxe.templateprovider.template.edit=Edit\nxe.templateprovider.template.example=Example: XWiki.MyTemplate\nxe.templateprovider.spaces=List of locations where the template must be available\nxe.templateprovider.spaces.all=The template is available from any location\nxe.templateprovider.spaces.info=If no location is selected, the template will be available from any location\nxe.templateprovider.backtoadmin=See all templates\nxe.templateprovider.action=Action on create\nxe.templateprovider.action.info=The action to execute when the create button is pushed, you can configure here whether the new page is saved before it is opened for edition or not.\nxe.templateprovider.terminal=Terminal Page\nxe.templateprovider.terminal.hint=Whether or not to create terminal documents by default when using this template provider.\n\nxe.welcome.edit=Edit welcome message\n\nXWiki.TemplateProviderClass_type_page=Page\nXWiki.TemplateProviderClass_type_space=Space homepage\nXWiki.TemplateProviderClass_action_edit=Edit\nXWiki.TemplateProviderClass_action_saveandedit=Save and Edit\nXWiki.TemplateProviderClass_action_saveandview=Save and View\n\nadmin.templates=Page Templates\nadmin.templates.description=Settings for the creation of page templates.\nadmin.templates.providerslist=Available Template Providers\nadmin.templates.createprovider=Create a Template Provider\nadmin.templates.createprovider.space=Space:\nadmin.templates.createprovider.page=Page:\nadmin.templates.createprovider.defaultdocname=MyTemplateProvider\nadmin.templates.createprovider.create=Create\n\n####################\n# XWiki Classes\n####################\n\n### Blog.BlogClass (blog application)\nBlog.BlogClass_title=Blog title\nBlog.BlogClass_description=Description\nBlog.BlogClass_displayType=Index display\nBlog.BlogClass_itemsPerPage=Items per page (only in the Paginated display mode)\nBlog.BlogClass_blogType=Blog type\nBlog.BlogClass_blogType_local=Space blog (aggregates posts from its space only)\nBlog.BlogClass_blogType_global=Global blog (aggregates posts from the entire wiki)\nBlog.BlogPostClass_displayType_paginated=Paginated\nBlog.BlogPostClass_displayType_weekly=Group posts weekly\nBlog.BlogPostClass_displayType_monthly=Group posts monthly\nBlog.BlogPostClass_displayType_all=Show all posts\nBlog.BlogPostClass_title=Title\nBlog.BlogPostClass_content=Content\nBlog.BlogPostClass_extract=Extract\nBlog.BlogPostClass_category=Category\nBlog.BlogPostClass_hidden=Is hidden\nBlog.BlogPostClass_published=Is published\nBlog.BlogPostClass_publishDate=Publish date\nBlog.CategoryClass_name=Name\nBlog.CategoryClass_description=Description\n\n### Panels.PanelClass (panel application)\nPanels.PanelClass_name=Name\nPanels.PanelClass_type=Panel type\nPanels.PanelClass_description=Description\nPanels.PanelClass_content=Content\nPanels.PanelClass_category=Category\nPanels.PanelClass_async_enabled=Asynchronous rendering\nPanels.PanelClass_async_cached=Cached\nPanels.PanelClass_async_context=Context elements\n\n### XWiki.AggregatorURLClass (watch application)\nXWiki.AggregatorURLClass_name=Name\nXWiki.AggregatorURLClass_url=URL\nXWiki.AggregatorURLClass_imgurl=Image URL\nXWiki.AggregatorURLClass_date=date\nXWiki.AggregatorURLClass_nb=nb\n\n### XWiki.FeedEntryClass (watch application)\nXWiki.FeedEntryClass_title=Title\nXWiki.FeedEntryClass_author=Author\nXWiki.FeedEntryClass_feedurl=Feed URL\nXWiki.FeedEntryClass_feedname=Feed Name\nXWiki.FeedEntryClass_url=URL\nXWiki.FeedEntryClass_category=Category\nXWiki.FeedEntryClass_content=Content\nXWiki.FeedEntryClass_fullContent=Full Content\nXWiki.FeedEntryClass_xml=XML\nXWiki.FeedEntryClass_date=Date\nXWiki.FeedEntryClass_flag=Flag\nXWiki.FeedEntryClass_read=Read\nXWiki.FeedEntryClass_tags=Tags\n\n### XWiki.JavaScriptExtension (skinx plugin)\nXWiki.JavaScriptExtension_name=Name\nXWiki.JavaScriptExtension_code=Code\nXWiki.JavaScriptExtension_use=Use this extension\nXWiki.JavaScriptExtension_parse=Parse content\nXWiki.JavaScriptExtension_cache=Caching policy\n\n### XWiki.MessageStreamConfig (XE)\nXWiki.MessageStreamConfig_active=Enable the message stream\nXWiki.MessageStreamConfig_active.hint=Whether the message stream is active or not.\nXWiki.MessageStreamConfig_visibilityLevel_everyone=Everyone\nXWiki.MessageStreamConfig_visibilityLevel_followers=Followers\nXWiki.MessageStreamConfig_visibilityLevel_group=Group\nXWiki.MessageStreamConfig_visibilityLevel_user=User\n\n### XWiki.StyleSheetExtension (skinx plugin)\nXWiki.StyleSheetExtension_name=Name\nXWiki.StyleSheetExtension_code=Code\nXWiki.StyleSheetExtension_use=Use this extension\nXWiki.StyleSheetExtension_parse=Parse content\nXWiki.StyleSheetExtension_cache=Caching policy\n\n### XWiki.Mail (mailsender plugin)\nXWiki.Mail_subject=Subject\nXWiki.Mail_language=Language\nXWiki.Mail_text=Text\nXWiki.Mail_html=HTML\n\n### XWiki.ResetPasswordRequestClass (administration application)\nXWiki.ResetPasswordRequestClass_verification=Request verification string\n\n### XWiki.SchedulerJobClass (scheduler plugin)\nXWiki.SchedulerJobClass_jobName=Job Name\nXWiki.SchedulerJobClass_jobClass=Job Class\nXWiki.SchedulerJobClass_status=Status\nXWiki.SchedulerJobClass_cron=Cron Expression\nXWiki.SchedulerJobClass_script=Job Script\nXWiki.SchedulerJobClass_jobDescription=Job Description\n\n### XWiki.TagClass (core)\nXWiki.TagClass_tags=Tags\n\n### XWiki.WatchListClass (watchlist plugin)\nXWiki.WatchListClass_interval=Email notifications interval\nXWiki.WatchListClass_spaces=Space list, comma separated\nXWiki.WatchListClass_documents=Page list, comma separated\nXWiki.WatchListClass_query=Query (HQL)\nXWiki.WatchListClass_automaticwatch=Automatic page watching\nXWiki.WatchListClass_automaticwatch_default=Default\nXWiki.WatchListClass_automaticwatch_NONE=Disabled\nXWiki.WatchListClass_automaticwatch_ALL=Any modification\nXWiki.WatchListClass_automaticwatch_MAJOR=Major modifications\nXWiki.WatchListClass_automaticwatch_NEW=New pages\n\n### XWiki.XWikiComments (core)\nXWiki.XWikiComments_author=Author\nXWiki.XWikiComments_highlight=Highlighted Text\nXWiki.XWikiComments_date=Date\nXWiki.XWikiComments_comment=Comment\nXWiki.XWikiComments_replyto=Reply To\n\n### XWiki.XWikiGlobalRights (core)\nXWiki.XWikiGlobalRights_allow=Allow/Deny\nXWiki.XWikiGlobalRights_groups=Groups\nXWiki.XWikiGlobalRights_levels=Levels\nXWiki.XWikiGlobalRights_users=Users\n\n### XWiki.XWikiGroups (core)\nXWiki.XWikiGroups_member=Member\n\n### XWiki.XWikiPreferences (core)\nXWiki.XWikiPreferences_skin=Skin\nXWiki.XWikiPreferences_colorTheme=Color theme\nXWiki.XWikiPreferences_accessibility=Enable extra accessibility features\nXWiki.XWikiPreferences_authenticate_view=Authenticated View\nXWiki.XWikiPreferences_webcopyright=Copyright\nXWiki.XWikiPreferences_plugins=Plugins\nXWiki.XWikiPreferences_authenticate_edit=Authenticate On Edit\nXWiki.XWikiPreferences_meta=HTTP Meta Info\nXWiki.XWikiPreferences_title=Title\nXWiki.XWikiPreferences_version=Version\nXWiki.XWikiPreferences_validation_email_content=Validation email Content\nXWiki.XWikiPreferences_confirmation_email_content=Confirmation email Content\nXWiki.XWikiPreferences_stylesheet=Stylesheet\nXWiki.XWikiPreferences_stylesheets=Stylesheets\nXWiki.XWikiPreferences_multilingual=Multilingual\nXWiki.XWikiPreferences_default_language=Default Language\nXWiki.XWikiPreferences_editor=Default Editor\nXWiki.XWikiPreferences_core.defaultDocumentSyntax=Default page syntax\nXWiki.XWikiPreferences_use_email_verification=Use email Verification\nXWiki.XWikiPreferences_backlinks=Backlinks\nXWiki.XWikiPreferences_invitation_email_content=Invitation email content\nXWiki.XWikiPreferences_registration_anonymous=Anonymous\nXWiki.XWikiPreferences_registration_registered=Registered\nXWiki.XWikiPreferences_edit_anonymous=Anonymous\nXWiki.XWikiPreferences_edit_registered=Registered\nXWiki.XWikiPreferences_comment_anonymous=Anonymous\nXWiki.XWikiPreferences_comment_registered=Registered\nXWiki.XWikiPreferences_leftPanels=Panels displayed on the left\nXWiki.XWikiPreferences_leftPanels.hint=A comma separated list of panels to display on the left column. E.g.: Panels.Applications, Panels.Navigation\nXWiki.XWikiPreferences_rightPanels=Panels displayed on the right\nXWiki.XWikiPreferences_rightPanels.hint=A comma separated list of panels to display on the right column.\nXWiki.XWikiPreferences_showLeftPanels=Display the left panel column\nXWiki.XWikiPreferences_showRightPanels=Display the right panel column\nXWiki.XWikiPreferences_leftPanelsWidth=Width of the left panel column\nXWiki.XWikiPreferences_leftPanelsWidth.hint=Choose the size of the left panel column.\nXWiki.XWikiPreferences_rightPanelsWidth=Width of the right panel column\nXWiki.XWikiPreferences_rightPanelsWidth.hint=Choose the size of the right panel column.\nXWiki.XWikiPreferences_leftPanelsWidth_Small=Small\nXWiki.XWikiPreferences_leftPanelsWidth_Medium=Medium\nXWiki.XWikiPreferences_leftPanelsWidth_Large=Large\nXWiki.XWikiPreferences_rightPanelsWidth_Small=Small\nXWiki.XWikiPreferences_rightPanelsWidth_Medium=Medium\nXWiki.XWikiPreferences_rightPanelsWidth_Large=Large\nXWiki.XWikiPreferences_languages=Supported languages\nXWiki.XWikiPreferences_tags=Activate the tagging\nXWiki.XWikiPreferences_parent=Parent space\nXWiki.XWikiPreferences_documentBundles=Internationalization Document Bundles\nXWiki.XWikiPreferences_upload_maxsize=Maximum Upload Size\nXWiki.XWikiPreferences_xwiki.title.mandatory=Make page title field mandatory\nXWiki.XWikiPreferences_showannotations=Show page annotations\nXWiki.XWikiPreferences_showcomments=Show page comments\nXWiki.XWikiPreferences_showattachments=Show page attachments\nXWiki.XWikiPreferences_showhistory=Show page history\nXWiki.XWikiPreferences_showinformation=Show page information\nXWiki.XWikiPreferences_editcomment=Enable version summaries\nXWiki.XWikiPreferences_editcomment_mandatory=Make version summaries mandatory\nXWiki.XWikiPreferences_minoredit=Enable minor edits\nXWiki.XWikiPreferences_ldap=Ldap\nXWiki.XWikiPreferences_ldap.hint=Enable or not LDAP authentication for this wiki. If enabled and configured properly, a local user will be created whenever a LDAP user visit this wiki for the first time.\nXWiki.XWikiPreferences_ldap_server=Ldap server address\nXWiki.XWikiPreferences_ldap_port=Ldap server port\nXWiki.XWikiPreferences_ldap_bind_DN=Ldap login matching\nXWiki.XWikiPreferences_ldap_bind_DN.hint=LDAP login. Leave empty for anonymous access, otherwise specify full dn. {0} is replaced with the user name, {1} with the password.\nXWiki.XWikiPreferences_ldap_bind_pass=Ldap password matching\nXWiki.XWikiPreferences_ldap_bind_pass.hint=Ldap password matching. Use in combination with Ldap login matching.\nXWiki.XWikiPreferences_ldap_validate_password=Validate Ldap user/password\nXWiki.XWikiPreferences_ldap_user_group=Restrict to group\nXWiki.XWikiPreferences_ldap_user_group.hint=Only members of the following group will be verified in the directory. If you leave empty, all users that are found after searching starting from the base_DN will be verified.\nXWiki.XWikiPreferences_ldap_exclude_group=Ldap group to exclude\nXWiki.XWikiPreferences_ldap_exclude_group.hint=If not empty, the mentionned group will never be verified against in the directory.\nXWiki.XWikiPreferences_ldap_base_DN=Ldap base DN\nXWiki.XWikiPreferences_ldap_UID_attr=Ldap UID attribute name\nXWiki.XWikiPreferences_ldap_UID_attr.hint=Specifies the LDAP attribute containing the identifier to be used as the XWiki name. The default is \"cn\".\nXWiki.XWikiPreferences_ldap_fields_mapping=Ldap user fields mapping\nXWiki.XWikiPreferences_ldap_update_user=Update user from LDAP after login\nXWiki.XWikiPreferences_ldap_update_user.hint=If not, the mapped attributes from LDAP to XWiki will be updated only when the user is created when login for the first time.\nXWiki.XWikiPreferences_ldap_update_photo=Update user photo from LDAP\nXWiki.XWikiPreferences_ldap_update_photo.hint=If enabled xwiki avatar will be synchronized with LDAP\nXWiki.XWikiPreferences_ldap_photo_attachment_name=Attachment name used to save LDAP photo\nXWiki.XWikiPreferences_ldap_photo_attachment_name.hint=Filename of LDAP photo that will be used in xwiki profile\nXWiki.XWikiPreferences_ldap_photo_attribute=Ldap photo attribute name\nXWiki.XWikiPreferences_ldap_photo_attribute.hint=Specifies the LDAP attribute containing photo image\nXWiki.XWikiPreferences_ldap_group_mapping=Ldap groups mapping\nXWiki.XWikiPreferences_ldap_groupcache_expiration=LDAP groups cache expiration\nXWiki.XWikiPreferences_ldap_groupcache_expiration.hint=Time in seconds after which the list of members in a group is refreshed from LDAP. The default is 21600 (6 hours).\nXWiki.XWikiPreferences_ldap_mode_group_sync=When to synchronize LDAP groups\nXWiki.XWikiPreferences_ldap_mode_group_sync_always=At each authentication of a user\nXWiki.XWikiPreferences_ldap_mode_group_sync_create=Upon creation of a user\nXWiki.XWikiPreferences_ldap_trylocal=Try local login\nXWiki.XWikiPreferences_ldap_trylocal.hint=If LDAP authentication fails, try XWiki DB authentication with the same credentials. Default is Yes.\nXWiki.XWikiPreferences_dateformat=Date format\nXWiki.XWikiPreferences_guest_comment_requires_captcha=Enable CAPTCHA in comments for unregistered users\nXWiki.XWikiPreferences_timezone=Timezone\nXWiki.XWikiPreferences_timezone_default=System Default\n\n### XWiki.XWikiRights (core)\nXWiki.XWikiRights_allow=Allow/Deny\nXWiki.XWikiRights_groups=Groups\nXWiki.XWikiRights_levels=Levels\nXWiki.XWikiRights_users=Users\n\n### XWiki.XWikiUsers (core)\nXWiki.XWikiUsers_active=Active\nXWiki.XWikiUsers_password=Password\nXWiki.XWikiUsers_email=Email\nXWiki.XWikiUsers_comment=About\nXWiki.XWikiUsers_first_name=First Name\nXWiki.XWikiUsers_last_name=Last Name\nXWiki.XWikiUsers_fullname=Full Name\nXWiki.XWikiUsers_validkey=Validation Key\nXWiki.XWikiUsers_default_language=Default Language\nXWiki.XWikiUsers_company=Company\nXWiki.XWikiUsers_blog=Blog\nXWiki.XWikiUsers_blogfeed=Blog Feed\nXWiki.XWikiUsers_imtype=IM Type\nXWiki.XWikiUsers_imaccount=IM Account\nXWiki.XWikiUsers_city=City\nXWiki.XWikiUsers_country=Country\nXWiki.XWikiUsers_editor=Default Editor\nXWiki.XWikiUsers_skin=Skin\nXWiki.XWikiUsers_pageWidth=Preferred page width\nXWiki.XWikiUsers_avatar=Avatar\nXWiki.XWikiUsers_usertype=User Type\nXWiki.XWikiUsers_usertype_Simple=Simple\nXWiki.XWikiUsers_usertype_Advanced=Advanced\nXWiki.XWikiUsers_phone=Phone\nXWiki.XWikiUsers_address=Address\nXWiki.XWikiUsers_extensionConflictSetup=Enable extension conflict setup\n\n### XWiki.XWikiSkins (core)\nXWiki.XWikiSkins_name=Name\nXWiki.XWikiSkins_style.css=Style\nXWiki.XWikiSkins_header.vm=Header\nXWiki.XWikiSkins_footer.vm=Footer\nXWiki.XWikiSkins_view.vm=View\nXWiki.XWikiSkins_viewheader.vm=View Header\nXWiki.XWikiSkins_pagemenu.vm=Page Menu\nXWiki.XWikiSkins_comments2.vm=Comments\nXWiki.XWikiSkins_edit.vm=Edit\nXWiki.XWikiSkins_baseskin=Base Skin\nXWiki.XWikiSkins_logo=Logo\n\n### XWiki.Registration (administration application)\nXWiki.Registration_heading=Registration page heading\nXWiki.Registration_welcomeMessage=Welcome message\nXWiki.Registration_liveValidation_enabled=Enable Javascript field validation\nXWiki.Registration_liveValidation_defaultFieldOkMessage=Default field okay message\nXWiki.Registration_loginButton_enabled=Enable login button\nXWiki.Registration_loginButton_autoLogin_enabled=Enable automatic login\nXWiki.Registration_defaultRedirect=Redirect here after registration\nXWiki.Registration_requireCaptcha=Require CAPTCHA to register\nXWiki.Registration_registrationSuccessMessage=Registration Successful Message\n\n### XWiki.InvitationMail (Invitation Application) Email XObject\nInvitation.InvitationMailClass_messageID=Email message identifier\nInvitation.InvitationMailClass_messageGroupID=Message group identifier\nInvitation.InvitationMailClass_recipient=Email address which this message was sent to\nInvitation.InvitationMailClass_sendingUser=User who sent the message\nInvitation.InvitationMailClass_subjectLine=Subject line\nInvitation.InvitationMailClass_messageBody=Message content\nInvitation.InvitationMailClass_status=Number indicating the message status\nInvitation.InvitationMailClass_sentDate=Date message was sent\nInvitation.InvitationMailClass_memo=Memo attached to this message\nInvitation.InvitationMailClass_history=Activity history for this invitation\nInvitation.InvitationMailClass_messageBodyPlain=Plain message for non HTML email clients\n\n### XWiki.WebHome (Invitation application) Configuration\nInvitation.WebHome_from_address=Email \"from\" address\nInvitation.WebHome_smtp_server_password=Smtp password\nInvitation.WebHome_smtp_server_username=Smtp username\nInvitation.WebHome_smtp_port=Smtp port\nInvitation.WebHome_smtp_server=Smtp server host name\nInvitation.WebHome_javamail_extra_props=Javamail extra properties\nInvitation.WebHome_subjectLineTemplate=Email subject line template\nInvitation.WebHome_messageBodyTemplate=Email message body HTML template\nInvitation.WebHome_messageBodyTemplatePlain=Message body plain text template\nInvitation.WebHome_emailClass=Email message XClass\nInvitation.WebHome_emailContainer=Page containing email XObjects\nInvitation.WebHome_emailRegex=Regular expression for validating email addresses\nInvitation.WebHome_allowUsersOfOtherWikis=Let users of other wikis send\nInvitation.WebHome_usersMayPersonalizeMessage=Let users personalize messages\nInvitation.WebHome_usersMaySendToMultiple=Let users send to multiple addresses\n\n### XWiki.WysiwygEditorConfigClass (administration application)\nXWiki.WysiwygEditorConfigClass_sourceEditorEnabled=Source editor enabled\nXWiki.WysiwygEditorConfigClass_plugins=Plugins\nXWiki.WysiwygEditorConfigClass_menuBar=Menu Bar\nXWiki.WysiwygEditorConfigClass_toolBar=Tool Bar\nXWiki.WysiwygEditorConfigClass_cleanPaste=Clean paste content automatically\nXWiki.WysiwygEditorConfigClass_attachmentSelectionLimited=Attachment selection limited\nXWiki.WysiwygEditorConfigClass_externalImages=External images\nXWiki.WysiwygEditorConfigClass_imageSelectionLimited=Image selection limited\nXWiki.WysiwygEditorConfigClass_colorPalette=Color palette\nXWiki.WysiwygEditorConfigClass_colorsPerRow=Colors per row\nXWiki.WysiwygEditorConfigClass_fontNames=Font names\nXWiki.WysiwygEditorConfigClass_fontSizes=Font sizes\nXWiki.WysiwygEditorConfigClass_styleNames=Style names\n\n####################\n# XWiki Classes End\n####################\n\n###Dashboard translations\ndashboard.gadget.actions.delete.confirm=Are you sure you want to delete this gadget?\ndashboard.gadget.actions.delete.inProgress=Deleting gadget...\ndashboard.gadget.actions.delete.done=Gadget deleted\ndashboard.gadget.actions.delete.failed=Failed to delete gadget:\ndashboard.gadget.actions.delete.tooltip=Remove this gadget from the dashboard\ndashboard.gadget.actions.edit.tooltip=Edit this gadget's parameters\ndashboard.gadget.actions.edit.error.notmacro=The parameters of this gadget cannot be edited using this visual editor, please use the object editor to edit this gadget.\ndashboard.gadget.actions.edit.error.notmacro.title=Edit gadget parameters\ndashboard.gadget.actions.drop=You can drop gadgets here\ndashboard.gadget.actions.edit.loading=Saving gadget configuration...\ndashboard.gadget.actions.edit.failed=Failed to save gadget configuration:\ndashboard.actions.save.loading=Saving dashboard changes...\ndashboard.actions.edit.failed=Failed to save dashboard configuration:\ndashboard.actions.edit.differentsource.information=You are editing a dashboard defined in a different page,\ndashboard.actions.edit.differentsource.warning=. Your changes will impact all the pages using that dashboard configuration. If you want to customize only this page, edit this page in WYSIWYG mode and configure the dashboard macro with an empty source parameter.\ndashboard.actions.add.button=Add Gadget\ndashboard.actions.add.tooltip=Add a new gadget to this dashboard\ndashboard.actions.add.loading=Adding the gadget...\ndashboard.actions.add.failed=Failed to add gadget:\ndashboard.actions.columns.add.button=Add column\ndashboard.actions.columns.add.tooltip=Add a new column in this dashboard, at the end\n\n### Search application resources\nadmin.searchsuggest=Search Suggest\nadmin.searchsuggest.description=Configure the search suggest options.\nadmin.search=Search\nadmin.search.description=Choose the default search engine or configure the search index.\nsearch.admin.title=Search\nsearch.admin.configuration.seexwikicfg=See xwiki.cfg file for more configurations options.\nsearch.admin.configuration.button=Save\nsearch.extension.title.database=Database\nsearch.extension.title.solr=Solr\nXWiki.SearchConfigClass_engine=Default search engine\nsearch.page.title.query=Search: {0}\nsearch.page.title.noquery=Search\nsearch.page.bar.spaces.title=Location\nsearch.page.bar.wikis.all=All wikis\nsearch.page.bar.query.tip=search...\nsearch.page.bar.query.title=Enter your search query\nsearch.page.bar.querytip=e.g. xwiki* AND \"search query\"\nsearch.page.bar.submit=Search\nsearch.page.bar.submit.title=Search query\nsearch.page.database.title.query=Database Search: {0}\nsearch.page.database.title.noquery=Database Search\nsearch.page.results=Results\nsearch.page.results.page=Page\nsearch.page.results.space=Space\nsearch.page.results.wiki=Wiki\nsearch.page.results.date=Date\nsearch.page.results.author=Last Author\nsearch.page.results.score=Score\nsearch.page.results.actions=Actions\nsearch.page.results.newcomment=- 1 new comment\nsearch.page.results.noResults=Your search did not match any pages.\nsearch.page.noimplementation=There's no Search UI Extension available in your wiki. Please contact your Administrator.\nsearch.item.locatedIn=Located in\nsearch.item.modified=Modified by <span class=\"itemAuthor\">{0}</span> on <span class=\"itemDate\">{1}</span>\nsearch.item.posted=Posted by <span class=\"itemAuthor\">{0}</span> on <span class=\"itemDate\">{1}</span>\nsearch.item.rating.title=Rating\nsearch.item.relevance.title=Relevance\nsearch.item.type.comment.title=Comment\nsearch.item.type.attachment.title=Attachment\nsearch.item.type.author.title=Author\nsearch.item.type.page.title=Page\nsearch.item.type.wiki.title=Wiki\nsearch.item.type.space.title=Space\nsearch.rss=RSS feed for search on {0}\nplatform.search.suggestSources=Sources\nplatform.search.suggestSources.hint=Search suggest results are aggregated from multiple sources. The sources are grouped by the search engine they use. Each source is configured to match a specific thing (e.g. the page name). Only the sources that are active and that use the current search engine contribute results to the search suggest.\nplatform.search.suggestAddNewSource=Add a new source\nplatform.search.suggestNewSourceName=New Source\nplatform.search.suggestSourceDocumentTitle=Page titles\nplatform.search.suggestSourceDocumentContent=Page content\nplatform.search.suggestSourceAttachmentName=Attachment names\nplatform.search.suggestSourceAttachmentContent=Attachment content\nplatform.search.suggestSourceBlogPost=Blog posts\nplatform.search.suggestSourceWikis=Wikis\nplatform.search.suggestSourceUsers=Users\nplatform.search.suggestConfigSaveComment=Updated the search suggest configuration from the Administration\nplatform.search.suggestResultLocatedIn=in\n\nXWiki.SearchSuggestConfig_activated=Activated\nXWiki.SearchSuggestConfig_activated.hint=Whether the search suggest is active or not.\n\nXWiki.SearchSuggestSourceClass_name=Name\nXWiki.SearchSuggestSourceClass_name.hint=The name used to group search results taken from this source. It can be a translation key.\nXWiki.SearchSuggestSourceClass_engine=Engine\nXWiki.SearchSuggestSourceClass_engine.hint=The search engine used to retrieve the results. This source is ignored if the current wiki is configured to use a different search engine.\nXWiki.SearchSuggestSourceClass_url=Service\nXWiki.SearchSuggestSourceClass_url.hint=The search suggest service. It can be either a page reference or an external URL.\nXWiki.SearchSuggestSourceClass_query=Query\nXWiki.SearchSuggestSourceClass_query.hint=The query that is passed to the search suggest service. It must contain a __INPUT__ placeholder for the searched text.\nXWiki.SearchSuggestSourceClass_resultsNumber=Limit\nXWiki.SearchSuggestSourceClass_resultsNumber.hint=The maximum number of search results taken from this source.\nXWiki.SearchSuggestSourceClass_icon=Icon\nXWiki.SearchSuggestSourceClass_icon.hint=The icon used to mark search results taken from this source. E.g. icon:user\nXWiki.SearchSuggestSourceClass_highlight=Highlight\nXWiki.SearchSuggestSourceClass_highlight.hint=Highlight the searched text in the search suggest results.\nXWiki.SearchSuggestSourceClass_activated=Activated\nXWiki.SearchSuggestSourceClass_activated.hint=Whether this source is used or not (as long as the source search engine matches the search engine used by the current wiki).\n\n### CSRFToken resources\ncsrf.confirmation=<p>This request contains an invalid authentication information.</p><p>This might happen in the following situations:</p><ul><li>You left the editor open in another window/tab and logged off and on again</li><li>Your authentication token expired after a long period of inactivity</li><li>Somebody tried to perform a CSRF attack</li></ul><p>If you are sure that none of these situations apply in your case, you might have found a bug. We are sorry about that, please report it on <a href=\"http://jira.xwiki.org/\">XWiki JIRA</a></p><p>Do you want to resend the request? If unsure, say <strong>No</strong>.</p>\n\n### Extension Manager application resources\nadmin.extensions=Extension Manager\n\n### WYSIWYG content editor administration section resources\nadmin.wysiwyg=WYSIWYG Editor\nwysiwyg.config.title=WYSIWYG Editor Configuration Panel\nwysiwyg.config.class.title=WYSIWYG Editor Configuration Class\nwysiwyg.config.sheet.title=WYSIWYG Editor Configuration Class Sheet\nwysiwyg.config.template.title=WYSIWYG Editor Configuration Template\nwysiwyg.admin.general=General settings\nwysiwyg.admin.sourceEditorEnabled.hint=Enable or disable the WYSIWYG/Source tabs.\nwysiwyg.admin.plugins.hint=The list of plugins that are loaded by the WYSIWYG editor. You can change the order in which they are loaded by drag and drop. You can also add new plugins to the list or remove existing ones.\nwysiwyg.admin.plugins.add.hint=Add plugin..\nwysiwyg.admin.menuBar.hint=The list of entries on the WYSIWYG editor menu bar. You can change their order by drag and drop. You can also add new entries on the menu bar or remove existing ones. Each menu bar entry is provided by a plugin and is displayed only if that plugin is loaded.\nwysiwyg.admin.menuBar.add.hint=Add entry..\nwysiwyg.admin.toolBar.hint=The list of features available on the WYSIWYG editor tool bar. You can change their order by drag and drop. You can also add new features on the tool bar or remove existing ones. Each tool bar feature is provided by a plugin and is displayed only if that plugin is loaded.\nwysiwyg.admin.toolBar.add.hint=Add feature..\nwysiwyg.admin.plugin.settings.hint=The following settings are taken into account only if the {0} plugin is loaded.\nwysiwyg.admin.cleanPaste.hint=Enable if you want the content that is pasted into the rich text area to be cleaned automatically. The cleaning process implies fixing HTML validity (e.g. by removing elements that are custom to some office document formats) and also filtering text styles like font, color, alignment or margins. Content structure like heading levels, paragraphs, list or tables are preserved. Semantic text styles like strong, emphasize, underline or strikethrough are also preserved. You can still clean the paste content when this option is disabled if you have the paste icon on the tool bar, but you have to trigger the clean manually.\nwysiwyg.admin.link=Link settings\nwysiwyg.admin.attachmentSelectionLimited.hint=When creating a link to an attachment allow the user to choose only from the attachments of the edited page.\nwysiwyg.admin.image=Image settings\nwysiwyg.admin.externalImages.hint=Allow users to insert external images, i.e. images that are not attached to a wiki page.\nwysiwyg.admin.imageSelectionLimited.hint=When inserting an image allow the user to choose only from the list of images attached to the edited page.\nwysiwyg.admin.color=Color settings\nwysiwyg.admin.colorsPerRow.hint=The number of colors to display per row in the color picker.\nwysiwyg.admin.colorPalette.hint=The colors available in the color picker. You can change any color by clicking on it.\nwysiwyg.admin.font=Font settings\nwysiwyg.admin.fontNames.hint=The list of font names available in the font picker. You can add new font names or remove existing ones.\nwysiwyg.admin.fontNames.add.hint=Add font name..\nwysiwyg.admin.fontSizes.hint=The list of font sizes available in the font picker. You can change their order by drag and drop. You can also add new font sizes or remove existing ones.\nwysiwyg.admin.fontSizes.add.hint=Add font size..\nwysiwyg.admin.style=Style settings\nwysiwyg.admin.styleNames.hint=The list of style names available in the style picker. You can also add new style names or remove/edit existing ones.\nwysiwyg.admin.widgets.sortableList.hint=Drag and drop to change the order\nwysiwyg.admin.widgets.sortableList.add=Add\nwysiwyg.admin.widgets.sortableList.delete=Delete\nwysiwyg.admin.widgets.colorPaletteEditor.hint=Click to change the color\nwysiwyg.admin.widgets.colorPaletteEditor.rows=Rows\nwysiwyg.admin.widgets.colorPaletteEditor.columns=Columns\nwysiwyg.admin.widgets.colorPaletteEditor.refresh=Refresh\nwysiwyg.admin.widgets.listBox.add=Add\nwysiwyg.admin.widgets.listBox.delete=Delete\nwysiwyg.admin.widgets.styleNamesEditor.blockStyles=Block Styles\nwysiwyg.admin.widgets.styleNamesEditor.inlineStyles=Inline Styles\nwysiwyg.admin.widgets.styleNamesEditor.styleName=Style name\nwysiwyg.admin.widgets.styleNamesEditor.styleLabel=Style label\nwysiwyg.admin.widgets.styleNamesEditor.styleInline=Inline style\nwysiwyg.admin.widgets.styleNamesEditor.add=Add\nwysiwyg.admin.saveComment=Updated the WYSIWYG Editor configuration from the Administration\n\n### Link Checker Application Resources\nplatform.linkchecker.indexTab=External Links\nplatform.linkchecker.livetable.link=Link\nplatform.linkchecker.livetable.page=Page\nplatform.linkchecker.livetable.code=State\nplatform.linkchecker.livetable.date=Last Checked\n\n### Dashboard Application Resources\nplatform.dashboard.user.preferences=Dashboard preferences\nplatform.dashboard.user.displayOnMainPage=Replace the default dashboard with my custom dashboard\nplatform.dashboard.wiki=Dashboard\nplatform.dashboard.wiki.pages=Pages\nplatform.dashboard.wiki.tagcloud=Tags\nplatform.dashboard.wiki.activity=Activity Stream\nplatform.dashboard.wiki.messageSender=Send Message\nplatform.dashboard.wiki.personal.empty.edit=edit the dashboard section in your profile\nplatform.dashboard.wiki.personal.empty=Your dashboard is currently empty. You can {0} to configure it. In the mean time, the default dashboard is displayed below.\nplatform.dashboard.space=Dashboard for space {0}\nplatform.dashboard.space.activity=Activity Stream for {0}\nplatform.dashboard.space.documents=Pages in {0}\nplatform.dashboard.space.remainingDocumentsInSpace=and {0} {0,choice,1#more page|1<more pages} in space {1}\nplatform.dashboard.space.visitSpaceIndex=visit the Space Index to see the full list\nplatform.dashboard.space.tagcloud=Tags for {0}\nplatform.dashboard.space.templateName=Dashboard\n\n### Extension Manager\nextensions.actions.showDetails=Show details\nextensions.actions.hideDetails=Hide details\nextensions.actions.install=Install\nextensions.actions.uninstall=Uninstall\nextensions.actions.upgrade=Upgrade\nextensions.actions.downgrade=Downgrade\nextensions.actions.installGlobally=Install on farm\nextensions.actions.uninstallGlobally=Uninstall from farm\nextensions.actions.upgradeGlobally=Upgrade on farm\nextensions.actions.downgradeGlobally=Downgrade on farm\nextensions.actions.back=Back to list\nextensions.actions.continue=Continue\nextensions.actions.diff=Show changes\nextensions.actions.repairXAR=Repair\nextensions.actions.repairXAR.hint=Mark this XAR extension as installed without importing its wiki pages\nextensions.actions.diffXAR=Compute changes\nextensions.actions.diffXAR.hint=Compute the changes made to the extension pages\nextensions.actions.repair=Repair\nextensions.actions.repairGlobally=Repair on farm\nextensions.install.title=Installing {0}\nextensions.install.error.installFailure=Failed to install extension with id {0} and version {1}:\nextensions.install.error.prepareFailure=Can''t resolve extension with id {0} and version {1}:\nextensions.install.error.alreadyInstalled=This extension is already installed.\nextensions.install.error.diffXarFailure=Failed to compute the changes made to the extension pages.\nextensions.install.list.install=The following new extensions will be installed:\nextensions.install.list.upgrade=The following extensions will be upgraded:\nextensions.install.list.downgrade=The following extensions will be downgraded:\nextensions.install.list.uninstall=The following extensions will be removed:\nextensions.install.list.repair=The following extensions will be repaired:\nextensions.install.list.top=The following extensions dependencies will be made top level:\nextensions.upgrade.mergeConflict.label=Merge conflict\nextensions.upgrade.mergeConflict.hint=The page {0} has changes that could be overwritten during the upgrade.\nextensions.upgrade.mergeConflict.versionToKeep.next=Keep the new version of the page (all your changes will be overwritten)\nextensions.upgrade.mergeConflict.versionToKeep.merged=Keep the merged version of the page (some of your changes could be overwritten)\nextensions.upgrade.mergeConflict.versionToKeep.current=Keep the current version of the page (the extension might not work properly after the upgrade)\nextensions.upgrade.mergeConflict.autoResolve=Resolve automatically\nextensions.upgrade.mergeConflict.autoResolve.hint=Resolve all the remaining merge conflicts automatically by choosing the same page version as now.\nextensions.upgrade.mergeConflict.changes.title=Changes for page {0}\nextensions.upgrade.mergeConflict.changes.original=Compare\nextensions.upgrade.mergeConflict.changes.revised=with\nextensions.upgrade.mergeConflict.changes.versionToCompare.previous=Previous version\nextensions.upgrade.mergeConflict.changes.versionToCompare.current=Current version\nextensions.upgrade.mergeConflict.changes.versionToCompare.next=New version\nextensions.upgrade.mergeConflict.changes.versionToCompare.merged=Merged version\nextensions.uninstall.title=Uninstalling {0}\nextensions.uninstall.error.uninstallFailure=Failed to uninstall extension with id {0} and version {1}:\nextensions.uninstall.error.prepareFailure=Failed to prepare uninstalling extension with id {0} and version {1}:\nextensions.uninstall.error.notInstalled=This extension is not installed.\nextensions.uninstall.cleanPages.label=Delete unused wiki pages?\nextensions.uninstall.cleanPages.hint=The following wiki pages are not needed any more so it should be safe to delete them. Unselect the ones that you wish to keep. The wiki pages that have modifications are left unselected so that you don't loose your changes. Select them if those changes are not important.\nextensions.uninstall.cleanPages.selectedCount={0} / {1} pages selected\nextensions.search.submit=Search\nextensions.search.tip=search extension...\nextensions.search.all.label=All Extensions\nextensions.search.more.label=More\nextensions.search.recommended.label=Recommended only\nextensions.search.recommended.tooltip=Only show extensions explicitly recommended by the XWiki community.\nextensions.search.recommended.fallback=No recommended extension could be found matching ''{0}'', displaying results of the search in all extensions.\nextensions.search.recommended.all.label=All recommended extensions\nextensions.search.recommended.disclaimer=This result only includes recommended extensions.\nextensions.search.indexed.label=Indexed\nextensions.search.indexed.tooltip=Search extensions in the local index or directly on the configured extensions repositories.\nextensions.search.indexed.disclaimer=This only includes indexed extensions.\nextensions.search.indexed.started=Index started on {0}. Any modification made after that to a remote extension won''t appear.\nextensions.search.indexed.on=Indexed on {0}. Any modification made after that to a remote extension won''t appear.\nextensions.search.indexed.nojob=Could not find any previous indexation processing.\nextensions.search.indexed.reindex=Reindex\nextensions.search.indexed.refresh=Refresh\nextensions.search.compatible.label=Compatible only\nextensions.search.compatible.tooltip=Only show extension which can be installed in the current wiki.\nextensions.search.compatible.all.label=All compatible extensions\nextensions.search.compatiblerecommended.disclaimer=This result only includes compatible recommended extensions.\nextensions.search.repository.remote.label=Available Extensions\nextensions.search.repository.core.label=Core extensions\nextensions.search.repository.core.empty=There are no core extensions.\nextensions.search.repository.installed.label=Installed extensions\nextensions.search.repository.installed.empty=There are no extensions installed.\nextensions.search.repository.local.label=Local extensions\nextensions.search.repository.local.empty=There are no local extensions.\nextensions.search.noResults=There were no extensions found matching ''{0}''. Try different keywords.\\nAlternatively, if you know the identifier and the version of the extension you''re looking for, you can use the Advanced Search form above.\nextensions.advancedSearch.title=Advanced search\nextensions.advancedSearch.id.label=Extension ID\nextensions.advancedSearch.version.label=Version\nextensions.advancedSearch.actions.submit=Search\nextensions.advancedSearch.actions.cancel=Cancel\nextensions.advancedSearch.noResults=We couldn''t find any extension with id ''{0}'' and version ''{1}''. Make sure you have the right extension repositories configured.\nextensions.info.authors=by:\nextensions.info.recommended=Recommended\nextensions.info.authors.xwikiorg=XWiki Development Team\nextensions.info.category.description=Description\nextensions.info.category.releaseNotes=Release Notes\nextensions.info.category.dependencies=Dependencies\nextensions.info.category.changes=Changes\nextensions.info.category.progress=Progress\nextensions.info.id=Id\nextensions.info.type=Type\nextensions.info.license={0,choice,0#Unknown license|1#License|1<Licenses}\nextensions.info.features={0,choice,0#No features|1#Feature|1<Features}\nextensions.info.components={0,choice,0#No component|1#Component|1<Components}\nextensions.info.repository=Repository\nextensions.info.website=Website\nextensions.info.scm=Sources\nextensions.info.issueManagement=Issues\nextensions.info.globalNamespace=global namespace\nextensions.info.namespaces.global=Installed globally\nextensions.info.namespaces.list=Installed on the following namespaces\nextensions.info.installedBy=Installed by {0} on {1}\nextensions.info.installedGloballyBy=Installed globally by {0} on {1}\nextensions.info.installedOnNamespaceBy={0}, by {1} on {2}\nextensions.info.dependencies.directDependencies={0,choice,0#|0<This extension depends on:}\nextensions.info.dependencies.backwardDependencies={0,choice,0#|0<This extension is required by:}\nextensions.info.dependency.wiki=(in wiki {0})\nextensions.info.fetch.failed=Failed to retrieve extension data.\nextensions.info.fetch.unauthorized=Unauthorized request. Your session has expired or you lost rights while installing or uninstalling an extension. You need to re-login in order to continue. Do you wish to proceed?\nextensions.info.status.core=Provided\nextensions.info.status.installed=Installed\nextensions.info.status.installed-dependency=Installed as dependency\nextensions.info.status.installed-invalid=Installed but not valid\nextensions.info.status.remote-core=Version {0} is provided\nextensions.info.status.remote-core-incompatible=Incompatible with provided version {0}\nextensions.info.status.remote-installed=Version {0} is installed\nextensions.info.status.remote-installed-dependency=Version {0} is installed as dependency\nextensions.info.status.remote-installed-incompatible=Incompatible with installed version {0}\nextensions.info.status.remote-installed-invalid=Installed version {0} is not valid\nextensions.info.stableVersions.linkLabel=List stable versions\nextensions.info.stableVersions.label=Stable Versions\nextensions.info.stableVersions.noResults=There are no stable versions available.\nextensions.applicationsPanel.install=Install new applications\nextensions.xar.changes.reset.button=Reset\nextension.rendering.macro.error.unknownMacro.followingMacros=This macro is provided by the following compatible extensions:\njob.log.label.install=Install log\njob.log.label.installplan=Install plan log\njob.log.label.uninstall=Uninstall log\njob.log.label.uninstallplan=Uninstall plan log\n\nplatform.extension.info.error.versionNotCompatible=This version is not compatible with your installation.\nplatform.extension.info.error.versionNotCompatibleHint=Search for a compatible version by going through the list of \"Stable Versions\" located in the extension's \"Description\" tab.\n\nplatform.extension.updater.checkForUpdates=Check for updates\nplatform.extension.updater.checkForUpdatesGlobally=Check for updates on farm\nplatform.extension.updater.lastCheckDate=The last time you checked for updates was on {0}.\nplatform.extension.updater.loading=Checking for updates...\nplatform.extension.updater.noUpdatesAvailable=All extensions are up to date.\nplatform.extension.updater.createUpgradePlanFailure=Failed to create the upgrade plan.\nplatform.extension.updater.invalidExtensionsLabel=Invalid extensions\nplatform.extension.updater.invalidExtensionsHint=The following extensions from {0} have to be upgraded or downgraded in order to work with your current distribution:\nplatform.extension.updater.outdatedExtensionsLabel=Outdated extensions\nplatform.extension.updater.outdatedExtensionsHint=The following extensions from {0} can be upgraded:\nplatform.extension.updater.pagingrestart=The list of extensions has been changed; showing first page of the changed list.\n\nplatform.extension.distributionWizard.stepHeading={0,choice,0#|0<Step {0} - } {1}\nplatform.extension.distributionWizard.unknownStepError=Unknown step\nplatform.extension.distributionWizard.continueLabel=Continue\nplatform.extension.distributionWizard.skipLabel=Later\nplatform.extension.distributionWizard.skipHint=Ask me again after XWiki is restarted\nplatform.extension.distributionWizard.replayLabel=Replay recorded actions\nplatform.extension.distributionWizard.replayHint=Upload an extension history file and replay the recorded actions\nplatform.extension.distributionWizard.cancelLabel=Never\nplatform.extension.distributionWizard.cancelHint=I can do this by myself, I don't want to use the wizard\nplatform.extension.distributionWizard.cancelConfirmation=Are you sure you don't want to use the wizard? If you don't know how to do this by yourself then you should continue with the wizard. You won't be able to get back the wizard easily otherwise.\n\nplatform.extension.distributionWizard.welcomeStepTitle=Distribution Wizard\nplatform.extension.distributionWizard.welcomeStepDescription=This wizard will guide you through the process of installing, upgrading or downgrading the XWiki distribution. You are seeing this wizard for one of the following reasons:{0}the default wiki pages recommended for the current version of the XWiki runtime are not installed{1}the version of the XWiki runtime has changed.\nplatform.extension.distributionWizard.welcomeStepStepsHint=The following steps are required in order to complete the XWiki installation:\nplatform.extension.distributionWizard.welcomeStepActionsHint=If you haven't finished configuring XWiki then you can choose to do the installation later. The wizard will reappear after the XWiki runtime is restarted. Although we don't recommend it, you can also do the installation by yourself, but note that you won't be able to get the wizard back easily if you choose to do so. Continue to the next step if you wish to perform the install now. Whatever you choose, after the wizard is closed you will be redirected back to the page you have requested.\n\nplatform.extension.distributionWizard.reportStepTitle=Report\nplatform.extension.distributionWizard.reportStepDescription=The installation is now finished. Here is a report of what happened during the process.\nplatform.extension.distributionWizard.reportStepDocumentsDescription=Various steps of the Distribution Wizard are modifying pages of the wikis. The following tree contains all the pages that have been created, modified or deleted page during the installation.\nplatform.extension.distributionWizard.reportStepDocumentsTitle=Pages\nplatform.extension.distributionWizard.reportStepDocumentsNoChange=No pages were modified during this Distribution Wizard.\nplatform.extension.distributionWizard.reportStepDocumentsDefaultLanguage=Default language\nplatform.extension.distributionWizard.reportStepDocumentDeletedSuccess=Successfully deleted page {0}\nplatform.extension.distributionWizard.reportStepDocumentRestoredSuccess=Successfully restored page {0}\nplatform.extension.distributionWizard.reportStepDocumentRollbackedSuccess=Successfully rollbacked page {0} to version {1}\n\nplatform.extension.distributionWizard.firstadminuserStepTitle=Admin user\nplatform.extension.distributionWizard.firstadminuserStepSummary=Make sure to create a user with administrative right\nplatform.extension.distributionWizard.firstadminuserStepDescription=You need a user with administrative right to install the wiki. This step will help you register and authenticate one for you.\nplatform.extension.distributionWizard.firstadminuser.registerAndLogin=Register and login\nplatform.extension.distributionWizard.firstadminuser.success.connected=You are connected with user {0}.\nplatform.extension.distributionWizard.firstadminuser.error.emptyUserName=Empty user name is not allowed.\nplatform.extension.distributionWizard.firstadminuser.error.emptyPassword=Empty password is not allowed.\nplatform.extension.distributionWizard.firstadminuser.error.passwordMismatch=The passwords do not match.\n\nplatform.extension.distributionWizard.extension.defaultuiStepTitle=User Interface\nplatform.extension.distributionWizard.extension.defaultuiStepSummary=Install the default set of wiki pages recommended for the current version of the XWiki runtime\nplatform.extension.distributionWizard.uiStepNoStateError=Can't get any information about the distribution.\nplatform.extension.distributionWizard.uiStepDescription=The user interface is a set of wiki pages that provide high level features on top of the XWiki runtime. These wiki pages are grouped by features into applications such as blog, activity stream, dashboard. Applications are packaged as extensions installable with the Extension Manager.\nplatform.extension.distributionWizard.uiStepDistributionLabel=Distribution\nplatform.extension.distributionWizard.uiStepDistributionHint=The following distribution has been detected:\nplatform.extension.distributionWizard.uiStepUILabel=User Interface\nplatform.extension.distributionWizard.uiStepUIHint=The following user interface is recommended for your distribution:\nplatform.extension.distributionWizard.uiStepInternetAccessWarning=The installation process requires internet access and it might take a few minutes to complete depending on the internet bandwidth and the load of the remote extension repository. Thank you for your patience.\nplatform.extension.distributionWizard.uiStepUIUnspecifiedError=The detected distribution doesn't specify a default user interface.\n\nplatform.extension.distributionWizard.uiStepPreviousUIUpgradeQuestion=Are you performing an upgrade? There are currently {0} pages in the database which indicates this is not a new install. Unfortunately we couldn''t determine what version of the user interface was previously installed, most probably because you are upgrading from an old version that didn''t have the distribution manager available.\nplatform.extension.distributionWizard.uiStepPreviousUIUpgradeYesLabel=Yes, this is an upgrade\nplatform.extension.distributionWizard.uiStepPreviousUIUpgradeNoLabel=No, this is a new install\nplatform.extension.distributionWizard.uiStepPreviousUIFormHint=Do you know what version of the user interface was previously installed? This would allow us to merge automatically the pages from your database with those from the new version of the user interface. You can still perform the upgrade even if you don't know the previous version but you may have to manually resolve a lot of merge conflicts.\nplatform.extension.distributionWizard.uiStepPreviousUIIdLabel=Previous user interface id\nplatform.extension.distributionWizard.uiStepPreviousUIIdHint=The id should normally have the following format: groupId:artifactId where the group id and the artifact id correspond to the Maven project that generated the XAR. Example: {0}\nplatform.extension.distributionWizard.uiStepPreviousUIVersionLabel=Previous version\nplatform.extension.distributionWizard.uiStepPreviousUIVersionListHint=Select the version from the following list. If your version is not in the list then click on the pencil icon to type your version.\nplatform.extension.distributionWizard.uiStepPreviousUIVersionHint=Examples:\nplatform.extension.distributionWizard.uiStepPreviousUIAdvancedInputHint=Edit\nplatform.extension.distributionWizard.uiStepPreviousUISubmitLabel=Yes, this is it\nplatform.extension.distributionWizard.uiStepPreviousUICancelLabel=I don't know\nplatform.extension.distributionWizard.uiStepPreviousUIRequestFailed=Request failed.\nplatform.extension.distributionWizard.uiStepPreviousUIHint=You indicated the following user interface as being previously installed:\nplatform.extension.distributionWizard.uiStepPreviousUIRepairLabel=Repair\nplatform.extension.distributionWizard.uiStepPreviousUIRepairHint=Register this XAR extension in the installed extensions index\n\nplatform.extension.distributionWizard.extension.defaultui.wikisStepTitle=Wikis\nplatform.extension.distributionWizard.extension.defaultui.wikisStepSummary=Update the default set of wiki pages on each of the existing wikis (except for the main wiki which is handled in the first step).\nplatform.extension.distributionWizard.wikisStepDescription=The following wikis have been detected. You can update the default set of wiki pages on all of them now by installing the user interface version recommended below, or you can do this later by accessing each wiki separately.\n\nplatform.extension.distributionWizard.extension.flavorStepTitle=Flavor\nplatform.extension.distributionWizard.extension.flavorStepSummary=Install or update the flavor of this wiki\nplatform.extension.distributionWizard.flavorStepDescription=The flavor is a set of wiki pages that provide high level features on top of the XWiki runtime. These wiki pages are grouped by features into applications such as blog, activity stream, dashboard. Applications are packaged as extensions installable with the Extension Manager.\nplatform.extension.distributionWizard.flavorStepDistributionLabel=Distribution\nplatform.extension.distributionWizard.flavorStepDistributionHint=The following distribution has been detected:\nplatform.extension.distributionWizard.flavorStepCurrentFlavorLabel=The currently installed flavor\nplatform.extension.distributionWizard.flavorStepCurrentFlavorHint=This is the flavor that was chosen during the previous install (or upgrade). It often need to be upgraded to be in sync with the new distribution.\nplatform.extension.distributionWizard.flavorStepCurrentFlavorInvalidError=The current flavor is not compatible with the current distribution.\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorUpgradeLabel=Try to find a valid version\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorUpgradeHint=Let's try to find a different version of the same flavor that would be compatible with the current distribution.\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorOrInstallNewLabel=Or install a new flavor\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorOrInstallNewHint=If you want to use a different flavor or the current flavor is not maintained anymore and don't have more compatible candidate you can select one of the available flavors.\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorInstallNewLabel=Install a new flavor\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorInstallNewHint=Choose one of the valid flavors found in the configured repositories\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorNoUpgradeError=Could not find any valid version for flavor \"{0}\".\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorUpgradeKnownLabel=Upgrade the flavor\nplatform.extension.distributionWizard.flavorStepInvalidCurrentFlavorUpgradeKnownHint=Here is the version of the current flavor corresponding to the current distribution.\nplatform.extension.distributionWizard.flavorStepNewFlavorLabel=Install a new flavor\nplatform.extension.distributionWizard.flavorStepSelectOtherFlavor=Select other flavor\nplatform.extension.distributionWizard.flavorStepConfirm=You are about to install the following flavor, please confirm or select an other flavor.\nplatform.extension.distributionWizard.flavorStepNoFlavorConfirm=You have chosen to let the wiki be empty, please confirm or go back.\nplatform.extension.distributionWizard.flavorStepNoFlavorBack=Back and select a flavor\nplatform.extension.distributionWizard.flavorStep=\n\nplatform.extension.distributionWizard.extension.flavor.wikisStepTitle=Wikis\nplatform.extension.distributionWizard.extension.flavor.wikisStepSummary=Update the flavor on each of the existing wikis that needs it (except for the main wiki which is handled in the first step).\nplatform.extension.distributionWizard.wikiflavorsStepDescription=The following wikis have been detected. You can update the flavor on all of them now or you can do this later by accessing each wiki separately.\n\nplatform.extension.distributionWizard.extension.outdatedextensionsStepTitle=Extensions\nplatform.extension.distributionWizard.extension.outdatedextensionsStepSummary=Update the installed extensions\nplatform.extension.distributionWizard.extensionsStepDescription=Extensions provide additional features on top of the XWiki runtime. They are commonly distributed as XARs (e.g. {0}XWiki applications{1}, {2}wiki macros{3}, {4}color themes{5}) and JARs (server side code including especially {6}components{7} and {8}script services{9}).\n\nplatform.extension.distributionWizard.extension.cleanStepTitle=Orphaned dependencies\nplatform.extension.distributionWizard.extension.cleanStepSummary=Make sure orphaned extension dependencies are either removed or made top level.\nplatform.extension.distributionWizard.extension.cleanStep.noOrphaned=No orphaned dependency could be found in that instance.\nplatform.extension.distributionWizard.extension.cleanStep.orphaned=The following extensions have been installed as dependencies and are no longer required. You can either uninstall them (checked) or make them top level extensions if you still need them (unchecked).\nplatform.extension.distributionWizard.extension.cleanStep.button.cleanapply=Continue\nplatform.extension.distributionWizard.extension.cleanStep.button.cleanapplyfinalize=Continue\nplatform.extension.distributionWizard.extension.cleanStep.button.cleanapplyreport=Continue\nplatform.extension.distributionWizard.extension.cleanStep.button.back=Back\nplatform.extension.distributionWizard.extension.cleanStep.apply.title=Apply\nplatform.extension.distributionWizard.extension.cleanStep.report.uninstalled=The following extensions have been uninstalled:\nplatform.extension.distributionWizard.extension.cleanStep.report.top=The following extensions have been made top level:\nplatform.extension.distributionWizard.extension.cleanStep.uninstall.finish.error=Failed to uninstall orphaned extensions\nplatform.extension.distributionWizard.extension.cleanStep.uninstall.finish.warning=The orphaned extensions have been successfully uninstalled but unexpected errors where logged during the process\nplatform.extension.distributionWizard.extension.cleanStep.uninstall.finish.success=The orphaned extensions have been successfully uninstalled\n\n### Logging Application Resources\nadmin.logging=Logging\nadmin.logging.description=Review and modify the log level associated to a registered logger.\nlogging.admin.intro=Here you can review and modify the log level associated to a registered logger. <default> or empty log level means that the logger inherits from its parent logger which is the package prefix when it's a package or the default level in the logger implementation configuration if there is no parent.\nlogging.admin.livetable.actions.set=Set\nlogging.admin.livetable.logger=Logger\nlogging.admin.livetable.level=Level\nlogging.admin.livetable.actions=Actions\n\n## Login Form\nplaform.web.login.forgotUserNameOrPassword=Forgot your {0}username{1} or {2}password{3}?\n\n## Initialization\nplatform.web.init.message.initializing=XWiki is initializing ({0}%)...\nplatform.web.init.message.initializationFailure=XWiki initialization failed!\nplatform.web.init.message.initializationSuccess=XWiki is initialized, you will be redirected shortly\nplatform.web.init.message.wiki.initializing=Wiki [{0}] is initializing ({1}%)...\nplatform.web.init.message.wiki.initializationFailure=Wiki [{0}] initialization failed!\nplatform.web.init.message.wiki.initializationSuccess=Wiki [{0}] is initialized, you will be redirected shortly\n\nrating.one-star=Poor\nrating.two-stars=Satisfactory\nrating.three-stars=Good\nrating.four-stars=Very good\nrating.five-stars=Excellent\nrating.votes=Votes\n\n## Hierarchy\nweb.hierarchy.error=Failed to get the full hierarchy.\n\n## XWiki Select Widget\nweb.widgets.select.filter=Filter\nweb.widgets.select.filter.placeholder=Type to filter...\nweb.widgets.select.filter.noResults=No matching result...\n\n## Syntax Picker\nweb.widgets.syntaxPicker.configureSyntaxes=Configure more syntaxes\nweb.widgets.syntaxPicker.conversionConfirmation.title=Syntax Conversion\nweb.widgets.syntaxPicker.conversionConfirmation.message=Do you want to also convert the page content and meta data from the previous {0} syntax to the selected {1} syntax? Choosing ''No'' will only change the syntax identifier, without modifying the page content.\nweb.widgets.syntaxPicker.conversion.inProgress=Converting syntax...\nweb.widgets.syntaxPicker.conversion.done=Syntax converted\nweb.widgets.syntaxPicker.conversion.failed=Syntax conversion failed\nweb.widgets.syntaxPicker.contentUpdate.inProgress=Updating content...\nweb.widgets.syntaxPicker.contentUpdate.done=Content updated\nweb.widgets.syntaxPicker.contentUpdate.failed=Content update failed\nweb.widgets.syntaxPicker.conversionUnsupported.message=The automatic conversion from {0} to {1} syntax is not yet supported. This will change the syntax identifier but you''ll have to do the syntax conversion yourself.\nweb.widgets.syntaxPicker.conversionUnsupported.acknowledge=OK\n\n## Editable Property (in-place editing of properties)\nweb.editableProperty.editFailed=Failed to edit property.\nweb.editableProperty.viewFailed=Failed to view property.\n\n## Drawer\ncore.drawer.global=Global\n\n## Notifications\nnotifications.events.update.description=edited the page\nnotifications.events.update.description.by.1user=edited by {0}\nnotifications.events.update.description.by.users=edited by {0} users\nnotifications.events.addComment.description=commented the page\nnotifications.events.addComment.description.by.1user=commented by {0}\nnotifications.events.addComment.description.by.users=commented by {0} users\nnotifications.events.create.description=created the page\nnotifications.events.create.description.by.1user=created by {0}\nnotifications.events.create.description.by.users=created by {0} users\nnotifications.events.delete.description=deleted the page\nnotifications.events.delete.description.by.1user=deleted by {0}\nnotifications.events.delete.description.by.users=deleted by {0} users\n\n## Templates\n\ntemplate.error.requirement.action=Action [{0}] does not match action requirement [{1}].\n\n###############################################################################\n## Deprecated\n## Note: each element should be removed when the last branch using it is no longer supported\n###############################################################################\n\n## Used to indicate where deprecated keys start\n#@deprecatedstart\n\n#######################################\n## until 14.9\n#######################################\n\nadmin.analytics=Google Analytics\\u2122\nadmin.analytics.description=Configure the Google Analytics\\u2122 account.\nadmin.analytics.account.description=To enable page view tracking in Google Analytics\\u2122, enter your Google Analytics\\u2122 account here. You may enter more accounts (space separated) to track pages in multiple accounts.\nadmin.analytics.method.description=The tracking method you selected when you created the account.\nadmin.analytics.notrunning=Google Analytics\\u2122 is not running.\nadmin.analytics.running=Google Analytics\\u2122 is running.\nadmin.analytics.noscript=The application is unable to retrieve the script required to execute Google Analytics\\u2122.\nXWiki.GoogleAnalyticsCode_method=Tracking Method\nXWiki.GoogleAnalyticsCode_method_universal=Universal Analytics\nXWiki.GoogleAnalyticsCode_method_classic=Classic Analytics\nXWiki.GoogleAnalyticsCode_account=Account\n\n#######################################\n## until 14.6\n#######################################\n\nplatform.extension.distributionWizard.eventmigrationStepTitle=Events migration\nplatform.extension.distributionWizard.eventmigrationStepSummary=Copy events from the legacy event store to the new one\nplatform.extension.distributionWizard.eventmigrationStepDescription=XWiki switched to a new store for events (notifications) in 12.6. Since copying events can be a long process for old wikis with a lot of events and keeping them is not always desired the choice of doing it is left to the wiki administrator. Not copying them imply that any previous notification will seems to have disappeared. The migration is executed in the background and you don't need to wait for it to be finished before going to the next step.\nplatform.extension.distributionWizard.eventmigration.alltime=All time\nplatform.extension.distributionWizard.eventmigration.since=Since\nplatform.extension.distributionWizard.eventmigration.startMigration=Start migration\n\n#######################################\n## until 12.10\n#######################################\n\n#@deprecated extensions.search.all.label\nextensions.search.repository.all.label=All Extensions\n#@deprecated extensions.search.recommended.label\nextensions.search.repository.recommended.label=Recommended Extensions\n#@deprecated extensions.search.recommended.disclaimer\nextensions.search.repository.recommended.disclaimer=This only includes recommended extensions.\n#@deprecated extensions.search.recommended.fallback\nextensions.search.repository.recommended.fallback=No recommended extension could be found matching ''{0}'', displaying results of the search in {1}.\n\n#######################################\n## until 10.1\n#######################################\n\njob.log.label.refactoring/rename=Rename log\njob.log.label.refactoring/copyAs=Copy log\n\n#######################################\n## until 2.3\n#######################################\n\nxe.search.lucene.try=You can also try the new experimental {0}. It adds scoring, searching into attachments and search paging. Please let us know what you think about it.\nxe.search.rebuild.started=Started index rebuild. This will take some time depending on the number of pages/attachments.\nxe.search.rebuild.rights=You must have administrator rights to rebuild the index.\nxe.search.rebuild.inprogress=Another rebuild is in progress.\nxe.search.rebuild.failed=Index rebuild failed.\nxe.search.index.rebuild=Rebuild the Lucene index\nxe.search.default.engine=default search engine\nxe.search.lucene.experimental=This is the new experimental Lucene search engine. You can still use the XWiki {0}.\npanels.search.title=Search\npanels.search.query=Search query\npanels.search.inputLabel=Search\npanels.search.inputText=search...\npanels.search.submit=Go\npanels.search.advanced=Advanced search\n### Search\nxe.search.query=Query\nxe.search.in.space=in space\nxe.search.in.wikis=in wikis\nxe.search.results.one=One result:\nxe.search.results=Results\nxe.search.of=of\nxe.search.page.previous=previous page\nxe.search.page.next=next page\nxe.search.plugin.notfound=Lucene plugin not found. Make sure it's defined in your xwiki.cfg file.\nxe.search.plugin.notenabled=The Lucene plugin is not enabled. You can use the XWiki {0}.\nxe.search.go=Search\nxe.search.web=Search\nxe.search.web.results=Search: {0}\nxe.search.lucene=Lucene Search\nxe.search.lucene.results=Lucene Search: {0}\nxe.search.rss=RSS feed for search on {0}\nxe.search.title=Search\nxe.search.bar.query.tip=search...\nxe.search.bar.query.title=Enter your search query\nxe.search.bar.wikis.all=All wikis\nxe.search.bar.wikis.title=Select wiki\nxe.search.bar.spaces.title=Select spaces\nxe.search.bar.spaces.all=All spaces\nxe.search.bar.submit=Search\nxe.search.bar.submit.title=Search query\nxe.search.bar.queryTip=e.g. xwiki* AND \"search query\"\nxe.search.bar.advanced=Advanced\n### Search results list\nxe.search.item.location=Located in <a href=\"{1}\">{0}</a> &#187; <a href=\"{3}\">{2}</a> &#187; <a href=\"{5}\">{4}</a>\nxe.search.item.modified=Modified by <span class=\"itemAuthor\">{0}</span> on <span class=\"itemDate\">{1}</span>\nxe.search.item.posted=Posted by <span class=\"itemAuthor\">{0}</span> on <span class=\"itemDate\">{1}</span>\nxe.search.item.rating.title=Rating\nxe.search.item.relevance.title=Relevance\nxe.search.item.type.comment.title=Comment\nxe.search.item.type.attachment.title=Attachment\nxe.search.item.type.author.title=Author\nxe.search.item.type.page.title=Page\nxe.search.item.type.wiki.title=Wiki\nxe.search.item.type.space.title=Space\nxe.search.index.uptodate=Lucene index is up to date.\nxe.search.rebuild.currently=Lucene is currently building its index, {0} documents in queue.\n### Results\nxe.results.page=Page\nxe.results.space=Space\nxe.results.wiki=Wiki\nxe.results.date=Date\nxe.results.author=Last Author\nxe.results.score=Score\nxe.results.actions=Actions\nxe.results.newcomment=- 1 new comment\nxe.results.guest=Guest\nxe.results.copy=Copy\nxe.results.delete=Delete\nxe.results.rename=Rename\nxe.results.rights=Rights\n\n#######################################\n## until 2.6 RC2\n#######################################\n\n### Recent Activity Macro\nxe.recentactivity=Recent Activity\nxe.recentactivity.rssfeed=RSS feed\nxe.recentactivity.noentries=There is no recent activity\n\nxe.recentactivity.action.create=created the page\nxe.recentactivity.action.delete=deleted the page\nxe.recentactivity.action.update=edited the page\nxe.recentactivity.action.addAnnotation=added an annotation\nxe.recentactivity.action.deleteAnnotation=deleted an annotation\nxe.recentactivity.action.updateAnnotation=edited an annotation\nxe.recentactivity.action.addAttachment=added {0,choice,1#an attachment|1<{0} attachments}\nxe.recentactivity.action.deleteAttachment=deleted an attachment\nxe.recentactivity.action.updateAttachment=edited {0,choice,1#an attachment|1<{0} attachments}\nxe.recentactivity.action.addComment=added a comment\nxe.recentactivity.action.deleteComment=deleted a comment\nxe.recentactivity.action.updateComment=edited a comment\nxe.recentactivity.action.summary={0,choice,1#one change|1<{0} changes} by {1,choice,1#one user|1<{1} users}\nxe.recentactivity.action.seechanges=see changes\n\n### Wiki and space dashboard (XWiki Enterprise wiki)\nxe.dashboard.wiki.recentactivity=Recent Activity\nxe.dashboard.space.recentactivity=Recent Activity for space {0}\n\n### User profile page\nplatform.core.profile.section.recentactivity=My Recent Activity\n\n### Tag application\nxe.tag.recentactivity=Recent activity in documents tagged with {0}\n\n#######################################\n## until 2.6 RC1\n#######################################\n\n### Recent Changes (XWiki Enterprise wiki)\nxe.recentchanges=Recent Changes\nxe.recentchanges.rssfeed=RSS feed\nxe.recentchanges.summary=This table lists recent changes brought to documents of this wiki, sorted by date (more recent changes come first). Each line contains all the aggregated changes done on a single day and by a given user. For each line, the user's name and avatar are displayed, along with the list of documents modified by that user.\nxe.recentchanges.showminor=Show minor edits\nxe.recentchanges.hideminor=Hide minor edits\nxe.recentchanges.column.authoranddate=Author and date\nxe.recentchanges.column.changes=Changes\nxe.recentchanges.entry.new=new!\nxe.recentchanges.entry.page.seemodifications=See modifications\nxe.recentchanges.entry.page.seemodifications.title=Modifications for {0}\nxe.recentchanges.entry.page.tooltip=Version {0}. Last modification {1}.\nxe.recentchanges.entry.comment.tooltip=Posted at {0}\nxe.recentchanges.entry.comment=comment\nxe.recentchanges.entry.comment.show=show\nxe.recentchanges.entry.comment.hide=hide\nxe.recentchanges.entry.comment.seediscussion=See discussion\n\n### Wiki and space dashboard (XWiki Enterprise wiki)\nxe.dashboard.wiki.recentchanges=Recent Changes\nxe.dashboard.space.recentchanges=Recent Changes for space {0}\n\n### User profile page\nplatform.core.profile.section.recentChanges=Recent Changes\n\n### Tag application\nxe.tag.recentchanges=Recent changes in documents tagged with {0}\n\n#######################################\n## until 2.7\n#######################################\n\n### Validation Messages\nxe.admin.registration.fieldMandatory=This field is mandatory.\nxe.admin.registration.fieldOkay=Ok.\ncore.create.validation.valid=OK\ncore.create.validation.mandatoryfield=Mandatory field\ncore.editors.validation.mandatoryField=This field is mandatory\n\n### Forgot Username (Administration application)\nxe.admin.passwordreset.forgotusername=Forgot your username?\nxe.admin.passwordreset.enteremail=Please enter the email address you provided when creating your account.\nxe.admin.passwordreset.email=Email:\nxe.admin.passwordreset.retrieve=Retrieve username\nxe.admin.passwordreset.noaccountregistered=No account is registered using this email address.\nxe.admin.passwordreset.differentaddress=Try again using another email address\nxe.admin.passwordreset.login=Login\nxe.admin.passwordreset.usernameis=Your username is:\nxe.admin.passwordreset.multipleusernames=The following usernames are registered with this email address:\nxe.admin.passwordreset.forgotpassword=Forgot your password?\nxe.admin.passwordreset.startprocess=Please enter your username to start the password recovery process.\nxe.admin.passwordreset.username=Username:\nxe.admin.passwordreset.resetpassword=Reset password\nxe.admin.passwordreset.nouser=The ~~{0}~~ user does not exist.\nxe.admin.passwordreset.ldapuser=The ~~{0}~~ user is an LDAP user. In that case the password has to be changed on the LDAP server.\nxe.admin.passwordreset.cannotreset=Cannot reset password: email address not provided in the user profile.\nxe.admin.passwordreset.emailsent=An e-mail was sent to <tt>{0}</tt>. Please follow the instructions in that e-mail to complete the password reset procedure.\nxe.admin.passwordreset.reseterror=An unknown problem occurred while sending the reset email.\nxe.admin.passwordreset.retry=Retry\nxe.admin.passwordreset.noprogrammingrights=This page requires programming rights to work, which currently isn't the case. Please notify an administrator of this problem and try again later.\nxe.admin.passwordreset.resetfor=Reset password for ~~{0}~~\nxe.admin.passwordreset.emptystring=The password cannot be an empty string.\nxe.admin.passwordreset.nomatch=The two passwords do not match.\nxe.admin.passwordreset.newpassword=New password:\nxe.admin.passwordreset.reenterpassword=Re-enter new password:\nxe.admin.passwordreset.save=Save\nxe.admin.passwordreset.notempty=The password cannot be empty.\nxe.admin.passwordreset.success=The password has been successfully set. Please\nxe.admin.passwordreset.loginsmall=login\nxe.admin.passwordreset.successend=to continue.\nxe.admin.passwordreset.wrongparameters=Wrong parameters.\nxe.admin.passwordreset.backtoreset=Back to the password reset page\n\npanels.documentInformation.parent=Parent:\n\n#######################################\n## until 3.0M2 \n#######################################\ncore.copy.copydoc=Copy Page\ncore.copy.sourcedoc=Source page\ncore.copy.sourcedoc.hint=Location of the original page\ncore.copy.targetdoc=Target page\ncore.copy.targetdoc.hint=Desired location for the copied page\n\n#######################################\n## until 3.0M3\n#######################################\nadmin.general.description=General settings of the wiki.\nadmin.admin=Administrator\nyoucanclicktoedit=You can <a href=\"${doc.getURL('create')}\">edit this page</a> to create it.\n\n#######################################\n## until 3.0\n#######################################\nXWiki.XWikiPreferences_webbgcolor=Space Background Color\nXWiki.XWikiPreferences_menu=Menu\nXWiki.XWikiPreferences_editbox_width=Editbox Width\nXWiki.XWikiPreferences_editbox_height=Editbox Height\nXWiki.XWikiPreferences_ad_clientid=Advertisement Client ID\nXWiki.XWikiPreferences_macros_languages=Macros Languages\nXWiki.XWikiPreferences_macros_velocity=Macros for Velocity\nXWiki.XWikiPreferences_macros_groovy=Macros for Groovy\nXWiki.XWikiPreferences_macros_wiki2=Macros for new wiki Parser\nXWiki.XWikiPreferences_macros_mapping=Macros Mapping\nXWiki.XWikiPreferences_macros_wiki=Macros for the wiki Parser\nXWiki.XWikiPreferences_notification_pages=Notification Pages\nXWiki.XWikiPreferences_renderXWikiVelocityRenderer=Render velocity code\nXWiki.XWikiPreferences_renderXWikiGroovyRenderer=Render Groovy code\nXWiki.XWikiPreferences_renderXWikiRadeoxRenderer=Render Wiki syntax\nXWiki.XWikiPreferences_pageWidth=Preferred page width\nXWiki.XWikiPreferences_convertmail=convert email type\n\n#######################################\n## until 3.2M3\n#######################################\nxe.scheduler.jobs.infos=Infos\nxe.scheduler.jobs.add=Add\nxe.index.attachments.doc.date=Date\nxe.index.attachments.doc.author=Author\n\n#######################################\n## until 3.3M1\n#######################################\nplatform.core.profile.dashboard.displayOnMainPage=Display my dashboard on the wiki home when I'm logged in (instead of the default dashboard)\nplatform.core.profile.section.dashboard.preferences=Dashboard preferences\nxe.dashboard.wiki=Dashboard\nxe.dashboard.wiki.spaces=Spaces\nxe.dashboard.wiki.tagcloud=Tags\nxe.dashboard.wiki.activity=Activity Stream\nxe.dashboard.wiki.welcome=Welcome to your wiki\nxe.dashboard.wiki.personal.empty.edit=edit the dashboard section in your profile\nxe.dashboard.wiki.personal.empty=Your dashboard is currently empty. You can {0} to configure it. In the mean time, the default dashboard is displayed below.\nxe.dashboard.space=Dashboard for space {0}\nxe.dashboard.space.activity=Activity Stream for space {0}\nxe.dashboard.space.documents=Documents in space {0}\nxe.dashboard.space.remainingDocumentsInSpace=and {0} {0,choice,1#more document|1<more documents} in space {1}\nxe.dashboard.space.visitSpaceIndex=visit the Space Index to see the full list\n\n#######################################\n## until 3.4M1\n#######################################\ncore.create.template.empty=Empty Wiki Page\n\n#######################################\n## until 3.5\n#######################################\n\n#@deprecated platform.livetable.results\nxe.livetable.results=Livetable Results\n\n#@deprecated platform.livetable.resultsMacros\nxe.livetable.resultsmacros=Livetable Results Macros\n\n#@deprecated platform.livetable._actions.delete\nxe.livetable._actions.delete=delete\n\n#@deprecated platform.livetable._actions.rename\nxe.livetable._actions.rename=rename\n\n#@deprecated platform.livetable._actions.rights\nxe.livetable._actions.rights=rights\n\n#@deprecated platform.livetable._actions.copy\nxe.livetable._actions.copy=copy\n\n#@deprecated platform.livetable.filtersTitle\nxe.livetable.filters.title=Filter for the {0} column\n\n#@deprecated platform.livetable.loading\nxe.livetable.loading=Loading...\n\n#@deprecated platform.livetable.tagsHelp\nxe.livetable.tags.help=Click on one or more tags to filter the list\n\n#@deprecated platform.livetable.tagsHelpCancel\nxe.livetable.tags.help.cancel=and click again on a tag to cancel the filter\n\n#@deprecated platform.livetable.environmentCannotLoadTableMessage\nxe.livetable.environmentCannotLoadTableMessage=The environment prevents the table from loading data.\n\n#@deprecated platform.livetable.pagesizeLabel\nxe.livetable.pagesize.label=per page of\n\n#@deprecated platform.livetable.selectAll\nxe.livetable.select.all=All\n\n#@deprecated platform.livetable.paginationPage\nxe.pagination.page=Page\n\n#@deprecated platform.livetable.paginationPageTitle\nxe.pagination.page.title=Go to page {0}\n\n#@deprecated platform.livetable.paginationPagePrevious\nxe.pagination.page.previous=&#171; previous page\n\n#@deprecated platform.livetable.paginationPagePrevTitle\nxe.pagination.page.prev.title=Previous Page\n\n#@deprecated platform.livetable.paginationPageNext\nxe.pagination.page.next=next page &#187;\n\n#@deprecated platform.livetable.paginationPageNextTitle\nxe.pagination.page.next.title=Next Page\n\n#@deprecated platform.livetable.paginationResultsNone\nxe.pagination.results.none=No results\n\n#@deprecated platform.livetable.paginationResultsOne\nxe.pagination.results.one=One result\n\n#@deprecated platform.livetable.paginationResultsSingle\nxe.pagination.results.single=Result <span class=\"currentResultsNo\">{0}</span> of <span class=\"totalResultsNo\">{1}</span>\n\n#@deprecated platform.livetable.paginationResultsMany\nxe.pagination.results.many=Results <span class=\"currentResultsNo\">{0} - {1}</span> of <span class=\"totalResultsNo\">{2}</span>\n\n#@deprecated platform.livetable.paginationResults\nxe.pagination.results=Results\n\n#@deprecated platform.livetable.paginationResultsOf\nxe.pagination.results.of=out of\n\n#@deprecated platform.index.documents\nxe.index.documents=Documents on this Wiki\n\n#@deprecated platform.index\nxe.index=Index\n\n#@deprecated platform.index.tree\nxe.index.tree=Tree\n\n#@deprecated platform.index.orphaned\nxe.index.orphaned=Orphaned Pages\n\n#@deprecated platform.index.orphanedResults\nxe.index.orphaned.results=Orphaned Pages JSON Service\n\n#@deprecated platform.index.attachments\nxe.index.attachments=Attachments\n\n#@deprecated platform.index.attachmentsResults\nxe.index.attachments.results=Attachments JSON Service\n\n#@deprecated platform.index.doc.name\nxe.index.doc.name=Page\n\n#@deprecated platform.index.doc.space\nxe.index.doc.space=Space\n\n#@deprecated platform.index.doc.date\nxe.index.doc.date=Date\n\n#@deprecated platform.index.doc.author\nxe.index.doc.author=Last Author\n\n#@deprecated platform.index._actions\nxe.index._actions=Actions\n\n#@deprecated platform.index.emptyvalue\nxe.index.emptyvalue=\n\n#@deprecated platform.index.attachments.filename\nxe.index.attachments.filename=Filename\n\n#@deprecated platform.index.attachments.doc.name\nxe.index.attachments.doc.name=Page\n\n#@deprecated platform.index.attachments.doc.space\nxe.index.attachments.doc.space=Space\n\n#@deprecated platform.index.attachments.date\nxe.index.attachments.date=Date\n\n#@deprecated platform.index.attachments.author\nxe.index.attachments.author=Author\n\n#@deprecated platform.index.attachments.type\nxe.index.attachments.type=Type\n\n#@deprecated platform.index.attachments.emptyvalue\nxe.index.attachments.emptyvalue=\n\n#@deprecated platform.index.documentsTrash\nxe.index.documentsTrash=Deleted Documents\n\n#@deprecated platform.index.trashDocumentsEmpty\nxe.index.trash.documents.empty=No deleted documents\n\n#@deprecated platform.index.trashDocuments.ddoc.fullName\nxe.index.trash.documents.ddoc.fullName=Document\n\n#@deprecated platform.index.trashDocuments.ddoc.title\nxe.index.trash.documents.ddoc.title=Title\n\n#@deprecated platform.index.trashDocuments.ddoc.date\nxe.index.trash.documents.ddoc.date=Deleted on\n\n#@deprecated platform.index.trashDocuments.ddoc.deleter\nxe.index.trash.documents.ddoc.deleter=Deleted by\n\n#@deprecated platform.index.trashDocuments.actions\nxe.index.trash.documents.actions=\n\n#@deprecated platform.index.trashDocumentsActionsRestoreTooltip\nxe.index.trash.documents.actions.restore.tooltip=Restore document\n\n#@deprecated platform.index.trashDocumentsActionsRestoreText\nxe.index.trash.documents.actions.restore.text=[restore]\n\n#@deprecated platform.index.trashDocumentsActionsCannotRestoreTooltip\nxe.index.trash.documents.actions.cannotRestore.tooltip=The document cannot be restored to its original location because it has been recreated\n\n#@deprecated platform.index.trashDocumentsActionsCannotRestoreText\nxe.index.trash.documents.actions.cannotRestore.text=[cannot restore]\n\n#@deprecated platform.index.trashDocumentsActionsDeleteTooltip\nxe.index.trash.documents.actions.delete.tooltip=Permanently delete document\n\n#@deprecated platform.index.trashDocumentsActionsDeleteText\nxe.index.trash.documents.actions.delete.text=[delete]\n\n#@deprecated platform.index.trashDocumentsDeleteInProgress\nxe.index.trash.documents.delete.inProgress=Permanently deleting document...\n\n#@deprecated platform.index.trashDocumentsDeleteDone\nxe.index.trash.documents.delete.done=Document permanently deleted\n\n#@deprecated platform.index.trashDocumentsDeleteFailed\nxe.index.trash.documents.delete.failed=Failed to delete:\n\n#@deprecated platform.index.trashDocumentsDeleteInformation\nxe.index.trash.documents.deleteInformation=Deleted by {0} on {1}\n\n#@deprecated platform.index.attachmentsTrash\nxe.index.attachmentsTrash=Deleted Attachments\n\n#@deprecated platform.index.trashAttachmentsEmpty\nxe.index.trash.attachments.empty=No deleted attachments\n\n#@deprecated platform.index.trashAttachments.datt.filename\nxe.index.trash.attachments.datt.filename=Attachment\n\n#@deprecated platform.index.trashAttachments.datt.docName\nxe.index.trash.attachments.datt.docName=Document\n\n#@deprecated platform.index.trashAttachments.datt.date\nxe.index.trash.attachments.datt.date=Deleted on\n\n#@deprecated platform.index.trashAttachments.datt.deleter\nxe.index.trash.attachments.datt.deleter=Deleted by\n\n#@deprecated platform.index.trashAttachments.actions\nxe.index.trash.attachments.actions=\n\n#@deprecated platform.index.trashAttachmentsActionsRestoreTooltip\nxe.index.trash.attachments.actions.restore.tooltip=Restore attachment\n\n#@deprecated platform.index.trashAttachmentsActionsRestoreText\nxe.index.trash.attachments.actions.restore.text=[restore]\n\n#@deprecated platform.index.trashAttachmentsActionsCannotRestoreTooltip\nxe.index.trash.attachments.actions.cannotRestore.tooltip=The attachment cannot be restored to its original location because another file with the same name has been attached.\n\n#@deprecated platform.index.trashAttachmentsActionsCannotRestoreText\nxe.index.trash.attachments.actions.cannotRestore.text=[cannot restore]\n\n#@deprecated platform.index.trashAttachmentsActionsDeleteTooltip\nxe.index.trash.attachments.actions.delete.tooltip=Permanently delete attachment\n\n#@deprecated platform.index.trashAttachmentsActionsDeleteText\nxe.index.trash.attachments.actions.delete.text=[delete]\n\n#@deprecated platform.index.trashAttachmentsDeleteInProgress\nxe.index.trash.attachments.delete.inProgress=Permanently deleting attachment...\n\n#@deprecated platform.index.trashAttachmentsDeleteDone\nxe.index.trash.attachments.delete.done=Attachment permanently deleted\n\n#@deprecated platform.index.trashAttachmentsDeleteFailed\nxe.index.trash.attachments.delete.failed=Failed to delete:\n\n#@deprecated platform.index.spaceIndex\nxe.space.index=Space Index\n\n#@deprecated platform.index.spaceIndexDescription\nxe.space.index.description=Pages in the {0} space:\n\n#@deprecated platform.index.spaceIndexDocumentListCreate\nxe.spaceIndex.documentList.create=Create a new page\n\n#######################################\n## until 4.1M1\n#######################################\n\n#@deprecated core.viewers.diff.class.changed\ncore.viewers.diff.class.changes=Changed property {0}\n\n#######################################\n## until 4.1RC1\n#######################################\ncore.viewers.diff.summary=Show changes done between selected versions\ncore.viewers.diff.property=Property\ncore.viewers.diff.oldValue=Previous value\ncore.viewers.diff.newValue=New value\ncore.viewers.diff.attachment.filename=Filename\ncore.viewers.diff.attachment.action=Action\n\n#######################################\n## until 4.2M1\n#######################################\nextensions.advancedSearch.wiki.label=The wiki where to install\n#@deprecated extensions.install.list.install\nextensions.install.list.new=The following new extensions will be installed:\nextensions.install.list.suggested=Suggested:\nextensions.install.list.conflict=Conflict with core extensions:\nextensions.install.error.conflictingExtension=extension {0} is needed in version {1} but core extension has version {2}\nextensions.install.error.installFailure.onWiki=Failed to install extension with id {0} and version {1} on wiki {2}:\n\n#######################################\n## until 4.3M1\n#######################################\nxe.officeimporter.results.missingspace=Missing target space name. Please {0} and correct it.\nxe.officeimporter.results.missingpage=Missing target page name. Please {0} and correct it.\nextensions.uninstall.list=The following extensions will be removed:\n\n#@deprecated platform.extension.distributionWizard.welcomeStepTitle\nextensions.distribution.wizardTitle=Distribution Wizard\n\n#@deprecated platform.extension.distributionWizard.uiStepNoStateError\nextensions.distribution.error.noState=Can't get any information about the distribution.\n\n#@deprecated platform.extension.distributionWizard.uiStepDistributionHint\nextensions.distribution.hint=The following distribution has been detected:\n\n#@deprecated platform.extension.distributionWizard.uiStepUIHint\nextensions.distribution.uiHint=The following user interface is recommended for your distribution:\n\n#@deprecated platform.extension.distributionWizard.uiStepUIUnspecifiedError\nextensions.distribution.error.noUI=The detected distribution doesn't specify a default user interface.\n\n#@deprecated platform.extension.distributionWizard.extensionsStepUpToDate\nextensions.distribution.upToDate=All extensions are up to date.\n\n#@deprecated platform.extension.distributionWizard.extensionsStepInvalidExtensionsLabel\nextensions.distribution.list.invalid.label=Invalid extensions\n\n#@deprecated platform.extension.distributionWizard.extensionsStepInvalidExtensionsHint\nextensions.distribution.list.invalid.hint=The following extensions have to be upgraded or downgraded in order to work with your current distribution:\n\n#@deprecated platform.extension.distributionWizard.extensionsStepOutdatedExtensionsLabel\nextensions.distribution.list.outdated.label=Outdated extensions\n\n#@deprecated platform.extension.distributionWizard.extensionsStepOutdatedExtensionsHint\nextensions.distribution.list.outdated.hint=The following extensions can be upgraded:\n\n#@deprecated platform.extension.distributionWizard.extensionsStepPrepareUpgradeFailure\nextensions.distribution.error.prepareUpgradeFailure=Failed to create upgrade plan.\n\n#@deprecated platform.extension.distributionWizard.continueLabel\nextensions.distribution.stepAction.complete=Continue\n\n#@deprecated platform.extension.distributionWizard.skipLabel\nextensions.distribution.stepAction.skip=Skip\n\n#@deprecated platform.extension.distributionWizard.skipHint\nextensions.distribution.stepAction.skip.hint=Ask me again after XWiki is restarted\n\n#@deprecated platform.extension.distributionWizard.cancelLabel\nextensions.distribution.stepAction.cancel=Cancel\n\n#@deprecated platform.extension.distributionWizard.cancelHint\nextensions.distribution.stepAction.cancel.hint=Let me complete the installation manually\n\n#######################################\n## until 4.3M2\n#######################################\nxe.admin.local=Local\nxe.admin.groups.addGroup.submit=Add\nxe.admin.groups.addUser.duplicate=The user is already a member of this group\nxe.admin.groups.addGroup.duplicate=The group is already a subgroup\n\n#######################################\n## until 4.4RC1\n#######################################\n\n#@deprecated action.addClassProperty.error.invalidName\npropertynamenotcorrect=Property names must follow these naming rules: <br/>Names can contain letters, numbers, and the following characters: \"., -, _, :\" <br/>Names must not start with a number or punctuation character. <br/>Names must not start with the letters xml (or XML, or Xml, etc). <br/>Names cannot contain spaces.\n\n#######################################\n## until 4.5\n#######################################\nextensions.info.dependency=Installed as a dependency needed by another extension\nextensions.install.actions.submit=Apply\nextensions.install.actions.cancel=Cancel\nextensions.uninstall.actions.submit=Apply\nextensions.uninstall.actions.cancel=Cancel\n\n#######################################\n## until 5.0M2\n#######################################\n## Translations should not contain velocity code\neditpageTitle=Editing $services.localization.render($editor) for $tdoc.displayTitle\n\n#######################################\n## until 5.0RC1\n#######################################\navailableversionsattachment=The available versions of file '$attachment.filename' are:\nplatform.extension.distributionWizard.experimentalWarning=This feature is currently experimental. It has some rough edges which we hope to fix in the next versions. Please report any {0}issues{1} you may encounter while using the distribution wizard.\n\n#@deprecated platform.extension.distributionWizard.extension.defaultuiStepTitle\nplatform.extension.distributionWizard.uiStepTitle=User Interface\n\n#@deprecated platform.extension.distributionWizard.extension.defaultuiStepSummary\nplatform.extension.distributionWizard.uiStepSummary=Install the default set of wiki pages recommended for the current version of the XWiki runtime\n\n#@deprecated platform.extension.distributionWizard.extension.outdatedextensionsStepTitle\nplatform.extension.distributionWizard.extensionsStepTitle=Extensions\n\n#@deprecated platform.extension.distributionWizard.extension.outdatedextensionsStepSummary\nplatform.extension.distributionWizard.extensionsStepSummary=Update the installed extensions\n\n#@deprecated platform.extension.updater.noUpdatesAvailable\nplatform.extension.distributionWizard.extensionsStepUpToDate=All extensions are up to date.\n\n#@deprecated platform.extension.updater.invalidExtensionsLabel\nplatform.extension.distributionWizard.extensionsStepInvalidExtensionsLabel=Invalid extensions\n\n#@deprecated platform.extension.updater.invalidExtensionsHint\nplatform.extension.distributionWizard.extensionsStepInvalidExtensionsHint=The following extensions from {0} have to be upgraded or downgraded in order to work with your current distribution:\n\n#@deprecated platform.extension.updater.outdatedExtensionsLabel\nplatform.extension.distributionWizard.extensionsStepOutdatedExtensionsLabel=Outdated extensions\n\n#@deprecated platform.extension.updater.outdatedExtensionsHint\nplatform.extension.distributionWizard.extensionsStepOutdatedExtensionsHint=The following extensions from {0} can be upgraded:\n\n#@deprecated platform.extension.updater.createUpgradePlanFailure\nplatform.extension.distributionWizard.extensionsStepPrepareUpgradeFailure=Failed to create upgrade plan.\n\n#@deprecated platform.extension.updater.loading\nplatform.extension.distributionWizard.extensionsStepLoading=Please wait a few minutes for the upgrade plan to be computed...\n\n#@deprecated platform.extension.updater.reloadHint\nplatform.extension.distributionWizard.extensionsStepReloadHint=In case this information is outdated you can {0}recompute{1} the upgrade plan.\n\nannotations.title=Annotations\nannotations.menu.loading=Loading annotations settings\nannotations.menu.loaderror=Failed:\nannotations.tab.info.noannotations=No annotations for this document\nannotations.settings.display=Show annotations\nannotations.settings.error.wrongsyntax=Annotations are not available for documents in XWiki/1.0 syntax.\nannotations.settings.error.notarget=No document specified to get annotations settings for.\nannotations.annotated.loading=Loading annotated document\nannotations.annotated.loaderror=Failed:\nannotations.annotated.loaderror.wrongresponse=Wrongly formatted server response\nannotations.annotated.error.noannotatedelement=Annotations could not be loaded because the content is not available.\nannotations.annotated.error.wrongsyntax=Annotations are not available for documents in XWiki/1.0 syntax.\nannotations.action.edit.text=[Edit]\nannotations.action.edit.tooltip=Edit this annotation\nannotations.action.edit.submit.text=Update\nannotations.action.edit.cancel.text=Cancel\nannotations.action.edit.success=Annotation has been successfully updated.\nannotations.action.edit.loaderror=Failed:\nannotations.action.edit.error.notfound=This annotation does not exist anymore. Please refresh the page for an updated view.\nannotations.action.delete.text=[Delete]\nannotations.action.delete.tooltip=Delete this annotation\nannotations.action.delete.confirm=Are you sure you want to delete this annotation?\nannotations.action.delete.inProgress=Deleting annotation...\nannotations.action.delete.done=Annotation deleted\nannotations.action.delete.failed=Failed to delete annotation:\nannotations.action.create.submit.text=Add annotation\nannotations.action.create.cancel.text=Cancel\nannotations.action.create.selection.invalid=Please select a nonempty text in the document content.\nannotations.action.create.form.loaderror=Failed:\nannotations.action.create.success=Annotation has been successfully added\nannotations.action.create.loaderror=Failed:\nannotations.action.create.error.unauthorized=You are not authorized to add annotations on this document.\nannotations.action.create.error.unauthorizedguest=You are not authorized to add annotations on this document. Try to login first.\nannotations.action.create.helpmessage=To annotate a piece of text, select it and hit {0}.\nannotations.action.create.error.wrongsyntax=Annotations are not available for documents in XWiki/1.0 syntax.\nannotations.action.create.error.notarget=Unspecified target (document) to create annotations for.\nannotations.action.view.hide.text=hide\nannotations.action.view.form.loaderror=Failed:\nannotations.action.view.error.notfound=This annotation does not exist anymore. Please refresh the page for an updated view.\nannotations.altered.text=This annotation could not be displayed because the annotated text was not found in the document:\nannotations.updated.text=This annotation was automatically repositioned after an update of the document. Originally:\nannotations.action.validate.text=[Validate]\nannotations.action.validate.tooltip=Validate the automatic update of the selected text of this annotation\nannotations.action.validate.success=Annotation has been successfully validated.\nannotations.action.validate.loaderror=Failed:\nannotations.filters.show=Refine the display criteria\nannotations.filters.nooption=There are no values to filter for \"{0}\"\nannotations.filters.anyvalue=any value\nannotations.filters.clearvalue=clear\nannotations.config.title=Annotations configuration panel\nannotations.config.display.title=Annotation display settings\nannotations.config.type.title=Annotation type settings\nannotations.config.activate.title=Annotation activation settings\nannotations.config.activate.explanation=The following two settings allow you to configure in which spaces are annotations active. The first setting specifies the general rule, while the second list specifies the spaces for which the rule shouldn't apply. For example, activated \"yes\" and exception spaces \"XWiki\" and \"Main\" means that annotations will be active on all spaces except for \"XWiki\" and \"Main\", while activated \"no\" and exception spaces \"Documents\" means that annotations will be active only for the \"Documents\" space.\nannotations.config.type.explanation=Add properties to this class if you want extra properties for your annotations.\nadmin.annotations=Annotations\n\n#######################################\n## until 5.1RC1\n#######################################\n\n#@deprecated admin.analytics.account.description\nadmin.analytics.sectiondesc=To enable page view tracking in Google Analytics\\u2122, enter your Google Analytics\\u2122 account here. You may enter more accounts (space separated) to track pages in multiple accounts.\n\ndashboard.gadget.actions.tooltip=Gadget settings\n\n#######################################\n## until 5.1\n#######################################\nadmin.sender=Default sender email address\n\n#######################################\n## until 5.2M2\n#######################################\npanels.translation.originalLanguage=The original language of the document is <a href=\"{0}\">{1}</a>.\n\n#######################################\n## until 5.2M2\n#######################################\nxe.tag.rss.tag.title=RSS feed for tag: {0}\nxe.tag.rss.tag.description=RSS feed for all pages containing tag: {0}\nxe.tag.rss.tags.title=RSS feed for tagged pages\nxe.tag.rss.tags.description=RSS feed for all pages containing tags\nxe.rss.space.description=RSS feed for document changes on space \"{0}\"\n\n#######################################\n## until 5.4RC1\n#######################################\nplatform.extension.distributionWizard.upgrademodeStepTitle=Upgrade Mode\nplatform.extension.distributionWizard.upgrademodeStepSummary=Choose whether to upgrade the entire farm or just the main wiki\nplatform.extension.distributionWizard.upgradeStepModeLabel=Upgrade mode\nplatform.extension.distributionWizard.upgradeStepModeHint=Choose carefully because the upgrade process may involve fixing merge conflicts and thus it's recommended to leave this to the person that knows best how to fix them.\nplatform.extension.distributionWizard.upgradeStep.mode.WIKI.label=Upgrade only the current wiki. Choose this option if each wiki is administrated by a separate entity. In this case it's best if each wiki is upgraded by its owner.\nplatform.extension.distributionWizard.upgradeStep.mode.ALLINONE.label=Upgrade all wikis. Choose this option if all wikis are administrated by the same entity.\n\n#######################################\n## until 6.0M1\n#######################################\nxe.panels.viewer=Viewer panels\nxe.panels.editor=Editor panels\n\n#######################################\n## until 6.0M2\n#######################################\nplatform.extension.updater.reloadHint=In case this information is outdated you can {0}recompute{1} the upgrade plan.\n\n#######################################\n## until 6.1M1\n#######################################\nxe.userdirectory.doc.fullName=User ID\n\n#######################################\n## until 6.2M1\n#######################################\nextensions.info.jobLog=Job log\n\n#@deprecated job.log.label.install\nextensions.info.jobLog.install=Install log\n#@deprecated job.log.label.installplan\nextensions.info.jobLog.installplan=Install plan log\n#@deprecated job.log.label.uninstall\nextensions.info.jobLog.uninstall=Uninstall log\n#@deprecated job.log.label.uninstallplan\nextensions.info.jobLog.uninstallplan=Uninstall plan log\n\n#######################################\n## until 6.3\n#######################################\neditincludepagemsgone=$pages.size() included document\neditincludepagemsgmore=$pages.size() included documents\nsimpleedittoolbardesc=Click on a button to get a sample text\nsimpleedittoolbardesc2=Enter the text that you wish to format. It will be shown to be copy-pasted.\\\\nExample:\\\\n$1\\\\nwill become:\\\\n$2\nmyhomepage=$xwiki.getDocument($context.user).display(\"first_name\", \"view\", $xwiki.getDocument($context.user).getObject(\"XWiki.XWikiUsers\", 0))'s profile\nviewcodetitle=Wiki code for <em>$doc.displayTitle</em>\nviewcommentstitle=Comments for <em>$doc.displayTitle</em>\nviewattachmentstitle=Attachments for <em>$doc.displayTitle</em>\nviewhistorytitle=History of <em>$doc.displayTitle</em>\nviewinformationtitle=Information about <em>$doc.displayTitle</em>\neditgroupsredirect=You can currently edit groups using the wiki on <a href=\"$xwiki.getURL(\"XWiki.XWikiGroups\")\">the groups page</a>.\neditusersredirect=You can currently edit users using the wiki on <a href=\"$xwiki.getURL(\"XWiki.XWikiUsers\")\">the users page</a>.\n\n#######################################\n## until 6.4M2\n#######################################\nplatform.appwithinminutes.liveTableEditorIconHint=You need to provide a reference to a 16x16px icon, you can pick a name from our <a href=\"{0}\" target=\"_blank\">default icons set</a> and use the **icon:** prefix. For example: **icon:application**.\nadmin.email=Email\nadmin.email.description=Configure the email sending process.\nXWiki.XWikiPreferences_smtp_server=Server\nXWiki.XWikiPreferences_smtp_port=Port\nXWiki.XWikiPreferences_smtp_server_username=Server username (optional)\nXWiki.XWikiPreferences_smtp_server_password=Server password (optional)\nXWiki.XWikiPreferences_javamail_extra_props=Additional JavaMail properties\nXWiki.XWikiPreferences_admin_email=Admin email\nXWiki.XWikiPreferences_admin_email.hint=The default email address used to send notification emails from\nXWiki.XWikiPreferences_obfuscateEmailAddresses=Obfuscate Email Addresses\nXWiki.XWikiPreferences_obfuscateEmailAddresses.hint=This affects only the email addresses stored in object properties of type Email, as long as the default custom displayer for the Email property type is not overwritten. Example: a...@domain.org\n\n#######################################\n## until 7.0M1\n#######################################\nplatform.appwithinminutes.classEditorDatePickerMonthNames=January, February, March, April, May, June, July, August, September, October, November, December\nplatform.appwithinminutes.classEditorDatePickerWeekDayNames=Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday\nplatform.appwithinminutes.classEditorDatePickerFirstWeekDay=0\n\n#######################################\n## until 7.0M2\n#######################################\n\n### RSS\nxe.rss.feeds=RSS Feeds\nxe.rss.feeds.description=There are currently 4 types of RSS feeds available on this wiki. You can subscribe to each of them by clicking on their name or on the icon next to them.\nxe.rss.search=Search RSS feeds:\nxe.rss.search.description=RSS feed on a specific search query term. To generate such a feed, go to the {0} page, run a search on a keyword and then click on the RSS icon.\nxe.rss.tags=Tags RSS feeds:\nxe.rss.tags.feed=Tags RSS Feed\nxe.rss.tags.description=RSS feed on documents tagged with a specific term or all documents with a tag. To generate such a feed, go to the {0} page and click on the RSS feed icon you wish to use.\nxe.rss.blog=Blog RSS feed:\nxe.rss.blog.feed=Blog RSS Feed\nxe.rss.blog.description=RSS feed of blog posts from all blogs.\nxe.rss.global=Global RSS feed:\nxe.rss.global.description=RSS feed of page activity.\nxe.rss.icon=rss icon\nxe.rss.version=Version\nxe.rss.editedby=edited by\nxe.rss.on=on\n\n#######################################\n## until 7.0RC1\n#######################################\n\n### Spaces (XWiki Enterprise wiki)\nxe.spaces=Spaces\nxe.spaces.createspace=Create a new space\nxe.spaces.createspace.defaultname=Space name\nxe.spaces.createspace.submit=Create\nxe.spaces.action.index=See space index\nxe.spaces.action.index.alt=Space index\nxe.spaces.action.admin=See space administration\nxe.spaces.action.admin.alt=Administer space\nxe.spaces.action.delete.alt=Delete space\nxe.spaces.deleteSpace.deleted=Space \\u00AB{0}\\u00BB deleted.\n\n### RSS\nxe.rss.pages.modified=Modified Pages RSS Feed\nxe.rss.feed.description=RSS feed for document changes\nxe.rss.feed.tags.description=RSS feed for documents tagged with \"{0}\"\nxe.rss.feed.spaces.description=RSS feed for documents in space(s) \"{0}\"\nxe.rss.feed.tagsAndSpaces.description=RSS feed for documents tagged with \"{0}\" in space(s) \"{1}\"\n\n### History\ncore.viewers.diff.tag.tags=Tags\ncore.viewers.diff.contentChanges=Content changes\ncore.viewers.diff.attachmentChanges=Attachment changes\ncore.viewers.diff.attachment.added=Attachment has been added\ncore.viewers.diff.attachment.deleted=Attachment has been deleted\ncore.viewers.diff.attachment.updated=Attachment has been updated from version <a href=\"{1}\">{0}</a> to version <a href=\"{3}\">{2}</a>\ncore.viewers.diff.commentChanges=Comment changes\ncore.viewers.diff.comment.added=Comment number {0} added\ncore.viewers.diff.comment.deleted=Comment number {0} deleted\ncore.viewers.diff.comment.updated=Comment number {0} modified\ncore.viewers.diff.comment.author=Author\ncore.viewers.diff.comment.date=Date\ncore.viewers.diff.comment.comment=Comment content\ncore.viewers.diff.comment.highlight=Highlighted text\ncore.viewers.diff.comment.replyto=Reply to\ncore.viewers.diff.comment.target=Comment target\ncore.viewers.diff.comment.state=Comment state\ncore.viewers.diff.comment.selection=Selection\ncore.viewers.diff.comment.originalSelection=Original selection\ncore.viewers.diff.comment.selectionLeftContext=Selection left context\ncore.viewers.diff.comment.selectionRightContext=Selection right context\ncore.viewers.diff.objectChanges=Object changes\ncore.viewers.diff.object.added=Object number {0} of type {1} added\ncore.viewers.diff.object.deleted=Object number {0} of type {1} deleted\ncore.viewers.diff.object.updated=Object number {0} of type {1} modified\ncore.viewers.diff.classChanges=Class changes\ncore.viewers.diff.class.added=Added property {0}\ncore.viewers.diff.class.removed=Removed property {0}\ncore.viewers.diff.class.changed=Changed property {0}\n\n### Old History (should have been deprecated long time ago)\nchanges.changesofpage=Changes\nchanges.in=in\nchanges.space=space\nchanges.from=From\nchanges.to=To\nchanges.comment=Change comment\nchanges.nocomment=There is no comment for this version\nchanges.version=Version\nchanges.editedby=edited by\nchanges.on=on\nchanges.metadatachanges=Metadata changes\nchanges.property=Property\nchanges.nometadatachanges=There are no metadata changes\nchanges.contentchanges=Content changes\nchanges.nocontentchanges=There are no content changes\nchanges.attachmentchanges=Attachment changes\nchanges.noattachmentchanges=There are no attachment changes\nchanges.filename=Filename\nchanges.action=Action\nchanges.commentchanges=Comment changes\nchanges.nocommentchanges=There are no comment changes\nchanges.metadata.parent=Parent\nchanges.metadata.web=Space\nchanges.metadata.name=Page Name\nchanges.metadata.author=Author\nchanges.metadata.language=Language\nchanges.metadata.defaultLanguage=Default Language\nchanges.attachmentadded=Attachment has been added\nchanges.attachmentdeleted=Attachment has been deleted\nchanges.attachmentupdatedfromversion=Attachment has been updated from version\nchanges.toversion=to version\nchanges.commentchange=Comment change\nchanges.commentAdded=Comment number {0} added\nchanges.commentRemoved=Comment number {0} removed\nchanges.comment.property=Property\nchanges.comment.previousvalue=Previous value\nchanges.comment.newvalue=New value\nchanges.comment.author=Author\nchanges.comment.date=Date\nchanges.comment.comment=Comment\nchanges.comment.highlight=Highlighted text\nchanges.comment.replyto=Reply to\nchanges.blog.title=Title\nchanges.blog.extract=Extract\nchanges.blog.category=Categories\nchanges.blog.editcategories=Edit categories\nchanges.blog.addnewcategory=Add a category\nchanges.tag.tags=Tags\nchanges.objectchanges=Object Changes\nchanges.objectAdded=Object added\nchanges.objectRemoved=Object removed\nchanges.ofclass=of class\nchanges.noobjectchanges=No Object Changes\nchanges.classeschanges=Class Changes\nchanges.noclasseschanges=No Class Changes\n\n#######################################\n## until 7.1M1\n#######################################\n\nsearch.page.bar.query.label=Query\nplatform.appwithinminutes.appHomePageTitle={0} Home\n\n### History\nweb.history.changes.attachment.author=Author\nweb.history.changes.lineEndings=Only the line endings have changed\n\n#@deprecated web.history.changes.document.title\ncore.viewers.diff.metadata.title=Title\n#@deprecated web.history.changes.document.parent\ncore.viewers.diff.metadata.parent=Parent\n#@deprecated web.history.changes.document.hidden\ncore.viewers.diff.metadata.hidden=Hidden\n#@deprecated web.history.changes.document.defaultLocale\ncore.viewers.diff.metadata.defaultLanguage=Default language\n#@deprecated web.history.changes.document.syntax\ncore.viewers.diff.metadata.syntax=Syntax\n\ncore.viewers.diff.metadata.author=Author\ncore.viewers.diff.metadata.language=Language\ncore.viewers.diff.metadata.name=Name\ncore.viewers.diff.metadata.web=Space\ncore.viewers.diff.metadata.space=Space\n\n#######################################\n## until 7.2M1\n#######################################\n\n### Create UI\ncore.create.spaceTitle=Create Space\ncore.create.space=Space Name\ncore.create.space.hint=Name of the new space\ncore.create.space.template.hint=Template to use for the homepage of the new space\ncore.create.space.template.empty=Blank Homepage\ncore.create.page.space.hint=Containing space for the new page\n\n#######################################\n## until 7.2M2\n#######################################\n\n### Create UI\ncore.create.page=Page Name\ncore.create.page.hint=Name of the new page\ncore.create.pageText=NewPage\n\n### Copy UI\ncore.copy.sourcewiki=Source Wiki\ncore.copy.sourcewiki.hint=Location of the original wiki\ncore.copy.sourcespace=Source Space\ncore.copy.sourcespace.hint=Location of the original space\ncore.copy.sourcepage=Source Page\ncore.copy.sourcepage.hint=Location of the original page\ncore.copy.targetwiki=Target Wiki\ncore.copy.targetwiki.hint=Desired wiki location for the copied page\ncore.copy.targetspace=Target Space\ncore.copy.targetspace.hint=Desired space location for the copied page\ncore.copy.targetpage=Target Page\ncore.copy.targetpage.hint=Desired page location for the copied page\n\n### Rename UI\ncore.rename.title.newName=New document name\ncore.rename.title.updateDocs=Documents having backlinks to modify\ncore.rename.title.updateChildren=Documents having this document as their parent\ncore.rename.inputPrompt=<new document name>\ncore.rename.sourcespace=Source Space\ncore.rename.sourcespace.hint=Location of the original space\ncore.rename.sourcepage=Source Page\ncore.rename.sourcepage.hint=Location of the original page\ncore.rename.newspace=New space\ncore.rename.newspace.hint=Containing space for the renamed page\ncore.rename.newpage=New page\ncore.rename.newpage.hint=Name of the renamed page\n\n#######################################\n## until 7.2M3\n#######################################\n\nplatform.dashboard.wiki.spaces=Spaces\n\n#######################################\n## until 7.3RC1\n#######################################\n\n## Replaced with the more generic admin.preferences.title key used for all WebPreferences page titles.\nxe.xwiki.space.preferences=XWiki Space Preferences\n\n## The restrictions on the class name have been dropped. \nplatform.appwithinminutes.appNameInvalidClassNameError=We can't extract a valid class name from the application name you entered. Make sure you include letters in the application name besides digits and punctuation signs.\n\n## The \"type\" property has been removed and data migrated to the new \"terminal\" property.\nxe.templateprovider.templatetype=Template type\nxe.templateprovider.templatetype.info=Whether this template should be used for creating generic pages or is specific to space homepages\n\n#######################################\n## until 7.4M1\n#######################################\n\n## We don't need this key any more because the page that is going to be created is specified by the location picker.\ncore.create.newPageTitle=Create Page: {0}\n\n## The database search UI doesn't use these keys any more.\nsearch.item.location=Located in <a href=\"{1}\">{0}</a> &#187; <a href=\"{3}\">{2}</a> &#187; <a href=\"{5}\">{4}</a>\nsearch.page.bar.spaces.all=All spaces\nsearch.page.results.copy=Copy\nsearch.page.results.delete=Delete\nsearch.page.results.rename=Rename\nsearch.page.results.rights=Rights\nsearch.page.results.guest=Guest\n\n#######################################\n## until 7.4\n#######################################\n\ncore.rename.success=Successfully renamed page {0} in space {3} to page <a href=\"{2}\">{1}</a> in space {4}\ncore.copy.copyingdoc=Page {0} successfully copied to {1}\n\n#######################################\n## until 7.4.3 / 8.0RC1\n#######################################\n\ncore.rename.children.labelWithoutParams=Affect the child pages\ncore.rename.links.labelWithoutParams=Update the wiki links\n\n#######################################\n## until 8.1M1\n#######################################\n\ncore.viewers.jump.quickLinksText=Jump to any page in the wiki (Meta+G)\n\n#######################################\n## until 8.2M2\n#######################################\n\n# Home\nxe.home.title=Home\n\n#######################################\n## until 8.2RC1\n#######################################\n\nplatform.dashboard.wiki.welcome=Welcome to your wiki\n\n#######################################\n## until 8.3M1\n#######################################\n\nplatform.ldap.missingLdapService=LDAP service is not available. Please verify your installation.\nplatform.ldap.ldapAuthenticationIsNotEnabledWarning=LDAP authentication is not enabled. Please set LDAP as authentication service in ##xwiki.cfg##\nplatform.ldap.ldapGroupTip=LDAP group...\nplatform.ldap.xwikiGroupTip=XWiki group...\nplatform.ldap.ldapUserField=LDAP field...\nplatform.ldap.xwikiUserField=XWiki user property...\nplatform.ldap.adminHeadingConfiguration=Configuration\nplatform.ldap.adminHeadingMiscellaneous=Miscellaneous\nplatform.ldap.resetGroupCacheSuccess=Groups cache has been reset\nplatform.ldap.resetGroupCacheButton=Reset group cache\n\n#######################################\n## until 8.3\n#######################################\n\nxe.xwiki.space=XWiki\n\n#######################################\n## until 8.4RC1\n#######################################\n\n#@deprecated platform.web.init.message.initializing\nplatform.web.init.message.intializing=XWiki is initializing ({0}%)...\n#@deprecated platform.web.init.message.initializationFailure\nplatform.web.init.message.intializationFailure=XWiki initialization failed!\n#@deprecated platform.web.init.message.initializationSuccess\nplatform.web.init.message.intializationSuccess=XWiki is initialized, you will be redirected shortly\n\n#######################################\n## until 9.1.2\n#######################################\n\nadmin.section.title=Administration: {0}\nxe.admin.global=Global\nadmin.xwiki.addextensions=Add Extensions\n#@deprecated admin.xwiki.extensions.description\nadmin.xwiki.addextensions.description=Search for new extensions to add to the wiki.\nadmin.xwiki.installedextensions=Installed Extensions\nadmin.xwiki.installedextensions.description=See the list of already installed extensions, which you can upgrade or uninstall.\nadmin.xwiki.coreextensions=Core Extensions\nadmin.xwiki.coreextensions.description=See what extensions make up the core of XWiki.\n#@deprecated extension.updater\nadmin.xwiki.extensionupdater=Extension Updater\nadmin.translations=Translations\nexport_authorpreserved=Author preserved\nadmin.applications=Applications\nadmin.applications.description=Various settings for pluggable applications.\nadmin.configuration=Configuration\nadmin.configuration.description=General configuration of the wiki.\nadmin.elements=Page Elements\nadmin.elements.description=Choose what to display in the titlebar and page footer, and which side panels and page metadata tabs to display.\n\nsearch.admin.configuration.title=Configuration\n\nsearch.admin.lucene.title=Lucene search administration\nsearch.admin.lucene.status.title=Status\nsearch.admin.lucene.status.infotitle=Info\nsearch.admin.lucene.status.valuetitle=Value\nsearch.admin.lucene.status.indexed=Number of indexed elements\nsearch.admin.lucene.status.indexing=Number of elements in indexing queue\nsearch.admin.lucene.indexing.title=Indexing\nsearch.admin.lucene.indexing.description=Tools to control Lucene index.\nsearch.admin.lucene.indexing.action.indexfarm=Index the whole farm\nsearch.admin.lucene.indexing.action.indexcurrentwiki=Index the wiki\nsearch.admin.lucene.indexing.action.indexcustom=Custom index\nsearch.admin.lucene.indexing.action.indexcustom.wikis=Wikis\nsearch.admin.lucene.indexing.action.indexcustom.wikis.title=Comma separated list of wiki identifiers\nsearch.admin.lucene.indexing.action.indexcustom.hqlfilter=An HQL based filter query\nsearch.admin.lucene.indexing.action.indexcustom.hqlfilter.title=Same as in searchDocument() methods\nsearch.admin.lucene.indexing.action.indexcustom.clearindex=Clear the index\nsearch.admin.lucene.indexing.action.indexcustom.clearindex.title=The index is cleaned before starting to scan database\nsearch.admin.lucene.indexing.action.indexcustom.onlynew=Only index elements not already indexed\nsearch.admin.lucene.indexing.action.indexcustom.onlynew.title=A page is loaded and scanned only if it is not already in the Lucene index\nsearch.admin.lucene.indexing.message.started=Started index rebuild.\nsearch.admin.lucene.indexing.message.alreadystarted=Another rebuild is in progress.\nsearch.admin.lucene.indexing.button=Start indexing\nsearch.extension.title.lucene=Lucene\nsearch.page.lucene.title.query=Lucene Search: {0}\nsearch.page.lucene.title.noquery=Lucene Search\nsearch.page.lucene.rebuilding=Lucene is currently building its index, {0} pages in queue.\nsearch.lucene.plugin.notfound=Lucene plugin not found. Make sure it's defined in your xwiki.cfg file.\n\n#######################################\n## until 9.3-rc-1\n#######################################\ncreateblogpost=Blog post\n\nxe.panels.quicklinks.blog=Blog\n\n### Blog application\nxe.blog.archive.paneltitle=Blog Archive\nxe.blog.archive.noarticle=No articles yet...\nxe.blog.archive.postsyear=Blog posts for {0}\nxe.blog.archive.unpublished=(unpublished)\nxe.blog.archive.hidden=(hidden)\nxe.blog.archive.noarticlesyear=No articles in this year...\nxe.blog.archive.postsfor=Blog posts for\nxe.blog.archive.noarticlesmonth=No articles in this month...\nxe.blog.code.blogsheet=Blog sheet\nxe.blog.code.sheetexplanation=This sheet should be used to display blog pages.\nxe.blog.code.notblog=This is not a blog page!\nxe.blog.code.published=This blog post is not published yet.\nxe.blog.code.hidden=This blog post is hidden.\nxe.blog.code.notpublished=This blog post is not published yet. Publish it.\nxe.blog.code.madevisible=Entry has been made visible.\nxe.blog.code.hid=Hidden entry\nxe.blog.code.makevisible=This blog post is not visible to other users. Make it visible.\nxe.blog.code.hide=Hide this blog post from other users.\nxe.blog.code.loading=Loading...\nxe.blog.code.failedToChangeBlogPostVisibility=Failed to change blog post visibility.\nxe.blog.code.editpost=Edit this blog post\nxe.blog.code.deletepost=Delete this blog post\nxe.blog.code.readpost=Read the full entry\nxe.blog.code.postedby=Posted by\nxe.blog.code.createdby=Created by\nxe.blog.code.modifiedby=Modified by\nxe.blog.code.comments=Comments\nxe.blog.code.permalink=Permalink\nxe.blog.code.categories=Categories:\nxe.blog.code.in=in\nxe.blog.code.previousweek=Previous week\nxe.blog.code.nextweek=Next week\nxe.blog.code.previousmonth=Previous month\nxe.blog.code.nextmonth=Next month\nxe.blog.code.olderposts=Older posts\nxe.blog.code.newerposts=Newer posts\nxe.blog.code.blogcategories=Blog categories\nxe.blog.code.description.category=Most recent blog posts in the {0} category\nxe.blog.code.description.space=Most recent blog posts in the {0} space\nxe.blog.code.description.wiki=Most recent blog posts in the wiki\nxe.blog.code.title=Blog\nxe.blog.code.warning=Warning:\nxe.blog.sheet.notpost=This is not a blog post!\nxe.blog.sheet.category=Category:\nxe.blog.sheet.summary=Summary (optional):\nxe.blog.sheet.content=Content:\nxe.blog.sheet.title=Title:\nxe.blog.sheet.publicationdate=This article was published on {0}\nxe.blog.sheet.hidearticle=Hide article {0}\nxe.blog.sheet.notpublished=This article is not published yet.\nxe.blog.sheet.publish=Publish\nxe.blog.sheet.setdate=Set the publication date to:\nxe.blog.category.created=The {0} category has been created.\nxe.blog.category.exists=The {0} category already exists.\nxe.blog.categories.paneltitle=Blog Categories\nxe.blog.categories.name=Name:\nxe.blog.categories.parentcategory=Parent category:\nxe.blog.categories.description=Description:\nxe.blog.categories.add=Add\nxe.blog.categories.new=New category:\nxe.blog.categories.newName=New category name:\nxe.blog.categories.parent=Parent:\nxe.blog.categories.none=None\nxe.blog.categories.remove=Remove deleted category\nxe.blog.categories.edit=Edit Categories\nxe.blog.categories.subcategories=Subcategories\nxe.blog.categories.addsubcategory=Add new subcategory\nxe.blog.categories.articles=Articles from this category\nxe.blog.categories.sheet=Category sheet\nxe.blog.categories.sheetmessage=This sheet should be used to display blog categories.\nxe.blog.categories.notcategory=This is not a blog category!\nxe.blog.categories.noentries=No entries in this category\nxe.blog.manageCategories.title=Manage blog categories\nxe.blog.manageCategories.create.error.emptyName=Please enter a valid category name\nxe.blog.manageCategories.create.error.alreadyExists=Target page already exists, please choose a different name\nxe.blog.manageCategories.create.error.notExists=The requested page could not be found.\nxe.blog.manageCategories.create.error.targetNotWritable=You don't have the right to create the target page.\nxe.blog.manageCategories.rename.error.emptyName=Please enter a valid category name\nxe.blog.manageCategories.js.fetchingForm=Fetching form...\nxe.blog.manageCategories.js.error.noServer=Server not responding\nxe.blog.manageCategories.js.rename.inProgress=Renaming category...\nxe.blog.manageCategories.js.rename.error.403=You are not allowed to create the target page\nxe.blog.manageCategories.js.rename.error.404=Invalid category, please refresh the page to update the category tree\nxe.blog.manageCategories.js.rename.error.409=Target page already exists, please choose a different name\nxe.blog.manageCategories.js.add.inProgress=Adding category...\nxe.blog.manageCategories.js.add.error.401=You have been logged out, please refresh and log in\nxe.blog.manageCategories.js.add.error.403=You are not allowed to create the target page\nxe.blog.manageCategories.js.add.error.409=Target page already exists, please choose a different name\nxe.blog.manageCategories.js.delete.confirm=Are you sure you want to delete this category? This action is not reversible.\nxe.blog.manageCategories.js.delete.inProgress=Deleting category...\nxe.blog.manageCategories.js.delete.done=Deleted\nxe.blog.manageCategories.js.delete.failed=Failed to delete category\nxe.blog.manageCategories.comment.updatedParent=Updated category parent\nxe.blog.manageCategories.comment.removedDeletedCategory=Removed deleted category\nxe.blog.manageCategories.comment.updatedRenamedCategory=Updated renamed category\nxe.blog.manageCategories.comment.updatedCategory=Updated category name\nxe.blog.post.createpost=Create a new post\nxe.blog.post.title=Post title\nxe.blog.post.titleEmptyError=The post title should not be empty!\nxe.blog.post.create=Create\nxe.blog.categories.existingcategories=Existing categories\nxe.blog.categories.addcategory=Add a category\nxe.blog.categories.deleteselected=Delete selected categories\nxe.blog.manage.existing=Existing blogs\nxe.blog.manage.createnew=Create a new blog\nxe.blog.manage.nospace=No space provided. Please enter a valid space where the blog should be created.\nxe.blog.manage.space=Space:\nxe.blog.manage.title=Title:\nxe.blog.manage.blogtitle=Blog title\nxe.blog.manage.blogtype=Blog type:\nxe.blog.manage.inside=blog inside an existing space\nxe.blog.manage.main=blog as the main content of a space\nxe.blog.manage.create=Create\nxe.blog.migration.migrated=Migrated old blog article to the new blog application\nxe.blog.migration.updated=Updated\nxe.blog.migration.inspace=in space\nxe.blog.migration.skipping=Skipping protected page\nxe.blog.migration.done=Done.\nxe.blog.migration.backtoblog=Back to the blog\nxe.blog.migration.pleaseconfirm=Please confirm if you want to migrate old articles to the new blog application:\nxe.blog.migration.confirm=Confirm\nxe.blog.publisher.published=Published article\nxe.blog.recentposts.paneltitle=Recent Blog Posts\nxe.blog.unpublished.entries=Unpublished articles\nxe.blog.unpublished.viewall=View all\n\n#######################################\n## until 9.4-rc-1\n#######################################\ncore.menu.actions=Actions\ncore.menu.moreactions=More actions\n\n#######################################\n## until 9.5-rc-1\n#######################################\ncore.delete.confirm.yes=Yes, please delete this page\ncore.delete.confirm.no=No, take me back!\n\n#######################################\n## until 9.7-rc-1\n#######################################\n\n# Attachment Index\nplatform.index.attachments.doc.name=Page\nplatform.index.attachments.doc.space=Space\n#@deprecated platform.index.attachments.mimeType\nplatform.index.attachments.type=Type\n\n####################\n# Wiki Macro Bridge Module\n####################\n\nxe.wikimacrobridge.wikiMacros=Existing wiki macro definitions\nxe.wikimacrobridge.macroName=Name\nxe.wikimacrobridge.macroId=id\nxe.wikimacrobridge.macroDescription=Description\nxe.wikimacrobridge.macroVisibility=Visibility\nxe.wikimacrobridge.macroPage=Macro page\nxe.wikimacrobridge.noWikiMacro=There are no wiki macro defined in this wiki yet.\n\n#######################################\n## until 10.6-rc-1\n#######################################\ncore.shortcuts.edit.saveandcontinue=Alt+Shift+S\nxe.scheduler.job.name=Job name:\nxe.scheduler.job.description=Job description:\nxe.scheduler.job.expression=Job cron expression:\nxe.scheduler.job.script=Job script:\n\n#######################################\n## until 10.6\n#######################################\ncore.viewers.comments.permalink.hide=Hide\n\n#######################################\n## until 10.8-rc-1\n#######################################\nadmin.defaultwikinotinstalled=Your wiki seems empty. You may want to import the default XWiki Enterprise wiki which contains a set of useful pages: user profiles, recent activity, administration pages and many more. This wiki is distributed as a XAR file, you can download it from {0}.\n\n### Image captcha\ncore.captcha.image.label=Verification image\ncore.captcha.image.instruction=Please type in the word shown above\ncore.captcha.image.alternateText=There is supposed to be an image captcha here, you could refresh the page or press the {0} button to try getting another image.\n\n#######################################\n## until 10.8\n#######################################\n\n### Groups Administration Section\n#@deprecated xe.admin.groups.name\nxe.admin.groups.groupname=Group Name\n\n### Users Administration Section\nxe.admin.users.manage=Manage\nxe.admin.users.username=Username\nxe.admin.users.filter.username=Username filter\n#@deprecated xe.admin.users.first_name\nxe.admin.users.firstname=First name\nxe.admin.users.filter.firstname=First name filter\n#@deprecated xe.admin.users.last_name\nxe.admin.users.lastname=Last name\nxe.admin.users.filter.lastname=Last name filter\n\n#######################################\n## until 11.1-rc-1\n#######################################\nplatform.search.suggestSourceDocumentName=Page names\n\n#######################################\n## until 11.1\n#######################################\ncore.editors.class.switchClass.submit=Edit\ncore.editors.class.switchClass.warning=Unsaved changes will be lost when switching to another class.\n\n#######################################\n## until 11.4-rc-1\n#######################################\ncore.editors.save.conflictversion.rollbackmessage=The document has been modified since you last saved it. Please copy your changes and reload the page to get the latest version and reapply your changes.\ncore.editors.save.conflictversion.previousVersion=Your version of the document:\ncore.editors.save.conflictversion.latestVersion=Latest version of the document:\ncore.editors.save.conflictversion.diffLink=Click here to check out the changes made on the latest version since you started editing it.\n\n#######################################\n## until 11.6-rc-1\n#######################################\nauth_active_check=Check Active fields for user authentication\nXWiki.XWikiPreferences_auth_active_check=Authentication Active Check\n\n#######################################\n## until 11.8-rc-1\n#######################################\nxe.userdirectory.customizeColumnsTitle=Customize the columns to display\nxe.userdirectory.customizeAvailableColumnsLabel=Available columns\nxe.userdirectory.customizeAvailableColumnsHint=Columns that can be displayed in the user directory for each user.\nxe.userdirectory.customizeAddColumnButtonLabel=Add\nxe.userdirectory.customizeSelectedColumnsLabel=Selected columns\nxe.userdirectory.customizeSelectedColumnsHint=Space or newline separated list of columns, corresponding to properties of the [[XWiki.XWikiUsers]] class, to be displayed in the user directory. Duplicate columns are ignored.\n\n#######################################\n## until 11.9-rc-1\n#######################################\nplatform.core.profile.passwd.instructions=Your new password must be at least 6 characters long.\n\n#######################################\n## until 12.3-rc-1\n#######################################\ncore.viewers.information.parent=Parent\ncore.viewers.information.noParent=No parent\ncore.viewers.information.children=Children\ncore.viewers.information.noChildren=No children\ncore.viewers.information.creation=Created\ncore.viewers.information.creationData=by {0} on {1}\ncore.viewers.information.translationCreation=Translated into {0}\ncore.viewers.information.translationCreationData=by {0} on {1}\n\n#######################################\n## until 12.4-rc-1\n#######################################\ncore.editors.object.delete.confirm=Are you sure you want to delete this object? Canceling the modifications will not restore deleted objects.\n\n#######################################\n## until 12.10, 12.6.5, 11.10.12\n#######################################\ncore.viewers.jump.dialog.invalidNameError=Invalid page name. Valid names have the following format: Space.Page\ncore.viewers.jump.suggest.noResults=No pages found\n\n#######################################\n## until 13.2-rc-1\n#######################################\ncore.widgets.suggestPicker.deleteAll=Clear selection\ncore.widgets.suggestPicker.deleteAll.tooltip=Clear the list of selected items\ncore.widgets.suggestPicker.delete.tooltip=Remove this item from the list of selected items\n\ncore.widgets.userPicker.noResults=User not found\ncore.widgets.userPicker.scopeHint=Click to toggle between local and global scope\ncore.widgets.groupPicker.noResults=Group not found\n\n#######################################\n## until 12.10.5, 13.2RC1\n#######################################\n\nxe.admin.forgotUsername.result=Your username is: {0}\nxe.admin.forgotUsername.multipleResults=The following usernames are registered with this email address:\nxe.admin.forgotUsername.error.noAccount=No account is registered using this email address.\n\n#######################################\n## until 12.10.9, 13.6RC1, 13.4.1\n#######################################\nxe.admin.passwordReset.emailSent=An e-mail was sent to {0}. Please follow the instructions in that e-mail to complete the password reset procedure.\n\n#######################################\n## until 14.4.2, 14.5\n#######################################\ncore.delete.backlinksWarning=The following pages contain links to the current page:{0}After deleting this page, those links will point to an empty page.\n\n#######################################\n## until 14.9\n#######################################\ncore.action.upload.failure.maxSize=The wiki administrators have set a limit of {0} for attached files. Please make sure the size of the files you are trying to attach does not exceed this limit.\n\n#######################################\n## until 14.10\n#######################################\ncore.menu.export.pdf=Export as PDF\ncore.menu.export.odt=Export as ODT\ncore.menu.export.rtf=Export as RTF\ncore.menu.export.html=Export as HTML\ncore.menu.export.xar=Export as XAR\n\n#######################################\n## until 14.4.8, 14.10.2, 15.0RC1\n#######################################\ncore.delete.backlinksInfo=After deleting this page, the {0,choice,0#incoming links|1#incoming link|1<incoming links} will point to an empty page. To avoid this, you can select a new target.\n\n#######################################\n## until 14.10.2, 15.0RC1\n#######################################\nxe.officeimporter.import.targetspace=Target space\nxe.officeimporter.import.targetpage=Target page\nxe.officeimporter.import.styles=Styles\nxe.officeimporter.import.splitting=Splitting\nxe.officeimporter.import.help.target=Key-in target space and page name. Select \"Append result\" to append the result to an existing wiki page.\nxe.officeimporter.import.appendresult=Append result\nplatform.office.importDocumentOverwriteConfirmation=The target document exists. Are you sure you want to overwrite its content?\n\n## Used to indicate where deprecated keys end\n#@deprecatedend\n\n###############################################################################\n## Old but critical deprecated\n## translation keys that kept\n## for backward compatibility\n## (with custom skins generally)\n###############################################################################\n\n## Used to indicate where keys that does not need to be translated starts\n## l10n wiki used that to not import them for example\nnotranslationsmarker=notranslationsmarker\n\nhrtext=\nsigntext=\ncore.edit.wikiToolbar.signtext=\ncore.edit.wikiToolbar.hrtext=\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.ByteArrayInputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Named;\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.io.IOUtils;\nimport org.dom4j.Document;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.link.LinkException;\nimport org.xwiki.link.LinkStore;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.user.UserConfiguration;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.user.UserReferenceSerializer;\n\nimport com.xpn.xwiki.XWikiConstant;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.internal.doc.XWikiAttachmentList;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.StringProperty;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.component.XWikiDocumentFilterUtilsComponentList;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\nimport com.xpn.xwiki.validation.XWikiValidationInterface;\nimport com.xpn.xwiki.web.EditForm;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link XWikiDocument}.\n * \n * @version $Id$\n */\n@OldcoreTest\n@ReferenceComponentList\n@XWikiDocumentFilterUtilsComponentList\npublic class XWikiDocumentMockitoTest\n{\n    private static final String DOCWIKI = \"wiki\";\n\n    private static final String DOCSPACE = \"space\";\n\n    private static final String DOCNAME = \"page\";\n\n    private static final DocumentReference DOCUMENT_REFERENCE = new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME);\n\n    private static final DocumentReference CLASS_REFERENCE = DOCUMENT_REFERENCE;\n\n    @MockComponent\n    @Named(\"document\")\n    private UserReferenceSerializer<DocumentReference> documentReferenceUserReferenceSerializer;\n\n    @MockComponent\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> userReferenceDocumentReferenceResolver;\n\n    @MockComponent\n    private UserConfiguration userConfiguration;\n\n    @MockComponent\n    @Named(\"compactwiki/document\")\n    private UserReferenceSerializer<String> compactWikiUserReferenceSerializer;\n\n    @MockComponent\n    private LinkStore linkStore;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    /**\n     * The object being tested.\n     */\n    private XWikiDocument document;\n\n    private BaseClass baseClass;\n\n    private BaseObject baseObject;\n\n    private BaseObject baseObject2;\n\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    private List<XWikiAttachment> attachmentList;\n\n    @BeforeEach\n    void beforeEach() throws Exception\n    {\n        // Activate programming rights in order to be able to call com.xpn.xwiki.api.Document#getDocument().\n        when(this.oldcore.getMockRightService().hasProgrammingRights(this.oldcore.getXWikiContext())).thenReturn(true);\n\n        this.document = new XWikiDocument(DOCUMENT_REFERENCE);\n        this.document.setSyntax(Syntax.PLAIN_1_0);\n        this.attachmentList = this.document.getAttachmentList();\n        this.baseClass = this.document.getXClass();\n        this.baseClass.addTextField(\"string\", \"String\", 30);\n        this.baseClass.addTextAreaField(\"area\", \"Area\", 10, 10);\n        this.baseClass.addTextAreaField(\"puretextarea\", \"Pure text area\", 10, 10);\n        // set the text areas an non interpreted content\n        ((TextAreaClass) this.baseClass.getField(\"puretextarea\")).setContentType(\"puretext\");\n        this.baseClass.addPasswordField(\"passwd\", \"Password\", 30);\n        this.baseClass.addBooleanField(\"boolean\", \"Boolean\", \"yesno\");\n        this.baseClass.addNumberField(\"int\", \"Int\", 10, \"integer\");\n        this.baseClass.addStaticListField(\"stringlist\", \"StringList\", 1, true, \"value1, value2\");\n\n        this.baseObject = this.document.newXObject(CLASS_REFERENCE, this.oldcore.getXWikiContext());\n        this.baseObject.setStringValue(\"string\", \"string\");\n        this.baseObject.setLargeStringValue(\"area\", \"area\");\n        this.baseObject.setLargeStringValue(\"puretextarea\", \"puretextarea\");\n        this.baseObject.setStringValue(\"passwd\", \"passwd\");\n        this.baseObject.setIntValue(\"boolean\", 1);\n        this.baseObject.setIntValue(\"int\", 42);\n        this.baseObject.setStringListValue(\"stringlist\", Arrays.asList(\"VALUE1\", \"VALUE2\"));\n\n        this.baseObject2 = this.baseObject.clone();\n        this.document.addXObject(this.baseObject2);\n\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        this.defaultEntityReferenceSerializer =\n            this.oldcore.getMocker().getInstance(EntityReferenceSerializer.TYPE_STRING);\n\n        this.oldcore.getXWikiContext().setWikiId(DOCWIKI);\n\n        // Reset the cached (static) MetaClass instance because it may have been initialized during the execution of the\n        // previous test classes, so before the StaticListMetaClass component needed by this test class was loaded.\n        MetaClass.setMetaClass(null);\n\n        when(this.userConfiguration.getStoreHint()).thenReturn(\"document\");\n    }\n\n    @Test\n    void getChildrenReferences() throws Exception\n    {\n        Query query = mock(Query.class);\n        when(this.oldcore.getQueryManager().createQuery(any(), eq(Query.XWQL))).thenReturn(query);\n\n        QueryFilter hiddenFilter = this.oldcore.getMocker().registerMockComponent(QueryFilter.class, \"hidden\");\n\n        when(query.setLimit(7)).thenReturn(query);\n\n        List<String> result = Arrays.asList(\"X.y\", \"A.b\");\n        when(query.<String>execute()).thenReturn(result);\n\n        List<DocumentReference> childrenReferences =\n            document.getChildrenReferences(7, 3, this.oldcore.getXWikiContext());\n\n        verify(query).addFilter(hiddenFilter);\n        verify(query).setLimit(7);\n        verify(query).setOffset(3);\n\n        assertEquals(2, childrenReferences.size());\n        assertEquals(new DocumentReference(\"wiki\", \"X\", \"y\"), childrenReferences.get(0));\n        assertEquals(new DocumentReference(\"wiki\", \"A\", \"b\"), childrenReferences.get(1));\n    }\n\n    /**\n     * Generate a fake map for the request used in the tests of {@link #readObjectsFromForm()} and\n     * {@link #readObjectsFromFormUpdateOrCreate()}.\n     * \n     * @return Map of fake parameters which should test every cases\n     */\n    private Map<String, String[]> generateFakeRequestMap()\n    {\n        Map<String, String[]> parameters = new HashMap<>();\n        // Testing update of values in existing object with existing properties\n        String[] string1 = {\"bloublou\"};\n        parameters.put(\"space.page_0_string\", string1);\n        String[] int1 = {\"7\"};\n        parameters.put(\"space.page_1_int\", int1);\n        // Testing creation and update of an object's properties when object\n        // doesn't exist\n        String[] string2 = {\"blabla\"};\n        String[] int2 = {\"13\"};\n        parameters.put(\"space.page_3_string\", string2);\n        parameters.put(\"space.page_3_int\", int2);\n        // Testing that objects with non-following number is not created\n        parameters.put(\"space.page_42_string\", string1);\n        parameters.put(\"space.page_42_int\", int1);\n        // Testing that invalid parameter are ignored\n        parameters.put(\"invalid\", new String[] {\"whatever\"});\n        // Testing that invalid xclass page are ignored\n        parameters.put(\"InvalidSpace.InvalidPage_0_string\", new String[] {\"whatever\"});\n        // Testing that an invalid number is ignored (first should be ignored by\n        // regexp parser, second by an exception)\n        parameters.put(\"space.page_notANumber_string\", new String[] {\"whatever\"});\n        parameters.put(\"space.page_9999999999_string\", new String[] {\"whatever\"});\n        return parameters;\n    }\n\n    /**\n     * Generate the fake class that is used for the test of {@link #readObjectsFromForm()} and\n     * {@link #readObjectsFromFormUpdateOrCreate()}.\n     * \n     * @return The fake BaseClass\n     */\n    private BaseClass generateFakeClass()\n    {\n        BaseClass baseClass = this.document.getXClass();\n        baseClass.addTextField(\"string\", \"String\", 30);\n        baseClass.addTextAreaField(\"area\", \"Area\", 10, 10);\n        baseClass.addTextAreaField(\"puretextarea\", \"Pure text area\", 10, 10);\n        // set the text areas an non interpreted content\n        ((TextAreaClass) baseClass.getField(\"puretextarea\")).setContentType(\"puretext\");\n        baseClass.addPasswordField(\"passwd\", \"Password\", 30);\n        baseClass.addBooleanField(\"boolean\", \"Boolean\", \"yesno\");\n        baseClass.addNumberField(\"int\", \"Int\", 10, \"integer\");\n        baseClass.addStaticListField(\"stringlist\", \"StringList\", \"value1, value2\");\n\n        return baseClass;\n    }\n\n    /**\n     * Generate 2 clones of a fake object in the document\n     * \n     * @return Return the reference of the first clone\n     */\n    private void generateFakeObjects()\n    {\n        BaseObject baseObject = null, baseObject2 = null, baseObject3 = null;\n        try {\n            baseObject = this.document.newXObject(this.document.getDocumentReference(), this.oldcore.getXWikiContext());\n            baseObject2 =\n                this.document.newXObject(this.document.getDocumentReference(), this.oldcore.getXWikiContext());\n            baseObject3 =\n                this.document.newXObject(this.document.getDocumentReference(), this.oldcore.getXWikiContext());\n        } catch (XWikiException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            return;\n        }\n        baseObject.setStringValue(\"string\", \"string\");\n        baseObject.setIntValue(\"int\", 42);\n        baseObject2.setStringValue(\"string\", \"string2\");\n        baseObject2.setIntValue(\"int\", 42);\n        baseObject3.setStringValue(\"string\", \"string3\");\n        baseObject3.setIntValue(\"int\", 42);\n    }\n\n    /**\n     * Unit test for {@link XWikiDocument#readObjectsFromForm(EditForm, XWikiContext)}.\n     */\n    @Test\n    void readObjectsFromForm() throws Exception\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        MockitoComponentManager mocker = this.oldcore.getMocker();\n        XWikiContext context = this.oldcore.getXWikiContext();\n        DocumentReferenceResolver<String> documentReferenceResolverString =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        // Entity Reference resolver is used in <BaseObject>.getXClass()\n        DocumentReferenceResolver<EntityReference> documentReferenceResolverEntity =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n        EntityReferenceSerializer<String> entityReferenceResolver =\n            mocker.registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n\n        Map<String, String[]> parameters = generateFakeRequestMap();\n        BaseClass baseClass = generateFakeClass();\n        generateFakeObjects();\n\n        when(request.getParameterMap()).thenReturn(parameters);\n\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"space\", \"page\");\n        // This entity resolver with this 'resolve' method is used in\n        // <BaseCollection>.getXClassReference()\n        when(documentReferenceResolverEntity.resolve(any(EntityReference.class), any(DocumentReference.class)))\n            .thenReturn(this.document.getDocumentReference());\n        when(documentReferenceResolverString.resolve(\"space.page\")).thenReturn(documentReference);\n        when(entityReferenceResolver.serialize(any(EntityReference.class))).thenReturn(\"space.page\");\n\n        EditForm eform = new EditForm();\n        eform.setRequest(request);\n        document.readObjectsFromForm(eform, context);\n\n        assertEquals(3, this.document.getXObjectSize(baseClass.getDocumentReference()));\n        assertEquals(\"string\", this.document.getXObject(baseClass.getDocumentReference(), 0).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 0).getIntValue(\"int\"));\n        assertEquals(\"string2\", this.document.getXObject(baseClass.getDocumentReference(), 1).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 1).getIntValue(\"int\"));\n        assertEquals(\"string3\", this.document.getXObject(baseClass.getDocumentReference(), 2).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 2).getIntValue(\"int\"));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 3));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 42));\n    }\n\n    /**\n     * Unit test for {@link XWikiDocument#readObjectsFromFormUpdateOrCreate(EditForm, XWikiContext)} .\n     */\n    @Test\n    void readObjectsFromFormUpdateOrCreate() throws Exception\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        MockitoComponentManager mocker = this.oldcore.getMocker();\n        XWikiContext context = this.oldcore.getXWikiContext();\n        DocumentReferenceResolver<String> documentReferenceResolverString =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        // Entity Reference resolver is used in <BaseObject>.getXClass()\n        DocumentReferenceResolver<EntityReference> documentReferenceResolverEntity =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n\n        Map<String, String[]> parameters = generateFakeRequestMap();\n        BaseClass baseClass = generateFakeClass();\n        generateFakeObjects();\n        EditForm eform = new EditForm();\n\n        when(request.getParameter(\"objectPolicy\")).thenReturn(\"updateOrCreate\");\n        when(request.getParameterMap()).thenReturn(parameters);\n        when(documentReferenceResolverString.resolve(\"space.page\")).thenReturn(this.document.getDocumentReference());\n        when(documentReferenceResolverString.resolve(\"InvalidSpace.InvalidPage\"))\n            .thenReturn(new DocumentReference(\"wiki\", \"InvalidSpace\", \"InvalidPage\"));\n        // This entity resolver with this 'resolve' method is used in\n        // <BaseCollection>.getXClassReference()\n        when(documentReferenceResolverEntity.resolve(any(EntityReference.class), any(DocumentReference.class)))\n            .thenReturn(this.document.getDocumentReference());\n        doReturn(this.document).when(this.oldcore.getSpyXWiki()).getDocument(this.document.getDocumentReference(),\n            context);\n\n        eform.setRequest(request);\n        eform.readRequest();\n        this.document.readObjectsFromFormUpdateOrCreate(eform, context);\n\n        assertEquals(43, this.document.getXObjectSize(baseClass.getDocumentReference()));\n        assertEquals(\"bloublou\",\n            this.document.getXObject(baseClass.getDocumentReference(), 0).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 0).getIntValue(\"int\"));\n        assertEquals(\"string2\", this.document.getXObject(baseClass.getDocumentReference(), 1).getStringValue(\"string\"));\n        assertEquals(7, this.document.getXObject(baseClass.getDocumentReference(), 1).getIntValue(\"int\"));\n        assertEquals(\"string3\", this.document.getXObject(baseClass.getDocumentReference(), 2).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 2).getIntValue(\"int\"));\n        assertNotNull(this.document.getXObject(baseClass.getDocumentReference(), 3));\n        assertEquals(\"blabla\", this.document.getXObject(baseClass.getDocumentReference(), 3).getStringValue(\"string\"));\n        assertEquals(13, this.document.getXObject(baseClass.getDocumentReference(), 3).getIntValue(\"int\"));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 4));\n        assertNotNull(this.document.getXObject(baseClass.getDocumentReference(), 42));\n        assertEquals(\"bloublou\",\n            this.document.getXObject(baseClass.getDocumentReference(), 42).getStringValue(\"string\"));\n        assertEquals(7, this.document.getXObject(baseClass.getDocumentReference(), 42).getIntValue(\"int\"));\n    }\n\n    /**\n     * Unit test for {@link XWikiDocument#readAddedUpdatedAndRemovedObjectsFromForm(EditForm, XWikiContext)}.\n     */\n    @Test\n    void readAddedUpdatedAndRemovedObjectsFromForm() throws Exception\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        HttpServletRequest request = mock(HttpServletRequest.class);\n        MockitoComponentManager mocker = this.oldcore.getMocker();\n        XWikiContext context = this.oldcore.getXWikiContext();\n        DocumentReferenceResolver<String> documentReferenceResolverString =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        // Entity Reference resolver is used in <BaseObject>.getXClass()\n        DocumentReferenceResolver<EntityReference> documentReferenceResolverEntity =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n\n        Map<String, String[]> parameters = generateFakeRequestMap();\n        BaseClass baseClass = generateFakeClass();\n        generateFakeObjects();\n        EditForm eform = new EditForm();\n\n        when(request.getParameterValues(\"addedObjects\")).thenReturn(new String[] {\"space.page_1\", \"space.page_42\"});\n        when(request.getParameterValues(\"deletedObjects\")).thenReturn(new String[] {\"space.page_2\"});\n        when(request.getParameterMap()).thenReturn(parameters);\n        when(documentReferenceResolverString.resolve(\"space.page\")).thenReturn(this.document.getDocumentReference());\n        when(documentReferenceResolverString.resolve(\"InvalidSpace.InvalidPage\"))\n            .thenReturn(new DocumentReference(\"wiki\", \"InvalidSpace\", \"InvalidPage\"));\n        // This entity resolver with this 'resolve' method is used in\n        // <BaseCollection>.getXClassReference()\n        when(documentReferenceResolverEntity.resolve(any(EntityReference.class), any(DocumentReference.class)))\n            .thenReturn(this.document.getDocumentReference());\n        doReturn(this.document).when(this.oldcore.getSpyXWiki()).getDocument(this.document.getDocumentReference(),\n            context);\n\n        eform.setRequest(request);\n        eform.readRequest();\n        this.document.readAddedUpdatedAndRemovedObjectsFromForm(eform, context);\n\n        assertEquals(43, this.document.getXObjectSize(baseClass.getDocumentReference()));\n        assertEquals(\"bloublou\",\n            this.document.getXObject(baseClass.getDocumentReference(), 0).getStringValue(\"string\"));\n        assertEquals(42, this.document.getXObject(baseClass.getDocumentReference(), 0).getIntValue(\"int\"));\n        assertEquals(\"string2\", this.document.getXObject(baseClass.getDocumentReference(), 1).getStringValue(\"string\"));\n        assertEquals(7, this.document.getXObject(baseClass.getDocumentReference(), 1).getIntValue(\"int\"));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 2));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 3));\n        assertNull(this.document.getXObject(baseClass.getDocumentReference(), 4));\n        assertNotNull(this.document.getXObject(baseClass.getDocumentReference(), 42));\n        assertEquals(\"bloublou\",\n            this.document.getXObject(baseClass.getDocumentReference(), 42).getStringValue(\"string\"));\n        assertEquals(7, this.document.getXObject(baseClass.getDocumentReference(), 42).getIntValue(\"int\"));\n    }\n\n    @Test\n    void testDeprecatedConstructors()\n    {\n        DocumentReference defaultReference = new DocumentReference(\"xwiki\", \"Main\", \"WebHome\");\n\n        XWikiDocument doc = new XWikiDocument(null);\n        assertEquals(defaultReference, doc.getDocumentReference());\n\n        doc = new XWikiDocument();\n        assertEquals(defaultReference, doc.getDocumentReference());\n\n        doc = new XWikiDocument(\"notused\", \"space.page\");\n        assertEquals(\"space\", doc.getSpaceName());\n        assertEquals(\"page\", doc.getPageName());\n        assertEquals(this.oldcore.getXWikiContext().getWikiId(), doc.getWikiName());\n\n        doc = new XWikiDocument(\"space\", \"page\");\n        assertEquals(\"space\", doc.getSpaceName());\n        assertEquals(\"page\", doc.getPageName());\n        assertEquals(this.oldcore.getXWikiContext().getWikiId(), doc.getWikiName());\n\n        doc = new XWikiDocument(\"wiki2\", \"space\", \"page\");\n        assertEquals(\"space\", doc.getSpaceName());\n        assertEquals(\"page\", doc.getPageName());\n        assertEquals(\"wiki2\", doc.getWikiName());\n\n        doc = new XWikiDocument(\"wiki2\", \"notused\", \"notused:space.page\");\n        assertEquals(\"space\", doc.getSpaceName());\n        assertEquals(\"page\", doc.getPageName());\n        assertEquals(\"wiki2\", doc.getWikiName());\n    }\n\n    @Test\n    void testMinorMajorVersions()\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n\n        // there is no version in doc yet, so 1.1\n        assertEquals(\"1.1\", this.document.getVersion());\n\n        this.document.setMinorEdit(false);\n        this.document.incrementVersion();\n        // no version => incrementVersion sets 1.1\n        assertEquals(\"1.1\", this.document.getVersion());\n\n        this.document.setMinorEdit(false);\n        this.document.incrementVersion();\n        // increment major version\n        assertEquals(\"2.1\", this.document.getVersion());\n\n        this.document.setMinorEdit(true);\n        this.document.incrementVersion();\n        // increment minor version\n        assertEquals(\"2.2\", this.document.getVersion());\n    }\n\n    @Test\n    void testGetPreviousVersion() throws XWikiException\n    {\n        this.document = new XWikiDocument(new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME));\n\n        Date now = new Date();\n        XWikiDocumentArchive archiveDoc = new XWikiDocumentArchive(this.document.getId());\n        this.document.setDocumentArchive(archiveDoc);\n\n        assertEquals(\"1.1\", this.document.getVersion());\n        assertNull(this.document.getPreviousVersion());\n\n        this.document.incrementVersion();\n        archiveDoc.updateArchive(this.document, \"Admin\", now, \"\", this.document.getRCSVersion(),\n            this.oldcore.getXWikiContext());\n        assertEquals(\"1.1\", this.document.getVersion());\n        assertNull(this.document.getPreviousVersion());\n\n        this.document.setMinorEdit(true);\n        this.document.incrementVersion();\n        archiveDoc.updateArchive(this.document, \"Admin\", now, \"\", this.document.getRCSVersion(),\n            this.oldcore.getXWikiContext());\n        assertEquals(\"1.2\", this.document.getVersion());\n        assertEquals(\"1.1\", this.document.getPreviousVersion());\n\n        this.document.setMinorEdit(false);\n        this.document.incrementVersion();\n        archiveDoc.updateArchive(this.document, \"Admin\", now, \"\", this.document.getRCSVersion(),\n            this.oldcore.getXWikiContext());\n        assertEquals(\"2.1\", this.document.getVersion());\n        assertEquals(\"1.2\", this.document.getPreviousVersion());\n\n        this.document.setMinorEdit(true);\n        this.document.incrementVersion();\n        archiveDoc.updateArchive(this.document, \"Admin\", now, \"\", this.document.getRCSVersion(),\n            this.oldcore.getXWikiContext());\n        assertEquals(\"2.2\", this.document.getVersion());\n        assertEquals(\"2.1\", this.document.getPreviousVersion());\n\n        archiveDoc.resetArchive();\n\n        assertEquals(\"2.2\", this.document.getVersion());\n        assertNull(this.document.getPreviousVersion());\n    }\n\n    @Test\n    void testCloneNullObjects()\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"wiki\", DOCSPACE, DOCNAME));\n\n        EntityReference relativeClassReference =\n            new EntityReference(DOCNAME, EntityType.DOCUMENT, new EntityReference(DOCSPACE, EntityType.SPACE));\n        DocumentReference classReference = new DocumentReference(\"wiki\", DOCSPACE, DOCNAME);\n        DocumentReference duplicatedClassReference = new DocumentReference(\"otherwiki\", DOCSPACE, DOCNAME);\n\n        // no object\n        XWikiDocument clonedDocument = document.clone();\n        assertTrue(clonedDocument.getXObjects().isEmpty());\n\n        XWikiDocument duplicatedDocument = document.duplicate(new DocumentReference(\"otherwiki\", DOCSPACE, DOCNAME));\n        assertTrue(duplicatedDocument.getXObjects().isEmpty());\n\n        // 1 null object\n\n        document.addXObject(classReference, null);\n\n        clonedDocument = document.clone();\n        assertEquals(1, clonedDocument.getXObjects(classReference).size());\n        assertEquals(document.getXObjects(classReference), clonedDocument.getXObjects(classReference));\n\n        duplicatedDocument = document.duplicate(new DocumentReference(\"otherwiki\", DOCSPACE, DOCNAME));\n        assertTrue(duplicatedDocument.getXObjects().isEmpty());\n\n        // 1 null object and 1 object\n\n        BaseObject object = new BaseObject();\n        object.setXClassReference(relativeClassReference);\n        document.addXObject(object);\n\n        clonedDocument = document.clone();\n        assertEquals(2, clonedDocument.getXObjects(classReference).size());\n        assertEquals(document.getXObjects(classReference), clonedDocument.getXObjects(classReference));\n\n        duplicatedDocument = document.duplicate(new DocumentReference(\"otherwiki\", DOCSPACE, DOCNAME));\n        assertEquals(2, duplicatedDocument.getXObjects(duplicatedClassReference).size());\n    }\n\n    @Test\n    void testToStringReturnsFullName()\n    {\n        assertEquals(\"space.page\", this.document.toString());\n        assertEquals(\"Main.WebHome\", new XWikiDocument().toString());\n    }\n\n    @Test\n    void testCloneSaveVersions()\n    {\n        XWikiDocument doc1 = new XWikiDocument(new DocumentReference(\"qwe\", \"qwe\", \"qwe\"));\n        XWikiDocument doc2 = doc1.clone();\n        doc1.incrementVersion();\n        doc2.incrementVersion();\n        assertEquals(doc1.getVersion(), doc2.getVersion());\n    }\n\n    @Test\n    void testAddObject() throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"test\", \"test\", \"document\"));\n        BaseObject object = BaseClass.newCustomClassInstance(\"XWiki.XWikiUsers\", this.oldcore.getXWikiContext());\n        doc.addObject(\"XWiki.XWikiUsers\", object);\n        assertEquals(doc.getFullName(), object.getName(), \"XWikiDocument.addObject does not set the object's name\");\n    }\n\n    @Test\n    void testObjectNumbersAfterXMLRoundrip() throws XWikiException\n    {\n        String wiki = oldcore.getXWikiContext().getWikiId();\n\n        XWikiDocument tagDocument = new XWikiDocument(new DocumentReference(wiki, \"XWiki\", \"TagClass\"));\n        BaseClass tagClass = tagDocument.getXClass();\n        tagClass.addStaticListField(XWikiConstant.TAG_CLASS_PROP_TAGS, \"Tags\", 30, true, \"\", \"checkbox\");\n        this.oldcore.getSpyXWiki().saveDocument(tagDocument, this.oldcore.getXWikiContext());\n\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(wiki, \"test\", \"document\"));\n        doReturn(\"iso-8859-1\").when(this.oldcore.getSpyXWiki()).getEncoding();\n\n        BaseObject object1 = doc.newXObject(tagDocument.getDocumentReference(), this.oldcore.getXWikiContext());\n        BaseObject object2 = doc.newXObject(tagDocument.getDocumentReference(), this.oldcore.getXWikiContext());\n        BaseObject object3 = doc.newXObject(tagDocument.getDocumentReference(), this.oldcore.getXWikiContext());\n\n        // Remove first object\n        doc.removeXObject(object1);\n\n        String docXML = doc.toXML(this.oldcore.getXWikiContext());\n        XWikiDocument docFromXML = new XWikiDocument(doc.getDocumentReference());\n        docFromXML.fromXML(docXML);\n\n        List<BaseObject> objects = doc.getXObjects(tagDocument.getDocumentReference());\n        List<BaseObject> objectsFromXML = docFromXML.getXObjects(tagDocument.getDocumentReference());\n\n        assertNotNull(objects);\n        assertNotNull(objectsFromXML);\n\n        assertTrue(objects.size() == objectsFromXML.size());\n\n        for (int i = 0; i < objects.size(); i++) {\n            if (objects.get(i) == null) {\n                assertNull(objectsFromXML.get(i));\n            } else {\n                assertTrue(objects.get(i).getNumber() == objectsFromXML.get(i).getNumber());\n            }\n        }\n    }\n\n    @Test\n    void testGetXObjectWithObjectReference()\n    {\n        assertSame(this.baseObject, this.document.getXObject(this.baseObject.getReference()));\n\n        assertSame(this.baseObject,\n            this.document.getXObject(new ObjectReference(\n                this.defaultEntityReferenceSerializer.serialize(this.baseObject.getXClassReference()),\n                this.document.getDocumentReference())));\n    }\n\n    @Test\n    void testGetXObjectWithNumber()\n    {\n        assertSame(this.baseObject, this.document.getXObject(CLASS_REFERENCE, this.baseObject.getNumber()));\n        assertSame(this.baseObject2, this.document.getXObject(CLASS_REFERENCE, this.baseObject2.getNumber()));\n        assertSame(this.baseObject,\n            this.document.getXObject((EntityReference) CLASS_REFERENCE, this.baseObject.getNumber()));\n        assertSame(this.baseObject2,\n            this.document.getXObject((EntityReference) CLASS_REFERENCE, this.baseObject2.getNumber()));\n    }\n\n    @Test\n    void testGetXObjectCreateWithNumber() throws XWikiException\n    {\n        assertSame(this.baseObject, this.document.getXObject(CLASS_REFERENCE, this.baseObject.getNumber(), true,\n            this.oldcore.getXWikiContext()));\n        assertSame(this.baseObject2, this.document.getXObject(CLASS_REFERENCE, this.baseObject2.getNumber(), true,\n            this.oldcore.getXWikiContext()));\n        assertSame(this.baseObject, this.document.getXObject((EntityReference) CLASS_REFERENCE,\n            this.baseObject.getNumber(), true, this.oldcore.getXWikiContext()));\n        assertSame(this.baseObject2, this.document.getXObject((EntityReference) CLASS_REFERENCE,\n            this.baseObject2.getNumber(), true, this.oldcore.getXWikiContext()));\n\n        BaseObject newObject = this.document.getXObject(CLASS_REFERENCE, 42, true, this.oldcore.getXWikiContext());\n        assertNotSame(this.baseObject, newObject);\n        assertNotSame(this.baseObject2, newObject);\n        assertEquals(42, newObject.getNumber());\n        assertSame(newObject, this.document.getXObject(CLASS_REFERENCE, newObject.getNumber()));\n    }\n\n    @Test\n    void testGetXObjectsWhenClassDoesNotExist()\n    {\n        assertEquals(Collections.emptyList(),\n            this.document.getXObjects(new DocumentReference(\"not\", \"existing\", \"class\")));\n    }\n\n    @Test\n    void testSetXObjectswithPreviousObject()\n    {\n        BaseObject object = new BaseObject();\n        object.setXClassReference(this.baseObject.getXClassReference());\n        this.document.addXObject(object);\n\n        this.document.setXObjects(this.baseObject.getXClassReference(), Arrays.asList(object));\n\n        assertEquals(Arrays.asList(object), this.document.getXObjects(this.baseObject.getXClassReference()));\n    }\n\n    @Test\n    void testSetXObjectWhithNoPreviousObject()\n    {\n        XWikiDocument document = new XWikiDocument(this.document.getDocumentReference());\n\n        document.setXObject(this.baseObject.getXClassReference(), 0, this.baseObject);\n\n        assertEquals(Arrays.asList(this.baseObject), document.getXObjects(this.baseObject.getXClassReference()));\n    }\n\n    /**\n     * Test that the parent remain the same relative value whatever the context.\n     */\n    @Test\n    void testGetParent()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n\n        assertEquals(\"\", doc.getParent());\n        doc.setParent(null);\n        assertEquals(\"\", doc.getParent());\n\n        doc.setParent(\"page\");\n        assertEquals(\"page\", doc.getParent());\n\n        this.oldcore.getXWikiContext().setWikiId(\"otherwiki\");\n        assertEquals(\"page\", doc.getParent());\n\n        doc.setDocumentReference(new DocumentReference(\"otherwiki\", \"otherspace\", \"otherpage\"));\n        assertEquals(\"page\", doc.getParent());\n    }\n\n    @Test\n    void testGetParentReference()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n\n        assertNull(doc.getParentReference());\n\n        doc.setParent(\"parentpage\");\n\n        // ////////////////////////////////////////////////////////////////\n        // The following tests are checking that document reference cache is properly cleaned something could make the\n        // parent change\n\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace\", \"parentpage\"), doc.getParentReference());\n\n        doc.setName(\"docpage2\");\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace\", \"parentpage\"), doc.getParentReference());\n\n        doc.setSpace(\"docspace2\");\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace2\", \"parentpage\"), doc.getParentReference());\n\n        doc.setDatabase(\"docwiki2\");\n        assertEquals(new DocumentReference(\"docwiki2\", \"docspace2\", \"parentpage\"), doc.getParentReference());\n\n        doc.setDocumentReference(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace\", \"parentpage\"), doc.getParentReference());\n\n        doc.setFullName(\"docwiki2:docspace2.docpage2\", this.oldcore.getXWikiContext());\n        assertEquals(new DocumentReference(\"docwiki2\", \"docspace2\", \"parentpage\"), doc.getParentReference());\n\n        doc.setParent(\"parentpage2\");\n        assertEquals(new DocumentReference(\"docwiki2\", \"docspace2\", \"parentpage2\"), doc.getParentReference());\n    }\n\n    @Test\n    void testSetRelativeParentReference()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n\n        doc.setParentReference(new EntityReference(\"docpage2\", EntityType.DOCUMENT));\n        assertEquals(new DocumentReference(\"docwiki\", \"docspace\", \"docpage2\"), doc.getParentReference());\n        assertEquals(\"docpage2\", doc.getParent());\n    }\n\n    /**\n     * Verify that setting a new creator will create a new revision (we verify that that metadata dirty flag is set to\n     * true).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetCreatorReferenceSetsMetadataDirtyFlag()\n    {\n        // Make sure we set the flag to false to verify it's changed\n        this.document.setMetaDataDirty(false);\n\n        DocumentReference creator = new DocumentReference(\"Wiki\", \"XWiki\", \"Creator\");\n        when(this.userReferenceDocumentReferenceResolver.resolve(creator)).thenReturn(mock(UserReference.class));\n        this.document.setCreatorReference(creator);\n\n        assertEquals(true, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new creator that is the same as the currenet creator doesn't create a new revision (we\n     * verify that the metadata dirty flag is not set).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetCreatorReferenceWithSameCreatorDoesntSetMetadataDirtyFlag()\n    {\n        // Make sure we set the metadata dirty flag to false to verify it's not changed thereafter\n        DocumentReference creator = new DocumentReference(\"Wiki\", \"XWiki\", \"Creator\");\n        this.document.setCreatorReference(creator);\n        this.document.setMetaDataDirty(false);\n\n        // Set the creator with the same reference to verify it doesn't change the flag\n        this.document.setCreatorReference(new DocumentReference(\"Wiki\", \"XWiki\", \"Creator\"));\n\n        assertEquals(false, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new author will create a new revision (we verify that that metadata dirty flag is set to\n     * true).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetAuthorReferenceSetsMetadataDirtyFlag()\n    {\n        // Make sure we set the flag to false to verify it's changed\n        this.document.setMetaDataDirty(false);\n\n        DocumentReference author = new DocumentReference(\"Wiki\", \"XWiki\", \"Author\");\n        when(this.userReferenceDocumentReferenceResolver.resolve(author)).thenReturn(mock(UserReference.class));\n        this.document.setAuthorReference(author);\n\n        assertEquals(true, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new author that is the same as the currenet creator doesn't create a new revision (we\n     * verify that the metadata dirty flag is not set).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetAuthorReferenceWithSameAuthorDoesntSetMetadataDirtyFlag()\n    {\n        // Make sure we set the metadata dirty flag to false to verify it's not changed thereafter\n        DocumentReference author = new DocumentReference(\"Wiki\", \"XWiki\", \"Author\");\n        UserReference userReference = mock(UserReference.class);\n        when(this.documentReferenceUserReferenceSerializer.serialize(userReference)).thenReturn(author);\n        when(this.userReferenceDocumentReferenceResolver.resolve(author)).thenReturn(userReference);\n        this.document.setAuthorReference(author);\n        this.document.setMetaDataDirty(false);\n\n        // Set the author with the same reference to verify it doesn't change the flag\n        this.document.setAuthorReference(new DocumentReference(\"Wiki\", \"XWiki\", \"Author\"));\n\n        assertEquals(false, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new content author will create a new revision (we verify that that metadata dirty flag is\n     * set to true).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetContentAuthorReferenceSetsMetadataDirtyFlag()\n    {\n        // Make sure we set the flag to false to verify it's changed\n        this.document.setMetaDataDirty(false);\n\n        DocumentReference contentAuthor = new DocumentReference(\"Wiki\", \"XWiki\", \"ContentAuthor\");\n        when(this.userReferenceDocumentReferenceResolver.resolve(contentAuthor)).thenReturn(mock(UserReference.class));\n        this.document.setContentAuthorReference(contentAuthor);\n\n        assertEquals(true, this.document.isMetaDataDirty());\n    }\n\n    /**\n     * Verify that setting a new content author that is the same as the currenet creator doesn't create a new revision\n     * (we verify that the metadata dirty flag is not set).\n     * \n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-7445\">XWIKI-7445</a>\n     */\n    @Test\n    void testSetContentAuthorReferenceWithSameContentAuthorDoesntSetMetadataDirtyFlag()\n    {\n        // Make sure we set the metadata dirty flag to false to verify it's not changed thereafter\n        DocumentReference contentAuthor = new DocumentReference(\"Wiki\", \"XWiki\", \"ContentAuthor\");\n        this.document.setContentAuthorReference(contentAuthor);\n        this.document.setMetaDataDirty(false);\n\n        // Set the content author with the same reference to verify it doesn't change the flag\n        this.document.setContentAuthorReference(new DocumentReference(\"Wiki\", \"XWiki\", \"ContentAuthor\"));\n\n        assertEquals(false, this.document.isMetaDataDirty());\n    }\n\n    @Test\n    void testSetContentSetsContentDirtyFlag()\n    {\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        this.document.setContent(\"something\");\n\n        assertTrue(this.document.isContentDirty());\n        assertFalse(this.document.isMetaDataDirty());\n    }\n\n    @Test\n    void testSetSameContentDoesNotSetContentDirtyFlag()\n    {\n        this.document.setContent(\"something\");\n        // Make sure we set the flag to false to verify it's changed\n        this.document.setContentDirty(false);\n\n        // Set the same content again.\n        this.document.setContent(\"something\");\n\n        assertFalse(this.document.isContentDirty());\n    }\n\n    @Test\n    void testModifyObjectsSetsOnlyMetadataDirtyFlag() throws Exception\n    {\n        DocumentReference classReference = this.document.getDocumentReference();\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // New objects.\n        BaseObject object = this.document.newXObject(classReference, this.oldcore.getXWikiContext());\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Set/add objects.\n        this.document.setXObject(0, object);\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Remove objects\n        this.document.removeXObject(object);\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n    }\n\n    @Test\n    void testModifyAttachmentsSetsOnlyMetadataDirtyFlag() throws Exception\n    {\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Add attachments.\n        XWikiAttachment attachment =\n            document.addAttachment(\"file\", new ByteArrayInputStream(new byte[] {}), this.oldcore.getXWikiContext());\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n        // Add attachments (2).\n        XWikiAttachment attachment2 =\n            document.addAttachment(\"file2\", new ByteArrayInputStream(new byte[] {}), this.oldcore.getXWikiContext());\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Modify attachment.\n        attachment.setContent(new ByteArrayInputStream(new byte[] {1, 2, 3}));\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n\n        // Make sure we set the flags to false to verify it's changed\n        this.document.setContentDirty(false);\n        this.document.setMetaDataDirty(false);\n\n        // Remove objects\n        this.document.removeAttachment(attachment);\n\n        assertTrue(this.document.isMetaDataDirty());\n        assertFalse(this.document.isContentDirty());\n    }\n\n    @Test\n    void testEqualsDatas()\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"wiki\", \"space\", \"page\"));\n        XWikiDocument otherDocument = document.clone();\n\n        assertTrue(document.equals(otherDocument));\n        assertTrue(document.equalsData(otherDocument));\n\n        otherDocument.setAuthorReference(new DocumentReference(\"wiki\", \"space\", \"otherauthor\"));\n        otherDocument.setContentAuthorReference(otherDocument.getAuthorReference());\n        otherDocument.setCreatorReference(otherDocument.getAuthorReference());\n        otherDocument.setVersion(\"42.0\");\n        otherDocument.setComment(\"other comment\");\n        otherDocument.setMinorEdit(true);\n\n        document.setMinorEdit(false);\n\n        assertFalse(document.equals(otherDocument));\n        assertTrue(document.equalsData(otherDocument));\n    }\n\n    @Test\n    void testEqualsAttachments() throws XWikiException\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"wiki\", \"space\", \"page\"));\n        XWikiDocument otherDocument = document.clone();\n\n        XWikiAttachment attachment = document.addAttachment(\"file\", new byte[] {1, 2}, this.oldcore.getXWikiContext());\n        XWikiAttachment otherAttachment =\n            otherDocument.addAttachment(\"file\", new byte[] {1, 2}, this.oldcore.getXWikiContext());\n\n        assertTrue(document.equals(otherDocument));\n        assertTrue(document.equalsData(otherDocument));\n\n        otherAttachment.setContent(new byte[] {1, 2, 3});\n\n        assertFalse(document.equals(otherDocument));\n        assertFalse(document.equalsData(otherDocument));\n    }\n\n    @Test\n    void testSetMetadataDirtyWhenAttachmenListChanges() throws XWikiException\n    {\n        XWikiDocument document = new XWikiDocument();\n\n        XWikiAttachment attachment = document.addAttachment(\"file\", new byte[] {1, 2}, this.oldcore.getXWikiContext());\n\n        // Force the metadata not dirty.\n        document.setMetaDataDirty(false);\n\n        List<XWikiAttachment> attachments = document.getAttachmentList();\n        // Modify (clear) the attachments list)\n        attachments.clear();\n\n        // Check that the the metadata is now dirty as a result.\n        assertTrue(document.isMetaDataDirty());\n\n        // Check adding to list\n        document.setMetaDataDirty(false);\n        attachments.add(new XWikiAttachment());\n        assertTrue(document.isMetaDataDirty());\n\n        // Check removing from the list\n        document.setMetaDataDirty(false);\n        attachments.remove(0);\n        assertTrue(document.isMetaDataDirty());\n    }\n\n    /**\n     * XWIKI-8463: Backwards compatibility issue with setting the same attachment list to a document\n     */\n    @Test\n    void testSetGetAttachmentList() throws Exception\n    {\n        String attachmentName1 = \"someFile.txt\";\n        String attachmentName2 = \"someOtherFile.txt\";\n        this.document.addAttachment(attachmentName1, new byte[0], this.oldcore.getXWikiContext());\n        this.document.addAttachment(attachmentName2, new byte[0], this.oldcore.getXWikiContext());\n\n        List<String> attachmentNames = new ArrayList<String>();\n\n        assertEquals(2, this.document.getAttachmentList().size());\n        for (XWikiAttachment attachment : this.document.getAttachmentList()) {\n            attachmentNames.add(attachment.getFilename());\n        }\n        assertTrue(attachmentNames.contains(attachmentName1));\n        assertTrue(attachmentNames.contains(attachmentName2));\n\n        // Set back the same list returned by the getter.\n        this.document.setAttachmentList(this.document.getAttachmentList());\n\n        // The result needs to stay the same.\n        assertEquals(2, this.document.getAttachmentList().size());\n        attachmentNames.clear();\n        for (XWikiAttachment attachment : this.document.getAttachmentList()) {\n            attachmentNames.add(attachment.getFilename());\n        }\n        assertTrue(attachmentNames.contains(attachmentName1));\n        assertTrue(attachmentNames.contains(attachmentName2));\n    }\n\n    /**\n     * Unit test for {@link XWikiDocument#readFromTemplate(DocumentReference, XWikiContext)}.\n     */\n    @Test\n    void testReadFromTemplate() throws Exception\n    {\n        XWikiContext xcontext = this.oldcore.getXWikiContext();\n\n        SpaceReference spaceReference = new SpaceReference(\"Space\", new WikiReference(\"wiki\"));\n        XWikiDocument template = new XWikiDocument(new DocumentReference(\"Template\", spaceReference));\n        template.setParentReference(new EntityReference(\"Parent\", EntityType.DOCUMENT, spaceReference));\n        template.setTitle(\"Enter title here\");\n        template.setSyntax(Syntax.XWIKI_2_0);\n        template.setContent(\"Enter content here\");\n\n        DocumentReference templateAuthor = new DocumentReference(\"test\", \"Users\", \"John\");\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"dd/MM/yyyy\");\n\n        XWikiAttachment aliceAttachment = new XWikiAttachment(template, \"alice.png\");\n        aliceAttachment.setContent(new ByteArrayInputStream(\"alice content\".getBytes()));\n        aliceAttachment.setVersion(\"2.3\");\n        aliceAttachment.setDate(simpleDateFormat.parse(\"12/03/2018\"));\n        aliceAttachment.setAuthorReference(templateAuthor);\n        template.setAttachment(aliceAttachment);\n\n        XWikiAttachment bobAttachment = new XWikiAttachment(template, \"bob.png\");\n        bobAttachment.setVersion(\"5.3\");\n        bobAttachment.setDate(simpleDateFormat.parse(\"25/5/2019\"));\n        bobAttachment.setAuthorReference(templateAuthor);\n        template.setAttachment(bobAttachment);\n\n        // Verify that the attachment content is loaded before being copied.\n        XWikiAttachmentStoreInterface attachmentContentStore = mock(XWikiAttachmentStoreInterface.class);\n        xcontext.getWiki().setDefaultAttachmentContentStore(attachmentContentStore);\n        doAnswer(invocation -> {\n            XWikiAttachment attachment = invocation.getArgument(0);\n            if (\"bob.png\".equals(attachment.getFilename())) {\n                XWikiAttachmentContent attachmentContent = new XWikiAttachmentContent(attachment);\n                attachmentContent.setContent(new ByteArrayInputStream(\"bob content\".getBytes()));\n                attachment.setAttachment_content(attachmentContent);\n            }\n            return null;\n        }).when(attachmentContentStore).loadAttachmentContent(any(XWikiAttachment.class), eq(xcontext), eq(true));\n\n        this.oldcore.getSpyXWiki().saveDocument(template, xcontext);\n\n        XWikiDocument target = new XWikiDocument(new DocumentReference(\"Page\", spaceReference));\n\n        DocumentReference targetAuthor = new DocumentReference(\"test\", \"Users\", \"Denis\");\n        xcontext.setUserReference(targetAuthor);\n\n        XWikiAttachment aliceModifiedAttachment = new XWikiAttachment(target, \"alice.png\");\n        aliceModifiedAttachment.setContent(new ByteArrayInputStream(\"alice modified content\".getBytes()));\n        aliceModifiedAttachment.setVersion(\"1.2\");\n        aliceModifiedAttachment.setDate(simpleDateFormat.parse(\"07/10/2020\"));\n        aliceModifiedAttachment.setAuthorReference(targetAuthor);\n        target.setAttachment(aliceModifiedAttachment);\n\n        XWikiAttachment carolAttachment = new XWikiAttachment(target, \"carol.png\");\n        carolAttachment.setContent(new ByteArrayInputStream(\"carol content\".getBytes()));\n        carolAttachment.setVersion(\"3.1\");\n        carolAttachment.setDate(simpleDateFormat.parse(\"13/11/2020\"));\n        carolAttachment.setAuthorReference(targetAuthor);\n        target.setAttachment(carolAttachment);\n\n        target.readFromTemplate(template.getDocumentReference(), xcontext);\n\n        assertEquals(template.getDocumentReference(), target.getTemplateDocumentReference());\n        assertEquals(template.getParentReference(), target.getParentReference());\n        assertEquals(template.getTitle(), target.getTitle());\n        assertEquals(template.getSyntax(), target.getSyntax());\n        assertEquals(template.getContent(), target.getContent());\n\n        assertEquals(3, target.getAttachmentList().size());\n        assertAttachment(\"alice modified content\", \"1.2\", targetAuthor, simpleDateFormat.parse(\"07/10/2020\"),\n            target.getAttachment(\"alice.png\"));\n        assertAttachment(\"bob content\", \"1.1\", targetAuthor, null, target.getAttachment(\"bob.png\"));\n        assertAttachment(\"carol content\", \"3.1\", targetAuthor, simpleDateFormat.parse(\"13/11/2020\"),\n            target.getAttachment(\"carol.png\"));\n    }\n\n    private void assertAttachment(String expectedContent, String expectedVersion,\n        DocumentReference expectedAuthorReference, Date expectedDate, XWikiAttachment actualAttachment) throws Exception\n    {\n        XWikiContext xcontext = this.oldcore.getXWikiContext();\n        assertEquals(expectedContent, IOUtils.toString(actualAttachment.getContentInputStream(xcontext), \"UTF-8\"));\n        assertEquals(expectedVersion, actualAttachment.getVersion());\n        assertEquals(expectedAuthorReference, actualAttachment.getAuthorReference());\n        if (expectedDate != null) {\n            assertEquals(expectedDate, actualAttachment.getDate());\n        } else {\n            // The expected date is pretty recent (no more than 5 seconds ago).\n            long delta = new Date().getTime() - actualAttachment.getDate().getTime();\n            assertTrue(delta < 5000);\n        }\n    }\n\n    @Test\n    void testResolveClassReference() throws Exception\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"docwiki\", \"docspace\", \"docpage\"));\n\n        DocumentReference expected1 = new DocumentReference(\"docwiki\", \"XWiki\", \"docpage\");\n        assertEquals(expected1, doc.resolveClassReference(\"\"));\n\n        DocumentReference expected2 = new DocumentReference(\"docwiki\", \"XWiki\", \"page\");\n        assertEquals(expected2, doc.resolveClassReference(\"page\"));\n\n        DocumentReference expected3 = new DocumentReference(\"docwiki\", \"space\", \"page\");\n        assertEquals(expected3, doc.resolveClassReference(\"space.page\"));\n\n        DocumentReference expected4 = new DocumentReference(\"wiki\", \"space\", \"page\");\n        assertEquals(expected4, doc.resolveClassReference(\"wiki:space.page\"));\n    }\n\n    /**\n     * Verify that cloning objects modify their references to point to the document in which they are cloned into.\n     */\n    @Test\n    void testCloneObjectsHaveCorrectReference()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"somewiki\", \"somespace\", \"somepage\"));\n        doc.cloneXObjects(this.document);\n        assertTrue(doc.getXObjects().size() > 0);\n\n        // Verify that the object references point to the doc in which it's cloned.\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : doc.getXObjects().entrySet()) {\n            for (BaseObject baseObject : entry.getValue()) {\n                assertEquals(doc.getDocumentReference(), baseObject.getDocumentReference());\n            }\n        }\n    }\n\n    /**\n     * Verify that merging objects modify their references to point to the document in which they are cloned into and\n     * that GUID for merged objects are different from the original GUIDs.\n     */\n    @Test\n    void testMergeObjectsHaveCorrectReferenceAndDifferentGuids()\n    {\n        List<String> originalGuids = new ArrayList<String>();\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : this.document.getXObjects().entrySet()) {\n            for (BaseObject baseObject : entry.getValue()) {\n                originalGuids.add(baseObject.getGuid());\n            }\n        }\n\n        // Use a document from a different wiki to see if the class reference of the merged objects is adjusted:\n        // documents can't have objects of types defined in a different wiki.\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"somewiki\", \"somespace\", \"somepage\"));\n        doc.mergeXObjects(this.document);\n\n        assertTrue(doc.getXObjects().size() > 0);\n\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : doc.getXObjects().entrySet()) {\n            // Verify that the class reference and the target document reference have the same wiki component.\n            assertEquals(doc.getDocumentReference().getWikiReference(), entry.getKey().getWikiReference());\n            for (BaseObject baseObject : entry.getValue()) {\n                // Verify that the object references point to the doc in which it's cloned.\n                assertEquals(doc.getDocumentReference(), baseObject.getDocumentReference());\n                // Verify that GUIDs are not the same as the original ones\n                assertFalse(originalGuids.contains(baseObject.getGuid()), \"Non unique object GUID found!\");\n            }\n        }\n    }\n\n    /**\n     * Tests that objects are not copied again when {@link XWikiDocument#mergeXObjects(XWikiDocument)} is called twice.\n     */\n    @Test\n    void testMergeObjectsTwice()\n    {\n        // Make sure the target document and the template document are from different wikis.\n        XWikiDocument targetDoc = new XWikiDocument(new DocumentReference(\"someWiki\", \"someSpace\", \"somePage\"));\n\n        // Merge the objects.\n        targetDoc.mergeXObjects(this.document);\n\n        assertEquals(1, targetDoc.getXObjects().size());\n        assertEquals(0, targetDoc.getXObjectSize(CLASS_REFERENCE));\n        DocumentReference classReference = CLASS_REFERENCE.replaceParent(CLASS_REFERENCE.getWikiReference(),\n            targetDoc.getDocumentReference().getWikiReference());\n        assertEquals(2, targetDoc.getXObjectSize(classReference));\n\n        // Try to merge the objects again.\n        targetDoc.mergeXObjects(this.document);\n\n        // Check that the object from the template document was not copied again.\n        assertEquals(2, targetDoc.getXObjectSize(classReference));\n    }\n\n    /** Check that a new empty document has empty content (used to have a new line before 2.5). */\n    @Test\n    void testInitialContent()\n    {\n        XWikiDocument doc = new XWikiDocument(new DocumentReference(\"somewiki\", \"somespace\", \"somepage\"));\n        assertEquals(\"\", doc.getContent());\n    }\n\n    @Test\n    void testAuthorAfterDocumentCopy() throws XWikiException\n    {\n        DocumentReference author = new DocumentReference(\"Wiki\", \"XWiki\", \"Albatross\");\n        UserReference userReference = mock(UserReference.class);\n        when(this.documentReferenceUserReferenceSerializer.serialize(userReference)).thenReturn(author);\n        when(this.userReferenceDocumentReferenceResolver.resolve(author)).thenReturn(userReference);\n        this.document.setAuthorReference(author);\n        XWikiDocument copy =\n            this.document.copyDocument(this.document.getName() + \" Copy\", this.oldcore.getXWikiContext());\n\n        assertEquals(author, copy.getAuthorReference());\n    }\n\n    @Test\n    void testCreatorAfterDocumentCopy() throws XWikiException\n    {\n        UserReference userReference = mock(UserReference.class);\n        DocumentReference creator = new DocumentReference(\"Wiki\", \"XWiki\", \"Condor\");\n        when(this.userReferenceDocumentReferenceResolver.resolve(creator)).thenReturn(userReference);\n        when(this.documentReferenceUserReferenceSerializer.serialize(userReference)).thenReturn(creator);\n        this.document.setCreatorReference(creator);\n        XWikiDocument copy =\n            this.document.copyDocument(this.document.getName() + \" Copy\", this.oldcore.getXWikiContext());\n\n        assertEquals(creator, copy.getCreatorReference());\n    }\n\n    @Test\n    void testCreationDateAfterDocumentCopy() throws Exception\n    {\n        Date sourceCreationDate = this.document.getCreationDate();\n        Thread.sleep(1000);\n        XWikiDocument copy =\n            this.document.copyDocument(this.document.getName() + \" Copy\", this.oldcore.getXWikiContext());\n\n        assertEquals(sourceCreationDate, copy.getCreationDate());\n    }\n\n    @Test\n    void testObjectGuidsAfterDocumentCopy() throws Exception\n    {\n        assertTrue(this.document.getXObjects().size() > 0);\n\n        List<String> originalGuids = new ArrayList<String>();\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : this.document.getXObjects().entrySet()) {\n            for (BaseObject baseObject : entry.getValue()) {\n                originalGuids.add(baseObject.getGuid());\n            }\n        }\n\n        XWikiDocument copy =\n            this.document.copyDocument(this.document.getName() + \" Copy\", this.oldcore.getXWikiContext());\n\n        // Verify that the cloned objects have different GUIDs\n        for (Map.Entry<DocumentReference, List<BaseObject>> entry : copy.getXObjects().entrySet()) {\n            for (BaseObject baseObject : entry.getValue()) {\n                assertFalse(originalGuids.contains(baseObject.getGuid()), \"Non unique object GUID found!\");\n            }\n        }\n    }\n\n    @Test\n    void testRelativeObjectReferencesAfterDocumentCopy() throws Exception\n    {\n        XWikiDocument copy = this.document.copyDocument(new DocumentReference(\"copywiki\", \"copyspace\", \"copypage\"),\n            this.oldcore.getXWikiContext());\n\n        // Verify that the XObject's XClass reference points to the target wiki and not the old wiki.\n        // This tests the XObject cache.\n        DocumentReference targetXClassReference = new DocumentReference(\"copywiki\", DOCSPACE, DOCNAME);\n        assertNotNull(copy.getXObject(targetXClassReference));\n\n        // Also verify that actual XObject's reference (not from the cache).\n        assertEquals(1, copy.getXObjects().size());\n        BaseObject bobject = copy.getXObjects().get(copy.getXObjects().keySet().iterator().next()).get(0);\n        assertEquals(new DocumentReference(\"copywiki\", DOCSPACE, DOCNAME), bobject.getXClassReference());\n    }\n\n    @Test\n    void testCustomMappingAfterDocumentCopy() throws Exception\n    {\n        this.document.getXClass().setCustomMapping(\"internal\");\n\n        XWikiDocument copy = this.document.copyDocument(new DocumentReference(\"copywiki\", \"copyspace\", \"copypage\"),\n            this.oldcore.getXWikiContext());\n\n        assertEquals(\"\", copy.getXClass().getCustomMapping());\n    }\n\n    /**\n     * Normally the xobject vector has the Nth object on the Nth position, but in case an object gets misplaced, trying\n     * to remove it should indeed remove that object, and no other.\n     */\n    @Test\n    void testRemovingObjectWithWrongObjectVector()\n    {\n        // Setup: Create a document and two xobjects\n        BaseObject o1 = new BaseObject();\n        BaseObject o2 = new BaseObject();\n        o1.setXClassReference(CLASS_REFERENCE);\n        o2.setXClassReference(CLASS_REFERENCE);\n\n        // Test: put the second xobject on the third position\n        // addObject creates the object vector and configures the objects\n        // o1 is added at position 0\n        // o2 is added at position 1\n        XWikiDocument doc = new XWikiDocument(DOCUMENT_REFERENCE);\n        doc.addXObject(o1);\n        doc.addXObject(o2);\n\n        // Modify the o2 object's position to ensure it can still be found and removed by the removeObject method.\n        assertEquals(1, o2.getNumber());\n        o2.setNumber(0);\n        // Set a field on o1 so that when comparing it with o2 they are different. This is needed so that the remove\n        // will pick the right object to remove (since we've voluntarily set a wrong number of o2 it would pick o1\n        // if they were equals).\n        o1.addField(\"somefield\", new StringProperty());\n\n        // Call the tested method, removing o2 from position 2 which is set to null\n        boolean result = doc.removeXObject(o2);\n\n        // Check the correct behavior:\n        assertTrue(result);\n        List<BaseObject> objects = doc.getXObjects(CLASS_REFERENCE);\n        assertTrue(objects.contains(o1));\n        assertFalse(objects.contains(o2));\n        assertNull(objects.get(1));\n\n        // Second test: swap the two objects, so that the first object is in the position the second should have\n        // Start over, re-adding the two objects\n        doc = new XWikiDocument(DOCUMENT_REFERENCE);\n        doc.addXObject(o1);\n        doc.addXObject(o2);\n    }\n\n    @Test\n    void testCopyDocument() throws XWikiException\n    {\n        DocumentReference oldReference =\n            new DocumentReference(CLASS_REFERENCE.getWikiReference().getName(), \"space1\", \"document1\");\n        DocumentReference newReference =\n            new DocumentReference(CLASS_REFERENCE.getWikiReference().getName(), \"space2\", \"document2\");\n\n        XWikiDocument doc = new XWikiDocument(oldReference);\n        doc.setTitle(\"Some title\");\n        BaseObject o = new BaseObject();\n        o.setXClassReference(CLASS_REFERENCE);\n        doc.addXObject(o);\n        doc.setLocale(Locale.ENGLISH);\n        doc.setNew(false);\n\n        XWikiDocument newDoc = doc.copyDocument(newReference, this.oldcore.getXWikiContext());\n        BaseObject newO = newDoc.getXObject(CLASS_REFERENCE);\n\n        assertNotSame(o, newDoc.getXObject(CLASS_REFERENCE));\n        assertFalse(newO.getGuid().equals(o.getGuid()));\n        // Verify that the title is copied\n        assertEquals(\"Some title\", newDoc.getTitle());\n        assertEquals(Locale.ENGLISH, newDoc.getLocale());\n        assertEquals(newReference, newDoc.getDocumentReference());\n        assertEquals(new DocumentReference(newReference, Locale.ENGLISH), newDoc.getDocumentReferenceWithLocale());\n        assertTrue(newDoc.isNew());\n    }\n\n    /**\n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-6743\">XWIKI-6743</a>\n     * @see <a href=\"https://jira.xwiki.org/browse/XWIKI-12349\">XWIKI-12349</a>\n     */\n    @Test\n    void testCopyDocumentSetsTitleToNewDocNameIfPreviouslySetToDocName() throws XWikiException\n    {\n        copyDocumentAndAssertTitle(new DocumentReference(\"wiki1\", \"space1\", \"page1\"), \"page1\",\n            new DocumentReference(\"wiki2\", \"space2\", \"page2\"), \"page2\");\n\n        copyDocumentAndAssertTitle(new DocumentReference(\"wiki1\", \"space1\", \"WebHome\"), \"space1\",\n            new DocumentReference(\"wiki2\", \"space2\", \"page2\"), \"page2\");\n\n        copyDocumentAndAssertTitle(new DocumentReference(\"wiki1\", \"space1\", \"WebHome\"), \"space1\",\n            new DocumentReference(\"wiki2\", \"space2\", \"WebHome\"), \"space2\");\n    }\n\n    private void copyDocumentAndAssertTitle(DocumentReference oldReference, String oldTitle,\n        DocumentReference newReference, String expectedNewTitle) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(oldReference);\n        doc.setTitle(oldTitle);\n\n        XWikiDocument newDoc = doc.copyDocument(newReference, this.oldcore.getXWikiContext());\n\n        // Verify that we get the expected title.\n        assertEquals(expectedNewTitle, newDoc.getTitle());\n    }\n\n    @Test\n    void testValidate() throws XWikiException, AccessDeniedException\n    {\n        this.document.setValidationScript(\"validationScript\");\n        this.baseClass.setValidationScript(\"validationScript\");\n\n        doReturn(new XWikiValidationInterface()\n        {\n            @Override\n            public boolean validateObject(BaseObject object, XWikiContext context)\n            {\n                return true;\n            }\n\n            @Override\n            public boolean validateDocument(XWikiDocument doc, XWikiContext context)\n            {\n                return true;\n            }\n        }).when(this.oldcore.getSpyXWiki()).parseGroovyFromPage(\"validationScript\", this.oldcore.getXWikiContext());\n\n        // With PR\n\n        assertTrue(this.document.validate(this.oldcore.getXWikiContext()));\n        assertTrue(this.baseClass.validateObject(this.baseObject, this.oldcore.getXWikiContext()));\n\n        // Without PR\n\n        doThrow(AccessDeniedException.class).when(this.oldcore.getMockContextualAuthorizationManager())\n            .checkAccess(Right.PROGRAM, new DocumentReference(\"wiki\", \"space\", \"validationScript\"));\n\n        assertFalse(this.document.validate(this.oldcore.getXWikiContext()));\n        assertFalse(this.baseClass.validateObject(this.baseObject, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    void tofromXMLDocument() throws XWikiException\n    {\n        // equals won't work on password fields because of https://jira.xwiki.org/browse/XWIKI-12561\n        this.baseClass.removeField(\"passwd\");\n        this.baseObject.removeField(\"passwd\");\n        this.baseObject2.removeField(\"passwd\");\n        this.oldcore.getSpyXWiki().saveDocument(this.document, \"\", true, this.oldcore.getXWikiContext());\n\n        Document document = this.document.toXMLDocument(this.oldcore.getXWikiContext());\n\n        XWikiDocument newDocument = new XWikiDocument(this.document.getDocumentReference());\n        newDocument.fromXML(document, false);\n\n        assertEquals(this.document, newDocument);\n        // Assert that the document restored from XML is restricted in contrast to the original document.\n        assertFalse(this.document.isRestricted());\n        assertTrue(newDocument.isRestricted());\n    }\n\n    @Test\n    void getAttachmentWithNullFilename() throws XWikiException\n    {\n        assertNull(this.document.getAttachment(null));\n    }\n\n    @Test\n    void listAdd() throws XWikiException\n    {\n        // reset\n        attachmentList.clear();\n        // add without index\n        XWikiAttachment attachment = new XWikiAttachment(this.document, \"testAttachment\");\n        attachmentList.add(attachment);\n        assertTrue(this.document.getAttachmentList().contains(attachment));\n        assertTrue(this.document.getAttachment(\"testAttachment\") == attachment);\n        assertTrue(((XWikiAttachmentList) (attachmentList)).getByFilename(\"testAttachment\") == attachment);\n        assertFalse(attachmentList.add(attachment));\n        assertTrue(attachmentList.size() == 1);\n\n        // add using index\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"testAttachment2\");\n        attachmentList.add(0, attachment2);\n        assertTrue(this.document.getAttachmentList().contains(attachment2));\n        assertTrue(this.document.getAttachment(\"testAttachment2\") == attachment2);\n        assertTrue(((XWikiAttachmentList) (attachmentList)).getByFilename(\"testAttachment2\") == attachment2);\n    }\n\n    @Test\n    void listMaintainsOrder() throws XWikiException\n    {\n        XWikiAttachment attachment1 = new XWikiAttachment(this.document, \"attachmentA\");\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"attachmentB\");\n        XWikiAttachment attachment3 = new XWikiAttachment(this.document, \"attachmentC\");\n        attachmentList.add(attachment3);\n        attachmentList.add(attachment1);\n        attachmentList.add(attachment2);\n        List<XWikiAttachment> list = new ArrayList<XWikiAttachment>();\n        list.add(attachment1);\n        list.add(attachment2);\n        list.add(attachment3);\n        assertEquals(this.document.getAttachmentList(), list);\n    }\n\n    @Test\n    void listClear() throws XWikiException\n    {\n        attachmentList.clear();\n        assertTrue(attachmentList.isEmpty());\n    }\n\n    @Test\n    void listRemove() throws XWikiException\n    {\n        // remove through object parameter\n        XWikiAttachment attachment = new XWikiAttachment(this.document, \"remove\");\n        attachmentList.add(attachment);\n        attachmentList.remove(attachment);\n        assertFalse(attachmentList.contains(attachment));\n\n        // remove through index parameter\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"remove\");\n        attachmentList.add(attachment2);\n        attachmentList.remove(0);\n        assertFalse(attachmentList.contains(attachment2));\n\n        // remove attachment that is not in the list\n        assertFalse(attachmentList.remove(attachment));\n\n    }\n\n    @Test\n    void listSet() throws XWikiException\n    {\n        XWikiAttachment attachment = new XWikiAttachment(this.document, \"testAttachment\");\n        attachmentList.set(0, attachment);\n        assertTrue(this.document.getAttachmentList().contains(attachment));\n        assertTrue(this.document.getAttachment(\"testAttachment\") == attachment);\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"testAttachment\");\n        attachmentList.set(0, attachment2);\n        assertTrue(this.document.getAttachmentList().contains(attachment2));\n        assertFalse(this.document.getAttachmentList().contains(attachment));\n        assertFalse(this.document.getAttachment(\"testAttachment\") == attachment);\n        assertTrue(this.document.getAttachment(\"testAttachment\") == attachment2);\n    }\n\n    @Test\n    void listAddAll() throws XWikiException\n    {\n        ArrayList<XWikiAttachment> list = new ArrayList<XWikiAttachment>();\n        XWikiAttachment attachment1 = new XWikiAttachment(this.document, \"attachmentA\");\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"attachmentB\");\n        XWikiAttachment attachment3 = new XWikiAttachment(this.document, \"attachmentC\");\n        list.add(attachment1);\n        list.add(attachment2);\n        list.add(attachment3);\n        attachmentList.addAll(list);\n        assertTrue(attachmentList.contains(attachment1));\n        assertTrue(attachmentList.contains(attachment2));\n        assertTrue(attachmentList.contains(attachment3));\n\n        // reset\n        attachmentList.clear();\n        attachmentList.addAll(0, list);\n        assertTrue(attachmentList.contains(attachment1));\n        assertTrue(attachmentList.contains(attachment2));\n        assertTrue(attachmentList.contains(attachment3));\n\n    }\n\n    @Test\n    void listRemoveAll() throws XWikiException\n    {\n        ArrayList<XWikiAttachment> list = new ArrayList<XWikiAttachment>();\n        XWikiAttachment attachment1 = new XWikiAttachment(this.document, \"attachmentA\");\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"attachmentB\");\n        XWikiAttachment attachment3 = new XWikiAttachment(this.document, \"attachmentC\");\n        XWikiAttachment attachment4 = new XWikiAttachment(this.document, \"attachmentD\");\n        list.add(attachment1);\n        list.add(attachment2);\n        list.add(attachment3);\n        attachmentList.addAll(list);\n        attachmentList.add(attachment4);\n        attachmentList.removeAll(list);\n        assertFalse(attachmentList.contains(attachment1));\n        assertFalse(attachmentList.contains(attachment2));\n        assertFalse(attachmentList.contains(attachment3));\n        assertTrue(attachmentList.contains(attachment4));\n    }\n\n    @Test\n    void listRetainAll() throws XWikiException\n    {\n        ArrayList<XWikiAttachment> list = new ArrayList<XWikiAttachment>();\n        XWikiAttachment attachment1 = new XWikiAttachment(this.document, \"attachmentA\");\n        XWikiAttachment attachment2 = new XWikiAttachment(this.document, \"attachmentB\");\n        XWikiAttachment attachment3 = new XWikiAttachment(this.document, \"attachmentC\");\n        XWikiAttachment attachment4 = new XWikiAttachment(this.document, \"attachmentD\");\n        list.add(attachment1);\n        list.add(attachment2);\n        list.add(attachment3);\n        attachmentList.addAll(list);\n        attachmentList.add(attachment4);\n        attachmentList.retainAll(list);\n        assertTrue(attachmentList.contains(attachment1));\n        assertTrue(attachmentList.contains(attachment2));\n        assertTrue(attachmentList.contains(attachment3));\n        assertFalse(attachmentList.contains(attachment4));\n    }\n\n    @Test\n    void modifyAttachmentName()\n    {\n        XWikiAttachment attachment = new XWikiAttachment();\n\n        this.document.getAttachmentList().add(attachment);\n\n        assertSame(1, this.document.getAttachmentList().size());\n        assertSame(attachment, this.document.getAttachmentList().get(0));\n\n        attachment.setFilename(\"attachment\");\n\n        assertSame(1, this.document.getAttachmentList().size());\n        assertSame(attachment, this.document.getAttachmentList().get(0));\n        assertSame(attachment, this.document.getAttachment(\"attachment\"));\n\n        attachment.setFilename(\"attachment2\");\n\n        assertSame(1, this.document.getAttachmentList().size());\n        assertSame(attachment, this.document.getAttachmentList().get(0));\n        assertNull(this.document.getAttachment(\"attachment\"));\n        assertSame(attachment, this.document.getAttachment(\"attachment2\"));\n    }\n\n    @Test\n    void getMetaDataDiff() throws Exception\n    {\n        XWikiDocument prevDoc = new XWikiDocument(DOCUMENT_REFERENCE);\n        XWikiDocument nextDoc = new XWikiDocument(DOCUMENT_REFERENCE);\n        XWikiDocument thisDoc = new XWikiDocument(DOCUMENT_REFERENCE);\n\n        List<MetaDataDiff> diff = thisDoc.getMetaDataDiff(prevDoc, nextDoc, this.oldcore.getXWikiContext());\n        assertEquals(0, diff.size());\n\n        UserReference alice = mock(UserReference.class, \"alice\");\n        prevDoc.getAuthors().setOriginalMetadataAuthor(alice);\n\n        UserReference bob = mock(UserReference.class, \"bob\");\n        nextDoc.getAuthors().setOriginalMetadataAuthor(bob);\n\n        when(this.compactWikiUserReferenceSerializer.serialize(alice, DOCUMENT_REFERENCE)).thenReturn(\"XWiki.alice\");\n        when(this.compactWikiUserReferenceSerializer.serialize(bob, DOCUMENT_REFERENCE)).thenReturn(\"XWiki.bob\");\n\n        diff = thisDoc.getMetaDataDiff(prevDoc, nextDoc, this.oldcore.getXWikiContext());\n        assertEquals(1, diff.size());\n        assertEquals(\"author\", diff.get(0).getField());\n        assertEquals(\"XWiki.alice\", diff.get(0).getPrevValue());\n        assertEquals(\"XWiki.bob\", diff.get(0).getNewValue());\n    }\n\n    @Test\n    void getBackLinkedReferences() throws XWikiException, LinkException\n    {\n        XWikiDocument doc = new XWikiDocument(DOCUMENT_REFERENCE);\n\n        DocumentReference backlink1 = new DocumentReference(\"wiki\", \"space\", \"page1\");\n        DocumentReference backlink21 = new DocumentReference(\"wiki\", \"space\", \"page2\", Locale.ENGLISH);\n        DocumentReference backlink22 = new DocumentReference(\"wiki\", \"space\", \"page2\", Locale.FRENCH);\n\n        assertEquals(Set.of(), new HashSet<>(doc.getBackLinkedReferences(this.oldcore.getXWikiContext())));\n\n        when(this.linkStore.resolveBackLinkedEntities(DOCUMENT_REFERENCE))\n            .thenReturn(Set.of(backlink1, backlink21, backlink22));\n\n        assertEquals(Set.of(backlink1, backlink21.withoutLocale()),\n            new HashSet<>(doc.getBackLinkedReferences(this.oldcore.getXWikiContext())));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.Reader;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\n\nimport org.apache.velocity.VelocityContext;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.display.internal.DisplayConfiguration;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.annotation.AllComponents;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.velocity.VelocityEngine;\nimport org.xwiki.velocity.VelocityFactory;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.api.Document;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.TextAreaClass;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.startsWith;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link XWikiDocument}'s rendering methods\n * ({@code getRenderedTitle()} and {@code getRenderedContent()}).\n *\n * @version $Id$\n */\n@OldcoreTest\n@AllComponents\npublic class XWikiDocumentRenderingTest\n{\n    private static final String DOCWIKI = \"xwiki\";\n\n    private static final String DOCSPACE = \"Space\";\n\n    private static final String DOCNAME = \"Page\";\n\n    private static final String DOCFULLNAME = DOCSPACE + \".\" + DOCNAME;\n\n    private static final String CLASSNAME = DOCFULLNAME;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    @InjectComponentManager\n    private MockitoComponentManager componentManager;\n\n    private DisplayConfiguration displayConfiguration;\n\n    private XWikiDocument document;\n\n    private BaseClass baseClass;\n\n    private BaseObject baseObject;\n\n    private XWiki xwiki;\n\n    @BeforeEach\n    public void setupComponents() throws Exception\n    {\n        // Setup display configuration.\n        this.displayConfiguration = this.componentManager.registerMockComponent(DisplayConfiguration.class);\n        when(this.displayConfiguration.getDocumentDisplayerHint()).thenReturn(\"default\");\n        when(this.displayConfiguration.getTitleHeadingDepth()).thenReturn(2);\n    }\n\n    @BeforeEach\n    public void setup() throws Exception\n    {\n        this.xwiki = this.oldcore.getSpyXWiki();\n\n        DocumentReference documentReference = new DocumentReference(DOCWIKI, DOCSPACE, DOCNAME);\n        this.document = new XWikiDocument(documentReference);\n        this.document.setSyntax(Syntax.XWIKI_2_1);\n        this.document.setNew(false);\n\n        this.oldcore.getXWikiContext().setDoc(this.document);\n\n        this.baseClass = this.document.getXClass();\n        this.baseClass.addTextField(\"string\", \"String\", 30);\n        this.baseClass.addTextAreaField(\"area\", \"Area\", 10, 10);\n        this.baseClass.addTextAreaField(\"puretextarea\", \"Pure text area\", 10, 10);\n        // set the text areas an non interpreted content\n        ((TextAreaClass) this.baseClass.getField(\"puretextarea\")).setContentType(\"puretext\");\n        this.baseClass.addPasswordField(\"passwd\", \"Password\", 30);\n        this.baseClass.addBooleanField(\"boolean\", \"Boolean\", \"yesno\");\n        this.baseClass.addNumberField(\"int\", \"Int\", 10, \"integer\");\n        this.baseClass.addStaticListField(\"stringlist\", \"StringList\", \"value1, value2\");\n\n        doReturn(this.baseClass).when(this.xwiki).getXClass(any(), any());\n\n        this.baseObject = this.document.newObject(CLASSNAME, this.oldcore.getXWikiContext());\n        this.baseObject.setStringValue(\"string\", \"string\");\n        this.baseObject.setLargeStringValue(\"area\", \"area\");\n        this.baseObject.setStringValue(\"passwd\", \"passwd\");\n        this.baseObject.setIntValue(\"boolean\", 1);\n        this.baseObject.setIntValue(\"int\", 42);\n        this.baseObject.setStringListValue(\"stringlist\", Arrays.asList(\"VALUE1\", \"VALUE2\"));\n\n        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);\n\n        when(this.oldcore.getMockAuthorizationManager().hasAccess(any(), any(), any())).thenReturn(true);\n        when(this.oldcore.getMockContextualAuthorizationManager().hasAccess(any())).thenAnswer(invocationOnMock -> {\n            if (List.of(Right.SCRIPT, Right.PROGRAM).contains(invocationOnMock.getArgument(0))) {\n                RenderingContext renderingContext = this.oldcore.getMocker().getInstance(RenderingContext.class);\n                return !renderingContext.isRestricted();\n            } else {\n                return true;\n            }\n        });\n        when(this.xwiki.getRightService().hasProgrammingRights(any())).thenReturn(true);\n\n        this.componentManager\n            .registerComponent(ConfigurationSource.class, \"xwikicfg\", this.oldcore.getConfigurationSource());\n    }\n\n    @Test\n    public void getRenderedContentWithCurrentDocumentVariableIsInjectedBeforeRendering() throws Exception\n    {\n        // Verifies we can access the doc variable from a groovy macro.\n        this.document.setContent(\"{{groovy}}print(doc);{{/groovy}}\");\n\n        assertEquals(\"<p>Space.Page</p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleWhenTitleIsSet()\n    {\n        // Plain title\n        this.document.setTitle(\"title\");\n        assertEquals(\"title\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        // Title with wiki syntax that should not be evaluated\n        this.document.setTitle(\"**title**\");\n        assertEquals(\"**title**\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        // Title with HTML syntax that should not be evaluated\n        this.document.setTitle(\"<strong>ti<em>tle</strong>\");\n        // The title is parsed as plain text after the Velocity code is evaluated so the HTML have no meaning.\n        assertEquals(\"&lt;strong&gt;ti&lt;em&gt;tle&lt;/strong&gt;\",\n            this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n        assertEquals(\"<strong>ti<em>tle</strong>\",\n            this.document.getRenderedTitle(Syntax.PLAIN_1_0, this.oldcore.getXWikiContext()));\n\n        // Title with velocity that should be evaluated\n        this.document.setTitle(\"#set($key = \\\"title\\\")$key\");\n        assertEquals(\"title\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    void getRenderedTitleRestricted()\n    {\n        this.document.setRestricted(true);\n        // Title with velocity that shouldn't be evaluated\n        String title = \"#set($key = \\\"title\\\")$key\";\n        this.document.setTitle(title);\n        assertEquals(title, this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleInHTMLWhenExtractedFromContent()\n    {\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n\n        this.document.setContent(\n            \"content not in section\\n\" + \"= header 1=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"header 1\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\n            \"content not in section\\n\" + \"= **header 1**=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"<strong>header 1</strong>\",\n            this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\n            \"content not in section\\n\" + \"= [[Space.Page]]=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"<span class=\\\"wikiexternallink\\\"><a href=\\\"Space.Page\\\">\"\n                + \"<span class=\\\"wikigeneratedlinkcontent\\\">Space.Page</span></a></span>\",\n            this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"content not in section\\n\" + \"= #set($var ~= \\\"value\\\")=\\nheader 1 content\\n\"\n            + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"#set($var = \\\"value\\\")\",\n            this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"content not in section\\n\"\n            + \"= {{groovy}}print \\\"value\\\"{{/groovy}}=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"value\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"content not in section\\n=== header 3===\");\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    void getRenderedTitleWhenRestricted()\n    {\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n        this.document.setRestricted(true);\n\n        this.document.setContent(\"content not in section\\n\"\n            + \"= {{groovy}}print \\\"value\\\"{{/groovy}}=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertThat(this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()),\n            startsWith(\"<span class=\\\"xwikirenderingerror\\\">Failed to execute the [groovy] macro.\"));\n    }\n\n    @Test\n    public void getRenderedTitleInPlainWhenExtractedFromContent()\n    {\n        this.document.setContent(\n            \"content not in section\\n\" + \"= **header 1**=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.PLAIN_1_0, this.oldcore.getXWikiContext()));\n\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n\n        this.document.setContent(\n            \"content not in section\\n\" + \"= **header 1**=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"header 1\", this.document.getRenderedTitle(Syntax.PLAIN_1_0, this.oldcore.getXWikiContext()));\n\n        this.document.setContent(\"content not in section\\n\"\n            + \"= {{groovy}}print \\\"value\\\"{{/groovy}}=\\nheader 1 content\\n\" + \"== header 2==\\nheader 2 content\");\n        assertEquals(\"value\", this.document.getRenderedTitle(Syntax.PLAIN_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleWhenNoTitleAndNoContentSet()\n    {\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * Make sure title extracted from content is protected from cycles\n     */\n    @Test\n    public void getRenderedTitleWhenRecursive()\n    {\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n\n        this.document.setContent(\"= {{groovy}}print doc.getDisplayTitle(){{/groovy}}\");\n\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleWhenMatchingTitleHeaderDepth()\n    {\n        // Configure XWiki to extract title from content\n        this.oldcore.getConfigurationSource().setProperty(\"xwiki.title.compatibility\", \"1\");\n\n        this.document.setContent(\"=== level3\");\n\n        // Overwrite the title heading depth.\n        when(this.displayConfiguration.getTitleHeadingDepth()).thenReturn(3);\n\n        assertEquals(\"level3\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedTitleWhenNotMatchingTitleHeaderDepth()\n    {\n        this.document.setContent(\"=== level3\");\n\n        assertEquals(\"Page\", this.document.getRenderedTitle(Syntax.XHTML_1_0, this.oldcore.getXWikiContext()));\n    }\n\n    /**\n     * See XWIKI-5277 for details.\n     */\n    @Test\n    public void getRenderedContentCleansVelocityMacroCache() throws Exception\n    {\n        // Make sure we start not in the rendering engine since this is what happens in real: a document is\n        // called by a template thus outside of the rendering engine.\n        this.oldcore.getXWikiContext().remove(\"isInRenderingEngine\");\n\n        // We display a text area since we know that rendering a text area will call getRenderedContent inside our top\n        // level getRenderedContent call, thus testing that velocity macros are not removed during nested calls to\n        // getRenderedContent.\n        this.baseObject.setLargeStringValue(\"area\", \"{{velocity}}#macro(testmacrocache)ok#end{{/velocity}}\");\n        this.document.setContent(\"{{velocity}}$doc.display(\\\"area\\\")#testmacrocache{{/velocity}}\");\n\n        // We need to put the current doc in the Velocity Context since it's normally set before the rendering is\n        // called in the execution flow.\n        VelocityManager originalVelocityManager = this.componentManager.getInstance(VelocityManager.class);\n        VelocityContext vcontext = originalVelocityManager.getVelocityContext();\n        vcontext.put(\"doc\", new Document(this.document, this.oldcore.getXWikiContext()));\n\n        // Register a Mock for the VelocityManager to bypass skin APIs that we would need to mock otherwise.\n        VelocityManager velocityManager = this.componentManager.registerMockComponent(VelocityManager.class);\n        when(velocityManager.getCurrentVelocityContext()).thenReturn(vcontext);\n\n        VelocityFactory velocityFactory = this.componentManager.getInstance(VelocityFactory.class);\n        VelocityEngine vengine = velocityFactory.createVelocityEngine(\"default\", new Properties());\n        when(velocityManager.getVelocityEngine()).thenReturn(vengine);\n        when(velocityManager.evaluate(any(), any(), any()))\n            .thenAnswer(invocation -> vengine.evaluate(vcontext, invocation.getArgument(0),\n                invocation.getArgument(1), (Reader) invocation.getArgument(2)));\n\n        // Verify that the macro located inside the TextArea has been taken into account when executing the doc's\n        // content.\n        assertEquals(\"<p>ok</p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentWithAndWithoutTranslations() throws Exception\n    {\n        this.document.setContent(\"**bold**\");\n        this.document.setSyntax(Syntax.XWIKI_2_0);\n\n        // Check the content from the default document\n        assertEquals(\"<p><strong>bold</strong></p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n\n        // Create a translation and set the current language to be that of the translation to verify that the rendered\n        // content is that of the translated document\n        // Note that this also verifies that the translation can have a different syntax than the default doc.\n        XWikiDocument translatedDocument = new XWikiDocument(this.document.getDocumentReference(), Locale.FRENCH);\n        translatedDocument.setContent(\"//italic//\");\n        translatedDocument.setSyntax(Syntax.XWIKI_1_0);\n        translatedDocument.setNew(false);\n\n        doReturn(Locale.FRENCH.toString()).when(this.xwiki).getLanguagePreference(any());\n        doReturn(translatedDocument).when(this.xwiki).getDocument(\n            eq(new DocumentReference(translatedDocument.getDocumentReference(), translatedDocument.getLocale())),\n            any());\n        assertEquals(\"<p><em>italic</em></p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p><strong>bold</strong></p>\", this.document.displayDocument(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentIsForcingCurrentDocumentAsTheSecurityDocument() throws Exception\n    {\n        // Remove whatever security document there is, to prove that a new security document is forced (it's set as\n        // the current document).\n        this.oldcore.getXWikiContext().remove(\"sdoc\");\n\n        this.document.setContent(\"{{velocity}}$xcontext.sdoc{{/velocity}}\");\n\n        // Verifies that a security document is always set,  independently of what was set before the execution of\n        // getRenderedContent().\n        assertEquals(\"<p>Space.Page</p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    void getRenderedContentSetsRestrictedRendering() throws Exception\n    {\n        XWikiDocument otherDocument = new XWikiDocument(new DocumentReference(\"otherwiki\", \"otherspace\", \"otherpage\"));\n        otherDocument.setContentAuthorReference(new DocumentReference(\"otherwiki\", \"XWiki\", \"othercontentauthor\"));\n        XWikiDocument sdoc = new XWikiDocument(new DocumentReference(\"callerwiki\", \"callerspace\", \"callerpage\"));\n        Document apiDocument = this.document.newDocument(this.oldcore.getXWikiContext());\n\n        String content = \"{{velocity}}test{{/velocity}}\";\n\n        this.document.setRestricted(true);\n        this.document.setContent(content);\n        this.oldcore.getXWikiContext().setDoc(null);\n\n        // Verify that the Velocity macro is not executed.\n        assertThat(this.document.getRenderedContent(this.oldcore.getXWikiContext()),\n            startsWith(\"<div class=\\\"xwikirenderingerror\\\">Failed to execute the [velocity] macro.\"));\n\n        this.document.setRestricted(false);\n\n        assertEquals(\"<p>test</p>\", this.document.getRenderedContent(this.oldcore.getXWikiContext()));\n\n        this.oldcore.getXWikiContext().setDoc(otherDocument);\n\n        assertEquals(\"<p>test</p>\", apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        otherDocument.setRestricted(true);\n\n        assertThat(apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()),\n            startsWith(\"<div class=\\\"xwikirenderingerror\\\">Failed to execute the [velocity] macro.\"));\n\n        this.oldcore.getXWikiContext().put(\"sdoc\", sdoc);\n        assertEquals(\"<p>test</p>\", apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        sdoc.setRestricted(true);\n\n        assertThat(apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()),\n            startsWith(\"<div class=\\\"xwikirenderingerror\\\">Failed to execute the [velocity] macro.\"));\n    }\n\n    @Test\n    public void getRenderedContentTextWithSourceSyntaxSpecified()\n    {\n        this.document.setSyntax(Syntax.XWIKI_1_0);\n\n        assertEquals(\"<p><strong>bold</strong></p>\",\n            this.document.getRenderedContent(\"**bold**\", \"xwiki/2.0\", this.oldcore.getXWikiContext()));\n    }\n\n    @Test\n    public void getRenderedContentTextRights() throws Exception\n    {\n        XWikiDocument otherDocument = new XWikiDocument(new DocumentReference(\"otherwiki\", \"otherspace\", \"otherpage\"));\n        otherDocument.setContentAuthorReference(new DocumentReference(\"otherwiki\", \"XWiki\", \"othercontentauthor\"));\n        XWikiDocument sdoc = new XWikiDocument(new DocumentReference(\"callerwiki\", \"callerspace\", \"callerpage\"));\n        sdoc.setContentAuthorReference(new DocumentReference(\"callerwiki\", \"XWiki\", \"calleruser\"));\n        Document apiDocument = this.document.newDocument(this.oldcore.getXWikiContext());\n\n        this.oldcore.getXWikiContext().setDoc(null);\n\n        String content =\n            \"{{velocity}}$xcontext.sdoc.contentAuthorReference $xcontext.doc $xcontext.doc.contentAuthorReference\"\n                + \"{{/velocity}}\";\n\n        this.document.setContentAuthorReference(new DocumentReference(\"authorwiki\", \"XWiki\", \"contentauthor\"));\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), Syntax.XHTML_1_0.toIdString()));\n\n        assertEquals(\"<p>otherwiki:XWiki.othercontentauthor Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), false, otherDocument,\n                this.oldcore.getXWikiContext()));\n\n        this.oldcore.getXWikiContext().setDoc(otherDocument);\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>otherwiki:XWiki.othercontentauthor Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        assertEquals(\"<p>otherwiki:XWiki.othercontentauthor Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), Syntax.XHTML_1_0.toIdString()));\n\n        this.oldcore.getXWikiContext().put(\"sdoc\", sdoc);\n        this.oldcore.getXWikiContext().setDoc(this.document);\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), Syntax.XHTML_1_0.toIdString()));\n\n        this.oldcore.getXWikiContext().setDoc(otherDocument);\n\n        assertEquals(\"<p>$xcontext.sdoc.contentAuthorReference Space.Page authorwiki:XWiki.contentauthor</p>\",\n            this.document.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), this.oldcore.getXWikiContext()));\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString()));\n\n        assertEquals(\"<p>callerwiki:XWiki.calleruser Space.Page authorwiki:XWiki.contentauthor</p>\",\n            apiDocument.getRenderedContent(content, Syntax.XWIKI_2_1.toIdString(), Syntax.XHTML_1_0.toIdString()));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.test;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.inject.Provider;\nimport javax.script.ScriptContext;\nimport javax.servlet.ServletContext;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.hibernate.cfg.Configuration;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.bridge.DocumentAccessBridge;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.component.descriptor.DefaultComponentDescriptor;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.configuration.internal.MemoryConfigurationSource;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.context.ExecutionContextManager;\nimport org.xwiki.environment.Environment;\nimport org.xwiki.environment.internal.ServletEnvironment;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.internal.reference.EntityReferenceFactory;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.query.QueryManager;\nimport org.xwiki.refactoring.internal.ModelBridge;\nimport org.xwiki.refactoring.internal.ReferenceUpdater;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.script.internal.CloneableSimpleScriptContext;\nimport org.xwiki.script.internal.ScriptExecutionContextInitializer;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.test.XWikiTempDirUtil;\nimport org.xwiki.test.annotation.AllComponents;\nimport org.xwiki.test.internal.MockConfigurationSource;\nimport org.xwiki.test.mockito.MockitoComponentManager;\nimport org.xwiki.url.URLConfiguration;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.user.UserReferenceSerializer;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\n\nimport com.xpn.xwiki.CoreConfiguration;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.doc.rcs.XWikiRCSNodeInfo;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.internal.filter.XWikiDocumentFilterUtils;\nimport com.xpn.xwiki.internal.store.hibernate.HibernateStore;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.store.AttachmentVersioningStore;\nimport com.xpn.xwiki.store.XWikiHibernateBaseStore;\nimport com.xpn.xwiki.store.XWikiHibernateStore;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiAuthService;\nimport com.xpn.xwiki.user.api.XWikiGroupService;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.util.XWikiStubContextProvider;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\n\nimport static com.xpn.xwiki.test.mockito.OldcoreMatchers.anyXWikiContext;\nimport static com.xpn.xwiki.test.mockito.OldcoreMatchers.anyXWikiDocument;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyBoolean;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.doNothing;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.when;\n\n/**\n * Test setup to initialize and manipulate various oldcore APIs.\n * \n * @version $Id$\n * @since 10.2\n */\npublic class MockitoOldcore\n{\n    public static final LocalDocumentReference USER_CLASS = new LocalDocumentReference(\"XWiki\", \"XWikiUsers\");\n\n    public static final LocalDocumentReference GROUP_CLASS = new LocalDocumentReference(\"XWiki\", \"XWikiGroups\");\n\n    public static final LocalDocumentReference RIGHTS_CLASS = new LocalDocumentReference(\"XWiki\", \"XWikiRights\");\n\n    public static final LocalDocumentReference GLOBAL_RIGHTS_CLASS =\n        new LocalDocumentReference(\"XWiki\", \"XWikiGlobalRights\");\n\n    private final MockitoComponentManager componentManager;\n\n    private XWikiContext context;\n\n    private XWiki spyXWiki;\n\n    protected File permanentDirectory;\n\n    protected File temporaryDirectory;\n\n    private HibernateStore mockHibernateStore;\n\n    private XWikiHibernateStore mockXWikiHibernateStore;\n\n    private XWikiVersioningStoreInterface mockVersioningStore;\n\n    private AttachmentVersioningStore mockAttachmentVersioningStore;\n\n    private XWikiRightService mockRightService;\n\n    private XWikiAuthService mockAuthService;\n\n    private XWikiGroupService mockGroupService;\n\n    private AuthorizationManager mockAuthorizationManager;\n\n    private ContextualAuthorizationManager mockContextualAuthorizationManager;\n\n    private QueryManager queryManager;\n\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    protected Map<DocumentReference, XWikiDocument> documents = new ConcurrentHashMap<>();\n\n    protected Map<DocumentReference, XWikiDocumentArchive> documentArchives = new ConcurrentHashMap<>();\n\n    private boolean notifyDocumentCreatedEvent;\n\n    private boolean notifyDocumentUpdatedEvent;\n\n    private boolean notifyDocumentDeletedEvent;\n\n    private MemoryConfigurationSource configurationSource;\n\n    private MemoryConfigurationSource xwikicfgConfigurationSource;\n\n    private MemoryConfigurationSource wikiConfigurationSource;\n\n    private MemoryConfigurationSource spaceConfigurationSource;\n\n    private ScriptContext scriptContext;\n\n    private Environment environment;\n\n    private DocumentAccessBridge documentAccessBridge;\n\n    private boolean mockXWiki = true;\n\n    public MockitoOldcore(MockitoComponentManager componentManager)\n    {\n        this.componentManager = componentManager;\n    }\n\n    public MockitoComponentManager getMocker()\n    {\n        return this.componentManager;\n    }\n\n    public void notifyDocumentCreatedEvent(boolean notifyDocumentCreatedEvent)\n    {\n        this.notifyDocumentCreatedEvent = notifyDocumentCreatedEvent;\n    }\n\n    public void notifyDocumentUpdatedEvent(boolean notifyDocumentUpdatedEvent)\n    {\n        this.notifyDocumentUpdatedEvent = notifyDocumentUpdatedEvent;\n    }\n\n    public void notifyDocumentDeletedEvent(boolean notifyDocumentDeletedEvent)\n    {\n        this.notifyDocumentDeletedEvent = notifyDocumentDeletedEvent;\n    }\n\n    public void mockXWiki(boolean mockXWiki)\n    {\n        this.mockXWiki = mockXWiki;\n    }\n\n    /**\n     * Enabled notification of component descriptor registration/unregistration.\n     * \n     * @throws ComponentLookupException when failing to lookup {@link ObservationManager} component\n     */\n    public void notifyComponentDescriptorEvent() throws ComponentLookupException\n    {\n        getMocker().notifyComponentDescriptorEvent();\n    }\n\n    public void before(Class<?> testClass) throws Exception\n    {\n        // Statically store the component manager in {@link Utils} to be able to access it without\n        // the context.\n        Utils.setComponentManager(getMocker());\n\n        this.context = new XWikiContext();\n\n        getXWikiContext().setWikiId(\"xwiki\");\n        getXWikiContext().setMainXWiki(\"xwiki\");\n\n        this.spyXWiki = spy(new XWiki());\n        getXWikiContext().setWiki(this.spyXWiki);\n\n        this.mockHibernateStore = getMocker().registerMockComponent(HibernateStore.class);\n        this.mockXWikiHibernateStore = mock(XWikiHibernateStore.class);\n        getMocker().registerComponent(XWikiStoreInterface.class, XWikiHibernateBaseStore.HINT,\n            this.mockXWikiHibernateStore);\n        this.mockVersioningStore =\n            getMocker().registerMockComponent(XWikiVersioningStoreInterface.class, XWikiHibernateBaseStore.HINT);\n        this.mockAttachmentVersioningStore =\n            getMocker().registerMockComponent(AttachmentVersioningStore.class, XWikiHibernateBaseStore.HINT);\n        this.mockRightService = mock(XWikiRightService.class);\n        this.mockGroupService = mock(XWikiGroupService.class);\n        this.mockAuthService = mock(XWikiAuthService.class);\n\n        doReturn(new Configuration()).when(this.mockHibernateStore).getConfiguration();\n\n        this.spyXWiki.setStore(this.mockXWikiHibernateStore);\n        this.spyXWiki.setVersioningStore(this.mockVersioningStore);\n        this.spyXWiki.setDefaultAttachmentArchiveStore(this.mockAttachmentVersioningStore);\n        this.spyXWiki.setRightService(this.mockRightService);\n        this.spyXWiki.setAuthService(this.mockAuthService);\n        this.spyXWiki.setGroupService(this.mockGroupService);\n        this.spyXWiki.setPluginManager(new XWikiPluginManager());\n\n        // We need to initialize the Component Manager so that the components can be looked up\n        getXWikiContext().put(ComponentManager.class.getName(), getMocker());\n\n        if (testClass.getAnnotation(AllComponents.class) != null) {\n            // If @AllComponents is enabled force mocking AuthorizationManager and ContextualAuthorizationManager if not\n            // already mocked\n            this.mockAuthorizationManager = getMocker().registerMockComponent(AuthorizationManager.class, false);\n            this.mockContextualAuthorizationManager =\n                getMocker().registerMockComponent(ContextualAuthorizationManager.class, false);\n        } else {\n            // Make sure an AuthorizationManager and a ContextualAuthorizationManager is available\n            if (!getMocker().hasComponent(AuthorizationManager.class)) {\n                this.mockAuthorizationManager = getMocker().registerMockComponent(AuthorizationManager.class);\n            }\n            if (!getMocker().hasComponent(ContextualAuthorizationManager.class)) {\n                this.mockContextualAuthorizationManager =\n                    getMocker().registerMockComponent(ContextualAuthorizationManager.class);\n            }\n        }\n\n        // Make sure to provide a EntityReferenceFactory\n        if (!getMocker().hasComponent(EntityReferenceFactory.class)) {\n            EntityReferenceFactory factory = getMocker().registerMockComponent(EntityReferenceFactory.class);\n            when(factory.getReference(any())).thenAnswer((invocation) -> invocation.getArgument(0));\n        }\n\n        // Make sure a default ConfigurationSource is available\n        if (!getMocker().hasComponent(ConfigurationSource.class)) {\n            this.configurationSource = getMocker().registerMemoryConfigurationSource();\n        }\n\n        // Make sure a \"xwikicfg\" ConfigurationSource is available\n        if (!getMocker().hasComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT)) {\n            this.xwikicfgConfigurationSource = new MockConfigurationSource();\n            getMocker().registerComponent(MockConfigurationSource.getDescriptor(XWikiCfgConfigurationSource.ROLEHINT),\n                this.xwikicfgConfigurationSource);\n        }\n        // Make sure a \"wiki\" ConfigurationSource is available\n        if (!getMocker().hasComponent(ConfigurationSource.class, \"wiki\")) {\n            this.wikiConfigurationSource = new MockConfigurationSource();\n            getMocker().registerComponent(MockConfigurationSource.getDescriptor(\"wiki\"), this.wikiConfigurationSource);\n        }\n\n        // Make sure a \"space\" ConfigurationSource is available\n        if (!getMocker().hasComponent(ConfigurationSource.class, \"space\")) {\n            this.spaceConfigurationSource = new MockConfigurationSource();\n            getMocker().registerComponent(MockConfigurationSource.getDescriptor(\"space\"),\n                this.spaceConfigurationSource);\n        }\n\n        // Since the oldcore module draws the Servlet Environment in its dependencies we need to ensure it's set up\n        // correctly with a Servlet Context.\n        if (getMocker().hasComponent(Environment.class)) {\n            if (getMocker().getInstance(Environment.class) instanceof ServletEnvironment) {\n                ServletEnvironment servletEnvironment = getMocker().getInstance(Environment.class);\n\n                ServletContext servletContextMock = mock(ServletContext.class);\n                servletEnvironment.setServletContext(servletContextMock);\n                when(servletContextMock.getAttribute(\"javax.servlet.context.tempdir\"))\n                    .thenReturn(new File(System.getProperty(\"java.io.tmpdir\")));\n\n                initEnvironmentDirectories();\n\n                servletEnvironment.setTemporaryDirectory(this.temporaryDirectory);\n                servletEnvironment.setPermanentDirectory(this.permanentDirectory);\n\n                this.environment = servletEnvironment;\n            }\n        } else {\n            // Automatically register an Environment when none is available since it's a very common need\n            registerMockEnvironment();\n        }\n\n        // Initialize XWikiContext provider\n        if (!this.componentManager.hasComponent(XWikiContext.TYPE_PROVIDER)) {\n            Provider<XWikiContext> xcontextProvider =\n                this.componentManager.registerMockComponent(XWikiContext.TYPE_PROVIDER);\n            when(xcontextProvider.get()).thenReturn(getXWikiContext());\n        } else {\n            Provider<XWikiContext> xcontextProvider = this.componentManager.getInstance(XWikiContext.TYPE_PROVIDER);\n            if (MockUtil.isMock(xcontextProvider)) {\n                when(xcontextProvider.get()).thenReturn(getXWikiContext());\n            }\n        }\n\n        // Initialize readonly XWikiContext provider\n        if (!this.componentManager.hasComponent(XWikiContext.TYPE_PROVIDER, \"readonly\")) {\n            Provider<XWikiContext> xcontextProvider =\n                this.componentManager.registerMockComponent(XWikiContext.TYPE_PROVIDER, \"readonly\");\n            when(xcontextProvider.get()).thenReturn(getXWikiContext());\n        } else {\n            Provider<XWikiContext> xcontextProvider = this.componentManager.getInstance(XWikiContext.TYPE_PROVIDER);\n            if (MockUtil.isMock(xcontextProvider)) {\n                when(xcontextProvider.get()).thenReturn(getXWikiContext());\n            }\n        }\n\n        // Initialize the Execution Context\n        if (this.componentManager.hasComponent(ExecutionContextManager.class)) {\n            ExecutionContextManager ecm = this.componentManager.getInstance(ExecutionContextManager.class);\n            ExecutionContext ec = new ExecutionContext();\n            ecm.initialize(ec);\n        }\n\n        // Bridge with old XWiki Context, required for old code.\n        Execution execution;\n        if (this.componentManager.hasComponent(Execution.class)) {\n            execution = this.componentManager.getInstance(Execution.class);\n        } else {\n            execution = this.componentManager.registerMockComponent(Execution.class);\n        }\n        ExecutionContext econtext;\n        if (MockUtil.isMock(execution)) {\n            econtext = new ExecutionContext();\n            when(execution.getContext()).thenReturn(econtext);\n        } else {\n            econtext = execution.getContext();\n        }\n\n        // Set a few standard things in the ExecutionContext\n        econtext.setProperty(XWikiContext.EXECUTIONCONTEXT_KEY, getXWikiContext());\n        this.scriptContext = (ScriptContext) econtext.getProperty(ScriptExecutionContextInitializer.SCRIPT_CONTEXT_ID);\n        if (this.scriptContext == null) {\n            this.scriptContext = new CloneableSimpleScriptContext();\n            econtext.setProperty(ScriptExecutionContextInitializer.SCRIPT_CONTEXT_ID, this.scriptContext);\n        }\n\n        if (!this.componentManager.hasComponent(ScriptContextManager.class)) {\n            ScriptContextManager scriptContextManager =\n                this.componentManager.registerMockComponent(ScriptContextManager.class);\n            when(scriptContextManager.getCurrentScriptContext()).thenReturn(this.scriptContext);\n            when(scriptContextManager.getScriptContext()).thenReturn(this.scriptContext);\n        }\n\n        // Initialize the initial context in the stub context provider (which is then used for all calls to\n        // createStubContext() in the stub context provider). This is to simulate an XWiki runtime, where this is\n        // initialized on the first HTTP request.\n        if (this.componentManager.hasComponent(XWikiStubContextProvider.class)) {\n            XWikiStubContextProvider stubContextProvider =\n                this.componentManager.getInstance(XWikiStubContextProvider.class);\n            if (!MockUtil.isMock(stubContextProvider)) {\n                // TODO: Since we create the XWikiContext in this method and since no request has been set into it at\n                // this point, the initial context in XWikiStubContextProvider would normally be initialized with an\n                // empty request which would lead to some NPE when ServletRequest is used later on, for example. Thus\n                // we force a request in the context here before the call to stubContextProvider.initialize().\n                // Note that this needs to be refactored to let the test control what to initialize in the initial\n                // context (i.e. before stubContextProvider.initialize() is called).\n                // Also note that setting a non null request forces us to set a non null URL as otherwise it would lead\n                // to another NPE...\n                XWikiRequest originalRequest = getXWikiContext().getRequest();\n                if (getXWikiContext().getRequest() == null) {\n                    getXWikiContext().setRequest(new XWikiServletRequestStub());\n                }\n                URL originalURL = getXWikiContext().getURL();\n                if (getXWikiContext().getURL() == null) {\n                    getXWikiContext().setURL(new URL(\"http://localhost:8080\"));\n                }\n                stubContextProvider.initialize(getXWikiContext());\n                // Make sure we leave the XWikiContext unchanged (since we just temporarily modified the URL and\n                // request to set up the initial context in XWikiStubContextProvider).\n                getXWikiContext().setURL(originalURL);\n                getXWikiContext().setRequest(originalRequest);\n            }\n        }\n\n        // Make sure to have a mocked CoreConfiguration (even if one already exist)\n        if (!this.componentManager.hasComponent(CoreConfiguration.class)) {\n            CoreConfiguration coreConfigurationMock =\n                this.componentManager.registerMockComponent(CoreConfiguration.class);\n            when(coreConfigurationMock.getDefaultDocumentSyntax()).thenReturn(Syntax.XWIKI_2_1);\n        } else {\n            CoreConfiguration coreConfiguration =\n                this.componentManager.registerMockComponent(CoreConfiguration.class, false);\n            if (MockUtil.isMock(coreConfiguration)) {\n                when(coreConfiguration.getDefaultDocumentSyntax()).thenReturn(Syntax.XWIKI_2_1);\n            }\n        }\n\n        // Set a context ComponentManager if none exist\n        if (!this.componentManager.hasComponent(ComponentManager.class, \"context\")) {\n            DefaultComponentDescriptor<ComponentManager> componentManagerDescriptor =\n                new DefaultComponentDescriptor<>();\n            componentManagerDescriptor.setRoleHint(\"context\");\n            componentManagerDescriptor.setRoleType(ComponentManager.class);\n            this.componentManager.registerComponent(componentManagerDescriptor, this.componentManager);\n        }\n\n        // Register mock components for refactoring listener components\n        if (!this.componentManager.hasComponent(ModelBridge.class)) {\n            this.componentManager.registerMockComponent(ModelBridge.class);\n        }\n\n        if (!this.componentManager.hasComponent(ReferenceUpdater.class)) {\n            this.componentManager.registerMockComponent(ReferenceUpdater.class);\n        }\n\n        // Make sure to a have an URLConfiguration component.\n        if (!this.componentManager.hasComponent(URLConfiguration.class)) {\n            URLConfiguration mockUrlConfigComponent =\n                this.componentManager.registerMockComponent(URLConfiguration.class);\n            when(mockUrlConfigComponent.getURLFormatId()).thenReturn(\"standard\");\n        }\n\n        if (!this.componentManager.hasComponent(EntityNameValidationManager.class)) {\n            this.componentManager.registerMockComponent(EntityNameValidationManager.class);\n        }\n        if (!this.componentManager.hasComponent(EntityNameValidationConfiguration.class)) {\n            this.componentManager.registerMockComponent(EntityNameValidationConfiguration.class);\n        }\n\n        boolean supportRevisionStore = this.componentManager.hasComponent(XWikiDocumentFilterUtils.class);\n\n        // Mock getting document revisions using DocumentRevisionProvider.\n        if (supportRevisionStore && !this.componentManager.hasComponent(DocumentRevisionProvider.class, \"database\")) {\n            DocumentRevisionProvider documentRevisionProvider =\n                this.componentManager.registerMockComponent(DocumentRevisionProvider.class, \"database\");\n\n            when(documentRevisionProvider.getRevision(any(DocumentReference.class), anyString()))\n                .then(invocation -> {\n                    DocumentReference reference = invocation.getArgument(0);\n                    String revision = invocation.getArgument(1);\n                    XWikiDocument document = getSpyXWiki().getDocument(reference, this.context);\n\n                    return documentRevisionProvider.getRevision(document, revision);\n                });\n\n            when(documentRevisionProvider.getRevision(anyXWikiDocument(), anyString()))\n                .then(invocation -> {\n                        XWikiDocument baseDocument = invocation.getArgument(0);\n                        String revision = invocation.getArgument(1);\n                        return getMockVersioningStore().loadXWikiDoc(baseDocument, revision, this.context);\n                    }\n                );\n        }\n\n        // Set the default revision provider to the database-one when missing as this covers most cases.\n        if (supportRevisionStore && !this.componentManager.hasComponent(DocumentRevisionProvider.class)) {\n            DocumentRevisionProvider databaseRevisionProvider =\n                this.componentManager.getInstance(DocumentRevisionProvider.class, \"database\");\n            this.componentManager.registerComponent(DocumentRevisionProvider.class, databaseRevisionProvider);\n        }\n\n        getXWikiContext().setLocale(Locale.ENGLISH);\n\n        // XWikiStoreInterface\n\n        when(getMockStore().getTranslationList(anyXWikiDocument(), anyXWikiContext())).then(new Answer<List<String>>()\n        {\n            @Override\n            public List<String> answer(InvocationOnMock invocation) throws Throwable\n            {\n                XWikiDocument document = invocation.getArgument(0);\n\n                List<String> translations = new ArrayList<String>();\n\n                for (XWikiDocument storedDocument : documents.values()) {\n                    Locale storedLocale = storedDocument.getLocale();\n                    if (!storedLocale.equals(Locale.ROOT)\n                        && storedDocument.getDocumentReference().equals(document.getDocumentReference())) {\n                        translations.add(storedLocale.toString());\n                    }\n                }\n\n                return translations;\n            }\n        });\n        when(getMockStore().loadXWikiDoc(anyXWikiDocument(), anyXWikiContext())).then(new Answer<XWikiDocument>()\n        {\n            @Override\n            public XWikiDocument answer(InvocationOnMock invocation) throws Throwable\n            {\n                // The store is based on the contex for the wiki\n                DocumentReference reference = invocation.<XWikiDocument>getArgument(0).getDocumentReferenceWithLocale();\n                XWikiContext xcontext = invocation.getArgument(1);\n                if (!xcontext.getWikiReference().equals(reference.getWikiReference())) {\n                    reference = reference.setWikiReference(xcontext.getWikiReference());\n                }\n\n                XWikiDocument document = documents.get(reference);\n\n                if (document == null) {\n                    document = new XWikiDocument(reference, reference.getLocale());\n                    document.setSyntax(Syntax.PLAIN_1_0);\n                    document.setOriginalDocument(document.clone());\n                }\n\n                return document;\n            }\n        });\n        when(getMockStore().exists(anyXWikiDocument(), anyXWikiContext())).then(new Answer<Boolean>()\n        {\n            @Override\n            public Boolean answer(InvocationOnMock invocation) throws Throwable\n            {\n                // The store is based on the context for the wiki\n                DocumentReference reference = invocation.<XWikiDocument>getArgument(0).getDocumentReferenceWithLocale();\n                XWikiContext xcontext = invocation.getArgument(1);\n                if (!xcontext.getWikiReference().equals(reference.getWikiReference())) {\n                    reference = reference.setWikiReference(xcontext.getWikiReference());\n                }\n\n                return documents.containsKey(reference);\n            }\n        });\n        doAnswer(new Answer<Void>()\n        {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable\n            {\n                // The store is based on the context for the wiki\n                DocumentReference reference = invocation.<XWikiDocument>getArgument(0).getDocumentReferenceWithLocale();\n                XWikiContext xcontext = invocation.getArgument(1);\n                if (!xcontext.getWikiReference().equals(reference.getWikiReference())) {\n                    reference = reference.setWikiReference(xcontext.getWikiReference());\n                }\n\n                documents.remove(reference);\n                documentArchives.remove(reference);\n\n                return null;\n            }\n        }).when(getMockStore()).deleteXWikiDoc(anyXWikiDocument(), anyXWikiContext());\n        doAnswer(new Answer<Void>()\n        {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable\n            {\n                XWikiDocument document = invocation.getArgument(0);\n\n                // The store is based on the context for the wiki\n                DocumentReference reference = document.getDocumentReferenceWithLocale();\n                XWikiContext xcontext = invocation.getArgument(1);\n                if (!xcontext.getWikiReference().equals(reference.getWikiReference())) {\n                    reference = reference.setWikiReference(xcontext.getWikiReference());\n                }\n\n                if (document.isContentDirty() || document.isMetaDataDirty()) {\n                    document.setDate(new Date());\n                    if (document.isContentDirty()) {\n                        document.setContentUpdateDate(new Date());\n                        document.setContentAuthorReference(document.getAuthorReference());\n                    }\n                    document.incrementVersion();\n\n                    document.setContentDirty(false);\n                    document.setMetaDataDirty(false);\n\n                    if (supportRevisionStore) {\n                        // Save the document in the document archive.\n                        getMockVersioningStore().updateXWikiDocArchive(document, true, xcontext);\n                    }\n                }\n                document.setNew(false);\n                document.setStore(getMockStore());\n\n                XWikiDocument savedDocument = document.clone();\n                // Make sure the saved version is not restricted.\n                savedDocument.setRestricted(false);\n\n                documents.put(document.getDocumentReferenceWithLocale(), savedDocument);\n\n\n                // Set the document as it's original document\n                savedDocument.setOriginalDocument(savedDocument.clone());\n\n                return null;\n            }\n        }).when(getMockStore()).saveXWikiDoc(anyXWikiDocument(), anyXWikiContext());\n        when(getMockStore().getLimitSize(any(), any(), any())).thenReturn(255);\n\n        // XWikiVersioningStoreInterface\n\n        when(getMockVersioningStore().getXWikiDocumentArchive(anyXWikiDocument(), anyXWikiContext()))\n            .then(new Answer<XWikiDocumentArchive>()\n            {\n                @Override\n                public XWikiDocumentArchive answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = invocation.getArgument(0);\n\n                    // The store is based on the context for the wiki\n                    DocumentReference reference = document.getDocumentReferenceWithLocale();\n\n                    XWikiDocumentArchive archiveDoc = documentArchives.get(reference);\n\n                    if (archiveDoc == null) {\n                        XWikiContext xcontext = invocation.getArgument(1);\n                        String db = xcontext.getWikiId();\n                        try {\n                            if (reference.getWikiReference().getName() != null) {\n                                xcontext.setWikiId(reference.getWikiReference().getName());\n                            }\n                            archiveDoc = new XWikiDocumentArchive(document.getId());\n                            document.setDocumentArchive(archiveDoc);\n                            documentArchives.put(reference, archiveDoc);\n                        } finally {\n                            xcontext.setWikiId(db);\n                        }\n                    }\n\n                    return archiveDoc;\n                }\n            });\n        when(getMockVersioningStore().getXWikiDocVersions(anyXWikiDocument(), anyXWikiContext()))\n            .then(new Answer<Version[]>()\n            {\n                @Override\n                public Version[] answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocumentArchive archive = getMockVersioningStore()\n                        .getXWikiDocumentArchive(invocation.getArgument(0), invocation.getArgument(1));\n\n                    if (archive == null) {\n                        return new Version[0];\n                    }\n                    Collection<XWikiRCSNodeInfo> nodes = archive.getNodes();\n                    Version[] versions = new Version[nodes.size()];\n                    Iterator<XWikiRCSNodeInfo> it = nodes.iterator();\n                    for (int i = 0; i < versions.length; i++) {\n                        XWikiRCSNodeInfo node = it.next();\n                        versions[versions.length - 1 - i] = node.getId().getVersion();\n                    }\n\n                    return versions;\n                }\n            });\n        doAnswer(new Answer<Void>()\n        {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable\n            {\n                XWikiDocument document = invocation.getArgument(0);\n                XWikiContext xcontext = invocation.getArgument(2);\n\n                XWikiDocumentArchive archiveDoc = getMockVersioningStore().getXWikiDocumentArchive(document, xcontext);\n                archiveDoc.updateArchive(document, document.getAuthor(), document.getDate(), document.getComment(),\n                    document.getRCSVersion(), xcontext);\n                document.setRCSVersion(archiveDoc.getLatestVersion());\n\n                return null;\n            }\n        }).when(getMockVersioningStore()).updateXWikiDocArchive(any(), anyBoolean(), any());\n\n        doAnswer(invocation -> {\n            XWikiDocument baseDocument = invocation.getArgument(0);\n            String revision = invocation.getArgument(1);\n            XWikiContext xContext = invocation.getArgument(2);\n\n            XWikiDocumentArchive archive = getMockVersioningStore().getXWikiDocumentArchive(baseDocument, xContext);\n            Version version = new Version(revision);\n\n            XWikiDocument doc = archive.loadDocument(version, xContext);\n            if (doc == null) {\n                Object[] args = { baseDocument.getDocumentReferenceWithLocale(), version.toString() };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_UNEXISTANT_VERSION,\n                    \"Version {1} does not exist while reading document {0}\", null, args);\n            }\n\n            doc.setStore(baseDocument.getStore());\n\n            // Make sure the attachment of the revision document have the right store\n            for (XWikiAttachment revisionAttachment : doc.getAttachmentList()) {\n                XWikiAttachment attachment = baseDocument.getAttachment(revisionAttachment.getFilename());\n\n                if (attachment != null) {\n                    revisionAttachment.setContentStore(attachment.getContentStore());\n                    revisionAttachment.setArchiveStore(attachment.getArchiveStore());\n                }\n            }\n\n            return doc;\n        }).when(getMockVersioningStore()).loadXWikiDoc(anyXWikiDocument(), anyString(), anyXWikiContext());\n\n        // XWiki\n\n        if (this.mockXWiki) {\n            if (!supportRevisionStore) {\n                doAnswer((Answer<XWikiDocument>) invocation -> {\n                    XWikiDocument doc = invocation.getArgument(0);\n                    String revision = invocation.getArgument(1);\n\n                    if (StringUtils.equals(revision, doc.getVersion())) {\n                        return doc;\n                    }\n\n                    return new XWikiDocument(doc.getDocumentReference());\n                }).when(getSpyXWiki()).getDocument(anyXWikiDocument(), any(), anyXWikiContext());\n            }\n            doAnswer(new Answer<XWikiDocument>()\n            {\n                @Override\n                public XWikiDocument answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = invocation.getArgument(0);\n\n                    String currentWiki = getXWikiContext().getWikiId();\n                    try {\n                        getXWikiContext().setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n                        return getMockStore().loadXWikiDoc(document, getXWikiContext());\n                    } finally {\n                        getXWikiContext().setWikiId(currentWiki);\n                    }\n                }\n            }).when(getSpyXWiki()).getDocument(anyXWikiDocument(), any(XWikiContext.class));\n            doAnswer(new Answer<Void>()\n            {\n                @Override\n                public Void answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = invocation.getArgument(0);\n                    String comment = invocation.getArgument(1);\n                    boolean minorEdit = invocation.getArgument(2);\n                    XWikiContext xcontext = invocation.getArgument(3);\n\n                    boolean isNew = document.isNew();\n\n                    document.setComment(StringUtils.defaultString(comment));\n                    document.setMinorEdit(minorEdit);\n\n                    if (document.isContentDirty() || document.isMetaDataDirty()) {\n                        Date ndate = new Date();\n                        document.setDate(ndate);\n                        if (document.isContentDirty()) {\n                            document.setContentUpdateDate(ndate);\n                            DocumentAuthors authors = document.getAuthors();\n                            authors.setContentAuthor(authors.getEffectiveMetadataAuthor());\n                        }\n                        document.incrementVersion();\n\n                        document.setContentDirty(false);\n                        document.setMetaDataDirty(false);\n\n                        // Save the document in the document archive.\n                        if (supportRevisionStore) {\n                            getMockVersioningStore().updateXWikiDocArchive(document, true, xcontext);\n                        }\n                    }\n                    document.setNew(false);\n                    document.setStore(getMockStore());\n\n                    XWikiDocument previousDocument = documents.get(document.getDocumentReferenceWithLocale());\n\n                    if (previousDocument != null && previousDocument != document) {\n                        for (XWikiAttachment attachment : document.getAttachmentList()) {\n                            if (!attachment.isContentDirty()) {\n                                attachment.setAttachment_content(\n                                    previousDocument.getAttachment(attachment.getFilename()).getAttachment_content());\n                            }\n                        }\n                    }\n\n                    XWikiDocument originalDocument = document.getOriginalDocument();\n                    if (originalDocument == null) {\n                        originalDocument =\n                            spyXWiki.getDocument(document.getDocumentReferenceWithLocale(), getXWikiContext());\n                        document.setOriginalDocument(originalDocument);\n                    }\n\n                    XWikiDocument savedDocument = document.clone();\n                    // Make sure the saved version is not restricted.\n                    savedDocument.setRestricted(false);\n\n                    documents.put(document.getDocumentReferenceWithLocale(), savedDocument);\n\n                    if (isNew) {\n                        if (notifyDocumentCreatedEvent) {\n                            getObservationManager().notify(new DocumentCreatedEvent(document.getDocumentReference()),\n                                document, getXWikiContext());\n                        }\n                    } else {\n                        if (notifyDocumentUpdatedEvent) {\n                            getObservationManager().notify(new DocumentUpdatedEvent(document.getDocumentReference()),\n                                document, getXWikiContext());\n                        }\n                    }\n\n                    // Set the document as it's original document\n                    savedDocument.setOriginalDocument(savedDocument.clone());\n\n                    return null;\n                }\n            }).when(getSpyXWiki()).saveDocument(anyXWikiDocument(), any(String.class), anyBoolean(), anyXWikiContext());\n            doNothing().when(getSpyXWiki()).checkSavingDocument(any(DocumentReference.class), anyXWikiDocument(),\n                any(String.class), anyBoolean(), anyXWikiContext());\n            doAnswer(new Answer<Void>()\n            {\n                @Override\n                public Void answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiDocument document = invocation.getArgument(0);\n\n                    String currentWiki = null;\n\n                    currentWiki = getXWikiContext().getWikiId();\n                    try {\n                        getXWikiContext().setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n                        getMockStore().deleteXWikiDoc(document, getXWikiContext());\n\n                        if (notifyDocumentDeletedEvent) {\n                            getObservationManager().notify(new DocumentDeletedEvent(document.getDocumentReference()),\n                                document, getXWikiContext());\n                        }\n                    } finally {\n                        getXWikiContext().setWikiId(currentWiki);\n                    }\n\n                    return null;\n                }\n            }).when(getSpyXWiki()).deleteDocument(anyXWikiDocument(), any(Boolean.class), anyXWikiContext());\n            doNothing().when(getSpyXWiki()).checkDeletingDocument(any(DocumentReference.class), anyXWikiDocument(),\n                anyXWikiContext());\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    return getSpyXWiki()\n                        .getDocument((DocumentReference) invocation.getArguments()[0], invocation.getArgument(1))\n                        .getXClass();\n                }\n            }).when(getSpyXWiki()).getXClass(any(DocumentReference.class), anyXWikiContext());\n            doAnswer(new Answer<String>()\n            {\n                @Override\n                public String answer(InvocationOnMock invocation) throws Throwable\n                {\n                    return getXWikiContext().getLanguage();\n                }\n            }).when(getSpyXWiki()).getLanguagePreference(anyXWikiContext());\n\n            // Users\n\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiContext xcontext = invocation.getArgument(0);\n\n                    XWikiDocument userDocument = getSpyXWiki().getDocument(\n                        new DocumentReference(USER_CLASS, new WikiReference(xcontext.getWikiId())), xcontext);\n\n                    final BaseClass userClass = userDocument.getXClass();\n\n                    if (userDocument.isNew()) {\n                        userClass.addTextField(\"first_name\", \"First Name\", 30);\n                        userClass.addTextField(\"last_name\", \"Last Name\", 30);\n                        userClass.addEmailField(\"email\", \"e-Mail\", 30);\n                        userClass.addPasswordField(\"password\", \"Password\", 10);\n                        userClass.addBooleanField(\"active\", \"Active\", \"active\");\n                        userClass.addTextAreaField(\"comment\", \"Comment\", 40, 5);\n                        userClass.addTextField(\"avatar\", \"Avatar\", 30);\n                        userClass.addTextField(\"phone\", \"Phone\", 30);\n                        userClass.addTextAreaField(\"address\", \"Address\", 40, 3);\n\n                        getSpyXWiki().saveDocument(userDocument, xcontext);\n                    }\n\n                    return userClass;\n                }\n            }).when(getSpyXWiki()).getUserClass(anyXWikiContext());\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiContext xcontext = invocation.getArgument(0);\n\n                    XWikiDocument groupDocument = getSpyXWiki().getDocument(\n                        new DocumentReference(GROUP_CLASS, new WikiReference(xcontext.getWikiId())), xcontext);\n\n                    final BaseClass groupClass = groupDocument.getXClass();\n\n                    if (groupDocument.isNew()) {\n                        groupClass.addTextField(\"member\", \"Member\", 30);\n\n                        getSpyXWiki().saveDocument(groupDocument, xcontext);\n                    }\n\n                    return groupClass;\n                }\n            }).when(getSpyXWiki()).getGroupClass(anyXWikiContext());\n\n            // RightsClass\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiContext xcontext = invocation.getArgument(0);\n\n                    XWikiDocument rightDocument = getSpyXWiki().getDocument(\n                        new DocumentReference(RIGHTS_CLASS, new WikiReference(xcontext.getWikiId())), xcontext);\n\n                    final BaseClass rightClass = rightDocument.getXClass();\n\n                    if (rightDocument.isNew()) {\n                        rightClass.addTextField(\"groups\", \"groups\", 80);\n                        rightClass.addTextField(\"levels\", \"Access Levels\", 80);\n                        rightClass.addTextField(\"users\", \"Users\", 80);\n                        rightClass.addBooleanField(\"allow\", \"Allow/Deny\", \"allow\");\n                        getSpyXWiki().saveDocument(rightDocument, xcontext);\n                    }\n\n                    return rightClass;\n                }\n            }).when(getSpyXWiki()).getRightsClass(anyXWikiContext());\n\n            // GlobalRightsClass\n            doAnswer(new Answer<BaseClass>()\n            {\n                @Override\n                public BaseClass answer(InvocationOnMock invocation) throws Throwable\n                {\n                    XWikiContext xcontext = invocation.getArgument(0);\n\n                    XWikiDocument globalRightDocument = getSpyXWiki().getDocument(\n                        new DocumentReference(GLOBAL_RIGHTS_CLASS, new WikiReference(xcontext.getWikiId())), xcontext);\n\n                    final BaseClass globalRightClass = globalRightDocument.getXClass();\n\n                    if (globalRightDocument.isNew()) {\n                        globalRightClass.addTextField(\"groups\", \"groups\", 80);\n                        globalRightClass.addTextField(\"levels\", \"Access Levels\", 80);\n                        globalRightClass.addTextField(\"users\", \"Users\", 80);\n                        globalRightClass.addBooleanField(\"allow\", \"Allow/Deny\", \"allow\");\n                        getSpyXWiki().saveDocument(globalRightDocument, xcontext);\n                    }\n\n                    return globalRightClass;\n                }\n            }).when(getSpyXWiki()).getGlobalRightsClass(anyXWikiContext());\n        }\n\n        // DocumentAccessBridge\n        if (!this.componentManager.hasComponent(DocumentAccessBridge.class)) {\n            this.documentAccessBridge = this.componentManager.registerMockComponent(DocumentAccessBridge.class);\n        } else {\n            this.documentAccessBridge = this.componentManager.getInstance(DocumentAccessBridge.class);\n        }\n        if (MockUtil.isMock(this.documentAccessBridge)) {\n            when(this.documentAccessBridge.exists(any(DocumentReference.class))).thenAnswer(new Answer<Boolean>()\n            {\n                @Override\n                public Boolean answer(InvocationOnMock invocation) throws Throwable\n                {\n                    DocumentReference documentReference = invocation.getArgument(0);\n\n                    return spyXWiki.exists(documentReference, context);\n                }\n            });\n        }\n\n        // Query Manager\n        // If there's already a Query Manager registered, use it instead.\n        // This allows, for example, using @ComponentList to use the real Query Manager, in integration tests.\n        if (!this.componentManager.hasComponent(QueryManager.class)) {\n            mockQueryManager();\n        }\n        when(getMockStore().getQueryManager()).then(new Answer<QueryManager>()\n        {\n\n            @Override\n            public QueryManager answer(InvocationOnMock invocation) throws Throwable\n            {\n                return getQueryManager();\n            }\n        });\n\n        // WikiDescriptorManager\n        // If there's already a WikiDescriptorManager registered, use it instead.\n        // This allows, for example, using @ComponentList to use the real WikiDescriptorManager, in integration tests.\n        if (!this.componentManager.hasComponent(WikiDescriptorManager.class)) {\n            this.wikiDescriptorManager = getMocker().registerMockComponent(WikiDescriptorManager.class);\n            when(this.wikiDescriptorManager.getMainWikiId()).then(new Answer<String>()\n            {\n                @Override\n                public String answer(InvocationOnMock invocation) throws Throwable\n                {\n                    return getXWikiContext().getMainXWiki();\n                }\n            });\n            when(this.wikiDescriptorManager.getCurrentWikiId()).then(new Answer<String>()\n            {\n                @Override\n                public String answer(InvocationOnMock invocation) throws Throwable\n                {\n                    return getXWikiContext().getWikiId();\n                }\n            });\n        }\n\n        DefaultParameterizedType userReferenceDocumentReferenceResolverType =\n            new DefaultParameterizedType(null, UserReferenceResolver.class, DocumentReference.class);\n        if (!this.componentManager.hasComponent(userReferenceDocumentReferenceResolverType, \"document\")) {\n            UserReferenceResolver<DocumentReference> userReferenceResolver =\n                getMocker().registerMockComponent(userReferenceDocumentReferenceResolverType, \"document\");\n\n            DefaultParameterizedType userReferenceDocumentReferenceSerializer =\n                new DefaultParameterizedType(null, UserReferenceSerializer.class, DocumentReference.class);\n            UserReferenceSerializer<DocumentReference> documentReferenceUserReferenceSerializer;\n            if (!this.componentManager.hasComponent(userReferenceDocumentReferenceSerializer, \"document\")) {\n                documentReferenceUserReferenceSerializer =\n                    getMocker().registerMockComponent(userReferenceDocumentReferenceSerializer, \"document\");\n            } else {\n                documentReferenceUserReferenceSerializer =\n                    getMocker().getInstance(userReferenceDocumentReferenceSerializer, \"document\");\n            }\n\n            // we ensure that when trying to resolve a DocumentReference to UserReference, then the returned mock\n            // will return the original DocumentReference when resolved back to DocumentReference.\n            when(userReferenceResolver.resolve(any())).then(invocationOnMock -> {\n                UserReference userReference = mock(UserReference.class);\n                when(documentReferenceUserReferenceSerializer.serialize(userReference))\n                    .thenReturn(invocationOnMock.getArgument(0));\n                return userReference;\n            });\n        }\n    }\n\n    protected DocumentReference resolveDocument(String documentName) throws ComponentLookupException\n    {\n        DocumentReferenceResolver<String> resolver =\n            getMocker().getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");\n\n        return resolver.resolve(documentName);\n    }\n\n    public void after() throws Exception\n    {\n        Utils.setComponentManager(null);\n\n        Execution execution = this.componentManager.getInstance(Execution.class);\n        execution.removeContext();\n    }\n\n    public XWikiContext getXWikiContext()\n    {\n        return this.context;\n    }\n\n    /**\n     * @since 7.3RC1\n     */\n    public XWiki getSpyXWiki()\n    {\n        return this.spyXWiki;\n    }\n\n    /**\n     * @deprecated since 7.3RC1, use {@link #getSpyXWiki()} instead\n     */\n    @Deprecated\n    public XWiki getMockXWiki()\n    {\n        return getSpyXWiki();\n    }\n\n    public File getPermanentDirectory()\n    {\n        return this.permanentDirectory;\n    }\n\n    public File getTemporaryDirectory()\n    {\n        return this.temporaryDirectory;\n    }\n\n    /**\n     * @since 15.0RC1\n     * @since 14.10.2\n     */\n    public DocumentAccessBridge getDocumentAccessBridge()\n    {\n        return this.documentAccessBridge;\n    }\n\n    public XWikiRightService getMockRightService()\n    {\n        return this.mockRightService;\n    }\n\n    public XWikiAuthService getMockAuthService()\n    {\n        return this.mockAuthService;\n    }\n\n    public XWikiGroupService getMockGroupService()\n    {\n        return this.mockGroupService;\n    }\n\n    public AuthorizationManager getMockAuthorizationManager()\n    {\n        return this.mockAuthorizationManager;\n    }\n\n    public ContextualAuthorizationManager getMockContextualAuthorizationManager()\n    {\n        return this.mockContextualAuthorizationManager;\n    }\n\n    public XWikiStoreInterface getMockStore()\n    {\n        return this.mockXWikiHibernateStore;\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public XWikiVersioningStoreInterface getMockVersioningStore()\n    {\n        return this.mockVersioningStore;\n    }\n\n    /**\n     * @since 6.0RC1\n     */\n    public ExecutionContext getExecutionContext() throws ComponentLookupException\n    {\n        return this.componentManager.<Execution>getInstance(Execution.class).getContext();\n    }\n\n    /**\n     * @since 8.3M1\n     */\n    public ScriptContext getScriptContext()\n    {\n        return this.scriptContext;\n    }\n\n    /**\n     * @since 6.1M2\n     */\n    public Map<DocumentReference, XWikiDocument> getDocuments()\n    {\n        return this.documents;\n    }\n\n    /**\n     * @since 6.1M2\n     */\n    public ObservationManager getObservationManager() throws ComponentLookupException\n    {\n        return getMocker().getInstance(ObservationManager.class);\n    }\n\n    /**\n     * @since 7.0RC1\n     */\n    public QueryManager getQueryManager() throws ComponentLookupException\n    {\n        if (this.queryManager == null) {\n            this.queryManager = this.componentManager.getInstance(QueryManager.class);\n        }\n\n        return this.queryManager;\n    }\n\n    /**\n     * Force mocking query manager.\n     * \n     * @return 7.2M1\n     */\n    public QueryManager mockQueryManager() throws Exception\n    {\n        this.queryManager = getMocker().registerMockComponent(QueryManager.class);\n\n        return this.queryManager;\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public WikiDescriptorManager getWikiDescriptorManager() throws ComponentLookupException\n    {\n        if (this.wikiDescriptorManager == null) {\n            // Avoid initializing it if not needed\n            if (this.componentManager.hasComponent(WikiDescriptorManager.class)) {\n                this.wikiDescriptorManager = this.componentManager.getInstance(WikiDescriptorManager.class);\n            }\n        }\n\n        return this.wikiDescriptorManager;\n    }\n\n    /**\n     * Return the default configuration, which is also registered for xwikiproperties.\n     * @since 7.1M1\n     */\n    public MemoryConfigurationSource getConfigurationSource()\n    {\n        return this.configurationSource;\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public MemoryConfigurationSource getMockXWikiCfg()\n    {\n        return this.xwikicfgConfigurationSource;\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public MemoryConfigurationSource getMockWikiConfigurationSource()\n    {\n        return this.wikiConfigurationSource;\n    }\n\n    private void initEnvironmentDirectories()\n    {\n        File testDirectory = XWikiTempDirUtil.createTemporaryDirectory();\n\n        this.temporaryDirectory = new File(testDirectory, \"temporary\");\n        this.permanentDirectory = new File(testDirectory, \"permanent-dir\");\n    }\n\n    /**\n     * @since 7.2M2\n     */\n    public void registerMockEnvironment() throws Exception\n    {\n        this.environment = getMocker().registerMockComponent(Environment.class);\n\n        initEnvironmentDirectories();\n\n        when(this.environment.getTemporaryDirectory()).thenReturn(this.temporaryDirectory);\n        when(this.environment.getPermanentDirectory()).thenReturn(this.permanentDirectory);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.internal.macro.context;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.xwiki.bridge.DocumentModelBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.rendering.async.internal.AbstractExecutedContentMacro;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererConfiguration;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.macro.MacroExecutionException;\nimport org.xwiki.rendering.macro.context.ContextMacroParameters;\nimport org.xwiki.rendering.macro.context.TransformationContextMode;\nimport org.xwiki.rendering.macro.descriptor.DefaultContentDescriptor;\nimport org.xwiki.rendering.macro.source.MacroContentWikiSource;\nimport org.xwiki.rendering.macro.source.MacroContentWikiSourceFactory;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.MacroTransformationContext;\nimport org.xwiki.rendering.transformation.TransformationContext;\nimport org.xwiki.rendering.transformation.TransformationManager;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\n/**\n * Execute the macro's content in the context of another document's reference.\n * \n * @version $Id$\n * @since 3.0M1\n */\n@Component\n@Named(\"context\")\n@Singleton\npublic class ContextMacro extends AbstractExecutedContentMacro<ContextMacroParameters>\n{\n    /**\n     * The description of the macro.\n     */\n    private static final String DESCRIPTION = \"Executes content in the context of the passed document\";\n\n    /**\n     * The description of the macro content.\n     */\n    private static final String CONTENT_DESCRIPTION = \"The content to execute\";\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private TransformationManager transformationManager;\n\n    @Inject\n    private MacroContentWikiSourceFactory contentFactory;\n\n    @Inject\n    @Named(\"macro\")\n    private DocumentReferenceResolver<String> macroReferenceResolver;\n\n    /**\n     * Create and initialize the descriptor of the macro.\n     */\n    public ContextMacro()\n    {\n        super(\"Context\", DESCRIPTION, new DefaultContentDescriptor(CONTENT_DESCRIPTION, false, Block.LIST_BLOCK_TYPE),\n            ContextMacroParameters.class);\n\n        setDefaultCategories(Set.of(DEFAULT_CATEGORY_DEVELOPMENT));\n    }\n\n    private void checkAccess(DocumentReference currentAuthor, DocumentReference referencedDocReference)\n        throws MacroExecutionException\n    {\n        // Current author must have view right on the target document to use it as context document\n        try {\n            this.authorizationManager.checkAccess(Right.VIEW, currentAuthor, referencedDocReference);\n        } catch (AccessDeniedException e) {\n            throw new MacroExecutionException(\"Author [\" + currentAuthor\n                + \"] is not allowed to access target document [\" + referencedDocReference + \"]\", e);\n        }\n    }\n\n    @Override\n    public List<Block> execute(ContextMacroParameters parameters, String macroContent,\n        MacroTransformationContext context) throws MacroExecutionException\n    {\n        MetaData metadata;\n        if (parameters.getDocument() != null) {\n            metadata = new MetaData();\n            metadata.addMetaData(MetaData.SOURCE, parameters.getDocument());\n            metadata.addMetaData(MetaData.BASE, parameters.getDocument());\n        } else {\n            metadata = null;\n        }\n        String content = macroContent;\n        Syntax syntax = null;\n        if (parameters.getSource() != null) {\n            MacroContentWikiSource wikiSource = this.contentFactory.getContent(parameters.getSource(), context);\n            syntax = wikiSource.getSyntax();\n            content = wikiSource.getContent();\n        }\n\n        XDOM xdom = this.parser.parse(content, syntax, context, false, metadata, context.isInline());\n\n        if (xdom.getChildren().isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Block> blocks;\n        if (parameters.isRestricted() || parameters.getTransformationContext() == TransformationContextMode.DOCUMENT\n            || parameters.getTransformationContext() == TransformationContextMode.TRANSFORMATIONS) {\n            // Execute the content in the context of the target document\n            blocks = executeContext(xdom, parameters, context);\n        } else {\n            // The content will be executed in the current context\n            blocks = xdom.getChildren();\n        }\n\n        // Keep metadata so that the result stay associated to context properties when inserted in the parent\n        // XDOM\n        return Arrays.asList(new MetaDataBlock(blocks, xdom.getMetaData()));\n    }\n\n    private List<Block> executeContext(XDOM xdom, ContextMacroParameters parameters, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        DocumentReference referencedDocReference;\n        if (parameters.getDocument() != null) {\n            referencedDocReference =\n                this.macroReferenceResolver.resolve(parameters.getDocument(), context.getCurrentMacroBlock());\n            DocumentReference currentAuthor = this.documentAccessBridge.getCurrentAuthorReference();\n\n            // Make sure the author is allowed to use the target document\n            checkAccess(currentAuthor, referencedDocReference);\n        } else {\n            referencedDocReference = null;\n        }\n\n        // Reuse the very generic async rendering framework (even if we don't do async and caching) since it's\n        // taking\n        // care of many other things\n        BlockAsyncRendererConfiguration configuration = createBlockAsyncRendererConfiguration(null, xdom, context);\n        configuration.setAsyncAllowed(false);\n        configuration.setCacheAllowed(false);\n\n        if (parameters.isRestricted()) {\n            configuration.setResricted(true);\n        }\n\n        Map<String, Object> backupObjects = null;\n        try {\n            if (referencedDocReference != null) {\n                backupObjects = new HashMap<>();\n\n                // Switch the context document\n                this.documentAccessBridge.pushDocumentInContext(backupObjects, referencedDocReference);\n\n                // Apply the transformations but with a Transformation Context having the XDOM of the passed\n                // document so that macros execute on the passed document's XDOM (e.g. the TOC macro will generate\n                // the toc for the passed document instead of the current document).\n                DocumentModelBridge referencedDoc =\n                    this.documentAccessBridge.getTranslatedDocumentInstance(referencedDocReference);\n                XDOM referencedXDOM = referencedDoc.getXDOM();\n\n                if (parameters.getTransformationContext() == TransformationContextMode.TRANSFORMATIONS) {\n                    // Get the XDOM from the referenced doc but with Transformations applied so that all macro are\n                    // executed and contribute XDOM elements.\n                    // IMPORTANT: This can be dangerous since it means executing macros, and thus also script macros\n                    // defined in the referenced document. To be used with caution.\n                    TransformationContext referencedTxContext =\n                        new TransformationContext(referencedXDOM, referencedDoc.getSyntax(),\n                            referencedDoc.isRestricted());\n                    this.transformationManager.performTransformations(referencedXDOM, referencedTxContext);\n                }\n\n                // Configure the Transformation Context XDOM depending on the mode asked.\n                configuration.setXDOM(referencedXDOM);\n            }\n\n            // Execute the content\n            Block result = this.executor.execute(configuration);\n\n            return result.getChildren();\n        } catch (Exception e) {\n            throw new MacroExecutionException(\"Failed start the execution of the macro\", e);\n        } finally {\n            if (backupObjects != null) {\n                // Restore the context document\n                this.documentAccessBridge.popDocumentFromContext(backupObjects);\n            }\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.security.authorization.internal;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.internal.XWikiConstants;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\n/**\n * Default implementation of the {@link ContextualAuthorizationManager}.\n *\n * @version $Id$\n * @since 6.1RC1\n */\n@Component\n@Singleton\npublic class DefaultContextualAuthorizationManager implements ContextualAuthorizationManager\n{\n    /**\n     * Rights to be checked for the content author instead of the current user.\n     */\n    private static final Set<Right> CONTENT_AUTHOR_RIGHTS =\n        new HashSet<Right>(Arrays.asList(Right.SCRIPT, Right.PROGRAM));\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private RenderingContext renderingContext;\n\n    @Inject\n    @Named(\"current\")\n    private EntityReferenceResolver<EntityReference> resolver;\n\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    @Override\n    public void checkAccess(Right right) throws AccessDeniedException\n    {\n        if (CONTENT_AUTHOR_RIGHTS.contains(right)) {\n            checkAccess(right, getCurrentUser(right, null), getCurrentAuthorDocumentReference(right));\n        } else {\n            checkAccess(right, getCurrentEntity());\n        }\n    }\n\n    @Override\n    public void checkAccess(Right right, EntityReference entity) throws AccessDeniedException\n    {\n        DocumentReference user = getCurrentUser(right, entity);\n\n        checkAccess(right, user, entity);\n    }\n\n    private void checkAccess(Right right, DocumentReference user, EntityReference entity) throws AccessDeniedException\n    {\n        if (!checkPreAccess(right)) {\n            throw new AccessDeniedException(right, user, entity);\n        }\n\n        this.authorizationManager.checkAccess(right, user, getFullReference(entity));\n    }\n\n    @Override\n    public boolean hasAccess(Right right)\n    {\n        if (CONTENT_AUTHOR_RIGHTS.contains(right)) {\n            return hasAccess(right, getCurrentUser(right, null), getCurrentAuthorDocumentReference(right));\n        }\n\n        return hasAccess(right, getCurrentEntity());\n    }\n\n    @Override\n    public boolean hasAccess(Right right, EntityReference entity)\n    {\n        DocumentReference user = getCurrentUser(right, entity);\n\n        return hasAccess(right, user, entity);\n    }\n\n    private boolean hasAccess(Right right, DocumentReference user, EntityReference entity)\n    {\n        return checkPreAccess(right) && this.authorizationManager.hasAccess(right, user, getFullReference(entity));\n    }\n\n    private EntityReference getFullReference(EntityReference reference)\n    {\n        return reference != null ? this.resolver.resolve(reference, reference.getType()) : null;\n    }\n\n    /**\n     * Check pre-condition for access.\n     *\n     * @param right the right being checked.\n     * @return true if pre-condition are fulfilled.\n     */\n    private boolean checkPreAccess(Right right)\n    {\n        if (CONTENT_AUTHOR_RIGHTS.contains(right)) {\n            XWikiDocument doc = getProgrammingDocument();\n            boolean restricted = this.renderingContext.isRestricted() || (doc != null && doc.isRestricted());\n            return !(restricted || (right == Right.PROGRAM && this.xcontextProvider.get().hasDroppedPermissions()));\n        }\n\n        return true;\n    }\n\n    private DocumentReference getCurrentUser(Right right, EntityReference entity)\n    {\n        // Backward compatibility for the old way of assigning programming right.\n        if (CONTENT_AUTHOR_RIGHTS.contains(right)) {\n            XWikiDocument doc = entity == null ? getProgrammingDocument() : getDocument(entity);\n            if (doc != null) {\n                return getContentAuthor(doc);\n            }\n        }\n\n        return this.xcontextProvider.get().getUserReference();\n    }\n\n    private DocumentReference getCurrentAuthorDocumentReference(Right right)\n    {\n        if (right == Right.PROGRAM) {\n            // Defaults to the main wiki reference.\n            return null;\n        }\n\n        XWikiDocument doc = getProgrammingDocument();\n\n        return doc != null ? doc.getDocumentReference() : null;\n    }\n\n    private XWikiDocument getDocument(EntityReference entity)\n    {\n        if (entity == null) {\n            return null;\n        }\n\n        EntityReference docEntity = entity.extractReference(EntityType.DOCUMENT);\n        if (docEntity == null) {\n            return null;\n        }\n\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        try {\n            return xcontext.getWiki().getDocument(new DocumentReference(docEntity), xcontext);\n        } catch (Exception e) {\n            // Ignored\n        }\n\n        return null;\n    }\n\n    /**\n     * @param doc a document.\n     * @return the content author reference of that document.\n     */\n    private DocumentReference getContentAuthor(XWikiDocument doc)\n    {\n        DocumentReference user = doc.getContentAuthorReference();\n\n        if (user != null && XWikiConstants.GUEST_USER.equals(user.getName())) {\n            // Public users (not logged in) should be passed as null in the new API. It may happen that badly\n            // design code, and poorly written API does not take care, so we prevent security issue here.\n            user = null;\n        }\n\n        return user;\n    }\n\n    /**\n     * Get the current entity from context.\n     *\n     * @return the current sdoc or doc document reference, or the current wiki reference if no doc available.\n     */\n    private EntityReference getCurrentEntity()\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n        XWikiDocument doc = xcontext.getDoc();\n\n        if (doc != null) {\n            return doc.getDocumentReference();\n        }\n\n        return null;\n    }\n\n    /**\n     * Get the document used to test programming right.\n     *\n     * @return the current sdoc or doc document, null if no doc available.\n     */\n    private XWikiDocument getProgrammingDocument()\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        XWikiDocument document = (XWikiDocument) xcontext.get(XWikiDocument.CKEY_SDOC);\n        if (document == null) {\n            document = xcontext.getDoc();\n        }\n\n        return document;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.security.authorization.internal;\n\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\n\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.ArgumentMatchers.same;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Validate {@link DefaultContextualAuthorizationManager}.\n * \n * @version $Id$\n */\n@ReferenceComponentList\n@OldcoreTest\nclass DefaultContextualAuthorizationManagerTest\n{\n    @MockComponent\n    private AuthorizationManager authorizationManager;\n\n    @MockComponent\n    private RenderingContext renderingContext;\n\n    @InjectMockComponents\n    private DefaultContextualAuthorizationManager contextualAuthorizationManager;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    private WikiReference currentWikiReference;\n\n    @BeforeEach\n    public void before() throws Exception\n    {\n        this.currentWikiReference = new WikiReference(\"wiki\");\n        this.oldcore.getXWikiContext().setWikiId(this.currentWikiReference.getName());\n    }\n\n    // Tests\n\n    @Test\n    void checkAccess() throws Exception\n    {\n        LocalDocumentReference localReference = new LocalDocumentReference(\"space\", \"page\");\n\n        this.contextualAuthorizationManager.checkAccess(Right.VIEW, localReference);\n\n        verify(this.authorizationManager).checkAccess(same(Right.VIEW), isNull(),\n            eq(new DocumentReference(localReference, this.currentWikiReference)));\n    }\n\n    @Test\n    void hasAccess()\n    {\n        LocalDocumentReference localReference = new LocalDocumentReference(\"space\", \"page\");\n\n        this.contextualAuthorizationManager.hasAccess(Right.VIEW, localReference);\n\n        verify(this.authorizationManager).hasAccess(same(Right.VIEW), isNull(),\n            eq(new DocumentReference(localReference, this.currentWikiReference)));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"contentRightsSource\")\n    void contentAuthorRightPreAccess(Right right)\n    {\n        when(this.authorizationManager.hasAccess(eq(right), any(), any())).thenReturn(true);\n\n        assertTrue(this.contextualAuthorizationManager.hasAccess(right));\n\n        // Check restricted rendering context (once).\n        when(this.renderingContext.isRestricted()).thenReturn(true).thenReturn(false);\n        assertFalse(this.contextualAuthorizationManager.hasAccess(right));\n\n        XWikiDocument contextDocument = mock(XWikiDocument.class);\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n        assertTrue(this.contextualAuthorizationManager.hasAccess(right));\n        verify(contextDocument).isRestricted();\n        // Check restricted document denies script right.\n        when(contextDocument.isRestricted()).thenReturn(true).thenReturn(false);\n        assertFalse(this.contextualAuthorizationManager.hasAccess(right));\n\n        // Check dropping permissions keeps script but not programming right\n        this.oldcore.getXWikiContext().dropPermissions();\n        if (right == Right.PROGRAM) {\n            assertFalse(this.contextualAuthorizationManager.hasAccess(right));\n        } else {\n            assertTrue(this.contextualAuthorizationManager.hasAccess(right));\n        }\n    }\n\n    static Stream<Right> contentRightsSource()\n    {\n        return Stream.of(Right.SCRIPT, Right.PROGRAM);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.test.ui.po;\n\nimport java.util.List;\n\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.NoSuchElementException;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.FindBy;\n\n/**\n * Represents the actions possible on the History Pane at the bottom of a page.\n * \n * @version $Id$\n * @since 3.2M3\n */\npublic class HistoryPane extends BaseElement\n{\n    @FindBy(id = \"historycontent\")\n    private WebElement pane;\n\n    public boolean isOpened()\n    {\n        return this.pane.isDisplayed();\n    }\n\n    public boolean hasVersionWithSummary(String summary)\n    {\n        List<WebElement> tableEntries = pane.findElements(By.xpath(\".//table/tbody/tr\"));\n        By commentVersionXPath;\n        try {\n            pane.findElement(By.xpath(\".//tr[2]/td/input\"));\n            commentVersionXPath = By.xpath(\".//td[6]\");\n        } catch (NoSuchElementException e) {\n            commentVersionXPath = By.xpath(\".//td[4]\");\n        }\n        for (WebElement tableEntry : tableEntries) {\n            try {\n                WebElement cell = tableEntry.findElement(commentVersionXPath);\n                if (cell.getText().trim().contentEquals(summary)) {\n                    return true;\n                }\n            } catch (NoSuchElementException e) {\n                // Ignore, better luck next time.\n            }\n        }\n        return false;\n    }\n\n    public String getCurrentVersion()\n    {\n        return getCurrentItemInTable(\"td[3]/a\", \"td[1]/a\");\n    }\n\n    public String getCurrentVersionComment()\n    {\n        return getCurrentItemInTable(\"td[6]\", \"td[4]\");\n    }\n\n    public String getCurrentAuthor()\n    {\n        return getCurrentItemInTable(\"td[4]\", \"td[2]\");\n    }\n\n    private String getCurrentItemInTable(String xpathFragment1, String xpathFragment2)\n    {\n        try {\n            // Try to find a radio button. This will mean there are several revisions in the table\n            // and we'll find the version written down in the 3rd column\n            getDriver().findElementWithoutWaiting(this.pane, By.xpath(\".//tr[2]/td/input\"));\n            return getDriver().findElementWithoutWaiting(this.pane,\n                By.xpath(\".//*[contains(@class, 'currentversion')]/\" + xpathFragment1)).getText();\n        } catch (NoSuchElementException e) {\n            // If we couldn't find the radio button, there is less columns displayed and the version will be\n            // in the first column\n            return getDriver().findElementWithoutWaiting(this.pane,\n                By.xpath(\".//*[contains(@class, 'currentversion')]/\" + xpathFragment2)).getText();\n        }\n    }\n\n    /**\n     * IMPORTANT: this method isn't blocking and doesn't wait for the page to be loaded (after the confirmation popup\n     *            has been accepted).\n     */\n    public ViewPage rollbackToVersion(String version)\n    {\n        getDriver().makeConfirmDialogSilent(true);\n\n        pane.findElement(\n            By.xpath(\".//table//tr[contains(., '\" + version\n                + \"')]//td[@class='xwikibuttonlink']/a[contains(.,'Rollback')]\")).click();\n\n        // A new page is loaded after the dialog is accepted, thus we need to wait that it's loaded before returning\n        // as otherwise following actions may be performed on the current page and not on the new page.\n        // TODO: Find a generic way to test for this condition. Right now users of this method need to perform their\n        // own wait.\n\n        return new ViewPage();\n    }\n\n    /**\n     * View the document at the given version.\n     *\n     * @param version the version to view\n     * @return the viewpage\n     * @since 14.10.7\n     * @since 15.2RC1\n     */\n    public ViewPage viewVersion(String version)\n    {\n        this.pane.findElement(By.xpath(\".//table//tr//td[position()=3]/a[contains(., '\" + version + \"')]\")).click();\n\n        return new ViewPage();\n    }\n\n    public HistoryPane deleteVersion(String version)\n    {\n        getDriver().makeConfirmDialogSilent(true);\n\n        pane.findElement(\n            By.xpath(\".//table//tr[contains(., '\" + version\n                + \"')]//td[@class='xwikibuttonlink']/a[contains(.,'Delete')]\")).click();\n\n        return new HistoryPane();\n    }\n\n    /**\n     * Clicks on the 'Show Minor Edits' button.\n     * \n     * @return the new history pane that includes the minor edits\n     */\n    public HistoryPane showMinorEdits()\n    {\n        getDriver().findElementWithoutWaiting(pane, By.name(\"viewMinorVersions\")).click();\n        return new HistoryPane();\n    }\n\n\n    private void selectVersions(String fromVersion, String toVersion)\n    {\n        String versionXPath = \".//input[@name = 'rev%s' and @value = '%s']\";\n        getDriver().findElementWithoutWaiting(pane, By.xpath(String.format(versionXPath, 1, fromVersion))).click();\n        getDriver().findElementWithoutWaiting(pane, By.xpath(String.format(versionXPath, 2, toVersion))).click();\n    }\n\n    public HistoryPane deleteRangeVersions(String fromVersion, String toVersion)\n    {\n        getDriver().makeConfirmDialogSilent(true);\n        this.selectVersions(fromVersion, toVersion);\n        getDriver().findElementWithoutWaiting(pane, By.xpath(\".//input[@name = 'deleteVersions']\")).click();\n\n        return new HistoryPane();\n    }\n\n    /**\n     * Selects the specified document versions and clicks the button to compare them.\n     * \n     * @param fromVersion the from version\n     * @param toVersion the to version\n     * @return the page that shows the differences between the selected pages\n     */\n    public ComparePage compare(String fromVersion, String toVersion)\n    {\n        this.selectVersions(fromVersion, toVersion);\n        getDriver().findElementWithoutWaiting(pane, By.xpath(\".//input[@accesskey = 'c']\")).click();\n        return new ComparePage();\n    }\n}\n", "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n#template('diff_macros.vm')\n##\n## Preamble: which versions are being compared\n##\n\n#if (\"$!previousOrigdocVersion\" != '')\n  #set ($changesLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${previousOrigdocVersion}&rev2=${rev2}\")})\n  #set ($changesTitle = $services.localization.render('core.viewers.diff.previousVersion'))\n  #set ($previousOrigdocLink = \"<a class='changes-arrow' href='$changesLink' title='$changesTitle'>&lt;</a>\")\n#end\n#if (\"$!nextOrigdocVersion\" != '')\n  #set ($changesLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${nextOrigdocVersion}&rev2=${rev2}\")})\n  #set ($changesTitle = $services.localization.render('core.viewers.diff.nextVersion'))\n  #set ($nextOrigdocLink = \"<a class='changes-arrow' href='$changesLink' title='$changesTitle'>&gt;</a>\")\n#end\n#if (\"$!previousNewdocVersion\" != '')\n  #set ($changesLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${rev1}&rev2=${previousNewdocVersion}\")})\n  #set ($changesTitle = $services.localization.render('core.viewers.diff.previousVersion'))\n  #set ($previousNewdocLink = \"<a class='changes-arrow' href='$changesLink' title='$changesTitle'>&lt;</a>\")\n#end\n#if (\"$!nextNewdocVersion\" != '')\n  #set ($changesLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${rev1}&rev2=${nextNewdocVersion}\")})\n  #set ($changesTitle = $services.localization.render('core.viewers.diff.nextVersion'))\n  #set ($nextNewdocLink = \"<a class='changes-arrow' href='$changesLink' title='$changesTitle'>&gt;</a>\")\n#end\n## Display the previous change arrow only if there is a previous version of the original document and there is no extension version\n#if (\"$!previousOrigdocVersion\" != '' && \"$!previousNewdocVersion\" != '')\n  ## Keep the reverse navigation order in case the original document version is greater than the version of the new document\n  #if ($origdoc.RCSVersion.isLessOrEqualThan($newdoc.RCSVersion))\n    #set ($previousLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${previousOrigdocVersion}&rev2=${rev1}\")})\n  #else\n    #set ($previousLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${rev2}&rev2=${previousNewdocVersion}\")})\n  #end\n#end\n## Display the next change arrow only if there is a next version of the new document and there is no extension version\n#if (\"$!nextOrigdocVersion\" != '' && \"$!nextNewdocVersion\" != '')\n  ## Keep the reverse navigation order in case the original document version is greater than the version of the new document\n  #if ($origdoc.RCSVersion.isLessOrEqualThan($newdoc.RCSVersion))\n    #set ($nextLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${rev2}&rev2=${nextNewdocVersion}\")})\n  #else\n    #set ($nextLink = ${xwiki.getURL($tdoc, 'view', \"viewer=changes&rev1=${nextOrigdocVersion}&rev2=${rev1}\")})\n  #end\n#end\n\n#set ($from = {\n  'doc': $origdoc,\n  'version': $rev1,\n  'previousVersionLink': $previousOrigdocLink,\n  'nextVersionLink': $nextOrigdocLink,\n  'previousLink': $previousLink\n})\n#set ($to = {\n  'doc': $newdoc,\n  'version': $rev2,\n  'previousVersionLink': $previousNewdocLink,\n  'nextVersionLink': $nextNewdocLink,\n  'nextLink': $nextLink\n})\n#displayDocumentChangesHeader($from $to)\n\n##\n## Changes\n##\n#set ($includes = $request.getParameterValues('include'))\n#if (!$includes)\n  #set ($includes = ['rawChanges'])\n#end\n<div class=\"changes-body\">\n  <div class=\"changes-body-header\">\n    <div class=\"row\">\n      <div class=\"col-xs-12 col-sm-6\">\n        <ul class=\"nav nav-pills\" role=\"tablist\">\n          <li role=\"presentation\" class=\"active\">\n            <a href=\"#rawChanges\" aria-controls=\"rawChanges\" role=\"tab\" data-toggle=\"pill\" data-hint=\"raw\">\n              $escapetool.xml($services.localization.render('web.history.changes.raw'))\n            </a>\n          </li>\n          <li role=\"presentation\">\n            <a href=\"#renderedChanges\" aria-controls=\"renderedChanges\" role=\"tab\" data-toggle=\"pill\" data-hint=\"rendered\">\n              $escapetool.xml($services.localization.render('web.history.changes.rendered'))\n            </a>\n          </li>\n        </ul>\n      </div>\n      <div class=\"col-xs-12 col-md-6\">\n        <div class=\"changes-actions raw active\"></div>\n        <div class=\"changes-actions rendered\">\n          <a href=\"#toggleRenderedDiffContext\" class=\"html-diff-context-toggle html-diff-context-toggle-show hidden\">\n            <span class=\"html-diff-context-show\">\n              $services.icon.renderHTML('plus-square')\n              $escapetool.xml($services.localization.render('web.history.changes.showContext'))\n            </span>\n            <span class=\"html-diff-context-hide\">\n              $services.icon.renderHTML('minus-square')\n              $escapetool.xml($services.localization.render('web.history.changes.hideContext'))\n            </span>\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"tab-content\">\n    <div role=\"tabpanel\" class=\"tab-pane active\" id=\"rawChanges\">\n      #if ($includes.contains('rawChanges'))\n        #displayDocumentRawChanges($origdoc $newdoc)\n      #end\n    </div>\n    <div role=\"tabpanel\" class=\"tab-pane html-diff\" id=\"renderedChanges\">\n      #if ($includes.contains('renderedChanges'))\n        #set ($htmlDiff = $services.diff.html.unified($origdoc.renderedContent, $newdoc.renderedContent))\n        #if ($htmlDiff == '')\n          <div class=\"infomessage\">\n            $escapetool.xml($services.localization.render('web.history.changes.noChanges'))\n          </div>\n        #elseif (\"$!htmlDiff\" == '')\n          <div class=\"errormessage\">\n            $escapetool.xml($services.localization.render('web.history.changes.failedToCompute'))\n          </div>\n        #else\n          #if (($origdoc.isRestricted() || $newdoc.isRestricted()) && ($services.user.allProperties.type == 'ADVANCED'\n            || $stringtool.contains($htmlDiff, 'xwikirenderingerror')))\n            #warning($escapetool.xml($services.localization.render('web.history.changes.restrictedInfo')))\n          #end\n          $htmlDiff\n        #end\n      #end\n    </div>\n  </div>\n</div>\n"], "filenames": ["xwiki-platform-core/xwiki-platform-bridge/src/main/java/org/xwiki/bridge/DocumentModelBridge.java", "xwiki-platform-core/xwiki-platform-display/xwiki-platform-display-api/src/main/java/org/xwiki/display/internal/AbstractDocumentTitleDisplayer.java", "xwiki-platform-core/xwiki-platform-display/xwiki-platform-display-api/src/main/java/org/xwiki/display/internal/DocumentContentAsyncRenderer.java", "xwiki-platform-core/xwiki-platform-display/xwiki-platform-display-api/src/main/java/org/xwiki/display/internal/DocumentTitleDisplayer.java", "xwiki-platform-core/xwiki-platform-flamingo/xwiki-platform-flamingo-skin/xwiki-platform-flamingo-skin-resources/src/main/resources/flamingo/contentheader.vm", "xwiki-platform-core/xwiki-platform-flamingo/xwiki-platform-flamingo-skin/xwiki-platform-flamingo-skin-test/xwiki-platform-flamingo-skin-test-docker/src/test/it/org/xwiki/flamingo/test/docker/RecycleBinIT.java", "xwiki-platform-core/xwiki-platform-flamingo/xwiki-platform-flamingo-skin/xwiki-platform-flamingo-skin-test/xwiki-platform-flamingo-skin-test-docker/src/test/it/org/xwiki/flamingo/test/docker/VersionIT.java", "xwiki-platform-core/xwiki-platform-legacy/xwiki-platform-legacy-oldcore/src/main/aspect/com/xpn/xwiki/doc/XWikiDocumentCompatibilityAspect.aj", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/api/Document.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDocument.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/internal/filter/output/XWikiDocumentOutputFilterStream.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/store/XWikiHibernateStore.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/resources/ApplicationResources.properties", "xwiki-platform-core/xwiki-platform-oldcore/src/test/java/com/xpn/xwiki/doc/XWikiDocumentMockitoTest.java", "xwiki-platform-core/xwiki-platform-oldcore/src/test/java/com/xpn/xwiki/doc/XWikiDocumentRenderingTest.java", "xwiki-platform-core/xwiki-platform-oldcore/src/test/java/com/xpn/xwiki/test/MockitoOldcore.java", "xwiki-platform-core/xwiki-platform-rendering/xwiki-platform-rendering-macros/xwiki-platform-rendering-macro-context/src/main/java/org/xwiki/rendering/internal/macro/context/ContextMacro.java", "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authorization/xwiki-platform-security-authorization-bridge/src/main/java/org/xwiki/security/authorization/internal/DefaultContextualAuthorizationManager.java", "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authorization/xwiki-platform-security-authorization-bridge/src/test/java/org/xwiki/security/authorization/internal/DefaultContextualAuthorizationManagerTest.java", "xwiki-platform-core/xwiki-platform-test/xwiki-platform-test-ui/src/main/java/org/xwiki/test/ui/po/HistoryPane.java", "xwiki-platform-core/xwiki-platform-web/xwiki-platform-web-templates/src/main/resources/templates/changesdoc.vm"], "buggy_code_start_loc": [181, 176, 79, 80, 53, 41, 35, 285, 3202, 627, 235, 716, 742, 1585, 23, 631, 202, 139, 21, 118, 138], "buggy_code_end_loc": [181, 179, 79, 81, 53, 286, 240, 286, 3202, 9518, 235, 716, 1687, 1585, 350, 834, 203, 144, 91, 118, 138], "fixing_code_start_loc": [182, 176, 80, 80, 54, 42, 36, 285, 3203, 628, 236, 717, 743, 1586, 24, 632, 202, 139, 22, 119, 139], "fixing_code_end_loc": [193, 181, 85, 81, 61, 319, 289, 287, 3214, 9563, 240, 720, 1692, 1589, 426, 840, 204, 142, 140, 134, 143], "type": "CWE-459", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. When an XWiki installation is upgraded and that upgrade contains a fix for a bug in a document, just a new version of that document is added. In some cases, it's still possible to exploit the vulnerability that was fixed in the new version. The severity of this depends on the fixed vulnerability, for the purpose of this advisory take CVE-2022-36100/GHSA-2g5c-228j-p52x as example - it is easily exploitable with just view rights and critical. When XWiki is upgraded from a version before the fix for it (e.g., 14.3) to a version including the fix (e.g., 14.4), the vulnerability can still be reproduced by adding `rev=1.1` to the URL used in the reproduction steps so remote code execution is possible even after upgrading. Therefore, this affects the confidentiality, integrity and availability of the whole XWiki installation. This vulnerability also affects manually added script macros that contained security vulnerabilities that were later fixed by changing the script macro without deleting the versions with the security vulnerability from the history. This vulnerability doesn't affect freshly installed versions of XWiki. Further, this vulnerability doesn't affect content that is only loaded from the current version of a document like the code of wiki macros or UI extensions. This vulnerability has been patched in XWiki 14.10.7 and 15.2RC1 by forcing old revisions to be executed in a restricted mode that disables all script macros. As a workaround, admins can manually delete old revisions of affected documents. A script could be used to identify all installed documents and delete the history for them. However, also manually added and later corrected code may be affected by this vulnerability so it is easy to miss documents.", "other": {"cve": {"id": "CVE-2023-36468", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-29T21:15:09.703", "lastModified": "2023-07-10T14:02:57.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. When an XWiki installation is upgraded and that upgrade contains a fix for a bug in a document, just a new version of that document is added. In some cases, it's still possible to exploit the vulnerability that was fixed in the new version. The severity of this depends on the fixed vulnerability, for the purpose of this advisory take CVE-2022-36100/GHSA-2g5c-228j-p52x as example - it is easily exploitable with just view rights and critical. When XWiki is upgraded from a version before the fix for it (e.g., 14.3) to a version including the fix (e.g., 14.4), the vulnerability can still be reproduced by adding `rev=1.1` to the URL used in the reproduction steps so remote code execution is possible even after upgrading. Therefore, this affects the confidentiality, integrity and availability of the whole XWiki installation. This vulnerability also affects manually added script macros that contained security vulnerabilities that were later fixed by changing the script macro without deleting the versions with the security vulnerability from the history. This vulnerability doesn't affect freshly installed versions of XWiki. Further, this vulnerability doesn't affect content that is only loaded from the current version of a document like the code of wiki macros or UI extensions. This vulnerability has been patched in XWiki 14.10.7 and 15.2RC1 by forcing old revisions to be executed in a restricted mode that disables all script macros. As a workaround, admins can manually delete old revisions of affected documents. A script could be used to identify all installed documents and delete the history for them. However, also manually added and later corrected code may be affected by this vulnerability so it is easy to miss documents."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-459"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-459"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0", "versionEndExcluding": "14.10.7", "matchCriteriaId": "B8D99155-5444-4CA2-A1C1-0CF39D27B41C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:15.0:-:*:*:*:*:*:*", "matchCriteriaId": "99329652-2907-4903-AAB1-1038F225C020"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:15.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "88E41345-F81E-401A-BD67-66AF4B3925D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:15.1:-:*:*:*:*:*:*", "matchCriteriaId": "5D121BDB-D7C5-4B79-A904-3C4A76F38E6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:15.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "67322CAC-1F17-4453-BC7F-4262E436E307"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/15a6f845d8206b0ae97f37aa092ca43d4f9d6e59", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-2g5c-228j-p52x", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-8q9q-r9v2-644m", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-20594", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/15a6f845d8206b0ae97f37aa092ca43d4f9d6e59"}}