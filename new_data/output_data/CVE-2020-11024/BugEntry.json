{"buggy_code": ["//\n//  PairManager.m\n//  Moonlight\n//\n//  Created by Diego Waxemberg on 10/19/14.\n//  Copyright (c) 2014 Moonlight Stream. All rights reserved.\n//\n\n#import \"PairManager.h\"\n#import \"CryptoManager.h\"\n#import \"Utils.h\"\n#import \"HttpResponse.h\"\n#import \"HttpRequest.h\"\n#import \"ServerInfoResponse.h\"\n\n#include <dispatch/dispatch.h>\n\n@implementation PairManager {\n    HttpManager* _httpManager;\n    NSData* _clientCert;\n    id<PairCallback> _callback;\n}\n\n- (id) initWithManager:(HttpManager*)httpManager clientCert:(NSData*)clientCert callback:(id<PairCallback>)callback {\n    self = [super init];\n    _httpManager = httpManager;\n    _clientCert = clientCert;\n    _callback = callback;\n    return self;\n}\n\n- (void) main {\n    // We have to call startPairing before calling any other _callback functions\n    NSString* PIN = [self generatePIN];\n    [_callback startPairing:PIN];\n    \n    ServerInfoResponse* serverInfoResp = [[ServerInfoResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:serverInfoResp withUrlRequest:[_httpManager newServerInfoRequest:false]\n                                               fallbackError:401 fallbackRequest:[_httpManager newHttpServerInfoRequest]]];\n    if ([serverInfoResp isStatusOk]) {\n        if ([[serverInfoResp getStringTag:@\"state\"] hasSuffix:@\"_SERVER_BUSY\"]) {\n            [_callback pairFailed:@\"You cannot pair while a previous session is still running on the host PC. Quit any running games or reboot the host PC, then try pairing again.\"];\n        } else if (![[serverInfoResp getStringTag:@\"PairStatus\"] isEqual:@\"1\"]) {\n            NSString* appversion = [serverInfoResp getStringTag:@\"appversion\"];\n            if (appversion == nil) {\n                [_callback pairFailed:@\"Missing XML element\"];\n                return;\n            }            \n            [self initiatePairWithPin:PIN forServerMajorVersion:[[appversion substringToIndex:1] intValue]];\n        } else {\n            [_callback alreadyPaired];\n        }\n    }\n    else {\n        [_callback pairFailed:serverInfoResp.statusMessage];\n    }\n}\n\n- (void) finishPairing:(UIBackgroundTaskIdentifier)bgId\n           forResponse:(HttpResponse*)resp\n     withFallbackError:(NSString*)errorMsg {\n    [_httpManager executeRequestSynchronously:[HttpRequest requestWithUrlRequest:[_httpManager newUnpairRequest]]];\n    \n    if (bgId != UIBackgroundTaskInvalid) {\n        [[UIApplication sharedApplication] endBackgroundTask:bgId];\n    }\n    \n    if (![resp isStatusOk]) {\n        // Use the response error if the request failed\n        errorMsg = resp.statusMessage;\n    }\n    \n    [_callback pairFailed:errorMsg];\n}\n\n- (void) finishPairing:(UIBackgroundTaskIdentifier)bgId withSuccess:(NSData*)derCertBytes {\n    if (bgId != UIBackgroundTaskInvalid) {\n        [[UIApplication sharedApplication] endBackgroundTask:bgId];\n    }\n    \n    [_callback pairSuccessful:derCertBytes];\n}\n\n// All codepaths must call finishPairing exactly once before returning!\n- (void) initiatePairWithPin:(NSString*)PIN forServerMajorVersion:(int)serverMajorVersion {\n    Log(LOG_I, @\"Pairing with generation %d server\", serverMajorVersion);\n    \n    // Start a background task to help prevent the app from being killed\n    // while pairing is in progress.\n    UIBackgroundTaskIdentifier bgId = [[UIApplication sharedApplication] beginBackgroundTaskWithName:@\"Pairing PC\" expirationHandler:^{\n        Log(LOG_W, @\"Background pairing time has expired!\");\n    }];\n    \n    NSData* salt = [self saltPIN:PIN];\n    Log(LOG_I, @\"PIN: %@, saltedPIN: %@\", PIN, salt);\n    \n    HttpResponse* pairResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:pairResp withUrlRequest:[_httpManager newPairRequest:salt clientCert:_clientCert]]];\n    if (![self verifyResponseStatus:pairResp]) {\n        [self finishPairing:bgId forResponse:pairResp withFallbackError:@\"Pairing was declined by the target.\"];\n        return;\n    }\n    \n    NSString* plainCert = [pairResp getStringTag:@\"plaincert\"];\n    if ([plainCert length] == 0) {\n        [self finishPairing:bgId forResponse:pairResp withFallbackError:@\"Another pairing attempt is already in progress.\"];\n        return;\n    }\n    \n    // Pin the cert for TLS usage on this host\n    NSData* derCertBytes = [CryptoManager pemToDer:[Utils hexToBytes:plainCert]];\n    [_httpManager setServerCert:derCertBytes];\n    \n    CryptoManager* cryptoMan = [[CryptoManager alloc] init];\n    NSData* aesKey;\n    \n    // Gen 7 servers use SHA256 to get the key\n    int hashLength;\n    if (serverMajorVersion >= 7) {\n        aesKey = [cryptoMan createAESKeyFromSaltSHA256:salt];\n        hashLength = 32;\n    }\n    else {\n        aesKey = [cryptoMan createAESKeyFromSaltSHA1:salt];\n        hashLength = 20;\n    }\n    \n    NSData* randomChallenge = [Utils randomBytes:16];\n    NSData* encryptedChallenge = [cryptoMan aesEncrypt:randomChallenge withKey:aesKey];\n    \n    HttpResponse* challengeResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:challengeResp withUrlRequest:[_httpManager newChallengeRequest:encryptedChallenge]]];\n    if (![self verifyResponseStatus:challengeResp]) {\n        [self finishPairing:bgId forResponse:challengeResp withFallbackError:@\"Pairing stage #2 failed\"];\n        return;\n    }\n    \n    NSData* encServerChallengeResp = [Utils hexToBytes:[challengeResp getStringTag:@\"challengeresponse\"]];\n    NSData* decServerChallengeResp = [cryptoMan aesDecrypt:encServerChallengeResp withKey:aesKey];\n    \n    NSData* serverResponse = [decServerChallengeResp subdataWithRange:NSMakeRange(0, hashLength)];\n    NSData* serverChallenge = [decServerChallengeResp subdataWithRange:NSMakeRange(hashLength, 16)];\n    \n    NSData* clientSecret = [Utils randomBytes:16];\n    NSData* challengeRespHashInput = [self concatData:[self concatData:serverChallenge with:[CryptoManager getSignatureFromCert:_clientCert]] with:clientSecret];\n    NSData* challengeRespHash;\n    if (serverMajorVersion >= 7) {\n        challengeRespHash = [cryptoMan SHA256HashData: challengeRespHashInput];\n    }\n    else {\n        challengeRespHash = [cryptoMan SHA1HashData: challengeRespHashInput];\n    }\n    NSData* challengeRespEncrypted = [cryptoMan aesEncrypt:challengeRespHash withKey:aesKey];\n    \n    HttpResponse* secretResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:secretResp withUrlRequest:[_httpManager newChallengeRespRequest:challengeRespEncrypted]]];\n    if (![self verifyResponseStatus:secretResp]) {\n        [self finishPairing:bgId forResponse:secretResp withFallbackError:@\"Pairing stage #3 failed\"];\n        return;\n    }\n    \n    NSData* serverSecretResp = [Utils hexToBytes:[secretResp getStringTag:@\"pairingsecret\"]];\n    NSData* serverSecret = [serverSecretResp subdataWithRange:NSMakeRange(0, 16)];\n    NSData* serverSignature = [serverSecretResp subdataWithRange:NSMakeRange(16, 256)];\n    \n    if (![cryptoMan verifySignature:serverSecret withSignature:serverSignature andCert:[Utils hexToBytes:plainCert]]) {\n        [self finishPairing:bgId forResponse:secretResp withFallbackError:@\"Server certificate invalid\"];\n        return;\n    }\n    \n    NSData* serverChallengeRespHashInput = [self concatData:[self concatData:randomChallenge with:[CryptoManager getSignatureFromCert:[Utils hexToBytes:plainCert]]] with:serverSecret];\n    NSData* serverChallengeRespHash;\n    if (serverMajorVersion >= 7) {\n        serverChallengeRespHash = [cryptoMan SHA256HashData: serverChallengeRespHashInput];\n    }\n    else {\n        serverChallengeRespHash = [cryptoMan SHA1HashData: serverChallengeRespHashInput];\n    }\n    if (![serverChallengeRespHash isEqual:serverResponse]) {\n        [self finishPairing:bgId forResponse:secretResp withFallbackError:@\"Incorrect PIN\"];\n        return;\n    }\n    \n    NSData* clientPairingSecret = [self concatData:clientSecret with:[cryptoMan signData:clientSecret withKey:[CryptoManager readKeyFromFile]]];\n    HttpResponse* clientSecretResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:clientSecretResp withUrlRequest:[_httpManager newClientSecretRespRequest:[Utils bytesToHex:clientPairingSecret]]]];\n    if (![self verifyResponseStatus:clientSecretResp]) {\n        [self finishPairing:bgId forResponse:clientSecretResp withFallbackError:@\"Pairing stage #4 failed\"];\n        return;\n    }\n    \n    HttpResponse* clientPairChallengeResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:clientPairChallengeResp withUrlRequest:[_httpManager newPairChallenge]]];\n    if (![self verifyResponseStatus:clientPairChallengeResp]) {\n        [self finishPairing:bgId forResponse:clientPairChallengeResp withFallbackError:@\"Pairing stage #5 failed\"];\n        return;\n    }\n    \n    [self finishPairing:bgId withSuccess:derCertBytes];\n}\n\n// Caller calls finishPairing for us on failure\n- (BOOL) verifyResponseStatus:(HttpResponse*)resp {\n    if (![resp isStatusOk]) {\n        return false;\n    } else {\n        NSInteger pairedStatus;\n        \n        if (![resp getIntTag:@\"paired\" value:&pairedStatus]) {\n            return false;\n        }\n        \n        return pairedStatus == 1;\n    }\n}\n\n- (NSData*) concatData:(NSData*)data with:(NSData*)moreData {\n    NSMutableData* concatData = [[NSMutableData alloc] initWithData:data];\n    [concatData appendData:moreData];\n    return concatData;\n}\n\n- (NSString*) generatePIN {\n    NSString* PIN = [NSString stringWithFormat:@\"%d%d%d%d\",\n                     arc4random() % 10, arc4random() % 10,\n                     arc4random() % 10, arc4random() % 10];\n    return PIN;\n}\n\n- (NSData*) saltPIN:(NSString*)PIN {\n    NSMutableData* saltedPIN = [[NSMutableData alloc] initWithCapacity:20];\n    [saltedPIN appendData:[Utils randomBytes:16]];\n    [saltedPIN appendBytes:[PIN UTF8String] length:4];\n    return saltedPIN;\n}\n\n@end\n"], "fixing_code": ["//\n//  PairManager.m\n//  Moonlight\n//\n//  Created by Diego Waxemberg on 10/19/14.\n//  Copyright (c) 2014 Moonlight Stream. All rights reserved.\n//\n\n#import \"PairManager.h\"\n#import \"CryptoManager.h\"\n#import \"Utils.h\"\n#import \"HttpResponse.h\"\n#import \"HttpRequest.h\"\n#import \"ServerInfoResponse.h\"\n\n#include <dispatch/dispatch.h>\n\n@implementation PairManager {\n    HttpManager* _httpManager;\n    NSData* _clientCert;\n    id<PairCallback> _callback;\n}\n\n- (id) initWithManager:(HttpManager*)httpManager clientCert:(NSData*)clientCert callback:(id<PairCallback>)callback {\n    self = [super init];\n    _httpManager = httpManager;\n    _clientCert = clientCert;\n    _callback = callback;\n    return self;\n}\n\n- (void) main {\n    // We have to call startPairing before calling any other _callback functions\n    NSString* PIN = [self generatePIN];\n    [_callback startPairing:PIN];\n    \n    ServerInfoResponse* serverInfoResp = [[ServerInfoResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:serverInfoResp withUrlRequest:[_httpManager newServerInfoRequest:false]\n                                               fallbackError:401 fallbackRequest:[_httpManager newHttpServerInfoRequest]]];\n    if ([serverInfoResp isStatusOk]) {\n        if ([[serverInfoResp getStringTag:@\"state\"] hasSuffix:@\"_SERVER_BUSY\"]) {\n            [_callback pairFailed:@\"You cannot pair while a previous session is still running on the host PC. Quit any running games or reboot the host PC, then try pairing again.\"];\n        } else if (![[serverInfoResp getStringTag:@\"PairStatus\"] isEqual:@\"1\"]) {\n            NSString* appversion = [serverInfoResp getStringTag:@\"appversion\"];\n            if (appversion == nil) {\n                [_callback pairFailed:@\"Missing XML element\"];\n                return;\n            }            \n            [self initiatePairWithPin:PIN forServerMajorVersion:[[appversion substringToIndex:1] intValue]];\n        } else {\n            [_callback alreadyPaired];\n        }\n    }\n    else {\n        [_callback pairFailed:serverInfoResp.statusMessage];\n    }\n}\n\n- (void) finishPairing:(UIBackgroundTaskIdentifier)bgId\n           forResponse:(HttpResponse*)resp\n     withFallbackError:(NSString*)errorMsg {\n    [_httpManager executeRequestSynchronously:[HttpRequest requestWithUrlRequest:[_httpManager newUnpairRequest]]];\n    \n    if (bgId != UIBackgroundTaskInvalid) {\n        [[UIApplication sharedApplication] endBackgroundTask:bgId];\n    }\n    \n    if (![resp isStatusOk]) {\n        // Use the response error if the request failed\n        errorMsg = resp.statusMessage;\n    }\n    \n    [_callback pairFailed:errorMsg];\n}\n\n- (void) finishPairing:(UIBackgroundTaskIdentifier)bgId withSuccess:(NSData*)derCertBytes {\n    if (bgId != UIBackgroundTaskInvalid) {\n        [[UIApplication sharedApplication] endBackgroundTask:bgId];\n    }\n    \n    [_callback pairSuccessful:derCertBytes];\n}\n\n// All codepaths must call finishPairing exactly once before returning!\n- (void) initiatePairWithPin:(NSString*)PIN forServerMajorVersion:(int)serverMajorVersion {\n    Log(LOG_I, @\"Pairing with generation %d server\", serverMajorVersion);\n    \n    // Start a background task to help prevent the app from being killed\n    // while pairing is in progress.\n    UIBackgroundTaskIdentifier bgId = [[UIApplication sharedApplication] beginBackgroundTaskWithName:@\"Pairing PC\" expirationHandler:^{\n        Log(LOG_W, @\"Background pairing time has expired!\");\n    }];\n    \n    NSData* salt = [Utils randomBytes:16];\n    NSData* saltedPIN = [self concatData:salt with:[PIN dataUsingEncoding:NSUTF8StringEncoding]];\n\n    Log(LOG_I, @\"PIN: %@, salt %@\", PIN, salt);\n    \n    HttpResponse* pairResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:pairResp withUrlRequest:[_httpManager newPairRequest:salt clientCert:_clientCert]]];\n    if (![self verifyResponseStatus:pairResp]) {\n        [self finishPairing:bgId forResponse:pairResp withFallbackError:@\"Pairing was declined by the target.\"];\n        return;\n    }\n    \n    NSString* plainCert = [pairResp getStringTag:@\"plaincert\"];\n    if ([plainCert length] == 0) {\n        [self finishPairing:bgId forResponse:pairResp withFallbackError:@\"Another pairing attempt is already in progress.\"];\n        return;\n    }\n    \n    // Pin the cert for TLS usage on this host\n    NSData* derCertBytes = [CryptoManager pemToDer:[Utils hexToBytes:plainCert]];\n    [_httpManager setServerCert:derCertBytes];\n    \n    CryptoManager* cryptoMan = [[CryptoManager alloc] init];\n    NSData* aesKey;\n    \n    // Gen 7 servers use SHA256 to get the key\n    int hashLength;\n    if (serverMajorVersion >= 7) {\n        aesKey = [cryptoMan createAESKeyFromSaltSHA256:saltedPIN];\n        hashLength = 32;\n    }\n    else {\n        aesKey = [cryptoMan createAESKeyFromSaltSHA1:saltedPIN];\n        hashLength = 20;\n    }\n    \n    NSData* randomChallenge = [Utils randomBytes:16];\n    NSData* encryptedChallenge = [cryptoMan aesEncrypt:randomChallenge withKey:aesKey];\n    \n    HttpResponse* challengeResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:challengeResp withUrlRequest:[_httpManager newChallengeRequest:encryptedChallenge]]];\n    if (![self verifyResponseStatus:challengeResp]) {\n        [self finishPairing:bgId forResponse:challengeResp withFallbackError:@\"Pairing stage #2 failed\"];\n        return;\n    }\n    \n    NSData* encServerChallengeResp = [Utils hexToBytes:[challengeResp getStringTag:@\"challengeresponse\"]];\n    NSData* decServerChallengeResp = [cryptoMan aesDecrypt:encServerChallengeResp withKey:aesKey];\n    \n    NSData* serverResponse = [decServerChallengeResp subdataWithRange:NSMakeRange(0, hashLength)];\n    NSData* serverChallenge = [decServerChallengeResp subdataWithRange:NSMakeRange(hashLength, 16)];\n    \n    NSData* clientSecret = [Utils randomBytes:16];\n    NSData* challengeRespHashInput = [self concatData:[self concatData:serverChallenge with:[CryptoManager getSignatureFromCert:_clientCert]] with:clientSecret];\n    NSData* challengeRespHash;\n    if (serverMajorVersion >= 7) {\n        challengeRespHash = [cryptoMan SHA256HashData: challengeRespHashInput];\n    }\n    else {\n        challengeRespHash = [cryptoMan SHA1HashData: challengeRespHashInput];\n    }\n    NSData* challengeRespEncrypted = [cryptoMan aesEncrypt:challengeRespHash withKey:aesKey];\n    \n    HttpResponse* secretResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:secretResp withUrlRequest:[_httpManager newChallengeRespRequest:challengeRespEncrypted]]];\n    if (![self verifyResponseStatus:secretResp]) {\n        [self finishPairing:bgId forResponse:secretResp withFallbackError:@\"Pairing stage #3 failed\"];\n        return;\n    }\n    \n    NSData* serverSecretResp = [Utils hexToBytes:[secretResp getStringTag:@\"pairingsecret\"]];\n    NSData* serverSecret = [serverSecretResp subdataWithRange:NSMakeRange(0, 16)];\n    NSData* serverSignature = [serverSecretResp subdataWithRange:NSMakeRange(16, 256)];\n    \n    if (![cryptoMan verifySignature:serverSecret withSignature:serverSignature andCert:[Utils hexToBytes:plainCert]]) {\n        [self finishPairing:bgId forResponse:secretResp withFallbackError:@\"Server certificate invalid\"];\n        return;\n    }\n    \n    NSData* serverChallengeRespHashInput = [self concatData:[self concatData:randomChallenge with:[CryptoManager getSignatureFromCert:[Utils hexToBytes:plainCert]]] with:serverSecret];\n    NSData* serverChallengeRespHash;\n    if (serverMajorVersion >= 7) {\n        serverChallengeRespHash = [cryptoMan SHA256HashData: serverChallengeRespHashInput];\n    }\n    else {\n        serverChallengeRespHash = [cryptoMan SHA1HashData: serverChallengeRespHashInput];\n    }\n    if (![serverChallengeRespHash isEqual:serverResponse]) {\n        [self finishPairing:bgId forResponse:secretResp withFallbackError:@\"Incorrect PIN\"];\n        return;\n    }\n    \n    NSData* clientPairingSecret = [self concatData:clientSecret with:[cryptoMan signData:clientSecret withKey:[CryptoManager readKeyFromFile]]];\n    HttpResponse* clientSecretResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:clientSecretResp withUrlRequest:[_httpManager newClientSecretRespRequest:[Utils bytesToHex:clientPairingSecret]]]];\n    if (![self verifyResponseStatus:clientSecretResp]) {\n        [self finishPairing:bgId forResponse:clientSecretResp withFallbackError:@\"Pairing stage #4 failed\"];\n        return;\n    }\n    \n    HttpResponse* clientPairChallengeResp = [[HttpResponse alloc] init];\n    [_httpManager executeRequestSynchronously:[HttpRequest requestForResponse:clientPairChallengeResp withUrlRequest:[_httpManager newPairChallenge]]];\n    if (![self verifyResponseStatus:clientPairChallengeResp]) {\n        [self finishPairing:bgId forResponse:clientPairChallengeResp withFallbackError:@\"Pairing stage #5 failed\"];\n        return;\n    }\n    \n    [self finishPairing:bgId withSuccess:derCertBytes];\n}\n\n// Caller calls finishPairing for us on failure\n- (BOOL) verifyResponseStatus:(HttpResponse*)resp {\n    if (![resp isStatusOk]) {\n        return false;\n    } else {\n        NSInteger pairedStatus;\n        \n        if (![resp getIntTag:@\"paired\" value:&pairedStatus]) {\n            return false;\n        }\n        \n        return pairedStatus == 1;\n    }\n}\n\n- (NSData*) concatData:(NSData*)data with:(NSData*)moreData {\n    NSMutableData* concatData = [[NSMutableData alloc] initWithData:data];\n    [concatData appendData:moreData];\n    return concatData;\n}\n\n- (NSString*) generatePIN {\n    NSString* PIN = [NSString stringWithFormat:@\"%d%d%d%d\",\n                     arc4random() % 10, arc4random() % 10,\n                     arc4random() % 10, arc4random() % 10];\n    return PIN;\n}\n\n@end\n"], "filenames": ["Limelight/Network/PairManager.m"], "buggy_code_start_loc": [94], "buggy_code_end_loc": [237], "fixing_code_start_loc": [94], "fixing_code_end_loc": [231], "type": "CWE-200", "message": "In Moonlight iOS/tvOS before 4.0.1, the pairing process is vulnerable to a man-in-the-middle attack. The bug has been fixed in Moonlight v4.0.1 for iOS and tvOS.", "other": {"cve": {"id": "CVE-2020-11024", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-29T21:15:11.807", "lastModified": "2021-10-26T20:01:44.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Moonlight iOS/tvOS before 4.0.1, the pairing process is vulnerable to a man-in-the-middle attack. The bug has been fixed in Moonlight v4.0.1 for iOS and tvOS."}, {"lang": "es", "value": "En Moonlight iOS/tvOS versiones anteriores a la versi\u00f3n 4.0.1, el proceso de emparejamiento es vulnerable a un ataque de tipo man-in-the-middle. El bug se ha corregido en Moonlight versi\u00f3n v4.0.1 para iOS y tvOS."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:H/PR:L/UI:R/S:C/C:H/I:L/A:L", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.3, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-300"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:iphone_os:*:*", "versionEndExcluding": "4.0.1", "matchCriteriaId": "BB1C5F97-1454-4938-9844-B994B4BF7E27"}, {"vulnerable": true, "criteria": "cpe:2.3:a:moonlight-stream:moonlight:*:*:*:*:*:tvos:*:*", "versionEndExcluding": "4.0.1", "matchCriteriaId": "62E7DF05-3914-4723-B9E0-960D79296FAC"}]}]}], "references": [{"url": "https://github.com/moonlight-stream/moonlight-ios/commit/b0149b2fe9125a77ee11fe133382673694b6e8cc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/moonlight-stream/moonlight-ios/pull/405", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/moonlight-stream/moonlight-ios/security/advisories/GHSA-g298-gp8q-h6j3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/moonlight-stream/moonlight-ios/commit/b0149b2fe9125a77ee11fe133382673694b6e8cc"}}