{"buggy_code": ["# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nHub utilities: utilities related to download and cache models\n\"\"\"\nimport json\nimport os\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport traceback\nimport warnings\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union\nfrom urllib.parse import urlparse\nfrom uuid import uuid4\n\nimport huggingface_hub\nimport requests\nfrom huggingface_hub import (\n    CommitOperationAdd,\n    create_commit,\n    create_repo,\n    get_hf_file_metadata,\n    hf_hub_download,\n    hf_hub_url,\n    whoami,\n)\nfrom huggingface_hub.file_download import REGEX_COMMIT_HASH, http_get\nfrom huggingface_hub.utils import (\n    EntryNotFoundError,\n    LocalEntryNotFoundError,\n    RepositoryNotFoundError,\n    RevisionNotFoundError,\n    build_hf_headers,\n    hf_raise_for_status,\n)\nfrom requests.exceptions import HTTPError\n\nfrom . import __version__, logging\nfrom .generic import working_or_temp_dir\nfrom .import_utils import (\n    ENV_VARS_TRUE_VALUES,\n    _tf_version,\n    _torch_version,\n    is_tf_available,\n    is_torch_available,\n    is_training_run_on_sagemaker,\n)\nfrom .logging import tqdm\n\n\nlogger = logging.get_logger(__name__)  # pylint: disable=invalid-name\n\n_is_offline_mode = True if os.environ.get(\"TRANSFORMERS_OFFLINE\", \"0\").upper() in ENV_VARS_TRUE_VALUES else False\n\n\ndef is_offline_mode():\n    return _is_offline_mode\n\n\ntorch_cache_home = os.getenv(\"TORCH_HOME\", os.path.join(os.getenv(\"XDG_CACHE_HOME\", \"~/.cache\"), \"torch\"))\nold_default_cache_path = os.path.join(torch_cache_home, \"transformers\")\n# New default cache, shared with the Datasets library\nhf_cache_home = os.path.expanduser(\n    os.getenv(\"HF_HOME\", os.path.join(os.getenv(\"XDG_CACHE_HOME\", \"~/.cache\"), \"huggingface\"))\n)\ndefault_cache_path = os.path.join(hf_cache_home, \"hub\")\n\n# Onetime move from the old location to the new one if no ENV variable has been set.\nif (\n    os.path.isdir(old_default_cache_path)\n    and not os.path.isdir(default_cache_path)\n    and \"PYTORCH_PRETRAINED_BERT_CACHE\" not in os.environ\n    and \"PYTORCH_TRANSFORMERS_CACHE\" not in os.environ\n    and \"TRANSFORMERS_CACHE\" not in os.environ\n):\n    logger.warning(\n        \"In Transformers v4.0.0, the default path to cache downloaded models changed from\"\n        \" '~/.cache/torch/transformers' to '~/.cache/huggingface/transformers'. Since you don't seem to have\"\n        \" overridden and '~/.cache/torch/transformers' is a directory that exists, we're moving it to\"\n        \" '~/.cache/huggingface/transformers' to avoid redownloading models you have already in the cache. You should\"\n        \" only see this message once.\"\n    )\n    shutil.move(old_default_cache_path, default_cache_path)\n\nPYTORCH_PRETRAINED_BERT_CACHE = os.getenv(\"PYTORCH_PRETRAINED_BERT_CACHE\", default_cache_path)\nPYTORCH_TRANSFORMERS_CACHE = os.getenv(\"PYTORCH_TRANSFORMERS_CACHE\", PYTORCH_PRETRAINED_BERT_CACHE)\nHUGGINGFACE_HUB_CACHE = os.getenv(\"HUGGINGFACE_HUB_CACHE\", PYTORCH_TRANSFORMERS_CACHE)\nTRANSFORMERS_CACHE = os.getenv(\"TRANSFORMERS_CACHE\", HUGGINGFACE_HUB_CACHE)\nHF_MODULES_CACHE = os.getenv(\"HF_MODULES_CACHE\", os.path.join(hf_cache_home, \"modules\"))\nTRANSFORMERS_DYNAMIC_MODULE_NAME = \"transformers_modules\"\nSESSION_ID = uuid4().hex\nDISABLE_TELEMETRY = os.getenv(\"DISABLE_TELEMETRY\", False) in ENV_VARS_TRUE_VALUES\n\nS3_BUCKET_PREFIX = \"https://s3.amazonaws.com/models.huggingface.co/bert\"\nCLOUDFRONT_DISTRIB_PREFIX = \"https://cdn.huggingface.co\"\n\n_staging_mode = os.environ.get(\"HUGGINGFACE_CO_STAGING\", \"NO\").upper() in ENV_VARS_TRUE_VALUES\n_default_endpoint = \"https://hub-ci.huggingface.co\" if _staging_mode else \"https://huggingface.co\"\n\nHUGGINGFACE_CO_RESOLVE_ENDPOINT = _default_endpoint\nif os.environ.get(\"HUGGINGFACE_CO_RESOLVE_ENDPOINT\", None) is not None:\n    warnings.warn(\n        \"Using the environment variable `HUGGINGFACE_CO_RESOLVE_ENDPOINT` is deprecated and will be removed in \"\n        \"Transformers v5. Use `HF_ENDPOINT` instead.\",\n        FutureWarning,\n    )\n    HUGGINGFACE_CO_RESOLVE_ENDPOINT = os.environ.get(\"HUGGINGFACE_CO_RESOLVE_ENDPOINT\", None)\nHUGGINGFACE_CO_RESOLVE_ENDPOINT = os.environ.get(\"HF_ENDPOINT\", HUGGINGFACE_CO_RESOLVE_ENDPOINT)\nHUGGINGFACE_CO_PREFIX = HUGGINGFACE_CO_RESOLVE_ENDPOINT + \"/{model_id}/resolve/{revision}/{filename}\"\nHUGGINGFACE_CO_EXAMPLES_TELEMETRY = HUGGINGFACE_CO_RESOLVE_ENDPOINT + \"/api/telemetry/examples\"\n\n# Return value when trying to load a file from cache but the file does not exist in the distant repo.\n_CACHED_NO_EXIST = object()\n\n\ndef is_remote_url(url_or_filename):\n    parsed = urlparse(url_or_filename)\n    return parsed.scheme in (\"http\", \"https\")\n\n\ndef get_cached_models(cache_dir: Union[str, Path] = None) -> List[Tuple]:\n    \"\"\"\n    Returns a list of tuples representing model binaries that are cached locally. Each tuple has shape `(model_url,\n    etag, size_MB)`. Filenames in `cache_dir` are use to get the metadata for each model, only urls ending with *.bin*\n    are added.\n\n    Args:\n        cache_dir (`Union[str, Path]`, *optional*):\n            The cache directory to search for models within. Will default to the transformers cache if unset.\n\n    Returns:\n        List[Tuple]: List of tuples each with shape `(model_url, etag, size_MB)`\n    \"\"\"\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    elif isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n    if not os.path.isdir(cache_dir):\n        return []\n\n    cached_models = []\n    for file in os.listdir(cache_dir):\n        if file.endswith(\".json\"):\n            meta_path = os.path.join(cache_dir, file)\n            with open(meta_path, encoding=\"utf-8\") as meta_file:\n                metadata = json.load(meta_file)\n                url = metadata[\"url\"]\n                etag = metadata[\"etag\"]\n                if url.endswith(\".bin\"):\n                    size_MB = os.path.getsize(meta_path.strip(\".json\")) / 1e6\n                    cached_models.append((url, etag, size_MB))\n\n    return cached_models\n\n\ndef define_sagemaker_information():\n    try:\n        instance_data = requests.get(os.environ[\"ECS_CONTAINER_METADATA_URI\"]).json()\n        dlc_container_used = instance_data[\"Image\"]\n        dlc_tag = instance_data[\"Image\"].split(\":\")[1]\n    except Exception:\n        dlc_container_used = None\n        dlc_tag = None\n\n    sagemaker_params = json.loads(os.getenv(\"SM_FRAMEWORK_PARAMS\", \"{}\"))\n    runs_distributed_training = True if \"sagemaker_distributed_dataparallel_enabled\" in sagemaker_params else False\n    account_id = os.getenv(\"TRAINING_JOB_ARN\").split(\":\")[4] if \"TRAINING_JOB_ARN\" in os.environ else None\n\n    sagemaker_object = {\n        \"sm_framework\": os.getenv(\"SM_FRAMEWORK_MODULE\", None),\n        \"sm_region\": os.getenv(\"AWS_REGION\", None),\n        \"sm_number_gpu\": os.getenv(\"SM_NUM_GPUS\", 0),\n        \"sm_number_cpu\": os.getenv(\"SM_NUM_CPUS\", 0),\n        \"sm_distributed_training\": runs_distributed_training,\n        \"sm_deep_learning_container\": dlc_container_used,\n        \"sm_deep_learning_container_tag\": dlc_tag,\n        \"sm_account_id\": account_id,\n    }\n    return sagemaker_object\n\n\ndef http_user_agent(user_agent: Union[Dict, str, None] = None) -> str:\n    \"\"\"\n    Formats a user-agent string with basic info about a request.\n    \"\"\"\n    ua = f\"transformers/{__version__}; python/{sys.version.split()[0]}; session_id/{SESSION_ID}\"\n    if is_torch_available():\n        ua += f\"; torch/{_torch_version}\"\n    if is_tf_available():\n        ua += f\"; tensorflow/{_tf_version}\"\n    if DISABLE_TELEMETRY:\n        return ua + \"; telemetry/off\"\n    if is_training_run_on_sagemaker():\n        ua += \"; \" + \"; \".join(f\"{k}/{v}\" for k, v in define_sagemaker_information().items())\n    # CI will set this value to True\n    if os.environ.get(\"TRANSFORMERS_IS_CI\", \"\").upper() in ENV_VARS_TRUE_VALUES:\n        ua += \"; is_ci/true\"\n    if isinstance(user_agent, dict):\n        ua += \"; \" + \"; \".join(f\"{k}/{v}\" for k, v in user_agent.items())\n    elif isinstance(user_agent, str):\n        ua += \"; \" + user_agent\n    return ua\n\n\ndef extract_commit_hash(resolved_file: Optional[str], commit_hash: Optional[str]):\n    \"\"\"\n    Extracts the commit hash from a resolved filename toward a cache file.\n    \"\"\"\n    if resolved_file is None or commit_hash is not None:\n        return commit_hash\n    resolved_file = str(Path(resolved_file).as_posix())\n    search = re.search(r\"snapshots/([^/]+)/\", resolved_file)\n    if search is None:\n        return None\n    commit_hash = search.groups()[0]\n    return commit_hash if REGEX_COMMIT_HASH.match(commit_hash) else None\n\n\ndef try_to_load_from_cache(\n    repo_id: str,\n    filename: str,\n    cache_dir: Union[str, Path, None] = None,\n    revision: Optional[str] = None,\n    repo_type: Optional[str] = None,\n) -> Optional[str]:\n    \"\"\"\n    Explores the cache to return the latest cached file for a given revision if found.\n\n    This function will not raise any exception if the file in not cached.\n\n    Args:\n        cache_dir (`str` or `os.PathLike`):\n            The folder where the cached files lie.\n        repo_id (`str`):\n            The ID of the repo on huggingface.co.\n        filename (`str`):\n            The filename to look for inside `repo_id`.\n        revision (`str`, *optional*):\n            The specific model version to use. Will default to `\"main\"` if it's not provided and no `commit_hash` is\n            provided either.\n        repo_type (`str`, *optional*):\n            The type of the repo.\n\n    Returns:\n        `Optional[str]` or `_CACHED_NO_EXIST`:\n            Will return `None` if the file was not cached. Otherwise:\n            - The exact path to the cached file if it's found in the cache\n            - A special value `_CACHED_NO_EXIST` if the file does not exist at the given commit hash and this fact was\n              cached.\n    \"\"\"\n    if revision is None:\n        revision = \"main\"\n\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n\n    object_id = repo_id.replace(\"/\", \"--\")\n    if repo_type is None:\n        repo_type = \"model\"\n    repo_cache = os.path.join(cache_dir, f\"{repo_type}s--{object_id}\")\n    if not os.path.isdir(repo_cache):\n        # No cache for this model\n        return None\n    for subfolder in [\"refs\", \"snapshots\"]:\n        if not os.path.isdir(os.path.join(repo_cache, subfolder)):\n            return None\n\n    # Resolve refs (for instance to convert main to the associated commit sha)\n    cached_refs = os.listdir(os.path.join(repo_cache, \"refs\"))\n    if revision in cached_refs:\n        with open(os.path.join(repo_cache, \"refs\", revision)) as f:\n            revision = f.read()\n\n    if os.path.isfile(os.path.join(repo_cache, \".no_exist\", revision, filename)):\n        return _CACHED_NO_EXIST\n\n    cached_shas = os.listdir(os.path.join(repo_cache, \"snapshots\"))\n    if revision not in cached_shas:\n        # No cache for this revision and we won't try to return a random revision\n        return None\n\n    cached_file = os.path.join(repo_cache, \"snapshots\", revision, filename)\n    return cached_file if os.path.isfile(cached_file) else None\n\n\ndef cached_file(\n    path_or_repo_id: Union[str, os.PathLike],\n    filename: str,\n    cache_dir: Optional[Union[str, os.PathLike]] = None,\n    force_download: bool = False,\n    resume_download: bool = False,\n    proxies: Optional[Dict[str, str]] = None,\n    use_auth_token: Optional[Union[bool, str]] = None,\n    revision: Optional[str] = None,\n    local_files_only: bool = False,\n    subfolder: str = \"\",\n    repo_type: Optional[str] = None,\n    user_agent: Optional[Union[str, Dict[str, str]]] = None,\n    _raise_exceptions_for_missing_entries: bool = True,\n    _raise_exceptions_for_connection_errors: bool = True,\n    _commit_hash: Optional[str] = None,\n):\n    \"\"\"\n    Tries to locate a file in a local folder and repo, downloads and cache it if necessary.\n\n    Args:\n        path_or_repo_id (`str` or `os.PathLike`):\n            This can be either:\n\n            - a string, the *model id* of a model repo on huggingface.co.\n            - a path to a *directory* potentially containing the file.\n        filename (`str`):\n            The name of the file to locate in `path_or_repo`.\n        cache_dir (`str` or `os.PathLike`, *optional*):\n            Path to a directory in which a downloaded pretrained model configuration should be cached if the standard\n            cache should not be used.\n        force_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to force to (re-)download the configuration files and override the cached versions if they\n            exist.\n        resume_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to delete incompletely received file. Attempts to resume the download if such a file exists.\n        proxies (`Dict[str, str]`, *optional*):\n            A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',\n            'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.\n        use_auth_token (`str` or *bool*, *optional*):\n            The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated\n            when running `huggingface-cli login` (stored in `~/.huggingface`).\n        revision (`str`, *optional*, defaults to `\"main\"`):\n            The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a\n            git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any\n            identifier allowed by git.\n        local_files_only (`bool`, *optional*, defaults to `False`):\n            If `True`, will only try to load the tokenizer configuration from local files.\n        subfolder (`str`, *optional*, defaults to `\"\"`):\n            In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can\n            specify the folder name here.\n        repo_type (`str`, *optional*):\n            Specify the repo type (useful when downloading from a space for instance).\n\n    <Tip>\n\n    Passing `use_auth_token=True` is required when you want to use a private model.\n\n    </Tip>\n\n    Returns:\n        `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).\n\n    Examples:\n\n    ```python\n    # Download a model weight from the Hub and cache it.\n    model_weights_file = cached_file(\"bert-base-uncased\", \"pytorch_model.bin\")\n    ```\"\"\"\n    # Private arguments\n    #     _raise_exceptions_for_missing_entries: if False, do not raise an exception for missing entries but return\n    #         None.\n    #     _raise_exceptions_for_connection_errors: if False, do not raise an exception for connection errors but return\n    #         None.\n    #     _commit_hash: passed when we are chaining several calls to various files (e.g. when loading a tokenizer or\n    #         a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.\n    if is_offline_mode() and not local_files_only:\n        logger.info(\"Offline mode: forcing local_files_only=True\")\n        local_files_only = True\n    if subfolder is None:\n        subfolder = \"\"\n\n    path_or_repo_id = str(path_or_repo_id)\n    full_filename = os.path.join(subfolder, filename)\n    if os.path.isdir(path_or_repo_id):\n        resolved_file = os.path.join(os.path.join(path_or_repo_id, subfolder), filename)\n        if not os.path.isfile(resolved_file):\n            if _raise_exceptions_for_missing_entries:\n                raise EnvironmentError(\n                    f\"{path_or_repo_id} does not appear to have a file named {full_filename}. Checkout \"\n                    f\"'https://huggingface.co/{path_or_repo_id}/{revision}' for available files.\"\n                )\n            else:\n                return None\n        return resolved_file\n\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    if isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    if _commit_hash is not None and not force_download:\n        # If the file is cached under that commit hash, we return it directly.\n        resolved_file = try_to_load_from_cache(\n            path_or_repo_id, full_filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type\n        )\n        if resolved_file is not None:\n            if resolved_file is not _CACHED_NO_EXIST:\n                return resolved_file\n            elif not _raise_exceptions_for_missing_entries:\n                return None\n            else:\n                raise EnvironmentError(f\"Could not locate {full_filename} inside {path_or_repo_id}.\")\n\n    user_agent = http_user_agent(user_agent)\n    try:\n        # Load from URL or cache if already cached\n        resolved_file = hf_hub_download(\n            path_or_repo_id,\n            filename,\n            subfolder=None if len(subfolder) == 0 else subfolder,\n            repo_type=repo_type,\n            revision=revision,\n            cache_dir=cache_dir,\n            user_agent=user_agent,\n            force_download=force_download,\n            proxies=proxies,\n            resume_download=resume_download,\n            use_auth_token=use_auth_token,\n            local_files_only=local_files_only,\n        )\n\n    except RepositoryNotFoundError:\n        raise EnvironmentError(\n            f\"{path_or_repo_id} is not a local folder and is not a valid model identifier \"\n            \"listed on 'https://huggingface.co/models'\\nIf this is a private repository, make sure to \"\n            \"pass a token having permission to this repo with `use_auth_token` or log in with \"\n            \"`huggingface-cli login` and pass `use_auth_token=True`.\"\n        )\n    except RevisionNotFoundError:\n        raise EnvironmentError(\n            f\"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists \"\n            \"for this model name. Check the model page at \"\n            f\"'https://huggingface.co/{path_or_repo_id}' for available revisions.\"\n        )\n    except LocalEntryNotFoundError:\n        # We try to see if we have a cached version (not up to date):\n        resolved_file = try_to_load_from_cache(path_or_repo_id, full_filename, cache_dir=cache_dir, revision=revision)\n        if resolved_file is not None and resolved_file != _CACHED_NO_EXIST:\n            return resolved_file\n        if not _raise_exceptions_for_missing_entries or not _raise_exceptions_for_connection_errors:\n            return None\n        raise EnvironmentError(\n            f\"We couldn't connect to '{HUGGINGFACE_CO_RESOLVE_ENDPOINT}' to load this file, couldn't find it in the\"\n            f\" cached files and it looks like {path_or_repo_id} is not the path to a directory containing a file named\"\n            f\" {full_filename}.\\nCheckout your internet connection or see how to run the library in offline mode at\"\n            \" 'https://huggingface.co/docs/transformers/installation#offline-mode'.\"\n        )\n    except EntryNotFoundError:\n        if not _raise_exceptions_for_missing_entries:\n            return None\n        if revision is None:\n            revision = \"main\"\n        raise EnvironmentError(\n            f\"{path_or_repo_id} does not appear to have a file named {full_filename}. Checkout \"\n            f\"'https://huggingface.co/{path_or_repo_id}/{revision}' for available files.\"\n        )\n    except HTTPError as err:\n        # First we try to see if we have a cached version (not up to date):\n        resolved_file = try_to_load_from_cache(path_or_repo_id, full_filename, cache_dir=cache_dir, revision=revision)\n        if resolved_file is not None and resolved_file != _CACHED_NO_EXIST:\n            return resolved_file\n        if not _raise_exceptions_for_connection_errors:\n            return None\n\n        raise EnvironmentError(f\"There was a specific connection error when trying to load {path_or_repo_id}:\\n{err}\")\n\n    return resolved_file\n\n\ndef get_file_from_repo(\n    path_or_repo: Union[str, os.PathLike],\n    filename: str,\n    cache_dir: Optional[Union[str, os.PathLike]] = None,\n    force_download: bool = False,\n    resume_download: bool = False,\n    proxies: Optional[Dict[str, str]] = None,\n    use_auth_token: Optional[Union[bool, str]] = None,\n    revision: Optional[str] = None,\n    local_files_only: bool = False,\n    subfolder: str = \"\",\n):\n    \"\"\"\n    Tries to locate a file in a local folder and repo, downloads and cache it if necessary.\n\n    Args:\n        path_or_repo (`str` or `os.PathLike`):\n            This can be either:\n\n            - a string, the *model id* of a model repo on huggingface.co.\n            - a path to a *directory* potentially containing the file.\n        filename (`str`):\n            The name of the file to locate in `path_or_repo`.\n        cache_dir (`str` or `os.PathLike`, *optional*):\n            Path to a directory in which a downloaded pretrained model configuration should be cached if the standard\n            cache should not be used.\n        force_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to force to (re-)download the configuration files and override the cached versions if they\n            exist.\n        resume_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to delete incompletely received file. Attempts to resume the download if such a file exists.\n        proxies (`Dict[str, str]`, *optional*):\n            A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',\n            'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.\n        use_auth_token (`str` or *bool*, *optional*):\n            The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated\n            when running `huggingface-cli login` (stored in `~/.huggingface`).\n        revision (`str`, *optional*, defaults to `\"main\"`):\n            The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a\n            git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any\n            identifier allowed by git.\n        local_files_only (`bool`, *optional*, defaults to `False`):\n            If `True`, will only try to load the tokenizer configuration from local files.\n        subfolder (`str`, *optional*, defaults to `\"\"`):\n            In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can\n            specify the folder name here.\n\n    <Tip>\n\n    Passing `use_auth_token=True` is required when you want to use a private model.\n\n    </Tip>\n\n    Returns:\n        `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo) or `None` if the\n        file does not exist.\n\n    Examples:\n\n    ```python\n    # Download a tokenizer configuration from huggingface.co and cache.\n    tokenizer_config = get_file_from_repo(\"bert-base-uncased\", \"tokenizer_config.json\")\n    # This model does not have a tokenizer config so the result will be None.\n    tokenizer_config = get_file_from_repo(\"xlm-roberta-base\", \"tokenizer_config.json\")\n    ```\"\"\"\n    return cached_file(\n        path_or_repo_id=path_or_repo,\n        filename=filename,\n        cache_dir=cache_dir,\n        force_download=force_download,\n        resume_download=resume_download,\n        proxies=proxies,\n        use_auth_token=use_auth_token,\n        revision=revision,\n        local_files_only=local_files_only,\n        subfolder=subfolder,\n        _raise_exceptions_for_missing_entries=False,\n        _raise_exceptions_for_connection_errors=False,\n    )\n\n\ndef download_url(url, proxies=None):\n    \"\"\"\n    Downloads a given url in a temporary file. This function is not safe to use in multiple processes. Its only use is\n    for deprecated behavior allowing to download config/models with a single url instead of using the Hub.\n\n    Args:\n        url (`str`): The url of the file to download.\n        proxies (`Dict[str, str]`, *optional*):\n            A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',\n            'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.\n\n    Returns:\n        `str`: The location of the temporary file where the url was downloaded.\n    \"\"\"\n    warnings.warn(\n        f\"Using `from_pretrained` with the url of a file (here {url}) is deprecated and won't be possible anymore in\"\n        \" v5 of Transformers. You should host your file on the Hub (hf.co) instead and use the repository ID. Note\"\n        \" that this is not compatible with the caching system (your file will be downloaded at each execution) or\"\n        \" multiple processes (each process will download the file in a different temporary file).\"\n    )\n    tmp_file = tempfile.mktemp()\n    with open(tmp_file, \"wb\") as f:\n        http_get(url, f, proxies=proxies)\n    return tmp_file\n\n\ndef has_file(\n    path_or_repo: Union[str, os.PathLike],\n    filename: str,\n    revision: Optional[str] = None,\n    proxies: Optional[Dict[str, str]] = None,\n    use_auth_token: Optional[Union[bool, str]] = None,\n):\n    \"\"\"\n    Checks if a repo contains a given file without downloading it. Works for remote repos and local folders.\n\n    <Tip warning={false}>\n\n    This function will raise an error if the repository `path_or_repo` is not valid or if `revision` does not exist for\n    this repo, but will return False for regular connection errors.\n\n    </Tip>\n    \"\"\"\n    if os.path.isdir(path_or_repo):\n        return os.path.isfile(os.path.join(path_or_repo, filename))\n\n    url = hf_hub_url(path_or_repo, filename=filename, revision=revision)\n    headers = build_hf_headers(use_auth_token=use_auth_token, user_agent=http_user_agent())\n\n    r = requests.head(url, headers=headers, allow_redirects=False, proxies=proxies, timeout=10)\n    try:\n        hf_raise_for_status(r)\n        return True\n    except RepositoryNotFoundError as e:\n        logger.error(e)\n        raise EnvironmentError(f\"{path_or_repo} is not a local folder or a valid repository name on 'https://hf.co'.\")\n    except RevisionNotFoundError as e:\n        logger.error(e)\n        raise EnvironmentError(\n            f\"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists for this \"\n            f\"model name. Check the model page at 'https://huggingface.co/{path_or_repo}' for available revisions.\"\n        )\n    except requests.HTTPError:\n        # We return false for EntryNotFoundError (logical) as well as any connection error.\n        return False\n\n\nclass PushToHubMixin:\n    \"\"\"\n    A Mixin containing the functionality to push a model or tokenizer to the hub.\n    \"\"\"\n\n    def _create_repo(\n        self,\n        repo_id: str,\n        private: Optional[bool] = None,\n        use_auth_token: Optional[Union[bool, str]] = None,\n        repo_url: Optional[str] = None,\n        organization: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Create the repo if needed, cleans up repo_id with deprecated kwargs `repo_url` and `organization`, retrieves\n        the token.\n        \"\"\"\n        if repo_url is not None:\n            warnings.warn(\n                \"The `repo_url` argument is deprecated and will be removed in v5 of Transformers. Use `repo_id` \"\n                \"instead.\"\n            )\n            repo_id = repo_url.replace(f\"{HUGGINGFACE_CO_RESOLVE_ENDPOINT}/\", \"\")\n        if organization is not None:\n            warnings.warn(\n                \"The `organization` argument is deprecated and will be removed in v5 of Transformers. Set your \"\n                \"organization directly in the `repo_id` passed instead (`repo_id={organization}/{model_id}`).\"\n            )\n            if not repo_id.startswith(organization):\n                if \"/\" in repo_id:\n                    repo_id = repo_id.split(\"/\")[-1]\n                repo_id = f\"{organization}/{repo_id}\"\n\n        url = create_repo(repo_id=repo_id, token=use_auth_token, private=private, exist_ok=True)\n\n        # If the namespace is not there, add it or `upload_file` will complain\n        if \"/\" not in repo_id and url != f\"{HUGGINGFACE_CO_RESOLVE_ENDPOINT}/{repo_id}\":\n            repo_id = get_full_repo_name(repo_id, token=use_auth_token)\n        return repo_id\n\n    def _get_files_timestamps(self, working_dir: Union[str, os.PathLike]):\n        \"\"\"\n        Returns the list of files with their last modification timestamp.\n        \"\"\"\n        return {f: os.path.getmtime(os.path.join(working_dir, f)) for f in os.listdir(working_dir)}\n\n    def _upload_modified_files(\n        self,\n        working_dir: Union[str, os.PathLike],\n        repo_id: str,\n        files_timestamps: Dict[str, float],\n        commit_message: Optional[str] = None,\n        token: Optional[Union[bool, str]] = None,\n        create_pr: bool = False,\n    ):\n        \"\"\"\n        Uploads all modified files in `working_dir` to `repo_id`, based on `files_timestamps`.\n        \"\"\"\n        if commit_message is None:\n            if \"Model\" in self.__class__.__name__:\n                commit_message = \"Upload model\"\n            elif \"Config\" in self.__class__.__name__:\n                commit_message = \"Upload config\"\n            elif \"Tokenizer\" in self.__class__.__name__:\n                commit_message = \"Upload tokenizer\"\n            elif \"FeatureExtractor\" in self.__class__.__name__:\n                commit_message = \"Upload feature extractor\"\n            elif \"Processor\" in self.__class__.__name__:\n                commit_message = \"Upload processor\"\n            else:\n                commit_message = f\"Upload {self.__class__.__name__}\"\n        modified_files = [\n            f\n            for f in os.listdir(working_dir)\n            if f not in files_timestamps or os.path.getmtime(os.path.join(working_dir, f)) > files_timestamps[f]\n        ]\n        operations = []\n        for file in modified_files:\n            operations.append(CommitOperationAdd(path_or_fileobj=os.path.join(working_dir, file), path_in_repo=file))\n        logger.info(f\"Uploading the following files to {repo_id}: {','.join(modified_files)}\")\n        return create_commit(\n            repo_id=repo_id, operations=operations, commit_message=commit_message, token=token, create_pr=create_pr\n        )\n\n    def push_to_hub(\n        self,\n        repo_id: str,\n        use_temp_dir: Optional[bool] = None,\n        commit_message: Optional[str] = None,\n        private: Optional[bool] = None,\n        use_auth_token: Optional[Union[bool, str]] = None,\n        max_shard_size: Optional[Union[int, str]] = \"10GB\",\n        create_pr: bool = False,\n        **deprecated_kwargs,\n    ) -> str:\n        \"\"\"\n        Upload the {object_files} to the \ud83e\udd17 Model Hub while synchronizing a local clone of the repo in\n        `repo_path_or_name`.\n\n        Parameters:\n            repo_id (`str`):\n                The name of the repository you want to push your {object} to. It should contain your organization name\n                when pushing to a given organization.\n            use_temp_dir (`bool`, *optional*):\n                Whether or not to use a temporary directory to store the files saved before they are pushed to the Hub.\n                Will default to `True` if there is no directory named like `repo_id`, `False` otherwise.\n            commit_message (`str`, *optional*):\n                Message to commit while pushing. Will default to `\"Upload {object}\"`.\n            private (`bool`, *optional*):\n                Whether or not the repository created should be private.\n            use_auth_token (`bool` or `str`, *optional*):\n                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated\n                when running `huggingface-cli login` (stored in `~/.huggingface`). Will default to `True` if `repo_url`\n                is not specified.\n            max_shard_size (`int` or `str`, *optional*, defaults to `\"10GB\"`):\n                Only applicable for models. The maximum size for a checkpoint before being sharded. Checkpoints shard\n                will then be each of size lower than this size. If expressed as a string, needs to be digits followed\n                by a unit (like `\"5MB\"`).\n            create_pr (`bool`, *optional*, defaults to `False`):\n                Whether or not to create a PR with the uploaded files or directly commit.\n\n        Examples:\n\n        ```python\n        from transformers import {object_class}\n\n        {object} = {object_class}.from_pretrained(\"bert-base-cased\")\n\n        # Push the {object} to your namespace with the name \"my-finetuned-bert\".\n        {object}.push_to_hub(\"my-finetuned-bert\")\n\n        # Push the {object} to an organization with the name \"my-finetuned-bert\".\n        {object}.push_to_hub(\"huggingface/my-finetuned-bert\")\n        ```\n        \"\"\"\n        if \"repo_path_or_name\" in deprecated_kwargs:\n            warnings.warn(\n                \"The `repo_path_or_name` argument is deprecated and will be removed in v5 of Transformers. Use \"\n                \"`repo_id` instead.\"\n            )\n            repo_id = deprecated_kwargs.pop(\"repo_path_or_name\")\n        # Deprecation warning will be sent after for repo_url and organization\n        repo_url = deprecated_kwargs.pop(\"repo_url\", None)\n        organization = deprecated_kwargs.pop(\"organization\", None)\n\n        if os.path.isdir(repo_id):\n            working_dir = repo_id\n            repo_id = repo_id.split(os.path.sep)[-1]\n        else:\n            working_dir = repo_id.split(\"/\")[-1]\n\n        repo_id = self._create_repo(\n            repo_id, private=private, use_auth_token=use_auth_token, repo_url=repo_url, organization=organization\n        )\n\n        if use_temp_dir is None:\n            use_temp_dir = not os.path.isdir(working_dir)\n\n        with working_or_temp_dir(working_dir=working_dir, use_temp_dir=use_temp_dir) as work_dir:\n            files_timestamps = self._get_files_timestamps(work_dir)\n\n            # Save all files.\n            self.save_pretrained(work_dir, max_shard_size=max_shard_size)\n\n            return self._upload_modified_files(\n                work_dir,\n                repo_id,\n                files_timestamps,\n                commit_message=commit_message,\n                token=use_auth_token,\n                create_pr=create_pr,\n            )\n\n\ndef get_full_repo_name(model_id: str, organization: Optional[str] = None, token: Optional[str] = None):\n    if organization is None:\n        username = whoami(token)[\"name\"]\n        return f\"{username}/{model_id}\"\n    else:\n        return f\"{organization}/{model_id}\"\n\n\ndef send_example_telemetry(example_name, *example_args, framework=\"pytorch\"):\n    \"\"\"\n    Sends telemetry that helps tracking the examples use.\n\n    Args:\n        example_name (`str`): The name of the example.\n        *example_args (dataclasses or `argparse.ArgumentParser`): The arguments to the script. This function will only\n            try to extract the model and dataset name from those. Nothing else is tracked.\n        framework (`str`, *optional*, defaults to `\"pytorch\"`): The framework for the example.\n    \"\"\"\n    if is_offline_mode():\n        return\n\n    data = {\"example\": example_name, \"framework\": framework}\n    for args in example_args:\n        args_as_dict = {k: v for k, v in args.__dict__.items() if not k.startswith(\"_\") and v is not None}\n        if \"model_name_or_path\" in args_as_dict:\n            model_name = args_as_dict[\"model_name_or_path\"]\n            # Filter out local paths\n            if not os.path.isdir(model_name):\n                data[\"model_name\"] = args_as_dict[\"model_name_or_path\"]\n        if \"dataset_name\" in args_as_dict:\n            data[\"dataset_name\"] = args_as_dict[\"dataset_name\"]\n        elif \"task_name\" in args_as_dict:\n            # Extract script name from the example_name\n            script_name = example_name.replace(\"tf_\", \"\").replace(\"flax_\", \"\").replace(\"run_\", \"\")\n            script_name = script_name.replace(\"_no_trainer\", \"\")\n            data[\"dataset_name\"] = f\"{script_name}-{args_as_dict['task_name']}\"\n\n    headers = {\"user-agent\": http_user_agent(data)}\n    try:\n        r = requests.head(HUGGINGFACE_CO_EXAMPLES_TELEMETRY, headers=headers)\n        r.raise_for_status()\n    except Exception:\n        # We don't want to error in case of connection errors of any kind.\n        pass\n\n\ndef convert_file_size_to_int(size: Union[int, str]):\n    \"\"\"\n    Converts a size expressed as a string with digits an unit (like `\"5MB\"`) to an integer (in bytes).\n\n    Args:\n        size (`int` or `str`): The size to convert. Will be directly returned if an `int`.\n\n    Example:\n    ```py\n    >>> convert_file_size_to_int(\"1MiB\")\n    1048576\n    ```\n    \"\"\"\n    if isinstance(size, int):\n        return size\n    if size.upper().endswith(\"GIB\"):\n        return int(size[:-3]) * (2**30)\n    if size.upper().endswith(\"MIB\"):\n        return int(size[:-3]) * (2**20)\n    if size.upper().endswith(\"KIB\"):\n        return int(size[:-3]) * (2**10)\n    if size.upper().endswith(\"GB\"):\n        int_size = int(size[:-2]) * (10**9)\n        return int_size // 8 if size.endswith(\"b\") else int_size\n    if size.upper().endswith(\"MB\"):\n        int_size = int(size[:-2]) * (10**6)\n        return int_size // 8 if size.endswith(\"b\") else int_size\n    if size.upper().endswith(\"KB\"):\n        int_size = int(size[:-2]) * (10**3)\n        return int_size // 8 if size.endswith(\"b\") else int_size\n    raise ValueError(\"`size` is not in a valid format. Use an integer followed by the unit, e.g., '5GB'.\")\n\n\ndef get_checkpoint_shard_files(\n    pretrained_model_name_or_path,\n    index_filename,\n    cache_dir=None,\n    force_download=False,\n    proxies=None,\n    resume_download=False,\n    local_files_only=False,\n    use_auth_token=None,\n    user_agent=None,\n    revision=None,\n    subfolder=\"\",\n    _commit_hash=None,\n):\n    \"\"\"\n    For a given model:\n\n    - download and cache all the shards of a sharded checkpoint if `pretrained_model_name_or_path` is a model ID on the\n      Hub\n    - returns the list of paths to all the shards, as well as some metadata.\n\n    For the description of each arg, see [`PreTrainedModel.from_pretrained`]. `index_filename` is the full path to the\n    index (downloaded and cached if `pretrained_model_name_or_path` is a model ID on the Hub).\n    \"\"\"\n    import json\n\n    if not os.path.isfile(index_filename):\n        raise ValueError(f\"Can't find a checkpoint index ({index_filename}) in {pretrained_model_name_or_path}.\")\n\n    with open(index_filename, \"r\") as f:\n        index = json.loads(f.read())\n\n    shard_filenames = sorted(set(index[\"weight_map\"].values()))\n    sharded_metadata = index[\"metadata\"]\n    sharded_metadata[\"all_checkpoint_keys\"] = list(index[\"weight_map\"].keys())\n    sharded_metadata[\"weight_map\"] = index[\"weight_map\"].copy()\n\n    # First, let's deal with local folder.\n    if os.path.isdir(pretrained_model_name_or_path):\n        shard_filenames = [os.path.join(pretrained_model_name_or_path, subfolder, f) for f in shard_filenames]\n        return shard_filenames, sharded_metadata\n\n    # At this stage pretrained_model_name_or_path is a model identifier on the Hub\n    cached_filenames = []\n    # Check if the model is already cached or not. We only try the last checkpoint, this should cover most cases of\n    # downloaded (if interrupted).\n    last_shard = try_to_load_from_cache(\n        pretrained_model_name_or_path, shard_filenames[-1], cache_dir=cache_dir, revision=_commit_hash\n    )\n    show_progress_bar = last_shard is None or force_download\n    for shard_filename in tqdm(shard_filenames, desc=\"Downloading shards\", disable=not show_progress_bar):\n        try:\n            # Load from URL\n            cached_filename = cached_file(\n                pretrained_model_name_or_path,\n                shard_filename,\n                cache_dir=cache_dir,\n                force_download=force_download,\n                proxies=proxies,\n                resume_download=resume_download,\n                local_files_only=local_files_only,\n                use_auth_token=use_auth_token,\n                user_agent=user_agent,\n                revision=revision,\n                subfolder=subfolder,\n                _commit_hash=_commit_hash,\n            )\n        # We have already dealt with RepositoryNotFoundError and RevisionNotFoundError when getting the index, so\n        # we don't have to catch them here.\n        except EntryNotFoundError:\n            raise EnvironmentError(\n                f\"{pretrained_model_name_or_path} does not appear to have a file named {shard_filename} which is \"\n                \"required according to the checkpoint index.\"\n            )\n        except HTTPError:\n            raise EnvironmentError(\n                f\"We couldn't connect to '{HUGGINGFACE_CO_RESOLVE_ENDPOINT}' to load {shard_filename}. You should try\"\n                \" again after checking your internet connection.\"\n            )\n\n        cached_filenames.append(cached_filename)\n\n    return cached_filenames, sharded_metadata\n\n\n# All what is below is for conversion between old cache format and new cache format.\n\n\ndef get_all_cached_files(cache_dir=None):\n    \"\"\"\n    Returns a list for all files cached with appropriate metadata.\n    \"\"\"\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    else:\n        cache_dir = str(cache_dir)\n    if not os.path.isdir(cache_dir):\n        return []\n\n    cached_files = []\n    for file in os.listdir(cache_dir):\n        meta_path = os.path.join(cache_dir, f\"{file}.json\")\n        if not os.path.isfile(meta_path):\n            continue\n\n        with open(meta_path, encoding=\"utf-8\") as meta_file:\n            metadata = json.load(meta_file)\n            url = metadata[\"url\"]\n            etag = metadata[\"etag\"].replace('\"', \"\")\n            cached_files.append({\"file\": file, \"url\": url, \"etag\": etag})\n\n    return cached_files\n\n\ndef extract_info_from_url(url):\n    \"\"\"\n    Extract repo_name, revision and filename from an url.\n    \"\"\"\n    search = re.search(r\"^https://huggingface\\.co/(.*)/resolve/([^/]*)/(.*)$\", url)\n    if search is None:\n        return None\n    repo, revision, filename = search.groups()\n    cache_repo = \"--\".join([\"models\"] + repo.split(\"/\"))\n    return {\"repo\": cache_repo, \"revision\": revision, \"filename\": filename}\n\n\ndef clean_files_for(file):\n    \"\"\"\n    Remove, if they exist, file, file.json and file.lock\n    \"\"\"\n    for f in [file, f\"{file}.json\", f\"{file}.lock\"]:\n        if os.path.isfile(f):\n            os.remove(f)\n\n\ndef move_to_new_cache(file, repo, filename, revision, etag, commit_hash):\n    \"\"\"\n    Move file to repo following the new huggingface hub cache organization.\n    \"\"\"\n    os.makedirs(repo, exist_ok=True)\n\n    # refs\n    os.makedirs(os.path.join(repo, \"refs\"), exist_ok=True)\n    if revision != commit_hash:\n        ref_path = os.path.join(repo, \"refs\", revision)\n        with open(ref_path, \"w\") as f:\n            f.write(commit_hash)\n\n    # blobs\n    os.makedirs(os.path.join(repo, \"blobs\"), exist_ok=True)\n    blob_path = os.path.join(repo, \"blobs\", etag)\n    shutil.move(file, blob_path)\n\n    # snapshots\n    os.makedirs(os.path.join(repo, \"snapshots\"), exist_ok=True)\n    os.makedirs(os.path.join(repo, \"snapshots\", commit_hash), exist_ok=True)\n    pointer_path = os.path.join(repo, \"snapshots\", commit_hash, filename)\n    huggingface_hub.file_download._create_relative_symlink(blob_path, pointer_path)\n    clean_files_for(file)\n\n\ndef move_cache(cache_dir=None, new_cache_dir=None, token=None):\n    if new_cache_dir is None:\n        new_cache_dir = TRANSFORMERS_CACHE\n    if cache_dir is None:\n        # Migrate from old cache in .cache/huggingface/hub\n        old_cache = Path(TRANSFORMERS_CACHE).parent / \"transformers\"\n        if os.path.isdir(str(old_cache)):\n            cache_dir = str(old_cache)\n        else:\n            cache_dir = new_cache_dir\n    cached_files = get_all_cached_files(cache_dir=cache_dir)\n    logger.info(f\"Moving {len(cached_files)} files to the new cache system\")\n\n    hub_metadata = {}\n    for file_info in tqdm(cached_files):\n        url = file_info.pop(\"url\")\n        if url not in hub_metadata:\n            try:\n                hub_metadata[url] = get_hf_file_metadata(url, token=token)\n            except requests.HTTPError:\n                continue\n\n        etag, commit_hash = hub_metadata[url].etag, hub_metadata[url].commit_hash\n        if etag is None or commit_hash is None:\n            continue\n\n        if file_info[\"etag\"] != etag:\n            # Cached file is not up to date, we just throw it as a new version will be downloaded anyway.\n            clean_files_for(os.path.join(cache_dir, file_info[\"file\"]))\n            continue\n\n        url_info = extract_info_from_url(url)\n        if url_info is None:\n            # Not a file from huggingface.co\n            continue\n\n        repo = os.path.join(new_cache_dir, url_info[\"repo\"])\n        move_to_new_cache(\n            file=os.path.join(cache_dir, file_info[\"file\"]),\n            repo=repo,\n            filename=url_info[\"filename\"],\n            revision=url_info[\"revision\"],\n            etag=etag,\n            commit_hash=commit_hash,\n        )\n\n\ncache_version_file = os.path.join(TRANSFORMERS_CACHE, \"version.txt\")\nif not os.path.isfile(cache_version_file):\n    cache_version = 0\nelse:\n    with open(cache_version_file) as f:\n        try:\n            cache_version = int(f.read())\n        except ValueError:\n            cache_version = 0\n\ncache_is_not_empty = os.path.isdir(TRANSFORMERS_CACHE) and len(os.listdir(TRANSFORMERS_CACHE)) > 0\n\nif cache_version < 1 and cache_is_not_empty:\n    if is_offline_mode():\n        logger.warning(\n            \"You are offline and the cache for model files in Transformers v4.22.0 has been updated while your local \"\n            \"cache seems to be the one of a previous version. It is very likely that all your calls to any \"\n            \"`from_pretrained()` method will fail. Remove the offline mode and enable internet connection to have \"\n            \"your cache be updated automatically, then you can go back to offline mode.\"\n        )\n    else:\n        logger.warning(\n            \"The cache for model files in Transformers v4.22.0 has been updated. Migrating your old cache. This is a \"\n            \"one-time only operation. You can interrupt this and resume the migration later on by calling \"\n            \"`transformers.utils.move_cache()`.\"\n        )\n    try:\n        if TRANSFORMERS_CACHE != default_cache_path:\n            # Users set some env variable to customize cache storage\n            move_cache(TRANSFORMERS_CACHE, TRANSFORMERS_CACHE)\n        else:\n            move_cache()\n    except Exception as e:\n        trace = \"\\n\".join(traceback.format_tb(e.__traceback__))\n        logger.error(\n            f\"There was a problem when trying to move your cache:\\n\\n{trace}\\n{e.__class__.__name__}: {e}\\n\\nPlease \"\n            \"file an issue at https://github.com/huggingface/transformers/issues/new/choose and copy paste this whole \"\n            \"message and we will do our best to help.\"\n        )\n\nif cache_version < 1:\n    try:\n        os.makedirs(TRANSFORMERS_CACHE, exist_ok=True)\n        with open(cache_version_file, \"w\") as f:\n            f.write(\"1\")\n    except Exception:\n        logger.warning(\n            f\"There was a problem when trying to write in your cache folder ({TRANSFORMERS_CACHE}). You should set \"\n            \"the environment variable TRANSFORMERS_CACHE to a writable directory.\"\n        )\n"], "fixing_code": ["# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nHub utilities: utilities related to download and cache models\n\"\"\"\nimport json\nimport os\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport traceback\nimport warnings\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union\nfrom urllib.parse import urlparse\nfrom uuid import uuid4\n\nimport huggingface_hub\nimport requests\nfrom huggingface_hub import (\n    CommitOperationAdd,\n    create_commit,\n    create_repo,\n    get_hf_file_metadata,\n    hf_hub_download,\n    hf_hub_url,\n    whoami,\n)\nfrom huggingface_hub.file_download import REGEX_COMMIT_HASH, http_get\nfrom huggingface_hub.utils import (\n    EntryNotFoundError,\n    LocalEntryNotFoundError,\n    RepositoryNotFoundError,\n    RevisionNotFoundError,\n    build_hf_headers,\n    hf_raise_for_status,\n)\nfrom requests.exceptions import HTTPError\n\nfrom . import __version__, logging\nfrom .generic import working_or_temp_dir\nfrom .import_utils import (\n    ENV_VARS_TRUE_VALUES,\n    _tf_version,\n    _torch_version,\n    is_tf_available,\n    is_torch_available,\n    is_training_run_on_sagemaker,\n)\nfrom .logging import tqdm\n\n\nlogger = logging.get_logger(__name__)  # pylint: disable=invalid-name\n\n_is_offline_mode = True if os.environ.get(\"TRANSFORMERS_OFFLINE\", \"0\").upper() in ENV_VARS_TRUE_VALUES else False\n\n\ndef is_offline_mode():\n    return _is_offline_mode\n\n\ntorch_cache_home = os.getenv(\"TORCH_HOME\", os.path.join(os.getenv(\"XDG_CACHE_HOME\", \"~/.cache\"), \"torch\"))\nold_default_cache_path = os.path.join(torch_cache_home, \"transformers\")\n# New default cache, shared with the Datasets library\nhf_cache_home = os.path.expanduser(\n    os.getenv(\"HF_HOME\", os.path.join(os.getenv(\"XDG_CACHE_HOME\", \"~/.cache\"), \"huggingface\"))\n)\ndefault_cache_path = os.path.join(hf_cache_home, \"hub\")\n\n# Onetime move from the old location to the new one if no ENV variable has been set.\nif (\n    os.path.isdir(old_default_cache_path)\n    and not os.path.isdir(default_cache_path)\n    and \"PYTORCH_PRETRAINED_BERT_CACHE\" not in os.environ\n    and \"PYTORCH_TRANSFORMERS_CACHE\" not in os.environ\n    and \"TRANSFORMERS_CACHE\" not in os.environ\n):\n    logger.warning(\n        \"In Transformers v4.0.0, the default path to cache downloaded models changed from\"\n        \" '~/.cache/torch/transformers' to '~/.cache/huggingface/transformers'. Since you don't seem to have\"\n        \" overridden and '~/.cache/torch/transformers' is a directory that exists, we're moving it to\"\n        \" '~/.cache/huggingface/transformers' to avoid redownloading models you have already in the cache. You should\"\n        \" only see this message once.\"\n    )\n    shutil.move(old_default_cache_path, default_cache_path)\n\nPYTORCH_PRETRAINED_BERT_CACHE = os.getenv(\"PYTORCH_PRETRAINED_BERT_CACHE\", default_cache_path)\nPYTORCH_TRANSFORMERS_CACHE = os.getenv(\"PYTORCH_TRANSFORMERS_CACHE\", PYTORCH_PRETRAINED_BERT_CACHE)\nHUGGINGFACE_HUB_CACHE = os.getenv(\"HUGGINGFACE_HUB_CACHE\", PYTORCH_TRANSFORMERS_CACHE)\nTRANSFORMERS_CACHE = os.getenv(\"TRANSFORMERS_CACHE\", HUGGINGFACE_HUB_CACHE)\nHF_MODULES_CACHE = os.getenv(\"HF_MODULES_CACHE\", os.path.join(hf_cache_home, \"modules\"))\nTRANSFORMERS_DYNAMIC_MODULE_NAME = \"transformers_modules\"\nSESSION_ID = uuid4().hex\nDISABLE_TELEMETRY = os.getenv(\"DISABLE_TELEMETRY\", False) in ENV_VARS_TRUE_VALUES\n\nS3_BUCKET_PREFIX = \"https://s3.amazonaws.com/models.huggingface.co/bert\"\nCLOUDFRONT_DISTRIB_PREFIX = \"https://cdn.huggingface.co\"\n\n_staging_mode = os.environ.get(\"HUGGINGFACE_CO_STAGING\", \"NO\").upper() in ENV_VARS_TRUE_VALUES\n_default_endpoint = \"https://hub-ci.huggingface.co\" if _staging_mode else \"https://huggingface.co\"\n\nHUGGINGFACE_CO_RESOLVE_ENDPOINT = _default_endpoint\nif os.environ.get(\"HUGGINGFACE_CO_RESOLVE_ENDPOINT\", None) is not None:\n    warnings.warn(\n        \"Using the environment variable `HUGGINGFACE_CO_RESOLVE_ENDPOINT` is deprecated and will be removed in \"\n        \"Transformers v5. Use `HF_ENDPOINT` instead.\",\n        FutureWarning,\n    )\n    HUGGINGFACE_CO_RESOLVE_ENDPOINT = os.environ.get(\"HUGGINGFACE_CO_RESOLVE_ENDPOINT\", None)\nHUGGINGFACE_CO_RESOLVE_ENDPOINT = os.environ.get(\"HF_ENDPOINT\", HUGGINGFACE_CO_RESOLVE_ENDPOINT)\nHUGGINGFACE_CO_PREFIX = HUGGINGFACE_CO_RESOLVE_ENDPOINT + \"/{model_id}/resolve/{revision}/{filename}\"\nHUGGINGFACE_CO_EXAMPLES_TELEMETRY = HUGGINGFACE_CO_RESOLVE_ENDPOINT + \"/api/telemetry/examples\"\n\n# Return value when trying to load a file from cache but the file does not exist in the distant repo.\n_CACHED_NO_EXIST = object()\n\n\ndef is_remote_url(url_or_filename):\n    parsed = urlparse(url_or_filename)\n    return parsed.scheme in (\"http\", \"https\")\n\n\ndef get_cached_models(cache_dir: Union[str, Path] = None) -> List[Tuple]:\n    \"\"\"\n    Returns a list of tuples representing model binaries that are cached locally. Each tuple has shape `(model_url,\n    etag, size_MB)`. Filenames in `cache_dir` are use to get the metadata for each model, only urls ending with *.bin*\n    are added.\n\n    Args:\n        cache_dir (`Union[str, Path]`, *optional*):\n            The cache directory to search for models within. Will default to the transformers cache if unset.\n\n    Returns:\n        List[Tuple]: List of tuples each with shape `(model_url, etag, size_MB)`\n    \"\"\"\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    elif isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n    if not os.path.isdir(cache_dir):\n        return []\n\n    cached_models = []\n    for file in os.listdir(cache_dir):\n        if file.endswith(\".json\"):\n            meta_path = os.path.join(cache_dir, file)\n            with open(meta_path, encoding=\"utf-8\") as meta_file:\n                metadata = json.load(meta_file)\n                url = metadata[\"url\"]\n                etag = metadata[\"etag\"]\n                if url.endswith(\".bin\"):\n                    size_MB = os.path.getsize(meta_path.strip(\".json\")) / 1e6\n                    cached_models.append((url, etag, size_MB))\n\n    return cached_models\n\n\ndef define_sagemaker_information():\n    try:\n        instance_data = requests.get(os.environ[\"ECS_CONTAINER_METADATA_URI\"]).json()\n        dlc_container_used = instance_data[\"Image\"]\n        dlc_tag = instance_data[\"Image\"].split(\":\")[1]\n    except Exception:\n        dlc_container_used = None\n        dlc_tag = None\n\n    sagemaker_params = json.loads(os.getenv(\"SM_FRAMEWORK_PARAMS\", \"{}\"))\n    runs_distributed_training = True if \"sagemaker_distributed_dataparallel_enabled\" in sagemaker_params else False\n    account_id = os.getenv(\"TRAINING_JOB_ARN\").split(\":\")[4] if \"TRAINING_JOB_ARN\" in os.environ else None\n\n    sagemaker_object = {\n        \"sm_framework\": os.getenv(\"SM_FRAMEWORK_MODULE\", None),\n        \"sm_region\": os.getenv(\"AWS_REGION\", None),\n        \"sm_number_gpu\": os.getenv(\"SM_NUM_GPUS\", 0),\n        \"sm_number_cpu\": os.getenv(\"SM_NUM_CPUS\", 0),\n        \"sm_distributed_training\": runs_distributed_training,\n        \"sm_deep_learning_container\": dlc_container_used,\n        \"sm_deep_learning_container_tag\": dlc_tag,\n        \"sm_account_id\": account_id,\n    }\n    return sagemaker_object\n\n\ndef http_user_agent(user_agent: Union[Dict, str, None] = None) -> str:\n    \"\"\"\n    Formats a user-agent string with basic info about a request.\n    \"\"\"\n    ua = f\"transformers/{__version__}; python/{sys.version.split()[0]}; session_id/{SESSION_ID}\"\n    if is_torch_available():\n        ua += f\"; torch/{_torch_version}\"\n    if is_tf_available():\n        ua += f\"; tensorflow/{_tf_version}\"\n    if DISABLE_TELEMETRY:\n        return ua + \"; telemetry/off\"\n    if is_training_run_on_sagemaker():\n        ua += \"; \" + \"; \".join(f\"{k}/{v}\" for k, v in define_sagemaker_information().items())\n    # CI will set this value to True\n    if os.environ.get(\"TRANSFORMERS_IS_CI\", \"\").upper() in ENV_VARS_TRUE_VALUES:\n        ua += \"; is_ci/true\"\n    if isinstance(user_agent, dict):\n        ua += \"; \" + \"; \".join(f\"{k}/{v}\" for k, v in user_agent.items())\n    elif isinstance(user_agent, str):\n        ua += \"; \" + user_agent\n    return ua\n\n\ndef extract_commit_hash(resolved_file: Optional[str], commit_hash: Optional[str]):\n    \"\"\"\n    Extracts the commit hash from a resolved filename toward a cache file.\n    \"\"\"\n    if resolved_file is None or commit_hash is not None:\n        return commit_hash\n    resolved_file = str(Path(resolved_file).as_posix())\n    search = re.search(r\"snapshots/([^/]+)/\", resolved_file)\n    if search is None:\n        return None\n    commit_hash = search.groups()[0]\n    return commit_hash if REGEX_COMMIT_HASH.match(commit_hash) else None\n\n\ndef try_to_load_from_cache(\n    repo_id: str,\n    filename: str,\n    cache_dir: Union[str, Path, None] = None,\n    revision: Optional[str] = None,\n    repo_type: Optional[str] = None,\n) -> Optional[str]:\n    \"\"\"\n    Explores the cache to return the latest cached file for a given revision if found.\n\n    This function will not raise any exception if the file in not cached.\n\n    Args:\n        cache_dir (`str` or `os.PathLike`):\n            The folder where the cached files lie.\n        repo_id (`str`):\n            The ID of the repo on huggingface.co.\n        filename (`str`):\n            The filename to look for inside `repo_id`.\n        revision (`str`, *optional*):\n            The specific model version to use. Will default to `\"main\"` if it's not provided and no `commit_hash` is\n            provided either.\n        repo_type (`str`, *optional*):\n            The type of the repo.\n\n    Returns:\n        `Optional[str]` or `_CACHED_NO_EXIST`:\n            Will return `None` if the file was not cached. Otherwise:\n            - The exact path to the cached file if it's found in the cache\n            - A special value `_CACHED_NO_EXIST` if the file does not exist at the given commit hash and this fact was\n              cached.\n    \"\"\"\n    if revision is None:\n        revision = \"main\"\n\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n\n    object_id = repo_id.replace(\"/\", \"--\")\n    if repo_type is None:\n        repo_type = \"model\"\n    repo_cache = os.path.join(cache_dir, f\"{repo_type}s--{object_id}\")\n    if not os.path.isdir(repo_cache):\n        # No cache for this model\n        return None\n    for subfolder in [\"refs\", \"snapshots\"]:\n        if not os.path.isdir(os.path.join(repo_cache, subfolder)):\n            return None\n\n    # Resolve refs (for instance to convert main to the associated commit sha)\n    cached_refs = os.listdir(os.path.join(repo_cache, \"refs\"))\n    if revision in cached_refs:\n        with open(os.path.join(repo_cache, \"refs\", revision)) as f:\n            revision = f.read()\n\n    if os.path.isfile(os.path.join(repo_cache, \".no_exist\", revision, filename)):\n        return _CACHED_NO_EXIST\n\n    cached_shas = os.listdir(os.path.join(repo_cache, \"snapshots\"))\n    if revision not in cached_shas:\n        # No cache for this revision and we won't try to return a random revision\n        return None\n\n    cached_file = os.path.join(repo_cache, \"snapshots\", revision, filename)\n    return cached_file if os.path.isfile(cached_file) else None\n\n\ndef cached_file(\n    path_or_repo_id: Union[str, os.PathLike],\n    filename: str,\n    cache_dir: Optional[Union[str, os.PathLike]] = None,\n    force_download: bool = False,\n    resume_download: bool = False,\n    proxies: Optional[Dict[str, str]] = None,\n    use_auth_token: Optional[Union[bool, str]] = None,\n    revision: Optional[str] = None,\n    local_files_only: bool = False,\n    subfolder: str = \"\",\n    repo_type: Optional[str] = None,\n    user_agent: Optional[Union[str, Dict[str, str]]] = None,\n    _raise_exceptions_for_missing_entries: bool = True,\n    _raise_exceptions_for_connection_errors: bool = True,\n    _commit_hash: Optional[str] = None,\n):\n    \"\"\"\n    Tries to locate a file in a local folder and repo, downloads and cache it if necessary.\n\n    Args:\n        path_or_repo_id (`str` or `os.PathLike`):\n            This can be either:\n\n            - a string, the *model id* of a model repo on huggingface.co.\n            - a path to a *directory* potentially containing the file.\n        filename (`str`):\n            The name of the file to locate in `path_or_repo`.\n        cache_dir (`str` or `os.PathLike`, *optional*):\n            Path to a directory in which a downloaded pretrained model configuration should be cached if the standard\n            cache should not be used.\n        force_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to force to (re-)download the configuration files and override the cached versions if they\n            exist.\n        resume_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to delete incompletely received file. Attempts to resume the download if such a file exists.\n        proxies (`Dict[str, str]`, *optional*):\n            A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',\n            'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.\n        use_auth_token (`str` or *bool*, *optional*):\n            The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated\n            when running `huggingface-cli login` (stored in `~/.huggingface`).\n        revision (`str`, *optional*, defaults to `\"main\"`):\n            The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a\n            git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any\n            identifier allowed by git.\n        local_files_only (`bool`, *optional*, defaults to `False`):\n            If `True`, will only try to load the tokenizer configuration from local files.\n        subfolder (`str`, *optional*, defaults to `\"\"`):\n            In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can\n            specify the folder name here.\n        repo_type (`str`, *optional*):\n            Specify the repo type (useful when downloading from a space for instance).\n\n    <Tip>\n\n    Passing `use_auth_token=True` is required when you want to use a private model.\n\n    </Tip>\n\n    Returns:\n        `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).\n\n    Examples:\n\n    ```python\n    # Download a model weight from the Hub and cache it.\n    model_weights_file = cached_file(\"bert-base-uncased\", \"pytorch_model.bin\")\n    ```\"\"\"\n    # Private arguments\n    #     _raise_exceptions_for_missing_entries: if False, do not raise an exception for missing entries but return\n    #         None.\n    #     _raise_exceptions_for_connection_errors: if False, do not raise an exception for connection errors but return\n    #         None.\n    #     _commit_hash: passed when we are chaining several calls to various files (e.g. when loading a tokenizer or\n    #         a pipeline). If files are cached for this commit hash, avoid calls to head and get from the cache.\n    if is_offline_mode() and not local_files_only:\n        logger.info(\"Offline mode: forcing local_files_only=True\")\n        local_files_only = True\n    if subfolder is None:\n        subfolder = \"\"\n\n    path_or_repo_id = str(path_or_repo_id)\n    full_filename = os.path.join(subfolder, filename)\n    if os.path.isdir(path_or_repo_id):\n        resolved_file = os.path.join(os.path.join(path_or_repo_id, subfolder), filename)\n        if not os.path.isfile(resolved_file):\n            if _raise_exceptions_for_missing_entries:\n                raise EnvironmentError(\n                    f\"{path_or_repo_id} does not appear to have a file named {full_filename}. Checkout \"\n                    f\"'https://huggingface.co/{path_or_repo_id}/{revision}' for available files.\"\n                )\n            else:\n                return None\n        return resolved_file\n\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    if isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    if _commit_hash is not None and not force_download:\n        # If the file is cached under that commit hash, we return it directly.\n        resolved_file = try_to_load_from_cache(\n            path_or_repo_id, full_filename, cache_dir=cache_dir, revision=_commit_hash, repo_type=repo_type\n        )\n        if resolved_file is not None:\n            if resolved_file is not _CACHED_NO_EXIST:\n                return resolved_file\n            elif not _raise_exceptions_for_missing_entries:\n                return None\n            else:\n                raise EnvironmentError(f\"Could not locate {full_filename} inside {path_or_repo_id}.\")\n\n    user_agent = http_user_agent(user_agent)\n    try:\n        # Load from URL or cache if already cached\n        resolved_file = hf_hub_download(\n            path_or_repo_id,\n            filename,\n            subfolder=None if len(subfolder) == 0 else subfolder,\n            repo_type=repo_type,\n            revision=revision,\n            cache_dir=cache_dir,\n            user_agent=user_agent,\n            force_download=force_download,\n            proxies=proxies,\n            resume_download=resume_download,\n            use_auth_token=use_auth_token,\n            local_files_only=local_files_only,\n        )\n\n    except RepositoryNotFoundError:\n        raise EnvironmentError(\n            f\"{path_or_repo_id} is not a local folder and is not a valid model identifier \"\n            \"listed on 'https://huggingface.co/models'\\nIf this is a private repository, make sure to \"\n            \"pass a token having permission to this repo with `use_auth_token` or log in with \"\n            \"`huggingface-cli login` and pass `use_auth_token=True`.\"\n        )\n    except RevisionNotFoundError:\n        raise EnvironmentError(\n            f\"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists \"\n            \"for this model name. Check the model page at \"\n            f\"'https://huggingface.co/{path_or_repo_id}' for available revisions.\"\n        )\n    except LocalEntryNotFoundError:\n        # We try to see if we have a cached version (not up to date):\n        resolved_file = try_to_load_from_cache(path_or_repo_id, full_filename, cache_dir=cache_dir, revision=revision)\n        if resolved_file is not None and resolved_file != _CACHED_NO_EXIST:\n            return resolved_file\n        if not _raise_exceptions_for_missing_entries or not _raise_exceptions_for_connection_errors:\n            return None\n        raise EnvironmentError(\n            f\"We couldn't connect to '{HUGGINGFACE_CO_RESOLVE_ENDPOINT}' to load this file, couldn't find it in the\"\n            f\" cached files and it looks like {path_or_repo_id} is not the path to a directory containing a file named\"\n            f\" {full_filename}.\\nCheckout your internet connection or see how to run the library in offline mode at\"\n            \" 'https://huggingface.co/docs/transformers/installation#offline-mode'.\"\n        )\n    except EntryNotFoundError:\n        if not _raise_exceptions_for_missing_entries:\n            return None\n        if revision is None:\n            revision = \"main\"\n        raise EnvironmentError(\n            f\"{path_or_repo_id} does not appear to have a file named {full_filename}. Checkout \"\n            f\"'https://huggingface.co/{path_or_repo_id}/{revision}' for available files.\"\n        )\n    except HTTPError as err:\n        # First we try to see if we have a cached version (not up to date):\n        resolved_file = try_to_load_from_cache(path_or_repo_id, full_filename, cache_dir=cache_dir, revision=revision)\n        if resolved_file is not None and resolved_file != _CACHED_NO_EXIST:\n            return resolved_file\n        if not _raise_exceptions_for_connection_errors:\n            return None\n\n        raise EnvironmentError(f\"There was a specific connection error when trying to load {path_or_repo_id}:\\n{err}\")\n\n    return resolved_file\n\n\ndef get_file_from_repo(\n    path_or_repo: Union[str, os.PathLike],\n    filename: str,\n    cache_dir: Optional[Union[str, os.PathLike]] = None,\n    force_download: bool = False,\n    resume_download: bool = False,\n    proxies: Optional[Dict[str, str]] = None,\n    use_auth_token: Optional[Union[bool, str]] = None,\n    revision: Optional[str] = None,\n    local_files_only: bool = False,\n    subfolder: str = \"\",\n):\n    \"\"\"\n    Tries to locate a file in a local folder and repo, downloads and cache it if necessary.\n\n    Args:\n        path_or_repo (`str` or `os.PathLike`):\n            This can be either:\n\n            - a string, the *model id* of a model repo on huggingface.co.\n            - a path to a *directory* potentially containing the file.\n        filename (`str`):\n            The name of the file to locate in `path_or_repo`.\n        cache_dir (`str` or `os.PathLike`, *optional*):\n            Path to a directory in which a downloaded pretrained model configuration should be cached if the standard\n            cache should not be used.\n        force_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to force to (re-)download the configuration files and override the cached versions if they\n            exist.\n        resume_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to delete incompletely received file. Attempts to resume the download if such a file exists.\n        proxies (`Dict[str, str]`, *optional*):\n            A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',\n            'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.\n        use_auth_token (`str` or *bool*, *optional*):\n            The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated\n            when running `huggingface-cli login` (stored in `~/.huggingface`).\n        revision (`str`, *optional*, defaults to `\"main\"`):\n            The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a\n            git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any\n            identifier allowed by git.\n        local_files_only (`bool`, *optional*, defaults to `False`):\n            If `True`, will only try to load the tokenizer configuration from local files.\n        subfolder (`str`, *optional*, defaults to `\"\"`):\n            In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can\n            specify the folder name here.\n\n    <Tip>\n\n    Passing `use_auth_token=True` is required when you want to use a private model.\n\n    </Tip>\n\n    Returns:\n        `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo) or `None` if the\n        file does not exist.\n\n    Examples:\n\n    ```python\n    # Download a tokenizer configuration from huggingface.co and cache.\n    tokenizer_config = get_file_from_repo(\"bert-base-uncased\", \"tokenizer_config.json\")\n    # This model does not have a tokenizer config so the result will be None.\n    tokenizer_config = get_file_from_repo(\"xlm-roberta-base\", \"tokenizer_config.json\")\n    ```\"\"\"\n    return cached_file(\n        path_or_repo_id=path_or_repo,\n        filename=filename,\n        cache_dir=cache_dir,\n        force_download=force_download,\n        resume_download=resume_download,\n        proxies=proxies,\n        use_auth_token=use_auth_token,\n        revision=revision,\n        local_files_only=local_files_only,\n        subfolder=subfolder,\n        _raise_exceptions_for_missing_entries=False,\n        _raise_exceptions_for_connection_errors=False,\n    )\n\n\ndef download_url(url, proxies=None):\n    \"\"\"\n    Downloads a given url in a temporary file. This function is not safe to use in multiple processes. Its only use is\n    for deprecated behavior allowing to download config/models with a single url instead of using the Hub.\n\n    Args:\n        url (`str`): The url of the file to download.\n        proxies (`Dict[str, str]`, *optional*):\n            A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',\n            'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.\n\n    Returns:\n        `str`: The location of the temporary file where the url was downloaded.\n    \"\"\"\n    warnings.warn(\n        f\"Using `from_pretrained` with the url of a file (here {url}) is deprecated and won't be possible anymore in\"\n        \" v5 of Transformers. You should host your file on the Hub (hf.co) instead and use the repository ID. Note\"\n        \" that this is not compatible with the caching system (your file will be downloaded at each execution) or\"\n        \" multiple processes (each process will download the file in a different temporary file).\"\n    )\n    tmp_file = tempfile.mkstemp()[1]\n    with open(tmp_file, \"wb\") as f:\n        http_get(url, f, proxies=proxies)\n    return tmp_file\n\n\ndef has_file(\n    path_or_repo: Union[str, os.PathLike],\n    filename: str,\n    revision: Optional[str] = None,\n    proxies: Optional[Dict[str, str]] = None,\n    use_auth_token: Optional[Union[bool, str]] = None,\n):\n    \"\"\"\n    Checks if a repo contains a given file without downloading it. Works for remote repos and local folders.\n\n    <Tip warning={false}>\n\n    This function will raise an error if the repository `path_or_repo` is not valid or if `revision` does not exist for\n    this repo, but will return False for regular connection errors.\n\n    </Tip>\n    \"\"\"\n    if os.path.isdir(path_or_repo):\n        return os.path.isfile(os.path.join(path_or_repo, filename))\n\n    url = hf_hub_url(path_or_repo, filename=filename, revision=revision)\n    headers = build_hf_headers(use_auth_token=use_auth_token, user_agent=http_user_agent())\n\n    r = requests.head(url, headers=headers, allow_redirects=False, proxies=proxies, timeout=10)\n    try:\n        hf_raise_for_status(r)\n        return True\n    except RepositoryNotFoundError as e:\n        logger.error(e)\n        raise EnvironmentError(f\"{path_or_repo} is not a local folder or a valid repository name on 'https://hf.co'.\")\n    except RevisionNotFoundError as e:\n        logger.error(e)\n        raise EnvironmentError(\n            f\"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists for this \"\n            f\"model name. Check the model page at 'https://huggingface.co/{path_or_repo}' for available revisions.\"\n        )\n    except requests.HTTPError:\n        # We return false for EntryNotFoundError (logical) as well as any connection error.\n        return False\n\n\nclass PushToHubMixin:\n    \"\"\"\n    A Mixin containing the functionality to push a model or tokenizer to the hub.\n    \"\"\"\n\n    def _create_repo(\n        self,\n        repo_id: str,\n        private: Optional[bool] = None,\n        use_auth_token: Optional[Union[bool, str]] = None,\n        repo_url: Optional[str] = None,\n        organization: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Create the repo if needed, cleans up repo_id with deprecated kwargs `repo_url` and `organization`, retrieves\n        the token.\n        \"\"\"\n        if repo_url is not None:\n            warnings.warn(\n                \"The `repo_url` argument is deprecated and will be removed in v5 of Transformers. Use `repo_id` \"\n                \"instead.\"\n            )\n            repo_id = repo_url.replace(f\"{HUGGINGFACE_CO_RESOLVE_ENDPOINT}/\", \"\")\n        if organization is not None:\n            warnings.warn(\n                \"The `organization` argument is deprecated and will be removed in v5 of Transformers. Set your \"\n                \"organization directly in the `repo_id` passed instead (`repo_id={organization}/{model_id}`).\"\n            )\n            if not repo_id.startswith(organization):\n                if \"/\" in repo_id:\n                    repo_id = repo_id.split(\"/\")[-1]\n                repo_id = f\"{organization}/{repo_id}\"\n\n        url = create_repo(repo_id=repo_id, token=use_auth_token, private=private, exist_ok=True)\n\n        # If the namespace is not there, add it or `upload_file` will complain\n        if \"/\" not in repo_id and url != f\"{HUGGINGFACE_CO_RESOLVE_ENDPOINT}/{repo_id}\":\n            repo_id = get_full_repo_name(repo_id, token=use_auth_token)\n        return repo_id\n\n    def _get_files_timestamps(self, working_dir: Union[str, os.PathLike]):\n        \"\"\"\n        Returns the list of files with their last modification timestamp.\n        \"\"\"\n        return {f: os.path.getmtime(os.path.join(working_dir, f)) for f in os.listdir(working_dir)}\n\n    def _upload_modified_files(\n        self,\n        working_dir: Union[str, os.PathLike],\n        repo_id: str,\n        files_timestamps: Dict[str, float],\n        commit_message: Optional[str] = None,\n        token: Optional[Union[bool, str]] = None,\n        create_pr: bool = False,\n    ):\n        \"\"\"\n        Uploads all modified files in `working_dir` to `repo_id`, based on `files_timestamps`.\n        \"\"\"\n        if commit_message is None:\n            if \"Model\" in self.__class__.__name__:\n                commit_message = \"Upload model\"\n            elif \"Config\" in self.__class__.__name__:\n                commit_message = \"Upload config\"\n            elif \"Tokenizer\" in self.__class__.__name__:\n                commit_message = \"Upload tokenizer\"\n            elif \"FeatureExtractor\" in self.__class__.__name__:\n                commit_message = \"Upload feature extractor\"\n            elif \"Processor\" in self.__class__.__name__:\n                commit_message = \"Upload processor\"\n            else:\n                commit_message = f\"Upload {self.__class__.__name__}\"\n        modified_files = [\n            f\n            for f in os.listdir(working_dir)\n            if f not in files_timestamps or os.path.getmtime(os.path.join(working_dir, f)) > files_timestamps[f]\n        ]\n        operations = []\n        for file in modified_files:\n            operations.append(CommitOperationAdd(path_or_fileobj=os.path.join(working_dir, file), path_in_repo=file))\n        logger.info(f\"Uploading the following files to {repo_id}: {','.join(modified_files)}\")\n        return create_commit(\n            repo_id=repo_id, operations=operations, commit_message=commit_message, token=token, create_pr=create_pr\n        )\n\n    def push_to_hub(\n        self,\n        repo_id: str,\n        use_temp_dir: Optional[bool] = None,\n        commit_message: Optional[str] = None,\n        private: Optional[bool] = None,\n        use_auth_token: Optional[Union[bool, str]] = None,\n        max_shard_size: Optional[Union[int, str]] = \"10GB\",\n        create_pr: bool = False,\n        **deprecated_kwargs,\n    ) -> str:\n        \"\"\"\n        Upload the {object_files} to the \ud83e\udd17 Model Hub while synchronizing a local clone of the repo in\n        `repo_path_or_name`.\n\n        Parameters:\n            repo_id (`str`):\n                The name of the repository you want to push your {object} to. It should contain your organization name\n                when pushing to a given organization.\n            use_temp_dir (`bool`, *optional*):\n                Whether or not to use a temporary directory to store the files saved before they are pushed to the Hub.\n                Will default to `True` if there is no directory named like `repo_id`, `False` otherwise.\n            commit_message (`str`, *optional*):\n                Message to commit while pushing. Will default to `\"Upload {object}\"`.\n            private (`bool`, *optional*):\n                Whether or not the repository created should be private.\n            use_auth_token (`bool` or `str`, *optional*):\n                The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated\n                when running `huggingface-cli login` (stored in `~/.huggingface`). Will default to `True` if `repo_url`\n                is not specified.\n            max_shard_size (`int` or `str`, *optional*, defaults to `\"10GB\"`):\n                Only applicable for models. The maximum size for a checkpoint before being sharded. Checkpoints shard\n                will then be each of size lower than this size. If expressed as a string, needs to be digits followed\n                by a unit (like `\"5MB\"`).\n            create_pr (`bool`, *optional*, defaults to `False`):\n                Whether or not to create a PR with the uploaded files or directly commit.\n\n        Examples:\n\n        ```python\n        from transformers import {object_class}\n\n        {object} = {object_class}.from_pretrained(\"bert-base-cased\")\n\n        # Push the {object} to your namespace with the name \"my-finetuned-bert\".\n        {object}.push_to_hub(\"my-finetuned-bert\")\n\n        # Push the {object} to an organization with the name \"my-finetuned-bert\".\n        {object}.push_to_hub(\"huggingface/my-finetuned-bert\")\n        ```\n        \"\"\"\n        if \"repo_path_or_name\" in deprecated_kwargs:\n            warnings.warn(\n                \"The `repo_path_or_name` argument is deprecated and will be removed in v5 of Transformers. Use \"\n                \"`repo_id` instead.\"\n            )\n            repo_id = deprecated_kwargs.pop(\"repo_path_or_name\")\n        # Deprecation warning will be sent after for repo_url and organization\n        repo_url = deprecated_kwargs.pop(\"repo_url\", None)\n        organization = deprecated_kwargs.pop(\"organization\", None)\n\n        if os.path.isdir(repo_id):\n            working_dir = repo_id\n            repo_id = repo_id.split(os.path.sep)[-1]\n        else:\n            working_dir = repo_id.split(\"/\")[-1]\n\n        repo_id = self._create_repo(\n            repo_id, private=private, use_auth_token=use_auth_token, repo_url=repo_url, organization=organization\n        )\n\n        if use_temp_dir is None:\n            use_temp_dir = not os.path.isdir(working_dir)\n\n        with working_or_temp_dir(working_dir=working_dir, use_temp_dir=use_temp_dir) as work_dir:\n            files_timestamps = self._get_files_timestamps(work_dir)\n\n            # Save all files.\n            self.save_pretrained(work_dir, max_shard_size=max_shard_size)\n\n            return self._upload_modified_files(\n                work_dir,\n                repo_id,\n                files_timestamps,\n                commit_message=commit_message,\n                token=use_auth_token,\n                create_pr=create_pr,\n            )\n\n\ndef get_full_repo_name(model_id: str, organization: Optional[str] = None, token: Optional[str] = None):\n    if organization is None:\n        username = whoami(token)[\"name\"]\n        return f\"{username}/{model_id}\"\n    else:\n        return f\"{organization}/{model_id}\"\n\n\ndef send_example_telemetry(example_name, *example_args, framework=\"pytorch\"):\n    \"\"\"\n    Sends telemetry that helps tracking the examples use.\n\n    Args:\n        example_name (`str`): The name of the example.\n        *example_args (dataclasses or `argparse.ArgumentParser`): The arguments to the script. This function will only\n            try to extract the model and dataset name from those. Nothing else is tracked.\n        framework (`str`, *optional*, defaults to `\"pytorch\"`): The framework for the example.\n    \"\"\"\n    if is_offline_mode():\n        return\n\n    data = {\"example\": example_name, \"framework\": framework}\n    for args in example_args:\n        args_as_dict = {k: v for k, v in args.__dict__.items() if not k.startswith(\"_\") and v is not None}\n        if \"model_name_or_path\" in args_as_dict:\n            model_name = args_as_dict[\"model_name_or_path\"]\n            # Filter out local paths\n            if not os.path.isdir(model_name):\n                data[\"model_name\"] = args_as_dict[\"model_name_or_path\"]\n        if \"dataset_name\" in args_as_dict:\n            data[\"dataset_name\"] = args_as_dict[\"dataset_name\"]\n        elif \"task_name\" in args_as_dict:\n            # Extract script name from the example_name\n            script_name = example_name.replace(\"tf_\", \"\").replace(\"flax_\", \"\").replace(\"run_\", \"\")\n            script_name = script_name.replace(\"_no_trainer\", \"\")\n            data[\"dataset_name\"] = f\"{script_name}-{args_as_dict['task_name']}\"\n\n    headers = {\"user-agent\": http_user_agent(data)}\n    try:\n        r = requests.head(HUGGINGFACE_CO_EXAMPLES_TELEMETRY, headers=headers)\n        r.raise_for_status()\n    except Exception:\n        # We don't want to error in case of connection errors of any kind.\n        pass\n\n\ndef convert_file_size_to_int(size: Union[int, str]):\n    \"\"\"\n    Converts a size expressed as a string with digits an unit (like `\"5MB\"`) to an integer (in bytes).\n\n    Args:\n        size (`int` or `str`): The size to convert. Will be directly returned if an `int`.\n\n    Example:\n    ```py\n    >>> convert_file_size_to_int(\"1MiB\")\n    1048576\n    ```\n    \"\"\"\n    if isinstance(size, int):\n        return size\n    if size.upper().endswith(\"GIB\"):\n        return int(size[:-3]) * (2**30)\n    if size.upper().endswith(\"MIB\"):\n        return int(size[:-3]) * (2**20)\n    if size.upper().endswith(\"KIB\"):\n        return int(size[:-3]) * (2**10)\n    if size.upper().endswith(\"GB\"):\n        int_size = int(size[:-2]) * (10**9)\n        return int_size // 8 if size.endswith(\"b\") else int_size\n    if size.upper().endswith(\"MB\"):\n        int_size = int(size[:-2]) * (10**6)\n        return int_size // 8 if size.endswith(\"b\") else int_size\n    if size.upper().endswith(\"KB\"):\n        int_size = int(size[:-2]) * (10**3)\n        return int_size // 8 if size.endswith(\"b\") else int_size\n    raise ValueError(\"`size` is not in a valid format. Use an integer followed by the unit, e.g., '5GB'.\")\n\n\ndef get_checkpoint_shard_files(\n    pretrained_model_name_or_path,\n    index_filename,\n    cache_dir=None,\n    force_download=False,\n    proxies=None,\n    resume_download=False,\n    local_files_only=False,\n    use_auth_token=None,\n    user_agent=None,\n    revision=None,\n    subfolder=\"\",\n    _commit_hash=None,\n):\n    \"\"\"\n    For a given model:\n\n    - download and cache all the shards of a sharded checkpoint if `pretrained_model_name_or_path` is a model ID on the\n      Hub\n    - returns the list of paths to all the shards, as well as some metadata.\n\n    For the description of each arg, see [`PreTrainedModel.from_pretrained`]. `index_filename` is the full path to the\n    index (downloaded and cached if `pretrained_model_name_or_path` is a model ID on the Hub).\n    \"\"\"\n    import json\n\n    if not os.path.isfile(index_filename):\n        raise ValueError(f\"Can't find a checkpoint index ({index_filename}) in {pretrained_model_name_or_path}.\")\n\n    with open(index_filename, \"r\") as f:\n        index = json.loads(f.read())\n\n    shard_filenames = sorted(set(index[\"weight_map\"].values()))\n    sharded_metadata = index[\"metadata\"]\n    sharded_metadata[\"all_checkpoint_keys\"] = list(index[\"weight_map\"].keys())\n    sharded_metadata[\"weight_map\"] = index[\"weight_map\"].copy()\n\n    # First, let's deal with local folder.\n    if os.path.isdir(pretrained_model_name_or_path):\n        shard_filenames = [os.path.join(pretrained_model_name_or_path, subfolder, f) for f in shard_filenames]\n        return shard_filenames, sharded_metadata\n\n    # At this stage pretrained_model_name_or_path is a model identifier on the Hub\n    cached_filenames = []\n    # Check if the model is already cached or not. We only try the last checkpoint, this should cover most cases of\n    # downloaded (if interrupted).\n    last_shard = try_to_load_from_cache(\n        pretrained_model_name_or_path, shard_filenames[-1], cache_dir=cache_dir, revision=_commit_hash\n    )\n    show_progress_bar = last_shard is None or force_download\n    for shard_filename in tqdm(shard_filenames, desc=\"Downloading shards\", disable=not show_progress_bar):\n        try:\n            # Load from URL\n            cached_filename = cached_file(\n                pretrained_model_name_or_path,\n                shard_filename,\n                cache_dir=cache_dir,\n                force_download=force_download,\n                proxies=proxies,\n                resume_download=resume_download,\n                local_files_only=local_files_only,\n                use_auth_token=use_auth_token,\n                user_agent=user_agent,\n                revision=revision,\n                subfolder=subfolder,\n                _commit_hash=_commit_hash,\n            )\n        # We have already dealt with RepositoryNotFoundError and RevisionNotFoundError when getting the index, so\n        # we don't have to catch them here.\n        except EntryNotFoundError:\n            raise EnvironmentError(\n                f\"{pretrained_model_name_or_path} does not appear to have a file named {shard_filename} which is \"\n                \"required according to the checkpoint index.\"\n            )\n        except HTTPError:\n            raise EnvironmentError(\n                f\"We couldn't connect to '{HUGGINGFACE_CO_RESOLVE_ENDPOINT}' to load {shard_filename}. You should try\"\n                \" again after checking your internet connection.\"\n            )\n\n        cached_filenames.append(cached_filename)\n\n    return cached_filenames, sharded_metadata\n\n\n# All what is below is for conversion between old cache format and new cache format.\n\n\ndef get_all_cached_files(cache_dir=None):\n    \"\"\"\n    Returns a list for all files cached with appropriate metadata.\n    \"\"\"\n    if cache_dir is None:\n        cache_dir = TRANSFORMERS_CACHE\n    else:\n        cache_dir = str(cache_dir)\n    if not os.path.isdir(cache_dir):\n        return []\n\n    cached_files = []\n    for file in os.listdir(cache_dir):\n        meta_path = os.path.join(cache_dir, f\"{file}.json\")\n        if not os.path.isfile(meta_path):\n            continue\n\n        with open(meta_path, encoding=\"utf-8\") as meta_file:\n            metadata = json.load(meta_file)\n            url = metadata[\"url\"]\n            etag = metadata[\"etag\"].replace('\"', \"\")\n            cached_files.append({\"file\": file, \"url\": url, \"etag\": etag})\n\n    return cached_files\n\n\ndef extract_info_from_url(url):\n    \"\"\"\n    Extract repo_name, revision and filename from an url.\n    \"\"\"\n    search = re.search(r\"^https://huggingface\\.co/(.*)/resolve/([^/]*)/(.*)$\", url)\n    if search is None:\n        return None\n    repo, revision, filename = search.groups()\n    cache_repo = \"--\".join([\"models\"] + repo.split(\"/\"))\n    return {\"repo\": cache_repo, \"revision\": revision, \"filename\": filename}\n\n\ndef clean_files_for(file):\n    \"\"\"\n    Remove, if they exist, file, file.json and file.lock\n    \"\"\"\n    for f in [file, f\"{file}.json\", f\"{file}.lock\"]:\n        if os.path.isfile(f):\n            os.remove(f)\n\n\ndef move_to_new_cache(file, repo, filename, revision, etag, commit_hash):\n    \"\"\"\n    Move file to repo following the new huggingface hub cache organization.\n    \"\"\"\n    os.makedirs(repo, exist_ok=True)\n\n    # refs\n    os.makedirs(os.path.join(repo, \"refs\"), exist_ok=True)\n    if revision != commit_hash:\n        ref_path = os.path.join(repo, \"refs\", revision)\n        with open(ref_path, \"w\") as f:\n            f.write(commit_hash)\n\n    # blobs\n    os.makedirs(os.path.join(repo, \"blobs\"), exist_ok=True)\n    blob_path = os.path.join(repo, \"blobs\", etag)\n    shutil.move(file, blob_path)\n\n    # snapshots\n    os.makedirs(os.path.join(repo, \"snapshots\"), exist_ok=True)\n    os.makedirs(os.path.join(repo, \"snapshots\", commit_hash), exist_ok=True)\n    pointer_path = os.path.join(repo, \"snapshots\", commit_hash, filename)\n    huggingface_hub.file_download._create_relative_symlink(blob_path, pointer_path)\n    clean_files_for(file)\n\n\ndef move_cache(cache_dir=None, new_cache_dir=None, token=None):\n    if new_cache_dir is None:\n        new_cache_dir = TRANSFORMERS_CACHE\n    if cache_dir is None:\n        # Migrate from old cache in .cache/huggingface/hub\n        old_cache = Path(TRANSFORMERS_CACHE).parent / \"transformers\"\n        if os.path.isdir(str(old_cache)):\n            cache_dir = str(old_cache)\n        else:\n            cache_dir = new_cache_dir\n    cached_files = get_all_cached_files(cache_dir=cache_dir)\n    logger.info(f\"Moving {len(cached_files)} files to the new cache system\")\n\n    hub_metadata = {}\n    for file_info in tqdm(cached_files):\n        url = file_info.pop(\"url\")\n        if url not in hub_metadata:\n            try:\n                hub_metadata[url] = get_hf_file_metadata(url, token=token)\n            except requests.HTTPError:\n                continue\n\n        etag, commit_hash = hub_metadata[url].etag, hub_metadata[url].commit_hash\n        if etag is None or commit_hash is None:\n            continue\n\n        if file_info[\"etag\"] != etag:\n            # Cached file is not up to date, we just throw it as a new version will be downloaded anyway.\n            clean_files_for(os.path.join(cache_dir, file_info[\"file\"]))\n            continue\n\n        url_info = extract_info_from_url(url)\n        if url_info is None:\n            # Not a file from huggingface.co\n            continue\n\n        repo = os.path.join(new_cache_dir, url_info[\"repo\"])\n        move_to_new_cache(\n            file=os.path.join(cache_dir, file_info[\"file\"]),\n            repo=repo,\n            filename=url_info[\"filename\"],\n            revision=url_info[\"revision\"],\n            etag=etag,\n            commit_hash=commit_hash,\n        )\n\n\ncache_version_file = os.path.join(TRANSFORMERS_CACHE, \"version.txt\")\nif not os.path.isfile(cache_version_file):\n    cache_version = 0\nelse:\n    with open(cache_version_file) as f:\n        try:\n            cache_version = int(f.read())\n        except ValueError:\n            cache_version = 0\n\ncache_is_not_empty = os.path.isdir(TRANSFORMERS_CACHE) and len(os.listdir(TRANSFORMERS_CACHE)) > 0\n\nif cache_version < 1 and cache_is_not_empty:\n    if is_offline_mode():\n        logger.warning(\n            \"You are offline and the cache for model files in Transformers v4.22.0 has been updated while your local \"\n            \"cache seems to be the one of a previous version. It is very likely that all your calls to any \"\n            \"`from_pretrained()` method will fail. Remove the offline mode and enable internet connection to have \"\n            \"your cache be updated automatically, then you can go back to offline mode.\"\n        )\n    else:\n        logger.warning(\n            \"The cache for model files in Transformers v4.22.0 has been updated. Migrating your old cache. This is a \"\n            \"one-time only operation. You can interrupt this and resume the migration later on by calling \"\n            \"`transformers.utils.move_cache()`.\"\n        )\n    try:\n        if TRANSFORMERS_CACHE != default_cache_path:\n            # Users set some env variable to customize cache storage\n            move_cache(TRANSFORMERS_CACHE, TRANSFORMERS_CACHE)\n        else:\n            move_cache()\n    except Exception as e:\n        trace = \"\\n\".join(traceback.format_tb(e.__traceback__))\n        logger.error(\n            f\"There was a problem when trying to move your cache:\\n\\n{trace}\\n{e.__class__.__name__}: {e}\\n\\nPlease \"\n            \"file an issue at https://github.com/huggingface/transformers/issues/new/choose and copy paste this whole \"\n            \"message and we will do our best to help.\"\n        )\n\nif cache_version < 1:\n    try:\n        os.makedirs(TRANSFORMERS_CACHE, exist_ok=True)\n        with open(cache_version_file, \"w\") as f:\n            f.write(\"1\")\n    except Exception:\n        logger.warning(\n            f\"There was a problem when trying to write in your cache folder ({TRANSFORMERS_CACHE}). You should set \"\n            \"the environment variable TRANSFORMERS_CACHE to a writable directory.\"\n        )\n"], "filenames": ["src/transformers/utils/hub.py"], "buggy_code_start_loc": [581], "buggy_code_end_loc": [582], "fixing_code_start_loc": [581], "fixing_code_end_loc": [582], "type": "CWE-377", "message": "Insecure Temporary File in GitHub repository huggingface/transformers prior to 4.30.0.", "other": {"cve": {"id": "CVE-2023-2800", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-18T17:15:08.817", "lastModified": "2023-05-26T18:11:36.360", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insecure Temporary File in GitHub repository huggingface/transformers prior to 4.30.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-377"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:huggingface:transformers:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.30.0", "matchCriteriaId": "FD022D67-4790-4570-A900-C7A70C284EC2"}]}]}], "references": [{"url": "https://github.com/huggingface/transformers/commit/80ca92470938bbcc348e2d9cf4734c7c25cb1c43", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/a3867b4e-6701-4418-8c20-3c6e7084a44a", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/huggingface/transformers/commit/80ca92470938bbcc348e2d9cf4734c7c25cb1c43"}}