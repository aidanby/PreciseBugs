{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                              JJJ  PPPP    222                               %\n%                               J   P   P  2   2                              %\n%                               J   PPPP     22                               %\n%                            J  J   P       2                                 %\n%                             JJ    P      22222                              %\n%                                                                             %\n%                                                                             %\n%                     Read/Write JPEG-2000 Image Format                       %\n%                                                                             %\n%                                   Cristy                                    %\n%                                Nathan Brown                                 %\n%                                 June 2001                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/static.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/module.h\"\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n#include <openjpeg.h>\n#endif\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\nstatic MagickBooleanType\n  WriteJP2Image(const ImageInfo *,Image *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J 2 K                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJ2K() returns MagickTrue if the image format type, identified by the\n%  magick string, is J2K.\n%\n%  The format of the IsJ2K method is:\n%\n%      MagickBooleanType IsJ2K(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJ2K(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\xff\\x4f\\xff\\x51\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P 2                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJP2() returns MagickTrue if the image format type, identified by the\n%  magick string, is JP2.\n%\n%  The format of the IsJP2 method is:\n%\n%      MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x0d\\x0a\\x87\\x0a\",4) == 0)\n    return(MagickTrue);\n  if (length < 12)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x00\\x00\\x00\\x0c\\x6a\\x50\\x20\\x20\\x0d\\x0a\\x87\\x0a\",12) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P 2 I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJP2Image() reads a JPEG 2000 Image file (JP2) or JPEG 2000\n%  codestream (JPC) image file and returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image or set of images.\n%\n%  JP2 support is originally written by Nathan Brown, nathanbrown@letu.edu.\n%\n%  The format of the ReadJP2Image method is:\n%\n%      Image *ReadJP2Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\nstatic void JP2ErrorHandler(const char *message,void *client_data)\n{\n  ExceptionInfo\n    *exception;\n\n  exception=(ExceptionInfo *) client_data;\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n    message,\"`%s'\",\"OpenJP2\");\n}\n\nstatic OPJ_SIZE_T JP2ReadHandler(void *buffer,OPJ_SIZE_T length,void *context)\n{\n  Image\n    *image;\n\n  ssize_t\n    count;\n\n  image=(Image *) context;\n  count=ReadBlob(image,(ssize_t) length,(unsigned char *) buffer);\n  if (count == 0)\n    return((OPJ_SIZE_T) -1);\n  return((OPJ_SIZE_T) count);\n}\n\nstatic OPJ_BOOL JP2SeekHandler(OPJ_OFF_T offset,void *context)\n{\n  Image\n    *image;\n\n  image=(Image *) context;\n  return(SeekBlob(image,offset,SEEK_SET) < 0 ? OPJ_FALSE : OPJ_TRUE);\n}\n\nstatic OPJ_OFF_T JP2SkipHandler(OPJ_OFF_T offset,void *context)\n{\n  Image\n    *image;\n\n  image=(Image *) context;\n  return(SeekBlob(image,offset,SEEK_CUR) < 0 ? -1 : offset);\n}\n\nstatic void JP2WarningHandler(const char *message,void *client_data)\n{\n  ExceptionInfo\n    *exception;\n\n  exception=(ExceptionInfo *) client_data;\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n    message,\"`%s'\",\"OpenJP2\");\n}\n\nstatic OPJ_SIZE_T JP2WriteHandler(void *buffer,OPJ_SIZE_T length,void *context)\n{\n  Image\n    *image;\n\n  ssize_t\n    count;\n\n  image=(Image *) context;\n  count=WriteBlob(image,(ssize_t) length,(unsigned char *) buffer);\n  return((OPJ_SIZE_T) count);\n}\n\nstatic Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  opj_codestream_index_t\n    *codestream_index = (opj_codestream_index_t *) NULL;\n\n  opj_dparameters_t\n    parameters;\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned char\n    sans[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JP2 codec.\n  */\n  if (ReadBlob(image,4,sans) != 4)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SeekBlob(image,SEEK_SET,0);\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_decompress(OPJ_CODEC_JPT);\n  else\n    if (IsJ2K(sans,4) != MagickFalse)\n      jp2_codec=opj_create_decompress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_decompress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_set_default_decoder_parameters(&parameters);\n  option=GetImageOption(image_info,\"jp2:reduce-factor\");\n  if (option != (const char *) NULL)\n    parameters.cp_reduce=StringToInteger(option);\n  option=GetImageOption(image_info,\"jp2:quality-layers\");\n  if (option == (const char *) NULL)\n    option=GetImageOption(image_info,\"jp2:layer-number\");\n  if (option != (const char *) NULL)\n    parameters.cp_layer=StringToInteger(option);\n  if (opj_setup_decoder(jp2_codec,&parameters) == 0)\n    {\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToManageJP2Stream\");\n    }\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image));\n  if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  jp2_status=1;\n  if ((image->columns != 0) && (image->rows != 0))\n    {\n      /*\n        Extract an area from the image.\n      */\n      jp2_status=opj_set_decode_area(jp2_codec,jp2_image,\n        (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y,\n        (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns,\n        (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows);\n      if (jp2_status == 0)\n        {\n          opj_stream_destroy(jp2_stream);\n          opj_destroy_codec(jp2_codec);\n          opj_image_destroy(jp2_image);\n          ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n        }\n    }\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image,\n      (unsigned int) image_info->scene-1);\n  else\n    if (image->ping == MagickFalse)\n      {\n        jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image);\n        if (jp2_status != 0)\n          jp2_status=opj_end_decompress(jp2_codec,jp2_stream);\n      }\n  if (jp2_status == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  opj_stream_destroy(jp2_stream);\n  for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n  {\n    if ((jp2_image->comps[i].dx == 0) || (jp2_image->comps[i].dy == 0))\n      {\n        opj_destroy_codec(jp2_codec);\n        opj_image_destroy(jp2_image);\n        ThrowReaderException(CoderError,\"IrregularChannelGeometryNotSupported\")\n      }\n  }\n  /*\n    Convert JP2 image.\n  */\n  image->columns=(size_t) jp2_image->comps[0].w;\n  image->rows=(size_t) jp2_image->comps[0].h;\n  image->depth=jp2_image->comps[0].prec;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  image->compression=JPEG2000Compression;\n  if (jp2_image->color_space == 2)\n    {\n      SetImageColorspace(image,GRAYColorspace);\n      if (jp2_image->numcomps > 1)\n        image->matte=MagickTrue;\n    }\n  else\n    if (jp2_image->color_space == 3)\n      SetImageColorspace(image,Rec601YCbCrColorspace);\n  if (jp2_image->numcomps > 3)\n    image->matte=MagickTrue;\n  if (jp2_image->icc_profile_buf != (unsigned char *) NULL)\n    {\n      StringInfo\n        *profile;\n\n      profile=BlobToStringInfo(jp2_image->icc_profile_buf,\n        jp2_image->icc_profile_len);\n      if (profile != (StringInfo *) NULL)\n        SetImageProfile(image,\"icc\",profile);\n    }\n  if (image->ping != MagickFalse)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      opj_destroy_cstr_index(&codestream_index);\n      return(GetFirstImageInList(image));\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n      {\n        double\n          pixel,\n          scale;\n\n        scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1);\n        pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+\n          (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0));\n        switch (i)\n        {\n           case 0:\n           {\n             q->red=ClampToQuantum(pixel);\n             q->green=q->red;\n             q->blue=q->red;\n             q->opacity=OpaqueOpacity;\n             break;\n           }\n           case 1:\n           {\n             if (jp2_image->numcomps == 2)\n               {\n                 q->opacity=ClampToQuantum(QuantumRange-pixel);\n                 break;\n               }\n             q->green=ClampToQuantum(pixel);\n             break;\n           }\n           case 2:\n           {\n             q->blue=ClampToQuantum(pixel);\n             break;\n           }\n           case 3:\n           {\n             q->opacity=ClampToQuantum(QuantumRange-pixel);\n             break;\n           }\n        }\n      }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  opj_destroy_cstr_index(&codestream_index);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P 2 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJP2Image() adds attributes for the JP2 image format to the list of\n%  supported formats.  The attributes include the image format tag, a method\n%  method to read and/or write the format, whether the format supports the\n%  saving of more than one frame to the same file or blob, whether the format\n%  supports native in-memory I/O, and a brief description of the format.\n%\n%  The format of the RegisterJP2Image method is:\n%\n%      size_t RegisterJP2Image(void)\n%\n*/\nModuleExport size_t RegisterJP2Image(void)\n{\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  (void) FormatLocaleString(version,MaxTextExtent,\"%s\",opj_version());\n#endif\n  entry=SetMagickInfo(\"JP2\");\n  entry->description=ConstantString(\"JPEG-2000 File Format Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJP2;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"J2C\");\n  entry->description=ConstantString(\"JPEG-2000 Code Stream Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJ2K;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"J2K\");\n  entry->description=ConstantString(\"JPEG-2000 Code Stream Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJ2K;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPM\");\n  entry->description=ConstantString(\"JPEG-2000 Code Stream Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJP2;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPT\");\n  entry->description=ConstantString(\"JPEG-2000 File Format Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJP2;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPC\");\n  entry->description=ConstantString(\"JPEG-2000 Code Stream Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJP2;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P 2 I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJP2Image() removes format registrations made by the JP2 module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterJP2Image method is:\n%\n%      UnregisterJP2Image(void)\n%\n*/\nModuleExport void UnregisterJP2Image(void)\n{\n  (void) UnregisterMagickInfo(\"JPC\");\n  (void) UnregisterMagickInfo(\"JPT\");\n  (void) UnregisterMagickInfo(\"JPM\");\n  (void) UnregisterMagickInfo(\"JP2\");\n  (void) UnregisterMagickInfo(\"J2K\");\n}\n\f\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e J P 2 I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJP2Image() writes an image in the JPEG 2000 image format.\n%\n%  JP2 support originally written by Nathan Brown, nathanbrown@letu.edu\n%\n%  The format of the WriteJP2Image method is:\n%\n%      MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\n\nstatic void CinemaProfileCompliance(const opj_image_t *jp2_image,\n  opj_cparameters_t *parameters)\n{\n  /*\n    Digital Cinema 4K profile compliant codestream.\n  */\n  parameters->tile_size_on=OPJ_FALSE;\n  parameters->cp_tdx=1;\n  parameters->cp_tdy=1;\n  parameters->tp_flag='C';\n  parameters->tp_on=1;\n  parameters->cp_tx0=0;\n  parameters->cp_ty0=0;\n  parameters->image_offset_x0=0;\n  parameters->image_offset_y0=0;\n  parameters->cblockw_init=32;\n  parameters->cblockh_init=32;\n  parameters->csty|=0x01;\n  parameters->prog_order=OPJ_CPRL;\n  parameters->roi_compno=(-1);\n  parameters->subsampling_dx=1;\n  parameters->subsampling_dy=1;\n  parameters->irreversible=1;\n  if ((jp2_image->comps[0].w == 2048) || (jp2_image->comps[0].h == 1080))\n    {\n      /*\n        Digital Cinema 2K.\n      */\n      parameters->cp_cinema=OPJ_CINEMA2K_24;\n      parameters->cp_rsiz=OPJ_CINEMA2K;\n      parameters->max_comp_size=1041666;\n      if (parameters->numresolution > 6)\n        parameters->numresolution=6;\n\n    }\n  if ((jp2_image->comps[0].w == 4096) || (jp2_image->comps[0].h == 2160))\n    {\n      /*\n        Digital Cinema 4K.\n      */\n      parameters->cp_cinema=OPJ_CINEMA4K_24;\n      parameters->cp_rsiz=OPJ_CINEMA4K;\n      parameters->max_comp_size=1041666;\n      if (parameters->numresolution < 1)\n        parameters->numresolution=1;\n      if (parameters->numresolution > 7)\n        parameters->numresolution=7;\n      parameters->numpocs=2;\n      parameters->POC[0].tile=1;\n      parameters->POC[0].resno0=0;\n      parameters->POC[0].compno0=0;\n      parameters->POC[0].layno1=1;\n      parameters->POC[0].resno1=parameters->numresolution-1;\n      parameters->POC[0].compno1=3;\n      parameters->POC[0].prg1=OPJ_CPRL;\n      parameters->POC[1].tile=1;\n      parameters->POC[1].resno0=parameters->numresolution-1;\n      parameters->POC[1].compno0=0;\n      parameters->POC[1].layno1=1;\n      parameters->POC[1].resno1=parameters->numresolution;\n      parameters->POC[1].compno1=3;\n      parameters->POC[1].prg1=OPJ_CPRL;\n    }\n  parameters->tcp_numlayers=1;\n  parameters->tcp_rates[0]=((float) (jp2_image->numcomps*jp2_image->comps[0].w*\n    jp2_image->comps[0].h*jp2_image->comps[0].prec))/(parameters->max_comp_size*\n    8*jp2_image->comps[0].dx*jp2_image->comps[0].dy);\n  parameters->cp_disto_alloc=1;\n}\n\nstatic MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 encoder parameters.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1 << (i+2)) > image->columns) &&\n        ((size_t) (1 << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n      &parameters.subsampling_dx,&parameters.subsampling_dy);\n  property=GetImageProperty(image,\"comment\");\n  if (property != (const char *) NULL)\n    parameters.cp_comment=ConstantString(property);\n  channels=3;\n  jp2_colorspace=OPJ_CLRSPC_SRGB;\n  if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte != MagickFalse)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  ResetMagickMemory(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(unsigned int) image->depth;\n    jp2_info[i].bpp=(unsigned int) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(unsigned int) image->columns;\n    jp2_info[i].h=(unsigned int) image->rows;\n  }\n  jp2_image=opj_image_create(channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const PixelPacket\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelLuma(image,p));\n                break;\n              }\n            *q=(int) (scale*p->red);\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*(QuantumRange-p->opacity));\n                break;\n              }\n            *q=(int) (scale*p->green);\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*p->blue);\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*(QuantumRange-p->opacity));\n            break;\n          }\n        }\n      }\n      p++;\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,&image->exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,&image->exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if (jp2_status == 0)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  if ((opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                              JJJ  PPPP    222                               %\n%                               J   P   P  2   2                              %\n%                               J   PPPP     22                               %\n%                            J  J   P       2                                 %\n%                             JJ    P      22222                              %\n%                                                                             %\n%                                                                             %\n%                     Read/Write JPEG-2000 Image Format                       %\n%                                                                             %\n%                                   Cristy                                    %\n%                                Nathan Brown                                 %\n%                                 June 2001                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/static.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/module.h\"\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n#include <openjpeg.h>\n#endif\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\nstatic MagickBooleanType\n  WriteJP2Image(const ImageInfo *,Image *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J 2 K                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJ2K() returns MagickTrue if the image format type, identified by the\n%  magick string, is J2K.\n%\n%  The format of the IsJ2K method is:\n%\n%      MagickBooleanType IsJ2K(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJ2K(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\xff\\x4f\\xff\\x51\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P 2                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJP2() returns MagickTrue if the image format type, identified by the\n%  magick string, is JP2.\n%\n%  The format of the IsJP2 method is:\n%\n%      MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x0d\\x0a\\x87\\x0a\",4) == 0)\n    return(MagickTrue);\n  if (length < 12)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x00\\x00\\x00\\x0c\\x6a\\x50\\x20\\x20\\x0d\\x0a\\x87\\x0a\",12) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P 2 I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJP2Image() reads a JPEG 2000 Image file (JP2) or JPEG 2000\n%  codestream (JPC) image file and returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image or set of images.\n%\n%  JP2 support is originally written by Nathan Brown, nathanbrown@letu.edu.\n%\n%  The format of the ReadJP2Image method is:\n%\n%      Image *ReadJP2Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\nstatic void JP2ErrorHandler(const char *message,void *client_data)\n{\n  ExceptionInfo\n    *exception;\n\n  exception=(ExceptionInfo *) client_data;\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n    message,\"`%s'\",\"OpenJP2\");\n}\n\nstatic OPJ_SIZE_T JP2ReadHandler(void *buffer,OPJ_SIZE_T length,void *context)\n{\n  Image\n    *image;\n\n  ssize_t\n    count;\n\n  image=(Image *) context;\n  count=ReadBlob(image,(ssize_t) length,(unsigned char *) buffer);\n  if (count == 0)\n    return((OPJ_SIZE_T) -1);\n  return((OPJ_SIZE_T) count);\n}\n\nstatic OPJ_BOOL JP2SeekHandler(OPJ_OFF_T offset,void *context)\n{\n  Image\n    *image;\n\n  image=(Image *) context;\n  return(SeekBlob(image,offset,SEEK_SET) < 0 ? OPJ_FALSE : OPJ_TRUE);\n}\n\nstatic OPJ_OFF_T JP2SkipHandler(OPJ_OFF_T offset,void *context)\n{\n  Image\n    *image;\n\n  image=(Image *) context;\n  return(SeekBlob(image,offset,SEEK_CUR) < 0 ? -1 : offset);\n}\n\nstatic void JP2WarningHandler(const char *message,void *client_data)\n{\n  ExceptionInfo\n    *exception;\n\n  exception=(ExceptionInfo *) client_data;\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n    message,\"`%s'\",\"OpenJP2\");\n}\n\nstatic OPJ_SIZE_T JP2WriteHandler(void *buffer,OPJ_SIZE_T length,void *context)\n{\n  Image\n    *image;\n\n  ssize_t\n    count;\n\n  image=(Image *) context;\n  count=WriteBlob(image,(ssize_t) length,(unsigned char *) buffer);\n  return((OPJ_SIZE_T) count);\n}\n\nstatic Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  opj_codestream_index_t\n    *codestream_index = (opj_codestream_index_t *) NULL;\n\n  opj_dparameters_t\n    parameters;\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned char\n    sans[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JP2 codec.\n  */\n  if (ReadBlob(image,4,sans) != 4)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SeekBlob(image,SEEK_SET,0);\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_decompress(OPJ_CODEC_JPT);\n  else\n    if (IsJ2K(sans,4) != MagickFalse)\n      jp2_codec=opj_create_decompress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_decompress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_set_default_decoder_parameters(&parameters);\n  option=GetImageOption(image_info,\"jp2:reduce-factor\");\n  if (option != (const char *) NULL)\n    parameters.cp_reduce=StringToInteger(option);\n  option=GetImageOption(image_info,\"jp2:quality-layers\");\n  if (option == (const char *) NULL)\n    option=GetImageOption(image_info,\"jp2:layer-number\");\n  if (option != (const char *) NULL)\n    parameters.cp_layer=StringToInteger(option);\n  if (opj_setup_decoder(jp2_codec,&parameters) == 0)\n    {\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToManageJP2Stream\");\n    }\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image));\n  if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  jp2_status=1;\n  if ((image->columns != 0) && (image->rows != 0))\n    {\n      /*\n        Extract an area from the image.\n      */\n      jp2_status=opj_set_decode_area(jp2_codec,jp2_image,\n        (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y,\n        (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns,\n        (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows);\n      if (jp2_status == 0)\n        {\n          opj_stream_destroy(jp2_stream);\n          opj_destroy_codec(jp2_codec);\n          opj_image_destroy(jp2_image);\n          ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n        }\n    }\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image,\n      (unsigned int) image_info->scene-1);\n  else\n    if (image->ping == MagickFalse)\n      {\n        jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image);\n        if (jp2_status != 0)\n          jp2_status=opj_end_decompress(jp2_codec,jp2_stream);\n      }\n  if (jp2_status == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  opj_stream_destroy(jp2_stream);\n  for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n  {\n    if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||\n        (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||\n        (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n        (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd))\n      {\n        opj_destroy_codec(jp2_codec);\n        opj_image_destroy(jp2_image);\n        ThrowReaderException(CoderError,\"IrregularChannelGeometryNotSupported\")\n      }\n  }\n  /*\n    Convert JP2 image.\n  */\n  image->columns=(size_t) jp2_image->comps[0].w;\n  image->rows=(size_t) jp2_image->comps[0].h;\n  image->depth=jp2_image->comps[0].prec;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  image->compression=JPEG2000Compression;\n  if (jp2_image->color_space == 2)\n    {\n      SetImageColorspace(image,GRAYColorspace);\n      if (jp2_image->numcomps > 1)\n        image->matte=MagickTrue;\n    }\n  else\n    if (jp2_image->color_space == 3)\n      SetImageColorspace(image,Rec601YCbCrColorspace);\n  if (jp2_image->numcomps > 3)\n    image->matte=MagickTrue;\n  if (jp2_image->icc_profile_buf != (unsigned char *) NULL)\n    {\n      StringInfo\n        *profile;\n\n      profile=BlobToStringInfo(jp2_image->icc_profile_buf,\n        jp2_image->icc_profile_len);\n      if (profile != (StringInfo *) NULL)\n        SetImageProfile(image,\"icc\",profile);\n    }\n  if (image->ping != MagickFalse)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      opj_destroy_cstr_index(&codestream_index);\n      return(GetFirstImageInList(image));\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n      {\n        double\n          pixel,\n          scale;\n\n        scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1);\n        pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+\n          (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0));\n        switch (i)\n        {\n           case 0:\n           {\n             q->red=ClampToQuantum(pixel);\n             q->green=q->red;\n             q->blue=q->red;\n             q->opacity=OpaqueOpacity;\n             break;\n           }\n           case 1:\n           {\n             if (jp2_image->numcomps == 2)\n               {\n                 q->opacity=ClampToQuantum(QuantumRange-pixel);\n                 break;\n               }\n             q->green=ClampToQuantum(pixel);\n             break;\n           }\n           case 2:\n           {\n             q->blue=ClampToQuantum(pixel);\n             break;\n           }\n           case 3:\n           {\n             q->opacity=ClampToQuantum(QuantumRange-pixel);\n             break;\n           }\n        }\n      }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  opj_destroy_cstr_index(&codestream_index);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P 2 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJP2Image() adds attributes for the JP2 image format to the list of\n%  supported formats.  The attributes include the image format tag, a method\n%  method to read and/or write the format, whether the format supports the\n%  saving of more than one frame to the same file or blob, whether the format\n%  supports native in-memory I/O, and a brief description of the format.\n%\n%  The format of the RegisterJP2Image method is:\n%\n%      size_t RegisterJP2Image(void)\n%\n*/\nModuleExport size_t RegisterJP2Image(void)\n{\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  (void) FormatLocaleString(version,MaxTextExtent,\"%s\",opj_version());\n#endif\n  entry=SetMagickInfo(\"JP2\");\n  entry->description=ConstantString(\"JPEG-2000 File Format Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJP2;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"J2C\");\n  entry->description=ConstantString(\"JPEG-2000 Code Stream Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJ2K;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"J2K\");\n  entry->description=ConstantString(\"JPEG-2000 Code Stream Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJ2K;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPM\");\n  entry->description=ConstantString(\"JPEG-2000 Code Stream Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJP2;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPT\");\n  entry->description=ConstantString(\"JPEG-2000 File Format Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJP2;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"JPC\");\n  entry->description=ConstantString(\"JPEG-2000 Code Stream Syntax\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jp2\");\n  entry->module=ConstantString(\"JP2\");\n  entry->magick=(IsImageFormatHandler *) IsJP2;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJP2Image;\n  entry->encoder=(EncodeImageHandler *) WriteJP2Image;\n#endif\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P 2 I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJP2Image() removes format registrations made by the JP2 module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterJP2Image method is:\n%\n%      UnregisterJP2Image(void)\n%\n*/\nModuleExport void UnregisterJP2Image(void)\n{\n  (void) UnregisterMagickInfo(\"JPC\");\n  (void) UnregisterMagickInfo(\"JPT\");\n  (void) UnregisterMagickInfo(\"JPM\");\n  (void) UnregisterMagickInfo(\"JP2\");\n  (void) UnregisterMagickInfo(\"J2K\");\n}\n\f\n#if defined(MAGICKCORE_LIBOPENJP2_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e J P 2 I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJP2Image() writes an image in the JPEG 2000 image format.\n%\n%  JP2 support originally written by Nathan Brown, nathanbrown@letu.edu\n%\n%  The format of the WriteJP2Image method is:\n%\n%      MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\n\nstatic void CinemaProfileCompliance(const opj_image_t *jp2_image,\n  opj_cparameters_t *parameters)\n{\n  /*\n    Digital Cinema 4K profile compliant codestream.\n  */\n  parameters->tile_size_on=OPJ_FALSE;\n  parameters->cp_tdx=1;\n  parameters->cp_tdy=1;\n  parameters->tp_flag='C';\n  parameters->tp_on=1;\n  parameters->cp_tx0=0;\n  parameters->cp_ty0=0;\n  parameters->image_offset_x0=0;\n  parameters->image_offset_y0=0;\n  parameters->cblockw_init=32;\n  parameters->cblockh_init=32;\n  parameters->csty|=0x01;\n  parameters->prog_order=OPJ_CPRL;\n  parameters->roi_compno=(-1);\n  parameters->subsampling_dx=1;\n  parameters->subsampling_dy=1;\n  parameters->irreversible=1;\n  if ((jp2_image->comps[0].w == 2048) || (jp2_image->comps[0].h == 1080))\n    {\n      /*\n        Digital Cinema 2K.\n      */\n      parameters->cp_cinema=OPJ_CINEMA2K_24;\n      parameters->cp_rsiz=OPJ_CINEMA2K;\n      parameters->max_comp_size=1041666;\n      if (parameters->numresolution > 6)\n        parameters->numresolution=6;\n\n    }\n  if ((jp2_image->comps[0].w == 4096) || (jp2_image->comps[0].h == 2160))\n    {\n      /*\n        Digital Cinema 4K.\n      */\n      parameters->cp_cinema=OPJ_CINEMA4K_24;\n      parameters->cp_rsiz=OPJ_CINEMA4K;\n      parameters->max_comp_size=1041666;\n      if (parameters->numresolution < 1)\n        parameters->numresolution=1;\n      if (parameters->numresolution > 7)\n        parameters->numresolution=7;\n      parameters->numpocs=2;\n      parameters->POC[0].tile=1;\n      parameters->POC[0].resno0=0;\n      parameters->POC[0].compno0=0;\n      parameters->POC[0].layno1=1;\n      parameters->POC[0].resno1=parameters->numresolution-1;\n      parameters->POC[0].compno1=3;\n      parameters->POC[0].prg1=OPJ_CPRL;\n      parameters->POC[1].tile=1;\n      parameters->POC[1].resno0=parameters->numresolution-1;\n      parameters->POC[1].compno0=0;\n      parameters->POC[1].layno1=1;\n      parameters->POC[1].resno1=parameters->numresolution;\n      parameters->POC[1].compno1=3;\n      parameters->POC[1].prg1=OPJ_CPRL;\n    }\n  parameters->tcp_numlayers=1;\n  parameters->tcp_rates[0]=((float) (jp2_image->numcomps*jp2_image->comps[0].w*\n    jp2_image->comps[0].h*jp2_image->comps[0].prec))/(parameters->max_comp_size*\n    8*jp2_image->comps[0].dx*jp2_image->comps[0].dy);\n  parameters->cp_disto_alloc=1;\n}\n\nstatic MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 encoder parameters.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1 << (i+2)) > image->columns) &&\n        ((size_t) (1 << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n      &parameters.subsampling_dx,&parameters.subsampling_dy);\n  property=GetImageProperty(image,\"comment\");\n  if (property != (const char *) NULL)\n    parameters.cp_comment=ConstantString(property);\n  channels=3;\n  jp2_colorspace=OPJ_CLRSPC_SRGB;\n  if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace);\n      if (image->matte != MagickFalse)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  ResetMagickMemory(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(unsigned int) image->depth;\n    jp2_info[i].bpp=(unsigned int) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(unsigned int) image->columns;\n    jp2_info[i].h=(unsigned int) image->rows;\n  }\n  jp2_image=opj_image_create(channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const PixelPacket\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelLuma(image,p));\n                break;\n              }\n            *q=(int) (scale*p->red);\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*(QuantumRange-p->opacity));\n                break;\n              }\n            *q=(int) (scale*p->green);\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*p->blue);\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*(QuantumRange-p->opacity));\n            break;\n          }\n        }\n      }\n      p++;\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,&image->exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,&image->exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if (jp2_status == 0)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  if ((opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n"], "filenames": ["coders/jp2.c"], "buggy_code_start_loc": [396], "buggy_code_end_loc": [397], "fixing_code_start_loc": [396], "fixing_code_end_loc": [401], "type": "CWE-20", "message": "In ImageMagick before 6.9.8-8 and 7.x before 7.0.5-9, the ReadJP2Image function in coders/jp2.c does not properly validate the channel geometry, leading to a crash.", "other": {"cve": {"id": "CVE-2017-13145", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-23T06:29:00.400", "lastModified": "2020-10-14T19:00:04.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ImageMagick before 6.9.8-8 and 7.x before 7.0.5-9, the ReadJP2Image function in coders/jp2.c does not properly validate the channel geometry, leading to a crash."}, {"lang": "es", "value": "En ImageMagick en versiones anteriores a la 6.9.8-8 y 7.x en versiones anteriores a la 7.0.5-9, la funci\u00f3n ReadJP2Image en coders/jp2.c no valida correctamente la geometr\u00eda del canal, lo que conduce a un bloqueo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.8-7", "matchCriteriaId": "BB75E6D5-E439-46D8-A2E3-05B0163EAC23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-6:*:*:*:*:*:*:*", "matchCriteriaId": "7B7F510A-A439-47A3-AF31-4BF7F74D58A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-7:*:*:*:*:*:*:*", "matchCriteriaId": "A91B94E3-33BB-46B6-A1AE-EAA9906605CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-8:*:*:*:*:*:*:*", "matchCriteriaId": "F5B3DE17-08A8-457D-9AEB-BD6E04376B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-9:*:*:*:*:*:*:*", "matchCriteriaId": "98AD438E-28B7-4491-B58F-55FDE7F67CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-10:*:*:*:*:*:*:*", "matchCriteriaId": "7E033A09-4F2F-4957-A9A8-5C9E7D90A1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-0:*:*:*:*:*:*:*", "matchCriteriaId": "BB9B68E7-0E40-437A-A71B-0C078FE76FD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "948D5778-AD2A-4293-AE39-A406D75F5678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-3:*:*:*:*:*:*:*", "matchCriteriaId": "CC773CB4-0E7B-4D73-AB9C-D7CC98C38BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-4:*:*:*:*:*:*:*", "matchCriteriaId": "24A0C584-9DA3-48B0-B152-67B9E0239876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-5:*:*:*:*:*:*:*", "matchCriteriaId": "E42943C5-CC66-4E88-9085-1BD39937C09B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-6:*:*:*:*:*:*:*", "matchCriteriaId": "E396985D-BE6A-4F4C-B294-FE69724534EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-7:*:*:*:*:*:*:*", "matchCriteriaId": "D1D84944-322C-4B5D-9B1C-587301747A34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-8:*:*:*:*:*:*:*", "matchCriteriaId": "B48F5327-CA20-4756-A06F-B30B660E8DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-9:*:*:*:*:*:*:*", "matchCriteriaId": "84C11EC2-C798-4C3B-8E00-9C70C3499B33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-10:*:*:*:*:*:*:*", "matchCriteriaId": "D30A3BD6-5903-42D6-A1E3-C6D2FE468A1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-0:*:*:*:*:*:*:*", "matchCriteriaId": "441F9FAE-11FA-4976-8BB3-4A3A79B57663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-1:*:*:*:*:*:*:*", "matchCriteriaId": "F4389D4A-8AD4-421E-AD4D-6761F45B7F6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-2:*:*:*:*:*:*:*", "matchCriteriaId": "1620AF57-49AF-4487-80A1-07627F50F817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-3:*:*:*:*:*:*:*", "matchCriteriaId": "DF373D13-0AB1-4518-AFFE-D09A5F56E992"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-4:*:*:*:*:*:*:*", "matchCriteriaId": "86483865-BFC3-4845-80DE-A6AC632A92A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-5:*:*:*:*:*:*:*", "matchCriteriaId": "2A147E12-E5D4-400E-9432-BB5BCF2352CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-6:*:*:*:*:*:*:*", "matchCriteriaId": "B1F2BF9D-9821-424E-8F06-BFB637C103A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-7:*:*:*:*:*:*:*", "matchCriteriaId": "26D7231D-442B-4E7C-BCB2-EE8D787FD46D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-8:*:*:*:*:*:*:*", "matchCriteriaId": "749B8733-47B0-4F63-874D-62DF323CD045"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-9:*:*:*:*:*:*:*", "matchCriteriaId": "AD9D1C91-B67A-430B-AB24-DCC7DAF69D7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-10:*:*:*:*:*:*:*", "matchCriteriaId": "0C5BE761-44E8-4614-BBD4-3FA7148156B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-0:*:*:*:*:*:*:*", "matchCriteriaId": "79AA4723-3637-4FA7-AE60-9CEE7C535A13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-1:*:*:*:*:*:*:*", "matchCriteriaId": "2D1F577A-316C-4ECE-91CB-4C15F12CC63B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-4:*:*:*:*:*:*:*", "matchCriteriaId": "68F19A0F-29E9-40A5-B6BB-23C20343CDBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-5:*:*:*:*:*:*:*", "matchCriteriaId": "72A65A02-CD63-4DDD-AFCC-FE6988F85E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-6:*:*:*:*:*:*:*", "matchCriteriaId": "25690796-E494-4D28-BB4F-AAF40D596AC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-7:*:*:*:*:*:*:*", "matchCriteriaId": "A2C0242E-0292-4DF7-A3FC-BE96DA95E7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-8:*:*:*:*:*:*:*", "matchCriteriaId": "9F853E8E-1ED2-4BDA-BE60-BBE1F658695B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=869830", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/acee073df34aa4d491bf5cb74d3a15fc80f0a3aa", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/f13c6b54a879aaa771ec64b5a066b939e8f8e7f0", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/501", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201711-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3681-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4019", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/acee073df34aa4d491bf5cb74d3a15fc80f0a3aa"}}