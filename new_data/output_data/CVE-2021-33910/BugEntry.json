{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include \"alloc-util.h\"\n#include \"glob-util.h\"\n#include \"hexdecoct.h\"\n#include \"path-util.h\"\n#include \"special.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"unit-name.h\"\n\n/* Characters valid in a unit name. */\n#define VALID_CHARS                             \\\n        DIGITS                                  \\\n        LETTERS                                 \\\n        \":-_.\\\\\"\n\n/* The same, but also permits the single @ character that may appear */\n#define VALID_CHARS_WITH_AT                     \\\n        \"@\"                                     \\\n        VALID_CHARS\n\n/* All chars valid in a unit name glob */\n#define VALID_CHARS_GLOB                        \\\n        VALID_CHARS_WITH_AT                     \\\n        \"[]!-*?\"\n\nbool unit_name_is_valid(const char *n, UnitNameFlags flags) {\n        const char *e, *i, *at;\n\n        assert((flags & ~(UNIT_NAME_PLAIN|UNIT_NAME_INSTANCE|UNIT_NAME_TEMPLATE)) == 0);\n\n        if (_unlikely_(flags == 0))\n                return false;\n\n        if (isempty(n))\n                return false;\n\n        if (strlen(n) >= UNIT_NAME_MAX)\n                return false;\n\n        e = strrchr(n, '.');\n        if (!e || e == n)\n                return false;\n\n        if (unit_type_from_string(e + 1) < 0)\n                return false;\n\n        for (i = n, at = NULL; i < e; i++) {\n\n                if (*i == '@' && !at)\n                        at = i;\n\n                if (!strchr(\"@\" VALID_CHARS, *i))\n                        return false;\n        }\n\n        if (at == n)\n                return false;\n\n        if (flags & UNIT_NAME_PLAIN)\n                if (!at)\n                        return true;\n\n        if (flags & UNIT_NAME_INSTANCE)\n                if (at && e > at + 1)\n                        return true;\n\n        if (flags & UNIT_NAME_TEMPLATE)\n                if (at && e == at + 1)\n                        return true;\n\n        return false;\n}\n\nbool unit_prefix_is_valid(const char *p) {\n\n        /* We don't allow additional @ in the prefix string */\n\n        if (isempty(p))\n                return false;\n\n        return in_charset(p, VALID_CHARS);\n}\n\nbool unit_instance_is_valid(const char *i) {\n\n        /* The max length depends on the length of the string, so we\n         * don't really check this here. */\n\n        if (isempty(i))\n                return false;\n\n        /* We allow additional @ in the instance string, we do not\n         * allow them in the prefix! */\n\n        return in_charset(i, \"@\" VALID_CHARS);\n}\n\nbool unit_suffix_is_valid(const char *s) {\n        if (isempty(s))\n                return false;\n\n        if (s[0] != '.')\n                return false;\n\n        if (unit_type_from_string(s + 1) < 0)\n                return false;\n\n        return true;\n}\n\nint unit_name_to_prefix(const char *n, char **ret) {\n        const char *p;\n        char *s;\n\n        assert(n);\n        assert(ret);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        p = strchr(n, '@');\n        if (!p)\n                p = strrchr(n, '.');\n\n        assert_se(p);\n\n        s = strndup(n, p - n);\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}\n\nint unit_name_to_instance(const char *n, char **ret) {\n        const char *p, *d;\n\n        assert(n);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        /* Everything past the first @ and before the last . is the instance */\n        p = strchr(n, '@');\n        if (!p) {\n                if (ret)\n                        *ret = NULL;\n                return UNIT_NAME_PLAIN;\n        }\n\n        p++;\n\n        d = strrchr(p, '.');\n        if (!d)\n                return -EINVAL;\n\n        if (ret) {\n                char *i = strndup(p, d-p);\n                if (!i)\n                        return -ENOMEM;\n\n                *ret = i;\n        }\n        return d > p ? UNIT_NAME_INSTANCE : UNIT_NAME_TEMPLATE;\n}\n\nint unit_name_to_prefix_and_instance(const char *n, char **ret) {\n        const char *d;\n        char *s;\n\n        assert(n);\n        assert(ret);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        d = strrchr(n, '.');\n        if (!d)\n                return -EINVAL;\n\n        s = strndup(n, d - n);\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}\n\nUnitType unit_name_to_type(const char *n) {\n        const char *e;\n\n        assert(n);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return _UNIT_TYPE_INVALID;\n\n        assert_se(e = strrchr(n, '.'));\n\n        return unit_type_from_string(e + 1);\n}\n\nint unit_name_change_suffix(const char *n, const char *suffix, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        size_t a, b;\n        char *e;\n\n        assert(n);\n        assert(suffix);\n        assert(ret);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        assert_se(e = strrchr(n, '.'));\n\n        a = e - n;\n        b = strlen(suffix);\n\n        s = new(char, a + b + 1);\n        if (!s)\n                return -ENOMEM;\n\n        strcpy(mempcpy(s, n, a), suffix);\n\n        /* Make sure the name is still valid (i.e. didn't grow too large due to longer suffix) */\n        if (!unit_name_is_valid(s, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint unit_name_build(const char *prefix, const char *instance, const char *suffix, char **ret) {\n        UnitType type;\n\n        assert(prefix);\n        assert(suffix);\n        assert(ret);\n\n        if (suffix[0] != '.')\n                return -EINVAL;\n\n        type = unit_type_from_string(suffix + 1);\n        if (type < 0)\n                return type;\n\n        return unit_name_build_from_type(prefix, instance, type, ret);\n}\n\nint unit_name_build_from_type(const char *prefix, const char *instance, UnitType type, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        const char *ut;\n\n        assert(prefix);\n        assert(type >= 0);\n        assert(type < _UNIT_TYPE_MAX);\n        assert(ret);\n\n        if (!unit_prefix_is_valid(prefix))\n                return -EINVAL;\n\n        ut = unit_type_to_string(type);\n\n        if (instance) {\n                if (!unit_instance_is_valid(instance))\n                        return -EINVAL;\n\n                s = strjoin(prefix, \"@\", instance, \".\", ut);\n        } else\n                s = strjoin(prefix, \".\", ut);\n        if (!s)\n                return -ENOMEM;\n\n        /* Verify that this didn't grow too large (or otherwise is invalid) */\n        if (!unit_name_is_valid(s, instance ? UNIT_NAME_INSTANCE : UNIT_NAME_PLAIN))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nstatic char *do_escape_char(char c, char *t) {\n        assert(t);\n\n        *(t++) = '\\\\';\n        *(t++) = 'x';\n        *(t++) = hexchar(c >> 4);\n        *(t++) = hexchar(c);\n\n        return t;\n}\n\nstatic char *do_escape(const char *f, char *t) {\n        assert(f);\n        assert(t);\n\n        /* do not create units with a leading '.', like for \"/.dotdir\" mount points */\n        if (*f == '.') {\n                t = do_escape_char(*f, t);\n                f++;\n        }\n\n        for (; *f; f++) {\n                if (*f == '/')\n                        *(t++) = '-';\n                else if (IN_SET(*f, '-', '\\\\') || !strchr(VALID_CHARS, *f))\n                        t = do_escape_char(*f, t);\n                else\n                        *(t++) = *f;\n        }\n\n        return t;\n}\n\nchar *unit_name_escape(const char *f) {\n        char *r, *t;\n\n        assert(f);\n\n        r = new(char, strlen(f)*4+1);\n        if (!r)\n                return NULL;\n\n        t = do_escape(f, r);\n        *t = 0;\n\n        return r;\n}\n\nint unit_name_unescape(const char *f, char **ret) {\n        _cleanup_free_ char *r = NULL;\n        char *t;\n\n        assert(f);\n\n        r = strdup(f);\n        if (!r)\n                return -ENOMEM;\n\n        for (t = r; *f; f++) {\n                if (*f == '-')\n                        *(t++) = '/';\n                else if (*f == '\\\\') {\n                        int a, b;\n\n                        if (f[1] != 'x')\n                                return -EINVAL;\n\n                        a = unhexchar(f[2]);\n                        if (a < 0)\n                                return -EINVAL;\n\n                        b = unhexchar(f[3]);\n                        if (b < 0)\n                                return -EINVAL;\n\n                        *(t++) = (char) (((uint8_t) a << 4U) | (uint8_t) b);\n                        f += 3;\n                } else\n                        *(t++) = *f;\n        }\n\n        *t = 0;\n\n        *ret = TAKE_PTR(r);\n\n        return 0;\n}\n\nint unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n\n        assert(f);\n        assert(ret);\n\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n\n        path_simplify(p, false);\n\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n\n                /* Truncate trailing slashes */\n                delete_trailing_chars(p, \"/\");\n\n                /* Truncate leading slashes */\n                p = skip_leading_chars(p, \"/\");\n\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}\n\nint unit_name_path_unescape(const char *f, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        int r;\n\n        assert(f);\n\n        if (isempty(f))\n                return -EINVAL;\n\n        if (streq(f, \"-\")) {\n                s = strdup(\"/\");\n                if (!s)\n                        return -ENOMEM;\n        } else {\n                _cleanup_free_ char *w = NULL;\n\n                r = unit_name_unescape(f, &w);\n                if (r < 0)\n                        return r;\n\n                /* Don't accept trailing or leading slashes */\n                if (startswith(w, \"/\") || endswith(w, \"/\"))\n                        return -EINVAL;\n\n                /* Prefix a slash again */\n                s = strjoin(\"/\", w);\n                if (!s)\n                        return -ENOMEM;\n\n                if (!path_is_normalized(s))\n                        return -EINVAL;\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(s);\n\n        return 0;\n}\n\nint unit_name_replace_instance(const char *f, const char *i, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        const char *p, *e;\n        size_t a, b;\n\n        assert(f);\n        assert(i);\n        assert(ret);\n\n        if (!unit_name_is_valid(f, UNIT_NAME_INSTANCE|UNIT_NAME_TEMPLATE))\n                return -EINVAL;\n        if (!unit_instance_is_valid(i))\n                return -EINVAL;\n\n        assert_se(p = strchr(f, '@'));\n        assert_se(e = strrchr(f, '.'));\n\n        a = p - f;\n        b = strlen(i);\n\n        s = new(char, a + 1 + b + strlen(e) + 1);\n        if (!s)\n                return -ENOMEM;\n\n        strcpy(mempcpy(mempcpy(s, f, a + 1), i, b), e);\n\n        /* Make sure the resulting name still is valid, i.e. didn't grow too large */\n        if (!unit_name_is_valid(s, UNIT_NAME_INSTANCE))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint unit_name_template(const char *f, char **ret) {\n        const char *p, *e;\n        char *s;\n        size_t a;\n\n        assert(f);\n        assert(ret);\n\n        if (!unit_name_is_valid(f, UNIT_NAME_INSTANCE|UNIT_NAME_TEMPLATE))\n                return -EINVAL;\n\n        assert_se(p = strchr(f, '@'));\n        assert_se(e = strrchr(f, '.'));\n\n        a = p - f;\n\n        s = new(char, a + 1 + strlen(e) + 1);\n        if (!s)\n                return -ENOMEM;\n\n        strcpy(mempcpy(s, f, a + 1), e);\n\n        *ret = s;\n        return 0;\n}\n\nint unit_name_from_path(const char *path, const char *suffix, char **ret) {\n        _cleanup_free_ char *p = NULL, *s = NULL;\n        int r;\n\n        assert(path);\n        assert(suffix);\n        assert(ret);\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        r = unit_name_path_escape(path, &p);\n        if (r < 0)\n                return r;\n\n        s = strjoin(p, suffix);\n        if (!s)\n                return -ENOMEM;\n\n        if (strlen(s) >= UNIT_NAME_MAX) /* Return a slightly more descriptive error for this specific condition */\n                return -ENAMETOOLONG;\n\n        /* Refuse this if this got too long or for some other reason didn't result in a valid name */\n        if (!unit_name_is_valid(s, UNIT_NAME_PLAIN))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint unit_name_from_path_instance(const char *prefix, const char *path, const char *suffix, char **ret) {\n        _cleanup_free_ char *p = NULL, *s = NULL;\n        int r;\n\n        assert(prefix);\n        assert(path);\n        assert(suffix);\n        assert(ret);\n\n        if (!unit_prefix_is_valid(prefix))\n                return -EINVAL;\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        r = unit_name_path_escape(path, &p);\n        if (r < 0)\n                return r;\n\n        s = strjoin(prefix, \"@\", p, suffix);\n        if (!s)\n                return -ENOMEM;\n\n        if (strlen(s) >= UNIT_NAME_MAX) /* Return a slightly more descriptive error for this specific condition */\n                return -ENAMETOOLONG;\n\n        /* Refuse this if this got too long or for some other reason didn't result in a valid name */\n        if (!unit_name_is_valid(s, UNIT_NAME_INSTANCE))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint unit_name_to_path(const char *name, char **ret) {\n        _cleanup_free_ char *prefix = NULL;\n        int r;\n\n        assert(name);\n\n        r = unit_name_to_prefix(name, &prefix);\n        if (r < 0)\n                return r;\n\n        return unit_name_path_unescape(prefix, ret);\n}\n\nstatic bool do_escape_mangle(const char *f, bool allow_globs, char *t) {\n        const char *valid_chars;\n        bool mangled = false;\n\n        assert(f);\n        assert(t);\n\n        /* We'll only escape the obvious characters here, to play safe.\n         *\n         * Returns true if any characters were mangled, false otherwise.\n         */\n\n        valid_chars = allow_globs ? VALID_CHARS_GLOB : VALID_CHARS_WITH_AT;\n\n        for (; *f; f++)\n                if (*f == '/') {\n                        *(t++) = '-';\n                        mangled = true;\n                } else if (!strchr(valid_chars, *f)) {\n                        t = do_escape_char(*f, t);\n                        mangled = true;\n                } else\n                        *(t++) = *f;\n        *t = 0;\n\n        return mangled;\n}\n\n/**\n *  Convert a string to a unit name. /dev/blah is converted to dev-blah.device,\n *  /blah/blah is converted to blah-blah.mount, anything else is left alone,\n *  except that @suffix is appended if a valid unit suffix is not present.\n *\n *  If @allow_globs, globs characters are preserved. Otherwise, they are escaped.\n */\nint unit_name_mangle_with_suffix(const char *name, const char *operation, UnitNameMangle flags, const char *suffix, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        bool mangled, suggest_escape = true;\n        int r;\n\n        assert(name);\n        assert(suffix);\n        assert(ret);\n\n        if (isempty(name)) /* We cannot mangle empty unit names to become valid, sorry. */\n                return -EINVAL;\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        /* Already a fully valid unit name? If so, no mangling is necessary... */\n        if (unit_name_is_valid(name, UNIT_NAME_ANY))\n                goto good;\n\n        /* Already a fully valid globbing expression? If so, no mangling is necessary either... */\n        if (string_is_glob(name) && in_charset(name, VALID_CHARS_GLOB)) {\n                if (flags & UNIT_NAME_MANGLE_GLOB)\n                        goto good;\n                log_full(flags & UNIT_NAME_MANGLE_WARN ? LOG_NOTICE : LOG_DEBUG,\n                         \"Glob pattern passed%s%s, but globs are not supported for this.\",\n                         operation ? \" \" : \"\", strempty(operation));\n                suggest_escape = false;\n        }\n\n        if (is_device_path(name)) {\n                r = unit_name_from_path(name, \".device\", ret);\n                if (r >= 0)\n                        return 1;\n                if (r != -EINVAL)\n                        return r;\n        }\n\n        if (path_is_absolute(name)) {\n                r = unit_name_from_path(name, \".mount\", ret);\n                if (r >= 0)\n                        return 1;\n                if (r != -EINVAL)\n                        return r;\n        }\n\n        s = new(char, strlen(name) * 4 + strlen(suffix) + 1);\n        if (!s)\n                return -ENOMEM;\n\n        mangled = do_escape_mangle(name, flags & UNIT_NAME_MANGLE_GLOB, s);\n        if (mangled)\n                log_full(flags & UNIT_NAME_MANGLE_WARN ? LOG_NOTICE : LOG_DEBUG,\n                         \"Invalid unit name \\\"%s\\\" escaped as \\\"%s\\\"%s.\",\n                         name, s,\n                         suggest_escape ? \" (maybe you should use systemd-escape?)\" : \"\");\n\n        /* Append a suffix if it doesn't have any, but only if this is not a glob, so that we can allow\n         * \"foo.*\" as a valid glob. */\n        if ((!(flags & UNIT_NAME_MANGLE_GLOB) || !string_is_glob(s)) && unit_name_to_type(s) < 0)\n                strcat(s, suffix);\n\n        /* Make sure mangling didn't grow this too large (but don't do this check if globbing is allowed,\n         * since globs generally do not qualify as valid unit names) */\n        if (!FLAGS_SET(flags, UNIT_NAME_MANGLE_GLOB) && !unit_name_is_valid(s, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 1;\n\ngood:\n        s = strdup(name);\n        if (!s)\n                return -ENOMEM;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint slice_build_parent_slice(const char *slice, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        char *dash;\n        int r;\n\n        assert(slice);\n        assert(ret);\n\n        if (!slice_name_is_valid(slice))\n                return -EINVAL;\n\n        if (streq(slice, SPECIAL_ROOT_SLICE)) {\n                *ret = NULL;\n                return 0;\n        }\n\n        s = strdup(slice);\n        if (!s)\n                return -ENOMEM;\n\n        dash = strrchr(s, '-');\n        if (dash)\n                strcpy(dash, \".slice\");\n        else {\n                r = free_and_strdup(&s, SPECIAL_ROOT_SLICE);\n                if (r < 0)\n                        return r;\n        }\n\n        *ret = TAKE_PTR(s);\n        return 1;\n}\n\nint slice_build_subslice(const char *slice, const char *name, char **ret) {\n        char *subslice;\n\n        assert(slice);\n        assert(name);\n        assert(ret);\n\n        if (!slice_name_is_valid(slice))\n                return -EINVAL;\n\n        if (!unit_prefix_is_valid(name))\n                return -EINVAL;\n\n        if (streq(slice, SPECIAL_ROOT_SLICE))\n                subslice = strjoin(name, \".slice\");\n        else {\n                char *e;\n\n                assert_se(e = endswith(slice, \".slice\"));\n\n                subslice = new(char, (e - slice) + 1 + strlen(name) + 6 + 1);\n                if (!subslice)\n                        return -ENOMEM;\n\n                stpcpy(stpcpy(stpcpy(mempcpy(subslice, slice, e - slice), \"-\"), name), \".slice\");\n        }\n\n        *ret = subslice;\n        return 0;\n}\n\nbool slice_name_is_valid(const char *name) {\n        const char *p, *e;\n        bool dash = false;\n\n        if (!unit_name_is_valid(name, UNIT_NAME_PLAIN))\n                return false;\n\n        if (streq(name, SPECIAL_ROOT_SLICE))\n                return true;\n\n        e = endswith(name, \".slice\");\n        if (!e)\n                return false;\n\n        for (p = name; p < e; p++) {\n\n                if (*p == '-') {\n\n                        /* Don't allow initial dash */\n                        if (p == name)\n                                return false;\n\n                        /* Don't allow multiple dashes */\n                        if (dash)\n                                return false;\n\n                        dash = true;\n                } else\n                        dash = false;\n        }\n\n        /* Don't allow trailing hash */\n        if (dash)\n                return false;\n\n        return true;\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include \"alloc-util.h\"\n#include \"glob-util.h\"\n#include \"hexdecoct.h\"\n#include \"path-util.h\"\n#include \"special.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"unit-name.h\"\n\n/* Characters valid in a unit name. */\n#define VALID_CHARS                             \\\n        DIGITS                                  \\\n        LETTERS                                 \\\n        \":-_.\\\\\"\n\n/* The same, but also permits the single @ character that may appear */\n#define VALID_CHARS_WITH_AT                     \\\n        \"@\"                                     \\\n        VALID_CHARS\n\n/* All chars valid in a unit name glob */\n#define VALID_CHARS_GLOB                        \\\n        VALID_CHARS_WITH_AT                     \\\n        \"[]!-*?\"\n\nbool unit_name_is_valid(const char *n, UnitNameFlags flags) {\n        const char *e, *i, *at;\n\n        assert((flags & ~(UNIT_NAME_PLAIN|UNIT_NAME_INSTANCE|UNIT_NAME_TEMPLATE)) == 0);\n\n        if (_unlikely_(flags == 0))\n                return false;\n\n        if (isempty(n))\n                return false;\n\n        if (strlen(n) >= UNIT_NAME_MAX)\n                return false;\n\n        e = strrchr(n, '.');\n        if (!e || e == n)\n                return false;\n\n        if (unit_type_from_string(e + 1) < 0)\n                return false;\n\n        for (i = n, at = NULL; i < e; i++) {\n\n                if (*i == '@' && !at)\n                        at = i;\n\n                if (!strchr(\"@\" VALID_CHARS, *i))\n                        return false;\n        }\n\n        if (at == n)\n                return false;\n\n        if (flags & UNIT_NAME_PLAIN)\n                if (!at)\n                        return true;\n\n        if (flags & UNIT_NAME_INSTANCE)\n                if (at && e > at + 1)\n                        return true;\n\n        if (flags & UNIT_NAME_TEMPLATE)\n                if (at && e == at + 1)\n                        return true;\n\n        return false;\n}\n\nbool unit_prefix_is_valid(const char *p) {\n\n        /* We don't allow additional @ in the prefix string */\n\n        if (isempty(p))\n                return false;\n\n        return in_charset(p, VALID_CHARS);\n}\n\nbool unit_instance_is_valid(const char *i) {\n\n        /* The max length depends on the length of the string, so we\n         * don't really check this here. */\n\n        if (isempty(i))\n                return false;\n\n        /* We allow additional @ in the instance string, we do not\n         * allow them in the prefix! */\n\n        return in_charset(i, \"@\" VALID_CHARS);\n}\n\nbool unit_suffix_is_valid(const char *s) {\n        if (isempty(s))\n                return false;\n\n        if (s[0] != '.')\n                return false;\n\n        if (unit_type_from_string(s + 1) < 0)\n                return false;\n\n        return true;\n}\n\nint unit_name_to_prefix(const char *n, char **ret) {\n        const char *p;\n        char *s;\n\n        assert(n);\n        assert(ret);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        p = strchr(n, '@');\n        if (!p)\n                p = strrchr(n, '.');\n\n        assert_se(p);\n\n        s = strndup(n, p - n);\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}\n\nint unit_name_to_instance(const char *n, char **ret) {\n        const char *p, *d;\n\n        assert(n);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        /* Everything past the first @ and before the last . is the instance */\n        p = strchr(n, '@');\n        if (!p) {\n                if (ret)\n                        *ret = NULL;\n                return UNIT_NAME_PLAIN;\n        }\n\n        p++;\n\n        d = strrchr(p, '.');\n        if (!d)\n                return -EINVAL;\n\n        if (ret) {\n                char *i = strndup(p, d-p);\n                if (!i)\n                        return -ENOMEM;\n\n                *ret = i;\n        }\n        return d > p ? UNIT_NAME_INSTANCE : UNIT_NAME_TEMPLATE;\n}\n\nint unit_name_to_prefix_and_instance(const char *n, char **ret) {\n        const char *d;\n        char *s;\n\n        assert(n);\n        assert(ret);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        d = strrchr(n, '.');\n        if (!d)\n                return -EINVAL;\n\n        s = strndup(n, d - n);\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}\n\nUnitType unit_name_to_type(const char *n) {\n        const char *e;\n\n        assert(n);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return _UNIT_TYPE_INVALID;\n\n        assert_se(e = strrchr(n, '.'));\n\n        return unit_type_from_string(e + 1);\n}\n\nint unit_name_change_suffix(const char *n, const char *suffix, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        size_t a, b;\n        char *e;\n\n        assert(n);\n        assert(suffix);\n        assert(ret);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        assert_se(e = strrchr(n, '.'));\n\n        a = e - n;\n        b = strlen(suffix);\n\n        s = new(char, a + b + 1);\n        if (!s)\n                return -ENOMEM;\n\n        strcpy(mempcpy(s, n, a), suffix);\n\n        /* Make sure the name is still valid (i.e. didn't grow too large due to longer suffix) */\n        if (!unit_name_is_valid(s, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint unit_name_build(const char *prefix, const char *instance, const char *suffix, char **ret) {\n        UnitType type;\n\n        assert(prefix);\n        assert(suffix);\n        assert(ret);\n\n        if (suffix[0] != '.')\n                return -EINVAL;\n\n        type = unit_type_from_string(suffix + 1);\n        if (type < 0)\n                return type;\n\n        return unit_name_build_from_type(prefix, instance, type, ret);\n}\n\nint unit_name_build_from_type(const char *prefix, const char *instance, UnitType type, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        const char *ut;\n\n        assert(prefix);\n        assert(type >= 0);\n        assert(type < _UNIT_TYPE_MAX);\n        assert(ret);\n\n        if (!unit_prefix_is_valid(prefix))\n                return -EINVAL;\n\n        ut = unit_type_to_string(type);\n\n        if (instance) {\n                if (!unit_instance_is_valid(instance))\n                        return -EINVAL;\n\n                s = strjoin(prefix, \"@\", instance, \".\", ut);\n        } else\n                s = strjoin(prefix, \".\", ut);\n        if (!s)\n                return -ENOMEM;\n\n        /* Verify that this didn't grow too large (or otherwise is invalid) */\n        if (!unit_name_is_valid(s, instance ? UNIT_NAME_INSTANCE : UNIT_NAME_PLAIN))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nstatic char *do_escape_char(char c, char *t) {\n        assert(t);\n\n        *(t++) = '\\\\';\n        *(t++) = 'x';\n        *(t++) = hexchar(c >> 4);\n        *(t++) = hexchar(c);\n\n        return t;\n}\n\nstatic char *do_escape(const char *f, char *t) {\n        assert(f);\n        assert(t);\n\n        /* do not create units with a leading '.', like for \"/.dotdir\" mount points */\n        if (*f == '.') {\n                t = do_escape_char(*f, t);\n                f++;\n        }\n\n        for (; *f; f++) {\n                if (*f == '/')\n                        *(t++) = '-';\n                else if (IN_SET(*f, '-', '\\\\') || !strchr(VALID_CHARS, *f))\n                        t = do_escape_char(*f, t);\n                else\n                        *(t++) = *f;\n        }\n\n        return t;\n}\n\nchar *unit_name_escape(const char *f) {\n        char *r, *t;\n\n        assert(f);\n\n        r = new(char, strlen(f)*4+1);\n        if (!r)\n                return NULL;\n\n        t = do_escape(f, r);\n        *t = 0;\n\n        return r;\n}\n\nint unit_name_unescape(const char *f, char **ret) {\n        _cleanup_free_ char *r = NULL;\n        char *t;\n\n        assert(f);\n\n        r = strdup(f);\n        if (!r)\n                return -ENOMEM;\n\n        for (t = r; *f; f++) {\n                if (*f == '-')\n                        *(t++) = '/';\n                else if (*f == '\\\\') {\n                        int a, b;\n\n                        if (f[1] != 'x')\n                                return -EINVAL;\n\n                        a = unhexchar(f[2]);\n                        if (a < 0)\n                                return -EINVAL;\n\n                        b = unhexchar(f[3]);\n                        if (b < 0)\n                                return -EINVAL;\n\n                        *(t++) = (char) (((uint8_t) a << 4U) | (uint8_t) b);\n                        f += 3;\n                } else\n                        *(t++) = *f;\n        }\n\n        *t = 0;\n\n        *ret = TAKE_PTR(r);\n\n        return 0;\n}\n\nint unit_name_path_escape(const char *f, char **ret) {\n        _cleanup_free_ char *p = NULL;\n        char *s;\n\n        assert(f);\n        assert(ret);\n\n        p = strdup(f);\n        if (!p)\n                return -ENOMEM;\n\n        path_simplify(p, false);\n\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n\n                /* Truncate trailing slashes and skip leading slashes */\n                delete_trailing_chars(p, \"/\");\n                s = unit_name_escape(skip_leading_chars(p, \"/\"));\n        }\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}\n\nint unit_name_path_unescape(const char *f, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        int r;\n\n        assert(f);\n\n        if (isempty(f))\n                return -EINVAL;\n\n        if (streq(f, \"-\")) {\n                s = strdup(\"/\");\n                if (!s)\n                        return -ENOMEM;\n        } else {\n                _cleanup_free_ char *w = NULL;\n\n                r = unit_name_unescape(f, &w);\n                if (r < 0)\n                        return r;\n\n                /* Don't accept trailing or leading slashes */\n                if (startswith(w, \"/\") || endswith(w, \"/\"))\n                        return -EINVAL;\n\n                /* Prefix a slash again */\n                s = strjoin(\"/\", w);\n                if (!s)\n                        return -ENOMEM;\n\n                if (!path_is_normalized(s))\n                        return -EINVAL;\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(s);\n\n        return 0;\n}\n\nint unit_name_replace_instance(const char *f, const char *i, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        const char *p, *e;\n        size_t a, b;\n\n        assert(f);\n        assert(i);\n        assert(ret);\n\n        if (!unit_name_is_valid(f, UNIT_NAME_INSTANCE|UNIT_NAME_TEMPLATE))\n                return -EINVAL;\n        if (!unit_instance_is_valid(i))\n                return -EINVAL;\n\n        assert_se(p = strchr(f, '@'));\n        assert_se(e = strrchr(f, '.'));\n\n        a = p - f;\n        b = strlen(i);\n\n        s = new(char, a + 1 + b + strlen(e) + 1);\n        if (!s)\n                return -ENOMEM;\n\n        strcpy(mempcpy(mempcpy(s, f, a + 1), i, b), e);\n\n        /* Make sure the resulting name still is valid, i.e. didn't grow too large */\n        if (!unit_name_is_valid(s, UNIT_NAME_INSTANCE))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint unit_name_template(const char *f, char **ret) {\n        const char *p, *e;\n        char *s;\n        size_t a;\n\n        assert(f);\n        assert(ret);\n\n        if (!unit_name_is_valid(f, UNIT_NAME_INSTANCE|UNIT_NAME_TEMPLATE))\n                return -EINVAL;\n\n        assert_se(p = strchr(f, '@'));\n        assert_se(e = strrchr(f, '.'));\n\n        a = p - f;\n\n        s = new(char, a + 1 + strlen(e) + 1);\n        if (!s)\n                return -ENOMEM;\n\n        strcpy(mempcpy(s, f, a + 1), e);\n\n        *ret = s;\n        return 0;\n}\n\nint unit_name_from_path(const char *path, const char *suffix, char **ret) {\n        _cleanup_free_ char *p = NULL, *s = NULL;\n        int r;\n\n        assert(path);\n        assert(suffix);\n        assert(ret);\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        r = unit_name_path_escape(path, &p);\n        if (r < 0)\n                return r;\n\n        s = strjoin(p, suffix);\n        if (!s)\n                return -ENOMEM;\n\n        if (strlen(s) >= UNIT_NAME_MAX) /* Return a slightly more descriptive error for this specific condition */\n                return -ENAMETOOLONG;\n\n        /* Refuse this if this got too long or for some other reason didn't result in a valid name */\n        if (!unit_name_is_valid(s, UNIT_NAME_PLAIN))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint unit_name_from_path_instance(const char *prefix, const char *path, const char *suffix, char **ret) {\n        _cleanup_free_ char *p = NULL, *s = NULL;\n        int r;\n\n        assert(prefix);\n        assert(path);\n        assert(suffix);\n        assert(ret);\n\n        if (!unit_prefix_is_valid(prefix))\n                return -EINVAL;\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        r = unit_name_path_escape(path, &p);\n        if (r < 0)\n                return r;\n\n        s = strjoin(prefix, \"@\", p, suffix);\n        if (!s)\n                return -ENOMEM;\n\n        if (strlen(s) >= UNIT_NAME_MAX) /* Return a slightly more descriptive error for this specific condition */\n                return -ENAMETOOLONG;\n\n        /* Refuse this if this got too long or for some other reason didn't result in a valid name */\n        if (!unit_name_is_valid(s, UNIT_NAME_INSTANCE))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint unit_name_to_path(const char *name, char **ret) {\n        _cleanup_free_ char *prefix = NULL;\n        int r;\n\n        assert(name);\n\n        r = unit_name_to_prefix(name, &prefix);\n        if (r < 0)\n                return r;\n\n        return unit_name_path_unescape(prefix, ret);\n}\n\nstatic bool do_escape_mangle(const char *f, bool allow_globs, char *t) {\n        const char *valid_chars;\n        bool mangled = false;\n\n        assert(f);\n        assert(t);\n\n        /* We'll only escape the obvious characters here, to play safe.\n         *\n         * Returns true if any characters were mangled, false otherwise.\n         */\n\n        valid_chars = allow_globs ? VALID_CHARS_GLOB : VALID_CHARS_WITH_AT;\n\n        for (; *f; f++)\n                if (*f == '/') {\n                        *(t++) = '-';\n                        mangled = true;\n                } else if (!strchr(valid_chars, *f)) {\n                        t = do_escape_char(*f, t);\n                        mangled = true;\n                } else\n                        *(t++) = *f;\n        *t = 0;\n\n        return mangled;\n}\n\n/**\n *  Convert a string to a unit name. /dev/blah is converted to dev-blah.device,\n *  /blah/blah is converted to blah-blah.mount, anything else is left alone,\n *  except that @suffix is appended if a valid unit suffix is not present.\n *\n *  If @allow_globs, globs characters are preserved. Otherwise, they are escaped.\n */\nint unit_name_mangle_with_suffix(const char *name, const char *operation, UnitNameMangle flags, const char *suffix, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        bool mangled, suggest_escape = true;\n        int r;\n\n        assert(name);\n        assert(suffix);\n        assert(ret);\n\n        if (isempty(name)) /* We cannot mangle empty unit names to become valid, sorry. */\n                return -EINVAL;\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        /* Already a fully valid unit name? If so, no mangling is necessary... */\n        if (unit_name_is_valid(name, UNIT_NAME_ANY))\n                goto good;\n\n        /* Already a fully valid globbing expression? If so, no mangling is necessary either... */\n        if (string_is_glob(name) && in_charset(name, VALID_CHARS_GLOB)) {\n                if (flags & UNIT_NAME_MANGLE_GLOB)\n                        goto good;\n                log_full(flags & UNIT_NAME_MANGLE_WARN ? LOG_NOTICE : LOG_DEBUG,\n                         \"Glob pattern passed%s%s, but globs are not supported for this.\",\n                         operation ? \" \" : \"\", strempty(operation));\n                suggest_escape = false;\n        }\n\n        if (is_device_path(name)) {\n                r = unit_name_from_path(name, \".device\", ret);\n                if (r >= 0)\n                        return 1;\n                if (r != -EINVAL)\n                        return r;\n        }\n\n        if (path_is_absolute(name)) {\n                r = unit_name_from_path(name, \".mount\", ret);\n                if (r >= 0)\n                        return 1;\n                if (r != -EINVAL)\n                        return r;\n        }\n\n        s = new(char, strlen(name) * 4 + strlen(suffix) + 1);\n        if (!s)\n                return -ENOMEM;\n\n        mangled = do_escape_mangle(name, flags & UNIT_NAME_MANGLE_GLOB, s);\n        if (mangled)\n                log_full(flags & UNIT_NAME_MANGLE_WARN ? LOG_NOTICE : LOG_DEBUG,\n                         \"Invalid unit name \\\"%s\\\" escaped as \\\"%s\\\"%s.\",\n                         name, s,\n                         suggest_escape ? \" (maybe you should use systemd-escape?)\" : \"\");\n\n        /* Append a suffix if it doesn't have any, but only if this is not a glob, so that we can allow\n         * \"foo.*\" as a valid glob. */\n        if ((!(flags & UNIT_NAME_MANGLE_GLOB) || !string_is_glob(s)) && unit_name_to_type(s) < 0)\n                strcat(s, suffix);\n\n        /* Make sure mangling didn't grow this too large (but don't do this check if globbing is allowed,\n         * since globs generally do not qualify as valid unit names) */\n        if (!FLAGS_SET(flags, UNIT_NAME_MANGLE_GLOB) && !unit_name_is_valid(s, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 1;\n\ngood:\n        s = strdup(name);\n        if (!s)\n                return -ENOMEM;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint slice_build_parent_slice(const char *slice, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        char *dash;\n        int r;\n\n        assert(slice);\n        assert(ret);\n\n        if (!slice_name_is_valid(slice))\n                return -EINVAL;\n\n        if (streq(slice, SPECIAL_ROOT_SLICE)) {\n                *ret = NULL;\n                return 0;\n        }\n\n        s = strdup(slice);\n        if (!s)\n                return -ENOMEM;\n\n        dash = strrchr(s, '-');\n        if (dash)\n                strcpy(dash, \".slice\");\n        else {\n                r = free_and_strdup(&s, SPECIAL_ROOT_SLICE);\n                if (r < 0)\n                        return r;\n        }\n\n        *ret = TAKE_PTR(s);\n        return 1;\n}\n\nint slice_build_subslice(const char *slice, const char *name, char **ret) {\n        char *subslice;\n\n        assert(slice);\n        assert(name);\n        assert(ret);\n\n        if (!slice_name_is_valid(slice))\n                return -EINVAL;\n\n        if (!unit_prefix_is_valid(name))\n                return -EINVAL;\n\n        if (streq(slice, SPECIAL_ROOT_SLICE))\n                subslice = strjoin(name, \".slice\");\n        else {\n                char *e;\n\n                assert_se(e = endswith(slice, \".slice\"));\n\n                subslice = new(char, (e - slice) + 1 + strlen(name) + 6 + 1);\n                if (!subslice)\n                        return -ENOMEM;\n\n                stpcpy(stpcpy(stpcpy(mempcpy(subslice, slice, e - slice), \"-\"), name), \".slice\");\n        }\n\n        *ret = subslice;\n        return 0;\n}\n\nbool slice_name_is_valid(const char *name) {\n        const char *p, *e;\n        bool dash = false;\n\n        if (!unit_name_is_valid(name, UNIT_NAME_PLAIN))\n                return false;\n\n        if (streq(name, SPECIAL_ROOT_SLICE))\n                return true;\n\n        e = endswith(name, \".slice\");\n        if (!e)\n                return false;\n\n        for (p = name; p < e; p++) {\n\n                if (*p == '-') {\n\n                        /* Don't allow initial dash */\n                        if (p == name)\n                                return false;\n\n                        /* Don't allow multiple dashes */\n                        if (dash)\n                                return false;\n\n                        dash = true;\n                } else\n                        dash = false;\n        }\n\n        /* Don't allow trailing hash */\n        if (dash)\n                return false;\n\n        return true;\n}\n"], "filenames": ["src/basic/unit-name.c"], "buggy_code_start_loc": [381], "buggy_code_end_loc": [405], "fixing_code_start_loc": [381], "fixing_code_end_loc": [402], "type": "CWE-770", "message": "basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.", "other": {"cve": {"id": "CVE-2021-33910", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-20T19:15:09.783", "lastModified": "2022-06-14T11:15:09.493", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash."}, {"lang": "es", "value": "basic/unit-name.c en systemd anterior a las versiones 246.15, 247.8, 248.5 y 249.1 tiene una asignaci\u00f3n de memoria con un valor de tama\u00f1o excesivo (que involucra a strdupa y alloca para un nombre de ruta controlado por un atacante local) que resulta en una ca\u00edda del sistema operativo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionEndExcluding": "246.15", "matchCriteriaId": "6FA89DC5-B340-4ADD-ABEF-81128C99847E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionStartIncluding": "247", "versionEndExcluding": "247.8", "matchCriteriaId": "77D58076-C816-4A9B-8BBF-46C756E02C74"}, {"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionStartIncluding": "248", "versionEndExcluding": "248.5", "matchCriteriaId": "0FD17152-7791-4FFB-8F38-126207D3D6D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionStartIncluding": "249", "versionEndExcluding": "249.1", "matchCriteriaId": "6F785921-64F2-4975-82D8-65C373F934C9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/163621/Sequoia-A-Deep-Root-In-Linuxs-Filesystem-Layer.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/08/04/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/08/17/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/09/07/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-222547.pdf", "source": "cve@mitre.org"}, {"url": "https://github.com/systemd/systemd-stable/commit/4a1c5f34bd3e1daed4490e9d97918e504d19733b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd-stable/commit/764b74113e36ac5219a4b82a05f311b5a92136ce", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd-stable/commit/b00674347337b7531c92fdb65590ab253bb57538", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd-stable/commit/cfd14c65374027b34dbbc4f0551456c5dc2d1f61", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/b34a4f0e6729de292cb3b0c03c1d48f246ad896b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/pull/20256/commits/441e0115646d54f080e5c3bb0ba477c892861ab9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2LSDMHAKI4LGFOCSPXNVVSEWQFAVFWR7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/42TMJVNYRY65B4QCJICBYOEIVZV3KUYI/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-48", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211104-0008/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4942", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/07/20/2", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd-stable/commit/4a1c5f34bd3e1daed4490e9d97918e504d19733b"}}