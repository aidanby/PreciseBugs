{"buggy_code": ["/*\n * pmcraid.c -- driver for PMC Sierra MaxRAID controller adapters\n *\n * Written By: Anil Ravindranath<anil_ravindranath@pmc-sierra.com>\n *             PMC-Sierra Inc\n *\n * Copyright (C) 2008, 2009 PMC Sierra Inc\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,\n * USA\n *\n */\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/hdreg.h>\n#include <linux/version.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <linux/libata.h>\n#include <linux/mutex.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsicam.h>\n\n#include \"pmcraid.h\"\n\n/*\n *   Module configuration parameters\n */\nstatic unsigned int pmcraid_debug_log;\nstatic unsigned int pmcraid_disable_aen;\nstatic unsigned int pmcraid_log_level = IOASC_LOG_LEVEL_MUST;\nstatic unsigned int pmcraid_enable_msix;\n\n/*\n * Data structures to support multiple adapters by the LLD.\n * pmcraid_adapter_count - count of configured adapters\n */\nstatic atomic_t pmcraid_adapter_count = ATOMIC_INIT(0);\n\n/*\n * Supporting user-level control interface through IOCTL commands.\n * pmcraid_major - major number to use\n * pmcraid_minor - minor number(s) to use\n */\nstatic unsigned int pmcraid_major;\nstatic struct class *pmcraid_class;\nDECLARE_BITMAP(pmcraid_minor, PMCRAID_MAX_ADAPTERS);\n\n/*\n * Module parameters\n */\nMODULE_AUTHOR(\"Anil Ravindranath<anil_ravindranath@pmc-sierra.com>\");\nMODULE_DESCRIPTION(\"PMC Sierra MaxRAID Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(PMCRAID_DRIVER_VERSION);\n\nmodule_param_named(log_level, pmcraid_log_level, uint, (S_IRUGO | S_IWUSR));\nMODULE_PARM_DESC(log_level,\n\t\t \"Enables firmware error code logging, default :1 high-severity\"\n\t\t \" errors, 2: all errors including high-severity errors,\"\n\t\t \" 0: disables logging\");\n\nmodule_param_named(debug, pmcraid_debug_log, uint, (S_IRUGO | S_IWUSR));\nMODULE_PARM_DESC(debug,\n\t\t \"Enable driver verbose message logging. Set 1 to enable.\"\n\t\t \"(default: 0)\");\n\nmodule_param_named(disable_aen, pmcraid_disable_aen, uint, (S_IRUGO | S_IWUSR));\nMODULE_PARM_DESC(disable_aen,\n\t\t \"Disable driver aen notifications to apps. Set 1 to disable.\"\n\t\t \"(default: 0)\");\n\n/* chip specific constants for PMC MaxRAID controllers (same for\n * 0x5220 and 0x8010\n */\nstatic struct pmcraid_chip_details pmcraid_chip_cfg[] = {\n\t{\n\t .ioastatus = 0x0,\n\t .ioarrin = 0x00040,\n\t .mailbox = 0x7FC30,\n\t .global_intr_mask = 0x00034,\n\t .ioa_host_intr = 0x0009C,\n\t .ioa_host_intr_clr = 0x000A0,\n\t .ioa_host_msix_intr = 0x7FC40,\n\t .ioa_host_mask = 0x7FC28,\n\t .ioa_host_mask_clr = 0x7FC28,\n\t .host_ioa_intr = 0x00020,\n\t .host_ioa_intr_clr = 0x00020,\n\t .transop_timeout = 300\n\t }\n};\n\n/*\n * PCI device ids supported by pmcraid driver\n */\nstatic struct pci_device_id pmcraid_pci_table[] __devinitdata = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_PMC, PCI_DEVICE_ID_PMC_MAXRAID),\n\t  0, 0, (kernel_ulong_t)&pmcraid_chip_cfg[0]\n\t},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, pmcraid_pci_table);\n\n\n\n/**\n * pmcraid_slave_alloc - Prepare for commands to a device\n * @scsi_dev: scsi device struct\n *\n * This function is called by mid-layer prior to sending any command to the new\n * device. Stores resource entry details of the device in scsi_device struct.\n * Queuecommand uses the resource handle and other details to fill up IOARCB\n * while sending commands to the device.\n *\n * Return value:\n *\t  0 on success / -ENXIO if device does not exist\n */\nstatic int pmcraid_slave_alloc(struct scsi_device *scsi_dev)\n{\n\tstruct pmcraid_resource_entry *temp, *res = NULL;\n\tstruct pmcraid_instance *pinstance;\n\tu8 target, bus, lun;\n\tunsigned long lock_flags;\n\tint rc = -ENXIO;\n\tu16 fw_version;\n\n\tpinstance = shost_priv(scsi_dev->host);\n\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\n\t/* Driver exposes VSET and GSCSI resources only; all other device types\n\t * are not exposed. Resource list is synchronized using resource lock\n\t * so any traversal or modifications to the list should be done inside\n\t * this lock\n\t */\n\tspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\n\tlist_for_each_entry(temp, &pinstance->used_res_q, queue) {\n\n\t\t/* do not expose VSETs with order-ids > MAX_VSET_TARGETS */\n\t\tif (RES_IS_VSET(temp->cfg_entry)) {\n\t\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\t\ttarget = temp->cfg_entry.unique_flags1;\n\t\t\telse\n\t\t\t\ttarget = temp->cfg_entry.array_id & 0xFF;\n\n\t\t\tif (target > PMCRAID_MAX_VSET_TARGETS)\n\t\t\t\tcontinue;\n\t\t\tbus = PMCRAID_VSET_BUS_ID;\n\t\t\tlun = 0;\n\t\t} else if (RES_IS_GSCSI(temp->cfg_entry)) {\n\t\t\ttarget = RES_TARGET(temp->cfg_entry.resource_address);\n\t\t\tbus = PMCRAID_PHYS_BUS_ID;\n\t\t\tlun = RES_LUN(temp->cfg_entry.resource_address);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bus == scsi_dev->channel &&\n\t\t    target == scsi_dev->id &&\n\t\t    lun == scsi_dev->lun) {\n\t\t\tres = temp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (res) {\n\t\tres->scsi_dev = scsi_dev;\n\t\tscsi_dev->hostdata = res;\n\t\tres->change_detected = 0;\n\t\tatomic_set(&res->read_failures, 0);\n\t\tatomic_set(&res->write_failures, 0);\n\t\trc = 0;\n\t}\n\tspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\n\treturn rc;\n}\n\n/**\n * pmcraid_slave_configure - Configures a SCSI device\n * @scsi_dev: scsi device struct\n *\n * This function is executed by SCSI mid layer just after a device is first\n * scanned (i.e. it has responded to an INQUIRY). For VSET resources, the\n * timeout value (default 30s) will be over-written to a higher value (60s)\n * and max_sectors value will be over-written to 512. It also sets queue depth\n * to host->cmd_per_lun value\n *\n * Return value:\n *\t  0 on success\n */\nstatic int pmcraid_slave_configure(struct scsi_device *scsi_dev)\n{\n\tstruct pmcraid_resource_entry *res = scsi_dev->hostdata;\n\n\tif (!res)\n\t\treturn 0;\n\n\t/* LLD exposes VSETs and Enclosure devices only */\n\tif (RES_IS_GSCSI(res->cfg_entry) &&\n\t    scsi_dev->type != TYPE_ENCLOSURE)\n\t\treturn -ENXIO;\n\n\tpmcraid_info(\"configuring %x:%x:%x:%x\\n\",\n\t\t     scsi_dev->host->unique_id,\n\t\t     scsi_dev->channel,\n\t\t     scsi_dev->id,\n\t\t     scsi_dev->lun);\n\n\tif (RES_IS_GSCSI(res->cfg_entry)) {\n\t\tscsi_dev->allow_restart = 1;\n\t} else if (RES_IS_VSET(res->cfg_entry)) {\n\t\tscsi_dev->allow_restart = 1;\n\t\tblk_queue_rq_timeout(scsi_dev->request_queue,\n\t\t\t\t     PMCRAID_VSET_IO_TIMEOUT);\n\t\tblk_queue_max_hw_sectors(scsi_dev->request_queue,\n\t\t\t\t      PMCRAID_VSET_MAX_SECTORS);\n\t}\n\n\tif (scsi_dev->tagged_supported &&\n\t    (RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry))) {\n\t\tscsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);\n\t\tscsi_adjust_queue_depth(scsi_dev, MSG_SIMPLE_TAG,\n\t\t\t\t\tscsi_dev->host->cmd_per_lun);\n\t} else {\n\t\tscsi_adjust_queue_depth(scsi_dev, 0,\n\t\t\t\t\tscsi_dev->host->cmd_per_lun);\n\t}\n\n\treturn 0;\n}\n\n/**\n * pmcraid_slave_destroy - Unconfigure a SCSI device before removing it\n *\n * @scsi_dev: scsi device struct\n *\n * This is called by mid-layer before removing a device. Pointer assignments\n * done in pmcraid_slave_alloc will be reset to NULL here.\n *\n * Return value\n *   none\n */\nstatic void pmcraid_slave_destroy(struct scsi_device *scsi_dev)\n{\n\tstruct pmcraid_resource_entry *res;\n\n\tres = (struct pmcraid_resource_entry *)scsi_dev->hostdata;\n\n\tif (res)\n\t\tres->scsi_dev = NULL;\n\n\tscsi_dev->hostdata = NULL;\n}\n\n/**\n * pmcraid_change_queue_depth - Change the device's queue depth\n * @scsi_dev: scsi device struct\n * @depth: depth to set\n * @reason: calling context\n *\n * Return value\n *\tactual depth set\n */\nstatic int pmcraid_change_queue_depth(struct scsi_device *scsi_dev, int depth,\n\t\t\t\t      int reason)\n{\n\tif (reason != SCSI_QDEPTH_DEFAULT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (depth > PMCRAID_MAX_CMD_PER_LUN)\n\t\tdepth = PMCRAID_MAX_CMD_PER_LUN;\n\n\tscsi_adjust_queue_depth(scsi_dev, scsi_get_tag_type(scsi_dev), depth);\n\n\treturn scsi_dev->queue_depth;\n}\n\n/**\n * pmcraid_change_queue_type - Change the device's queue type\n * @scsi_dev: scsi device struct\n * @tag: type of tags to use\n *\n * Return value:\n *\tactual queue type set\n */\nstatic int pmcraid_change_queue_type(struct scsi_device *scsi_dev, int tag)\n{\n\tstruct pmcraid_resource_entry *res;\n\n\tres = (struct pmcraid_resource_entry *)scsi_dev->hostdata;\n\n\tif ((res) && scsi_dev->tagged_supported &&\n\t    (RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry))) {\n\t\tscsi_set_tag_type(scsi_dev, tag);\n\n\t\tif (tag)\n\t\t\tscsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);\n\t\telse\n\t\t\tscsi_deactivate_tcq(scsi_dev, scsi_dev->queue_depth);\n\t} else\n\t\ttag = 0;\n\n\treturn tag;\n}\n\n\n/**\n * pmcraid_init_cmdblk - initializes a command block\n *\n * @cmd: pointer to struct pmcraid_cmd to be initialized\n * @index: if >=0 first time initialization; otherwise reinitialization\n *\n * Return Value\n *\t None\n */\nvoid pmcraid_init_cmdblk(struct pmcraid_cmd *cmd, int index)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &(cmd->ioa_cb->ioarcb);\n\tdma_addr_t dma_addr = cmd->ioa_cb_bus_addr;\n\n\tif (index >= 0) {\n\t\t/* first time initialization (called from  probe) */\n\t\tu32 ioasa_offset =\n\t\t\toffsetof(struct pmcraid_control_block, ioasa);\n\n\t\tcmd->index = index;\n\t\tioarcb->response_handle = cpu_to_le32(index << 2);\n\t\tioarcb->ioarcb_bus_addr = cpu_to_le64(dma_addr);\n\t\tioarcb->ioasa_bus_addr = cpu_to_le64(dma_addr + ioasa_offset);\n\t\tioarcb->ioasa_len = cpu_to_le16(sizeof(struct pmcraid_ioasa));\n\t} else {\n\t\t/* re-initialization of various lengths, called once command is\n\t\t * processed by IOA\n\t\t */\n\t\tmemset(&cmd->ioa_cb->ioarcb.cdb, 0, PMCRAID_MAX_CDB_LEN);\n\t\tioarcb->hrrq_id = 0;\n\t\tioarcb->request_flags0 = 0;\n\t\tioarcb->request_flags1 = 0;\n\t\tioarcb->cmd_timeout = 0;\n\t\tioarcb->ioarcb_bus_addr &= (~0x1FULL);\n\t\tioarcb->ioadl_bus_addr = 0;\n\t\tioarcb->ioadl_length = 0;\n\t\tioarcb->data_transfer_length = 0;\n\t\tioarcb->add_cmd_param_length = 0;\n\t\tioarcb->add_cmd_param_offset = 0;\n\t\tcmd->ioa_cb->ioasa.ioasc = 0;\n\t\tcmd->ioa_cb->ioasa.residual_data_length = 0;\n\t\tcmd->time_left = 0;\n\t}\n\n\tcmd->cmd_done = NULL;\n\tcmd->scsi_cmd = NULL;\n\tcmd->release = 0;\n\tcmd->completion_req = 0;\n\tcmd->sense_buffer = 0;\n\tcmd->sense_buffer_dma = 0;\n\tcmd->dma_handle = 0;\n\tinit_timer(&cmd->timer);\n}\n\n/**\n * pmcraid_reinit_cmdblk - reinitialize a command block\n *\n * @cmd: pointer to struct pmcraid_cmd to be reinitialized\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_reinit_cmdblk(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_init_cmdblk(cmd, -1);\n}\n\n/**\n * pmcraid_get_free_cmd - get a free cmd block from command block pool\n * @pinstance: adapter instance structure\n *\n * Return Value:\n *\treturns pointer to cmd block or NULL if no blocks are available\n */\nstatic struct pmcraid_cmd *pmcraid_get_free_cmd(\n\tstruct pmcraid_instance *pinstance\n)\n{\n\tstruct pmcraid_cmd *cmd = NULL;\n\tunsigned long lock_flags;\n\n\t/* free cmd block list is protected by free_pool_lock */\n\tspin_lock_irqsave(&pinstance->free_pool_lock, lock_flags);\n\n\tif (!list_empty(&pinstance->free_cmd_pool)) {\n\t\tcmd = list_entry(pinstance->free_cmd_pool.next,\n\t\t\t\t struct pmcraid_cmd, free_list);\n\t\tlist_del(&cmd->free_list);\n\t}\n\tspin_unlock_irqrestore(&pinstance->free_pool_lock, lock_flags);\n\n\t/* Initialize the command block before giving it the caller */\n\tif (cmd != NULL)\n\t\tpmcraid_reinit_cmdblk(cmd);\n\treturn cmd;\n}\n\n/**\n * pmcraid_return_cmd - return a completed command block back into free pool\n * @cmd: pointer to the command block\n *\n * Return Value:\n *\tnothing\n */\nvoid pmcraid_return_cmd(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(&pinstance->free_pool_lock, lock_flags);\n\tlist_add_tail(&cmd->free_list, &pinstance->free_cmd_pool);\n\tspin_unlock_irqrestore(&pinstance->free_pool_lock, lock_flags);\n}\n\n/**\n * pmcraid_read_interrupts -  reads IOA interrupts\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return value\n *\t interrupts read from IOA\n */\nstatic u32 pmcraid_read_interrupts(struct pmcraid_instance *pinstance)\n{\n\treturn (pinstance->interrupt_mode) ?\n\t\tioread32(pinstance->int_regs.ioa_host_msix_interrupt_reg) :\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_reg);\n}\n\n/**\n * pmcraid_disable_interrupts - Masks and clears all specified interrupts\n *\n * @pinstance: pointer to per adapter instance structure\n * @intrs: interrupts to disable\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_disable_interrupts(\n\tstruct pmcraid_instance *pinstance,\n\tu32 intrs\n)\n{\n\tu32 gmask = ioread32(pinstance->int_regs.global_interrupt_mask_reg);\n\tu32 nmask = gmask | GLOBAL_INTERRUPT_MASK;\n\n\tiowrite32(intrs, pinstance->int_regs.ioa_host_interrupt_clr_reg);\n\tiowrite32(nmask, pinstance->int_regs.global_interrupt_mask_reg);\n\tioread32(pinstance->int_regs.global_interrupt_mask_reg);\n\n\tif (!pinstance->interrupt_mode) {\n\t\tiowrite32(intrs,\n\t\t\tpinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t}\n}\n\n/**\n * pmcraid_enable_interrupts - Enables specified interrupts\n *\n * @pinstance: pointer to per adapter instance structure\n * @intr: interrupts to enable\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_enable_interrupts(\n\tstruct pmcraid_instance *pinstance,\n\tu32 intrs\n)\n{\n\tu32 gmask = ioread32(pinstance->int_regs.global_interrupt_mask_reg);\n\tu32 nmask = gmask & (~GLOBAL_INTERRUPT_MASK);\n\n\tiowrite32(nmask, pinstance->int_regs.global_interrupt_mask_reg);\n\n\tif (!pinstance->interrupt_mode) {\n\t\tiowrite32(~intrs,\n\t\t\t pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t}\n\n\tpmcraid_info(\"enabled interrupts global mask = %x intr_mask = %x\\n\",\n\t\tioread32(pinstance->int_regs.global_interrupt_mask_reg),\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg));\n}\n\n/**\n * pmcraid_clr_trans_op - clear trans to op interrupt\n *\n * @pinstance: pointer to per adapter instance structure\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_clr_trans_op(\n\tstruct pmcraid_instance *pinstance\n)\n{\n\tunsigned long lock_flags;\n\n\tif (!pinstance->interrupt_mode) {\n\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\tpinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t}\n\n\tif (pinstance->reset_cmd != NULL) {\n\t\tdel_timer(&pinstance->reset_cmd->timer);\n\t\tspin_lock_irqsave(\n\t\t\tpinstance->host->host_lock, lock_flags);\n\t\tpinstance->reset_cmd->cmd_done(pinstance->reset_cmd);\n\t\tspin_unlock_irqrestore(\n\t\t\tpinstance->host->host_lock, lock_flags);\n\t}\n}\n\n/**\n * pmcraid_reset_type - Determine the required reset type\n * @pinstance: pointer to adapter instance structure\n *\n * IOA requires hard reset if any of the following conditions is true.\n * 1. If HRRQ valid interrupt is not masked\n * 2. IOA reset alert doorbell is set\n * 3. If there are any error interrupts\n */\nstatic void pmcraid_reset_type(struct pmcraid_instance *pinstance)\n{\n\tu32 mask;\n\tu32 intrs;\n\tu32 alerts;\n\n\tmask = ioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\tintrs = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\n\talerts = ioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\n\tif ((mask & INTRS_HRRQ_VALID) == 0 ||\n\t    (alerts & DOORBELL_IOA_RESET_ALERT) ||\n\t    (intrs & PMCRAID_ERROR_INTERRUPTS)) {\n\t\tpmcraid_info(\"IOA requires hard reset\\n\");\n\t\tpinstance->ioa_hard_reset = 1;\n\t}\n\n\t/* If unit check is active, trigger the dump */\n\tif (intrs & INTRS_IOA_UNIT_CHECK)\n\t\tpinstance->ioa_unit_check = 1;\n}\n\n/**\n * pmcraid_bist_done - completion function for PCI BIST\n * @cmd: pointer to reset command\n * Return Value\n *\tnone\n */\n\nstatic void pmcraid_ioa_reset(struct pmcraid_cmd *);\n\nstatic void pmcraid_bist_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\tint rc;\n\tu16 pci_reg;\n\n\trc = pci_read_config_word(pinstance->pdev, PCI_COMMAND, &pci_reg);\n\n\t/* If PCI config space can't be accessed wait for another two secs */\n\tif ((rc != PCIBIOS_SUCCESSFUL || (!(pci_reg & PCI_COMMAND_MEMORY))) &&\n\t    cmd->time_left > 0) {\n\t\tpmcraid_info(\"BIST not complete, waiting another 2 secs\\n\");\n\t\tcmd->timer.expires = jiffies + cmd->time_left;\n\t\tcmd->time_left = 0;\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.function =\n\t\t\t(void (*)(unsigned long))pmcraid_bist_done;\n\t\tadd_timer(&cmd->timer);\n\t} else {\n\t\tcmd->time_left = 0;\n\t\tpmcraid_info(\"BIST is complete, proceeding with reset\\n\");\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_ioa_reset(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t}\n}\n\n/**\n * pmcraid_start_bist - starts BIST\n * @cmd: pointer to reset cmd\n * Return Value\n *   none\n */\nstatic void pmcraid_start_bist(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 doorbells, intrs;\n\n\t/* proceed with bist and wait for 2 seconds */\n\tiowrite32(DOORBELL_IOA_START_BIST,\n\t\tpinstance->int_regs.host_ioa_interrupt_reg);\n\tdoorbells = ioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\tintrs = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\n\tpmcraid_info(\"doorbells after start bist: %x intrs: %x\\n\",\n\t\t      doorbells, intrs);\n\n\tcmd->time_left = msecs_to_jiffies(PMCRAID_BIST_TIMEOUT);\n\tcmd->timer.data = (unsigned long)cmd;\n\tcmd->timer.expires = jiffies + msecs_to_jiffies(PMCRAID_BIST_TIMEOUT);\n\tcmd->timer.function = (void (*)(unsigned long))pmcraid_bist_done;\n\tadd_timer(&cmd->timer);\n}\n\n/**\n * pmcraid_reset_alert_done - completion routine for reset_alert\n * @cmd: pointer to command block used in reset sequence\n * Return value\n *  None\n */\nstatic void pmcraid_reset_alert_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 status = ioread32(pinstance->ioa_status);\n\tunsigned long lock_flags;\n\n\t/* if the critical operation in progress bit is set or the wait times\n\t * out, invoke reset engine to proceed with hard reset. If there is\n\t * some more time to wait, restart the timer\n\t */\n\tif (((status & INTRS_CRITICAL_OP_IN_PROGRESS) == 0) ||\n\t    cmd->time_left <= 0) {\n\t\tpmcraid_info(\"critical op is reset proceeding with reset\\n\");\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_ioa_reset(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t} else {\n\t\tpmcraid_info(\"critical op is not yet reset waiting again\\n\");\n\t\t/* restart timer if some more time is available to wait */\n\t\tcmd->time_left -= PMCRAID_CHECK_FOR_RESET_TIMEOUT;\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.expires = jiffies + PMCRAID_CHECK_FOR_RESET_TIMEOUT;\n\t\tcmd->timer.function =\n\t\t\t(void (*)(unsigned long))pmcraid_reset_alert_done;\n\t\tadd_timer(&cmd->timer);\n\t}\n}\n\n/**\n * pmcraid_reset_alert - alerts IOA for a possible reset\n * @cmd : command block to be used for reset sequence.\n *\n * Return Value\n *\treturns 0 if pci config-space is accessible and RESET_DOORBELL is\n *\tsuccessfully written to IOA. Returns non-zero in case pci_config_space\n *\tis not accessible\n */\nstatic void pmcraid_notify_ioastate(struct pmcraid_instance *, u32);\nstatic void pmcraid_reset_alert(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 doorbells;\n\tint rc;\n\tu16 pci_reg;\n\n\t/* If we are able to access IOA PCI config space, alert IOA that we are\n\t * going to reset it soon. This enables IOA to preserv persistent error\n\t * data if any. In case memory space is not accessible, proceed with\n\t * BIST or slot_reset\n\t */\n\trc = pci_read_config_word(pinstance->pdev, PCI_COMMAND, &pci_reg);\n\tif ((rc == PCIBIOS_SUCCESSFUL) && (pci_reg & PCI_COMMAND_MEMORY)) {\n\n\t\t/* wait for IOA permission i.e until CRITICAL_OPERATION bit is\n\t\t * reset IOA doesn't generate any interrupts when CRITICAL\n\t\t * OPERATION bit is reset. A timer is started to wait for this\n\t\t * bit to be reset.\n\t\t */\n\t\tcmd->time_left = PMCRAID_RESET_TIMEOUT;\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.expires = jiffies + PMCRAID_CHECK_FOR_RESET_TIMEOUT;\n\t\tcmd->timer.function =\n\t\t\t(void (*)(unsigned long))pmcraid_reset_alert_done;\n\t\tadd_timer(&cmd->timer);\n\n\t\tiowrite32(DOORBELL_IOA_RESET_ALERT,\n\t\t\tpinstance->int_regs.host_ioa_interrupt_reg);\n\t\tdoorbells =\n\t\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tpmcraid_info(\"doorbells after reset alert: %x\\n\", doorbells);\n\t} else {\n\t\tpmcraid_info(\"PCI config is not accessible starting BIST\\n\");\n\t\tpinstance->ioa_state = IOA_STATE_IN_HARD_RESET;\n\t\tpmcraid_start_bist(cmd);\n\t}\n}\n\n/**\n * pmcraid_timeout_handler -  Timeout handler for internally generated ops\n *\n * @cmd : pointer to command structure, that got timedout\n *\n * This function blocks host requests and initiates an adapter reset.\n *\n * Return value:\n *   None\n */\nstatic void pmcraid_timeout_handler(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\tdev_info(&pinstance->pdev->dev,\n\t\t\"Adapter being reset due to cmd(CDB[0] = %x) timeout\\n\",\n\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t/* Command timeouts result in hard reset sequence. The command that got\n\t * timed out may be the one used as part of reset sequence. In this\n\t * case restart reset sequence using the same command block even if\n\t * reset is in progress. Otherwise fail this command and get a free\n\t * command block to restart the reset sequence.\n\t */\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\tif (!pinstance->ioa_reset_in_progress) {\n\t\tpinstance->ioa_reset_attempts = 0;\n\t\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\t\t/* If we are out of command blocks, just return here itself.\n\t\t * Some other command's timeout handler can do the reset job\n\t\t */\n\t\tif (cmd == NULL) {\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\tpmcraid_err(\"no free cmnd block for timeout handler\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tpinstance->reset_cmd = cmd;\n\t\tpinstance->ioa_reset_in_progress = 1;\n\t} else {\n\t\tpmcraid_info(\"reset is already in progress\\n\");\n\n\t\tif (pinstance->reset_cmd != cmd) {\n\t\t\t/* This command should have been given to IOA, this\n\t\t\t * command will be completed by fail_outstanding_cmds\n\t\t\t * anyway\n\t\t\t */\n\t\t\tpmcraid_err(\"cmd is pending but reset in progress\\n\");\n\t\t}\n\n\t\t/* If this command was being used as part of the reset\n\t\t * sequence, set cmd_done pointer to pmcraid_ioa_reset. This\n\t\t * causes fail_outstanding_commands not to return the command\n\t\t * block back to free pool\n\t\t */\n\t\tif (cmd == pinstance->reset_cmd)\n\t\t\tcmd->cmd_done = pmcraid_ioa_reset;\n\t}\n\n\t/* Notify apps of important IOA bringup/bringdown sequences */\n\tif (pinstance->scn.ioa_state != PMC_DEVICE_EVENT_RESET_START &&\n\t    pinstance->scn.ioa_state != PMC_DEVICE_EVENT_SHUTDOWN_START)\n\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\tPMC_DEVICE_EVENT_RESET_START);\n\n\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\tscsi_block_requests(pinstance->host);\n\tpmcraid_reset_alert(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n}\n\n/**\n * pmcraid_internal_done - completion routine for internally generated cmds\n *\n * @cmd: command that got response from IOA\n *\n * Return Value:\n *\t none\n */\nstatic void pmcraid_internal_done(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_info(\"response internal cmd CDB[0] = %x ioasc = %x\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\n\n\t/* Some of the internal commands are sent with callers blocking for the\n\t * response. Same will be indicated as part of cmd->completion_req\n\t * field. Response path needs to wake up any waiters waiting for cmd\n\t * completion if this flag is set.\n\t */\n\tif (cmd->completion_req) {\n\t\tcmd->completion_req = 0;\n\t\tcomplete(&cmd->wait_for_completion);\n\t}\n\n\t/* most of the internal commands are completed by caller itself, so\n\t * no need to return the command block back to free pool until we are\n\t * required to do so (e.g once done with initialization).\n\t */\n\tif (cmd->release) {\n\t\tcmd->release = 0;\n\t\tpmcraid_return_cmd(cmd);\n\t}\n}\n\n/**\n * pmcraid_reinit_cfgtable_done - done function for cfg table reinitialization\n *\n * @cmd: command that got response from IOA\n *\n * This routine is called after driver re-reads configuration table due to a\n * lost CCN. It returns the command block back to free pool and schedules\n * worker thread to add/delete devices into the system.\n *\n * Return Value:\n *\t none\n */\nstatic void pmcraid_reinit_cfgtable_done(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_info(\"response internal cmd CDB[0] = %x ioasc = %x\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\n\n\tif (cmd->release) {\n\t\tcmd->release = 0;\n\t\tpmcraid_return_cmd(cmd);\n\t}\n\tpmcraid_info(\"scheduling worker for config table reinitialization\\n\");\n\tschedule_work(&cmd->drv_inst->worker_q);\n}\n\n/**\n * pmcraid_erp_done - Process completion of SCSI error response from device\n * @cmd: pmcraid_command\n *\n * This function copies the sense buffer into the scsi_cmd struct and completes\n * scsi_cmd by calling scsi_done function.\n *\n * Return value:\n *  none\n */\nstatic void pmcraid_erp_done(struct pmcraid_cmd *cmd)\n{\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\n\tif (PMCRAID_IOASC_SENSE_KEY(ioasc) > 0) {\n\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tscmd_printk(KERN_INFO, scsi_cmd,\n\t\t\t    \"command CDB[0] = %x failed with IOASC: 0x%08X\\n\",\n\t\t\t    cmd->ioa_cb->ioarcb.cdb[0], ioasc);\n\t}\n\n\t/* if we had allocated sense buffers for request sense, copy the sense\n\t * release the buffers\n\t */\n\tif (cmd->sense_buffer != NULL) {\n\t\tmemcpy(scsi_cmd->sense_buffer,\n\t\t       cmd->sense_buffer,\n\t\t       SCSI_SENSE_BUFFERSIZE);\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t    cmd->sense_buffer, cmd->sense_buffer_dma);\n\t\tcmd->sense_buffer = NULL;\n\t\tcmd->sense_buffer_dma = 0;\n\t}\n\n\tscsi_dma_unmap(scsi_cmd);\n\tpmcraid_return_cmd(cmd);\n\tscsi_cmd->scsi_done(scsi_cmd);\n}\n\n/**\n * pmcraid_fire_command - sends an IOA command to adapter\n *\n * This function adds the given block into pending command list\n * and returns without waiting\n *\n * @cmd : command to be sent to the device\n *\n * Return Value\n *\tNone\n */\nstatic void _pmcraid_fire_command(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\t/* Add this command block to pending cmd pool. We do this prior to\n\t * writting IOARCB to ioarrin because IOA might complete the command\n\t * by the time we are about to add it to the list. Response handler\n\t * (isr/tasklet) looks for cmd block in the pending pending list.\n\t */\n\tspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\n\tlist_add_tail(&cmd->free_list, &pinstance->pending_cmd_pool);\n\tspin_unlock_irqrestore(&pinstance->pending_pool_lock, lock_flags);\n\tatomic_inc(&pinstance->outstanding_cmds);\n\n\t/* driver writes lower 32-bit value of IOARCB address only */\n\tmb();\n\tiowrite32(le32_to_cpu(cmd->ioa_cb->ioarcb.ioarcb_bus_addr),\n\t\t  pinstance->ioarrin);\n}\n\n/**\n * pmcraid_send_cmd - fires a command to IOA\n *\n * This function also sets up timeout function, and command completion\n * function\n *\n * @cmd: pointer to the command block to be fired to IOA\n * @cmd_done: command completion function, called once IOA responds\n * @timeout: timeout to wait for this command completion\n * @timeout_func: timeout handler\n *\n * Return value\n *   none\n */\nstatic void pmcraid_send_cmd(\n\tstruct pmcraid_cmd *cmd,\n\tvoid (*cmd_done) (struct pmcraid_cmd *),\n\tunsigned long timeout,\n\tvoid (*timeout_func) (struct pmcraid_cmd *)\n)\n{\n\t/* initialize done function */\n\tcmd->cmd_done = cmd_done;\n\n\tif (timeout_func) {\n\t\t/* setup timeout handler */\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.expires = jiffies + timeout;\n\t\tcmd->timer.function = (void (*)(unsigned long))timeout_func;\n\t\tadd_timer(&cmd->timer);\n\t}\n\n\t/* fire the command to IOA */\n\t_pmcraid_fire_command(cmd);\n}\n\n/**\n * pmcraid_ioa_shutdown_done - completion function for IOA shutdown command\n * @cmd: pointer to the command block used for sending IOA shutdown command\n *\n * Return value\n *  None\n */\nstatic void pmcraid_ioa_shutdown_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\tpmcraid_ioa_reset(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n}\n\n/**\n * pmcraid_ioa_shutdown - sends SHUTDOWN command to ioa\n *\n * @cmd: pointer to the command block used as part of reset sequence\n *\n * Return Value\n *  None\n */\nstatic void pmcraid_ioa_shutdown(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_info(\"response for Cancel CCN CDB[0] = %x ioasc = %x\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\n\n\t/* Note that commands sent during reset require next command to be sent\n\t * to IOA. Hence reinit the done function as well as timeout function\n\t */\n\tpmcraid_reinit_cmdblk(cmd);\n\tcmd->ioa_cb->ioarcb.request_type = REQ_TYPE_IOACMD;\n\tcmd->ioa_cb->ioarcb.resource_handle =\n\t\tcpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tcmd->ioa_cb->ioarcb.cdb[0] = PMCRAID_IOA_SHUTDOWN;\n\tcmd->ioa_cb->ioarcb.cdb[1] = PMCRAID_SHUTDOWN_NORMAL;\n\n\t/* fire shutdown command to hardware. */\n\tpmcraid_info(\"firing normal shutdown command (%d) to IOA\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle));\n\n\tpmcraid_notify_ioastate(cmd->drv_inst, PMC_DEVICE_EVENT_SHUTDOWN_START);\n\n\tpmcraid_send_cmd(cmd, pmcraid_ioa_shutdown_done,\n\t\t\t PMCRAID_SHUTDOWN_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_get_fwversion_done - completion function for get_fwversion\n *\n * @cmd: pointer to command block used to send INQUIRY command\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_querycfg(struct pmcraid_cmd *);\n\nstatic void pmcraid_get_fwversion_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\tunsigned long lock_flags;\n\n\t/* configuration table entry size depends on firmware version. If fw\n\t * version is not known, it is not possible to interpret IOA config\n\t * table\n\t */\n\tif (ioasc) {\n\t\tpmcraid_err(\"IOA Inquiry failed with %x\\n\", ioasc);\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\tpmcraid_reset_alert(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t} else  {\n\t\tpmcraid_querycfg(cmd);\n\t}\n}\n\n/**\n * pmcraid_get_fwversion - reads firmware version information\n *\n * @cmd: pointer to command block used to send INQUIRY command\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_get_fwversion(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu16 data_size = sizeof(struct pmcraid_inquiry_data);\n\n\tpmcraid_reinit_cmdblk(cmd);\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->cdb[0] = INQUIRY;\n\tioarcb->cdb[1] = 1;\n\tioarcb->cdb[2] = 0xD0;\n\tioarcb->cdb[3] = (data_size >> 8) & 0xFF;\n\tioarcb->cdb[4] = data_size & 0xFF;\n\n\t/* Since entire inquiry data it can be part of IOARCB itself\n\t */\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length = cpu_to_le32(data_size);\n\tioadl = &(ioarcb->add_data.u.ioadl[0]);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\tioadl->address = cpu_to_le64(pinstance->inq_data_baddr);\n\tioadl->data_len = cpu_to_le32(data_size);\n\n\tpmcraid_send_cmd(cmd, pmcraid_get_fwversion_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_identify_hrrq - registers host rrq buffers with IOA\n * @cmd: pointer to command block to be used for identify hrrq\n *\n * Return Value\n *\t none\n */\nstatic void pmcraid_identify_hrrq(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tint index = cmd->hrrq_index;\n\t__be64 hrrq_addr = cpu_to_be64(pinstance->hrrq_start_bus_addr[index]);\n\tu32 hrrq_size = cpu_to_be32(sizeof(u32) * PMCRAID_MAX_CMD);\n\tvoid (*done_function)(struct pmcraid_cmd *);\n\n\tpmcraid_reinit_cmdblk(cmd);\n\tcmd->hrrq_index = index + 1;\n\n\tif (cmd->hrrq_index < pinstance->num_hrrq) {\n\t\tdone_function = pmcraid_identify_hrrq;\n\t} else {\n\t\tcmd->hrrq_index = 0;\n\t\tdone_function = pmcraid_get_fwversion;\n\t}\n\n\t/* Initialize ioarcb */\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\n\t/* initialize the hrrq number where IOA will respond to this command */\n\tioarcb->hrrq_id = index;\n\tioarcb->cdb[0] = PMCRAID_IDENTIFY_HRRQ;\n\tioarcb->cdb[1] = index;\n\n\t/* IOA expects 64-bit pci address to be written in B.E format\n\t * (i.e cdb[2]=MSByte..cdb[9]=LSB.\n\t */\n\tpmcraid_info(\"HRRQ_IDENTIFY with hrrq:ioarcb:index => %llx:%llx:%x\\n\",\n\t\t     hrrq_addr, ioarcb->ioarcb_bus_addr, index);\n\n\tmemcpy(&(ioarcb->cdb[2]), &hrrq_addr, sizeof(hrrq_addr));\n\tmemcpy(&(ioarcb->cdb[10]), &hrrq_size, sizeof(hrrq_size));\n\n\t/* Subsequent commands require HRRQ identification to be successful.\n\t * Note that this gets called even during reset from SCSI mid-layer\n\t * or tasklet\n\t */\n\tpmcraid_send_cmd(cmd, done_function,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\nstatic void pmcraid_process_ccn(struct pmcraid_cmd *cmd);\nstatic void pmcraid_process_ldn(struct pmcraid_cmd *cmd);\n\n/**\n * pmcraid_send_hcam_cmd - send an initialized command block(HCAM) to IOA\n *\n * @cmd: initialized command block pointer\n *\n * Return Value\n *   none\n */\nstatic void pmcraid_send_hcam_cmd(struct pmcraid_cmd *cmd)\n{\n\tif (cmd->ioa_cb->ioarcb.cdb[1] == PMCRAID_HCAM_CODE_CONFIG_CHANGE)\n\t\tatomic_set(&(cmd->drv_inst->ccn.ignore), 0);\n\telse\n\t\tatomic_set(&(cmd->drv_inst->ldn.ignore), 0);\n\n\tpmcraid_send_cmd(cmd, cmd->cmd_done, 0, NULL);\n}\n\n/**\n * pmcraid_init_hcam - send an initialized command block(HCAM) to IOA\n *\n * @pinstance: pointer to adapter instance structure\n * @type: HCAM type\n *\n * Return Value\n *   pointer to initialized pmcraid_cmd structure or NULL\n */\nstatic struct pmcraid_cmd *pmcraid_init_hcam\n(\n\tstruct pmcraid_instance *pinstance,\n\tu8 type\n)\n{\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl;\n\tstruct pmcraid_hostrcb *hcam;\n\tvoid (*cmd_done) (struct pmcraid_cmd *);\n\tdma_addr_t dma;\n\tint rcb_size;\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"no free command blocks for hcam\\n\");\n\t\treturn cmd;\n\t}\n\n\tif (type == PMCRAID_HCAM_CODE_CONFIG_CHANGE) {\n\t\trcb_size = sizeof(struct pmcraid_hcam_ccn_ext);\n\t\tcmd_done = pmcraid_process_ccn;\n\t\tdma = pinstance->ccn.baddr + PMCRAID_AEN_HDR_SIZE;\n\t\thcam = &pinstance->ccn;\n\t} else {\n\t\trcb_size = sizeof(struct pmcraid_hcam_ldn);\n\t\tcmd_done = pmcraid_process_ldn;\n\t\tdma = pinstance->ldn.baddr + PMCRAID_AEN_HDR_SIZE;\n\t\thcam = &pinstance->ldn;\n\t}\n\n\t/* initialize command pointer used for HCAM registration */\n\thcam->cmd = cmd;\n\n\tioarcb = &cmd->ioa_cb->ioarcb;\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioadl = ioarcb->add_data.u.ioadl;\n\n\t/* Initialize ioarcb */\n\tioarcb->request_type = REQ_TYPE_HCAM;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->cdb[0] = PMCRAID_HOST_CONTROLLED_ASYNC;\n\tioarcb->cdb[1] = type;\n\tioarcb->cdb[7] = (rcb_size >> 8) & 0xFF;\n\tioarcb->cdb[8] = (rcb_size) & 0xFF;\n\n\tioarcb->data_transfer_length = cpu_to_le32(rcb_size);\n\n\tioadl[0].flags |= IOADL_FLAGS_READ_LAST;\n\tioadl[0].data_len = cpu_to_le32(rcb_size);\n\tioadl[0].address = cpu_to_le32(dma);\n\n\tcmd->cmd_done = cmd_done;\n\treturn cmd;\n}\n\n/**\n * pmcraid_send_hcam - Send an HCAM to IOA\n * @pinstance: ioa config struct\n * @type: HCAM type\n *\n * This function will send a Host Controlled Async command to IOA.\n *\n * Return value:\n *\tnone\n */\nstatic void pmcraid_send_hcam(struct pmcraid_instance *pinstance, u8 type)\n{\n\tstruct pmcraid_cmd *cmd = pmcraid_init_hcam(pinstance, type);\n\tpmcraid_send_hcam_cmd(cmd);\n}\n\n\n/**\n * pmcraid_prepare_cancel_cmd - prepares a command block to abort another\n *\n * @cmd: pointer to cmd that is used as cancelling command\n * @cmd_to_cancel: pointer to the command that needs to be cancelled\n */\nstatic void pmcraid_prepare_cancel_cmd(\n\tstruct pmcraid_cmd *cmd,\n\tstruct pmcraid_cmd *cmd_to_cancel\n)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\t__be64 ioarcb_addr = cmd_to_cancel->ioa_cb->ioarcb.ioarcb_bus_addr;\n\n\t/* Get the resource handle to where the command to be aborted has been\n\t * sent.\n\t */\n\tioarcb->resource_handle = cmd_to_cancel->ioa_cb->ioarcb.resource_handle;\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\n\tioarcb->cdb[0] = PMCRAID_ABORT_CMD;\n\n\t/* IOARCB address of the command to be cancelled is given in\n\t * cdb[2]..cdb[9] is Big-Endian format. Note that length bits in\n\t * IOARCB address are not masked.\n\t */\n\tioarcb_addr = cpu_to_be64(ioarcb_addr);\n\tmemcpy(&(ioarcb->cdb[2]), &ioarcb_addr, sizeof(ioarcb_addr));\n}\n\n/**\n * pmcraid_cancel_hcam - sends ABORT task to abort a given HCAM\n *\n * @cmd: command to be used as cancelling command\n * @type: HCAM type\n * @cmd_done: op done function for the cancelling command\n */\nstatic void pmcraid_cancel_hcam(\n\tstruct pmcraid_cmd *cmd,\n\tu8 type,\n\tvoid (*cmd_done) (struct pmcraid_cmd *)\n)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_hostrcb  *hcam;\n\n\tpinstance = cmd->drv_inst;\n\thcam =  (type == PMCRAID_HCAM_CODE_LOG_DATA) ?\n\t\t&pinstance->ldn : &pinstance->ccn;\n\n\t/* prepare for cancelling previous hcam command. If the HCAM is\n\t * currently not pending with IOA, we would have hcam->cmd as non-null\n\t */\n\tif (hcam->cmd == NULL)\n\t\treturn;\n\n\tpmcraid_prepare_cancel_cmd(cmd, hcam->cmd);\n\n\t/* writing to IOARRIN must be protected by host_lock, as mid-layer\n\t * schedule queuecommand while we are doing this\n\t */\n\tpmcraid_send_cmd(cmd, cmd_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_cancel_ccn - cancel CCN HCAM already registered with IOA\n *\n * @cmd: command block to be used for cancelling the HCAM\n */\nstatic void pmcraid_cancel_ccn(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_info(\"response for Cancel LDN CDB[0] = %x ioasc = %x\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\n\n\tpmcraid_reinit_cmdblk(cmd);\n\n\tpmcraid_cancel_hcam(cmd,\n\t\t\t    PMCRAID_HCAM_CODE_CONFIG_CHANGE,\n\t\t\t    pmcraid_ioa_shutdown);\n}\n\n/**\n * pmcraid_cancel_ldn - cancel LDN HCAM already registered with IOA\n *\n * @cmd: command block to be used for cancelling the HCAM\n */\nstatic void pmcraid_cancel_ldn(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_cancel_hcam(cmd,\n\t\t\t    PMCRAID_HCAM_CODE_LOG_DATA,\n\t\t\t    pmcraid_cancel_ccn);\n}\n\n/**\n * pmcraid_expose_resource - check if the resource can be exposed to OS\n *\n * @fw_version: firmware version code\n * @cfgte: pointer to configuration table entry of the resource\n *\n * Return value:\n *\ttrue if resource can be added to midlayer, false(0) otherwise\n */\nstatic int pmcraid_expose_resource(u16 fw_version,\n\t\t\t\t   struct pmcraid_config_table_entry *cfgte)\n{\n\tint retval = 0;\n\n\tif (cfgte->resource_type == RES_TYPE_VSET) {\n\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\tretval = ((cfgte->unique_flags1 & 0x80) == 0);\n\t\telse\n\t\t\tretval = ((cfgte->unique_flags0 & 0x80) == 0 &&\n\t\t\t\t  (cfgte->unique_flags1 & 0x80) == 0);\n\n\t} else if (cfgte->resource_type == RES_TYPE_GSCSI)\n\t\tretval = (RES_BUS(cfgte->resource_address) !=\n\t\t\t\tPMCRAID_VIRTUAL_ENCL_BUS_ID);\n\treturn retval;\n}\n\n/* attributes supported by pmcraid_event_family */\nenum {\n\tPMCRAID_AEN_ATTR_UNSPEC,\n\tPMCRAID_AEN_ATTR_EVENT,\n\t__PMCRAID_AEN_ATTR_MAX,\n};\n#define PMCRAID_AEN_ATTR_MAX (__PMCRAID_AEN_ATTR_MAX - 1)\n\n/* commands supported by pmcraid_event_family */\nenum {\n\tPMCRAID_AEN_CMD_UNSPEC,\n\tPMCRAID_AEN_CMD_EVENT,\n\t__PMCRAID_AEN_CMD_MAX,\n};\n#define PMCRAID_AEN_CMD_MAX (__PMCRAID_AEN_CMD_MAX - 1)\n\nstatic struct genl_family pmcraid_event_family = {\n\t.id = GENL_ID_GENERATE,\n\t.name = \"pmcraid\",\n\t.version = 1,\n\t.maxattr = PMCRAID_AEN_ATTR_MAX\n};\n\n/**\n * pmcraid_netlink_init - registers pmcraid_event_family\n *\n * Return value:\n *\t0 if the pmcraid_event_family is successfully registered\n *\twith netlink generic, non-zero otherwise\n */\nstatic int pmcraid_netlink_init(void)\n{\n\tint result;\n\n\tresult = genl_register_family(&pmcraid_event_family);\n\n\tif (result)\n\t\treturn result;\n\n\tpmcraid_info(\"registered NETLINK GENERIC group: %d\\n\",\n\t\t     pmcraid_event_family.id);\n\n\treturn result;\n}\n\n/**\n * pmcraid_netlink_release - unregisters pmcraid_event_family\n *\n * Return value:\n *\tnone\n */\nstatic void pmcraid_netlink_release(void)\n{\n\tgenl_unregister_family(&pmcraid_event_family);\n}\n\n/**\n * pmcraid_notify_aen - sends event msg to user space application\n * @pinstance: pointer to adapter instance structure\n * @type: HCAM type\n *\n * Return value:\n *\t0 if success, error value in case of any failure.\n */\nstatic int pmcraid_notify_aen(\n\tstruct pmcraid_instance *pinstance,\n\tstruct pmcraid_aen_msg  *aen_msg,\n\tu32    data_size\n)\n{\n\tstruct sk_buff *skb;\n\tvoid *msg_header;\n\tu32  total_size, nla_genl_hdr_total_size;\n\tint result;\n\n\taen_msg->hostno = (pinstance->host->unique_id << 16 |\n\t\t\t   MINOR(pinstance->cdev.dev));\n\taen_msg->length = data_size;\n\n\tdata_size += sizeof(*aen_msg);\n\n\ttotal_size = nla_total_size(data_size);\n\t/* Add GENL_HDR to total_size */\n\tnla_genl_hdr_total_size =\n\t\t(total_size + (GENL_HDRLEN +\n\t\t((struct genl_family *)&pmcraid_event_family)->hdrsize)\n\t\t + NLMSG_HDRLEN);\n\tskb = genlmsg_new(nla_genl_hdr_total_size, GFP_ATOMIC);\n\n\n\tif (!skb) {\n\t\tpmcraid_err(\"Failed to allocate aen data SKB of size: %x\\n\",\n\t\t\t     total_size);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* add the genetlink message header */\n\tmsg_header = genlmsg_put(skb, 0, 0,\n\t\t\t\t &pmcraid_event_family, 0,\n\t\t\t\t PMCRAID_AEN_CMD_EVENT);\n\tif (!msg_header) {\n\t\tpmcraid_err(\"failed to copy command details\\n\");\n\t\tnlmsg_free(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tresult = nla_put(skb, PMCRAID_AEN_ATTR_EVENT, data_size, aen_msg);\n\n\tif (result) {\n\t\tpmcraid_err(\"failed to copy AEN attribute data\\n\");\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t/* send genetlink multicast message to notify appplications */\n\tresult = genlmsg_end(skb, msg_header);\n\n\tif (result < 0) {\n\t\tpmcraid_err(\"genlmsg_end failed\\n\");\n\t\tnlmsg_free(skb);\n\t\treturn result;\n\t}\n\n\tresult =\n\t\tgenlmsg_multicast(skb, 0, pmcraid_event_family.id, GFP_ATOMIC);\n\n\t/* If there are no listeners, genlmsg_multicast may return non-zero\n\t * value.\n\t */\n\tif (result)\n\t\tpmcraid_info(\"error (%x) sending aen event message\\n\", result);\n\treturn result;\n}\n\n/**\n * pmcraid_notify_ccn - notifies about CCN event msg to user space\n * @pinstance: pointer adapter instance structure\n *\n * Return value:\n *\t0 if success, error value in case of any failure\n */\nstatic int pmcraid_notify_ccn(struct pmcraid_instance *pinstance)\n{\n\treturn pmcraid_notify_aen(pinstance,\n\t\t\t\tpinstance->ccn.msg,\n\t\t\t\tpinstance->ccn.hcam->data_len +\n\t\t\t\tsizeof(struct pmcraid_hcam_hdr));\n}\n\n/**\n * pmcraid_notify_ldn - notifies about CCN event msg to user space\n * @pinstance: pointer adapter instance structure\n *\n * Return value:\n *\t0 if success, error value in case of any failure\n */\nstatic int pmcraid_notify_ldn(struct pmcraid_instance *pinstance)\n{\n\treturn pmcraid_notify_aen(pinstance,\n\t\t\t\tpinstance->ldn.msg,\n\t\t\t\tpinstance->ldn.hcam->data_len +\n\t\t\t\tsizeof(struct pmcraid_hcam_hdr));\n}\n\n/**\n * pmcraid_notify_ioastate - sends IOA state event msg to user space\n * @pinstance: pointer adapter instance structure\n * @evt: controller state event to be sent\n *\n * Return value:\n *\t0 if success, error value in case of any failure\n */\nstatic void pmcraid_notify_ioastate(struct pmcraid_instance *pinstance, u32 evt)\n{\n\tpinstance->scn.ioa_state = evt;\n\tpmcraid_notify_aen(pinstance,\n\t\t\t  &pinstance->scn.msg,\n\t\t\t  sizeof(u32));\n}\n\n/**\n * pmcraid_handle_config_change - Handle a config change from the adapter\n * @pinstance: pointer to per adapter instance structure\n *\n * Return value:\n *  none\n */\n\nstatic void pmcraid_handle_config_change(struct pmcraid_instance *pinstance)\n{\n\tstruct pmcraid_config_table_entry *cfg_entry;\n\tstruct pmcraid_hcam_ccn *ccn_hcam;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cfgcmd;\n\tstruct pmcraid_resource_entry *res = NULL;\n\tunsigned long lock_flags;\n\tunsigned long host_lock_flags;\n\tu32 new_entry = 1;\n\tu32 hidden_entry = 0;\n\tu16 fw_version;\n\tint rc;\n\n\tccn_hcam = (struct pmcraid_hcam_ccn *)pinstance->ccn.hcam;\n\tcfg_entry = &ccn_hcam->cfg_entry;\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\n\tpmcraid_info(\"CCN(%x): %x timestamp: %llx type: %x lost: %x flags: %x \\\n\t\t res: %x:%x:%x:%x\\n\",\n\t\t pinstance->ccn.hcam->ilid,\n\t\t pinstance->ccn.hcam->op_code,\n\t\t((pinstance->ccn.hcam->timestamp1) |\n\t\t((pinstance->ccn.hcam->timestamp2 & 0xffffffffLL) << 32)),\n\t\t pinstance->ccn.hcam->notification_type,\n\t\t pinstance->ccn.hcam->notification_lost,\n\t\t pinstance->ccn.hcam->flags,\n\t\t pinstance->host->unique_id,\n\t\t RES_IS_VSET(*cfg_entry) ? PMCRAID_VSET_BUS_ID :\n\t\t (RES_IS_GSCSI(*cfg_entry) ? PMCRAID_PHYS_BUS_ID :\n\t\t\tRES_BUS(cfg_entry->resource_address)),\n\t\t RES_IS_VSET(*cfg_entry) ?\n\t\t\t(fw_version <= PMCRAID_FW_VERSION_1 ?\n\t\t\t\tcfg_entry->unique_flags1 :\n\t\t\t\t\tcfg_entry->array_id & 0xFF) :\n\t\t\tRES_TARGET(cfg_entry->resource_address),\n\t\t RES_LUN(cfg_entry->resource_address));\n\n\n\t/* If this HCAM indicates a lost notification, read the config table */\n\tif (pinstance->ccn.hcam->notification_lost) {\n\t\tcfgcmd = pmcraid_get_free_cmd(pinstance);\n\t\tif (cfgcmd) {\n\t\t\tpmcraid_info(\"lost CCN, reading config table\\b\");\n\t\t\tpinstance->reinit_cfg_table = 1;\n\t\t\tpmcraid_querycfg(cfgcmd);\n\t\t} else {\n\t\t\tpmcraid_err(\"lost CCN, no free cmd for querycfg\\n\");\n\t\t}\n\t\tgoto out_notify_apps;\n\t}\n\n\t/* If this resource is not going to be added to mid-layer, just notify\n\t * applications and return. If this notification is about hiding a VSET\n\t * resource, check if it was exposed already.\n\t */\n\tif (pinstance->ccn.hcam->notification_type ==\n\t    NOTIFICATION_TYPE_ENTRY_CHANGED &&\n\t    cfg_entry->resource_type == RES_TYPE_VSET) {\n\n\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\thidden_entry = (cfg_entry->unique_flags1 & 0x80) != 0;\n\t\telse\n\t\t\thidden_entry = (cfg_entry->unique_flags1 & 0x80) != 0;\n\n\t} else if (!pmcraid_expose_resource(fw_version, cfg_entry)) {\n\t\tgoto out_notify_apps;\n\t}\n\n\tspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\n\tlist_for_each_entry(res, &pinstance->used_res_q, queue) {\n\t\trc = memcmp(&res->cfg_entry.resource_address,\n\t\t\t    &cfg_entry->resource_address,\n\t\t\t    sizeof(cfg_entry->resource_address));\n\t\tif (!rc) {\n\t\t\tnew_entry = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_entry) {\n\n\t\tif (hidden_entry) {\n\t\t\tspin_unlock_irqrestore(&pinstance->resource_lock,\n\t\t\t\t\t\tlock_flags);\n\t\t\tgoto out_notify_apps;\n\t\t}\n\n\t\t/* If there are more number of resources than what driver can\n\t\t * manage, do not notify the applications about the CCN. Just\n\t\t * ignore this notifications and re-register the same HCAM\n\t\t */\n\t\tif (list_empty(&pinstance->free_res_q)) {\n\t\t\tspin_unlock_irqrestore(&pinstance->resource_lock,\n\t\t\t\t\t\tlock_flags);\n\t\t\tpmcraid_err(\"too many resources attached\\n\");\n\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\t  host_lock_flags);\n\t\t\tpmcraid_send_hcam(pinstance,\n\t\t\t\t\t  PMCRAID_HCAM_CODE_CONFIG_CHANGE);\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       host_lock_flags);\n\t\t\treturn;\n\t\t}\n\n\t\tres = list_entry(pinstance->free_res_q.next,\n\t\t\t\t struct pmcraid_resource_entry, queue);\n\n\t\tlist_del(&res->queue);\n\t\tres->scsi_dev = NULL;\n\t\tres->reset_progress = 0;\n\t\tlist_add_tail(&res->queue, &pinstance->used_res_q);\n\t}\n\n\tmemcpy(&res->cfg_entry, cfg_entry, pinstance->config_table_entry_size);\n\n\tif (pinstance->ccn.hcam->notification_type ==\n\t    NOTIFICATION_TYPE_ENTRY_DELETED || hidden_entry) {\n\t\tif (res->scsi_dev) {\n\t\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\t\tres->cfg_entry.unique_flags1 &= 0x7F;\n\t\t\telse\n\t\t\t\tres->cfg_entry.array_id &= 0xFF;\n\t\t\tres->change_detected = RES_CHANGE_DEL;\n\t\t\tres->cfg_entry.resource_handle =\n\t\t\t\tPMCRAID_INVALID_RES_HANDLE;\n\t\t\tschedule_work(&pinstance->worker_q);\n\t\t} else {\n\t\t\t/* This may be one of the non-exposed resources */\n\t\t\tlist_move_tail(&res->queue, &pinstance->free_res_q);\n\t\t}\n\t} else if (!res->scsi_dev) {\n\t\tres->change_detected = RES_CHANGE_ADD;\n\t\tschedule_work(&pinstance->worker_q);\n\t}\n\tspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\n\nout_notify_apps:\n\n\t/* Notify configuration changes to registered applications.*/\n\tif (!pmcraid_disable_aen)\n\t\tpmcraid_notify_ccn(pinstance);\n\n\tcmd = pmcraid_init_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\n\tif (cmd)\n\t\tpmcraid_send_hcam_cmd(cmd);\n}\n\n/**\n * pmcraid_get_error_info - return error string for an ioasc\n * @ioasc: ioasc code\n * Return Value\n *\t none\n */\nstatic struct pmcraid_ioasc_error *pmcraid_get_error_info(u32 ioasc)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(pmcraid_ioasc_error_table); i++) {\n\t\tif (pmcraid_ioasc_error_table[i].ioasc_code == ioasc)\n\t\t\treturn &pmcraid_ioasc_error_table[i];\n\t}\n\treturn NULL;\n}\n\n/**\n * pmcraid_ioasc_logger - log IOASC information based user-settings\n * @ioasc: ioasc code\n * @cmd: pointer to command that resulted in 'ioasc'\n */\nvoid pmcraid_ioasc_logger(u32 ioasc, struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioasc_error *error_info = pmcraid_get_error_info(ioasc);\n\n\tif (error_info == NULL ||\n\t\tcmd->drv_inst->current_log_level < error_info->log_level)\n\t\treturn;\n\n\t/* log the error string */\n\tpmcraid_err(\"cmd [%x] for resource %x failed with %x(%s)\\n\",\n\t\tcmd->ioa_cb->ioarcb.cdb[0],\n\t\tcmd->ioa_cb->ioarcb.resource_handle,\n\t\tle32_to_cpu(ioasc), error_info->error_string);\n}\n\n/**\n * pmcraid_handle_error_log - Handle a config change (error log) from the IOA\n *\n * @pinstance: pointer to per adapter instance structure\n *\n * Return value:\n *  none\n */\nstatic void pmcraid_handle_error_log(struct pmcraid_instance *pinstance)\n{\n\tstruct pmcraid_hcam_ldn *hcam_ldn;\n\tu32 ioasc;\n\n\thcam_ldn = (struct pmcraid_hcam_ldn *)pinstance->ldn.hcam;\n\n\tpmcraid_info\n\t\t(\"LDN(%x): %x type: %x lost: %x flags: %x overlay id: %x\\n\",\n\t\t pinstance->ldn.hcam->ilid,\n\t\t pinstance->ldn.hcam->op_code,\n\t\t pinstance->ldn.hcam->notification_type,\n\t\t pinstance->ldn.hcam->notification_lost,\n\t\t pinstance->ldn.hcam->flags,\n\t\t pinstance->ldn.hcam->overlay_id);\n\n\t/* log only the errors, no need to log informational log entries */\n\tif (pinstance->ldn.hcam->notification_type !=\n\t    NOTIFICATION_TYPE_ERROR_LOG)\n\t\treturn;\n\n\tif (pinstance->ldn.hcam->notification_lost ==\n\t    HOSTRCB_NOTIFICATIONS_LOST)\n\t\tdev_info(&pinstance->pdev->dev, \"Error notifications lost\\n\");\n\n\tioasc = le32_to_cpu(hcam_ldn->error_log.fd_ioasc);\n\n\tif (ioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET ||\n\t\tioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET_BY_OTHER) {\n\t\tdev_info(&pinstance->pdev->dev,\n\t\t\t\"UnitAttention due to IOA Bus Reset\\n\");\n\t\tscsi_report_bus_reset(\n\t\t\tpinstance->host,\n\t\t\tRES_BUS(hcam_ldn->error_log.fd_ra));\n\t}\n\n\treturn;\n}\n\n/**\n * pmcraid_process_ccn - Op done function for a CCN.\n * @cmd: pointer to command struct\n *\n * This function is the op done function for a configuration\n * change notification\n *\n * Return value:\n * none\n */\nstatic void pmcraid_process_ccn(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\tunsigned long lock_flags;\n\n\tpinstance->ccn.cmd = NULL;\n\tpmcraid_return_cmd(cmd);\n\n\t/* If driver initiated IOA reset happened while this hcam was pending\n\t * with IOA, or IOA bringdown sequence is in progress, no need to\n\t * re-register the hcam\n\t */\n\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t    atomic_read(&pinstance->ccn.ignore) == 1) {\n\t\treturn;\n\t} else if (ioasc) {\n\t\tdev_info(&pinstance->pdev->dev,\n\t\t\t\"Host RCB (CCN) failed with IOASC: 0x%08X\\n\", ioasc);\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t} else {\n\t\tpmcraid_handle_config_change(pinstance);\n\t}\n}\n\n/**\n * pmcraid_process_ldn - op done function for an LDN\n * @cmd: pointer to command block\n *\n * Return value\n *   none\n */\nstatic void pmcraid_initiate_reset(struct pmcraid_instance *);\nstatic void pmcraid_set_timestamp(struct pmcraid_cmd *cmd);\n\nstatic void pmcraid_process_ldn(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_hcam_ldn *ldn_hcam =\n\t\t\t(struct pmcraid_hcam_ldn *)pinstance->ldn.hcam;\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\tu32 fd_ioasc = le32_to_cpu(ldn_hcam->error_log.fd_ioasc);\n\tunsigned long lock_flags;\n\n\t/* return the command block back to freepool */\n\tpinstance->ldn.cmd = NULL;\n\tpmcraid_return_cmd(cmd);\n\n\t/* If driver initiated IOA reset happened while this hcam was pending\n\t * with IOA, no need to re-register the hcam as reset engine will do it\n\t * once reset sequence is complete\n\t */\n\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t    atomic_read(&pinstance->ccn.ignore) == 1) {\n\t\treturn;\n\t} else if (!ioasc) {\n\t\tpmcraid_handle_error_log(pinstance);\n\t\tif (fd_ioasc == PMCRAID_IOASC_NR_IOA_RESET_REQUIRED) {\n\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\t  lock_flags);\n\t\t\tpmcraid_initiate_reset(pinstance);\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\treturn;\n\t\t}\n\t\tif (fd_ioasc == PMCRAID_IOASC_TIME_STAMP_OUT_OF_SYNC) {\n\t\t\tpinstance->timestamp_error = 1;\n\t\t\tpmcraid_set_timestamp(cmd);\n\t\t}\n\t} else {\n\t\tdev_info(&pinstance->pdev->dev,\n\t\t\t\"Host RCB(LDN) failed with IOASC: 0x%08X\\n\", ioasc);\n\t}\n\t/* send netlink message for HCAM notification if enabled */\n\tif (!pmcraid_disable_aen)\n\t\tpmcraid_notify_ldn(pinstance);\n\n\tcmd = pmcraid_init_hcam(pinstance, PMCRAID_HCAM_CODE_LOG_DATA);\n\tif (cmd)\n\t\tpmcraid_send_hcam_cmd(cmd);\n}\n\n/**\n * pmcraid_register_hcams - register HCAMs for CCN and LDN\n *\n * @pinstance: pointer per adapter instance structure\n *\n * Return Value\n *   none\n */\nstatic void pmcraid_register_hcams(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\n\tpmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_LOG_DATA);\n}\n\n/**\n * pmcraid_unregister_hcams - cancel HCAMs registered already\n * @cmd: pointer to command used as part of reset sequence\n */\nstatic void pmcraid_unregister_hcams(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\n\t/* During IOA bringdown, HCAM gets fired and tasklet proceeds with\n\t * handling hcam response though it is not necessary. In order to\n\t * prevent this, set 'ignore', so that bring-down sequence doesn't\n\t * re-send any more hcams\n\t */\n\tatomic_set(&pinstance->ccn.ignore, 1);\n\tatomic_set(&pinstance->ldn.ignore, 1);\n\n\t/* If adapter reset was forced as part of runtime reset sequence,\n\t * start the reset sequence. Reset will be triggered even in case\n\t * IOA unit_check.\n\t */\n\tif ((pinstance->force_ioa_reset && !pinstance->ioa_bringdown) ||\n\t     pinstance->ioa_unit_check) {\n\t\tpinstance->force_ioa_reset = 0;\n\t\tpinstance->ioa_unit_check = 0;\n\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\tpmcraid_reset_alert(cmd);\n\t\treturn;\n\t}\n\n\t/* Driver tries to cancel HCAMs by sending ABORT TASK for each HCAM\n\t * one after the other. So CCN cancellation will be triggered by\n\t * pmcraid_cancel_ldn itself.\n\t */\n\tpmcraid_cancel_ldn(cmd);\n}\n\n/**\n * pmcraid_reset_enable_ioa - re-enable IOA after a hard reset\n * @pinstance: pointer to adapter instance structure\n * Return Value\n *  1 if TRANSITION_TO_OPERATIONAL is active, otherwise 0\n */\nstatic void pmcraid_reinit_buffers(struct pmcraid_instance *);\n\nstatic int pmcraid_reset_enable_ioa(struct pmcraid_instance *pinstance)\n{\n\tu32 intrs;\n\n\tpmcraid_reinit_buffers(pinstance);\n\tintrs = pmcraid_read_interrupts(pinstance);\n\n\tpmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\n\n\tif (intrs & INTRS_TRANSITION_TO_OPERATIONAL) {\n\t\tif (!pinstance->interrupt_mode) {\n\t\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\t\tpinstance->int_regs.\n\t\t\t\tioa_host_interrupt_mask_reg);\n\t\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/**\n * pmcraid_soft_reset - performs a soft reset and makes IOA become ready\n * @cmd : pointer to reset command block\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_soft_reset(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 int_reg;\n\tu32 doorbell;\n\n\t/* There will be an interrupt when Transition to Operational bit is\n\t * set so tasklet would execute next reset task. The timeout handler\n\t * would re-initiate a reset\n\t */\n\tcmd->cmd_done = pmcraid_ioa_reset;\n\tcmd->timer.data = (unsigned long)cmd;\n\tcmd->timer.expires = jiffies +\n\t\t\t     msecs_to_jiffies(PMCRAID_TRANSOP_TIMEOUT);\n\tcmd->timer.function = (void (*)(unsigned long))pmcraid_timeout_handler;\n\n\tif (!timer_pending(&cmd->timer))\n\t\tadd_timer(&cmd->timer);\n\n\t/* Enable destructive diagnostics on IOA if it is not yet in\n\t * operational state\n\t */\n\tdoorbell = DOORBELL_RUNTIME_RESET |\n\t\t   DOORBELL_ENABLE_DESTRUCTIVE_DIAGS;\n\n\t/* Since we do RESET_ALERT and Start BIST we have to again write\n\t * MSIX Doorbell to indicate the interrupt mode\n\t */\n\tif (pinstance->interrupt_mode) {\n\t\tiowrite32(DOORBELL_INTR_MODE_MSIX,\n\t\t\t  pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\t}\n\n\tiowrite32(doorbell, pinstance->int_regs.host_ioa_interrupt_reg);\n\tioread32(pinstance->int_regs.host_ioa_interrupt_reg),\n\tint_reg = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\n\n\tpmcraid_info(\"Waiting for IOA to become operational %x:%x\\n\",\n\t\t     ioread32(pinstance->int_regs.host_ioa_interrupt_reg),\n\t\t     int_reg);\n}\n\n/**\n * pmcraid_get_dump - retrieves IOA dump in case of Unit Check interrupt\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_get_dump(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_info(\"%s is not yet implemented\\n\", __func__);\n}\n\n/**\n * pmcraid_fail_outstanding_cmds - Fails all outstanding ops.\n * @pinstance: pointer to adapter instance structure\n *\n * This function fails all outstanding ops. If they are submitted to IOA\n * already, it sends cancel all messages if IOA is still accepting IOARCBs,\n * otherwise just completes the commands and returns the cmd blocks to free\n * pool.\n *\n * Return value:\n *\t none\n */\nstatic void pmcraid_fail_outstanding_cmds(struct pmcraid_instance *pinstance)\n{\n\tstruct pmcraid_cmd *cmd, *temp;\n\tunsigned long lock_flags;\n\n\t/* pending command list is protected by pending_pool_lock. Its\n\t * traversal must be done as within this lock\n\t */\n\tspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\n\tlist_for_each_entry_safe(cmd, temp, &pinstance->pending_cmd_pool,\n\t\t\t\t free_list) {\n\t\tlist_del(&cmd->free_list);\n\t\tspin_unlock_irqrestore(&pinstance->pending_pool_lock,\n\t\t\t\t\tlock_flags);\n\t\tcmd->ioa_cb->ioasa.ioasc =\n\t\t\tcpu_to_le32(PMCRAID_IOASC_IOA_WAS_RESET);\n\t\tcmd->ioa_cb->ioasa.ilid =\n\t\t\tcpu_to_be32(PMCRAID_DRIVER_ILID);\n\n\t\t/* In case the command timer is still running */\n\t\tdel_timer(&cmd->timer);\n\n\t\t/* If this is an IO command, complete it by invoking scsi_done\n\t\t * function. If this is one of the internal commands other\n\t\t * than pmcraid_ioa_reset and HCAM commands invoke cmd_done to\n\t\t * complete it\n\t\t */\n\t\tif (cmd->scsi_cmd) {\n\n\t\t\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\t\t\t__le32 resp = cmd->ioa_cb->ioarcb.response_handle;\n\n\t\t\tscsi_cmd->result |= DID_ERROR << 16;\n\n\t\t\tscsi_dma_unmap(scsi_cmd);\n\t\t\tpmcraid_return_cmd(cmd);\n\n\t\t\tpmcraid_info(\"failing(%d) CDB[0] = %x result: %x\\n\",\n\t\t\t\t     le32_to_cpu(resp) >> 2,\n\t\t\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t\t\t     scsi_cmd->result);\n\t\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t\t} else if (cmd->cmd_done == pmcraid_internal_done ||\n\t\t\t   cmd->cmd_done == pmcraid_erp_done) {\n\t\t\tcmd->cmd_done(cmd);\n\t\t} else if (cmd->cmd_done != pmcraid_ioa_reset &&\n\t\t\t   cmd->cmd_done != pmcraid_ioa_shutdown_done) {\n\t\t\tpmcraid_return_cmd(cmd);\n\t\t}\n\n\t\tatomic_dec(&pinstance->outstanding_cmds);\n\t\tspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\n\t}\n\n\tspin_unlock_irqrestore(&pinstance->pending_pool_lock, lock_flags);\n}\n\n/**\n * pmcraid_ioa_reset - Implementation of IOA reset logic\n *\n * @cmd: pointer to the cmd block to be used for entire reset process\n *\n * This function executes most of the steps required for IOA reset. This gets\n * called by user threads (modprobe/insmod/rmmod) timer, tasklet and midlayer's\n * 'eh_' thread. Access to variables used for controlling the reset sequence is\n * synchronized using host lock. Various functions called during reset process\n * would make use of a single command block, pointer to which is also stored in\n * adapter instance structure.\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_ioa_reset(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu8 reset_complete = 0;\n\n\tpinstance->ioa_reset_in_progress = 1;\n\n\tif (pinstance->reset_cmd != cmd) {\n\t\tpmcraid_err(\"reset is called with different command block\\n\");\n\t\tpinstance->reset_cmd = cmd;\n\t}\n\n\tpmcraid_info(\"reset_engine: state = %d, command = %p\\n\",\n\t\t      pinstance->ioa_state, cmd);\n\n\tswitch (pinstance->ioa_state) {\n\n\tcase IOA_STATE_DEAD:\n\t\t/* If IOA is offline, whatever may be the reset reason, just\n\t\t * return. callers might be waiting on the reset wait_q, wake\n\t\t * up them\n\t\t */\n\t\tpmcraid_err(\"IOA is offline no reset is possible\\n\");\n\t\treset_complete = 1;\n\t\tbreak;\n\n\tcase IOA_STATE_IN_BRINGDOWN:\n\t\t/* we enter here, once ioa shutdown command is processed by IOA\n\t\t * Alert IOA for a possible reset. If reset alert fails, IOA\n\t\t * goes through hard-reset\n\t\t */\n\t\tpmcraid_disable_interrupts(pinstance, ~0);\n\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\tpmcraid_reset_alert(cmd);\n\t\tbreak;\n\n\tcase IOA_STATE_UNKNOWN:\n\t\t/* We may be called during probe or resume. Some pre-processing\n\t\t * is required for prior to reset\n\t\t */\n\t\tscsi_block_requests(pinstance->host);\n\n\t\t/* If asked to reset while IOA was processing responses or\n\t\t * there are any error responses then IOA may require\n\t\t * hard-reset.\n\t\t */\n\t\tif (pinstance->ioa_hard_reset == 0) {\n\t\t\tif (ioread32(pinstance->ioa_status) &\n\t\t\t    INTRS_TRANSITION_TO_OPERATIONAL) {\n\t\t\t\tpmcraid_info(\"sticky bit set, bring-up\\n\");\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_BRINGUP;\n\t\t\t\tpmcraid_reinit_cmdblk(cmd);\n\t\t\t\tpmcraid_identify_hrrq(cmd);\n\t\t\t} else {\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_SOFT_RESET;\n\t\t\t\tpmcraid_soft_reset(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Alert IOA of a possible reset and wait for critical\n\t\t\t * operation in progress bit to reset\n\t\t\t */\n\t\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\t\tpmcraid_reset_alert(cmd);\n\t\t}\n\t\tbreak;\n\n\tcase IOA_STATE_IN_RESET_ALERT:\n\t\t/* If critical operation in progress bit is reset or wait gets\n\t\t * timed out, reset proceeds with starting BIST on the IOA.\n\t\t * pmcraid_ioa_hard_reset keeps a count of reset attempts. If\n\t\t * they are 3 or more, reset engine marks IOA dead and returns\n\t\t */\n\t\tpinstance->ioa_state = IOA_STATE_IN_HARD_RESET;\n\t\tpmcraid_start_bist(cmd);\n\t\tbreak;\n\n\tcase IOA_STATE_IN_HARD_RESET:\n\t\tpinstance->ioa_reset_attempts++;\n\n\t\t/* retry reset if we haven't reached maximum allowed limit */\n\t\tif (pinstance->ioa_reset_attempts > PMCRAID_RESET_ATTEMPTS) {\n\t\t\tpinstance->ioa_reset_attempts = 0;\n\t\t\tpmcraid_err(\"IOA didn't respond marking it as dead\\n\");\n\t\t\tpinstance->ioa_state = IOA_STATE_DEAD;\n\n\t\t\tif (pinstance->ioa_bringdown)\n\t\t\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\tPMC_DEVICE_EVENT_SHUTDOWN_FAILED);\n\t\t\telse\n\t\t\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\t\tPMC_DEVICE_EVENT_RESET_FAILED);\n\t\t\treset_complete = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Once either bist or pci reset is done, restore PCI config\n\t\t * space. If this fails, proceed with hard reset again\n\t\t */\n\t\tpci_restore_state(pinstance->pdev);\n\n\t\t/* fail all pending commands */\n\t\tpmcraid_fail_outstanding_cmds(pinstance);\n\n\t\t/* check if unit check is active, if so extract dump */\n\t\tif (pinstance->ioa_unit_check) {\n\t\t\tpmcraid_info(\"unit check is active\\n\");\n\t\t\tpinstance->ioa_unit_check = 0;\n\t\t\tpmcraid_get_dump(pinstance);\n\t\t\tpinstance->ioa_reset_attempts--;\n\t\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\t\tpmcraid_reset_alert(cmd);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if the reset reason is to bring-down the ioa, we might be\n\t\t * done with the reset restore pci_config_space and complete\n\t\t * the reset\n\t\t */\n\t\tif (pinstance->ioa_bringdown) {\n\t\t\tpmcraid_info(\"bringing down the adapter\\n\");\n\t\t\tpinstance->ioa_shutdown_type = SHUTDOWN_NONE;\n\t\t\tpinstance->ioa_bringdown = 0;\n\t\t\tpinstance->ioa_state = IOA_STATE_UNKNOWN;\n\t\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\tPMC_DEVICE_EVENT_SHUTDOWN_SUCCESS);\n\t\t\treset_complete = 1;\n\t\t} else {\n\t\t\t/* bring-up IOA, so proceed with soft reset\n\t\t\t * Reinitialize hrrq_buffers and their indices also\n\t\t\t * enable interrupts after a pci_restore_state\n\t\t\t */\n\t\t\tif (pmcraid_reset_enable_ioa(pinstance)) {\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_BRINGUP;\n\t\t\t\tpmcraid_info(\"bringing up the adapter\\n\");\n\t\t\t\tpmcraid_reinit_cmdblk(cmd);\n\t\t\t\tpmcraid_identify_hrrq(cmd);\n\t\t\t} else {\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_SOFT_RESET;\n\t\t\t\tpmcraid_soft_reset(cmd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOA_STATE_IN_SOFT_RESET:\n\t\t/* TRANSITION TO OPERATIONAL is on so start initialization\n\t\t * sequence\n\t\t */\n\t\tpmcraid_info(\"In softreset proceeding with bring-up\\n\");\n\t\tpinstance->ioa_state = IOA_STATE_IN_BRINGUP;\n\n\t\t/* Initialization commands start with HRRQ identification. From\n\t\t * now on tasklet completes most of the commands as IOA is up\n\t\t * and intrs are enabled\n\t\t */\n\t\tpmcraid_identify_hrrq(cmd);\n\t\tbreak;\n\n\tcase IOA_STATE_IN_BRINGUP:\n\t\t/* we are done with bringing up of IOA, change the ioa_state to\n\t\t * operational and wake up any waiters\n\t\t */\n\t\tpinstance->ioa_state = IOA_STATE_OPERATIONAL;\n\t\treset_complete = 1;\n\t\tbreak;\n\n\tcase IOA_STATE_OPERATIONAL:\n\tdefault:\n\t\t/* When IOA is operational and a reset is requested, check for\n\t\t * the reset reason. If reset is to bring down IOA, unregister\n\t\t * HCAMs and initiate shutdown; if adapter reset is forced then\n\t\t * restart reset sequence again\n\t\t */\n\t\tif (pinstance->ioa_shutdown_type == SHUTDOWN_NONE &&\n\t\t    pinstance->force_ioa_reset == 0) {\n\t\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\t\tPMC_DEVICE_EVENT_RESET_SUCCESS);\n\t\t\treset_complete = 1;\n\t\t} else {\n\t\t\tif (pinstance->ioa_shutdown_type != SHUTDOWN_NONE)\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_BRINGDOWN;\n\t\t\tpmcraid_reinit_cmdblk(cmd);\n\t\t\tpmcraid_unregister_hcams(cmd);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* reset will be completed if ioa_state is either DEAD or UNKNOWN or\n\t * OPERATIONAL. Reset all control variables used during reset, wake up\n\t * any waiting threads and let the SCSI mid-layer send commands. Note\n\t * that host_lock must be held before invoking scsi_report_bus_reset.\n\t */\n\tif (reset_complete) {\n\t\tpinstance->ioa_reset_in_progress = 0;\n\t\tpinstance->ioa_reset_attempts = 0;\n\t\tpinstance->reset_cmd = NULL;\n\t\tpinstance->ioa_shutdown_type = SHUTDOWN_NONE;\n\t\tpinstance->ioa_bringdown = 0;\n\t\tpmcraid_return_cmd(cmd);\n\n\t\t/* If target state is to bring up the adapter, proceed with\n\t\t * hcam registration and resource exposure to mid-layer.\n\t\t */\n\t\tif (pinstance->ioa_state == IOA_STATE_OPERATIONAL)\n\t\t\tpmcraid_register_hcams(pinstance);\n\n\t\twake_up_all(&pinstance->reset_wait_q);\n\t}\n\n\treturn;\n}\n\n/**\n * pmcraid_initiate_reset - initiates reset sequence. This is called from\n * ISR/tasklet during error interrupts including IOA unit check. If reset\n * is already in progress, it just returns, otherwise initiates IOA reset\n * to bring IOA up to operational state.\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return value\n *\t none\n */\nstatic void pmcraid_initiate_reset(struct pmcraid_instance *pinstance)\n{\n\tstruct pmcraid_cmd *cmd;\n\n\t/* If the reset is already in progress, just return, otherwise start\n\t * reset sequence and return\n\t */\n\tif (!pinstance->ioa_reset_in_progress) {\n\t\tscsi_block_requests(pinstance->host);\n\t\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\t\tif (cmd == NULL) {\n\t\t\tpmcraid_err(\"no cmnd blocks for initiate_reset\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tpinstance->ioa_shutdown_type = SHUTDOWN_NONE;\n\t\tpinstance->reset_cmd = cmd;\n\t\tpinstance->force_ioa_reset = 1;\n\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\tPMC_DEVICE_EVENT_RESET_START);\n\t\tpmcraid_ioa_reset(cmd);\n\t}\n}\n\n/**\n * pmcraid_reset_reload - utility routine for doing IOA reset either to bringup\n *\t\t\t  or bringdown IOA\n * @pinstance: pointer adapter instance structure\n * @shutdown_type: shutdown type to be used NONE, NORMAL or ABRREV\n * @target_state: expected target state after reset\n *\n * Note: This command initiates reset and waits for its completion. Hence this\n * should not be called from isr/timer/tasklet functions (timeout handlers,\n * error response handlers and interrupt handlers).\n *\n * Return Value\n *\t 1 in case ioa_state is not target_state, 0 otherwise.\n */\nstatic int pmcraid_reset_reload(\n\tstruct pmcraid_instance *pinstance,\n\tu8 shutdown_type,\n\tu8 target_state\n)\n{\n\tstruct pmcraid_cmd *reset_cmd = NULL;\n\tunsigned long lock_flags;\n\tint reset = 1;\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\n\tif (pinstance->ioa_reset_in_progress) {\n\t\tpmcraid_info(\"reset_reload: reset is already in progress\\n\");\n\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\twait_event(pinstance->reset_wait_q,\n\t\t\t   !pinstance->ioa_reset_in_progress);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\n\t\tif (pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\tpmcraid_info(\"reset_reload: IOA is dead\\n\");\n\t\t\treturn reset;\n\t\t} else if (pinstance->ioa_state == target_state) {\n\t\t\treset = 0;\n\t\t}\n\t}\n\n\tif (reset) {\n\t\tpmcraid_info(\"reset_reload: proceeding with reset\\n\");\n\t\tscsi_block_requests(pinstance->host);\n\t\treset_cmd = pmcraid_get_free_cmd(pinstance);\n\n\t\tif (reset_cmd == NULL) {\n\t\t\tpmcraid_err(\"no free cmnd for reset_reload\\n\");\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\treturn reset;\n\t\t}\n\n\t\tif (shutdown_type == SHUTDOWN_NORMAL)\n\t\t\tpinstance->ioa_bringdown = 1;\n\n\t\tpinstance->ioa_shutdown_type = shutdown_type;\n\t\tpinstance->reset_cmd = reset_cmd;\n\t\tpinstance->force_ioa_reset = reset;\n\t\tpmcraid_info(\"reset_reload: initiating reset\\n\");\n\t\tpmcraid_ioa_reset(reset_cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_info(\"reset_reload: waiting for reset to complete\\n\");\n\t\twait_event(pinstance->reset_wait_q,\n\t\t\t   !pinstance->ioa_reset_in_progress);\n\n\t\tpmcraid_info(\"reset_reload: reset is complete !!\\n\");\n\t\tscsi_unblock_requests(pinstance->host);\n\t\tif (pinstance->ioa_state == target_state)\n\t\t\treset = 0;\n\t}\n\n\treturn reset;\n}\n\n/**\n * pmcraid_reset_bringdown - wrapper over pmcraid_reset_reload to bringdown IOA\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return Value\n *\t whatever is returned from pmcraid_reset_reload\n */\nstatic int pmcraid_reset_bringdown(struct pmcraid_instance *pinstance)\n{\n\treturn pmcraid_reset_reload(pinstance,\n\t\t\t\t    SHUTDOWN_NORMAL,\n\t\t\t\t    IOA_STATE_UNKNOWN);\n}\n\n/**\n * pmcraid_reset_bringup - wrapper over pmcraid_reset_reload to bring up IOA\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return Value\n *\t whatever is returned from pmcraid_reset_reload\n */\nstatic int pmcraid_reset_bringup(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_notify_ioastate(pinstance, PMC_DEVICE_EVENT_RESET_START);\n\n\treturn pmcraid_reset_reload(pinstance,\n\t\t\t\t    SHUTDOWN_NONE,\n\t\t\t\t    IOA_STATE_OPERATIONAL);\n}\n\n/**\n * pmcraid_request_sense - Send request sense to a device\n * @cmd: pmcraid command struct\n *\n * This function sends a request sense to a device as a result of a check\n * condition. This method re-uses the same command block that failed earlier.\n */\nstatic void pmcraid_request_sense(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\n\t/* allocate DMAable memory for sense buffers */\n\tcmd->sense_buffer = pci_alloc_consistent(cmd->drv_inst->pdev,\n\t\t\t\t\t\t SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t\t &cmd->sense_buffer_dma);\n\n\tif (cmd->sense_buffer == NULL) {\n\t\tpmcraid_err\n\t\t\t(\"couldn't allocate sense buffer for request sense\\n\");\n\t\tpmcraid_erp_done(cmd);\n\t\treturn;\n\t}\n\n\t/* re-use the command block */\n\tmemset(&cmd->ioa_cb->ioasa, 0, sizeof(struct pmcraid_ioasa));\n\tmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\n\tioarcb->request_flags0 = (SYNC_COMPLETE |\n\t\t\t\t  NO_LINK_DESCS |\n\t\t\t\t  INHIBIT_UL_CHECK);\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\tioarcb->cdb[0] = REQUEST_SENSE;\n\tioarcb->cdb[4] = SCSI_SENSE_BUFFERSIZE;\n\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\n\tioarcb->data_transfer_length = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);\n\n\tioadl->address = cpu_to_le64(cmd->sense_buffer_dma);\n\tioadl->data_len = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\n\t/* request sense might be called as part of error response processing\n\t * which runs in tasklets context. It is possible that mid-layer might\n\t * schedule queuecommand during this time, hence, writting to IOARRIN\n\t * must be protect by host_lock\n\t */\n\tpmcraid_send_cmd(cmd, pmcraid_erp_done,\n\t\t\t PMCRAID_REQUEST_SENSE_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_cancel_all - cancel all outstanding IOARCBs as part of error recovery\n * @cmd: command that failed\n * @sense: true if request_sense is required after cancel all\n *\n * This function sends a cancel all to a device to clear the queue.\n */\nstatic void pmcraid_cancel_all(struct pmcraid_cmd *cmd, u32 sense)\n{\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_resource_entry *res = scsi_cmd->device->hostdata;\n\tvoid (*cmd_done) (struct pmcraid_cmd *) = sense ? pmcraid_erp_done\n\t\t\t\t\t\t\t: pmcraid_request_sense;\n\n\tmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\n\tioarcb->request_flags0 = SYNC_OVERRIDE;\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->cdb[0] = PMCRAID_CANCEL_ALL_REQUESTS;\n\n\tif (RES_IS_GSCSI(res->cfg_entry))\n\t\tioarcb->cdb[1] = PMCRAID_SYNC_COMPLETE_AFTER_CANCEL;\n\n\tioarcb->ioadl_bus_addr = 0;\n\tioarcb->ioadl_length = 0;\n\tioarcb->data_transfer_length = 0;\n\tioarcb->ioarcb_bus_addr &= (~0x1FULL);\n\n\t/* writing to IOARRIN must be protected by host_lock, as mid-layer\n\t * schedule queuecommand while we are doing this\n\t */\n\tpmcraid_send_cmd(cmd, cmd_done,\n\t\t\t PMCRAID_REQUEST_SENSE_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_frame_auto_sense: frame fixed format sense information\n *\n * @cmd: pointer to failing command block\n *\n * Return value\n *  none\n */\nstatic void pmcraid_frame_auto_sense(struct pmcraid_cmd *cmd)\n{\n\tu8 *sense_buf = cmd->scsi_cmd->sense_buffer;\n\tstruct pmcraid_resource_entry *res = cmd->scsi_cmd->device->hostdata;\n\tstruct pmcraid_ioasa *ioasa = &cmd->ioa_cb->ioasa;\n\tu32 ioasc = le32_to_cpu(ioasa->ioasc);\n\tu32 failing_lba = 0;\n\n\tmemset(sense_buf, 0, SCSI_SENSE_BUFFERSIZE);\n\tcmd->scsi_cmd->result = SAM_STAT_CHECK_CONDITION;\n\n\tif (RES_IS_VSET(res->cfg_entry) &&\n\t    ioasc == PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC &&\n\t    ioasa->u.vset.failing_lba_hi != 0) {\n\n\t\tsense_buf[0] = 0x72;\n\t\tsense_buf[1] = PMCRAID_IOASC_SENSE_KEY(ioasc);\n\t\tsense_buf[2] = PMCRAID_IOASC_SENSE_CODE(ioasc);\n\t\tsense_buf[3] = PMCRAID_IOASC_SENSE_QUAL(ioasc);\n\n\t\tsense_buf[7] = 12;\n\t\tsense_buf[8] = 0;\n\t\tsense_buf[9] = 0x0A;\n\t\tsense_buf[10] = 0x80;\n\n\t\tfailing_lba = le32_to_cpu(ioasa->u.vset.failing_lba_hi);\n\n\t\tsense_buf[12] = (failing_lba & 0xff000000) >> 24;\n\t\tsense_buf[13] = (failing_lba & 0x00ff0000) >> 16;\n\t\tsense_buf[14] = (failing_lba & 0x0000ff00) >> 8;\n\t\tsense_buf[15] = failing_lba & 0x000000ff;\n\n\t\tfailing_lba = le32_to_cpu(ioasa->u.vset.failing_lba_lo);\n\n\t\tsense_buf[16] = (failing_lba & 0xff000000) >> 24;\n\t\tsense_buf[17] = (failing_lba & 0x00ff0000) >> 16;\n\t\tsense_buf[18] = (failing_lba & 0x0000ff00) >> 8;\n\t\tsense_buf[19] = failing_lba & 0x000000ff;\n\t} else {\n\t\tsense_buf[0] = 0x70;\n\t\tsense_buf[2] = PMCRAID_IOASC_SENSE_KEY(ioasc);\n\t\tsense_buf[12] = PMCRAID_IOASC_SENSE_CODE(ioasc);\n\t\tsense_buf[13] = PMCRAID_IOASC_SENSE_QUAL(ioasc);\n\n\t\tif (ioasc == PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC) {\n\t\t\tif (RES_IS_VSET(res->cfg_entry))\n\t\t\t\tfailing_lba =\n\t\t\t\t\tle32_to_cpu(ioasa->u.\n\t\t\t\t\t\t vset.failing_lba_lo);\n\t\t\tsense_buf[0] |= 0x80;\n\t\t\tsense_buf[3] = (failing_lba >> 24) & 0xff;\n\t\t\tsense_buf[4] = (failing_lba >> 16) & 0xff;\n\t\t\tsense_buf[5] = (failing_lba >> 8) & 0xff;\n\t\t\tsense_buf[6] = failing_lba & 0xff;\n\t\t}\n\n\t\tsense_buf[7] = 6; /* additional length */\n\t}\n}\n\n/**\n * pmcraid_error_handler - Error response handlers for a SCSI op\n * @cmd: pointer to pmcraid_cmd that has failed\n *\n * This function determines whether or not to initiate ERP on the affected\n * device. This is called from a tasklet, which doesn't hold any locks.\n *\n * Return value:\n *\t 0 it caller can complete the request, otherwise 1 where in error\n *\t handler itself completes the request and returns the command block\n *\t back to free-pool\n */\nstatic int pmcraid_error_handler(struct pmcraid_cmd *cmd)\n{\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_resource_entry *res = scsi_cmd->device->hostdata;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_ioasa *ioasa = &cmd->ioa_cb->ioasa;\n\tu32 ioasc = le32_to_cpu(ioasa->ioasc);\n\tu32 masked_ioasc = ioasc & PMCRAID_IOASC_SENSE_MASK;\n\tu32 sense_copied = 0;\n\n\tif (!res) {\n\t\tpmcraid_info(\"resource pointer is NULL\\n\");\n\t\treturn 0;\n\t}\n\n\t/* If this was a SCSI read/write command keep count of errors */\n\tif (SCSI_CMD_TYPE(scsi_cmd->cmnd[0]) == SCSI_READ_CMD)\n\t\tatomic_inc(&res->read_failures);\n\telse if (SCSI_CMD_TYPE(scsi_cmd->cmnd[0]) == SCSI_WRITE_CMD)\n\t\tatomic_inc(&res->write_failures);\n\n\tif (!RES_IS_GSCSI(res->cfg_entry) &&\n\t\tmasked_ioasc != PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR) {\n\t\tpmcraid_frame_auto_sense(cmd);\n\t}\n\n\t/* Log IOASC/IOASA information based on user settings */\n\tpmcraid_ioasc_logger(ioasc, cmd);\n\n\tswitch (masked_ioasc) {\n\n\tcase PMCRAID_IOASC_AC_TERMINATED_BY_HOST:\n\t\tscsi_cmd->result |= (DID_ABORT << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_IR_INVALID_RESOURCE_HANDLE:\n\tcase PMCRAID_IOASC_HW_CANNOT_COMMUNICATE:\n\t\tscsi_cmd->result |= (DID_NO_CONNECT << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_NR_SYNC_REQUIRED:\n\t\tres->sync_reqd = 1;\n\t\tscsi_cmd->result |= (DID_IMM_RETRY << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC:\n\t\tscsi_cmd->result |= (DID_PASSTHROUGH << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_UA_BUS_WAS_RESET:\n\tcase PMCRAID_IOASC_UA_BUS_WAS_RESET_BY_OTHER:\n\t\tif (!res->reset_progress)\n\t\t\tscsi_report_bus_reset(pinstance->host,\n\t\t\t\t\t      scsi_cmd->device->channel);\n\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR:\n\t\tscsi_cmd->result |= PMCRAID_IOASC_SENSE_STATUS(ioasc);\n\t\tres->sync_reqd = 1;\n\n\t\t/* if check_condition is not active return with error otherwise\n\t\t * get/frame the sense buffer\n\t\t */\n\t\tif (PMCRAID_IOASC_SENSE_STATUS(ioasc) !=\n\t\t    SAM_STAT_CHECK_CONDITION &&\n\t\t    PMCRAID_IOASC_SENSE_STATUS(ioasc) != SAM_STAT_ACA_ACTIVE)\n\t\t\treturn 0;\n\n\t\t/* If we have auto sense data as part of IOASA pass it to\n\t\t * mid-layer\n\t\t */\n\t\tif (ioasa->auto_sense_length != 0) {\n\t\t\tshort sense_len = ioasa->auto_sense_length;\n\t\t\tint data_size = min_t(u16, le16_to_cpu(sense_len),\n\t\t\t\t\t      SCSI_SENSE_BUFFERSIZE);\n\n\t\t\tmemcpy(scsi_cmd->sense_buffer,\n\t\t\t       ioasa->sense_data,\n\t\t\t       data_size);\n\t\t\tsense_copied = 1;\n\t\t}\n\n\t\tif (RES_IS_GSCSI(res->cfg_entry))\n\t\t\tpmcraid_cancel_all(cmd, sense_copied);\n\t\telse if (sense_copied)\n\t\t\tpmcraid_erp_done(cmd);\n\t\telse\n\t\t\tpmcraid_request_sense(cmd);\n\n\t\treturn 1;\n\n\tcase PMCRAID_IOASC_NR_INIT_CMD_REQUIRED:\n\t\tbreak;\n\n\tdefault:\n\t\tif (PMCRAID_IOASC_SENSE_KEY(ioasc) > RECOVERED_ERROR)\n\t\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/**\n * pmcraid_reset_device - device reset handler functions\n *\n * @scsi_cmd: scsi command struct\n * @modifier: reset modifier indicating the reset sequence to be performed\n *\n * This function issues a device reset to the affected device.\n * A LUN reset will be sent to the device first. If that does\n * not work, a target reset will be sent.\n *\n * Return value:\n *\tSUCCESS / FAILED\n */\nstatic int pmcraid_reset_device(\n\tstruct scsi_cmnd *scsi_cmd,\n\tunsigned long timeout,\n\tu8 modifier\n)\n{\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tunsigned long lock_flags;\n\tu32 ioasc;\n\n\tpinstance =\n\t\t(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\n\tres = scsi_cmd->device->hostdata;\n\n\tif (!res) {\n\t\tsdev_printk(KERN_ERR, scsi_cmd->device,\n\t\t\t    \"reset_device: NULL resource pointer\\n\");\n\t\treturn FAILED;\n\t}\n\n\t/* If adapter is currently going through reset/reload, return failed.\n\t * This will force the mid-layer to call _eh_bus/host reset, which\n\t * will then go to sleep and wait for the reset to complete\n\t */\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\tif (pinstance->ioa_reset_in_progress ||\n\t    pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t\treturn FAILED;\n\t}\n\n\tres->reset_progress = 1;\n\tpmcraid_info(\"Resetting %s resource with addr %x\\n\",\n\t\t     ((modifier & RESET_DEVICE_LUN) ? \"LUN\" :\n\t\t     ((modifier & RESET_DEVICE_TARGET) ? \"TARGET\" : \"BUS\")),\n\t\t     le32_to_cpu(res->cfg_entry.resource_address));\n\n\t/* get a free cmd block */\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (cmd == NULL) {\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_err(\"%s: no cmd blocks are available\\n\", __func__);\n\t\treturn FAILED;\n\t}\n\n\tioarcb = &cmd->ioa_cb->ioarcb;\n\tioarcb->resource_handle = res->cfg_entry.resource_handle;\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->cdb[0] = PMCRAID_RESET_DEVICE;\n\n\t/* Initialize reset modifier bits */\n\tif (modifier)\n\t\tmodifier = ENABLE_RESET_MODIFIER | modifier;\n\n\tioarcb->cdb[1] = modifier;\n\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"cmd(CDB[0] = %x) for %x with index = %d\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle),\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2);\n\n\tpmcraid_send_cmd(cmd,\n\t\t\t pmcraid_internal_done,\n\t\t\t timeout,\n\t\t\t pmcraid_timeout_handler);\n\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* RESET_DEVICE command completes after all pending IOARCBs are\n\t * completed. Once this command is completed, pmcraind_internal_done\n\t * will wake up the 'completion' queue.\n\t */\n\twait_for_completion(&cmd->wait_for_completion);\n\n\t/* complete the command here itself and return the command block\n\t * to free list\n\t */\n\tpmcraid_return_cmd(cmd);\n\tres->reset_progress = 0;\n\tioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\n\t/* set the return value based on the returned ioasc */\n\treturn PMCRAID_IOASC_SENSE_KEY(ioasc) ? FAILED : SUCCESS;\n}\n\n/**\n * _pmcraid_io_done - helper for pmcraid_io_done function\n *\n * @cmd: pointer to pmcraid command struct\n * @reslen: residual data length to be set in the ioasa\n * @ioasc: ioasc either returned by IOA or set by driver itself.\n *\n * This function is invoked by pmcraid_io_done to complete mid-layer\n * scsi ops.\n *\n * Return value:\n *\t  0 if caller is required to return it to free_pool. Returns 1 if\n *\t  caller need not worry about freeing command block as error handler\n *\t  will take care of that.\n */\n\nstatic int _pmcraid_io_done(struct pmcraid_cmd *cmd, int reslen, int ioasc)\n{\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tint rc = 0;\n\n\tscsi_set_resid(scsi_cmd, reslen);\n\n\tpmcraid_info(\"response(%d) CDB[0] = %x ioasc:result: %x:%x\\n\",\n\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\tcmd->ioa_cb->ioarcb.cdb[0],\n\t\tioasc, scsi_cmd->result);\n\n\tif (PMCRAID_IOASC_SENSE_KEY(ioasc) != 0)\n\t\trc = pmcraid_error_handler(cmd);\n\n\tif (rc == 0) {\n\t\tscsi_dma_unmap(scsi_cmd);\n\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t}\n\n\treturn rc;\n}\n\n/**\n * pmcraid_io_done - SCSI completion function\n *\n * @cmd: pointer to pmcraid command struct\n *\n * This function is invoked by tasklet/mid-layer error handler to completing\n * the SCSI ops sent from mid-layer.\n *\n * Return value\n *\t  none\n */\n\nstatic void pmcraid_io_done(struct pmcraid_cmd *cmd)\n{\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\tu32 reslen = le32_to_cpu(cmd->ioa_cb->ioasa.residual_data_length);\n\n\tif (_pmcraid_io_done(cmd, reslen, ioasc) == 0)\n\t\tpmcraid_return_cmd(cmd);\n}\n\n/**\n * pmcraid_abort_cmd - Aborts a single IOARCB already submitted to IOA\n *\n * @cmd: command block of the command to be aborted\n *\n * Return Value:\n *\t returns pointer to command structure used as cancelling cmd\n */\nstatic struct pmcraid_cmd *pmcraid_abort_cmd(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_cmd *cancel_cmd;\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\n\tpinstance = (struct pmcraid_instance *)cmd->drv_inst;\n\tres = cmd->scsi_cmd->device->hostdata;\n\n\tcancel_cmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (cancel_cmd == NULL) {\n\t\tpmcraid_err(\"%s: no cmd blocks are available\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tpmcraid_prepare_cancel_cmd(cancel_cmd, cmd);\n\n\tpmcraid_info(\"aborting command CDB[0]= %x with index = %d\\n\",\n\t\tcmd->ioa_cb->ioarcb.cdb[0],\n\t\tcmd->ioa_cb->ioarcb.response_handle >> 2);\n\n\tinit_completion(&cancel_cmd->wait_for_completion);\n\tcancel_cmd->completion_req = 1;\n\n\tpmcraid_info(\"command (%d) CDB[0] = %x for %x\\n\",\n\t\tle32_to_cpu(cancel_cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\tcancel_cmd->ioa_cb->ioarcb.cdb[0],\n\t\tle32_to_cpu(cancel_cmd->ioa_cb->ioarcb.resource_handle));\n\n\tpmcraid_send_cmd(cancel_cmd,\n\t\t\t pmcraid_internal_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n\treturn cancel_cmd;\n}\n\n/**\n * pmcraid_abort_complete - Waits for ABORT TASK completion\n *\n * @cancel_cmd: command block use as cancelling command\n *\n * Return Value:\n *\t returns SUCCESS if ABORT TASK has good completion\n *\t otherwise FAILED\n */\nstatic int pmcraid_abort_complete(struct pmcraid_cmd *cancel_cmd)\n{\n\tstruct pmcraid_resource_entry *res;\n\tu32 ioasc;\n\n\twait_for_completion(&cancel_cmd->wait_for_completion);\n\tres = cancel_cmd->res;\n\tcancel_cmd->res = NULL;\n\tioasc = le32_to_cpu(cancel_cmd->ioa_cb->ioasa.ioasc);\n\n\t/* If the abort task is not timed out we will get a Good completion\n\t * as sense_key, otherwise we may get one the following responses\n\t * due to subsequent bus reset or device reset. In case IOASC is\n\t * NR_SYNC_REQUIRED, set sync_reqd flag for the corresponding resource\n\t */\n\tif (ioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET ||\n\t    ioasc == PMCRAID_IOASC_NR_SYNC_REQUIRED) {\n\t\tif (ioasc == PMCRAID_IOASC_NR_SYNC_REQUIRED)\n\t\t\tres->sync_reqd = 1;\n\t\tioasc = 0;\n\t}\n\n\t/* complete the command here itself */\n\tpmcraid_return_cmd(cancel_cmd);\n\treturn PMCRAID_IOASC_SENSE_KEY(ioasc) ? FAILED : SUCCESS;\n}\n\n/**\n * pmcraid_eh_abort_handler - entry point for aborting a single task on errors\n *\n * @scsi_cmd:   scsi command struct given by mid-layer. When this is called\n *\t\tmid-layer ensures that no other commands are queued. This\n *\t\tnever gets called under interrupt, but a separate eh thread.\n *\n * Return value:\n *\t SUCCESS / FAILED\n */\nstatic int pmcraid_eh_abort_handler(struct scsi_cmnd *scsi_cmd)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_resource_entry *res;\n\tunsigned long host_lock_flags;\n\tunsigned long pending_lock_flags;\n\tstruct pmcraid_cmd *cancel_cmd = NULL;\n\tint cmd_found = 0;\n\tint rc = FAILED;\n\n\tpinstance =\n\t\t(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, scsi_cmd,\n\t\t    \"I/O command timed out, aborting it.\\n\");\n\n\tres = scsi_cmd->device->hostdata;\n\n\tif (res == NULL)\n\t\treturn rc;\n\n\t/* If we are currently going through reset/reload, return failed.\n\t * This will force the mid-layer to eventually call\n\t * pmcraid_eh_host_reset which will then go to sleep and wait for the\n\t * reset to complete\n\t */\n\tspin_lock_irqsave(pinstance->host->host_lock, host_lock_flags);\n\n\tif (pinstance->ioa_reset_in_progress ||\n\t    pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t       host_lock_flags);\n\t\treturn rc;\n\t}\n\n\t/* loop over pending cmd list to find cmd corresponding to this\n\t * scsi_cmd. Note that this command might not have been completed\n\t * already. locking: all pending commands are protected with\n\t * pending_pool_lock.\n\t */\n\tspin_lock_irqsave(&pinstance->pending_pool_lock, pending_lock_flags);\n\tlist_for_each_entry(cmd, &pinstance->pending_cmd_pool, free_list) {\n\n\t\tif (cmd->scsi_cmd == scsi_cmd) {\n\t\t\tcmd_found = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pinstance->pending_pool_lock,\n\t\t\t\tpending_lock_flags);\n\n\t/* If the command to be aborted was given to IOA and still pending with\n\t * it, send ABORT_TASK to abort this and wait for its completion\n\t */\n\tif (cmd_found)\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\n\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t       host_lock_flags);\n\n\tif (cancel_cmd) {\n\t\tcancel_cmd->res = cmd->scsi_cmd->device->hostdata;\n\t\trc = pmcraid_abort_complete(cancel_cmd);\n\t}\n\n\treturn cmd_found ? rc : SUCCESS;\n}\n\n/**\n * pmcraid_eh_xxxx_reset_handler - bus/target/device reset handler callbacks\n *\n * @scmd: pointer to scsi_cmd that was sent to the resource to be reset.\n *\n * All these routines invokve pmcraid_reset_device with appropriate parameters.\n * Since these are called from mid-layer EH thread, no other IO will be queued\n * to the resource being reset. However, control path (IOCTL) may be active so\n * it is necessary to synchronize IOARRIN writes which pmcraid_reset_device\n * takes care by locking/unlocking host_lock.\n *\n * Return value\n *\tSUCCESS or FAILED\n */\nstatic int pmcraid_eh_device_reset_handler(struct scsi_cmnd *scmd)\n{\n\tscmd_printk(KERN_INFO, scmd,\n\t\t    \"resetting device due to an I/O command timeout.\\n\");\n\treturn pmcraid_reset_device(scmd,\n\t\t\t\t    PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t\t    RESET_DEVICE_LUN);\n}\n\nstatic int pmcraid_eh_bus_reset_handler(struct scsi_cmnd *scmd)\n{\n\tscmd_printk(KERN_INFO, scmd,\n\t\t    \"Doing bus reset due to an I/O command timeout.\\n\");\n\treturn pmcraid_reset_device(scmd,\n\t\t\t\t    PMCRAID_RESET_BUS_TIMEOUT,\n\t\t\t\t    RESET_DEVICE_BUS);\n}\n\nstatic int pmcraid_eh_target_reset_handler(struct scsi_cmnd *scmd)\n{\n\tscmd_printk(KERN_INFO, scmd,\n\t\t    \"Doing target reset due to an I/O command timeout.\\n\");\n\treturn pmcraid_reset_device(scmd,\n\t\t\t\t    PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t\t    RESET_DEVICE_TARGET);\n}\n\n/**\n * pmcraid_eh_host_reset_handler - adapter reset handler callback\n *\n * @scmd: pointer to scsi_cmd that was sent to a resource of adapter\n *\n * Initiates adapter reset to bring it up to operational state\n *\n * Return value\n *\tSUCCESS or FAILED\n */\nstatic int pmcraid_eh_host_reset_handler(struct scsi_cmnd *scmd)\n{\n\tunsigned long interval = 10000; /* 10 seconds interval */\n\tint waits = jiffies_to_msecs(PMCRAID_RESET_HOST_TIMEOUT) / interval;\n\tstruct pmcraid_instance *pinstance =\n\t\t(struct pmcraid_instance *)(scmd->device->host->hostdata);\n\n\n\t/* wait for an additional 150 seconds just in case firmware could come\n\t * up and if it could complete all the pending commands excluding the\n\t * two HCAM (CCN and LDN).\n\t */\n\twhile (waits--) {\n\t\tif (atomic_read(&pinstance->outstanding_cmds) <=\n\t\t    PMCRAID_MAX_HCAM_CMD)\n\t\t\treturn SUCCESS;\n\t\tmsleep(interval);\n\t}\n\n\tdev_err(&pinstance->pdev->dev,\n\t\t\"Adapter being reset due to an I/O command timeout.\\n\");\n\treturn pmcraid_reset_bringup(pinstance) == 0 ? SUCCESS : FAILED;\n}\n\n/**\n * pmcraid_task_attributes - Translate SPI Q-Tags to task attributes\n * @scsi_cmd:   scsi command struct\n *\n * Return value\n *\t  number of tags or 0 if the task is not tagged\n */\nstatic u8 pmcraid_task_attributes(struct scsi_cmnd *scsi_cmd)\n{\n\tchar tag[2];\n\tu8 rc = 0;\n\n\tif (scsi_populate_tag_msg(scsi_cmd, tag)) {\n\t\tswitch (tag[0]) {\n\t\tcase MSG_SIMPLE_TAG:\n\t\t\trc = TASK_TAG_SIMPLE;\n\t\t\tbreak;\n\t\tcase MSG_HEAD_TAG:\n\t\t\trc = TASK_TAG_QUEUE_HEAD;\n\t\t\tbreak;\n\t\tcase MSG_ORDERED_TAG:\n\t\t\trc = TASK_TAG_ORDERED;\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn rc;\n}\n\n\n/**\n * pmcraid_init_ioadls - initializes IOADL related fields in IOARCB\n * @cmd: pmcraid command struct\n * @sgcount: count of scatter-gather elements\n *\n * Return value\n *   returns pointer pmcraid_ioadl_desc, initialized to point to internal\n *   or external IOADLs\n */\nstruct pmcraid_ioadl_desc *\npmcraid_init_ioadls(struct pmcraid_cmd *cmd, int sgcount)\n{\n\tstruct pmcraid_ioadl_desc *ioadl;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tint ioadl_count = 0;\n\n\tif (ioarcb->add_cmd_param_length)\n\t\tioadl_count = DIV_ROUND_UP(ioarcb->add_cmd_param_length, 16);\n\tioarcb->ioadl_length =\n\t\tsizeof(struct pmcraid_ioadl_desc) * sgcount;\n\n\tif ((sgcount + ioadl_count) > (ARRAY_SIZE(ioarcb->add_data.u.ioadl))) {\n\t\t/* external ioadls start at offset 0x80 from control_block\n\t\t * structure, re-using 24 out of 27 ioadls part of IOARCB.\n\t\t * It is necessary to indicate to firmware that driver is\n\t\t * using ioadls to be treated as external to IOARCB.\n\t\t */\n\t\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\t\tioarcb->ioadl_bus_addr =\n\t\t\tcpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\tadd_data.u.ioadl[3]));\n\t\tioadl = &ioarcb->add_data.u.ioadl[3];\n\t} else {\n\t\tioarcb->ioadl_bus_addr =\n\t\t\tcpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\tadd_data.u.ioadl[ioadl_count]));\n\n\t\tioadl = &ioarcb->add_data.u.ioadl[ioadl_count];\n\t\tioarcb->ioarcb_bus_addr |=\n\t\t\t\tDIV_ROUND_CLOSEST(sgcount + ioadl_count, 8);\n\t}\n\n\treturn ioadl;\n}\n\n/**\n * pmcraid_build_ioadl - Build a scatter/gather list and map the buffer\n * @pinstance: pointer to adapter instance structure\n * @cmd: pmcraid command struct\n *\n * This function is invoked by queuecommand entry point while sending a command\n * to firmware. This builds ioadl descriptors and sets up ioarcb fields.\n *\n * Return value:\n *\t0 on success or -1 on failure\n */\nstatic int pmcraid_build_ioadl(\n\tstruct pmcraid_instance *pinstance,\n\tstruct pmcraid_cmd *cmd\n)\n{\n\tint i, nseg;\n\tstruct scatterlist *sglist;\n\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_ioarcb *ioarcb = &(cmd->ioa_cb->ioarcb);\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\n\tu32 length = scsi_bufflen(scsi_cmd);\n\n\tif (!length)\n\t\treturn 0;\n\n\tnseg = scsi_dma_map(scsi_cmd);\n\n\tif (nseg < 0) {\n\t\tscmd_printk(KERN_ERR, scsi_cmd, \"scsi_map_dma failed!\\n\");\n\t\treturn -1;\n\t} else if (nseg > PMCRAID_MAX_IOADLS) {\n\t\tscsi_dma_unmap(scsi_cmd);\n\t\tscmd_printk(KERN_ERR, scsi_cmd,\n\t\t\t\"sg count is (%d) more than allowed!\\n\", nseg);\n\t\treturn -1;\n\t}\n\n\t/* Initialize IOARCB data transfer length fields */\n\tif (scsi_cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tioarcb->request_flags0 |= TRANSFER_DIR_WRITE;\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length = cpu_to_le32(length);\n\tioadl = pmcraid_init_ioadls(cmd, nseg);\n\n\t/* Initialize IOADL descriptor addresses */\n\tscsi_for_each_sg(scsi_cmd, sglist, nseg, i) {\n\t\tioadl[i].data_len = cpu_to_le32(sg_dma_len(sglist));\n\t\tioadl[i].address = cpu_to_le64(sg_dma_address(sglist));\n\t\tioadl[i].flags = 0;\n\t}\n\t/* setup last descriptor */\n\tioadl[i - 1].flags = IOADL_FLAGS_LAST_DESC;\n\n\treturn 0;\n}\n\n/**\n * pmcraid_free_sglist - Frees an allocated SG buffer list\n * @sglist: scatter/gather list pointer\n *\n * Free a DMA'able memory previously allocated with pmcraid_alloc_sglist\n *\n * Return value:\n *\tnone\n */\nstatic void pmcraid_free_sglist(struct pmcraid_sglist *sglist)\n{\n\tint i;\n\n\tfor (i = 0; i < sglist->num_sg; i++)\n\t\t__free_pages(sg_page(&(sglist->scatterlist[i])),\n\t\t\t     sglist->order);\n\n\tkfree(sglist);\n}\n\n/**\n * pmcraid_alloc_sglist - Allocates memory for a SG list\n * @buflen: buffer length\n *\n * Allocates a DMA'able buffer in chunks and assembles a scatter/gather\n * list.\n *\n * Return value\n *\tpointer to sglist / NULL on failure\n */\nstatic struct pmcraid_sglist *pmcraid_alloc_sglist(int buflen)\n{\n\tstruct pmcraid_sglist *sglist;\n\tstruct scatterlist *scatterlist;\n\tstruct page *page;\n\tint num_elem, i, j;\n\tint sg_size;\n\tint order;\n\tint bsize_elem;\n\n\tsg_size = buflen / (PMCRAID_MAX_IOADLS - 1);\n\torder = (sg_size > 0) ? get_order(sg_size) : 0;\n\tbsize_elem = PAGE_SIZE * (1 << order);\n\n\t/* Determine the actual number of sg entries needed */\n\tif (buflen % bsize_elem)\n\t\tnum_elem = (buflen / bsize_elem) + 1;\n\telse\n\t\tnum_elem = buflen / bsize_elem;\n\n\t/* Allocate a scatter/gather list for the DMA */\n\tsglist = kzalloc(sizeof(struct pmcraid_sglist) +\n\t\t\t (sizeof(struct scatterlist) * (num_elem - 1)),\n\t\t\t GFP_KERNEL);\n\n\tif (sglist == NULL)\n\t\treturn NULL;\n\n\tscatterlist = sglist->scatterlist;\n\tsg_init_table(scatterlist, num_elem);\n\tsglist->order = order;\n\tsglist->num_sg = num_elem;\n\tsg_size = buflen;\n\n\tfor (i = 0; i < num_elem; i++) {\n\t\tpage = alloc_pages(GFP_KERNEL|GFP_DMA|__GFP_ZERO, order);\n\t\tif (!page) {\n\t\t\tfor (j = i - 1; j >= 0; j--)\n\t\t\t\t__free_pages(sg_page(&scatterlist[j]), order);\n\t\t\tkfree(sglist);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsg_set_page(&scatterlist[i], page,\n\t\t\tsg_size < bsize_elem ? sg_size : bsize_elem, 0);\n\t\tsg_size -= bsize_elem;\n\t}\n\n\treturn sglist;\n}\n\n/**\n * pmcraid_copy_sglist - Copy user buffer to kernel buffer's SG list\n * @sglist: scatter/gather list pointer\n * @buffer: buffer pointer\n * @len: buffer length\n * @direction: data transfer direction\n *\n * Copy a user buffer into a buffer allocated by pmcraid_alloc_sglist\n *\n * Return value:\n * 0 on success / other on failure\n */\nstatic int pmcraid_copy_sglist(\n\tstruct pmcraid_sglist *sglist,\n\tunsigned long buffer,\n\tu32 len,\n\tint direction\n)\n{\n\tstruct scatterlist *scatterlist;\n\tvoid *kaddr;\n\tint bsize_elem;\n\tint i;\n\tint rc = 0;\n\n\t/* Determine the actual number of bytes per element */\n\tbsize_elem = PAGE_SIZE * (1 << sglist->order);\n\n\tscatterlist = sglist->scatterlist;\n\n\tfor (i = 0; i < (len / bsize_elem); i++, buffer += bsize_elem) {\n\t\tstruct page *page = sg_page(&scatterlist[i]);\n\n\t\tkaddr = kmap(page);\n\t\tif (direction == DMA_TO_DEVICE)\n\t\t\trc = __copy_from_user(kaddr,\n\t\t\t\t\t      (void *)buffer,\n\t\t\t\t\t      bsize_elem);\n\t\telse\n\t\t\trc = __copy_to_user((void *)buffer, kaddr, bsize_elem);\n\n\t\tkunmap(page);\n\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user data into sg list\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tscatterlist[i].length = bsize_elem;\n\t}\n\n\tif (len % bsize_elem) {\n\t\tstruct page *page = sg_page(&scatterlist[i]);\n\n\t\tkaddr = kmap(page);\n\n\t\tif (direction == DMA_TO_DEVICE)\n\t\t\trc = __copy_from_user(kaddr,\n\t\t\t\t\t      (void *)buffer,\n\t\t\t\t\t      len % bsize_elem);\n\t\telse\n\t\t\trc = __copy_to_user((void *)buffer,\n\t\t\t\t\t    kaddr,\n\t\t\t\t\t    len % bsize_elem);\n\n\t\tkunmap(page);\n\n\t\tscatterlist[i].length = len % bsize_elem;\n\t}\n\n\tif (rc) {\n\t\tpmcraid_err(\"failed to copy user data into sg list\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\treturn rc;\n}\n\n/**\n * pmcraid_queuecommand - Queue a mid-layer request\n * @scsi_cmd: scsi command struct\n * @done: done function\n *\n * This function queues a request generated by the mid-layer. Midlayer calls\n * this routine within host->lock. Some of the functions called by queuecommand\n * would use cmd block queue locks (free_pool_lock and pending_pool_lock)\n *\n * Return value:\n *\t  0 on success\n *\t  SCSI_MLQUEUE_DEVICE_BUSY if device is busy\n *\t  SCSI_MLQUEUE_HOST_BUSY if host is busy\n */\nstatic int pmcraid_queuecommand_lck(\n\tstruct scsi_cmnd *scsi_cmd,\n\tvoid (*done) (struct scsi_cmnd *)\n)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tu32 fw_version;\n\tint rc = 0;\n\n\tpinstance =\n\t\t(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\tscsi_cmd->scsi_done = done;\n\tres = scsi_cmd->device->hostdata;\n\tscsi_cmd->result = (DID_OK << 16);\n\n\t/* if adapter is marked as dead, set result to DID_NO_CONNECT complete\n\t * the command\n\t */\n\tif (pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\tpmcraid_info(\"IOA is dead, but queuecommand is scheduled\\n\");\n\t\tscsi_cmd->result = (DID_NO_CONNECT << 16);\n\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t\treturn 0;\n\t}\n\n\t/* If IOA reset is in progress, can't queue the commands */\n\tif (pinstance->ioa_reset_in_progress)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t/* Firmware doesn't support SYNCHRONIZE_CACHE command (0x35), complete\n\t * the command here itself with success return\n\t */\n\tif (scsi_cmd->cmnd[0] == SYNCHRONIZE_CACHE) {\n\t\tpmcraid_info(\"SYNC_CACHE(0x35), completing in driver itself\\n\");\n\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t\treturn 0;\n\t}\n\n\t/* initialize the command and IOARCB to be sent to IOA */\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (cmd == NULL) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tcmd->scsi_cmd = scsi_cmd;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\tmemcpy(ioarcb->cdb, scsi_cmd->cmnd, scsi_cmd->cmd_len);\n\tioarcb->resource_handle = res->cfg_entry.resource_handle;\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\tcmd->cmd_done = pmcraid_io_done;\n\n\tif (RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry)) {\n\t\tif (scsi_cmd->underflow == 0)\n\t\t\tioarcb->request_flags0 |= INHIBIT_UL_CHECK;\n\n\t\tif (res->sync_reqd) {\n\t\t\tioarcb->request_flags0 |= SYNC_COMPLETE;\n\t\t\tres->sync_reqd = 0;\n\t\t}\n\n\t\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\t\tioarcb->request_flags1 |= pmcraid_task_attributes(scsi_cmd);\n\n\t\tif (RES_IS_GSCSI(res->cfg_entry))\n\t\t\tioarcb->request_flags1 |= DELAY_AFTER_RESET;\n\t}\n\n\trc = pmcraid_build_ioadl(pinstance, cmd);\n\n\tpmcraid_info(\"command (%d) CDB[0] = %x for %x:%x:%x:%x\\n\",\n\t\t     le32_to_cpu(ioarcb->response_handle) >> 2,\n\t\t     scsi_cmd->cmnd[0], pinstance->host->unique_id,\n\t\t     RES_IS_VSET(res->cfg_entry) ? PMCRAID_VSET_BUS_ID :\n\t\t\tPMCRAID_PHYS_BUS_ID,\n\t\t     RES_IS_VSET(res->cfg_entry) ?\n\t\t\t(fw_version <= PMCRAID_FW_VERSION_1 ?\n\t\t\t\tres->cfg_entry.unique_flags1 :\n\t\t\t\t\tres->cfg_entry.array_id & 0xFF) :\n\t\t\tRES_TARGET(res->cfg_entry.resource_address),\n\t\t     RES_LUN(res->cfg_entry.resource_address));\n\n\tif (likely(rc == 0)) {\n\t\t_pmcraid_fire_command(cmd);\n\t} else {\n\t\tpmcraid_err(\"queuecommand could not build ioadl\\n\");\n\t\tpmcraid_return_cmd(cmd);\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\treturn rc;\n}\n\nstatic DEF_SCSI_QCMD(pmcraid_queuecommand)\n\n/**\n * pmcraid_open -char node \"open\" entry, allowed only users with admin access\n */\nstatic int pmcraid_chr_open(struct inode *inode, struct file *filep)\n{\n\tstruct pmcraid_instance *pinstance;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\t/* Populate adapter instance * pointer for use by ioctl */\n\tpinstance = container_of(inode->i_cdev, struct pmcraid_instance, cdev);\n\tfilep->private_data = pinstance;\n\n\treturn 0;\n}\n\n/**\n * pmcraid_release - char node \"release\" entry point\n */\nstatic int pmcraid_chr_release(struct inode *inode, struct file *filep)\n{\n\tstruct pmcraid_instance *pinstance = filep->private_data;\n\n\tfilep->private_data = NULL;\n\tfasync_helper(-1, filep, 0, &pinstance->aen_queue);\n\n\treturn 0;\n}\n\n/**\n * pmcraid_fasync - Async notifier registration from applications\n *\n * This function adds the calling process to a driver global queue. When an\n * event occurs, SIGIO will be sent to all processes in this queue.\n */\nstatic int pmcraid_chr_fasync(int fd, struct file *filep, int mode)\n{\n\tstruct pmcraid_instance *pinstance;\n\tint rc;\n\n\tpinstance = filep->private_data;\n\tmutex_lock(&pinstance->aen_queue_lock);\n\trc = fasync_helper(fd, filep, mode, &pinstance->aen_queue);\n\tmutex_unlock(&pinstance->aen_queue_lock);\n\n\treturn rc;\n}\n\n\n/**\n * pmcraid_build_passthrough_ioadls - builds SG elements for passthrough\n * commands sent over IOCTL interface\n *\n * @cmd       : pointer to struct pmcraid_cmd\n * @buflen    : length of the request buffer\n * @direction : data transfer direction\n *\n * Return value\n *  0 on success, non-zero error code on failure\n */\nstatic int pmcraid_build_passthrough_ioadls(\n\tstruct pmcraid_cmd *cmd,\n\tint buflen,\n\tint direction\n)\n{\n\tstruct pmcraid_sglist *sglist = NULL;\n\tstruct scatterlist *sg = NULL;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl;\n\tint i;\n\n\tsglist = pmcraid_alloc_sglist(buflen);\n\n\tif (!sglist) {\n\t\tpmcraid_err(\"can't allocate memory for passthrough SGls\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsglist->num_dma_sg = pci_map_sg(cmd->drv_inst->pdev,\n\t\t\t\t\tsglist->scatterlist,\n\t\t\t\t\tsglist->num_sg, direction);\n\n\tif (!sglist->num_dma_sg || sglist->num_dma_sg > PMCRAID_MAX_IOADLS) {\n\t\tdev_err(&cmd->drv_inst->pdev->dev,\n\t\t\t\"Failed to map passthrough buffer!\\n\");\n\t\tpmcraid_free_sglist(sglist);\n\t\treturn -EIO;\n\t}\n\n\tcmd->sglist = sglist;\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\n\tioadl = pmcraid_init_ioadls(cmd, sglist->num_dma_sg);\n\n\t/* Initialize IOADL descriptor addresses */\n\tfor_each_sg(sglist->scatterlist, sg, sglist->num_dma_sg, i) {\n\t\tioadl[i].data_len = cpu_to_le32(sg_dma_len(sg));\n\t\tioadl[i].address = cpu_to_le64(sg_dma_address(sg));\n\t\tioadl[i].flags = 0;\n\t}\n\n\t/* setup the last descriptor */\n\tioadl[i - 1].flags = IOADL_FLAGS_LAST_DESC;\n\n\treturn 0;\n}\n\n\n/**\n * pmcraid_release_passthrough_ioadls - release passthrough ioadls\n *\n * @cmd: pointer to struct pmcraid_cmd for which ioadls were allocated\n * @buflen: size of the request buffer\n * @direction: data transfer direction\n *\n * Return value\n *  0 on success, non-zero error code on failure\n */\nstatic void pmcraid_release_passthrough_ioadls(\n\tstruct pmcraid_cmd *cmd,\n\tint buflen,\n\tint direction\n)\n{\n\tstruct pmcraid_sglist *sglist = cmd->sglist;\n\n\tif (buflen > 0) {\n\t\tpci_unmap_sg(cmd->drv_inst->pdev,\n\t\t\t     sglist->scatterlist,\n\t\t\t     sglist->num_sg,\n\t\t\t     direction);\n\t\tpmcraid_free_sglist(sglist);\n\t\tcmd->sglist = NULL;\n\t}\n}\n\n/**\n * pmcraid_ioctl_passthrough - handling passthrough IOCTL commands\n *\n * @pinstance: pointer to adapter instance structure\n * @cmd: ioctl code\n * @arg: pointer to pmcraid_passthrough_buffer user buffer\n *\n * Return value\n *  0 on success, non-zero error code on failure\n */\nstatic long pmcraid_ioctl_passthrough(\n\tstruct pmcraid_instance *pinstance,\n\tunsigned int ioctl_cmd,\n\tunsigned int buflen,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_passthrough_ioctl_buffer *buffer;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cancel_cmd;\n\tunsigned long request_buffer;\n\tunsigned long request_offset;\n\tunsigned long lock_flags;\n\tvoid *ioasa;\n\tu32 ioasc;\n\tint request_size;\n\tint buffer_size;\n\tu8 access, direction;\n\tint rc = 0;\n\n\t/* If IOA reset is in progress, wait 10 secs for reset to complete */\n\tif (pinstance->ioa_reset_in_progress) {\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\tpinstance->reset_wait_q,\n\t\t\t\t!pinstance->ioa_reset_in_progress,\n\t\t\t\tmsecs_to_jiffies(10000));\n\n\t\tif (!rc)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (rc < 0)\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\t/* If adapter is not in operational state, return error */\n\tif (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {\n\t\tpmcraid_err(\"IOA is not operational\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\tbuffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\tpmcraid_err(\"no memory for passthrough buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trequest_offset =\n\t    offsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);\n\n\trequest_buffer = arg + request_offset;\n\n\trc = __copy_from_user(buffer,\n\t\t\t     (struct pmcraid_passthrough_ioctl_buffer *) arg,\n\t\t\t     sizeof(struct pmcraid_passthrough_ioctl_buffer));\n\n\tioasa =\n\t(void *)(arg +\n\t\toffsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));\n\n\tif (rc) {\n\t\tpmcraid_err(\"ioctl: can't copy passthrough buffer\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out_free_buffer;\n\t}\n\n\trequest_size = buffer->ioarcb.data_transfer_length;\n\n\tif (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {\n\t\taccess = VERIFY_READ;\n\t\tdirection = DMA_TO_DEVICE;\n\t} else {\n\t\taccess = VERIFY_WRITE;\n\t\tdirection = DMA_FROM_DEVICE;\n\t}\n\n\tif (request_size > 0) {\n\t\trc = access_ok(access, arg, request_offset + request_size);\n\n\t\tif (!rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* check if we have any additional command parameters */\n\tif (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd->scsi_cmd = NULL;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\n\t/* Copy the user-provided IOARCB stuff field by field */\n\tioarcb->resource_handle = buffer->ioarcb.resource_handle;\n\tioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;\n\tioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;\n\tioarcb->request_type = buffer->ioarcb.request_type;\n\tioarcb->request_flags0 = buffer->ioarcb.request_flags0;\n\tioarcb->request_flags1 = buffer->ioarcb.request_flags1;\n\tmemcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);\n\n\tif (buffer->ioarcb.add_cmd_param_length) {\n\t\tioarcb->add_cmd_param_length =\n\t\t\tbuffer->ioarcb.add_cmd_param_length;\n\t\tioarcb->add_cmd_param_offset =\n\t\t\tbuffer->ioarcb.add_cmd_param_offset;\n\t\tmemcpy(ioarcb->add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_cmd_param_length);\n\t}\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\n\tif (request_size) {\n\t\trc = pmcraid_build_passthrough_ioadls(cmd,\n\t\t\t\t\t\t      request_size,\n\t\t\t\t\t\t      direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"couldn't build passthrough ioadls\\n\");\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t}\n\n\t/* If data is being written into the device, copy the data from user\n\t * buffers\n\t */\n\tif (direction == DMA_TO_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\tgoto out_free_sglist;\n\t\t}\n\t}\n\n\t/* passthrough ioctl is a blocking command so, put the user to sleep\n\t * until timeout. Note that a timeout value of 0 means, do timeout.\n\t */\n\tcmd->cmd_done = pmcraid_internal_done;\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"command(%d) (CDB[0] = %x) for %x\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t_pmcraid_fire_command(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* NOTE ! Remove the below line once abort_task is implemented\n\t * in firmware. This line disables ioctl command timeout handling logic\n\t * similar to IO command timeout handling, making ioctl commands to wait\n\t * until the command completion regardless of timeout value specified in\n\t * ioarcb\n\t */\n\tbuffer->ioarcb.cmd_timeout = 0;\n\n\t/* If command timeout is specified put caller to wait till that time,\n\t * otherwise it would be blocking wait. If command gets timed out, it\n\t * will be aborted.\n\t */\n\tif (buffer->ioarcb.cmd_timeout == 0) {\n\t\twait_for_completion(&cmd->wait_for_completion);\n\t} else if (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {\n\n\t\tpmcraid_info(\"aborting cmd %d (CDB[0] = %x) due to timeout\\n\",\n\t\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),\n\t\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\tif (cancel_cmd) {\n\t\t\twait_for_completion(&cancel_cmd->wait_for_completion);\n\t\t\tioasc = cancel_cmd->ioa_cb->ioasa.ioasc;\n\t\t\tpmcraid_return_cmd(cancel_cmd);\n\n\t\t\t/* if abort task couldn't find the command i.e it got\n\t\t\t * completed prior to aborting, return good completion.\n\t\t\t * if command got aborted successfully or there was IOA\n\t\t\t * reset due to abort task itself getting timedout then\n\t\t\t * return -ETIMEDOUT\n\t\t\t */\n\t\t\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t\t\t    PMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {\n\t\t\t\tif (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto out_handle_response;\n\t\t\t}\n\t\t}\n\n\t\t/* no command block for abort task or abort task failed to abort\n\t\t * the IOARCB, then wait for 150 more seconds and initiate reset\n\t\t * sequence after timeout\n\t\t */\n\t\tif (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(150 * 1000))) {\n\t\t\tpmcraid_reset_bringup(cmd->drv_inst);\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\t}\n\nout_handle_response:\n\t/* copy entire IOASA buffer and return IOCTL success.\n\t * If copying IOASA to user-buffer fails, return\n\t * EFAULT\n\t */\n\tif (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,\n\t\tsizeof(struct pmcraid_ioasa))) {\n\t\tpmcraid_err(\"failed to copy ioasa buffer to user\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\t/* If the data transfer was from device, copy the data onto user\n\t * buffers\n\t */\n\telse if (direction == DMA_FROM_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\nout_free_sglist:\n\tpmcraid_release_passthrough_ioadls(cmd, request_size, direction);\n\tpmcraid_return_cmd(cmd);\n\nout_free_buffer:\n\tkfree(buffer);\n\n\treturn rc;\n}\n\n\n\n\n/**\n * pmcraid_ioctl_driver - ioctl handler for commands handled by driver itself\n *\n * @pinstance: pointer to adapter instance structure\n * @cmd: ioctl command passed in\n * @buflen: length of user_buffer\n * @user_buffer: user buffer pointer\n *\n * Return Value\n *   0 in case of success, otherwise appropriate error code\n */\nstatic long pmcraid_ioctl_driver(\n\tstruct pmcraid_instance *pinstance,\n\tunsigned int cmd,\n\tunsigned int buflen,\n\tvoid __user *user_buffer\n)\n{\n\tint rc = -ENOSYS;\n\n\tif (!access_ok(VERIFY_READ, user_buffer, _IOC_SIZE(cmd))) {\n\t\tpmcraid_err(\"ioctl_driver: access fault in request buffer\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (cmd) {\n\tcase PMCRAID_IOCTL_RESET_ADAPTER:\n\t\tpmcraid_reset_bringup(pinstance);\n\t\trc = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n/**\n * pmcraid_check_ioctl_buffer - check for proper access to user buffer\n *\n * @cmd: ioctl command\n * @arg: user buffer\n * @hdr: pointer to kernel memory for pmcraid_ioctl_header\n *\n * Return Value\n *\tnegetive error code if there are access issues, otherwise zero.\n *\tUpon success, returns ioctl header copied out of user buffer.\n */\n\nstatic int pmcraid_check_ioctl_buffer(\n\tint cmd,\n\tvoid __user *arg,\n\tstruct pmcraid_ioctl_header *hdr\n)\n{\n\tint rc = 0;\n\tint access = VERIFY_READ;\n\n\tif (copy_from_user(hdr, arg, sizeof(struct pmcraid_ioctl_header))) {\n\t\tpmcraid_err(\"couldn't copy ioctl header from user buffer\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* check for valid driver signature */\n\trc = memcmp(hdr->signature,\n\t\t    PMCRAID_IOCTL_SIGNATURE,\n\t\t    sizeof(hdr->signature));\n\tif (rc) {\n\t\tpmcraid_err(\"signature verification failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check for appropriate buffer access */\n\tif ((_IOC_DIR(cmd) & _IOC_READ) == _IOC_READ)\n\t\taccess = VERIFY_WRITE;\n\n\trc = access_ok(access,\n\t\t       (arg + sizeof(struct pmcraid_ioctl_header)),\n\t\t       hdr->buffer_length);\n\tif (!rc) {\n\t\tpmcraid_err(\"access failed for user buffer of size %d\\n\",\n\t\t\t     hdr->buffer_length);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/**\n *  pmcraid_ioctl - char node ioctl entry point\n */\nstatic long pmcraid_chr_ioctl(\n\tstruct file *filep,\n\tunsigned int cmd,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_instance *pinstance = NULL;\n\tstruct pmcraid_ioctl_header *hdr = NULL;\n\tint retval = -ENOTTY;\n\n\thdr = kmalloc(GFP_KERNEL, sizeof(struct pmcraid_ioctl_header));\n\n\tif (!hdr) {\n\t\tpmcraid_err(\"faile to allocate memory for ioctl header\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tretval = pmcraid_check_ioctl_buffer(cmd, (void *)arg, hdr);\n\n\tif (retval) {\n\t\tpmcraid_info(\"chr_ioctl: header check failed\\n\");\n\t\tkfree(hdr);\n\t\treturn retval;\n\t}\n\n\tpinstance = filep->private_data;\n\n\tif (!pinstance) {\n\t\tpmcraid_info(\"adapter instance is not found\\n\");\n\t\tkfree(hdr);\n\t\treturn -ENOTTY;\n\t}\n\n\tswitch (_IOC_TYPE(cmd)) {\n\n\tcase PMCRAID_PASSTHROUGH_IOCTL:\n\t\t/* If ioctl code is to download microcode, we need to block\n\t\t * mid-layer requests.\n\t\t */\n\t\tif (cmd == PMCRAID_IOCTL_DOWNLOAD_MICROCODE)\n\t\t\tscsi_block_requests(pinstance->host);\n\n\t\tretval = pmcraid_ioctl_passthrough(pinstance,\n\t\t\t\t\t\t   cmd,\n\t\t\t\t\t\t   hdr->buffer_length,\n\t\t\t\t\t\t   arg);\n\n\t\tif (cmd == PMCRAID_IOCTL_DOWNLOAD_MICROCODE)\n\t\t\tscsi_unblock_requests(pinstance->host);\n\t\tbreak;\n\n\tcase PMCRAID_DRIVER_IOCTL:\n\t\targ += sizeof(struct pmcraid_ioctl_header);\n\t\tretval = pmcraid_ioctl_driver(pinstance,\n\t\t\t\t\t      cmd,\n\t\t\t\t\t      hdr->buffer_length,\n\t\t\t\t\t      (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tkfree(hdr);\n\n\treturn retval;\n}\n\n/**\n * File operations structure for management interface\n */\nstatic const struct file_operations pmcraid_fops = {\n\t.owner = THIS_MODULE,\n\t.open = pmcraid_chr_open,\n\t.release = pmcraid_chr_release,\n\t.fasync = pmcraid_chr_fasync,\n\t.unlocked_ioctl = pmcraid_chr_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = pmcraid_chr_ioctl,\n#endif\n\t.llseek = noop_llseek,\n};\n\n\n\n\n/**\n * pmcraid_show_log_level - Display adapter's error logging level\n * @dev: class device struct\n * @buf: buffer\n *\n * Return value:\n *  number of bytes printed to buffer\n */\nstatic ssize_t pmcraid_show_log_level(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct pmcraid_instance *pinstance =\n\t\t(struct pmcraid_instance *)shost->hostdata;\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", pinstance->current_log_level);\n}\n\n/**\n * pmcraid_store_log_level - Change the adapter's error logging level\n * @dev: class device struct\n * @buf: buffer\n * @count: not used\n *\n * Return value:\n *  number of bytes printed to buffer\n */\nstatic ssize_t pmcraid_store_log_level(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tconst char *buf,\n\tsize_t count\n)\n{\n\tstruct Scsi_Host *shost;\n\tstruct pmcraid_instance *pinstance;\n\tunsigned long val;\n\n\tif (strict_strtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\t/* log-level should be from 0 to 2 */\n\tif (val > 2)\n\t\treturn -EINVAL;\n\n\tshost = class_to_shost(dev);\n\tpinstance = (struct pmcraid_instance *)shost->hostdata;\n\tpinstance->current_log_level = val;\n\n\treturn strlen(buf);\n}\n\nstatic struct device_attribute pmcraid_log_level_attr = {\n\t.attr = {\n\t\t .name = \"log_level\",\n\t\t .mode = S_IRUGO | S_IWUSR,\n\t\t },\n\t.show = pmcraid_show_log_level,\n\t.store = pmcraid_store_log_level,\n};\n\n/**\n * pmcraid_show_drv_version - Display driver version\n * @dev: class device struct\n * @buf: buffer\n *\n * Return value:\n *  number of bytes printed to buffer\n */\nstatic ssize_t pmcraid_show_drv_version(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf\n)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"version: %s\\n\",\n\t\t\tPMCRAID_DRIVER_VERSION);\n}\n\nstatic struct device_attribute pmcraid_driver_version_attr = {\n\t.attr = {\n\t\t .name = \"drv_version\",\n\t\t .mode = S_IRUGO,\n\t\t },\n\t.show = pmcraid_show_drv_version,\n};\n\n/**\n * pmcraid_show_io_adapter_id - Display driver assigned adapter id\n * @dev: class device struct\n * @buf: buffer\n *\n * Return value:\n *  number of bytes printed to buffer\n */\nstatic ssize_t pmcraid_show_adapter_id(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf\n)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct pmcraid_instance *pinstance =\n\t\t(struct pmcraid_instance *)shost->hostdata;\n\tu32 adapter_id = (pinstance->pdev->bus->number << 8) |\n\t\tpinstance->pdev->devfn;\n\tu32 aen_group = pmcraid_event_family.id;\n\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"adapter id: %d\\nminor: %d\\naen group: %d\\n\",\n\t\t\tadapter_id, MINOR(pinstance->cdev.dev), aen_group);\n}\n\nstatic struct device_attribute pmcraid_adapter_id_attr = {\n\t.attr = {\n\t\t .name = \"adapter_id\",\n\t\t .mode = S_IRUGO | S_IWUSR,\n\t\t },\n\t.show = pmcraid_show_adapter_id,\n};\n\nstatic struct device_attribute *pmcraid_host_attrs[] = {\n\t&pmcraid_log_level_attr,\n\t&pmcraid_driver_version_attr,\n\t&pmcraid_adapter_id_attr,\n\tNULL,\n};\n\n\n/* host template structure for pmcraid driver */\nstatic struct scsi_host_template pmcraid_host_template = {\n\t.module = THIS_MODULE,\n\t.name = PMCRAID_DRIVER_NAME,\n\t.queuecommand = pmcraid_queuecommand,\n\t.eh_abort_handler = pmcraid_eh_abort_handler,\n\t.eh_bus_reset_handler = pmcraid_eh_bus_reset_handler,\n\t.eh_target_reset_handler = pmcraid_eh_target_reset_handler,\n\t.eh_device_reset_handler = pmcraid_eh_device_reset_handler,\n\t.eh_host_reset_handler = pmcraid_eh_host_reset_handler,\n\n\t.slave_alloc = pmcraid_slave_alloc,\n\t.slave_configure = pmcraid_slave_configure,\n\t.slave_destroy = pmcraid_slave_destroy,\n\t.change_queue_depth = pmcraid_change_queue_depth,\n\t.change_queue_type  = pmcraid_change_queue_type,\n\t.can_queue = PMCRAID_MAX_IO_CMD,\n\t.this_id = -1,\n\t.sg_tablesize = PMCRAID_MAX_IOADLS,\n\t.max_sectors = PMCRAID_IOA_MAX_SECTORS,\n\t.cmd_per_lun = PMCRAID_MAX_CMD_PER_LUN,\n\t.use_clustering = ENABLE_CLUSTERING,\n\t.shost_attrs = pmcraid_host_attrs,\n\t.proc_name = PMCRAID_DRIVER_NAME\n};\n\n/*\n * pmcraid_isr_msix - implements MSI-X interrupt handling routine\n * @irq: interrupt vector number\n * @dev_id: pointer hrrq_vector\n *\n * Return Value\n *\t IRQ_HANDLED if interrupt is handled or IRQ_NONE if ignored\n */\n\nstatic irqreturn_t pmcraid_isr_msix(int irq, void *dev_id)\n{\n\tstruct pmcraid_isr_param *hrrq_vector;\n\tstruct pmcraid_instance *pinstance;\n\tunsigned long lock_flags;\n\tu32 intrs_val;\n\tint hrrq_id;\n\n\thrrq_vector = (struct pmcraid_isr_param *)dev_id;\n\thrrq_id = hrrq_vector->hrrq_id;\n\tpinstance = hrrq_vector->drv_inst;\n\n\tif (!hrrq_id) {\n\t\t/* Read the interrupt */\n\t\tintrs_val = pmcraid_read_interrupts(pinstance);\n\t\tif (intrs_val &&\n\t\t\t((ioread32(pinstance->int_regs.host_ioa_interrupt_reg)\n\t\t\t& DOORBELL_INTR_MSIX_CLR) == 0)) {\n\t\t\t/* Any error interrupts including unit_check,\n\t\t\t * initiate IOA reset.In case of unit check indicate\n\t\t\t * to reset_sequence that IOA unit checked and prepare\n\t\t\t * for a dump during reset sequence\n\t\t\t */\n\t\t\tif (intrs_val & PMCRAID_ERROR_INTERRUPTS) {\n\t\t\t\tif (intrs_val & INTRS_IOA_UNIT_CHECK)\n\t\t\t\t\tpinstance->ioa_unit_check = 1;\n\n\t\t\t\tpmcraid_err(\"ISR: error interrupts: %x \\\n\t\t\t\t\tinitiating reset\\n\", intrs_val);\n\t\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\tlock_flags);\n\t\t\t\tpmcraid_initiate_reset(pinstance);\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\tpinstance->host->host_lock,\n\t\t\t\t\tlock_flags);\n\t\t\t}\n\t\t\t/* If interrupt was as part of the ioa initialization,\n\t\t\t * clear it. Delete the timer and wakeup the\n\t\t\t * reset engine to proceed with reset sequence\n\t\t\t */\n\t\t\tif (intrs_val & INTRS_TRANSITION_TO_OPERATIONAL)\n\t\t\t\tpmcraid_clr_trans_op(pinstance);\n\n\t\t\t/* Clear the interrupt register by writing\n\t\t\t * to host to ioa doorbell. Once done\n\t\t\t * FW will clear the interrupt.\n\t\t\t */\n\t\t\tiowrite32(DOORBELL_INTR_MSIX_CLR,\n\t\t\t\tpinstance->int_regs.host_ioa_interrupt_reg);\n\t\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\n\n\t\t}\n\t}\n\n\ttasklet_schedule(&(pinstance->isr_tasklet[hrrq_id]));\n\n\treturn IRQ_HANDLED;\n}\n\n/**\n * pmcraid_isr  - implements legacy interrupt handling routine\n *\n * @irq: interrupt vector number\n * @dev_id: pointer hrrq_vector\n *\n * Return Value\n *\t IRQ_HANDLED if interrupt is handled or IRQ_NONE if ignored\n */\nstatic irqreturn_t pmcraid_isr(int irq, void *dev_id)\n{\n\tstruct pmcraid_isr_param *hrrq_vector;\n\tstruct pmcraid_instance *pinstance;\n\tu32 intrs;\n\tunsigned long lock_flags;\n\tint hrrq_id = 0;\n\n\t/* In case of legacy interrupt mode where interrupts are shared across\n\t * isrs, it may be possible that the current interrupt is not from IOA\n\t */\n\tif (!dev_id) {\n\t\tprintk(KERN_INFO \"%s(): NULL host pointer\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\thrrq_vector = (struct pmcraid_isr_param *)dev_id;\n\tpinstance = hrrq_vector->drv_inst;\n\n\tintrs = pmcraid_read_interrupts(pinstance);\n\n\tif (unlikely((intrs & PMCRAID_PCI_INTERRUPTS) == 0))\n\t\treturn IRQ_NONE;\n\n\t/* Any error interrupts including unit_check, initiate IOA reset.\n\t * In case of unit check indicate to reset_sequence that IOA unit\n\t * checked and prepare for a dump during reset sequence\n\t */\n\tif (intrs & PMCRAID_ERROR_INTERRUPTS) {\n\n\t\tif (intrs & INTRS_IOA_UNIT_CHECK)\n\t\t\tpinstance->ioa_unit_check = 1;\n\n\t\tiowrite32(intrs,\n\t\t\t  pinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\tpmcraid_err(\"ISR: error interrupts: %x initiating reset\\n\",\n\t\t\t    intrs);\n\t\tintrs = ioread32(\n\t\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_initiate_reset(pinstance);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t} else {\n\t\t/* If interrupt was as part of the ioa initialization,\n\t\t * clear. Delete the timer and wakeup the\n\t\t * reset engine to proceed with reset sequence\n\t\t */\n\t\tif (intrs & INTRS_TRANSITION_TO_OPERATIONAL) {\n\t\t\tpmcraid_clr_trans_op(pinstance);\n\t\t} else {\n\t\t\tiowrite32(intrs,\n\t\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\t\tioread32(\n\t\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\n\t\t\ttasklet_schedule(\n\t\t\t\t\t&(pinstance->isr_tasklet[hrrq_id]));\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n\n/**\n * pmcraid_worker_function -  worker thread function\n *\n * @workp: pointer to struct work queue\n *\n * Return Value\n *\t None\n */\n\nstatic void pmcraid_worker_function(struct work_struct *workp)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\tstruct pmcraid_resource_entry *temp;\n\tstruct scsi_device *sdev;\n\tunsigned long lock_flags;\n\tunsigned long host_lock_flags;\n\tu16 fw_version;\n\tu8 bus, target, lun;\n\n\tpinstance = container_of(workp, struct pmcraid_instance, worker_q);\n\t/* add resources only after host is added into system */\n\tif (!atomic_read(&pinstance->expose_resources))\n\t\treturn;\n\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\n\tspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\n\tlist_for_each_entry_safe(res, temp, &pinstance->used_res_q, queue) {\n\n\t\tif (res->change_detected == RES_CHANGE_DEL && res->scsi_dev) {\n\t\t\tsdev = res->scsi_dev;\n\n\t\t\t/* host_lock must be held before calling\n\t\t\t * scsi_device_get\n\t\t\t */\n\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\t  host_lock_flags);\n\t\t\tif (!scsi_device_get(sdev)) {\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\tpinstance->host->host_lock,\n\t\t\t\t\t\thost_lock_flags);\n\t\t\t\tpmcraid_info(\"deleting %x from midlayer\\n\",\n\t\t\t\t\t     res->cfg_entry.resource_address);\n\t\t\t\tlist_move_tail(&res->queue,\n\t\t\t\t\t\t&pinstance->free_res_q);\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t&pinstance->resource_lock,\n\t\t\t\t\tlock_flags);\n\t\t\t\tscsi_remove_device(sdev);\n\t\t\t\tscsi_device_put(sdev);\n\t\t\t\tspin_lock_irqsave(&pinstance->resource_lock,\n\t\t\t\t\t\t   lock_flags);\n\t\t\t\tres->change_detected = 0;\n\t\t\t} else {\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\tpinstance->host->host_lock,\n\t\t\t\t\t\thost_lock_flags);\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_for_each_entry(res, &pinstance->used_res_q, queue) {\n\n\t\tif (res->change_detected == RES_CHANGE_ADD) {\n\n\t\t\tif (!pmcraid_expose_resource(fw_version,\n\t\t\t\t\t\t     &res->cfg_entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (RES_IS_VSET(res->cfg_entry)) {\n\t\t\t\tbus = PMCRAID_VSET_BUS_ID;\n\t\t\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\t\t\ttarget = res->cfg_entry.unique_flags1;\n\t\t\t\telse\n\t\t\t\t\ttarget = res->cfg_entry.array_id & 0xFF;\n\t\t\t\tlun = PMCRAID_VSET_LUN_ID;\n\t\t\t} else {\n\t\t\t\tbus = PMCRAID_PHYS_BUS_ID;\n\t\t\t\ttarget =\n\t\t\t\t     RES_TARGET(\n\t\t\t\t\tres->cfg_entry.resource_address);\n\t\t\t\tlun = RES_LUN(res->cfg_entry.resource_address);\n\t\t\t}\n\n\t\t\tres->change_detected = 0;\n\t\t\tspin_unlock_irqrestore(&pinstance->resource_lock,\n\t\t\t\t\t\tlock_flags);\n\t\t\tscsi_add_device(pinstance->host, bus, target, lun);\n\t\t\tspin_lock_irqsave(&pinstance->resource_lock,\n\t\t\t\t\t   lock_flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\n}\n\n/**\n * pmcraid_tasklet_function - Tasklet function\n *\n * @instance: pointer to msix param structure\n *\n * Return Value\n *\tNone\n */\nstatic void pmcraid_tasklet_function(unsigned long instance)\n{\n\tstruct pmcraid_isr_param *hrrq_vector;\n\tstruct pmcraid_instance *pinstance;\n\tunsigned long hrrq_lock_flags;\n\tunsigned long pending_lock_flags;\n\tunsigned long host_lock_flags;\n\tspinlock_t *lockp; /* hrrq buffer lock */\n\tint id;\n\t__le32 resp;\n\n\thrrq_vector = (struct pmcraid_isr_param *)instance;\n\tpinstance = hrrq_vector->drv_inst;\n\tid = hrrq_vector->hrrq_id;\n\tlockp = &(pinstance->hrrq_lock[id]);\n\n\t/* loop through each of the commands responded by IOA. Each HRRQ buf is\n\t * protected by its own lock. Traversals must be done within this lock\n\t * as there may be multiple tasklets running on multiple CPUs. Note\n\t * that the lock is held just for picking up the response handle and\n\t * manipulating hrrq_curr/toggle_bit values.\n\t */\n\tspin_lock_irqsave(lockp, hrrq_lock_flags);\n\n\tresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\n\n\twhile ((resp & HRRQ_TOGGLE_BIT) ==\n\t\tpinstance->host_toggle_bit[id]) {\n\n\t\tint cmd_index = resp >> 2;\n\t\tstruct pmcraid_cmd *cmd = NULL;\n\n\t\tif (pinstance->hrrq_curr[id] < pinstance->hrrq_end[id]) {\n\t\t\tpinstance->hrrq_curr[id]++;\n\t\t} else {\n\t\t\tpinstance->hrrq_curr[id] = pinstance->hrrq_start[id];\n\t\t\tpinstance->host_toggle_bit[id] ^= 1u;\n\t\t}\n\n\t\tif (cmd_index >= PMCRAID_MAX_CMD) {\n\t\t\t/* In case of invalid response handle, log message */\n\t\t\tpmcraid_err(\"Invalid response handle %d\\n\", cmd_index);\n\t\t\tresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd = pinstance->cmd_list[cmd_index];\n\t\tspin_unlock_irqrestore(lockp, hrrq_lock_flags);\n\n\t\tspin_lock_irqsave(&pinstance->pending_pool_lock,\n\t\t\t\t   pending_lock_flags);\n\t\tlist_del(&cmd->free_list);\n\t\tspin_unlock_irqrestore(&pinstance->pending_pool_lock,\n\t\t\t\t\tpending_lock_flags);\n\t\tdel_timer(&cmd->timer);\n\t\tatomic_dec(&pinstance->outstanding_cmds);\n\n\t\tif (cmd->cmd_done == pmcraid_ioa_reset) {\n\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\t  host_lock_flags);\n\t\t\tcmd->cmd_done(cmd);\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       host_lock_flags);\n\t\t} else if (cmd->cmd_done != NULL) {\n\t\t\tcmd->cmd_done(cmd);\n\t\t}\n\t\t/* loop over until we are done with all responses */\n\t\tspin_lock_irqsave(lockp, hrrq_lock_flags);\n\t\tresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\n\t}\n\n\tspin_unlock_irqrestore(lockp, hrrq_lock_flags);\n}\n\n/**\n * pmcraid_unregister_interrupt_handler - de-register interrupts handlers\n * @pinstance: pointer to adapter instance structure\n *\n * This routine un-registers registered interrupt handler and\n * also frees irqs/vectors.\n *\n * Retun Value\n *\tNone\n */\nstatic\nvoid pmcraid_unregister_interrupt_handler(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tfor (i = 0; i < pinstance->num_hrrq; i++)\n\t\tfree_irq(pinstance->hrrq_vector[i].vector,\n\t\t\t &(pinstance->hrrq_vector[i]));\n\n\tif (pinstance->interrupt_mode) {\n\t\tpci_disable_msix(pinstance->pdev);\n\t\tpinstance->interrupt_mode = 0;\n\t}\n}\n\n/**\n * pmcraid_register_interrupt_handler - registers interrupt handler\n * @pinstance: pointer to per-adapter instance structure\n *\n * Return Value\n *\t0 on success, non-zero error code otherwise.\n */\nstatic int\npmcraid_register_interrupt_handler(struct pmcraid_instance *pinstance)\n{\n\tint rc;\n\tstruct pci_dev *pdev = pinstance->pdev;\n\n\tif ((pmcraid_enable_msix) &&\n\t\t(pci_find_capability(pdev, PCI_CAP_ID_MSIX))) {\n\t\tint num_hrrq = PMCRAID_NUM_MSIX_VECTORS;\n\t\tstruct msix_entry entries[PMCRAID_NUM_MSIX_VECTORS];\n\t\tint i;\n\t\tfor (i = 0; i < PMCRAID_NUM_MSIX_VECTORS; i++)\n\t\t\tentries[i].entry = i;\n\n\t\trc = pci_enable_msix(pdev, entries, num_hrrq);\n\t\tif (rc < 0)\n\t\t\tgoto pmcraid_isr_legacy;\n\n\t\t/* Check how many MSIX vectors are allocated and register\n\t\t * msi-x handlers for each of them giving appropriate buffer\n\t\t */\n\t\tif (rc > 0) {\n\t\t\tnum_hrrq = rc;\n\t\t\tif (pci_enable_msix(pdev, entries, num_hrrq))\n\t\t\t\tgoto pmcraid_isr_legacy;\n\t\t}\n\n\t\tfor (i = 0; i < num_hrrq; i++) {\n\t\t\tpinstance->hrrq_vector[i].hrrq_id = i;\n\t\t\tpinstance->hrrq_vector[i].drv_inst = pinstance;\n\t\t\tpinstance->hrrq_vector[i].vector = entries[i].vector;\n\t\t\trc = request_irq(pinstance->hrrq_vector[i].vector,\n\t\t\t\t\tpmcraid_isr_msix, 0,\n\t\t\t\t\tPMCRAID_DRIVER_NAME,\n\t\t\t\t\t&(pinstance->hrrq_vector[i]));\n\n\t\t\tif (rc) {\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tfree_irq(entries[j].vector,\n\t\t\t\t\t\t &(pinstance->hrrq_vector[j]));\n\t\t\t\tpci_disable_msix(pdev);\n\t\t\t\tgoto pmcraid_isr_legacy;\n\t\t\t}\n\t\t}\n\n\t\tpinstance->num_hrrq = num_hrrq;\n\t\tpinstance->interrupt_mode = 1;\n\t\tiowrite32(DOORBELL_INTR_MODE_MSIX,\n\t\t\t  pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tgoto pmcraid_isr_out;\n\t}\n\npmcraid_isr_legacy:\n\t/* If MSI-X registration failed fallback to legacy mode, where\n\t * only one hrrq entry will be used\n\t */\n\tpinstance->hrrq_vector[0].hrrq_id = 0;\n\tpinstance->hrrq_vector[0].drv_inst = pinstance;\n\tpinstance->hrrq_vector[0].vector = pdev->irq;\n\tpinstance->num_hrrq = 1;\n\trc = 0;\n\n\trc = request_irq(pdev->irq, pmcraid_isr, IRQF_SHARED,\n\t\t\t PMCRAID_DRIVER_NAME, &pinstance->hrrq_vector[0]);\npmcraid_isr_out:\n\treturn rc;\n}\n\n/**\n * pmcraid_release_cmd_blocks - release buufers allocated for command blocks\n * @pinstance: per adapter instance structure pointer\n * @max_index: number of buffer blocks to release\n *\n * Return Value\n *  None\n */\nstatic void\npmcraid_release_cmd_blocks(struct pmcraid_instance *pinstance, int max_index)\n{\n\tint i;\n\tfor (i = 0; i < max_index; i++) {\n\t\tkmem_cache_free(pinstance->cmd_cachep, pinstance->cmd_list[i]);\n\t\tpinstance->cmd_list[i] = NULL;\n\t}\n\tkmem_cache_destroy(pinstance->cmd_cachep);\n\tpinstance->cmd_cachep = NULL;\n}\n\n/**\n * pmcraid_release_control_blocks - releases buffers alloced for control blocks\n * @pinstance: pointer to per adapter instance structure\n * @max_index: number of buffers (from 0 onwards) to release\n *\n * This function assumes that the command blocks for which control blocks are\n * linked are not released.\n *\n * Return Value\n *\t None\n */\nstatic void\npmcraid_release_control_blocks(\n\tstruct pmcraid_instance *pinstance,\n\tint max_index\n)\n{\n\tint i;\n\n\tif (pinstance->control_pool == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < max_index; i++) {\n\t\tpci_pool_free(pinstance->control_pool,\n\t\t\t      pinstance->cmd_list[i]->ioa_cb,\n\t\t\t      pinstance->cmd_list[i]->ioa_cb_bus_addr);\n\t\tpinstance->cmd_list[i]->ioa_cb = NULL;\n\t\tpinstance->cmd_list[i]->ioa_cb_bus_addr = 0;\n\t}\n\tpci_pool_destroy(pinstance->control_pool);\n\tpinstance->control_pool = NULL;\n}\n\n/**\n * pmcraid_allocate_cmd_blocks - allocate memory for cmd block structures\n * @pinstance - pointer to per adapter instance structure\n *\n * Allocates memory for command blocks using kernel slab allocator.\n *\n * Return Value\n *\t0 in case of success; -ENOMEM in case of failure\n */\nstatic int __devinit\npmcraid_allocate_cmd_blocks(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tsprintf(pinstance->cmd_pool_name, \"pmcraid_cmd_pool_%d\",\n\t\tpinstance->host->unique_id);\n\n\n\tpinstance->cmd_cachep = kmem_cache_create(\n\t\t\t\t\tpinstance->cmd_pool_name,\n\t\t\t\t\tsizeof(struct pmcraid_cmd), 0,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!pinstance->cmd_cachep)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\n\t\tpinstance->cmd_list[i] =\n\t\t\tkmem_cache_alloc(pinstance->cmd_cachep, GFP_KERNEL);\n\t\tif (!pinstance->cmd_list[i]) {\n\t\t\tpmcraid_release_cmd_blocks(pinstance, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * pmcraid_allocate_control_blocks - allocates memory control blocks\n * @pinstance : pointer to per adapter instance structure\n *\n * This function allocates PCI memory for DMAable buffers like IOARCB, IOADLs\n * and IOASAs. This is called after command blocks are already allocated.\n *\n * Return Value\n *  0 in case it can allocate all control blocks, otherwise -ENOMEM\n */\nstatic int __devinit\npmcraid_allocate_control_blocks(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tsprintf(pinstance->ctl_pool_name, \"pmcraid_control_pool_%d\",\n\t\tpinstance->host->unique_id);\n\n\tpinstance->control_pool =\n\t\tpci_pool_create(pinstance->ctl_pool_name,\n\t\t\t\tpinstance->pdev,\n\t\t\t\tsizeof(struct pmcraid_control_block),\n\t\t\t\tPMCRAID_IOARCB_ALIGNMENT, 0);\n\n\tif (!pinstance->control_pool)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\n\t\tpinstance->cmd_list[i]->ioa_cb =\n\t\t\tpci_pool_alloc(\n\t\t\t\tpinstance->control_pool,\n\t\t\t\tGFP_KERNEL,\n\t\t\t\t&(pinstance->cmd_list[i]->ioa_cb_bus_addr));\n\n\t\tif (!pinstance->cmd_list[i]->ioa_cb) {\n\t\t\tpmcraid_release_control_blocks(pinstance, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(pinstance->cmd_list[i]->ioa_cb, 0,\n\t\t\tsizeof(struct pmcraid_control_block));\n\t}\n\treturn 0;\n}\n\n/**\n * pmcraid_release_host_rrqs - release memory allocated for hrrq buffer(s)\n * @pinstance: pointer to per adapter instance structure\n * @maxindex: size of hrrq buffer pointer array\n *\n * Return Value\n *\tNone\n */\nstatic void\npmcraid_release_host_rrqs(struct pmcraid_instance *pinstance, int maxindex)\n{\n\tint i;\n\tfor (i = 0; i < maxindex; i++) {\n\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    HRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD,\n\t\t\t\t    pinstance->hrrq_start[i],\n\t\t\t\t    pinstance->hrrq_start_bus_addr[i]);\n\n\t\t/* reset pointers and toggle bit to zeros */\n\t\tpinstance->hrrq_start[i] = NULL;\n\t\tpinstance->hrrq_start_bus_addr[i] = 0;\n\t\tpinstance->host_toggle_bit[i] = 0;\n\t}\n}\n\n/**\n * pmcraid_allocate_host_rrqs - Allocate and initialize host RRQ buffers\n * @pinstance: pointer to per adapter instance structure\n *\n * Return value\n *\t0 hrrq buffers are allocated, -ENOMEM otherwise.\n */\nstatic int __devinit\npmcraid_allocate_host_rrqs(struct pmcraid_instance *pinstance)\n{\n\tint i, buffer_size;\n\n\tbuffer_size = HRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD;\n\n\tfor (i = 0; i < pinstance->num_hrrq; i++) {\n\t\tpinstance->hrrq_start[i] =\n\t\t\tpci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tbuffer_size,\n\t\t\t\t\t&(pinstance->hrrq_start_bus_addr[i]));\n\n\t\tif (pinstance->hrrq_start[i] == 0) {\n\t\t\tpmcraid_err(\"pci_alloc failed for hrrq vector : %d\\n\",\n\t\t\t\t    i);\n\t\t\tpmcraid_release_host_rrqs(pinstance, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemset(pinstance->hrrq_start[i], 0, buffer_size);\n\t\tpinstance->hrrq_curr[i] = pinstance->hrrq_start[i];\n\t\tpinstance->hrrq_end[i] =\n\t\t\tpinstance->hrrq_start[i] + PMCRAID_MAX_CMD - 1;\n\t\tpinstance->host_toggle_bit[i] = 1;\n\t\tspin_lock_init(&pinstance->hrrq_lock[i]);\n\t}\n\treturn 0;\n}\n\n/**\n * pmcraid_release_hcams - release HCAM buffers\n *\n * @pinstance: pointer to per adapter instance structure\n *\n * Return value\n *  none\n */\nstatic void pmcraid_release_hcams(struct pmcraid_instance *pinstance)\n{\n\tif (pinstance->ccn.msg != NULL) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    PMCRAID_AEN_HDR_SIZE +\n\t\t\t\t    sizeof(struct pmcraid_hcam_ccn_ext),\n\t\t\t\t    pinstance->ccn.msg,\n\t\t\t\t    pinstance->ccn.baddr);\n\n\t\tpinstance->ccn.msg = NULL;\n\t\tpinstance->ccn.hcam = NULL;\n\t\tpinstance->ccn.baddr = 0;\n\t}\n\n\tif (pinstance->ldn.msg != NULL) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    PMCRAID_AEN_HDR_SIZE +\n\t\t\t\t    sizeof(struct pmcraid_hcam_ldn),\n\t\t\t\t    pinstance->ldn.msg,\n\t\t\t\t    pinstance->ldn.baddr);\n\n\t\tpinstance->ldn.msg = NULL;\n\t\tpinstance->ldn.hcam = NULL;\n\t\tpinstance->ldn.baddr = 0;\n\t}\n}\n\n/**\n * pmcraid_allocate_hcams - allocates HCAM buffers\n * @pinstance : pointer to per adapter instance structure\n *\n * Return Value:\n *   0 in case of successful allocation, non-zero otherwise\n */\nstatic int pmcraid_allocate_hcams(struct pmcraid_instance *pinstance)\n{\n\tpinstance->ccn.msg = pci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tPMCRAID_AEN_HDR_SIZE +\n\t\t\t\t\tsizeof(struct pmcraid_hcam_ccn_ext),\n\t\t\t\t\t&(pinstance->ccn.baddr));\n\n\tpinstance->ldn.msg = pci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tPMCRAID_AEN_HDR_SIZE +\n\t\t\t\t\tsizeof(struct pmcraid_hcam_ldn),\n\t\t\t\t\t&(pinstance->ldn.baddr));\n\n\tif (pinstance->ldn.msg == NULL || pinstance->ccn.msg == NULL) {\n\t\tpmcraid_release_hcams(pinstance);\n\t} else {\n\t\tpinstance->ccn.hcam =\n\t\t\t(void *)pinstance->ccn.msg + PMCRAID_AEN_HDR_SIZE;\n\t\tpinstance->ldn.hcam =\n\t\t\t(void *)pinstance->ldn.msg + PMCRAID_AEN_HDR_SIZE;\n\n\t\tatomic_set(&pinstance->ccn.ignore, 0);\n\t\tatomic_set(&pinstance->ldn.ignore, 0);\n\t}\n\n\treturn (pinstance->ldn.msg == NULL) ? -ENOMEM : 0;\n}\n\n/**\n * pmcraid_release_config_buffers - release config.table buffers\n * @pinstance: pointer to per adapter instance structure\n *\n * Return Value\n *\t none\n */\nstatic void pmcraid_release_config_buffers(struct pmcraid_instance *pinstance)\n{\n\tif (pinstance->cfg_table != NULL &&\n\t    pinstance->cfg_table_bus_addr != 0) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    sizeof(struct pmcraid_config_table),\n\t\t\t\t    pinstance->cfg_table,\n\t\t\t\t    pinstance->cfg_table_bus_addr);\n\t\tpinstance->cfg_table = NULL;\n\t\tpinstance->cfg_table_bus_addr = 0;\n\t}\n\n\tif (pinstance->res_entries != NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PMCRAID_MAX_RESOURCES; i++)\n\t\t\tlist_del(&pinstance->res_entries[i].queue);\n\t\tkfree(pinstance->res_entries);\n\t\tpinstance->res_entries = NULL;\n\t}\n\n\tpmcraid_release_hcams(pinstance);\n}\n\n/**\n * pmcraid_allocate_config_buffers - allocates DMAable memory for config table\n * @pinstance : pointer to per adapter instance structure\n *\n * Return Value\n *\t0 for successful allocation, -ENOMEM for any failure\n */\nstatic int __devinit\npmcraid_allocate_config_buffers(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tpinstance->res_entries =\n\t\t\tkzalloc(sizeof(struct pmcraid_resource_entry) *\n\t\t\t\tPMCRAID_MAX_RESOURCES, GFP_KERNEL);\n\n\tif (NULL == pinstance->res_entries) {\n\t\tpmcraid_err(\"failed to allocate memory for resource table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < PMCRAID_MAX_RESOURCES; i++)\n\t\tlist_add_tail(&pinstance->res_entries[i].queue,\n\t\t\t      &pinstance->free_res_q);\n\n\tpinstance->cfg_table =\n\t\tpci_alloc_consistent(pinstance->pdev,\n\t\t\t\t     sizeof(struct pmcraid_config_table),\n\t\t\t\t     &pinstance->cfg_table_bus_addr);\n\n\tif (NULL == pinstance->cfg_table) {\n\t\tpmcraid_err(\"couldn't alloc DMA memory for config table\\n\");\n\t\tpmcraid_release_config_buffers(pinstance);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pmcraid_allocate_hcams(pinstance)) {\n\t\tpmcraid_err(\"could not alloc DMA memory for HCAMS\\n\");\n\t\tpmcraid_release_config_buffers(pinstance);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/**\n * pmcraid_init_tasklets - registers tasklets for response handling\n *\n * @pinstance: pointer adapter instance structure\n *\n * Return value\n *\tnone\n */\nstatic void pmcraid_init_tasklets(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\tfor (i = 0; i < pinstance->num_hrrq; i++)\n\t\ttasklet_init(&pinstance->isr_tasklet[i],\n\t\t\t     pmcraid_tasklet_function,\n\t\t\t     (unsigned long)&pinstance->hrrq_vector[i]);\n}\n\n/**\n * pmcraid_kill_tasklets - destroys tasklets registered for response handling\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return value\n *\tnone\n */\nstatic void pmcraid_kill_tasklets(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\tfor (i = 0; i < pinstance->num_hrrq; i++)\n\t\ttasklet_kill(&pinstance->isr_tasklet[i]);\n}\n\n/**\n * pmcraid_release_buffers - release per-adapter buffers allocated\n *\n * @pinstance: pointer to adapter soft state\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_release_buffers(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_release_config_buffers(pinstance);\n\tpmcraid_release_control_blocks(pinstance, PMCRAID_MAX_CMD);\n\tpmcraid_release_cmd_blocks(pinstance, PMCRAID_MAX_CMD);\n\tpmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\n\n\tif (pinstance->inq_data != NULL) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    sizeof(struct pmcraid_inquiry_data),\n\t\t\t\t    pinstance->inq_data,\n\t\t\t\t    pinstance->inq_data_baddr);\n\n\t\tpinstance->inq_data = NULL;\n\t\tpinstance->inq_data_baddr = 0;\n\t}\n\n\tif (pinstance->timestamp_data != NULL) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    sizeof(struct pmcraid_timestamp_data),\n\t\t\t\t    pinstance->timestamp_data,\n\t\t\t\t    pinstance->timestamp_data_baddr);\n\n\t\tpinstance->timestamp_data = NULL;\n\t\tpinstance->timestamp_data_baddr = 0;\n\t}\n}\n\n/**\n * pmcraid_init_buffers - allocates memory and initializes various structures\n * @pinstance: pointer to per adapter instance structure\n *\n * This routine pre-allocates memory based on the type of block as below:\n * cmdblocks(PMCRAID_MAX_CMD): kernel memory using kernel's slab_allocator,\n * IOARCBs(PMCRAID_MAX_CMD)  : DMAable memory, using pci pool allocator\n * config-table entries      : DMAable memory using pci_alloc_consistent\n * HostRRQs                  : DMAable memory, using pci_alloc_consistent\n *\n * Return Value\n *\t 0 in case all of the blocks are allocated, -ENOMEM otherwise.\n */\nstatic int __devinit pmcraid_init_buffers(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tif (pmcraid_allocate_host_rrqs(pinstance)) {\n\t\tpmcraid_err(\"couldn't allocate memory for %d host rrqs\\n\",\n\t\t\t     pinstance->num_hrrq);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pmcraid_allocate_config_buffers(pinstance)) {\n\t\tpmcraid_err(\"couldn't allocate memory for config buffers\\n\");\n\t\tpmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pmcraid_allocate_cmd_blocks(pinstance)) {\n\t\tpmcraid_err(\"couldn't allocate memory for cmd blocks\\n\");\n\t\tpmcraid_release_config_buffers(pinstance);\n\t\tpmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pmcraid_allocate_control_blocks(pinstance)) {\n\t\tpmcraid_err(\"couldn't allocate memory control blocks\\n\");\n\t\tpmcraid_release_config_buffers(pinstance);\n\t\tpmcraid_release_cmd_blocks(pinstance, PMCRAID_MAX_CMD);\n\t\tpmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* allocate DMAable memory for page D0 INQUIRY buffer */\n\tpinstance->inq_data = pci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tsizeof(struct pmcraid_inquiry_data),\n\t\t\t\t\t&pinstance->inq_data_baddr);\n\n\tif (pinstance->inq_data == NULL) {\n\t\tpmcraid_err(\"couldn't allocate DMA memory for INQUIRY\\n\");\n\t\tpmcraid_release_buffers(pinstance);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* allocate DMAable memory for set timestamp data buffer */\n\tpinstance->timestamp_data = pci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tsizeof(struct pmcraid_timestamp_data),\n\t\t\t\t\t&pinstance->timestamp_data_baddr);\n\n\tif (pinstance->timestamp_data == NULL) {\n\t\tpmcraid_err(\"couldn't allocate DMA memory for \\\n\t\t\t\tset time_stamp \\n\");\n\t\tpmcraid_release_buffers(pinstance);\n\t\treturn -ENOMEM;\n\t}\n\n\n\t/* Initialize all the command blocks and add them to free pool. No\n\t * need to lock (free_pool_lock) as this is done in initialization\n\t * itself\n\t */\n\tfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\n\t\tstruct pmcraid_cmd *cmdp = pinstance->cmd_list[i];\n\t\tpmcraid_init_cmdblk(cmdp, i);\n\t\tcmdp->drv_inst = pinstance;\n\t\tlist_add_tail(&cmdp->free_list, &pinstance->free_cmd_pool);\n\t}\n\n\treturn 0;\n}\n\n/**\n * pmcraid_reinit_buffers - resets various buffer pointers\n * @pinstance: pointer to adapter instance\n * Return value\n *\tnone\n */\nstatic void pmcraid_reinit_buffers(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\tint buffer_size = HRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD;\n\n\tfor (i = 0; i < pinstance->num_hrrq; i++) {\n\t\tmemset(pinstance->hrrq_start[i], 0, buffer_size);\n\t\tpinstance->hrrq_curr[i] = pinstance->hrrq_start[i];\n\t\tpinstance->hrrq_end[i] =\n\t\t\tpinstance->hrrq_start[i] + PMCRAID_MAX_CMD - 1;\n\t\tpinstance->host_toggle_bit[i] = 1;\n\t}\n}\n\n/**\n * pmcraid_init_instance - initialize per instance data structure\n * @pdev: pointer to pci device structure\n * @host: pointer to Scsi_Host structure\n * @mapped_pci_addr: memory mapped IOA configuration registers\n *\n * Return Value\n *\t 0 on success, non-zero in case of any failure\n */\nstatic int __devinit pmcraid_init_instance(\n\tstruct pci_dev *pdev,\n\tstruct Scsi_Host *host,\n\tvoid __iomem *mapped_pci_addr\n)\n{\n\tstruct pmcraid_instance *pinstance =\n\t\t(struct pmcraid_instance *)host->hostdata;\n\n\tpinstance->host = host;\n\tpinstance->pdev = pdev;\n\n\t/* Initialize register addresses */\n\tpinstance->mapped_dma_addr = mapped_pci_addr;\n\n\t/* Initialize chip-specific details */\n\t{\n\t\tstruct pmcraid_chip_details *chip_cfg = pinstance->chip_cfg;\n\t\tstruct pmcraid_interrupts *pint_regs = &pinstance->int_regs;\n\n\t\tpinstance->ioarrin = mapped_pci_addr + chip_cfg->ioarrin;\n\n\t\tpint_regs->ioa_host_interrupt_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_intr;\n\t\tpint_regs->ioa_host_interrupt_clr_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_intr_clr;\n\t\tpint_regs->ioa_host_msix_interrupt_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_msix_intr;\n\t\tpint_regs->host_ioa_interrupt_reg =\n\t\t\tmapped_pci_addr + chip_cfg->host_ioa_intr;\n\t\tpint_regs->host_ioa_interrupt_clr_reg =\n\t\t\tmapped_pci_addr + chip_cfg->host_ioa_intr_clr;\n\n\t\t/* Current version of firmware exposes interrupt mask set\n\t\t * and mask clr registers through memory mapped bar0.\n\t\t */\n\t\tpinstance->mailbox = mapped_pci_addr + chip_cfg->mailbox;\n\t\tpinstance->ioa_status = mapped_pci_addr + chip_cfg->ioastatus;\n\t\tpint_regs->ioa_host_interrupt_mask_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_mask;\n\t\tpint_regs->ioa_host_interrupt_mask_clr_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_mask_clr;\n\t\tpint_regs->global_interrupt_mask_reg =\n\t\t\tmapped_pci_addr + chip_cfg->global_intr_mask;\n\t};\n\n\tpinstance->ioa_reset_attempts = 0;\n\tinit_waitqueue_head(&pinstance->reset_wait_q);\n\n\tatomic_set(&pinstance->outstanding_cmds, 0);\n\tatomic_set(&pinstance->last_message_id, 0);\n\tatomic_set(&pinstance->expose_resources, 0);\n\n\tINIT_LIST_HEAD(&pinstance->free_res_q);\n\tINIT_LIST_HEAD(&pinstance->used_res_q);\n\tINIT_LIST_HEAD(&pinstance->free_cmd_pool);\n\tINIT_LIST_HEAD(&pinstance->pending_cmd_pool);\n\n\tspin_lock_init(&pinstance->free_pool_lock);\n\tspin_lock_init(&pinstance->pending_pool_lock);\n\tspin_lock_init(&pinstance->resource_lock);\n\tmutex_init(&pinstance->aen_queue_lock);\n\n\t/* Work-queue (Shared) for deferred processing error handling */\n\tINIT_WORK(&pinstance->worker_q, pmcraid_worker_function);\n\n\t/* Initialize the default log_level */\n\tpinstance->current_log_level = pmcraid_log_level;\n\n\t/* Setup variables required for reset engine */\n\tpinstance->ioa_state = IOA_STATE_UNKNOWN;\n\tpinstance->reset_cmd = NULL;\n\treturn 0;\n}\n\n/**\n * pmcraid_shutdown - shutdown adapter controller.\n * @pdev: pci device struct\n *\n * Issues an adapter shutdown to the card waits for its completion\n *\n * Return value\n *\t  none\n */\nstatic void pmcraid_shutdown(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\tpmcraid_reset_bringdown(pinstance);\n}\n\n\n/**\n * pmcraid_get_minor - returns unused minor number from minor number bitmap\n */\nstatic unsigned short pmcraid_get_minor(void)\n{\n\tint minor;\n\n\tminor = find_first_zero_bit(pmcraid_minor, sizeof(pmcraid_minor));\n\t__set_bit(minor, pmcraid_minor);\n\treturn minor;\n}\n\n/**\n * pmcraid_release_minor - releases given minor back to minor number bitmap\n */\nstatic void pmcraid_release_minor(unsigned short minor)\n{\n\t__clear_bit(minor, pmcraid_minor);\n}\n\n/**\n * pmcraid_setup_chrdev - allocates a minor number and registers a char device\n *\n * @pinstance: pointer to adapter instance for which to register device\n *\n * Return value\n *\t0 in case of success, otherwise non-zero\n */\nstatic int pmcraid_setup_chrdev(struct pmcraid_instance *pinstance)\n{\n\tint minor;\n\tint error;\n\n\tminor = pmcraid_get_minor();\n\tcdev_init(&pinstance->cdev, &pmcraid_fops);\n\tpinstance->cdev.owner = THIS_MODULE;\n\n\terror = cdev_add(&pinstance->cdev, MKDEV(pmcraid_major, minor), 1);\n\n\tif (error)\n\t\tpmcraid_release_minor(minor);\n\telse\n\t\tdevice_create(pmcraid_class, NULL, MKDEV(pmcraid_major, minor),\n\t\t\t      NULL, \"%s%u\", PMCRAID_DEVFILE, minor);\n\treturn error;\n}\n\n/**\n * pmcraid_release_chrdev - unregisters per-adapter management interface\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return value\n *  none\n */\nstatic void pmcraid_release_chrdev(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_release_minor(MINOR(pinstance->cdev.dev));\n\tdevice_destroy(pmcraid_class,\n\t\t       MKDEV(pmcraid_major, MINOR(pinstance->cdev.dev)));\n\tcdev_del(&pinstance->cdev);\n}\n\n/**\n * pmcraid_remove - IOA hot plug remove entry point\n * @pdev: pci device struct\n *\n * Return value\n *\t  none\n */\nstatic void __devexit pmcraid_remove(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\n\t/* remove the management interface (/dev file) for this device */\n\tpmcraid_release_chrdev(pinstance);\n\n\t/* remove host template from scsi midlayer */\n\tscsi_remove_host(pinstance->host);\n\n\t/* block requests from mid-layer */\n\tscsi_block_requests(pinstance->host);\n\n\t/* initiate shutdown adapter */\n\tpmcraid_shutdown(pdev);\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tflush_work_sync(&pinstance->worker_q);\n\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\tpmcraid_release_buffers(pinstance);\n\tiounmap(pinstance->mapped_dma_addr);\n\tpci_release_regions(pdev);\n\tscsi_host_put(pinstance->host);\n\tpci_disable_device(pdev);\n\n\treturn;\n}\n\n#ifdef CONFIG_PM\n/**\n * pmcraid_suspend - driver suspend entry point for power management\n * @pdev:   PCI device structure\n * @state:  PCI power state to suspend routine\n *\n * Return Value - 0 always\n */\nstatic int pmcraid_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\n\tpmcraid_shutdown(pdev);\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tpmcraid_kill_tasklets(pinstance);\n\tpci_set_drvdata(pinstance->pdev, pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\n/**\n * pmcraid_resume - driver resume entry point PCI power management\n * @pdev: PCI device structure\n *\n * Return Value - 0 in case of success. Error code in case of any failure\n */\nstatic int pmcraid_resume(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\tstruct Scsi_Host *host = pinstance->host;\n\tint rc;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\n\trc = pci_enable_device(pdev);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"resume: Enable device failed\\n\");\n\t\treturn rc;\n\t}\n\n\tpci_set_master(pdev);\n\n\tif ((sizeof(dma_addr_t) == 4) ||\n\t     pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\n\t\trc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\tif (rc == 0)\n\t\trc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\tif (rc != 0) {\n\t\tdev_err(&pdev->dev, \"resume: Failed to set PCI DMA mask\\n\");\n\t\tgoto disable_device;\n\t}\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tatomic_set(&pinstance->outstanding_cmds, 0);\n\trc = pmcraid_register_interrupt_handler(pinstance);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"resume: couldn't register interrupt handlers\\n\");\n\t\trc = -ENODEV;\n\t\tgoto release_host;\n\t}\n\n\tpmcraid_init_tasklets(pinstance);\n\tpmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\n\n\t/* Start with hard reset sequence which brings up IOA to operational\n\t * state as well as completes the reset sequence.\n\t */\n\tpinstance->ioa_hard_reset = 1;\n\n\t/* Start IOA firmware initialization and bring card to Operational\n\t * state.\n\t */\n\tif (pmcraid_reset_bringup(pinstance)) {\n\t\tdev_err(&pdev->dev, \"couldn't initialize IOA\\n\");\n\t\trc = -ENODEV;\n\t\tgoto release_tasklets;\n\t}\n\n\treturn 0;\n\nrelease_tasklets:\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\nrelease_host:\n\tscsi_host_put(host);\n\ndisable_device:\n\tpci_disable_device(pdev);\n\n\treturn rc;\n}\n\n#else\n\n#define pmcraid_suspend NULL\n#define pmcraid_resume  NULL\n\n#endif /* CONFIG_PM */\n\n/**\n * pmcraid_complete_ioa_reset - Called by either timer or tasklet during\n *\t\t\t\tcompletion of the ioa reset\n * @cmd: pointer to reset command block\n */\nstatic void pmcraid_complete_ioa_reset(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(pinstance->host->host_lock, flags);\n\tpmcraid_ioa_reset(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, flags);\n\tscsi_unblock_requests(pinstance->host);\n\tschedule_work(&pinstance->worker_q);\n}\n\n/**\n * pmcraid_set_supported_devs - sends SET SUPPORTED DEVICES to IOAFP\n *\n * @cmd: pointer to pmcraid_cmd structure\n *\n * Return Value\n *  0 for success or non-zero for failure cases\n */\nstatic void pmcraid_set_supported_devs(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tvoid (*cmd_done) (struct pmcraid_cmd *) = pmcraid_complete_ioa_reset;\n\n\tpmcraid_reinit_cmdblk(cmd);\n\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->cdb[0] = PMCRAID_SET_SUPPORTED_DEVICES;\n\tioarcb->cdb[1] = ALL_DEVICES_SUPPORTED;\n\n\t/* If this was called as part of resource table reinitialization due to\n\t * lost CCN, it is enough to return the command block back to free pool\n\t * as part of set_supported_devs completion function.\n\t */\n\tif (cmd->drv_inst->reinit_cfg_table) {\n\t\tcmd->drv_inst->reinit_cfg_table = 0;\n\t\tcmd->release = 1;\n\t\tcmd_done = pmcraid_reinit_cfgtable_done;\n\t}\n\n\t/* we will be done with the reset sequence after set supported devices,\n\t * setup the done function to return the command block back to free\n\t * pool\n\t */\n\tpmcraid_send_cmd(cmd,\n\t\t\t cmd_done,\n\t\t\t PMCRAID_SET_SUP_DEV_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n\treturn;\n}\n\n/**\n * pmcraid_set_timestamp - set the timestamp to IOAFP\n *\n * @cmd: pointer to pmcraid_cmd structure\n *\n * Return Value\n *  0 for success or non-zero for failure cases\n */\nstatic void pmcraid_set_timestamp(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\t__be32 time_stamp_len = cpu_to_be32(PMCRAID_TIMESTAMP_LEN);\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\n\tstruct timeval tv;\n\t__le64 timestamp;\n\n\tdo_gettimeofday(&tv);\n\ttimestamp = tv.tv_sec * 1000;\n\n\tpinstance->timestamp_data->timestamp[0] = (__u8)(timestamp);\n\tpinstance->timestamp_data->timestamp[1] = (__u8)((timestamp) >> 8);\n\tpinstance->timestamp_data->timestamp[2] = (__u8)((timestamp) >> 16);\n\tpinstance->timestamp_data->timestamp[3] = (__u8)((timestamp) >> 24);\n\tpinstance->timestamp_data->timestamp[4] = (__u8)((timestamp) >> 32);\n\tpinstance->timestamp_data->timestamp[5] = (__u8)((timestamp)  >> 40);\n\n\tpmcraid_reinit_cmdblk(cmd);\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->cdb[0] = PMCRAID_SCSI_SET_TIMESTAMP;\n\tioarcb->cdb[1] = PMCRAID_SCSI_SERVICE_ACTION;\n\tmemcpy(&(ioarcb->cdb[6]), &time_stamp_len, sizeof(time_stamp_len));\n\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->request_flags0 |= TRANSFER_DIR_WRITE;\n\tioarcb->data_transfer_length =\n\t\tcpu_to_le32(sizeof(struct pmcraid_timestamp_data));\n\tioadl = &(ioarcb->add_data.u.ioadl[0]);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\tioadl->address = cpu_to_le64(pinstance->timestamp_data_baddr);\n\tioadl->data_len = cpu_to_le32(sizeof(struct pmcraid_timestamp_data));\n\n\tif (!pinstance->timestamp_error) {\n\t\tpinstance->timestamp_error = 0;\n\t\tpmcraid_send_cmd(cmd, pmcraid_set_supported_devs,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n\t} else {\n\t\tpmcraid_send_cmd(cmd, pmcraid_return_cmd,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n\t\treturn;\n\t}\n}\n\n\n/**\n * pmcraid_init_res_table - Initialize the resource table\n * @cmd:  pointer to pmcraid command struct\n *\n * This function looks through the existing resource table, comparing\n * it with the config table. This function will take care of old/new\n * devices and schedule adding/removing them from the mid-layer\n * as appropriate.\n *\n * Return value\n *\t None\n */\nstatic void pmcraid_init_res_table(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_resource_entry *res, *temp;\n\tstruct pmcraid_config_table_entry *cfgte;\n\tunsigned long lock_flags;\n\tint found, rc, i;\n\tu16 fw_version;\n\tLIST_HEAD(old_res);\n\n\tif (pinstance->cfg_table->flags & MICROCODE_UPDATE_REQUIRED)\n\t\tpmcraid_err(\"IOA requires microcode download\\n\");\n\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\n\t/* resource list is protected by pinstance->resource_lock.\n\t * init_res_table can be called from probe (user-thread) or runtime\n\t * reset (timer/tasklet)\n\t */\n\tspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\n\n\tlist_for_each_entry_safe(res, temp, &pinstance->used_res_q, queue)\n\t\tlist_move_tail(&res->queue, &old_res);\n\n\tfor (i = 0; i < pinstance->cfg_table->num_entries; i++) {\n\t\tif (be16_to_cpu(pinstance->inq_data->fw_version) <=\n\t\t\t\t\t\tPMCRAID_FW_VERSION_1)\n\t\t\tcfgte = &pinstance->cfg_table->entries[i];\n\t\telse\n\t\t\tcfgte = (struct pmcraid_config_table_entry *)\n\t\t\t\t\t&pinstance->cfg_table->entries_ext[i];\n\n\t\tif (!pmcraid_expose_resource(fw_version, cfgte))\n\t\t\tcontinue;\n\n\t\tfound = 0;\n\n\t\t/* If this entry was already detected and initialized */\n\t\tlist_for_each_entry_safe(res, temp, &old_res, queue) {\n\n\t\t\trc = memcmp(&res->cfg_entry.resource_address,\n\t\t\t\t    &cfgte->resource_address,\n\t\t\t\t    sizeof(cfgte->resource_address));\n\t\t\tif (!rc) {\n\t\t\t\tlist_move_tail(&res->queue,\n\t\t\t\t\t\t&pinstance->used_res_q);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* If this is new entry, initialize it and add it the queue */\n\t\tif (!found) {\n\n\t\t\tif (list_empty(&pinstance->free_res_q)) {\n\t\t\t\tpmcraid_err(\"Too many devices attached\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfound = 1;\n\t\t\tres = list_entry(pinstance->free_res_q.next,\n\t\t\t\t\t struct pmcraid_resource_entry, queue);\n\n\t\t\tres->scsi_dev = NULL;\n\t\t\tres->change_detected = RES_CHANGE_ADD;\n\t\t\tres->reset_progress = 0;\n\t\t\tlist_move_tail(&res->queue, &pinstance->used_res_q);\n\t\t}\n\n\t\t/* copy new configuration table entry details into driver\n\t\t * maintained resource entry\n\t\t */\n\t\tif (found) {\n\t\t\tmemcpy(&res->cfg_entry, cfgte,\n\t\t\t\t\tpinstance->config_table_entry_size);\n\t\t\tpmcraid_info(\"New res type:%x, vset:%x, addr:%x:\\n\",\n\t\t\t\t res->cfg_entry.resource_type,\n\t\t\t\t (fw_version <= PMCRAID_FW_VERSION_1 ?\n\t\t\t\t\tres->cfg_entry.unique_flags1 :\n\t\t\t\t\t\tres->cfg_entry.array_id & 0xFF),\n\t\t\t\t le32_to_cpu(res->cfg_entry.resource_address));\n\t\t}\n\t}\n\n\t/* Detect any deleted entries, mark them for deletion from mid-layer */\n\tlist_for_each_entry_safe(res, temp, &old_res, queue) {\n\n\t\tif (res->scsi_dev) {\n\t\t\tres->change_detected = RES_CHANGE_DEL;\n\t\t\tres->cfg_entry.resource_handle =\n\t\t\t\tPMCRAID_INVALID_RES_HANDLE;\n\t\t\tlist_move_tail(&res->queue, &pinstance->used_res_q);\n\t\t} else {\n\t\t\tlist_move_tail(&res->queue, &pinstance->free_res_q);\n\t\t}\n\t}\n\n\t/* release the resource list lock */\n\tspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\n\tpmcraid_set_timestamp(cmd);\n}\n\n/**\n * pmcraid_querycfg - Send a Query IOA Config to the adapter.\n * @cmd: pointer pmcraid_cmd struct\n *\n * This function sends a Query IOA Configuration command to the adapter to\n * retrieve the IOA configuration table.\n *\n * Return value:\n *\tnone\n */\nstatic void pmcraid_querycfg(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tint cfg_table_size = cpu_to_be32(sizeof(struct pmcraid_config_table));\n\n\tif (be16_to_cpu(pinstance->inq_data->fw_version) <=\n\t\t\t\t\tPMCRAID_FW_VERSION_1)\n\t\tpinstance->config_table_entry_size =\n\t\t\tsizeof(struct pmcraid_config_table_entry);\n\telse\n\t\tpinstance->config_table_entry_size =\n\t\t\tsizeof(struct pmcraid_config_table_entry_ext);\n\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\n\tioarcb->cdb[0] = PMCRAID_QUERY_IOA_CONFIG;\n\n\t/* firmware requires 4-byte length field, specified in B.E format */\n\tmemcpy(&(ioarcb->cdb[10]), &cfg_table_size, sizeof(cfg_table_size));\n\n\t/* Since entire config table can be described by single IOADL, it can\n\t * be part of IOARCB itself\n\t */\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length =\n\t\tcpu_to_le32(sizeof(struct pmcraid_config_table));\n\n\tioadl = &(ioarcb->add_data.u.ioadl[0]);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\tioadl->address = cpu_to_le64(pinstance->cfg_table_bus_addr);\n\tioadl->data_len = cpu_to_le32(sizeof(struct pmcraid_config_table));\n\n\tpmcraid_send_cmd(cmd, pmcraid_init_res_table,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n}\n\n\n/**\n * pmcraid_probe - PCI probe entry pointer for PMC MaxRAID controller driver\n * @pdev: pointer to pci device structure\n * @dev_id: pointer to device ids structure\n *\n * Return Value\n *\treturns 0 if the device is claimed and successfully configured.\n *\treturns non-zero error code in case of any failure\n */\nstatic int __devinit pmcraid_probe(\n\tstruct pci_dev *pdev,\n\tconst struct pci_device_id *dev_id\n)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct Scsi_Host *host;\n\tvoid __iomem *mapped_pci_addr;\n\tint rc = PCIBIOS_SUCCESSFUL;\n\n\tif (atomic_read(&pmcraid_adapter_count) >= PMCRAID_MAX_ADAPTERS) {\n\t\tpmcraid_err\n\t\t\t(\"maximum number(%d) of supported adapters reached\\n\",\n\t\t\t atomic_read(&pmcraid_adapter_count));\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_inc(&pmcraid_adapter_count);\n\trc = pci_enable_device(pdev);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot enable adapter\\n\");\n\t\tatomic_dec(&pmcraid_adapter_count);\n\t\treturn rc;\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t\"Found new IOA(%x:%x), Total IOA count: %d\\n\",\n\t\t pdev->vendor, pdev->device,\n\t\t atomic_read(&pmcraid_adapter_count));\n\n\trc = pci_request_regions(pdev, PMCRAID_DRIVER_NAME);\n\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Couldn't register memory range of registers\\n\");\n\t\tgoto out_disable_device;\n\t}\n\n\tmapped_pci_addr = pci_iomap(pdev, 0, 0);\n\n\tif (!mapped_pci_addr) {\n\t\tdev_err(&pdev->dev, \"Couldn't map PCI registers memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\n\tpci_set_master(pdev);\n\n\t/* Firmware requires the system bus address of IOARCB to be within\n\t * 32-bit addressable range though it has 64-bit IOARRIN register.\n\t * However, firmware supports 64-bit streaming DMA buffers, whereas\n\t * coherent buffers are to be 32-bit. Since pci_alloc_consistent always\n\t * returns memory within 4GB (if not, change this logic), coherent\n\t * buffers are within firmware acceptable address ranges.\n\t */\n\tif ((sizeof(dma_addr_t) == 4) ||\n\t    pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\n\t\trc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\t/* firmware expects 32-bit DMA addresses for IOARRIN register; set 32\n\t * bit mask for pci_alloc_consistent to return addresses within 4GB\n\t */\n\tif (rc == 0)\n\t\trc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\tif (rc != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to set PCI DMA mask\\n\");\n\t\tgoto cleanup_nomem;\n\t}\n\n\thost = scsi_host_alloc(&pmcraid_host_template,\n\t\t\t\tsizeof(struct pmcraid_instance));\n\n\tif (!host) {\n\t\tdev_err(&pdev->dev, \"scsi_host_alloc failed!\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto cleanup_nomem;\n\t}\n\n\thost->max_id = PMCRAID_MAX_NUM_TARGETS_PER_BUS;\n\thost->max_lun = PMCRAID_MAX_NUM_LUNS_PER_TARGET;\n\thost->unique_id = host->host_no;\n\thost->max_channel = PMCRAID_MAX_BUS_TO_SCAN;\n\thost->max_cmd_len = PMCRAID_MAX_CDB_LEN;\n\n\t/* zero out entire instance structure */\n\tpinstance = (struct pmcraid_instance *)host->hostdata;\n\tmemset(pinstance, 0, sizeof(*pinstance));\n\n\tpinstance->chip_cfg =\n\t\t(struct pmcraid_chip_details *)(dev_id->driver_data);\n\n\trc = pmcraid_init_instance(pdev, host, mapped_pci_addr);\n\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"failed to initialize adapter instance\\n\");\n\t\tgoto out_scsi_host_put;\n\t}\n\n\tpci_set_drvdata(pdev, pinstance);\n\n\t/* Save PCI config-space for use following the reset */\n\trc = pci_save_state(pinstance->pdev);\n\n\tif (rc != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to save PCI config space\\n\");\n\t\tgoto out_scsi_host_put;\n\t}\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\n\trc = pmcraid_register_interrupt_handler(pinstance);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"couldn't register interrupt handler\\n\");\n\t\tgoto out_scsi_host_put;\n\t}\n\n\tpmcraid_init_tasklets(pinstance);\n\n\t/* allocate verious buffers used by LLD.*/\n\trc = pmcraid_init_buffers(pinstance);\n\n\tif (rc) {\n\t\tpmcraid_err(\"couldn't allocate memory blocks\\n\");\n\t\tgoto out_unregister_isr;\n\t}\n\n\t/* check the reset type required */\n\tpmcraid_reset_type(pinstance);\n\n\tpmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\n\n\t/* Start IOA firmware initialization and bring card to Operational\n\t * state.\n\t */\n\tpmcraid_info(\"starting IOA initialization sequence\\n\");\n\tif (pmcraid_reset_bringup(pinstance)) {\n\t\tdev_err(&pdev->dev, \"couldn't initialize IOA\\n\");\n\t\trc = 1;\n\t\tgoto out_release_bufs;\n\t}\n\n\t/* Add adapter instance into mid-layer list */\n\trc = scsi_add_host(pinstance->host, &pdev->dev);\n\tif (rc != 0) {\n\t\tpmcraid_err(\"couldn't add host into mid-layer: %d\\n\", rc);\n\t\tgoto out_release_bufs;\n\t}\n\n\tscsi_scan_host(pinstance->host);\n\n\trc = pmcraid_setup_chrdev(pinstance);\n\n\tif (rc != 0) {\n\t\tpmcraid_err(\"couldn't create mgmt interface, error: %x\\n\",\n\t\t\t     rc);\n\t\tgoto out_remove_host;\n\t}\n\n\t/* Schedule worker thread to handle CCN and take care of adding and\n\t * removing devices to OS\n\t */\n\tatomic_set(&pinstance->expose_resources, 1);\n\tschedule_work(&pinstance->worker_q);\n\treturn rc;\n\nout_remove_host:\n\tscsi_remove_host(host);\n\nout_release_bufs:\n\tpmcraid_release_buffers(pinstance);\n\nout_unregister_isr:\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\nout_scsi_host_put:\n\tscsi_host_put(host);\n\ncleanup_nomem:\n\tiounmap(mapped_pci_addr);\n\nout_release_regions:\n\tpci_release_regions(pdev);\n\nout_disable_device:\n\tatomic_dec(&pmcraid_adapter_count);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\n/*\n * PCI driver structure of pcmraid driver\n */\nstatic struct pci_driver pmcraid_driver = {\n\t.name = PMCRAID_DRIVER_NAME,\n\t.id_table = pmcraid_pci_table,\n\t.probe = pmcraid_probe,\n\t.remove = pmcraid_remove,\n\t.suspend = pmcraid_suspend,\n\t.resume = pmcraid_resume,\n\t.shutdown = pmcraid_shutdown\n};\n\n/**\n * pmcraid_init - module load entry point\n */\nstatic int __init pmcraid_init(void)\n{\n\tdev_t dev;\n\tint error;\n\n\tpmcraid_info(\"%s Device Driver version: %s\\n\",\n\t\t\t PMCRAID_DRIVER_NAME, PMCRAID_DRIVER_VERSION);\n\n\terror = alloc_chrdev_region(&dev, 0,\n\t\t\t\t    PMCRAID_MAX_ADAPTERS,\n\t\t\t\t    PMCRAID_DEVFILE);\n\n\tif (error) {\n\t\tpmcraid_err(\"failed to get a major number for adapters\\n\");\n\t\tgoto out_init;\n\t}\n\n\tpmcraid_major = MAJOR(dev);\n\tpmcraid_class = class_create(THIS_MODULE, PMCRAID_DEVFILE);\n\n\tif (IS_ERR(pmcraid_class)) {\n\t\terror = PTR_ERR(pmcraid_class);\n\t\tpmcraid_err(\"failed to register with with sysfs, error = %x\\n\",\n\t\t\t    error);\n\t\tgoto out_unreg_chrdev;\n\t}\n\n\terror = pmcraid_netlink_init();\n\n\tif (error)\n\t\tgoto out_unreg_chrdev;\n\n\terror = pci_register_driver(&pmcraid_driver);\n\n\tif (error == 0)\n\t\tgoto out_init;\n\n\tpmcraid_err(\"failed to register pmcraid driver, error = %x\\n\",\n\t\t     error);\n\tclass_destroy(pmcraid_class);\n\tpmcraid_netlink_release();\n\nout_unreg_chrdev:\n\tunregister_chrdev_region(MKDEV(pmcraid_major, 0), PMCRAID_MAX_ADAPTERS);\n\nout_init:\n\treturn error;\n}\n\n/**\n * pmcraid_exit - module unload entry point\n */\nstatic void __exit pmcraid_exit(void)\n{\n\tpmcraid_netlink_release();\n\tunregister_chrdev_region(MKDEV(pmcraid_major, 0),\n\t\t\t\t PMCRAID_MAX_ADAPTERS);\n\tpci_unregister_driver(&pmcraid_driver);\n\tclass_destroy(pmcraid_class);\n}\n\nmodule_init(pmcraid_init);\nmodule_exit(pmcraid_exit);\n"], "fixing_code": ["/*\n * pmcraid.c -- driver for PMC Sierra MaxRAID controller adapters\n *\n * Written By: Anil Ravindranath<anil_ravindranath@pmc-sierra.com>\n *             PMC-Sierra Inc\n *\n * Copyright (C) 2008, 2009 PMC Sierra Inc\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,\n * USA\n *\n */\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/hdreg.h>\n#include <linux/version.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <linux/libata.h>\n#include <linux/mutex.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsicam.h>\n\n#include \"pmcraid.h\"\n\n/*\n *   Module configuration parameters\n */\nstatic unsigned int pmcraid_debug_log;\nstatic unsigned int pmcraid_disable_aen;\nstatic unsigned int pmcraid_log_level = IOASC_LOG_LEVEL_MUST;\nstatic unsigned int pmcraid_enable_msix;\n\n/*\n * Data structures to support multiple adapters by the LLD.\n * pmcraid_adapter_count - count of configured adapters\n */\nstatic atomic_t pmcraid_adapter_count = ATOMIC_INIT(0);\n\n/*\n * Supporting user-level control interface through IOCTL commands.\n * pmcraid_major - major number to use\n * pmcraid_minor - minor number(s) to use\n */\nstatic unsigned int pmcraid_major;\nstatic struct class *pmcraid_class;\nDECLARE_BITMAP(pmcraid_minor, PMCRAID_MAX_ADAPTERS);\n\n/*\n * Module parameters\n */\nMODULE_AUTHOR(\"Anil Ravindranath<anil_ravindranath@pmc-sierra.com>\");\nMODULE_DESCRIPTION(\"PMC Sierra MaxRAID Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(PMCRAID_DRIVER_VERSION);\n\nmodule_param_named(log_level, pmcraid_log_level, uint, (S_IRUGO | S_IWUSR));\nMODULE_PARM_DESC(log_level,\n\t\t \"Enables firmware error code logging, default :1 high-severity\"\n\t\t \" errors, 2: all errors including high-severity errors,\"\n\t\t \" 0: disables logging\");\n\nmodule_param_named(debug, pmcraid_debug_log, uint, (S_IRUGO | S_IWUSR));\nMODULE_PARM_DESC(debug,\n\t\t \"Enable driver verbose message logging. Set 1 to enable.\"\n\t\t \"(default: 0)\");\n\nmodule_param_named(disable_aen, pmcraid_disable_aen, uint, (S_IRUGO | S_IWUSR));\nMODULE_PARM_DESC(disable_aen,\n\t\t \"Disable driver aen notifications to apps. Set 1 to disable.\"\n\t\t \"(default: 0)\");\n\n/* chip specific constants for PMC MaxRAID controllers (same for\n * 0x5220 and 0x8010\n */\nstatic struct pmcraid_chip_details pmcraid_chip_cfg[] = {\n\t{\n\t .ioastatus = 0x0,\n\t .ioarrin = 0x00040,\n\t .mailbox = 0x7FC30,\n\t .global_intr_mask = 0x00034,\n\t .ioa_host_intr = 0x0009C,\n\t .ioa_host_intr_clr = 0x000A0,\n\t .ioa_host_msix_intr = 0x7FC40,\n\t .ioa_host_mask = 0x7FC28,\n\t .ioa_host_mask_clr = 0x7FC28,\n\t .host_ioa_intr = 0x00020,\n\t .host_ioa_intr_clr = 0x00020,\n\t .transop_timeout = 300\n\t }\n};\n\n/*\n * PCI device ids supported by pmcraid driver\n */\nstatic struct pci_device_id pmcraid_pci_table[] __devinitdata = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_PMC, PCI_DEVICE_ID_PMC_MAXRAID),\n\t  0, 0, (kernel_ulong_t)&pmcraid_chip_cfg[0]\n\t},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, pmcraid_pci_table);\n\n\n\n/**\n * pmcraid_slave_alloc - Prepare for commands to a device\n * @scsi_dev: scsi device struct\n *\n * This function is called by mid-layer prior to sending any command to the new\n * device. Stores resource entry details of the device in scsi_device struct.\n * Queuecommand uses the resource handle and other details to fill up IOARCB\n * while sending commands to the device.\n *\n * Return value:\n *\t  0 on success / -ENXIO if device does not exist\n */\nstatic int pmcraid_slave_alloc(struct scsi_device *scsi_dev)\n{\n\tstruct pmcraid_resource_entry *temp, *res = NULL;\n\tstruct pmcraid_instance *pinstance;\n\tu8 target, bus, lun;\n\tunsigned long lock_flags;\n\tint rc = -ENXIO;\n\tu16 fw_version;\n\n\tpinstance = shost_priv(scsi_dev->host);\n\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\n\t/* Driver exposes VSET and GSCSI resources only; all other device types\n\t * are not exposed. Resource list is synchronized using resource lock\n\t * so any traversal or modifications to the list should be done inside\n\t * this lock\n\t */\n\tspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\n\tlist_for_each_entry(temp, &pinstance->used_res_q, queue) {\n\n\t\t/* do not expose VSETs with order-ids > MAX_VSET_TARGETS */\n\t\tif (RES_IS_VSET(temp->cfg_entry)) {\n\t\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\t\ttarget = temp->cfg_entry.unique_flags1;\n\t\t\telse\n\t\t\t\ttarget = temp->cfg_entry.array_id & 0xFF;\n\n\t\t\tif (target > PMCRAID_MAX_VSET_TARGETS)\n\t\t\t\tcontinue;\n\t\t\tbus = PMCRAID_VSET_BUS_ID;\n\t\t\tlun = 0;\n\t\t} else if (RES_IS_GSCSI(temp->cfg_entry)) {\n\t\t\ttarget = RES_TARGET(temp->cfg_entry.resource_address);\n\t\t\tbus = PMCRAID_PHYS_BUS_ID;\n\t\t\tlun = RES_LUN(temp->cfg_entry.resource_address);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bus == scsi_dev->channel &&\n\t\t    target == scsi_dev->id &&\n\t\t    lun == scsi_dev->lun) {\n\t\t\tres = temp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (res) {\n\t\tres->scsi_dev = scsi_dev;\n\t\tscsi_dev->hostdata = res;\n\t\tres->change_detected = 0;\n\t\tatomic_set(&res->read_failures, 0);\n\t\tatomic_set(&res->write_failures, 0);\n\t\trc = 0;\n\t}\n\tspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\n\treturn rc;\n}\n\n/**\n * pmcraid_slave_configure - Configures a SCSI device\n * @scsi_dev: scsi device struct\n *\n * This function is executed by SCSI mid layer just after a device is first\n * scanned (i.e. it has responded to an INQUIRY). For VSET resources, the\n * timeout value (default 30s) will be over-written to a higher value (60s)\n * and max_sectors value will be over-written to 512. It also sets queue depth\n * to host->cmd_per_lun value\n *\n * Return value:\n *\t  0 on success\n */\nstatic int pmcraid_slave_configure(struct scsi_device *scsi_dev)\n{\n\tstruct pmcraid_resource_entry *res = scsi_dev->hostdata;\n\n\tif (!res)\n\t\treturn 0;\n\n\t/* LLD exposes VSETs and Enclosure devices only */\n\tif (RES_IS_GSCSI(res->cfg_entry) &&\n\t    scsi_dev->type != TYPE_ENCLOSURE)\n\t\treturn -ENXIO;\n\n\tpmcraid_info(\"configuring %x:%x:%x:%x\\n\",\n\t\t     scsi_dev->host->unique_id,\n\t\t     scsi_dev->channel,\n\t\t     scsi_dev->id,\n\t\t     scsi_dev->lun);\n\n\tif (RES_IS_GSCSI(res->cfg_entry)) {\n\t\tscsi_dev->allow_restart = 1;\n\t} else if (RES_IS_VSET(res->cfg_entry)) {\n\t\tscsi_dev->allow_restart = 1;\n\t\tblk_queue_rq_timeout(scsi_dev->request_queue,\n\t\t\t\t     PMCRAID_VSET_IO_TIMEOUT);\n\t\tblk_queue_max_hw_sectors(scsi_dev->request_queue,\n\t\t\t\t      PMCRAID_VSET_MAX_SECTORS);\n\t}\n\n\tif (scsi_dev->tagged_supported &&\n\t    (RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry))) {\n\t\tscsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);\n\t\tscsi_adjust_queue_depth(scsi_dev, MSG_SIMPLE_TAG,\n\t\t\t\t\tscsi_dev->host->cmd_per_lun);\n\t} else {\n\t\tscsi_adjust_queue_depth(scsi_dev, 0,\n\t\t\t\t\tscsi_dev->host->cmd_per_lun);\n\t}\n\n\treturn 0;\n}\n\n/**\n * pmcraid_slave_destroy - Unconfigure a SCSI device before removing it\n *\n * @scsi_dev: scsi device struct\n *\n * This is called by mid-layer before removing a device. Pointer assignments\n * done in pmcraid_slave_alloc will be reset to NULL here.\n *\n * Return value\n *   none\n */\nstatic void pmcraid_slave_destroy(struct scsi_device *scsi_dev)\n{\n\tstruct pmcraid_resource_entry *res;\n\n\tres = (struct pmcraid_resource_entry *)scsi_dev->hostdata;\n\n\tif (res)\n\t\tres->scsi_dev = NULL;\n\n\tscsi_dev->hostdata = NULL;\n}\n\n/**\n * pmcraid_change_queue_depth - Change the device's queue depth\n * @scsi_dev: scsi device struct\n * @depth: depth to set\n * @reason: calling context\n *\n * Return value\n *\tactual depth set\n */\nstatic int pmcraid_change_queue_depth(struct scsi_device *scsi_dev, int depth,\n\t\t\t\t      int reason)\n{\n\tif (reason != SCSI_QDEPTH_DEFAULT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (depth > PMCRAID_MAX_CMD_PER_LUN)\n\t\tdepth = PMCRAID_MAX_CMD_PER_LUN;\n\n\tscsi_adjust_queue_depth(scsi_dev, scsi_get_tag_type(scsi_dev), depth);\n\n\treturn scsi_dev->queue_depth;\n}\n\n/**\n * pmcraid_change_queue_type - Change the device's queue type\n * @scsi_dev: scsi device struct\n * @tag: type of tags to use\n *\n * Return value:\n *\tactual queue type set\n */\nstatic int pmcraid_change_queue_type(struct scsi_device *scsi_dev, int tag)\n{\n\tstruct pmcraid_resource_entry *res;\n\n\tres = (struct pmcraid_resource_entry *)scsi_dev->hostdata;\n\n\tif ((res) && scsi_dev->tagged_supported &&\n\t    (RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry))) {\n\t\tscsi_set_tag_type(scsi_dev, tag);\n\n\t\tif (tag)\n\t\t\tscsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);\n\t\telse\n\t\t\tscsi_deactivate_tcq(scsi_dev, scsi_dev->queue_depth);\n\t} else\n\t\ttag = 0;\n\n\treturn tag;\n}\n\n\n/**\n * pmcraid_init_cmdblk - initializes a command block\n *\n * @cmd: pointer to struct pmcraid_cmd to be initialized\n * @index: if >=0 first time initialization; otherwise reinitialization\n *\n * Return Value\n *\t None\n */\nvoid pmcraid_init_cmdblk(struct pmcraid_cmd *cmd, int index)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &(cmd->ioa_cb->ioarcb);\n\tdma_addr_t dma_addr = cmd->ioa_cb_bus_addr;\n\n\tif (index >= 0) {\n\t\t/* first time initialization (called from  probe) */\n\t\tu32 ioasa_offset =\n\t\t\toffsetof(struct pmcraid_control_block, ioasa);\n\n\t\tcmd->index = index;\n\t\tioarcb->response_handle = cpu_to_le32(index << 2);\n\t\tioarcb->ioarcb_bus_addr = cpu_to_le64(dma_addr);\n\t\tioarcb->ioasa_bus_addr = cpu_to_le64(dma_addr + ioasa_offset);\n\t\tioarcb->ioasa_len = cpu_to_le16(sizeof(struct pmcraid_ioasa));\n\t} else {\n\t\t/* re-initialization of various lengths, called once command is\n\t\t * processed by IOA\n\t\t */\n\t\tmemset(&cmd->ioa_cb->ioarcb.cdb, 0, PMCRAID_MAX_CDB_LEN);\n\t\tioarcb->hrrq_id = 0;\n\t\tioarcb->request_flags0 = 0;\n\t\tioarcb->request_flags1 = 0;\n\t\tioarcb->cmd_timeout = 0;\n\t\tioarcb->ioarcb_bus_addr &= (~0x1FULL);\n\t\tioarcb->ioadl_bus_addr = 0;\n\t\tioarcb->ioadl_length = 0;\n\t\tioarcb->data_transfer_length = 0;\n\t\tioarcb->add_cmd_param_length = 0;\n\t\tioarcb->add_cmd_param_offset = 0;\n\t\tcmd->ioa_cb->ioasa.ioasc = 0;\n\t\tcmd->ioa_cb->ioasa.residual_data_length = 0;\n\t\tcmd->time_left = 0;\n\t}\n\n\tcmd->cmd_done = NULL;\n\tcmd->scsi_cmd = NULL;\n\tcmd->release = 0;\n\tcmd->completion_req = 0;\n\tcmd->sense_buffer = 0;\n\tcmd->sense_buffer_dma = 0;\n\tcmd->dma_handle = 0;\n\tinit_timer(&cmd->timer);\n}\n\n/**\n * pmcraid_reinit_cmdblk - reinitialize a command block\n *\n * @cmd: pointer to struct pmcraid_cmd to be reinitialized\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_reinit_cmdblk(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_init_cmdblk(cmd, -1);\n}\n\n/**\n * pmcraid_get_free_cmd - get a free cmd block from command block pool\n * @pinstance: adapter instance structure\n *\n * Return Value:\n *\treturns pointer to cmd block or NULL if no blocks are available\n */\nstatic struct pmcraid_cmd *pmcraid_get_free_cmd(\n\tstruct pmcraid_instance *pinstance\n)\n{\n\tstruct pmcraid_cmd *cmd = NULL;\n\tunsigned long lock_flags;\n\n\t/* free cmd block list is protected by free_pool_lock */\n\tspin_lock_irqsave(&pinstance->free_pool_lock, lock_flags);\n\n\tif (!list_empty(&pinstance->free_cmd_pool)) {\n\t\tcmd = list_entry(pinstance->free_cmd_pool.next,\n\t\t\t\t struct pmcraid_cmd, free_list);\n\t\tlist_del(&cmd->free_list);\n\t}\n\tspin_unlock_irqrestore(&pinstance->free_pool_lock, lock_flags);\n\n\t/* Initialize the command block before giving it the caller */\n\tif (cmd != NULL)\n\t\tpmcraid_reinit_cmdblk(cmd);\n\treturn cmd;\n}\n\n/**\n * pmcraid_return_cmd - return a completed command block back into free pool\n * @cmd: pointer to the command block\n *\n * Return Value:\n *\tnothing\n */\nvoid pmcraid_return_cmd(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(&pinstance->free_pool_lock, lock_flags);\n\tlist_add_tail(&cmd->free_list, &pinstance->free_cmd_pool);\n\tspin_unlock_irqrestore(&pinstance->free_pool_lock, lock_flags);\n}\n\n/**\n * pmcraid_read_interrupts -  reads IOA interrupts\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return value\n *\t interrupts read from IOA\n */\nstatic u32 pmcraid_read_interrupts(struct pmcraid_instance *pinstance)\n{\n\treturn (pinstance->interrupt_mode) ?\n\t\tioread32(pinstance->int_regs.ioa_host_msix_interrupt_reg) :\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_reg);\n}\n\n/**\n * pmcraid_disable_interrupts - Masks and clears all specified interrupts\n *\n * @pinstance: pointer to per adapter instance structure\n * @intrs: interrupts to disable\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_disable_interrupts(\n\tstruct pmcraid_instance *pinstance,\n\tu32 intrs\n)\n{\n\tu32 gmask = ioread32(pinstance->int_regs.global_interrupt_mask_reg);\n\tu32 nmask = gmask | GLOBAL_INTERRUPT_MASK;\n\n\tiowrite32(intrs, pinstance->int_regs.ioa_host_interrupt_clr_reg);\n\tiowrite32(nmask, pinstance->int_regs.global_interrupt_mask_reg);\n\tioread32(pinstance->int_regs.global_interrupt_mask_reg);\n\n\tif (!pinstance->interrupt_mode) {\n\t\tiowrite32(intrs,\n\t\t\tpinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t}\n}\n\n/**\n * pmcraid_enable_interrupts - Enables specified interrupts\n *\n * @pinstance: pointer to per adapter instance structure\n * @intr: interrupts to enable\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_enable_interrupts(\n\tstruct pmcraid_instance *pinstance,\n\tu32 intrs\n)\n{\n\tu32 gmask = ioread32(pinstance->int_regs.global_interrupt_mask_reg);\n\tu32 nmask = gmask & (~GLOBAL_INTERRUPT_MASK);\n\n\tiowrite32(nmask, pinstance->int_regs.global_interrupt_mask_reg);\n\n\tif (!pinstance->interrupt_mode) {\n\t\tiowrite32(~intrs,\n\t\t\t pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t}\n\n\tpmcraid_info(\"enabled interrupts global mask = %x intr_mask = %x\\n\",\n\t\tioread32(pinstance->int_regs.global_interrupt_mask_reg),\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg));\n}\n\n/**\n * pmcraid_clr_trans_op - clear trans to op interrupt\n *\n * @pinstance: pointer to per adapter instance structure\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_clr_trans_op(\n\tstruct pmcraid_instance *pinstance\n)\n{\n\tunsigned long lock_flags;\n\n\tif (!pinstance->interrupt_mode) {\n\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\tpinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t}\n\n\tif (pinstance->reset_cmd != NULL) {\n\t\tdel_timer(&pinstance->reset_cmd->timer);\n\t\tspin_lock_irqsave(\n\t\t\tpinstance->host->host_lock, lock_flags);\n\t\tpinstance->reset_cmd->cmd_done(pinstance->reset_cmd);\n\t\tspin_unlock_irqrestore(\n\t\t\tpinstance->host->host_lock, lock_flags);\n\t}\n}\n\n/**\n * pmcraid_reset_type - Determine the required reset type\n * @pinstance: pointer to adapter instance structure\n *\n * IOA requires hard reset if any of the following conditions is true.\n * 1. If HRRQ valid interrupt is not masked\n * 2. IOA reset alert doorbell is set\n * 3. If there are any error interrupts\n */\nstatic void pmcraid_reset_type(struct pmcraid_instance *pinstance)\n{\n\tu32 mask;\n\tu32 intrs;\n\tu32 alerts;\n\n\tmask = ioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\tintrs = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\n\talerts = ioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\n\tif ((mask & INTRS_HRRQ_VALID) == 0 ||\n\t    (alerts & DOORBELL_IOA_RESET_ALERT) ||\n\t    (intrs & PMCRAID_ERROR_INTERRUPTS)) {\n\t\tpmcraid_info(\"IOA requires hard reset\\n\");\n\t\tpinstance->ioa_hard_reset = 1;\n\t}\n\n\t/* If unit check is active, trigger the dump */\n\tif (intrs & INTRS_IOA_UNIT_CHECK)\n\t\tpinstance->ioa_unit_check = 1;\n}\n\n/**\n * pmcraid_bist_done - completion function for PCI BIST\n * @cmd: pointer to reset command\n * Return Value\n *\tnone\n */\n\nstatic void pmcraid_ioa_reset(struct pmcraid_cmd *);\n\nstatic void pmcraid_bist_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\tint rc;\n\tu16 pci_reg;\n\n\trc = pci_read_config_word(pinstance->pdev, PCI_COMMAND, &pci_reg);\n\n\t/* If PCI config space can't be accessed wait for another two secs */\n\tif ((rc != PCIBIOS_SUCCESSFUL || (!(pci_reg & PCI_COMMAND_MEMORY))) &&\n\t    cmd->time_left > 0) {\n\t\tpmcraid_info(\"BIST not complete, waiting another 2 secs\\n\");\n\t\tcmd->timer.expires = jiffies + cmd->time_left;\n\t\tcmd->time_left = 0;\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.function =\n\t\t\t(void (*)(unsigned long))pmcraid_bist_done;\n\t\tadd_timer(&cmd->timer);\n\t} else {\n\t\tcmd->time_left = 0;\n\t\tpmcraid_info(\"BIST is complete, proceeding with reset\\n\");\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_ioa_reset(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t}\n}\n\n/**\n * pmcraid_start_bist - starts BIST\n * @cmd: pointer to reset cmd\n * Return Value\n *   none\n */\nstatic void pmcraid_start_bist(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 doorbells, intrs;\n\n\t/* proceed with bist and wait for 2 seconds */\n\tiowrite32(DOORBELL_IOA_START_BIST,\n\t\tpinstance->int_regs.host_ioa_interrupt_reg);\n\tdoorbells = ioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\tintrs = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\n\tpmcraid_info(\"doorbells after start bist: %x intrs: %x\\n\",\n\t\t      doorbells, intrs);\n\n\tcmd->time_left = msecs_to_jiffies(PMCRAID_BIST_TIMEOUT);\n\tcmd->timer.data = (unsigned long)cmd;\n\tcmd->timer.expires = jiffies + msecs_to_jiffies(PMCRAID_BIST_TIMEOUT);\n\tcmd->timer.function = (void (*)(unsigned long))pmcraid_bist_done;\n\tadd_timer(&cmd->timer);\n}\n\n/**\n * pmcraid_reset_alert_done - completion routine for reset_alert\n * @cmd: pointer to command block used in reset sequence\n * Return value\n *  None\n */\nstatic void pmcraid_reset_alert_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 status = ioread32(pinstance->ioa_status);\n\tunsigned long lock_flags;\n\n\t/* if the critical operation in progress bit is set or the wait times\n\t * out, invoke reset engine to proceed with hard reset. If there is\n\t * some more time to wait, restart the timer\n\t */\n\tif (((status & INTRS_CRITICAL_OP_IN_PROGRESS) == 0) ||\n\t    cmd->time_left <= 0) {\n\t\tpmcraid_info(\"critical op is reset proceeding with reset\\n\");\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_ioa_reset(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t} else {\n\t\tpmcraid_info(\"critical op is not yet reset waiting again\\n\");\n\t\t/* restart timer if some more time is available to wait */\n\t\tcmd->time_left -= PMCRAID_CHECK_FOR_RESET_TIMEOUT;\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.expires = jiffies + PMCRAID_CHECK_FOR_RESET_TIMEOUT;\n\t\tcmd->timer.function =\n\t\t\t(void (*)(unsigned long))pmcraid_reset_alert_done;\n\t\tadd_timer(&cmd->timer);\n\t}\n}\n\n/**\n * pmcraid_reset_alert - alerts IOA for a possible reset\n * @cmd : command block to be used for reset sequence.\n *\n * Return Value\n *\treturns 0 if pci config-space is accessible and RESET_DOORBELL is\n *\tsuccessfully written to IOA. Returns non-zero in case pci_config_space\n *\tis not accessible\n */\nstatic void pmcraid_notify_ioastate(struct pmcraid_instance *, u32);\nstatic void pmcraid_reset_alert(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 doorbells;\n\tint rc;\n\tu16 pci_reg;\n\n\t/* If we are able to access IOA PCI config space, alert IOA that we are\n\t * going to reset it soon. This enables IOA to preserv persistent error\n\t * data if any. In case memory space is not accessible, proceed with\n\t * BIST or slot_reset\n\t */\n\trc = pci_read_config_word(pinstance->pdev, PCI_COMMAND, &pci_reg);\n\tif ((rc == PCIBIOS_SUCCESSFUL) && (pci_reg & PCI_COMMAND_MEMORY)) {\n\n\t\t/* wait for IOA permission i.e until CRITICAL_OPERATION bit is\n\t\t * reset IOA doesn't generate any interrupts when CRITICAL\n\t\t * OPERATION bit is reset. A timer is started to wait for this\n\t\t * bit to be reset.\n\t\t */\n\t\tcmd->time_left = PMCRAID_RESET_TIMEOUT;\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.expires = jiffies + PMCRAID_CHECK_FOR_RESET_TIMEOUT;\n\t\tcmd->timer.function =\n\t\t\t(void (*)(unsigned long))pmcraid_reset_alert_done;\n\t\tadd_timer(&cmd->timer);\n\n\t\tiowrite32(DOORBELL_IOA_RESET_ALERT,\n\t\t\tpinstance->int_regs.host_ioa_interrupt_reg);\n\t\tdoorbells =\n\t\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tpmcraid_info(\"doorbells after reset alert: %x\\n\", doorbells);\n\t} else {\n\t\tpmcraid_info(\"PCI config is not accessible starting BIST\\n\");\n\t\tpinstance->ioa_state = IOA_STATE_IN_HARD_RESET;\n\t\tpmcraid_start_bist(cmd);\n\t}\n}\n\n/**\n * pmcraid_timeout_handler -  Timeout handler for internally generated ops\n *\n * @cmd : pointer to command structure, that got timedout\n *\n * This function blocks host requests and initiates an adapter reset.\n *\n * Return value:\n *   None\n */\nstatic void pmcraid_timeout_handler(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\tdev_info(&pinstance->pdev->dev,\n\t\t\"Adapter being reset due to cmd(CDB[0] = %x) timeout\\n\",\n\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t/* Command timeouts result in hard reset sequence. The command that got\n\t * timed out may be the one used as part of reset sequence. In this\n\t * case restart reset sequence using the same command block even if\n\t * reset is in progress. Otherwise fail this command and get a free\n\t * command block to restart the reset sequence.\n\t */\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\tif (!pinstance->ioa_reset_in_progress) {\n\t\tpinstance->ioa_reset_attempts = 0;\n\t\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\t\t/* If we are out of command blocks, just return here itself.\n\t\t * Some other command's timeout handler can do the reset job\n\t\t */\n\t\tif (cmd == NULL) {\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\tpmcraid_err(\"no free cmnd block for timeout handler\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tpinstance->reset_cmd = cmd;\n\t\tpinstance->ioa_reset_in_progress = 1;\n\t} else {\n\t\tpmcraid_info(\"reset is already in progress\\n\");\n\n\t\tif (pinstance->reset_cmd != cmd) {\n\t\t\t/* This command should have been given to IOA, this\n\t\t\t * command will be completed by fail_outstanding_cmds\n\t\t\t * anyway\n\t\t\t */\n\t\t\tpmcraid_err(\"cmd is pending but reset in progress\\n\");\n\t\t}\n\n\t\t/* If this command was being used as part of the reset\n\t\t * sequence, set cmd_done pointer to pmcraid_ioa_reset. This\n\t\t * causes fail_outstanding_commands not to return the command\n\t\t * block back to free pool\n\t\t */\n\t\tif (cmd == pinstance->reset_cmd)\n\t\t\tcmd->cmd_done = pmcraid_ioa_reset;\n\t}\n\n\t/* Notify apps of important IOA bringup/bringdown sequences */\n\tif (pinstance->scn.ioa_state != PMC_DEVICE_EVENT_RESET_START &&\n\t    pinstance->scn.ioa_state != PMC_DEVICE_EVENT_SHUTDOWN_START)\n\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\tPMC_DEVICE_EVENT_RESET_START);\n\n\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\tscsi_block_requests(pinstance->host);\n\tpmcraid_reset_alert(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n}\n\n/**\n * pmcraid_internal_done - completion routine for internally generated cmds\n *\n * @cmd: command that got response from IOA\n *\n * Return Value:\n *\t none\n */\nstatic void pmcraid_internal_done(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_info(\"response internal cmd CDB[0] = %x ioasc = %x\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\n\n\t/* Some of the internal commands are sent with callers blocking for the\n\t * response. Same will be indicated as part of cmd->completion_req\n\t * field. Response path needs to wake up any waiters waiting for cmd\n\t * completion if this flag is set.\n\t */\n\tif (cmd->completion_req) {\n\t\tcmd->completion_req = 0;\n\t\tcomplete(&cmd->wait_for_completion);\n\t}\n\n\t/* most of the internal commands are completed by caller itself, so\n\t * no need to return the command block back to free pool until we are\n\t * required to do so (e.g once done with initialization).\n\t */\n\tif (cmd->release) {\n\t\tcmd->release = 0;\n\t\tpmcraid_return_cmd(cmd);\n\t}\n}\n\n/**\n * pmcraid_reinit_cfgtable_done - done function for cfg table reinitialization\n *\n * @cmd: command that got response from IOA\n *\n * This routine is called after driver re-reads configuration table due to a\n * lost CCN. It returns the command block back to free pool and schedules\n * worker thread to add/delete devices into the system.\n *\n * Return Value:\n *\t none\n */\nstatic void pmcraid_reinit_cfgtable_done(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_info(\"response internal cmd CDB[0] = %x ioasc = %x\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\n\n\tif (cmd->release) {\n\t\tcmd->release = 0;\n\t\tpmcraid_return_cmd(cmd);\n\t}\n\tpmcraid_info(\"scheduling worker for config table reinitialization\\n\");\n\tschedule_work(&cmd->drv_inst->worker_q);\n}\n\n/**\n * pmcraid_erp_done - Process completion of SCSI error response from device\n * @cmd: pmcraid_command\n *\n * This function copies the sense buffer into the scsi_cmd struct and completes\n * scsi_cmd by calling scsi_done function.\n *\n * Return value:\n *  none\n */\nstatic void pmcraid_erp_done(struct pmcraid_cmd *cmd)\n{\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\n\tif (PMCRAID_IOASC_SENSE_KEY(ioasc) > 0) {\n\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tscmd_printk(KERN_INFO, scsi_cmd,\n\t\t\t    \"command CDB[0] = %x failed with IOASC: 0x%08X\\n\",\n\t\t\t    cmd->ioa_cb->ioarcb.cdb[0], ioasc);\n\t}\n\n\t/* if we had allocated sense buffers for request sense, copy the sense\n\t * release the buffers\n\t */\n\tif (cmd->sense_buffer != NULL) {\n\t\tmemcpy(scsi_cmd->sense_buffer,\n\t\t       cmd->sense_buffer,\n\t\t       SCSI_SENSE_BUFFERSIZE);\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t    cmd->sense_buffer, cmd->sense_buffer_dma);\n\t\tcmd->sense_buffer = NULL;\n\t\tcmd->sense_buffer_dma = 0;\n\t}\n\n\tscsi_dma_unmap(scsi_cmd);\n\tpmcraid_return_cmd(cmd);\n\tscsi_cmd->scsi_done(scsi_cmd);\n}\n\n/**\n * pmcraid_fire_command - sends an IOA command to adapter\n *\n * This function adds the given block into pending command list\n * and returns without waiting\n *\n * @cmd : command to be sent to the device\n *\n * Return Value\n *\tNone\n */\nstatic void _pmcraid_fire_command(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\t/* Add this command block to pending cmd pool. We do this prior to\n\t * writting IOARCB to ioarrin because IOA might complete the command\n\t * by the time we are about to add it to the list. Response handler\n\t * (isr/tasklet) looks for cmd block in the pending pending list.\n\t */\n\tspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\n\tlist_add_tail(&cmd->free_list, &pinstance->pending_cmd_pool);\n\tspin_unlock_irqrestore(&pinstance->pending_pool_lock, lock_flags);\n\tatomic_inc(&pinstance->outstanding_cmds);\n\n\t/* driver writes lower 32-bit value of IOARCB address only */\n\tmb();\n\tiowrite32(le32_to_cpu(cmd->ioa_cb->ioarcb.ioarcb_bus_addr),\n\t\t  pinstance->ioarrin);\n}\n\n/**\n * pmcraid_send_cmd - fires a command to IOA\n *\n * This function also sets up timeout function, and command completion\n * function\n *\n * @cmd: pointer to the command block to be fired to IOA\n * @cmd_done: command completion function, called once IOA responds\n * @timeout: timeout to wait for this command completion\n * @timeout_func: timeout handler\n *\n * Return value\n *   none\n */\nstatic void pmcraid_send_cmd(\n\tstruct pmcraid_cmd *cmd,\n\tvoid (*cmd_done) (struct pmcraid_cmd *),\n\tunsigned long timeout,\n\tvoid (*timeout_func) (struct pmcraid_cmd *)\n)\n{\n\t/* initialize done function */\n\tcmd->cmd_done = cmd_done;\n\n\tif (timeout_func) {\n\t\t/* setup timeout handler */\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.expires = jiffies + timeout;\n\t\tcmd->timer.function = (void (*)(unsigned long))timeout_func;\n\t\tadd_timer(&cmd->timer);\n\t}\n\n\t/* fire the command to IOA */\n\t_pmcraid_fire_command(cmd);\n}\n\n/**\n * pmcraid_ioa_shutdown_done - completion function for IOA shutdown command\n * @cmd: pointer to the command block used for sending IOA shutdown command\n *\n * Return value\n *  None\n */\nstatic void pmcraid_ioa_shutdown_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\tpmcraid_ioa_reset(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n}\n\n/**\n * pmcraid_ioa_shutdown - sends SHUTDOWN command to ioa\n *\n * @cmd: pointer to the command block used as part of reset sequence\n *\n * Return Value\n *  None\n */\nstatic void pmcraid_ioa_shutdown(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_info(\"response for Cancel CCN CDB[0] = %x ioasc = %x\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\n\n\t/* Note that commands sent during reset require next command to be sent\n\t * to IOA. Hence reinit the done function as well as timeout function\n\t */\n\tpmcraid_reinit_cmdblk(cmd);\n\tcmd->ioa_cb->ioarcb.request_type = REQ_TYPE_IOACMD;\n\tcmd->ioa_cb->ioarcb.resource_handle =\n\t\tcpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tcmd->ioa_cb->ioarcb.cdb[0] = PMCRAID_IOA_SHUTDOWN;\n\tcmd->ioa_cb->ioarcb.cdb[1] = PMCRAID_SHUTDOWN_NORMAL;\n\n\t/* fire shutdown command to hardware. */\n\tpmcraid_info(\"firing normal shutdown command (%d) to IOA\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle));\n\n\tpmcraid_notify_ioastate(cmd->drv_inst, PMC_DEVICE_EVENT_SHUTDOWN_START);\n\n\tpmcraid_send_cmd(cmd, pmcraid_ioa_shutdown_done,\n\t\t\t PMCRAID_SHUTDOWN_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_get_fwversion_done - completion function for get_fwversion\n *\n * @cmd: pointer to command block used to send INQUIRY command\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_querycfg(struct pmcraid_cmd *);\n\nstatic void pmcraid_get_fwversion_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\tunsigned long lock_flags;\n\n\t/* configuration table entry size depends on firmware version. If fw\n\t * version is not known, it is not possible to interpret IOA config\n\t * table\n\t */\n\tif (ioasc) {\n\t\tpmcraid_err(\"IOA Inquiry failed with %x\\n\", ioasc);\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\tpmcraid_reset_alert(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t} else  {\n\t\tpmcraid_querycfg(cmd);\n\t}\n}\n\n/**\n * pmcraid_get_fwversion - reads firmware version information\n *\n * @cmd: pointer to command block used to send INQUIRY command\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_get_fwversion(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu16 data_size = sizeof(struct pmcraid_inquiry_data);\n\n\tpmcraid_reinit_cmdblk(cmd);\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->cdb[0] = INQUIRY;\n\tioarcb->cdb[1] = 1;\n\tioarcb->cdb[2] = 0xD0;\n\tioarcb->cdb[3] = (data_size >> 8) & 0xFF;\n\tioarcb->cdb[4] = data_size & 0xFF;\n\n\t/* Since entire inquiry data it can be part of IOARCB itself\n\t */\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length = cpu_to_le32(data_size);\n\tioadl = &(ioarcb->add_data.u.ioadl[0]);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\tioadl->address = cpu_to_le64(pinstance->inq_data_baddr);\n\tioadl->data_len = cpu_to_le32(data_size);\n\n\tpmcraid_send_cmd(cmd, pmcraid_get_fwversion_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_identify_hrrq - registers host rrq buffers with IOA\n * @cmd: pointer to command block to be used for identify hrrq\n *\n * Return Value\n *\t none\n */\nstatic void pmcraid_identify_hrrq(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tint index = cmd->hrrq_index;\n\t__be64 hrrq_addr = cpu_to_be64(pinstance->hrrq_start_bus_addr[index]);\n\tu32 hrrq_size = cpu_to_be32(sizeof(u32) * PMCRAID_MAX_CMD);\n\tvoid (*done_function)(struct pmcraid_cmd *);\n\n\tpmcraid_reinit_cmdblk(cmd);\n\tcmd->hrrq_index = index + 1;\n\n\tif (cmd->hrrq_index < pinstance->num_hrrq) {\n\t\tdone_function = pmcraid_identify_hrrq;\n\t} else {\n\t\tcmd->hrrq_index = 0;\n\t\tdone_function = pmcraid_get_fwversion;\n\t}\n\n\t/* Initialize ioarcb */\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\n\t/* initialize the hrrq number where IOA will respond to this command */\n\tioarcb->hrrq_id = index;\n\tioarcb->cdb[0] = PMCRAID_IDENTIFY_HRRQ;\n\tioarcb->cdb[1] = index;\n\n\t/* IOA expects 64-bit pci address to be written in B.E format\n\t * (i.e cdb[2]=MSByte..cdb[9]=LSB.\n\t */\n\tpmcraid_info(\"HRRQ_IDENTIFY with hrrq:ioarcb:index => %llx:%llx:%x\\n\",\n\t\t     hrrq_addr, ioarcb->ioarcb_bus_addr, index);\n\n\tmemcpy(&(ioarcb->cdb[2]), &hrrq_addr, sizeof(hrrq_addr));\n\tmemcpy(&(ioarcb->cdb[10]), &hrrq_size, sizeof(hrrq_size));\n\n\t/* Subsequent commands require HRRQ identification to be successful.\n\t * Note that this gets called even during reset from SCSI mid-layer\n\t * or tasklet\n\t */\n\tpmcraid_send_cmd(cmd, done_function,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\nstatic void pmcraid_process_ccn(struct pmcraid_cmd *cmd);\nstatic void pmcraid_process_ldn(struct pmcraid_cmd *cmd);\n\n/**\n * pmcraid_send_hcam_cmd - send an initialized command block(HCAM) to IOA\n *\n * @cmd: initialized command block pointer\n *\n * Return Value\n *   none\n */\nstatic void pmcraid_send_hcam_cmd(struct pmcraid_cmd *cmd)\n{\n\tif (cmd->ioa_cb->ioarcb.cdb[1] == PMCRAID_HCAM_CODE_CONFIG_CHANGE)\n\t\tatomic_set(&(cmd->drv_inst->ccn.ignore), 0);\n\telse\n\t\tatomic_set(&(cmd->drv_inst->ldn.ignore), 0);\n\n\tpmcraid_send_cmd(cmd, cmd->cmd_done, 0, NULL);\n}\n\n/**\n * pmcraid_init_hcam - send an initialized command block(HCAM) to IOA\n *\n * @pinstance: pointer to adapter instance structure\n * @type: HCAM type\n *\n * Return Value\n *   pointer to initialized pmcraid_cmd structure or NULL\n */\nstatic struct pmcraid_cmd *pmcraid_init_hcam\n(\n\tstruct pmcraid_instance *pinstance,\n\tu8 type\n)\n{\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl;\n\tstruct pmcraid_hostrcb *hcam;\n\tvoid (*cmd_done) (struct pmcraid_cmd *);\n\tdma_addr_t dma;\n\tint rcb_size;\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"no free command blocks for hcam\\n\");\n\t\treturn cmd;\n\t}\n\n\tif (type == PMCRAID_HCAM_CODE_CONFIG_CHANGE) {\n\t\trcb_size = sizeof(struct pmcraid_hcam_ccn_ext);\n\t\tcmd_done = pmcraid_process_ccn;\n\t\tdma = pinstance->ccn.baddr + PMCRAID_AEN_HDR_SIZE;\n\t\thcam = &pinstance->ccn;\n\t} else {\n\t\trcb_size = sizeof(struct pmcraid_hcam_ldn);\n\t\tcmd_done = pmcraid_process_ldn;\n\t\tdma = pinstance->ldn.baddr + PMCRAID_AEN_HDR_SIZE;\n\t\thcam = &pinstance->ldn;\n\t}\n\n\t/* initialize command pointer used for HCAM registration */\n\thcam->cmd = cmd;\n\n\tioarcb = &cmd->ioa_cb->ioarcb;\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioadl = ioarcb->add_data.u.ioadl;\n\n\t/* Initialize ioarcb */\n\tioarcb->request_type = REQ_TYPE_HCAM;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->cdb[0] = PMCRAID_HOST_CONTROLLED_ASYNC;\n\tioarcb->cdb[1] = type;\n\tioarcb->cdb[7] = (rcb_size >> 8) & 0xFF;\n\tioarcb->cdb[8] = (rcb_size) & 0xFF;\n\n\tioarcb->data_transfer_length = cpu_to_le32(rcb_size);\n\n\tioadl[0].flags |= IOADL_FLAGS_READ_LAST;\n\tioadl[0].data_len = cpu_to_le32(rcb_size);\n\tioadl[0].address = cpu_to_le32(dma);\n\n\tcmd->cmd_done = cmd_done;\n\treturn cmd;\n}\n\n/**\n * pmcraid_send_hcam - Send an HCAM to IOA\n * @pinstance: ioa config struct\n * @type: HCAM type\n *\n * This function will send a Host Controlled Async command to IOA.\n *\n * Return value:\n *\tnone\n */\nstatic void pmcraid_send_hcam(struct pmcraid_instance *pinstance, u8 type)\n{\n\tstruct pmcraid_cmd *cmd = pmcraid_init_hcam(pinstance, type);\n\tpmcraid_send_hcam_cmd(cmd);\n}\n\n\n/**\n * pmcraid_prepare_cancel_cmd - prepares a command block to abort another\n *\n * @cmd: pointer to cmd that is used as cancelling command\n * @cmd_to_cancel: pointer to the command that needs to be cancelled\n */\nstatic void pmcraid_prepare_cancel_cmd(\n\tstruct pmcraid_cmd *cmd,\n\tstruct pmcraid_cmd *cmd_to_cancel\n)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\t__be64 ioarcb_addr = cmd_to_cancel->ioa_cb->ioarcb.ioarcb_bus_addr;\n\n\t/* Get the resource handle to where the command to be aborted has been\n\t * sent.\n\t */\n\tioarcb->resource_handle = cmd_to_cancel->ioa_cb->ioarcb.resource_handle;\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\n\tioarcb->cdb[0] = PMCRAID_ABORT_CMD;\n\n\t/* IOARCB address of the command to be cancelled is given in\n\t * cdb[2]..cdb[9] is Big-Endian format. Note that length bits in\n\t * IOARCB address are not masked.\n\t */\n\tioarcb_addr = cpu_to_be64(ioarcb_addr);\n\tmemcpy(&(ioarcb->cdb[2]), &ioarcb_addr, sizeof(ioarcb_addr));\n}\n\n/**\n * pmcraid_cancel_hcam - sends ABORT task to abort a given HCAM\n *\n * @cmd: command to be used as cancelling command\n * @type: HCAM type\n * @cmd_done: op done function for the cancelling command\n */\nstatic void pmcraid_cancel_hcam(\n\tstruct pmcraid_cmd *cmd,\n\tu8 type,\n\tvoid (*cmd_done) (struct pmcraid_cmd *)\n)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_hostrcb  *hcam;\n\n\tpinstance = cmd->drv_inst;\n\thcam =  (type == PMCRAID_HCAM_CODE_LOG_DATA) ?\n\t\t&pinstance->ldn : &pinstance->ccn;\n\n\t/* prepare for cancelling previous hcam command. If the HCAM is\n\t * currently not pending with IOA, we would have hcam->cmd as non-null\n\t */\n\tif (hcam->cmd == NULL)\n\t\treturn;\n\n\tpmcraid_prepare_cancel_cmd(cmd, hcam->cmd);\n\n\t/* writing to IOARRIN must be protected by host_lock, as mid-layer\n\t * schedule queuecommand while we are doing this\n\t */\n\tpmcraid_send_cmd(cmd, cmd_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_cancel_ccn - cancel CCN HCAM already registered with IOA\n *\n * @cmd: command block to be used for cancelling the HCAM\n */\nstatic void pmcraid_cancel_ccn(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_info(\"response for Cancel LDN CDB[0] = %x ioasc = %x\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\n\n\tpmcraid_reinit_cmdblk(cmd);\n\n\tpmcraid_cancel_hcam(cmd,\n\t\t\t    PMCRAID_HCAM_CODE_CONFIG_CHANGE,\n\t\t\t    pmcraid_ioa_shutdown);\n}\n\n/**\n * pmcraid_cancel_ldn - cancel LDN HCAM already registered with IOA\n *\n * @cmd: command block to be used for cancelling the HCAM\n */\nstatic void pmcraid_cancel_ldn(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_cancel_hcam(cmd,\n\t\t\t    PMCRAID_HCAM_CODE_LOG_DATA,\n\t\t\t    pmcraid_cancel_ccn);\n}\n\n/**\n * pmcraid_expose_resource - check if the resource can be exposed to OS\n *\n * @fw_version: firmware version code\n * @cfgte: pointer to configuration table entry of the resource\n *\n * Return value:\n *\ttrue if resource can be added to midlayer, false(0) otherwise\n */\nstatic int pmcraid_expose_resource(u16 fw_version,\n\t\t\t\t   struct pmcraid_config_table_entry *cfgte)\n{\n\tint retval = 0;\n\n\tif (cfgte->resource_type == RES_TYPE_VSET) {\n\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\tretval = ((cfgte->unique_flags1 & 0x80) == 0);\n\t\telse\n\t\t\tretval = ((cfgte->unique_flags0 & 0x80) == 0 &&\n\t\t\t\t  (cfgte->unique_flags1 & 0x80) == 0);\n\n\t} else if (cfgte->resource_type == RES_TYPE_GSCSI)\n\t\tretval = (RES_BUS(cfgte->resource_address) !=\n\t\t\t\tPMCRAID_VIRTUAL_ENCL_BUS_ID);\n\treturn retval;\n}\n\n/* attributes supported by pmcraid_event_family */\nenum {\n\tPMCRAID_AEN_ATTR_UNSPEC,\n\tPMCRAID_AEN_ATTR_EVENT,\n\t__PMCRAID_AEN_ATTR_MAX,\n};\n#define PMCRAID_AEN_ATTR_MAX (__PMCRAID_AEN_ATTR_MAX - 1)\n\n/* commands supported by pmcraid_event_family */\nenum {\n\tPMCRAID_AEN_CMD_UNSPEC,\n\tPMCRAID_AEN_CMD_EVENT,\n\t__PMCRAID_AEN_CMD_MAX,\n};\n#define PMCRAID_AEN_CMD_MAX (__PMCRAID_AEN_CMD_MAX - 1)\n\nstatic struct genl_family pmcraid_event_family = {\n\t.id = GENL_ID_GENERATE,\n\t.name = \"pmcraid\",\n\t.version = 1,\n\t.maxattr = PMCRAID_AEN_ATTR_MAX\n};\n\n/**\n * pmcraid_netlink_init - registers pmcraid_event_family\n *\n * Return value:\n *\t0 if the pmcraid_event_family is successfully registered\n *\twith netlink generic, non-zero otherwise\n */\nstatic int pmcraid_netlink_init(void)\n{\n\tint result;\n\n\tresult = genl_register_family(&pmcraid_event_family);\n\n\tif (result)\n\t\treturn result;\n\n\tpmcraid_info(\"registered NETLINK GENERIC group: %d\\n\",\n\t\t     pmcraid_event_family.id);\n\n\treturn result;\n}\n\n/**\n * pmcraid_netlink_release - unregisters pmcraid_event_family\n *\n * Return value:\n *\tnone\n */\nstatic void pmcraid_netlink_release(void)\n{\n\tgenl_unregister_family(&pmcraid_event_family);\n}\n\n/**\n * pmcraid_notify_aen - sends event msg to user space application\n * @pinstance: pointer to adapter instance structure\n * @type: HCAM type\n *\n * Return value:\n *\t0 if success, error value in case of any failure.\n */\nstatic int pmcraid_notify_aen(\n\tstruct pmcraid_instance *pinstance,\n\tstruct pmcraid_aen_msg  *aen_msg,\n\tu32    data_size\n)\n{\n\tstruct sk_buff *skb;\n\tvoid *msg_header;\n\tu32  total_size, nla_genl_hdr_total_size;\n\tint result;\n\n\taen_msg->hostno = (pinstance->host->unique_id << 16 |\n\t\t\t   MINOR(pinstance->cdev.dev));\n\taen_msg->length = data_size;\n\n\tdata_size += sizeof(*aen_msg);\n\n\ttotal_size = nla_total_size(data_size);\n\t/* Add GENL_HDR to total_size */\n\tnla_genl_hdr_total_size =\n\t\t(total_size + (GENL_HDRLEN +\n\t\t((struct genl_family *)&pmcraid_event_family)->hdrsize)\n\t\t + NLMSG_HDRLEN);\n\tskb = genlmsg_new(nla_genl_hdr_total_size, GFP_ATOMIC);\n\n\n\tif (!skb) {\n\t\tpmcraid_err(\"Failed to allocate aen data SKB of size: %x\\n\",\n\t\t\t     total_size);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* add the genetlink message header */\n\tmsg_header = genlmsg_put(skb, 0, 0,\n\t\t\t\t &pmcraid_event_family, 0,\n\t\t\t\t PMCRAID_AEN_CMD_EVENT);\n\tif (!msg_header) {\n\t\tpmcraid_err(\"failed to copy command details\\n\");\n\t\tnlmsg_free(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tresult = nla_put(skb, PMCRAID_AEN_ATTR_EVENT, data_size, aen_msg);\n\n\tif (result) {\n\t\tpmcraid_err(\"failed to copy AEN attribute data\\n\");\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t/* send genetlink multicast message to notify appplications */\n\tresult = genlmsg_end(skb, msg_header);\n\n\tif (result < 0) {\n\t\tpmcraid_err(\"genlmsg_end failed\\n\");\n\t\tnlmsg_free(skb);\n\t\treturn result;\n\t}\n\n\tresult =\n\t\tgenlmsg_multicast(skb, 0, pmcraid_event_family.id, GFP_ATOMIC);\n\n\t/* If there are no listeners, genlmsg_multicast may return non-zero\n\t * value.\n\t */\n\tif (result)\n\t\tpmcraid_info(\"error (%x) sending aen event message\\n\", result);\n\treturn result;\n}\n\n/**\n * pmcraid_notify_ccn - notifies about CCN event msg to user space\n * @pinstance: pointer adapter instance structure\n *\n * Return value:\n *\t0 if success, error value in case of any failure\n */\nstatic int pmcraid_notify_ccn(struct pmcraid_instance *pinstance)\n{\n\treturn pmcraid_notify_aen(pinstance,\n\t\t\t\tpinstance->ccn.msg,\n\t\t\t\tpinstance->ccn.hcam->data_len +\n\t\t\t\tsizeof(struct pmcraid_hcam_hdr));\n}\n\n/**\n * pmcraid_notify_ldn - notifies about CCN event msg to user space\n * @pinstance: pointer adapter instance structure\n *\n * Return value:\n *\t0 if success, error value in case of any failure\n */\nstatic int pmcraid_notify_ldn(struct pmcraid_instance *pinstance)\n{\n\treturn pmcraid_notify_aen(pinstance,\n\t\t\t\tpinstance->ldn.msg,\n\t\t\t\tpinstance->ldn.hcam->data_len +\n\t\t\t\tsizeof(struct pmcraid_hcam_hdr));\n}\n\n/**\n * pmcraid_notify_ioastate - sends IOA state event msg to user space\n * @pinstance: pointer adapter instance structure\n * @evt: controller state event to be sent\n *\n * Return value:\n *\t0 if success, error value in case of any failure\n */\nstatic void pmcraid_notify_ioastate(struct pmcraid_instance *pinstance, u32 evt)\n{\n\tpinstance->scn.ioa_state = evt;\n\tpmcraid_notify_aen(pinstance,\n\t\t\t  &pinstance->scn.msg,\n\t\t\t  sizeof(u32));\n}\n\n/**\n * pmcraid_handle_config_change - Handle a config change from the adapter\n * @pinstance: pointer to per adapter instance structure\n *\n * Return value:\n *  none\n */\n\nstatic void pmcraid_handle_config_change(struct pmcraid_instance *pinstance)\n{\n\tstruct pmcraid_config_table_entry *cfg_entry;\n\tstruct pmcraid_hcam_ccn *ccn_hcam;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cfgcmd;\n\tstruct pmcraid_resource_entry *res = NULL;\n\tunsigned long lock_flags;\n\tunsigned long host_lock_flags;\n\tu32 new_entry = 1;\n\tu32 hidden_entry = 0;\n\tu16 fw_version;\n\tint rc;\n\n\tccn_hcam = (struct pmcraid_hcam_ccn *)pinstance->ccn.hcam;\n\tcfg_entry = &ccn_hcam->cfg_entry;\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\n\tpmcraid_info(\"CCN(%x): %x timestamp: %llx type: %x lost: %x flags: %x \\\n\t\t res: %x:%x:%x:%x\\n\",\n\t\t pinstance->ccn.hcam->ilid,\n\t\t pinstance->ccn.hcam->op_code,\n\t\t((pinstance->ccn.hcam->timestamp1) |\n\t\t((pinstance->ccn.hcam->timestamp2 & 0xffffffffLL) << 32)),\n\t\t pinstance->ccn.hcam->notification_type,\n\t\t pinstance->ccn.hcam->notification_lost,\n\t\t pinstance->ccn.hcam->flags,\n\t\t pinstance->host->unique_id,\n\t\t RES_IS_VSET(*cfg_entry) ? PMCRAID_VSET_BUS_ID :\n\t\t (RES_IS_GSCSI(*cfg_entry) ? PMCRAID_PHYS_BUS_ID :\n\t\t\tRES_BUS(cfg_entry->resource_address)),\n\t\t RES_IS_VSET(*cfg_entry) ?\n\t\t\t(fw_version <= PMCRAID_FW_VERSION_1 ?\n\t\t\t\tcfg_entry->unique_flags1 :\n\t\t\t\t\tcfg_entry->array_id & 0xFF) :\n\t\t\tRES_TARGET(cfg_entry->resource_address),\n\t\t RES_LUN(cfg_entry->resource_address));\n\n\n\t/* If this HCAM indicates a lost notification, read the config table */\n\tif (pinstance->ccn.hcam->notification_lost) {\n\t\tcfgcmd = pmcraid_get_free_cmd(pinstance);\n\t\tif (cfgcmd) {\n\t\t\tpmcraid_info(\"lost CCN, reading config table\\b\");\n\t\t\tpinstance->reinit_cfg_table = 1;\n\t\t\tpmcraid_querycfg(cfgcmd);\n\t\t} else {\n\t\t\tpmcraid_err(\"lost CCN, no free cmd for querycfg\\n\");\n\t\t}\n\t\tgoto out_notify_apps;\n\t}\n\n\t/* If this resource is not going to be added to mid-layer, just notify\n\t * applications and return. If this notification is about hiding a VSET\n\t * resource, check if it was exposed already.\n\t */\n\tif (pinstance->ccn.hcam->notification_type ==\n\t    NOTIFICATION_TYPE_ENTRY_CHANGED &&\n\t    cfg_entry->resource_type == RES_TYPE_VSET) {\n\n\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\thidden_entry = (cfg_entry->unique_flags1 & 0x80) != 0;\n\t\telse\n\t\t\thidden_entry = (cfg_entry->unique_flags1 & 0x80) != 0;\n\n\t} else if (!pmcraid_expose_resource(fw_version, cfg_entry)) {\n\t\tgoto out_notify_apps;\n\t}\n\n\tspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\n\tlist_for_each_entry(res, &pinstance->used_res_q, queue) {\n\t\trc = memcmp(&res->cfg_entry.resource_address,\n\t\t\t    &cfg_entry->resource_address,\n\t\t\t    sizeof(cfg_entry->resource_address));\n\t\tif (!rc) {\n\t\t\tnew_entry = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_entry) {\n\n\t\tif (hidden_entry) {\n\t\t\tspin_unlock_irqrestore(&pinstance->resource_lock,\n\t\t\t\t\t\tlock_flags);\n\t\t\tgoto out_notify_apps;\n\t\t}\n\n\t\t/* If there are more number of resources than what driver can\n\t\t * manage, do not notify the applications about the CCN. Just\n\t\t * ignore this notifications and re-register the same HCAM\n\t\t */\n\t\tif (list_empty(&pinstance->free_res_q)) {\n\t\t\tspin_unlock_irqrestore(&pinstance->resource_lock,\n\t\t\t\t\t\tlock_flags);\n\t\t\tpmcraid_err(\"too many resources attached\\n\");\n\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\t  host_lock_flags);\n\t\t\tpmcraid_send_hcam(pinstance,\n\t\t\t\t\t  PMCRAID_HCAM_CODE_CONFIG_CHANGE);\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       host_lock_flags);\n\t\t\treturn;\n\t\t}\n\n\t\tres = list_entry(pinstance->free_res_q.next,\n\t\t\t\t struct pmcraid_resource_entry, queue);\n\n\t\tlist_del(&res->queue);\n\t\tres->scsi_dev = NULL;\n\t\tres->reset_progress = 0;\n\t\tlist_add_tail(&res->queue, &pinstance->used_res_q);\n\t}\n\n\tmemcpy(&res->cfg_entry, cfg_entry, pinstance->config_table_entry_size);\n\n\tif (pinstance->ccn.hcam->notification_type ==\n\t    NOTIFICATION_TYPE_ENTRY_DELETED || hidden_entry) {\n\t\tif (res->scsi_dev) {\n\t\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\t\tres->cfg_entry.unique_flags1 &= 0x7F;\n\t\t\telse\n\t\t\t\tres->cfg_entry.array_id &= 0xFF;\n\t\t\tres->change_detected = RES_CHANGE_DEL;\n\t\t\tres->cfg_entry.resource_handle =\n\t\t\t\tPMCRAID_INVALID_RES_HANDLE;\n\t\t\tschedule_work(&pinstance->worker_q);\n\t\t} else {\n\t\t\t/* This may be one of the non-exposed resources */\n\t\t\tlist_move_tail(&res->queue, &pinstance->free_res_q);\n\t\t}\n\t} else if (!res->scsi_dev) {\n\t\tres->change_detected = RES_CHANGE_ADD;\n\t\tschedule_work(&pinstance->worker_q);\n\t}\n\tspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\n\nout_notify_apps:\n\n\t/* Notify configuration changes to registered applications.*/\n\tif (!pmcraid_disable_aen)\n\t\tpmcraid_notify_ccn(pinstance);\n\n\tcmd = pmcraid_init_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\n\tif (cmd)\n\t\tpmcraid_send_hcam_cmd(cmd);\n}\n\n/**\n * pmcraid_get_error_info - return error string for an ioasc\n * @ioasc: ioasc code\n * Return Value\n *\t none\n */\nstatic struct pmcraid_ioasc_error *pmcraid_get_error_info(u32 ioasc)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(pmcraid_ioasc_error_table); i++) {\n\t\tif (pmcraid_ioasc_error_table[i].ioasc_code == ioasc)\n\t\t\treturn &pmcraid_ioasc_error_table[i];\n\t}\n\treturn NULL;\n}\n\n/**\n * pmcraid_ioasc_logger - log IOASC information based user-settings\n * @ioasc: ioasc code\n * @cmd: pointer to command that resulted in 'ioasc'\n */\nvoid pmcraid_ioasc_logger(u32 ioasc, struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioasc_error *error_info = pmcraid_get_error_info(ioasc);\n\n\tif (error_info == NULL ||\n\t\tcmd->drv_inst->current_log_level < error_info->log_level)\n\t\treturn;\n\n\t/* log the error string */\n\tpmcraid_err(\"cmd [%x] for resource %x failed with %x(%s)\\n\",\n\t\tcmd->ioa_cb->ioarcb.cdb[0],\n\t\tcmd->ioa_cb->ioarcb.resource_handle,\n\t\tle32_to_cpu(ioasc), error_info->error_string);\n}\n\n/**\n * pmcraid_handle_error_log - Handle a config change (error log) from the IOA\n *\n * @pinstance: pointer to per adapter instance structure\n *\n * Return value:\n *  none\n */\nstatic void pmcraid_handle_error_log(struct pmcraid_instance *pinstance)\n{\n\tstruct pmcraid_hcam_ldn *hcam_ldn;\n\tu32 ioasc;\n\n\thcam_ldn = (struct pmcraid_hcam_ldn *)pinstance->ldn.hcam;\n\n\tpmcraid_info\n\t\t(\"LDN(%x): %x type: %x lost: %x flags: %x overlay id: %x\\n\",\n\t\t pinstance->ldn.hcam->ilid,\n\t\t pinstance->ldn.hcam->op_code,\n\t\t pinstance->ldn.hcam->notification_type,\n\t\t pinstance->ldn.hcam->notification_lost,\n\t\t pinstance->ldn.hcam->flags,\n\t\t pinstance->ldn.hcam->overlay_id);\n\n\t/* log only the errors, no need to log informational log entries */\n\tif (pinstance->ldn.hcam->notification_type !=\n\t    NOTIFICATION_TYPE_ERROR_LOG)\n\t\treturn;\n\n\tif (pinstance->ldn.hcam->notification_lost ==\n\t    HOSTRCB_NOTIFICATIONS_LOST)\n\t\tdev_info(&pinstance->pdev->dev, \"Error notifications lost\\n\");\n\n\tioasc = le32_to_cpu(hcam_ldn->error_log.fd_ioasc);\n\n\tif (ioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET ||\n\t\tioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET_BY_OTHER) {\n\t\tdev_info(&pinstance->pdev->dev,\n\t\t\t\"UnitAttention due to IOA Bus Reset\\n\");\n\t\tscsi_report_bus_reset(\n\t\t\tpinstance->host,\n\t\t\tRES_BUS(hcam_ldn->error_log.fd_ra));\n\t}\n\n\treturn;\n}\n\n/**\n * pmcraid_process_ccn - Op done function for a CCN.\n * @cmd: pointer to command struct\n *\n * This function is the op done function for a configuration\n * change notification\n *\n * Return value:\n * none\n */\nstatic void pmcraid_process_ccn(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\tunsigned long lock_flags;\n\n\tpinstance->ccn.cmd = NULL;\n\tpmcraid_return_cmd(cmd);\n\n\t/* If driver initiated IOA reset happened while this hcam was pending\n\t * with IOA, or IOA bringdown sequence is in progress, no need to\n\t * re-register the hcam\n\t */\n\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t    atomic_read(&pinstance->ccn.ignore) == 1) {\n\t\treturn;\n\t} else if (ioasc) {\n\t\tdev_info(&pinstance->pdev->dev,\n\t\t\t\"Host RCB (CCN) failed with IOASC: 0x%08X\\n\", ioasc);\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t} else {\n\t\tpmcraid_handle_config_change(pinstance);\n\t}\n}\n\n/**\n * pmcraid_process_ldn - op done function for an LDN\n * @cmd: pointer to command block\n *\n * Return value\n *   none\n */\nstatic void pmcraid_initiate_reset(struct pmcraid_instance *);\nstatic void pmcraid_set_timestamp(struct pmcraid_cmd *cmd);\n\nstatic void pmcraid_process_ldn(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_hcam_ldn *ldn_hcam =\n\t\t\t(struct pmcraid_hcam_ldn *)pinstance->ldn.hcam;\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\tu32 fd_ioasc = le32_to_cpu(ldn_hcam->error_log.fd_ioasc);\n\tunsigned long lock_flags;\n\n\t/* return the command block back to freepool */\n\tpinstance->ldn.cmd = NULL;\n\tpmcraid_return_cmd(cmd);\n\n\t/* If driver initiated IOA reset happened while this hcam was pending\n\t * with IOA, no need to re-register the hcam as reset engine will do it\n\t * once reset sequence is complete\n\t */\n\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t    atomic_read(&pinstance->ccn.ignore) == 1) {\n\t\treturn;\n\t} else if (!ioasc) {\n\t\tpmcraid_handle_error_log(pinstance);\n\t\tif (fd_ioasc == PMCRAID_IOASC_NR_IOA_RESET_REQUIRED) {\n\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\t  lock_flags);\n\t\t\tpmcraid_initiate_reset(pinstance);\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\treturn;\n\t\t}\n\t\tif (fd_ioasc == PMCRAID_IOASC_TIME_STAMP_OUT_OF_SYNC) {\n\t\t\tpinstance->timestamp_error = 1;\n\t\t\tpmcraid_set_timestamp(cmd);\n\t\t}\n\t} else {\n\t\tdev_info(&pinstance->pdev->dev,\n\t\t\t\"Host RCB(LDN) failed with IOASC: 0x%08X\\n\", ioasc);\n\t}\n\t/* send netlink message for HCAM notification if enabled */\n\tif (!pmcraid_disable_aen)\n\t\tpmcraid_notify_ldn(pinstance);\n\n\tcmd = pmcraid_init_hcam(pinstance, PMCRAID_HCAM_CODE_LOG_DATA);\n\tif (cmd)\n\t\tpmcraid_send_hcam_cmd(cmd);\n}\n\n/**\n * pmcraid_register_hcams - register HCAMs for CCN and LDN\n *\n * @pinstance: pointer per adapter instance structure\n *\n * Return Value\n *   none\n */\nstatic void pmcraid_register_hcams(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\n\tpmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_LOG_DATA);\n}\n\n/**\n * pmcraid_unregister_hcams - cancel HCAMs registered already\n * @cmd: pointer to command used as part of reset sequence\n */\nstatic void pmcraid_unregister_hcams(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\n\t/* During IOA bringdown, HCAM gets fired and tasklet proceeds with\n\t * handling hcam response though it is not necessary. In order to\n\t * prevent this, set 'ignore', so that bring-down sequence doesn't\n\t * re-send any more hcams\n\t */\n\tatomic_set(&pinstance->ccn.ignore, 1);\n\tatomic_set(&pinstance->ldn.ignore, 1);\n\n\t/* If adapter reset was forced as part of runtime reset sequence,\n\t * start the reset sequence. Reset will be triggered even in case\n\t * IOA unit_check.\n\t */\n\tif ((pinstance->force_ioa_reset && !pinstance->ioa_bringdown) ||\n\t     pinstance->ioa_unit_check) {\n\t\tpinstance->force_ioa_reset = 0;\n\t\tpinstance->ioa_unit_check = 0;\n\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\tpmcraid_reset_alert(cmd);\n\t\treturn;\n\t}\n\n\t/* Driver tries to cancel HCAMs by sending ABORT TASK for each HCAM\n\t * one after the other. So CCN cancellation will be triggered by\n\t * pmcraid_cancel_ldn itself.\n\t */\n\tpmcraid_cancel_ldn(cmd);\n}\n\n/**\n * pmcraid_reset_enable_ioa - re-enable IOA after a hard reset\n * @pinstance: pointer to adapter instance structure\n * Return Value\n *  1 if TRANSITION_TO_OPERATIONAL is active, otherwise 0\n */\nstatic void pmcraid_reinit_buffers(struct pmcraid_instance *);\n\nstatic int pmcraid_reset_enable_ioa(struct pmcraid_instance *pinstance)\n{\n\tu32 intrs;\n\n\tpmcraid_reinit_buffers(pinstance);\n\tintrs = pmcraid_read_interrupts(pinstance);\n\n\tpmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\n\n\tif (intrs & INTRS_TRANSITION_TO_OPERATIONAL) {\n\t\tif (!pinstance->interrupt_mode) {\n\t\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\t\tpinstance->int_regs.\n\t\t\t\tioa_host_interrupt_mask_reg);\n\t\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/**\n * pmcraid_soft_reset - performs a soft reset and makes IOA become ready\n * @cmd : pointer to reset command block\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_soft_reset(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu32 int_reg;\n\tu32 doorbell;\n\n\t/* There will be an interrupt when Transition to Operational bit is\n\t * set so tasklet would execute next reset task. The timeout handler\n\t * would re-initiate a reset\n\t */\n\tcmd->cmd_done = pmcraid_ioa_reset;\n\tcmd->timer.data = (unsigned long)cmd;\n\tcmd->timer.expires = jiffies +\n\t\t\t     msecs_to_jiffies(PMCRAID_TRANSOP_TIMEOUT);\n\tcmd->timer.function = (void (*)(unsigned long))pmcraid_timeout_handler;\n\n\tif (!timer_pending(&cmd->timer))\n\t\tadd_timer(&cmd->timer);\n\n\t/* Enable destructive diagnostics on IOA if it is not yet in\n\t * operational state\n\t */\n\tdoorbell = DOORBELL_RUNTIME_RESET |\n\t\t   DOORBELL_ENABLE_DESTRUCTIVE_DIAGS;\n\n\t/* Since we do RESET_ALERT and Start BIST we have to again write\n\t * MSIX Doorbell to indicate the interrupt mode\n\t */\n\tif (pinstance->interrupt_mode) {\n\t\tiowrite32(DOORBELL_INTR_MODE_MSIX,\n\t\t\t  pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\t}\n\n\tiowrite32(doorbell, pinstance->int_regs.host_ioa_interrupt_reg);\n\tioread32(pinstance->int_regs.host_ioa_interrupt_reg),\n\tint_reg = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\n\n\tpmcraid_info(\"Waiting for IOA to become operational %x:%x\\n\",\n\t\t     ioread32(pinstance->int_regs.host_ioa_interrupt_reg),\n\t\t     int_reg);\n}\n\n/**\n * pmcraid_get_dump - retrieves IOA dump in case of Unit Check interrupt\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_get_dump(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_info(\"%s is not yet implemented\\n\", __func__);\n}\n\n/**\n * pmcraid_fail_outstanding_cmds - Fails all outstanding ops.\n * @pinstance: pointer to adapter instance structure\n *\n * This function fails all outstanding ops. If they are submitted to IOA\n * already, it sends cancel all messages if IOA is still accepting IOARCBs,\n * otherwise just completes the commands and returns the cmd blocks to free\n * pool.\n *\n * Return value:\n *\t none\n */\nstatic void pmcraid_fail_outstanding_cmds(struct pmcraid_instance *pinstance)\n{\n\tstruct pmcraid_cmd *cmd, *temp;\n\tunsigned long lock_flags;\n\n\t/* pending command list is protected by pending_pool_lock. Its\n\t * traversal must be done as within this lock\n\t */\n\tspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\n\tlist_for_each_entry_safe(cmd, temp, &pinstance->pending_cmd_pool,\n\t\t\t\t free_list) {\n\t\tlist_del(&cmd->free_list);\n\t\tspin_unlock_irqrestore(&pinstance->pending_pool_lock,\n\t\t\t\t\tlock_flags);\n\t\tcmd->ioa_cb->ioasa.ioasc =\n\t\t\tcpu_to_le32(PMCRAID_IOASC_IOA_WAS_RESET);\n\t\tcmd->ioa_cb->ioasa.ilid =\n\t\t\tcpu_to_be32(PMCRAID_DRIVER_ILID);\n\n\t\t/* In case the command timer is still running */\n\t\tdel_timer(&cmd->timer);\n\n\t\t/* If this is an IO command, complete it by invoking scsi_done\n\t\t * function. If this is one of the internal commands other\n\t\t * than pmcraid_ioa_reset and HCAM commands invoke cmd_done to\n\t\t * complete it\n\t\t */\n\t\tif (cmd->scsi_cmd) {\n\n\t\t\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\t\t\t__le32 resp = cmd->ioa_cb->ioarcb.response_handle;\n\n\t\t\tscsi_cmd->result |= DID_ERROR << 16;\n\n\t\t\tscsi_dma_unmap(scsi_cmd);\n\t\t\tpmcraid_return_cmd(cmd);\n\n\t\t\tpmcraid_info(\"failing(%d) CDB[0] = %x result: %x\\n\",\n\t\t\t\t     le32_to_cpu(resp) >> 2,\n\t\t\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t\t\t     scsi_cmd->result);\n\t\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t\t} else if (cmd->cmd_done == pmcraid_internal_done ||\n\t\t\t   cmd->cmd_done == pmcraid_erp_done) {\n\t\t\tcmd->cmd_done(cmd);\n\t\t} else if (cmd->cmd_done != pmcraid_ioa_reset &&\n\t\t\t   cmd->cmd_done != pmcraid_ioa_shutdown_done) {\n\t\t\tpmcraid_return_cmd(cmd);\n\t\t}\n\n\t\tatomic_dec(&pinstance->outstanding_cmds);\n\t\tspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\n\t}\n\n\tspin_unlock_irqrestore(&pinstance->pending_pool_lock, lock_flags);\n}\n\n/**\n * pmcraid_ioa_reset - Implementation of IOA reset logic\n *\n * @cmd: pointer to the cmd block to be used for entire reset process\n *\n * This function executes most of the steps required for IOA reset. This gets\n * called by user threads (modprobe/insmod/rmmod) timer, tasklet and midlayer's\n * 'eh_' thread. Access to variables used for controlling the reset sequence is\n * synchronized using host lock. Various functions called during reset process\n * would make use of a single command block, pointer to which is also stored in\n * adapter instance structure.\n *\n * Return Value\n *\t None\n */\nstatic void pmcraid_ioa_reset(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu8 reset_complete = 0;\n\n\tpinstance->ioa_reset_in_progress = 1;\n\n\tif (pinstance->reset_cmd != cmd) {\n\t\tpmcraid_err(\"reset is called with different command block\\n\");\n\t\tpinstance->reset_cmd = cmd;\n\t}\n\n\tpmcraid_info(\"reset_engine: state = %d, command = %p\\n\",\n\t\t      pinstance->ioa_state, cmd);\n\n\tswitch (pinstance->ioa_state) {\n\n\tcase IOA_STATE_DEAD:\n\t\t/* If IOA is offline, whatever may be the reset reason, just\n\t\t * return. callers might be waiting on the reset wait_q, wake\n\t\t * up them\n\t\t */\n\t\tpmcraid_err(\"IOA is offline no reset is possible\\n\");\n\t\treset_complete = 1;\n\t\tbreak;\n\n\tcase IOA_STATE_IN_BRINGDOWN:\n\t\t/* we enter here, once ioa shutdown command is processed by IOA\n\t\t * Alert IOA for a possible reset. If reset alert fails, IOA\n\t\t * goes through hard-reset\n\t\t */\n\t\tpmcraid_disable_interrupts(pinstance, ~0);\n\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\tpmcraid_reset_alert(cmd);\n\t\tbreak;\n\n\tcase IOA_STATE_UNKNOWN:\n\t\t/* We may be called during probe or resume. Some pre-processing\n\t\t * is required for prior to reset\n\t\t */\n\t\tscsi_block_requests(pinstance->host);\n\n\t\t/* If asked to reset while IOA was processing responses or\n\t\t * there are any error responses then IOA may require\n\t\t * hard-reset.\n\t\t */\n\t\tif (pinstance->ioa_hard_reset == 0) {\n\t\t\tif (ioread32(pinstance->ioa_status) &\n\t\t\t    INTRS_TRANSITION_TO_OPERATIONAL) {\n\t\t\t\tpmcraid_info(\"sticky bit set, bring-up\\n\");\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_BRINGUP;\n\t\t\t\tpmcraid_reinit_cmdblk(cmd);\n\t\t\t\tpmcraid_identify_hrrq(cmd);\n\t\t\t} else {\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_SOFT_RESET;\n\t\t\t\tpmcraid_soft_reset(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Alert IOA of a possible reset and wait for critical\n\t\t\t * operation in progress bit to reset\n\t\t\t */\n\t\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\t\tpmcraid_reset_alert(cmd);\n\t\t}\n\t\tbreak;\n\n\tcase IOA_STATE_IN_RESET_ALERT:\n\t\t/* If critical operation in progress bit is reset or wait gets\n\t\t * timed out, reset proceeds with starting BIST on the IOA.\n\t\t * pmcraid_ioa_hard_reset keeps a count of reset attempts. If\n\t\t * they are 3 or more, reset engine marks IOA dead and returns\n\t\t */\n\t\tpinstance->ioa_state = IOA_STATE_IN_HARD_RESET;\n\t\tpmcraid_start_bist(cmd);\n\t\tbreak;\n\n\tcase IOA_STATE_IN_HARD_RESET:\n\t\tpinstance->ioa_reset_attempts++;\n\n\t\t/* retry reset if we haven't reached maximum allowed limit */\n\t\tif (pinstance->ioa_reset_attempts > PMCRAID_RESET_ATTEMPTS) {\n\t\t\tpinstance->ioa_reset_attempts = 0;\n\t\t\tpmcraid_err(\"IOA didn't respond marking it as dead\\n\");\n\t\t\tpinstance->ioa_state = IOA_STATE_DEAD;\n\n\t\t\tif (pinstance->ioa_bringdown)\n\t\t\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\tPMC_DEVICE_EVENT_SHUTDOWN_FAILED);\n\t\t\telse\n\t\t\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\t\tPMC_DEVICE_EVENT_RESET_FAILED);\n\t\t\treset_complete = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Once either bist or pci reset is done, restore PCI config\n\t\t * space. If this fails, proceed with hard reset again\n\t\t */\n\t\tpci_restore_state(pinstance->pdev);\n\n\t\t/* fail all pending commands */\n\t\tpmcraid_fail_outstanding_cmds(pinstance);\n\n\t\t/* check if unit check is active, if so extract dump */\n\t\tif (pinstance->ioa_unit_check) {\n\t\t\tpmcraid_info(\"unit check is active\\n\");\n\t\t\tpinstance->ioa_unit_check = 0;\n\t\t\tpmcraid_get_dump(pinstance);\n\t\t\tpinstance->ioa_reset_attempts--;\n\t\t\tpinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\n\t\t\tpmcraid_reset_alert(cmd);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if the reset reason is to bring-down the ioa, we might be\n\t\t * done with the reset restore pci_config_space and complete\n\t\t * the reset\n\t\t */\n\t\tif (pinstance->ioa_bringdown) {\n\t\t\tpmcraid_info(\"bringing down the adapter\\n\");\n\t\t\tpinstance->ioa_shutdown_type = SHUTDOWN_NONE;\n\t\t\tpinstance->ioa_bringdown = 0;\n\t\t\tpinstance->ioa_state = IOA_STATE_UNKNOWN;\n\t\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\tPMC_DEVICE_EVENT_SHUTDOWN_SUCCESS);\n\t\t\treset_complete = 1;\n\t\t} else {\n\t\t\t/* bring-up IOA, so proceed with soft reset\n\t\t\t * Reinitialize hrrq_buffers and their indices also\n\t\t\t * enable interrupts after a pci_restore_state\n\t\t\t */\n\t\t\tif (pmcraid_reset_enable_ioa(pinstance)) {\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_BRINGUP;\n\t\t\t\tpmcraid_info(\"bringing up the adapter\\n\");\n\t\t\t\tpmcraid_reinit_cmdblk(cmd);\n\t\t\t\tpmcraid_identify_hrrq(cmd);\n\t\t\t} else {\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_SOFT_RESET;\n\t\t\t\tpmcraid_soft_reset(cmd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOA_STATE_IN_SOFT_RESET:\n\t\t/* TRANSITION TO OPERATIONAL is on so start initialization\n\t\t * sequence\n\t\t */\n\t\tpmcraid_info(\"In softreset proceeding with bring-up\\n\");\n\t\tpinstance->ioa_state = IOA_STATE_IN_BRINGUP;\n\n\t\t/* Initialization commands start with HRRQ identification. From\n\t\t * now on tasklet completes most of the commands as IOA is up\n\t\t * and intrs are enabled\n\t\t */\n\t\tpmcraid_identify_hrrq(cmd);\n\t\tbreak;\n\n\tcase IOA_STATE_IN_BRINGUP:\n\t\t/* we are done with bringing up of IOA, change the ioa_state to\n\t\t * operational and wake up any waiters\n\t\t */\n\t\tpinstance->ioa_state = IOA_STATE_OPERATIONAL;\n\t\treset_complete = 1;\n\t\tbreak;\n\n\tcase IOA_STATE_OPERATIONAL:\n\tdefault:\n\t\t/* When IOA is operational and a reset is requested, check for\n\t\t * the reset reason. If reset is to bring down IOA, unregister\n\t\t * HCAMs and initiate shutdown; if adapter reset is forced then\n\t\t * restart reset sequence again\n\t\t */\n\t\tif (pinstance->ioa_shutdown_type == SHUTDOWN_NONE &&\n\t\t    pinstance->force_ioa_reset == 0) {\n\t\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\t\tPMC_DEVICE_EVENT_RESET_SUCCESS);\n\t\t\treset_complete = 1;\n\t\t} else {\n\t\t\tif (pinstance->ioa_shutdown_type != SHUTDOWN_NONE)\n\t\t\t\tpinstance->ioa_state = IOA_STATE_IN_BRINGDOWN;\n\t\t\tpmcraid_reinit_cmdblk(cmd);\n\t\t\tpmcraid_unregister_hcams(cmd);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* reset will be completed if ioa_state is either DEAD or UNKNOWN or\n\t * OPERATIONAL. Reset all control variables used during reset, wake up\n\t * any waiting threads and let the SCSI mid-layer send commands. Note\n\t * that host_lock must be held before invoking scsi_report_bus_reset.\n\t */\n\tif (reset_complete) {\n\t\tpinstance->ioa_reset_in_progress = 0;\n\t\tpinstance->ioa_reset_attempts = 0;\n\t\tpinstance->reset_cmd = NULL;\n\t\tpinstance->ioa_shutdown_type = SHUTDOWN_NONE;\n\t\tpinstance->ioa_bringdown = 0;\n\t\tpmcraid_return_cmd(cmd);\n\n\t\t/* If target state is to bring up the adapter, proceed with\n\t\t * hcam registration and resource exposure to mid-layer.\n\t\t */\n\t\tif (pinstance->ioa_state == IOA_STATE_OPERATIONAL)\n\t\t\tpmcraid_register_hcams(pinstance);\n\n\t\twake_up_all(&pinstance->reset_wait_q);\n\t}\n\n\treturn;\n}\n\n/**\n * pmcraid_initiate_reset - initiates reset sequence. This is called from\n * ISR/tasklet during error interrupts including IOA unit check. If reset\n * is already in progress, it just returns, otherwise initiates IOA reset\n * to bring IOA up to operational state.\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return value\n *\t none\n */\nstatic void pmcraid_initiate_reset(struct pmcraid_instance *pinstance)\n{\n\tstruct pmcraid_cmd *cmd;\n\n\t/* If the reset is already in progress, just return, otherwise start\n\t * reset sequence and return\n\t */\n\tif (!pinstance->ioa_reset_in_progress) {\n\t\tscsi_block_requests(pinstance->host);\n\t\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\t\tif (cmd == NULL) {\n\t\t\tpmcraid_err(\"no cmnd blocks for initiate_reset\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tpinstance->ioa_shutdown_type = SHUTDOWN_NONE;\n\t\tpinstance->reset_cmd = cmd;\n\t\tpinstance->force_ioa_reset = 1;\n\t\tpmcraid_notify_ioastate(pinstance,\n\t\t\t\t\tPMC_DEVICE_EVENT_RESET_START);\n\t\tpmcraid_ioa_reset(cmd);\n\t}\n}\n\n/**\n * pmcraid_reset_reload - utility routine for doing IOA reset either to bringup\n *\t\t\t  or bringdown IOA\n * @pinstance: pointer adapter instance structure\n * @shutdown_type: shutdown type to be used NONE, NORMAL or ABRREV\n * @target_state: expected target state after reset\n *\n * Note: This command initiates reset and waits for its completion. Hence this\n * should not be called from isr/timer/tasklet functions (timeout handlers,\n * error response handlers and interrupt handlers).\n *\n * Return Value\n *\t 1 in case ioa_state is not target_state, 0 otherwise.\n */\nstatic int pmcraid_reset_reload(\n\tstruct pmcraid_instance *pinstance,\n\tu8 shutdown_type,\n\tu8 target_state\n)\n{\n\tstruct pmcraid_cmd *reset_cmd = NULL;\n\tunsigned long lock_flags;\n\tint reset = 1;\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\n\tif (pinstance->ioa_reset_in_progress) {\n\t\tpmcraid_info(\"reset_reload: reset is already in progress\\n\");\n\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\twait_event(pinstance->reset_wait_q,\n\t\t\t   !pinstance->ioa_reset_in_progress);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\n\t\tif (pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\tpmcraid_info(\"reset_reload: IOA is dead\\n\");\n\t\t\treturn reset;\n\t\t} else if (pinstance->ioa_state == target_state) {\n\t\t\treset = 0;\n\t\t}\n\t}\n\n\tif (reset) {\n\t\tpmcraid_info(\"reset_reload: proceeding with reset\\n\");\n\t\tscsi_block_requests(pinstance->host);\n\t\treset_cmd = pmcraid_get_free_cmd(pinstance);\n\n\t\tif (reset_cmd == NULL) {\n\t\t\tpmcraid_err(\"no free cmnd for reset_reload\\n\");\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\treturn reset;\n\t\t}\n\n\t\tif (shutdown_type == SHUTDOWN_NORMAL)\n\t\t\tpinstance->ioa_bringdown = 1;\n\n\t\tpinstance->ioa_shutdown_type = shutdown_type;\n\t\tpinstance->reset_cmd = reset_cmd;\n\t\tpinstance->force_ioa_reset = reset;\n\t\tpmcraid_info(\"reset_reload: initiating reset\\n\");\n\t\tpmcraid_ioa_reset(reset_cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_info(\"reset_reload: waiting for reset to complete\\n\");\n\t\twait_event(pinstance->reset_wait_q,\n\t\t\t   !pinstance->ioa_reset_in_progress);\n\n\t\tpmcraid_info(\"reset_reload: reset is complete !!\\n\");\n\t\tscsi_unblock_requests(pinstance->host);\n\t\tif (pinstance->ioa_state == target_state)\n\t\t\treset = 0;\n\t}\n\n\treturn reset;\n}\n\n/**\n * pmcraid_reset_bringdown - wrapper over pmcraid_reset_reload to bringdown IOA\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return Value\n *\t whatever is returned from pmcraid_reset_reload\n */\nstatic int pmcraid_reset_bringdown(struct pmcraid_instance *pinstance)\n{\n\treturn pmcraid_reset_reload(pinstance,\n\t\t\t\t    SHUTDOWN_NORMAL,\n\t\t\t\t    IOA_STATE_UNKNOWN);\n}\n\n/**\n * pmcraid_reset_bringup - wrapper over pmcraid_reset_reload to bring up IOA\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return Value\n *\t whatever is returned from pmcraid_reset_reload\n */\nstatic int pmcraid_reset_bringup(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_notify_ioastate(pinstance, PMC_DEVICE_EVENT_RESET_START);\n\n\treturn pmcraid_reset_reload(pinstance,\n\t\t\t\t    SHUTDOWN_NONE,\n\t\t\t\t    IOA_STATE_OPERATIONAL);\n}\n\n/**\n * pmcraid_request_sense - Send request sense to a device\n * @cmd: pmcraid command struct\n *\n * This function sends a request sense to a device as a result of a check\n * condition. This method re-uses the same command block that failed earlier.\n */\nstatic void pmcraid_request_sense(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\n\t/* allocate DMAable memory for sense buffers */\n\tcmd->sense_buffer = pci_alloc_consistent(cmd->drv_inst->pdev,\n\t\t\t\t\t\t SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t\t &cmd->sense_buffer_dma);\n\n\tif (cmd->sense_buffer == NULL) {\n\t\tpmcraid_err\n\t\t\t(\"couldn't allocate sense buffer for request sense\\n\");\n\t\tpmcraid_erp_done(cmd);\n\t\treturn;\n\t}\n\n\t/* re-use the command block */\n\tmemset(&cmd->ioa_cb->ioasa, 0, sizeof(struct pmcraid_ioasa));\n\tmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\n\tioarcb->request_flags0 = (SYNC_COMPLETE |\n\t\t\t\t  NO_LINK_DESCS |\n\t\t\t\t  INHIBIT_UL_CHECK);\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\tioarcb->cdb[0] = REQUEST_SENSE;\n\tioarcb->cdb[4] = SCSI_SENSE_BUFFERSIZE;\n\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\n\tioarcb->data_transfer_length = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);\n\n\tioadl->address = cpu_to_le64(cmd->sense_buffer_dma);\n\tioadl->data_len = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\n\t/* request sense might be called as part of error response processing\n\t * which runs in tasklets context. It is possible that mid-layer might\n\t * schedule queuecommand during this time, hence, writting to IOARRIN\n\t * must be protect by host_lock\n\t */\n\tpmcraid_send_cmd(cmd, pmcraid_erp_done,\n\t\t\t PMCRAID_REQUEST_SENSE_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_cancel_all - cancel all outstanding IOARCBs as part of error recovery\n * @cmd: command that failed\n * @sense: true if request_sense is required after cancel all\n *\n * This function sends a cancel all to a device to clear the queue.\n */\nstatic void pmcraid_cancel_all(struct pmcraid_cmd *cmd, u32 sense)\n{\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_resource_entry *res = scsi_cmd->device->hostdata;\n\tvoid (*cmd_done) (struct pmcraid_cmd *) = sense ? pmcraid_erp_done\n\t\t\t\t\t\t\t: pmcraid_request_sense;\n\n\tmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\n\tioarcb->request_flags0 = SYNC_OVERRIDE;\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->cdb[0] = PMCRAID_CANCEL_ALL_REQUESTS;\n\n\tif (RES_IS_GSCSI(res->cfg_entry))\n\t\tioarcb->cdb[1] = PMCRAID_SYNC_COMPLETE_AFTER_CANCEL;\n\n\tioarcb->ioadl_bus_addr = 0;\n\tioarcb->ioadl_length = 0;\n\tioarcb->data_transfer_length = 0;\n\tioarcb->ioarcb_bus_addr &= (~0x1FULL);\n\n\t/* writing to IOARRIN must be protected by host_lock, as mid-layer\n\t * schedule queuecommand while we are doing this\n\t */\n\tpmcraid_send_cmd(cmd, cmd_done,\n\t\t\t PMCRAID_REQUEST_SENSE_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n}\n\n/**\n * pmcraid_frame_auto_sense: frame fixed format sense information\n *\n * @cmd: pointer to failing command block\n *\n * Return value\n *  none\n */\nstatic void pmcraid_frame_auto_sense(struct pmcraid_cmd *cmd)\n{\n\tu8 *sense_buf = cmd->scsi_cmd->sense_buffer;\n\tstruct pmcraid_resource_entry *res = cmd->scsi_cmd->device->hostdata;\n\tstruct pmcraid_ioasa *ioasa = &cmd->ioa_cb->ioasa;\n\tu32 ioasc = le32_to_cpu(ioasa->ioasc);\n\tu32 failing_lba = 0;\n\n\tmemset(sense_buf, 0, SCSI_SENSE_BUFFERSIZE);\n\tcmd->scsi_cmd->result = SAM_STAT_CHECK_CONDITION;\n\n\tif (RES_IS_VSET(res->cfg_entry) &&\n\t    ioasc == PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC &&\n\t    ioasa->u.vset.failing_lba_hi != 0) {\n\n\t\tsense_buf[0] = 0x72;\n\t\tsense_buf[1] = PMCRAID_IOASC_SENSE_KEY(ioasc);\n\t\tsense_buf[2] = PMCRAID_IOASC_SENSE_CODE(ioasc);\n\t\tsense_buf[3] = PMCRAID_IOASC_SENSE_QUAL(ioasc);\n\n\t\tsense_buf[7] = 12;\n\t\tsense_buf[8] = 0;\n\t\tsense_buf[9] = 0x0A;\n\t\tsense_buf[10] = 0x80;\n\n\t\tfailing_lba = le32_to_cpu(ioasa->u.vset.failing_lba_hi);\n\n\t\tsense_buf[12] = (failing_lba & 0xff000000) >> 24;\n\t\tsense_buf[13] = (failing_lba & 0x00ff0000) >> 16;\n\t\tsense_buf[14] = (failing_lba & 0x0000ff00) >> 8;\n\t\tsense_buf[15] = failing_lba & 0x000000ff;\n\n\t\tfailing_lba = le32_to_cpu(ioasa->u.vset.failing_lba_lo);\n\n\t\tsense_buf[16] = (failing_lba & 0xff000000) >> 24;\n\t\tsense_buf[17] = (failing_lba & 0x00ff0000) >> 16;\n\t\tsense_buf[18] = (failing_lba & 0x0000ff00) >> 8;\n\t\tsense_buf[19] = failing_lba & 0x000000ff;\n\t} else {\n\t\tsense_buf[0] = 0x70;\n\t\tsense_buf[2] = PMCRAID_IOASC_SENSE_KEY(ioasc);\n\t\tsense_buf[12] = PMCRAID_IOASC_SENSE_CODE(ioasc);\n\t\tsense_buf[13] = PMCRAID_IOASC_SENSE_QUAL(ioasc);\n\n\t\tif (ioasc == PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC) {\n\t\t\tif (RES_IS_VSET(res->cfg_entry))\n\t\t\t\tfailing_lba =\n\t\t\t\t\tle32_to_cpu(ioasa->u.\n\t\t\t\t\t\t vset.failing_lba_lo);\n\t\t\tsense_buf[0] |= 0x80;\n\t\t\tsense_buf[3] = (failing_lba >> 24) & 0xff;\n\t\t\tsense_buf[4] = (failing_lba >> 16) & 0xff;\n\t\t\tsense_buf[5] = (failing_lba >> 8) & 0xff;\n\t\t\tsense_buf[6] = failing_lba & 0xff;\n\t\t}\n\n\t\tsense_buf[7] = 6; /* additional length */\n\t}\n}\n\n/**\n * pmcraid_error_handler - Error response handlers for a SCSI op\n * @cmd: pointer to pmcraid_cmd that has failed\n *\n * This function determines whether or not to initiate ERP on the affected\n * device. This is called from a tasklet, which doesn't hold any locks.\n *\n * Return value:\n *\t 0 it caller can complete the request, otherwise 1 where in error\n *\t handler itself completes the request and returns the command block\n *\t back to free-pool\n */\nstatic int pmcraid_error_handler(struct pmcraid_cmd *cmd)\n{\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_resource_entry *res = scsi_cmd->device->hostdata;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_ioasa *ioasa = &cmd->ioa_cb->ioasa;\n\tu32 ioasc = le32_to_cpu(ioasa->ioasc);\n\tu32 masked_ioasc = ioasc & PMCRAID_IOASC_SENSE_MASK;\n\tu32 sense_copied = 0;\n\n\tif (!res) {\n\t\tpmcraid_info(\"resource pointer is NULL\\n\");\n\t\treturn 0;\n\t}\n\n\t/* If this was a SCSI read/write command keep count of errors */\n\tif (SCSI_CMD_TYPE(scsi_cmd->cmnd[0]) == SCSI_READ_CMD)\n\t\tatomic_inc(&res->read_failures);\n\telse if (SCSI_CMD_TYPE(scsi_cmd->cmnd[0]) == SCSI_WRITE_CMD)\n\t\tatomic_inc(&res->write_failures);\n\n\tif (!RES_IS_GSCSI(res->cfg_entry) &&\n\t\tmasked_ioasc != PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR) {\n\t\tpmcraid_frame_auto_sense(cmd);\n\t}\n\n\t/* Log IOASC/IOASA information based on user settings */\n\tpmcraid_ioasc_logger(ioasc, cmd);\n\n\tswitch (masked_ioasc) {\n\n\tcase PMCRAID_IOASC_AC_TERMINATED_BY_HOST:\n\t\tscsi_cmd->result |= (DID_ABORT << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_IR_INVALID_RESOURCE_HANDLE:\n\tcase PMCRAID_IOASC_HW_CANNOT_COMMUNICATE:\n\t\tscsi_cmd->result |= (DID_NO_CONNECT << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_NR_SYNC_REQUIRED:\n\t\tres->sync_reqd = 1;\n\t\tscsi_cmd->result |= (DID_IMM_RETRY << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC:\n\t\tscsi_cmd->result |= (DID_PASSTHROUGH << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_UA_BUS_WAS_RESET:\n\tcase PMCRAID_IOASC_UA_BUS_WAS_RESET_BY_OTHER:\n\t\tif (!res->reset_progress)\n\t\t\tscsi_report_bus_reset(pinstance->host,\n\t\t\t\t\t      scsi_cmd->device->channel);\n\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tbreak;\n\n\tcase PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR:\n\t\tscsi_cmd->result |= PMCRAID_IOASC_SENSE_STATUS(ioasc);\n\t\tres->sync_reqd = 1;\n\n\t\t/* if check_condition is not active return with error otherwise\n\t\t * get/frame the sense buffer\n\t\t */\n\t\tif (PMCRAID_IOASC_SENSE_STATUS(ioasc) !=\n\t\t    SAM_STAT_CHECK_CONDITION &&\n\t\t    PMCRAID_IOASC_SENSE_STATUS(ioasc) != SAM_STAT_ACA_ACTIVE)\n\t\t\treturn 0;\n\n\t\t/* If we have auto sense data as part of IOASA pass it to\n\t\t * mid-layer\n\t\t */\n\t\tif (ioasa->auto_sense_length != 0) {\n\t\t\tshort sense_len = ioasa->auto_sense_length;\n\t\t\tint data_size = min_t(u16, le16_to_cpu(sense_len),\n\t\t\t\t\t      SCSI_SENSE_BUFFERSIZE);\n\n\t\t\tmemcpy(scsi_cmd->sense_buffer,\n\t\t\t       ioasa->sense_data,\n\t\t\t       data_size);\n\t\t\tsense_copied = 1;\n\t\t}\n\n\t\tif (RES_IS_GSCSI(res->cfg_entry))\n\t\t\tpmcraid_cancel_all(cmd, sense_copied);\n\t\telse if (sense_copied)\n\t\t\tpmcraid_erp_done(cmd);\n\t\telse\n\t\t\tpmcraid_request_sense(cmd);\n\n\t\treturn 1;\n\n\tcase PMCRAID_IOASC_NR_INIT_CMD_REQUIRED:\n\t\tbreak;\n\n\tdefault:\n\t\tif (PMCRAID_IOASC_SENSE_KEY(ioasc) > RECOVERED_ERROR)\n\t\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/**\n * pmcraid_reset_device - device reset handler functions\n *\n * @scsi_cmd: scsi command struct\n * @modifier: reset modifier indicating the reset sequence to be performed\n *\n * This function issues a device reset to the affected device.\n * A LUN reset will be sent to the device first. If that does\n * not work, a target reset will be sent.\n *\n * Return value:\n *\tSUCCESS / FAILED\n */\nstatic int pmcraid_reset_device(\n\tstruct scsi_cmnd *scsi_cmd,\n\tunsigned long timeout,\n\tu8 modifier\n)\n{\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tunsigned long lock_flags;\n\tu32 ioasc;\n\n\tpinstance =\n\t\t(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\n\tres = scsi_cmd->device->hostdata;\n\n\tif (!res) {\n\t\tsdev_printk(KERN_ERR, scsi_cmd->device,\n\t\t\t    \"reset_device: NULL resource pointer\\n\");\n\t\treturn FAILED;\n\t}\n\n\t/* If adapter is currently going through reset/reload, return failed.\n\t * This will force the mid-layer to call _eh_bus/host reset, which\n\t * will then go to sleep and wait for the reset to complete\n\t */\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\tif (pinstance->ioa_reset_in_progress ||\n\t    pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t\treturn FAILED;\n\t}\n\n\tres->reset_progress = 1;\n\tpmcraid_info(\"Resetting %s resource with addr %x\\n\",\n\t\t     ((modifier & RESET_DEVICE_LUN) ? \"LUN\" :\n\t\t     ((modifier & RESET_DEVICE_TARGET) ? \"TARGET\" : \"BUS\")),\n\t\t     le32_to_cpu(res->cfg_entry.resource_address));\n\n\t/* get a free cmd block */\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (cmd == NULL) {\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_err(\"%s: no cmd blocks are available\\n\", __func__);\n\t\treturn FAILED;\n\t}\n\n\tioarcb = &cmd->ioa_cb->ioarcb;\n\tioarcb->resource_handle = res->cfg_entry.resource_handle;\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->cdb[0] = PMCRAID_RESET_DEVICE;\n\n\t/* Initialize reset modifier bits */\n\tif (modifier)\n\t\tmodifier = ENABLE_RESET_MODIFIER | modifier;\n\n\tioarcb->cdb[1] = modifier;\n\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"cmd(CDB[0] = %x) for %x with index = %d\\n\",\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle),\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2);\n\n\tpmcraid_send_cmd(cmd,\n\t\t\t pmcraid_internal_done,\n\t\t\t timeout,\n\t\t\t pmcraid_timeout_handler);\n\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* RESET_DEVICE command completes after all pending IOARCBs are\n\t * completed. Once this command is completed, pmcraind_internal_done\n\t * will wake up the 'completion' queue.\n\t */\n\twait_for_completion(&cmd->wait_for_completion);\n\n\t/* complete the command here itself and return the command block\n\t * to free list\n\t */\n\tpmcraid_return_cmd(cmd);\n\tres->reset_progress = 0;\n\tioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\n\t/* set the return value based on the returned ioasc */\n\treturn PMCRAID_IOASC_SENSE_KEY(ioasc) ? FAILED : SUCCESS;\n}\n\n/**\n * _pmcraid_io_done - helper for pmcraid_io_done function\n *\n * @cmd: pointer to pmcraid command struct\n * @reslen: residual data length to be set in the ioasa\n * @ioasc: ioasc either returned by IOA or set by driver itself.\n *\n * This function is invoked by pmcraid_io_done to complete mid-layer\n * scsi ops.\n *\n * Return value:\n *\t  0 if caller is required to return it to free_pool. Returns 1 if\n *\t  caller need not worry about freeing command block as error handler\n *\t  will take care of that.\n */\n\nstatic int _pmcraid_io_done(struct pmcraid_cmd *cmd, int reslen, int ioasc)\n{\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tint rc = 0;\n\n\tscsi_set_resid(scsi_cmd, reslen);\n\n\tpmcraid_info(\"response(%d) CDB[0] = %x ioasc:result: %x:%x\\n\",\n\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\tcmd->ioa_cb->ioarcb.cdb[0],\n\t\tioasc, scsi_cmd->result);\n\n\tif (PMCRAID_IOASC_SENSE_KEY(ioasc) != 0)\n\t\trc = pmcraid_error_handler(cmd);\n\n\tif (rc == 0) {\n\t\tscsi_dma_unmap(scsi_cmd);\n\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t}\n\n\treturn rc;\n}\n\n/**\n * pmcraid_io_done - SCSI completion function\n *\n * @cmd: pointer to pmcraid command struct\n *\n * This function is invoked by tasklet/mid-layer error handler to completing\n * the SCSI ops sent from mid-layer.\n *\n * Return value\n *\t  none\n */\n\nstatic void pmcraid_io_done(struct pmcraid_cmd *cmd)\n{\n\tu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\n\tu32 reslen = le32_to_cpu(cmd->ioa_cb->ioasa.residual_data_length);\n\n\tif (_pmcraid_io_done(cmd, reslen, ioasc) == 0)\n\t\tpmcraid_return_cmd(cmd);\n}\n\n/**\n * pmcraid_abort_cmd - Aborts a single IOARCB already submitted to IOA\n *\n * @cmd: command block of the command to be aborted\n *\n * Return Value:\n *\t returns pointer to command structure used as cancelling cmd\n */\nstatic struct pmcraid_cmd *pmcraid_abort_cmd(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_cmd *cancel_cmd;\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\n\tpinstance = (struct pmcraid_instance *)cmd->drv_inst;\n\tres = cmd->scsi_cmd->device->hostdata;\n\n\tcancel_cmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (cancel_cmd == NULL) {\n\t\tpmcraid_err(\"%s: no cmd blocks are available\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tpmcraid_prepare_cancel_cmd(cancel_cmd, cmd);\n\n\tpmcraid_info(\"aborting command CDB[0]= %x with index = %d\\n\",\n\t\tcmd->ioa_cb->ioarcb.cdb[0],\n\t\tcmd->ioa_cb->ioarcb.response_handle >> 2);\n\n\tinit_completion(&cancel_cmd->wait_for_completion);\n\tcancel_cmd->completion_req = 1;\n\n\tpmcraid_info(\"command (%d) CDB[0] = %x for %x\\n\",\n\t\tle32_to_cpu(cancel_cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\tcancel_cmd->ioa_cb->ioarcb.cdb[0],\n\t\tle32_to_cpu(cancel_cmd->ioa_cb->ioarcb.resource_handle));\n\n\tpmcraid_send_cmd(cancel_cmd,\n\t\t\t pmcraid_internal_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n\treturn cancel_cmd;\n}\n\n/**\n * pmcraid_abort_complete - Waits for ABORT TASK completion\n *\n * @cancel_cmd: command block use as cancelling command\n *\n * Return Value:\n *\t returns SUCCESS if ABORT TASK has good completion\n *\t otherwise FAILED\n */\nstatic int pmcraid_abort_complete(struct pmcraid_cmd *cancel_cmd)\n{\n\tstruct pmcraid_resource_entry *res;\n\tu32 ioasc;\n\n\twait_for_completion(&cancel_cmd->wait_for_completion);\n\tres = cancel_cmd->res;\n\tcancel_cmd->res = NULL;\n\tioasc = le32_to_cpu(cancel_cmd->ioa_cb->ioasa.ioasc);\n\n\t/* If the abort task is not timed out we will get a Good completion\n\t * as sense_key, otherwise we may get one the following responses\n\t * due to subsequent bus reset or device reset. In case IOASC is\n\t * NR_SYNC_REQUIRED, set sync_reqd flag for the corresponding resource\n\t */\n\tif (ioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET ||\n\t    ioasc == PMCRAID_IOASC_NR_SYNC_REQUIRED) {\n\t\tif (ioasc == PMCRAID_IOASC_NR_SYNC_REQUIRED)\n\t\t\tres->sync_reqd = 1;\n\t\tioasc = 0;\n\t}\n\n\t/* complete the command here itself */\n\tpmcraid_return_cmd(cancel_cmd);\n\treturn PMCRAID_IOASC_SENSE_KEY(ioasc) ? FAILED : SUCCESS;\n}\n\n/**\n * pmcraid_eh_abort_handler - entry point for aborting a single task on errors\n *\n * @scsi_cmd:   scsi command struct given by mid-layer. When this is called\n *\t\tmid-layer ensures that no other commands are queued. This\n *\t\tnever gets called under interrupt, but a separate eh thread.\n *\n * Return value:\n *\t SUCCESS / FAILED\n */\nstatic int pmcraid_eh_abort_handler(struct scsi_cmnd *scsi_cmd)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_resource_entry *res;\n\tunsigned long host_lock_flags;\n\tunsigned long pending_lock_flags;\n\tstruct pmcraid_cmd *cancel_cmd = NULL;\n\tint cmd_found = 0;\n\tint rc = FAILED;\n\n\tpinstance =\n\t\t(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, scsi_cmd,\n\t\t    \"I/O command timed out, aborting it.\\n\");\n\n\tres = scsi_cmd->device->hostdata;\n\n\tif (res == NULL)\n\t\treturn rc;\n\n\t/* If we are currently going through reset/reload, return failed.\n\t * This will force the mid-layer to eventually call\n\t * pmcraid_eh_host_reset which will then go to sleep and wait for the\n\t * reset to complete\n\t */\n\tspin_lock_irqsave(pinstance->host->host_lock, host_lock_flags);\n\n\tif (pinstance->ioa_reset_in_progress ||\n\t    pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t       host_lock_flags);\n\t\treturn rc;\n\t}\n\n\t/* loop over pending cmd list to find cmd corresponding to this\n\t * scsi_cmd. Note that this command might not have been completed\n\t * already. locking: all pending commands are protected with\n\t * pending_pool_lock.\n\t */\n\tspin_lock_irqsave(&pinstance->pending_pool_lock, pending_lock_flags);\n\tlist_for_each_entry(cmd, &pinstance->pending_cmd_pool, free_list) {\n\n\t\tif (cmd->scsi_cmd == scsi_cmd) {\n\t\t\tcmd_found = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pinstance->pending_pool_lock,\n\t\t\t\tpending_lock_flags);\n\n\t/* If the command to be aborted was given to IOA and still pending with\n\t * it, send ABORT_TASK to abort this and wait for its completion\n\t */\n\tif (cmd_found)\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\n\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t       host_lock_flags);\n\n\tif (cancel_cmd) {\n\t\tcancel_cmd->res = cmd->scsi_cmd->device->hostdata;\n\t\trc = pmcraid_abort_complete(cancel_cmd);\n\t}\n\n\treturn cmd_found ? rc : SUCCESS;\n}\n\n/**\n * pmcraid_eh_xxxx_reset_handler - bus/target/device reset handler callbacks\n *\n * @scmd: pointer to scsi_cmd that was sent to the resource to be reset.\n *\n * All these routines invokve pmcraid_reset_device with appropriate parameters.\n * Since these are called from mid-layer EH thread, no other IO will be queued\n * to the resource being reset. However, control path (IOCTL) may be active so\n * it is necessary to synchronize IOARRIN writes which pmcraid_reset_device\n * takes care by locking/unlocking host_lock.\n *\n * Return value\n *\tSUCCESS or FAILED\n */\nstatic int pmcraid_eh_device_reset_handler(struct scsi_cmnd *scmd)\n{\n\tscmd_printk(KERN_INFO, scmd,\n\t\t    \"resetting device due to an I/O command timeout.\\n\");\n\treturn pmcraid_reset_device(scmd,\n\t\t\t\t    PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t\t    RESET_DEVICE_LUN);\n}\n\nstatic int pmcraid_eh_bus_reset_handler(struct scsi_cmnd *scmd)\n{\n\tscmd_printk(KERN_INFO, scmd,\n\t\t    \"Doing bus reset due to an I/O command timeout.\\n\");\n\treturn pmcraid_reset_device(scmd,\n\t\t\t\t    PMCRAID_RESET_BUS_TIMEOUT,\n\t\t\t\t    RESET_DEVICE_BUS);\n}\n\nstatic int pmcraid_eh_target_reset_handler(struct scsi_cmnd *scmd)\n{\n\tscmd_printk(KERN_INFO, scmd,\n\t\t    \"Doing target reset due to an I/O command timeout.\\n\");\n\treturn pmcraid_reset_device(scmd,\n\t\t\t\t    PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t\t    RESET_DEVICE_TARGET);\n}\n\n/**\n * pmcraid_eh_host_reset_handler - adapter reset handler callback\n *\n * @scmd: pointer to scsi_cmd that was sent to a resource of adapter\n *\n * Initiates adapter reset to bring it up to operational state\n *\n * Return value\n *\tSUCCESS or FAILED\n */\nstatic int pmcraid_eh_host_reset_handler(struct scsi_cmnd *scmd)\n{\n\tunsigned long interval = 10000; /* 10 seconds interval */\n\tint waits = jiffies_to_msecs(PMCRAID_RESET_HOST_TIMEOUT) / interval;\n\tstruct pmcraid_instance *pinstance =\n\t\t(struct pmcraid_instance *)(scmd->device->host->hostdata);\n\n\n\t/* wait for an additional 150 seconds just in case firmware could come\n\t * up and if it could complete all the pending commands excluding the\n\t * two HCAM (CCN and LDN).\n\t */\n\twhile (waits--) {\n\t\tif (atomic_read(&pinstance->outstanding_cmds) <=\n\t\t    PMCRAID_MAX_HCAM_CMD)\n\t\t\treturn SUCCESS;\n\t\tmsleep(interval);\n\t}\n\n\tdev_err(&pinstance->pdev->dev,\n\t\t\"Adapter being reset due to an I/O command timeout.\\n\");\n\treturn pmcraid_reset_bringup(pinstance) == 0 ? SUCCESS : FAILED;\n}\n\n/**\n * pmcraid_task_attributes - Translate SPI Q-Tags to task attributes\n * @scsi_cmd:   scsi command struct\n *\n * Return value\n *\t  number of tags or 0 if the task is not tagged\n */\nstatic u8 pmcraid_task_attributes(struct scsi_cmnd *scsi_cmd)\n{\n\tchar tag[2];\n\tu8 rc = 0;\n\n\tif (scsi_populate_tag_msg(scsi_cmd, tag)) {\n\t\tswitch (tag[0]) {\n\t\tcase MSG_SIMPLE_TAG:\n\t\t\trc = TASK_TAG_SIMPLE;\n\t\t\tbreak;\n\t\tcase MSG_HEAD_TAG:\n\t\t\trc = TASK_TAG_QUEUE_HEAD;\n\t\t\tbreak;\n\t\tcase MSG_ORDERED_TAG:\n\t\t\trc = TASK_TAG_ORDERED;\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn rc;\n}\n\n\n/**\n * pmcraid_init_ioadls - initializes IOADL related fields in IOARCB\n * @cmd: pmcraid command struct\n * @sgcount: count of scatter-gather elements\n *\n * Return value\n *   returns pointer pmcraid_ioadl_desc, initialized to point to internal\n *   or external IOADLs\n */\nstruct pmcraid_ioadl_desc *\npmcraid_init_ioadls(struct pmcraid_cmd *cmd, int sgcount)\n{\n\tstruct pmcraid_ioadl_desc *ioadl;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tint ioadl_count = 0;\n\n\tif (ioarcb->add_cmd_param_length)\n\t\tioadl_count = DIV_ROUND_UP(ioarcb->add_cmd_param_length, 16);\n\tioarcb->ioadl_length =\n\t\tsizeof(struct pmcraid_ioadl_desc) * sgcount;\n\n\tif ((sgcount + ioadl_count) > (ARRAY_SIZE(ioarcb->add_data.u.ioadl))) {\n\t\t/* external ioadls start at offset 0x80 from control_block\n\t\t * structure, re-using 24 out of 27 ioadls part of IOARCB.\n\t\t * It is necessary to indicate to firmware that driver is\n\t\t * using ioadls to be treated as external to IOARCB.\n\t\t */\n\t\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\t\tioarcb->ioadl_bus_addr =\n\t\t\tcpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\tadd_data.u.ioadl[3]));\n\t\tioadl = &ioarcb->add_data.u.ioadl[3];\n\t} else {\n\t\tioarcb->ioadl_bus_addr =\n\t\t\tcpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\tadd_data.u.ioadl[ioadl_count]));\n\n\t\tioadl = &ioarcb->add_data.u.ioadl[ioadl_count];\n\t\tioarcb->ioarcb_bus_addr |=\n\t\t\t\tDIV_ROUND_CLOSEST(sgcount + ioadl_count, 8);\n\t}\n\n\treturn ioadl;\n}\n\n/**\n * pmcraid_build_ioadl - Build a scatter/gather list and map the buffer\n * @pinstance: pointer to adapter instance structure\n * @cmd: pmcraid command struct\n *\n * This function is invoked by queuecommand entry point while sending a command\n * to firmware. This builds ioadl descriptors and sets up ioarcb fields.\n *\n * Return value:\n *\t0 on success or -1 on failure\n */\nstatic int pmcraid_build_ioadl(\n\tstruct pmcraid_instance *pinstance,\n\tstruct pmcraid_cmd *cmd\n)\n{\n\tint i, nseg;\n\tstruct scatterlist *sglist;\n\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_ioarcb *ioarcb = &(cmd->ioa_cb->ioarcb);\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\n\tu32 length = scsi_bufflen(scsi_cmd);\n\n\tif (!length)\n\t\treturn 0;\n\n\tnseg = scsi_dma_map(scsi_cmd);\n\n\tif (nseg < 0) {\n\t\tscmd_printk(KERN_ERR, scsi_cmd, \"scsi_map_dma failed!\\n\");\n\t\treturn -1;\n\t} else if (nseg > PMCRAID_MAX_IOADLS) {\n\t\tscsi_dma_unmap(scsi_cmd);\n\t\tscmd_printk(KERN_ERR, scsi_cmd,\n\t\t\t\"sg count is (%d) more than allowed!\\n\", nseg);\n\t\treturn -1;\n\t}\n\n\t/* Initialize IOARCB data transfer length fields */\n\tif (scsi_cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tioarcb->request_flags0 |= TRANSFER_DIR_WRITE;\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length = cpu_to_le32(length);\n\tioadl = pmcraid_init_ioadls(cmd, nseg);\n\n\t/* Initialize IOADL descriptor addresses */\n\tscsi_for_each_sg(scsi_cmd, sglist, nseg, i) {\n\t\tioadl[i].data_len = cpu_to_le32(sg_dma_len(sglist));\n\t\tioadl[i].address = cpu_to_le64(sg_dma_address(sglist));\n\t\tioadl[i].flags = 0;\n\t}\n\t/* setup last descriptor */\n\tioadl[i - 1].flags = IOADL_FLAGS_LAST_DESC;\n\n\treturn 0;\n}\n\n/**\n * pmcraid_free_sglist - Frees an allocated SG buffer list\n * @sglist: scatter/gather list pointer\n *\n * Free a DMA'able memory previously allocated with pmcraid_alloc_sglist\n *\n * Return value:\n *\tnone\n */\nstatic void pmcraid_free_sglist(struct pmcraid_sglist *sglist)\n{\n\tint i;\n\n\tfor (i = 0; i < sglist->num_sg; i++)\n\t\t__free_pages(sg_page(&(sglist->scatterlist[i])),\n\t\t\t     sglist->order);\n\n\tkfree(sglist);\n}\n\n/**\n * pmcraid_alloc_sglist - Allocates memory for a SG list\n * @buflen: buffer length\n *\n * Allocates a DMA'able buffer in chunks and assembles a scatter/gather\n * list.\n *\n * Return value\n *\tpointer to sglist / NULL on failure\n */\nstatic struct pmcraid_sglist *pmcraid_alloc_sglist(int buflen)\n{\n\tstruct pmcraid_sglist *sglist;\n\tstruct scatterlist *scatterlist;\n\tstruct page *page;\n\tint num_elem, i, j;\n\tint sg_size;\n\tint order;\n\tint bsize_elem;\n\n\tsg_size = buflen / (PMCRAID_MAX_IOADLS - 1);\n\torder = (sg_size > 0) ? get_order(sg_size) : 0;\n\tbsize_elem = PAGE_SIZE * (1 << order);\n\n\t/* Determine the actual number of sg entries needed */\n\tif (buflen % bsize_elem)\n\t\tnum_elem = (buflen / bsize_elem) + 1;\n\telse\n\t\tnum_elem = buflen / bsize_elem;\n\n\t/* Allocate a scatter/gather list for the DMA */\n\tsglist = kzalloc(sizeof(struct pmcraid_sglist) +\n\t\t\t (sizeof(struct scatterlist) * (num_elem - 1)),\n\t\t\t GFP_KERNEL);\n\n\tif (sglist == NULL)\n\t\treturn NULL;\n\n\tscatterlist = sglist->scatterlist;\n\tsg_init_table(scatterlist, num_elem);\n\tsglist->order = order;\n\tsglist->num_sg = num_elem;\n\tsg_size = buflen;\n\n\tfor (i = 0; i < num_elem; i++) {\n\t\tpage = alloc_pages(GFP_KERNEL|GFP_DMA|__GFP_ZERO, order);\n\t\tif (!page) {\n\t\t\tfor (j = i - 1; j >= 0; j--)\n\t\t\t\t__free_pages(sg_page(&scatterlist[j]), order);\n\t\t\tkfree(sglist);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsg_set_page(&scatterlist[i], page,\n\t\t\tsg_size < bsize_elem ? sg_size : bsize_elem, 0);\n\t\tsg_size -= bsize_elem;\n\t}\n\n\treturn sglist;\n}\n\n/**\n * pmcraid_copy_sglist - Copy user buffer to kernel buffer's SG list\n * @sglist: scatter/gather list pointer\n * @buffer: buffer pointer\n * @len: buffer length\n * @direction: data transfer direction\n *\n * Copy a user buffer into a buffer allocated by pmcraid_alloc_sglist\n *\n * Return value:\n * 0 on success / other on failure\n */\nstatic int pmcraid_copy_sglist(\n\tstruct pmcraid_sglist *sglist,\n\tunsigned long buffer,\n\tu32 len,\n\tint direction\n)\n{\n\tstruct scatterlist *scatterlist;\n\tvoid *kaddr;\n\tint bsize_elem;\n\tint i;\n\tint rc = 0;\n\n\t/* Determine the actual number of bytes per element */\n\tbsize_elem = PAGE_SIZE * (1 << sglist->order);\n\n\tscatterlist = sglist->scatterlist;\n\n\tfor (i = 0; i < (len / bsize_elem); i++, buffer += bsize_elem) {\n\t\tstruct page *page = sg_page(&scatterlist[i]);\n\n\t\tkaddr = kmap(page);\n\t\tif (direction == DMA_TO_DEVICE)\n\t\t\trc = __copy_from_user(kaddr,\n\t\t\t\t\t      (void *)buffer,\n\t\t\t\t\t      bsize_elem);\n\t\telse\n\t\t\trc = __copy_to_user((void *)buffer, kaddr, bsize_elem);\n\n\t\tkunmap(page);\n\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user data into sg list\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tscatterlist[i].length = bsize_elem;\n\t}\n\n\tif (len % bsize_elem) {\n\t\tstruct page *page = sg_page(&scatterlist[i]);\n\n\t\tkaddr = kmap(page);\n\n\t\tif (direction == DMA_TO_DEVICE)\n\t\t\trc = __copy_from_user(kaddr,\n\t\t\t\t\t      (void *)buffer,\n\t\t\t\t\t      len % bsize_elem);\n\t\telse\n\t\t\trc = __copy_to_user((void *)buffer,\n\t\t\t\t\t    kaddr,\n\t\t\t\t\t    len % bsize_elem);\n\n\t\tkunmap(page);\n\n\t\tscatterlist[i].length = len % bsize_elem;\n\t}\n\n\tif (rc) {\n\t\tpmcraid_err(\"failed to copy user data into sg list\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\treturn rc;\n}\n\n/**\n * pmcraid_queuecommand - Queue a mid-layer request\n * @scsi_cmd: scsi command struct\n * @done: done function\n *\n * This function queues a request generated by the mid-layer. Midlayer calls\n * this routine within host->lock. Some of the functions called by queuecommand\n * would use cmd block queue locks (free_pool_lock and pending_pool_lock)\n *\n * Return value:\n *\t  0 on success\n *\t  SCSI_MLQUEUE_DEVICE_BUSY if device is busy\n *\t  SCSI_MLQUEUE_HOST_BUSY if host is busy\n */\nstatic int pmcraid_queuecommand_lck(\n\tstruct scsi_cmnd *scsi_cmd,\n\tvoid (*done) (struct scsi_cmnd *)\n)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tu32 fw_version;\n\tint rc = 0;\n\n\tpinstance =\n\t\t(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\tscsi_cmd->scsi_done = done;\n\tres = scsi_cmd->device->hostdata;\n\tscsi_cmd->result = (DID_OK << 16);\n\n\t/* if adapter is marked as dead, set result to DID_NO_CONNECT complete\n\t * the command\n\t */\n\tif (pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\tpmcraid_info(\"IOA is dead, but queuecommand is scheduled\\n\");\n\t\tscsi_cmd->result = (DID_NO_CONNECT << 16);\n\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t\treturn 0;\n\t}\n\n\t/* If IOA reset is in progress, can't queue the commands */\n\tif (pinstance->ioa_reset_in_progress)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t/* Firmware doesn't support SYNCHRONIZE_CACHE command (0x35), complete\n\t * the command here itself with success return\n\t */\n\tif (scsi_cmd->cmnd[0] == SYNCHRONIZE_CACHE) {\n\t\tpmcraid_info(\"SYNC_CACHE(0x35), completing in driver itself\\n\");\n\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t\treturn 0;\n\t}\n\n\t/* initialize the command and IOARCB to be sent to IOA */\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (cmd == NULL) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tcmd->scsi_cmd = scsi_cmd;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\tmemcpy(ioarcb->cdb, scsi_cmd->cmnd, scsi_cmd->cmd_len);\n\tioarcb->resource_handle = res->cfg_entry.resource_handle;\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\tcmd->cmd_done = pmcraid_io_done;\n\n\tif (RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry)) {\n\t\tif (scsi_cmd->underflow == 0)\n\t\t\tioarcb->request_flags0 |= INHIBIT_UL_CHECK;\n\n\t\tif (res->sync_reqd) {\n\t\t\tioarcb->request_flags0 |= SYNC_COMPLETE;\n\t\t\tres->sync_reqd = 0;\n\t\t}\n\n\t\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\t\tioarcb->request_flags1 |= pmcraid_task_attributes(scsi_cmd);\n\n\t\tif (RES_IS_GSCSI(res->cfg_entry))\n\t\t\tioarcb->request_flags1 |= DELAY_AFTER_RESET;\n\t}\n\n\trc = pmcraid_build_ioadl(pinstance, cmd);\n\n\tpmcraid_info(\"command (%d) CDB[0] = %x for %x:%x:%x:%x\\n\",\n\t\t     le32_to_cpu(ioarcb->response_handle) >> 2,\n\t\t     scsi_cmd->cmnd[0], pinstance->host->unique_id,\n\t\t     RES_IS_VSET(res->cfg_entry) ? PMCRAID_VSET_BUS_ID :\n\t\t\tPMCRAID_PHYS_BUS_ID,\n\t\t     RES_IS_VSET(res->cfg_entry) ?\n\t\t\t(fw_version <= PMCRAID_FW_VERSION_1 ?\n\t\t\t\tres->cfg_entry.unique_flags1 :\n\t\t\t\t\tres->cfg_entry.array_id & 0xFF) :\n\t\t\tRES_TARGET(res->cfg_entry.resource_address),\n\t\t     RES_LUN(res->cfg_entry.resource_address));\n\n\tif (likely(rc == 0)) {\n\t\t_pmcraid_fire_command(cmd);\n\t} else {\n\t\tpmcraid_err(\"queuecommand could not build ioadl\\n\");\n\t\tpmcraid_return_cmd(cmd);\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\treturn rc;\n}\n\nstatic DEF_SCSI_QCMD(pmcraid_queuecommand)\n\n/**\n * pmcraid_open -char node \"open\" entry, allowed only users with admin access\n */\nstatic int pmcraid_chr_open(struct inode *inode, struct file *filep)\n{\n\tstruct pmcraid_instance *pinstance;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\t/* Populate adapter instance * pointer for use by ioctl */\n\tpinstance = container_of(inode->i_cdev, struct pmcraid_instance, cdev);\n\tfilep->private_data = pinstance;\n\n\treturn 0;\n}\n\n/**\n * pmcraid_release - char node \"release\" entry point\n */\nstatic int pmcraid_chr_release(struct inode *inode, struct file *filep)\n{\n\tstruct pmcraid_instance *pinstance = filep->private_data;\n\n\tfilep->private_data = NULL;\n\tfasync_helper(-1, filep, 0, &pinstance->aen_queue);\n\n\treturn 0;\n}\n\n/**\n * pmcraid_fasync - Async notifier registration from applications\n *\n * This function adds the calling process to a driver global queue. When an\n * event occurs, SIGIO will be sent to all processes in this queue.\n */\nstatic int pmcraid_chr_fasync(int fd, struct file *filep, int mode)\n{\n\tstruct pmcraid_instance *pinstance;\n\tint rc;\n\n\tpinstance = filep->private_data;\n\tmutex_lock(&pinstance->aen_queue_lock);\n\trc = fasync_helper(fd, filep, mode, &pinstance->aen_queue);\n\tmutex_unlock(&pinstance->aen_queue_lock);\n\n\treturn rc;\n}\n\n\n/**\n * pmcraid_build_passthrough_ioadls - builds SG elements for passthrough\n * commands sent over IOCTL interface\n *\n * @cmd       : pointer to struct pmcraid_cmd\n * @buflen    : length of the request buffer\n * @direction : data transfer direction\n *\n * Return value\n *  0 on success, non-zero error code on failure\n */\nstatic int pmcraid_build_passthrough_ioadls(\n\tstruct pmcraid_cmd *cmd,\n\tint buflen,\n\tint direction\n)\n{\n\tstruct pmcraid_sglist *sglist = NULL;\n\tstruct scatterlist *sg = NULL;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl;\n\tint i;\n\n\tsglist = pmcraid_alloc_sglist(buflen);\n\n\tif (!sglist) {\n\t\tpmcraid_err(\"can't allocate memory for passthrough SGls\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsglist->num_dma_sg = pci_map_sg(cmd->drv_inst->pdev,\n\t\t\t\t\tsglist->scatterlist,\n\t\t\t\t\tsglist->num_sg, direction);\n\n\tif (!sglist->num_dma_sg || sglist->num_dma_sg > PMCRAID_MAX_IOADLS) {\n\t\tdev_err(&cmd->drv_inst->pdev->dev,\n\t\t\t\"Failed to map passthrough buffer!\\n\");\n\t\tpmcraid_free_sglist(sglist);\n\t\treturn -EIO;\n\t}\n\n\tcmd->sglist = sglist;\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\n\tioadl = pmcraid_init_ioadls(cmd, sglist->num_dma_sg);\n\n\t/* Initialize IOADL descriptor addresses */\n\tfor_each_sg(sglist->scatterlist, sg, sglist->num_dma_sg, i) {\n\t\tioadl[i].data_len = cpu_to_le32(sg_dma_len(sg));\n\t\tioadl[i].address = cpu_to_le64(sg_dma_address(sg));\n\t\tioadl[i].flags = 0;\n\t}\n\n\t/* setup the last descriptor */\n\tioadl[i - 1].flags = IOADL_FLAGS_LAST_DESC;\n\n\treturn 0;\n}\n\n\n/**\n * pmcraid_release_passthrough_ioadls - release passthrough ioadls\n *\n * @cmd: pointer to struct pmcraid_cmd for which ioadls were allocated\n * @buflen: size of the request buffer\n * @direction: data transfer direction\n *\n * Return value\n *  0 on success, non-zero error code on failure\n */\nstatic void pmcraid_release_passthrough_ioadls(\n\tstruct pmcraid_cmd *cmd,\n\tint buflen,\n\tint direction\n)\n{\n\tstruct pmcraid_sglist *sglist = cmd->sglist;\n\n\tif (buflen > 0) {\n\t\tpci_unmap_sg(cmd->drv_inst->pdev,\n\t\t\t     sglist->scatterlist,\n\t\t\t     sglist->num_sg,\n\t\t\t     direction);\n\t\tpmcraid_free_sglist(sglist);\n\t\tcmd->sglist = NULL;\n\t}\n}\n\n/**\n * pmcraid_ioctl_passthrough - handling passthrough IOCTL commands\n *\n * @pinstance: pointer to adapter instance structure\n * @cmd: ioctl code\n * @arg: pointer to pmcraid_passthrough_buffer user buffer\n *\n * Return value\n *  0 on success, non-zero error code on failure\n */\nstatic long pmcraid_ioctl_passthrough(\n\tstruct pmcraid_instance *pinstance,\n\tunsigned int ioctl_cmd,\n\tunsigned int buflen,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_passthrough_ioctl_buffer *buffer;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cancel_cmd;\n\tunsigned long request_buffer;\n\tunsigned long request_offset;\n\tunsigned long lock_flags;\n\tvoid *ioasa;\n\tu32 ioasc;\n\tint request_size;\n\tint buffer_size;\n\tu8 access, direction;\n\tint rc = 0;\n\n\t/* If IOA reset is in progress, wait 10 secs for reset to complete */\n\tif (pinstance->ioa_reset_in_progress) {\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\tpinstance->reset_wait_q,\n\t\t\t\t!pinstance->ioa_reset_in_progress,\n\t\t\t\tmsecs_to_jiffies(10000));\n\n\t\tif (!rc)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (rc < 0)\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\t/* If adapter is not in operational state, return error */\n\tif (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {\n\t\tpmcraid_err(\"IOA is not operational\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\tbuffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\tpmcraid_err(\"no memory for passthrough buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trequest_offset =\n\t    offsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);\n\n\trequest_buffer = arg + request_offset;\n\n\trc = __copy_from_user(buffer,\n\t\t\t     (struct pmcraid_passthrough_ioctl_buffer *) arg,\n\t\t\t     sizeof(struct pmcraid_passthrough_ioctl_buffer));\n\n\tioasa =\n\t(void *)(arg +\n\t\toffsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));\n\n\tif (rc) {\n\t\tpmcraid_err(\"ioctl: can't copy passthrough buffer\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out_free_buffer;\n\t}\n\n\trequest_size = buffer->ioarcb.data_transfer_length;\n\n\tif (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {\n\t\taccess = VERIFY_READ;\n\t\tdirection = DMA_TO_DEVICE;\n\t} else {\n\t\taccess = VERIFY_WRITE;\n\t\tdirection = DMA_FROM_DEVICE;\n\t}\n\n\tif (request_size > 0) {\n\t\trc = access_ok(access, arg, request_offset + request_size);\n\n\t\tif (!rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* check if we have any additional command parameters */\n\tif (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd->scsi_cmd = NULL;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\n\t/* Copy the user-provided IOARCB stuff field by field */\n\tioarcb->resource_handle = buffer->ioarcb.resource_handle;\n\tioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;\n\tioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;\n\tioarcb->request_type = buffer->ioarcb.request_type;\n\tioarcb->request_flags0 = buffer->ioarcb.request_flags0;\n\tioarcb->request_flags1 = buffer->ioarcb.request_flags1;\n\tmemcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);\n\n\tif (buffer->ioarcb.add_cmd_param_length) {\n\t\tioarcb->add_cmd_param_length =\n\t\t\tbuffer->ioarcb.add_cmd_param_length;\n\t\tioarcb->add_cmd_param_offset =\n\t\t\tbuffer->ioarcb.add_cmd_param_offset;\n\t\tmemcpy(ioarcb->add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_cmd_param_length);\n\t}\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\n\tif (request_size) {\n\t\trc = pmcraid_build_passthrough_ioadls(cmd,\n\t\t\t\t\t\t      request_size,\n\t\t\t\t\t\t      direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"couldn't build passthrough ioadls\\n\");\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* If data is being written into the device, copy the data from user\n\t * buffers\n\t */\n\tif (direction == DMA_TO_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\tgoto out_free_sglist;\n\t\t}\n\t}\n\n\t/* passthrough ioctl is a blocking command so, put the user to sleep\n\t * until timeout. Note that a timeout value of 0 means, do timeout.\n\t */\n\tcmd->cmd_done = pmcraid_internal_done;\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"command(%d) (CDB[0] = %x) for %x\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t_pmcraid_fire_command(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* NOTE ! Remove the below line once abort_task is implemented\n\t * in firmware. This line disables ioctl command timeout handling logic\n\t * similar to IO command timeout handling, making ioctl commands to wait\n\t * until the command completion regardless of timeout value specified in\n\t * ioarcb\n\t */\n\tbuffer->ioarcb.cmd_timeout = 0;\n\n\t/* If command timeout is specified put caller to wait till that time,\n\t * otherwise it would be blocking wait. If command gets timed out, it\n\t * will be aborted.\n\t */\n\tif (buffer->ioarcb.cmd_timeout == 0) {\n\t\twait_for_completion(&cmd->wait_for_completion);\n\t} else if (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {\n\n\t\tpmcraid_info(\"aborting cmd %d (CDB[0] = %x) due to timeout\\n\",\n\t\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),\n\t\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\tif (cancel_cmd) {\n\t\t\twait_for_completion(&cancel_cmd->wait_for_completion);\n\t\t\tioasc = cancel_cmd->ioa_cb->ioasa.ioasc;\n\t\t\tpmcraid_return_cmd(cancel_cmd);\n\n\t\t\t/* if abort task couldn't find the command i.e it got\n\t\t\t * completed prior to aborting, return good completion.\n\t\t\t * if command got aborted successfully or there was IOA\n\t\t\t * reset due to abort task itself getting timedout then\n\t\t\t * return -ETIMEDOUT\n\t\t\t */\n\t\t\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t\t\t    PMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {\n\t\t\t\tif (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto out_handle_response;\n\t\t\t}\n\t\t}\n\n\t\t/* no command block for abort task or abort task failed to abort\n\t\t * the IOARCB, then wait for 150 more seconds and initiate reset\n\t\t * sequence after timeout\n\t\t */\n\t\tif (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(150 * 1000))) {\n\t\t\tpmcraid_reset_bringup(cmd->drv_inst);\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\t}\n\nout_handle_response:\n\t/* copy entire IOASA buffer and return IOCTL success.\n\t * If copying IOASA to user-buffer fails, return\n\t * EFAULT\n\t */\n\tif (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,\n\t\tsizeof(struct pmcraid_ioasa))) {\n\t\tpmcraid_err(\"failed to copy ioasa buffer to user\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\t/* If the data transfer was from device, copy the data onto user\n\t * buffers\n\t */\n\telse if (direction == DMA_FROM_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\nout_free_sglist:\n\tpmcraid_release_passthrough_ioadls(cmd, request_size, direction);\n\tpmcraid_return_cmd(cmd);\n\nout_free_buffer:\n\tkfree(buffer);\n\n\treturn rc;\n}\n\n\n\n\n/**\n * pmcraid_ioctl_driver - ioctl handler for commands handled by driver itself\n *\n * @pinstance: pointer to adapter instance structure\n * @cmd: ioctl command passed in\n * @buflen: length of user_buffer\n * @user_buffer: user buffer pointer\n *\n * Return Value\n *   0 in case of success, otherwise appropriate error code\n */\nstatic long pmcraid_ioctl_driver(\n\tstruct pmcraid_instance *pinstance,\n\tunsigned int cmd,\n\tunsigned int buflen,\n\tvoid __user *user_buffer\n)\n{\n\tint rc = -ENOSYS;\n\n\tif (!access_ok(VERIFY_READ, user_buffer, _IOC_SIZE(cmd))) {\n\t\tpmcraid_err(\"ioctl_driver: access fault in request buffer\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (cmd) {\n\tcase PMCRAID_IOCTL_RESET_ADAPTER:\n\t\tpmcraid_reset_bringup(pinstance);\n\t\trc = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n/**\n * pmcraid_check_ioctl_buffer - check for proper access to user buffer\n *\n * @cmd: ioctl command\n * @arg: user buffer\n * @hdr: pointer to kernel memory for pmcraid_ioctl_header\n *\n * Return Value\n *\tnegetive error code if there are access issues, otherwise zero.\n *\tUpon success, returns ioctl header copied out of user buffer.\n */\n\nstatic int pmcraid_check_ioctl_buffer(\n\tint cmd,\n\tvoid __user *arg,\n\tstruct pmcraid_ioctl_header *hdr\n)\n{\n\tint rc = 0;\n\tint access = VERIFY_READ;\n\n\tif (copy_from_user(hdr, arg, sizeof(struct pmcraid_ioctl_header))) {\n\t\tpmcraid_err(\"couldn't copy ioctl header from user buffer\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* check for valid driver signature */\n\trc = memcmp(hdr->signature,\n\t\t    PMCRAID_IOCTL_SIGNATURE,\n\t\t    sizeof(hdr->signature));\n\tif (rc) {\n\t\tpmcraid_err(\"signature verification failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check for appropriate buffer access */\n\tif ((_IOC_DIR(cmd) & _IOC_READ) == _IOC_READ)\n\t\taccess = VERIFY_WRITE;\n\n\trc = access_ok(access,\n\t\t       (arg + sizeof(struct pmcraid_ioctl_header)),\n\t\t       hdr->buffer_length);\n\tif (!rc) {\n\t\tpmcraid_err(\"access failed for user buffer of size %d\\n\",\n\t\t\t     hdr->buffer_length);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/**\n *  pmcraid_ioctl - char node ioctl entry point\n */\nstatic long pmcraid_chr_ioctl(\n\tstruct file *filep,\n\tunsigned int cmd,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_instance *pinstance = NULL;\n\tstruct pmcraid_ioctl_header *hdr = NULL;\n\tint retval = -ENOTTY;\n\n\thdr = kmalloc(GFP_KERNEL, sizeof(struct pmcraid_ioctl_header));\n\n\tif (!hdr) {\n\t\tpmcraid_err(\"faile to allocate memory for ioctl header\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tretval = pmcraid_check_ioctl_buffer(cmd, (void *)arg, hdr);\n\n\tif (retval) {\n\t\tpmcraid_info(\"chr_ioctl: header check failed\\n\");\n\t\tkfree(hdr);\n\t\treturn retval;\n\t}\n\n\tpinstance = filep->private_data;\n\n\tif (!pinstance) {\n\t\tpmcraid_info(\"adapter instance is not found\\n\");\n\t\tkfree(hdr);\n\t\treturn -ENOTTY;\n\t}\n\n\tswitch (_IOC_TYPE(cmd)) {\n\n\tcase PMCRAID_PASSTHROUGH_IOCTL:\n\t\t/* If ioctl code is to download microcode, we need to block\n\t\t * mid-layer requests.\n\t\t */\n\t\tif (cmd == PMCRAID_IOCTL_DOWNLOAD_MICROCODE)\n\t\t\tscsi_block_requests(pinstance->host);\n\n\t\tretval = pmcraid_ioctl_passthrough(pinstance,\n\t\t\t\t\t\t   cmd,\n\t\t\t\t\t\t   hdr->buffer_length,\n\t\t\t\t\t\t   arg);\n\n\t\tif (cmd == PMCRAID_IOCTL_DOWNLOAD_MICROCODE)\n\t\t\tscsi_unblock_requests(pinstance->host);\n\t\tbreak;\n\n\tcase PMCRAID_DRIVER_IOCTL:\n\t\targ += sizeof(struct pmcraid_ioctl_header);\n\t\tretval = pmcraid_ioctl_driver(pinstance,\n\t\t\t\t\t      cmd,\n\t\t\t\t\t      hdr->buffer_length,\n\t\t\t\t\t      (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tkfree(hdr);\n\n\treturn retval;\n}\n\n/**\n * File operations structure for management interface\n */\nstatic const struct file_operations pmcraid_fops = {\n\t.owner = THIS_MODULE,\n\t.open = pmcraid_chr_open,\n\t.release = pmcraid_chr_release,\n\t.fasync = pmcraid_chr_fasync,\n\t.unlocked_ioctl = pmcraid_chr_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = pmcraid_chr_ioctl,\n#endif\n\t.llseek = noop_llseek,\n};\n\n\n\n\n/**\n * pmcraid_show_log_level - Display adapter's error logging level\n * @dev: class device struct\n * @buf: buffer\n *\n * Return value:\n *  number of bytes printed to buffer\n */\nstatic ssize_t pmcraid_show_log_level(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct pmcraid_instance *pinstance =\n\t\t(struct pmcraid_instance *)shost->hostdata;\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", pinstance->current_log_level);\n}\n\n/**\n * pmcraid_store_log_level - Change the adapter's error logging level\n * @dev: class device struct\n * @buf: buffer\n * @count: not used\n *\n * Return value:\n *  number of bytes printed to buffer\n */\nstatic ssize_t pmcraid_store_log_level(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tconst char *buf,\n\tsize_t count\n)\n{\n\tstruct Scsi_Host *shost;\n\tstruct pmcraid_instance *pinstance;\n\tunsigned long val;\n\n\tif (strict_strtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\t/* log-level should be from 0 to 2 */\n\tif (val > 2)\n\t\treturn -EINVAL;\n\n\tshost = class_to_shost(dev);\n\tpinstance = (struct pmcraid_instance *)shost->hostdata;\n\tpinstance->current_log_level = val;\n\n\treturn strlen(buf);\n}\n\nstatic struct device_attribute pmcraid_log_level_attr = {\n\t.attr = {\n\t\t .name = \"log_level\",\n\t\t .mode = S_IRUGO | S_IWUSR,\n\t\t },\n\t.show = pmcraid_show_log_level,\n\t.store = pmcraid_store_log_level,\n};\n\n/**\n * pmcraid_show_drv_version - Display driver version\n * @dev: class device struct\n * @buf: buffer\n *\n * Return value:\n *  number of bytes printed to buffer\n */\nstatic ssize_t pmcraid_show_drv_version(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf\n)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"version: %s\\n\",\n\t\t\tPMCRAID_DRIVER_VERSION);\n}\n\nstatic struct device_attribute pmcraid_driver_version_attr = {\n\t.attr = {\n\t\t .name = \"drv_version\",\n\t\t .mode = S_IRUGO,\n\t\t },\n\t.show = pmcraid_show_drv_version,\n};\n\n/**\n * pmcraid_show_io_adapter_id - Display driver assigned adapter id\n * @dev: class device struct\n * @buf: buffer\n *\n * Return value:\n *  number of bytes printed to buffer\n */\nstatic ssize_t pmcraid_show_adapter_id(\n\tstruct device *dev,\n\tstruct device_attribute *attr,\n\tchar *buf\n)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct pmcraid_instance *pinstance =\n\t\t(struct pmcraid_instance *)shost->hostdata;\n\tu32 adapter_id = (pinstance->pdev->bus->number << 8) |\n\t\tpinstance->pdev->devfn;\n\tu32 aen_group = pmcraid_event_family.id;\n\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"adapter id: %d\\nminor: %d\\naen group: %d\\n\",\n\t\t\tadapter_id, MINOR(pinstance->cdev.dev), aen_group);\n}\n\nstatic struct device_attribute pmcraid_adapter_id_attr = {\n\t.attr = {\n\t\t .name = \"adapter_id\",\n\t\t .mode = S_IRUGO | S_IWUSR,\n\t\t },\n\t.show = pmcraid_show_adapter_id,\n};\n\nstatic struct device_attribute *pmcraid_host_attrs[] = {\n\t&pmcraid_log_level_attr,\n\t&pmcraid_driver_version_attr,\n\t&pmcraid_adapter_id_attr,\n\tNULL,\n};\n\n\n/* host template structure for pmcraid driver */\nstatic struct scsi_host_template pmcraid_host_template = {\n\t.module = THIS_MODULE,\n\t.name = PMCRAID_DRIVER_NAME,\n\t.queuecommand = pmcraid_queuecommand,\n\t.eh_abort_handler = pmcraid_eh_abort_handler,\n\t.eh_bus_reset_handler = pmcraid_eh_bus_reset_handler,\n\t.eh_target_reset_handler = pmcraid_eh_target_reset_handler,\n\t.eh_device_reset_handler = pmcraid_eh_device_reset_handler,\n\t.eh_host_reset_handler = pmcraid_eh_host_reset_handler,\n\n\t.slave_alloc = pmcraid_slave_alloc,\n\t.slave_configure = pmcraid_slave_configure,\n\t.slave_destroy = pmcraid_slave_destroy,\n\t.change_queue_depth = pmcraid_change_queue_depth,\n\t.change_queue_type  = pmcraid_change_queue_type,\n\t.can_queue = PMCRAID_MAX_IO_CMD,\n\t.this_id = -1,\n\t.sg_tablesize = PMCRAID_MAX_IOADLS,\n\t.max_sectors = PMCRAID_IOA_MAX_SECTORS,\n\t.cmd_per_lun = PMCRAID_MAX_CMD_PER_LUN,\n\t.use_clustering = ENABLE_CLUSTERING,\n\t.shost_attrs = pmcraid_host_attrs,\n\t.proc_name = PMCRAID_DRIVER_NAME\n};\n\n/*\n * pmcraid_isr_msix - implements MSI-X interrupt handling routine\n * @irq: interrupt vector number\n * @dev_id: pointer hrrq_vector\n *\n * Return Value\n *\t IRQ_HANDLED if interrupt is handled or IRQ_NONE if ignored\n */\n\nstatic irqreturn_t pmcraid_isr_msix(int irq, void *dev_id)\n{\n\tstruct pmcraid_isr_param *hrrq_vector;\n\tstruct pmcraid_instance *pinstance;\n\tunsigned long lock_flags;\n\tu32 intrs_val;\n\tint hrrq_id;\n\n\thrrq_vector = (struct pmcraid_isr_param *)dev_id;\n\thrrq_id = hrrq_vector->hrrq_id;\n\tpinstance = hrrq_vector->drv_inst;\n\n\tif (!hrrq_id) {\n\t\t/* Read the interrupt */\n\t\tintrs_val = pmcraid_read_interrupts(pinstance);\n\t\tif (intrs_val &&\n\t\t\t((ioread32(pinstance->int_regs.host_ioa_interrupt_reg)\n\t\t\t& DOORBELL_INTR_MSIX_CLR) == 0)) {\n\t\t\t/* Any error interrupts including unit_check,\n\t\t\t * initiate IOA reset.In case of unit check indicate\n\t\t\t * to reset_sequence that IOA unit checked and prepare\n\t\t\t * for a dump during reset sequence\n\t\t\t */\n\t\t\tif (intrs_val & PMCRAID_ERROR_INTERRUPTS) {\n\t\t\t\tif (intrs_val & INTRS_IOA_UNIT_CHECK)\n\t\t\t\t\tpinstance->ioa_unit_check = 1;\n\n\t\t\t\tpmcraid_err(\"ISR: error interrupts: %x \\\n\t\t\t\t\tinitiating reset\\n\", intrs_val);\n\t\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\tlock_flags);\n\t\t\t\tpmcraid_initiate_reset(pinstance);\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\tpinstance->host->host_lock,\n\t\t\t\t\tlock_flags);\n\t\t\t}\n\t\t\t/* If interrupt was as part of the ioa initialization,\n\t\t\t * clear it. Delete the timer and wakeup the\n\t\t\t * reset engine to proceed with reset sequence\n\t\t\t */\n\t\t\tif (intrs_val & INTRS_TRANSITION_TO_OPERATIONAL)\n\t\t\t\tpmcraid_clr_trans_op(pinstance);\n\n\t\t\t/* Clear the interrupt register by writing\n\t\t\t * to host to ioa doorbell. Once done\n\t\t\t * FW will clear the interrupt.\n\t\t\t */\n\t\t\tiowrite32(DOORBELL_INTR_MSIX_CLR,\n\t\t\t\tpinstance->int_regs.host_ioa_interrupt_reg);\n\t\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\n\n\t\t}\n\t}\n\n\ttasklet_schedule(&(pinstance->isr_tasklet[hrrq_id]));\n\n\treturn IRQ_HANDLED;\n}\n\n/**\n * pmcraid_isr  - implements legacy interrupt handling routine\n *\n * @irq: interrupt vector number\n * @dev_id: pointer hrrq_vector\n *\n * Return Value\n *\t IRQ_HANDLED if interrupt is handled or IRQ_NONE if ignored\n */\nstatic irqreturn_t pmcraid_isr(int irq, void *dev_id)\n{\n\tstruct pmcraid_isr_param *hrrq_vector;\n\tstruct pmcraid_instance *pinstance;\n\tu32 intrs;\n\tunsigned long lock_flags;\n\tint hrrq_id = 0;\n\n\t/* In case of legacy interrupt mode where interrupts are shared across\n\t * isrs, it may be possible that the current interrupt is not from IOA\n\t */\n\tif (!dev_id) {\n\t\tprintk(KERN_INFO \"%s(): NULL host pointer\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\thrrq_vector = (struct pmcraid_isr_param *)dev_id;\n\tpinstance = hrrq_vector->drv_inst;\n\n\tintrs = pmcraid_read_interrupts(pinstance);\n\n\tif (unlikely((intrs & PMCRAID_PCI_INTERRUPTS) == 0))\n\t\treturn IRQ_NONE;\n\n\t/* Any error interrupts including unit_check, initiate IOA reset.\n\t * In case of unit check indicate to reset_sequence that IOA unit\n\t * checked and prepare for a dump during reset sequence\n\t */\n\tif (intrs & PMCRAID_ERROR_INTERRUPTS) {\n\n\t\tif (intrs & INTRS_IOA_UNIT_CHECK)\n\t\t\tpinstance->ioa_unit_check = 1;\n\n\t\tiowrite32(intrs,\n\t\t\t  pinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\tpmcraid_err(\"ISR: error interrupts: %x initiating reset\\n\",\n\t\t\t    intrs);\n\t\tintrs = ioread32(\n\t\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_initiate_reset(pinstance);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t} else {\n\t\t/* If interrupt was as part of the ioa initialization,\n\t\t * clear. Delete the timer and wakeup the\n\t\t * reset engine to proceed with reset sequence\n\t\t */\n\t\tif (intrs & INTRS_TRANSITION_TO_OPERATIONAL) {\n\t\t\tpmcraid_clr_trans_op(pinstance);\n\t\t} else {\n\t\t\tiowrite32(intrs,\n\t\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\t\tioread32(\n\t\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\n\t\t\ttasklet_schedule(\n\t\t\t\t\t&(pinstance->isr_tasklet[hrrq_id]));\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n\n/**\n * pmcraid_worker_function -  worker thread function\n *\n * @workp: pointer to struct work queue\n *\n * Return Value\n *\t None\n */\n\nstatic void pmcraid_worker_function(struct work_struct *workp)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\tstruct pmcraid_resource_entry *temp;\n\tstruct scsi_device *sdev;\n\tunsigned long lock_flags;\n\tunsigned long host_lock_flags;\n\tu16 fw_version;\n\tu8 bus, target, lun;\n\n\tpinstance = container_of(workp, struct pmcraid_instance, worker_q);\n\t/* add resources only after host is added into system */\n\tif (!atomic_read(&pinstance->expose_resources))\n\t\treturn;\n\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\n\tspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\n\tlist_for_each_entry_safe(res, temp, &pinstance->used_res_q, queue) {\n\n\t\tif (res->change_detected == RES_CHANGE_DEL && res->scsi_dev) {\n\t\t\tsdev = res->scsi_dev;\n\n\t\t\t/* host_lock must be held before calling\n\t\t\t * scsi_device_get\n\t\t\t */\n\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\t  host_lock_flags);\n\t\t\tif (!scsi_device_get(sdev)) {\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\tpinstance->host->host_lock,\n\t\t\t\t\t\thost_lock_flags);\n\t\t\t\tpmcraid_info(\"deleting %x from midlayer\\n\",\n\t\t\t\t\t     res->cfg_entry.resource_address);\n\t\t\t\tlist_move_tail(&res->queue,\n\t\t\t\t\t\t&pinstance->free_res_q);\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t&pinstance->resource_lock,\n\t\t\t\t\tlock_flags);\n\t\t\t\tscsi_remove_device(sdev);\n\t\t\t\tscsi_device_put(sdev);\n\t\t\t\tspin_lock_irqsave(&pinstance->resource_lock,\n\t\t\t\t\t\t   lock_flags);\n\t\t\t\tres->change_detected = 0;\n\t\t\t} else {\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\tpinstance->host->host_lock,\n\t\t\t\t\t\thost_lock_flags);\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_for_each_entry(res, &pinstance->used_res_q, queue) {\n\n\t\tif (res->change_detected == RES_CHANGE_ADD) {\n\n\t\t\tif (!pmcraid_expose_resource(fw_version,\n\t\t\t\t\t\t     &res->cfg_entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (RES_IS_VSET(res->cfg_entry)) {\n\t\t\t\tbus = PMCRAID_VSET_BUS_ID;\n\t\t\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\t\t\ttarget = res->cfg_entry.unique_flags1;\n\t\t\t\telse\n\t\t\t\t\ttarget = res->cfg_entry.array_id & 0xFF;\n\t\t\t\tlun = PMCRAID_VSET_LUN_ID;\n\t\t\t} else {\n\t\t\t\tbus = PMCRAID_PHYS_BUS_ID;\n\t\t\t\ttarget =\n\t\t\t\t     RES_TARGET(\n\t\t\t\t\tres->cfg_entry.resource_address);\n\t\t\t\tlun = RES_LUN(res->cfg_entry.resource_address);\n\t\t\t}\n\n\t\t\tres->change_detected = 0;\n\t\t\tspin_unlock_irqrestore(&pinstance->resource_lock,\n\t\t\t\t\t\tlock_flags);\n\t\t\tscsi_add_device(pinstance->host, bus, target, lun);\n\t\t\tspin_lock_irqsave(&pinstance->resource_lock,\n\t\t\t\t\t   lock_flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\n}\n\n/**\n * pmcraid_tasklet_function - Tasklet function\n *\n * @instance: pointer to msix param structure\n *\n * Return Value\n *\tNone\n */\nstatic void pmcraid_tasklet_function(unsigned long instance)\n{\n\tstruct pmcraid_isr_param *hrrq_vector;\n\tstruct pmcraid_instance *pinstance;\n\tunsigned long hrrq_lock_flags;\n\tunsigned long pending_lock_flags;\n\tunsigned long host_lock_flags;\n\tspinlock_t *lockp; /* hrrq buffer lock */\n\tint id;\n\t__le32 resp;\n\n\thrrq_vector = (struct pmcraid_isr_param *)instance;\n\tpinstance = hrrq_vector->drv_inst;\n\tid = hrrq_vector->hrrq_id;\n\tlockp = &(pinstance->hrrq_lock[id]);\n\n\t/* loop through each of the commands responded by IOA. Each HRRQ buf is\n\t * protected by its own lock. Traversals must be done within this lock\n\t * as there may be multiple tasklets running on multiple CPUs. Note\n\t * that the lock is held just for picking up the response handle and\n\t * manipulating hrrq_curr/toggle_bit values.\n\t */\n\tspin_lock_irqsave(lockp, hrrq_lock_flags);\n\n\tresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\n\n\twhile ((resp & HRRQ_TOGGLE_BIT) ==\n\t\tpinstance->host_toggle_bit[id]) {\n\n\t\tint cmd_index = resp >> 2;\n\t\tstruct pmcraid_cmd *cmd = NULL;\n\n\t\tif (pinstance->hrrq_curr[id] < pinstance->hrrq_end[id]) {\n\t\t\tpinstance->hrrq_curr[id]++;\n\t\t} else {\n\t\t\tpinstance->hrrq_curr[id] = pinstance->hrrq_start[id];\n\t\t\tpinstance->host_toggle_bit[id] ^= 1u;\n\t\t}\n\n\t\tif (cmd_index >= PMCRAID_MAX_CMD) {\n\t\t\t/* In case of invalid response handle, log message */\n\t\t\tpmcraid_err(\"Invalid response handle %d\\n\", cmd_index);\n\t\t\tresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd = pinstance->cmd_list[cmd_index];\n\t\tspin_unlock_irqrestore(lockp, hrrq_lock_flags);\n\n\t\tspin_lock_irqsave(&pinstance->pending_pool_lock,\n\t\t\t\t   pending_lock_flags);\n\t\tlist_del(&cmd->free_list);\n\t\tspin_unlock_irqrestore(&pinstance->pending_pool_lock,\n\t\t\t\t\tpending_lock_flags);\n\t\tdel_timer(&cmd->timer);\n\t\tatomic_dec(&pinstance->outstanding_cmds);\n\n\t\tif (cmd->cmd_done == pmcraid_ioa_reset) {\n\t\t\tspin_lock_irqsave(pinstance->host->host_lock,\n\t\t\t\t\t  host_lock_flags);\n\t\t\tcmd->cmd_done(cmd);\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       host_lock_flags);\n\t\t} else if (cmd->cmd_done != NULL) {\n\t\t\tcmd->cmd_done(cmd);\n\t\t}\n\t\t/* loop over until we are done with all responses */\n\t\tspin_lock_irqsave(lockp, hrrq_lock_flags);\n\t\tresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\n\t}\n\n\tspin_unlock_irqrestore(lockp, hrrq_lock_flags);\n}\n\n/**\n * pmcraid_unregister_interrupt_handler - de-register interrupts handlers\n * @pinstance: pointer to adapter instance structure\n *\n * This routine un-registers registered interrupt handler and\n * also frees irqs/vectors.\n *\n * Retun Value\n *\tNone\n */\nstatic\nvoid pmcraid_unregister_interrupt_handler(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tfor (i = 0; i < pinstance->num_hrrq; i++)\n\t\tfree_irq(pinstance->hrrq_vector[i].vector,\n\t\t\t &(pinstance->hrrq_vector[i]));\n\n\tif (pinstance->interrupt_mode) {\n\t\tpci_disable_msix(pinstance->pdev);\n\t\tpinstance->interrupt_mode = 0;\n\t}\n}\n\n/**\n * pmcraid_register_interrupt_handler - registers interrupt handler\n * @pinstance: pointer to per-adapter instance structure\n *\n * Return Value\n *\t0 on success, non-zero error code otherwise.\n */\nstatic int\npmcraid_register_interrupt_handler(struct pmcraid_instance *pinstance)\n{\n\tint rc;\n\tstruct pci_dev *pdev = pinstance->pdev;\n\n\tif ((pmcraid_enable_msix) &&\n\t\t(pci_find_capability(pdev, PCI_CAP_ID_MSIX))) {\n\t\tint num_hrrq = PMCRAID_NUM_MSIX_VECTORS;\n\t\tstruct msix_entry entries[PMCRAID_NUM_MSIX_VECTORS];\n\t\tint i;\n\t\tfor (i = 0; i < PMCRAID_NUM_MSIX_VECTORS; i++)\n\t\t\tentries[i].entry = i;\n\n\t\trc = pci_enable_msix(pdev, entries, num_hrrq);\n\t\tif (rc < 0)\n\t\t\tgoto pmcraid_isr_legacy;\n\n\t\t/* Check how many MSIX vectors are allocated and register\n\t\t * msi-x handlers for each of them giving appropriate buffer\n\t\t */\n\t\tif (rc > 0) {\n\t\t\tnum_hrrq = rc;\n\t\t\tif (pci_enable_msix(pdev, entries, num_hrrq))\n\t\t\t\tgoto pmcraid_isr_legacy;\n\t\t}\n\n\t\tfor (i = 0; i < num_hrrq; i++) {\n\t\t\tpinstance->hrrq_vector[i].hrrq_id = i;\n\t\t\tpinstance->hrrq_vector[i].drv_inst = pinstance;\n\t\t\tpinstance->hrrq_vector[i].vector = entries[i].vector;\n\t\t\trc = request_irq(pinstance->hrrq_vector[i].vector,\n\t\t\t\t\tpmcraid_isr_msix, 0,\n\t\t\t\t\tPMCRAID_DRIVER_NAME,\n\t\t\t\t\t&(pinstance->hrrq_vector[i]));\n\n\t\t\tif (rc) {\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tfree_irq(entries[j].vector,\n\t\t\t\t\t\t &(pinstance->hrrq_vector[j]));\n\t\t\t\tpci_disable_msix(pdev);\n\t\t\t\tgoto pmcraid_isr_legacy;\n\t\t\t}\n\t\t}\n\n\t\tpinstance->num_hrrq = num_hrrq;\n\t\tpinstance->interrupt_mode = 1;\n\t\tiowrite32(DOORBELL_INTR_MODE_MSIX,\n\t\t\t  pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tgoto pmcraid_isr_out;\n\t}\n\npmcraid_isr_legacy:\n\t/* If MSI-X registration failed fallback to legacy mode, where\n\t * only one hrrq entry will be used\n\t */\n\tpinstance->hrrq_vector[0].hrrq_id = 0;\n\tpinstance->hrrq_vector[0].drv_inst = pinstance;\n\tpinstance->hrrq_vector[0].vector = pdev->irq;\n\tpinstance->num_hrrq = 1;\n\trc = 0;\n\n\trc = request_irq(pdev->irq, pmcraid_isr, IRQF_SHARED,\n\t\t\t PMCRAID_DRIVER_NAME, &pinstance->hrrq_vector[0]);\npmcraid_isr_out:\n\treturn rc;\n}\n\n/**\n * pmcraid_release_cmd_blocks - release buufers allocated for command blocks\n * @pinstance: per adapter instance structure pointer\n * @max_index: number of buffer blocks to release\n *\n * Return Value\n *  None\n */\nstatic void\npmcraid_release_cmd_blocks(struct pmcraid_instance *pinstance, int max_index)\n{\n\tint i;\n\tfor (i = 0; i < max_index; i++) {\n\t\tkmem_cache_free(pinstance->cmd_cachep, pinstance->cmd_list[i]);\n\t\tpinstance->cmd_list[i] = NULL;\n\t}\n\tkmem_cache_destroy(pinstance->cmd_cachep);\n\tpinstance->cmd_cachep = NULL;\n}\n\n/**\n * pmcraid_release_control_blocks - releases buffers alloced for control blocks\n * @pinstance: pointer to per adapter instance structure\n * @max_index: number of buffers (from 0 onwards) to release\n *\n * This function assumes that the command blocks for which control blocks are\n * linked are not released.\n *\n * Return Value\n *\t None\n */\nstatic void\npmcraid_release_control_blocks(\n\tstruct pmcraid_instance *pinstance,\n\tint max_index\n)\n{\n\tint i;\n\n\tif (pinstance->control_pool == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < max_index; i++) {\n\t\tpci_pool_free(pinstance->control_pool,\n\t\t\t      pinstance->cmd_list[i]->ioa_cb,\n\t\t\t      pinstance->cmd_list[i]->ioa_cb_bus_addr);\n\t\tpinstance->cmd_list[i]->ioa_cb = NULL;\n\t\tpinstance->cmd_list[i]->ioa_cb_bus_addr = 0;\n\t}\n\tpci_pool_destroy(pinstance->control_pool);\n\tpinstance->control_pool = NULL;\n}\n\n/**\n * pmcraid_allocate_cmd_blocks - allocate memory for cmd block structures\n * @pinstance - pointer to per adapter instance structure\n *\n * Allocates memory for command blocks using kernel slab allocator.\n *\n * Return Value\n *\t0 in case of success; -ENOMEM in case of failure\n */\nstatic int __devinit\npmcraid_allocate_cmd_blocks(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tsprintf(pinstance->cmd_pool_name, \"pmcraid_cmd_pool_%d\",\n\t\tpinstance->host->unique_id);\n\n\n\tpinstance->cmd_cachep = kmem_cache_create(\n\t\t\t\t\tpinstance->cmd_pool_name,\n\t\t\t\t\tsizeof(struct pmcraid_cmd), 0,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!pinstance->cmd_cachep)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\n\t\tpinstance->cmd_list[i] =\n\t\t\tkmem_cache_alloc(pinstance->cmd_cachep, GFP_KERNEL);\n\t\tif (!pinstance->cmd_list[i]) {\n\t\t\tpmcraid_release_cmd_blocks(pinstance, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * pmcraid_allocate_control_blocks - allocates memory control blocks\n * @pinstance : pointer to per adapter instance structure\n *\n * This function allocates PCI memory for DMAable buffers like IOARCB, IOADLs\n * and IOASAs. This is called after command blocks are already allocated.\n *\n * Return Value\n *  0 in case it can allocate all control blocks, otherwise -ENOMEM\n */\nstatic int __devinit\npmcraid_allocate_control_blocks(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tsprintf(pinstance->ctl_pool_name, \"pmcraid_control_pool_%d\",\n\t\tpinstance->host->unique_id);\n\n\tpinstance->control_pool =\n\t\tpci_pool_create(pinstance->ctl_pool_name,\n\t\t\t\tpinstance->pdev,\n\t\t\t\tsizeof(struct pmcraid_control_block),\n\t\t\t\tPMCRAID_IOARCB_ALIGNMENT, 0);\n\n\tif (!pinstance->control_pool)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\n\t\tpinstance->cmd_list[i]->ioa_cb =\n\t\t\tpci_pool_alloc(\n\t\t\t\tpinstance->control_pool,\n\t\t\t\tGFP_KERNEL,\n\t\t\t\t&(pinstance->cmd_list[i]->ioa_cb_bus_addr));\n\n\t\tif (!pinstance->cmd_list[i]->ioa_cb) {\n\t\t\tpmcraid_release_control_blocks(pinstance, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(pinstance->cmd_list[i]->ioa_cb, 0,\n\t\t\tsizeof(struct pmcraid_control_block));\n\t}\n\treturn 0;\n}\n\n/**\n * pmcraid_release_host_rrqs - release memory allocated for hrrq buffer(s)\n * @pinstance: pointer to per adapter instance structure\n * @maxindex: size of hrrq buffer pointer array\n *\n * Return Value\n *\tNone\n */\nstatic void\npmcraid_release_host_rrqs(struct pmcraid_instance *pinstance, int maxindex)\n{\n\tint i;\n\tfor (i = 0; i < maxindex; i++) {\n\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    HRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD,\n\t\t\t\t    pinstance->hrrq_start[i],\n\t\t\t\t    pinstance->hrrq_start_bus_addr[i]);\n\n\t\t/* reset pointers and toggle bit to zeros */\n\t\tpinstance->hrrq_start[i] = NULL;\n\t\tpinstance->hrrq_start_bus_addr[i] = 0;\n\t\tpinstance->host_toggle_bit[i] = 0;\n\t}\n}\n\n/**\n * pmcraid_allocate_host_rrqs - Allocate and initialize host RRQ buffers\n * @pinstance: pointer to per adapter instance structure\n *\n * Return value\n *\t0 hrrq buffers are allocated, -ENOMEM otherwise.\n */\nstatic int __devinit\npmcraid_allocate_host_rrqs(struct pmcraid_instance *pinstance)\n{\n\tint i, buffer_size;\n\n\tbuffer_size = HRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD;\n\n\tfor (i = 0; i < pinstance->num_hrrq; i++) {\n\t\tpinstance->hrrq_start[i] =\n\t\t\tpci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tbuffer_size,\n\t\t\t\t\t&(pinstance->hrrq_start_bus_addr[i]));\n\n\t\tif (pinstance->hrrq_start[i] == 0) {\n\t\t\tpmcraid_err(\"pci_alloc failed for hrrq vector : %d\\n\",\n\t\t\t\t    i);\n\t\t\tpmcraid_release_host_rrqs(pinstance, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemset(pinstance->hrrq_start[i], 0, buffer_size);\n\t\tpinstance->hrrq_curr[i] = pinstance->hrrq_start[i];\n\t\tpinstance->hrrq_end[i] =\n\t\t\tpinstance->hrrq_start[i] + PMCRAID_MAX_CMD - 1;\n\t\tpinstance->host_toggle_bit[i] = 1;\n\t\tspin_lock_init(&pinstance->hrrq_lock[i]);\n\t}\n\treturn 0;\n}\n\n/**\n * pmcraid_release_hcams - release HCAM buffers\n *\n * @pinstance: pointer to per adapter instance structure\n *\n * Return value\n *  none\n */\nstatic void pmcraid_release_hcams(struct pmcraid_instance *pinstance)\n{\n\tif (pinstance->ccn.msg != NULL) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    PMCRAID_AEN_HDR_SIZE +\n\t\t\t\t    sizeof(struct pmcraid_hcam_ccn_ext),\n\t\t\t\t    pinstance->ccn.msg,\n\t\t\t\t    pinstance->ccn.baddr);\n\n\t\tpinstance->ccn.msg = NULL;\n\t\tpinstance->ccn.hcam = NULL;\n\t\tpinstance->ccn.baddr = 0;\n\t}\n\n\tif (pinstance->ldn.msg != NULL) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    PMCRAID_AEN_HDR_SIZE +\n\t\t\t\t    sizeof(struct pmcraid_hcam_ldn),\n\t\t\t\t    pinstance->ldn.msg,\n\t\t\t\t    pinstance->ldn.baddr);\n\n\t\tpinstance->ldn.msg = NULL;\n\t\tpinstance->ldn.hcam = NULL;\n\t\tpinstance->ldn.baddr = 0;\n\t}\n}\n\n/**\n * pmcraid_allocate_hcams - allocates HCAM buffers\n * @pinstance : pointer to per adapter instance structure\n *\n * Return Value:\n *   0 in case of successful allocation, non-zero otherwise\n */\nstatic int pmcraid_allocate_hcams(struct pmcraid_instance *pinstance)\n{\n\tpinstance->ccn.msg = pci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tPMCRAID_AEN_HDR_SIZE +\n\t\t\t\t\tsizeof(struct pmcraid_hcam_ccn_ext),\n\t\t\t\t\t&(pinstance->ccn.baddr));\n\n\tpinstance->ldn.msg = pci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tPMCRAID_AEN_HDR_SIZE +\n\t\t\t\t\tsizeof(struct pmcraid_hcam_ldn),\n\t\t\t\t\t&(pinstance->ldn.baddr));\n\n\tif (pinstance->ldn.msg == NULL || pinstance->ccn.msg == NULL) {\n\t\tpmcraid_release_hcams(pinstance);\n\t} else {\n\t\tpinstance->ccn.hcam =\n\t\t\t(void *)pinstance->ccn.msg + PMCRAID_AEN_HDR_SIZE;\n\t\tpinstance->ldn.hcam =\n\t\t\t(void *)pinstance->ldn.msg + PMCRAID_AEN_HDR_SIZE;\n\n\t\tatomic_set(&pinstance->ccn.ignore, 0);\n\t\tatomic_set(&pinstance->ldn.ignore, 0);\n\t}\n\n\treturn (pinstance->ldn.msg == NULL) ? -ENOMEM : 0;\n}\n\n/**\n * pmcraid_release_config_buffers - release config.table buffers\n * @pinstance: pointer to per adapter instance structure\n *\n * Return Value\n *\t none\n */\nstatic void pmcraid_release_config_buffers(struct pmcraid_instance *pinstance)\n{\n\tif (pinstance->cfg_table != NULL &&\n\t    pinstance->cfg_table_bus_addr != 0) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    sizeof(struct pmcraid_config_table),\n\t\t\t\t    pinstance->cfg_table,\n\t\t\t\t    pinstance->cfg_table_bus_addr);\n\t\tpinstance->cfg_table = NULL;\n\t\tpinstance->cfg_table_bus_addr = 0;\n\t}\n\n\tif (pinstance->res_entries != NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PMCRAID_MAX_RESOURCES; i++)\n\t\t\tlist_del(&pinstance->res_entries[i].queue);\n\t\tkfree(pinstance->res_entries);\n\t\tpinstance->res_entries = NULL;\n\t}\n\n\tpmcraid_release_hcams(pinstance);\n}\n\n/**\n * pmcraid_allocate_config_buffers - allocates DMAable memory for config table\n * @pinstance : pointer to per adapter instance structure\n *\n * Return Value\n *\t0 for successful allocation, -ENOMEM for any failure\n */\nstatic int __devinit\npmcraid_allocate_config_buffers(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tpinstance->res_entries =\n\t\t\tkzalloc(sizeof(struct pmcraid_resource_entry) *\n\t\t\t\tPMCRAID_MAX_RESOURCES, GFP_KERNEL);\n\n\tif (NULL == pinstance->res_entries) {\n\t\tpmcraid_err(\"failed to allocate memory for resource table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < PMCRAID_MAX_RESOURCES; i++)\n\t\tlist_add_tail(&pinstance->res_entries[i].queue,\n\t\t\t      &pinstance->free_res_q);\n\n\tpinstance->cfg_table =\n\t\tpci_alloc_consistent(pinstance->pdev,\n\t\t\t\t     sizeof(struct pmcraid_config_table),\n\t\t\t\t     &pinstance->cfg_table_bus_addr);\n\n\tif (NULL == pinstance->cfg_table) {\n\t\tpmcraid_err(\"couldn't alloc DMA memory for config table\\n\");\n\t\tpmcraid_release_config_buffers(pinstance);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pmcraid_allocate_hcams(pinstance)) {\n\t\tpmcraid_err(\"could not alloc DMA memory for HCAMS\\n\");\n\t\tpmcraid_release_config_buffers(pinstance);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/**\n * pmcraid_init_tasklets - registers tasklets for response handling\n *\n * @pinstance: pointer adapter instance structure\n *\n * Return value\n *\tnone\n */\nstatic void pmcraid_init_tasklets(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\tfor (i = 0; i < pinstance->num_hrrq; i++)\n\t\ttasklet_init(&pinstance->isr_tasklet[i],\n\t\t\t     pmcraid_tasklet_function,\n\t\t\t     (unsigned long)&pinstance->hrrq_vector[i]);\n}\n\n/**\n * pmcraid_kill_tasklets - destroys tasklets registered for response handling\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return value\n *\tnone\n */\nstatic void pmcraid_kill_tasklets(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\tfor (i = 0; i < pinstance->num_hrrq; i++)\n\t\ttasklet_kill(&pinstance->isr_tasklet[i]);\n}\n\n/**\n * pmcraid_release_buffers - release per-adapter buffers allocated\n *\n * @pinstance: pointer to adapter soft state\n *\n * Return Value\n *\tnone\n */\nstatic void pmcraid_release_buffers(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_release_config_buffers(pinstance);\n\tpmcraid_release_control_blocks(pinstance, PMCRAID_MAX_CMD);\n\tpmcraid_release_cmd_blocks(pinstance, PMCRAID_MAX_CMD);\n\tpmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\n\n\tif (pinstance->inq_data != NULL) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    sizeof(struct pmcraid_inquiry_data),\n\t\t\t\t    pinstance->inq_data,\n\t\t\t\t    pinstance->inq_data_baddr);\n\n\t\tpinstance->inq_data = NULL;\n\t\tpinstance->inq_data_baddr = 0;\n\t}\n\n\tif (pinstance->timestamp_data != NULL) {\n\t\tpci_free_consistent(pinstance->pdev,\n\t\t\t\t    sizeof(struct pmcraid_timestamp_data),\n\t\t\t\t    pinstance->timestamp_data,\n\t\t\t\t    pinstance->timestamp_data_baddr);\n\n\t\tpinstance->timestamp_data = NULL;\n\t\tpinstance->timestamp_data_baddr = 0;\n\t}\n}\n\n/**\n * pmcraid_init_buffers - allocates memory and initializes various structures\n * @pinstance: pointer to per adapter instance structure\n *\n * This routine pre-allocates memory based on the type of block as below:\n * cmdblocks(PMCRAID_MAX_CMD): kernel memory using kernel's slab_allocator,\n * IOARCBs(PMCRAID_MAX_CMD)  : DMAable memory, using pci pool allocator\n * config-table entries      : DMAable memory using pci_alloc_consistent\n * HostRRQs                  : DMAable memory, using pci_alloc_consistent\n *\n * Return Value\n *\t 0 in case all of the blocks are allocated, -ENOMEM otherwise.\n */\nstatic int __devinit pmcraid_init_buffers(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\n\tif (pmcraid_allocate_host_rrqs(pinstance)) {\n\t\tpmcraid_err(\"couldn't allocate memory for %d host rrqs\\n\",\n\t\t\t     pinstance->num_hrrq);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pmcraid_allocate_config_buffers(pinstance)) {\n\t\tpmcraid_err(\"couldn't allocate memory for config buffers\\n\");\n\t\tpmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pmcraid_allocate_cmd_blocks(pinstance)) {\n\t\tpmcraid_err(\"couldn't allocate memory for cmd blocks\\n\");\n\t\tpmcraid_release_config_buffers(pinstance);\n\t\tpmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pmcraid_allocate_control_blocks(pinstance)) {\n\t\tpmcraid_err(\"couldn't allocate memory control blocks\\n\");\n\t\tpmcraid_release_config_buffers(pinstance);\n\t\tpmcraid_release_cmd_blocks(pinstance, PMCRAID_MAX_CMD);\n\t\tpmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* allocate DMAable memory for page D0 INQUIRY buffer */\n\tpinstance->inq_data = pci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tsizeof(struct pmcraid_inquiry_data),\n\t\t\t\t\t&pinstance->inq_data_baddr);\n\n\tif (pinstance->inq_data == NULL) {\n\t\tpmcraid_err(\"couldn't allocate DMA memory for INQUIRY\\n\");\n\t\tpmcraid_release_buffers(pinstance);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* allocate DMAable memory for set timestamp data buffer */\n\tpinstance->timestamp_data = pci_alloc_consistent(\n\t\t\t\t\tpinstance->pdev,\n\t\t\t\t\tsizeof(struct pmcraid_timestamp_data),\n\t\t\t\t\t&pinstance->timestamp_data_baddr);\n\n\tif (pinstance->timestamp_data == NULL) {\n\t\tpmcraid_err(\"couldn't allocate DMA memory for \\\n\t\t\t\tset time_stamp \\n\");\n\t\tpmcraid_release_buffers(pinstance);\n\t\treturn -ENOMEM;\n\t}\n\n\n\t/* Initialize all the command blocks and add them to free pool. No\n\t * need to lock (free_pool_lock) as this is done in initialization\n\t * itself\n\t */\n\tfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\n\t\tstruct pmcraid_cmd *cmdp = pinstance->cmd_list[i];\n\t\tpmcraid_init_cmdblk(cmdp, i);\n\t\tcmdp->drv_inst = pinstance;\n\t\tlist_add_tail(&cmdp->free_list, &pinstance->free_cmd_pool);\n\t}\n\n\treturn 0;\n}\n\n/**\n * pmcraid_reinit_buffers - resets various buffer pointers\n * @pinstance: pointer to adapter instance\n * Return value\n *\tnone\n */\nstatic void pmcraid_reinit_buffers(struct pmcraid_instance *pinstance)\n{\n\tint i;\n\tint buffer_size = HRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD;\n\n\tfor (i = 0; i < pinstance->num_hrrq; i++) {\n\t\tmemset(pinstance->hrrq_start[i], 0, buffer_size);\n\t\tpinstance->hrrq_curr[i] = pinstance->hrrq_start[i];\n\t\tpinstance->hrrq_end[i] =\n\t\t\tpinstance->hrrq_start[i] + PMCRAID_MAX_CMD - 1;\n\t\tpinstance->host_toggle_bit[i] = 1;\n\t}\n}\n\n/**\n * pmcraid_init_instance - initialize per instance data structure\n * @pdev: pointer to pci device structure\n * @host: pointer to Scsi_Host structure\n * @mapped_pci_addr: memory mapped IOA configuration registers\n *\n * Return Value\n *\t 0 on success, non-zero in case of any failure\n */\nstatic int __devinit pmcraid_init_instance(\n\tstruct pci_dev *pdev,\n\tstruct Scsi_Host *host,\n\tvoid __iomem *mapped_pci_addr\n)\n{\n\tstruct pmcraid_instance *pinstance =\n\t\t(struct pmcraid_instance *)host->hostdata;\n\n\tpinstance->host = host;\n\tpinstance->pdev = pdev;\n\n\t/* Initialize register addresses */\n\tpinstance->mapped_dma_addr = mapped_pci_addr;\n\n\t/* Initialize chip-specific details */\n\t{\n\t\tstruct pmcraid_chip_details *chip_cfg = pinstance->chip_cfg;\n\t\tstruct pmcraid_interrupts *pint_regs = &pinstance->int_regs;\n\n\t\tpinstance->ioarrin = mapped_pci_addr + chip_cfg->ioarrin;\n\n\t\tpint_regs->ioa_host_interrupt_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_intr;\n\t\tpint_regs->ioa_host_interrupt_clr_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_intr_clr;\n\t\tpint_regs->ioa_host_msix_interrupt_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_msix_intr;\n\t\tpint_regs->host_ioa_interrupt_reg =\n\t\t\tmapped_pci_addr + chip_cfg->host_ioa_intr;\n\t\tpint_regs->host_ioa_interrupt_clr_reg =\n\t\t\tmapped_pci_addr + chip_cfg->host_ioa_intr_clr;\n\n\t\t/* Current version of firmware exposes interrupt mask set\n\t\t * and mask clr registers through memory mapped bar0.\n\t\t */\n\t\tpinstance->mailbox = mapped_pci_addr + chip_cfg->mailbox;\n\t\tpinstance->ioa_status = mapped_pci_addr + chip_cfg->ioastatus;\n\t\tpint_regs->ioa_host_interrupt_mask_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_mask;\n\t\tpint_regs->ioa_host_interrupt_mask_clr_reg =\n\t\t\tmapped_pci_addr + chip_cfg->ioa_host_mask_clr;\n\t\tpint_regs->global_interrupt_mask_reg =\n\t\t\tmapped_pci_addr + chip_cfg->global_intr_mask;\n\t};\n\n\tpinstance->ioa_reset_attempts = 0;\n\tinit_waitqueue_head(&pinstance->reset_wait_q);\n\n\tatomic_set(&pinstance->outstanding_cmds, 0);\n\tatomic_set(&pinstance->last_message_id, 0);\n\tatomic_set(&pinstance->expose_resources, 0);\n\n\tINIT_LIST_HEAD(&pinstance->free_res_q);\n\tINIT_LIST_HEAD(&pinstance->used_res_q);\n\tINIT_LIST_HEAD(&pinstance->free_cmd_pool);\n\tINIT_LIST_HEAD(&pinstance->pending_cmd_pool);\n\n\tspin_lock_init(&pinstance->free_pool_lock);\n\tspin_lock_init(&pinstance->pending_pool_lock);\n\tspin_lock_init(&pinstance->resource_lock);\n\tmutex_init(&pinstance->aen_queue_lock);\n\n\t/* Work-queue (Shared) for deferred processing error handling */\n\tINIT_WORK(&pinstance->worker_q, pmcraid_worker_function);\n\n\t/* Initialize the default log_level */\n\tpinstance->current_log_level = pmcraid_log_level;\n\n\t/* Setup variables required for reset engine */\n\tpinstance->ioa_state = IOA_STATE_UNKNOWN;\n\tpinstance->reset_cmd = NULL;\n\treturn 0;\n}\n\n/**\n * pmcraid_shutdown - shutdown adapter controller.\n * @pdev: pci device struct\n *\n * Issues an adapter shutdown to the card waits for its completion\n *\n * Return value\n *\t  none\n */\nstatic void pmcraid_shutdown(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\tpmcraid_reset_bringdown(pinstance);\n}\n\n\n/**\n * pmcraid_get_minor - returns unused minor number from minor number bitmap\n */\nstatic unsigned short pmcraid_get_minor(void)\n{\n\tint minor;\n\n\tminor = find_first_zero_bit(pmcraid_minor, sizeof(pmcraid_minor));\n\t__set_bit(minor, pmcraid_minor);\n\treturn minor;\n}\n\n/**\n * pmcraid_release_minor - releases given minor back to minor number bitmap\n */\nstatic void pmcraid_release_minor(unsigned short minor)\n{\n\t__clear_bit(minor, pmcraid_minor);\n}\n\n/**\n * pmcraid_setup_chrdev - allocates a minor number and registers a char device\n *\n * @pinstance: pointer to adapter instance for which to register device\n *\n * Return value\n *\t0 in case of success, otherwise non-zero\n */\nstatic int pmcraid_setup_chrdev(struct pmcraid_instance *pinstance)\n{\n\tint minor;\n\tint error;\n\n\tminor = pmcraid_get_minor();\n\tcdev_init(&pinstance->cdev, &pmcraid_fops);\n\tpinstance->cdev.owner = THIS_MODULE;\n\n\terror = cdev_add(&pinstance->cdev, MKDEV(pmcraid_major, minor), 1);\n\n\tif (error)\n\t\tpmcraid_release_minor(minor);\n\telse\n\t\tdevice_create(pmcraid_class, NULL, MKDEV(pmcraid_major, minor),\n\t\t\t      NULL, \"%s%u\", PMCRAID_DEVFILE, minor);\n\treturn error;\n}\n\n/**\n * pmcraid_release_chrdev - unregisters per-adapter management interface\n *\n * @pinstance: pointer to adapter instance structure\n *\n * Return value\n *  none\n */\nstatic void pmcraid_release_chrdev(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_release_minor(MINOR(pinstance->cdev.dev));\n\tdevice_destroy(pmcraid_class,\n\t\t       MKDEV(pmcraid_major, MINOR(pinstance->cdev.dev)));\n\tcdev_del(&pinstance->cdev);\n}\n\n/**\n * pmcraid_remove - IOA hot plug remove entry point\n * @pdev: pci device struct\n *\n * Return value\n *\t  none\n */\nstatic void __devexit pmcraid_remove(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\n\t/* remove the management interface (/dev file) for this device */\n\tpmcraid_release_chrdev(pinstance);\n\n\t/* remove host template from scsi midlayer */\n\tscsi_remove_host(pinstance->host);\n\n\t/* block requests from mid-layer */\n\tscsi_block_requests(pinstance->host);\n\n\t/* initiate shutdown adapter */\n\tpmcraid_shutdown(pdev);\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tflush_work_sync(&pinstance->worker_q);\n\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\tpmcraid_release_buffers(pinstance);\n\tiounmap(pinstance->mapped_dma_addr);\n\tpci_release_regions(pdev);\n\tscsi_host_put(pinstance->host);\n\tpci_disable_device(pdev);\n\n\treturn;\n}\n\n#ifdef CONFIG_PM\n/**\n * pmcraid_suspend - driver suspend entry point for power management\n * @pdev:   PCI device structure\n * @state:  PCI power state to suspend routine\n *\n * Return Value - 0 always\n */\nstatic int pmcraid_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\n\tpmcraid_shutdown(pdev);\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tpmcraid_kill_tasklets(pinstance);\n\tpci_set_drvdata(pinstance->pdev, pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\n/**\n * pmcraid_resume - driver resume entry point PCI power management\n * @pdev: PCI device structure\n *\n * Return Value - 0 in case of success. Error code in case of any failure\n */\nstatic int pmcraid_resume(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\tstruct Scsi_Host *host = pinstance->host;\n\tint rc;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\n\trc = pci_enable_device(pdev);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"resume: Enable device failed\\n\");\n\t\treturn rc;\n\t}\n\n\tpci_set_master(pdev);\n\n\tif ((sizeof(dma_addr_t) == 4) ||\n\t     pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\n\t\trc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\tif (rc == 0)\n\t\trc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\tif (rc != 0) {\n\t\tdev_err(&pdev->dev, \"resume: Failed to set PCI DMA mask\\n\");\n\t\tgoto disable_device;\n\t}\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tatomic_set(&pinstance->outstanding_cmds, 0);\n\trc = pmcraid_register_interrupt_handler(pinstance);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"resume: couldn't register interrupt handlers\\n\");\n\t\trc = -ENODEV;\n\t\tgoto release_host;\n\t}\n\n\tpmcraid_init_tasklets(pinstance);\n\tpmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\n\n\t/* Start with hard reset sequence which brings up IOA to operational\n\t * state as well as completes the reset sequence.\n\t */\n\tpinstance->ioa_hard_reset = 1;\n\n\t/* Start IOA firmware initialization and bring card to Operational\n\t * state.\n\t */\n\tif (pmcraid_reset_bringup(pinstance)) {\n\t\tdev_err(&pdev->dev, \"couldn't initialize IOA\\n\");\n\t\trc = -ENODEV;\n\t\tgoto release_tasklets;\n\t}\n\n\treturn 0;\n\nrelease_tasklets:\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\nrelease_host:\n\tscsi_host_put(host);\n\ndisable_device:\n\tpci_disable_device(pdev);\n\n\treturn rc;\n}\n\n#else\n\n#define pmcraid_suspend NULL\n#define pmcraid_resume  NULL\n\n#endif /* CONFIG_PM */\n\n/**\n * pmcraid_complete_ioa_reset - Called by either timer or tasklet during\n *\t\t\t\tcompletion of the ioa reset\n * @cmd: pointer to reset command block\n */\nstatic void pmcraid_complete_ioa_reset(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(pinstance->host->host_lock, flags);\n\tpmcraid_ioa_reset(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, flags);\n\tscsi_unblock_requests(pinstance->host);\n\tschedule_work(&pinstance->worker_q);\n}\n\n/**\n * pmcraid_set_supported_devs - sends SET SUPPORTED DEVICES to IOAFP\n *\n * @cmd: pointer to pmcraid_cmd structure\n *\n * Return Value\n *  0 for success or non-zero for failure cases\n */\nstatic void pmcraid_set_supported_devs(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tvoid (*cmd_done) (struct pmcraid_cmd *) = pmcraid_complete_ioa_reset;\n\n\tpmcraid_reinit_cmdblk(cmd);\n\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->cdb[0] = PMCRAID_SET_SUPPORTED_DEVICES;\n\tioarcb->cdb[1] = ALL_DEVICES_SUPPORTED;\n\n\t/* If this was called as part of resource table reinitialization due to\n\t * lost CCN, it is enough to return the command block back to free pool\n\t * as part of set_supported_devs completion function.\n\t */\n\tif (cmd->drv_inst->reinit_cfg_table) {\n\t\tcmd->drv_inst->reinit_cfg_table = 0;\n\t\tcmd->release = 1;\n\t\tcmd_done = pmcraid_reinit_cfgtable_done;\n\t}\n\n\t/* we will be done with the reset sequence after set supported devices,\n\t * setup the done function to return the command block back to free\n\t * pool\n\t */\n\tpmcraid_send_cmd(cmd,\n\t\t\t cmd_done,\n\t\t\t PMCRAID_SET_SUP_DEV_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n\treturn;\n}\n\n/**\n * pmcraid_set_timestamp - set the timestamp to IOAFP\n *\n * @cmd: pointer to pmcraid_cmd structure\n *\n * Return Value\n *  0 for success or non-zero for failure cases\n */\nstatic void pmcraid_set_timestamp(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\t__be32 time_stamp_len = cpu_to_be32(PMCRAID_TIMESTAMP_LEN);\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\n\tstruct timeval tv;\n\t__le64 timestamp;\n\n\tdo_gettimeofday(&tv);\n\ttimestamp = tv.tv_sec * 1000;\n\n\tpinstance->timestamp_data->timestamp[0] = (__u8)(timestamp);\n\tpinstance->timestamp_data->timestamp[1] = (__u8)((timestamp) >> 8);\n\tpinstance->timestamp_data->timestamp[2] = (__u8)((timestamp) >> 16);\n\tpinstance->timestamp_data->timestamp[3] = (__u8)((timestamp) >> 24);\n\tpinstance->timestamp_data->timestamp[4] = (__u8)((timestamp) >> 32);\n\tpinstance->timestamp_data->timestamp[5] = (__u8)((timestamp)  >> 40);\n\n\tpmcraid_reinit_cmdblk(cmd);\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->cdb[0] = PMCRAID_SCSI_SET_TIMESTAMP;\n\tioarcb->cdb[1] = PMCRAID_SCSI_SERVICE_ACTION;\n\tmemcpy(&(ioarcb->cdb[6]), &time_stamp_len, sizeof(time_stamp_len));\n\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->request_flags0 |= TRANSFER_DIR_WRITE;\n\tioarcb->data_transfer_length =\n\t\tcpu_to_le32(sizeof(struct pmcraid_timestamp_data));\n\tioadl = &(ioarcb->add_data.u.ioadl[0]);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\tioadl->address = cpu_to_le64(pinstance->timestamp_data_baddr);\n\tioadl->data_len = cpu_to_le32(sizeof(struct pmcraid_timestamp_data));\n\n\tif (!pinstance->timestamp_error) {\n\t\tpinstance->timestamp_error = 0;\n\t\tpmcraid_send_cmd(cmd, pmcraid_set_supported_devs,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n\t} else {\n\t\tpmcraid_send_cmd(cmd, pmcraid_return_cmd,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n\t\treturn;\n\t}\n}\n\n\n/**\n * pmcraid_init_res_table - Initialize the resource table\n * @cmd:  pointer to pmcraid command struct\n *\n * This function looks through the existing resource table, comparing\n * it with the config table. This function will take care of old/new\n * devices and schedule adding/removing them from the mid-layer\n * as appropriate.\n *\n * Return value\n *\t None\n */\nstatic void pmcraid_init_res_table(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tstruct pmcraid_resource_entry *res, *temp;\n\tstruct pmcraid_config_table_entry *cfgte;\n\tunsigned long lock_flags;\n\tint found, rc, i;\n\tu16 fw_version;\n\tLIST_HEAD(old_res);\n\n\tif (pinstance->cfg_table->flags & MICROCODE_UPDATE_REQUIRED)\n\t\tpmcraid_err(\"IOA requires microcode download\\n\");\n\n\tfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\n\n\t/* resource list is protected by pinstance->resource_lock.\n\t * init_res_table can be called from probe (user-thread) or runtime\n\t * reset (timer/tasklet)\n\t */\n\tspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\n\n\tlist_for_each_entry_safe(res, temp, &pinstance->used_res_q, queue)\n\t\tlist_move_tail(&res->queue, &old_res);\n\n\tfor (i = 0; i < pinstance->cfg_table->num_entries; i++) {\n\t\tif (be16_to_cpu(pinstance->inq_data->fw_version) <=\n\t\t\t\t\t\tPMCRAID_FW_VERSION_1)\n\t\t\tcfgte = &pinstance->cfg_table->entries[i];\n\t\telse\n\t\t\tcfgte = (struct pmcraid_config_table_entry *)\n\t\t\t\t\t&pinstance->cfg_table->entries_ext[i];\n\n\t\tif (!pmcraid_expose_resource(fw_version, cfgte))\n\t\t\tcontinue;\n\n\t\tfound = 0;\n\n\t\t/* If this entry was already detected and initialized */\n\t\tlist_for_each_entry_safe(res, temp, &old_res, queue) {\n\n\t\t\trc = memcmp(&res->cfg_entry.resource_address,\n\t\t\t\t    &cfgte->resource_address,\n\t\t\t\t    sizeof(cfgte->resource_address));\n\t\t\tif (!rc) {\n\t\t\t\tlist_move_tail(&res->queue,\n\t\t\t\t\t\t&pinstance->used_res_q);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* If this is new entry, initialize it and add it the queue */\n\t\tif (!found) {\n\n\t\t\tif (list_empty(&pinstance->free_res_q)) {\n\t\t\t\tpmcraid_err(\"Too many devices attached\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfound = 1;\n\t\t\tres = list_entry(pinstance->free_res_q.next,\n\t\t\t\t\t struct pmcraid_resource_entry, queue);\n\n\t\t\tres->scsi_dev = NULL;\n\t\t\tres->change_detected = RES_CHANGE_ADD;\n\t\t\tres->reset_progress = 0;\n\t\t\tlist_move_tail(&res->queue, &pinstance->used_res_q);\n\t\t}\n\n\t\t/* copy new configuration table entry details into driver\n\t\t * maintained resource entry\n\t\t */\n\t\tif (found) {\n\t\t\tmemcpy(&res->cfg_entry, cfgte,\n\t\t\t\t\tpinstance->config_table_entry_size);\n\t\t\tpmcraid_info(\"New res type:%x, vset:%x, addr:%x:\\n\",\n\t\t\t\t res->cfg_entry.resource_type,\n\t\t\t\t (fw_version <= PMCRAID_FW_VERSION_1 ?\n\t\t\t\t\tres->cfg_entry.unique_flags1 :\n\t\t\t\t\t\tres->cfg_entry.array_id & 0xFF),\n\t\t\t\t le32_to_cpu(res->cfg_entry.resource_address));\n\t\t}\n\t}\n\n\t/* Detect any deleted entries, mark them for deletion from mid-layer */\n\tlist_for_each_entry_safe(res, temp, &old_res, queue) {\n\n\t\tif (res->scsi_dev) {\n\t\t\tres->change_detected = RES_CHANGE_DEL;\n\t\t\tres->cfg_entry.resource_handle =\n\t\t\t\tPMCRAID_INVALID_RES_HANDLE;\n\t\t\tlist_move_tail(&res->queue, &pinstance->used_res_q);\n\t\t} else {\n\t\t\tlist_move_tail(&res->queue, &pinstance->free_res_q);\n\t\t}\n\t}\n\n\t/* release the resource list lock */\n\tspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\n\tpmcraid_set_timestamp(cmd);\n}\n\n/**\n * pmcraid_querycfg - Send a Query IOA Config to the adapter.\n * @cmd: pointer pmcraid_cmd struct\n *\n * This function sends a Query IOA Configuration command to the adapter to\n * retrieve the IOA configuration table.\n *\n * Return value:\n *\tnone\n */\nstatic void pmcraid_querycfg(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tint cfg_table_size = cpu_to_be32(sizeof(struct pmcraid_config_table));\n\n\tif (be16_to_cpu(pinstance->inq_data->fw_version) <=\n\t\t\t\t\tPMCRAID_FW_VERSION_1)\n\t\tpinstance->config_table_entry_size =\n\t\t\tsizeof(struct pmcraid_config_table_entry);\n\telse\n\t\tpinstance->config_table_entry_size =\n\t\t\tsizeof(struct pmcraid_config_table_entry_ext);\n\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\n\tioarcb->cdb[0] = PMCRAID_QUERY_IOA_CONFIG;\n\n\t/* firmware requires 4-byte length field, specified in B.E format */\n\tmemcpy(&(ioarcb->cdb[10]), &cfg_table_size, sizeof(cfg_table_size));\n\n\t/* Since entire config table can be described by single IOADL, it can\n\t * be part of IOARCB itself\n\t */\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length =\n\t\tcpu_to_le32(sizeof(struct pmcraid_config_table));\n\n\tioadl = &(ioarcb->add_data.u.ioadl[0]);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\tioadl->address = cpu_to_le64(pinstance->cfg_table_bus_addr);\n\tioadl->data_len = cpu_to_le32(sizeof(struct pmcraid_config_table));\n\n\tpmcraid_send_cmd(cmd, pmcraid_init_res_table,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n}\n\n\n/**\n * pmcraid_probe - PCI probe entry pointer for PMC MaxRAID controller driver\n * @pdev: pointer to pci device structure\n * @dev_id: pointer to device ids structure\n *\n * Return Value\n *\treturns 0 if the device is claimed and successfully configured.\n *\treturns non-zero error code in case of any failure\n */\nstatic int __devinit pmcraid_probe(\n\tstruct pci_dev *pdev,\n\tconst struct pci_device_id *dev_id\n)\n{\n\tstruct pmcraid_instance *pinstance;\n\tstruct Scsi_Host *host;\n\tvoid __iomem *mapped_pci_addr;\n\tint rc = PCIBIOS_SUCCESSFUL;\n\n\tif (atomic_read(&pmcraid_adapter_count) >= PMCRAID_MAX_ADAPTERS) {\n\t\tpmcraid_err\n\t\t\t(\"maximum number(%d) of supported adapters reached\\n\",\n\t\t\t atomic_read(&pmcraid_adapter_count));\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_inc(&pmcraid_adapter_count);\n\trc = pci_enable_device(pdev);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot enable adapter\\n\");\n\t\tatomic_dec(&pmcraid_adapter_count);\n\t\treturn rc;\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t\"Found new IOA(%x:%x), Total IOA count: %d\\n\",\n\t\t pdev->vendor, pdev->device,\n\t\t atomic_read(&pmcraid_adapter_count));\n\n\trc = pci_request_regions(pdev, PMCRAID_DRIVER_NAME);\n\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Couldn't register memory range of registers\\n\");\n\t\tgoto out_disable_device;\n\t}\n\n\tmapped_pci_addr = pci_iomap(pdev, 0, 0);\n\n\tif (!mapped_pci_addr) {\n\t\tdev_err(&pdev->dev, \"Couldn't map PCI registers memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\n\tpci_set_master(pdev);\n\n\t/* Firmware requires the system bus address of IOARCB to be within\n\t * 32-bit addressable range though it has 64-bit IOARRIN register.\n\t * However, firmware supports 64-bit streaming DMA buffers, whereas\n\t * coherent buffers are to be 32-bit. Since pci_alloc_consistent always\n\t * returns memory within 4GB (if not, change this logic), coherent\n\t * buffers are within firmware acceptable address ranges.\n\t */\n\tif ((sizeof(dma_addr_t) == 4) ||\n\t    pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\n\t\trc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\t/* firmware expects 32-bit DMA addresses for IOARRIN register; set 32\n\t * bit mask for pci_alloc_consistent to return addresses within 4GB\n\t */\n\tif (rc == 0)\n\t\trc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\tif (rc != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to set PCI DMA mask\\n\");\n\t\tgoto cleanup_nomem;\n\t}\n\n\thost = scsi_host_alloc(&pmcraid_host_template,\n\t\t\t\tsizeof(struct pmcraid_instance));\n\n\tif (!host) {\n\t\tdev_err(&pdev->dev, \"scsi_host_alloc failed!\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto cleanup_nomem;\n\t}\n\n\thost->max_id = PMCRAID_MAX_NUM_TARGETS_PER_BUS;\n\thost->max_lun = PMCRAID_MAX_NUM_LUNS_PER_TARGET;\n\thost->unique_id = host->host_no;\n\thost->max_channel = PMCRAID_MAX_BUS_TO_SCAN;\n\thost->max_cmd_len = PMCRAID_MAX_CDB_LEN;\n\n\t/* zero out entire instance structure */\n\tpinstance = (struct pmcraid_instance *)host->hostdata;\n\tmemset(pinstance, 0, sizeof(*pinstance));\n\n\tpinstance->chip_cfg =\n\t\t(struct pmcraid_chip_details *)(dev_id->driver_data);\n\n\trc = pmcraid_init_instance(pdev, host, mapped_pci_addr);\n\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"failed to initialize adapter instance\\n\");\n\t\tgoto out_scsi_host_put;\n\t}\n\n\tpci_set_drvdata(pdev, pinstance);\n\n\t/* Save PCI config-space for use following the reset */\n\trc = pci_save_state(pinstance->pdev);\n\n\tif (rc != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to save PCI config space\\n\");\n\t\tgoto out_scsi_host_put;\n\t}\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\n\trc = pmcraid_register_interrupt_handler(pinstance);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"couldn't register interrupt handler\\n\");\n\t\tgoto out_scsi_host_put;\n\t}\n\n\tpmcraid_init_tasklets(pinstance);\n\n\t/* allocate verious buffers used by LLD.*/\n\trc = pmcraid_init_buffers(pinstance);\n\n\tif (rc) {\n\t\tpmcraid_err(\"couldn't allocate memory blocks\\n\");\n\t\tgoto out_unregister_isr;\n\t}\n\n\t/* check the reset type required */\n\tpmcraid_reset_type(pinstance);\n\n\tpmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\n\n\t/* Start IOA firmware initialization and bring card to Operational\n\t * state.\n\t */\n\tpmcraid_info(\"starting IOA initialization sequence\\n\");\n\tif (pmcraid_reset_bringup(pinstance)) {\n\t\tdev_err(&pdev->dev, \"couldn't initialize IOA\\n\");\n\t\trc = 1;\n\t\tgoto out_release_bufs;\n\t}\n\n\t/* Add adapter instance into mid-layer list */\n\trc = scsi_add_host(pinstance->host, &pdev->dev);\n\tif (rc != 0) {\n\t\tpmcraid_err(\"couldn't add host into mid-layer: %d\\n\", rc);\n\t\tgoto out_release_bufs;\n\t}\n\n\tscsi_scan_host(pinstance->host);\n\n\trc = pmcraid_setup_chrdev(pinstance);\n\n\tif (rc != 0) {\n\t\tpmcraid_err(\"couldn't create mgmt interface, error: %x\\n\",\n\t\t\t     rc);\n\t\tgoto out_remove_host;\n\t}\n\n\t/* Schedule worker thread to handle CCN and take care of adding and\n\t * removing devices to OS\n\t */\n\tatomic_set(&pinstance->expose_resources, 1);\n\tschedule_work(&pinstance->worker_q);\n\treturn rc;\n\nout_remove_host:\n\tscsi_remove_host(host);\n\nout_release_bufs:\n\tpmcraid_release_buffers(pinstance);\n\nout_unregister_isr:\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\nout_scsi_host_put:\n\tscsi_host_put(host);\n\ncleanup_nomem:\n\tiounmap(mapped_pci_addr);\n\nout_release_regions:\n\tpci_release_regions(pdev);\n\nout_disable_device:\n\tatomic_dec(&pmcraid_adapter_count);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_disable_device(pdev);\n\treturn -ENODEV;\n}\n\n/*\n * PCI driver structure of pcmraid driver\n */\nstatic struct pci_driver pmcraid_driver = {\n\t.name = PMCRAID_DRIVER_NAME,\n\t.id_table = pmcraid_pci_table,\n\t.probe = pmcraid_probe,\n\t.remove = pmcraid_remove,\n\t.suspend = pmcraid_suspend,\n\t.resume = pmcraid_resume,\n\t.shutdown = pmcraid_shutdown\n};\n\n/**\n * pmcraid_init - module load entry point\n */\nstatic int __init pmcraid_init(void)\n{\n\tdev_t dev;\n\tint error;\n\n\tpmcraid_info(\"%s Device Driver version: %s\\n\",\n\t\t\t PMCRAID_DRIVER_NAME, PMCRAID_DRIVER_VERSION);\n\n\terror = alloc_chrdev_region(&dev, 0,\n\t\t\t\t    PMCRAID_MAX_ADAPTERS,\n\t\t\t\t    PMCRAID_DEVFILE);\n\n\tif (error) {\n\t\tpmcraid_err(\"failed to get a major number for adapters\\n\");\n\t\tgoto out_init;\n\t}\n\n\tpmcraid_major = MAJOR(dev);\n\tpmcraid_class = class_create(THIS_MODULE, PMCRAID_DEVFILE);\n\n\tif (IS_ERR(pmcraid_class)) {\n\t\terror = PTR_ERR(pmcraid_class);\n\t\tpmcraid_err(\"failed to register with with sysfs, error = %x\\n\",\n\t\t\t    error);\n\t\tgoto out_unreg_chrdev;\n\t}\n\n\terror = pmcraid_netlink_init();\n\n\tif (error)\n\t\tgoto out_unreg_chrdev;\n\n\terror = pci_register_driver(&pmcraid_driver);\n\n\tif (error == 0)\n\t\tgoto out_init;\n\n\tpmcraid_err(\"failed to register pmcraid driver, error = %x\\n\",\n\t\t     error);\n\tclass_destroy(pmcraid_class);\n\tpmcraid_netlink_release();\n\nout_unreg_chrdev:\n\tunregister_chrdev_region(MKDEV(pmcraid_major, 0), PMCRAID_MAX_ADAPTERS);\n\nout_init:\n\treturn error;\n}\n\n/**\n * pmcraid_exit - module unload entry point\n */\nstatic void __exit pmcraid_exit(void)\n{\n\tpmcraid_netlink_release();\n\tunregister_chrdev_region(MKDEV(pmcraid_major, 0),\n\t\t\t\t PMCRAID_MAX_ADAPTERS);\n\tpci_unregister_driver(&pmcraid_driver);\n\tclass_destroy(pmcraid_class);\n}\n\nmodule_init(pmcraid_init);\nmodule_exit(pmcraid_exit);\n"], "filenames": ["drivers/scsi/pmcraid.c"], "buggy_code_start_loc": [3873], "buggy_code_end_loc": [3873], "fixing_code_start_loc": [3874], "fixing_code_end_loc": [3877], "type": "CWE-400", "message": "** DISPUTED ** Integer signedness error in the pmcraid_ioctl_passthrough function in drivers/scsi/pmcraid.c in the Linux kernel before 3.1 might allow local users to cause a denial of service (memory consumption or memory corruption) via a negative size value in an ioctl call. NOTE: this may be a vulnerability only in unusual environments that provide a privileged program for obtaining the required file descriptor.", "other": {"cve": {"id": "CVE-2011-2906", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-24T23:55:02.120", "lastModified": "2023-02-12T20:15:11.317", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "** DISPUTED ** Integer signedness error in the pmcraid_ioctl_passthrough function in drivers/scsi/pmcraid.c in the Linux kernel before 3.1 might allow local users to cause a denial of service (memory consumption or memory corruption) via a negative size value in an ioctl call. NOTE: this may be a vulnerability only in unusual environments that provide a privileged program for obtaining the required file descriptor."}, {"lang": "es", "value": "** DISPUTADA ** Error de signo de enteros en la funci\u00f3n pmcraid_ioctl_passthrough en drivers/scsi/pmcraid.c en el kernel de Linux anterior a 3.1 podr\u00eda permitir a usuarios locales causar una denegaci\u00f3n de servicio (consumo de memoria o corrupci\u00f3n de memoria) a trav\u00e9s de un valor de tama\u00f1o negativo en una llamada ioctl. NOTA: esto podr\u00eda tratarse de una vulnerabilidad exclusivamente en entornos inusuales que proporcionan un programa privilegiado para para obtener el descriptor de ficheros requerido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1", "matchCriteriaId": "156989A4-23D9-434A-B512-9C0F3583D13D"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=b5b515445f4f5a905c5dd27e6e682868ccd6c09d", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/09/8", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d"}}