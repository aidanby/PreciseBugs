{"buggy_code": ["const idrErr = require('../../utils/error')\n\nclass OrgControllerError extends idrErr.IDRError {\n  orgDneParam (shortname) { // org\n    const err = {}\n    err.error = 'ORG_DNE_PARAM'\n    err.message = `The '${shortname}' organization designated by the shortname parameter does not exist.`\n    return err\n  }\n\n  userDne (username) { // org\n    const err = {}\n    err.error = 'USER_DNE'\n    err.message = `The user '${username}' designated by the username parameter does not exist.`\n    return err\n  }\n\n  notSameOrgOrSecretariat () { // org\n    const err = {}\n    err.error = 'NOT_SAME_ORG_OR_SECRETARIAT'\n    err.message = 'This information can only be viewed by the users of the same organization or the Secretariat.'\n    return err\n  }\n\n  orgExists (shortname) { // org\n    const err = {}\n    err.error = 'ORG_EXISTS'\n    err.message = `The '${shortname}' organization already exists.`\n    return err\n  }\n\n  userExists (username) { // org\n    const err = {}\n    err.error = 'USER_EXISTS'\n    err.message = `The user '${username}' already exists.`\n    return err\n  }\n\n  uuidProvided () { // org\n    const err = {}\n    err.error = 'UUID_PROVIDED'\n    err.message = 'Providing UUIDs for user creation or update is not allowed.'\n    return err\n  }\n\n  duplicateUsername (shortname, username) { // org\n    const err = {}\n    err.error = 'DUPLICATE_USERNAME'\n    err.message = `The user could not be updated because the '${shortname}' organization contains another user with the username '${username}'.`\n    return err\n  }\n\n  duplicateShortname (shortname) { // org\n    const err = {}\n    err.error = 'DUPLICATE_SHORTNAME'\n    err.message = `The organization cannot be renamed as '${shortname}' because this shortname is used by another organization.`\n    return err\n  }\n}\n\nmodule.exports = {\n  OrgControllerError\n}\n", "require('dotenv').config()\nconst User = require('../../model/user')\nconst Org = require('../../model/org')\nconst logger = require('../../middleware/logger')\nconst argon2 = require('argon2')\nconst CONSTANTS = require('../../constants')\nconst cryptoRandomString = require('crypto-random-string')\nconst uuid = require('uuid')\nconst errors = require('./error')\nconst error = new errors.OrgControllerError()\nconst options = CONSTANTS.PAGINATOR_OPTIONS\n\n// Get the details of all orgs\nasync function getOrgs (req, res, next) {\n  try {\n    options.sort = { short_name: 'asc' }\n    options.page = req.ctx.query.page ? parseInt(req.ctx.query.page) : CONSTANTS.PAGINATOR_PAGE // if 'page' query parameter is not defined, set 'page' to the default page value\n    const repo = req.ctx.repositories.getOrgRepository()\n\n    const agt = setAggregateOrgObj({})\n    const pg = await repo.aggregatePaginate(agt, options)\n    const payload = { organizations: pg.itemsList }\n\n    if (pg.itemCount >= CONSTANTS.PAGINATOR_OPTIONS.limit) {\n      payload.totalCount = pg.itemCount\n      payload.itemsPerPage = pg.itemsPerPage\n      payload.pageCount = pg.pageCount\n      payload.currentPage = pg.currentPage\n      payload.prevPage = pg.prevPage\n      payload.nextPage = pg.nextPage\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: 'The orgs were sent to the user.' })\n    return res.status(200).json(payload)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Get the details of a single org for the specified shortname\nasync function getOrg (req, res, next) {\n  try {\n    const orgShortName = req.ctx.org\n    const shortName = req.ctx.params.shortname\n    const repo = req.ctx.repositories.getOrgRepository()\n    const isSecretariat = await repo.isSecretariat(orgShortName)\n\n    if (orgShortName !== shortName && !isSecretariat) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization can only be viewed by the users of the same organization or the Secretariat.' })\n      return res.status(403).json(error.notSameOrgOrSecretariat())\n    }\n\n    const agt = setAggregateOrgObj({ short_name: shortName })\n    let result = await repo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    if (!result) { // an empty result can only happen if the requestor is the Secretariat\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization was sent to the user.', org: result })\n    return res.status(200).json(result)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Get the details of all users from an org given the specified shortname\nasync function getUsers (req, res, next) {\n  try {\n    options.sort = { username: 'asc' }\n    options.page = req.ctx.query.page ? parseInt(req.ctx.query.page) : CONSTANTS.PAGINATOR_PAGE // if 'page' query parameter is not defined, set 'page' to the default page value\n    const shortName = req.ctx.org\n    const orgShortName = req.ctx.params.shortname\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const orgUUID = await orgRepo.getOrgUUID(orgShortName)\n    const isSecretariat = await orgRepo.isSecretariat(shortName)\n\n    if (!orgUUID) {\n      logger.info({ uuid: req.ctx.uuid, message: orgShortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(orgShortName))\n    }\n\n    if (orgShortName !== shortName && !isSecretariat) {\n      logger.info({ uuid: req.ctx.uuid, message: orgShortName + ' organization can only be viewed by the users of the same organization or the Secretariat.' })\n      return res.status(403).json(error.notSameOrgOrSecretariat())\n    }\n\n    const agt = setAggregateUserObj({ org_UUID: orgUUID })\n    const pg = await userRepo.aggregatePaginate(agt, options)\n    const payload = { users: pg.itemsList }\n\n    if (pg.itemCount >= CONSTANTS.PAGINATOR_OPTIONS.limit) {\n      payload.totalCount = pg.itemCount\n      payload.itemsPerPage = pg.itemsPerPage\n      payload.pageCount = pg.pageCount\n      payload.currentPage = pg.currentPage\n      payload.prevPage = pg.prevPage\n      payload.nextPage = pg.nextPage\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: `The users of ${orgShortName} organization were sent to the user.` })\n    return res.status(200).json(payload)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Get the details of a single user for the specified username\nasync function getUser (req, res, next) {\n  try {\n    const shortName = req.ctx.org\n    const username = req.ctx.params.username\n    const orgShortName = req.ctx.params.shortname\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const isSecretariat = await orgRepo.isSecretariat(shortName)\n\n    if (orgShortName !== shortName && !isSecretariat) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization can only be viewed by that organization\\'s users or the Secretariat.' })\n      return res.status(403).json(error.notSameOrgOrSecretariat())\n    }\n\n    const orgUUID = await orgRepo.getOrgUUID(orgShortName)\n    if (!orgUUID) { // the org can only be non-existent if the requestor is the Secretariat\n      logger.info({ uuid: req.ctx.uuid, message: orgShortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(orgShortName))\n    }\n\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const agt = setAggregateUserObj({ username: username, org_UUID: orgUUID })\n    let result = await userRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    if (!result) {\n      logger.info({ uuid: req.ctx.uuid, message: username + ' does not exist.' })\n      return res.status(404).json(error.userDne(username))\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: username + ' was sent to the user.', user: result })\n    return res.status(200).json(result)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Get details on ID quota for an org with the specified org shortname\nasync function getOrgIdQuota (req, res, next) {\n  try {\n    const orgShortName = req.ctx.org\n    const shortName = req.ctx.params.shortname\n    const repo = req.ctx.repositories.getOrgRepository()\n    const isSecretariat = await repo.isSecretariat(orgShortName)\n\n    if (orgShortName !== shortName && !isSecretariat) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization id quota can only be viewed by the users of the same organization or the Secretariat.' })\n      return res.status(403).json(error.notSameOrgOrSecretariat())\n    }\n\n    let result = await repo.findOneByShortName(shortName)\n    if (!result) { // a null result can only happen if the requestor is the Secretariat\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    const returnPayload = {\n      id_quota: result.policies.id_quota,\n      total_reserved: null,\n      available: null\n    }\n\n    const query = {\n      owning_cna: await repo.getOrgUUID(shortName),\n      state: CONSTANTS.CVE_STATES.RESERVED\n    }\n    const cveIdRepo = req.ctx.repositories.getCveIdRepository()\n    result = await cveIdRepo.countDocuments(query)\n    returnPayload.total_reserved = result\n    returnPayload.available = returnPayload.id_quota - returnPayload.total_reserved\n\n    logger.info({ uuid: req.ctx.uuid, message: 'The organization\\'s id quota was returned to the user.', details: returnPayload })\n    return res.status(200).json(returnPayload)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Creates a new org only if the org doesn't exist for the specified shortname. If the org exists, we do not update the org.\nasync function createOrg (req, res, next) {\n  try {\n    const newOrg = new Org()\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n\n    Object.keys(req.ctx.body).forEach(k => {\n      const key = k.toLowerCase()\n\n      if (key === 'short_name') {\n        newOrg.short_name = req.ctx.body.short_name\n      } else if (key === 'name') {\n        newOrg.name = req.ctx.body.name\n      } else if (key === 'authority') {\n        if (req.ctx.body.authority.active_roles) {\n          newOrg.authority.active_roles = req.ctx.body.authority.active_roles\n        }\n      } else if (key === 'policies') {\n        if (req.ctx.body.policies.id_quota) {\n          newOrg.policies.id_quota = req.ctx.body.policies.id_quota\n        }\n      } else if (key === 'uuid') {\n        return res.status(400).json(error.uuidProvided())\n      }\n    })\n\n    let result = await orgRepo.findOneByShortName(newOrg.short_name) // Find org in MongoDB\n    if (result) {\n      logger.info({ uuid: req.ctx.uuid, message: newOrg.short_name + ' organization was not created because it already exists.' })\n      return res.status(400).json(error.orgExists(newOrg.short_name))\n    }\n\n    newOrg.inUse = false\n    newOrg.UUID = uuid.v4()\n    newOrg.authority.active_roles = [CONSTANTS.AUTH_ROLE_ENUM.CNA] // default role\n\n    if (!newOrg.policies.id_quota) {\n      newOrg.policies.id_quota = CONSTANTS.DEFAULT_ID_QUOTA\n    }\n\n    await orgRepo.updateByOrgUUID(newOrg.UUID, newOrg, { upsert: true }) // Create org in MongoDB if it doesn't exist\n    const agt = setAggregateOrgObj({ short_name: newOrg.short_name })\n    result = await orgRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    const responseMessage = {\n      message: newOrg.short_name + ' organization was successfully created.',\n      created: result\n    }\n\n    const payload = {\n      action: 'create_org',\n      change: newOrg.short_name + ' organization was successfully created.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),\n      org: result\n    }\n    const userRepo = req.ctx.repositories.getUserRepository()\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json(responseMessage)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Updates an org only if the org exist for the specified shortname. If no org exists, we do not create the org.\nasync function updateOrg (req, res, next) {\n  try {\n    const shortName = req.ctx.params.shortname\n    const newOrg = new Org()\n    const removeRoles = []\n    const addRoles = []\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const org = await orgRepo.findOneByShortName(shortName)\n    let agt = setAggregateOrgObj({ short_name: shortName })\n\n    // org doesn't exist\n    if (!org) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization could not be updated in MongoDB because it does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    Object.keys(req.ctx.query).forEach(k => {\n      const key = k.toLowerCase()\n\n      if (key === 'shortname') {\n        newOrg.short_name = req.ctx.query.shortname\n        agt = setAggregateOrgObj({ short_name: newOrg.short_name })\n      } else if (key === 'name') {\n        newOrg.name = req.ctx.query.name\n      } else if (key === 'id_quota') {\n        newOrg.policies.id_quota = req.ctx.query.id_quota\n      } else if (key === 'active_roles.add') {\n        if (Array.isArray(req.ctx.query['active_roles.add'])) {\n          req.ctx.query['active_roles.add'].forEach(r => {\n            addRoles.push(r)\n          })\n        }\n      } else if (key === 'active_roles.remove') {\n        if (Array.isArray(req.ctx.query['active_roles.remove'])) {\n          req.ctx.query['active_roles.remove'].forEach(r => {\n            removeRoles.push(r)\n          })\n        }\n      }\n    })\n\n    // updating the org's roles\n    if (org) {\n      const roles = org.authority.active_roles\n\n      // adding roles\n      addRoles.forEach(role => {\n        if (!roles.includes(role)) {\n          roles.push(role)\n        }\n      })\n\n      // removing roles\n      removeRoles.forEach(role => {\n        const index = roles.indexOf(role)\n\n        if (index > -1) {\n          roles.splice(index, 1)\n        }\n      })\n\n      newOrg.authority.active_roles = roles\n    }\n\n    if (newOrg.short_name) {\n      const result = await orgRepo.findOneByShortName(newOrg.short_name)\n\n      if (result) {\n        return res.status(403).json(error.duplicateShortname(newOrg.short_name))\n      }\n    }\n\n    // update org\n    let result = await orgRepo.updateByOrgUUID(org.UUID, newOrg)\n    if (result.n === 0) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization could not be updated in MongoDB because it does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    result = await orgRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    const responseMessage = {\n      message: shortName + ' organization was successfully updated.',\n      updated: result\n    }\n\n    const payload = {\n      action: 'update_org',\n      change: shortName + ' organization was successfully updated.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),\n      org: result\n    }\n    const userRepo = req.ctx.repositories.getUserRepository()\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json(responseMessage)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Creates a user only if the org exist and the user does not exist for the specified shortname and username\nasync function createUser (req, res, next) {\n  try {\n    const orgShortName = req.ctx.params.shortname\n    const requesterUsername = req.ctx.user\n    const requesterShortName = req.ctx.org\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const newUser = new User()\n\n    const orgUUID = await orgRepo.getOrgUUID(orgShortName)\n    if (!orgUUID) { // the org can only be non-existent if the requestor is the Secretariat\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be created because ' + orgShortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(orgShortName))\n    }\n\n    Object.keys(req.ctx.body).forEach(k => {\n      const key = k.toLowerCase()\n\n      if (key === 'username') {\n        newUser.username = req.ctx.body.username\n      } else if (key === 'authority') {\n        if (req.ctx.body.authority.active_roles) {\n          newUser.authority.active_roles = req.ctx.body.authority.active_roles\n        }\n      } else if (key === 'name') {\n        if (req.ctx.body.name.first) {\n          newUser.name.first = req.ctx.body.name.first\n        }\n        if (req.ctx.body.name.last) {\n          newUser.name.last = req.ctx.body.name.last\n        }\n        if (req.ctx.body.name.middle) {\n          newUser.name.middle = req.ctx.body.name.middle\n        }\n        if (req.ctx.body.name.suffix) {\n          newUser.name.suffix = req.ctx.body.name.suffix\n        }\n        if (req.ctx.body.name.surname) {\n          newUser.name.surname = req.ctx.body.name.surname\n        }\n      } else if (key === 'org_uuid') {\n        return res.status(400).json(error.uuidProvided())\n      } else if (key === 'uuid') {\n        return res.status(400).json(error.uuidProvided())\n      }\n    })\n\n    const requesterOrgUUID = await orgRepo.getOrgUUID(requesterShortName)\n    const isSecretariat = await orgRepo.isSecretariatUUID(requesterOrgUUID)\n    const isAdmin = await userRepo.isAdminUUID(requesterUsername, requesterOrgUUID)\n    // check if user is only an Admin (not Secretatiat) and the user does not belong to the same organization as the new user\n    if (!isSecretariat && isAdmin) {\n      if (requesterOrgUUID !== orgUUID) {\n        return res.status(403).json(error.notOrgAdminOrSecretariat()) // The Admin user must belong to the new user's organization\n      }\n    }\n\n    newUser.org_UUID = orgUUID\n    newUser.UUID = uuid.v4()\n    newUser.active = true\n    const randomKey = cryptoRandomString({ length: CONSTANTS.CRYPTO_RANDOM_STRING_LENGTH })\n    newUser.secret = await argon2.hash(randomKey)\n\n    let result = await userRepo.findOneByUserNameAndOrgUUID(newUser.username, newUser.org_UUID) // Find user in MongoDB\n    if (result) {\n      logger.info({ uuid: req.ctx.uuid, message: newUser.username + ' was not created because it already exists.' })\n      return res.status(400).json(error.userExists(newUser.username))\n    }\n\n    // Parsing all user name fields\n    newUser.name = parseUserName(newUser)\n\n    await userRepo.updateByUserNameAndOrgUUID(newUser.username, newUser.org_UUID, newUser, { upsert: true }) // Create user in MongoDB if it doesn't exist\n    const agt = setAggregateUserObj({ username: newUser.username, org_UUID: newUser.org_UUID })\n    result = await userRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    result.secret = randomKey\n    const responseMessage = {\n      message: result.username + ' was successfully created.',\n      created: result\n    }\n\n    const payload = {\n      action: 'create_user',\n      change: result.username + ' was successfully created.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),\n      user: result\n    }\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json(responseMessage)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Updates a user only if the user exist for the specified username. If no user exists, it does not create the user.\nasync function updateUser (req, res, next) {\n  try {\n    const requesterShortName = req.ctx.org\n    const requesterUsername = req.ctx.user\n    const username = req.ctx.params.username\n    const shortName = req.ctx.params.shortname\n    const newUser = new User()\n    let newOrgShortName\n    let changesRequirePrivilegedRole // Set variable to true if protected fields are being modified\n    const removeRoles = []\n    const addRoles = []\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const orgUUID = await orgRepo.getOrgUUID(shortName)\n    const isSecretariat = await orgRepo.isSecretariat(requesterShortName)\n    const isAdmin = await userRepo.isAdmin(requesterUsername, requesterShortName) // Check if requester is Admin of the designated user's org\n\n    if (!orgUUID) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + shortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    const user = await userRepo.findOneByUserNameAndOrgUUID(username, orgUUID)\n    if (!user) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + username + ' does not exist for ' + shortName + ' organization.' })\n      return res.status(404).json(error.userDne(username))\n    }\n\n    // check if the user is not the requester or if the requester is not a secretariat\n    if ((shortName !== requesterShortName || username !== requesterUsername) && !isSecretariat) {\n      // check if the requester is not and admin; if admin, the requester must be from the same org as the user\n      if (!isAdmin || (isAdmin && shortName !== requesterShortName)) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user can only be updated by the Secretariat, an Org admin or if the requester is the user.' })\n        return res.status(403).json(error.notSameUserOrSecretariat())\n      }\n    }\n\n    Object.keys(req.ctx.query).forEach(k => {\n      const key = k.toLowerCase()\n\n      if (key === 'new_username') {\n        newUser.username = req.ctx.query.new_username\n      } else if (key === 'org_shortname') {\n        newOrgShortName = req.ctx.query.org_shortname\n        changesRequirePrivilegedRole = true\n      } else if (key === 'name.first') {\n        newUser.name.first = req.ctx.query['name.first']\n      } else if (key === 'name.last') {\n        newUser.name.last = req.ctx.query['name.last']\n      } else if (key === 'name.middle') {\n        newUser.name.middle = req.ctx.query['name.middle']\n      } else if (key === 'name.suffix') {\n        newUser.name.suffix = req.ctx.query['name.suffix']\n      } else if (key === 'name.surname') {\n        newUser.name.surname = req.ctx.query['name.surname']\n      } else if (key === 'active') {\n        newUser.active = req.ctx.query.active\n        changesRequirePrivilegedRole = true\n      } else if (key === 'active_roles.add') {\n        if (Array.isArray(req.ctx.query['active_roles.add'])) {\n          req.ctx.query['active_roles.add'].forEach(r => {\n            addRoles.push(r)\n          })\n          changesRequirePrivilegedRole = true\n        }\n      } else if (key === 'active_roles.remove') {\n        if (Array.isArray(req.ctx.query['active_roles.remove'])) {\n          req.ctx.query['active_roles.remove'].forEach(r => {\n            removeRoles.push(r)\n          })\n          changesRequirePrivilegedRole = true\n        }\n      }\n    })\n\n    // updating user's roles and org_uuid is only allowed for secretariats and org admins\n    if (changesRequirePrivilegedRole && !(isAdmin || isSecretariat)) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + requesterUsername + ' user is not Org Admin or Secretariat to modify these fields.' })\n      return res.status(403).json(error.notOrgAdminOrSecretariat())\n    }\n\n    // check if the new org exist\n    if (newOrgShortName) {\n      newUser.org_UUID = await orgRepo.getOrgUUID(newOrgShortName)\n\n      if (!newUser.org_UUID) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + newOrgShortName + ' organization does not exist.' })\n        return res.status(404).json(error.orgDne(newOrgShortName))\n      }\n    }\n\n    let agt = setAggregateUserObj({ username: username, org_UUID: orgUUID })\n\n    // check if org has user of same username already\n    if (newUser.username && newUser.org_UUID) {\n      agt = setAggregateUserObj({ username: newUser.username, org_UUID: newUser.org_UUID })\n      const duplicateUsers = await userRepo.find({ org_UUID: newUser.org_UUID, username: newUser.username })\n      if (duplicateUsers.length) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + newOrgShortName + ' organization contains a user with the same username.' })\n        return res.status(403).json(error.duplicateUsername(newOrgShortName, newUser.username))\n      }\n    } else if (newUser.username) {\n      agt = setAggregateUserObj({ username: newUser.username, org_UUID: orgUUID })\n      const duplicateUsers = await userRepo.find({ org_UUID: orgUUID, username: newUser.username })\n      if (duplicateUsers.length) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + shortName + ' organization contains a user with the same username.' })\n        return res.status(403).json(error.duplicateUsername(shortName, newUser.username))\n      }\n    } else if (newUser.org_UUID) {\n      agt = setAggregateUserObj({ username: username, org_UUID: newUser.org_UUID })\n      const duplicateUsers = await userRepo.find({ org_UUID: newUser.org_UUID, username: username })\n      if (duplicateUsers.length) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + newOrgShortName + ' organization contains a user with the same username.' })\n        return res.status(403).json(error.duplicateUsername(newOrgShortName, username))\n      }\n    }\n\n    // updating the user's roles\n    const roles = user.authority.active_roles\n\n    // adding roles\n    addRoles.forEach(role => {\n      if (!roles.includes(role)) {\n        roles.push(role)\n      }\n    })\n\n    // removing roles\n    removeRoles.forEach(role => {\n      const index = roles.indexOf(role)\n\n      if (index > -1) {\n        roles.splice(index, 1)\n      }\n    })\n\n    newUser.authority.active_roles = roles\n\n    let result = await userRepo.updateByUserNameAndOrgUUID(username, orgUUID, newUser)\n    if (result.n === 0) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + username + ' does not exist for ' + shortName + ' organization.' })\n      return res.status(404).json(error.userDne(username))\n    }\n\n    result = await userRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    const responseMessage = {\n      message: username + ' was successfully updated.',\n      updated: result\n    }\n\n    const payload = {\n      action: 'update_user',\n      change: username + ' was successfully updated.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),\n      user: result\n    }\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json(responseMessage)\n  } catch (err) {\n    next(err)\n  }\n}\n\nasync function resetSecret (req, res, next) {\n  try {\n    const requesterShortName = req.ctx.org\n    const requesterUsername = req.ctx.user\n    const username = req.ctx.params.username\n    const orgShortName = req.ctx.params.shortname\n    const newUser = new User()\n    const randomKey = cryptoRandomString({ length: CONSTANTS.CRYPTO_RANDOM_STRING_LENGTH })\n    newUser.secret = await argon2.hash(randomKey) // store in db\n    newUser.username = username\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const orgUUID = await orgRepo.getOrgUUID(orgShortName) // userUUID may be null if user does not exist\n    const isSecretariat = await orgRepo.isSecretariat(requesterShortName)\n    const isAdmin = await userRepo.isAdmin(requesterUsername, requesterShortName)\n\n    if (!orgUUID) {\n      logger.info({ uuid: req.ctx.uuid, messsage: orgShortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(orgShortName))\n    }\n\n    // check if the user is not the requester or if the requester is not a secretariat\n    if ((orgShortName !== requesterShortName || username !== requesterUsername) && !isSecretariat) {\n      // check if the requester is not and admin; if admin, the requester must be from the same org as the user\n      if (!isAdmin || (isAdmin && orgShortName !== requesterShortName)) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The api secret can only be reset by the Secretariat, an Org admin or if the requester is the user.' })\n        return res.status(403).json(error.notSameUserOrSecretariat())\n      }\n    }\n\n    const user = await userRepo.updateByUserNameAndOrgUUID(newUser.username, orgUUID, newUser)\n    if (user.n === 0) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + username + ' does not exist for ' + orgShortName + ' organization.' })\n      return res.status(404).json(error.userDne(username))\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: `The API secret was successfully reset and sent to ${username}` })\n    const payload = {\n      action: 'reset_userAPIkey',\n      change: 'API secret was successfully reset.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org)\n    }\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json({ 'API-secret': randomKey })\n  } catch (err) {\n    next(err)\n  }\n}\n\nfunction setAggregateOrgObj (query) {\n  return [\n    {\n      $match: query\n    },\n    {\n      $project: {\n        _id: false,\n        UUID: true,\n        short_name: true,\n        name: true,\n        'authority.active_roles': true,\n        'policies.id_quota': true,\n        time: true\n      }\n    }\n  ]\n}\n\nfunction setAggregateUserObj (query) {\n  return [\n    {\n      $match: query\n    },\n    {\n      $project: {\n        _id: false,\n        username: true,\n        name: true,\n        UUID: true,\n        org_UUID: true,\n        active: true,\n        'authority.active_roles': true,\n        time: true\n      }\n    }\n  ]\n}\n\nfunction parseUserName (newUser) {\n  if (newUser.name) {\n    if (!newUser.name.first) {\n      newUser.name.first = ''\n    }\n    if (!newUser.name.last) {\n      newUser.name.last = ''\n    }\n    if (!newUser.name.middle) {\n      newUser.name.middle = ''\n    }\n    if (!newUser.name.surname) {\n      newUser.name.surname = ''\n    }\n    if (!newUser.name.suffix) {\n      newUser.name.suffix = ''\n    }\n  }\n\n  return newUser.name\n}\n\nmodule.exports = {\n  ORG_ALL: getOrgs,\n  ORG_SINGLE: getOrg,\n  ORG_CREATE_SINGLE: createOrg,\n  ORG_UPDATE_SINGLE: updateOrg,\n  USER_ALL: getUsers,\n  ORG_ID_QUOTA: getOrgIdQuota,\n  USER_SINGLE: getUser,\n  USER_CREATE_SINGLE: createUser,\n  USER_UPDATE_SINGLE: updateUser,\n  USER_RESET_SECRET: resetSecret\n}\n", "const express = require('express')\nconst app = express()\nconst chai = require('chai')\nconst expect = chai.expect\nchai.use(require('chai-http'))\n\n// Body Parser Middleware\napp.use(express.json()) // Allows us to handle raw JSON data\napp.use(express.urlencoded({ extended: false })) // Allows us to handle url encoded data\nconst middleware = require('../../../src/middleware/middleware')\napp.use(middleware.createCtxAndReqUUID)\n\nconst CONSTANTS = require('../../../src/constants')\nconst errors = require('../../../src/controller/org.controller/error')\nconst error = new errors.OrgControllerError()\n\nconst userFixtures = require('./mockObjects.user')\nconst orgController = require('../../../src/controller/org.controller/org.controller')\nconst orgParams = require('../../../src/controller/org.controller/org.middleware')\n\nclass OrgUserNotUpdatedOrgQueryDoesntExist {\n  async getOrgUUID (shortname) {\n    if (shortname === userFixtures.existentOrg.short_name) {\n      return userFixtures.existentOrg.UUID\n    }\n    return null\n  }\n\n  async isSecretariat () {\n    return true\n  }\n}\n\nclass OrgUserUpdatedAddingRole {\n  async getOrgUUID () {\n    return userFixtures.owningOrg.UUID\n  }\n\n  async isSecretariat () {\n    return true\n  }\n}\n\nclass UserUpdatedAddingRole {\n  constructor () {\n    this.user = {\n      org_UUID: userFixtures.existentUserDummy.org_UUID,\n      username: userFixtures.existentUserDummy.username,\n      UUID: userFixtures.existentUserDummy.UUID,\n      active: userFixtures.existentUserDummy.active,\n      name: userFixtures.existentUserDummy.name,\n      authority: {\n        active_roles: []\n      },\n      secret: userFixtures.existentUserDummy.secret\n    }\n\n    this.testRes1 = JSON.parse(JSON.stringify(userFixtures.existentUserDummy))\n    this.testRes1.authority.active_roles = [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n  }\n\n  getUser () {\n    this.user.authority.active_roles.push(CONSTANTS.USER_ROLE_ENUM.ADMIN)\n    return this.user\n  }\n\n  async findOneByUserNameAndOrgUUID () {\n    return this.user\n  }\n\n  async updateByUserNameAndOrgUUID () {\n    return { n: 1, nModified: 1, ok: 1 }\n  }\n\n  async getUserUUID () {\n    return this.user.UUID\n  }\n\n  async isAdmin () {\n    return true\n  }\n\n  async aggregate () {\n    return [this.testRes1]\n  }\n}\n\ndescribe('Testing the PUT /org/:shortname/user/:username endpoint in Org Controller', () => {\n  context('Negative Tests', () => {\n    it('User is not updated because org does not exist', (done) => {\n      class OrgUserNotUpdatedOrgDoesntExist {\n        async getOrgUUID () {\n          return null\n        }\n\n        async isSecretariat () {\n          return true\n        }\n      }\n\n      class NullUserRepo {\n        async getUserUUID () {\n          return null\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return null\n        }\n\n        async isAdmin () {\n          return null\n        }\n      }\n\n      app.route('/user-not-updated-org-doesnt-exist/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserNotUpdatedOrgDoesntExist() },\n            getUserRepository: () => { return new NullUserRepo() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const shortname = userFixtures.nonExistentOrg.short_name.replace(/\\s/g, '')\n      const username = userFixtures.existentUser.username.replace(/\\s/g, '')\n      chai.request(app)\n        .put(`/user-not-updated-org-doesnt-exist/${shortname}/${username}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(404)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.orgDneParam(userFixtures.nonExistentOrg.short_name)\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because user does not exist', (done) => {\n      class OrgUserNotUpdatedUserDoesntExist {\n        async getOrgUUID () {\n          return userFixtures.existentOrg\n        }\n\n        async isSecretariat () {\n          return true\n        }\n      }\n\n      class UserNotUpdatedUserDoesntExist {\n        async findOneByUserNameAndOrgUUID () {\n          return null\n        }\n\n        async isAdmin () {\n          return null\n        }\n      }\n\n      app.route('/user-not-updated-doesnt-exist/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserNotUpdatedUserDoesntExist() },\n            getUserRepository: () => { return new UserNotUpdatedUserDoesntExist() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const shortname = userFixtures.existentOrg.short_name.replace(/\\s/g, '')\n      const username = userFixtures.nonExistentUser.username.replace(/\\s/g, '')\n      chai.request(app)\n        .put(`/user-not-updated-doesnt-exist/${shortname}/${username}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(404)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.userDne(userFixtures.nonExistentUser.username)\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because the new shortname does not exist', (done) => {\n      class UserNotUpdatedOrgQueryDoesntExist {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async isAdmin () {\n          return null\n        }\n      }\n\n      app.route('/user-not-updated-user-doesnt-exist/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserNotUpdatedOrgQueryDoesntExist() },\n            getUserRepository: () => { return new UserNotUpdatedOrgQueryDoesntExist() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-user-doesnt-exist/${userFixtures.existentOrg.short_name}/${userFixtures.existentUser.username}?org_shortname=${userFixtures.nonExistentOrg.short_name}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(404)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.orgDne(userFixtures.nonExistentOrg.short_name)\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because requestor is not Org Admin, Secretariat, or user', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrg.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async isAdmin () {\n          return false\n        }\n      }\n\n      app.route('/user-not-updated-requestor-not-admin-secretariat-user/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-requestor-not-admin-secretariat-user/${userFixtures.existentOrg.short_name}/${userFixtures.existentUser.username}?org_shortname=${userFixtures.existentOrg.short_name}`)\n        .set(userFixtures.owningOrgHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(403)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.notSameUserOrSecretariat()\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because requestor is Org Admin of different organization', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrg.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async isAdmin (username, shortname) {\n          expect(username).to.equal(userFixtures.userDHeader['CVE-API-USER'])\n          expect(shortname).to.equal(userFixtures.existentOrgDummy.short_name)\n          return true\n        }\n      }\n\n      app.route('/user-not-updated-requestor-different-admin/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-requestor-different-admin/${userFixtures.existentOrg.short_name}/${userFixtures.existentUser.username}?org_shortname=${userFixtures.existentOrg.short_name}`)\n        .set(userFixtures.userDHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(403)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.notSameUserOrSecretariat()\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because user can\\'t update their own active field', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrgDummy.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.userA\n        }\n\n        async isAdmin (username, shortname) {\n          expect(username).to.equal(userFixtures.userAHeader['CVE-API-USER'])\n          expect(shortname).to.equal(userFixtures.existentOrgDummy.short_name)\n          return false\n        }\n      }\n\n      app.route('/user-not-updated-cant-update-active-field/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-cant-update-active-field/${userFixtures.existentOrgDummy.short_name}/${userFixtures.userA.username}?active=true`)\n        .set(userFixtures.userAHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(403)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.notOrgAdminOrSecretariat()\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n  })\n\n  context('Positive Tests', () => {\n    it('User is updated: Adding a user role', (done) => {\n      app.route('/user-updated-adding-role-1/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserUpdatedAddingRole() },\n            getUserRepository: () => { return new UserUpdatedAddingRole() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const testUser = Object.assign({}, userFixtures.existentUserDummy)\n      testUser.authority = {\n        active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n      }\n\n      chai.request(app)\n        .put(`/user-updated-adding-role-1/${userFixtures.owningOrg.short_name}/${testUser.username}?active_roles.add=${CONSTANTS.USER_ROLE_ENUM.ADMIN}&active_roles.add=${CONSTANTS.USER_ROLE_ENUM.ADMIN}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.authority.active_roles).to.have.lengthOf(1)\n          expect(res.body.updated.authority.active_roles[0]).to.equal(testUser.authority.active_roles[0])\n          expect(res.body.updated.org_UUID).to.equal(testUser.org_UUID)\n          expect(res.body.updated.username).to.equal(testUser.username)\n          expect(res.body.updated.UUID).to.equal(testUser.UUID)\n          expect(res.body.updated.secret).to.equal(testUser.secret)\n          expect(res.body.updated.active).to.equal(testUser.active)\n          expect(res.body.updated.name.first).to.equal(testUser.name.first)\n          expect(res.body.updated.name.last).to.equal(testUser.name.last)\n          expect(res.body.updated.name.middle).to.equal(testUser.name.middle)\n          expect(res.body.updated.name.suffix).to.equal(testUser.name.suffix)\n          expect(res.body.updated.name.surname).to.equal(testUser.name.surname)\n          done()\n        })\n    })\n\n    it('User is unchanged: Adding a user role that the user already have', (done) => {\n      class UserUpdatedAddingRoleAlreadyExists {\n        constructor () {\n          this.user = {\n            org_UUID: userFixtures.existentUserDummy.org_UUID,\n            username: userFixtures.existentUserDummy.username,\n            UUID: userFixtures.existentUserDummy.UUID,\n            active: userFixtures.existentUserDummy.active,\n            name: userFixtures.existentUserDummy.name,\n            authority: {\n              active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n            },\n            secret: userFixtures.existentUserDummy.secret\n          }\n\n          this.testRes1 = JSON.parse(JSON.stringify(userFixtures.existentUserDummy))\n          this.testRes1.authority.active_roles = [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n        }\n\n        getUser () {\n          return this.user\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return this.user\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1, nModified: 1, ok: 1 }\n        }\n\n        async getUserUUID () {\n          return this.user.UUID\n        }\n\n        async isAdmin () {\n          return false\n        }\n\n        async aggregate () {\n          return [this.testRes1]\n        }\n      }\n\n      app.route('/user-updated-adding-role-2/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserUpdatedAddingRole() },\n            getUserRepository: () => { return new UserUpdatedAddingRoleAlreadyExists() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const testUser = Object.assign({}, userFixtures.existentUserDummy)\n      testUser.authority = {\n        active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n      }\n\n      chai.request(app)\n        .put(`/user-updated-adding-role-2/${userFixtures.owningOrg.short_name}/${testUser.username}?active_roles.add=${CONSTANTS.USER_ROLE_ENUM.ADMIN}&active_roles.add=${CONSTANTS.USER_ROLE_ENUM.ADMIN}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.authority.active_roles).to.have.lengthOf(1)\n          expect(res.body.updated.authority.active_roles[0]).to.equal(testUser.authority.active_roles[0])\n          expect(res.body.updated.org_UUID).to.equal(testUser.org_UUID)\n          expect(res.body.updated.username).to.equal(testUser.username)\n          expect(res.body.updated.UUID).to.equal(testUser.UUID)\n          expect(res.body.updated.secret).to.equal(testUser.secret)\n          expect(res.body.updated.active).to.equal(testUser.active)\n          expect(res.body.updated.name.first).to.equal(testUser.name.first)\n          expect(res.body.updated.name.last).to.equal(testUser.name.last)\n          expect(res.body.updated.name.middle).to.equal(testUser.name.middle)\n          expect(res.body.updated.name.suffix).to.equal(testUser.name.suffix)\n          expect(res.body.updated.name.surname).to.equal(testUser.name.surname)\n          done()\n        })\n    })\n\n    it('User is updated: Removing a user role', (done) => {\n      class UserUpdatedRemovingRole {\n        constructor () {\n          this.user = {\n            org_UUID: userFixtures.existentUserDummy.org_UUID,\n            username: userFixtures.existentUserDummy.username,\n            UUID: userFixtures.existentUserDummy.UUID,\n            active: userFixtures.existentUserDummy.active,\n            name: userFixtures.existentUserDummy.name,\n            authority: {\n              active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n            },\n            secret: userFixtures.existentUserDummy.secret\n          }\n\n          this.testRes1 = JSON.parse(JSON.stringify(userFixtures.existentUserDummy))\n          this.testRes1.authority.active_roles = []\n        }\n\n        getUser () {\n          this.user.authority.active_roles.splice(0, 1)\n          return this.user\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return this.user\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1, nModified: 1, ok: 1 }\n        }\n\n        async getUserUUID () {\n          return this.user.UUID\n        }\n\n        async isAdmin () {\n          return false\n        }\n\n        async aggregate () {\n          return [this.testRes1]\n        }\n      }\n\n      app.route('/user-updated-removing-role-1/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserUpdatedAddingRole() },\n            getUserRepository: () => { return new UserUpdatedRemovingRole() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const testUser = Object.assign({}, userFixtures.existentUserDummy)\n      testUser.authority = {\n        active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n      }\n\n      chai.request(app)\n        .put(`/user-updated-removing-role-1/${userFixtures.owningOrg.short_name}/${testUser.username}?active_roles.remove=${CONSTANTS.USER_ROLE_ENUM.ADMIN}&active_roles.remove=${CONSTANTS.USER_ROLE_ENUM.ADMIN}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.authority.active_roles).to.have.lengthOf(0)\n          expect(res.body.updated.org_UUID).to.equal(testUser.org_UUID)\n          expect(res.body.updated.username).to.equal(testUser.username)\n          expect(res.body.updated.UUID).to.equal(testUser.UUID)\n          expect(res.body.updated.secret).to.equal(testUser.secret)\n          expect(res.body.updated.active).to.equal(testUser.active)\n          expect(res.body.updated.name.first).to.equal(testUser.name.first)\n          expect(res.body.updated.name.last).to.equal(testUser.name.last)\n          expect(res.body.updated.name.middle).to.equal(testUser.name.middle)\n          expect(res.body.updated.name.suffix).to.equal(testUser.name.suffix)\n          expect(res.body.updated.name.surname).to.equal(testUser.name.surname)\n          done()\n        })\n    })\n\n    it('User is unchanged: Removing a user role that the user does not have', (done) => {\n      class UserUpdatedRemovingRoleAlreadyRemoved {\n        constructor () {\n          this.user = {\n            org_UUID: userFixtures.existentUserDummy.org_UUID,\n            username: userFixtures.existentUserDummy.username,\n            UUID: userFixtures.existentUserDummy.UUID,\n            active: userFixtures.existentUserDummy.active,\n            name: userFixtures.existentUserDummy.name,\n            authority: userFixtures.existentUserDummy.authority,\n            secret: userFixtures.existentUserDummy.secret\n          }\n        }\n\n        getUser () {\n          return this.user\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return this.user\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1, nModified: 1, ok: 1 }\n        }\n\n        async getUserUUID () {\n          return this.user.UUID\n        }\n\n        async isAdmin () {\n          return false\n        }\n\n        async aggregate () {\n          return [this.user]\n        }\n      }\n\n      app.route('/user-updated-removing-role-2/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserUpdatedAddingRole() },\n            getUserRepository: () => { return new UserUpdatedRemovingRoleAlreadyRemoved() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-updated-removing-role-2/${userFixtures.owningOrg.short_name}/${userFixtures.existentUserDummy.username}?active_roles.remove=${CONSTANTS.USER_ROLE_ENUM.ADMIN}&active_roles.remove=${CONSTANTS.USER_ROLE_ENUM.ADMIN}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.authority.active_roles).to.have.lengthOf(0)\n          expect(res.body.updated.org_UUID).to.equal(userFixtures.existentUserDummy.org_UUID)\n          expect(res.body.updated.username).to.equal(userFixtures.existentUserDummy.username)\n          expect(res.body.updated.UUID).to.equal(userFixtures.existentUserDummy.UUID)\n          expect(res.body.updated.secret).to.equal(userFixtures.existentUserDummy.secret)\n          expect(res.body.updated.active).to.equal(userFixtures.existentUserDummy.active)\n          expect(res.body.updated.name.first).to.equal(userFixtures.existentUserDummy.name.first)\n          expect(res.body.updated.name.last).to.equal(userFixtures.existentUserDummy.name.last)\n          expect(res.body.updated.name.middle).to.equal(userFixtures.existentUserDummy.name.middle)\n          expect(res.body.updated.name.suffix).to.equal(userFixtures.existentUserDummy.name.suffix)\n          expect(res.body.updated.name.surname).to.equal(userFixtures.existentUserDummy.name.surname)\n          done()\n        })\n    })\n\n    it('User is updated: Deactivating User as Admin', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrgDummy.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        constructor () {\n          this.testRes1 = JSON.parse(JSON.stringify(userFixtures.userA))\n          this.testRes1.active = false\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.userA\n        }\n\n        async isAdmin (username, shortname) {\n          expect(username).to.equal(userFixtures.userDHeader['CVE-API-USER'])\n          expect(shortname).to.equal(userFixtures.existentOrgDummy.short_name)\n          return true\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1 }\n        }\n\n        async getUserUUID () {\n          return userFixtures.userD.UUID\n        }\n\n        async aggregate () {\n          return [this.testRes1]\n        }\n      }\n\n      app.route('/user-updated-requestor-admin-deactivate-user/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-updated-requestor-admin-deactivate-user/${userFixtures.existentOrgDummy.short_name}/${userFixtures.userA.username}?active=false`)\n        .set(userFixtures.userDHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.active).to.equal(false)\n          done()\n        })\n    })\n\n    it('User is updated: Username changed as user', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrgDummy.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        constructor () {\n          this.testRes1 = JSON.parse(JSON.stringify(userFixtures.userA))\n          this.testRes1.username = 'TESTER'\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.userA\n        }\n\n        async isAdmin (username, shortname) {\n          expect(username).to.equal(userFixtures.userAHeader['CVE-API-USER'])\n          expect(shortname).to.equal(userFixtures.existentOrgDummy.short_name)\n          return false\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1 }\n        }\n\n        async getUserUUID () {\n          return userFixtures.userA.UUID\n        }\n\n        async find () {\n          return []\n        }\n\n        async aggregate () {\n          return [this.testRes1]\n        }\n      }\n\n      app.route('/user-updated-requestor-user-username-changed/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-updated-requestor-user-username-changed/${userFixtures.existentOrgDummy.short_name}/${userFixtures.userA.username}?new_username=TESTER`)\n        .set(userFixtures.userAHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.username).to.equal('TESTER')\n          done()\n        })\n    })\n\n    it('User is unchanged: No query parameters are provided', async () => {\n      class UserNotUpdatedNoQuery {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1, nModified: 1, ok: 1 }\n        }\n\n        async getUserUUID () {\n          return userFixtures.existentUser.UUID\n        }\n\n        async isAdmin () {\n          return false\n        }\n\n        async aggregate () {\n          return [userFixtures.existentUser]\n        }\n      }\n\n      app.route('/user-not-updated-no-parameters/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserNotUpdatedOrgQueryDoesntExist() },\n            getUserRepository: () => { return new UserNotUpdatedNoQuery() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const res = await chai.request(app)\n        .put(`/user-not-updated-no-parameters/${userFixtures.existentOrg.short_name}/${userFixtures.existentUser.username}`)\n        .set(userFixtures.secretariatHeader)\n\n      expect(res).to.have.status(200)\n      expect(res).to.have.property('body').and.to.be.a('object')\n      expect(res.body).to.have.property('updated').and.to.be.a('object')\n      expect(res.body.updated.authority.active_roles[0]).to.equal(userFixtures.existentUser.authority.active_roles[0])\n      expect(res.body.updated.org_UUID).to.equal(userFixtures.existentUser.org_UUID)\n      expect(res.body.updated.username).to.equal(userFixtures.existentUser.username)\n      expect(res.body.updated.UUID).to.equal(userFixtures.existentUser.UUID)\n      expect(res.body.updated.secret).to.equal(userFixtures.existentUser.secret)\n      expect(res.body.updated.active).to.equal(userFixtures.existentUser.active)\n      expect(res.body.updated.name.first).to.equal(userFixtures.existentUser.name.first)\n      expect(res.body.updated.name.last).to.equal(userFixtures.existentUser.name.last)\n      expect(res.body.updated.name.middle).to.equal(userFixtures.existentUser.name.middle)\n      expect(res.body.updated.name.suffix).to.equal(userFixtures.existentUser.name.suffix)\n      expect(res.body.updated.name.surname).to.equal(userFixtures.existentUser.name.surname)\n    })\n  })\n})\n"], "fixing_code": ["const idrErr = require('../../utils/error')\n\nclass OrgControllerError extends idrErr.IDRError {\n  orgDneParam (shortname) { // org\n    const err = {}\n    err.error = 'ORG_DNE_PARAM'\n    err.message = `The '${shortname}' organization designated by the shortname parameter does not exist.`\n    return err\n  }\n\n  userDne (username) { // org\n    const err = {}\n    err.error = 'USER_DNE'\n    err.message = `The user '${username}' designated by the username parameter does not exist.`\n    return err\n  }\n\n  notSameOrgOrSecretariat () { // org\n    const err = {}\n    err.error = 'NOT_SAME_ORG_OR_SECRETARIAT'\n    err.message = 'This information can only be viewed by the users of the same organization or the Secretariat.'\n    return err\n  }\n\n  notAllowedToChangeOrganization () {\n    const err = {}\n    err.error = 'NOT_ALLOWED_TO_CHANGE_ORGANIZATION'\n    err.message = 'Only the Secretariat can change the organization for a user.'\n    return err\n  }\n\n  orgExists (shortname) { // org\n    const err = {}\n    err.error = 'ORG_EXISTS'\n    err.message = `The '${shortname}' organization already exists.`\n    return err\n  }\n\n  userExists (username) { // org\n    const err = {}\n    err.error = 'USER_EXISTS'\n    err.message = `The user '${username}' already exists.`\n    return err\n  }\n\n  uuidProvided () { // org\n    const err = {}\n    err.error = 'UUID_PROVIDED'\n    err.message = 'Providing UUIDs for user creation or update is not allowed.'\n    return err\n  }\n\n  duplicateUsername (shortname, username) { // org\n    const err = {}\n    err.error = 'DUPLICATE_USERNAME'\n    err.message = `The user could not be updated because the '${shortname}' organization contains another user with the username '${username}'.`\n    return err\n  }\n\n  duplicateShortname (shortname) { // org\n    const err = {}\n    err.error = 'DUPLICATE_SHORTNAME'\n    err.message = `The organization cannot be renamed as '${shortname}' because this shortname is used by another organization.`\n    return err\n  }\n}\n\nmodule.exports = {\n  OrgControllerError\n}\n", "require('dotenv').config()\nconst User = require('../../model/user')\nconst Org = require('../../model/org')\nconst logger = require('../../middleware/logger')\nconst argon2 = require('argon2')\nconst CONSTANTS = require('../../constants')\nconst cryptoRandomString = require('crypto-random-string')\nconst uuid = require('uuid')\nconst errors = require('./error')\nconst error = new errors.OrgControllerError()\nconst options = CONSTANTS.PAGINATOR_OPTIONS\n\n// Get the details of all orgs\nasync function getOrgs (req, res, next) {\n  try {\n    options.sort = { short_name: 'asc' }\n    options.page = req.ctx.query.page ? parseInt(req.ctx.query.page) : CONSTANTS.PAGINATOR_PAGE // if 'page' query parameter is not defined, set 'page' to the default page value\n    const repo = req.ctx.repositories.getOrgRepository()\n\n    const agt = setAggregateOrgObj({})\n    const pg = await repo.aggregatePaginate(agt, options)\n    const payload = { organizations: pg.itemsList }\n\n    if (pg.itemCount >= CONSTANTS.PAGINATOR_OPTIONS.limit) {\n      payload.totalCount = pg.itemCount\n      payload.itemsPerPage = pg.itemsPerPage\n      payload.pageCount = pg.pageCount\n      payload.currentPage = pg.currentPage\n      payload.prevPage = pg.prevPage\n      payload.nextPage = pg.nextPage\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: 'The orgs were sent to the user.' })\n    return res.status(200).json(payload)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Get the details of a single org for the specified shortname\nasync function getOrg (req, res, next) {\n  try {\n    const orgShortName = req.ctx.org\n    const shortName = req.ctx.params.shortname\n    const repo = req.ctx.repositories.getOrgRepository()\n    const isSecretariat = await repo.isSecretariat(orgShortName)\n\n    if (orgShortName !== shortName && !isSecretariat) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization can only be viewed by the users of the same organization or the Secretariat.' })\n      return res.status(403).json(error.notSameOrgOrSecretariat())\n    }\n\n    const agt = setAggregateOrgObj({ short_name: shortName })\n    let result = await repo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    if (!result) { // an empty result can only happen if the requestor is the Secretariat\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization was sent to the user.', org: result })\n    return res.status(200).json(result)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Get the details of all users from an org given the specified shortname\nasync function getUsers (req, res, next) {\n  try {\n    options.sort = { username: 'asc' }\n    options.page = req.ctx.query.page ? parseInt(req.ctx.query.page) : CONSTANTS.PAGINATOR_PAGE // if 'page' query parameter is not defined, set 'page' to the default page value\n    const shortName = req.ctx.org\n    const orgShortName = req.ctx.params.shortname\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const orgUUID = await orgRepo.getOrgUUID(orgShortName)\n    const isSecretariat = await orgRepo.isSecretariat(shortName)\n\n    if (!orgUUID) {\n      logger.info({ uuid: req.ctx.uuid, message: orgShortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(orgShortName))\n    }\n\n    if (orgShortName !== shortName && !isSecretariat) {\n      logger.info({ uuid: req.ctx.uuid, message: orgShortName + ' organization can only be viewed by the users of the same organization or the Secretariat.' })\n      return res.status(403).json(error.notSameOrgOrSecretariat())\n    }\n\n    const agt = setAggregateUserObj({ org_UUID: orgUUID })\n    const pg = await userRepo.aggregatePaginate(agt, options)\n    const payload = { users: pg.itemsList }\n\n    if (pg.itemCount >= CONSTANTS.PAGINATOR_OPTIONS.limit) {\n      payload.totalCount = pg.itemCount\n      payload.itemsPerPage = pg.itemsPerPage\n      payload.pageCount = pg.pageCount\n      payload.currentPage = pg.currentPage\n      payload.prevPage = pg.prevPage\n      payload.nextPage = pg.nextPage\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: `The users of ${orgShortName} organization were sent to the user.` })\n    return res.status(200).json(payload)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Get the details of a single user for the specified username\nasync function getUser (req, res, next) {\n  try {\n    const shortName = req.ctx.org\n    const username = req.ctx.params.username\n    const orgShortName = req.ctx.params.shortname\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const isSecretariat = await orgRepo.isSecretariat(shortName)\n\n    if (orgShortName !== shortName && !isSecretariat) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization can only be viewed by that organization\\'s users or the Secretariat.' })\n      return res.status(403).json(error.notSameOrgOrSecretariat())\n    }\n\n    const orgUUID = await orgRepo.getOrgUUID(orgShortName)\n    if (!orgUUID) { // the org can only be non-existent if the requestor is the Secretariat\n      logger.info({ uuid: req.ctx.uuid, message: orgShortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(orgShortName))\n    }\n\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const agt = setAggregateUserObj({ username: username, org_UUID: orgUUID })\n    let result = await userRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    if (!result) {\n      logger.info({ uuid: req.ctx.uuid, message: username + ' does not exist.' })\n      return res.status(404).json(error.userDne(username))\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: username + ' was sent to the user.', user: result })\n    return res.status(200).json(result)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Get details on ID quota for an org with the specified org shortname\nasync function getOrgIdQuota (req, res, next) {\n  try {\n    const orgShortName = req.ctx.org\n    const shortName = req.ctx.params.shortname\n    const repo = req.ctx.repositories.getOrgRepository()\n    const isSecretariat = await repo.isSecretariat(orgShortName)\n\n    if (orgShortName !== shortName && !isSecretariat) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization id quota can only be viewed by the users of the same organization or the Secretariat.' })\n      return res.status(403).json(error.notSameOrgOrSecretariat())\n    }\n\n    let result = await repo.findOneByShortName(shortName)\n    if (!result) { // a null result can only happen if the requestor is the Secretariat\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    const returnPayload = {\n      id_quota: result.policies.id_quota,\n      total_reserved: null,\n      available: null\n    }\n\n    const query = {\n      owning_cna: await repo.getOrgUUID(shortName),\n      state: CONSTANTS.CVE_STATES.RESERVED\n    }\n    const cveIdRepo = req.ctx.repositories.getCveIdRepository()\n    result = await cveIdRepo.countDocuments(query)\n    returnPayload.total_reserved = result\n    returnPayload.available = returnPayload.id_quota - returnPayload.total_reserved\n\n    logger.info({ uuid: req.ctx.uuid, message: 'The organization\\'s id quota was returned to the user.', details: returnPayload })\n    return res.status(200).json(returnPayload)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Creates a new org only if the org doesn't exist for the specified shortname. If the org exists, we do not update the org.\nasync function createOrg (req, res, next) {\n  try {\n    const newOrg = new Org()\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n\n    Object.keys(req.ctx.body).forEach(k => {\n      const key = k.toLowerCase()\n\n      if (key === 'short_name') {\n        newOrg.short_name = req.ctx.body.short_name\n      } else if (key === 'name') {\n        newOrg.name = req.ctx.body.name\n      } else if (key === 'authority') {\n        if (req.ctx.body.authority.active_roles) {\n          newOrg.authority.active_roles = req.ctx.body.authority.active_roles\n        }\n      } else if (key === 'policies') {\n        if (req.ctx.body.policies.id_quota) {\n          newOrg.policies.id_quota = req.ctx.body.policies.id_quota\n        }\n      } else if (key === 'uuid') {\n        return res.status(400).json(error.uuidProvided())\n      }\n    })\n\n    let result = await orgRepo.findOneByShortName(newOrg.short_name) // Find org in MongoDB\n    if (result) {\n      logger.info({ uuid: req.ctx.uuid, message: newOrg.short_name + ' organization was not created because it already exists.' })\n      return res.status(400).json(error.orgExists(newOrg.short_name))\n    }\n\n    newOrg.inUse = false\n    newOrg.UUID = uuid.v4()\n    newOrg.authority.active_roles = [CONSTANTS.AUTH_ROLE_ENUM.CNA] // default role\n\n    if (!newOrg.policies.id_quota) {\n      newOrg.policies.id_quota = CONSTANTS.DEFAULT_ID_QUOTA\n    }\n\n    await orgRepo.updateByOrgUUID(newOrg.UUID, newOrg, { upsert: true }) // Create org in MongoDB if it doesn't exist\n    const agt = setAggregateOrgObj({ short_name: newOrg.short_name })\n    result = await orgRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    const responseMessage = {\n      message: newOrg.short_name + ' organization was successfully created.',\n      created: result\n    }\n\n    const payload = {\n      action: 'create_org',\n      change: newOrg.short_name + ' organization was successfully created.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),\n      org: result\n    }\n    const userRepo = req.ctx.repositories.getUserRepository()\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json(responseMessage)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Updates an org only if the org exist for the specified shortname. If no org exists, we do not create the org.\nasync function updateOrg (req, res, next) {\n  try {\n    const shortName = req.ctx.params.shortname\n    const newOrg = new Org()\n    const removeRoles = []\n    const addRoles = []\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const org = await orgRepo.findOneByShortName(shortName)\n    let agt = setAggregateOrgObj({ short_name: shortName })\n\n    // org doesn't exist\n    if (!org) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization could not be updated in MongoDB because it does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    Object.keys(req.ctx.query).forEach(k => {\n      const key = k.toLowerCase()\n\n      if (key === 'shortname') {\n        newOrg.short_name = req.ctx.query.shortname\n        agt = setAggregateOrgObj({ short_name: newOrg.short_name })\n      } else if (key === 'name') {\n        newOrg.name = req.ctx.query.name\n      } else if (key === 'id_quota') {\n        newOrg.policies.id_quota = req.ctx.query.id_quota\n      } else if (key === 'active_roles.add') {\n        if (Array.isArray(req.ctx.query['active_roles.add'])) {\n          req.ctx.query['active_roles.add'].forEach(r => {\n            addRoles.push(r)\n          })\n        }\n      } else if (key === 'active_roles.remove') {\n        if (Array.isArray(req.ctx.query['active_roles.remove'])) {\n          req.ctx.query['active_roles.remove'].forEach(r => {\n            removeRoles.push(r)\n          })\n        }\n      }\n    })\n\n    // updating the org's roles\n    if (org) {\n      const roles = org.authority.active_roles\n\n      // adding roles\n      addRoles.forEach(role => {\n        if (!roles.includes(role)) {\n          roles.push(role)\n        }\n      })\n\n      // removing roles\n      removeRoles.forEach(role => {\n        const index = roles.indexOf(role)\n\n        if (index > -1) {\n          roles.splice(index, 1)\n        }\n      })\n\n      newOrg.authority.active_roles = roles\n    }\n\n    if (newOrg.short_name) {\n      const result = await orgRepo.findOneByShortName(newOrg.short_name)\n\n      if (result) {\n        return res.status(403).json(error.duplicateShortname(newOrg.short_name))\n      }\n    }\n\n    // update org\n    let result = await orgRepo.updateByOrgUUID(org.UUID, newOrg)\n    if (result.n === 0) {\n      logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization could not be updated in MongoDB because it does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    result = await orgRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    const responseMessage = {\n      message: shortName + ' organization was successfully updated.',\n      updated: result\n    }\n\n    const payload = {\n      action: 'update_org',\n      change: shortName + ' organization was successfully updated.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),\n      org: result\n    }\n    const userRepo = req.ctx.repositories.getUserRepository()\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json(responseMessage)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Creates a user only if the org exist and the user does not exist for the specified shortname and username\nasync function createUser (req, res, next) {\n  try {\n    const orgShortName = req.ctx.params.shortname\n    const requesterUsername = req.ctx.user\n    const requesterShortName = req.ctx.org\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const newUser = new User()\n\n    const orgUUID = await orgRepo.getOrgUUID(orgShortName)\n    if (!orgUUID) { // the org can only be non-existent if the requestor is the Secretariat\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be created because ' + orgShortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(orgShortName))\n    }\n\n    Object.keys(req.ctx.body).forEach(k => {\n      const key = k.toLowerCase()\n\n      if (key === 'username') {\n        newUser.username = req.ctx.body.username\n      } else if (key === 'authority') {\n        if (req.ctx.body.authority.active_roles) {\n          newUser.authority.active_roles = req.ctx.body.authority.active_roles\n        }\n      } else if (key === 'name') {\n        if (req.ctx.body.name.first) {\n          newUser.name.first = req.ctx.body.name.first\n        }\n        if (req.ctx.body.name.last) {\n          newUser.name.last = req.ctx.body.name.last\n        }\n        if (req.ctx.body.name.middle) {\n          newUser.name.middle = req.ctx.body.name.middle\n        }\n        if (req.ctx.body.name.suffix) {\n          newUser.name.suffix = req.ctx.body.name.suffix\n        }\n        if (req.ctx.body.name.surname) {\n          newUser.name.surname = req.ctx.body.name.surname\n        }\n      } else if (key === 'org_uuid') {\n        return res.status(400).json(error.uuidProvided())\n      } else if (key === 'uuid') {\n        return res.status(400).json(error.uuidProvided())\n      }\n    })\n\n    const requesterOrgUUID = await orgRepo.getOrgUUID(requesterShortName)\n    const isSecretariat = await orgRepo.isSecretariatUUID(requesterOrgUUID)\n    const isAdmin = await userRepo.isAdminUUID(requesterUsername, requesterOrgUUID)\n    // check if user is only an Admin (not Secretatiat) and the user does not belong to the same organization as the new user\n    if (!isSecretariat && isAdmin) {\n      if (requesterOrgUUID !== orgUUID) {\n        return res.status(403).json(error.notOrgAdminOrSecretariat()) // The Admin user must belong to the new user's organization\n      }\n    }\n\n    newUser.org_UUID = orgUUID\n    newUser.UUID = uuid.v4()\n    newUser.active = true\n    const randomKey = cryptoRandomString({ length: CONSTANTS.CRYPTO_RANDOM_STRING_LENGTH })\n    newUser.secret = await argon2.hash(randomKey)\n\n    let result = await userRepo.findOneByUserNameAndOrgUUID(newUser.username, newUser.org_UUID) // Find user in MongoDB\n    if (result) {\n      logger.info({ uuid: req.ctx.uuid, message: newUser.username + ' was not created because it already exists.' })\n      return res.status(400).json(error.userExists(newUser.username))\n    }\n\n    // Parsing all user name fields\n    newUser.name = parseUserName(newUser)\n\n    await userRepo.updateByUserNameAndOrgUUID(newUser.username, newUser.org_UUID, newUser, { upsert: true }) // Create user in MongoDB if it doesn't exist\n    const agt = setAggregateUserObj({ username: newUser.username, org_UUID: newUser.org_UUID })\n    result = await userRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    result.secret = randomKey\n    const responseMessage = {\n      message: result.username + ' was successfully created.',\n      created: result\n    }\n\n    const payload = {\n      action: 'create_user',\n      change: result.username + ' was successfully created.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),\n      user: result\n    }\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json(responseMessage)\n  } catch (err) {\n    next(err)\n  }\n}\n\n// Updates a user only if the user exist for the specified username. If no user exists, it does not create the user.\nasync function updateUser (req, res, next) {\n  try {\n    const requesterShortName = req.ctx.org\n    const requesterUsername = req.ctx.user\n    const username = req.ctx.params.username\n    const shortName = req.ctx.params.shortname\n    const newUser = new User()\n    let newOrgShortName\n    let changesRequirePrivilegedRole // Set variable to true if protected fields are being modified\n    const removeRoles = []\n    const addRoles = []\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const orgUUID = await orgRepo.getOrgUUID(shortName)\n    const isSecretariat = await orgRepo.isSecretariat(requesterShortName)\n    const isAdmin = await userRepo.isAdmin(requesterUsername, requesterShortName) // Check if requester is Admin of the designated user's org\n\n    if (!orgUUID) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + shortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(shortName))\n    }\n\n    const user = await userRepo.findOneByUserNameAndOrgUUID(username, orgUUID)\n    if (!user) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + username + ' does not exist for ' + shortName + ' organization.' })\n      return res.status(404).json(error.userDne(username))\n    }\n\n    // check if the user is not the requester or if the requester is not a secretariat\n    if ((shortName !== requesterShortName || username !== requesterUsername) && !isSecretariat) {\n      // check if the requester is not and admin; if admin, the requester must be from the same org as the user\n      if (!isAdmin || (isAdmin && shortName !== requesterShortName)) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user can only be updated by the Secretariat, an Org admin or if the requester is the user.' })\n        return res.status(403).json(error.notSameUserOrSecretariat())\n      }\n    }\n\n    Object.keys(req.ctx.query).forEach(k => {\n      const key = k.toLowerCase()\n\n      if (key === 'new_username') {\n        newUser.username = req.ctx.query.new_username\n      } else if (key === 'org_shortname') {\n        newOrgShortName = req.ctx.query.org_shortname\n        changesRequirePrivilegedRole = true\n        if (!isSecretariat) {\n          logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + requesterUsername + ' is an Org Admin and tried to reassign the organization.' })\n          return res.status(403).json(error.notAllowedToChangeOrganization())\n        }\n      } else if (key === 'name.first') {\n        newUser.name.first = req.ctx.query['name.first']\n      } else if (key === 'name.last') {\n        newUser.name.last = req.ctx.query['name.last']\n      } else if (key === 'name.middle') {\n        newUser.name.middle = req.ctx.query['name.middle']\n      } else if (key === 'name.suffix') {\n        newUser.name.suffix = req.ctx.query['name.suffix']\n      } else if (key === 'name.surname') {\n        newUser.name.surname = req.ctx.query['name.surname']\n      } else if (key === 'active') {\n        newUser.active = req.ctx.query.active\n        changesRequirePrivilegedRole = true\n      } else if (key === 'active_roles.add') {\n        if (Array.isArray(req.ctx.query['active_roles.add'])) {\n          req.ctx.query['active_roles.add'].forEach(r => {\n            addRoles.push(r)\n          })\n          changesRequirePrivilegedRole = true\n        }\n      } else if (key === 'active_roles.remove') {\n        if (Array.isArray(req.ctx.query['active_roles.remove'])) {\n          req.ctx.query['active_roles.remove'].forEach(r => {\n            removeRoles.push(r)\n          })\n          changesRequirePrivilegedRole = true\n        }\n      }\n    })\n\n    // updating user's roles and org_uuid is only allowed for secretariats and org admins\n    if (changesRequirePrivilegedRole && !(isAdmin || isSecretariat)) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + requesterUsername + ' user is not Org Admin or Secretariat to modify these fields.' })\n      return res.status(403).json(error.notOrgAdminOrSecretariat())\n    }\n\n    // check if the new org exist\n    if (newOrgShortName) {\n      newUser.org_UUID = await orgRepo.getOrgUUID(newOrgShortName)\n\n      if (!newUser.org_UUID) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + newOrgShortName + ' organization does not exist.' })\n        return res.status(404).json(error.orgDne(newOrgShortName))\n      }\n    }\n\n    let agt = setAggregateUserObj({ username: username, org_UUID: orgUUID })\n\n    // check if org has user of same username already\n    if (newUser.username && newUser.org_UUID) {\n      agt = setAggregateUserObj({ username: newUser.username, org_UUID: newUser.org_UUID })\n      const duplicateUsers = await userRepo.find({ org_UUID: newUser.org_UUID, username: newUser.username })\n      if (duplicateUsers.length) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + newOrgShortName + ' organization contains a user with the same username.' })\n        return res.status(403).json(error.duplicateUsername(newOrgShortName, newUser.username))\n      }\n    } else if (newUser.username) {\n      agt = setAggregateUserObj({ username: newUser.username, org_UUID: orgUUID })\n      const duplicateUsers = await userRepo.find({ org_UUID: orgUUID, username: newUser.username })\n      if (duplicateUsers.length) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + shortName + ' organization contains a user with the same username.' })\n        return res.status(403).json(error.duplicateUsername(shortName, newUser.username))\n      }\n    } else if (newUser.org_UUID) {\n      agt = setAggregateUserObj({ username: username, org_UUID: newUser.org_UUID })\n      const duplicateUsers = await userRepo.find({ org_UUID: newUser.org_UUID, username: username })\n      if (duplicateUsers.length) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + newOrgShortName + ' organization contains a user with the same username.' })\n        return res.status(403).json(error.duplicateUsername(newOrgShortName, username))\n      }\n    }\n\n    // updating the user's roles\n    const roles = user.authority.active_roles\n\n    // adding roles\n    addRoles.forEach(role => {\n      if (!roles.includes(role)) {\n        roles.push(role)\n      }\n    })\n\n    // removing roles\n    removeRoles.forEach(role => {\n      const index = roles.indexOf(role)\n\n      if (index > -1) {\n        roles.splice(index, 1)\n      }\n    })\n\n    newUser.authority.active_roles = roles\n\n    let result = await userRepo.updateByUserNameAndOrgUUID(username, orgUUID, newUser)\n    if (result.n === 0) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + username + ' does not exist for ' + shortName + ' organization.' })\n      return res.status(404).json(error.userDne(username))\n    }\n\n    result = await userRepo.aggregate(agt)\n    result = result.length > 0 ? result[0] : null\n\n    const responseMessage = {\n      message: username + ' was successfully updated.',\n      updated: result\n    }\n\n    const payload = {\n      action: 'update_user',\n      change: username + ' was successfully updated.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),\n      user: result\n    }\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json(responseMessage)\n  } catch (err) {\n    next(err)\n  }\n}\n\nasync function resetSecret (req, res, next) {\n  try {\n    const requesterShortName = req.ctx.org\n    const requesterUsername = req.ctx.user\n    const username = req.ctx.params.username\n    const orgShortName = req.ctx.params.shortname\n    const newUser = new User()\n    const randomKey = cryptoRandomString({ length: CONSTANTS.CRYPTO_RANDOM_STRING_LENGTH })\n    newUser.secret = await argon2.hash(randomKey) // store in db\n    newUser.username = username\n    const userRepo = req.ctx.repositories.getUserRepository()\n    const orgRepo = req.ctx.repositories.getOrgRepository()\n    const orgUUID = await orgRepo.getOrgUUID(orgShortName) // userUUID may be null if user does not exist\n    const isSecretariat = await orgRepo.isSecretariat(requesterShortName)\n    const isAdmin = await userRepo.isAdmin(requesterUsername, requesterShortName)\n\n    if (!orgUUID) {\n      logger.info({ uuid: req.ctx.uuid, messsage: orgShortName + ' organization does not exist.' })\n      return res.status(404).json(error.orgDneParam(orgShortName))\n    }\n\n    // check if the user is not the requester or if the requester is not a secretariat\n    if ((orgShortName !== requesterShortName || username !== requesterUsername) && !isSecretariat) {\n      // check if the requester is not and admin; if admin, the requester must be from the same org as the user\n      if (!isAdmin || (isAdmin && orgShortName !== requesterShortName)) {\n        logger.info({ uuid: req.ctx.uuid, message: 'The api secret can only be reset by the Secretariat, an Org admin or if the requester is the user.' })\n        return res.status(403).json(error.notSameUserOrSecretariat())\n      }\n    }\n\n    const user = await userRepo.updateByUserNameAndOrgUUID(newUser.username, orgUUID, newUser)\n    if (user.n === 0) {\n      logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + username + ' does not exist for ' + orgShortName + ' organization.' })\n      return res.status(404).json(error.userDne(username))\n    }\n\n    logger.info({ uuid: req.ctx.uuid, message: `The API secret was successfully reset and sent to ${username}` })\n    const payload = {\n      action: 'reset_userAPIkey',\n      change: 'API secret was successfully reset.',\n      req_UUID: req.ctx.uuid,\n      org_UUID: await orgRepo.getOrgUUID(req.ctx.org)\n    }\n    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)\n    logger.info(JSON.stringify(payload))\n    return res.status(200).json({ 'API-secret': randomKey })\n  } catch (err) {\n    next(err)\n  }\n}\n\nfunction setAggregateOrgObj (query) {\n  return [\n    {\n      $match: query\n    },\n    {\n      $project: {\n        _id: false,\n        UUID: true,\n        short_name: true,\n        name: true,\n        'authority.active_roles': true,\n        'policies.id_quota': true,\n        time: true\n      }\n    }\n  ]\n}\n\nfunction setAggregateUserObj (query) {\n  return [\n    {\n      $match: query\n    },\n    {\n      $project: {\n        _id: false,\n        username: true,\n        name: true,\n        UUID: true,\n        org_UUID: true,\n        active: true,\n        'authority.active_roles': true,\n        time: true\n      }\n    }\n  ]\n}\n\nfunction parseUserName (newUser) {\n  if (newUser.name) {\n    if (!newUser.name.first) {\n      newUser.name.first = ''\n    }\n    if (!newUser.name.last) {\n      newUser.name.last = ''\n    }\n    if (!newUser.name.middle) {\n      newUser.name.middle = ''\n    }\n    if (!newUser.name.surname) {\n      newUser.name.surname = ''\n    }\n    if (!newUser.name.suffix) {\n      newUser.name.suffix = ''\n    }\n  }\n\n  return newUser.name\n}\n\nmodule.exports = {\n  ORG_ALL: getOrgs,\n  ORG_SINGLE: getOrg,\n  ORG_CREATE_SINGLE: createOrg,\n  ORG_UPDATE_SINGLE: updateOrg,\n  USER_ALL: getUsers,\n  ORG_ID_QUOTA: getOrgIdQuota,\n  USER_SINGLE: getUser,\n  USER_CREATE_SINGLE: createUser,\n  USER_UPDATE_SINGLE: updateUser,\n  USER_RESET_SECRET: resetSecret\n}\n", "const express = require('express')\nconst app = express()\nconst chai = require('chai')\nconst expect = chai.expect\nchai.use(require('chai-http'))\n\n// Body Parser Middleware\napp.use(express.json()) // Allows us to handle raw JSON data\napp.use(express.urlencoded({ extended: false })) // Allows us to handle url encoded data\nconst middleware = require('../../../src/middleware/middleware')\napp.use(middleware.createCtxAndReqUUID)\n\nconst CONSTANTS = require('../../../src/constants')\nconst errors = require('../../../src/controller/org.controller/error')\nconst error = new errors.OrgControllerError()\n\nconst userFixtures = require('./mockObjects.user')\nconst orgController = require('../../../src/controller/org.controller/org.controller')\nconst orgParams = require('../../../src/controller/org.controller/org.middleware')\n\nclass OrgUserNotUpdatedOrgQueryDoesntExist {\n  async getOrgUUID (shortname) {\n    if (shortname === userFixtures.existentOrg.short_name) {\n      return userFixtures.existentOrg.UUID\n    }\n    return null\n  }\n\n  async isSecretariat () {\n    return true\n  }\n}\n\nclass OrgUserUpdatedAddingRole {\n  async getOrgUUID () {\n    return userFixtures.owningOrg.UUID\n  }\n\n  async isSecretariat () {\n    return true\n  }\n}\n\nclass UserUpdatedAddingRole {\n  constructor () {\n    this.user = {\n      org_UUID: userFixtures.existentUserDummy.org_UUID,\n      username: userFixtures.existentUserDummy.username,\n      UUID: userFixtures.existentUserDummy.UUID,\n      active: userFixtures.existentUserDummy.active,\n      name: userFixtures.existentUserDummy.name,\n      authority: {\n        active_roles: []\n      },\n      secret: userFixtures.existentUserDummy.secret\n    }\n\n    this.testRes1 = JSON.parse(JSON.stringify(userFixtures.existentUserDummy))\n    this.testRes1.authority.active_roles = [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n  }\n\n  getUser () {\n    this.user.authority.active_roles.push(CONSTANTS.USER_ROLE_ENUM.ADMIN)\n    return this.user\n  }\n\n  async findOneByUserNameAndOrgUUID () {\n    return this.user\n  }\n\n  async updateByUserNameAndOrgUUID () {\n    return { n: 1, nModified: 1, ok: 1 }\n  }\n\n  async getUserUUID () {\n    return this.user.UUID\n  }\n\n  async isAdmin () {\n    return true\n  }\n\n  async aggregate () {\n    return [this.testRes1]\n  }\n}\n\ndescribe('Testing the PUT /org/:shortname/user/:username endpoint in Org Controller', () => {\n  context('Negative Tests', () => {\n    it('User is not updated because org does not exist', (done) => {\n      class OrgUserNotUpdatedOrgDoesntExist {\n        async getOrgUUID () {\n          return null\n        }\n\n        async isSecretariat () {\n          return true\n        }\n      }\n\n      class NullUserRepo {\n        async getUserUUID () {\n          return null\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return null\n        }\n\n        async isAdmin () {\n          return null\n        }\n      }\n\n      app.route('/user-not-updated-org-doesnt-exist/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserNotUpdatedOrgDoesntExist() },\n            getUserRepository: () => { return new NullUserRepo() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const shortname = userFixtures.nonExistentOrg.short_name.replace(/\\s/g, '')\n      const username = userFixtures.existentUser.username.replace(/\\s/g, '')\n      chai.request(app)\n        .put(`/user-not-updated-org-doesnt-exist/${shortname}/${username}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(404)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.orgDneParam(userFixtures.nonExistentOrg.short_name)\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because user does not exist', (done) => {\n      class OrgUserNotUpdatedUserDoesntExist {\n        async getOrgUUID () {\n          return userFixtures.existentOrg\n        }\n\n        async isSecretariat () {\n          return true\n        }\n      }\n\n      class UserNotUpdatedUserDoesntExist {\n        async findOneByUserNameAndOrgUUID () {\n          return null\n        }\n\n        async isAdmin () {\n          return null\n        }\n      }\n\n      app.route('/user-not-updated-doesnt-exist/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserNotUpdatedUserDoesntExist() },\n            getUserRepository: () => { return new UserNotUpdatedUserDoesntExist() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const shortname = userFixtures.existentOrg.short_name.replace(/\\s/g, '')\n      const username = userFixtures.nonExistentUser.username.replace(/\\s/g, '')\n      chai.request(app)\n        .put(`/user-not-updated-doesnt-exist/${shortname}/${username}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(404)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.userDne(userFixtures.nonExistentUser.username)\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because the new shortname does not exist', (done) => {\n      class UserNotUpdatedOrgQueryDoesntExist {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async isAdmin () {\n          return null\n        }\n      }\n\n      app.route('/user-not-updated-user-doesnt-exist/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserNotUpdatedOrgQueryDoesntExist() },\n            getUserRepository: () => { return new UserNotUpdatedOrgQueryDoesntExist() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-user-doesnt-exist/${userFixtures.existentOrg.short_name}/${userFixtures.existentUser.username}?org_shortname=${userFixtures.nonExistentOrg.short_name}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(404)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.orgDne(userFixtures.nonExistentOrg.short_name)\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because requestor is not Org Admin, Secretariat, or user', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrg.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async isAdmin () {\n          return false\n        }\n      }\n\n      app.route('/user-not-updated-requestor-not-admin-secretariat-user/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-requestor-not-admin-secretariat-user/${userFixtures.existentOrg.short_name}/${userFixtures.existentUser.username}?org_shortname=${userFixtures.existentOrg.short_name}`)\n        .set(userFixtures.owningOrgHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(403)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.notSameUserOrSecretariat()\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because Org Admin is trying to change organization', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrg.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async isAdmin () {\n          return true\n        }\n      }\n\n      app.route('/user-not-updated-admin-changing-org/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-admin-changing-org/${userFixtures.existentOrgDummy.short_name}/${userFixtures.userA.username}?org_shortname=${userFixtures.existentOrgDummy.short_name}`)\n        .set(userFixtures.userDHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(403)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.notAllowedToChangeOrganization()\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because requestor is Org Admin of different organization', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrg.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async isAdmin (username, shortname) {\n          expect(username).to.equal(userFixtures.userDHeader['CVE-API-USER'])\n          expect(shortname).to.equal(userFixtures.existentOrgDummy.short_name)\n          return true\n        }\n      }\n\n      app.route('/user-not-updated-requestor-different-admin/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-requestor-different-admin/${userFixtures.existentOrg.short_name}/${userFixtures.existentUser.username}?org_shortname=${userFixtures.existentOrg.short_name}`)\n        .set(userFixtures.userDHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(403)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.notSameUserOrSecretariat()\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n\n    it('User is not updated because user can\\'t update their own active field', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrgDummy.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.userA\n        }\n\n        async isAdmin (username, shortname) {\n          expect(username).to.equal(userFixtures.userAHeader['CVE-API-USER'])\n          expect(shortname).to.equal(userFixtures.existentOrgDummy.short_name)\n          return false\n        }\n      }\n\n      app.route('/user-not-updated-cant-update-active-field/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-not-updated-cant-update-active-field/${userFixtures.existentOrgDummy.short_name}/${userFixtures.userA.username}?active=true`)\n        .set(userFixtures.userAHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(403)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          const errObj = error.notOrgAdminOrSecretariat()\n          expect(res.body.error).to.equal(errObj.error)\n          expect(res.body.message).to.equal(errObj.message)\n          done()\n        })\n    })\n  })\n\n  context('Positive Tests', () => {\n    it('User is updated: Adding a user role', (done) => {\n      app.route('/user-updated-adding-role-1/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserUpdatedAddingRole() },\n            getUserRepository: () => { return new UserUpdatedAddingRole() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const testUser = Object.assign({}, userFixtures.existentUserDummy)\n      testUser.authority = {\n        active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n      }\n\n      chai.request(app)\n        .put(`/user-updated-adding-role-1/${userFixtures.owningOrg.short_name}/${testUser.username}?active_roles.add=${CONSTANTS.USER_ROLE_ENUM.ADMIN}&active_roles.add=${CONSTANTS.USER_ROLE_ENUM.ADMIN}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.authority.active_roles).to.have.lengthOf(1)\n          expect(res.body.updated.authority.active_roles[0]).to.equal(testUser.authority.active_roles[0])\n          expect(res.body.updated.org_UUID).to.equal(testUser.org_UUID)\n          expect(res.body.updated.username).to.equal(testUser.username)\n          expect(res.body.updated.UUID).to.equal(testUser.UUID)\n          expect(res.body.updated.secret).to.equal(testUser.secret)\n          expect(res.body.updated.active).to.equal(testUser.active)\n          expect(res.body.updated.name.first).to.equal(testUser.name.first)\n          expect(res.body.updated.name.last).to.equal(testUser.name.last)\n          expect(res.body.updated.name.middle).to.equal(testUser.name.middle)\n          expect(res.body.updated.name.suffix).to.equal(testUser.name.suffix)\n          expect(res.body.updated.name.surname).to.equal(testUser.name.surname)\n          done()\n        })\n    })\n\n    it('User is unchanged: Adding a user role that the user already have', (done) => {\n      class UserUpdatedAddingRoleAlreadyExists {\n        constructor () {\n          this.user = {\n            org_UUID: userFixtures.existentUserDummy.org_UUID,\n            username: userFixtures.existentUserDummy.username,\n            UUID: userFixtures.existentUserDummy.UUID,\n            active: userFixtures.existentUserDummy.active,\n            name: userFixtures.existentUserDummy.name,\n            authority: {\n              active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n            },\n            secret: userFixtures.existentUserDummy.secret\n          }\n\n          this.testRes1 = JSON.parse(JSON.stringify(userFixtures.existentUserDummy))\n          this.testRes1.authority.active_roles = [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n        }\n\n        getUser () {\n          return this.user\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return this.user\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1, nModified: 1, ok: 1 }\n        }\n\n        async getUserUUID () {\n          return this.user.UUID\n        }\n\n        async isAdmin () {\n          return false\n        }\n\n        async aggregate () {\n          return [this.testRes1]\n        }\n      }\n\n      app.route('/user-updated-adding-role-2/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserUpdatedAddingRole() },\n            getUserRepository: () => { return new UserUpdatedAddingRoleAlreadyExists() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const testUser = Object.assign({}, userFixtures.existentUserDummy)\n      testUser.authority = {\n        active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n      }\n\n      chai.request(app)\n        .put(`/user-updated-adding-role-2/${userFixtures.owningOrg.short_name}/${testUser.username}?active_roles.add=${CONSTANTS.USER_ROLE_ENUM.ADMIN}&active_roles.add=${CONSTANTS.USER_ROLE_ENUM.ADMIN}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.authority.active_roles).to.have.lengthOf(1)\n          expect(res.body.updated.authority.active_roles[0]).to.equal(testUser.authority.active_roles[0])\n          expect(res.body.updated.org_UUID).to.equal(testUser.org_UUID)\n          expect(res.body.updated.username).to.equal(testUser.username)\n          expect(res.body.updated.UUID).to.equal(testUser.UUID)\n          expect(res.body.updated.secret).to.equal(testUser.secret)\n          expect(res.body.updated.active).to.equal(testUser.active)\n          expect(res.body.updated.name.first).to.equal(testUser.name.first)\n          expect(res.body.updated.name.last).to.equal(testUser.name.last)\n          expect(res.body.updated.name.middle).to.equal(testUser.name.middle)\n          expect(res.body.updated.name.suffix).to.equal(testUser.name.suffix)\n          expect(res.body.updated.name.surname).to.equal(testUser.name.surname)\n          done()\n        })\n    })\n\n    it('User is updated: Removing a user role', (done) => {\n      class UserUpdatedRemovingRole {\n        constructor () {\n          this.user = {\n            org_UUID: userFixtures.existentUserDummy.org_UUID,\n            username: userFixtures.existentUserDummy.username,\n            UUID: userFixtures.existentUserDummy.UUID,\n            active: userFixtures.existentUserDummy.active,\n            name: userFixtures.existentUserDummy.name,\n            authority: {\n              active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n            },\n            secret: userFixtures.existentUserDummy.secret\n          }\n\n          this.testRes1 = JSON.parse(JSON.stringify(userFixtures.existentUserDummy))\n          this.testRes1.authority.active_roles = []\n        }\n\n        getUser () {\n          this.user.authority.active_roles.splice(0, 1)\n          return this.user\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return this.user\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1, nModified: 1, ok: 1 }\n        }\n\n        async getUserUUID () {\n          return this.user.UUID\n        }\n\n        async isAdmin () {\n          return false\n        }\n\n        async aggregate () {\n          return [this.testRes1]\n        }\n      }\n\n      app.route('/user-updated-removing-role-1/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserUpdatedAddingRole() },\n            getUserRepository: () => { return new UserUpdatedRemovingRole() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const testUser = Object.assign({}, userFixtures.existentUserDummy)\n      testUser.authority = {\n        active_roles: [CONSTANTS.USER_ROLE_ENUM.ADMIN]\n      }\n\n      chai.request(app)\n        .put(`/user-updated-removing-role-1/${userFixtures.owningOrg.short_name}/${testUser.username}?active_roles.remove=${CONSTANTS.USER_ROLE_ENUM.ADMIN}&active_roles.remove=${CONSTANTS.USER_ROLE_ENUM.ADMIN}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.authority.active_roles).to.have.lengthOf(0)\n          expect(res.body.updated.org_UUID).to.equal(testUser.org_UUID)\n          expect(res.body.updated.username).to.equal(testUser.username)\n          expect(res.body.updated.UUID).to.equal(testUser.UUID)\n          expect(res.body.updated.secret).to.equal(testUser.secret)\n          expect(res.body.updated.active).to.equal(testUser.active)\n          expect(res.body.updated.name.first).to.equal(testUser.name.first)\n          expect(res.body.updated.name.last).to.equal(testUser.name.last)\n          expect(res.body.updated.name.middle).to.equal(testUser.name.middle)\n          expect(res.body.updated.name.suffix).to.equal(testUser.name.suffix)\n          expect(res.body.updated.name.surname).to.equal(testUser.name.surname)\n          done()\n        })\n    })\n\n    it('User is unchanged: Removing a user role that the user does not have', (done) => {\n      class UserUpdatedRemovingRoleAlreadyRemoved {\n        constructor () {\n          this.user = {\n            org_UUID: userFixtures.existentUserDummy.org_UUID,\n            username: userFixtures.existentUserDummy.username,\n            UUID: userFixtures.existentUserDummy.UUID,\n            active: userFixtures.existentUserDummy.active,\n            name: userFixtures.existentUserDummy.name,\n            authority: userFixtures.existentUserDummy.authority,\n            secret: userFixtures.existentUserDummy.secret\n          }\n        }\n\n        getUser () {\n          return this.user\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return this.user\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1, nModified: 1, ok: 1 }\n        }\n\n        async getUserUUID () {\n          return this.user.UUID\n        }\n\n        async isAdmin () {\n          return false\n        }\n\n        async aggregate () {\n          return [this.user]\n        }\n      }\n\n      app.route('/user-updated-removing-role-2/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserUpdatedAddingRole() },\n            getUserRepository: () => { return new UserUpdatedRemovingRoleAlreadyRemoved() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-updated-removing-role-2/${userFixtures.owningOrg.short_name}/${userFixtures.existentUserDummy.username}?active_roles.remove=${CONSTANTS.USER_ROLE_ENUM.ADMIN}&active_roles.remove=${CONSTANTS.USER_ROLE_ENUM.ADMIN}`)\n        .set(userFixtures.secretariatHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.authority.active_roles).to.have.lengthOf(0)\n          expect(res.body.updated.org_UUID).to.equal(userFixtures.existentUserDummy.org_UUID)\n          expect(res.body.updated.username).to.equal(userFixtures.existentUserDummy.username)\n          expect(res.body.updated.UUID).to.equal(userFixtures.existentUserDummy.UUID)\n          expect(res.body.updated.secret).to.equal(userFixtures.existentUserDummy.secret)\n          expect(res.body.updated.active).to.equal(userFixtures.existentUserDummy.active)\n          expect(res.body.updated.name.first).to.equal(userFixtures.existentUserDummy.name.first)\n          expect(res.body.updated.name.last).to.equal(userFixtures.existentUserDummy.name.last)\n          expect(res.body.updated.name.middle).to.equal(userFixtures.existentUserDummy.name.middle)\n          expect(res.body.updated.name.suffix).to.equal(userFixtures.existentUserDummy.name.suffix)\n          expect(res.body.updated.name.surname).to.equal(userFixtures.existentUserDummy.name.surname)\n          done()\n        })\n    })\n\n    it('User is updated: Deactivating User as Admin', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrgDummy.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        constructor () {\n          this.testRes1 = JSON.parse(JSON.stringify(userFixtures.userA))\n          this.testRes1.active = false\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.userA\n        }\n\n        async isAdmin (username, shortname) {\n          expect(username).to.equal(userFixtures.userDHeader['CVE-API-USER'])\n          expect(shortname).to.equal(userFixtures.existentOrgDummy.short_name)\n          return true\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1 }\n        }\n\n        async getUserUUID () {\n          return userFixtures.userD.UUID\n        }\n\n        async aggregate () {\n          return [this.testRes1]\n        }\n      }\n\n      app.route('/user-updated-requestor-admin-deactivate-user/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-updated-requestor-admin-deactivate-user/${userFixtures.existentOrgDummy.short_name}/${userFixtures.userA.username}?active=false`)\n        .set(userFixtures.userDHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.active).to.equal(false)\n          done()\n        })\n    })\n\n    it('User is updated: Username changed as user', (done) => {\n      class Org {\n        async getOrgUUID () {\n          return userFixtures.existentOrgDummy.UUID\n        }\n\n        async isSecretariat () {\n          return false\n        }\n      }\n\n      class User {\n        constructor () {\n          this.testRes1 = JSON.parse(JSON.stringify(userFixtures.userA))\n          this.testRes1.username = 'TESTER'\n        }\n\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.userA\n        }\n\n        async isAdmin (username, shortname) {\n          expect(username).to.equal(userFixtures.userAHeader['CVE-API-USER'])\n          expect(shortname).to.equal(userFixtures.existentOrgDummy.short_name)\n          return false\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1 }\n        }\n\n        async getUserUUID () {\n          return userFixtures.userA.UUID\n        }\n\n        async find () {\n          return []\n        }\n\n        async aggregate () {\n          return [this.testRes1]\n        }\n      }\n\n      app.route('/user-updated-requestor-user-username-changed/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new Org() },\n            getUserRepository: () => { return new User() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      chai.request(app)\n        .put(`/user-updated-requestor-user-username-changed/${userFixtures.existentOrgDummy.short_name}/${userFixtures.userA.username}?new_username=TESTER`)\n        .set(userFixtures.userAHeader)\n        .end((err, res) => {\n          if (err) {\n            done(err)\n          }\n\n          expect(res).to.have.status(200)\n          expect(res).to.have.property('body').and.to.be.a('object')\n          expect(res.body).to.have.property('updated').and.to.be.a('object')\n          expect(res.body.updated.username).to.equal('TESTER')\n          done()\n        })\n    })\n\n    it('User is unchanged: No query parameters are provided', async () => {\n      class UserNotUpdatedNoQuery {\n        async findOneByUserNameAndOrgUUID () {\n          return userFixtures.existentUser\n        }\n\n        async updateByUserNameAndOrgUUID () {\n          return { n: 1, nModified: 1, ok: 1 }\n        }\n\n        async getUserUUID () {\n          return userFixtures.existentUser.UUID\n        }\n\n        async isAdmin () {\n          return false\n        }\n\n        async aggregate () {\n          return [userFixtures.existentUser]\n        }\n      }\n\n      app.route('/user-not-updated-no-parameters/:shortname/:username')\n        .put((req, res, next) => {\n          const factory = {\n            getOrgRepository: () => { return new OrgUserNotUpdatedOrgQueryDoesntExist() },\n            getUserRepository: () => { return new UserNotUpdatedNoQuery() }\n          }\n          req.ctx.repositories = factory\n          next()\n        }, orgParams.parsePostParams, orgController.USER_UPDATE_SINGLE)\n\n      const res = await chai.request(app)\n        .put(`/user-not-updated-no-parameters/${userFixtures.existentOrg.short_name}/${userFixtures.existentUser.username}`)\n        .set(userFixtures.secretariatHeader)\n\n      expect(res).to.have.status(200)\n      expect(res).to.have.property('body').and.to.be.a('object')\n      expect(res.body).to.have.property('updated').and.to.be.a('object')\n      expect(res.body.updated.authority.active_roles[0]).to.equal(userFixtures.existentUser.authority.active_roles[0])\n      expect(res.body.updated.org_UUID).to.equal(userFixtures.existentUser.org_UUID)\n      expect(res.body.updated.username).to.equal(userFixtures.existentUser.username)\n      expect(res.body.updated.UUID).to.equal(userFixtures.existentUser.UUID)\n      expect(res.body.updated.secret).to.equal(userFixtures.existentUser.secret)\n      expect(res.body.updated.active).to.equal(userFixtures.existentUser.active)\n      expect(res.body.updated.name.first).to.equal(userFixtures.existentUser.name.first)\n      expect(res.body.updated.name.last).to.equal(userFixtures.existentUser.name.last)\n      expect(res.body.updated.name.middle).to.equal(userFixtures.existentUser.name.middle)\n      expect(res.body.updated.name.suffix).to.equal(userFixtures.existentUser.name.suffix)\n      expect(res.body.updated.name.surname).to.equal(userFixtures.existentUser.name.surname)\n    })\n  })\n})\n"], "filenames": ["src/controller/org.controller/error.js", "src/controller/org.controller/org.controller.js", "test/unit-tests/user/userUpdateTest.js"], "buggy_code_start_loc": [21, 503, 273], "buggy_code_end_loc": [21, 503, 273], "fixing_code_start_loc": [22, 504, 274], "fixing_code_end_loc": [29, 508, 322], "type": "CWE-863", "message": "controller/org.controller/org.controller.js in the CVE Services API 1.1.1 before 5c50baf3bda28133a3bc90b854765a64fb538304 allows an organizational administrator to transfer a user account to an arbitrary new organization, and thereby achieve unintended access within the context of that new organization.", "other": {"cve": {"id": "CVE-2021-46561", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-26T18:15:08.040", "lastModified": "2022-07-12T17:42:04.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "controller/org.controller/org.controller.js in the CVE Services API 1.1.1 before 5c50baf3bda28133a3bc90b854765a64fb538304 allows an organizational administrator to transfer a user account to an arbitrary new organization, and thereby achieve unintended access within the context of that new organization."}, {"lang": "es", "value": "El archivo controller/org.controller/org.controller.js en la API de servicios de CVE versiones 1.1.1 anteriores a 5c50baf3bda28133a3bc90b854765a64fb538304, permite a un administrador de la organizaci\u00f3n transferir una cuenta de usuario a una nueva organizaci\u00f3n arbitraria y, por lo tanto, conseguir un acceso no deseado en el contexto de esa nueva organizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mitre:cve_services:1.1.1:*:*:*:*:node.js:*:*", "matchCriteriaId": "2841F02E-8663-4051-B09F-ACFD437F8E10"}]}]}], "references": [{"url": "https://github.com/CVEProject/cve-services/commit/5c50baf3bda28133a3bc90b854765a64fb538304", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CVEProject/cve-services/commit/5c50baf3bda28133a3bc90b854765a64fb538304"}}