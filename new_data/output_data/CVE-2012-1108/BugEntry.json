{"buggy_code": ["/***************************************************************************\n    copyright            : (C) 2002 - 2008 by Scott Wheeler\n    email                : wheeler@kde.org\n ***************************************************************************/\n\n/***************************************************************************\n *   This library is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU Lesser General Public License version   *\n *   2.1 as published by the Free Software Foundation.                     *\n *                                                                         *\n *   This library is distributed in the hope that it will be useful, but   *\n *   WITHOUT ANY WARRANTY; without even the implied warranty of            *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *\n *   Lesser General Public License for more details.                       *\n *                                                                         *\n *   You should have received a copy of the GNU Lesser General Public      *\n *   License along with this library; if not, write to the Free Software   *\n *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *\n *   02110-1301  USA                                                       *\n *                                                                         *\n *   Alternatively, this file is available under the Mozilla Public        *\n *   License Version 1.1.  You may obtain a copy of the License at         *\n *   http://www.mozilla.org/MPL/                                           *\n ***************************************************************************/\n\n#include <tbytevector.h>\n#include <tdebug.h>\n\n#include <xiphcomment.h>\n\nusing namespace TagLib;\n\nclass Ogg::XiphComment::XiphCommentPrivate\n{\npublic:\n  FieldListMap fieldListMap;\n  String vendorID;\n  String commentField;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// public members\n////////////////////////////////////////////////////////////////////////////////\n\nOgg::XiphComment::XiphComment() : TagLib::Tag()\n{\n  d = new XiphCommentPrivate;\n}\n\nOgg::XiphComment::XiphComment(const ByteVector &data) : TagLib::Tag()\n{\n  d = new XiphCommentPrivate;\n  parse(data);\n}\n\nOgg::XiphComment::~XiphComment()\n{\n  delete d;\n}\n\nString Ogg::XiphComment::title() const\n{\n  if(d->fieldListMap[\"TITLE\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"TITLE\"].front();\n}\n\nString Ogg::XiphComment::artist() const\n{\n  if(d->fieldListMap[\"ARTIST\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"ARTIST\"].front();\n}\n\nString Ogg::XiphComment::album() const\n{\n  if(d->fieldListMap[\"ALBUM\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"ALBUM\"].front();\n}\n\nString Ogg::XiphComment::comment() const\n{\n  if(!d->fieldListMap[\"DESCRIPTION\"].isEmpty()) {\n    d->commentField = \"DESCRIPTION\";\n    return d->fieldListMap[\"DESCRIPTION\"].front();\n  }\n\n  if(!d->fieldListMap[\"COMMENT\"].isEmpty()) {\n    d->commentField = \"COMMENT\";\n    return d->fieldListMap[\"COMMENT\"].front();\n  }\n\n  return String::null;\n}\n\nString Ogg::XiphComment::genre() const\n{\n  if(d->fieldListMap[\"GENRE\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"GENRE\"].front();\n}\n\nTagLib::uint Ogg::XiphComment::year() const\n{\n  if(!d->fieldListMap[\"DATE\"].isEmpty())\n    return d->fieldListMap[\"DATE\"].front().toInt();\n  if(!d->fieldListMap[\"YEAR\"].isEmpty())\n    return d->fieldListMap[\"YEAR\"].front().toInt();\n  return 0;\n}\n\nTagLib::uint Ogg::XiphComment::track() const\n{\n  if(!d->fieldListMap[\"TRACKNUMBER\"].isEmpty())\n    return d->fieldListMap[\"TRACKNUMBER\"].front().toInt();\n  if(!d->fieldListMap[\"TRACKNUM\"].isEmpty())\n    return d->fieldListMap[\"TRACKNUM\"].front().toInt();\n  return 0;\n}\n\nvoid Ogg::XiphComment::setTitle(const String &s)\n{\n  addField(\"TITLE\", s);\n}\n\nvoid Ogg::XiphComment::setArtist(const String &s)\n{\n  addField(\"ARTIST\", s);\n}\n\nvoid Ogg::XiphComment::setAlbum(const String &s)\n{\n  addField(\"ALBUM\", s);\n}\n\nvoid Ogg::XiphComment::setComment(const String &s)\n{\n  addField(d->commentField.isEmpty() ? \"DESCRIPTION\" : d->commentField, s);\n}\n\nvoid Ogg::XiphComment::setGenre(const String &s)\n{\n  addField(\"GENRE\", s);\n}\n\nvoid Ogg::XiphComment::setYear(uint i)\n{\n  removeField(\"YEAR\");\n  if(i == 0)\n    removeField(\"DATE\");\n  else\n    addField(\"DATE\", String::number(i));\n}\n\nvoid Ogg::XiphComment::setTrack(uint i)\n{\n  removeField(\"TRACKNUM\");\n  if(i == 0)\n    removeField(\"TRACKNUMBER\");\n  else\n    addField(\"TRACKNUMBER\", String::number(i));\n}\n\nbool Ogg::XiphComment::isEmpty() const\n{\n  FieldListMap::ConstIterator it = d->fieldListMap.begin();\n  for(; it != d->fieldListMap.end(); ++it)\n    if(!(*it).second.isEmpty())\n      return false;\n\n  return true;\n}\n\nTagLib::uint Ogg::XiphComment::fieldCount() const\n{\n  uint count = 0;\n\n  FieldListMap::ConstIterator it = d->fieldListMap.begin();\n  for(; it != d->fieldListMap.end(); ++it)\n    count += (*it).second.size();\n\n  return count;\n}\n\nconst Ogg::FieldListMap &Ogg::XiphComment::fieldListMap() const\n{\n  return d->fieldListMap;\n}\n\nString Ogg::XiphComment::vendorID() const\n{\n  return d->vendorID;\n}\n\nvoid Ogg::XiphComment::addField(const String &key, const String &value, bool replace)\n{\n  if(replace)\n    removeField(key.upper());\n\n  if(!key.isEmpty() && !value.isEmpty())\n    d->fieldListMap[key.upper()].append(value);\n}\n\nvoid Ogg::XiphComment::removeField(const String &key, const String &value)\n{\n  if(!value.isNull()) {\n    StringList::Iterator it = d->fieldListMap[key].begin();\n    while(it != d->fieldListMap[key].end()) {\n      if(value == *it)\n        it = d->fieldListMap[key].erase(it);\n      else\n        it++;\n    }\n  }\n  else\n    d->fieldListMap.erase(key);\n}\n\nbool Ogg::XiphComment::contains(const String &key) const\n{\n  return d->fieldListMap.contains(key) && !d->fieldListMap[key].isEmpty();\n}\n\nByteVector Ogg::XiphComment::render() const\n{\n  return render(true);\n}\n\nByteVector Ogg::XiphComment::render(bool addFramingBit) const\n{\n  ByteVector data;\n\n  // Add the vendor ID length and the vendor ID.  It's important to use the\n  // length of the data(String::UTF8) rather than the length of the the string\n  // since this is UTF8 text and there may be more characters in the data than\n  // in the UTF16 string.\n\n  ByteVector vendorData = d->vendorID.data(String::UTF8);\n\n  data.append(ByteVector::fromUInt(vendorData.size(), false));\n  data.append(vendorData);\n\n  // Add the number of fields.\n\n  data.append(ByteVector::fromUInt(fieldCount(), false));\n\n  // Iterate over the the field lists.  Our iterator returns a\n  // std::pair<String, StringList> where the first String is the field name and\n  // the StringList is the values associated with that field.\n\n  FieldListMap::ConstIterator it = d->fieldListMap.begin();\n  for(; it != d->fieldListMap.end(); ++it) {\n\n    // And now iterate over the values of the current list.\n\n    String fieldName = (*it).first;\n    StringList values = (*it).second;\n\n    StringList::ConstIterator valuesIt = values.begin();\n    for(; valuesIt != values.end(); ++valuesIt) {\n      ByteVector fieldData = fieldName.data(String::UTF8);\n      fieldData.append('=');\n      fieldData.append((*valuesIt).data(String::UTF8));\n\n      data.append(ByteVector::fromUInt(fieldData.size(), false));\n      data.append(fieldData);\n    }\n  }\n\n  // Append the \"framing bit\".\n\n  if(addFramingBit)\n    data.append(char(1));\n\n  return data;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// protected members\n////////////////////////////////////////////////////////////////////////////////\n\nvoid Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  int pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  for(int i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n\n    int commentSeparatorPosition = comment.find(\"=\");\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}\n"], "fixing_code": ["/***************************************************************************\n    copyright            : (C) 2002 - 2008 by Scott Wheeler\n    email                : wheeler@kde.org\n ***************************************************************************/\n\n/***************************************************************************\n *   This library is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU Lesser General Public License version   *\n *   2.1 as published by the Free Software Foundation.                     *\n *                                                                         *\n *   This library is distributed in the hope that it will be useful, but   *\n *   WITHOUT ANY WARRANTY; without even the implied warranty of            *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *\n *   Lesser General Public License for more details.                       *\n *                                                                         *\n *   You should have received a copy of the GNU Lesser General Public      *\n *   License along with this library; if not, write to the Free Software   *\n *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *\n *   02110-1301  USA                                                       *\n *                                                                         *\n *   Alternatively, this file is available under the Mozilla Public        *\n *   License Version 1.1.  You may obtain a copy of the License at         *\n *   http://www.mozilla.org/MPL/                                           *\n ***************************************************************************/\n\n#include <tbytevector.h>\n#include <tdebug.h>\n\n#include <xiphcomment.h>\n\nusing namespace TagLib;\n\nclass Ogg::XiphComment::XiphCommentPrivate\n{\npublic:\n  FieldListMap fieldListMap;\n  String vendorID;\n  String commentField;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// public members\n////////////////////////////////////////////////////////////////////////////////\n\nOgg::XiphComment::XiphComment() : TagLib::Tag()\n{\n  d = new XiphCommentPrivate;\n}\n\nOgg::XiphComment::XiphComment(const ByteVector &data) : TagLib::Tag()\n{\n  d = new XiphCommentPrivate;\n  parse(data);\n}\n\nOgg::XiphComment::~XiphComment()\n{\n  delete d;\n}\n\nString Ogg::XiphComment::title() const\n{\n  if(d->fieldListMap[\"TITLE\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"TITLE\"].front();\n}\n\nString Ogg::XiphComment::artist() const\n{\n  if(d->fieldListMap[\"ARTIST\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"ARTIST\"].front();\n}\n\nString Ogg::XiphComment::album() const\n{\n  if(d->fieldListMap[\"ALBUM\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"ALBUM\"].front();\n}\n\nString Ogg::XiphComment::comment() const\n{\n  if(!d->fieldListMap[\"DESCRIPTION\"].isEmpty()) {\n    d->commentField = \"DESCRIPTION\";\n    return d->fieldListMap[\"DESCRIPTION\"].front();\n  }\n\n  if(!d->fieldListMap[\"COMMENT\"].isEmpty()) {\n    d->commentField = \"COMMENT\";\n    return d->fieldListMap[\"COMMENT\"].front();\n  }\n\n  return String::null;\n}\n\nString Ogg::XiphComment::genre() const\n{\n  if(d->fieldListMap[\"GENRE\"].isEmpty())\n    return String::null;\n  return d->fieldListMap[\"GENRE\"].front();\n}\n\nTagLib::uint Ogg::XiphComment::year() const\n{\n  if(!d->fieldListMap[\"DATE\"].isEmpty())\n    return d->fieldListMap[\"DATE\"].front().toInt();\n  if(!d->fieldListMap[\"YEAR\"].isEmpty())\n    return d->fieldListMap[\"YEAR\"].front().toInt();\n  return 0;\n}\n\nTagLib::uint Ogg::XiphComment::track() const\n{\n  if(!d->fieldListMap[\"TRACKNUMBER\"].isEmpty())\n    return d->fieldListMap[\"TRACKNUMBER\"].front().toInt();\n  if(!d->fieldListMap[\"TRACKNUM\"].isEmpty())\n    return d->fieldListMap[\"TRACKNUM\"].front().toInt();\n  return 0;\n}\n\nvoid Ogg::XiphComment::setTitle(const String &s)\n{\n  addField(\"TITLE\", s);\n}\n\nvoid Ogg::XiphComment::setArtist(const String &s)\n{\n  addField(\"ARTIST\", s);\n}\n\nvoid Ogg::XiphComment::setAlbum(const String &s)\n{\n  addField(\"ALBUM\", s);\n}\n\nvoid Ogg::XiphComment::setComment(const String &s)\n{\n  addField(d->commentField.isEmpty() ? \"DESCRIPTION\" : d->commentField, s);\n}\n\nvoid Ogg::XiphComment::setGenre(const String &s)\n{\n  addField(\"GENRE\", s);\n}\n\nvoid Ogg::XiphComment::setYear(uint i)\n{\n  removeField(\"YEAR\");\n  if(i == 0)\n    removeField(\"DATE\");\n  else\n    addField(\"DATE\", String::number(i));\n}\n\nvoid Ogg::XiphComment::setTrack(uint i)\n{\n  removeField(\"TRACKNUM\");\n  if(i == 0)\n    removeField(\"TRACKNUMBER\");\n  else\n    addField(\"TRACKNUMBER\", String::number(i));\n}\n\nbool Ogg::XiphComment::isEmpty() const\n{\n  FieldListMap::ConstIterator it = d->fieldListMap.begin();\n  for(; it != d->fieldListMap.end(); ++it)\n    if(!(*it).second.isEmpty())\n      return false;\n\n  return true;\n}\n\nTagLib::uint Ogg::XiphComment::fieldCount() const\n{\n  uint count = 0;\n\n  FieldListMap::ConstIterator it = d->fieldListMap.begin();\n  for(; it != d->fieldListMap.end(); ++it)\n    count += (*it).second.size();\n\n  return count;\n}\n\nconst Ogg::FieldListMap &Ogg::XiphComment::fieldListMap() const\n{\n  return d->fieldListMap;\n}\n\nString Ogg::XiphComment::vendorID() const\n{\n  return d->vendorID;\n}\n\nvoid Ogg::XiphComment::addField(const String &key, const String &value, bool replace)\n{\n  if(replace)\n    removeField(key.upper());\n\n  if(!key.isEmpty() && !value.isEmpty())\n    d->fieldListMap[key.upper()].append(value);\n}\n\nvoid Ogg::XiphComment::removeField(const String &key, const String &value)\n{\n  if(!value.isNull()) {\n    StringList::Iterator it = d->fieldListMap[key].begin();\n    while(it != d->fieldListMap[key].end()) {\n      if(value == *it)\n        it = d->fieldListMap[key].erase(it);\n      else\n        it++;\n    }\n  }\n  else\n    d->fieldListMap.erase(key);\n}\n\nbool Ogg::XiphComment::contains(const String &key) const\n{\n  return d->fieldListMap.contains(key) && !d->fieldListMap[key].isEmpty();\n}\n\nByteVector Ogg::XiphComment::render() const\n{\n  return render(true);\n}\n\nByteVector Ogg::XiphComment::render(bool addFramingBit) const\n{\n  ByteVector data;\n\n  // Add the vendor ID length and the vendor ID.  It's important to use the\n  // length of the data(String::UTF8) rather than the length of the the string\n  // since this is UTF8 text and there may be more characters in the data than\n  // in the UTF16 string.\n\n  ByteVector vendorData = d->vendorID.data(String::UTF8);\n\n  data.append(ByteVector::fromUInt(vendorData.size(), false));\n  data.append(vendorData);\n\n  // Add the number of fields.\n\n  data.append(ByteVector::fromUInt(fieldCount(), false));\n\n  // Iterate over the the field lists.  Our iterator returns a\n  // std::pair<String, StringList> where the first String is the field name and\n  // the StringList is the values associated with that field.\n\n  FieldListMap::ConstIterator it = d->fieldListMap.begin();\n  for(; it != d->fieldListMap.end(); ++it) {\n\n    // And now iterate over the values of the current list.\n\n    String fieldName = (*it).first;\n    StringList values = (*it).second;\n\n    StringList::ConstIterator valuesIt = values.begin();\n    for(; valuesIt != values.end(); ++valuesIt) {\n      ByteVector fieldData = fieldName.data(String::UTF8);\n      fieldData.append('=');\n      fieldData.append((*valuesIt).data(String::UTF8));\n\n      data.append(ByteVector::fromUInt(fieldData.size(), false));\n      data.append(fieldData);\n    }\n  }\n\n  // Append the \"framing bit\".\n\n  if(addFramingBit)\n    data.append(char(1));\n\n  return data;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// protected members\n////////////////////////////////////////////////////////////////////////////////\n\nvoid Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  int pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}\n"], "filenames": ["taglib/ogg/xiphcomment.cpp"], "buggy_code_start_loc": [298], "buggy_code_end_loc": [312], "fixing_code_start_loc": [298], "fixing_code_end_loc": [323], "type": "CWE-20", "message": "The parse function in ogg/xiphcomment.cpp in TagLib 1.7 and earlier allows remote attackers to cause a denial of service (crash) via a crafted vendorLength field in an ogg file.", "other": {"cve": {"id": "CVE-2012-1108", "sourceIdentifier": "secalert@redhat.com", "published": "2012-09-06T18:55:01.050", "lastModified": "2017-08-29T01:31:12.320", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The parse function in ogg/xiphcomment.cpp in TagLib 1.7 and earlier allows remote attackers to cause a denial of service (crash) via a crafted vendorLength field in an ogg file."}, {"lang": "es", "value": "La funci\u00f3n de an\u00e1lisis en ogg/xiphcomment.cpp en TagLib v1.7 y anteriores permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de un campo vendorLength dise\u00f1ado en un archivo ogg"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.7", "matchCriteriaId": "0F562C2E-4011-40CD-B0D0-2A3F9DBCAB8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "C28F20C9-4939-4F4A-96A8-B44B84F20DA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "11625F29-9539-45ED-8C69-BE49CB3E1640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "D74F6CEA-4FEE-44CD-844A-886E5A6B2D76"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "A7EE066F-C257-4AE8-81ED-880F0DB35CDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3BEFD3D-3091-41B2-93E1-9BB5464455B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.4:*:*:*:*:*:*:*", "matchCriteriaId": "403A4D45-BE2E-41DC-971E-6A83B0F44DD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "C64D253F-DE01-46D0-A1BD-099DF5ABC445"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.6:*:*:*:*:*:*:*", "matchCriteriaId": "062A2172-E47F-43BA-AB6C-E7CE669D2BD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "34AF2A82-886F-42F5-9841-ECACE1BED7C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "CDBC7873-2E15-44AA-8D31-10394CED96BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scott_wheeler:taglib:1.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "F990984E-7F9F-4DC0-B05D-60F88F8DC947"}]}]}], "references": [{"url": "http://mail.kde.org/pipermail/taglib-devel/2012-March/002186.html", "source": "secalert@redhat.com"}, {"url": "http://mail.kde.org/pipermail/taglib-devel/2012-March/002191.html", "source": "secalert@redhat.com"}, {"url": "http://www.gentoo.org/security/en/glsa/glsa-201206-16.xml", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/03/05/19", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/52284", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/73665", "source": "secalert@redhat.com"}, {"url": "https://github.com/taglib/taglib/commit/b3646a07348ffa276ea41a9dae03ddc63ea6c532", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/taglib/taglib/commit/b3646a07348ffa276ea41a9dae03ddc63ea6c532"}}