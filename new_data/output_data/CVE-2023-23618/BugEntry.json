{"buggy_code": ["#!/bin/sh\n# Tcl ignores the next line -*- tcl -*- \\\nexec wish \"$0\" -- \"$@\"\n\n# Copyright \u00a9 2005-2016 Paul Mackerras.  All rights reserved.\n# This program is free software; it may be used, copied, modified\n# and distributed under the terms of the GNU General Public Licence,\n# either version 2, or (at your option) any later version.\n\npackage require Tk\n\nproc hasworktree {} {\n    return [expr {[exec git rev-parse --is-bare-repository] == \"false\" &&\n                  [exec git rev-parse --is-inside-git-dir] == \"false\"}]\n}\n\nproc reponame {} {\n    global gitdir\n    set n [file normalize $gitdir]\n    if {[string match \"*/.git\" $n]} {\n        set n [string range $n 0 end-5]\n    }\n    return [file tail $n]\n}\n\nproc gitworktree {} {\n    variable _gitworktree\n    if {[info exists _gitworktree]} {\n        return $_gitworktree\n    }\n    # v1.7.0 introduced --show-toplevel to return the canonical work-tree\n    if {[catch {set _gitworktree [exec git rev-parse --show-toplevel]}]} {\n        # try to set work tree from environment, core.worktree or use\n        # cdup to obtain a relative path to the top of the worktree. If\n        # run from the top, the ./ prefix ensures normalize expands pwd.\n        if {[catch { set _gitworktree $env(GIT_WORK_TREE) }]} {\n            if {[catch {set _gitworktree [exec git config --get core.worktree]}]} {\n                set _gitworktree [file normalize ./[exec git rev-parse --show-cdup]]\n            }\n        }\n    }\n    return $_gitworktree\n}\n\n# A simple scheduler for compute-intensive stuff.\n# The aim is to make sure that event handlers for GUI actions can\n# run at least every 50-100 ms.  Unfortunately fileevent handlers are\n# run before X event handlers, so reading from a fast source can\n# make the GUI completely unresponsive.\nproc run args {\n    global isonrunq runq currunq\n\n    set script $args\n    if {[info exists isonrunq($script)]} return\n    if {$runq eq {} && ![info exists currunq]} {\n        after idle dorunq\n    }\n    lappend runq [list {} $script]\n    set isonrunq($script) 1\n}\n\nproc filerun {fd script} {\n    fileevent $fd readable [list filereadable $fd $script]\n}\n\nproc filereadable {fd script} {\n    global runq currunq\n\n    fileevent $fd readable {}\n    if {$runq eq {} && ![info exists currunq]} {\n        after idle dorunq\n    }\n    lappend runq [list $fd $script]\n}\n\nproc nukefile {fd} {\n    global runq\n\n    for {set i 0} {$i < [llength $runq]} {} {\n        if {[lindex $runq $i 0] eq $fd} {\n            set runq [lreplace $runq $i $i]\n        } else {\n            incr i\n        }\n    }\n}\n\nproc dorunq {} {\n    global isonrunq runq currunq\n\n    set tstart [clock clicks -milliseconds]\n    set t0 $tstart\n    while {[llength $runq] > 0} {\n        set fd [lindex $runq 0 0]\n        set script [lindex $runq 0 1]\n        set currunq [lindex $runq 0]\n        set runq [lrange $runq 1 end]\n        set repeat [eval $script]\n        unset currunq\n        set t1 [clock clicks -milliseconds]\n        set t [expr {$t1 - $t0}]\n        if {$repeat ne {} && $repeat} {\n            if {$fd eq {} || $repeat == 2} {\n                # script returns 1 if it wants to be readded\n                # file readers return 2 if they could do more straight away\n                lappend runq [list $fd $script]\n            } else {\n                fileevent $fd readable [list filereadable $fd $script]\n            }\n        } elseif {$fd eq {}} {\n            unset isonrunq($script)\n        }\n        set t0 $t1\n        if {$t1 - $tstart >= 80} break\n    }\n    if {$runq ne {}} {\n        after idle dorunq\n    }\n}\n\nproc reg_instance {fd} {\n    global commfd leftover loginstance\n\n    set i [incr loginstance]\n    set commfd($i) $fd\n    set leftover($i) {}\n    return $i\n}\n\nproc unmerged_files {files} {\n    global nr_unmerged\n\n    # find the list of unmerged files\n    set mlist {}\n    set nr_unmerged 0\n    if {[catch {\n        set fd [open \"| git ls-files -u\" r]\n    } err]} {\n        show_error {} . \"[mc \"Couldn't get list of unmerged files:\"] $err\"\n        exit 1\n    }\n    while {[gets $fd line] >= 0} {\n        set i [string first \"\\t\" $line]\n        if {$i < 0} continue\n        set fname [string range $line [expr {$i+1}] end]\n        if {[lsearch -exact $mlist $fname] >= 0} continue\n        incr nr_unmerged\n        if {$files eq {} || [path_filter $files $fname]} {\n            lappend mlist $fname\n        }\n    }\n    catch {close $fd}\n    return $mlist\n}\n\nproc parseviewargs {n arglist} {\n    global vdatemode vmergeonly vflags vdflags vrevs vfiltered vorigargs env\n    global vinlinediff\n    global worddiff git_version\n\n    set vdatemode($n) 0\n    set vmergeonly($n) 0\n    set vinlinediff($n) 0\n    set glflags {}\n    set diffargs {}\n    set nextisval 0\n    set revargs {}\n    set origargs $arglist\n    set allknown 1\n    set filtered 0\n    set i -1\n    foreach arg $arglist {\n        incr i\n        if {$nextisval} {\n            lappend glflags $arg\n            set nextisval 0\n            continue\n        }\n        switch -glob -- $arg {\n            \"-d\" -\n            \"--date-order\" {\n                set vdatemode($n) 1\n                # remove from origargs in case we hit an unknown option\n                set origargs [lreplace $origargs $i $i]\n                incr i -1\n            }\n            \"-[puabwcrRBMC]\" -\n            \"--no-renames\" - \"--full-index\" - \"--binary\" - \"--abbrev=*\" -\n            \"--find-copies-harder\" - \"-l*\" - \"--ext-diff\" - \"--no-ext-diff\" -\n            \"--src-prefix=*\" - \"--dst-prefix=*\" - \"--no-prefix\" -\n            \"-O*\" - \"--text\" - \"--full-diff\" - \"--ignore-space-at-eol\" -\n            \"--ignore-space-change\" - \"-U*\" - \"--unified=*\" {\n                # These request or affect diff output, which we don't want.\n                # Some could be used to set our defaults for diff display.\n                lappend diffargs $arg\n            }\n            \"--raw\" - \"--patch-with-raw\" - \"--patch-with-stat\" -\n            \"--name-only\" - \"--name-status\" - \"--color\" -\n            \"--log-size\" - \"--pretty=*\" - \"--decorate\" - \"--abbrev-commit\" -\n            \"--cc\" - \"-z\" - \"--header\" - \"--parents\" - \"--boundary\" -\n            \"--no-color\" - \"-g\" - \"--walk-reflogs\" - \"--no-walk\" -\n            \"--timestamp\" - \"relative-date\" - \"--date=*\" - \"--stdin\" -\n            \"--objects\" - \"--objects-edge\" - \"--reverse\" {\n                # These cause our parsing of git log's output to fail, or else\n                # they're options we want to set ourselves, so ignore them.\n            }\n            \"--color-words*\" - \"--word-diff=color\" {\n                # These trigger a word diff in the console interface,\n                # so help the user by enabling our own support\n                if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n                    set worddiff [mc \"Color words\"]\n                }\n            }\n            \"--word-diff*\" {\n                if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n                    set worddiff [mc \"Markup words\"]\n                }\n            }\n            \"--stat=*\" - \"--numstat\" - \"--shortstat\" - \"--summary\" -\n            \"--check\" - \"--exit-code\" - \"--quiet\" - \"--topo-order\" -\n            \"--full-history\" - \"--dense\" - \"--sparse\" -\n            \"--follow\" - \"--left-right\" - \"--encoding=*\" {\n                # These are harmless, and some are even useful\n                lappend glflags $arg\n            }\n            \"--diff-filter=*\" - \"--no-merges\" - \"--unpacked\" -\n            \"--max-count=*\" - \"--skip=*\" - \"--since=*\" - \"--after=*\" -\n            \"--until=*\" - \"--before=*\" - \"--max-age=*\" - \"--min-age=*\" -\n            \"--author=*\" - \"--committer=*\" - \"--grep=*\" - \"-[iE]\" -\n            \"--remove-empty\" - \"--first-parent\" - \"--cherry-pick\" -\n            \"-S*\" - \"-G*\" - \"--pickaxe-all\" - \"--pickaxe-regex\" -\n            \"--simplify-by-decoration\" {\n                # These mean that we get a subset of the commits\n                set filtered 1\n                lappend glflags $arg\n            }\n            \"-L*\" {\n                # Line-log with 'stuck' argument (unstuck form is\n                # not supported)\n                set filtered 1\n                set vinlinediff($n) 1\n                set allknown 0\n                lappend glflags $arg\n            }\n            \"-n\" {\n                # This appears to be the only one that has a value as a\n                # separate word following it\n                set filtered 1\n                set nextisval 1\n                lappend glflags $arg\n            }\n            \"--not\" - \"--all\" {\n                lappend revargs $arg\n            }\n            \"--merge\" {\n                set vmergeonly($n) 1\n                # git rev-parse doesn't understand --merge\n                lappend revargs --gitk-symmetric-diff-marker MERGE_HEAD...HEAD\n            }\n            \"--no-replace-objects\" {\n                set env(GIT_NO_REPLACE_OBJECTS) \"1\"\n            }\n            \"-*\" {\n                # Other flag arguments including -<n>\n                if {[string is digit -strict [string range $arg 1 end]]} {\n                    set filtered 1\n                } else {\n                    # a flag argument that we don't recognize;\n                    # that means we can't optimize\n                    set allknown 0\n                }\n                lappend glflags $arg\n            }\n            default {\n                # Non-flag arguments specify commits or ranges of commits\n                if {[string match \"*...*\" $arg]} {\n                    lappend revargs --gitk-symmetric-diff-marker\n                }\n                lappend revargs $arg\n            }\n        }\n    }\n    set vdflags($n) $diffargs\n    set vflags($n) $glflags\n    set vrevs($n) $revargs\n    set vfiltered($n) $filtered\n    set vorigargs($n) $origargs\n    return $allknown\n}\n\nproc parseviewrevs {view revs} {\n    global vposids vnegids\n\n    if {$revs eq {}} {\n        set revs HEAD\n    } elseif {[lsearch -exact $revs --all] >= 0} {\n        lappend revs HEAD\n    }\n    if {[catch {set ids [eval exec git rev-parse $revs]} err]} {\n        # we get stdout followed by stderr in $err\n        # for an unknown rev, git rev-parse echoes it and then errors out\n        set errlines [split $err \"\\n\"]\n        set badrev {}\n        for {set l 0} {$l < [llength $errlines]} {incr l} {\n            set line [lindex $errlines $l]\n            if {!([string length $line] == 40 && [string is xdigit $line])} {\n                if {[string match \"fatal:*\" $line]} {\n                    if {[string match \"fatal: ambiguous argument*\" $line]\n                        && $badrev ne {}} {\n                        if {[llength $badrev] == 1} {\n                            set err \"unknown revision $badrev\"\n                        } else {\n                            set err \"unknown revisions: [join $badrev \", \"]\"\n                        }\n                    } else {\n                        set err [join [lrange $errlines $l end] \"\\n\"]\n                    }\n                    break\n                }\n                lappend badrev $line\n            }\n        }\n        error_popup \"[mc \"Error parsing revisions:\"] $err\"\n        return {}\n    }\n    set ret {}\n    set pos {}\n    set neg {}\n    set sdm 0\n    foreach id [split $ids \"\\n\"] {\n        if {$id eq \"--gitk-symmetric-diff-marker\"} {\n            set sdm 4\n        } elseif {[string match \"^*\" $id]} {\n            if {$sdm != 1} {\n                lappend ret $id\n                if {$sdm == 3} {\n                    set sdm 0\n                }\n            }\n            lappend neg [string range $id 1 end]\n        } else {\n            if {$sdm != 2} {\n                lappend ret $id\n            } else {\n                lset ret end $id...[lindex $ret end]\n            }\n            lappend pos $id\n        }\n        incr sdm -1\n    }\n    set vposids($view) $pos\n    set vnegids($view) $neg\n    return $ret\n}\n\n# Escapes a list of filter paths to be passed to git log via stdin. Note that\n# paths must not be quoted.\nproc escape_filter_paths {paths} {\n\tset escaped [list]\n\tforeach path $paths {\n\t\tlappend escaped [string map {\\\\ \\\\\\\\ \"\\ \" \"\\\\\\ \"} $path]\n\t}\n\treturn $escaped\n}\n\n# Start off a git log process and arrange to read its output\nproc start_rev_list {view} {\n    global startmsecs commitidx viewcomplete curview\n    global tclencoding\n    global viewargs viewargscmd viewfiles vfilelimit\n    global showlocalchanges\n    global viewactive viewinstances vmergeonly\n    global mainheadid viewmainheadid viewmainheadid_orig\n    global vcanopt vflags vrevs vorigargs\n    global show_notes\n\n    set startmsecs [clock clicks -milliseconds]\n    set commitidx($view) 0\n    # these are set this way for the error exits\n    set viewcomplete($view) 1\n    set viewactive($view) 0\n    varcinit $view\n\n    set args $viewargs($view)\n    if {$viewargscmd($view) ne {}} {\n        if {[catch {\n            set str [exec sh -c $viewargscmd($view)]\n        } err]} {\n            error_popup \"[mc \"Error executing --argscmd command:\"] $err\"\n            return 0\n        }\n        set args [concat $args [split $str \"\\n\"]]\n    }\n    set vcanopt($view) [parseviewargs $view $args]\n\n    set files $viewfiles($view)\n    if {$vmergeonly($view)} {\n        set files [unmerged_files $files]\n        if {$files eq {}} {\n            global nr_unmerged\n            if {$nr_unmerged == 0} {\n                error_popup [mc \"No files selected: --merge specified but\\\n                             no files are unmerged.\"]\n            } else {\n                error_popup [mc \"No files selected: --merge specified but\\\n                             no unmerged files are within file limit.\"]\n            }\n            return 0\n        }\n    }\n    set vfilelimit($view) $files\n\n    if {$vcanopt($view)} {\n        set revs [parseviewrevs $view $vrevs($view)]\n        if {$revs eq {}} {\n            return 0\n        }\n        set args $vflags($view)\n    } else {\n        set revs {}\n        set args $vorigargs($view)\n    }\n\n    if {[catch {\n        set fd [open [concat | git log --no-color -z --pretty=raw $show_notes \\\n                        --parents --boundary $args --stdin \\\n                        \"<<[join [concat $revs \"--\" \\\n                                [escape_filter_paths $files]] \"\\\\n\"]\"] r]\n    } err]} {\n        error_popup \"[mc \"Error executing git log:\"] $err\"\n        return 0\n    }\n    set i [reg_instance $fd]\n    set viewinstances($view) [list $i]\n    set viewmainheadid($view) $mainheadid\n    set viewmainheadid_orig($view) $mainheadid\n    if {$files ne {} && $mainheadid ne {}} {\n        get_viewmainhead $view\n    }\n    if {$showlocalchanges && $viewmainheadid($view) ne {}} {\n        interestedin $viewmainheadid($view) dodiffindex\n    }\n    fconfigure $fd -blocking 0 -translation lf -eofchar {}\n    if {$tclencoding != {}} {\n        fconfigure $fd -encoding $tclencoding\n    }\n    filerun $fd [list getcommitlines $fd $i $view 0]\n    nowbusy $view [mc \"Reading\"]\n    set viewcomplete($view) 0\n    set viewactive($view) 1\n    return 1\n}\n\nproc stop_instance {inst} {\n    global commfd leftover\n\n    set fd $commfd($inst)\n    catch {\n        set pid [pid $fd]\n\n        if {$::tcl_platform(platform) eq {windows}} {\n            exec taskkill /pid $pid\n        } else {\n            exec kill $pid\n        }\n    }\n    catch {close $fd}\n    nukefile $fd\n    unset commfd($inst)\n    unset leftover($inst)\n}\n\nproc stop_backends {} {\n    global commfd\n\n    foreach inst [array names commfd] {\n        stop_instance $inst\n    }\n}\n\nproc stop_rev_list {view} {\n    global viewinstances\n\n    foreach inst $viewinstances($view) {\n        stop_instance $inst\n    }\n    set viewinstances($view) {}\n}\n\nproc reset_pending_select {selid} {\n    global pending_select mainheadid selectheadid\n\n    if {$selid ne {}} {\n        set pending_select $selid\n    } elseif {$selectheadid ne {}} {\n        set pending_select $selectheadid\n    } else {\n        set pending_select $mainheadid\n    }\n}\n\nproc getcommits {selid} {\n    global canv curview need_redisplay viewactive\n\n    initlayout\n    if {[start_rev_list $curview]} {\n        reset_pending_select $selid\n        show_status [mc \"Reading commits...\"]\n        set need_redisplay 1\n    } else {\n        show_status [mc \"No commits selected\"]\n    }\n}\n\nproc updatecommits {} {\n    global curview vcanopt vorigargs vfilelimit viewinstances\n    global viewactive viewcomplete tclencoding\n    global startmsecs showneartags showlocalchanges\n    global mainheadid viewmainheadid viewmainheadid_orig pending_select\n    global hasworktree\n    global varcid vposids vnegids vflags vrevs\n    global show_notes\n\n    set hasworktree [hasworktree]\n    rereadrefs\n    set view $curview\n    if {$mainheadid ne $viewmainheadid_orig($view)} {\n        if {$showlocalchanges} {\n            dohidelocalchanges\n        }\n        set viewmainheadid($view) $mainheadid\n        set viewmainheadid_orig($view) $mainheadid\n        if {$vfilelimit($view) ne {}} {\n            get_viewmainhead $view\n        }\n    }\n    if {$showlocalchanges} {\n        doshowlocalchanges\n    }\n    if {$vcanopt($view)} {\n        set oldpos $vposids($view)\n        set oldneg $vnegids($view)\n        set revs [parseviewrevs $view $vrevs($view)]\n        if {$revs eq {}} {\n            return\n        }\n        # note: getting the delta when negative refs change is hard,\n        # and could require multiple git log invocations, so in that\n        # case we ask git log for all the commits (not just the delta)\n        if {$oldneg eq $vnegids($view)} {\n            set newrevs {}\n            set npos 0\n            # take out positive refs that we asked for before or\n            # that we have already seen\n            foreach rev $revs {\n                if {[string length $rev] == 40} {\n                    if {[lsearch -exact $oldpos $rev] < 0\n                        && ![info exists varcid($view,$rev)]} {\n                        lappend newrevs $rev\n                        incr npos\n                    }\n                } else {\n                    lappend $newrevs $rev\n                }\n            }\n            if {$npos == 0} return\n            set revs $newrevs\n            set vposids($view) [lsort -unique [concat $oldpos $vposids($view)]]\n        }\n        set args $vflags($view)\n        foreach r $oldpos {\n                lappend revs \"^$r\"\n        }\n    } else {\n        set revs {}\n        set args $vorigargs($view)\n    }\n    if {[catch {\n        set fd [open [concat | git log --no-color -z --pretty=raw $show_notes \\\n                        --parents --boundary $args --stdin \\\n                        \"<<[join [concat $revs \"--\" \\\n                                [escape_filter_paths \\\n                                        $vfilelimit($view)]] \"\\\\n\"]\"] r]\n    } err]} {\n        error_popup \"[mc \"Error executing git log:\"] $err\"\n        return\n    }\n    if {$viewactive($view) == 0} {\n        set startmsecs [clock clicks -milliseconds]\n    }\n    set i [reg_instance $fd]\n    lappend viewinstances($view) $i\n    fconfigure $fd -blocking 0 -translation lf -eofchar {}\n    if {$tclencoding != {}} {\n        fconfigure $fd -encoding $tclencoding\n    }\n    filerun $fd [list getcommitlines $fd $i $view 1]\n    incr viewactive($view)\n    set viewcomplete($view) 0\n    reset_pending_select {}\n    nowbusy $view [mc \"Reading\"]\n    if {$showneartags} {\n        getallcommits\n    }\n}\n\nproc reloadcommits {} {\n    global curview viewcomplete selectedline currentid thickerline\n    global showneartags treediffs commitinterest cached_commitrow\n    global targetid commitinfo\n\n    set selid {}\n    if {$selectedline ne {}} {\n        set selid $currentid\n    }\n\n    if {!$viewcomplete($curview)} {\n        stop_rev_list $curview\n    }\n    resetvarcs $curview\n    set selectedline {}\n    unset -nocomplain currentid\n    unset -nocomplain thickerline\n    unset -nocomplain treediffs\n    readrefs\n    changedrefs\n    if {$showneartags} {\n        getallcommits\n    }\n    clear_display\n    unset -nocomplain commitinfo\n    unset -nocomplain commitinterest\n    unset -nocomplain cached_commitrow\n    unset -nocomplain targetid\n    setcanvscroll\n    getcommits $selid\n    return 0\n}\n\n# This makes a string representation of a positive integer which\n# sorts as a string in numerical order\nproc strrep {n} {\n    if {$n < 16} {\n        return [format \"%x\" $n]\n    } elseif {$n < 256} {\n        return [format \"x%.2x\" $n]\n    } elseif {$n < 65536} {\n        return [format \"y%.4x\" $n]\n    }\n    return [format \"z%.8x\" $n]\n}\n\n# Procedures used in reordering commits from git log (without\n# --topo-order) into the order for display.\n\nproc varcinit {view} {\n    global varcstart vupptr vdownptr vleftptr vbackptr varctok varcrow\n    global vtokmod varcmod vrowmod varcix vlastins\n\n    set varcstart($view) {{}}\n    set vupptr($view) {0}\n    set vdownptr($view) {0}\n    set vleftptr($view) {0}\n    set vbackptr($view) {0}\n    set varctok($view) {{}}\n    set varcrow($view) {{}}\n    set vtokmod($view) {}\n    set varcmod($view) 0\n    set vrowmod($view) 0\n    set varcix($view) {{}}\n    set vlastins($view) {0}\n}\n\nproc resetvarcs {view} {\n    global varcid varccommits parents children vseedcount ordertok\n    global vshortids\n\n    foreach vid [array names varcid $view,*] {\n        unset varcid($vid)\n        unset children($vid)\n        unset parents($vid)\n    }\n    foreach vid [array names vshortids $view,*] {\n        unset vshortids($vid)\n    }\n    # some commits might have children but haven't been seen yet\n    foreach vid [array names children $view,*] {\n        unset children($vid)\n    }\n    foreach va [array names varccommits $view,*] {\n        unset varccommits($va)\n    }\n    foreach vd [array names vseedcount $view,*] {\n        unset vseedcount($vd)\n    }\n    unset -nocomplain ordertok\n}\n\n# returns a list of the commits with no children\nproc seeds {v} {\n    global vdownptr vleftptr varcstart\n\n    set ret {}\n    set a [lindex $vdownptr($v) 0]\n    while {$a != 0} {\n        lappend ret [lindex $varcstart($v) $a]\n        set a [lindex $vleftptr($v) $a]\n    }\n    return $ret\n}\n\nproc newvarc {view id} {\n    global varcid varctok parents children vdatemode\n    global vupptr vdownptr vleftptr vbackptr varcrow varcix varcstart\n    global commitdata commitinfo vseedcount varccommits vlastins\n\n    set a [llength $varctok($view)]\n    set vid $view,$id\n    if {[llength $children($vid)] == 0 || $vdatemode($view)} {\n        if {![info exists commitinfo($id)]} {\n            parsecommit $id $commitdata($id) 1\n        }\n        set cdate [lindex [lindex $commitinfo($id) 4] 0]\n        if {![string is integer -strict $cdate]} {\n            set cdate 0\n        }\n        if {![info exists vseedcount($view,$cdate)]} {\n            set vseedcount($view,$cdate) -1\n        }\n        set c [incr vseedcount($view,$cdate)]\n        set cdate [expr {$cdate ^ 0xffffffff}]\n        set tok \"s[strrep $cdate][strrep $c]\"\n    } else {\n        set tok {}\n    }\n    set ka 0\n    if {[llength $children($vid)] > 0} {\n        set kid [lindex $children($vid) end]\n        set k $varcid($view,$kid)\n        if {[string compare [lindex $varctok($view) $k] $tok] > 0} {\n            set ki $kid\n            set ka $k\n            set tok [lindex $varctok($view) $k]\n        }\n    }\n    if {$ka != 0} {\n        set i [lsearch -exact $parents($view,$ki) $id]\n        set j [expr {[llength $parents($view,$ki)] - 1 - $i}]\n        append tok [strrep $j]\n    }\n    set c [lindex $vlastins($view) $ka]\n    if {$c == 0 || [string compare $tok [lindex $varctok($view) $c]] < 0} {\n        set c $ka\n        set b [lindex $vdownptr($view) $ka]\n    } else {\n        set b [lindex $vleftptr($view) $c]\n    }\n    while {$b != 0 && [string compare $tok [lindex $varctok($view) $b]] >= 0} {\n        set c $b\n        set b [lindex $vleftptr($view) $c]\n    }\n    if {$c == $ka} {\n        lset vdownptr($view) $ka $a\n        lappend vbackptr($view) 0\n    } else {\n        lset vleftptr($view) $c $a\n        lappend vbackptr($view) $c\n    }\n    lset vlastins($view) $ka $a\n    lappend vupptr($view) $ka\n    lappend vleftptr($view) $b\n    if {$b != 0} {\n        lset vbackptr($view) $b $a\n    }\n    lappend varctok($view) $tok\n    lappend varcstart($view) $id\n    lappend vdownptr($view) 0\n    lappend varcrow($view) {}\n    lappend varcix($view) {}\n    set varccommits($view,$a) {}\n    lappend vlastins($view) 0\n    return $a\n}\n\nproc splitvarc {p v} {\n    global varcid varcstart varccommits varctok vtokmod\n    global vupptr vdownptr vleftptr vbackptr varcix varcrow vlastins\n\n    set oa $varcid($v,$p)\n    set otok [lindex $varctok($v) $oa]\n    set ac $varccommits($v,$oa)\n    set i [lsearch -exact $varccommits($v,$oa) $p]\n    if {$i <= 0} return\n    set na [llength $varctok($v)]\n    # \"%\" sorts before \"0\"...\n    set tok \"$otok%[strrep $i]\"\n    lappend varctok($v) $tok\n    lappend varcrow($v) {}\n    lappend varcix($v) {}\n    set varccommits($v,$oa) [lrange $ac 0 [expr {$i - 1}]]\n    set varccommits($v,$na) [lrange $ac $i end]\n    lappend varcstart($v) $p\n    foreach id $varccommits($v,$na) {\n        set varcid($v,$id) $na\n    }\n    lappend vdownptr($v) [lindex $vdownptr($v) $oa]\n    lappend vlastins($v) [lindex $vlastins($v) $oa]\n    lset vdownptr($v) $oa $na\n    lset vlastins($v) $oa 0\n    lappend vupptr($v) $oa\n    lappend vleftptr($v) 0\n    lappend vbackptr($v) 0\n    for {set b [lindex $vdownptr($v) $na]} {$b != 0} {set b [lindex $vleftptr($v) $b]} {\n        lset vupptr($v) $b $na\n    }\n    if {[string compare $otok $vtokmod($v)] <= 0} {\n        modify_arc $v $oa\n    }\n}\n\nproc renumbervarc {a v} {\n    global parents children varctok varcstart varccommits\n    global vupptr vdownptr vleftptr vbackptr vlastins varcid vtokmod vdatemode\n\n    set t1 [clock clicks -milliseconds]\n    set todo {}\n    set isrelated($a) 1\n    set kidchanged($a) 1\n    set ntot 0\n    while {$a != 0} {\n        if {[info exists isrelated($a)]} {\n            lappend todo $a\n            set id [lindex $varccommits($v,$a) end]\n            foreach p $parents($v,$id) {\n                if {[info exists varcid($v,$p)]} {\n                    set isrelated($varcid($v,$p)) 1\n                }\n            }\n        }\n        incr ntot\n        set b [lindex $vdownptr($v) $a]\n        if {$b == 0} {\n            while {$a != 0} {\n                set b [lindex $vleftptr($v) $a]\n                if {$b != 0} break\n                set a [lindex $vupptr($v) $a]\n            }\n        }\n        set a $b\n    }\n    foreach a $todo {\n        if {![info exists kidchanged($a)]} continue\n        set id [lindex $varcstart($v) $a]\n        if {[llength $children($v,$id)] > 1} {\n            set children($v,$id) [lsort -command [list vtokcmp $v] \\\n                                      $children($v,$id)]\n        }\n        set oldtok [lindex $varctok($v) $a]\n        if {!$vdatemode($v)} {\n            set tok {}\n        } else {\n            set tok $oldtok\n        }\n        set ka 0\n        set kid [last_real_child $v,$id]\n        if {$kid ne {}} {\n            set k $varcid($v,$kid)\n            if {[string compare [lindex $varctok($v) $k] $tok] > 0} {\n                set ki $kid\n                set ka $k\n                set tok [lindex $varctok($v) $k]\n            }\n        }\n        if {$ka != 0} {\n            set i [lsearch -exact $parents($v,$ki) $id]\n            set j [expr {[llength $parents($v,$ki)] - 1 - $i}]\n            append tok [strrep $j]\n        }\n        if {$tok eq $oldtok} {\n            continue\n        }\n        set id [lindex $varccommits($v,$a) end]\n        foreach p $parents($v,$id) {\n            if {[info exists varcid($v,$p)]} {\n                set kidchanged($varcid($v,$p)) 1\n            } else {\n                set sortkids($p) 1\n            }\n        }\n        lset varctok($v) $a $tok\n        set b [lindex $vupptr($v) $a]\n        if {$b != $ka} {\n            if {[string compare [lindex $varctok($v) $ka] $vtokmod($v)] < 0} {\n                modify_arc $v $ka\n            }\n            if {[string compare [lindex $varctok($v) $b] $vtokmod($v)] < 0} {\n                modify_arc $v $b\n            }\n            set c [lindex $vbackptr($v) $a]\n            set d [lindex $vleftptr($v) $a]\n            if {$c == 0} {\n                lset vdownptr($v) $b $d\n            } else {\n                lset vleftptr($v) $c $d\n            }\n            if {$d != 0} {\n                lset vbackptr($v) $d $c\n            }\n            if {[lindex $vlastins($v) $b] == $a} {\n                lset vlastins($v) $b $c\n            }\n            lset vupptr($v) $a $ka\n            set c [lindex $vlastins($v) $ka]\n            if {$c == 0 || \\\n                    [string compare $tok [lindex $varctok($v) $c]] < 0} {\n                set c $ka\n                set b [lindex $vdownptr($v) $ka]\n            } else {\n                set b [lindex $vleftptr($v) $c]\n            }\n            while {$b != 0 && \\\n                      [string compare $tok [lindex $varctok($v) $b]] >= 0} {\n                set c $b\n                set b [lindex $vleftptr($v) $c]\n            }\n            if {$c == $ka} {\n                lset vdownptr($v) $ka $a\n                lset vbackptr($v) $a 0\n            } else {\n                lset vleftptr($v) $c $a\n                lset vbackptr($v) $a $c\n            }\n            lset vleftptr($v) $a $b\n            if {$b != 0} {\n                lset vbackptr($v) $b $a\n            }\n            lset vlastins($v) $ka $a\n        }\n    }\n    foreach id [array names sortkids] {\n        if {[llength $children($v,$id)] > 1} {\n            set children($v,$id) [lsort -command [list vtokcmp $v] \\\n                                      $children($v,$id)]\n        }\n    }\n    set t2 [clock clicks -milliseconds]\n    #puts \"renumbervarc did [llength $todo] of $ntot arcs in [expr {$t2-$t1}]ms\"\n}\n\n# Fix up the graph after we have found out that in view $v,\n# $p (a commit that we have already seen) is actually the parent\n# of the last commit in arc $a.\nproc fix_reversal {p a v} {\n    global varcid varcstart varctok vupptr\n\n    set pa $varcid($v,$p)\n    if {$p ne [lindex $varcstart($v) $pa]} {\n        splitvarc $p $v\n        set pa $varcid($v,$p)\n    }\n    # seeds always need to be renumbered\n    if {[lindex $vupptr($v) $pa] == 0 ||\n        [string compare [lindex $varctok($v) $a] \\\n             [lindex $varctok($v) $pa]] > 0} {\n        renumbervarc $pa $v\n    }\n}\n\nproc insertrow {id p v} {\n    global cmitlisted children parents varcid varctok vtokmod\n    global varccommits ordertok commitidx numcommits curview\n    global targetid targetrow vshortids\n\n    readcommit $id\n    set vid $v,$id\n    set cmitlisted($vid) 1\n    set children($vid) {}\n    set parents($vid) [list $p]\n    set a [newvarc $v $id]\n    set varcid($vid) $a\n    lappend vshortids($v,[string range $id 0 3]) $id\n    if {[string compare [lindex $varctok($v) $a] $vtokmod($v)] < 0} {\n        modify_arc $v $a\n    }\n    lappend varccommits($v,$a) $id\n    set vp $v,$p\n    if {[llength [lappend children($vp) $id]] > 1} {\n        set children($vp) [lsort -command [list vtokcmp $v] $children($vp)]\n        unset -nocomplain ordertok\n    }\n    fix_reversal $p $a $v\n    incr commitidx($v)\n    if {$v == $curview} {\n        set numcommits $commitidx($v)\n        setcanvscroll\n        if {[info exists targetid]} {\n            if {![comes_before $targetid $p]} {\n                incr targetrow\n            }\n        }\n    }\n}\n\nproc insertfakerow {id p} {\n    global varcid varccommits parents children cmitlisted\n    global commitidx varctok vtokmod targetid targetrow curview numcommits\n\n    set v $curview\n    set a $varcid($v,$p)\n    set i [lsearch -exact $varccommits($v,$a) $p]\n    if {$i < 0} {\n        puts \"oops: insertfakerow can't find [shortids $p] on arc $a\"\n        return\n    }\n    set children($v,$id) {}\n    set parents($v,$id) [list $p]\n    set varcid($v,$id) $a\n    lappend children($v,$p) $id\n    set cmitlisted($v,$id) 1\n    set numcommits [incr commitidx($v)]\n    # note we deliberately don't update varcstart($v) even if $i == 0\n    set varccommits($v,$a) [linsert $varccommits($v,$a) $i $id]\n    modify_arc $v $a $i\n    if {[info exists targetid]} {\n        if {![comes_before $targetid $p]} {\n            incr targetrow\n        }\n    }\n    setcanvscroll\n    drawvisible\n}\n\nproc removefakerow {id} {\n    global varcid varccommits parents children commitidx\n    global varctok vtokmod cmitlisted currentid selectedline\n    global targetid curview numcommits\n\n    set v $curview\n    if {[llength $parents($v,$id)] != 1} {\n        puts \"oops: removefakerow [shortids $id] has [llength $parents($v,$id)] parents\"\n        return\n    }\n    set p [lindex $parents($v,$id) 0]\n    set a $varcid($v,$id)\n    set i [lsearch -exact $varccommits($v,$a) $id]\n    if {$i < 0} {\n        puts \"oops: removefakerow can't find [shortids $id] on arc $a\"\n        return\n    }\n    unset varcid($v,$id)\n    set varccommits($v,$a) [lreplace $varccommits($v,$a) $i $i]\n    unset parents($v,$id)\n    unset children($v,$id)\n    unset cmitlisted($v,$id)\n    set numcommits [incr commitidx($v) -1]\n    set j [lsearch -exact $children($v,$p) $id]\n    if {$j >= 0} {\n        set children($v,$p) [lreplace $children($v,$p) $j $j]\n    }\n    modify_arc $v $a $i\n    if {[info exist currentid] && $id eq $currentid} {\n        unset currentid\n        set selectedline {}\n    }\n    if {[info exists targetid] && $targetid eq $id} {\n        set targetid $p\n    }\n    setcanvscroll\n    drawvisible\n}\n\nproc real_children {vp} {\n    global children nullid nullid2\n\n    set kids {}\n    foreach id $children($vp) {\n        if {$id ne $nullid && $id ne $nullid2} {\n            lappend kids $id\n        }\n    }\n    return $kids\n}\n\nproc first_real_child {vp} {\n    global children nullid nullid2\n\n    foreach id $children($vp) {\n        if {$id ne $nullid && $id ne $nullid2} {\n            return $id\n        }\n    }\n    return {}\n}\n\nproc last_real_child {vp} {\n    global children nullid nullid2\n\n    set kids $children($vp)\n    for {set i [llength $kids]} {[incr i -1] >= 0} {} {\n        set id [lindex $kids $i]\n        if {$id ne $nullid && $id ne $nullid2} {\n            return $id\n        }\n    }\n    return {}\n}\n\nproc vtokcmp {v a b} {\n    global varctok varcid\n\n    return [string compare [lindex $varctok($v) $varcid($v,$a)] \\\n                [lindex $varctok($v) $varcid($v,$b)]]\n}\n\n# This assumes that if lim is not given, the caller has checked that\n# arc a's token is less than $vtokmod($v)\nproc modify_arc {v a {lim {}}} {\n    global varctok vtokmod varcmod varcrow vupptr curview vrowmod varccommits\n\n    if {$lim ne {}} {\n        set c [string compare [lindex $varctok($v) $a] $vtokmod($v)]\n        if {$c > 0} return\n        if {$c == 0} {\n            set r [lindex $varcrow($v) $a]\n            if {$r ne {} && $vrowmod($v) <= $r + $lim} return\n        }\n    }\n    set vtokmod($v) [lindex $varctok($v) $a]\n    set varcmod($v) $a\n    if {$v == $curview} {\n        while {$a != 0 && [lindex $varcrow($v) $a] eq {}} {\n            set a [lindex $vupptr($v) $a]\n            set lim {}\n        }\n        set r 0\n        if {$a != 0} {\n            if {$lim eq {}} {\n                set lim [llength $varccommits($v,$a)]\n            }\n            set r [expr {[lindex $varcrow($v) $a] + $lim}]\n        }\n        set vrowmod($v) $r\n        undolayout $r\n    }\n}\n\nproc update_arcrows {v} {\n    global vtokmod varcmod vrowmod varcrow commitidx currentid selectedline\n    global varcid vrownum varcorder varcix varccommits\n    global vupptr vdownptr vleftptr varctok\n    global displayorder parentlist curview cached_commitrow\n\n    if {$vrowmod($v) == $commitidx($v)} return\n    if {$v == $curview} {\n        if {[llength $displayorder] > $vrowmod($v)} {\n            set displayorder [lrange $displayorder 0 [expr {$vrowmod($v) - 1}]]\n            set parentlist [lrange $parentlist 0 [expr {$vrowmod($v) - 1}]]\n        }\n        unset -nocomplain cached_commitrow\n    }\n    set narctot [expr {[llength $varctok($v)] - 1}]\n    set a $varcmod($v)\n    while {$a != 0 && [lindex $varcix($v) $a] eq {}} {\n        # go up the tree until we find something that has a row number,\n        # or we get to a seed\n        set a [lindex $vupptr($v) $a]\n    }\n    if {$a == 0} {\n        set a [lindex $vdownptr($v) 0]\n        if {$a == 0} return\n        set vrownum($v) {0}\n        set varcorder($v) [list $a]\n        lset varcix($v) $a 0\n        lset varcrow($v) $a 0\n        set arcn 0\n        set row 0\n    } else {\n        set arcn [lindex $varcix($v) $a]\n        if {[llength $vrownum($v)] > $arcn + 1} {\n            set vrownum($v) [lrange $vrownum($v) 0 $arcn]\n            set varcorder($v) [lrange $varcorder($v) 0 $arcn]\n        }\n        set row [lindex $varcrow($v) $a]\n    }\n    while {1} {\n        set p $a\n        incr row [llength $varccommits($v,$a)]\n        # go down if possible\n        set b [lindex $vdownptr($v) $a]\n        if {$b == 0} {\n            # if not, go left, or go up until we can go left\n            while {$a != 0} {\n                set b [lindex $vleftptr($v) $a]\n                if {$b != 0} break\n                set a [lindex $vupptr($v) $a]\n            }\n            if {$a == 0} break\n        }\n        set a $b\n        incr arcn\n        lappend vrownum($v) $row\n        lappend varcorder($v) $a\n        lset varcix($v) $a $arcn\n        lset varcrow($v) $a $row\n    }\n    set vtokmod($v) [lindex $varctok($v) $p]\n    set varcmod($v) $p\n    set vrowmod($v) $row\n    if {[info exists currentid]} {\n        set selectedline [rowofcommit $currentid]\n    }\n}\n\n# Test whether view $v contains commit $id\nproc commitinview {id v} {\n    global varcid\n\n    return [info exists varcid($v,$id)]\n}\n\n# Return the row number for commit $id in the current view\nproc rowofcommit {id} {\n    global varcid varccommits varcrow curview cached_commitrow\n    global varctok vtokmod\n\n    set v $curview\n    if {![info exists varcid($v,$id)]} {\n        puts \"oops rowofcommit no arc for [shortids $id]\"\n        return {}\n    }\n    set a $varcid($v,$id)\n    if {[string compare [lindex $varctok($v) $a] $vtokmod($v)] >= 0} {\n        update_arcrows $v\n    }\n    if {[info exists cached_commitrow($id)]} {\n        return $cached_commitrow($id)\n    }\n    set i [lsearch -exact $varccommits($v,$a) $id]\n    if {$i < 0} {\n        puts \"oops didn't find commit [shortids $id] in arc $a\"\n        return {}\n    }\n    incr i [lindex $varcrow($v) $a]\n    set cached_commitrow($id) $i\n    return $i\n}\n\n# Returns 1 if a is on an earlier row than b, otherwise 0\nproc comes_before {a b} {\n    global varcid varctok curview\n\n    set v $curview\n    if {$a eq $b || ![info exists varcid($v,$a)] || \\\n            ![info exists varcid($v,$b)]} {\n        return 0\n    }\n    if {$varcid($v,$a) != $varcid($v,$b)} {\n        return [expr {[string compare [lindex $varctok($v) $varcid($v,$a)] \\\n                           [lindex $varctok($v) $varcid($v,$b)]] < 0}]\n    }\n    return [expr {[rowofcommit $a] < [rowofcommit $b]}]\n}\n\nproc bsearch {l elt} {\n    if {[llength $l] == 0 || $elt <= [lindex $l 0]} {\n        return 0\n    }\n    set lo 0\n    set hi [llength $l]\n    while {$hi - $lo > 1} {\n        set mid [expr {int(($lo + $hi) / 2)}]\n        set t [lindex $l $mid]\n        if {$elt < $t} {\n            set hi $mid\n        } elseif {$elt > $t} {\n            set lo $mid\n        } else {\n            return $mid\n        }\n    }\n    return $lo\n}\n\n# Make sure rows $start..$end-1 are valid in displayorder and parentlist\nproc make_disporder {start end} {\n    global vrownum curview commitidx displayorder parentlist\n    global varccommits varcorder parents vrowmod varcrow\n    global d_valid_start d_valid_end\n\n    if {$end > $vrowmod($curview)} {\n        update_arcrows $curview\n    }\n    set ai [bsearch $vrownum($curview) $start]\n    set start [lindex $vrownum($curview) $ai]\n    set narc [llength $vrownum($curview)]\n    for {set r $start} {$ai < $narc && $r < $end} {incr ai} {\n        set a [lindex $varcorder($curview) $ai]\n        set l [llength $displayorder]\n        set al [llength $varccommits($curview,$a)]\n        if {$l < $r + $al} {\n            if {$l < $r} {\n                set pad [ntimes [expr {$r - $l}] {}]\n                set displayorder [concat $displayorder $pad]\n                set parentlist [concat $parentlist $pad]\n            } elseif {$l > $r} {\n                set displayorder [lrange $displayorder 0 [expr {$r - 1}]]\n                set parentlist [lrange $parentlist 0 [expr {$r - 1}]]\n            }\n            foreach id $varccommits($curview,$a) {\n                lappend displayorder $id\n                lappend parentlist $parents($curview,$id)\n            }\n        } elseif {[lindex $displayorder [expr {$r + $al - 1}]] eq {}} {\n            set i $r\n            foreach id $varccommits($curview,$a) {\n                lset displayorder $i $id\n                lset parentlist $i $parents($curview,$id)\n                incr i\n            }\n        }\n        incr r $al\n    }\n}\n\nproc commitonrow {row} {\n    global displayorder\n\n    set id [lindex $displayorder $row]\n    if {$id eq {}} {\n        make_disporder $row [expr {$row + 1}]\n        set id [lindex $displayorder $row]\n    }\n    return $id\n}\n\nproc closevarcs {v} {\n    global varctok varccommits varcid parents children\n    global cmitlisted commitidx vtokmod curview numcommits\n\n    set missing_parents 0\n    set scripts {}\n    set narcs [llength $varctok($v)]\n    for {set a 1} {$a < $narcs} {incr a} {\n        set id [lindex $varccommits($v,$a) end]\n        foreach p $parents($v,$id) {\n            if {[info exists varcid($v,$p)]} continue\n            # add p as a new commit\n            incr missing_parents\n            set cmitlisted($v,$p) 0\n            set parents($v,$p) {}\n            if {[llength $children($v,$p)] == 1 &&\n                [llength $parents($v,$id)] == 1} {\n                set b $a\n            } else {\n                set b [newvarc $v $p]\n            }\n            set varcid($v,$p) $b\n            if {[string compare [lindex $varctok($v) $b] $vtokmod($v)] < 0} {\n                modify_arc $v $b\n            }\n            lappend varccommits($v,$b) $p\n            incr commitidx($v)\n            if {$v == $curview} {\n                set numcommits $commitidx($v)\n            }\n            set scripts [check_interest $p $scripts]\n        }\n    }\n    if {$missing_parents > 0} {\n        foreach s $scripts {\n            eval $s\n        }\n    }\n}\n\n# Use $rwid as a substitute for $id, i.e. reparent $id's children to $rwid\n# Assumes we already have an arc for $rwid.\nproc rewrite_commit {v id rwid} {\n    global children parents varcid varctok vtokmod varccommits\n\n    foreach ch $children($v,$id) {\n        # make $rwid be $ch's parent in place of $id\n        set i [lsearch -exact $parents($v,$ch) $id]\n        if {$i < 0} {\n            puts \"oops rewrite_commit didn't find $id in parent list for $ch\"\n        }\n        set parents($v,$ch) [lreplace $parents($v,$ch) $i $i $rwid]\n        # add $ch to $rwid's children and sort the list if necessary\n        if {[llength [lappend children($v,$rwid) $ch]] > 1} {\n            set children($v,$rwid) [lsort -command [list vtokcmp $v] \\\n                                        $children($v,$rwid)]\n        }\n        # fix the graph after joining $id to $rwid\n        set a $varcid($v,$ch)\n        fix_reversal $rwid $a $v\n        # parentlist is wrong for the last element of arc $a\n        # even if displayorder is right, hence the 3rd arg here\n        modify_arc $v $a [expr {[llength $varccommits($v,$a)] - 1}]\n    }\n}\n\n# Mechanism for registering a command to be executed when we come\n# across a particular commit.  To handle the case when only the\n# prefix of the commit is known, the commitinterest array is now\n# indexed by the first 4 characters of the ID.  Each element is a\n# list of id, cmd pairs.\nproc interestedin {id cmd} {\n    global commitinterest\n\n    lappend commitinterest([string range $id 0 3]) $id $cmd\n}\n\nproc check_interest {id scripts} {\n    global commitinterest\n\n    set prefix [string range $id 0 3]\n    if {[info exists commitinterest($prefix)]} {\n        set newlist {}\n        foreach {i script} $commitinterest($prefix) {\n            if {[string match \"$i*\" $id]} {\n                lappend scripts [string map [list \"%I\" $id \"%P\" $i] $script]\n            } else {\n                lappend newlist $i $script\n            }\n        }\n        if {$newlist ne {}} {\n            set commitinterest($prefix) $newlist\n        } else {\n            unset commitinterest($prefix)\n        }\n    }\n    return $scripts\n}\n\nproc getcommitlines {fd inst view updating}  {\n    global cmitlisted leftover\n    global commitidx commitdata vdatemode\n    global parents children curview hlview\n    global idpending ordertok\n    global varccommits varcid varctok vtokmod vfilelimit vshortids\n\n    set stuff [read $fd 500000]\n    # git log doesn't terminate the last commit with a null...\n    if {$stuff == {} && $leftover($inst) ne {} && [eof $fd]} {\n        set stuff \"\\0\"\n    }\n    if {$stuff == {}} {\n        if {![eof $fd]} {\n            return 1\n        }\n        global commfd viewcomplete viewactive viewname\n        global viewinstances\n        unset commfd($inst)\n        set i [lsearch -exact $viewinstances($view) $inst]\n        if {$i >= 0} {\n            set viewinstances($view) [lreplace $viewinstances($view) $i $i]\n        }\n        # set it blocking so we wait for the process to terminate\n        fconfigure $fd -blocking 1\n        if {[catch {close $fd} err]} {\n            set fv {}\n            if {$view != $curview} {\n                set fv \" for the \\\"$viewname($view)\\\" view\"\n            }\n            if {[string range $err 0 4] == \"usage\"} {\n                set err \"Gitk: error reading commits$fv:\\\n                        bad arguments to git log.\"\n                if {$viewname($view) eq [mc \"Command line\"]} {\n                    append err \\\n                        \"  (Note: arguments to gitk are passed to git log\\\n                         to allow selection of commits to be displayed.)\"\n                }\n            } else {\n                set err \"Error reading commits$fv: $err\"\n            }\n            error_popup $err\n        }\n        if {[incr viewactive($view) -1] <= 0} {\n            set viewcomplete($view) 1\n            # Check if we have seen any ids listed as parents that haven't\n            # appeared in the list\n            closevarcs $view\n            notbusy $view\n        }\n        if {$view == $curview} {\n            run chewcommits\n        }\n        return 0\n    }\n    set start 0\n    set gotsome 0\n    set scripts {}\n    while 1 {\n        set i [string first \"\\0\" $stuff $start]\n        if {$i < 0} {\n            append leftover($inst) [string range $stuff $start end]\n            break\n        }\n        if {$start == 0} {\n            set cmit $leftover($inst)\n            append cmit [string range $stuff 0 [expr {$i - 1}]]\n            set leftover($inst) {}\n        } else {\n            set cmit [string range $stuff $start [expr {$i - 1}]]\n        }\n        set start [expr {$i + 1}]\n        set j [string first \"\\n\" $cmit]\n        set ok 0\n        set listed 1\n        if {$j >= 0 && [string match \"commit *\" $cmit]} {\n            set ids [string range $cmit 7 [expr {$j - 1}]]\n            if {[string match {[-^<>]*} $ids]} {\n                switch -- [string index $ids 0] {\n                    \"-\" {set listed 0}\n                    \"^\" {set listed 2}\n                    \"<\" {set listed 3}\n                    \">\" {set listed 4}\n                }\n                set ids [string range $ids 1 end]\n            }\n            set ok 1\n            foreach id $ids {\n                if {[string length $id] != 40} {\n                    set ok 0\n                    break\n                }\n            }\n        }\n        if {!$ok} {\n            set shortcmit $cmit\n            if {[string length $shortcmit] > 80} {\n                set shortcmit \"[string range $shortcmit 0 80]...\"\n            }\n            error_popup \"[mc \"Can't parse git log output:\"] {$shortcmit}\"\n            exit 1\n        }\n        set id [lindex $ids 0]\n        set vid $view,$id\n\n        lappend vshortids($view,[string range $id 0 3]) $id\n\n        if {!$listed && $updating && ![info exists varcid($vid)] &&\n            $vfilelimit($view) ne {}} {\n            # git log doesn't rewrite parents for unlisted commits\n            # when doing path limiting, so work around that here\n            # by working out the rewritten parent with git rev-list\n            # and if we already know about it, using the rewritten\n            # parent as a substitute parent for $id's children.\n            if {![catch {\n                set rwid [exec git rev-list --first-parent --max-count=1 \\\n                              $id -- $vfilelimit($view)]\n            }]} {\n                if {$rwid ne {} && [info exists varcid($view,$rwid)]} {\n                    # use $rwid in place of $id\n                    rewrite_commit $view $id $rwid\n                    continue\n                }\n            }\n        }\n\n        set a 0\n        if {[info exists varcid($vid)]} {\n            if {$cmitlisted($vid) || !$listed} continue\n            set a $varcid($vid)\n        }\n        if {$listed} {\n            set olds [lrange $ids 1 end]\n        } else {\n            set olds {}\n        }\n        set commitdata($id) [string range $cmit [expr {$j + 1}] end]\n        set cmitlisted($vid) $listed\n        set parents($vid) $olds\n        if {![info exists children($vid)]} {\n            set children($vid) {}\n        } elseif {$a == 0 && [llength $children($vid)] == 1} {\n            set k [lindex $children($vid) 0]\n            if {[llength $parents($view,$k)] == 1 &&\n                (!$vdatemode($view) ||\n                 $varcid($view,$k) == [llength $varctok($view)] - 1)} {\n                set a $varcid($view,$k)\n            }\n        }\n        if {$a == 0} {\n            # new arc\n            set a [newvarc $view $id]\n        }\n        if {[string compare [lindex $varctok($view) $a] $vtokmod($view)] < 0} {\n            modify_arc $view $a\n        }\n        if {![info exists varcid($vid)]} {\n            set varcid($vid) $a\n            lappend varccommits($view,$a) $id\n            incr commitidx($view)\n        }\n\n        set i 0\n        foreach p $olds {\n            if {$i == 0 || [lsearch -exact $olds $p] >= $i} {\n                set vp $view,$p\n                if {[llength [lappend children($vp) $id]] > 1 &&\n                    [vtokcmp $view [lindex $children($vp) end-1] $id] > 0} {\n                    set children($vp) [lsort -command [list vtokcmp $view] \\\n                                           $children($vp)]\n                    unset -nocomplain ordertok\n                }\n                if {[info exists varcid($view,$p)]} {\n                    fix_reversal $p $a $view\n                }\n            }\n            incr i\n        }\n\n        set scripts [check_interest $id $scripts]\n        set gotsome 1\n    }\n    if {$gotsome} {\n        global numcommits hlview\n\n        if {$view == $curview} {\n            set numcommits $commitidx($view)\n            run chewcommits\n        }\n        if {[info exists hlview] && $view == $hlview} {\n            # we never actually get here...\n            run vhighlightmore\n        }\n        foreach s $scripts {\n            eval $s\n        }\n    }\n    return 2\n}\n\nproc chewcommits {} {\n    global curview hlview viewcomplete\n    global pending_select\n\n    layoutmore\n    if {$viewcomplete($curview)} {\n        global commitidx varctok\n        global numcommits startmsecs\n\n        if {[info exists pending_select]} {\n            update\n            reset_pending_select {}\n\n            if {[commitinview $pending_select $curview]} {\n                selectline [rowofcommit $pending_select] 1\n            } else {\n                set row [first_real_row]\n                selectline $row 1\n            }\n        }\n        if {$commitidx($curview) > 0} {\n            #set ms [expr {[clock clicks -milliseconds] - $startmsecs}]\n            #puts \"overall $ms ms for $numcommits commits\"\n            #puts \"[llength $varctok($view)] arcs, $commitidx($view) commits\"\n        } else {\n            show_status [mc \"No commits selected\"]\n        }\n        notbusy layout\n    }\n    return 0\n}\n\nproc do_readcommit {id} {\n    global tclencoding\n\n    # Invoke git-log to handle automatic encoding conversion\n    set fd [open [concat | git log --no-color --pretty=raw -1 $id] r]\n    # Read the results using i18n.logoutputencoding\n    fconfigure $fd -translation lf -eofchar {}\n    if {$tclencoding != {}} {\n        fconfigure $fd -encoding $tclencoding\n    }\n    set contents [read $fd]\n    close $fd\n    # Remove the heading line\n    regsub {^commit [0-9a-f]+\\n} $contents {} contents\n\n    return $contents\n}\n\nproc readcommit {id} {\n    if {[catch {set contents [do_readcommit $id]}]} return\n    parsecommit $id $contents 1\n}\n\nproc parsecommit {id contents listed} {\n    global commitinfo\n\n    set inhdr 1\n    set comment {}\n    set headline {}\n    set auname {}\n    set audate {}\n    set comname {}\n    set comdate {}\n    set hdrend [string first \"\\n\\n\" $contents]\n    if {$hdrend < 0} {\n        # should never happen...\n        set hdrend [string length $contents]\n    }\n    set header [string range $contents 0 [expr {$hdrend - 1}]]\n    set comment [string range $contents [expr {$hdrend + 2}] end]\n    foreach line [split $header \"\\n\"] {\n        set line [split $line \" \"]\n        set tag [lindex $line 0]\n        if {$tag == \"author\"} {\n            set audate [lrange $line end-1 end]\n            set auname [join [lrange $line 1 end-2] \" \"]\n        } elseif {$tag == \"committer\"} {\n            set comdate [lrange $line end-1 end]\n            set comname [join [lrange $line 1 end-2] \" \"]\n        }\n    }\n    set headline {}\n    # take the first non-blank line of the comment as the headline\n    set headline [string trimleft $comment]\n    set i [string first \"\\n\" $headline]\n    if {$i >= 0} {\n        set headline [string range $headline 0 $i]\n    }\n    set headline [string trimright $headline]\n    set i [string first \"\\r\" $headline]\n    if {$i >= 0} {\n        set headline [string trimright [string range $headline 0 $i]]\n    }\n    if {!$listed} {\n        # git log indents the comment by 4 spaces;\n        # if we got this via git cat-file, add the indentation\n        set newcomment {}\n        foreach line [split $comment \"\\n\"] {\n            append newcomment \"    \"\n            append newcomment $line\n            append newcomment \"\\n\"\n        }\n        set comment $newcomment\n    }\n    set hasnote [string first \"\\nNotes:\\n\" $contents]\n    set diff \"\"\n    # If there is diff output shown in the git-log stream, split it\n    # out.  But get rid of the empty line that always precedes the\n    # diff.\n    set i [string first \"\\n\\ndiff\" $comment]\n    if {$i >= 0} {\n        set diff [string range $comment $i+1 end]\n        set comment [string range $comment 0 $i-1]\n    }\n    set commitinfo($id) [list $headline $auname $audate \\\n                             $comname $comdate $comment $hasnote $diff]\n}\n\nproc getcommit {id} {\n    global commitdata commitinfo\n\n    if {[info exists commitdata($id)]} {\n        parsecommit $id $commitdata($id) 1\n    } else {\n        readcommit $id\n        if {![info exists commitinfo($id)]} {\n            set commitinfo($id) [list [mc \"No commit information available\"]]\n        }\n    }\n    return 1\n}\n\n# Expand an abbreviated commit ID to a list of full 40-char IDs that match\n# and are present in the current view.\n# This is fairly slow...\nproc longid {prefix} {\n    global varcid curview vshortids\n\n    set ids {}\n    if {[string length $prefix] >= 4} {\n        set vshortid $curview,[string range $prefix 0 3]\n        if {[info exists vshortids($vshortid)]} {\n            foreach id $vshortids($vshortid) {\n                if {[string match \"$prefix*\" $id]} {\n                    if {[lsearch -exact $ids $id] < 0} {\n                        lappend ids $id\n                        if {[llength $ids] >= 2} break\n                    }\n                }\n            }\n        }\n    } else {\n        foreach match [array names varcid \"$curview,$prefix*\"] {\n            lappend ids [lindex [split $match \",\"] 1]\n            if {[llength $ids] >= 2} break\n        }\n    }\n    return $ids\n}\n\nproc readrefs {} {\n    global tagids idtags headids idheads tagobjid\n    global otherrefids idotherrefs mainhead mainheadid\n    global selecthead selectheadid\n    global hideremotes\n    global tclencoding\n\n    foreach v {tagids idtags headids idheads otherrefids idotherrefs} {\n        unset -nocomplain $v\n    }\n    set refd [open [list | git show-ref -d] r]\n    if {$tclencoding != {}} {\n        fconfigure $refd -encoding $tclencoding\n    }\n    while {[gets $refd line] >= 0} {\n        if {[string index $line 40] ne \" \"} continue\n        set id [string range $line 0 39]\n        set ref [string range $line 41 end]\n        if {![string match \"refs/*\" $ref]} continue\n        set name [string range $ref 5 end]\n        if {[string match \"remotes/*\" $name]} {\n            if {![string match \"*/HEAD\" $name] && !$hideremotes} {\n                set headids($name) $id\n                lappend idheads($id) $name\n            }\n        } elseif {[string match \"heads/*\" $name]} {\n            set name [string range $name 6 end]\n            set headids($name) $id\n            lappend idheads($id) $name\n        } elseif {[string match \"tags/*\" $name]} {\n            # this lets refs/tags/foo^{} overwrite refs/tags/foo,\n            # which is what we want since the former is the commit ID\n            set name [string range $name 5 end]\n            if {[string match \"*^{}\" $name]} {\n                set name [string range $name 0 end-3]\n            } else {\n                set tagobjid($name) $id\n            }\n            set tagids($name) $id\n            lappend idtags($id) $name\n        } else {\n            set otherrefids($name) $id\n            lappend idotherrefs($id) $name\n        }\n    }\n    catch {close $refd}\n    set mainhead {}\n    set mainheadid {}\n    catch {\n        set mainheadid [exec git rev-parse HEAD]\n        set thehead [exec git symbolic-ref HEAD]\n        if {[string match \"refs/heads/*\" $thehead]} {\n            set mainhead [string range $thehead 11 end]\n        }\n    }\n    set selectheadid {}\n    if {$selecthead ne {}} {\n        catch {\n            set selectheadid [exec git rev-parse --verify $selecthead]\n        }\n    }\n}\n\n# skip over fake commits\nproc first_real_row {} {\n    global nullid nullid2 numcommits\n\n    for {set row 0} {$row < $numcommits} {incr row} {\n        set id [commitonrow $row]\n        if {$id ne $nullid && $id ne $nullid2} {\n            break\n        }\n    }\n    return $row\n}\n\n# update things for a head moved to a child of its previous location\nproc movehead {id name} {\n    global headids idheads\n\n    removehead $headids($name) $name\n    set headids($name) $id\n    lappend idheads($id) $name\n}\n\n# update things when a head has been removed\nproc removehead {id name} {\n    global headids idheads\n\n    if {$idheads($id) eq $name} {\n        unset idheads($id)\n    } else {\n        set i [lsearch -exact $idheads($id) $name]\n        if {$i >= 0} {\n            set idheads($id) [lreplace $idheads($id) $i $i]\n        }\n    }\n    unset headids($name)\n}\n\nproc ttk_toplevel {w args} {\n    global use_ttk\n    eval [linsert $args 0 ::toplevel $w]\n    if {$use_ttk} {\n        place [ttk::frame $w._toplevel_background] -x 0 -y 0 -relwidth 1 -relheight 1\n    }\n    return $w\n}\n\nproc make_transient {window origin} {\n    global have_tk85\n\n    # In MacOS Tk 8.4 transient appears to work by setting\n    # overrideredirect, which is utterly useless, since the\n    # windows get no border, and are not even kept above\n    # the parent.\n    if {!$have_tk85 && [tk windowingsystem] eq {aqua}} return\n\n    wm transient $window $origin\n\n    # Windows fails to place transient windows normally, so\n    # schedule a callback to center them on the parent.\n    if {[tk windowingsystem] eq {win32}} {\n        after idle [list tk::PlaceWindow $window widget $origin]\n    }\n}\n\nproc show_error {w top msg} {\n    global NS\n    if {![info exists NS]} {set NS \"\"}\n    if {[wm state $top] eq \"withdrawn\"} { wm deiconify $top }\n    message $w.m -text $msg -justify center -aspect 400\n    pack $w.m -side top -fill x -padx 20 -pady 20\n    ${NS}::button $w.ok -default active -text [mc OK] -command \"destroy $top\"\n    pack $w.ok -side bottom -fill x\n    bind $top <Visibility> \"grab $top; focus $top\"\n    bind $top <Key-Return> \"destroy $top\"\n    bind $top <Key-space>  \"destroy $top\"\n    bind $top <Key-Escape> \"destroy $top\"\n    tkwait window $top\n}\n\nproc error_popup {msg {owner .}} {\n    if {[tk windowingsystem] eq \"win32\"} {\n        tk_messageBox -icon error -type ok -title [wm title .] \\\n            -parent $owner -message $msg\n    } else {\n        set w .error\n        ttk_toplevel $w\n        make_transient $w $owner\n        show_error $w $w $msg\n    }\n}\n\nproc confirm_popup {msg {owner .}} {\n    global confirm_ok NS\n    set confirm_ok 0\n    set w .confirm\n    ttk_toplevel $w\n    make_transient $w $owner\n    message $w.m -text $msg -justify center -aspect 400\n    pack $w.m -side top -fill x -padx 20 -pady 20\n    ${NS}::button $w.ok -text [mc OK] -command \"set confirm_ok 1; destroy $w\"\n    pack $w.ok -side left -fill x\n    ${NS}::button $w.cancel -text [mc Cancel] -command \"destroy $w\"\n    pack $w.cancel -side right -fill x\n    bind $w <Visibility> \"grab $w; focus $w\"\n    bind $w <Key-Return> \"set confirm_ok 1; destroy $w\"\n    bind $w <Key-space>  \"set confirm_ok 1; destroy $w\"\n    bind $w <Key-Escape> \"destroy $w\"\n    tk::PlaceWindow $w widget $owner\n    tkwait window $w\n    return $confirm_ok\n}\n\nproc setoptions {} {\n    global use_ttk\n\n    if {[tk windowingsystem] ne \"win32\"} {\n        option add *Panedwindow.showHandle 1 startupFile\n        option add *Panedwindow.sashRelief raised startupFile\n        if {[tk windowingsystem] ne \"aqua\"} {\n            option add *Menu.font uifont startupFile\n        }\n    } else {\n        option add *Menu.TearOff 0 startupFile\n    }\n    option add *Button.font uifont startupFile\n    option add *Checkbutton.font uifont startupFile\n    option add *Radiobutton.font uifont startupFile\n    option add *Menubutton.font uifont startupFile\n    option add *Label.font uifont startupFile\n    option add *Message.font uifont startupFile\n    option add *Entry.font textfont startupFile\n    option add *Text.font textfont startupFile\n    option add *Labelframe.font uifont startupFile\n    option add *Spinbox.font textfont startupFile\n    option add *Listbox.font mainfont startupFile\n}\n\nproc setttkstyle {} {\n    eval font configure TkDefaultFont [fontflags mainfont]\n    eval font configure TkTextFont [fontflags textfont]\n    eval font configure TkHeadingFont [fontflags mainfont]\n    eval font configure TkCaptionFont [fontflags mainfont] -weight bold\n    eval font configure TkTooltipFont [fontflags uifont]\n    eval font configure TkFixedFont   [fontflags textfont]\n    eval font configure TkIconFont    [fontflags uifont]\n    eval font configure TkMenuFont    [fontflags uifont]\n    eval font configure TkSmallCaptionFont [fontflags uifont]\n}\n\n# Make a menu and submenus.\n# m is the window name for the menu, items is the list of menu items to add.\n# Each item is a list {mc label type description options...}\n# mc is ignored; it's so we can put mc there to alert xgettext\n# label is the string that appears in the menu\n# type is cascade, command or radiobutton (should add checkbutton)\n# description depends on type; it's the sublist for cascade, the\n# command to invoke for command, or {variable value} for radiobutton\nproc makemenu {m items} {\n    menu $m\n    if {[tk windowingsystem] eq {aqua}} {\n        set Meta1 Cmd\n    } else {\n        set Meta1 Ctrl\n    }\n    foreach i $items {\n        set name [mc [lindex $i 1]]\n        set type [lindex $i 2]\n        set thing [lindex $i 3]\n        set params [list $type]\n        if {$name ne {}} {\n            set u [string first \"&\" [string map {&& x} $name]]\n            lappend params -label [string map {&& & & {}} $name]\n            if {$u >= 0} {\n                lappend params -underline $u\n            }\n        }\n        switch -- $type {\n            \"cascade\" {\n                set submenu [string tolower [string map {& \"\"} [lindex $i 1]]]\n                lappend params -menu $m.$submenu\n            }\n            \"command\" {\n                lappend params -command $thing\n            }\n            \"radiobutton\" {\n                lappend params -variable [lindex $thing 0] \\\n                    -value [lindex $thing 1]\n            }\n        }\n        set tail [lrange $i 4 end]\n        regsub -all {\\yMeta1\\y} $tail $Meta1 tail\n        eval $m add $params $tail\n        if {$type eq \"cascade\"} {\n            makemenu $m.$submenu $thing\n        }\n    }\n}\n\n# translate string and remove ampersands\nproc mca {str} {\n    return [string map {&& & & {}} [mc $str]]\n}\n\nproc cleardropsel {w} {\n    $w selection clear\n}\nproc makedroplist {w varname args} {\n    global use_ttk\n    if {$use_ttk} {\n        set width 0\n        foreach label $args {\n            set cx [string length $label]\n            if {$cx > $width} {set width $cx}\n        }\n        set gm [ttk::combobox $w -width $width -state readonly\\\n                    -textvariable $varname -values $args \\\n                    -exportselection false]\n        bind $gm <<ComboboxSelected>> [list $gm selection clear]\n    } else {\n        set gm [eval [linsert $args 0 tk_optionMenu $w $varname]]\n    }\n    return $gm\n}\n\nproc makewindow {} {\n    global canv canv2 canv3 linespc charspc ctext cflist cscroll\n    global tabstop\n    global findtype findtypemenu findloc findstring fstring geometry\n    global entries sha1entry sha1string sha1but\n    global diffcontextstring diffcontext\n    global ignorespace\n    global maincursor textcursor curtextcursor\n    global rowctxmenu fakerowmenu mergemax wrapcomment\n    global highlight_files gdttype\n    global searchstring sstring\n    global bgcolor fgcolor bglist fglist diffcolors diffbgcolors selectbgcolor\n    global uifgcolor uifgdisabledcolor\n    global filesepbgcolor filesepfgcolor\n    global mergecolors foundbgcolor currentsearchhitbgcolor\n    global headctxmenu progresscanv progressitem progresscoords statusw\n    global fprogitem fprogcoord lastprogupdate progupdatepending\n    global rprogitem rprogcoord rownumsel numcommits\n    global have_tk85 have_tk86 use_ttk NS\n    global git_version\n    global worddiff\n\n    # The \"mc\" arguments here are purely so that xgettext\n    # sees the following string as needing to be translated\n    set file {\n        mc \"&File\" cascade {\n            {mc \"&Update\" command updatecommits -accelerator F5}\n            {mc \"&Reload\" command reloadcommits -accelerator Shift-F5}\n            {mc \"Reread re&ferences\" command rereadrefs}\n            {mc \"&List references\" command showrefs -accelerator F2}\n            {xx \"\" separator}\n            {mc \"Start git &gui\" command {exec git gui &}}\n            {xx \"\" separator}\n            {mc \"&Quit\" command doquit -accelerator Meta1-Q}\n        }}\n    set edit {\n        mc \"&Edit\" cascade {\n            {mc \"&Preferences\" command doprefs}\n        }}\n    set view {\n        mc \"&View\" cascade {\n            {mc \"&New view...\" command {newview 0} -accelerator Shift-F4}\n            {mc \"&Edit view...\" command editview -state disabled -accelerator F4}\n            {mc \"&Delete view\" command delview -state disabled}\n            {xx \"\" separator}\n            {mc \"&All files\" radiobutton {selectedview 0} -command {showview 0}}\n        }}\n    if {[tk windowingsystem] ne \"aqua\"} {\n        set help {\n        mc \"&Help\" cascade {\n            {mc \"&About gitk\" command about}\n            {mc \"&Key bindings\" command keys}\n        }}\n        set bar [list $file $edit $view $help]\n    } else {\n        proc ::tk::mac::ShowPreferences {} {doprefs}\n        proc ::tk::mac::Quit {} {doquit}\n        lset file end [lreplace [lindex $file end] end-1 end]\n        set apple {\n        xx \"&Apple\" cascade {\n            {mc \"&About gitk\" command about}\n            {xx \"\" separator}\n        }}\n        set help {\n        mc \"&Help\" cascade {\n            {mc \"&Key bindings\" command keys}\n        }}\n        set bar [list $apple $file $view $help]\n    }\n    makemenu .bar $bar\n    . configure -menu .bar\n\n    if {$use_ttk} {\n        # cover the non-themed toplevel with a themed frame.\n        place [ttk::frame ._main_background] -x 0 -y 0 -relwidth 1 -relheight 1\n    }\n\n    # the gui has upper and lower half, parts of a paned window.\n    ${NS}::panedwindow .ctop -orient vertical\n\n    # possibly use assumed geometry\n    if {![info exists geometry(pwsash0)]} {\n        set geometry(topheight) [expr {15 * $linespc}]\n        set geometry(topwidth) [expr {80 * $charspc}]\n        set geometry(botheight) [expr {15 * $linespc}]\n        set geometry(botwidth) [expr {50 * $charspc}]\n        set geometry(pwsash0) [list [expr {40 * $charspc}] 2]\n        set geometry(pwsash1) [list [expr {60 * $charspc}] 2]\n    }\n\n    # the upper half will have a paned window, a scroll bar to the right, and some stuff below\n    ${NS}::frame .tf -height $geometry(topheight) -width $geometry(topwidth)\n    ${NS}::frame .tf.histframe\n    ${NS}::panedwindow .tf.histframe.pwclist -orient horizontal\n    if {!$use_ttk} {\n        .tf.histframe.pwclist configure -sashpad 0 -handlesize 4\n    }\n\n    # create three canvases\n    set cscroll .tf.histframe.csb\n    set canv .tf.histframe.pwclist.canv\n    canvas $canv \\\n        -selectbackground $selectbgcolor \\\n        -background $bgcolor -bd 0 \\\n        -yscrollincr $linespc -yscrollcommand \"scrollcanv $cscroll\"\n    .tf.histframe.pwclist add $canv\n    set canv2 .tf.histframe.pwclist.canv2\n    canvas $canv2 \\\n        -selectbackground $selectbgcolor \\\n        -background $bgcolor -bd 0 -yscrollincr $linespc\n    .tf.histframe.pwclist add $canv2\n    set canv3 .tf.histframe.pwclist.canv3\n    canvas $canv3 \\\n        -selectbackground $selectbgcolor \\\n        -background $bgcolor -bd 0 -yscrollincr $linespc\n    .tf.histframe.pwclist add $canv3\n    if {$use_ttk} {\n        bind .tf.histframe.pwclist <Map> {\n            bind %W <Map> {}\n            .tf.histframe.pwclist sashpos 1 [lindex $::geometry(pwsash1) 0]\n            .tf.histframe.pwclist sashpos 0 [lindex $::geometry(pwsash0) 0]\n        }\n    } else {\n        eval .tf.histframe.pwclist sash place 0 $geometry(pwsash0)\n        eval .tf.histframe.pwclist sash place 1 $geometry(pwsash1)\n    }\n\n    # a scroll bar to rule them\n    ${NS}::scrollbar $cscroll -command {allcanvs yview}\n    if {!$use_ttk} {$cscroll configure -highlightthickness 0}\n    pack $cscroll -side right -fill y\n    bind .tf.histframe.pwclist <Configure> {resizeclistpanes %W %w}\n    lappend bglist $canv $canv2 $canv3\n    pack .tf.histframe.pwclist -fill both -expand 1 -side left\n\n    # we have two button bars at bottom of top frame. Bar 1\n    ${NS}::frame .tf.bar\n    ${NS}::frame .tf.lbar -height 15\n\n    set sha1entry .tf.bar.sha1\n    set entries $sha1entry\n    set sha1but .tf.bar.sha1label\n    button $sha1but -text \"[mc \"SHA1 ID:\"] \" -state disabled -relief flat \\\n        -command gotocommit -width 8\n    $sha1but conf -disabledforeground [$sha1but cget -foreground]\n    pack .tf.bar.sha1label -side left\n    ${NS}::entry $sha1entry -width 40 -font textfont -textvariable sha1string\n    trace add variable sha1string write sha1change\n    pack $sha1entry -side left -pady 2\n\n    set bm_left_data {\n        #define left_width 16\n        #define left_height 16\n        static unsigned char left_bits[] = {\n        0x00, 0x00, 0xc0, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1c, 0x00,\n        0x0e, 0x00, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x0e, 0x00, 0x1c, 0x00,\n        0x38, 0x00, 0x70, 0x00, 0xe0, 0x00, 0xc0, 0x01};\n    }\n    set bm_right_data {\n        #define right_width 16\n        #define right_height 16\n        static unsigned char right_bits[] = {\n        0x00, 0x00, 0xc0, 0x01, 0x80, 0x03, 0x00, 0x07, 0x00, 0x0e, 0x00, 0x1c,\n        0x00, 0x38, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x00, 0x38, 0x00, 0x1c,\n        0x00, 0x0e, 0x00, 0x07, 0x80, 0x03, 0xc0, 0x01};\n    }\n    image create bitmap bm-left -data $bm_left_data -foreground $uifgcolor\n    image create bitmap bm-left-gray -data $bm_left_data -foreground $uifgdisabledcolor\n    image create bitmap bm-right -data $bm_right_data -foreground $uifgcolor\n    image create bitmap bm-right-gray -data $bm_right_data -foreground $uifgdisabledcolor\n\n    ${NS}::button .tf.bar.leftbut -command goback -state disabled -width 26\n    if {$use_ttk} {\n        .tf.bar.leftbut configure -image [list bm-left disabled bm-left-gray]\n    } else {\n        .tf.bar.leftbut configure -image bm-left\n    }\n    pack .tf.bar.leftbut -side left -fill y\n    ${NS}::button .tf.bar.rightbut -command goforw -state disabled -width 26\n    if {$use_ttk} {\n        .tf.bar.rightbut configure -image [list bm-right disabled bm-right-gray]\n    } else {\n        .tf.bar.rightbut configure -image bm-right\n    }\n    pack .tf.bar.rightbut -side left -fill y\n\n    ${NS}::label .tf.bar.rowlabel -text [mc \"Row\"]\n    set rownumsel {}\n    ${NS}::label .tf.bar.rownum -width 7 -textvariable rownumsel \\\n        -relief sunken -anchor e\n    ${NS}::label .tf.bar.rowlabel2 -text \"/\"\n    ${NS}::label .tf.bar.numcommits -width 7 -textvariable numcommits \\\n        -relief sunken -anchor e\n    pack .tf.bar.rowlabel .tf.bar.rownum .tf.bar.rowlabel2 .tf.bar.numcommits \\\n        -side left\n    if {!$use_ttk} {\n        foreach w {rownum numcommits} {.tf.bar.$w configure -font textfont}\n    }\n    global selectedline\n    trace add variable selectedline write selectedline_change\n\n    # Status label and progress bar\n    set statusw .tf.bar.status\n    ${NS}::label $statusw -width 15 -relief sunken\n    pack $statusw -side left -padx 5\n    if {$use_ttk} {\n        set progresscanv [ttk::progressbar .tf.bar.progress]\n    } else {\n        set h [expr {[font metrics uifont -linespace] + 2}]\n        set progresscanv .tf.bar.progress\n        canvas $progresscanv -relief sunken -height $h -borderwidth 2\n        set progressitem [$progresscanv create rect -1 0 0 $h -fill \"#00ff00\"]\n        set fprogitem [$progresscanv create rect -1 0 0 $h -fill yellow]\n        set rprogitem [$progresscanv create rect -1 0 0 $h -fill red]\n    }\n    pack $progresscanv -side right -expand 1 -fill x -padx {0 2}\n    set progresscoords {0 0}\n    set fprogcoord 0\n    set rprogcoord 0\n    bind $progresscanv <Configure> adjustprogress\n    set lastprogupdate [clock clicks -milliseconds]\n    set progupdatepending 0\n\n    # build up the bottom bar of upper window\n    ${NS}::label .tf.lbar.flabel -text \"[mc \"Find\"] \"\n\n    set bm_down_data {\n        #define down_width 16\n        #define down_height 16\n        static unsigned char down_bits[] = {\n        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01,\n        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01,\n        0x87, 0xe1, 0x8e, 0x71, 0x9c, 0x39, 0xb8, 0x1d,\n        0xf0, 0x0f, 0xe0, 0x07, 0xc0, 0x03, 0x80, 0x01};\n    }\n    image create bitmap bm-down -data $bm_down_data -foreground $uifgcolor\n    ${NS}::button .tf.lbar.fnext -width 26 -command {dofind 1 1}\n    .tf.lbar.fnext configure -image bm-down\n\n    set bm_up_data {\n        #define up_width 16\n        #define up_height 16\n        static unsigned char up_bits[] = {\n        0x80, 0x01, 0xc0, 0x03, 0xe0, 0x07, 0xf0, 0x0f,\n        0xb8, 0x1d, 0x9c, 0x39, 0x8e, 0x71, 0x87, 0xe1,\n        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01,\n        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01};\n    }\n    image create bitmap bm-up -data $bm_up_data -foreground $uifgcolor\n    ${NS}::button .tf.lbar.fprev -width 26 -command {dofind -1 1}\n    .tf.lbar.fprev configure -image bm-up\n\n    ${NS}::label .tf.lbar.flab2 -text \" [mc \"commit\"] \"\n\n    pack .tf.lbar.flabel .tf.lbar.fnext .tf.lbar.fprev .tf.lbar.flab2 \\\n        -side left -fill y\n    set gdttype [mc \"containing:\"]\n    set gm [makedroplist .tf.lbar.gdttype gdttype \\\n                [mc \"containing:\"] \\\n                [mc \"touching paths:\"] \\\n                [mc \"adding/removing string:\"] \\\n                [mc \"changing lines matching:\"]]\n    trace add variable gdttype write gdttype_change\n    pack .tf.lbar.gdttype -side left -fill y\n\n    set findstring {}\n    set fstring .tf.lbar.findstring\n    lappend entries $fstring\n    ${NS}::entry $fstring -width 30 -textvariable findstring\n    trace add variable findstring write find_change\n    set findtype [mc \"Exact\"]\n    set findtypemenu [makedroplist .tf.lbar.findtype \\\n                          findtype [mc \"Exact\"] [mc \"IgnCase\"] [mc \"Regexp\"]]\n    trace add variable findtype write findcom_change\n    set findloc [mc \"All fields\"]\n    makedroplist .tf.lbar.findloc findloc [mc \"All fields\"] [mc \"Headline\"] \\\n        [mc \"Comments\"] [mc \"Author\"] [mc \"Committer\"]\n    trace add variable findloc write find_change\n    pack .tf.lbar.findloc -side right\n    pack .tf.lbar.findtype -side right\n    pack $fstring -side left -expand 1 -fill x\n\n    # Finish putting the upper half of the viewer together\n    pack .tf.lbar -in .tf -side bottom -fill x\n    pack .tf.bar -in .tf -side bottom -fill x\n    pack .tf.histframe -fill both -side top -expand 1\n    .ctop add .tf\n    if {!$use_ttk} {\n        .ctop paneconfigure .tf -height $geometry(topheight)\n        .ctop paneconfigure .tf -width $geometry(topwidth)\n    }\n\n    # now build up the bottom\n    ${NS}::panedwindow .pwbottom -orient horizontal\n\n    # lower left, a text box over search bar, scroll bar to the right\n    # if we know window height, then that will set the lower text height, otherwise\n    # we set lower text height which will drive window height\n    if {[info exists geometry(main)]} {\n        ${NS}::frame .bleft -width $geometry(botwidth)\n    } else {\n        ${NS}::frame .bleft -width $geometry(botwidth) -height $geometry(botheight)\n    }\n    ${NS}::frame .bleft.top\n    ${NS}::frame .bleft.mid\n    ${NS}::frame .bleft.bottom\n\n    # gap between sub-widgets\n    set wgap [font measure uifont \"i\"]\n\n    ${NS}::button .bleft.top.search -text [mc \"Search\"] -command dosearch\n    pack .bleft.top.search -side left -padx 5\n    set sstring .bleft.top.sstring\n    set searchstring \"\"\n    ${NS}::entry $sstring -width 20 -textvariable searchstring\n    lappend entries $sstring\n    trace add variable searchstring write incrsearch\n    pack $sstring -side left -expand 1 -fill x\n    ${NS}::radiobutton .bleft.mid.diff -text [mc \"Diff\"] \\\n        -command changediffdisp -variable diffelide -value {0 0}\n    ${NS}::radiobutton .bleft.mid.old -text [mc \"Old version\"] \\\n        -command changediffdisp -variable diffelide -value {0 1}\n    ${NS}::radiobutton .bleft.mid.new -text [mc \"New version\"] \\\n        -command changediffdisp -variable diffelide -value {1 0}\n\n    ${NS}::label .bleft.mid.labeldiffcontext -text \"      [mc \"Lines of context\"]: \"\n    pack .bleft.mid.diff .bleft.mid.old .bleft.mid.new -side left -ipadx $wgap\n    spinbox .bleft.mid.diffcontext -width 5 \\\n        -from 0 -increment 1 -to 10000000 \\\n        -validate all -validatecommand \"diffcontextvalidate %P\" \\\n        -textvariable diffcontextstring\n    .bleft.mid.diffcontext set $diffcontext\n    trace add variable diffcontextstring write diffcontextchange\n    lappend entries .bleft.mid.diffcontext\n    pack .bleft.mid.labeldiffcontext .bleft.mid.diffcontext -side left -ipadx $wgap\n    ${NS}::checkbutton .bleft.mid.ignspace -text [mc \"Ignore space change\"] \\\n        -command changeignorespace -variable ignorespace\n    pack .bleft.mid.ignspace -side left -padx 5\n\n    set worddiff [mc \"Line diff\"]\n    if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n        makedroplist .bleft.mid.worddiff worddiff [mc \"Line diff\"] \\\n            [mc \"Markup words\"] [mc \"Color words\"]\n        trace add variable worddiff write changeworddiff\n        pack .bleft.mid.worddiff -side left -padx 5\n    }\n\n    set ctext .bleft.bottom.ctext\n    text $ctext -background $bgcolor -foreground $fgcolor \\\n        -state disabled -undo 0 -font textfont \\\n        -yscrollcommand scrolltext -wrap none \\\n        -xscrollcommand \".bleft.bottom.sbhorizontal set\"\n    if {$have_tk85} {\n        $ctext conf -tabstyle wordprocessor\n    }\n    ${NS}::scrollbar .bleft.bottom.sb -command \"$ctext yview\"\n    ${NS}::scrollbar .bleft.bottom.sbhorizontal -command \"$ctext xview\" -orient h\n    pack .bleft.top -side top -fill x\n    pack .bleft.mid -side top -fill x\n    grid $ctext .bleft.bottom.sb -sticky nsew\n    grid .bleft.bottom.sbhorizontal -sticky ew\n    grid columnconfigure .bleft.bottom 0 -weight 1\n    grid rowconfigure .bleft.bottom 0 -weight 1\n    grid rowconfigure .bleft.bottom 1 -weight 0\n    pack .bleft.bottom -side top -fill both -expand 1\n    lappend bglist $ctext\n    lappend fglist $ctext\n\n    $ctext tag conf comment -wrap $wrapcomment\n    $ctext tag conf filesep -font textfontbold -fore $filesepfgcolor -back $filesepbgcolor\n    $ctext tag conf hunksep -fore [lindex $diffcolors 2]\n    $ctext tag conf d0 -fore [lindex $diffcolors 0]\n    $ctext tag conf d0 -back [lindex $diffbgcolors 0]\n    $ctext tag conf dresult -fore [lindex $diffcolors 1]\n    $ctext tag conf dresult -back [lindex $diffbgcolors 1]\n    $ctext tag conf m0 -fore [lindex $mergecolors 0]\n    $ctext tag conf m1 -fore [lindex $mergecolors 1]\n    $ctext tag conf m2 -fore [lindex $mergecolors 2]\n    $ctext tag conf m3 -fore [lindex $mergecolors 3]\n    $ctext tag conf m4 -fore [lindex $mergecolors 4]\n    $ctext tag conf m5 -fore [lindex $mergecolors 5]\n    $ctext tag conf m6 -fore [lindex $mergecolors 6]\n    $ctext tag conf m7 -fore [lindex $mergecolors 7]\n    $ctext tag conf m8 -fore [lindex $mergecolors 8]\n    $ctext tag conf m9 -fore [lindex $mergecolors 9]\n    $ctext tag conf m10 -fore [lindex $mergecolors 10]\n    $ctext tag conf m11 -fore [lindex $mergecolors 11]\n    $ctext tag conf m12 -fore [lindex $mergecolors 12]\n    $ctext tag conf m13 -fore [lindex $mergecolors 13]\n    $ctext tag conf m14 -fore [lindex $mergecolors 14]\n    $ctext tag conf m15 -fore [lindex $mergecolors 15]\n    $ctext tag conf mmax -fore darkgrey\n    set mergemax 16\n    $ctext tag conf mresult -font textfontbold\n    $ctext tag conf msep -font textfontbold\n    $ctext tag conf found -back $foundbgcolor\n    $ctext tag conf currentsearchhit -back $currentsearchhitbgcolor\n    $ctext tag conf wwrap -wrap word -lmargin2 1c\n    $ctext tag conf bold -font textfontbold\n    # set these to the lowest priority:\n    $ctext tag lower currentsearchhit\n    $ctext tag lower found\n    $ctext tag lower filesep\n    $ctext tag lower dresult\n    $ctext tag lower d0\n\n    .pwbottom add .bleft\n    if {!$use_ttk} {\n        .pwbottom paneconfigure .bleft -width $geometry(botwidth)\n    }\n\n    # lower right\n    ${NS}::frame .bright\n    ${NS}::frame .bright.mode\n    ${NS}::radiobutton .bright.mode.patch -text [mc \"Patch\"] \\\n        -command reselectline -variable cmitmode -value \"patch\"\n    ${NS}::radiobutton .bright.mode.tree -text [mc \"Tree\"] \\\n        -command reselectline -variable cmitmode -value \"tree\"\n    grid .bright.mode.patch .bright.mode.tree -sticky ew\n    pack .bright.mode -side top -fill x\n    set cflist .bright.cfiles\n    set indent [font measure mainfont \"nn\"]\n    text $cflist \\\n        -selectbackground $selectbgcolor \\\n        -background $bgcolor -foreground $fgcolor \\\n        -font mainfont \\\n        -tabs [list $indent [expr {2 * $indent}]] \\\n        -yscrollcommand \".bright.sb set\" \\\n        -cursor [. cget -cursor] \\\n        -spacing1 1 -spacing3 1\n    lappend bglist $cflist\n    lappend fglist $cflist\n    ${NS}::scrollbar .bright.sb -command \"$cflist yview\"\n    pack .bright.sb -side right -fill y\n    pack $cflist -side left -fill both -expand 1\n    $cflist tag configure highlight \\\n        -background [$cflist cget -selectbackground]\n    $cflist tag configure bold -font mainfontbold\n\n    .pwbottom add .bright\n    .ctop add .pwbottom\n\n    # restore window width & height if known\n    if {[info exists geometry(main)]} {\n        if {[scan $geometry(main) \"%dx%d\" w h] >= 2} {\n            if {$w > [winfo screenwidth .]} {\n                set w [winfo screenwidth .]\n            }\n            if {$h > [winfo screenheight .]} {\n                set h [winfo screenheight .]\n            }\n            wm geometry . \"${w}x$h\"\n        }\n    }\n\n    if {[info exists geometry(state)] && $geometry(state) eq \"zoomed\"} {\n        wm state . $geometry(state)\n    }\n\n    if {[tk windowingsystem] eq {aqua}} {\n        set M1B M1\n        set ::BM \"3\"\n    } else {\n        set M1B Control\n        set ::BM \"2\"\n    }\n\n    if {$use_ttk} {\n        bind .ctop <Map> {\n            bind %W <Map> {}\n            %W sashpos 0 $::geometry(topheight)\n        }\n        bind .pwbottom <Map> {\n            bind %W <Map> {}\n            %W sashpos 0 $::geometry(botwidth)\n        }\n        bind .pwbottom <Configure> {resizecdetpanes %W %w}\n    }\n\n    pack .ctop -fill both -expand 1\n    bindall <1> {selcanvline %W %x %y}\n    #bindall <B1-Motion> {selcanvline %W %x %y}\n    if {[tk windowingsystem] == \"win32\"} {\n        bind . <MouseWheel> { windows_mousewheel_redirector %W %X %Y %D }\n        bind $ctext <MouseWheel> { windows_mousewheel_redirector %W %X %Y %D ; break }\n    } else {\n        bindall <ButtonRelease-4> \"allcanvs yview scroll -5 units\"\n        bindall <ButtonRelease-5> \"allcanvs yview scroll 5 units\"\n        bind $ctext <Button> {\n            if {\"%b\" eq 6} {\n                $ctext xview scroll -5 units\n            } elseif {\"%b\" eq 7} {\n                $ctext xview scroll 5 units\n            }\n        }\n        if {[tk windowingsystem] eq \"aqua\"} {\n            bindall <MouseWheel> {\n                set delta [expr {- (%D)}]\n                allcanvs yview scroll $delta units\n            }\n            bindall <Shift-MouseWheel> {\n                set delta [expr {- (%D)}]\n                $canv xview scroll $delta units\n            }\n        }\n    }\n    bindall <$::BM> \"canvscan mark %W %x %y\"\n    bindall <B$::BM-Motion> \"canvscan dragto %W %x %y\"\n    bind all <$M1B-Key-w> {destroy [winfo toplevel %W]}\n    bind . <$M1B-Key-w> doquit\n    bindkey <Home> selfirstline\n    bindkey <End> sellastline\n    bind . <Key-Up> \"selnextline -1\"\n    bind . <Key-Down> \"selnextline 1\"\n    bind . <Shift-Key-Up> \"dofind -1 0\"\n    bind . <Shift-Key-Down> \"dofind 1 0\"\n    if {$have_tk86} {\n        bindkey <<NextChar>> \"goforw\"\n        bindkey <<PrevChar>> \"goback\"\n    } else {\n        bindkey <Key-Right> \"goforw\"\n        bindkey <Key-Left> \"goback\"\n    }\n    bind . <Key-Prior> \"selnextpage -1\"\n    bind . <Key-Next> \"selnextpage 1\"\n    bind . <$M1B-Home> \"allcanvs yview moveto 0.0\"\n    bind . <$M1B-End> \"allcanvs yview moveto 1.0\"\n    bind . <$M1B-Key-Up> \"allcanvs yview scroll -1 units\"\n    bind . <$M1B-Key-Down> \"allcanvs yview scroll 1 units\"\n    bind . <$M1B-Key-Prior> \"allcanvs yview scroll -1 pages\"\n    bind . <$M1B-Key-Next> \"allcanvs yview scroll 1 pages\"\n    bindkey <Key-Delete> \"$ctext yview scroll -1 pages\"\n    bindkey <Key-BackSpace> \"$ctext yview scroll -1 pages\"\n    bindkey <Key-space> \"$ctext yview scroll 1 pages\"\n    bindkey p \"selnextline -1\"\n    bindkey n \"selnextline 1\"\n    bindkey z \"goback\"\n    bindkey x \"goforw\"\n    bindkey k \"selnextline -1\"\n    bindkey j \"selnextline 1\"\n    bindkey h \"goback\"\n    bindkey l \"goforw\"\n    bindkey b prevfile\n    bindkey d \"$ctext yview scroll 18 units\"\n    bindkey u \"$ctext yview scroll -18 units\"\n    bindkey g {$sha1entry delete 0 end; focus $sha1entry}\n    bindkey / {focus $fstring}\n    bindkey <Key-KP_Divide> {focus $fstring}\n    bindkey <Key-Return> {dofind 1 1}\n    bindkey ? {dofind -1 1}\n    bindkey f nextfile\n    bind . <F5> updatecommits\n    bindmodfunctionkey Shift 5 reloadcommits\n    bind . <F2> showrefs\n    bindmodfunctionkey Shift 4 {newview 0}\n    bind . <F4> edit_or_newview\n    bind . <$M1B-q> doquit\n    bind . <$M1B-f> {dofind 1 1}\n    bind . <$M1B-g> {dofind 1 0}\n    bind . <$M1B-r> dosearchback\n    bind . <$M1B-s> dosearch\n    bind . <$M1B-equal> {incrfont 1}\n    bind . <$M1B-plus> {incrfont 1}\n    bind . <$M1B-KP_Add> {incrfont 1}\n    bind . <$M1B-minus> {incrfont -1}\n    bind . <$M1B-KP_Subtract> {incrfont -1}\n    wm protocol . WM_DELETE_WINDOW doquit\n    bind . <Destroy> {stop_backends}\n    bind . <Button-1> \"click %W\"\n    bind $fstring <Key-Return> {dofind 1 1}\n    bind $sha1entry <Key-Return> {gotocommit; break}\n    bind $sha1entry <<PasteSelection>> clearsha1\n    bind $sha1entry <<Paste>> clearsha1\n    bind $cflist <1> {sel_flist %W %x %y; break}\n    bind $cflist <B1-Motion> {sel_flist %W %x %y; break}\n    bind $cflist <ButtonRelease-1> {treeclick %W %x %y}\n    global ctxbut\n    bind $cflist $ctxbut {pop_flist_menu %W %X %Y %x %y}\n    bind $ctext $ctxbut {pop_diff_menu %W %X %Y %x %y}\n    bind $ctext <Button-1> {focus %W}\n    bind $ctext <<Selection>> rehighlight_search_results\n    for {set i 1} {$i < 10} {incr i} {\n        bind . <$M1B-Key-$i> [list go_to_parent $i]\n    }\n\n    set maincursor [. cget -cursor]\n    set textcursor [$ctext cget -cursor]\n    set curtextcursor $textcursor\n\n    set rowctxmenu .rowctxmenu\n    makemenu $rowctxmenu {\n        {mc \"Diff this -> selected\" command {diffvssel 0}}\n        {mc \"Diff selected -> this\" command {diffvssel 1}}\n        {mc \"Make patch\" command mkpatch}\n        {mc \"Create tag\" command mktag}\n        {mc \"Copy commit reference\" command copyreference}\n        {mc \"Write commit to file\" command writecommit}\n        {mc \"Create new branch\" command mkbranch}\n        {mc \"Cherry-pick this commit\" command cherrypick}\n        {mc \"Reset HEAD branch to here\" command resethead}\n        {mc \"Mark this commit\" command markhere}\n        {mc \"Return to mark\" command gotomark}\n        {mc \"Find descendant of this and mark\" command find_common_desc}\n        {mc \"Compare with marked commit\" command compare_commits}\n        {mc \"Diff this -> marked commit\" command {diffvsmark 0}}\n        {mc \"Diff marked commit -> this\" command {diffvsmark 1}}\n        {mc \"Revert this commit\" command revert}\n    }\n    $rowctxmenu configure -tearoff 0\n\n    set fakerowmenu .fakerowmenu\n    makemenu $fakerowmenu {\n        {mc \"Diff this -> selected\" command {diffvssel 0}}\n        {mc \"Diff selected -> this\" command {diffvssel 1}}\n        {mc \"Make patch\" command mkpatch}\n        {mc \"Diff this -> marked commit\" command {diffvsmark 0}}\n        {mc \"Diff marked commit -> this\" command {diffvsmark 1}}\n    }\n    $fakerowmenu configure -tearoff 0\n\n    set headctxmenu .headctxmenu\n    makemenu $headctxmenu {\n        {mc \"Check out this branch\" command cobranch}\n        {mc \"Rename this branch\" command mvbranch}\n        {mc \"Remove this branch\" command rmbranch}\n        {mc \"Copy branch name\" command {clipboard clear; clipboard append $headmenuhead}}\n    }\n    $headctxmenu configure -tearoff 0\n\n    global flist_menu\n    set flist_menu .flistctxmenu\n    makemenu $flist_menu {\n        {mc \"Highlight this too\" command {flist_hl 0}}\n        {mc \"Highlight this only\" command {flist_hl 1}}\n        {mc \"External diff\" command {external_diff}}\n        {mc \"Blame parent commit\" command {external_blame 1}}\n        {mc \"Copy path\" command {clipboard clear; clipboard append $flist_menu_file}}\n    }\n    $flist_menu configure -tearoff 0\n\n    global diff_menu\n    set diff_menu .diffctxmenu\n    makemenu $diff_menu {\n        {mc \"Show origin of this line\" command show_line_source}\n        {mc \"Run git gui blame on this line\" command {external_blame_diff}}\n    }\n    $diff_menu configure -tearoff 0\n}\n\n# Windows sends all mouse wheel events to the current focused window, not\n# the one where the mouse hovers, so bind those events here and redirect\n# to the correct window\nproc windows_mousewheel_redirector {W X Y D} {\n    global canv canv2 canv3\n    set w [winfo containing -displayof $W $X $Y]\n    if {$w ne \"\"} {\n        set u [expr {$D < 0 ? 5 : -5}]\n        if {$w == $canv || $w == $canv2 || $w == $canv3} {\n            allcanvs yview scroll $u units\n        } else {\n            catch {\n                $w yview scroll $u units\n            }\n        }\n    }\n}\n\n# Update row number label when selectedline changes\nproc selectedline_change {n1 n2 op} {\n    global selectedline rownumsel\n\n    if {$selectedline eq {}} {\n        set rownumsel {}\n    } else {\n        set rownumsel [expr {$selectedline + 1}]\n    }\n}\n\n# mouse-2 makes all windows scan vertically, but only the one\n# the cursor is in scans horizontally\nproc canvscan {op w x y} {\n    global canv canv2 canv3\n    foreach c [list $canv $canv2 $canv3] {\n        if {$c == $w} {\n            $c scan $op $x $y\n        } else {\n            $c scan $op 0 $y\n        }\n    }\n}\n\nproc scrollcanv {cscroll f0 f1} {\n    $cscroll set $f0 $f1\n    drawvisible\n    flushhighlights\n}\n\n# when we make a key binding for the toplevel, make sure\n# it doesn't get triggered when that key is pressed in the\n# find string entry widget.\nproc bindkey {ev script} {\n    global entries\n    bind . $ev $script\n    set escript [bind Entry $ev]\n    if {$escript == {}} {\n        set escript [bind Entry <Key>]\n    }\n    foreach e $entries {\n        bind $e $ev \"$escript; break\"\n    }\n}\n\nproc bindmodfunctionkey {mod n script} {\n    bind . <$mod-F$n> $script\n    catch { bind . <$mod-XF86_Switch_VT_$n> $script }\n}\n\n# set the focus back to the toplevel for any click outside\n# the entry widgets\nproc click {w} {\n    global ctext entries\n    foreach e [concat $entries $ctext] {\n        if {$w == $e} return\n    }\n    focus .\n}\n\n# Adjust the progress bar for a change in requested extent or canvas size\nproc adjustprogress {} {\n    global progresscanv progressitem progresscoords\n    global fprogitem fprogcoord lastprogupdate progupdatepending\n    global rprogitem rprogcoord use_ttk\n\n    if {$use_ttk} {\n        $progresscanv configure -value [expr {int($fprogcoord * 100)}]\n        return\n    }\n\n    set w [expr {[winfo width $progresscanv] - 4}]\n    set x0 [expr {$w * [lindex $progresscoords 0]}]\n    set x1 [expr {$w * [lindex $progresscoords 1]}]\n    set h [winfo height $progresscanv]\n    $progresscanv coords $progressitem $x0 0 $x1 $h\n    $progresscanv coords $fprogitem 0 0 [expr {$w * $fprogcoord}] $h\n    $progresscanv coords $rprogitem 0 0 [expr {$w * $rprogcoord}] $h\n    set now [clock clicks -milliseconds]\n    if {$now >= $lastprogupdate + 100} {\n        set progupdatepending 0\n        update\n    } elseif {!$progupdatepending} {\n        set progupdatepending 1\n        after [expr {$lastprogupdate + 100 - $now}] doprogupdate\n    }\n}\n\nproc doprogupdate {} {\n    global lastprogupdate progupdatepending\n\n    if {$progupdatepending} {\n        set progupdatepending 0\n        set lastprogupdate [clock clicks -milliseconds]\n        update\n    }\n}\n\nproc config_check_tmp_exists {tries_left} {\n    global config_file_tmp\n\n    if {[file exists $config_file_tmp]} {\n        incr tries_left -1\n        if {$tries_left > 0} {\n            after 100 [list config_check_tmp_exists $tries_left]\n        } else {\n            error_popup \"There appears to be a stale $config_file_tmp\\\n file, which will prevent gitk from saving its configuration on exit.\\\n Please remove it if it is not being used by any existing gitk process.\"\n        }\n    }\n}\n\nproc config_init_trace {name} {\n    global config_variable_changed config_variable_original\n\n    upvar #0 $name var\n    set config_variable_changed($name) 0\n    set config_variable_original($name) $var\n}\n\nproc config_variable_change_cb {name name2 op} {\n    global config_variable_changed config_variable_original\n\n    upvar #0 $name var\n    if {$op eq \"write\" &&\n        (![info exists config_variable_original($name)] ||\n         $config_variable_original($name) ne $var)} {\n        set config_variable_changed($name) 1\n    }\n}\n\nproc savestuff {w} {\n    global stuffsaved\n    global config_file config_file_tmp\n    global config_variables config_variable_changed\n    global viewchanged\n\n    upvar #0 viewname current_viewname\n    upvar #0 viewfiles current_viewfiles\n    upvar #0 viewargs current_viewargs\n    upvar #0 viewargscmd current_viewargscmd\n    upvar #0 viewperm current_viewperm\n    upvar #0 nextviewnum current_nextviewnum\n    upvar #0 use_ttk current_use_ttk\n\n    if {$stuffsaved} return\n    if {![winfo viewable .]} return\n    set remove_tmp 0\n    if {[catch {\n        set try_count 0\n        while {[catch {set f [open $config_file_tmp {WRONLY CREAT EXCL}]}]} {\n            if {[incr try_count] > 50} {\n                error \"Unable to write config file: $config_file_tmp exists\"\n            }\n            after 100\n        }\n        set remove_tmp 1\n        if {$::tcl_platform(platform) eq {windows}} {\n            file attributes $config_file_tmp -hidden true\n        }\n        if {[file exists $config_file]} {\n            source $config_file\n        }\n        foreach var_name $config_variables {\n            upvar #0 $var_name var\n            upvar 0 $var_name old_var\n            if {!$config_variable_changed($var_name) && [info exists old_var]} {\n                puts $f [list set $var_name $old_var]\n            } else {\n                puts $f [list set $var_name $var]\n            }\n        }\n\n        puts $f \"set geometry(main) [wm geometry .]\"\n        puts $f \"set geometry(state) [wm state .]\"\n        puts $f \"set geometry(topwidth) [winfo width .tf]\"\n        puts $f \"set geometry(topheight) [winfo height .tf]\"\n        if {$current_use_ttk} {\n            puts $f \"set geometry(pwsash0) \\\"[.tf.histframe.pwclist sashpos 0] 1\\\"\"\n            puts $f \"set geometry(pwsash1) \\\"[.tf.histframe.pwclist sashpos 1] 1\\\"\"\n        } else {\n            puts $f \"set geometry(pwsash0) \\\"[.tf.histframe.pwclist sash coord 0]\\\"\"\n            puts $f \"set geometry(pwsash1) \\\"[.tf.histframe.pwclist sash coord 1]\\\"\"\n        }\n        puts $f \"set geometry(botwidth) [winfo width .bleft]\"\n        puts $f \"set geometry(botheight) [winfo height .bleft]\"\n\n        array set view_save {}\n        array set views {}\n        if {![info exists permviews]} { set permviews {} }\n        foreach view $permviews {\n            set view_save([lindex $view 0]) 1\n            set views([lindex $view 0]) $view\n        }\n        puts -nonewline $f \"set permviews {\"\n        for {set v 1} {$v < $current_nextviewnum} {incr v} {\n            if {$viewchanged($v)} {\n                if {$current_viewperm($v)} {\n                    set views($current_viewname($v)) [list $current_viewname($v) $current_viewfiles($v) $current_viewargs($v) $current_viewargscmd($v)]\n                } else {\n                    set view_save($current_viewname($v)) 0\n                }\n            }\n        }\n        # write old and updated view to their places and append remaining to the end\n        foreach view $permviews {\n            set view_name [lindex $view 0]\n            if {$view_save($view_name)} {\n                puts $f \"{$views($view_name)}\"\n            }\n            unset views($view_name)\n        }\n        foreach view_name [array names views] {\n            puts $f \"{$views($view_name)}\"\n        }\n        puts $f \"}\"\n        close $f\n        file rename -force $config_file_tmp $config_file\n        set remove_tmp 0\n    } err]} {\n        puts \"Error saving config: $err\"\n    }\n    if {$remove_tmp} {\n        file delete -force $config_file_tmp\n    }\n    set stuffsaved 1\n}\n\nproc resizeclistpanes {win w} {\n    global oldwidth oldsash use_ttk\n    if {[info exists oldwidth($win)]} {\n        if {[info exists oldsash($win)]} {\n            set s0 [lindex $oldsash($win) 0]\n            set s1 [lindex $oldsash($win) 1]\n        } elseif {$use_ttk} {\n            set s0 [$win sashpos 0]\n            set s1 [$win sashpos 1]\n        } else {\n            set s0 [$win sash coord 0]\n            set s1 [$win sash coord 1]\n        }\n        if {$w < 60} {\n            set sash0 [expr {int($w/2 - 2)}]\n            set sash1 [expr {int($w*5/6 - 2)}]\n        } else {\n            set factor [expr {1.0 * $w / $oldwidth($win)}]\n            set sash0 [expr {int($factor * [lindex $s0 0])}]\n            set sash1 [expr {int($factor * [lindex $s1 0])}]\n            if {$sash0 < 30} {\n                set sash0 30\n            }\n            if {$sash1 < $sash0 + 20} {\n                set sash1 [expr {$sash0 + 20}]\n            }\n            if {$sash1 > $w - 10} {\n                set sash1 [expr {$w - 10}]\n                if {$sash0 > $sash1 - 20} {\n                    set sash0 [expr {$sash1 - 20}]\n                }\n            }\n        }\n        if {$use_ttk} {\n            $win sashpos 0 $sash0\n            $win sashpos 1 $sash1\n        } else {\n            $win sash place 0 $sash0 [lindex $s0 1]\n            $win sash place 1 $sash1 [lindex $s1 1]\n            set sash0 [list $sash0 [lindex $s0 1]]\n            set sash1 [list $sash1 [lindex $s1 1]]\n        }\n        set oldsash($win) [list $sash0 $sash1]\n    }\n    set oldwidth($win) $w\n}\n\nproc resizecdetpanes {win w} {\n    global oldwidth oldsash use_ttk\n    if {[info exists oldwidth($win)]} {\n        if {[info exists oldsash($win)]} {\n            set s0 $oldsash($win)\n        } elseif {$use_ttk} {\n            set s0 [$win sashpos 0]\n        } else {\n            set s0 [$win sash coord 0]\n        }\n        if {$w < 60} {\n            set sash0 [expr {int($w*3/4 - 2)}]\n        } else {\n            set factor [expr {1.0 * $w / $oldwidth($win)}]\n            set sash0 [expr {int($factor * [lindex $s0 0])}]\n            if {$sash0 < 45} {\n                set sash0 45\n            }\n            if {$sash0 > $w - 15} {\n                set sash0 [expr {$w - 15}]\n            }\n        }\n        if {$use_ttk} {\n            $win sashpos 0 $sash0\n        } else {\n            $win sash place 0 $sash0 [lindex $s0 1]\n            set sash0 [list $sash0 [lindex $s0 1]]\n        }\n        set oldsash($win) $sash0\n    }\n    set oldwidth($win) $w\n}\n\nproc allcanvs args {\n    global canv canv2 canv3\n    eval $canv $args\n    eval $canv2 $args\n    eval $canv3 $args\n}\n\nproc bindall {event action} {\n    global canv canv2 canv3\n    bind $canv $event $action\n    bind $canv2 $event $action\n    bind $canv3 $event $action\n}\n\nproc about {} {\n    global bgcolor NS\n    set w .about\n    if {[winfo exists $w]} {\n        raise $w\n        return\n    }\n    ttk_toplevel $w\n    wm title $w [mc \"About gitk\"]\n    make_transient $w .\n    message $w.m -text [mc \"\nGitk - a commit viewer for git\n\nCopyright \\u00a9 2005-2016 Paul Mackerras\n\nUse and redistribute under the terms of the GNU General Public License\"] \\\n            -justify center -aspect 400 -border 2 -bg $bgcolor -relief groove\n    pack $w.m -side top -fill x -padx 2 -pady 2\n    ${NS}::button $w.ok -text [mc \"Close\"] -command \"destroy $w\" -default active\n    pack $w.ok -side bottom\n    bind $w <Visibility> \"focus $w.ok\"\n    bind $w <Key-Escape> \"destroy $w\"\n    bind $w <Key-Return> \"destroy $w\"\n    tk::PlaceWindow $w widget .\n}\n\nproc keys {} {\n    global bgcolor NS\n    set w .keys\n    if {[winfo exists $w]} {\n        raise $w\n        return\n    }\n    if {[tk windowingsystem] eq {aqua}} {\n        set M1T Cmd\n    } else {\n        set M1T Ctrl\n    }\n    ttk_toplevel $w\n    wm title $w [mc \"Gitk key bindings\"]\n    make_transient $w .\n    message $w.m -text \"\n[mc \"Gitk key bindings:\"]\n\n[mc \"<%s-Q>\t\tQuit\" $M1T]\n[mc \"<%s-W>\t\tClose window\" $M1T]\n[mc \"<Home>\t\tMove to first commit\"]\n[mc \"<End>\t\tMove to last commit\"]\n[mc \"<Up>, p, k\tMove up one commit\"]\n[mc \"<Down>, n, j\tMove down one commit\"]\n[mc \"<Left>, z, h\tGo back in history list\"]\n[mc \"<Right>, x, l\tGo forward in history list\"]\n[mc \"<%s-n>\tGo to n-th parent of current commit in history list\" $M1T]\n[mc \"<PageUp>\tMove up one page in commit list\"]\n[mc \"<PageDown>\tMove down one page in commit list\"]\n[mc \"<%s-Home>\tScroll to top of commit list\" $M1T]\n[mc \"<%s-End>\tScroll to bottom of commit list\" $M1T]\n[mc \"<%s-Up>\tScroll commit list up one line\" $M1T]\n[mc \"<%s-Down>\tScroll commit list down one line\" $M1T]\n[mc \"<%s-PageUp>\tScroll commit list up one page\" $M1T]\n[mc \"<%s-PageDown>\tScroll commit list down one page\" $M1T]\n[mc \"<Shift-Up>\tFind backwards (upwards, later commits)\"]\n[mc \"<Shift-Down>\tFind forwards (downwards, earlier commits)\"]\n[mc \"<Delete>, b\tScroll diff view up one page\"]\n[mc \"<Backspace>\tScroll diff view up one page\"]\n[mc \"<Space>\t\tScroll diff view down one page\"]\n[mc \"u\t\tScroll diff view up 18 lines\"]\n[mc \"d\t\tScroll diff view down 18 lines\"]\n[mc \"<%s-F>\t\tFind\" $M1T]\n[mc \"<%s-G>\t\tMove to next find hit\" $M1T]\n[mc \"<Return>\tMove to next find hit\"]\n[mc \"g\t\tGo to commit\"]\n[mc \"/\t\tFocus the search box\"]\n[mc \"?\t\tMove to previous find hit\"]\n[mc \"f\t\tScroll diff view to next file\"]\n[mc \"<%s-S>\t\tSearch for next hit in diff view\" $M1T]\n[mc \"<%s-R>\t\tSearch for previous hit in diff view\" $M1T]\n[mc \"<%s-KP+>\tIncrease font size\" $M1T]\n[mc \"<%s-plus>\tIncrease font size\" $M1T]\n[mc \"<%s-KP->\tDecrease font size\" $M1T]\n[mc \"<%s-minus>\tDecrease font size\" $M1T]\n[mc \"<F5>\t\tUpdate\"]\n\" \\\n            -justify left -bg $bgcolor -border 2 -relief groove\n    pack $w.m -side top -fill both -padx 2 -pady 2\n    ${NS}::button $w.ok -text [mc \"Close\"] -command \"destroy $w\" -default active\n    bind $w <Key-Escape> [list destroy $w]\n    pack $w.ok -side bottom\n    bind $w <Visibility> \"focus $w.ok\"\n    bind $w <Key-Escape> \"destroy $w\"\n    bind $w <Key-Return> \"destroy $w\"\n}\n\n# Procedures for manipulating the file list window at the\n# bottom right of the overall window.\n\nproc treeview {w l openlevs} {\n    global treecontents treediropen treeheight treeparent treeindex\n\n    set ix 0\n    set treeindex() 0\n    set lev 0\n    set prefix {}\n    set prefixend -1\n    set prefendstack {}\n    set htstack {}\n    set ht 0\n    set treecontents() {}\n    $w conf -state normal\n    foreach f $l {\n        while {[string range $f 0 $prefixend] ne $prefix} {\n            if {$lev <= $openlevs} {\n                $w mark set e:$treeindex($prefix) \"end -1c\"\n                $w mark gravity e:$treeindex($prefix) left\n            }\n            set treeheight($prefix) $ht\n            incr ht [lindex $htstack end]\n            set htstack [lreplace $htstack end end]\n            set prefixend [lindex $prefendstack end]\n            set prefendstack [lreplace $prefendstack end end]\n            set prefix [string range $prefix 0 $prefixend]\n            incr lev -1\n        }\n        set tail [string range $f [expr {$prefixend+1}] end]\n        while {[set slash [string first \"/\" $tail]] >= 0} {\n            lappend htstack $ht\n            set ht 0\n            lappend prefendstack $prefixend\n            incr prefixend [expr {$slash + 1}]\n            set d [string range $tail 0 $slash]\n            lappend treecontents($prefix) $d\n            set oldprefix $prefix\n            append prefix $d\n            set treecontents($prefix) {}\n            set treeindex($prefix) [incr ix]\n            set treeparent($prefix) $oldprefix\n            set tail [string range $tail [expr {$slash+1}] end]\n            if {$lev <= $openlevs} {\n                set ht 1\n                set treediropen($prefix) [expr {$lev < $openlevs}]\n                set bm [expr {$lev == $openlevs? \"tri-rt\": \"tri-dn\"}]\n                $w mark set d:$ix \"end -1c\"\n                $w mark gravity d:$ix left\n                set str \"\\n\"\n                for {set i 0} {$i < $lev} {incr i} {append str \"\\t\"}\n                $w insert end $str\n                $w image create end -align center -image $bm -padx 1 \\\n                    -name a:$ix\n                $w insert end $d [highlight_tag $prefix]\n                $w mark set s:$ix \"end -1c\"\n                $w mark gravity s:$ix left\n            }\n            incr lev\n        }\n        if {$tail ne {}} {\n            if {$lev <= $openlevs} {\n                incr ht\n                set str \"\\n\"\n                for {set i 0} {$i < $lev} {incr i} {append str \"\\t\"}\n                $w insert end $str\n                $w insert end $tail [highlight_tag $f]\n            }\n            lappend treecontents($prefix) $tail\n        }\n    }\n    while {$htstack ne {}} {\n        set treeheight($prefix) $ht\n        incr ht [lindex $htstack end]\n        set htstack [lreplace $htstack end end]\n        set prefixend [lindex $prefendstack end]\n        set prefendstack [lreplace $prefendstack end end]\n        set prefix [string range $prefix 0 $prefixend]\n    }\n    $w conf -state disabled\n}\n\nproc linetoelt {l} {\n    global treeheight treecontents\n\n    set y 2\n    set prefix {}\n    while {1} {\n        foreach e $treecontents($prefix) {\n            if {$y == $l} {\n                return \"$prefix$e\"\n            }\n            set n 1\n            if {[string index $e end] eq \"/\"} {\n                set n $treeheight($prefix$e)\n                if {$y + $n > $l} {\n                    append prefix $e\n                    incr y\n                    break\n                }\n            }\n            incr y $n\n        }\n    }\n}\n\nproc highlight_tree {y prefix} {\n    global treeheight treecontents cflist\n\n    foreach e $treecontents($prefix) {\n        set path $prefix$e\n        if {[highlight_tag $path] ne {}} {\n            $cflist tag add bold $y.0 \"$y.0 lineend\"\n        }\n        incr y\n        if {[string index $e end] eq \"/\" && $treeheight($path) > 1} {\n            set y [highlight_tree $y $path]\n        }\n    }\n    return $y\n}\n\nproc treeclosedir {w dir} {\n    global treediropen treeheight treeparent treeindex\n\n    set ix $treeindex($dir)\n    $w conf -state normal\n    $w delete s:$ix e:$ix\n    set treediropen($dir) 0\n    $w image configure a:$ix -image tri-rt\n    $w conf -state disabled\n    set n [expr {1 - $treeheight($dir)}]\n    while {$dir ne {}} {\n        incr treeheight($dir) $n\n        set dir $treeparent($dir)\n    }\n}\n\nproc treeopendir {w dir} {\n    global treediropen treeheight treeparent treecontents treeindex\n\n    set ix $treeindex($dir)\n    $w conf -state normal\n    $w image configure a:$ix -image tri-dn\n    $w mark set e:$ix s:$ix\n    $w mark gravity e:$ix right\n    set lev 0\n    set str \"\\n\"\n    set n [llength $treecontents($dir)]\n    for {set x $dir} {$x ne {}} {set x $treeparent($x)} {\n        incr lev\n        append str \"\\t\"\n        incr treeheight($x) $n\n    }\n    foreach e $treecontents($dir) {\n        set de $dir$e\n        if {[string index $e end] eq \"/\"} {\n            set iy $treeindex($de)\n            $w mark set d:$iy e:$ix\n            $w mark gravity d:$iy left\n            $w insert e:$ix $str\n            set treediropen($de) 0\n            $w image create e:$ix -align center -image tri-rt -padx 1 \\\n                -name a:$iy\n            $w insert e:$ix $e [highlight_tag $de]\n            $w mark set s:$iy e:$ix\n            $w mark gravity s:$iy left\n            set treeheight($de) 1\n        } else {\n            $w insert e:$ix $str\n            $w insert e:$ix $e [highlight_tag $de]\n        }\n    }\n    $w mark gravity e:$ix right\n    $w conf -state disabled\n    set treediropen($dir) 1\n    set top [lindex [split [$w index @0,0] .] 0]\n    set ht [$w cget -height]\n    set l [lindex [split [$w index s:$ix] .] 0]\n    if {$l < $top} {\n        $w yview $l.0\n    } elseif {$l + $n + 1 > $top + $ht} {\n        set top [expr {$l + $n + 2 - $ht}]\n        if {$l < $top} {\n            set top $l\n        }\n        $w yview $top.0\n    }\n}\n\nproc treeclick {w x y} {\n    global treediropen cmitmode ctext cflist cflist_top\n\n    if {$cmitmode ne \"tree\"} return\n    if {![info exists cflist_top]} return\n    set l [lindex [split [$w index \"@$x,$y\"] \".\"] 0]\n    $cflist tag remove highlight $cflist_top.0 \"$cflist_top.0 lineend\"\n    $cflist tag add highlight $l.0 \"$l.0 lineend\"\n    set cflist_top $l\n    if {$l == 1} {\n        $ctext yview 1.0\n        return\n    }\n    set e [linetoelt $l]\n    if {[string index $e end] ne \"/\"} {\n        showfile $e\n    } elseif {$treediropen($e)} {\n        treeclosedir $w $e\n    } else {\n        treeopendir $w $e\n    }\n}\n\nproc setfilelist {id} {\n    global treefilelist cflist jump_to_here\n\n    treeview $cflist $treefilelist($id) 0\n    if {$jump_to_here ne {}} {\n        set f [lindex $jump_to_here 0]\n        if {[lsearch -exact $treefilelist($id) $f] >= 0} {\n            showfile $f\n        }\n    }\n}\n\nimage create bitmap tri-rt -background black -foreground blue -data {\n    #define tri-rt_width 13\n    #define tri-rt_height 13\n    static unsigned char tri-rt_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x30, 0x00, 0x70, 0x00, 0xf0, 0x00,\n       0xf0, 0x01, 0xf0, 0x00, 0x70, 0x00, 0x30, 0x00, 0x10, 0x00, 0x00, 0x00,\n       0x00, 0x00};\n} -maskdata {\n    #define tri-rt-mask_width 13\n    #define tri-rt-mask_height 13\n    static unsigned char tri-rt-mask_bits[] = {\n       0x08, 0x00, 0x18, 0x00, 0x38, 0x00, 0x78, 0x00, 0xf8, 0x00, 0xf8, 0x01,\n       0xf8, 0x03, 0xf8, 0x01, 0xf8, 0x00, 0x78, 0x00, 0x38, 0x00, 0x18, 0x00,\n       0x08, 0x00};\n}\nimage create bitmap tri-dn -background black -foreground blue -data {\n    #define tri-dn_width 13\n    #define tri-dn_height 13\n    static unsigned char tri-dn_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x07, 0xf8, 0x03,\n       0xf0, 0x01, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00};\n} -maskdata {\n    #define tri-dn-mask_width 13\n    #define tri-dn-mask_height 13\n    static unsigned char tri-dn-mask_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xfe, 0x0f, 0xfc, 0x07,\n       0xf8, 0x03, 0xf0, 0x01, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00};\n}\n\nimage create bitmap reficon-T -background black -foreground yellow -data {\n    #define tagicon_width 13\n    #define tagicon_height 9\n    static unsigned char tagicon_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0xf8, 0x07,\n       0xfc, 0x07, 0xf8, 0x07, 0xf0, 0x07, 0x00, 0x00, 0x00, 0x00};\n} -maskdata {\n    #define tagicon-mask_width 13\n    #define tagicon-mask_height 9\n    static unsigned char tagicon-mask_bits[] = {\n       0x00, 0x00, 0xf0, 0x0f, 0xf8, 0x0f, 0xfc, 0x0f,\n       0xfe, 0x0f, 0xfc, 0x0f, 0xf8, 0x0f, 0xf0, 0x0f, 0x00, 0x00};\n}\nset rectdata {\n    #define headicon_width 13\n    #define headicon_height 9\n    static unsigned char headicon_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0xf8, 0x07,\n       0xf8, 0x07, 0xf8, 0x07, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00};\n}\nset rectmask {\n    #define headicon-mask_width 13\n    #define headicon-mask_height 9\n    static unsigned char headicon-mask_bits[] = {\n       0x00, 0x00, 0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f,\n       0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f, 0x00, 0x00};\n}\nimage create bitmap reficon-H -background black -foreground \"#00ff00\" \\\n    -data $rectdata -maskdata $rectmask\nimage create bitmap reficon-R -background black -foreground \"#ffddaa\" \\\n    -data $rectdata -maskdata $rectmask\nimage create bitmap reficon-o -background black -foreground \"#ddddff\" \\\n    -data $rectdata -maskdata $rectmask\n\nproc init_flist {first} {\n    global cflist cflist_top difffilestart\n\n    $cflist conf -state normal\n    $cflist delete 0.0 end\n    if {$first ne {}} {\n        $cflist insert end $first\n        set cflist_top 1\n        $cflist tag add highlight 1.0 \"1.0 lineend\"\n    } else {\n        unset -nocomplain cflist_top\n    }\n    $cflist conf -state disabled\n    set difffilestart {}\n}\n\nproc highlight_tag {f} {\n    global highlight_paths\n\n    foreach p $highlight_paths {\n        if {[string match $p $f]} {\n            return \"bold\"\n        }\n    }\n    return {}\n}\n\nproc highlight_filelist {} {\n    global cmitmode cflist\n\n    $cflist conf -state normal\n    if {$cmitmode ne \"tree\"} {\n        set end [lindex [split [$cflist index end] .] 0]\n        for {set l 2} {$l < $end} {incr l} {\n            set line [$cflist get $l.0 \"$l.0 lineend\"]\n            if {[highlight_tag $line] ne {}} {\n                $cflist tag add bold $l.0 \"$l.0 lineend\"\n            }\n        }\n    } else {\n        highlight_tree 2 {}\n    }\n    $cflist conf -state disabled\n}\n\nproc unhighlight_filelist {} {\n    global cflist\n\n    $cflist conf -state normal\n    $cflist tag remove bold 1.0 end\n    $cflist conf -state disabled\n}\n\nproc add_flist {fl} {\n    global cflist\n\n    $cflist conf -state normal\n    foreach f $fl {\n        $cflist insert end \"\\n\"\n        $cflist insert end $f [highlight_tag $f]\n    }\n    $cflist conf -state disabled\n}\n\nproc sel_flist {w x y} {\n    global ctext difffilestart cflist cflist_top cmitmode\n\n    if {$cmitmode eq \"tree\"} return\n    if {![info exists cflist_top]} return\n    set l [lindex [split [$w index \"@$x,$y\"] \".\"] 0]\n    $cflist tag remove highlight $cflist_top.0 \"$cflist_top.0 lineend\"\n    $cflist tag add highlight $l.0 \"$l.0 lineend\"\n    set cflist_top $l\n    if {$l == 1} {\n        $ctext yview 1.0\n    } else {\n        catch {$ctext yview [lindex $difffilestart [expr {$l - 2}]]}\n    }\n    suppress_highlighting_file_for_current_scrollpos\n}\n\nproc pop_flist_menu {w X Y x y} {\n    global ctext cflist cmitmode flist_menu flist_menu_file\n    global treediffs diffids\n\n    stopfinding\n    set l [lindex [split [$w index \"@$x,$y\"] \".\"] 0]\n    if {$l <= 1} return\n    if {$cmitmode eq \"tree\"} {\n        set e [linetoelt $l]\n        if {[string index $e end] eq \"/\"} return\n    } else {\n        set e [lindex $treediffs($diffids) [expr {$l-2}]]\n    }\n    set flist_menu_file $e\n    set xdiffstate \"normal\"\n    if {$cmitmode eq \"tree\"} {\n        set xdiffstate \"disabled\"\n    }\n    # Disable \"External diff\" item in tree mode\n    $flist_menu entryconf 2 -state $xdiffstate\n    tk_popup $flist_menu $X $Y\n}\n\nproc find_ctext_fileinfo {line} {\n    global ctext_file_names ctext_file_lines\n\n    set ok [bsearch $ctext_file_lines $line]\n    set tline [lindex $ctext_file_lines $ok]\n\n    if {$ok >= [llength $ctext_file_lines] || $line < $tline} {\n        return {}\n    } else {\n        return [list [lindex $ctext_file_names $ok] $tline]\n    }\n}\n\nproc pop_diff_menu {w X Y x y} {\n    global ctext diff_menu flist_menu_file\n    global diff_menu_txtpos diff_menu_line\n    global diff_menu_filebase\n\n    set diff_menu_txtpos [split [$w index \"@$x,$y\"] \".\"]\n    set diff_menu_line [lindex $diff_menu_txtpos 0]\n    # don't pop up the menu on hunk-separator or file-separator lines\n    if {[lsearch -glob [$ctext tag names $diff_menu_line.0] \"*sep\"] >= 0} {\n        return\n    }\n    stopfinding\n    set f [find_ctext_fileinfo $diff_menu_line]\n    if {$f eq {}} return\n    set flist_menu_file [lindex $f 0]\n    set diff_menu_filebase [lindex $f 1]\n    tk_popup $diff_menu $X $Y\n}\n\nproc flist_hl {only} {\n    global flist_menu_file findstring gdttype\n\n    set x [shellquote $flist_menu_file]\n    if {$only || $findstring eq {} || $gdttype ne [mc \"touching paths:\"]} {\n        set findstring $x\n    } else {\n        append findstring \" \" $x\n    }\n    set gdttype [mc \"touching paths:\"]\n}\n\nproc gitknewtmpdir {} {\n    global diffnum gitktmpdir gitdir env\n\n    if {![info exists gitktmpdir]} {\n        if {[info exists env(GITK_TMPDIR)]} {\n            set tmpdir $env(GITK_TMPDIR)\n        } elseif {[info exists env(TMPDIR)]} {\n            set tmpdir $env(TMPDIR)\n        } else {\n            set tmpdir $gitdir\n        }\n        set gitktmpformat [file join $tmpdir \".gitk-tmp.XXXXXX\"]\n        if {[catch {set gitktmpdir [exec mktemp -d $gitktmpformat]}]} {\n            set gitktmpdir [file join $gitdir [format \".gitk-tmp.%s\" [pid]]]\n        }\n        if {[catch {file mkdir $gitktmpdir} err]} {\n            error_popup \"[mc \"Error creating temporary directory %s:\" $gitktmpdir] $err\"\n            unset gitktmpdir\n            return {}\n        }\n        set diffnum 0\n    }\n    incr diffnum\n    set diffdir [file join $gitktmpdir $diffnum]\n    if {[catch {file mkdir $diffdir} err]} {\n        error_popup \"[mc \"Error creating temporary directory %s:\" $diffdir] $err\"\n        return {}\n    }\n    return $diffdir\n}\n\nproc save_file_from_commit {filename output what} {\n    global nullfile\n\n    if {[catch {exec git show $filename -- > $output} err]} {\n        if {[string match \"fatal: bad revision *\" $err]} {\n            return $nullfile\n        }\n        error_popup \"[mc \"Error getting \\\"%s\\\" from %s:\" $filename $what] $err\"\n        return {}\n    }\n    return $output\n}\n\nproc external_diff_get_one_file {diffid filename diffdir} {\n    global nullid nullid2 nullfile\n    global worktree\n\n    if {$diffid == $nullid} {\n        set difffile [file join $worktree $filename]\n        if {[file exists $difffile]} {\n            return $difffile\n        }\n        return $nullfile\n    }\n    if {$diffid == $nullid2} {\n        set difffile [file join $diffdir \"\\[index\\] [file tail $filename]\"]\n        return [save_file_from_commit :$filename $difffile index]\n    }\n    set difffile [file join $diffdir \"\\[$diffid\\] [file tail $filename]\"]\n    return [save_file_from_commit $diffid:$filename $difffile \\\n               \"revision $diffid\"]\n}\n\nproc external_diff {} {\n    global nullid nullid2\n    global flist_menu_file\n    global diffids\n    global extdifftool\n\n    if {[llength $diffids] == 1} {\n        # no reference commit given\n        set diffidto [lindex $diffids 0]\n        if {$diffidto eq $nullid} {\n            # diffing working copy with index\n            set diffidfrom $nullid2\n        } elseif {$diffidto eq $nullid2} {\n            # diffing index with HEAD\n            set diffidfrom \"HEAD\"\n        } else {\n            # use first parent commit\n            global parentlist selectedline\n            set diffidfrom [lindex $parentlist $selectedline 0]\n        }\n    } else {\n        set diffidfrom [lindex $diffids 0]\n        set diffidto [lindex $diffids 1]\n    }\n\n    # make sure that several diffs wont collide\n    set diffdir [gitknewtmpdir]\n    if {$diffdir eq {}} return\n\n    # gather files to diff\n    set difffromfile [external_diff_get_one_file $diffidfrom $flist_menu_file $diffdir]\n    set difftofile [external_diff_get_one_file $diffidto $flist_menu_file $diffdir]\n\n    if {$difffromfile ne {} && $difftofile ne {}} {\n        set cmd [list [shellsplit $extdifftool] $difffromfile $difftofile]\n        if {[catch {set fl [open |$cmd r]} err]} {\n            file delete -force $diffdir\n            error_popup \"$extdifftool: [mc \"command failed:\"] $err\"\n        } else {\n            fconfigure $fl -blocking 0\n            filerun $fl [list delete_at_eof $fl $diffdir]\n        }\n    }\n}\n\nproc find_hunk_blamespec {base line} {\n    global ctext\n\n    # Find and parse the hunk header\n    set s_lix [$ctext search -backwards -regexp ^@@ \"$line.0 lineend\" $base.0]\n    if {$s_lix eq {}} return\n\n    set s_line [$ctext get $s_lix \"$s_lix + 1 lines\"]\n    if {![regexp {^@@@*(( -\\d+(,\\d+)?)+) \\+(\\d+)(,\\d+)? @@} $s_line \\\n            s_line old_specs osz osz1 new_line nsz]} {\n        return\n    }\n\n    # base lines for the parents\n    set base_lines [list $new_line]\n    foreach old_spec [lrange [split $old_specs \" \"] 1 end] {\n        if {![regexp -- {-(\\d+)(,\\d+)?} $old_spec \\\n                old_spec old_line osz]} {\n            return\n        }\n        lappend base_lines $old_line\n    }\n\n    # Now scan the lines to determine offset within the hunk\n    set max_parent [expr {[llength $base_lines]-2}]\n    set dline 0\n    set s_lno [lindex [split $s_lix \".\"] 0]\n\n    # Determine if the line is removed\n    set chunk [$ctext get $line.0 \"$line.1 + $max_parent chars\"]\n    if {[string match {[-+ ]*} $chunk]} {\n        set removed_idx [string first \"-\" $chunk]\n        # Choose a parent index\n        if {$removed_idx >= 0} {\n            set parent $removed_idx\n        } else {\n            set unchanged_idx [string first \" \" $chunk]\n            if {$unchanged_idx >= 0} {\n                set parent $unchanged_idx\n            } else {\n                # blame the current commit\n                set parent -1\n            }\n        }\n        # then count other lines that belong to it\n        for {set i $line} {[incr i -1] > $s_lno} {} {\n            set chunk [$ctext get $i.0 \"$i.1 + $max_parent chars\"]\n            # Determine if the line is removed\n            set removed_idx [string first \"-\" $chunk]\n            if {$parent >= 0} {\n                set code [string index $chunk $parent]\n                if {$code eq \"-\" || ($removed_idx < 0 && $code ne \"+\")} {\n                    incr dline\n                }\n            } else {\n                if {$removed_idx < 0} {\n                    incr dline\n                }\n            }\n        }\n        incr parent\n    } else {\n        set parent 0\n    }\n\n    incr dline [lindex $base_lines $parent]\n    return [list $parent $dline]\n}\n\nproc external_blame_diff {} {\n    global currentid cmitmode\n    global diff_menu_txtpos diff_menu_line\n    global diff_menu_filebase flist_menu_file\n\n    if {$cmitmode eq \"tree\"} {\n        set parent_idx 0\n        set line [expr {$diff_menu_line - $diff_menu_filebase}]\n    } else {\n        set hinfo [find_hunk_blamespec $diff_menu_filebase $diff_menu_line]\n        if {$hinfo ne {}} {\n            set parent_idx [lindex $hinfo 0]\n            set line [lindex $hinfo 1]\n        } else {\n            set parent_idx 0\n            set line 0\n        }\n    }\n\n    external_blame $parent_idx $line\n}\n\n# Find the SHA1 ID of the blob for file $fname in the index\n# at stage 0 or 2\nproc index_sha1 {fname} {\n    set f [open [list | git ls-files -s $fname] r]\n    while {[gets $f line] >= 0} {\n        set info [lindex [split $line \"\\t\"] 0]\n        set stage [lindex $info 2]\n        if {$stage eq \"0\" || $stage eq \"2\"} {\n            close $f\n            return [lindex $info 1]\n        }\n    }\n    close $f\n    return {}\n}\n\n# Turn an absolute path into one relative to the current directory\nproc make_relative {f} {\n    if {[file pathtype $f] eq \"relative\"} {\n        return $f\n    }\n    set elts [file split $f]\n    set here [file split [pwd]]\n    set ei 0\n    set hi 0\n    set res {}\n    foreach d $here {\n        if {$ei < $hi || $ei >= [llength $elts] || [lindex $elts $ei] ne $d} {\n            lappend res \"..\"\n        } else {\n            incr ei\n        }\n        incr hi\n    }\n    set elts [concat $res [lrange $elts $ei end]]\n    return [eval file join $elts]\n}\n\nproc external_blame {parent_idx {line {}}} {\n    global flist_menu_file cdup\n    global nullid nullid2\n    global parentlist selectedline currentid\n\n    if {$parent_idx > 0} {\n        set base_commit [lindex $parentlist $selectedline [expr {$parent_idx-1}]]\n    } else {\n        set base_commit $currentid\n    }\n\n    if {$base_commit eq {} || $base_commit eq $nullid || $base_commit eq $nullid2} {\n        error_popup [mc \"No such commit\"]\n        return\n    }\n\n    set cmdline [list git gui blame]\n    if {$line ne {} && $line > 1} {\n        lappend cmdline \"--line=$line\"\n    }\n    set f [file join $cdup $flist_menu_file]\n    # Unfortunately it seems git gui blame doesn't like\n    # being given an absolute path...\n    set f [make_relative $f]\n    lappend cmdline $base_commit $f\n    if {[catch {eval exec $cmdline &} err]} {\n        error_popup \"[mc \"git gui blame: command failed:\"] $err\"\n    }\n}\n\nproc show_line_source {} {\n    global cmitmode currentid parents curview blamestuff blameinst\n    global diff_menu_line diff_menu_filebase flist_menu_file\n    global nullid nullid2 gitdir cdup\n\n    set from_index {}\n    if {$cmitmode eq \"tree\"} {\n        set id $currentid\n        set line [expr {$diff_menu_line - $diff_menu_filebase}]\n    } else {\n        set h [find_hunk_blamespec $diff_menu_filebase $diff_menu_line]\n        if {$h eq {}} return\n        set pi [lindex $h 0]\n        if {$pi == 0} {\n            mark_ctext_line $diff_menu_line\n            return\n        }\n        incr pi -1\n        if {$currentid eq $nullid} {\n            if {$pi > 0} {\n                # must be a merge in progress...\n                if {[catch {\n                    # get the last line from .git/MERGE_HEAD\n                    set f [open [file join $gitdir MERGE_HEAD] r]\n                    set id [lindex [split [read $f] \"\\n\"] end-1]\n                    close $f\n                } err]} {\n                    error_popup [mc \"Couldn't read merge head: %s\" $err]\n                    return\n                }\n            } elseif {$parents($curview,$currentid) eq $nullid2} {\n                # need to do the blame from the index\n                if {[catch {\n                    set from_index [index_sha1 $flist_menu_file]\n                } err]} {\n                    error_popup [mc \"Error reading index: %s\" $err]\n                    return\n                }\n            } else {\n                set id $parents($curview,$currentid)\n            }\n        } else {\n            set id [lindex $parents($curview,$currentid) $pi]\n        }\n        set line [lindex $h 1]\n    }\n    set blameargs {}\n    if {$from_index ne {}} {\n        lappend blameargs | git cat-file blob $from_index\n    }\n    lappend blameargs | git blame -p -L$line,+1\n    if {$from_index ne {}} {\n        lappend blameargs --contents -\n    } else {\n        lappend blameargs $id\n    }\n    lappend blameargs -- [file join $cdup $flist_menu_file]\n    if {[catch {\n        set f [open $blameargs r]\n    } err]} {\n        error_popup [mc \"Couldn't start git blame: %s\" $err]\n        return\n    }\n    nowbusy blaming [mc \"Searching\"]\n    fconfigure $f -blocking 0\n    set i [reg_instance $f]\n    set blamestuff($i) {}\n    set blameinst $i\n    filerun $f [list read_line_source $f $i]\n}\n\nproc stopblaming {} {\n    global blameinst\n\n    if {[info exists blameinst]} {\n        stop_instance $blameinst\n        unset blameinst\n        notbusy blaming\n    }\n}\n\nproc read_line_source {fd inst} {\n    global blamestuff curview commfd blameinst nullid nullid2\n\n    while {[gets $fd line] >= 0} {\n        lappend blamestuff($inst) $line\n    }\n    if {![eof $fd]} {\n        return 1\n    }\n    unset commfd($inst)\n    unset blameinst\n    notbusy blaming\n    fconfigure $fd -blocking 1\n    if {[catch {close $fd} err]} {\n        error_popup [mc \"Error running git blame: %s\" $err]\n        return 0\n    }\n\n    set fname {}\n    set line [split [lindex $blamestuff($inst) 0] \" \"]\n    set id [lindex $line 0]\n    set lnum [lindex $line 1]\n    if {[string length $id] == 40 && [string is xdigit $id] &&\n        [string is digit -strict $lnum]} {\n        # look for \"filename\" line\n        foreach l $blamestuff($inst) {\n            if {[string match \"filename *\" $l]} {\n                set fname [string range $l 9 end]\n                break\n            }\n        }\n    }\n    if {$fname ne {}} {\n        # all looks good, select it\n        if {$id eq $nullid} {\n            # blame uses all-zeroes to mean not committed,\n            # which would mean a change in the index\n            set id $nullid2\n        }\n        if {[commitinview $id $curview]} {\n            selectline [rowofcommit $id] 1 [list $fname $lnum] 1\n        } else {\n            error_popup [mc \"That line comes from commit %s, \\\n                             which is not in this view\" [shortids $id]]\n        }\n    } else {\n        puts \"oops couldn't parse git blame output\"\n    }\n    return 0\n}\n\n# delete $dir when we see eof on $f (presumably because the child has exited)\nproc delete_at_eof {f dir} {\n    while {[gets $f line] >= 0} {}\n    if {[eof $f]} {\n        if {[catch {close $f} err]} {\n            error_popup \"[mc \"External diff viewer failed:\"] $err\"\n        }\n        file delete -force $dir\n        return 0\n    }\n    return 1\n}\n\n# Functions for adding and removing shell-type quoting\n\nproc shellquote {str} {\n    if {![string match \"*\\['\\\"\\\\ \\t]*\" $str]} {\n        return $str\n    }\n    if {![string match \"*\\['\\\"\\\\]*\" $str]} {\n        return \"\\\"$str\\\"\"\n    }\n    if {![string match \"*'*\" $str]} {\n        return \"'$str'\"\n    }\n    return \"\\\"[string map {\\\" \\\\\\\" \\\\ \\\\\\\\} $str]\\\"\"\n}\n\nproc shellarglist {l} {\n    set str {}\n    foreach a $l {\n        if {$str ne {}} {\n            append str \" \"\n        }\n        append str [shellquote $a]\n    }\n    return $str\n}\n\nproc shelldequote {str} {\n    set ret {}\n    set used -1\n    while {1} {\n        incr used\n        if {![regexp -start $used -indices \"\\['\\\"\\\\\\\\ \\t]\" $str first]} {\n            append ret [string range $str $used end]\n            set used [string length $str]\n            break\n        }\n        set first [lindex $first 0]\n        set ch [string index $str $first]\n        if {$first > $used} {\n            append ret [string range $str $used [expr {$first - 1}]]\n            set used $first\n        }\n        if {$ch eq \" \" || $ch eq \"\\t\"} break\n        incr used\n        if {$ch eq \"'\"} {\n            set first [string first \"'\" $str $used]\n            if {$first < 0} {\n                error \"unmatched single-quote\"\n            }\n            append ret [string range $str $used [expr {$first - 1}]]\n            set used $first\n            continue\n        }\n        if {$ch eq \"\\\\\"} {\n            if {$used >= [string length $str]} {\n                error \"trailing backslash\"\n            }\n            append ret [string index $str $used]\n            continue\n        }\n        # here ch == \"\\\"\"\n        while {1} {\n            if {![regexp -start $used -indices \"\\[\\\"\\\\\\\\]\" $str first]} {\n                error \"unmatched double-quote\"\n            }\n            set first [lindex $first 0]\n            set ch [string index $str $first]\n            if {$first > $used} {\n                append ret [string range $str $used [expr {$first - 1}]]\n                set used $first\n            }\n            if {$ch eq \"\\\"\"} break\n            incr used\n            append ret [string index $str $used]\n            incr used\n        }\n    }\n    return [list $used $ret]\n}\n\nproc shellsplit {str} {\n    set l {}\n    while {1} {\n        set str [string trimleft $str]\n        if {$str eq {}} break\n        set dq [shelldequote $str]\n        set n [lindex $dq 0]\n        set word [lindex $dq 1]\n        set str [string range $str $n end]\n        lappend l $word\n    }\n    return $l\n}\n\nproc set_window_title {} {\n    global appname curview viewname vrevs\n    set rev [mc \"All files\"]\n    if {$curview ne 0} {\n        if {$viewname($curview) eq [mc \"Command line\"]} {\n            set rev [string map {\"--gitk-symmetric-diff-marker\" \"--merge\"} $vrevs($curview)]\n        } else {\n            set rev $viewname($curview)\n        }\n    }\n    wm title . \"[reponame]: $rev - $appname\"\n}\n\n# Code to implement multiple views\n\nproc newview {ishighlight} {\n    global nextviewnum newviewname newishighlight\n    global revtreeargs viewargscmd newviewopts curview\n\n    set newishighlight $ishighlight\n    set top .gitkview\n    if {[winfo exists $top]} {\n        raise $top\n        return\n    }\n    decode_view_opts $nextviewnum $revtreeargs\n    set newviewname($nextviewnum) \"[mc \"View\"] $nextviewnum\"\n    set newviewopts($nextviewnum,perm) 0\n    set newviewopts($nextviewnum,cmd)  $viewargscmd($curview)\n    vieweditor $top $nextviewnum [mc \"Gitk view definition\"]\n}\n\nset known_view_options {\n    {perm      b    .  {}               {mc \"Remember this view\"}}\n    {reflabel  l    +  {}               {mc \"References (space separated list):\"}}\n    {refs      t15  .. {}               {mc \"Branches & tags:\"}}\n    {allrefs   b    *. \"--all\"          {mc \"All refs\"}}\n    {branches  b    .  \"--branches\"     {mc \"All (local) branches\"}}\n    {tags      b    .  \"--tags\"         {mc \"All tags\"}}\n    {remotes   b    .  \"--remotes\"      {mc \"All remote-tracking branches\"}}\n    {commitlbl l    +  {}               {mc \"Commit Info (regular expressions):\"}}\n    {author    t15  .. \"--author=*\"     {mc \"Author:\"}}\n    {committer t15  .  \"--committer=*\"  {mc \"Committer:\"}}\n    {loginfo   t15  .. \"--grep=*\"       {mc \"Commit Message:\"}}\n    {allmatch  b    .. \"--all-match\"    {mc \"Matches all Commit Info criteria\"}}\n    {igrep     b    .. \"--invert-grep\"  {mc \"Matches no Commit Info criteria\"}}\n    {changes_l l    +  {}               {mc \"Changes to Files:\"}}\n    {pickaxe_s r0   .  {}               {mc \"Fixed String\"}}\n    {pickaxe_t r1   .  \"--pickaxe-regex\"  {mc \"Regular Expression\"}}\n    {pickaxe   t15  .. \"-S*\"            {mc \"Search string:\"}}\n    {datelabel l    +  {}               {mc \"Commit Dates (\\\"2 weeks ago\\\", \\\"2009-03-17 15:27:38\\\", \\\"March 17, 2009 15:27:38\\\"):\"}}\n    {since     t15  ..  {\"--since=*\" \"--after=*\"}  {mc \"Since:\"}}\n    {until     t15  .   {\"--until=*\" \"--before=*\"} {mc \"Until:\"}}\n    {limit_lbl l    +  {}               {mc \"Limit and/or skip a number of revisions (positive integer):\"}}\n    {limit     t10  *. \"--max-count=*\"  {mc \"Number to show:\"}}\n    {skip      t10  .  \"--skip=*\"       {mc \"Number to skip:\"}}\n    {misc_lbl  l    +  {}               {mc \"Miscellaneous options:\"}}\n    {dorder    b    *. {\"--date-order\" \"-d\"}      {mc \"Strictly sort by date\"}}\n    {lright    b    .  \"--left-right\"   {mc \"Mark branch sides\"}}\n    {first     b    .  \"--first-parent\" {mc \"Limit to first parent\"}}\n    {smplhst   b    .  \"--simplify-by-decoration\"   {mc \"Simple history\"}}\n    {args      t50  *. {}               {mc \"Additional arguments to git log:\"}}\n    {allpaths  path +  {}               {mc \"Enter files and directories to include, one per line:\"}}\n    {cmd       t50= +  {}               {mc \"Command to generate more commits to include:\"}}\n    }\n\n# Convert $newviewopts($n, ...) into args for git log.\nproc encode_view_opts {n} {\n    global known_view_options newviewopts\n\n    set rargs [list]\n    foreach opt $known_view_options {\n        set patterns [lindex $opt 3]\n        if {$patterns eq {}} continue\n        set pattern [lindex $patterns 0]\n\n        if {[lindex $opt 1] eq \"b\"} {\n            set val $newviewopts($n,[lindex $opt 0])\n            if {$val} {\n                lappend rargs $pattern\n            }\n        } elseif {[regexp {^r(\\d+)$} [lindex $opt 1] type value]} {\n            regexp {^(.*_)} [lindex $opt 0] uselessvar button_id\n            set val $newviewopts($n,$button_id)\n            if {$val eq $value} {\n                lappend rargs $pattern\n            }\n        } else {\n            set val $newviewopts($n,[lindex $opt 0])\n            set val [string trim $val]\n            if {$val ne {}} {\n                set pfix [string range $pattern 0 end-1]\n                lappend rargs $pfix$val\n            }\n        }\n    }\n    set rargs [concat $rargs [shellsplit $newviewopts($n,refs)]]\n    return [concat $rargs [shellsplit $newviewopts($n,args)]]\n}\n\n# Fill $newviewopts($n, ...) based on args for git log.\nproc decode_view_opts {n view_args} {\n    global known_view_options newviewopts\n\n    foreach opt $known_view_options {\n        set id [lindex $opt 0]\n        if {[lindex $opt 1] eq \"b\"} {\n            # Checkboxes\n            set val 0\n        } elseif {[regexp {^r(\\d+)$} [lindex $opt 1]]} {\n            # Radiobuttons\n            regexp {^(.*_)} $id uselessvar id\n            set val 0\n        } else {\n            # Text fields\n            set val {}\n        }\n        set newviewopts($n,$id) $val\n    }\n    set oargs [list]\n    set refargs [list]\n    foreach arg $view_args {\n        if {[regexp -- {^-([0-9]+)$} $arg arg cnt]\n            && ![info exists found(limit)]} {\n            set newviewopts($n,limit) $cnt\n            set found(limit) 1\n            continue\n        }\n        catch { unset val }\n        foreach opt $known_view_options {\n            set id [lindex $opt 0]\n            if {[info exists found($id)]} continue\n            foreach pattern [lindex $opt 3] {\n                if {![string match $pattern $arg]} continue\n                if {[lindex $opt 1] eq \"b\"} {\n                    # Check buttons\n                    set val 1\n                } elseif {[regexp {^r(\\d+)$} [lindex $opt 1] match num]} {\n                    # Radio buttons\n                    regexp {^(.*_)} $id uselessvar id\n                    set val $num\n                } else {\n                    # Text input fields\n                    set size [string length $pattern]\n                    set val [string range $arg [expr {$size-1}] end]\n                }\n                set newviewopts($n,$id) $val\n                set found($id) 1\n                break\n            }\n            if {[info exists val]} break\n        }\n        if {[info exists val]} continue\n        if {[regexp {^-} $arg]} {\n            lappend oargs $arg\n        } else {\n            lappend refargs $arg\n        }\n    }\n    set newviewopts($n,refs) [shellarglist $refargs]\n    set newviewopts($n,args) [shellarglist $oargs]\n}\n\nproc edit_or_newview {} {\n    global curview\n\n    if {$curview > 0} {\n        editview\n    } else {\n        newview 0\n    }\n}\n\nproc editview {} {\n    global curview\n    global viewname viewperm newviewname newviewopts\n    global viewargs viewargscmd\n\n    set top .gitkvedit-$curview\n    if {[winfo exists $top]} {\n        raise $top\n        return\n    }\n    decode_view_opts $curview $viewargs($curview)\n    set newviewname($curview)      $viewname($curview)\n    set newviewopts($curview,perm) $viewperm($curview)\n    set newviewopts($curview,cmd)  $viewargscmd($curview)\n    vieweditor $top $curview \"[mc \"Gitk: edit view\"] $viewname($curview)\"\n}\n\nproc vieweditor {top n title} {\n    global newviewname newviewopts viewfiles bgcolor\n    global known_view_options NS\n\n    ttk_toplevel $top\n    wm title $top [concat $title [mc \"-- criteria for selecting revisions\"]]\n    make_transient $top .\n\n    # View name\n    ${NS}::frame $top.nfr\n    ${NS}::label $top.nl -text [mc \"View Name\"]\n    ${NS}::entry $top.name -width 20 -textvariable newviewname($n)\n    pack $top.nfr -in $top -fill x -pady 5 -padx 3\n    pack $top.nl -in $top.nfr -side left -padx {0 5}\n    pack $top.name -in $top.nfr -side left -padx {0 25}\n\n    # View options\n    set cframe $top.nfr\n    set cexpand 0\n    set cnt 0\n    foreach opt $known_view_options {\n        set id [lindex $opt 0]\n        set type [lindex $opt 1]\n        set flags [lindex $opt 2]\n        set title [eval [lindex $opt 4]]\n        set lxpad 0\n\n        if {$flags eq \"+\" || $flags eq \"*\"} {\n            set cframe $top.fr$cnt\n            incr cnt\n            ${NS}::frame $cframe\n            pack $cframe -in $top -fill x -pady 3 -padx 3\n            set cexpand [expr {$flags eq \"*\"}]\n        } elseif {$flags eq \"..\" || $flags eq \"*.\"} {\n            set cframe $top.fr$cnt\n            incr cnt\n            ${NS}::frame $cframe\n            pack $cframe -in $top -fill x -pady 3 -padx [list 15 3]\n            set cexpand [expr {$flags eq \"*.\"}]\n        } else {\n            set lxpad 5\n        }\n\n        if {$type eq \"l\"} {\n            ${NS}::label $cframe.l_$id -text $title\n            pack $cframe.l_$id -in $cframe -side left -pady [list 3 0] -anchor w\n        } elseif {$type eq \"b\"} {\n            ${NS}::checkbutton $cframe.c_$id -text $title -variable newviewopts($n,$id)\n            pack $cframe.c_$id -in $cframe -side left \\\n                -padx [list $lxpad 0] -expand $cexpand -anchor w\n        } elseif {[regexp {^r(\\d+)$} $type type sz]} {\n            regexp {^(.*_)} $id uselessvar button_id\n            ${NS}::radiobutton $cframe.c_$id -text $title -variable newviewopts($n,$button_id) -value $sz\n            pack $cframe.c_$id -in $cframe -side left \\\n                -padx [list $lxpad 0] -expand $cexpand -anchor w\n        } elseif {[regexp {^t(\\d+)$} $type type sz]} {\n            ${NS}::label $cframe.l_$id -text $title\n            ${NS}::entry $cframe.e_$id -width $sz -background $bgcolor \\\n                -textvariable newviewopts($n,$id)\n            pack $cframe.l_$id -in $cframe -side left -padx [list $lxpad 0]\n            pack $cframe.e_$id -in $cframe -side left -expand 1 -fill x\n        } elseif {[regexp {^t(\\d+)=$} $type type sz]} {\n            ${NS}::label $cframe.l_$id -text $title\n            ${NS}::entry $cframe.e_$id -width $sz -background $bgcolor \\\n                -textvariable newviewopts($n,$id)\n            pack $cframe.l_$id -in $cframe -side top -pady [list 3 0] -anchor w\n            pack $cframe.e_$id -in $cframe -side top -fill x\n        } elseif {$type eq \"path\"} {\n            ${NS}::label $top.l -text $title\n            pack $top.l -in $top -side top -pady [list 3 0] -anchor w -padx 3\n            text $top.t -width 40 -height 5 -background $bgcolor\n            if {[info exists viewfiles($n)]} {\n                foreach f $viewfiles($n) {\n                    $top.t insert end $f\n                    $top.t insert end \"\\n\"\n                }\n                $top.t delete {end - 1c} end\n                $top.t mark set insert 0.0\n            }\n            pack $top.t -in $top -side top -pady [list 0 5] -fill both -expand 1 -padx 3\n        }\n    }\n\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.ok -text [mc \"OK\"] -command [list newviewok $top $n]\n    ${NS}::button $top.buts.apply -text [mc \"Apply (F5)\"] -command [list newviewok $top $n 1]\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command [list destroy $top]\n    bind $top <Control-Return> [list newviewok $top $n]\n    bind $top <F5> [list newviewok $top $n 1]\n    bind $top <Escape> [list destroy $top]\n    grid $top.buts.ok $top.buts.apply $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid columnconfigure $top.buts 2 -weight 1 -uniform a\n    pack $top.buts -in $top -side top -fill x\n    focus $top.t\n}\n\nproc doviewmenu {m first cmd op argv} {\n    set nmenu [$m index end]\n    for {set i $first} {$i <= $nmenu} {incr i} {\n        if {[$m entrycget $i -command] eq $cmd} {\n            eval $m $op $i $argv\n            break\n        }\n    }\n}\n\nproc allviewmenus {n op args} {\n    # global viewhlmenu\n\n    doviewmenu .bar.view 5 [list showview $n] $op $args\n    # doviewmenu $viewhlmenu 1 [list addvhighlight $n] $op $args\n}\n\nproc newviewok {top n {apply 0}} {\n    global nextviewnum newviewperm newviewname newishighlight\n    global viewname viewfiles viewperm viewchanged selectedview curview\n    global viewargs viewargscmd newviewopts viewhlmenu\n\n    if {[catch {\n        set newargs [encode_view_opts $n]\n    } err]} {\n        error_popup \"[mc \"Error in commit selection arguments:\"] $err\" $top\n        return\n    }\n    set files {}\n    foreach f [split [$top.t get 0.0 end] \"\\n\"] {\n        set ft [string trim $f]\n        if {$ft ne {}} {\n            lappend files $ft\n        }\n    }\n    if {![info exists viewfiles($n)]} {\n        # creating a new view\n        incr nextviewnum\n        set viewname($n) $newviewname($n)\n        set viewperm($n) $newviewopts($n,perm)\n        set viewchanged($n) 1\n        set viewfiles($n) $files\n        set viewargs($n) $newargs\n        set viewargscmd($n) $newviewopts($n,cmd)\n        addviewmenu $n\n        if {!$newishighlight} {\n            run showview $n\n        } else {\n            run addvhighlight $n\n        }\n    } else {\n        # editing an existing view\n        set viewperm($n) $newviewopts($n,perm)\n        set viewchanged($n) 1\n        if {$newviewname($n) ne $viewname($n)} {\n            set viewname($n) $newviewname($n)\n            doviewmenu .bar.view 5 [list showview $n] \\\n                entryconf [list -label $viewname($n)]\n            # doviewmenu $viewhlmenu 1 [list addvhighlight $n] \\\n                # entryconf [list -label $viewname($n) -value $viewname($n)]\n        }\n        if {$files ne $viewfiles($n) || $newargs ne $viewargs($n) || \\\n                $newviewopts($n,cmd) ne $viewargscmd($n)} {\n            set viewfiles($n) $files\n            set viewargs($n) $newargs\n            set viewargscmd($n) $newviewopts($n,cmd)\n            if {$curview == $n} {\n                run reloadcommits\n            }\n        }\n    }\n    if {$apply} return\n    catch {destroy $top}\n}\n\nproc delview {} {\n    global curview viewperm hlview selectedhlview viewchanged\n\n    if {$curview == 0} return\n    if {[info exists hlview] && $hlview == $curview} {\n        set selectedhlview [mc \"None\"]\n        unset hlview\n    }\n    allviewmenus $curview delete\n    set viewperm($curview) 0\n    set viewchanged($curview) 1\n    showview 0\n}\n\nproc addviewmenu {n} {\n    global viewname viewhlmenu\n\n    .bar.view add radiobutton -label $viewname($n) \\\n        -command [list showview $n] -variable selectedview -value $n\n    #$viewhlmenu add radiobutton -label $viewname($n) \\\n    #\t-command [list addvhighlight $n] -variable selectedhlview\n}\n\nproc showview {n} {\n    global curview cached_commitrow ordertok\n    global displayorder parentlist rowidlist rowisopt rowfinal\n    global colormap rowtextx nextcolor canvxmax\n    global numcommits viewcomplete\n    global selectedline currentid canv canvy0\n    global treediffs\n    global pending_select mainheadid\n    global commitidx\n    global selectedview\n    global hlview selectedhlview commitinterest\n\n    if {$n == $curview} return\n    set selid {}\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    set span [$canv yview]\n    set ytop [expr {[lindex $span 0] * $ymax}]\n    set ybot [expr {[lindex $span 1] * $ymax}]\n    set yscreen [expr {($ybot - $ytop) / 2}]\n    if {$selectedline ne {}} {\n        set selid $currentid\n        set y [yc $selectedline]\n        if {$ytop < $y && $y < $ybot} {\n            set yscreen [expr {$y - $ytop}]\n        }\n    } elseif {[info exists pending_select]} {\n        set selid $pending_select\n        unset pending_select\n    }\n    unselectline\n    normalline\n    unset -nocomplain treediffs\n    clear_display\n    if {[info exists hlview] && $hlview == $n} {\n        unset hlview\n        set selectedhlview [mc \"None\"]\n    }\n    unset -nocomplain commitinterest\n    unset -nocomplain cached_commitrow\n    unset -nocomplain ordertok\n\n    set curview $n\n    set selectedview $n\n    .bar.view entryconf [mca \"&Edit view...\"] -state [expr {$n == 0? \"disabled\": \"normal\"}]\n    .bar.view entryconf [mca \"&Delete view\"] -state [expr {$n == 0? \"disabled\": \"normal\"}]\n\n    run refill_reflist\n    if {![info exists viewcomplete($n)]} {\n        getcommits $selid\n        return\n    }\n\n    set displayorder {}\n    set parentlist {}\n    set rowidlist {}\n    set rowisopt {}\n    set rowfinal {}\n    set numcommits $commitidx($n)\n\n    unset -nocomplain colormap\n    unset -nocomplain rowtextx\n    set nextcolor 0\n    set canvxmax [$canv cget -width]\n    set curview $n\n    set row 0\n    setcanvscroll\n    set yf 0\n    set row {}\n    if {$selid ne {} && [commitinview $selid $n]} {\n        set row [rowofcommit $selid]\n        # try to get the selected row in the same position on the screen\n        set ymax [lindex [$canv cget -scrollregion] 3]\n        set ytop [expr {[yc $row] - $yscreen}]\n        if {$ytop < 0} {\n            set ytop 0\n        }\n        set yf [expr {$ytop * 1.0 / $ymax}]\n    }\n    allcanvs yview moveto $yf\n    drawvisible\n    if {$row ne {}} {\n        selectline $row 0\n    } elseif {!$viewcomplete($n)} {\n        reset_pending_select $selid\n    } else {\n        reset_pending_select {}\n\n        if {[commitinview $pending_select $curview]} {\n            selectline [rowofcommit $pending_select] 1\n        } else {\n            set row [first_real_row]\n            if {$row < $numcommits} {\n                selectline $row 0\n            }\n        }\n    }\n    if {!$viewcomplete($n)} {\n        if {$numcommits == 0} {\n            show_status [mc \"Reading commits...\"]\n        }\n    } elseif {$numcommits == 0} {\n        show_status [mc \"No commits selected\"]\n    }\n    set_window_title\n}\n\n# Stuff relating to the highlighting facility\n\nproc ishighlighted {id} {\n    global vhighlights fhighlights nhighlights rhighlights\n\n    if {[info exists nhighlights($id)] && $nhighlights($id) > 0} {\n        return $nhighlights($id)\n    }\n    if {[info exists vhighlights($id)] && $vhighlights($id) > 0} {\n        return $vhighlights($id)\n    }\n    if {[info exists fhighlights($id)] && $fhighlights($id) > 0} {\n        return $fhighlights($id)\n    }\n    if {[info exists rhighlights($id)] && $rhighlights($id) > 0} {\n        return $rhighlights($id)\n    }\n    return 0\n}\n\nproc bolden {id font} {\n    global canv linehtag currentid boldids need_redisplay markedid\n\n    # need_redisplay = 1 means the display is stale and about to be redrawn\n    if {$need_redisplay} return\n    lappend boldids $id\n    $canv itemconf $linehtag($id) -font $font\n    if {[info exists currentid] && $id eq $currentid} {\n        $canv delete secsel\n        set t [eval $canv create rect [$canv bbox $linehtag($id)] \\\n                   -outline {{}} -tags secsel \\\n                   -fill [$canv cget -selectbackground]]\n        $canv lower $t\n    }\n    if {[info exists markedid] && $id eq $markedid} {\n        make_idmark $id\n    }\n}\n\nproc bolden_name {id font} {\n    global canv2 linentag currentid boldnameids need_redisplay\n\n    if {$need_redisplay} return\n    lappend boldnameids $id\n    $canv2 itemconf $linentag($id) -font $font\n    if {[info exists currentid] && $id eq $currentid} {\n        $canv2 delete secsel\n        set t [eval $canv2 create rect [$canv2 bbox $linentag($id)] \\\n                   -outline {{}} -tags secsel \\\n                   -fill [$canv2 cget -selectbackground]]\n        $canv2 lower $t\n    }\n}\n\nproc unbolden {} {\n    global boldids\n\n    set stillbold {}\n    foreach id $boldids {\n        if {![ishighlighted $id]} {\n            bolden $id mainfont\n        } else {\n            lappend stillbold $id\n        }\n    }\n    set boldids $stillbold\n}\n\nproc addvhighlight {n} {\n    global hlview viewcomplete curview vhl_done commitidx\n\n    if {[info exists hlview]} {\n        delvhighlight\n    }\n    set hlview $n\n    if {$n != $curview && ![info exists viewcomplete($n)]} {\n        start_rev_list $n\n    }\n    set vhl_done $commitidx($hlview)\n    if {$vhl_done > 0} {\n        drawvisible\n    }\n}\n\nproc delvhighlight {} {\n    global hlview vhighlights\n\n    if {![info exists hlview]} return\n    unset hlview\n    unset -nocomplain vhighlights\n    unbolden\n}\n\nproc vhighlightmore {} {\n    global hlview vhl_done commitidx vhighlights curview\n\n    set max $commitidx($hlview)\n    set vr [visiblerows]\n    set r0 [lindex $vr 0]\n    set r1 [lindex $vr 1]\n    for {set i $vhl_done} {$i < $max} {incr i} {\n        set id [commitonrow $i $hlview]\n        if {[commitinview $id $curview]} {\n            set row [rowofcommit $id]\n            if {$r0 <= $row && $row <= $r1} {\n                if {![highlighted $row]} {\n                    bolden $id mainfontbold\n                }\n                set vhighlights($id) 1\n            }\n        }\n    }\n    set vhl_done $max\n    return 0\n}\n\nproc askvhighlight {row id} {\n    global hlview vhighlights iddrawn\n\n    if {[commitinview $id $hlview]} {\n        if {[info exists iddrawn($id)] && ![ishighlighted $id]} {\n            bolden $id mainfontbold\n        }\n        set vhighlights($id) 1\n    } else {\n        set vhighlights($id) 0\n    }\n}\n\nproc hfiles_change {} {\n    global highlight_files filehighlight fhighlights fh_serial\n    global highlight_paths\n\n    if {[info exists filehighlight]} {\n        # delete previous highlights\n        catch {close $filehighlight}\n        unset filehighlight\n        unset -nocomplain fhighlights\n        unbolden\n        unhighlight_filelist\n    }\n    set highlight_paths {}\n    after cancel do_file_hl $fh_serial\n    incr fh_serial\n    if {$highlight_files ne {}} {\n        after 300 do_file_hl $fh_serial\n    }\n}\n\nproc gdttype_change {name ix op} {\n    global gdttype highlight_files findstring findpattern\n\n    stopfinding\n    if {$findstring ne {}} {\n        if {$gdttype eq [mc \"containing:\"]} {\n            if {$highlight_files ne {}} {\n                set highlight_files {}\n                hfiles_change\n            }\n            findcom_change\n        } else {\n            if {$findpattern ne {}} {\n                set findpattern {}\n                findcom_change\n            }\n            set highlight_files $findstring\n            hfiles_change\n        }\n        drawvisible\n    }\n    # enable/disable findtype/findloc menus too\n}\n\nproc find_change {name ix op} {\n    global gdttype findstring highlight_files\n\n    stopfinding\n    if {$gdttype eq [mc \"containing:\"]} {\n        findcom_change\n    } else {\n        if {$highlight_files ne $findstring} {\n            set highlight_files $findstring\n            hfiles_change\n        }\n    }\n    drawvisible\n}\n\nproc findcom_change args {\n    global nhighlights boldnameids\n    global findpattern findtype findstring gdttype\n\n    stopfinding\n    # delete previous highlights, if any\n    foreach id $boldnameids {\n        bolden_name $id mainfont\n    }\n    set boldnameids {}\n    unset -nocomplain nhighlights\n    unbolden\n    unmarkmatches\n    if {$gdttype ne [mc \"containing:\"] || $findstring eq {}} {\n        set findpattern {}\n    } elseif {$findtype eq [mc \"Regexp\"]} {\n        set findpattern $findstring\n    } else {\n        set e [string map {\"*\" \"\\\\*\" \"?\" \"\\\\?\" \"\\[\" \"\\\\\\[\" \"\\\\\" \"\\\\\\\\\"} \\\n                   $findstring]\n        set findpattern \"*$e*\"\n    }\n}\n\nproc makepatterns {l} {\n    set ret {}\n    foreach e $l {\n        set ee [string map {\"*\" \"\\\\*\" \"?\" \"\\\\?\" \"\\[\" \"\\\\\\[\" \"\\\\\" \"\\\\\\\\\"} $e]\n        if {[string index $ee end] eq \"/\"} {\n            lappend ret \"$ee*\"\n        } else {\n            lappend ret $ee\n            lappend ret \"$ee/*\"\n        }\n    }\n    return $ret\n}\n\nproc do_file_hl {serial} {\n    global highlight_files filehighlight highlight_paths gdttype fhl_list\n    global cdup findtype\n\n    if {$gdttype eq [mc \"touching paths:\"]} {\n        # If \"exact\" match then convert backslashes to forward slashes.\n        # Most useful to support Windows-flavoured file paths.\n        if {$findtype eq [mc \"Exact\"]} {\n            set highlight_files [string map {\"\\\\\" \"/\"} $highlight_files]\n        }\n        if {[catch {set paths [shellsplit $highlight_files]}]} return\n        set highlight_paths [makepatterns $paths]\n        highlight_filelist\n        set relative_paths {}\n        foreach path $paths {\n            lappend relative_paths [file join $cdup $path]\n        }\n        set gdtargs [concat -- $relative_paths]\n    } elseif {$gdttype eq [mc \"adding/removing string:\"]} {\n        set gdtargs [list \"-S$highlight_files\"]\n    } elseif {$gdttype eq [mc \"changing lines matching:\"]} {\n        set gdtargs [list \"-G$highlight_files\"]\n    } else {\n        # must be \"containing:\", i.e. we're searching commit info\n        return\n    }\n    set cmd [concat | git diff-tree -r -s --stdin $gdtargs]\n    set filehighlight [open $cmd r+]\n    fconfigure $filehighlight -blocking 0\n    filerun $filehighlight readfhighlight\n    set fhl_list {}\n    drawvisible\n    flushhighlights\n}\n\nproc flushhighlights {} {\n    global filehighlight fhl_list\n\n    if {[info exists filehighlight]} {\n        lappend fhl_list {}\n        puts $filehighlight \"\"\n        flush $filehighlight\n    }\n}\n\nproc askfilehighlight {row id} {\n    global filehighlight fhighlights fhl_list\n\n    lappend fhl_list $id\n    set fhighlights($id) -1\n    puts $filehighlight $id\n}\n\nproc readfhighlight {} {\n    global filehighlight fhighlights curview iddrawn\n    global fhl_list find_dirn\n\n    if {![info exists filehighlight]} {\n        return 0\n    }\n    set nr 0\n    while {[incr nr] <= 100 && [gets $filehighlight line] >= 0} {\n        set line [string trim $line]\n        set i [lsearch -exact $fhl_list $line]\n        if {$i < 0} continue\n        for {set j 0} {$j < $i} {incr j} {\n            set id [lindex $fhl_list $j]\n            set fhighlights($id) 0\n        }\n        set fhl_list [lrange $fhl_list [expr {$i+1}] end]\n        if {$line eq {}} continue\n        if {![commitinview $line $curview]} continue\n        if {[info exists iddrawn($line)] && ![ishighlighted $line]} {\n            bolden $line mainfontbold\n        }\n        set fhighlights($line) 1\n    }\n    if {[eof $filehighlight]} {\n        # strange...\n        puts \"oops, git diff-tree died\"\n        catch {close $filehighlight}\n        unset filehighlight\n        return 0\n    }\n    if {[info exists find_dirn]} {\n        run findmore\n    }\n    return 1\n}\n\nproc doesmatch {f} {\n    global findtype findpattern\n\n    if {$findtype eq [mc \"Regexp\"]} {\n        return [regexp $findpattern $f]\n    } elseif {$findtype eq [mc \"IgnCase\"]} {\n        return [string match -nocase $findpattern $f]\n    } else {\n        return [string match $findpattern $f]\n    }\n}\n\nproc askfindhighlight {row id} {\n    global nhighlights commitinfo iddrawn\n    global findloc\n    global markingmatches\n\n    if {![info exists commitinfo($id)]} {\n        getcommit $id\n    }\n    set info $commitinfo($id)\n    set isbold 0\n    set fldtypes [list [mc Headline] [mc Author] \"\" [mc Committer] \"\" [mc Comments]]\n    foreach f $info ty $fldtypes {\n        if {$ty eq \"\"} continue\n        if {($findloc eq [mc \"All fields\"] || $findloc eq $ty) &&\n            [doesmatch $f]} {\n            if {$ty eq [mc \"Author\"]} {\n                set isbold 2\n                break\n            }\n            set isbold 1\n        }\n    }\n    if {$isbold && [info exists iddrawn($id)]} {\n        if {![ishighlighted $id]} {\n            bolden $id mainfontbold\n            if {$isbold > 1} {\n                bolden_name $id mainfontbold\n            }\n        }\n        if {$markingmatches} {\n            markrowmatches $row $id\n        }\n    }\n    set nhighlights($id) $isbold\n}\n\nproc markrowmatches {row id} {\n    global canv canv2 linehtag linentag commitinfo findloc\n\n    set headline [lindex $commitinfo($id) 0]\n    set author [lindex $commitinfo($id) 1]\n    $canv delete match$row\n    $canv2 delete match$row\n    if {$findloc eq [mc \"All fields\"] || $findloc eq [mc \"Headline\"]} {\n        set m [findmatches $headline]\n        if {$m ne {}} {\n            markmatches $canv $row $headline $linehtag($id) $m \\\n                [$canv itemcget $linehtag($id) -font] $row\n        }\n    }\n    if {$findloc eq [mc \"All fields\"] || $findloc eq [mc \"Author\"]} {\n        set m [findmatches $author]\n        if {$m ne {}} {\n            markmatches $canv2 $row $author $linentag($id) $m \\\n                [$canv2 itemcget $linentag($id) -font] $row\n        }\n    }\n}\n\nproc vrel_change {name ix op} {\n    global highlight_related\n\n    rhighlight_none\n    if {$highlight_related ne [mc \"None\"]} {\n        run drawvisible\n    }\n}\n\n# prepare for testing whether commits are descendents or ancestors of a\nproc rhighlight_sel {a} {\n    global descendent desc_todo ancestor anc_todo\n    global highlight_related\n\n    unset -nocomplain descendent\n    set desc_todo [list $a]\n    unset -nocomplain ancestor\n    set anc_todo [list $a]\n    if {$highlight_related ne [mc \"None\"]} {\n        rhighlight_none\n        run drawvisible\n    }\n}\n\nproc rhighlight_none {} {\n    global rhighlights\n\n    unset -nocomplain rhighlights\n    unbolden\n}\n\nproc is_descendent {a} {\n    global curview children descendent desc_todo\n\n    set v $curview\n    set la [rowofcommit $a]\n    set todo $desc_todo\n    set leftover {}\n    set done 0\n    for {set i 0} {$i < [llength $todo]} {incr i} {\n        set do [lindex $todo $i]\n        if {[rowofcommit $do] < $la} {\n            lappend leftover $do\n            continue\n        }\n        foreach nk $children($v,$do) {\n            if {![info exists descendent($nk)]} {\n                set descendent($nk) 1\n                lappend todo $nk\n                if {$nk eq $a} {\n                    set done 1\n                }\n            }\n        }\n        if {$done} {\n            set desc_todo [concat $leftover [lrange $todo [expr {$i+1}] end]]\n            return\n        }\n    }\n    set descendent($a) 0\n    set desc_todo $leftover\n}\n\nproc is_ancestor {a} {\n    global curview parents ancestor anc_todo\n\n    set v $curview\n    set la [rowofcommit $a]\n    set todo $anc_todo\n    set leftover {}\n    set done 0\n    for {set i 0} {$i < [llength $todo]} {incr i} {\n        set do [lindex $todo $i]\n        if {![commitinview $do $v] || [rowofcommit $do] > $la} {\n            lappend leftover $do\n            continue\n        }\n        foreach np $parents($v,$do) {\n            if {![info exists ancestor($np)]} {\n                set ancestor($np) 1\n                lappend todo $np\n                if {$np eq $a} {\n                    set done 1\n                }\n            }\n        }\n        if {$done} {\n            set anc_todo [concat $leftover [lrange $todo [expr {$i+1}] end]]\n            return\n        }\n    }\n    set ancestor($a) 0\n    set anc_todo $leftover\n}\n\nproc askrelhighlight {row id} {\n    global descendent highlight_related iddrawn rhighlights\n    global selectedline ancestor\n\n    if {$selectedline eq {}} return\n    set isbold 0\n    if {$highlight_related eq [mc \"Descendant\"] ||\n        $highlight_related eq [mc \"Not descendant\"]} {\n        if {![info exists descendent($id)]} {\n            is_descendent $id\n        }\n        if {$descendent($id) == ($highlight_related eq [mc \"Descendant\"])} {\n            set isbold 1\n        }\n    } elseif {$highlight_related eq [mc \"Ancestor\"] ||\n              $highlight_related eq [mc \"Not ancestor\"]} {\n        if {![info exists ancestor($id)]} {\n            is_ancestor $id\n        }\n        if {$ancestor($id) == ($highlight_related eq [mc \"Ancestor\"])} {\n            set isbold 1\n        }\n    }\n    if {[info exists iddrawn($id)]} {\n        if {$isbold && ![ishighlighted $id]} {\n            bolden $id mainfontbold\n        }\n    }\n    set rhighlights($id) $isbold\n}\n\n# Graph layout functions\n\nproc shortids {ids} {\n    set res {}\n    foreach id $ids {\n        if {[llength $id] > 1} {\n            lappend res [shortids $id]\n        } elseif {[regexp {^[0-9a-f]{40}$} $id]} {\n            lappend res [string range $id 0 7]\n        } else {\n            lappend res $id\n        }\n    }\n    return $res\n}\n\nproc ntimes {n o} {\n    set ret {}\n    set o [list $o]\n    for {set mask 1} {$mask <= $n} {incr mask $mask} {\n        if {($n & $mask) != 0} {\n            set ret [concat $ret $o]\n        }\n        set o [concat $o $o]\n    }\n    return $ret\n}\n\nproc ordertoken {id} {\n    global ordertok curview varcid varcstart varctok curview parents children\n    global nullid nullid2\n\n    if {[info exists ordertok($id)]} {\n        return $ordertok($id)\n    }\n    set origid $id\n    set todo {}\n    while {1} {\n        if {[info exists varcid($curview,$id)]} {\n            set a $varcid($curview,$id)\n            set p [lindex $varcstart($curview) $a]\n        } else {\n            set p [lindex $children($curview,$id) 0]\n        }\n        if {[info exists ordertok($p)]} {\n            set tok $ordertok($p)\n            break\n        }\n        set id [first_real_child $curview,$p]\n        if {$id eq {}} {\n            # it's a root\n            set tok [lindex $varctok($curview) $varcid($curview,$p)]\n            break\n        }\n        if {[llength $parents($curview,$id)] == 1} {\n            lappend todo [list $p {}]\n        } else {\n            set j [lsearch -exact $parents($curview,$id) $p]\n            if {$j < 0} {\n                puts \"oops didn't find [shortids $p] in parents of [shortids $id]\"\n            }\n            lappend todo [list $p [strrep $j]]\n        }\n    }\n    for {set i [llength $todo]} {[incr i -1] >= 0} {} {\n        set p [lindex $todo $i 0]\n        append tok [lindex $todo $i 1]\n        set ordertok($p) $tok\n    }\n    set ordertok($origid) $tok\n    return $tok\n}\n\n# Work out where id should go in idlist so that order-token\n# values increase from left to right\nproc idcol {idlist id {i 0}} {\n    set t [ordertoken $id]\n    if {$i < 0} {\n        set i 0\n    }\n    if {$i >= [llength $idlist] || $t < [ordertoken [lindex $idlist $i]]} {\n        if {$i > [llength $idlist]} {\n            set i [llength $idlist]\n        }\n        while {[incr i -1] >= 0 && $t < [ordertoken [lindex $idlist $i]]} {}\n        incr i\n    } else {\n        if {$t > [ordertoken [lindex $idlist $i]]} {\n            while {[incr i] < [llength $idlist] &&\n                   $t >= [ordertoken [lindex $idlist $i]]} {}\n        }\n    }\n    return $i\n}\n\nproc initlayout {} {\n    global rowidlist rowisopt rowfinal displayorder parentlist\n    global numcommits canvxmax canv\n    global nextcolor\n    global colormap rowtextx\n\n    set numcommits 0\n    set displayorder {}\n    set parentlist {}\n    set nextcolor 0\n    set rowidlist {}\n    set rowisopt {}\n    set rowfinal {}\n    set canvxmax [$canv cget -width]\n    unset -nocomplain colormap\n    unset -nocomplain rowtextx\n    setcanvscroll\n}\n\nproc setcanvscroll {} {\n    global canv canv2 canv3 numcommits linespc canvxmax canvy0\n    global lastscrollset lastscrollrows\n\n    set ymax [expr {$canvy0 + ($numcommits - 0.5) * $linespc + 2}]\n    $canv conf -scrollregion [list 0 0 $canvxmax $ymax]\n    $canv2 conf -scrollregion [list 0 0 0 $ymax]\n    $canv3 conf -scrollregion [list 0 0 0 $ymax]\n    set lastscrollset [clock clicks -milliseconds]\n    set lastscrollrows $numcommits\n}\n\nproc visiblerows {} {\n    global canv numcommits linespc\n\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax eq {} || $ymax == 0} return\n    set f [$canv yview]\n    set y0 [expr {int([lindex $f 0] * $ymax)}]\n    set r0 [expr {int(($y0 - 3) / $linespc) - 1}]\n    if {$r0 < 0} {\n        set r0 0\n    }\n    set y1 [expr {int([lindex $f 1] * $ymax)}]\n    set r1 [expr {int(($y1 - 3) / $linespc) + 1}]\n    if {$r1 >= $numcommits} {\n        set r1 [expr {$numcommits - 1}]\n    }\n    return [list $r0 $r1]\n}\n\nproc layoutmore {} {\n    global commitidx viewcomplete curview\n    global numcommits pending_select curview\n    global lastscrollset lastscrollrows\n\n    if {$lastscrollrows < 100 || $viewcomplete($curview) ||\n        [clock clicks -milliseconds] - $lastscrollset > 500} {\n        setcanvscroll\n    }\n    if {[info exists pending_select] &&\n        [commitinview $pending_select $curview]} {\n        update\n        selectline [rowofcommit $pending_select] 1\n    }\n    drawvisible\n}\n\n# With path limiting, we mightn't get the actual HEAD commit,\n# so ask git rev-list what is the first ancestor of HEAD that\n# touches a file in the path limit.\nproc get_viewmainhead {view} {\n    global viewmainheadid vfilelimit viewinstances mainheadid\n\n    catch {\n        set rfd [open [concat | git rev-list -1 $mainheadid \\\n                           -- $vfilelimit($view)] r]\n        set j [reg_instance $rfd]\n        lappend viewinstances($view) $j\n        fconfigure $rfd -blocking 0\n        filerun $rfd [list getviewhead $rfd $j $view]\n        set viewmainheadid($curview) {}\n    }\n}\n\n# git rev-list should give us just 1 line to use as viewmainheadid($view)\nproc getviewhead {fd inst view} {\n    global viewmainheadid commfd curview viewinstances showlocalchanges\n\n    set id {}\n    if {[gets $fd line] < 0} {\n        if {![eof $fd]} {\n            return 1\n        }\n    } elseif {[string length $line] == 40 && [string is xdigit $line]} {\n        set id $line\n    }\n    set viewmainheadid($view) $id\n    close $fd\n    unset commfd($inst)\n    set i [lsearch -exact $viewinstances($view) $inst]\n    if {$i >= 0} {\n        set viewinstances($view) [lreplace $viewinstances($view) $i $i]\n    }\n    if {$showlocalchanges && $id ne {} && $view == $curview} {\n        doshowlocalchanges\n    }\n    return 0\n}\n\nproc doshowlocalchanges {} {\n    global curview viewmainheadid\n\n    if {$viewmainheadid($curview) eq {}} return\n    if {[commitinview $viewmainheadid($curview) $curview]} {\n        dodiffindex\n    } else {\n        interestedin $viewmainheadid($curview) dodiffindex\n    }\n}\n\nproc dohidelocalchanges {} {\n    global nullid nullid2 lserial curview\n\n    if {[commitinview $nullid $curview]} {\n        removefakerow $nullid\n    }\n    if {[commitinview $nullid2 $curview]} {\n        removefakerow $nullid2\n    }\n    incr lserial\n}\n\n# spawn off a process to do git diff-index --cached HEAD\nproc dodiffindex {} {\n    global lserial showlocalchanges vfilelimit curview\n    global hasworktree git_version\n\n    if {!$showlocalchanges || !$hasworktree} return\n    incr lserial\n    if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n        set cmd \"|git diff-index --cached --ignore-submodules=dirty HEAD\"\n    } else {\n        set cmd \"|git diff-index --cached HEAD\"\n    }\n    if {$vfilelimit($curview) ne {}} {\n        set cmd [concat $cmd -- $vfilelimit($curview)]\n    }\n    set fd [open $cmd r]\n    fconfigure $fd -blocking 0\n    set i [reg_instance $fd]\n    filerun $fd [list readdiffindex $fd $lserial $i]\n}\n\nproc readdiffindex {fd serial inst} {\n    global viewmainheadid nullid nullid2 curview commitinfo commitdata lserial\n    global vfilelimit\n\n    set isdiff 1\n    if {[gets $fd line] < 0} {\n        if {![eof $fd]} {\n            return 1\n        }\n        set isdiff 0\n    }\n    # we only need to see one line and we don't really care what it says...\n    stop_instance $inst\n\n    if {$serial != $lserial} {\n        return 0\n    }\n\n    # now see if there are any local changes not checked in to the index\n    set cmd \"|git diff-files\"\n    if {$vfilelimit($curview) ne {}} {\n        set cmd [concat $cmd -- $vfilelimit($curview)]\n    }\n    set fd [open $cmd r]\n    fconfigure $fd -blocking 0\n    set i [reg_instance $fd]\n    filerun $fd [list readdifffiles $fd $serial $i]\n\n    if {$isdiff && ![commitinview $nullid2 $curview]} {\n        # add the line for the changes in the index to the graph\n        set hl [mc \"Local changes checked in to index but not committed\"]\n        set commitinfo($nullid2) [list  $hl {} {} {} {} \"    $hl\\n\"]\n        set commitdata($nullid2) \"\\n    $hl\\n\"\n        if {[commitinview $nullid $curview]} {\n            removefakerow $nullid\n        }\n        insertfakerow $nullid2 $viewmainheadid($curview)\n    } elseif {!$isdiff && [commitinview $nullid2 $curview]} {\n        if {[commitinview $nullid $curview]} {\n            removefakerow $nullid\n        }\n        removefakerow $nullid2\n    }\n    return 0\n}\n\nproc readdifffiles {fd serial inst} {\n    global viewmainheadid nullid nullid2 curview\n    global commitinfo commitdata lserial\n\n    set isdiff 1\n    if {[gets $fd line] < 0} {\n        if {![eof $fd]} {\n            return 1\n        }\n        set isdiff 0\n    }\n    # we only need to see one line and we don't really care what it says...\n    stop_instance $inst\n\n    if {$serial != $lserial} {\n        return 0\n    }\n\n    if {$isdiff && ![commitinview $nullid $curview]} {\n        # add the line for the local diff to the graph\n        set hl [mc \"Local uncommitted changes, not checked in to index\"]\n        set commitinfo($nullid) [list  $hl {} {} {} {} \"    $hl\\n\"]\n        set commitdata($nullid) \"\\n    $hl\\n\"\n        if {[commitinview $nullid2 $curview]} {\n            set p $nullid2\n        } else {\n            set p $viewmainheadid($curview)\n        }\n        insertfakerow $nullid $p\n    } elseif {!$isdiff && [commitinview $nullid $curview]} {\n        removefakerow $nullid\n    }\n    return 0\n}\n\nproc nextuse {id row} {\n    global curview children\n\n    if {[info exists children($curview,$id)]} {\n        foreach kid $children($curview,$id) {\n            if {![commitinview $kid $curview]} {\n                return -1\n            }\n            if {[rowofcommit $kid] > $row} {\n                return [rowofcommit $kid]\n            }\n        }\n    }\n    if {[commitinview $id $curview]} {\n        return [rowofcommit $id]\n    }\n    return -1\n}\n\nproc prevuse {id row} {\n    global curview children\n\n    set ret -1\n    if {[info exists children($curview,$id)]} {\n        foreach kid $children($curview,$id) {\n            if {![commitinview $kid $curview]} break\n            if {[rowofcommit $kid] < $row} {\n                set ret [rowofcommit $kid]\n            }\n        }\n    }\n    return $ret\n}\n\nproc make_idlist {row} {\n    global displayorder parentlist uparrowlen downarrowlen mingaplen\n    global commitidx curview children\n\n    set r [expr {$row - $mingaplen - $downarrowlen - 1}]\n    if {$r < 0} {\n        set r 0\n    }\n    set ra [expr {$row - $downarrowlen}]\n    if {$ra < 0} {\n        set ra 0\n    }\n    set rb [expr {$row + $uparrowlen}]\n    if {$rb > $commitidx($curview)} {\n        set rb $commitidx($curview)\n    }\n    make_disporder $r [expr {$rb + 1}]\n    set ids {}\n    for {} {$r < $ra} {incr r} {\n        set nextid [lindex $displayorder [expr {$r + 1}]]\n        foreach p [lindex $parentlist $r] {\n            if {$p eq $nextid} continue\n            set rn [nextuse $p $r]\n            if {$rn >= $row &&\n                $rn <= $r + $downarrowlen + $mingaplen + $uparrowlen} {\n                lappend ids [list [ordertoken $p] $p]\n            }\n        }\n    }\n    for {} {$r < $row} {incr r} {\n        set nextid [lindex $displayorder [expr {$r + 1}]]\n        foreach p [lindex $parentlist $r] {\n            if {$p eq $nextid} continue\n            set rn [nextuse $p $r]\n            if {$rn < 0 || $rn >= $row} {\n                lappend ids [list [ordertoken $p] $p]\n            }\n        }\n    }\n    set id [lindex $displayorder $row]\n    lappend ids [list [ordertoken $id] $id]\n    while {$r < $rb} {\n        foreach p [lindex $parentlist $r] {\n            set firstkid [lindex $children($curview,$p) 0]\n            if {[rowofcommit $firstkid] < $row} {\n                lappend ids [list [ordertoken $p] $p]\n            }\n        }\n        incr r\n        set id [lindex $displayorder $r]\n        if {$id ne {}} {\n            set firstkid [lindex $children($curview,$id) 0]\n            if {$firstkid ne {} && [rowofcommit $firstkid] < $row} {\n                lappend ids [list [ordertoken $id] $id]\n            }\n        }\n    }\n    set idlist {}\n    foreach idx [lsort -unique $ids] {\n        lappend idlist [lindex $idx 1]\n    }\n    return $idlist\n}\n\nproc rowsequal {a b} {\n    while {[set i [lsearch -exact $a {}]] >= 0} {\n        set a [lreplace $a $i $i]\n    }\n    while {[set i [lsearch -exact $b {}]] >= 0} {\n        set b [lreplace $b $i $i]\n    }\n    return [expr {$a eq $b}]\n}\n\nproc makeupline {id row rend col} {\n    global rowidlist uparrowlen downarrowlen mingaplen\n\n    for {set r $rend} {1} {set r $rstart} {\n        set rstart [prevuse $id $r]\n        if {$rstart < 0} return\n        if {$rstart < $row} break\n    }\n    if {$rstart + $uparrowlen + $mingaplen + $downarrowlen < $rend} {\n        set rstart [expr {$rend - $uparrowlen - 1}]\n    }\n    for {set r $rstart} {[incr r] <= $row} {} {\n        set idlist [lindex $rowidlist $r]\n        if {$idlist ne {} && [lsearch -exact $idlist $id] < 0} {\n            set col [idcol $idlist $id $col]\n            lset rowidlist $r [linsert $idlist $col $id]\n            changedrow $r\n        }\n    }\n}\n\nproc layoutrows {row endrow} {\n    global rowidlist rowisopt rowfinal displayorder\n    global uparrowlen downarrowlen maxwidth mingaplen\n    global children parentlist\n    global commitidx viewcomplete curview\n\n    make_disporder [expr {$row - 1}] [expr {$endrow + $uparrowlen}]\n    set idlist {}\n    if {$row > 0} {\n        set rm1 [expr {$row - 1}]\n        foreach id [lindex $rowidlist $rm1] {\n            if {$id ne {}} {\n                lappend idlist $id\n            }\n        }\n        set final [lindex $rowfinal $rm1]\n    }\n    for {} {$row < $endrow} {incr row} {\n        set rm1 [expr {$row - 1}]\n        if {$rm1 < 0 || $idlist eq {}} {\n            set idlist [make_idlist $row]\n            set final 1\n        } else {\n            set id [lindex $displayorder $rm1]\n            set col [lsearch -exact $idlist $id]\n            set idlist [lreplace $idlist $col $col]\n            foreach p [lindex $parentlist $rm1] {\n                if {[lsearch -exact $idlist $p] < 0} {\n                    set col [idcol $idlist $p $col]\n                    set idlist [linsert $idlist $col $p]\n                    # if not the first child, we have to insert a line going up\n                    if {$id ne [lindex $children($curview,$p) 0]} {\n                        makeupline $p $rm1 $row $col\n                    }\n                }\n            }\n            set id [lindex $displayorder $row]\n            if {$row > $downarrowlen} {\n                set termrow [expr {$row - $downarrowlen - 1}]\n                foreach p [lindex $parentlist $termrow] {\n                    set i [lsearch -exact $idlist $p]\n                    if {$i < 0} continue\n                    set nr [nextuse $p $termrow]\n                    if {$nr < 0 || $nr >= $row + $mingaplen + $uparrowlen} {\n                        set idlist [lreplace $idlist $i $i]\n                    }\n                }\n            }\n            set col [lsearch -exact $idlist $id]\n            if {$col < 0} {\n                set col [idcol $idlist $id]\n                set idlist [linsert $idlist $col $id]\n                if {$children($curview,$id) ne {}} {\n                    makeupline $id $rm1 $row $col\n                }\n            }\n            set r [expr {$row + $uparrowlen - 1}]\n            if {$r < $commitidx($curview)} {\n                set x $col\n                foreach p [lindex $parentlist $r] {\n                    if {[lsearch -exact $idlist $p] >= 0} continue\n                    set fk [lindex $children($curview,$p) 0]\n                    if {[rowofcommit $fk] < $row} {\n                        set x [idcol $idlist $p $x]\n                        set idlist [linsert $idlist $x $p]\n                    }\n                }\n                if {[incr r] < $commitidx($curview)} {\n                    set p [lindex $displayorder $r]\n                    if {[lsearch -exact $idlist $p] < 0} {\n                        set fk [lindex $children($curview,$p) 0]\n                        if {$fk ne {} && [rowofcommit $fk] < $row} {\n                            set x [idcol $idlist $p $x]\n                            set idlist [linsert $idlist $x $p]\n                        }\n                    }\n                }\n            }\n        }\n        if {$final && !$viewcomplete($curview) &&\n            $row + $uparrowlen + $mingaplen + $downarrowlen\n                >= $commitidx($curview)} {\n            set final 0\n        }\n        set l [llength $rowidlist]\n        if {$row == $l} {\n            lappend rowidlist $idlist\n            lappend rowisopt 0\n            lappend rowfinal $final\n        } elseif {$row < $l} {\n            if {![rowsequal $idlist [lindex $rowidlist $row]]} {\n                lset rowidlist $row $idlist\n                changedrow $row\n            }\n            lset rowfinal $row $final\n        } else {\n            set pad [ntimes [expr {$row - $l}] {}]\n            set rowidlist [concat $rowidlist $pad]\n            lappend rowidlist $idlist\n            set rowfinal [concat $rowfinal $pad]\n            lappend rowfinal $final\n            set rowisopt [concat $rowisopt [ntimes [expr {$row - $l + 1}] 0]]\n        }\n    }\n    return $row\n}\n\nproc changedrow {row} {\n    global displayorder iddrawn rowisopt need_redisplay\n\n    set l [llength $rowisopt]\n    if {$row < $l} {\n        lset rowisopt $row 0\n        if {$row + 1 < $l} {\n            lset rowisopt [expr {$row + 1}] 0\n            if {$row + 2 < $l} {\n                lset rowisopt [expr {$row + 2}] 0\n            }\n        }\n    }\n    set id [lindex $displayorder $row]\n    if {[info exists iddrawn($id)]} {\n        set need_redisplay 1\n    }\n}\n\nproc insert_pad {row col npad} {\n    global rowidlist\n\n    set pad [ntimes $npad {}]\n    set idlist [lindex $rowidlist $row]\n    set bef [lrange $idlist 0 [expr {$col - 1}]]\n    set aft [lrange $idlist $col end]\n    set i [lsearch -exact $aft {}]\n    if {$i > 0} {\n        set aft [lreplace $aft $i $i]\n    }\n    lset rowidlist $row [concat $bef $pad $aft]\n    changedrow $row\n}\n\nproc optimize_rows {row col endrow} {\n    global rowidlist rowisopt displayorder curview children\n\n    if {$row < 1} {\n        set row 1\n    }\n    for {} {$row < $endrow} {incr row; set col 0} {\n        if {[lindex $rowisopt $row]} continue\n        set haspad 0\n        set y0 [expr {$row - 1}]\n        set ym [expr {$row - 2}]\n        set idlist [lindex $rowidlist $row]\n        set previdlist [lindex $rowidlist $y0]\n        if {$idlist eq {} || $previdlist eq {}} continue\n        if {$ym >= 0} {\n            set pprevidlist [lindex $rowidlist $ym]\n            if {$pprevidlist eq {}} continue\n        } else {\n            set pprevidlist {}\n        }\n        set x0 -1\n        set xm -1\n        for {} {$col < [llength $idlist]} {incr col} {\n            set id [lindex $idlist $col]\n            if {[lindex $previdlist $col] eq $id} continue\n            if {$id eq {}} {\n                set haspad 1\n                continue\n            }\n            set x0 [lsearch -exact $previdlist $id]\n            if {$x0 < 0} continue\n            set z [expr {$x0 - $col}]\n            set isarrow 0\n            set z0 {}\n            if {$ym >= 0} {\n                set xm [lsearch -exact $pprevidlist $id]\n                if {$xm >= 0} {\n                    set z0 [expr {$xm - $x0}]\n                }\n            }\n            if {$z0 eq {}} {\n                # if row y0 is the first child of $id then it's not an arrow\n                if {[lindex $children($curview,$id) 0] ne\n                    [lindex $displayorder $y0]} {\n                    set isarrow 1\n                }\n            }\n            if {!$isarrow && $id ne [lindex $displayorder $row] &&\n                [lsearch -exact [lindex $rowidlist [expr {$row+1}]] $id] < 0} {\n                set isarrow 1\n            }\n            # Looking at lines from this row to the previous row,\n            # make them go straight up if they end in an arrow on\n            # the previous row; otherwise make them go straight up\n            # or at 45 degrees.\n            if {$z < -1 || ($z < 0 && $isarrow)} {\n                # Line currently goes left too much;\n                # insert pads in the previous row, then optimize it\n                set npad [expr {-1 - $z + $isarrow}]\n                insert_pad $y0 $x0 $npad\n                if {$y0 > 0} {\n                    optimize_rows $y0 $x0 $row\n                }\n                set previdlist [lindex $rowidlist $y0]\n                set x0 [lsearch -exact $previdlist $id]\n                set z [expr {$x0 - $col}]\n                if {$z0 ne {}} {\n                    set pprevidlist [lindex $rowidlist $ym]\n                    set xm [lsearch -exact $pprevidlist $id]\n                    set z0 [expr {$xm - $x0}]\n                }\n            } elseif {$z > 1 || ($z > 0 && $isarrow)} {\n                # Line currently goes right too much;\n                # insert pads in this line\n                set npad [expr {$z - 1 + $isarrow}]\n                insert_pad $row $col $npad\n                set idlist [lindex $rowidlist $row]\n                incr col $npad\n                set z [expr {$x0 - $col}]\n                set haspad 1\n            }\n            if {$z0 eq {} && !$isarrow && $ym >= 0} {\n                # this line links to its first child on row $row-2\n                set id [lindex $displayorder $ym]\n                set xc [lsearch -exact $pprevidlist $id]\n                if {$xc >= 0} {\n                    set z0 [expr {$xc - $x0}]\n                }\n            }\n            # avoid lines jigging left then immediately right\n            if {$z0 ne {} && $z < 0 && $z0 > 0} {\n                insert_pad $y0 $x0 1\n                incr x0\n                optimize_rows $y0 $x0 $row\n                set previdlist [lindex $rowidlist $y0]\n            }\n        }\n        if {!$haspad} {\n            # Find the first column that doesn't have a line going right\n            for {set col [llength $idlist]} {[incr col -1] >= 0} {} {\n                set id [lindex $idlist $col]\n                if {$id eq {}} break\n                set x0 [lsearch -exact $previdlist $id]\n                if {$x0 < 0} {\n                    # check if this is the link to the first child\n                    set kid [lindex $displayorder $y0]\n                    if {[lindex $children($curview,$id) 0] eq $kid} {\n                        # it is, work out offset to child\n                        set x0 [lsearch -exact $previdlist $kid]\n                    }\n                }\n                if {$x0 <= $col} break\n            }\n            # Insert a pad at that column as long as it has a line and\n            # isn't the last column\n            if {$x0 >= 0 && [incr col] < [llength $idlist]} {\n                set idlist [linsert $idlist $col {}]\n                lset rowidlist $row $idlist\n                changedrow $row\n            }\n        }\n    }\n}\n\nproc xc {row col} {\n    global canvx0 linespc\n    return [expr {$canvx0 + $col * $linespc}]\n}\n\nproc yc {row} {\n    global canvy0 linespc\n    return [expr {$canvy0 + $row * $linespc}]\n}\n\nproc linewidth {id} {\n    global thickerline lthickness\n\n    set wid $lthickness\n    if {[info exists thickerline] && $id eq $thickerline} {\n        set wid [expr {2 * $lthickness}]\n    }\n    return $wid\n}\n\nproc rowranges {id} {\n    global curview children uparrowlen downarrowlen\n    global rowidlist\n\n    set kids $children($curview,$id)\n    if {$kids eq {}} {\n        return {}\n    }\n    set ret {}\n    lappend kids $id\n    foreach child $kids {\n        if {![commitinview $child $curview]} break\n        set row [rowofcommit $child]\n        if {![info exists prev]} {\n            lappend ret [expr {$row + 1}]\n        } else {\n            if {$row <= $prevrow} {\n                puts \"oops children of [shortids $id] out of order [shortids $child] $row <= [shortids $prev] $prevrow\"\n            }\n            # see if the line extends the whole way from prevrow to row\n            if {$row > $prevrow + $uparrowlen + $downarrowlen &&\n                [lsearch -exact [lindex $rowidlist \\\n                            [expr {int(($row + $prevrow) / 2)}]] $id] < 0} {\n                # it doesn't, see where it ends\n                set r [expr {$prevrow + $downarrowlen}]\n                if {[lsearch -exact [lindex $rowidlist $r] $id] < 0} {\n                    while {[incr r -1] > $prevrow &&\n                           [lsearch -exact [lindex $rowidlist $r] $id] < 0} {}\n                } else {\n                    while {[incr r] <= $row &&\n                           [lsearch -exact [lindex $rowidlist $r] $id] >= 0} {}\n                    incr r -1\n                }\n                lappend ret $r\n                # see where it starts up again\n                set r [expr {$row - $uparrowlen}]\n                if {[lsearch -exact [lindex $rowidlist $r] $id] < 0} {\n                    while {[incr r] < $row &&\n                           [lsearch -exact [lindex $rowidlist $r] $id] < 0} {}\n                } else {\n                    while {[incr r -1] >= $prevrow &&\n                           [lsearch -exact [lindex $rowidlist $r] $id] >= 0} {}\n                    incr r\n                }\n                lappend ret $r\n            }\n        }\n        if {$child eq $id} {\n            lappend ret $row\n        }\n        set prev $child\n        set prevrow $row\n    }\n    return $ret\n}\n\nproc drawlineseg {id row endrow arrowlow} {\n    global rowidlist displayorder iddrawn linesegs\n    global canv colormap linespc curview maxlinelen parentlist\n\n    set cols [list [lsearch -exact [lindex $rowidlist $row] $id]]\n    set le [expr {$row + 1}]\n    set arrowhigh 1\n    while {1} {\n        set c [lsearch -exact [lindex $rowidlist $le] $id]\n        if {$c < 0} {\n            incr le -1\n            break\n        }\n        lappend cols $c\n        set x [lindex $displayorder $le]\n        if {$x eq $id} {\n            set arrowhigh 0\n            break\n        }\n        if {[info exists iddrawn($x)] || $le == $endrow} {\n            set c [lsearch -exact [lindex $rowidlist [expr {$le+1}]] $id]\n            if {$c >= 0} {\n                lappend cols $c\n                set arrowhigh 0\n            }\n            break\n        }\n        incr le\n    }\n    if {$le <= $row} {\n        return $row\n    }\n\n    set lines {}\n    set i 0\n    set joinhigh 0\n    if {[info exists linesegs($id)]} {\n        set lines $linesegs($id)\n        foreach li $lines {\n            set r0 [lindex $li 0]\n            if {$r0 > $row} {\n                if {$r0 == $le && [lindex $li 1] - $row <= $maxlinelen} {\n                    set joinhigh 1\n                }\n                break\n            }\n            incr i\n        }\n    }\n    set joinlow 0\n    if {$i > 0} {\n        set li [lindex $lines [expr {$i-1}]]\n        set r1 [lindex $li 1]\n        if {$r1 == $row && $le - [lindex $li 0] <= $maxlinelen} {\n            set joinlow 1\n        }\n    }\n\n    set x [lindex $cols [expr {$le - $row}]]\n    set xp [lindex $cols [expr {$le - 1 - $row}]]\n    set dir [expr {$xp - $x}]\n    if {$joinhigh} {\n        set ith [lindex $lines $i 2]\n        set coords [$canv coords $ith]\n        set ah [$canv itemcget $ith -arrow]\n        set arrowhigh [expr {$ah eq \"first\" || $ah eq \"both\"}]\n        set x2 [lindex $cols [expr {$le + 1 - $row}]]\n        if {$x2 ne {} && $x - $x2 == $dir} {\n            set coords [lrange $coords 0 end-2]\n        }\n    } else {\n        set coords [list [xc $le $x] [yc $le]]\n    }\n    if {$joinlow} {\n        set itl [lindex $lines [expr {$i-1}] 2]\n        set al [$canv itemcget $itl -arrow]\n        set arrowlow [expr {$al eq \"last\" || $al eq \"both\"}]\n    } elseif {$arrowlow} {\n        if {[lsearch -exact [lindex $rowidlist [expr {$row-1}]] $id] >= 0 ||\n            [lsearch -exact [lindex $parentlist [expr {$row-1}]] $id] >= 0} {\n            set arrowlow 0\n        }\n    }\n    set arrow [lindex {none first last both} [expr {$arrowhigh + 2*$arrowlow}]]\n    for {set y $le} {[incr y -1] > $row} {} {\n        set x $xp\n        set xp [lindex $cols [expr {$y - 1 - $row}]]\n        set ndir [expr {$xp - $x}]\n        if {$dir != $ndir || $xp < 0} {\n            lappend coords [xc $y $x] [yc $y]\n        }\n        set dir $ndir\n    }\n    if {!$joinlow} {\n        if {$xp < 0} {\n            # join parent line to first child\n            set ch [lindex $displayorder $row]\n            set xc [lsearch -exact [lindex $rowidlist $row] $ch]\n            if {$xc < 0} {\n                puts \"oops: drawlineseg: child $ch not on row $row\"\n            } elseif {$xc != $x} {\n                if {($arrowhigh && $le == $row + 1) || $dir == 0} {\n                    set d [expr {int(0.5 * $linespc)}]\n                    set x1 [xc $row $x]\n                    if {$xc < $x} {\n                        set x2 [expr {$x1 - $d}]\n                    } else {\n                        set x2 [expr {$x1 + $d}]\n                    }\n                    set y2 [yc $row]\n                    set y1 [expr {$y2 + $d}]\n                    lappend coords $x1 $y1 $x2 $y2\n                } elseif {$xc < $x - 1} {\n                    lappend coords [xc $row [expr {$x-1}]] [yc $row]\n                } elseif {$xc > $x + 1} {\n                    lappend coords [xc $row [expr {$x+1}]] [yc $row]\n                }\n                set x $xc\n            }\n            lappend coords [xc $row $x] [yc $row]\n        } else {\n            set xn [xc $row $xp]\n            set yn [yc $row]\n            lappend coords $xn $yn\n        }\n        if {!$joinhigh} {\n            assigncolor $id\n            set t [$canv create line $coords -width [linewidth $id] \\\n                       -fill $colormap($id) -tags lines.$id -arrow $arrow]\n            $canv lower $t\n            bindline $t $id\n            set lines [linsert $lines $i [list $row $le $t]]\n        } else {\n            $canv coords $ith $coords\n            if {$arrow ne $ah} {\n                $canv itemconf $ith -arrow $arrow\n            }\n            lset lines $i 0 $row\n        }\n    } else {\n        set xo [lsearch -exact [lindex $rowidlist [expr {$row - 1}]] $id]\n        set ndir [expr {$xo - $xp}]\n        set clow [$canv coords $itl]\n        if {$dir == $ndir} {\n            set clow [lrange $clow 2 end]\n        }\n        set coords [concat $coords $clow]\n        if {!$joinhigh} {\n            lset lines [expr {$i-1}] 1 $le\n        } else {\n            # coalesce two pieces\n            $canv delete $ith\n            set b [lindex $lines [expr {$i-1}] 0]\n            set e [lindex $lines $i 1]\n            set lines [lreplace $lines [expr {$i-1}] $i [list $b $e $itl]]\n        }\n        $canv coords $itl $coords\n        if {$arrow ne $al} {\n            $canv itemconf $itl -arrow $arrow\n        }\n    }\n\n    set linesegs($id) $lines\n    return $le\n}\n\nproc drawparentlinks {id row} {\n    global rowidlist canv colormap curview parentlist\n    global idpos linespc\n\n    set rowids [lindex $rowidlist $row]\n    set col [lsearch -exact $rowids $id]\n    if {$col < 0} return\n    set olds [lindex $parentlist $row]\n    set row2 [expr {$row + 1}]\n    set x [xc $row $col]\n    set y [yc $row]\n    set y2 [yc $row2]\n    set d [expr {int(0.5 * $linespc)}]\n    set ymid [expr {$y + $d}]\n    set ids [lindex $rowidlist $row2]\n    # rmx = right-most X coord used\n    set rmx 0\n    foreach p $olds {\n        set i [lsearch -exact $ids $p]\n        if {$i < 0} {\n            puts \"oops, parent $p of $id not in list\"\n            continue\n        }\n        set x2 [xc $row2 $i]\n        if {$x2 > $rmx} {\n            set rmx $x2\n        }\n        set j [lsearch -exact $rowids $p]\n        if {$j < 0} {\n            # drawlineseg will do this one for us\n            continue\n        }\n        assigncolor $p\n        # should handle duplicated parents here...\n        set coords [list $x $y]\n        if {$i != $col} {\n            # if attaching to a vertical segment, draw a smaller\n            # slant for visual distinctness\n            if {$i == $j} {\n                if {$i < $col} {\n                    lappend coords [expr {$x2 + $d}] $y $x2 $ymid\n                } else {\n                    lappend coords [expr {$x2 - $d}] $y $x2 $ymid\n                }\n            } elseif {$i < $col && $i < $j} {\n                # segment slants towards us already\n                lappend coords [xc $row $j] $y\n            } else {\n                if {$i < $col - 1} {\n                    lappend coords [expr {$x2 + $linespc}] $y\n                } elseif {$i > $col + 1} {\n                    lappend coords [expr {$x2 - $linespc}] $y\n                }\n                lappend coords $x2 $y2\n            }\n        } else {\n            lappend coords $x2 $y2\n        }\n        set t [$canv create line $coords -width [linewidth $p] \\\n                   -fill $colormap($p) -tags lines.$p]\n        $canv lower $t\n        bindline $t $p\n    }\n    if {$rmx > [lindex $idpos($id) 1]} {\n        lset idpos($id) 1 $rmx\n        redrawtags $id\n    }\n}\n\nproc drawlines {id} {\n    global canv\n\n    $canv itemconf lines.$id -width [linewidth $id]\n}\n\nproc drawcmittext {id row col} {\n    global linespc canv canv2 canv3 fgcolor curview\n    global cmitlisted commitinfo rowidlist parentlist\n    global rowtextx idpos idtags idheads idotherrefs\n    global linehtag linentag linedtag selectedline\n    global canvxmax boldids boldnameids fgcolor markedid\n    global mainheadid nullid nullid2 circleitem circlecolors ctxbut\n    global mainheadcirclecolor workingfilescirclecolor indexcirclecolor\n    global circleoutlinecolor\n\n    # listed is 0 for boundary, 1 for normal, 2 for negative, 3 for left, 4 for right\n    set listed $cmitlisted($curview,$id)\n    if {$id eq $nullid} {\n        set ofill $workingfilescirclecolor\n    } elseif {$id eq $nullid2} {\n        set ofill $indexcirclecolor\n    } elseif {$id eq $mainheadid} {\n        set ofill $mainheadcirclecolor\n    } else {\n        set ofill [lindex $circlecolors $listed]\n    }\n    set x [xc $row $col]\n    set y [yc $row]\n    set orad [expr {$linespc / 3}]\n    if {$listed <= 2} {\n        set t [$canv create oval [expr {$x - $orad}] [expr {$y - $orad}] \\\n                   [expr {$x + $orad - 1}] [expr {$y + $orad - 1}] \\\n                   -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]\n    } elseif {$listed == 3} {\n        # triangle pointing left for left-side commits\n        set t [$canv create polygon \\\n                   [expr {$x - $orad}] $y \\\n                   [expr {$x + $orad - 1}] [expr {$y - $orad}] \\\n                   [expr {$x + $orad - 1}] [expr {$y + $orad - 1}] \\\n                   -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]\n    } else {\n        # triangle pointing right for right-side commits\n        set t [$canv create polygon \\\n                   [expr {$x + $orad - 1}] $y \\\n                   [expr {$x - $orad}] [expr {$y - $orad}] \\\n                   [expr {$x - $orad}] [expr {$y + $orad - 1}] \\\n                   -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]\n    }\n    set circleitem($row) $t\n    $canv raise $t\n    $canv bind $t <1> {selcanvline {} %x %y}\n    set rmx [llength [lindex $rowidlist $row]]\n    set olds [lindex $parentlist $row]\n    if {$olds ne {}} {\n        set nextids [lindex $rowidlist [expr {$row + 1}]]\n        foreach p $olds {\n            set i [lsearch -exact $nextids $p]\n            if {$i > $rmx} {\n                set rmx $i\n            }\n        }\n    }\n    set xt [xc $row $rmx]\n    set rowtextx($row) $xt\n    set idpos($id) [list $x $xt $y]\n    if {[info exists idtags($id)] || [info exists idheads($id)]\n        || [info exists idotherrefs($id)]} {\n        set xt [drawtags $id $x $xt $y]\n    }\n    if {[lindex $commitinfo($id) 6] > 0} {\n        set xt [drawnotesign $xt $y]\n    }\n    set headline [lindex $commitinfo($id) 0]\n    set name [lindex $commitinfo($id) 1]\n    set date [lindex $commitinfo($id) 2]\n    set date [formatdate $date]\n    set font mainfont\n    set nfont mainfont\n    set isbold [ishighlighted $id]\n    if {$isbold > 0} {\n        lappend boldids $id\n        set font mainfontbold\n        if {$isbold > 1} {\n            lappend boldnameids $id\n            set nfont mainfontbold\n        }\n    }\n    set linehtag($id) [$canv create text $xt $y -anchor w -fill $fgcolor \\\n                           -text $headline -font $font -tags text]\n    $canv bind $linehtag($id) $ctxbut \"rowmenu %X %Y $id\"\n    set linentag($id) [$canv2 create text 3 $y -anchor w -fill $fgcolor \\\n                           -text $name -font $nfont -tags text]\n    set linedtag($id) [$canv3 create text 3 $y -anchor w -fill $fgcolor \\\n                           -text $date -font mainfont -tags text]\n    if {$selectedline == $row} {\n        make_secsel $id\n    }\n    if {[info exists markedid] && $markedid eq $id} {\n        make_idmark $id\n    }\n    set xr [expr {$xt + [font measure $font $headline]}]\n    if {$xr > $canvxmax} {\n        set canvxmax $xr\n        setcanvscroll\n    }\n}\n\nproc drawcmitrow {row} {\n    global displayorder rowidlist nrows_drawn\n    global iddrawn markingmatches\n    global commitinfo numcommits\n    global filehighlight fhighlights findpattern nhighlights\n    global hlview vhighlights\n    global highlight_related rhighlights\n\n    if {$row >= $numcommits} return\n\n    set id [lindex $displayorder $row]\n    if {[info exists hlview] && ![info exists vhighlights($id)]} {\n        askvhighlight $row $id\n    }\n    if {[info exists filehighlight] && ![info exists fhighlights($id)]} {\n        askfilehighlight $row $id\n    }\n    if {$findpattern ne {} && ![info exists nhighlights($id)]} {\n        askfindhighlight $row $id\n    }\n    if {$highlight_related ne [mc \"None\"] && ![info exists rhighlights($id)]} {\n        askrelhighlight $row $id\n    }\n    if {![info exists iddrawn($id)]} {\n        set col [lsearch -exact [lindex $rowidlist $row] $id]\n        if {$col < 0} {\n            puts \"oops, row $row id $id not in list\"\n            return\n        }\n        if {![info exists commitinfo($id)]} {\n            getcommit $id\n        }\n        assigncolor $id\n        drawcmittext $id $row $col\n        set iddrawn($id) 1\n        incr nrows_drawn\n    }\n    if {$markingmatches} {\n        markrowmatches $row $id\n    }\n}\n\nproc drawcommits {row {endrow {}}} {\n    global numcommits iddrawn displayorder curview need_redisplay\n    global parentlist rowidlist rowfinal uparrowlen downarrowlen nrows_drawn\n\n    if {$row < 0} {\n        set row 0\n    }\n    if {$endrow eq {}} {\n        set endrow $row\n    }\n    if {$endrow >= $numcommits} {\n        set endrow [expr {$numcommits - 1}]\n    }\n\n    set rl1 [expr {$row - $downarrowlen - 3}]\n    if {$rl1 < 0} {\n        set rl1 0\n    }\n    set ro1 [expr {$row - 3}]\n    if {$ro1 < 0} {\n        set ro1 0\n    }\n    set r2 [expr {$endrow + $uparrowlen + 3}]\n    if {$r2 > $numcommits} {\n        set r2 $numcommits\n    }\n    for {set r $rl1} {$r < $r2} {incr r} {\n        if {[lindex $rowidlist $r] ne {} && [lindex $rowfinal $r]} {\n            if {$rl1 < $r} {\n                layoutrows $rl1 $r\n            }\n            set rl1 [expr {$r + 1}]\n        }\n    }\n    if {$rl1 < $r} {\n        layoutrows $rl1 $r\n    }\n    optimize_rows $ro1 0 $r2\n    if {$need_redisplay || $nrows_drawn > 2000} {\n        clear_display\n    }\n\n    # make the lines join to already-drawn rows either side\n    set r [expr {$row - 1}]\n    if {$r < 0 || ![info exists iddrawn([lindex $displayorder $r])]} {\n        set r $row\n    }\n    set er [expr {$endrow + 1}]\n    if {$er >= $numcommits ||\n        ![info exists iddrawn([lindex $displayorder $er])]} {\n        set er $endrow\n    }\n    for {} {$r <= $er} {incr r} {\n        set id [lindex $displayorder $r]\n        set wasdrawn [info exists iddrawn($id)]\n        drawcmitrow $r\n        if {$r == $er} break\n        set nextid [lindex $displayorder [expr {$r + 1}]]\n        if {$wasdrawn && [info exists iddrawn($nextid)]} continue\n        drawparentlinks $id $r\n\n        set rowids [lindex $rowidlist $r]\n        foreach lid $rowids {\n            if {$lid eq {}} continue\n            if {[info exists lineend($lid)] && $lineend($lid) > $r} continue\n            if {$lid eq $id} {\n                # see if this is the first child of any of its parents\n                foreach p [lindex $parentlist $r] {\n                    if {[lsearch -exact $rowids $p] < 0} {\n                        # make this line extend up to the child\n                        set lineend($p) [drawlineseg $p $r $er 0]\n                    }\n                }\n            } else {\n                set lineend($lid) [drawlineseg $lid $r $er 1]\n            }\n        }\n    }\n}\n\nproc undolayout {row} {\n    global uparrowlen mingaplen downarrowlen\n    global rowidlist rowisopt rowfinal need_redisplay\n\n    set r [expr {$row - ($uparrowlen + $mingaplen + $downarrowlen)}]\n    if {$r < 0} {\n        set r 0\n    }\n    if {[llength $rowidlist] > $r} {\n        incr r -1\n        set rowidlist [lrange $rowidlist 0 $r]\n        set rowfinal [lrange $rowfinal 0 $r]\n        set rowisopt [lrange $rowisopt 0 $r]\n        set need_redisplay 1\n        run drawvisible\n    }\n}\n\nproc drawvisible {} {\n    global canv linespc curview vrowmod selectedline targetrow targetid\n    global need_redisplay cscroll numcommits\n\n    set fs [$canv yview]\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax eq {} || $ymax == 0 || $numcommits == 0} return\n    set f0 [lindex $fs 0]\n    set f1 [lindex $fs 1]\n    set y0 [expr {int($f0 * $ymax)}]\n    set y1 [expr {int($f1 * $ymax)}]\n\n    if {[info exists targetid]} {\n        if {[commitinview $targetid $curview]} {\n            set r [rowofcommit $targetid]\n            if {$r != $targetrow} {\n                # Fix up the scrollregion and change the scrolling position\n                # now that our target row has moved.\n                set diff [expr {($r - $targetrow) * $linespc}]\n                set targetrow $r\n                setcanvscroll\n                set ymax [lindex [$canv cget -scrollregion] 3]\n                incr y0 $diff\n                incr y1 $diff\n                set f0 [expr {$y0 / $ymax}]\n                set f1 [expr {$y1 / $ymax}]\n                allcanvs yview moveto $f0\n                $cscroll set $f0 $f1\n                set need_redisplay 1\n            }\n        } else {\n            unset targetid\n        }\n    }\n\n    set row [expr {int(($y0 - 3) / $linespc) - 1}]\n    set endrow [expr {int(($y1 - 3) / $linespc) + 1}]\n    if {$endrow >= $vrowmod($curview)} {\n        update_arcrows $curview\n    }\n    if {$selectedline ne {} &&\n        $row <= $selectedline && $selectedline <= $endrow} {\n        set targetrow $selectedline\n    } elseif {[info exists targetid]} {\n        set targetrow [expr {int(($row + $endrow) / 2)}]\n    }\n    if {[info exists targetrow]} {\n        if {$targetrow >= $numcommits} {\n            set targetrow [expr {$numcommits - 1}]\n        }\n        set targetid [commitonrow $targetrow]\n    }\n    drawcommits $row $endrow\n}\n\nproc clear_display {} {\n    global iddrawn linesegs need_redisplay nrows_drawn\n    global vhighlights fhighlights nhighlights rhighlights\n    global linehtag linentag linedtag boldids boldnameids\n\n    allcanvs delete all\n    unset -nocomplain iddrawn\n    unset -nocomplain linesegs\n    unset -nocomplain linehtag\n    unset -nocomplain linentag\n    unset -nocomplain linedtag\n    set boldids {}\n    set boldnameids {}\n    unset -nocomplain vhighlights\n    unset -nocomplain fhighlights\n    unset -nocomplain nhighlights\n    unset -nocomplain rhighlights\n    set need_redisplay 0\n    set nrows_drawn 0\n}\n\nproc findcrossings {id} {\n    global rowidlist parentlist numcommits displayorder\n\n    set cross {}\n    set ccross {}\n    foreach {s e} [rowranges $id] {\n        if {$e >= $numcommits} {\n            set e [expr {$numcommits - 1}]\n        }\n        if {$e <= $s} continue\n        for {set row $e} {[incr row -1] >= $s} {} {\n            set x [lsearch -exact [lindex $rowidlist $row] $id]\n            if {$x < 0} break\n            set olds [lindex $parentlist $row]\n            set kid [lindex $displayorder $row]\n            set kidx [lsearch -exact [lindex $rowidlist $row] $kid]\n            if {$kidx < 0} continue\n            set nextrow [lindex $rowidlist [expr {$row + 1}]]\n            foreach p $olds {\n                set px [lsearch -exact $nextrow $p]\n                if {$px < 0} continue\n                if {($kidx < $x && $x < $px) || ($px < $x && $x < $kidx)} {\n                    if {[lsearch -exact $ccross $p] >= 0} continue\n                    if {$x == $px + ($kidx < $px? -1: 1)} {\n                        lappend ccross $p\n                    } elseif {[lsearch -exact $cross $p] < 0} {\n                        lappend cross $p\n                    }\n                }\n            }\n        }\n    }\n    return [concat $ccross {{}} $cross]\n}\n\nproc assigncolor {id} {\n    global colormap colors nextcolor\n    global parents children children curview\n\n    if {[info exists colormap($id)]} return\n    set ncolors [llength $colors]\n    if {[info exists children($curview,$id)]} {\n        set kids $children($curview,$id)\n    } else {\n        set kids {}\n    }\n    if {[llength $kids] == 1} {\n        set child [lindex $kids 0]\n        if {[info exists colormap($child)]\n            && [llength $parents($curview,$child)] == 1} {\n            set colormap($id) $colormap($child)\n            return\n        }\n    }\n    set badcolors {}\n    set origbad {}\n    foreach x [findcrossings $id] {\n        if {$x eq {}} {\n            # delimiter between corner crossings and other crossings\n            if {[llength $badcolors] >= $ncolors - 1} break\n            set origbad $badcolors\n        }\n        if {[info exists colormap($x)]\n            && [lsearch -exact $badcolors $colormap($x)] < 0} {\n            lappend badcolors $colormap($x)\n        }\n    }\n    if {[llength $badcolors] >= $ncolors} {\n        set badcolors $origbad\n    }\n    set origbad $badcolors\n    if {[llength $badcolors] < $ncolors - 1} {\n        foreach child $kids {\n            if {[info exists colormap($child)]\n                && [lsearch -exact $badcolors $colormap($child)] < 0} {\n                lappend badcolors $colormap($child)\n            }\n            foreach p $parents($curview,$child) {\n                if {[info exists colormap($p)]\n                    && [lsearch -exact $badcolors $colormap($p)] < 0} {\n                    lappend badcolors $colormap($p)\n                }\n            }\n        }\n        if {[llength $badcolors] >= $ncolors} {\n            set badcolors $origbad\n        }\n    }\n    for {set i 0} {$i <= $ncolors} {incr i} {\n        set c [lindex $colors $nextcolor]\n        if {[incr nextcolor] >= $ncolors} {\n            set nextcolor 0\n        }\n        if {[lsearch -exact $badcolors $c]} break\n    }\n    set colormap($id) $c\n}\n\nproc bindline {t id} {\n    global canv\n\n    $canv bind $t <Enter> \"lineenter %x %y $id\"\n    $canv bind $t <Motion> \"linemotion %x %y $id\"\n    $canv bind $t <Leave> \"lineleave $id\"\n    $canv bind $t <Button-1> \"lineclick %x %y $id 1\"\n}\n\nproc graph_pane_width {} {\n    global use_ttk\n\n    if {$use_ttk} {\n        set g [.tf.histframe.pwclist sashpos 0]\n    } else {\n        set g [.tf.histframe.pwclist sash coord 0]\n    }\n    return [lindex $g 0]\n}\n\nproc totalwidth {l font extra} {\n    set tot 0\n    foreach str $l {\n        set tot [expr {$tot + [font measure $font $str] + $extra}]\n    }\n    return $tot\n}\n\nproc drawtags {id x xt y1} {\n    global idtags idheads idotherrefs mainhead\n    global linespc lthickness\n    global canv rowtextx curview fgcolor bgcolor ctxbut\n    global headbgcolor headfgcolor headoutlinecolor remotebgcolor\n    global tagbgcolor tagfgcolor tagoutlinecolor\n    global reflinecolor\n\n    set marks {}\n    set ntags 0\n    set nheads 0\n    set singletag 0\n    set maxtags 3\n    set maxtagpct 25\n    set maxwidth [expr {[graph_pane_width] * $maxtagpct / 100}]\n    set delta [expr {int(0.5 * ($linespc - $lthickness))}]\n    set extra [expr {$delta + $lthickness + $linespc}]\n\n    if {[info exists idtags($id)]} {\n        set marks $idtags($id)\n        set ntags [llength $marks]\n        if {$ntags > $maxtags ||\n            [totalwidth $marks mainfont $extra] > $maxwidth} {\n            # show just a single \"n tags...\" tag\n            set singletag 1\n            if {$ntags == 1} {\n                set marks [list \"tag...\"]\n            } else {\n                set marks [list [format \"%d tags...\" $ntags]]\n            }\n            set ntags 1\n        }\n    }\n    if {[info exists idheads($id)]} {\n        set marks [concat $marks $idheads($id)]\n        set nheads [llength $idheads($id)]\n    }\n    if {[info exists idotherrefs($id)]} {\n        set marks [concat $marks $idotherrefs($id)]\n    }\n    if {$marks eq {}} {\n        return $xt\n    }\n\n    set yt [expr {$y1 - 0.5 * $linespc}]\n    set yb [expr {$yt + $linespc - 1}]\n    set xvals {}\n    set wvals {}\n    set i -1\n    foreach tag $marks {\n        incr i\n        if {$i >= $ntags && $i < $ntags + $nheads && $tag eq $mainhead} {\n            set wid [font measure mainfontbold $tag]\n        } else {\n            set wid [font measure mainfont $tag]\n        }\n        lappend xvals $xt\n        lappend wvals $wid\n        set xt [expr {$xt + $wid + $extra}]\n    }\n    set t [$canv create line $x $y1 [lindex $xvals end] $y1 \\\n               -width $lthickness -fill $reflinecolor -tags tag.$id]\n    $canv lower $t\n    foreach tag $marks x $xvals wid $wvals {\n        set tag_quoted [string map {% %%} $tag]\n        set xl [expr {$x + $delta}]\n        set xr [expr {$x + $delta + $wid + $lthickness}]\n        set font mainfont\n        if {[incr ntags -1] >= 0} {\n            # draw a tag\n            set t [$canv create polygon $x [expr {$yt + $delta}] $xl $yt \\\n                       $xr $yt $xr $yb $xl $yb $x [expr {$yb - $delta}] \\\n                       -width 1 -outline $tagoutlinecolor -fill $tagbgcolor \\\n                       -tags tag.$id]\n            if {$singletag} {\n                set tagclick [list showtags $id 1]\n            } else {\n                set tagclick [list showtag $tag_quoted 1]\n            }\n            $canv bind $t <1> $tagclick\n            set rowtextx([rowofcommit $id]) [expr {$xr + $linespc}]\n        } else {\n            # draw a head or other ref\n            if {[incr nheads -1] >= 0} {\n                set col $headbgcolor\n                if {$tag eq $mainhead} {\n                    set font mainfontbold\n                }\n            } else {\n                set col \"#ddddff\"\n            }\n            set xl [expr {$xl - $delta/2}]\n            $canv create polygon $x $yt $xr $yt $xr $yb $x $yb \\\n                -width 1 -outline black -fill $col -tags tag.$id\n            if {[regexp {^(remotes/.*/|remotes/)} $tag match remoteprefix]} {\n                set rwid [font measure mainfont $remoteprefix]\n                set xi [expr {$x + 1}]\n                set yti [expr {$yt + 1}]\n                set xri [expr {$x + $rwid}]\n                $canv create polygon $xi $yti $xri $yti $xri $yb $xi $yb \\\n                        -width 0 -fill $remotebgcolor -tags tag.$id\n            }\n        }\n        set t [$canv create text $xl $y1 -anchor w -text $tag -fill $headfgcolor \\\n                   -font $font -tags [list tag.$id text]]\n        if {$ntags >= 0} {\n            $canv bind $t <1> $tagclick\n        } elseif {$nheads >= 0} {\n            $canv bind $t $ctxbut [list headmenu %X %Y $id $tag_quoted]\n        }\n    }\n    return $xt\n}\n\nproc drawnotesign {xt y} {\n    global linespc canv fgcolor\n\n    set orad [expr {$linespc / 3}]\n    set t [$canv create rectangle [expr {$xt - $orad}] [expr {$y - $orad}] \\\n               [expr {$xt + $orad - 1}] [expr {$y + $orad - 1}] \\\n               -fill yellow -outline $fgcolor -width 1 -tags circle]\n    set xt [expr {$xt + $orad * 3}]\n    return $xt\n}\n\nproc xcoord {i level ln} {\n    global canvx0 xspc1 xspc2\n\n    set x [expr {$canvx0 + $i * $xspc1($ln)}]\n    if {$i > 0 && $i == $level} {\n        set x [expr {$x + 0.5 * ($xspc2 - $xspc1($ln))}]\n    } elseif {$i > $level} {\n        set x [expr {$x + $xspc2 - $xspc1($ln)}]\n    }\n    return $x\n}\n\nproc show_status {msg} {\n    global canv fgcolor\n\n    clear_display\n    set_window_title\n    $canv create text 3 3 -anchor nw -text $msg -font mainfont \\\n        -tags text -fill $fgcolor\n}\n\n# Don't change the text pane cursor if it is currently the hand cursor,\n# showing that we are over a sha1 ID link.\nproc settextcursor {c} {\n    global ctext curtextcursor\n\n    if {[$ctext cget -cursor] == $curtextcursor} {\n        $ctext config -cursor $c\n    }\n    set curtextcursor $c\n}\n\nproc nowbusy {what {name {}}} {\n    global isbusy busyname statusw\n\n    if {[array names isbusy] eq {}} {\n        . config -cursor watch\n        settextcursor watch\n    }\n    set isbusy($what) 1\n    set busyname($what) $name\n    if {$name ne {}} {\n        $statusw conf -text $name\n    }\n}\n\nproc notbusy {what} {\n    global isbusy maincursor textcursor busyname statusw\n\n    catch {\n        unset isbusy($what)\n        if {$busyname($what) ne {} &&\n            [$statusw cget -text] eq $busyname($what)} {\n            $statusw conf -text {}\n        }\n    }\n    if {[array names isbusy] eq {}} {\n        . config -cursor $maincursor\n        settextcursor $textcursor\n    }\n}\n\nproc findmatches {f} {\n    global findtype findstring\n    if {$findtype == [mc \"Regexp\"]} {\n        set matches [regexp -indices -all -inline $findstring $f]\n    } else {\n        set fs $findstring\n        if {$findtype == [mc \"IgnCase\"]} {\n            set f [string tolower $f]\n            set fs [string tolower $fs]\n        }\n        set matches {}\n        set i 0\n        set l [string length $fs]\n        while {[set j [string first $fs $f $i]] >= 0} {\n            lappend matches [list $j [expr {$j+$l-1}]]\n            set i [expr {$j + $l}]\n        }\n    }\n    return $matches\n}\n\nproc dofind {{dirn 1} {wrap 1}} {\n    global findstring findstartline findcurline selectedline numcommits\n    global gdttype filehighlight fh_serial find_dirn findallowwrap\n\n    if {[info exists find_dirn]} {\n        if {$find_dirn == $dirn} return\n        stopfinding\n    }\n    focus .\n    if {$findstring eq {} || $numcommits == 0} return\n    if {$selectedline eq {}} {\n        set findstartline [lindex [visiblerows] [expr {$dirn < 0}]]\n    } else {\n        set findstartline $selectedline\n    }\n    set findcurline $findstartline\n    nowbusy finding [mc \"Searching\"]\n    if {$gdttype ne [mc \"containing:\"] && ![info exists filehighlight]} {\n        after cancel do_file_hl $fh_serial\n        do_file_hl $fh_serial\n    }\n    set find_dirn $dirn\n    set findallowwrap $wrap\n    run findmore\n}\n\nproc stopfinding {} {\n    global find_dirn findcurline fprogcoord\n\n    if {[info exists find_dirn]} {\n        unset find_dirn\n        unset findcurline\n        notbusy finding\n        set fprogcoord 0\n        adjustprogress\n    }\n    stopblaming\n}\n\nproc findmore {} {\n    global commitdata commitinfo numcommits findpattern findloc\n    global findstartline findcurline findallowwrap\n    global find_dirn gdttype fhighlights fprogcoord\n    global curview varcorder vrownum varccommits vrowmod\n\n    if {![info exists find_dirn]} {\n        return 0\n    }\n    set fldtypes [list [mc \"Headline\"] [mc \"Author\"] \"\" [mc \"Committer\"] \"\" [mc \"Comments\"]]\n    set l $findcurline\n    set moretodo 0\n    if {$find_dirn > 0} {\n        incr l\n        if {$l >= $numcommits} {\n            set l 0\n        }\n        if {$l <= $findstartline} {\n            set lim [expr {$findstartline + 1}]\n        } else {\n            set lim $numcommits\n            set moretodo $findallowwrap\n        }\n    } else {\n        if {$l == 0} {\n            set l $numcommits\n        }\n        incr l -1\n        if {$l >= $findstartline} {\n            set lim [expr {$findstartline - 1}]\n        } else {\n            set lim -1\n            set moretodo $findallowwrap\n        }\n    }\n    set n [expr {($lim - $l) * $find_dirn}]\n    if {$n > 500} {\n        set n 500\n        set moretodo 1\n    }\n    if {$l + ($find_dirn > 0? $n: 1) > $vrowmod($curview)} {\n        update_arcrows $curview\n    }\n    set found 0\n    set domore 1\n    set ai [bsearch $vrownum($curview) $l]\n    set a [lindex $varcorder($curview) $ai]\n    set arow [lindex $vrownum($curview) $ai]\n    set ids [lindex $varccommits($curview,$a)]\n    set arowend [expr {$arow + [llength $ids]}]\n    if {$gdttype eq [mc \"containing:\"]} {\n        for {} {$n > 0} {incr n -1; incr l $find_dirn} {\n            if {$l < $arow || $l >= $arowend} {\n                incr ai $find_dirn\n                set a [lindex $varcorder($curview) $ai]\n                set arow [lindex $vrownum($curview) $ai]\n                set ids [lindex $varccommits($curview,$a)]\n                set arowend [expr {$arow + [llength $ids]}]\n            }\n            set id [lindex $ids [expr {$l - $arow}]]\n            # shouldn't happen unless git log doesn't give all the commits...\n            if {![info exists commitdata($id)] ||\n                ![doesmatch $commitdata($id)]} {\n                continue\n            }\n            if {![info exists commitinfo($id)]} {\n                getcommit $id\n            }\n            set info $commitinfo($id)\n            foreach f $info ty $fldtypes {\n                if {$ty eq \"\"} continue\n                if {($findloc eq [mc \"All fields\"] || $findloc eq $ty) &&\n                    [doesmatch $f]} {\n                    set found 1\n                    break\n                }\n            }\n            if {$found} break\n        }\n    } else {\n        for {} {$n > 0} {incr n -1; incr l $find_dirn} {\n            if {$l < $arow || $l >= $arowend} {\n                incr ai $find_dirn\n                set a [lindex $varcorder($curview) $ai]\n                set arow [lindex $vrownum($curview) $ai]\n                set ids [lindex $varccommits($curview,$a)]\n                set arowend [expr {$arow + [llength $ids]}]\n            }\n            set id [lindex $ids [expr {$l - $arow}]]\n            if {![info exists fhighlights($id)]} {\n                # this sets fhighlights($id) to -1\n                askfilehighlight $l $id\n            }\n            if {$fhighlights($id) > 0} {\n                set found $domore\n                break\n            }\n            if {$fhighlights($id) < 0} {\n                if {$domore} {\n                    set domore 0\n                    set findcurline [expr {$l - $find_dirn}]\n                }\n            }\n        }\n    }\n    if {$found || ($domore && !$moretodo)} {\n        unset findcurline\n        unset find_dirn\n        notbusy finding\n        set fprogcoord 0\n        adjustprogress\n        if {$found} {\n            findselectline $l\n        } else {\n            bell\n        }\n        return 0\n    }\n    if {!$domore} {\n        flushhighlights\n    } else {\n        set findcurline [expr {$l - $find_dirn}]\n    }\n    set n [expr {($findcurline - $findstartline) * $find_dirn - 1}]\n    if {$n < 0} {\n        incr n $numcommits\n    }\n    set fprogcoord [expr {$n * 1.0 / $numcommits}]\n    adjustprogress\n    return $domore\n}\n\nproc findselectline {l} {\n    global findloc commentend ctext findcurline markingmatches gdttype\n\n    set markingmatches [expr {$gdttype eq [mc \"containing:\"]}]\n    set findcurline $l\n    selectline $l 1\n    if {$markingmatches &&\n        ($findloc eq [mc \"All fields\"] || $findloc eq [mc \"Comments\"])} {\n        # highlight the matches in the comments\n        set f [$ctext get 1.0 $commentend]\n        set matches [findmatches $f]\n        foreach match $matches {\n            set start [lindex $match 0]\n            set end [expr {[lindex $match 1] + 1}]\n            $ctext tag add found \"1.0 + $start c\" \"1.0 + $end c\"\n        }\n    }\n    drawvisible\n}\n\n# mark the bits of a headline or author that match a find string\nproc markmatches {canv l str tag matches font row} {\n    global selectedline\n\n    set bbox [$canv bbox $tag]\n    set x0 [lindex $bbox 0]\n    set y0 [lindex $bbox 1]\n    set y1 [lindex $bbox 3]\n    foreach match $matches {\n        set start [lindex $match 0]\n        set end [lindex $match 1]\n        if {$start > $end} continue\n        set xoff [font measure $font [string range $str 0 [expr {$start-1}]]]\n        set xlen [font measure $font [string range $str 0 [expr {$end}]]]\n        set t [$canv create rect [expr {$x0+$xoff}] $y0 \\\n                   [expr {$x0+$xlen+2}] $y1 \\\n                   -outline {} -tags [list match$l matches] -fill yellow]\n        $canv lower $t\n        if {$row == $selectedline} {\n            $canv raise $t secsel\n        }\n    }\n}\n\nproc unmarkmatches {} {\n    global markingmatches\n\n    allcanvs delete matches\n    set markingmatches 0\n    stopfinding\n}\n\nproc selcanvline {w x y} {\n    global canv canvy0 ctext linespc\n    global rowtextx\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax == {}} return\n    set yfrac [lindex [$canv yview] 0]\n    set y [expr {$y + $yfrac * $ymax}]\n    set l [expr {int(($y - $canvy0) / $linespc + 0.5)}]\n    if {$l < 0} {\n        set l 0\n    }\n    if {$w eq $canv} {\n        set xmax [lindex [$canv cget -scrollregion] 2]\n        set xleft [expr {[lindex [$canv xview] 0] * $xmax}]\n        if {![info exists rowtextx($l)] || $xleft + $x < $rowtextx($l)} return\n    }\n    unmarkmatches\n    selectline $l 1\n}\n\nproc commit_descriptor {p} {\n    global commitinfo\n    if {![info exists commitinfo($p)]} {\n        getcommit $p\n    }\n    set l \"...\"\n    if {[llength $commitinfo($p)] > 1} {\n        set l [lindex $commitinfo($p) 0]\n    }\n    return \"$p ($l)\\n\"\n}\n\n# append some text to the ctext widget, and make any SHA1 ID\n# that we know about be a clickable link.\n# Also look for URLs of the form \"http[s]://...\" and make them web links.\nproc appendwithlinks {text tags} {\n    global ctext linknum curview\n\n    set start [$ctext index \"end - 1c\"]\n    $ctext insert end $text $tags\n    set links [regexp -indices -all -inline {(?:\\m|-g)[0-9a-f]{6,40}\\M} $text]\n    foreach l $links {\n        set s [lindex $l 0]\n        set e [lindex $l 1]\n        set linkid [string range $text $s $e]\n        incr e\n        $ctext tag delete link$linknum\n        $ctext tag add link$linknum \"$start + $s c\" \"$start + $e c\"\n        setlink $linkid link$linknum\n        incr linknum\n    }\n    set wlinks [regexp -indices -all -inline -line \\\n                    {https?://[^[:space:]]+} $text]\n    foreach l $wlinks {\n        set s2 [lindex $l 0]\n        set e2 [lindex $l 1]\n        set url [string range $text $s2 $e2]\n        incr e2\n        $ctext tag delete link$linknum\n        $ctext tag add link$linknum \"$start + $s2 c\" \"$start + $e2 c\"\n        setwlink $url link$linknum\n        incr linknum\n    }\n}\n\nproc setlink {id lk} {\n    global curview ctext pendinglinks\n    global linkfgcolor\n\n    if {[string range $id 0 1] eq \"-g\"} {\n      set id [string range $id 2 end]\n    }\n\n    set known 0\n    if {[string length $id] < 40} {\n        set matches [longid $id]\n        if {[llength $matches] > 0} {\n            if {[llength $matches] > 1} return\n            set known 1\n            set id [lindex $matches 0]\n        }\n    } else {\n        set known [commitinview $id $curview]\n    }\n    if {$known} {\n        $ctext tag conf $lk -foreground $linkfgcolor -underline 1\n        $ctext tag bind $lk <1> [list selbyid $id]\n        $ctext tag bind $lk <Enter> {linkcursor %W 1}\n        $ctext tag bind $lk <Leave> {linkcursor %W -1}\n    } else {\n        lappend pendinglinks($id) $lk\n        interestedin $id {makelink %P}\n    }\n}\n\nproc setwlink {url lk} {\n    global ctext\n    global linkfgcolor\n    global web_browser\n\n    if {$web_browser eq {}} return\n    $ctext tag conf $lk -foreground $linkfgcolor -underline 1\n    $ctext tag bind $lk <1> [list browseweb $url]\n    $ctext tag bind $lk <Enter> {linkcursor %W 1}\n    $ctext tag bind $lk <Leave> {linkcursor %W -1}\n}\n\nproc appendshortlink {id {pre {}} {post {}}} {\n    global ctext linknum\n\n    $ctext insert end $pre\n    $ctext tag delete link$linknum\n    $ctext insert end [string range $id 0 7] link$linknum\n    $ctext insert end $post\n    setlink $id link$linknum\n    incr linknum\n}\n\nproc makelink {id} {\n    global pendinglinks\n\n    if {![info exists pendinglinks($id)]} return\n    foreach lk $pendinglinks($id) {\n        setlink $id $lk\n    }\n    unset pendinglinks($id)\n}\n\nproc linkcursor {w inc} {\n    global linkentercount curtextcursor\n\n    if {[incr linkentercount $inc] > 0} {\n        $w configure -cursor hand2\n    } else {\n        $w configure -cursor $curtextcursor\n        if {$linkentercount < 0} {\n            set linkentercount 0\n        }\n    }\n}\n\nproc browseweb {url} {\n    global web_browser\n\n    if {$web_browser eq {}} return\n    # Use eval here in case $web_browser is a command plus some arguments\n    if {[catch {eval exec $web_browser [list $url] &} err]} {\n        error_popup \"[mc \"Error starting web browser:\"] $err\"\n    }\n}\n\nproc viewnextline {dir} {\n    global canv linespc\n\n    $canv delete hover\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    set wnow [$canv yview]\n    set wtop [expr {[lindex $wnow 0] * $ymax}]\n    set newtop [expr {$wtop + $dir * $linespc}]\n    if {$newtop < 0} {\n        set newtop 0\n    } elseif {$newtop > $ymax} {\n        set newtop $ymax\n    }\n    allcanvs yview moveto [expr {$newtop * 1.0 / $ymax}]\n}\n\n# add a list of tag or branch names at position pos\n# returns the number of names inserted\nproc appendrefs {pos ids var} {\n    global ctext linknum curview $var maxrefs visiblerefs mainheadid\n\n    if {[catch {$ctext index $pos}]} {\n        return 0\n    }\n    $ctext conf -state normal\n    $ctext delete $pos \"$pos lineend\"\n    set tags {}\n    foreach id $ids {\n        foreach tag [set $var\\($id\\)] {\n            lappend tags [list $tag $id]\n        }\n    }\n\n    set sep {}\n    set tags [lsort -index 0 -decreasing $tags]\n    set nutags 0\n\n    if {[llength $tags] > $maxrefs} {\n        # If we are displaying heads, and there are too many,\n        # see if there are some important heads to display.\n        # Currently that are the current head and heads listed in $visiblerefs option\n        set itags {}\n        if {$var eq \"idheads\"} {\n            set utags {}\n            foreach ti $tags {\n                set hname [lindex $ti 0]\n                set id [lindex $ti 1]\n                if {([lsearch -exact $visiblerefs $hname] != -1 || $id eq $mainheadid) &&\n                    [llength $itags] < $maxrefs} {\n                    lappend itags $ti\n                } else {\n                    lappend utags $ti\n                }\n            }\n            set tags $utags\n        }\n        if {$itags ne {}} {\n            set str [mc \"and many more\"]\n            set sep \" \"\n        } else {\n            set str [mc \"many\"]\n        }\n        $ctext insert $pos \"$str ([llength $tags])\"\n        set nutags [llength $tags]\n        set tags $itags\n    }\n\n    foreach ti $tags {\n        set id [lindex $ti 1]\n        set lk link$linknum\n        incr linknum\n        $ctext tag delete $lk\n        $ctext insert $pos $sep\n        $ctext insert $pos [lindex $ti 0] $lk\n        setlink $id $lk\n        set sep \", \"\n    }\n    $ctext tag add wwrap \"$pos linestart\" \"$pos lineend\"\n    $ctext conf -state disabled\n    return [expr {[llength $tags] + $nutags}]\n}\n\n# called when we have finished computing the nearby tags\nproc dispneartags {delay} {\n    global selectedline currentid showneartags tagphase\n\n    if {$selectedline eq {} || !$showneartags} return\n    after cancel dispnexttag\n    if {$delay} {\n        after 200 dispnexttag\n        set tagphase -1\n    } else {\n        after idle dispnexttag\n        set tagphase 0\n    }\n}\n\nproc dispnexttag {} {\n    global selectedline currentid showneartags tagphase ctext\n\n    if {$selectedline eq {} || !$showneartags} return\n    switch -- $tagphase {\n        0 {\n            set dtags [desctags $currentid]\n            if {$dtags ne {}} {\n                appendrefs precedes $dtags idtags\n            }\n        }\n        1 {\n            set atags [anctags $currentid]\n            if {$atags ne {}} {\n                appendrefs follows $atags idtags\n            }\n        }\n        2 {\n            set dheads [descheads $currentid]\n            if {$dheads ne {}} {\n                if {[appendrefs branch $dheads idheads] > 1\n                    && [$ctext get \"branch -3c\"] eq \"h\"} {\n                    # turn \"Branch\" into \"Branches\"\n                    $ctext conf -state normal\n                    $ctext insert \"branch -2c\" \"es\"\n                    $ctext conf -state disabled\n                }\n            }\n        }\n    }\n    if {[incr tagphase] <= 2} {\n        after idle dispnexttag\n    }\n}\n\nproc make_secsel {id} {\n    global linehtag linentag linedtag canv canv2 canv3\n\n    if {![info exists linehtag($id)]} return\n    $canv delete secsel\n    set t [eval $canv create rect [$canv bbox $linehtag($id)] -outline {{}} \\\n               -tags secsel -fill [$canv cget -selectbackground]]\n    $canv lower $t\n    $canv2 delete secsel\n    set t [eval $canv2 create rect [$canv2 bbox $linentag($id)] -outline {{}} \\\n               -tags secsel -fill [$canv2 cget -selectbackground]]\n    $canv2 lower $t\n    $canv3 delete secsel\n    set t [eval $canv3 create rect [$canv3 bbox $linedtag($id)] -outline {{}} \\\n               -tags secsel -fill [$canv3 cget -selectbackground]]\n    $canv3 lower $t\n}\n\nproc make_idmark {id} {\n    global linehtag canv fgcolor\n\n    if {![info exists linehtag($id)]} return\n    $canv delete markid\n    set t [eval $canv create rect [$canv bbox $linehtag($id)] \\\n               -tags markid -outline $fgcolor]\n    $canv raise $t\n}\n\nproc selectline {l isnew {desired_loc {}} {switch_to_patch 0}} {\n    global canv ctext commitinfo selectedline\n    global canvy0 linespc parents children curview\n    global currentid sha1entry\n    global commentend idtags linknum\n    global mergemax numcommits pending_select\n    global cmitmode showneartags allcommits\n    global targetrow targetid lastscrollrows\n    global autoselect autosellen jump_to_here\n    global vinlinediff\n\n    unset -nocomplain pending_select\n    $canv delete hover\n    normalline\n    unsel_reflist\n    stopfinding\n    if {$l < 0 || $l >= $numcommits} return\n    set id [commitonrow $l]\n    set targetid $id\n    set targetrow $l\n    set selectedline $l\n    set currentid $id\n    if {$lastscrollrows < $numcommits} {\n        setcanvscroll\n    }\n\n    if {$cmitmode ne \"patch\" && $switch_to_patch} {\n        set cmitmode \"patch\"\n    }\n\n    set y [expr {$canvy0 + $l * $linespc}]\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    set ytop [expr {$y - $linespc - 1}]\n    set ybot [expr {$y + $linespc + 1}]\n    set wnow [$canv yview]\n    set wtop [expr {[lindex $wnow 0] * $ymax}]\n    set wbot [expr {[lindex $wnow 1] * $ymax}]\n    set wh [expr {$wbot - $wtop}]\n    set newtop $wtop\n    if {$ytop < $wtop} {\n        if {$ybot < $wtop} {\n            set newtop [expr {$y - $wh / 2.0}]\n        } else {\n            set newtop $ytop\n            if {$newtop > $wtop - $linespc} {\n                set newtop [expr {$wtop - $linespc}]\n            }\n        }\n    } elseif {$ybot > $wbot} {\n        if {$ytop > $wbot} {\n            set newtop [expr {$y - $wh / 2.0}]\n        } else {\n            set newtop [expr {$ybot - $wh}]\n            if {$newtop < $wtop + $linespc} {\n                set newtop [expr {$wtop + $linespc}]\n            }\n        }\n    }\n    if {$newtop != $wtop} {\n        if {$newtop < 0} {\n            set newtop 0\n        }\n        allcanvs yview moveto [expr {$newtop * 1.0 / $ymax}]\n        drawvisible\n    }\n\n    make_secsel $id\n\n    if {$isnew} {\n        addtohistory [list selbyid $id 0] savecmitpos\n    }\n\n    $sha1entry delete 0 end\n    $sha1entry insert 0 $id\n    if {$autoselect} {\n        $sha1entry selection range 0 $autosellen\n    }\n    rhighlight_sel $id\n\n    $ctext conf -state normal\n    clear_ctext\n    set linknum 0\n    if {![info exists commitinfo($id)]} {\n        getcommit $id\n    }\n    set info $commitinfo($id)\n    set date [formatdate [lindex $info 2]]\n    $ctext insert end \"[mc \"Author\"]: [lindex $info 1]  $date\\n\"\n    set date [formatdate [lindex $info 4]]\n    $ctext insert end \"[mc \"Committer\"]: [lindex $info 3]  $date\\n\"\n    if {[info exists idtags($id)]} {\n        $ctext insert end [mc \"Tags:\"]\n        foreach tag $idtags($id) {\n            $ctext insert end \" $tag\"\n        }\n        $ctext insert end \"\\n\"\n    }\n\n    set headers {}\n    set olds $parents($curview,$id)\n    if {[llength $olds] > 1} {\n        set np 0\n        foreach p $olds {\n            if {$np >= $mergemax} {\n                set tag mmax\n            } else {\n                set tag m$np\n            }\n            $ctext insert end \"[mc \"Parent\"]: \" $tag\n            appendwithlinks [commit_descriptor $p] {}\n            incr np\n        }\n    } else {\n        foreach p $olds {\n            append headers \"[mc \"Parent\"]: [commit_descriptor $p]\"\n        }\n    }\n\n    foreach c $children($curview,$id) {\n        append headers \"[mc \"Child\"]:  [commit_descriptor $c]\"\n    }\n\n    # make anything that looks like a SHA1 ID be a clickable link\n    appendwithlinks $headers {}\n    if {$showneartags} {\n        if {![info exists allcommits]} {\n            getallcommits\n        }\n        $ctext insert end \"[mc \"Branch\"]: \"\n        $ctext mark set branch \"end -1c\"\n        $ctext mark gravity branch left\n        $ctext insert end \"\\n[mc \"Follows\"]: \"\n        $ctext mark set follows \"end -1c\"\n        $ctext mark gravity follows left\n        $ctext insert end \"\\n[mc \"Precedes\"]: \"\n        $ctext mark set precedes \"end -1c\"\n        $ctext mark gravity precedes left\n        $ctext insert end \"\\n\"\n        dispneartags 1\n    }\n    $ctext insert end \"\\n\"\n    set comment [lindex $info 5]\n    if {[string first \"\\r\" $comment] >= 0} {\n        set comment [string map {\"\\r\" \"\\n    \"} $comment]\n    }\n    appendwithlinks $comment {comment}\n\n    $ctext tag remove found 1.0 end\n    $ctext conf -state disabled\n    set commentend [$ctext index \"end - 1c\"]\n\n    set jump_to_here $desired_loc\n    init_flist [mc \"Comments\"]\n    if {$cmitmode eq \"tree\"} {\n        gettree $id\n    } elseif {$vinlinediff($curview) == 1} {\n        showinlinediff $id\n    } elseif {[llength $olds] <= 1} {\n        startdiff $id\n    } else {\n        mergediff $id\n    }\n}\n\nproc selfirstline {} {\n    unmarkmatches\n    selectline 0 1\n}\n\nproc sellastline {} {\n    global numcommits\n    unmarkmatches\n    set l [expr {$numcommits - 1}]\n    selectline $l 1\n}\n\nproc selnextline {dir} {\n    global selectedline\n    focus .\n    if {$selectedline eq {}} return\n    set l [expr {$selectedline + $dir}]\n    unmarkmatches\n    selectline $l 1\n}\n\nproc selnextpage {dir} {\n    global canv linespc selectedline numcommits\n\n    set lpp [expr {([winfo height $canv] - 2) / $linespc}]\n    if {$lpp < 1} {\n        set lpp 1\n    }\n    allcanvs yview scroll [expr {$dir * $lpp}] units\n    drawvisible\n    if {$selectedline eq {}} return\n    set l [expr {$selectedline + $dir * $lpp}]\n    if {$l < 0} {\n        set l 0\n    } elseif {$l >= $numcommits} {\n        set l [expr $numcommits - 1]\n    }\n    unmarkmatches\n    selectline $l 1\n}\n\nproc unselectline {} {\n    global selectedline currentid\n\n    set selectedline {}\n    unset -nocomplain currentid\n    allcanvs delete secsel\n    rhighlight_none\n}\n\nproc reselectline {} {\n    global selectedline\n\n    if {$selectedline ne {}} {\n        selectline $selectedline 0\n    }\n}\n\nproc addtohistory {cmd {saveproc {}}} {\n    global history historyindex curview\n\n    unset_posvars\n    save_position\n    set elt [list $curview $cmd $saveproc {}]\n    if {$historyindex > 0\n        && [lindex $history [expr {$historyindex - 1}]] == $elt} {\n        return\n    }\n\n    if {$historyindex < [llength $history]} {\n        set history [lreplace $history $historyindex end $elt]\n    } else {\n        lappend history $elt\n    }\n    incr historyindex\n    if {$historyindex > 1} {\n        .tf.bar.leftbut conf -state normal\n    } else {\n        .tf.bar.leftbut conf -state disabled\n    }\n    .tf.bar.rightbut conf -state disabled\n}\n\n# save the scrolling position of the diff display pane\nproc save_position {} {\n    global historyindex history\n\n    if {$historyindex < 1} return\n    set hi [expr {$historyindex - 1}]\n    set fn [lindex $history $hi 2]\n    if {$fn ne {}} {\n        lset history $hi 3 [eval $fn]\n    }\n}\n\nproc unset_posvars {} {\n    global last_posvars\n\n    if {[info exists last_posvars]} {\n        foreach {var val} $last_posvars {\n            global $var\n            unset -nocomplain $var\n        }\n        unset last_posvars\n    }\n}\n\nproc godo {elt} {\n    global curview last_posvars\n\n    set view [lindex $elt 0]\n    set cmd [lindex $elt 1]\n    set pv [lindex $elt 3]\n    if {$curview != $view} {\n        showview $view\n    }\n    unset_posvars\n    foreach {var val} $pv {\n        global $var\n        set $var $val\n    }\n    set last_posvars $pv\n    eval $cmd\n}\n\nproc goback {} {\n    global history historyindex\n    focus .\n\n    if {$historyindex > 1} {\n        save_position\n        incr historyindex -1\n        godo [lindex $history [expr {$historyindex - 1}]]\n        .tf.bar.rightbut conf -state normal\n    }\n    if {$historyindex <= 1} {\n        .tf.bar.leftbut conf -state disabled\n    }\n}\n\nproc goforw {} {\n    global history historyindex\n    focus .\n\n    if {$historyindex < [llength $history]} {\n        save_position\n        set cmd [lindex $history $historyindex]\n        incr historyindex\n        godo $cmd\n        .tf.bar.leftbut conf -state normal\n    }\n    if {$historyindex >= [llength $history]} {\n        .tf.bar.rightbut conf -state disabled\n    }\n}\n\nproc go_to_parent {i} {\n    global parents curview targetid\n    set ps $parents($curview,$targetid)\n    if {[llength $ps] >= $i} {\n        selbyid [lindex $ps [expr $i - 1]]\n    }\n}\n\nproc gettree {id} {\n    global treefilelist treeidlist diffids diffmergeid treepending\n    global nullid nullid2\n\n    set diffids $id\n    unset -nocomplain diffmergeid\n    if {![info exists treefilelist($id)]} {\n        if {![info exists treepending]} {\n            if {$id eq $nullid} {\n                set cmd [list | git ls-files]\n            } elseif {$id eq $nullid2} {\n                set cmd [list | git ls-files --stage -t]\n            } else {\n                set cmd [list | git ls-tree -r $id]\n            }\n            if {[catch {set gtf [open $cmd r]}]} {\n                return\n            }\n            set treepending $id\n            set treefilelist($id) {}\n            set treeidlist($id) {}\n            fconfigure $gtf -blocking 0 -encoding binary\n            filerun $gtf [list gettreeline $gtf $id]\n        }\n    } else {\n        setfilelist $id\n    }\n}\n\nproc gettreeline {gtf id} {\n    global treefilelist treeidlist treepending cmitmode diffids nullid nullid2\n\n    set nl 0\n    while {[incr nl] <= 1000 && [gets $gtf line] >= 0} {\n        if {$diffids eq $nullid} {\n            set fname $line\n        } else {\n            set i [string first \"\\t\" $line]\n            if {$i < 0} continue\n            set fname [string range $line [expr {$i+1}] end]\n            set line [string range $line 0 [expr {$i-1}]]\n            if {$diffids ne $nullid2 && [lindex $line 1] ne \"blob\"} continue\n            set sha1 [lindex $line 2]\n            lappend treeidlist($id) $sha1\n        }\n        if {[string index $fname 0] eq \"\\\"\"} {\n            set fname [lindex $fname 0]\n        }\n        set fname [encoding convertfrom utf-8 $fname]\n        lappend treefilelist($id) $fname\n    }\n    if {![eof $gtf]} {\n        return [expr {$nl >= 1000? 2: 1}]\n    }\n    close $gtf\n    unset treepending\n    if {$cmitmode ne \"tree\"} {\n        if {![info exists diffmergeid]} {\n            gettreediffs $diffids\n        }\n    } elseif {$id ne $diffids} {\n        gettree $diffids\n    } else {\n        setfilelist $id\n    }\n    return 0\n}\n\nproc showfile {f} {\n    global treefilelist treeidlist diffids nullid nullid2\n    global ctext_file_names ctext_file_lines\n    global ctext commentend\n\n    set i [lsearch -exact $treefilelist($diffids) $f]\n    if {$i < 0} {\n        puts \"oops, $f not in list for id $diffids\"\n        return\n    }\n    if {$diffids eq $nullid} {\n        if {[catch {set bf [open $f r]} err]} {\n            puts \"oops, can't read $f: $err\"\n            return\n        }\n    } else {\n        set blob [lindex $treeidlist($diffids) $i]\n        if {[catch {set bf [open [concat | git cat-file blob $blob] r]} err]} {\n            puts \"oops, error reading blob $blob: $err\"\n            return\n        }\n    }\n    fconfigure $bf -blocking 0 -encoding [get_path_encoding $f]\n    filerun $bf [list getblobline $bf $diffids]\n    $ctext config -state normal\n    clear_ctext $commentend\n    lappend ctext_file_names $f\n    lappend ctext_file_lines [lindex [split $commentend \".\"] 0]\n    $ctext insert end \"\\n\"\n    $ctext insert end \"$f\\n\" filesep\n    $ctext config -state disabled\n    $ctext yview $commentend\n    settabs 0\n}\n\nproc getblobline {bf id} {\n    global diffids cmitmode ctext\n\n    if {$id ne $diffids || $cmitmode ne \"tree\"} {\n        catch {close $bf}\n        return 0\n    }\n    $ctext config -state normal\n    set nl 0\n    while {[incr nl] <= 1000 && [gets $bf line] >= 0} {\n        $ctext insert end \"$line\\n\"\n    }\n    if {[eof $bf]} {\n        global jump_to_here ctext_file_names commentend\n\n        # delete last newline\n        $ctext delete \"end - 2c\" \"end - 1c\"\n        close $bf\n        if {$jump_to_here ne {} &&\n            [lindex $jump_to_here 0] eq [lindex $ctext_file_names 0]} {\n            set lnum [expr {[lindex $jump_to_here 1] +\n                            [lindex [split $commentend .] 0]}]\n            mark_ctext_line $lnum\n        }\n        $ctext config -state disabled\n        return 0\n    }\n    $ctext config -state disabled\n    return [expr {$nl >= 1000? 2: 1}]\n}\n\nproc mark_ctext_line {lnum} {\n    global ctext markbgcolor\n\n    $ctext tag delete omark\n    $ctext tag add omark $lnum.0 \"$lnum.0 + 1 line\"\n    $ctext tag conf omark -background $markbgcolor\n    $ctext see $lnum.0\n}\n\nproc mergediff {id} {\n    global diffmergeid\n    global diffids treediffs\n    global parents curview\n\n    set diffmergeid $id\n    set diffids $id\n    set treediffs($id) {}\n    set np [llength $parents($curview,$id)]\n    settabs $np\n    getblobdiffs $id\n}\n\nproc startdiff {ids} {\n    global treediffs diffids treepending diffmergeid nullid nullid2\n\n    settabs 1\n    set diffids $ids\n    unset -nocomplain diffmergeid\n    if {![info exists treediffs($ids)] ||\n        [lsearch -exact $ids $nullid] >= 0 ||\n        [lsearch -exact $ids $nullid2] >= 0} {\n        if {![info exists treepending]} {\n            gettreediffs $ids\n        }\n    } else {\n        addtocflist $ids\n    }\n}\n\nproc showinlinediff {ids} {\n    global commitinfo commitdata ctext\n    global treediffs\n\n    set info $commitinfo($ids)\n    set diff [lindex $info 7]\n    set difflines [split $diff \"\\n\"]\n\n    initblobdiffvars\n    set treediff {}\n\n    set inhdr 0\n    foreach line $difflines {\n        if {![string compare -length 5 \"diff \" $line]} {\n            set inhdr 1\n        } elseif {$inhdr && ![string compare -length 4 \"+++ \" $line]} {\n            # offset also accounts for the b/ prefix\n            lappend treediff [string range $line 6 end]\n            set inhdr 0\n        }\n    }\n\n    set treediffs($ids) $treediff\n    add_flist $treediff\n\n    $ctext conf -state normal\n    foreach line $difflines {\n        parseblobdiffline $ids $line\n    }\n    maybe_scroll_ctext 1\n    $ctext conf -state disabled\n}\n\n# If the filename (name) is under any of the passed filter paths\n# then return true to include the file in the listing.\nproc path_filter {filter name} {\n    set worktree [gitworktree]\n    foreach p $filter {\n        set fq_p [file normalize $p]\n        set fq_n [file normalize [file join $worktree $name]]\n        if {[string match [file normalize $fq_p]* $fq_n]} {\n            return 1\n        }\n    }\n    return 0\n}\n\nproc addtocflist {ids} {\n    global treediffs\n\n    add_flist $treediffs($ids)\n    getblobdiffs $ids\n}\n\nproc diffcmd {ids flags} {\n    global log_showroot nullid nullid2 git_version\n\n    set i [lsearch -exact $ids $nullid]\n    set j [lsearch -exact $ids $nullid2]\n    if {$i >= 0} {\n        if {[llength $ids] > 1 && $j < 0} {\n            # comparing working directory with some specific revision\n            set cmd [concat | git diff-index $flags]\n            if {$i == 0} {\n                lappend cmd -R [lindex $ids 1]\n            } else {\n                lappend cmd [lindex $ids 0]\n            }\n        } else {\n            # comparing working directory with index\n            set cmd [concat | git diff-files $flags]\n            if {$j == 1} {\n                lappend cmd -R\n            }\n        }\n    } elseif {$j >= 0} {\n        if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n            set flags \"$flags --ignore-submodules=dirty\"\n        }\n        set cmd [concat | git diff-index --cached $flags]\n        if {[llength $ids] > 1} {\n            # comparing index with specific revision\n            if {$j == 0} {\n                lappend cmd -R [lindex $ids 1]\n            } else {\n                lappend cmd [lindex $ids 0]\n            }\n        } else {\n            # comparing index with HEAD\n            lappend cmd HEAD\n        }\n    } else {\n        if {$log_showroot} {\n            lappend flags --root\n        }\n        set cmd [concat | git diff-tree -r $flags $ids]\n    }\n    return $cmd\n}\n\nproc gettreediffs {ids} {\n    global treediff treepending limitdiffs vfilelimit curview\n\n    set cmd [diffcmd $ids {--no-commit-id}]\n    if {$limitdiffs && $vfilelimit($curview) ne {}} {\n            set cmd [concat $cmd -- $vfilelimit($curview)]\n    }\n    if {[catch {set gdtf [open $cmd r]}]} return\n\n    set treepending $ids\n    set treediff {}\n    fconfigure $gdtf -blocking 0 -encoding binary\n    filerun $gdtf [list gettreediffline $gdtf $ids]\n}\n\nproc gettreediffline {gdtf ids} {\n    global treediff treediffs treepending diffids diffmergeid\n    global cmitmode vfilelimit curview limitdiffs perfile_attrs\n\n    set nr 0\n    set sublist {}\n    set max 1000\n    if {$perfile_attrs} {\n        # cache_gitattr is slow, and even slower on win32 where we\n        # have to invoke it for only about 30 paths at a time\n        set max 500\n        if {[tk windowingsystem] == \"win32\"} {\n            set max 120\n        }\n    }\n    while {[incr nr] <= $max && [gets $gdtf line] >= 0} {\n        set i [string first \"\\t\" $line]\n        if {$i >= 0} {\n            set file [string range $line [expr {$i+1}] end]\n            if {[string index $file 0] eq \"\\\"\"} {\n                set file [lindex $file 0]\n            }\n            set file [encoding convertfrom utf-8 $file]\n            if {$file ne [lindex $treediff end]} {\n                lappend treediff $file\n                lappend sublist $file\n            }\n        }\n    }\n    if {$perfile_attrs} {\n        cache_gitattr encoding $sublist\n    }\n    if {![eof $gdtf]} {\n        return [expr {$nr >= $max? 2: 1}]\n    }\n    close $gdtf\n    set treediffs($ids) $treediff\n    unset treepending\n    if {$cmitmode eq \"tree\" && [llength $diffids] == 1} {\n        gettree $diffids\n    } elseif {$ids != $diffids} {\n        if {![info exists diffmergeid]} {\n            gettreediffs $diffids\n        }\n    } else {\n        addtocflist $ids\n    }\n    return 0\n}\n\n# empty string or positive integer\nproc diffcontextvalidate {v} {\n    return [regexp {^(|[1-9][0-9]*)$} $v]\n}\n\nproc diffcontextchange {n1 n2 op} {\n    global diffcontextstring diffcontext\n\n    if {[string is integer -strict $diffcontextstring]} {\n        if {$diffcontextstring >= 0} {\n            set diffcontext $diffcontextstring\n            reselectline\n        }\n    }\n}\n\nproc changeignorespace {} {\n    reselectline\n}\n\nproc changeworddiff {name ix op} {\n    reselectline\n}\n\nproc initblobdiffvars {} {\n    global diffencoding targetline diffnparents\n    global diffinhdr currdiffsubmod diffseehere\n    set targetline {}\n    set diffnparents 0\n    set diffinhdr 0\n    set diffencoding [get_path_encoding {}]\n    set currdiffsubmod \"\"\n    set diffseehere -1\n}\n\nproc getblobdiffs {ids} {\n    global blobdifffd diffids env\n    global treediffs\n    global diffcontext\n    global ignorespace\n    global worddiff\n    global limitdiffs vfilelimit curview\n    global git_version\n\n    set textconv {}\n    if {[package vcompare $git_version \"1.6.1\"] >= 0} {\n        set textconv \"--textconv\"\n    }\n    set submodule {}\n    if {[package vcompare $git_version \"1.6.6\"] >= 0} {\n        set submodule \"--submodule\"\n    }\n    set cmd [diffcmd $ids \"-p $textconv $submodule  -C --cc --no-commit-id -U$diffcontext\"]\n    if {$ignorespace} {\n        append cmd \" -w\"\n    }\n    if {$worddiff ne [mc \"Line diff\"]} {\n        append cmd \" --word-diff=porcelain\"\n    }\n    if {$limitdiffs && $vfilelimit($curview) ne {}} {\n        set cmd [concat $cmd -- $vfilelimit($curview)]\n    }\n    if {[catch {set bdf [open $cmd r]} err]} {\n        error_popup [mc \"Error getting diffs: %s\" $err]\n        return\n    }\n    fconfigure $bdf -blocking 0 -encoding binary -eofchar {}\n    set blobdifffd($ids) $bdf\n    initblobdiffvars\n    filerun $bdf [list getblobdiffline $bdf $diffids]\n}\n\nproc savecmitpos {} {\n    global ctext cmitmode\n\n    if {$cmitmode eq \"tree\"} {\n        return {}\n    }\n    return [list target_scrollpos [$ctext index @0,0]]\n}\n\nproc savectextpos {} {\n    global ctext\n\n    return [list target_scrollpos [$ctext index @0,0]]\n}\n\nproc maybe_scroll_ctext {ateof} {\n    global ctext target_scrollpos\n\n    if {![info exists target_scrollpos]} return\n    if {!$ateof} {\n        set nlines [expr {[winfo height $ctext]\n                          / [font metrics textfont -linespace]}]\n        if {[$ctext compare \"$target_scrollpos + $nlines lines\" <= end]} return\n    }\n    $ctext yview $target_scrollpos\n    unset target_scrollpos\n}\n\nproc setinlist {var i val} {\n    global $var\n\n    while {[llength [set $var]] < $i} {\n        lappend $var {}\n    }\n    if {[llength [set $var]] == $i} {\n        lappend $var $val\n    } else {\n        lset $var $i $val\n    }\n}\n\nproc makediffhdr {fname ids} {\n    global ctext curdiffstart treediffs diffencoding\n    global ctext_file_names jump_to_here targetline diffline\n\n    set fname [encoding convertfrom utf-8 $fname]\n    set diffencoding [get_path_encoding $fname]\n    set i [lsearch -exact $treediffs($ids) $fname]\n    if {$i >= 0} {\n        setinlist difffilestart $i $curdiffstart\n    }\n    lset ctext_file_names end $fname\n    set l [expr {(78 - [string length $fname]) / 2}]\n    set pad [string range \"----------------------------------------\" 1 $l]\n    $ctext insert $curdiffstart \"$pad $fname $pad\" filesep\n    set targetline {}\n    if {$jump_to_here ne {} && [lindex $jump_to_here 0] eq $fname} {\n        set targetline [lindex $jump_to_here 1]\n    }\n    set diffline 0\n}\n\nproc blobdiffmaybeseehere {ateof} {\n    global diffseehere\n    if {$diffseehere >= 0} {\n        mark_ctext_line [lindex [split $diffseehere .] 0]\n    }\n    maybe_scroll_ctext $ateof\n}\n\nproc getblobdiffline {bdf ids} {\n    global diffids blobdifffd\n    global ctext\n\n    set nr 0\n    $ctext conf -state normal\n    while {[incr nr] <= 1000 && [gets $bdf line] >= 0} {\n        if {$ids != $diffids || $bdf != $blobdifffd($ids)} {\n            # Older diff read. Abort it.\n            catch {close $bdf}\n            if {$ids != $diffids} {\n                array unset blobdifffd $ids\n            }\n            return 0\n        }\n        parseblobdiffline $ids $line\n    }\n    $ctext conf -state disabled\n    blobdiffmaybeseehere [eof $bdf]\n    if {[eof $bdf]} {\n        catch {close $bdf}\n        array unset blobdifffd $ids\n        return 0\n    }\n    return [expr {$nr >= 1000? 2: 1}]\n}\n\nproc parseblobdiffline {ids line} {\n    global ctext curdiffstart\n    global diffnexthead diffnextnote difffilestart\n    global ctext_file_names ctext_file_lines\n    global diffinhdr treediffs mergemax diffnparents\n    global diffencoding jump_to_here targetline diffline currdiffsubmod\n    global worddiff diffseehere\n\n    if {![string compare -length 5 \"diff \" $line]} {\n        if {![regexp {^diff (--cc|--git) } $line m type]} {\n            set line [encoding convertfrom utf-8 $line]\n            $ctext insert end \"$line\\n\" hunksep\n            continue\n        }\n        # start of a new file\n        set diffinhdr 1\n        set currdiffsubmod \"\"\n\n        $ctext insert end \"\\n\"\n        set curdiffstart [$ctext index \"end - 1c\"]\n        lappend ctext_file_names \"\"\n        lappend ctext_file_lines [lindex [split $curdiffstart \".\"] 0]\n        $ctext insert end \"\\n\" filesep\n\n        if {$type eq \"--cc\"} {\n            # start of a new file in a merge diff\n            set fname [string range $line 10 end]\n            if {[lsearch -exact $treediffs($ids) $fname] < 0} {\n                lappend treediffs($ids) $fname\n                add_flist [list $fname]\n            }\n\n        } else {\n            set line [string range $line 11 end]\n            # If the name hasn't changed the length will be odd,\n            # the middle char will be a space, and the two bits either\n            # side will be a/name and b/name, or \"a/name\" and \"b/name\".\n            # If the name has changed we'll get \"rename from\" and\n            # \"rename to\" or \"copy from\" and \"copy to\" lines following\n            # this, and we'll use them to get the filenames.\n            # This complexity is necessary because spaces in the\n            # filename(s) don't get escaped.\n            set l [string length $line]\n            set i [expr {$l / 2}]\n            if {!(($l & 1) && [string index $line $i] eq \" \" &&\n                  [string range $line 2 [expr {$i - 1}]] eq \\\n                      [string range $line [expr {$i + 3}] end])} {\n                return\n            }\n            # unescape if quoted and chop off the a/ from the front\n            if {[string index $line 0] eq \"\\\"\"} {\n                set fname [string range [lindex $line 0] 2 end]\n            } else {\n                set fname [string range $line 2 [expr {$i - 1}]]\n            }\n        }\n        makediffhdr $fname $ids\n\n    } elseif {![string compare -length 16 \"* Unmerged path \" $line]} {\n        set fname [encoding convertfrom utf-8 [string range $line 16 end]]\n        $ctext insert end \"\\n\"\n        set curdiffstart [$ctext index \"end - 1c\"]\n        lappend ctext_file_names $fname\n        lappend ctext_file_lines [lindex [split $curdiffstart \".\"] 0]\n        $ctext insert end \"$line\\n\" filesep\n        set i [lsearch -exact $treediffs($ids) $fname]\n        if {$i >= 0} {\n            setinlist difffilestart $i $curdiffstart\n        }\n\n    } elseif {![string compare -length 2 \"@@\" $line]} {\n        regexp {^@@+} $line ats\n        set line [encoding convertfrom $diffencoding $line]\n        $ctext insert end \"$line\\n\" hunksep\n        if {[regexp { \\+(\\d+),\\d+ @@} $line m nl]} {\n            set diffline $nl\n        }\n        set diffnparents [expr {[string length $ats] - 1}]\n        set diffinhdr 0\n\n    } elseif {![string compare -length 10 \"Submodule \" $line]} {\n        # start of a new submodule\n        if {[regexp -indices \"\\[0-9a-f\\]+\\\\.\\\\.\" $line nameend]} {\n            set fname [string range $line 10 [expr [lindex $nameend 0] - 2]]\n        } else {\n            set fname [string range $line 10 [expr [string first \"contains \" $line] - 2]]\n        }\n        if {$currdiffsubmod != $fname} {\n            $ctext insert end \"\\n\";     # Add newline after commit message\n        }\n        if {$currdiffsubmod != $fname} {\n            set curdiffstart [$ctext index \"end - 1c\"]\n            lappend ctext_file_names \"\"\n            lappend ctext_file_lines [lindex [split $curdiffstart \".\"] 0]\n            makediffhdr $fname $ids\n            set currdiffsubmod $fname\n            $ctext insert end \"\\n$line\\n\" filesep\n        } else {\n            $ctext insert end \"$line\\n\" filesep\n        }\n    } elseif {$currdiffsubmod != \"\" && ![string compare -length 3 \"  >\" $line]} {\n        set line [encoding convertfrom $diffencoding $line]\n        $ctext insert end \"$line\\n\" dresult\n    } elseif {$currdiffsubmod != \"\" && ![string compare -length 3 \"  <\" $line]} {\n        set line [encoding convertfrom $diffencoding $line]\n        $ctext insert end \"$line\\n\" d0\n    } elseif {$diffinhdr} {\n        if {![string compare -length 12 \"rename from \" $line]} {\n            set fname [string range $line [expr 6 + [string first \" from \" $line] ] end]\n            if {[string index $fname 0] eq \"\\\"\"} {\n                set fname [lindex $fname 0]\n            }\n            set fname [encoding convertfrom utf-8 $fname]\n            set i [lsearch -exact $treediffs($ids) $fname]\n            if {$i >= 0} {\n                setinlist difffilestart $i $curdiffstart\n            }\n        } elseif {![string compare -length 10 $line \"rename to \"] ||\n                  ![string compare -length 8 $line \"copy to \"]} {\n            set fname [string range $line [expr 4 + [string first \" to \" $line] ] end]\n            if {[string index $fname 0] eq \"\\\"\"} {\n                set fname [lindex $fname 0]\n            }\n            makediffhdr $fname $ids\n        } elseif {[string compare -length 3 $line \"---\"] == 0} {\n            # do nothing\n            return\n        } elseif {[string compare -length 3 $line \"+++\"] == 0} {\n            set diffinhdr 0\n            return\n        }\n        set line [encoding convertfrom utf-8 $line]\n        $ctext insert end \"$line\\n\" filesep\n\n    } else {\n        set line [string map {\\x1A ^Z} \\\n                      [encoding convertfrom $diffencoding $line]]\n        # parse the prefix - one ' ', '-' or '+' for each parent\n        set prefix [string range $line 0 [expr {$diffnparents - 1}]]\n        set tag [expr {$diffnparents > 1? \"m\": \"d\"}]\n        set dowords [expr {$worddiff ne [mc \"Line diff\"] && $diffnparents == 1}]\n        set words_pre_markup \"\"\n        set words_post_markup \"\"\n        if {[string trim $prefix \" -+\"] eq {}} {\n            # prefix only has \" \", \"-\" and \"+\" in it: normal diff line\n            set num [string first \"-\" $prefix]\n            if {$dowords} {\n                set line [string range $line 1 end]\n            }\n            if {$num >= 0} {\n                # removed line, first parent with line is $num\n                if {$num >= $mergemax} {\n                    set num \"max\"\n                }\n                if {$dowords && $worddiff eq [mc \"Markup words\"]} {\n                    $ctext insert end \"\\[-$line-\\]\" $tag$num\n                } else {\n                    $ctext insert end \"$line\" $tag$num\n                }\n                if {!$dowords} {\n                    $ctext insert end \"\\n\" $tag$num\n                }\n            } else {\n                set tags {}\n                if {[string first \"+\" $prefix] >= 0} {\n                    # added line\n                    lappend tags ${tag}result\n                    if {$diffnparents > 1} {\n                        set num [string first \" \" $prefix]\n                        if {$num >= 0} {\n                            if {$num >= $mergemax} {\n                                set num \"max\"\n                            }\n                            lappend tags m$num\n                        }\n                    }\n                    set words_pre_markup \"{+\"\n                    set words_post_markup \"+}\"\n                }\n                if {$targetline ne {}} {\n                    if {$diffline == $targetline} {\n                        set diffseehere [$ctext index \"end - 1 chars\"]\n                        set targetline {}\n                    } else {\n                        incr diffline\n                    }\n                }\n                if {$dowords && $worddiff eq [mc \"Markup words\"]} {\n                    $ctext insert end \"$words_pre_markup$line$words_post_markup\" $tags\n                } else {\n                    $ctext insert end \"$line\" $tags\n                }\n                if {!$dowords} {\n                    $ctext insert end \"\\n\" $tags\n                }\n            }\n        } elseif {$dowords && $prefix eq \"~\"} {\n            $ctext insert end \"\\n\" {}\n        } else {\n            # \"\\ No newline at end of file\",\n            # or something else we don't recognize\n            $ctext insert end \"$line\\n\" hunksep\n        }\n    }\n}\n\nproc changediffdisp {} {\n    global ctext diffelide\n\n    $ctext tag conf d0 -elide [lindex $diffelide 0]\n    $ctext tag conf dresult -elide [lindex $diffelide 1]\n}\n\nproc highlightfile {cline} {\n    global cflist cflist_top\n\n    if {![info exists cflist_top]} return\n\n    $cflist tag remove highlight $cflist_top.0 \"$cflist_top.0 lineend\"\n    $cflist tag add highlight $cline.0 \"$cline.0 lineend\"\n    $cflist see $cline.0\n    set cflist_top $cline\n}\n\nproc highlightfile_for_scrollpos {topidx} {\n    global cmitmode difffilestart\n\n    if {$cmitmode eq \"tree\"} return\n    if {![info exists difffilestart]} return\n\n    set top [lindex [split $topidx .] 0]\n    if {$difffilestart eq {} || $top < [lindex $difffilestart 0]} {\n        highlightfile 0\n    } else {\n        highlightfile [expr {[bsearch $difffilestart $top] + 2}]\n    }\n}\n\nproc prevfile {} {\n    global difffilestart ctext cmitmode\n\n    if {$cmitmode eq \"tree\"} return\n    set prev 0.0\n    set here [$ctext index @0,0]\n    foreach loc $difffilestart {\n        if {[$ctext compare $loc >= $here]} {\n            $ctext yview $prev\n            return\n        }\n        set prev $loc\n    }\n    $ctext yview $prev\n}\n\nproc nextfile {} {\n    global difffilestart ctext cmitmode\n\n    if {$cmitmode eq \"tree\"} return\n    set here [$ctext index @0,0]\n    foreach loc $difffilestart {\n        if {[$ctext compare $loc > $here]} {\n            $ctext yview $loc\n            return\n        }\n    }\n}\n\nproc clear_ctext {{first 1.0}} {\n    global ctext smarktop smarkbot\n    global ctext_file_names ctext_file_lines\n    global pendinglinks\n\n    set l [lindex [split $first .] 0]\n    if {![info exists smarktop] || [$ctext compare $first < $smarktop.0]} {\n        set smarktop $l\n    }\n    if {![info exists smarkbot] || [$ctext compare $first < $smarkbot.0]} {\n        set smarkbot $l\n    }\n    $ctext delete $first end\n    if {$first eq \"1.0\"} {\n        unset -nocomplain pendinglinks\n    }\n    set ctext_file_names {}\n    set ctext_file_lines {}\n}\n\nproc settabs {{firstab {}}} {\n    global firsttabstop tabstop ctext have_tk85\n\n    if {$firstab ne {} && $have_tk85} {\n        set firsttabstop $firstab\n    }\n    set w [font measure textfont \"0\"]\n    if {$firsttabstop != 0} {\n        $ctext conf -tabs [list [expr {($firsttabstop + $tabstop) * $w}] \\\n                               [expr {($firsttabstop + 2 * $tabstop) * $w}]]\n    } elseif {$have_tk85 || $tabstop != 8} {\n        $ctext conf -tabs [expr {$tabstop * $w}]\n    } else {\n        $ctext conf -tabs {}\n    }\n}\n\nproc incrsearch {name ix op} {\n    global ctext searchstring searchdirn\n\n    if {[catch {$ctext index anchor}]} {\n        # no anchor set, use start of selection, or of visible area\n        set sel [$ctext tag ranges sel]\n        if {$sel ne {}} {\n            $ctext mark set anchor [lindex $sel 0]\n        } elseif {$searchdirn eq \"-forwards\"} {\n            $ctext mark set anchor @0,0\n        } else {\n            $ctext mark set anchor @0,[winfo height $ctext]\n        }\n    }\n    if {$searchstring ne {}} {\n        set here [$ctext search -count mlen $searchdirn -- $searchstring anchor]\n        if {$here ne {}} {\n            $ctext see $here\n            set mend \"$here + $mlen c\"\n            $ctext tag remove sel 1.0 end\n            $ctext tag add sel $here $mend\n            suppress_highlighting_file_for_current_scrollpos\n            highlightfile_for_scrollpos $here\n        }\n    }\n    rehighlight_search_results\n}\n\nproc dosearch {} {\n    global sstring ctext searchstring searchdirn\n\n    focus $sstring\n    $sstring icursor end\n    set searchdirn -forwards\n    if {$searchstring ne {}} {\n        set sel [$ctext tag ranges sel]\n        if {$sel ne {}} {\n            set start \"[lindex $sel 0] + 1c\"\n        } elseif {[catch {set start [$ctext index anchor]}]} {\n            set start \"@0,0\"\n        }\n        set match [$ctext search -count mlen -- $searchstring $start]\n        $ctext tag remove sel 1.0 end\n        if {$match eq {}} {\n            bell\n            return\n        }\n        $ctext see $match\n        suppress_highlighting_file_for_current_scrollpos\n        highlightfile_for_scrollpos $match\n        set mend \"$match + $mlen c\"\n        $ctext tag add sel $match $mend\n        $ctext mark unset anchor\n        rehighlight_search_results\n    }\n}\n\nproc dosearchback {} {\n    global sstring ctext searchstring searchdirn\n\n    focus $sstring\n    $sstring icursor end\n    set searchdirn -backwards\n    if {$searchstring ne {}} {\n        set sel [$ctext tag ranges sel]\n        if {$sel ne {}} {\n            set start [lindex $sel 0]\n        } elseif {[catch {set start [$ctext index anchor]}]} {\n            set start @0,[winfo height $ctext]\n        }\n        set match [$ctext search -backwards -count ml -- $searchstring $start]\n        $ctext tag remove sel 1.0 end\n        if {$match eq {}} {\n            bell\n            return\n        }\n        $ctext see $match\n        suppress_highlighting_file_for_current_scrollpos\n        highlightfile_for_scrollpos $match\n        set mend \"$match + $ml c\"\n        $ctext tag add sel $match $mend\n        $ctext mark unset anchor\n        rehighlight_search_results\n    }\n}\n\nproc rehighlight_search_results {} {\n    global ctext searchstring\n\n    $ctext tag remove found 1.0 end\n    $ctext tag remove currentsearchhit 1.0 end\n\n    if {$searchstring ne {}} {\n        searchmarkvisible 1\n    }\n}\n\nproc searchmark {first last} {\n    global ctext searchstring\n\n    set sel [$ctext tag ranges sel]\n\n    set mend $first.0\n    while {1} {\n        set match [$ctext search -count mlen -- $searchstring $mend $last.end]\n        if {$match eq {}} break\n        set mend \"$match + $mlen c\"\n        if {$sel ne {} && [$ctext compare $match == [lindex $sel 0]]} {\n            $ctext tag add currentsearchhit $match $mend\n        } else {\n            $ctext tag add found $match $mend\n        }\n    }\n}\n\nproc searchmarkvisible {doall} {\n    global ctext smarktop smarkbot\n\n    set topline [lindex [split [$ctext index @0,0] .] 0]\n    set botline [lindex [split [$ctext index @0,[winfo height $ctext]] .] 0]\n    if {$doall || $botline < $smarktop || $topline > $smarkbot} {\n        # no overlap with previous\n        searchmark $topline $botline\n        set smarktop $topline\n        set smarkbot $botline\n    } else {\n        if {$topline < $smarktop} {\n            searchmark $topline [expr {$smarktop-1}]\n            set smarktop $topline\n        }\n        if {$botline > $smarkbot} {\n            searchmark [expr {$smarkbot+1}] $botline\n            set smarkbot $botline\n        }\n    }\n}\n\nproc suppress_highlighting_file_for_current_scrollpos {} {\n    global ctext suppress_highlighting_file_for_this_scrollpos\n\n    set suppress_highlighting_file_for_this_scrollpos [$ctext index @0,0]\n}\n\nproc scrolltext {f0 f1} {\n    global searchstring cmitmode ctext\n    global suppress_highlighting_file_for_this_scrollpos\n\n    set topidx [$ctext index @0,0]\n    if {![info exists suppress_highlighting_file_for_this_scrollpos]\n        || $topidx ne $suppress_highlighting_file_for_this_scrollpos} {\n        highlightfile_for_scrollpos $topidx\n    }\n\n    unset -nocomplain suppress_highlighting_file_for_this_scrollpos\n\n    .bleft.bottom.sb set $f0 $f1\n    if {$searchstring ne {}} {\n        searchmarkvisible 0\n    }\n}\n\nproc setcoords {} {\n    global linespc charspc canvx0 canvy0\n    global xspc1 xspc2 lthickness\n\n    set linespc [font metrics mainfont -linespace]\n    set charspc [font measure mainfont \"m\"]\n    set canvy0 [expr {int(3 + 0.5 * $linespc)}]\n    set canvx0 [expr {int(3 + 0.5 * $linespc)}]\n    set lthickness [expr {int($linespc / 9) + 1}]\n    set xspc1(0) $linespc\n    set xspc2 $linespc\n}\n\nproc redisplay {} {\n    global canv\n    global selectedline\n\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax eq {} || $ymax == 0} return\n    set span [$canv yview]\n    clear_display\n    setcanvscroll\n    allcanvs yview moveto [lindex $span 0]\n    drawvisible\n    if {$selectedline ne {}} {\n        selectline $selectedline 0\n        allcanvs yview moveto [lindex $span 0]\n    }\n}\n\nproc parsefont {f n} {\n    global fontattr\n\n    set fontattr($f,family) [lindex $n 0]\n    set s [lindex $n 1]\n    if {$s eq {} || $s == 0} {\n        set s 10\n    } elseif {$s < 0} {\n        set s [expr {int(-$s / [winfo fpixels . 1p] + 0.5)}]\n    }\n    set fontattr($f,size) $s\n    set fontattr($f,weight) normal\n    set fontattr($f,slant) roman\n    foreach style [lrange $n 2 end] {\n        switch -- $style {\n            \"normal\" -\n            \"bold\"   {set fontattr($f,weight) $style}\n            \"roman\" -\n            \"italic\" {set fontattr($f,slant) $style}\n        }\n    }\n}\n\nproc fontflags {f {isbold 0}} {\n    global fontattr\n\n    return [list -family $fontattr($f,family) -size $fontattr($f,size) \\\n                -weight [expr {$isbold? \"bold\": $fontattr($f,weight)}] \\\n                -slant $fontattr($f,slant)]\n}\n\nproc fontname {f} {\n    global fontattr\n\n    set n [list $fontattr($f,family) $fontattr($f,size)]\n    if {$fontattr($f,weight) eq \"bold\"} {\n        lappend n \"bold\"\n    }\n    if {$fontattr($f,slant) eq \"italic\"} {\n        lappend n \"italic\"\n    }\n    return $n\n}\n\nproc incrfont {inc} {\n    global mainfont textfont ctext canv cflist showrefstop\n    global stopped entries fontattr\n\n    unmarkmatches\n    set s $fontattr(mainfont,size)\n    incr s $inc\n    if {$s < 1} {\n        set s 1\n    }\n    set fontattr(mainfont,size) $s\n    font config mainfont -size $s\n    font config mainfontbold -size $s\n    set mainfont [fontname mainfont]\n    set s $fontattr(textfont,size)\n    incr s $inc\n    if {$s < 1} {\n        set s 1\n    }\n    set fontattr(textfont,size) $s\n    font config textfont -size $s\n    font config textfontbold -size $s\n    set textfont [fontname textfont]\n    setcoords\n    settabs\n    redisplay\n}\n\nproc clearsha1 {} {\n    global sha1entry sha1string\n    if {[string length $sha1string] == 40} {\n        $sha1entry delete 0 end\n    }\n}\n\nproc sha1change {n1 n2 op} {\n    global sha1string currentid sha1but\n    if {$sha1string == {}\n        || ([info exists currentid] && $sha1string == $currentid)} {\n        set state disabled\n    } else {\n        set state normal\n    }\n    if {[$sha1but cget -state] == $state} return\n    if {$state == \"normal\"} {\n        $sha1but conf -state normal -relief raised -text \"[mc \"Goto:\"] \"\n    } else {\n        $sha1but conf -state disabled -relief flat -text \"[mc \"SHA1 ID:\"] \"\n    }\n}\n\nproc gotocommit {} {\n    global sha1string tagids headids curview varcid\n\n    if {$sha1string == {}\n        || ([info exists currentid] && $sha1string == $currentid)} return\n    if {[info exists tagids($sha1string)]} {\n        set id $tagids($sha1string)\n    } elseif {[info exists headids($sha1string)]} {\n        set id $headids($sha1string)\n    } else {\n        set id [string tolower $sha1string]\n        if {[regexp {^[0-9a-f]{4,39}$} $id]} {\n            set matches [longid $id]\n            if {$matches ne {}} {\n                if {[llength $matches] > 1} {\n                    error_popup [mc \"Short SHA1 id %s is ambiguous\" $id]\n                    return\n                }\n                set id [lindex $matches 0]\n            }\n        } else {\n            if {[catch {set id [exec git rev-parse --verify $sha1string]}]} {\n                error_popup [mc \"Revision %s is not known\" $sha1string]\n                return\n            }\n        }\n    }\n    if {[commitinview $id $curview]} {\n        selectline [rowofcommit $id] 1\n        return\n    }\n    if {[regexp {^[0-9a-fA-F]{4,}$} $sha1string]} {\n        set msg [mc \"SHA1 id %s is not known\" $sha1string]\n    } else {\n        set msg [mc \"Revision %s is not in the current view\" $sha1string]\n    }\n    error_popup $msg\n}\n\nproc lineenter {x y id} {\n    global hoverx hovery hoverid hovertimer\n    global commitinfo canv\n\n    if {![info exists commitinfo($id)] && ![getcommit $id]} return\n    set hoverx $x\n    set hovery $y\n    set hoverid $id\n    if {[info exists hovertimer]} {\n        after cancel $hovertimer\n    }\n    set hovertimer [after 500 linehover]\n    $canv delete hover\n}\n\nproc linemotion {x y id} {\n    global hoverx hovery hoverid hovertimer\n\n    if {[info exists hoverid] && $id == $hoverid} {\n        set hoverx $x\n        set hovery $y\n        if {[info exists hovertimer]} {\n            after cancel $hovertimer\n        }\n        set hovertimer [after 500 linehover]\n    }\n}\n\nproc lineleave {id} {\n    global hoverid hovertimer canv\n\n    if {[info exists hoverid] && $id == $hoverid} {\n        $canv delete hover\n        if {[info exists hovertimer]} {\n            after cancel $hovertimer\n            unset hovertimer\n        }\n        unset hoverid\n    }\n}\n\nproc linehover {} {\n    global hoverx hovery hoverid hovertimer\n    global canv linespc lthickness\n    global linehoverbgcolor linehoverfgcolor linehoveroutlinecolor\n\n    global commitinfo\n\n    set text [lindex $commitinfo($hoverid) 0]\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax == {}} return\n    set yfrac [lindex [$canv yview] 0]\n    set x [expr {$hoverx + 2 * $linespc}]\n    set y [expr {$hovery + $yfrac * $ymax - $linespc / 2}]\n    set x0 [expr {$x - 2 * $lthickness}]\n    set y0 [expr {$y - 2 * $lthickness}]\n    set x1 [expr {$x + [font measure mainfont $text] + 2 * $lthickness}]\n    set y1 [expr {$y + $linespc + 2 * $lthickness}]\n    set t [$canv create rectangle $x0 $y0 $x1 $y1 \\\n               -fill $linehoverbgcolor -outline $linehoveroutlinecolor \\\n               -width 1 -tags hover]\n    $canv raise $t\n    set t [$canv create text $x $y -anchor nw -text $text -tags hover \\\n               -font mainfont -fill $linehoverfgcolor]\n    $canv raise $t\n}\n\nproc clickisonarrow {id y} {\n    global lthickness\n\n    set ranges [rowranges $id]\n    set thresh [expr {2 * $lthickness + 6}]\n    set n [expr {[llength $ranges] - 1}]\n    for {set i 1} {$i < $n} {incr i} {\n        set row [lindex $ranges $i]\n        if {abs([yc $row] - $y) < $thresh} {\n            return $i\n        }\n    }\n    return {}\n}\n\nproc arrowjump {id n y} {\n    global canv\n\n    # 1 <-> 2, 3 <-> 4, etc...\n    set n [expr {(($n - 1) ^ 1) + 1}]\n    set row [lindex [rowranges $id] $n]\n    set yt [yc $row]\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax eq {} || $ymax <= 0} return\n    set view [$canv yview]\n    set yspan [expr {[lindex $view 1] - [lindex $view 0]}]\n    set yfrac [expr {$yt / $ymax - $yspan / 2}]\n    if {$yfrac < 0} {\n        set yfrac 0\n    }\n    allcanvs yview moveto $yfrac\n}\n\nproc lineclick {x y id isnew} {\n    global ctext commitinfo children canv thickerline curview\n\n    if {![info exists commitinfo($id)] && ![getcommit $id]} return\n    unmarkmatches\n    unselectline\n    normalline\n    $canv delete hover\n    # draw this line thicker than normal\n    set thickerline $id\n    drawlines $id\n    if {$isnew} {\n        set ymax [lindex [$canv cget -scrollregion] 3]\n        if {$ymax eq {}} return\n        set yfrac [lindex [$canv yview] 0]\n        set y [expr {$y + $yfrac * $ymax}]\n    }\n    set dirn [clickisonarrow $id $y]\n    if {$dirn ne {}} {\n        arrowjump $id $dirn $y\n        return\n    }\n\n    if {$isnew} {\n        addtohistory [list lineclick $x $y $id 0] savectextpos\n    }\n    # fill the details pane with info about this line\n    $ctext conf -state normal\n    clear_ctext\n    settabs 0\n    $ctext insert end \"[mc \"Parent\"]:\\t\"\n    $ctext insert end $id link0\n    setlink $id link0\n    set info $commitinfo($id)\n    $ctext insert end \"\\n\\t[lindex $info 0]\\n\"\n    $ctext insert end \"\\t[mc \"Author\"]:\\t[lindex $info 1]\\n\"\n    set date [formatdate [lindex $info 2]]\n    $ctext insert end \"\\t[mc \"Date\"]:\\t$date\\n\"\n    set kids $children($curview,$id)\n    if {$kids ne {}} {\n        $ctext insert end \"\\n[mc \"Children\"]:\"\n        set i 0\n        foreach child $kids {\n            incr i\n            if {![info exists commitinfo($child)] && ![getcommit $child]} continue\n            set info $commitinfo($child)\n            $ctext insert end \"\\n\\t\"\n            $ctext insert end $child link$i\n            setlink $child link$i\n            $ctext insert end \"\\n\\t[lindex $info 0]\"\n            $ctext insert end \"\\n\\t[mc \"Author\"]:\\t[lindex $info 1]\"\n            set date [formatdate [lindex $info 2]]\n            $ctext insert end \"\\n\\t[mc \"Date\"]:\\t$date\\n\"\n        }\n    }\n    maybe_scroll_ctext 1\n    $ctext conf -state disabled\n    init_flist {}\n}\n\nproc normalline {} {\n    global thickerline\n    if {[info exists thickerline]} {\n        set id $thickerline\n        unset thickerline\n        drawlines $id\n    }\n}\n\nproc selbyid {id {isnew 1}} {\n    global curview\n    if {[commitinview $id $curview]} {\n        selectline [rowofcommit $id] $isnew\n    }\n}\n\nproc mstime {} {\n    global startmstime\n    if {![info exists startmstime]} {\n        set startmstime [clock clicks -milliseconds]\n    }\n    return [format \"%.3f\" [expr {([clock click -milliseconds] - $startmstime) / 1000.0}]]\n}\n\nproc rowmenu {x y id} {\n    global rowctxmenu selectedline rowmenuid curview\n    global nullid nullid2 fakerowmenu mainhead markedid\n\n    stopfinding\n    set rowmenuid $id\n    if {$selectedline eq {} || [rowofcommit $id] eq $selectedline} {\n        set state disabled\n    } else {\n        set state normal\n    }\n    if {[info exists markedid] && $markedid ne $id} {\n        set mstate normal\n    } else {\n        set mstate disabled\n    }\n    if {$id ne $nullid && $id ne $nullid2} {\n        set menu $rowctxmenu\n        if {$mainhead ne {}} {\n            $menu entryconfigure 8 -label [mc \"Reset %s branch to here\" $mainhead] -state normal\n        } else {\n            $menu entryconfigure 8 -label [mc \"Detached head: can't reset\" $mainhead] -state disabled\n        }\n        $menu entryconfigure 10 -state $mstate\n        $menu entryconfigure 11 -state $mstate\n        $menu entryconfigure 12 -state $mstate\n    } else {\n        set menu $fakerowmenu\n    }\n    $menu entryconfigure [mca \"Diff this -> selected\"] -state $state\n    $menu entryconfigure [mca \"Diff selected -> this\"] -state $state\n    $menu entryconfigure [mca \"Make patch\"] -state $state\n    $menu entryconfigure [mca \"Diff this -> marked commit\"] -state $mstate\n    $menu entryconfigure [mca \"Diff marked commit -> this\"] -state $mstate\n    tk_popup $menu $x $y\n}\n\nproc markhere {} {\n    global rowmenuid markedid canv\n\n    set markedid $rowmenuid\n    make_idmark $markedid\n}\n\nproc gotomark {} {\n    global markedid\n\n    if {[info exists markedid]} {\n        selbyid $markedid\n    }\n}\n\nproc replace_by_kids {l r} {\n    global curview children\n\n    set id [commitonrow $r]\n    set l [lreplace $l 0 0]\n    foreach kid $children($curview,$id) {\n        lappend l [rowofcommit $kid]\n    }\n    return [lsort -integer -decreasing -unique $l]\n}\n\nproc find_common_desc {} {\n    global markedid rowmenuid curview children\n\n    if {![info exists markedid]} return\n    if {![commitinview $markedid $curview] ||\n        ![commitinview $rowmenuid $curview]} return\n    #set t1 [clock clicks -milliseconds]\n    set l1 [list [rowofcommit $markedid]]\n    set l2 [list [rowofcommit $rowmenuid]]\n    while 1 {\n        set r1 [lindex $l1 0]\n        set r2 [lindex $l2 0]\n        if {$r1 eq {} || $r2 eq {}} break\n        if {$r1 == $r2} {\n            selectline $r1 1\n            break\n        }\n        if {$r1 > $r2} {\n            set l1 [replace_by_kids $l1 $r1]\n        } else {\n            set l2 [replace_by_kids $l2 $r2]\n        }\n    }\n    #set t2 [clock clicks -milliseconds]\n    #puts \"took [expr {$t2-$t1}]ms\"\n}\n\nproc compare_commits {} {\n    global markedid rowmenuid curview children\n\n    if {![info exists markedid]} return\n    if {![commitinview $markedid $curview]} return\n    addtohistory [list do_cmp_commits $markedid $rowmenuid]\n    do_cmp_commits $markedid $rowmenuid\n}\n\nproc getpatchid {id} {\n    global patchids\n\n    if {![info exists patchids($id)]} {\n        set cmd [diffcmd [list $id] {-p --root}]\n        # trim off the initial \"|\"\n        set cmd [lrange $cmd 1 end]\n        if {[catch {\n            set x [eval exec $cmd | git patch-id]\n            set patchids($id) [lindex $x 0]\n        }]} {\n            set patchids($id) \"error\"\n        }\n    }\n    return $patchids($id)\n}\n\nproc do_cmp_commits {a b} {\n    global ctext curview parents children patchids commitinfo\n\n    $ctext conf -state normal\n    clear_ctext\n    init_flist {}\n    for {set i 0} {$i < 100} {incr i} {\n        set skipa 0\n        set skipb 0\n        if {[llength $parents($curview,$a)] > 1} {\n            appendshortlink $a [mc \"Skipping merge commit \"] \"\\n\"\n            set skipa 1\n        } else {\n            set patcha [getpatchid $a]\n        }\n        if {[llength $parents($curview,$b)] > 1} {\n            appendshortlink $b [mc \"Skipping merge commit \"] \"\\n\"\n            set skipb 1\n        } else {\n            set patchb [getpatchid $b]\n        }\n        if {!$skipa && !$skipb} {\n            set heada [lindex $commitinfo($a) 0]\n            set headb [lindex $commitinfo($b) 0]\n            if {$patcha eq \"error\"} {\n                appendshortlink $a [mc \"Error getting patch ID for \"] \\\n                    [mc \" - stopping\\n\"]\n                break\n            }\n            if {$patchb eq \"error\"} {\n                appendshortlink $b [mc \"Error getting patch ID for \"] \\\n                    [mc \" - stopping\\n\"]\n                break\n            }\n            if {$patcha eq $patchb} {\n                if {$heada eq $headb} {\n                    appendshortlink $a [mc \"Commit \"]\n                    appendshortlink $b \" == \" \"  $heada\\n\"\n                } else {\n                    appendshortlink $a [mc \"Commit \"] \"  $heada\\n\"\n                    appendshortlink $b [mc \" is the same patch as\\n       \"] \\\n                        \"  $headb\\n\"\n                }\n                set skipa 1\n                set skipb 1\n            } else {\n                $ctext insert end \"\\n\"\n                appendshortlink $a [mc \"Commit \"] \"  $heada\\n\"\n                appendshortlink $b [mc \" differs from\\n       \"] \\\n                    \"  $headb\\n\"\n                $ctext insert end [mc \"Diff of commits:\\n\\n\"]\n                $ctext conf -state disabled\n                update\n                diffcommits $a $b\n                return\n            }\n        }\n        if {$skipa} {\n            set kids [real_children $curview,$a]\n            if {[llength $kids] != 1} {\n                $ctext insert end \"\\n\"\n                appendshortlink $a [mc \"Commit \"] \\\n                    [mc \" has %s children - stopping\\n\" [llength $kids]]\n                break\n            }\n            set a [lindex $kids 0]\n        }\n        if {$skipb} {\n            set kids [real_children $curview,$b]\n            if {[llength $kids] != 1} {\n                appendshortlink $b [mc \"Commit \"] \\\n                    [mc \" has %s children - stopping\\n\" [llength $kids]]\n                break\n            }\n            set b [lindex $kids 0]\n        }\n    }\n    $ctext conf -state disabled\n}\n\nproc diffcommits {a b} {\n    global diffcontext diffids blobdifffd diffinhdr currdiffsubmod\n\n    set tmpdir [gitknewtmpdir]\n    set fna [file join $tmpdir \"commit-[string range $a 0 7]\"]\n    set fnb [file join $tmpdir \"commit-[string range $b 0 7]\"]\n    if {[catch {\n        exec git diff-tree -p --pretty $a >$fna\n        exec git diff-tree -p --pretty $b >$fnb\n    } err]} {\n        error_popup [mc \"Error writing commit to file: %s\" $err]\n        return\n    }\n    if {[catch {\n        set fd [open \"| diff -U$diffcontext $fna $fnb\" r]\n    } err]} {\n        error_popup [mc \"Error diffing commits: %s\" $err]\n        return\n    }\n    set diffids [list commits $a $b]\n    set blobdifffd($diffids) $fd\n    set diffinhdr 0\n    set currdiffsubmod \"\"\n    filerun $fd [list getblobdiffline $fd $diffids]\n}\n\nproc diffvssel {dirn} {\n    global rowmenuid selectedline\n\n    if {$selectedline eq {}} return\n    if {$dirn} {\n        set oldid [commitonrow $selectedline]\n        set newid $rowmenuid\n    } else {\n        set oldid $rowmenuid\n        set newid [commitonrow $selectedline]\n    }\n    addtohistory [list doseldiff $oldid $newid] savectextpos\n    doseldiff $oldid $newid\n}\n\nproc diffvsmark {dirn} {\n    global rowmenuid markedid\n\n    if {![info exists markedid]} return\n    if {$dirn} {\n        set oldid $markedid\n        set newid $rowmenuid\n    } else {\n        set oldid $rowmenuid\n        set newid $markedid\n    }\n    addtohistory [list doseldiff $oldid $newid] savectextpos\n    doseldiff $oldid $newid\n}\n\nproc doseldiff {oldid newid} {\n    global ctext\n    global commitinfo\n\n    $ctext conf -state normal\n    clear_ctext\n    init_flist [mc \"Top\"]\n    $ctext insert end \"[mc \"From\"] \"\n    $ctext insert end $oldid link0\n    setlink $oldid link0\n    $ctext insert end \"\\n     \"\n    $ctext insert end [lindex $commitinfo($oldid) 0]\n    $ctext insert end \"\\n\\n[mc \"To\"]   \"\n    $ctext insert end $newid link1\n    setlink $newid link1\n    $ctext insert end \"\\n     \"\n    $ctext insert end [lindex $commitinfo($newid) 0]\n    $ctext insert end \"\\n\"\n    $ctext conf -state disabled\n    $ctext tag remove found 1.0 end\n    startdiff [list $oldid $newid]\n}\n\nproc mkpatch {} {\n    global rowmenuid currentid commitinfo patchtop patchnum NS\n\n    if {![info exists currentid]} return\n    set oldid $currentid\n    set oldhead [lindex $commitinfo($oldid) 0]\n    set newid $rowmenuid\n    set newhead [lindex $commitinfo($newid) 0]\n    set top .patch\n    set patchtop $top\n    catch {destroy $top}\n    ttk_toplevel $top\n    make_transient $top .\n    ${NS}::label $top.title -text [mc \"Generate patch\"]\n    grid $top.title - -pady 10\n    ${NS}::label $top.from -text [mc \"From:\"]\n    ${NS}::entry $top.fromsha1 -width 40\n    $top.fromsha1 insert 0 $oldid\n    $top.fromsha1 conf -state readonly\n    grid $top.from $top.fromsha1 -sticky w\n    ${NS}::entry $top.fromhead -width 60\n    $top.fromhead insert 0 $oldhead\n    $top.fromhead conf -state readonly\n    grid x $top.fromhead -sticky w\n    ${NS}::label $top.to -text [mc \"To:\"]\n    ${NS}::entry $top.tosha1 -width 40\n    $top.tosha1 insert 0 $newid\n    $top.tosha1 conf -state readonly\n    grid $top.to $top.tosha1 -sticky w\n    ${NS}::entry $top.tohead -width 60\n    $top.tohead insert 0 $newhead\n    $top.tohead conf -state readonly\n    grid x $top.tohead -sticky w\n    ${NS}::button $top.rev -text [mc \"Reverse\"] -command mkpatchrev\n    grid $top.rev x -pady 10 -padx 5\n    ${NS}::label $top.flab -text [mc \"Output file:\"]\n    ${NS}::entry $top.fname -width 60\n    $top.fname insert 0 [file normalize \"patch$patchnum.patch\"]\n    incr patchnum\n    grid $top.flab $top.fname -sticky w\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.gen -text [mc \"Generate\"] -command mkpatchgo\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command mkpatchcan\n    bind $top <Key-Return> mkpatchgo\n    bind $top <Key-Escape> mkpatchcan\n    grid $top.buts.gen $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - -pady 10 -sticky ew\n    focus $top.fname\n}\n\nproc mkpatchrev {} {\n    global patchtop\n\n    set oldid [$patchtop.fromsha1 get]\n    set oldhead [$patchtop.fromhead get]\n    set newid [$patchtop.tosha1 get]\n    set newhead [$patchtop.tohead get]\n    foreach e [list fromsha1 fromhead tosha1 tohead] \\\n            v [list $newid $newhead $oldid $oldhead] {\n        $patchtop.$e conf -state normal\n        $patchtop.$e delete 0 end\n        $patchtop.$e insert 0 $v\n        $patchtop.$e conf -state readonly\n    }\n}\n\nproc mkpatchgo {} {\n    global patchtop nullid nullid2\n\n    set oldid [$patchtop.fromsha1 get]\n    set newid [$patchtop.tosha1 get]\n    set fname [$patchtop.fname get]\n    set cmd [diffcmd [list $oldid $newid] -p]\n    # trim off the initial \"|\"\n    set cmd [lrange $cmd 1 end]\n    lappend cmd >$fname &\n    if {[catch {eval exec $cmd} err]} {\n        error_popup \"[mc \"Error creating patch:\"] $err\" $patchtop\n    }\n    catch {destroy $patchtop}\n    unset patchtop\n}\n\nproc mkpatchcan {} {\n    global patchtop\n\n    catch {destroy $patchtop}\n    unset patchtop\n}\n\nproc mktag {} {\n    global rowmenuid mktagtop commitinfo NS\n\n    set top .maketag\n    set mktagtop $top\n    catch {destroy $top}\n    ttk_toplevel $top\n    make_transient $top .\n    ${NS}::label $top.title -text [mc \"Create tag\"]\n    grid $top.title - -pady 10\n    ${NS}::label $top.id -text [mc \"ID:\"]\n    ${NS}::entry $top.sha1 -width 40\n    $top.sha1 insert 0 $rowmenuid\n    $top.sha1 conf -state readonly\n    grid $top.id $top.sha1 -sticky w\n    ${NS}::entry $top.head -width 60\n    $top.head insert 0 [lindex $commitinfo($rowmenuid) 0]\n    $top.head conf -state readonly\n    grid x $top.head -sticky w\n    ${NS}::label $top.tlab -text [mc \"Tag name:\"]\n    ${NS}::entry $top.tag -width 60\n    grid $top.tlab $top.tag -sticky w\n    ${NS}::label $top.op -text [mc \"Tag message is optional\"]\n    grid $top.op -columnspan 2 -sticky we\n    ${NS}::label $top.mlab -text [mc \"Tag message:\"]\n    ${NS}::entry $top.msg -width 60\n    grid $top.mlab $top.msg -sticky w\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.gen -text [mc \"Create\"] -command mktaggo\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command mktagcan\n    bind $top <Key-Return> mktaggo\n    bind $top <Key-Escape> mktagcan\n    grid $top.buts.gen $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - -pady 10 -sticky ew\n    focus $top.tag\n}\n\nproc domktag {} {\n    global mktagtop env tagids idtags\n\n    set id [$mktagtop.sha1 get]\n    set tag [$mktagtop.tag get]\n    set msg [$mktagtop.msg get]\n    if {$tag == {}} {\n        error_popup [mc \"No tag name specified\"] $mktagtop\n        return 0\n    }\n    if {[info exists tagids($tag)]} {\n        error_popup [mc \"Tag \\\"%s\\\" already exists\" $tag] $mktagtop\n        return 0\n    }\n    if {[catch {\n        if {$msg != {}} {\n            exec git tag -a -m $msg $tag $id\n        } else {\n            exec git tag $tag $id\n        }\n    } err]} {\n        error_popup \"[mc \"Error creating tag:\"] $err\" $mktagtop\n        return 0\n    }\n\n    set tagids($tag) $id\n    lappend idtags($id) $tag\n    redrawtags $id\n    addedtag $id\n    dispneartags 0\n    run refill_reflist\n    return 1\n}\n\nproc redrawtags {id} {\n    global canv linehtag idpos currentid curview cmitlisted markedid\n    global canvxmax iddrawn circleitem mainheadid circlecolors\n    global mainheadcirclecolor\n\n    if {![commitinview $id $curview]} return\n    if {![info exists iddrawn($id)]} return\n    set row [rowofcommit $id]\n    if {$id eq $mainheadid} {\n        set ofill $mainheadcirclecolor\n    } else {\n        set ofill [lindex $circlecolors $cmitlisted($curview,$id)]\n    }\n    $canv itemconf $circleitem($row) -fill $ofill\n    $canv delete tag.$id\n    set xt [eval drawtags $id $idpos($id)]\n    $canv coords $linehtag($id) $xt [lindex $idpos($id) 2]\n    set text [$canv itemcget $linehtag($id) -text]\n    set font [$canv itemcget $linehtag($id) -font]\n    set xr [expr {$xt + [font measure $font $text]}]\n    if {$xr > $canvxmax} {\n        set canvxmax $xr\n        setcanvscroll\n    }\n    if {[info exists currentid] && $currentid == $id} {\n        make_secsel $id\n    }\n    if {[info exists markedid] && $markedid eq $id} {\n        make_idmark $id\n    }\n}\n\nproc mktagcan {} {\n    global mktagtop\n\n    catch {destroy $mktagtop}\n    unset mktagtop\n}\n\nproc mktaggo {} {\n    if {![domktag]} return\n    mktagcan\n}\n\nproc copyreference {} {\n    global rowmenuid autosellen\n\n    set format \"%h (\\\"%s\\\", %ad)\"\n    set cmd [list git show -s --pretty=format:$format --date=short]\n    if {$autosellen < 40} {\n        lappend cmd --abbrev=$autosellen\n    }\n    set reference [eval exec $cmd $rowmenuid]\n\n    clipboard clear\n    clipboard append $reference\n}\n\nproc writecommit {} {\n    global rowmenuid wrcomtop commitinfo wrcomcmd NS\n\n    set top .writecommit\n    set wrcomtop $top\n    catch {destroy $top}\n    ttk_toplevel $top\n    make_transient $top .\n    ${NS}::label $top.title -text [mc \"Write commit to file\"]\n    grid $top.title - -pady 10\n    ${NS}::label $top.id -text [mc \"ID:\"]\n    ${NS}::entry $top.sha1 -width 40\n    $top.sha1 insert 0 $rowmenuid\n    $top.sha1 conf -state readonly\n    grid $top.id $top.sha1 -sticky w\n    ${NS}::entry $top.head -width 60\n    $top.head insert 0 [lindex $commitinfo($rowmenuid) 0]\n    $top.head conf -state readonly\n    grid x $top.head -sticky w\n    ${NS}::label $top.clab -text [mc \"Command:\"]\n    ${NS}::entry $top.cmd -width 60 -textvariable wrcomcmd\n    grid $top.clab $top.cmd -sticky w -pady 10\n    ${NS}::label $top.flab -text [mc \"Output file:\"]\n    ${NS}::entry $top.fname -width 60\n    $top.fname insert 0 [file normalize \"commit-[string range $rowmenuid 0 6]\"]\n    grid $top.flab $top.fname -sticky w\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.gen -text [mc \"Write\"] -command wrcomgo\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command wrcomcan\n    bind $top <Key-Return> wrcomgo\n    bind $top <Key-Escape> wrcomcan\n    grid $top.buts.gen $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - -pady 10 -sticky ew\n    focus $top.fname\n}\n\nproc wrcomgo {} {\n    global wrcomtop\n\n    set id [$wrcomtop.sha1 get]\n    set cmd \"echo $id | [$wrcomtop.cmd get]\"\n    set fname [$wrcomtop.fname get]\n    if {[catch {exec sh -c $cmd >$fname &} err]} {\n        error_popup \"[mc \"Error writing commit:\"] $err\" $wrcomtop\n    }\n    catch {destroy $wrcomtop}\n    unset wrcomtop\n}\n\nproc wrcomcan {} {\n    global wrcomtop\n\n    catch {destroy $wrcomtop}\n    unset wrcomtop\n}\n\nproc mkbranch {} {\n    global NS rowmenuid\n\n    set top .branchdialog\n\n    set val(name) \"\"\n    set val(id) $rowmenuid\n    set val(command) [list mkbrgo $top]\n\n    set ui(title) [mc \"Create branch\"]\n    set ui(accept) [mc \"Create\"]\n\n    branchdia $top val ui\n}\n\nproc mvbranch {} {\n    global NS\n    global headmenuid headmenuhead\n\n    set top .branchdialog\n\n    set val(name) $headmenuhead\n    set val(id) $headmenuid\n    set val(command) [list mvbrgo $top $headmenuhead]\n\n    set ui(title) [mc \"Rename branch %s\" $headmenuhead]\n    set ui(accept) [mc \"Rename\"]\n\n    branchdia $top val ui\n}\n\nproc branchdia {top valvar uivar} {\n    global NS commitinfo\n    upvar $valvar val $uivar ui\n\n    catch {destroy $top}\n    ttk_toplevel $top\n    make_transient $top .\n    ${NS}::label $top.title -text $ui(title)\n    grid $top.title - -pady 10\n    ${NS}::label $top.id -text [mc \"ID:\"]\n    ${NS}::entry $top.sha1 -width 40\n    $top.sha1 insert 0 $val(id)\n    $top.sha1 conf -state readonly\n    grid $top.id $top.sha1 -sticky w\n    ${NS}::entry $top.head -width 60\n    $top.head insert 0 [lindex $commitinfo($val(id)) 0]\n    $top.head conf -state readonly\n    grid x $top.head -sticky ew\n    grid columnconfigure $top 1 -weight 1\n    ${NS}::label $top.nlab -text [mc \"Name:\"]\n    ${NS}::entry $top.name -width 40\n    $top.name insert 0 $val(name)\n    grid $top.nlab $top.name -sticky w\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.go -text $ui(accept) -command $val(command)\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command \"catch {destroy $top}\"\n    bind $top <Key-Return> $val(command)\n    bind $top <Key-Escape> \"catch {destroy $top}\"\n    grid $top.buts.go $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - -pady 10 -sticky ew\n    focus $top.name\n}\n\nproc mkbrgo {top} {\n    global headids idheads\n\n    set name [$top.name get]\n    set id [$top.sha1 get]\n    set cmdargs {}\n    set old_id {}\n    if {$name eq {}} {\n        error_popup [mc \"Please specify a name for the new branch\"] $top\n        return\n    }\n    if {[info exists headids($name)]} {\n        if {![confirm_popup [mc \\\n                \"Branch '%s' already exists. Overwrite?\" $name] $top]} {\n            return\n        }\n        set old_id $headids($name)\n        lappend cmdargs -f\n    }\n    catch {destroy $top}\n    lappend cmdargs $name $id\n    nowbusy newbranch\n    update\n    if {[catch {\n        eval exec git branch $cmdargs\n    } err]} {\n        notbusy newbranch\n        error_popup $err\n    } else {\n        notbusy newbranch\n        if {$old_id ne {}} {\n            movehead $id $name\n            movedhead $id $name\n            redrawtags $old_id\n            redrawtags $id\n        } else {\n            set headids($name) $id\n            lappend idheads($id) $name\n            addedhead $id $name\n            redrawtags $id\n        }\n        dispneartags 0\n        run refill_reflist\n    }\n}\n\nproc mvbrgo {top prevname} {\n    global headids idheads mainhead mainheadid\n\n    set name [$top.name get]\n    set id [$top.sha1 get]\n    set cmdargs {}\n    if {$name eq $prevname} {\n        catch {destroy $top}\n        return\n    }\n    if {$name eq {}} {\n        error_popup [mc \"Please specify a new name for the branch\"] $top\n        return\n    }\n    catch {destroy $top}\n    lappend cmdargs -m $prevname $name\n    nowbusy renamebranch\n    update\n    if {[catch {\n        eval exec git branch $cmdargs\n    } err]} {\n        notbusy renamebranch\n        error_popup $err\n    } else {\n        notbusy renamebranch\n        removehead $id $prevname\n        removedhead $id $prevname\n        set headids($name) $id\n        lappend idheads($id) $name\n        addedhead $id $name\n        if {$prevname eq $mainhead} {\n            set mainhead $name\n            set mainheadid $id\n        }\n        redrawtags $id\n        dispneartags 0\n        run refill_reflist\n    }\n}\n\nproc exec_citool {tool_args {baseid {}}} {\n    global commitinfo env\n\n    set save_env [array get env GIT_AUTHOR_*]\n\n    if {$baseid ne {}} {\n        if {![info exists commitinfo($baseid)]} {\n            getcommit $baseid\n        }\n        set author [lindex $commitinfo($baseid) 1]\n        set date [lindex $commitinfo($baseid) 2]\n        if {[regexp {^\\s*(\\S.*\\S|\\S)\\s*<(.*)>\\s*$} \\\n                    $author author name email]\n            && $date ne {}} {\n            set env(GIT_AUTHOR_NAME) $name\n            set env(GIT_AUTHOR_EMAIL) $email\n            set env(GIT_AUTHOR_DATE) $date\n        }\n    }\n\n    eval exec git citool $tool_args &\n\n    array unset env GIT_AUTHOR_*\n    array set env $save_env\n}\n\nproc cherrypick {} {\n    global rowmenuid curview\n    global mainhead mainheadid\n    global gitdir\n\n    set oldhead [exec git rev-parse HEAD]\n    set dheads [descheads $rowmenuid]\n    if {$dheads ne {} && [lsearch -exact $dheads $oldhead] >= 0} {\n        set ok [confirm_popup [mc \"Commit %s is already\\\n                included in branch %s -- really re-apply it?\" \\\n                                   [string range $rowmenuid 0 7] $mainhead]]\n        if {!$ok} return\n    }\n    nowbusy cherrypick [mc \"Cherry-picking\"]\n    update\n    # Unfortunately git-cherry-pick writes stuff to stderr even when\n    # no error occurs, and exec takes that as an indication of error...\n    if {[catch {exec sh -c \"git cherry-pick -r $rowmenuid 2>&1\"} err]} {\n        notbusy cherrypick\n        if {[regexp -line \\\n                 {Entry '(.*)' (would be overwritten by merge|not uptodate)} \\\n                 $err msg fname]} {\n            error_popup [mc \"Cherry-pick failed because of local changes\\\n                        to file '%s'.\\nPlease commit, reset or stash\\\n                        your changes and try again.\" $fname]\n        } elseif {[regexp -line \\\n                       {^(CONFLICT \\(.*\\):|Automatic cherry-pick failed|error: could not apply)} \\\n                       $err]} {\n            if {[confirm_popup [mc \"Cherry-pick failed because of merge\\\n                        conflict.\\nDo you wish to run git citool to\\\n                        resolve it?\"]]} {\n                # Force citool to read MERGE_MSG\n                file delete [file join $gitdir \"GITGUI_MSG\"]\n                exec_citool {} $rowmenuid\n            }\n        } else {\n            error_popup $err\n        }\n        run updatecommits\n        return\n    }\n    set newhead [exec git rev-parse HEAD]\n    if {$newhead eq $oldhead} {\n        notbusy cherrypick\n        error_popup [mc \"No changes committed\"]\n        return\n    }\n    addnewchild $newhead $oldhead\n    if {[commitinview $oldhead $curview]} {\n        # XXX this isn't right if we have a path limit...\n        insertrow $newhead $oldhead $curview\n        if {$mainhead ne {}} {\n            movehead $newhead $mainhead\n            movedhead $newhead $mainhead\n        }\n        set mainheadid $newhead\n        redrawtags $oldhead\n        redrawtags $newhead\n        selbyid $newhead\n    }\n    notbusy cherrypick\n}\n\nproc revert {} {\n    global rowmenuid curview\n    global mainhead mainheadid\n    global gitdir\n\n    set oldhead [exec git rev-parse HEAD]\n    set dheads [descheads $rowmenuid]\n    if { $dheads eq {} || [lsearch -exact $dheads $oldhead] == -1 } {\n       set ok [confirm_popup [mc \"Commit %s is not\\\n           included in branch %s -- really revert it?\" \\\n                      [string range $rowmenuid 0 7] $mainhead]]\n       if {!$ok} return\n    }\n    nowbusy revert [mc \"Reverting\"]\n    update\n\n    if [catch {exec git revert --no-edit $rowmenuid} err] {\n        notbusy revert\n        if [regexp {files would be overwritten by merge:(\\n(( |\\t)+[^\\n]+\\n)+)}\\\n                $err match files] {\n            regsub {\\n( |\\t)+} $files \"\\n\" files\n            error_popup [mc \"Revert failed because of local changes to\\\n                the following files:%s Please commit, reset or stash \\\n                your changes and try again.\" $files]\n        } elseif [regexp {error: could not revert} $err] {\n            if [confirm_popup [mc \"Revert failed because of merge conflict.\\n\\\n                Do you wish to run git citool to resolve it?\"]] {\n                # Force citool to read MERGE_MSG\n                file delete [file join $gitdir \"GITGUI_MSG\"]\n                exec_citool {} $rowmenuid\n            }\n        } else { error_popup $err }\n        run updatecommits\n        return\n    }\n\n    set newhead [exec git rev-parse HEAD]\n    if { $newhead eq $oldhead } {\n        notbusy revert\n        error_popup [mc \"No changes committed\"]\n        return\n    }\n\n    addnewchild $newhead $oldhead\n\n    if [commitinview $oldhead $curview] {\n        # XXX this isn't right if we have a path limit...\n        insertrow $newhead $oldhead $curview\n        if {$mainhead ne {}} {\n            movehead $newhead $mainhead\n            movedhead $newhead $mainhead\n        }\n        set mainheadid $newhead\n        redrawtags $oldhead\n        redrawtags $newhead\n        selbyid $newhead\n    }\n\n    notbusy revert\n}\n\nproc resethead {} {\n    global mainhead rowmenuid confirm_ok resettype NS\n\n    set confirm_ok 0\n    set w \".confirmreset\"\n    ttk_toplevel $w\n    make_transient $w .\n    wm title $w [mc \"Confirm reset\"]\n    ${NS}::label $w.m -text \\\n        [mc \"Reset branch %s to %s?\" $mainhead [string range $rowmenuid 0 7]]\n    pack $w.m -side top -fill x -padx 20 -pady 20\n    ${NS}::labelframe $w.f -text [mc \"Reset type:\"]\n    set resettype mixed\n    ${NS}::radiobutton $w.f.soft -value soft -variable resettype \\\n        -text [mc \"Soft: Leave working tree and index untouched\"]\n    grid $w.f.soft -sticky w\n    ${NS}::radiobutton $w.f.mixed -value mixed -variable resettype \\\n        -text [mc \"Mixed: Leave working tree untouched, reset index\"]\n    grid $w.f.mixed -sticky w\n    ${NS}::radiobutton $w.f.hard -value hard -variable resettype \\\n        -text [mc \"Hard: Reset working tree and index\\n(discard ALL local changes)\"]\n    grid $w.f.hard -sticky w\n    pack $w.f -side top -fill x -padx 4\n    ${NS}::button $w.ok -text [mc OK] -command \"set confirm_ok 1; destroy $w\"\n    pack $w.ok -side left -fill x -padx 20 -pady 20\n    ${NS}::button $w.cancel -text [mc Cancel] -command \"destroy $w\"\n    bind $w <Key-Escape> [list destroy $w]\n    pack $w.cancel -side right -fill x -padx 20 -pady 20\n    bind $w <Visibility> \"grab $w; focus $w\"\n    tkwait window $w\n    if {!$confirm_ok} return\n    if {[catch {set fd [open \\\n            [list | git reset --$resettype $rowmenuid 2>@1] r]} err]} {\n        error_popup $err\n    } else {\n        dohidelocalchanges\n        filerun $fd [list readresetstat $fd]\n        nowbusy reset [mc \"Resetting\"]\n        selbyid $rowmenuid\n    }\n}\n\nproc readresetstat {fd} {\n    global mainhead mainheadid showlocalchanges rprogcoord\n\n    if {[gets $fd line] >= 0} {\n        if {[regexp {([0-9]+)% \\(([0-9]+)/([0-9]+)\\)} $line match p m n]} {\n            set rprogcoord [expr {1.0 * $m / $n}]\n            adjustprogress\n        }\n        return 1\n    }\n    set rprogcoord 0\n    adjustprogress\n    notbusy reset\n    if {[catch {close $fd} err]} {\n        error_popup $err\n    }\n    set oldhead $mainheadid\n    set newhead [exec git rev-parse HEAD]\n    if {$newhead ne $oldhead} {\n        movehead $newhead $mainhead\n        movedhead $newhead $mainhead\n        set mainheadid $newhead\n        redrawtags $oldhead\n        redrawtags $newhead\n    }\n    if {$showlocalchanges} {\n        doshowlocalchanges\n    }\n    return 0\n}\n\n# context menu for a head\nproc headmenu {x y id head} {\n    global headmenuid headmenuhead headctxmenu mainhead headids\n\n    stopfinding\n    set headmenuid $id\n    set headmenuhead $head\n    array set state {0 normal 1 normal 2 normal}\n    if {[string match \"remotes/*\" $head]} {\n        set localhead [string range $head [expr [string last / $head] + 1] end]\n        if {[info exists headids($localhead)]} {\n            set state(0) disabled\n        }\n        array set state {1 disabled 2 disabled}\n    }\n    if {$head eq $mainhead} {\n        array set state {0 disabled 2 disabled}\n    }\n    foreach i {0 1 2} {\n        $headctxmenu entryconfigure $i -state $state($i)\n    }\n    tk_popup $headctxmenu $x $y\n}\n\nproc cobranch {} {\n    global headmenuid headmenuhead headids\n    global showlocalchanges\n\n    # check the tree is clean first??\n    set newhead $headmenuhead\n    set command [list | git checkout]\n    if {[string match \"remotes/*\" $newhead]} {\n        set remote $newhead\n        set newhead [string range $newhead [expr [string last / $newhead] + 1] end]\n        # The following check is redundant - the menu option should\n        # be disabled to begin with...\n        if {[info exists headids($newhead)]} {\n            error_popup [mc \"A local branch named %s exists already\" $newhead]\n            return\n        }\n        lappend command -b $newhead --track $remote\n    } else {\n        lappend command $newhead\n    }\n    lappend command 2>@1\n    nowbusy checkout [mc \"Checking out\"]\n    update\n    dohidelocalchanges\n    if {[catch {\n        set fd [open $command r]\n    } err]} {\n        notbusy checkout\n        error_popup $err\n        if {$showlocalchanges} {\n            dodiffindex\n        }\n    } else {\n        filerun $fd [list readcheckoutstat $fd $newhead $headmenuid]\n    }\n}\n\nproc readcheckoutstat {fd newhead newheadid} {\n    global mainhead mainheadid headids idheads showlocalchanges progresscoords\n    global viewmainheadid curview\n\n    if {[gets $fd line] >= 0} {\n        if {[regexp {([0-9]+)% \\(([0-9]+)/([0-9]+)\\)} $line match p m n]} {\n            set progresscoords [list 0 [expr {1.0 * $m / $n}]]\n            adjustprogress\n        }\n        return 1\n    }\n    set progresscoords {0 0}\n    adjustprogress\n    notbusy checkout\n    if {[catch {close $fd} err]} {\n        error_popup $err\n        return\n    }\n    set oldmainid $mainheadid\n    if {! [info exists headids($newhead)]} {\n        set headids($newhead) $newheadid\n        lappend idheads($newheadid) $newhead\n        addedhead $newheadid $newhead\n    }\n    set mainhead $newhead\n    set mainheadid $newheadid\n    set viewmainheadid($curview) $newheadid\n    redrawtags $oldmainid\n    redrawtags $newheadid\n    selbyid $newheadid\n    if {$showlocalchanges} {\n        dodiffindex\n    }\n}\n\nproc rmbranch {} {\n    global headmenuid headmenuhead mainhead\n    global idheads\n\n    set head $headmenuhead\n    set id $headmenuid\n    # this check shouldn't be needed any more...\n    if {$head eq $mainhead} {\n        error_popup [mc \"Cannot delete the currently checked-out branch\"]\n        return\n    }\n    set dheads [descheads $id]\n    if {[llength $dheads] == 1 && $idheads($dheads) eq $head} {\n        # the stuff on this branch isn't on any other branch\n        if {![confirm_popup [mc \"The commits on branch %s aren't on any other\\\n                        branch.\\nReally delete branch %s?\" $head $head]]} return\n    }\n    nowbusy rmbranch\n    update\n    if {[catch {exec git branch -D $head} err]} {\n        notbusy rmbranch\n        error_popup $err\n        return\n    }\n    removehead $id $head\n    removedhead $id $head\n    redrawtags $id\n    notbusy rmbranch\n    dispneartags 0\n    run refill_reflist\n}\n\n# Display a list of tags and heads\nproc showrefs {} {\n    global showrefstop bgcolor fgcolor selectbgcolor NS\n    global bglist fglist reflistfilter reflist maincursor\n\n    set top .showrefs\n    set showrefstop $top\n    if {[winfo exists $top]} {\n        raise $top\n        refill_reflist\n        return\n    }\n    ttk_toplevel $top\n    wm title $top [mc \"Tags and heads: %s\" [file tail [pwd]]]\n    make_transient $top .\n    text $top.list -background $bgcolor -foreground $fgcolor \\\n        -selectbackground $selectbgcolor -font mainfont \\\n        -xscrollcommand \"$top.xsb set\" -yscrollcommand \"$top.ysb set\" \\\n        -width 60 -height 20 -cursor $maincursor \\\n        -spacing1 1 -spacing3 1 -state disabled\n    $top.list tag configure highlight -background $selectbgcolor\n    if {![lsearch -exact $bglist $top.list]} {\n        lappend bglist $top.list\n        lappend fglist $top.list\n    }\n    ${NS}::scrollbar $top.ysb -command \"$top.list yview\" -orient vertical\n    ${NS}::scrollbar $top.xsb -command \"$top.list xview\" -orient horizontal\n    grid $top.list $top.ysb -sticky nsew\n    grid $top.xsb x -sticky ew\n    ${NS}::frame $top.f\n    ${NS}::label $top.f.l -text \"[mc \"Filter\"]: \"\n    ${NS}::entry $top.f.e -width 20 -textvariable reflistfilter\n    set reflistfilter \"*\"\n    trace add variable reflistfilter write reflistfilter_change\n    pack $top.f.e -side right -fill x -expand 1\n    pack $top.f.l -side left\n    grid $top.f - -sticky ew -pady 2\n    ${NS}::button $top.close -command [list destroy $top] -text [mc \"Close\"]\n    bind $top <Key-Escape> [list destroy $top]\n    grid $top.close -\n    grid columnconfigure $top 0 -weight 1\n    grid rowconfigure $top 0 -weight 1\n    bind $top.list <1> {break}\n    bind $top.list <B1-Motion> {break}\n    bind $top.list <ButtonRelease-1> {sel_reflist %W %x %y; break}\n    set reflist {}\n    refill_reflist\n}\n\nproc sel_reflist {w x y} {\n    global showrefstop reflist headids tagids otherrefids\n\n    if {![winfo exists $showrefstop]} return\n    set l [lindex [split [$w index \"@$x,$y\"] \".\"] 0]\n    set ref [lindex $reflist [expr {$l-1}]]\n    set n [lindex $ref 0]\n    switch -- [lindex $ref 1] {\n        \"H\" {selbyid $headids($n)}\n        \"R\" {selbyid $headids($n)}\n        \"T\" {selbyid $tagids($n)}\n        \"o\" {selbyid $otherrefids($n)}\n    }\n    $showrefstop.list tag add highlight $l.0 \"$l.0 lineend\"\n}\n\nproc unsel_reflist {} {\n    global showrefstop\n\n    if {![info exists showrefstop] || ![winfo exists $showrefstop]} return\n    $showrefstop.list tag remove highlight 0.0 end\n}\n\nproc reflistfilter_change {n1 n2 op} {\n    global reflistfilter\n\n    after cancel refill_reflist\n    after 200 refill_reflist\n}\n\nproc refill_reflist {} {\n    global reflist reflistfilter showrefstop headids tagids otherrefids\n    global curview\n\n    if {![info exists showrefstop] || ![winfo exists $showrefstop]} return\n    set refs {}\n    foreach n [array names headids] {\n        if {[string match $reflistfilter $n]} {\n            if {[commitinview $headids($n) $curview]} {\n                if {[string match \"remotes/*\" $n]} {\n                    lappend refs [list $n R]\n                } else {\n                    lappend refs [list $n H]\n                }\n            } else {\n                interestedin $headids($n) {run refill_reflist}\n            }\n        }\n    }\n    foreach n [array names tagids] {\n        if {[string match $reflistfilter $n]} {\n            if {[commitinview $tagids($n) $curview]} {\n                lappend refs [list $n T]\n            } else {\n                interestedin $tagids($n) {run refill_reflist}\n            }\n        }\n    }\n    foreach n [array names otherrefids] {\n        if {[string match $reflistfilter $n]} {\n            if {[commitinview $otherrefids($n) $curview]} {\n                lappend refs [list $n o]\n            } else {\n                interestedin $otherrefids($n) {run refill_reflist}\n            }\n        }\n    }\n    set refs [lsort -index 0 $refs]\n    if {$refs eq $reflist} return\n\n    # Update the contents of $showrefstop.list according to the\n    # differences between $reflist (old) and $refs (new)\n    $showrefstop.list conf -state normal\n    $showrefstop.list insert end \"\\n\"\n    set i 0\n    set j 0\n    while {$i < [llength $reflist] || $j < [llength $refs]} {\n        if {$i < [llength $reflist]} {\n            if {$j < [llength $refs]} {\n                set cmp [string compare [lindex $reflist $i 0] \\\n                             [lindex $refs $j 0]]\n                if {$cmp == 0} {\n                    set cmp [string compare [lindex $reflist $i 1] \\\n                                 [lindex $refs $j 1]]\n                }\n            } else {\n                set cmp -1\n            }\n        } else {\n            set cmp 1\n        }\n        switch -- $cmp {\n            -1 {\n                $showrefstop.list delete \"[expr {$j+1}].0\" \"[expr {$j+2}].0\"\n                incr i\n            }\n            0 {\n                incr i\n                incr j\n            }\n            1 {\n                set l [expr {$j + 1}]\n                $showrefstop.list image create $l.0 -align baseline \\\n                    -image reficon-[lindex $refs $j 1] -padx 2\n                $showrefstop.list insert $l.1 \"[lindex $refs $j 0]\\n\"\n                incr j\n            }\n        }\n    }\n    set reflist $refs\n    # delete last newline\n    $showrefstop.list delete end-2c end-1c\n    $showrefstop.list conf -state disabled\n}\n\n# Stuff for finding nearby tags\nproc getallcommits {} {\n    global allcommits nextarc seeds allccache allcwait cachedarcs allcupdate\n    global idheads idtags idotherrefs allparents tagobjid\n    global gitdir\n\n    if {![info exists allcommits]} {\n        set nextarc 0\n        set allcommits 0\n        set seeds {}\n        set allcwait 0\n        set cachedarcs 0\n        set allccache [file join $gitdir \"gitk.cache\"]\n        if {![catch {\n            set f [open $allccache r]\n            set allcwait 1\n            getcache $f\n        }]} return\n    }\n\n    if {$allcwait} {\n        return\n    }\n    set cmd [list | git rev-list --parents]\n    set allcupdate [expr {$seeds ne {}}]\n    if {!$allcupdate} {\n        set ids \"--all\"\n    } else {\n        set refs [concat [array names idheads] [array names idtags] \\\n                      [array names idotherrefs]]\n        set ids {}\n        set tagobjs {}\n        foreach name [array names tagobjid] {\n            lappend tagobjs $tagobjid($name)\n        }\n        foreach id [lsort -unique $refs] {\n            if {![info exists allparents($id)] &&\n                [lsearch -exact $tagobjs $id] < 0} {\n                lappend ids $id\n            }\n        }\n        if {$ids ne {}} {\n            foreach id $seeds {\n                lappend ids \"^$id\"\n            }\n            lappend ids \"--\"\n        }\n    }\n    if {$ids ne {}} {\n        if {$ids eq \"--all\"} {\n            set cmd [concat $cmd \"--all\"]\n        } else {\n            set cmd [concat $cmd --stdin \"<<[join $ids \"\\\\n\"]\"]\n        }\n        set fd [open $cmd r]\n        fconfigure $fd -blocking 0\n        incr allcommits\n        nowbusy allcommits\n        filerun $fd [list getallclines $fd]\n    } else {\n        dispneartags 0\n    }\n}\n\n# Since most commits have 1 parent and 1 child, we group strings of\n# such commits into \"arcs\" joining branch/merge points (BMPs), which\n# are commits that either don't have 1 parent or don't have 1 child.\n#\n# arcnos(id) - incoming arcs for BMP, arc we're on for other nodes\n# arcout(id) - outgoing arcs for BMP\n# arcids(a) - list of IDs on arc including end but not start\n# arcstart(a) - BMP ID at start of arc\n# arcend(a) - BMP ID at end of arc\n# growing(a) - arc a is still growing\n# arctags(a) - IDs out of arcids (excluding end) that have tags\n# archeads(a) - IDs out of arcids (excluding end) that have heads\n# The start of an arc is at the descendent end, so \"incoming\" means\n# coming from descendents, and \"outgoing\" means going towards ancestors.\n\nproc getallclines {fd} {\n    global allparents allchildren idtags idheads nextarc\n    global arcnos arcids arctags arcout arcend arcstart archeads growing\n    global seeds allcommits cachedarcs allcupdate\n\n    set nid 0\n    while {[incr nid] <= 1000 && [gets $fd line] >= 0} {\n        set id [lindex $line 0]\n        if {[info exists allparents($id)]} {\n            # seen it already\n            continue\n        }\n        set cachedarcs 0\n        set olds [lrange $line 1 end]\n        set allparents($id) $olds\n        if {![info exists allchildren($id)]} {\n            set allchildren($id) {}\n            set arcnos($id) {}\n            lappend seeds $id\n        } else {\n            set a $arcnos($id)\n            if {[llength $olds] == 1 && [llength $a] == 1} {\n                lappend arcids($a) $id\n                if {[info exists idtags($id)]} {\n                    lappend arctags($a) $id\n                }\n                if {[info exists idheads($id)]} {\n                    lappend archeads($a) $id\n                }\n                if {[info exists allparents($olds)]} {\n                    # seen parent already\n                    if {![info exists arcout($olds)]} {\n                        splitarc $olds\n                    }\n                    lappend arcids($a) $olds\n                    set arcend($a) $olds\n                    unset growing($a)\n                }\n                lappend allchildren($olds) $id\n                lappend arcnos($olds) $a\n                continue\n            }\n        }\n        foreach a $arcnos($id) {\n            lappend arcids($a) $id\n            set arcend($a) $id\n            unset growing($a)\n        }\n\n        set ao {}\n        foreach p $olds {\n            lappend allchildren($p) $id\n            set a [incr nextarc]\n            set arcstart($a) $id\n            set archeads($a) {}\n            set arctags($a) {}\n            set archeads($a) {}\n            set arcids($a) {}\n            lappend ao $a\n            set growing($a) 1\n            if {[info exists allparents($p)]} {\n                # seen it already, may need to make a new branch\n                if {![info exists arcout($p)]} {\n                    splitarc $p\n                }\n                lappend arcids($a) $p\n                set arcend($a) $p\n                unset growing($a)\n            }\n            lappend arcnos($p) $a\n        }\n        set arcout($id) $ao\n    }\n    if {$nid > 0} {\n        global cached_dheads cached_dtags cached_atags\n        unset -nocomplain cached_dheads\n        unset -nocomplain cached_dtags\n        unset -nocomplain cached_atags\n    }\n    if {![eof $fd]} {\n        return [expr {$nid >= 1000? 2: 1}]\n    }\n    set cacheok 1\n    if {[catch {\n        fconfigure $fd -blocking 1\n        close $fd\n    } err]} {\n        # got an error reading the list of commits\n        # if we were updating, try rereading the whole thing again\n        if {$allcupdate} {\n            incr allcommits -1\n            dropcache $err\n            return\n        }\n        error_popup \"[mc \"Error reading commit topology information;\\\n                branch and preceding/following tag information\\\n                will be incomplete.\"]\\n($err)\"\n        set cacheok 0\n    }\n    if {[incr allcommits -1] == 0} {\n        notbusy allcommits\n        if {$cacheok} {\n            run savecache\n        }\n    }\n    dispneartags 0\n    return 0\n}\n\nproc recalcarc {a} {\n    global arctags archeads arcids idtags idheads\n\n    set at {}\n    set ah {}\n    foreach id [lrange $arcids($a) 0 end-1] {\n        if {[info exists idtags($id)]} {\n            lappend at $id\n        }\n        if {[info exists idheads($id)]} {\n            lappend ah $id\n        }\n    }\n    set arctags($a) $at\n    set archeads($a) $ah\n}\n\nproc splitarc {p} {\n    global arcnos arcids nextarc arctags archeads idtags idheads\n    global arcstart arcend arcout allparents growing\n\n    set a $arcnos($p)\n    if {[llength $a] != 1} {\n        puts \"oops splitarc called but [llength $a] arcs already\"\n        return\n    }\n    set a [lindex $a 0]\n    set i [lsearch -exact $arcids($a) $p]\n    if {$i < 0} {\n        puts \"oops splitarc $p not in arc $a\"\n        return\n    }\n    set na [incr nextarc]\n    if {[info exists arcend($a)]} {\n        set arcend($na) $arcend($a)\n    } else {\n        set l [lindex $allparents([lindex $arcids($a) end]) 0]\n        set j [lsearch -exact $arcnos($l) $a]\n        set arcnos($l) [lreplace $arcnos($l) $j $j $na]\n    }\n    set tail [lrange $arcids($a) [expr {$i+1}] end]\n    set arcids($a) [lrange $arcids($a) 0 $i]\n    set arcend($a) $p\n    set arcstart($na) $p\n    set arcout($p) $na\n    set arcids($na) $tail\n    if {[info exists growing($a)]} {\n        set growing($na) 1\n        unset growing($a)\n    }\n\n    foreach id $tail {\n        if {[llength $arcnos($id)] == 1} {\n            set arcnos($id) $na\n        } else {\n            set j [lsearch -exact $arcnos($id) $a]\n            set arcnos($id) [lreplace $arcnos($id) $j $j $na]\n        }\n    }\n\n    # reconstruct tags and heads lists\n    if {$arctags($a) ne {} || $archeads($a) ne {}} {\n        recalcarc $a\n        recalcarc $na\n    } else {\n        set arctags($na) {}\n        set archeads($na) {}\n    }\n}\n\n# Update things for a new commit added that is a child of one\n# existing commit.  Used when cherry-picking.\nproc addnewchild {id p} {\n    global allparents allchildren idtags nextarc\n    global arcnos arcids arctags arcout arcend arcstart archeads growing\n    global seeds allcommits\n\n    if {![info exists allcommits] || ![info exists arcnos($p)]} return\n    set allparents($id) [list $p]\n    set allchildren($id) {}\n    set arcnos($id) {}\n    lappend seeds $id\n    lappend allchildren($p) $id\n    set a [incr nextarc]\n    set arcstart($a) $id\n    set archeads($a) {}\n    set arctags($a) {}\n    set arcids($a) [list $p]\n    set arcend($a) $p\n    if {![info exists arcout($p)]} {\n        splitarc $p\n    }\n    lappend arcnos($p) $a\n    set arcout($id) [list $a]\n}\n\n# This implements a cache for the topology information.\n# The cache saves, for each arc, the start and end of the arc,\n# the ids on the arc, and the outgoing arcs from the end.\nproc readcache {f} {\n    global arcnos arcids arcout arcstart arcend arctags archeads nextarc\n    global idtags idheads allparents cachedarcs possible_seeds seeds growing\n    global allcwait\n\n    set a $nextarc\n    set lim $cachedarcs\n    if {$lim - $a > 500} {\n        set lim [expr {$a + 500}]\n    }\n    if {[catch {\n        if {$a == $lim} {\n            # finish reading the cache and setting up arctags, etc.\n            set line [gets $f]\n            if {$line ne \"1\"} {error \"bad final version\"}\n            close $f\n            foreach id [array names idtags] {\n                if {[info exists arcnos($id)] && [llength $arcnos($id)] == 1 &&\n                    [llength $allparents($id)] == 1} {\n                    set a [lindex $arcnos($id) 0]\n                    if {$arctags($a) eq {}} {\n                        recalcarc $a\n                    }\n                }\n            }\n            foreach id [array names idheads] {\n                if {[info exists arcnos($id)] && [llength $arcnos($id)] == 1 &&\n                    [llength $allparents($id)] == 1} {\n                    set a [lindex $arcnos($id) 0]\n                    if {$archeads($a) eq {}} {\n                        recalcarc $a\n                    }\n                }\n            }\n            foreach id [lsort -unique $possible_seeds] {\n                if {$arcnos($id) eq {}} {\n                    lappend seeds $id\n                }\n            }\n            set allcwait 0\n        } else {\n            while {[incr a] <= $lim} {\n                set line [gets $f]\n                if {[llength $line] != 3} {error \"bad line\"}\n                set s [lindex $line 0]\n                set arcstart($a) $s\n                lappend arcout($s) $a\n                if {![info exists arcnos($s)]} {\n                    lappend possible_seeds $s\n                    set arcnos($s) {}\n                }\n                set e [lindex $line 1]\n                if {$e eq {}} {\n                    set growing($a) 1\n                } else {\n                    set arcend($a) $e\n                    if {![info exists arcout($e)]} {\n                        set arcout($e) {}\n                    }\n                }\n                set arcids($a) [lindex $line 2]\n                foreach id $arcids($a) {\n                    lappend allparents($s) $id\n                    set s $id\n                    lappend arcnos($id) $a\n                }\n                if {![info exists allparents($s)]} {\n                    set allparents($s) {}\n                }\n                set arctags($a) {}\n                set archeads($a) {}\n            }\n            set nextarc [expr {$a - 1}]\n        }\n    } err]} {\n        dropcache $err\n        return 0\n    }\n    if {!$allcwait} {\n        getallcommits\n    }\n    return $allcwait\n}\n\nproc getcache {f} {\n    global nextarc cachedarcs possible_seeds\n\n    if {[catch {\n        set line [gets $f]\n        if {[llength $line] != 2 || [lindex $line 0] ne \"1\"} {error \"bad version\"}\n        # make sure it's an integer\n        set cachedarcs [expr {int([lindex $line 1])}]\n        if {$cachedarcs < 0} {error \"bad number of arcs\"}\n        set nextarc 0\n        set possible_seeds {}\n        run readcache $f\n    } err]} {\n        dropcache $err\n    }\n    return 0\n}\n\nproc dropcache {err} {\n    global allcwait nextarc cachedarcs seeds\n\n    #puts \"dropping cache ($err)\"\n    foreach v {arcnos arcout arcids arcstart arcend growing \\\n                   arctags archeads allparents allchildren} {\n        global $v\n        unset -nocomplain $v\n    }\n    set allcwait 0\n    set nextarc 0\n    set cachedarcs 0\n    set seeds {}\n    getallcommits\n}\n\nproc writecache {f} {\n    global cachearc cachedarcs allccache\n    global arcstart arcend arcnos arcids arcout\n\n    set a $cachearc\n    set lim $cachedarcs\n    if {$lim - $a > 1000} {\n        set lim [expr {$a + 1000}]\n    }\n    if {[catch {\n        while {[incr a] <= $lim} {\n            if {[info exists arcend($a)]} {\n                puts $f [list $arcstart($a) $arcend($a) $arcids($a)]\n            } else {\n                puts $f [list $arcstart($a) {} $arcids($a)]\n            }\n        }\n    } err]} {\n        catch {close $f}\n        catch {file delete $allccache}\n        #puts \"writing cache failed ($err)\"\n        return 0\n    }\n    set cachearc [expr {$a - 1}]\n    if {$a > $cachedarcs} {\n        puts $f \"1\"\n        close $f\n        return 0\n    }\n    return 1\n}\n\nproc savecache {} {\n    global nextarc cachedarcs cachearc allccache\n\n    if {$nextarc == $cachedarcs} return\n    set cachearc 0\n    set cachedarcs $nextarc\n    catch {\n        set f [open $allccache w]\n        puts $f [list 1 $cachedarcs]\n        run writecache $f\n    }\n}\n\n# Returns 1 if a is an ancestor of b, -1 if b is an ancestor of a,\n# or 0 if neither is true.\nproc anc_or_desc {a b} {\n    global arcout arcstart arcend arcnos cached_isanc\n\n    if {$arcnos($a) eq $arcnos($b)} {\n        # Both are on the same arc(s); either both are the same BMP,\n        # or if one is not a BMP, the other is also not a BMP or is\n        # the BMP at end of the arc (and it only has 1 incoming arc).\n        # Or both can be BMPs with no incoming arcs.\n        if {$a eq $b || $arcnos($a) eq {}} {\n            return 0\n        }\n        # assert {[llength $arcnos($a)] == 1}\n        set arc [lindex $arcnos($a) 0]\n        set i [lsearch -exact $arcids($arc) $a]\n        set j [lsearch -exact $arcids($arc) $b]\n        if {$i < 0 || $i > $j} {\n            return 1\n        } else {\n            return -1\n        }\n    }\n\n    if {![info exists arcout($a)]} {\n        set arc [lindex $arcnos($a) 0]\n        if {[info exists arcend($arc)]} {\n            set aend $arcend($arc)\n        } else {\n            set aend {}\n        }\n        set a $arcstart($arc)\n    } else {\n        set aend $a\n    }\n    if {![info exists arcout($b)]} {\n        set arc [lindex $arcnos($b) 0]\n        if {[info exists arcend($arc)]} {\n            set bend $arcend($arc)\n        } else {\n            set bend {}\n        }\n        set b $arcstart($arc)\n    } else {\n        set bend $b\n    }\n    if {$a eq $bend} {\n        return 1\n    }\n    if {$b eq $aend} {\n        return -1\n    }\n    if {[info exists cached_isanc($a,$bend)]} {\n        if {$cached_isanc($a,$bend)} {\n            return 1\n        }\n    }\n    if {[info exists cached_isanc($b,$aend)]} {\n        if {$cached_isanc($b,$aend)} {\n            return -1\n        }\n        if {[info exists cached_isanc($a,$bend)]} {\n            return 0\n        }\n    }\n\n    set todo [list $a $b]\n    set anc($a) a\n    set anc($b) b\n    for {set i 0} {$i < [llength $todo]} {incr i} {\n        set x [lindex $todo $i]\n        if {$anc($x) eq {}} {\n            continue\n        }\n        foreach arc $arcnos($x) {\n            set xd $arcstart($arc)\n            if {$xd eq $bend} {\n                set cached_isanc($a,$bend) 1\n                set cached_isanc($b,$aend) 0\n                return 1\n            } elseif {$xd eq $aend} {\n                set cached_isanc($b,$aend) 1\n                set cached_isanc($a,$bend) 0\n                return -1\n            }\n            if {![info exists anc($xd)]} {\n                set anc($xd) $anc($x)\n                lappend todo $xd\n            } elseif {$anc($xd) ne $anc($x)} {\n                set anc($xd) {}\n            }\n        }\n    }\n    set cached_isanc($a,$bend) 0\n    set cached_isanc($b,$aend) 0\n    return 0\n}\n\n# This identifies whether $desc has an ancestor that is\n# a growing tip of the graph and which is not an ancestor of $anc\n# and returns 0 if so and 1 if not.\n# If we subsequently discover a tag on such a growing tip, and that\n# turns out to be a descendent of $anc (which it could, since we\n# don't necessarily see children before parents), then $desc\n# isn't a good choice to display as a descendent tag of\n# $anc (since it is the descendent of another tag which is\n# a descendent of $anc).  Similarly, $anc isn't a good choice to\n# display as a ancestor tag of $desc.\n#\nproc is_certain {desc anc} {\n    global arcnos arcout arcstart arcend growing problems\n\n    set certain {}\n    if {[llength $arcnos($anc)] == 1} {\n        # tags on the same arc are certain\n        if {$arcnos($desc) eq $arcnos($anc)} {\n            return 1\n        }\n        if {![info exists arcout($anc)]} {\n            # if $anc is partway along an arc, use the start of the arc instead\n            set a [lindex $arcnos($anc) 0]\n            set anc $arcstart($a)\n        }\n    }\n    if {[llength $arcnos($desc)] > 1 || [info exists arcout($desc)]} {\n        set x $desc\n    } else {\n        set a [lindex $arcnos($desc) 0]\n        set x $arcend($a)\n    }\n    if {$x == $anc} {\n        return 1\n    }\n    set anclist [list $x]\n    set dl($x) 1\n    set nnh 1\n    set ngrowanc 0\n    for {set i 0} {$i < [llength $anclist] && ($nnh > 0 || $ngrowanc > 0)} {incr i} {\n        set x [lindex $anclist $i]\n        if {$dl($x)} {\n            incr nnh -1\n        }\n        set done($x) 1\n        foreach a $arcout($x) {\n            if {[info exists growing($a)]} {\n                if {![info exists growanc($x)] && $dl($x)} {\n                    set growanc($x) 1\n                    incr ngrowanc\n                }\n            } else {\n                set y $arcend($a)\n                if {[info exists dl($y)]} {\n                    if {$dl($y)} {\n                        if {!$dl($x)} {\n                            set dl($y) 0\n                            if {![info exists done($y)]} {\n                                incr nnh -1\n                            }\n                            if {[info exists growanc($x)]} {\n                                incr ngrowanc -1\n                            }\n                            set xl [list $y]\n                            for {set k 0} {$k < [llength $xl]} {incr k} {\n                                set z [lindex $xl $k]\n                                foreach c $arcout($z) {\n                                    if {[info exists arcend($c)]} {\n                                        set v $arcend($c)\n                                        if {[info exists dl($v)] && $dl($v)} {\n                                            set dl($v) 0\n                                            if {![info exists done($v)]} {\n                                                incr nnh -1\n                                            }\n                                            if {[info exists growanc($v)]} {\n                                                incr ngrowanc -1\n                                            }\n                                            lappend xl $v\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } elseif {$y eq $anc || !$dl($x)} {\n                    set dl($y) 0\n                    lappend anclist $y\n                } else {\n                    set dl($y) 1\n                    lappend anclist $y\n                    incr nnh\n                }\n            }\n        }\n    }\n    foreach x [array names growanc] {\n        if {$dl($x)} {\n            return 0\n        }\n        return 0\n    }\n    return 1\n}\n\nproc validate_arctags {a} {\n    global arctags idtags\n\n    set i -1\n    set na $arctags($a)\n    foreach id $arctags($a) {\n        incr i\n        if {![info exists idtags($id)]} {\n            set na [lreplace $na $i $i]\n            incr i -1\n        }\n    }\n    set arctags($a) $na\n}\n\nproc validate_archeads {a} {\n    global archeads idheads\n\n    set i -1\n    set na $archeads($a)\n    foreach id $archeads($a) {\n        incr i\n        if {![info exists idheads($id)]} {\n            set na [lreplace $na $i $i]\n            incr i -1\n        }\n    }\n    set archeads($a) $na\n}\n\n# Return the list of IDs that have tags that are descendents of id,\n# ignoring IDs that are descendents of IDs already reported.\nproc desctags {id} {\n    global arcnos arcstart arcids arctags idtags allparents\n    global growing cached_dtags\n\n    if {![info exists allparents($id)]} {\n        return {}\n    }\n    set t1 [clock clicks -milliseconds]\n    set argid $id\n    if {[llength $arcnos($id)] == 1 && [llength $allparents($id)] == 1} {\n        # part-way along an arc; check that arc first\n        set a [lindex $arcnos($id) 0]\n        if {$arctags($a) ne {}} {\n            validate_arctags $a\n            set i [lsearch -exact $arcids($a) $id]\n            set tid {}\n            foreach t $arctags($a) {\n                set j [lsearch -exact $arcids($a) $t]\n                if {$j >= $i} break\n                set tid $t\n            }\n            if {$tid ne {}} {\n                return $tid\n            }\n        }\n        set id $arcstart($a)\n        if {[info exists idtags($id)]} {\n            return $id\n        }\n    }\n    if {[info exists cached_dtags($id)]} {\n        return $cached_dtags($id)\n    }\n\n    set origid $id\n    set todo [list $id]\n    set queued($id) 1\n    set nc 1\n    for {set i 0} {$i < [llength $todo] && $nc > 0} {incr i} {\n        set id [lindex $todo $i]\n        set done($id) 1\n        set ta [info exists hastaggedancestor($id)]\n        if {!$ta} {\n            incr nc -1\n        }\n        # ignore tags on starting node\n        if {!$ta && $i > 0} {\n            if {[info exists idtags($id)]} {\n                set tagloc($id) $id\n                set ta 1\n            } elseif {[info exists cached_dtags($id)]} {\n                set tagloc($id) $cached_dtags($id)\n                set ta 1\n            }\n        }\n        foreach a $arcnos($id) {\n            set d $arcstart($a)\n            if {!$ta && $arctags($a) ne {}} {\n                validate_arctags $a\n                if {$arctags($a) ne {}} {\n                    lappend tagloc($id) [lindex $arctags($a) end]\n                }\n            }\n            if {$ta || $arctags($a) ne {}} {\n                set tomark [list $d]\n                for {set j 0} {$j < [llength $tomark]} {incr j} {\n                    set dd [lindex $tomark $j]\n                    if {![info exists hastaggedancestor($dd)]} {\n                        if {[info exists done($dd)]} {\n                            foreach b $arcnos($dd) {\n                                lappend tomark $arcstart($b)\n                            }\n                            if {[info exists tagloc($dd)]} {\n                                unset tagloc($dd)\n                            }\n                        } elseif {[info exists queued($dd)]} {\n                            incr nc -1\n                        }\n                        set hastaggedancestor($dd) 1\n                    }\n                }\n            }\n            if {![info exists queued($d)]} {\n                lappend todo $d\n                set queued($d) 1\n                if {![info exists hastaggedancestor($d)]} {\n                    incr nc\n                }\n            }\n        }\n    }\n    set tags {}\n    foreach id [array names tagloc] {\n        if {![info exists hastaggedancestor($id)]} {\n            foreach t $tagloc($id) {\n                if {[lsearch -exact $tags $t] < 0} {\n                    lappend tags $t\n                }\n            }\n        }\n    }\n    set t2 [clock clicks -milliseconds]\n    set loopix $i\n\n    # remove tags that are descendents of other tags\n    for {set i 0} {$i < [llength $tags]} {incr i} {\n        set a [lindex $tags $i]\n        for {set j 0} {$j < $i} {incr j} {\n            set b [lindex $tags $j]\n            set r [anc_or_desc $a $b]\n            if {$r == 1} {\n                set tags [lreplace $tags $j $j]\n                incr j -1\n                incr i -1\n            } elseif {$r == -1} {\n                set tags [lreplace $tags $i $i]\n                incr i -1\n                break\n            }\n        }\n    }\n\n    if {[array names growing] ne {}} {\n        # graph isn't finished, need to check if any tag could get\n        # eclipsed by another tag coming later.  Simply ignore any\n        # tags that could later get eclipsed.\n        set ctags {}\n        foreach t $tags {\n            if {[is_certain $t $origid]} {\n                lappend ctags $t\n            }\n        }\n        if {$tags eq $ctags} {\n            set cached_dtags($origid) $tags\n        } else {\n            set tags $ctags\n        }\n    } else {\n        set cached_dtags($origid) $tags\n    }\n    set t3 [clock clicks -milliseconds]\n    if {0 && $t3 - $t1 >= 100} {\n        puts \"iterating descendents ($loopix/[llength $todo] nodes) took\\\n            [expr {$t2-$t1}]+[expr {$t3-$t2}]ms, $nc candidates left\"\n    }\n    return $tags\n}\n\nproc anctags {id} {\n    global arcnos arcids arcout arcend arctags idtags allparents\n    global growing cached_atags\n\n    if {![info exists allparents($id)]} {\n        return {}\n    }\n    set t1 [clock clicks -milliseconds]\n    set argid $id\n    if {[llength $arcnos($id)] == 1 && [llength $allparents($id)] == 1} {\n        # part-way along an arc; check that arc first\n        set a [lindex $arcnos($id) 0]\n        if {$arctags($a) ne {}} {\n            validate_arctags $a\n            set i [lsearch -exact $arcids($a) $id]\n            foreach t $arctags($a) {\n                set j [lsearch -exact $arcids($a) $t]\n                if {$j > $i} {\n                    return $t\n                }\n            }\n        }\n        if {![info exists arcend($a)]} {\n            return {}\n        }\n        set id $arcend($a)\n        if {[info exists idtags($id)]} {\n            return $id\n        }\n    }\n    if {[info exists cached_atags($id)]} {\n        return $cached_atags($id)\n    }\n\n    set origid $id\n    set todo [list $id]\n    set queued($id) 1\n    set taglist {}\n    set nc 1\n    for {set i 0} {$i < [llength $todo] && $nc > 0} {incr i} {\n        set id [lindex $todo $i]\n        set done($id) 1\n        set td [info exists hastaggeddescendent($id)]\n        if {!$td} {\n            incr nc -1\n        }\n        # ignore tags on starting node\n        if {!$td && $i > 0} {\n            if {[info exists idtags($id)]} {\n                set tagloc($id) $id\n                set td 1\n            } elseif {[info exists cached_atags($id)]} {\n                set tagloc($id) $cached_atags($id)\n                set td 1\n            }\n        }\n        foreach a $arcout($id) {\n            if {!$td && $arctags($a) ne {}} {\n                validate_arctags $a\n                if {$arctags($a) ne {}} {\n                    lappend tagloc($id) [lindex $arctags($a) 0]\n                }\n            }\n            if {![info exists arcend($a)]} continue\n            set d $arcend($a)\n            if {$td || $arctags($a) ne {}} {\n                set tomark [list $d]\n                for {set j 0} {$j < [llength $tomark]} {incr j} {\n                    set dd [lindex $tomark $j]\n                    if {![info exists hastaggeddescendent($dd)]} {\n                        if {[info exists done($dd)]} {\n                            foreach b $arcout($dd) {\n                                if {[info exists arcend($b)]} {\n                                    lappend tomark $arcend($b)\n                                }\n                            }\n                            if {[info exists tagloc($dd)]} {\n                                unset tagloc($dd)\n                            }\n                        } elseif {[info exists queued($dd)]} {\n                            incr nc -1\n                        }\n                        set hastaggeddescendent($dd) 1\n                    }\n                }\n            }\n            if {![info exists queued($d)]} {\n                lappend todo $d\n                set queued($d) 1\n                if {![info exists hastaggeddescendent($d)]} {\n                    incr nc\n                }\n            }\n        }\n    }\n    set t2 [clock clicks -milliseconds]\n    set loopix $i\n    set tags {}\n    foreach id [array names tagloc] {\n        if {![info exists hastaggeddescendent($id)]} {\n            foreach t $tagloc($id) {\n                if {[lsearch -exact $tags $t] < 0} {\n                    lappend tags $t\n                }\n            }\n        }\n    }\n\n    # remove tags that are ancestors of other tags\n    for {set i 0} {$i < [llength $tags]} {incr i} {\n        set a [lindex $tags $i]\n        for {set j 0} {$j < $i} {incr j} {\n            set b [lindex $tags $j]\n            set r [anc_or_desc $a $b]\n            if {$r == -1} {\n                set tags [lreplace $tags $j $j]\n                incr j -1\n                incr i -1\n            } elseif {$r == 1} {\n                set tags [lreplace $tags $i $i]\n                incr i -1\n                break\n            }\n        }\n    }\n\n    if {[array names growing] ne {}} {\n        # graph isn't finished, need to check if any tag could get\n        # eclipsed by another tag coming later.  Simply ignore any\n        # tags that could later get eclipsed.\n        set ctags {}\n        foreach t $tags {\n            if {[is_certain $origid $t]} {\n                lappend ctags $t\n            }\n        }\n        if {$tags eq $ctags} {\n            set cached_atags($origid) $tags\n        } else {\n            set tags $ctags\n        }\n    } else {\n        set cached_atags($origid) $tags\n    }\n    set t3 [clock clicks -milliseconds]\n    if {0 && $t3 - $t1 >= 100} {\n        puts \"iterating ancestors ($loopix/[llength $todo] nodes) took\\\n            [expr {$t2-$t1}]+[expr {$t3-$t2}]ms, $nc candidates left\"\n    }\n    return $tags\n}\n\n# Return the list of IDs that have heads that are descendents of id,\n# including id itself if it has a head.\nproc descheads {id} {\n    global arcnos arcstart arcids archeads idheads cached_dheads\n    global allparents arcout\n\n    if {![info exists allparents($id)]} {\n        return {}\n    }\n    set aret {}\n    if {![info exists arcout($id)]} {\n        # part-way along an arc; check it first\n        set a [lindex $arcnos($id) 0]\n        if {$archeads($a) ne {}} {\n            validate_archeads $a\n            set i [lsearch -exact $arcids($a) $id]\n            foreach t $archeads($a) {\n                set j [lsearch -exact $arcids($a) $t]\n                if {$j > $i} break\n                lappend aret $t\n            }\n        }\n        set id $arcstart($a)\n    }\n    set origid $id\n    set todo [list $id]\n    set seen($id) 1\n    set ret {}\n    for {set i 0} {$i < [llength $todo]} {incr i} {\n        set id [lindex $todo $i]\n        if {[info exists cached_dheads($id)]} {\n            set ret [concat $ret $cached_dheads($id)]\n        } else {\n            if {[info exists idheads($id)]} {\n                lappend ret $id\n            }\n            foreach a $arcnos($id) {\n                if {$archeads($a) ne {}} {\n                    validate_archeads $a\n                    if {$archeads($a) ne {}} {\n                        set ret [concat $ret $archeads($a)]\n                    }\n                }\n                set d $arcstart($a)\n                if {![info exists seen($d)]} {\n                    lappend todo $d\n                    set seen($d) 1\n                }\n            }\n        }\n    }\n    set ret [lsort -unique $ret]\n    set cached_dheads($origid) $ret\n    return [concat $ret $aret]\n}\n\nproc addedtag {id} {\n    global arcnos arcout cached_dtags cached_atags\n\n    if {![info exists arcnos($id)]} return\n    if {![info exists arcout($id)]} {\n        recalcarc [lindex $arcnos($id) 0]\n    }\n    unset -nocomplain cached_dtags\n    unset -nocomplain cached_atags\n}\n\nproc addedhead {hid head} {\n    global arcnos arcout cached_dheads\n\n    if {![info exists arcnos($hid)]} return\n    if {![info exists arcout($hid)]} {\n        recalcarc [lindex $arcnos($hid) 0]\n    }\n    unset -nocomplain cached_dheads\n}\n\nproc removedhead {hid head} {\n    global cached_dheads\n\n    unset -nocomplain cached_dheads\n}\n\nproc movedhead {hid head} {\n    global arcnos arcout cached_dheads\n\n    if {![info exists arcnos($hid)]} return\n    if {![info exists arcout($hid)]} {\n        recalcarc [lindex $arcnos($hid) 0]\n    }\n    unset -nocomplain cached_dheads\n}\n\nproc changedrefs {} {\n    global cached_dheads cached_dtags cached_atags cached_tagcontent\n    global arctags archeads arcnos arcout idheads idtags\n\n    foreach id [concat [array names idheads] [array names idtags]] {\n        if {[info exists arcnos($id)] && ![info exists arcout($id)]} {\n            set a [lindex $arcnos($id) 0]\n            if {![info exists donearc($a)]} {\n                recalcarc $a\n                set donearc($a) 1\n            }\n        }\n    }\n    unset -nocomplain cached_tagcontent\n    unset -nocomplain cached_dtags\n    unset -nocomplain cached_atags\n    unset -nocomplain cached_dheads\n}\n\nproc rereadrefs {} {\n    global idtags idheads idotherrefs mainheadid\n\n    set refids [concat [array names idtags] \\\n                    [array names idheads] [array names idotherrefs]]\n    foreach id $refids {\n        if {![info exists ref($id)]} {\n            set ref($id) [listrefs $id]\n        }\n    }\n    set oldmainhead $mainheadid\n    readrefs\n    changedrefs\n    set refids [lsort -unique [concat $refids [array names idtags] \\\n                        [array names idheads] [array names idotherrefs]]]\n    foreach id $refids {\n        set v [listrefs $id]\n        if {![info exists ref($id)] || $ref($id) != $v} {\n            redrawtags $id\n        }\n    }\n    if {$oldmainhead ne $mainheadid} {\n        redrawtags $oldmainhead\n        redrawtags $mainheadid\n    }\n    run refill_reflist\n}\n\nproc listrefs {id} {\n    global idtags idheads idotherrefs\n\n    set x {}\n    if {[info exists idtags($id)]} {\n        set x $idtags($id)\n    }\n    set y {}\n    if {[info exists idheads($id)]} {\n        set y $idheads($id)\n    }\n    set z {}\n    if {[info exists idotherrefs($id)]} {\n        set z $idotherrefs($id)\n    }\n    return [list $x $y $z]\n}\n\nproc add_tag_ctext {tag} {\n    global ctext cached_tagcontent tagids\n\n    if {![info exists cached_tagcontent($tag)]} {\n        catch {\n            set cached_tagcontent($tag) [exec git cat-file -p $tag]\n        }\n    }\n    $ctext insert end \"[mc \"Tag\"]: $tag\\n\" bold\n    if {[info exists cached_tagcontent($tag)]} {\n        set text $cached_tagcontent($tag)\n    } else {\n        set text \"[mc \"Id\"]:  $tagids($tag)\"\n    }\n    appendwithlinks $text {}\n}\n\nproc showtag {tag isnew} {\n    global ctext cached_tagcontent tagids linknum tagobjid\n\n    if {$isnew} {\n        addtohistory [list showtag $tag 0] savectextpos\n    }\n    $ctext conf -state normal\n    clear_ctext\n    settabs 0\n    set linknum 0\n    add_tag_ctext $tag\n    maybe_scroll_ctext 1\n    $ctext conf -state disabled\n    init_flist {}\n}\n\nproc showtags {id isnew} {\n    global idtags ctext linknum\n\n    if {$isnew} {\n        addtohistory [list showtags $id 0] savectextpos\n    }\n    $ctext conf -state normal\n    clear_ctext\n    settabs 0\n    set linknum 0\n    set sep {}\n    foreach tag $idtags($id) {\n        $ctext insert end $sep\n        add_tag_ctext $tag\n        set sep \"\\n\\n\"\n    }\n    maybe_scroll_ctext 1\n    $ctext conf -state disabled\n    init_flist {}\n}\n\nproc doquit {} {\n    global stopped\n    global gitktmpdir\n\n    set stopped 100\n    savestuff .\n    destroy .\n\n    if {[info exists gitktmpdir]} {\n        catch {file delete -force $gitktmpdir}\n    }\n}\n\nproc mkfontdisp {font top which} {\n    global fontattr fontpref $font NS use_ttk\n\n    set fontpref($font) [set $font]\n    ${NS}::button $top.${font}but -text $which \\\n        -command [list choosefont $font $which]\n    ${NS}::label $top.$font -relief flat -font $font \\\n        -text $fontattr($font,family) -justify left\n    grid x $top.${font}but $top.$font -sticky w\n}\n\nproc choosefont {font which} {\n    global fontparam fontlist fonttop fontattr\n    global prefstop NS\n\n    set fontparam(which) $which\n    set fontparam(font) $font\n    set fontparam(family) [font actual $font -family]\n    set fontparam(size) $fontattr($font,size)\n    set fontparam(weight) $fontattr($font,weight)\n    set fontparam(slant) $fontattr($font,slant)\n    set top .gitkfont\n    set fonttop $top\n    if {![winfo exists $top]} {\n        font create sample\n        eval font config sample [font actual $font]\n        ttk_toplevel $top\n        make_transient $top $prefstop\n        wm title $top [mc \"Gitk font chooser\"]\n        ${NS}::label $top.l -textvariable fontparam(which)\n        pack $top.l -side top\n        set fontlist [lsort [font families]]\n        ${NS}::frame $top.f\n        listbox $top.f.fam -listvariable fontlist \\\n            -yscrollcommand [list $top.f.sb set]\n        bind $top.f.fam <<ListboxSelect>> selfontfam\n        ${NS}::scrollbar $top.f.sb -command [list $top.f.fam yview]\n        pack $top.f.sb -side right -fill y\n        pack $top.f.fam -side left -fill both -expand 1\n        pack $top.f -side top -fill both -expand 1\n        ${NS}::frame $top.g\n        spinbox $top.g.size -from 4 -to 40 -width 4 \\\n            -textvariable fontparam(size) \\\n            -validatecommand {string is integer -strict %s}\n        checkbutton $top.g.bold -padx 5 \\\n            -font {{Times New Roman} 12 bold} -text [mc \"B\"] -indicatoron 0 \\\n            -variable fontparam(weight) -onvalue bold -offvalue normal\n        checkbutton $top.g.ital -padx 5 \\\n            -font {{Times New Roman} 12 italic} -text [mc \"I\"] -indicatoron 0  \\\n            -variable fontparam(slant) -onvalue italic -offvalue roman\n        pack $top.g.size $top.g.bold $top.g.ital -side left\n        pack $top.g -side top\n        canvas $top.c -width 150 -height 50 -border 2 -relief sunk \\\n            -background white\n        $top.c create text 100 25 -anchor center -text $which -font sample \\\n            -fill black -tags text\n        bind $top.c <Configure> [list centertext $top.c]\n        pack $top.c -side top -fill x\n        ${NS}::frame $top.buts\n        ${NS}::button $top.buts.ok -text [mc \"OK\"] -command fontok -default active\n        ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command fontcan -default normal\n        bind $top <Key-Return> fontok\n        bind $top <Key-Escape> fontcan\n        grid $top.buts.ok $top.buts.can\n        grid columnconfigure $top.buts 0 -weight 1 -uniform a\n        grid columnconfigure $top.buts 1 -weight 1 -uniform a\n        pack $top.buts -side bottom -fill x\n        trace add variable fontparam write chg_fontparam\n    } else {\n        raise $top\n        $top.c itemconf text -text $which\n    }\n    set i [lsearch -exact $fontlist $fontparam(family)]\n    if {$i >= 0} {\n        $top.f.fam selection set $i\n        $top.f.fam see $i\n    }\n}\n\nproc centertext {w} {\n    $w coords text [expr {[winfo width $w] / 2}] [expr {[winfo height $w] / 2}]\n}\n\nproc fontok {} {\n    global fontparam fontpref prefstop\n\n    set f $fontparam(font)\n    set fontpref($f) [list $fontparam(family) $fontparam(size)]\n    if {$fontparam(weight) eq \"bold\"} {\n        lappend fontpref($f) \"bold\"\n    }\n    if {$fontparam(slant) eq \"italic\"} {\n        lappend fontpref($f) \"italic\"\n    }\n    set w $prefstop.notebook.fonts.$f\n    $w conf -text $fontparam(family) -font $fontpref($f)\n\n    fontcan\n}\n\nproc fontcan {} {\n    global fonttop fontparam\n\n    if {[info exists fonttop]} {\n        catch {destroy $fonttop}\n        catch {font delete sample}\n        unset fonttop\n        unset fontparam\n    }\n}\n\nif {[package vsatisfies [package provide Tk] 8.6]} {\n    # In Tk 8.6 we have a native font chooser dialog. Overwrite the above\n    # function to make use of it.\n    proc choosefont {font which} {\n        tk fontchooser configure -title $which -font $font \\\n            -command [list on_choosefont $font $which]\n        tk fontchooser show\n    }\n    proc on_choosefont {font which newfont} {\n        global fontparam\n        puts stderr \"$font $newfont\"\n        array set f [font actual $newfont]\n        set fontparam(which) $which\n        set fontparam(font) $font\n        set fontparam(family) $f(-family)\n        set fontparam(size) $f(-size)\n        set fontparam(weight) $f(-weight)\n        set fontparam(slant) $f(-slant)\n        fontok\n    }\n}\n\nproc selfontfam {} {\n    global fonttop fontparam\n\n    set i [$fonttop.f.fam curselection]\n    if {$i ne {}} {\n        set fontparam(family) [$fonttop.f.fam get $i]\n    }\n}\n\nproc chg_fontparam {v sub op} {\n    global fontparam\n\n    font config sample -$sub $fontparam($sub)\n}\n\n# Create a property sheet tab page\nproc create_prefs_page {w} {\n    global NS\n    set parent [join [lrange [split $w .] 0 end-1] .]\n    if {[winfo class $parent] eq \"TNotebook\"} {\n        ${NS}::frame $w\n    } else {\n        ${NS}::labelframe $w\n    }\n}\n\nproc prefspage_general {notebook} {\n    global NS maxwidth maxgraphpct showneartags showlocalchanges\n    global tabstop limitdiffs autoselect autosellen extdifftool perfile_attrs\n    global hideremotes want_ttk have_ttk maxrefs web_browser\n\n    set page [create_prefs_page $notebook.general]\n\n    ${NS}::label $page.ldisp -text [mc \"Commit list display options\"]\n    grid $page.ldisp - -sticky w -pady 10\n    ${NS}::label $page.spacer -text \" \"\n    ${NS}::label $page.maxwidthl -text [mc \"Maximum graph width (lines)\"]\n    spinbox $page.maxwidth -from 0 -to 100 -width 4 -textvariable maxwidth\n    grid $page.spacer $page.maxwidthl $page.maxwidth -sticky w\n                                         #xgettext:no-tcl-format\n    ${NS}::label $page.maxpctl -text [mc \"Maximum graph width (% of pane)\"]\n    spinbox $page.maxpct -from 1 -to 100 -width 4 -textvariable maxgraphpct\n    grid x $page.maxpctl $page.maxpct -sticky w\n    ${NS}::checkbutton $page.showlocal -text [mc \"Show local changes\"] \\\n        -variable showlocalchanges\n    grid x $page.showlocal -sticky w\n    ${NS}::checkbutton $page.autoselect -text [mc \"Auto-select SHA1 (length)\"] \\\n        -variable autoselect\n    spinbox $page.autosellen -from 1 -to 40 -width 4 -textvariable autosellen\n    grid x $page.autoselect $page.autosellen -sticky w\n    ${NS}::checkbutton $page.hideremotes -text [mc \"Hide remote refs\"] \\\n        -variable hideremotes\n    grid x $page.hideremotes -sticky w\n\n    ${NS}::label $page.ddisp -text [mc \"Diff display options\"]\n    grid $page.ddisp - -sticky w -pady 10\n    ${NS}::label $page.tabstopl -text [mc \"Tab spacing\"]\n    spinbox $page.tabstop -from 1 -to 20 -width 4 -textvariable tabstop\n    grid x $page.tabstopl $page.tabstop -sticky w\n    ${NS}::checkbutton $page.ntag -text [mc \"Display nearby tags/heads\"] \\\n        -variable showneartags\n    grid x $page.ntag -sticky w\n    ${NS}::label $page.maxrefsl -text [mc \"Maximum # tags/heads to show\"]\n    spinbox $page.maxrefs -from 1 -to 1000 -width 4 -textvariable maxrefs\n    grid x $page.maxrefsl $page.maxrefs -sticky w\n    ${NS}::checkbutton $page.ldiff -text [mc \"Limit diffs to listed paths\"] \\\n        -variable limitdiffs\n    grid x $page.ldiff -sticky w\n    ${NS}::checkbutton $page.lattr -text [mc \"Support per-file encodings\"] \\\n        -variable perfile_attrs\n    grid x $page.lattr -sticky w\n\n    ${NS}::entry $page.extdifft -textvariable extdifftool\n    ${NS}::frame $page.extdifff\n    ${NS}::label $page.extdifff.l -text [mc \"External diff tool\" ]\n    ${NS}::button $page.extdifff.b -text [mc \"Choose...\"] -command choose_extdiff\n    pack $page.extdifff.l $page.extdifff.b -side left\n    pack configure $page.extdifff.l -padx 10\n    grid x $page.extdifff $page.extdifft -sticky ew\n\n    ${NS}::entry $page.webbrowser -textvariable web_browser\n    ${NS}::frame $page.webbrowserf\n    ${NS}::label $page.webbrowserf.l -text [mc \"Web browser\" ]\n    pack $page.webbrowserf.l -side left\n    pack configure $page.webbrowserf.l -padx 10\n    grid x $page.webbrowserf $page.webbrowser -sticky ew\n\n    ${NS}::label $page.lgen -text [mc \"General options\"]\n    grid $page.lgen - -sticky w -pady 10\n    ${NS}::checkbutton $page.want_ttk -variable want_ttk \\\n        -text [mc \"Use themed widgets\"]\n    if {$have_ttk} {\n        ${NS}::label $page.ttk_note -text [mc \"(change requires restart)\"]\n    } else {\n        ${NS}::label $page.ttk_note -text [mc \"(currently unavailable)\"]\n    }\n    grid x $page.want_ttk $page.ttk_note -sticky w\n    return $page\n}\n\nproc prefspage_colors {notebook} {\n    global NS uicolor bgcolor fgcolor ctext diffcolors selectbgcolor markbgcolor\n    global diffbgcolors\n\n    set page [create_prefs_page $notebook.colors]\n\n    ${NS}::label $page.cdisp -text [mc \"Colors: press to choose\"]\n    grid $page.cdisp - -sticky w -pady 10\n    label $page.ui -padx 40 -relief sunk -background $uicolor\n    ${NS}::button $page.uibut -text [mc \"Interface\"] \\\n       -command [list choosecolor uicolor {} $page.ui [mc \"interface\"] setui]\n    grid x $page.uibut $page.ui -sticky w\n    label $page.bg -padx 40 -relief sunk -background $bgcolor\n    ${NS}::button $page.bgbut -text [mc \"Background\"] \\\n        -command [list choosecolor bgcolor {} $page.bg [mc \"background\"] setbg]\n    grid x $page.bgbut $page.bg -sticky w\n    label $page.fg -padx 40 -relief sunk -background $fgcolor\n    ${NS}::button $page.fgbut -text [mc \"Foreground\"] \\\n        -command [list choosecolor fgcolor {} $page.fg [mc \"foreground\"] setfg]\n    grid x $page.fgbut $page.fg -sticky w\n    label $page.diffold -padx 40 -relief sunk -background [lindex $diffcolors 0]\n    ${NS}::button $page.diffoldbut -text [mc \"Diff: old lines\"] \\\n        -command [list choosecolor diffcolors 0 $page.diffold [mc \"diff old lines\"] \\\n                      [list $ctext tag conf d0 -foreground]]\n    grid x $page.diffoldbut $page.diffold -sticky w\n    label $page.diffoldbg -padx 40 -relief sunk -background [lindex $diffbgcolors 0]\n    ${NS}::button $page.diffoldbgbut -text [mc \"Diff: old lines bg\"] \\\n        -command [list choosecolor diffbgcolors 0 $page.diffoldbg \\\n                      [mc \"diff old lines bg\"] \\\n                      [list $ctext tag conf d0 -background]]\n    grid x $page.diffoldbgbut $page.diffoldbg -sticky w\n    label $page.diffnew -padx 40 -relief sunk -background [lindex $diffcolors 1]\n    ${NS}::button $page.diffnewbut -text [mc \"Diff: new lines\"] \\\n        -command [list choosecolor diffcolors 1 $page.diffnew [mc \"diff new lines\"] \\\n                      [list $ctext tag conf dresult -foreground]]\n    grid x $page.diffnewbut $page.diffnew -sticky w\n    label $page.diffnewbg -padx 40 -relief sunk -background [lindex $diffbgcolors 1]\n    ${NS}::button $page.diffnewbgbut -text [mc \"Diff: new lines bg\"] \\\n        -command [list choosecolor diffbgcolors 1 $page.diffnewbg \\\n                      [mc \"diff new lines bg\"] \\\n                      [list $ctext tag conf dresult -background]]\n    grid x $page.diffnewbgbut $page.diffnewbg -sticky w\n    label $page.hunksep -padx 40 -relief sunk -background [lindex $diffcolors 2]\n    ${NS}::button $page.hunksepbut -text [mc \"Diff: hunk header\"] \\\n        -command [list choosecolor diffcolors 2 $page.hunksep \\\n                      [mc \"diff hunk header\"] \\\n                      [list $ctext tag conf hunksep -foreground]]\n    grid x $page.hunksepbut $page.hunksep -sticky w\n    label $page.markbgsep -padx 40 -relief sunk -background $markbgcolor\n    ${NS}::button $page.markbgbut -text [mc \"Marked line bg\"] \\\n        -command [list choosecolor markbgcolor {} $page.markbgsep \\\n                      [mc \"marked line background\"] \\\n                      [list $ctext tag conf omark -background]]\n    grid x $page.markbgbut $page.markbgsep -sticky w\n    label $page.selbgsep -padx 40 -relief sunk -background $selectbgcolor\n    ${NS}::button $page.selbgbut -text [mc \"Select bg\"] \\\n        -command [list choosecolor selectbgcolor {} $page.selbgsep [mc \"background\"] setselbg]\n    grid x $page.selbgbut $page.selbgsep -sticky w\n    return $page\n}\n\nproc prefspage_fonts {notebook} {\n    global NS\n    set page [create_prefs_page $notebook.fonts]\n    ${NS}::label $page.cfont -text [mc \"Fonts: press to choose\"]\n    grid $page.cfont - -sticky w -pady 10\n    mkfontdisp mainfont $page [mc \"Main font\"]\n    mkfontdisp textfont $page [mc \"Diff display font\"]\n    mkfontdisp uifont $page [mc \"User interface font\"]\n    return $page\n}\n\nproc doprefs {} {\n    global maxwidth maxgraphpct use_ttk NS\n    global oldprefs prefstop showneartags showlocalchanges\n    global uicolor bgcolor fgcolor ctext diffcolors selectbgcolor markbgcolor\n    global tabstop limitdiffs autoselect autosellen extdifftool perfile_attrs\n    global hideremotes want_ttk have_ttk\n\n    set top .gitkprefs\n    set prefstop $top\n    if {[winfo exists $top]} {\n        raise $top\n        return\n    }\n    foreach v {maxwidth maxgraphpct showneartags showlocalchanges \\\n                   limitdiffs tabstop perfile_attrs hideremotes want_ttk} {\n        set oldprefs($v) [set $v]\n    }\n    ttk_toplevel $top\n    wm title $top [mc \"Gitk preferences\"]\n    make_transient $top .\n\n    if {[set use_notebook [expr {$use_ttk && [info command ::ttk::notebook] ne \"\"}]]} {\n        set notebook [ttk::notebook $top.notebook]\n    } else {\n        set notebook [${NS}::frame $top.notebook -borderwidth 0 -relief flat]\n    }\n\n    lappend pages [prefspage_general $notebook] [mc \"General\"]\n    lappend pages [prefspage_colors $notebook] [mc \"Colors\"]\n    lappend pages [prefspage_fonts $notebook] [mc \"Fonts\"]\n    set col 0\n    foreach {page title} $pages {\n        if {$use_notebook} {\n            $notebook add $page -text $title\n        } else {\n            set btn [${NS}::button $notebook.b_[string map {. X} $page] \\\n                         -text $title -command [list raise $page]]\n            $page configure -text $title\n            grid $btn -row 0 -column [incr col] -sticky w\n            grid $page -row 1 -column 0 -sticky news -columnspan 100\n        }\n    }\n\n    if {!$use_notebook} {\n        grid columnconfigure $notebook 0 -weight 1\n        grid rowconfigure $notebook 1 -weight 1\n        raise [lindex $pages 0]\n    }\n\n    grid $notebook -sticky news -padx 2 -pady 2\n    grid rowconfigure $top 0 -weight 1\n    grid columnconfigure $top 0 -weight 1\n\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.ok -text [mc \"OK\"] -command prefsok -default active\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command prefscan -default normal\n    bind $top <Key-Return> prefsok\n    bind $top <Key-Escape> prefscan\n    grid $top.buts.ok $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - - -pady 10 -sticky ew\n    grid columnconfigure $top 2 -weight 1\n    bind $top <Visibility> [list focus $top.buts.ok]\n}\n\nproc choose_extdiff {} {\n    global extdifftool\n\n    set prog [tk_getOpenFile -title [mc \"External diff tool\"] -multiple false]\n    if {$prog ne {}} {\n        set extdifftool $prog\n    }\n}\n\nproc choosecolor {v vi w x cmd} {\n    global $v\n\n    set c [tk_chooseColor -initialcolor [lindex [set $v] $vi] \\\n               -title [mc \"Gitk: choose color for %s\" $x]]\n    if {$c eq {}} return\n    $w conf -background $c\n    lset $v $vi $c\n    eval $cmd $c\n}\n\nproc setselbg {c} {\n    global bglist cflist\n    foreach w $bglist {\n        if {[winfo exists $w]} {\n            $w configure -selectbackground $c\n        }\n    }\n    $cflist tag configure highlight \\\n        -background [$cflist cget -selectbackground]\n    allcanvs itemconf secsel -fill $c\n}\n\n# This sets the background color and the color scheme for the whole UI.\n# For some reason, tk_setPalette chooses a nasty dark red for selectColor\n# if we don't specify one ourselves, which makes the checkbuttons and\n# radiobuttons look bad.  This chooses white for selectColor if the\n# background color is light, or black if it is dark.\nproc setui {c} {\n    if {[tk windowingsystem] eq \"win32\"} { return }\n    set bg [winfo rgb . $c]\n    set selc black\n    if {[lindex $bg 0] + 1.5 * [lindex $bg 1] + 0.5 * [lindex $bg 2] > 100000} {\n        set selc white\n    }\n    tk_setPalette background $c selectColor $selc\n}\n\nproc setbg {c} {\n    global bglist\n\n    foreach w $bglist {\n        if {[winfo exists $w]} {\n            $w conf -background $c\n        }\n    }\n}\n\nproc setfg {c} {\n    global fglist canv\n\n    foreach w $fglist {\n        if {[winfo exists $w]} {\n            $w conf -foreground $c\n        }\n    }\n    allcanvs itemconf text -fill $c\n    $canv itemconf circle -outline $c\n    $canv itemconf markid -outline $c\n}\n\nproc prefscan {} {\n    global oldprefs prefstop\n\n    foreach v {maxwidth maxgraphpct showneartags showlocalchanges \\\n                   limitdiffs tabstop perfile_attrs hideremotes want_ttk} {\n        global $v\n        set $v $oldprefs($v)\n    }\n    catch {destroy $prefstop}\n    unset prefstop\n    fontcan\n}\n\nproc prefsok {} {\n    global maxwidth maxgraphpct\n    global oldprefs prefstop showneartags showlocalchanges\n    global fontpref mainfont textfont uifont\n    global limitdiffs treediffs perfile_attrs\n    global hideremotes\n\n    catch {destroy $prefstop}\n    unset prefstop\n    fontcan\n    set fontchanged 0\n    if {$mainfont ne $fontpref(mainfont)} {\n        set mainfont $fontpref(mainfont)\n        parsefont mainfont $mainfont\n        eval font configure mainfont [fontflags mainfont]\n        eval font configure mainfontbold [fontflags mainfont 1]\n        setcoords\n        set fontchanged 1\n    }\n    if {$textfont ne $fontpref(textfont)} {\n        set textfont $fontpref(textfont)\n        parsefont textfont $textfont\n        eval font configure textfont [fontflags textfont]\n        eval font configure textfontbold [fontflags textfont 1]\n    }\n    if {$uifont ne $fontpref(uifont)} {\n        set uifont $fontpref(uifont)\n        parsefont uifont $uifont\n        eval font configure uifont [fontflags uifont]\n    }\n    settabs\n    if {$showlocalchanges != $oldprefs(showlocalchanges)} {\n        if {$showlocalchanges} {\n            doshowlocalchanges\n        } else {\n            dohidelocalchanges\n        }\n    }\n    if {$limitdiffs != $oldprefs(limitdiffs) ||\n        ($perfile_attrs && !$oldprefs(perfile_attrs))} {\n        # treediffs elements are limited by path;\n        # won't have encodings cached if perfile_attrs was just turned on\n        unset -nocomplain treediffs\n    }\n    if {$fontchanged || $maxwidth != $oldprefs(maxwidth)\n        || $maxgraphpct != $oldprefs(maxgraphpct)} {\n        redisplay\n    } elseif {$showneartags != $oldprefs(showneartags) ||\n          $limitdiffs != $oldprefs(limitdiffs)} {\n        reselectline\n    }\n    if {$hideremotes != $oldprefs(hideremotes)} {\n        rereadrefs\n    }\n}\n\nproc formatdate {d} {\n    global datetimeformat\n    if {$d ne {}} {\n        # If $datetimeformat includes a timezone, display in the\n        # timezone of the argument.  Otherwise, display in local time.\n        if {[string match {*%[zZ]*} $datetimeformat]} {\n            if {[catch {set d [clock format [lindex $d 0] -timezone [lindex $d 1] -format $datetimeformat]}]} {\n                # Tcl < 8.5 does not support -timezone.  Emulate it by\n                # setting TZ (e.g. TZ=<-0430>+04:30).\n                global env\n                if {[info exists env(TZ)]} {\n                    set savedTZ $env(TZ)\n                }\n                set zone [lindex $d 1]\n                set sign [string map {+ - - +} [string index $zone 0]]\n                set env(TZ) <$zone>$sign[string range $zone 1 2]:[string range $zone 3 4]\n                set d [clock format [lindex $d 0] -format $datetimeformat]\n                if {[info exists savedTZ]} {\n                    set env(TZ) $savedTZ\n                } else {\n                    unset env(TZ)\n                }\n            }\n        } else {\n            set d [clock format [lindex $d 0] -format $datetimeformat]\n        }\n    }\n    return $d\n}\n\n# This list of encoding names and aliases is distilled from\n# http://www.iana.org/assignments/character-sets.\n# Not all of them are supported by Tcl.\nset encoding_aliases {\n    { ANSI_X3.4-1968 iso-ir-6 ANSI_X3.4-1986 ISO_646.irv:1991 ASCII\n      ISO646-US US-ASCII us IBM367 cp367 csASCII }\n    { ISO-10646-UTF-1 csISO10646UTF1 }\n    { ISO_646.basic:1983 ref csISO646basic1983 }\n    { INVARIANT csINVARIANT }\n    { ISO_646.irv:1983 iso-ir-2 irv csISO2IntlRefVersion }\n    { BS_4730 iso-ir-4 ISO646-GB gb uk csISO4UnitedKingdom }\n    { NATS-SEFI iso-ir-8-1 csNATSSEFI }\n    { NATS-SEFI-ADD iso-ir-8-2 csNATSSEFIADD }\n    { NATS-DANO iso-ir-9-1 csNATSDANO }\n    { NATS-DANO-ADD iso-ir-9-2 csNATSDANOADD }\n    { SEN_850200_B iso-ir-10 FI ISO646-FI ISO646-SE se csISO10Swedish }\n    { SEN_850200_C iso-ir-11 ISO646-SE2 se2 csISO11SwedishForNames }\n    { KS_C_5601-1987 iso-ir-149 KS_C_5601-1989 KSC_5601 korean csKSC56011987 }\n    { ISO-2022-KR csISO2022KR }\n    { EUC-KR csEUCKR }\n    { ISO-2022-JP csISO2022JP }\n    { ISO-2022-JP-2 csISO2022JP2 }\n    { JIS_C6220-1969-jp JIS_C6220-1969 iso-ir-13 katakana x0201-7\n      csISO13JISC6220jp }\n    { JIS_C6220-1969-ro iso-ir-14 jp ISO646-JP csISO14JISC6220ro }\n    { IT iso-ir-15 ISO646-IT csISO15Italian }\n    { PT iso-ir-16 ISO646-PT csISO16Portuguese }\n    { ES iso-ir-17 ISO646-ES csISO17Spanish }\n    { greek7-old iso-ir-18 csISO18Greek7Old }\n    { latin-greek iso-ir-19 csISO19LatinGreek }\n    { DIN_66003 iso-ir-21 de ISO646-DE csISO21German }\n    { NF_Z_62-010_(1973) iso-ir-25 ISO646-FR1 csISO25French }\n    { Latin-greek-1 iso-ir-27 csISO27LatinGreek1 }\n    { ISO_5427 iso-ir-37 csISO5427Cyrillic }\n    { JIS_C6226-1978 iso-ir-42 csISO42JISC62261978 }\n    { BS_viewdata iso-ir-47 csISO47BSViewdata }\n    { INIS iso-ir-49 csISO49INIS }\n    { INIS-8 iso-ir-50 csISO50INIS8 }\n    { INIS-cyrillic iso-ir-51 csISO51INISCyrillic }\n    { ISO_5427:1981 iso-ir-54 ISO5427Cyrillic1981 }\n    { ISO_5428:1980 iso-ir-55 csISO5428Greek }\n    { GB_1988-80 iso-ir-57 cn ISO646-CN csISO57GB1988 }\n    { GB_2312-80 iso-ir-58 chinese csISO58GB231280 }\n    { NS_4551-1 iso-ir-60 ISO646-NO no csISO60DanishNorwegian\n      csISO60Norwegian1 }\n    { NS_4551-2 ISO646-NO2 iso-ir-61 no2 csISO61Norwegian2 }\n    { NF_Z_62-010 iso-ir-69 ISO646-FR fr csISO69French }\n    { videotex-suppl iso-ir-70 csISO70VideotexSupp1 }\n    { PT2 iso-ir-84 ISO646-PT2 csISO84Portuguese2 }\n    { ES2 iso-ir-85 ISO646-ES2 csISO85Spanish2 }\n    { MSZ_7795.3 iso-ir-86 ISO646-HU hu csISO86Hungarian }\n    { JIS_C6226-1983 iso-ir-87 x0208 JIS_X0208-1983 csISO87JISX0208 }\n    { greek7 iso-ir-88 csISO88Greek7 }\n    { ASMO_449 ISO_9036 arabic7 iso-ir-89 csISO89ASMO449 }\n    { iso-ir-90 csISO90 }\n    { JIS_C6229-1984-a iso-ir-91 jp-ocr-a csISO91JISC62291984a }\n    { JIS_C6229-1984-b iso-ir-92 ISO646-JP-OCR-B jp-ocr-b\n      csISO92JISC62991984b }\n    { JIS_C6229-1984-b-add iso-ir-93 jp-ocr-b-add csISO93JIS62291984badd }\n    { JIS_C6229-1984-hand iso-ir-94 jp-ocr-hand csISO94JIS62291984hand }\n    { JIS_C6229-1984-hand-add iso-ir-95 jp-ocr-hand-add\n      csISO95JIS62291984handadd }\n    { JIS_C6229-1984-kana iso-ir-96 csISO96JISC62291984kana }\n    { ISO_2033-1983 iso-ir-98 e13b csISO2033 }\n    { ANSI_X3.110-1983 iso-ir-99 CSA_T500-1983 NAPLPS csISO99NAPLPS }\n    { ISO_8859-1:1987 iso-ir-100 ISO_8859-1 ISO-8859-1 latin1 l1 IBM819\n      CP819 csISOLatin1 }\n    { ISO_8859-2:1987 iso-ir-101 ISO_8859-2 ISO-8859-2 latin2 l2 csISOLatin2 }\n    { T.61-7bit iso-ir-102 csISO102T617bit }\n    { T.61-8bit T.61 iso-ir-103 csISO103T618bit }\n    { ISO_8859-3:1988 iso-ir-109 ISO_8859-3 ISO-8859-3 latin3 l3 csISOLatin3 }\n    { ISO_8859-4:1988 iso-ir-110 ISO_8859-4 ISO-8859-4 latin4 l4 csISOLatin4 }\n    { ECMA-cyrillic iso-ir-111 KOI8-E csISO111ECMACyrillic }\n    { CSA_Z243.4-1985-1 iso-ir-121 ISO646-CA csa7-1 ca csISO121Canadian1 }\n    { CSA_Z243.4-1985-2 iso-ir-122 ISO646-CA2 csa7-2 csISO122Canadian2 }\n    { CSA_Z243.4-1985-gr iso-ir-123 csISO123CSAZ24341985gr }\n    { ISO_8859-6:1987 iso-ir-127 ISO_8859-6 ISO-8859-6 ECMA-114 ASMO-708\n      arabic csISOLatinArabic }\n    { ISO_8859-6-E csISO88596E ISO-8859-6-E }\n    { ISO_8859-6-I csISO88596I ISO-8859-6-I }\n    { ISO_8859-7:1987 iso-ir-126 ISO_8859-7 ISO-8859-7 ELOT_928 ECMA-118\n      greek greek8 csISOLatinGreek }\n    { T.101-G2 iso-ir-128 csISO128T101G2 }\n    { ISO_8859-8:1988 iso-ir-138 ISO_8859-8 ISO-8859-8 hebrew\n      csISOLatinHebrew }\n    { ISO_8859-8-E csISO88598E ISO-8859-8-E }\n    { ISO_8859-8-I csISO88598I ISO-8859-8-I }\n    { CSN_369103 iso-ir-139 csISO139CSN369103 }\n    { JUS_I.B1.002 iso-ir-141 ISO646-YU js yu csISO141JUSIB1002 }\n    { ISO_6937-2-add iso-ir-142 csISOTextComm }\n    { IEC_P27-1 iso-ir-143 csISO143IECP271 }\n    { ISO_8859-5:1988 iso-ir-144 ISO_8859-5 ISO-8859-5 cyrillic\n      csISOLatinCyrillic }\n    { JUS_I.B1.003-serb iso-ir-146 serbian csISO146Serbian }\n    { JUS_I.B1.003-mac macedonian iso-ir-147 csISO147Macedonian }\n    { ISO_8859-9:1989 iso-ir-148 ISO_8859-9 ISO-8859-9 latin5 l5 csISOLatin5 }\n    { greek-ccitt iso-ir-150 csISO150 csISO150GreekCCITT }\n    { NC_NC00-10:81 cuba iso-ir-151 ISO646-CU csISO151Cuba }\n    { ISO_6937-2-25 iso-ir-152 csISO6937Add }\n    { GOST_19768-74 ST_SEV_358-88 iso-ir-153 csISO153GOST1976874 }\n    { ISO_8859-supp iso-ir-154 latin1-2-5 csISO8859Supp }\n    { ISO_10367-box iso-ir-155 csISO10367Box }\n    { ISO-8859-10 iso-ir-157 l6 ISO_8859-10:1992 csISOLatin6 latin6 }\n    { latin-lap lap iso-ir-158 csISO158Lap }\n    { JIS_X0212-1990 x0212 iso-ir-159 csISO159JISX02121990 }\n    { DS_2089 DS2089 ISO646-DK dk csISO646Danish }\n    { us-dk csUSDK }\n    { dk-us csDKUS }\n    { JIS_X0201 X0201 csHalfWidthKatakana }\n    { KSC5636 ISO646-KR csKSC5636 }\n    { ISO-10646-UCS-2 csUnicode }\n    { ISO-10646-UCS-4 csUCS4 }\n    { DEC-MCS dec csDECMCS }\n    { hp-roman8 roman8 r8 csHPRoman8 }\n    { macintosh mac csMacintosh }\n    { IBM037 cp037 ebcdic-cp-us ebcdic-cp-ca ebcdic-cp-wt ebcdic-cp-nl\n      csIBM037 }\n    { IBM038 EBCDIC-INT cp038 csIBM038 }\n    { IBM273 CP273 csIBM273 }\n    { IBM274 EBCDIC-BE CP274 csIBM274 }\n    { IBM275 EBCDIC-BR cp275 csIBM275 }\n    { IBM277 EBCDIC-CP-DK EBCDIC-CP-NO csIBM277 }\n    { IBM278 CP278 ebcdic-cp-fi ebcdic-cp-se csIBM278 }\n    { IBM280 CP280 ebcdic-cp-it csIBM280 }\n    { IBM281 EBCDIC-JP-E cp281 csIBM281 }\n    { IBM284 CP284 ebcdic-cp-es csIBM284 }\n    { IBM285 CP285 ebcdic-cp-gb csIBM285 }\n    { IBM290 cp290 EBCDIC-JP-kana csIBM290 }\n    { IBM297 cp297 ebcdic-cp-fr csIBM297 }\n    { IBM420 cp420 ebcdic-cp-ar1 csIBM420 }\n    { IBM423 cp423 ebcdic-cp-gr csIBM423 }\n    { IBM424 cp424 ebcdic-cp-he csIBM424 }\n    { IBM437 cp437 437 csPC8CodePage437 }\n    { IBM500 CP500 ebcdic-cp-be ebcdic-cp-ch csIBM500 }\n    { IBM775 cp775 csPC775Baltic }\n    { IBM850 cp850 850 csPC850Multilingual }\n    { IBM851 cp851 851 csIBM851 }\n    { IBM852 cp852 852 csPCp852 }\n    { IBM855 cp855 855 csIBM855 }\n    { IBM857 cp857 857 csIBM857 }\n    { IBM860 cp860 860 csIBM860 }\n    { IBM861 cp861 861 cp-is csIBM861 }\n    { IBM862 cp862 862 csPC862LatinHebrew }\n    { IBM863 cp863 863 csIBM863 }\n    { IBM864 cp864 csIBM864 }\n    { IBM865 cp865 865 csIBM865 }\n    { IBM866 cp866 866 csIBM866 }\n    { IBM868 CP868 cp-ar csIBM868 }\n    { IBM869 cp869 869 cp-gr csIBM869 }\n    { IBM870 CP870 ebcdic-cp-roece ebcdic-cp-yu csIBM870 }\n    { IBM871 CP871 ebcdic-cp-is csIBM871 }\n    { IBM880 cp880 EBCDIC-Cyrillic csIBM880 }\n    { IBM891 cp891 csIBM891 }\n    { IBM903 cp903 csIBM903 }\n    { IBM904 cp904 904 csIBBM904 }\n    { IBM905 CP905 ebcdic-cp-tr csIBM905 }\n    { IBM918 CP918 ebcdic-cp-ar2 csIBM918 }\n    { IBM1026 CP1026 csIBM1026 }\n    { EBCDIC-AT-DE csIBMEBCDICATDE }\n    { EBCDIC-AT-DE-A csEBCDICATDEA }\n    { EBCDIC-CA-FR csEBCDICCAFR }\n    { EBCDIC-DK-NO csEBCDICDKNO }\n    { EBCDIC-DK-NO-A csEBCDICDKNOA }\n    { EBCDIC-FI-SE csEBCDICFISE }\n    { EBCDIC-FI-SE-A csEBCDICFISEA }\n    { EBCDIC-FR csEBCDICFR }\n    { EBCDIC-IT csEBCDICIT }\n    { EBCDIC-PT csEBCDICPT }\n    { EBCDIC-ES csEBCDICES }\n    { EBCDIC-ES-A csEBCDICESA }\n    { EBCDIC-ES-S csEBCDICESS }\n    { EBCDIC-UK csEBCDICUK }\n    { EBCDIC-US csEBCDICUS }\n    { UNKNOWN-8BIT csUnknown8BiT }\n    { MNEMONIC csMnemonic }\n    { MNEM csMnem }\n    { VISCII csVISCII }\n    { VIQR csVIQR }\n    { KOI8-R csKOI8R }\n    { IBM00858 CCSID00858 CP00858 PC-Multilingual-850+euro }\n    { IBM00924 CCSID00924 CP00924 ebcdic-Latin9--euro }\n    { IBM01140 CCSID01140 CP01140 ebcdic-us-37+euro }\n    { IBM01141 CCSID01141 CP01141 ebcdic-de-273+euro }\n    { IBM01142 CCSID01142 CP01142 ebcdic-dk-277+euro ebcdic-no-277+euro }\n    { IBM01143 CCSID01143 CP01143 ebcdic-fi-278+euro ebcdic-se-278+euro }\n    { IBM01144 CCSID01144 CP01144 ebcdic-it-280+euro }\n    { IBM01145 CCSID01145 CP01145 ebcdic-es-284+euro }\n    { IBM01146 CCSID01146 CP01146 ebcdic-gb-285+euro }\n    { IBM01147 CCSID01147 CP01147 ebcdic-fr-297+euro }\n    { IBM01148 CCSID01148 CP01148 ebcdic-international-500+euro }\n    { IBM01149 CCSID01149 CP01149 ebcdic-is-871+euro }\n    { IBM1047 IBM-1047 }\n    { PTCP154 csPTCP154 PT154 CP154 Cyrillic-Asian }\n    { Amiga-1251 Ami1251 Amiga1251 Ami-1251 }\n    { UNICODE-1-1 csUnicode11 }\n    { CESU-8 csCESU-8 }\n    { BOCU-1 csBOCU-1 }\n    { UNICODE-1-1-UTF-7 csUnicode11UTF7 }\n    { ISO-8859-14 iso-ir-199 ISO_8859-14:1998 ISO_8859-14 latin8 iso-celtic\n      l8 }\n    { ISO-8859-15 ISO_8859-15 Latin-9 }\n    { ISO-8859-16 iso-ir-226 ISO_8859-16:2001 ISO_8859-16 latin10 l10 }\n    { GBK CP936 MS936 windows-936 }\n    { JIS_Encoding csJISEncoding }\n    { Shift_JIS MS_Kanji csShiftJIS ShiftJIS Shift-JIS }\n    { Extended_UNIX_Code_Packed_Format_for_Japanese csEUCPkdFmtJapanese\n      EUC-JP }\n    { Extended_UNIX_Code_Fixed_Width_for_Japanese csEUCFixWidJapanese }\n    { ISO-10646-UCS-Basic csUnicodeASCII }\n    { ISO-10646-Unicode-Latin1 csUnicodeLatin1 ISO-10646 }\n    { ISO-Unicode-IBM-1261 csUnicodeIBM1261 }\n    { ISO-Unicode-IBM-1268 csUnicodeIBM1268 }\n    { ISO-Unicode-IBM-1276 csUnicodeIBM1276 }\n    { ISO-Unicode-IBM-1264 csUnicodeIBM1264 }\n    { ISO-Unicode-IBM-1265 csUnicodeIBM1265 }\n    { ISO-8859-1-Windows-3.0-Latin-1 csWindows30Latin1 }\n    { ISO-8859-1-Windows-3.1-Latin-1 csWindows31Latin1 }\n    { ISO-8859-2-Windows-Latin-2 csWindows31Latin2 }\n    { ISO-8859-9-Windows-Latin-5 csWindows31Latin5 }\n    { Adobe-Standard-Encoding csAdobeStandardEncoding }\n    { Ventura-US csVenturaUS }\n    { Ventura-International csVenturaInternational }\n    { PC8-Danish-Norwegian csPC8DanishNorwegian }\n    { PC8-Turkish csPC8Turkish }\n    { IBM-Symbols csIBMSymbols }\n    { IBM-Thai csIBMThai }\n    { HP-Legal csHPLegal }\n    { HP-Pi-font csHPPiFont }\n    { HP-Math8 csHPMath8 }\n    { Adobe-Symbol-Encoding csHPPSMath }\n    { HP-DeskTop csHPDesktop }\n    { Ventura-Math csVenturaMath }\n    { Microsoft-Publishing csMicrosoftPublishing }\n    { Windows-31J csWindows31J }\n    { GB2312 csGB2312 }\n    { Big5 csBig5 }\n}\n\nproc tcl_encoding {enc} {\n    global encoding_aliases tcl_encoding_cache\n    if {[info exists tcl_encoding_cache($enc)]} {\n        return $tcl_encoding_cache($enc)\n    }\n    set names [encoding names]\n    set lcnames [string tolower $names]\n    set enc [string tolower $enc]\n    set i [lsearch -exact $lcnames $enc]\n    if {$i < 0} {\n        # look for \"isonnn\" instead of \"iso-nnn\" or \"iso_nnn\"\n        if {[regsub {^(iso|cp|ibm|jis)[-_]} $enc {\\1} encx]} {\n            set i [lsearch -exact $lcnames $encx]\n        }\n    }\n    if {$i < 0} {\n        foreach l $encoding_aliases {\n            set ll [string tolower $l]\n            if {[lsearch -exact $ll $enc] < 0} continue\n            # look through the aliases for one that tcl knows about\n            foreach e $ll {\n                set i [lsearch -exact $lcnames $e]\n                if {$i < 0} {\n                    if {[regsub {^(iso|cp|ibm|jis)[-_]} $e {\\1} ex]} {\n                        set i [lsearch -exact $lcnames $ex]\n                    }\n                }\n                if {$i >= 0} break\n            }\n            break\n        }\n    }\n    set tclenc {}\n    if {$i >= 0} {\n        set tclenc [lindex $names $i]\n    }\n    set tcl_encoding_cache($enc) $tclenc\n    return $tclenc\n}\n\nproc gitattr {path attr default} {\n    global path_attr_cache\n    if {[info exists path_attr_cache($attr,$path)]} {\n        set r $path_attr_cache($attr,$path)\n    } else {\n        set r \"unspecified\"\n        if {![catch {set line [exec git check-attr $attr -- $path]}]} {\n            regexp \"(.*): $attr: (.*)\" $line m f r\n        }\n        set path_attr_cache($attr,$path) $r\n    }\n    if {$r eq \"unspecified\"} {\n        return $default\n    }\n    return $r\n}\n\nproc cache_gitattr {attr pathlist} {\n    global path_attr_cache\n    set newlist {}\n    foreach path $pathlist {\n        if {![info exists path_attr_cache($attr,$path)]} {\n            lappend newlist $path\n        }\n    }\n    set lim 1000\n    if {[tk windowingsystem] == \"win32\"} {\n        # windows has a 32k limit on the arguments to a command...\n        set lim 30\n    }\n    while {$newlist ne {}} {\n        set head [lrange $newlist 0 [expr {$lim - 1}]]\n        set newlist [lrange $newlist $lim end]\n        if {![catch {set rlist [eval exec git check-attr $attr -- $head]}]} {\n            foreach row [split $rlist \"\\n\"] {\n                if {[regexp \"(.*): $attr: (.*)\" $row m path value]} {\n                    if {[string index $path 0] eq \"\\\"\"} {\n                        set path [encoding convertfrom utf-8 [lindex $path 0]]\n                    }\n                    set path_attr_cache($attr,$path) $value\n                }\n            }\n        }\n    }\n}\n\nproc get_path_encoding {path} {\n    global gui_encoding perfile_attrs\n    set tcl_enc $gui_encoding\n    if {$path ne {} && $perfile_attrs} {\n        set enc2 [tcl_encoding [gitattr $path encoding $tcl_enc]]\n        if {$enc2 ne {}} {\n            set tcl_enc $enc2\n        }\n    }\n    return $tcl_enc\n}\n\n## For msgcat loading, first locate the installation location.\nif { [info exists ::env(GITK_MSGSDIR)] } {\n    ## Msgsdir was manually set in the environment.\n    set gitk_msgsdir $::env(GITK_MSGSDIR)\n} else {\n    ## Let's guess the prefix from argv0.\n    set gitk_prefix [file dirname [file dirname [file normalize $argv0]]]\n    set gitk_libdir [file join $gitk_prefix share gitk lib]\n    set gitk_msgsdir [file join $gitk_libdir msgs]\n}\n\n## Internationalization (i18n) through msgcat and gettext. See\n## http://www.gnu.org/software/gettext/manual/html_node/Tcl.html\npackage require msgcat\nnamespace import ::msgcat::mc\n## And eventually load the actual message catalog\n::msgcat::mcload $gitk_msgsdir\n\n# First check that Tcl/Tk is recent enough\nif {[catch {package require Tk 8.4} err]} {\n    show_error {} . [mc \"Sorry, gitk cannot run with this version of Tcl/Tk.\\n\\\n                         Gitk requires at least Tcl/Tk 8.4.\"]\n    exit 1\n}\n\n# on OSX bring the current Wish process window to front\nif {[tk windowingsystem] eq \"aqua\"} {\n    exec osascript -e [format {\n        tell application \"System Events\"\n            set frontmost of processes whose unix id is %d to true\n        end tell\n    } [pid] ]\n}\n\n# Unset GIT_TRACE var if set\nif { [info exists ::env(GIT_TRACE)] } {\n    unset ::env(GIT_TRACE)\n}\n\n# defaults...\nset wrcomcmd \"git diff-tree --stdin -p --pretty=email\"\n\nset gitencoding {}\ncatch {\n    set gitencoding [exec git config --get i18n.commitencoding]\n}\ncatch {\n    set gitencoding [exec git config --get i18n.logoutputencoding]\n}\nif {$gitencoding == \"\"} {\n    set gitencoding \"utf-8\"\n}\nset tclencoding [tcl_encoding $gitencoding]\nif {$tclencoding == {}} {\n    puts stderr \"Warning: encoding $gitencoding is not supported by Tcl/Tk\"\n}\n\nset gui_encoding [encoding system]\ncatch {\n    set enc [exec git config --get gui.encoding]\n    if {$enc ne {}} {\n        set tclenc [tcl_encoding $enc]\n        if {$tclenc ne {}} {\n            set gui_encoding $tclenc\n        } else {\n            puts stderr \"Warning: encoding $enc is not supported by Tcl/Tk\"\n        }\n    }\n}\n\nset log_showroot true\ncatch {\n    set log_showroot [exec git config --bool --get log.showroot]\n}\n\nif {[tk windowingsystem] eq \"aqua\"} {\n    set mainfont {{Lucida Grande} 9}\n    set textfont {Monaco 9}\n    set uifont {{Lucida Grande} 9 bold}\n} elseif {![catch {::tk::pkgconfig get fontsystem} xft] && $xft eq \"xft\"} {\n    # fontconfig!\n    set mainfont {sans 9}\n    set textfont {monospace 9}\n    set uifont {sans 9 bold}\n} else {\n    set mainfont {Helvetica 9}\n    set textfont {Courier 9}\n    set uifont {Helvetica 9 bold}\n}\nset tabstop 8\nset findmergefiles 0\nset maxgraphpct 50\nset maxwidth 16\nset revlistorder 0\nset fastdate 0\nset uparrowlen 5\nset downarrowlen 5\nset mingaplen 100\nset cmitmode \"patch\"\nset wrapcomment \"none\"\nset showneartags 1\nset hideremotes 0\nset maxrefs 20\nset visiblerefs {\"master\"}\nset maxlinelen 200\nset showlocalchanges 1\nset limitdiffs 1\nset datetimeformat \"%Y-%m-%d %H:%M:%S\"\nset autoselect 1\nset autosellen 40\nset perfile_attrs 0\nset want_ttk 1\n\nif {[tk windowingsystem] eq \"aqua\"} {\n    set extdifftool \"opendiff\"\n} else {\n    set extdifftool \"meld\"\n}\n\nset colors {\"#00ff00\" red blue magenta darkgrey brown orange}\nif {[tk windowingsystem] eq \"win32\"} {\n    set uicolor SystemButtonFace\n    set uifgcolor SystemButtonText\n    set uifgdisabledcolor SystemDisabledText\n    set bgcolor SystemWindow\n    set fgcolor SystemWindowText\n    set selectbgcolor SystemHighlight\n    set web_browser \"cmd /c start\"\n} else {\n    set uicolor grey85\n    set uifgcolor black\n    set uifgdisabledcolor \"#999\"\n    set bgcolor white\n    set fgcolor black\n    set selectbgcolor gray85\n    if {[tk windowingsystem] eq \"aqua\"} {\n        set web_browser \"open\"\n    } else {\n        set web_browser \"xdg-open\"\n    }\n}\nset diffcolors {\"#c30000\" \"#009800\" blue}\nset diffbgcolors {\"#fff3f3\" \"#f0fff0\"}\nset diffcontext 3\nset mergecolors {red blue \"#00ff00\" purple brown \"#009090\" magenta \"#808000\" \"#009000\" \"#ff0080\" cyan \"#b07070\" \"#70b0f0\" \"#70f0b0\" \"#f0b070\" \"#ff70b0\"}\nset ignorespace 0\nset worddiff \"\"\nset markbgcolor \"#e0e0ff\"\n\nset headbgcolor \"#00ff00\"\nset headfgcolor black\nset headoutlinecolor black\nset remotebgcolor #ffddaa\nset tagbgcolor yellow\nset tagfgcolor black\nset tagoutlinecolor black\nset reflinecolor black\nset filesepbgcolor #aaaaaa\nset filesepfgcolor black\nset linehoverbgcolor #ffff80\nset linehoverfgcolor black\nset linehoveroutlinecolor black\nset mainheadcirclecolor yellow\nset workingfilescirclecolor red\nset indexcirclecolor \"#00ff00\"\nset circlecolors {white blue gray blue blue}\nset linkfgcolor blue\nset circleoutlinecolor $fgcolor\nset foundbgcolor yellow\nset currentsearchhitbgcolor orange\n\n# button for popping up context menus\nif {[tk windowingsystem] eq \"aqua\"} {\n    set ctxbut <Button-2>\n} else {\n    set ctxbut <Button-3>\n}\n\ncatch {\n    # follow the XDG base directory specification by default. See\n    # http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n    if {[info exists env(XDG_CONFIG_HOME)] && $env(XDG_CONFIG_HOME) ne \"\"} {\n        # XDG_CONFIG_HOME environment variable is set\n        set config_file [file join $env(XDG_CONFIG_HOME) git gitk]\n        set config_file_tmp [file join $env(XDG_CONFIG_HOME) git gitk-tmp]\n    } else {\n        # default XDG_CONFIG_HOME\n        set config_file \"~/.config/git/gitk\"\n        set config_file_tmp \"~/.config/git/gitk-tmp\"\n    }\n    if {![file exists $config_file]} {\n        # for backward compatibility use the old config file if it exists\n        if {[file exists \"~/.gitk\"]} {\n            set config_file \"~/.gitk\"\n            set config_file_tmp \"~/.gitk-tmp\"\n        } elseif {![file exists [file dirname $config_file]]} {\n            file mkdir [file dirname $config_file]\n        }\n    }\n    source $config_file\n}\nconfig_check_tmp_exists 50\n\nset config_variables {\n    mainfont textfont uifont tabstop findmergefiles maxgraphpct maxwidth\n    cmitmode wrapcomment autoselect autosellen showneartags maxrefs visiblerefs\n    hideremotes showlocalchanges datetimeformat limitdiffs uicolor want_ttk\n    bgcolor fgcolor uifgcolor uifgdisabledcolor colors diffcolors mergecolors\n    markbgcolor diffcontext selectbgcolor foundbgcolor currentsearchhitbgcolor\n    extdifftool perfile_attrs headbgcolor headfgcolor headoutlinecolor\n    remotebgcolor tagbgcolor tagfgcolor tagoutlinecolor reflinecolor\n    filesepbgcolor filesepfgcolor linehoverbgcolor linehoverfgcolor\n    linehoveroutlinecolor mainheadcirclecolor workingfilescirclecolor\n    indexcirclecolor circlecolors linkfgcolor circleoutlinecolor diffbgcolors\n    web_browser\n}\nforeach var $config_variables {\n    config_init_trace $var\n    trace add variable $var write config_variable_change_cb\n}\n\nparsefont mainfont $mainfont\neval font create mainfont [fontflags mainfont]\neval font create mainfontbold [fontflags mainfont 1]\n\nparsefont textfont $textfont\neval font create textfont [fontflags textfont]\neval font create textfontbold [fontflags textfont 1]\n\nparsefont uifont $uifont\neval font create uifont [fontflags uifont]\n\nsetui $uicolor\n\nsetoptions\n\n# check that we can find a .git directory somewhere...\nif {[catch {set gitdir [exec git rev-parse --git-dir]}]} {\n    show_error {} . [mc \"Cannot find a git repository here.\"]\n    exit 1\n}\n\nset selecthead {}\nset selectheadid {}\n\nset revtreeargs {}\nset cmdline_files {}\nset i 0\nset revtreeargscmd {}\nforeach arg $argv {\n    switch -glob -- $arg {\n        \"\" { }\n        \"--\" {\n            set cmdline_files [lrange $argv [expr {$i + 1}] end]\n            break\n        }\n        \"--select-commit=*\" {\n            set selecthead [string range $arg 16 end]\n        }\n        \"--argscmd=*\" {\n            set revtreeargscmd [string range $arg 10 end]\n        }\n        default {\n            lappend revtreeargs $arg\n        }\n    }\n    incr i\n}\n\nif {$selecthead eq \"HEAD\"} {\n    set selecthead {}\n}\n\nif {$i >= [llength $argv] && $revtreeargs ne {}} {\n    # no -- on command line, but some arguments (other than --argscmd)\n    if {[catch {\n        set f [eval exec git rev-parse --no-revs --no-flags $revtreeargs]\n        set cmdline_files [split $f \"\\n\"]\n        set n [llength $cmdline_files]\n        set revtreeargs [lrange $revtreeargs 0 end-$n]\n        # Unfortunately git rev-parse doesn't produce an error when\n        # something is both a revision and a filename.  To be consistent\n        # with git log and git rev-list, check revtreeargs for filenames.\n        foreach arg $revtreeargs {\n            if {[file exists $arg]} {\n                show_error {} . [mc \"Ambiguous argument '%s': both revision\\\n                                 and filename\" $arg]\n                exit 1\n            }\n        }\n    } err]} {\n        # unfortunately we get both stdout and stderr in $err,\n        # so look for \"fatal:\".\n        set i [string first \"fatal:\" $err]\n        if {$i > 0} {\n            set err [string range $err [expr {$i + 6}] end]\n        }\n        show_error {} . \"[mc \"Bad arguments to gitk:\"]\\n$err\"\n        exit 1\n    }\n}\n\nset nullid \"0000000000000000000000000000000000000000\"\nset nullid2 \"0000000000000000000000000000000000000001\"\nset nullfile \"/dev/null\"\n\nset have_tk85 [expr {[package vcompare $tk_version \"8.5\"] >= 0}]\nset have_tk86 [expr {[package vcompare $tk_version \"8.6\"] >= 0}]\nif {![info exists have_ttk]} {\n    set have_ttk [llength [info commands ::ttk::style]]\n}\nset use_ttk [expr {$have_ttk && $want_ttk}]\nset NS [expr {$use_ttk ? \"ttk\" : \"\"}]\n\nif {$use_ttk} {\n    setttkstyle\n}\n\nregexp {^git version ([\\d.]*\\d)} [exec git version] _ git_version\n\nset show_notes {}\nif {[package vcompare $git_version \"1.6.6.2\"] >= 0} {\n    set show_notes \"--show-notes\"\n}\n\nset appname \"gitk\"\n\nset runq {}\nset history {}\nset historyindex 0\nset fh_serial 0\nset nhl_names {}\nset highlight_paths {}\nset findpattern {}\nset searchdirn -forwards\nset boldids {}\nset boldnameids {}\nset diffelide {0 0}\nset markingmatches 0\nset linkentercount 0\nset need_redisplay 0\nset nrows_drawn 0\nset firsttabstop 0\n\nset nextviewnum 1\nset curview 0\nset selectedview 0\nset selectedhlview [mc \"None\"]\nset highlight_related [mc \"None\"]\nset highlight_files {}\nset viewfiles(0) {}\nset viewperm(0) 0\nset viewchanged(0) 0\nset viewargs(0) {}\nset viewargscmd(0) {}\n\nset selectedline {}\nset numcommits 0\nset loginstance 0\nset cmdlineok 0\nset stopped 0\nset stuffsaved 0\nset patchnum 0\nset lserial 0\nset hasworktree [hasworktree]\nset cdup {}\nif {[expr {[exec git rev-parse --is-inside-work-tree] == \"true\"}]} {\n    set cdup [exec git rev-parse --show-cdup]\n}\nset worktree [gitworktree]\nsetcoords\nmakewindow\nif {$::tcl_platform(platform) eq {windows} && [file exists $gitk_prefix/etc/git.ico]} {\n    wm iconbitmap . -default $gitk_prefix/etc/git.ico\n} else {\n    catch {\n        image create photo gitlogo      -width 16 -height 16\n\n        image create photo gitlogominus -width  4 -height  2\n        gitlogominus put #C00000 -to 0 0 4 2\n        gitlogo copy gitlogominus -to  1 5\n        gitlogo copy gitlogominus -to  6 5\n        gitlogo copy gitlogominus -to 11 5\n        image delete gitlogominus\n\n        image create photo gitlogoplus  -width  4 -height  4\n        gitlogoplus  put #008000 -to 1 0 3 4\n        gitlogoplus  put #008000 -to 0 1 4 3\n        gitlogo copy gitlogoplus  -to  1 9\n        gitlogo copy gitlogoplus  -to  6 9\n        gitlogo copy gitlogoplus  -to 11 9\n        image delete gitlogoplus\n\n        image create photo gitlogo32    -width 32 -height 32\n        gitlogo32 copy gitlogo -zoom 2 2\n\n        wm iconphoto . -default gitlogo gitlogo32\n    }\n}\n# wait for the window to become visible\ntkwait visibility .\nset_window_title\nupdate\nreadrefs\n\nif {$cmdline_files ne {} || $revtreeargs ne {} || $revtreeargscmd ne {}} {\n    # create a view for the files/dirs specified on the command line\n    set curview 1\n    set selectedview 1\n    set nextviewnum 2\n    set viewname(1) [mc \"Command line\"]\n    set viewfiles(1) $cmdline_files\n    set viewargs(1) $revtreeargs\n    set viewargscmd(1) $revtreeargscmd\n    set viewperm(1) 0\n    set viewchanged(1) 0\n    set vdatemode(1) 0\n    addviewmenu 1\n    .bar.view entryconf [mca \"&Edit view...\"] -state normal\n    .bar.view entryconf [mca \"&Delete view\"] -state normal\n}\n\nif {[info exists permviews]} {\n    foreach v $permviews {\n        set n $nextviewnum\n        incr nextviewnum\n        set viewname($n) [lindex $v 0]\n        set viewfiles($n) [lindex $v 1]\n        set viewargs($n) [lindex $v 2]\n        set viewargscmd($n) [lindex $v 3]\n        set viewperm($n) 1\n        set viewchanged($n) 0\n        addviewmenu $n\n    }\n}\n\nif {[tk windowingsystem] eq \"win32\"} {\n    focus -force .\n}\n\ngetcommits {}\n\n# Local variables:\n# mode: tcl\n# indent-tabs-mode: t\n# tab-width: 8\n# End:\n"], "fixing_code": ["#!/bin/sh\n# Tcl ignores the next line -*- tcl -*- \\\nexec wish \"$0\" -- \"$@\"\n\n# Copyright \u00a9 2005-2016 Paul Mackerras.  All rights reserved.\n# This program is free software; it may be used, copied, modified\n# and distributed under the terms of the GNU General Public Licence,\n# either version 2, or (at your option) any later version.\n\npackage require Tk\n\n######################################################################\n##\n## Enabling platform-specific code paths\n\nproc is_MacOSX {} {\n\tif {[tk windowingsystem] eq {aqua}} {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nproc is_Windows {} {\n\tif {$::tcl_platform(platform) eq {windows}} {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nset _iscygwin {}\nproc is_Cygwin {} {\n\tglobal _iscygwin\n\tif {$_iscygwin eq {}} {\n\t\tif {[string match \"CYGWIN_*\" $::tcl_platform(os)]} {\n\t\t\tset _iscygwin 1\n\t\t} else {\n\t\t\tset _iscygwin 0\n\t\t}\n\t}\n\treturn $_iscygwin\n}\n\n######################################################################\n##\n## PATH lookup\n\nset _search_path {}\nproc _which {what args} {\n\tglobal env _search_exe _search_path\n\n\tif {$_search_path eq {}} {\n\t\tif {[is_Cygwin] && [regexp {^(/|\\.:)} $env(PATH)]} {\n\t\t\tset _search_path [split [exec cygpath \\\n\t\t\t\t--windows \\\n\t\t\t\t--path \\\n\t\t\t\t--absolute \\\n\t\t\t\t$env(PATH)] {;}]\n\t\t\tset _search_exe .exe\n\t\t} elseif {[is_Windows]} {\n\t\t\tset gitguidir [file dirname [info script]]\n\t\t\tregsub -all \";\" $gitguidir \"\\\\;\" gitguidir\n\t\t\tset env(PATH) \"$gitguidir;$env(PATH)\"\n\t\t\tset _search_path [split $env(PATH) {;}]\n\t\t\t# Skip empty `PATH` elements\n\t\t\tset _search_path [lsearch -all -inline -not -exact \\\n\t\t\t\t$_search_path \"\"]\n\t\t\tset _search_exe .exe\n\t\t} else {\n\t\t\tset _search_path [split $env(PATH) :]\n\t\t\tset _search_exe {}\n\t\t}\n\t}\n\n\tif {[is_Windows] && [lsearch -exact $args -script] >= 0} {\n\t\tset suffix {}\n\t} else {\n\t\tset suffix $_search_exe\n\t}\n\n\tforeach p $_search_path {\n\t\tset p [file join $p $what$suffix]\n\t\tif {[file exists $p]} {\n\t\t\treturn [file normalize $p]\n\t\t}\n\t}\n\treturn {}\n}\n\nproc sanitize_command_line {command_line from_index} {\n\tset i $from_index\n\twhile {$i < [llength $command_line]} {\n\t\tset cmd [lindex $command_line $i]\n\t\tif {[file pathtype $cmd] ne \"absolute\"} {\n\t\t\tset fullpath [_which $cmd]\n\t\t\tif {$fullpath eq \"\"} {\n\t\t\t\tthrow {NOT-FOUND} \"$cmd not found in PATH\"\n\t\t\t}\n\t\t\tlset command_line $i $fullpath\n\t\t}\n\n\t\t# handle piped commands, e.g. `exec A | B`\n\t\tfor {incr i} {$i < [llength $command_line]} {incr i} {\n\t\t\tif {[lindex $command_line $i] eq \"|\"} {\n\t\t\t\tincr i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn $command_line\n}\n\n# Override `exec` to avoid unsafe PATH lookup\n\nrename exec real_exec\n\nproc exec {args} {\n\t# skip options\n\tfor {set i 0} {$i < [llength $args]} {incr i} {\n\t\tset arg [lindex $args $i]\n\t\tif {$arg eq \"--\"} {\n\t\t\tincr i\n\t\t\tbreak\n\t\t}\n\t\tif {[string range $arg 0 0] ne \"-\"} {\n\t\t\tbreak\n\t\t}\n\t}\n\tset args [sanitize_command_line $args $i]\n\tuplevel 1 real_exec $args\n}\n\n# Override `open` to avoid unsafe PATH lookup\n\nrename open real_open\n\nproc open {args} {\n\tset arg0 [lindex $args 0]\n\tif {[string range $arg0 0 0] eq \"|\"} {\n\t\tset command_line [string trim [string range $arg0 1 end]]\n\t\tlset args 0 \"| [sanitize_command_line $command_line 0]\"\n\t}\n\tuplevel 1 real_open $args\n}\n\n# End of safe PATH lookup stuff\n\nproc hasworktree {} {\n    return [expr {[exec git rev-parse --is-bare-repository] == \"false\" &&\n                  [exec git rev-parse --is-inside-git-dir] == \"false\"}]\n}\n\nproc reponame {} {\n    global gitdir\n    set n [file normalize $gitdir]\n    if {[string match \"*/.git\" $n]} {\n        set n [string range $n 0 end-5]\n    }\n    return [file tail $n]\n}\n\nproc gitworktree {} {\n    variable _gitworktree\n    if {[info exists _gitworktree]} {\n        return $_gitworktree\n    }\n    # v1.7.0 introduced --show-toplevel to return the canonical work-tree\n    if {[catch {set _gitworktree [exec git rev-parse --show-toplevel]}]} {\n        # try to set work tree from environment, core.worktree or use\n        # cdup to obtain a relative path to the top of the worktree. If\n        # run from the top, the ./ prefix ensures normalize expands pwd.\n        if {[catch { set _gitworktree $env(GIT_WORK_TREE) }]} {\n            if {[catch {set _gitworktree [exec git config --get core.worktree]}]} {\n                set _gitworktree [file normalize ./[exec git rev-parse --show-cdup]]\n            }\n        }\n    }\n    return $_gitworktree\n}\n\n# A simple scheduler for compute-intensive stuff.\n# The aim is to make sure that event handlers for GUI actions can\n# run at least every 50-100 ms.  Unfortunately fileevent handlers are\n# run before X event handlers, so reading from a fast source can\n# make the GUI completely unresponsive.\nproc run args {\n    global isonrunq runq currunq\n\n    set script $args\n    if {[info exists isonrunq($script)]} return\n    if {$runq eq {} && ![info exists currunq]} {\n        after idle dorunq\n    }\n    lappend runq [list {} $script]\n    set isonrunq($script) 1\n}\n\nproc filerun {fd script} {\n    fileevent $fd readable [list filereadable $fd $script]\n}\n\nproc filereadable {fd script} {\n    global runq currunq\n\n    fileevent $fd readable {}\n    if {$runq eq {} && ![info exists currunq]} {\n        after idle dorunq\n    }\n    lappend runq [list $fd $script]\n}\n\nproc nukefile {fd} {\n    global runq\n\n    for {set i 0} {$i < [llength $runq]} {} {\n        if {[lindex $runq $i 0] eq $fd} {\n            set runq [lreplace $runq $i $i]\n        } else {\n            incr i\n        }\n    }\n}\n\nproc dorunq {} {\n    global isonrunq runq currunq\n\n    set tstart [clock clicks -milliseconds]\n    set t0 $tstart\n    while {[llength $runq] > 0} {\n        set fd [lindex $runq 0 0]\n        set script [lindex $runq 0 1]\n        set currunq [lindex $runq 0]\n        set runq [lrange $runq 1 end]\n        set repeat [eval $script]\n        unset currunq\n        set t1 [clock clicks -milliseconds]\n        set t [expr {$t1 - $t0}]\n        if {$repeat ne {} && $repeat} {\n            if {$fd eq {} || $repeat == 2} {\n                # script returns 1 if it wants to be readded\n                # file readers return 2 if they could do more straight away\n                lappend runq [list $fd $script]\n            } else {\n                fileevent $fd readable [list filereadable $fd $script]\n            }\n        } elseif {$fd eq {}} {\n            unset isonrunq($script)\n        }\n        set t0 $t1\n        if {$t1 - $tstart >= 80} break\n    }\n    if {$runq ne {}} {\n        after idle dorunq\n    }\n}\n\nproc reg_instance {fd} {\n    global commfd leftover loginstance\n\n    set i [incr loginstance]\n    set commfd($i) $fd\n    set leftover($i) {}\n    return $i\n}\n\nproc unmerged_files {files} {\n    global nr_unmerged\n\n    # find the list of unmerged files\n    set mlist {}\n    set nr_unmerged 0\n    if {[catch {\n        set fd [open \"| git ls-files -u\" r]\n    } err]} {\n        show_error {} . \"[mc \"Couldn't get list of unmerged files:\"] $err\"\n        exit 1\n    }\n    while {[gets $fd line] >= 0} {\n        set i [string first \"\\t\" $line]\n        if {$i < 0} continue\n        set fname [string range $line [expr {$i+1}] end]\n        if {[lsearch -exact $mlist $fname] >= 0} continue\n        incr nr_unmerged\n        if {$files eq {} || [path_filter $files $fname]} {\n            lappend mlist $fname\n        }\n    }\n    catch {close $fd}\n    return $mlist\n}\n\nproc parseviewargs {n arglist} {\n    global vdatemode vmergeonly vflags vdflags vrevs vfiltered vorigargs env\n    global vinlinediff\n    global worddiff git_version\n\n    set vdatemode($n) 0\n    set vmergeonly($n) 0\n    set vinlinediff($n) 0\n    set glflags {}\n    set diffargs {}\n    set nextisval 0\n    set revargs {}\n    set origargs $arglist\n    set allknown 1\n    set filtered 0\n    set i -1\n    foreach arg $arglist {\n        incr i\n        if {$nextisval} {\n            lappend glflags $arg\n            set nextisval 0\n            continue\n        }\n        switch -glob -- $arg {\n            \"-d\" -\n            \"--date-order\" {\n                set vdatemode($n) 1\n                # remove from origargs in case we hit an unknown option\n                set origargs [lreplace $origargs $i $i]\n                incr i -1\n            }\n            \"-[puabwcrRBMC]\" -\n            \"--no-renames\" - \"--full-index\" - \"--binary\" - \"--abbrev=*\" -\n            \"--find-copies-harder\" - \"-l*\" - \"--ext-diff\" - \"--no-ext-diff\" -\n            \"--src-prefix=*\" - \"--dst-prefix=*\" - \"--no-prefix\" -\n            \"-O*\" - \"--text\" - \"--full-diff\" - \"--ignore-space-at-eol\" -\n            \"--ignore-space-change\" - \"-U*\" - \"--unified=*\" {\n                # These request or affect diff output, which we don't want.\n                # Some could be used to set our defaults for diff display.\n                lappend diffargs $arg\n            }\n            \"--raw\" - \"--patch-with-raw\" - \"--patch-with-stat\" -\n            \"--name-only\" - \"--name-status\" - \"--color\" -\n            \"--log-size\" - \"--pretty=*\" - \"--decorate\" - \"--abbrev-commit\" -\n            \"--cc\" - \"-z\" - \"--header\" - \"--parents\" - \"--boundary\" -\n            \"--no-color\" - \"-g\" - \"--walk-reflogs\" - \"--no-walk\" -\n            \"--timestamp\" - \"relative-date\" - \"--date=*\" - \"--stdin\" -\n            \"--objects\" - \"--objects-edge\" - \"--reverse\" {\n                # These cause our parsing of git log's output to fail, or else\n                # they're options we want to set ourselves, so ignore them.\n            }\n            \"--color-words*\" - \"--word-diff=color\" {\n                # These trigger a word diff in the console interface,\n                # so help the user by enabling our own support\n                if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n                    set worddiff [mc \"Color words\"]\n                }\n            }\n            \"--word-diff*\" {\n                if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n                    set worddiff [mc \"Markup words\"]\n                }\n            }\n            \"--stat=*\" - \"--numstat\" - \"--shortstat\" - \"--summary\" -\n            \"--check\" - \"--exit-code\" - \"--quiet\" - \"--topo-order\" -\n            \"--full-history\" - \"--dense\" - \"--sparse\" -\n            \"--follow\" - \"--left-right\" - \"--encoding=*\" {\n                # These are harmless, and some are even useful\n                lappend glflags $arg\n            }\n            \"--diff-filter=*\" - \"--no-merges\" - \"--unpacked\" -\n            \"--max-count=*\" - \"--skip=*\" - \"--since=*\" - \"--after=*\" -\n            \"--until=*\" - \"--before=*\" - \"--max-age=*\" - \"--min-age=*\" -\n            \"--author=*\" - \"--committer=*\" - \"--grep=*\" - \"-[iE]\" -\n            \"--remove-empty\" - \"--first-parent\" - \"--cherry-pick\" -\n            \"-S*\" - \"-G*\" - \"--pickaxe-all\" - \"--pickaxe-regex\" -\n            \"--simplify-by-decoration\" {\n                # These mean that we get a subset of the commits\n                set filtered 1\n                lappend glflags $arg\n            }\n            \"-L*\" {\n                # Line-log with 'stuck' argument (unstuck form is\n                # not supported)\n                set filtered 1\n                set vinlinediff($n) 1\n                set allknown 0\n                lappend glflags $arg\n            }\n            \"-n\" {\n                # This appears to be the only one that has a value as a\n                # separate word following it\n                set filtered 1\n                set nextisval 1\n                lappend glflags $arg\n            }\n            \"--not\" - \"--all\" {\n                lappend revargs $arg\n            }\n            \"--merge\" {\n                set vmergeonly($n) 1\n                # git rev-parse doesn't understand --merge\n                lappend revargs --gitk-symmetric-diff-marker MERGE_HEAD...HEAD\n            }\n            \"--no-replace-objects\" {\n                set env(GIT_NO_REPLACE_OBJECTS) \"1\"\n            }\n            \"-*\" {\n                # Other flag arguments including -<n>\n                if {[string is digit -strict [string range $arg 1 end]]} {\n                    set filtered 1\n                } else {\n                    # a flag argument that we don't recognize;\n                    # that means we can't optimize\n                    set allknown 0\n                }\n                lappend glflags $arg\n            }\n            default {\n                # Non-flag arguments specify commits or ranges of commits\n                if {[string match \"*...*\" $arg]} {\n                    lappend revargs --gitk-symmetric-diff-marker\n                }\n                lappend revargs $arg\n            }\n        }\n    }\n    set vdflags($n) $diffargs\n    set vflags($n) $glflags\n    set vrevs($n) $revargs\n    set vfiltered($n) $filtered\n    set vorigargs($n) $origargs\n    return $allknown\n}\n\nproc parseviewrevs {view revs} {\n    global vposids vnegids\n\n    if {$revs eq {}} {\n        set revs HEAD\n    } elseif {[lsearch -exact $revs --all] >= 0} {\n        lappend revs HEAD\n    }\n    if {[catch {set ids [eval exec git rev-parse $revs]} err]} {\n        # we get stdout followed by stderr in $err\n        # for an unknown rev, git rev-parse echoes it and then errors out\n        set errlines [split $err \"\\n\"]\n        set badrev {}\n        for {set l 0} {$l < [llength $errlines]} {incr l} {\n            set line [lindex $errlines $l]\n            if {!([string length $line] == 40 && [string is xdigit $line])} {\n                if {[string match \"fatal:*\" $line]} {\n                    if {[string match \"fatal: ambiguous argument*\" $line]\n                        && $badrev ne {}} {\n                        if {[llength $badrev] == 1} {\n                            set err \"unknown revision $badrev\"\n                        } else {\n                            set err \"unknown revisions: [join $badrev \", \"]\"\n                        }\n                    } else {\n                        set err [join [lrange $errlines $l end] \"\\n\"]\n                    }\n                    break\n                }\n                lappend badrev $line\n            }\n        }\n        error_popup \"[mc \"Error parsing revisions:\"] $err\"\n        return {}\n    }\n    set ret {}\n    set pos {}\n    set neg {}\n    set sdm 0\n    foreach id [split $ids \"\\n\"] {\n        if {$id eq \"--gitk-symmetric-diff-marker\"} {\n            set sdm 4\n        } elseif {[string match \"^*\" $id]} {\n            if {$sdm != 1} {\n                lappend ret $id\n                if {$sdm == 3} {\n                    set sdm 0\n                }\n            }\n            lappend neg [string range $id 1 end]\n        } else {\n            if {$sdm != 2} {\n                lappend ret $id\n            } else {\n                lset ret end $id...[lindex $ret end]\n            }\n            lappend pos $id\n        }\n        incr sdm -1\n    }\n    set vposids($view) $pos\n    set vnegids($view) $neg\n    return $ret\n}\n\n# Escapes a list of filter paths to be passed to git log via stdin. Note that\n# paths must not be quoted.\nproc escape_filter_paths {paths} {\n\tset escaped [list]\n\tforeach path $paths {\n\t\tlappend escaped [string map {\\\\ \\\\\\\\ \"\\ \" \"\\\\\\ \"} $path]\n\t}\n\treturn $escaped\n}\n\n# Start off a git log process and arrange to read its output\nproc start_rev_list {view} {\n    global startmsecs commitidx viewcomplete curview\n    global tclencoding\n    global viewargs viewargscmd viewfiles vfilelimit\n    global showlocalchanges\n    global viewactive viewinstances vmergeonly\n    global mainheadid viewmainheadid viewmainheadid_orig\n    global vcanopt vflags vrevs vorigargs\n    global show_notes\n\n    set startmsecs [clock clicks -milliseconds]\n    set commitidx($view) 0\n    # these are set this way for the error exits\n    set viewcomplete($view) 1\n    set viewactive($view) 0\n    varcinit $view\n\n    set args $viewargs($view)\n    if {$viewargscmd($view) ne {}} {\n        if {[catch {\n            set str [exec sh -c $viewargscmd($view)]\n        } err]} {\n            error_popup \"[mc \"Error executing --argscmd command:\"] $err\"\n            return 0\n        }\n        set args [concat $args [split $str \"\\n\"]]\n    }\n    set vcanopt($view) [parseviewargs $view $args]\n\n    set files $viewfiles($view)\n    if {$vmergeonly($view)} {\n        set files [unmerged_files $files]\n        if {$files eq {}} {\n            global nr_unmerged\n            if {$nr_unmerged == 0} {\n                error_popup [mc \"No files selected: --merge specified but\\\n                             no files are unmerged.\"]\n            } else {\n                error_popup [mc \"No files selected: --merge specified but\\\n                             no unmerged files are within file limit.\"]\n            }\n            return 0\n        }\n    }\n    set vfilelimit($view) $files\n\n    if {$vcanopt($view)} {\n        set revs [parseviewrevs $view $vrevs($view)]\n        if {$revs eq {}} {\n            return 0\n        }\n        set args $vflags($view)\n    } else {\n        set revs {}\n        set args $vorigargs($view)\n    }\n\n    if {[catch {\n        set fd [open [concat | git log --no-color -z --pretty=raw $show_notes \\\n                        --parents --boundary $args --stdin \\\n                        \"<<[join [concat $revs \"--\" \\\n                                [escape_filter_paths $files]] \"\\\\n\"]\"] r]\n    } err]} {\n        error_popup \"[mc \"Error executing git log:\"] $err\"\n        return 0\n    }\n    set i [reg_instance $fd]\n    set viewinstances($view) [list $i]\n    set viewmainheadid($view) $mainheadid\n    set viewmainheadid_orig($view) $mainheadid\n    if {$files ne {} && $mainheadid ne {}} {\n        get_viewmainhead $view\n    }\n    if {$showlocalchanges && $viewmainheadid($view) ne {}} {\n        interestedin $viewmainheadid($view) dodiffindex\n    }\n    fconfigure $fd -blocking 0 -translation lf -eofchar {}\n    if {$tclencoding != {}} {\n        fconfigure $fd -encoding $tclencoding\n    }\n    filerun $fd [list getcommitlines $fd $i $view 0]\n    nowbusy $view [mc \"Reading\"]\n    set viewcomplete($view) 0\n    set viewactive($view) 1\n    return 1\n}\n\nproc stop_instance {inst} {\n    global commfd leftover\n\n    set fd $commfd($inst)\n    catch {\n        set pid [pid $fd]\n\n        if {$::tcl_platform(platform) eq {windows}} {\n            exec taskkill /pid $pid\n        } else {\n            exec kill $pid\n        }\n    }\n    catch {close $fd}\n    nukefile $fd\n    unset commfd($inst)\n    unset leftover($inst)\n}\n\nproc stop_backends {} {\n    global commfd\n\n    foreach inst [array names commfd] {\n        stop_instance $inst\n    }\n}\n\nproc stop_rev_list {view} {\n    global viewinstances\n\n    foreach inst $viewinstances($view) {\n        stop_instance $inst\n    }\n    set viewinstances($view) {}\n}\n\nproc reset_pending_select {selid} {\n    global pending_select mainheadid selectheadid\n\n    if {$selid ne {}} {\n        set pending_select $selid\n    } elseif {$selectheadid ne {}} {\n        set pending_select $selectheadid\n    } else {\n        set pending_select $mainheadid\n    }\n}\n\nproc getcommits {selid} {\n    global canv curview need_redisplay viewactive\n\n    initlayout\n    if {[start_rev_list $curview]} {\n        reset_pending_select $selid\n        show_status [mc \"Reading commits...\"]\n        set need_redisplay 1\n    } else {\n        show_status [mc \"No commits selected\"]\n    }\n}\n\nproc updatecommits {} {\n    global curview vcanopt vorigargs vfilelimit viewinstances\n    global viewactive viewcomplete tclencoding\n    global startmsecs showneartags showlocalchanges\n    global mainheadid viewmainheadid viewmainheadid_orig pending_select\n    global hasworktree\n    global varcid vposids vnegids vflags vrevs\n    global show_notes\n\n    set hasworktree [hasworktree]\n    rereadrefs\n    set view $curview\n    if {$mainheadid ne $viewmainheadid_orig($view)} {\n        if {$showlocalchanges} {\n            dohidelocalchanges\n        }\n        set viewmainheadid($view) $mainheadid\n        set viewmainheadid_orig($view) $mainheadid\n        if {$vfilelimit($view) ne {}} {\n            get_viewmainhead $view\n        }\n    }\n    if {$showlocalchanges} {\n        doshowlocalchanges\n    }\n    if {$vcanopt($view)} {\n        set oldpos $vposids($view)\n        set oldneg $vnegids($view)\n        set revs [parseviewrevs $view $vrevs($view)]\n        if {$revs eq {}} {\n            return\n        }\n        # note: getting the delta when negative refs change is hard,\n        # and could require multiple git log invocations, so in that\n        # case we ask git log for all the commits (not just the delta)\n        if {$oldneg eq $vnegids($view)} {\n            set newrevs {}\n            set npos 0\n            # take out positive refs that we asked for before or\n            # that we have already seen\n            foreach rev $revs {\n                if {[string length $rev] == 40} {\n                    if {[lsearch -exact $oldpos $rev] < 0\n                        && ![info exists varcid($view,$rev)]} {\n                        lappend newrevs $rev\n                        incr npos\n                    }\n                } else {\n                    lappend $newrevs $rev\n                }\n            }\n            if {$npos == 0} return\n            set revs $newrevs\n            set vposids($view) [lsort -unique [concat $oldpos $vposids($view)]]\n        }\n        set args $vflags($view)\n        foreach r $oldpos {\n                lappend revs \"^$r\"\n        }\n    } else {\n        set revs {}\n        set args $vorigargs($view)\n    }\n    if {[catch {\n        set fd [open [concat | git log --no-color -z --pretty=raw $show_notes \\\n                        --parents --boundary $args --stdin \\\n                        \"<<[join [concat $revs \"--\" \\\n                                [escape_filter_paths \\\n                                        $vfilelimit($view)]] \"\\\\n\"]\"] r]\n    } err]} {\n        error_popup \"[mc \"Error executing git log:\"] $err\"\n        return\n    }\n    if {$viewactive($view) == 0} {\n        set startmsecs [clock clicks -milliseconds]\n    }\n    set i [reg_instance $fd]\n    lappend viewinstances($view) $i\n    fconfigure $fd -blocking 0 -translation lf -eofchar {}\n    if {$tclencoding != {}} {\n        fconfigure $fd -encoding $tclencoding\n    }\n    filerun $fd [list getcommitlines $fd $i $view 1]\n    incr viewactive($view)\n    set viewcomplete($view) 0\n    reset_pending_select {}\n    nowbusy $view [mc \"Reading\"]\n    if {$showneartags} {\n        getallcommits\n    }\n}\n\nproc reloadcommits {} {\n    global curview viewcomplete selectedline currentid thickerline\n    global showneartags treediffs commitinterest cached_commitrow\n    global targetid commitinfo\n\n    set selid {}\n    if {$selectedline ne {}} {\n        set selid $currentid\n    }\n\n    if {!$viewcomplete($curview)} {\n        stop_rev_list $curview\n    }\n    resetvarcs $curview\n    set selectedline {}\n    unset -nocomplain currentid\n    unset -nocomplain thickerline\n    unset -nocomplain treediffs\n    readrefs\n    changedrefs\n    if {$showneartags} {\n        getallcommits\n    }\n    clear_display\n    unset -nocomplain commitinfo\n    unset -nocomplain commitinterest\n    unset -nocomplain cached_commitrow\n    unset -nocomplain targetid\n    setcanvscroll\n    getcommits $selid\n    return 0\n}\n\n# This makes a string representation of a positive integer which\n# sorts as a string in numerical order\nproc strrep {n} {\n    if {$n < 16} {\n        return [format \"%x\" $n]\n    } elseif {$n < 256} {\n        return [format \"x%.2x\" $n]\n    } elseif {$n < 65536} {\n        return [format \"y%.4x\" $n]\n    }\n    return [format \"z%.8x\" $n]\n}\n\n# Procedures used in reordering commits from git log (without\n# --topo-order) into the order for display.\n\nproc varcinit {view} {\n    global varcstart vupptr vdownptr vleftptr vbackptr varctok varcrow\n    global vtokmod varcmod vrowmod varcix vlastins\n\n    set varcstart($view) {{}}\n    set vupptr($view) {0}\n    set vdownptr($view) {0}\n    set vleftptr($view) {0}\n    set vbackptr($view) {0}\n    set varctok($view) {{}}\n    set varcrow($view) {{}}\n    set vtokmod($view) {}\n    set varcmod($view) 0\n    set vrowmod($view) 0\n    set varcix($view) {{}}\n    set vlastins($view) {0}\n}\n\nproc resetvarcs {view} {\n    global varcid varccommits parents children vseedcount ordertok\n    global vshortids\n\n    foreach vid [array names varcid $view,*] {\n        unset varcid($vid)\n        unset children($vid)\n        unset parents($vid)\n    }\n    foreach vid [array names vshortids $view,*] {\n        unset vshortids($vid)\n    }\n    # some commits might have children but haven't been seen yet\n    foreach vid [array names children $view,*] {\n        unset children($vid)\n    }\n    foreach va [array names varccommits $view,*] {\n        unset varccommits($va)\n    }\n    foreach vd [array names vseedcount $view,*] {\n        unset vseedcount($vd)\n    }\n    unset -nocomplain ordertok\n}\n\n# returns a list of the commits with no children\nproc seeds {v} {\n    global vdownptr vleftptr varcstart\n\n    set ret {}\n    set a [lindex $vdownptr($v) 0]\n    while {$a != 0} {\n        lappend ret [lindex $varcstart($v) $a]\n        set a [lindex $vleftptr($v) $a]\n    }\n    return $ret\n}\n\nproc newvarc {view id} {\n    global varcid varctok parents children vdatemode\n    global vupptr vdownptr vleftptr vbackptr varcrow varcix varcstart\n    global commitdata commitinfo vseedcount varccommits vlastins\n\n    set a [llength $varctok($view)]\n    set vid $view,$id\n    if {[llength $children($vid)] == 0 || $vdatemode($view)} {\n        if {![info exists commitinfo($id)]} {\n            parsecommit $id $commitdata($id) 1\n        }\n        set cdate [lindex [lindex $commitinfo($id) 4] 0]\n        if {![string is integer -strict $cdate]} {\n            set cdate 0\n        }\n        if {![info exists vseedcount($view,$cdate)]} {\n            set vseedcount($view,$cdate) -1\n        }\n        set c [incr vseedcount($view,$cdate)]\n        set cdate [expr {$cdate ^ 0xffffffff}]\n        set tok \"s[strrep $cdate][strrep $c]\"\n    } else {\n        set tok {}\n    }\n    set ka 0\n    if {[llength $children($vid)] > 0} {\n        set kid [lindex $children($vid) end]\n        set k $varcid($view,$kid)\n        if {[string compare [lindex $varctok($view) $k] $tok] > 0} {\n            set ki $kid\n            set ka $k\n            set tok [lindex $varctok($view) $k]\n        }\n    }\n    if {$ka != 0} {\n        set i [lsearch -exact $parents($view,$ki) $id]\n        set j [expr {[llength $parents($view,$ki)] - 1 - $i}]\n        append tok [strrep $j]\n    }\n    set c [lindex $vlastins($view) $ka]\n    if {$c == 0 || [string compare $tok [lindex $varctok($view) $c]] < 0} {\n        set c $ka\n        set b [lindex $vdownptr($view) $ka]\n    } else {\n        set b [lindex $vleftptr($view) $c]\n    }\n    while {$b != 0 && [string compare $tok [lindex $varctok($view) $b]] >= 0} {\n        set c $b\n        set b [lindex $vleftptr($view) $c]\n    }\n    if {$c == $ka} {\n        lset vdownptr($view) $ka $a\n        lappend vbackptr($view) 0\n    } else {\n        lset vleftptr($view) $c $a\n        lappend vbackptr($view) $c\n    }\n    lset vlastins($view) $ka $a\n    lappend vupptr($view) $ka\n    lappend vleftptr($view) $b\n    if {$b != 0} {\n        lset vbackptr($view) $b $a\n    }\n    lappend varctok($view) $tok\n    lappend varcstart($view) $id\n    lappend vdownptr($view) 0\n    lappend varcrow($view) {}\n    lappend varcix($view) {}\n    set varccommits($view,$a) {}\n    lappend vlastins($view) 0\n    return $a\n}\n\nproc splitvarc {p v} {\n    global varcid varcstart varccommits varctok vtokmod\n    global vupptr vdownptr vleftptr vbackptr varcix varcrow vlastins\n\n    set oa $varcid($v,$p)\n    set otok [lindex $varctok($v) $oa]\n    set ac $varccommits($v,$oa)\n    set i [lsearch -exact $varccommits($v,$oa) $p]\n    if {$i <= 0} return\n    set na [llength $varctok($v)]\n    # \"%\" sorts before \"0\"...\n    set tok \"$otok%[strrep $i]\"\n    lappend varctok($v) $tok\n    lappend varcrow($v) {}\n    lappend varcix($v) {}\n    set varccommits($v,$oa) [lrange $ac 0 [expr {$i - 1}]]\n    set varccommits($v,$na) [lrange $ac $i end]\n    lappend varcstart($v) $p\n    foreach id $varccommits($v,$na) {\n        set varcid($v,$id) $na\n    }\n    lappend vdownptr($v) [lindex $vdownptr($v) $oa]\n    lappend vlastins($v) [lindex $vlastins($v) $oa]\n    lset vdownptr($v) $oa $na\n    lset vlastins($v) $oa 0\n    lappend vupptr($v) $oa\n    lappend vleftptr($v) 0\n    lappend vbackptr($v) 0\n    for {set b [lindex $vdownptr($v) $na]} {$b != 0} {set b [lindex $vleftptr($v) $b]} {\n        lset vupptr($v) $b $na\n    }\n    if {[string compare $otok $vtokmod($v)] <= 0} {\n        modify_arc $v $oa\n    }\n}\n\nproc renumbervarc {a v} {\n    global parents children varctok varcstart varccommits\n    global vupptr vdownptr vleftptr vbackptr vlastins varcid vtokmod vdatemode\n\n    set t1 [clock clicks -milliseconds]\n    set todo {}\n    set isrelated($a) 1\n    set kidchanged($a) 1\n    set ntot 0\n    while {$a != 0} {\n        if {[info exists isrelated($a)]} {\n            lappend todo $a\n            set id [lindex $varccommits($v,$a) end]\n            foreach p $parents($v,$id) {\n                if {[info exists varcid($v,$p)]} {\n                    set isrelated($varcid($v,$p)) 1\n                }\n            }\n        }\n        incr ntot\n        set b [lindex $vdownptr($v) $a]\n        if {$b == 0} {\n            while {$a != 0} {\n                set b [lindex $vleftptr($v) $a]\n                if {$b != 0} break\n                set a [lindex $vupptr($v) $a]\n            }\n        }\n        set a $b\n    }\n    foreach a $todo {\n        if {![info exists kidchanged($a)]} continue\n        set id [lindex $varcstart($v) $a]\n        if {[llength $children($v,$id)] > 1} {\n            set children($v,$id) [lsort -command [list vtokcmp $v] \\\n                                      $children($v,$id)]\n        }\n        set oldtok [lindex $varctok($v) $a]\n        if {!$vdatemode($v)} {\n            set tok {}\n        } else {\n            set tok $oldtok\n        }\n        set ka 0\n        set kid [last_real_child $v,$id]\n        if {$kid ne {}} {\n            set k $varcid($v,$kid)\n            if {[string compare [lindex $varctok($v) $k] $tok] > 0} {\n                set ki $kid\n                set ka $k\n                set tok [lindex $varctok($v) $k]\n            }\n        }\n        if {$ka != 0} {\n            set i [lsearch -exact $parents($v,$ki) $id]\n            set j [expr {[llength $parents($v,$ki)] - 1 - $i}]\n            append tok [strrep $j]\n        }\n        if {$tok eq $oldtok} {\n            continue\n        }\n        set id [lindex $varccommits($v,$a) end]\n        foreach p $parents($v,$id) {\n            if {[info exists varcid($v,$p)]} {\n                set kidchanged($varcid($v,$p)) 1\n            } else {\n                set sortkids($p) 1\n            }\n        }\n        lset varctok($v) $a $tok\n        set b [lindex $vupptr($v) $a]\n        if {$b != $ka} {\n            if {[string compare [lindex $varctok($v) $ka] $vtokmod($v)] < 0} {\n                modify_arc $v $ka\n            }\n            if {[string compare [lindex $varctok($v) $b] $vtokmod($v)] < 0} {\n                modify_arc $v $b\n            }\n            set c [lindex $vbackptr($v) $a]\n            set d [lindex $vleftptr($v) $a]\n            if {$c == 0} {\n                lset vdownptr($v) $b $d\n            } else {\n                lset vleftptr($v) $c $d\n            }\n            if {$d != 0} {\n                lset vbackptr($v) $d $c\n            }\n            if {[lindex $vlastins($v) $b] == $a} {\n                lset vlastins($v) $b $c\n            }\n            lset vupptr($v) $a $ka\n            set c [lindex $vlastins($v) $ka]\n            if {$c == 0 || \\\n                    [string compare $tok [lindex $varctok($v) $c]] < 0} {\n                set c $ka\n                set b [lindex $vdownptr($v) $ka]\n            } else {\n                set b [lindex $vleftptr($v) $c]\n            }\n            while {$b != 0 && \\\n                      [string compare $tok [lindex $varctok($v) $b]] >= 0} {\n                set c $b\n                set b [lindex $vleftptr($v) $c]\n            }\n            if {$c == $ka} {\n                lset vdownptr($v) $ka $a\n                lset vbackptr($v) $a 0\n            } else {\n                lset vleftptr($v) $c $a\n                lset vbackptr($v) $a $c\n            }\n            lset vleftptr($v) $a $b\n            if {$b != 0} {\n                lset vbackptr($v) $b $a\n            }\n            lset vlastins($v) $ka $a\n        }\n    }\n    foreach id [array names sortkids] {\n        if {[llength $children($v,$id)] > 1} {\n            set children($v,$id) [lsort -command [list vtokcmp $v] \\\n                                      $children($v,$id)]\n        }\n    }\n    set t2 [clock clicks -milliseconds]\n    #puts \"renumbervarc did [llength $todo] of $ntot arcs in [expr {$t2-$t1}]ms\"\n}\n\n# Fix up the graph after we have found out that in view $v,\n# $p (a commit that we have already seen) is actually the parent\n# of the last commit in arc $a.\nproc fix_reversal {p a v} {\n    global varcid varcstart varctok vupptr\n\n    set pa $varcid($v,$p)\n    if {$p ne [lindex $varcstart($v) $pa]} {\n        splitvarc $p $v\n        set pa $varcid($v,$p)\n    }\n    # seeds always need to be renumbered\n    if {[lindex $vupptr($v) $pa] == 0 ||\n        [string compare [lindex $varctok($v) $a] \\\n             [lindex $varctok($v) $pa]] > 0} {\n        renumbervarc $pa $v\n    }\n}\n\nproc insertrow {id p v} {\n    global cmitlisted children parents varcid varctok vtokmod\n    global varccommits ordertok commitidx numcommits curview\n    global targetid targetrow vshortids\n\n    readcommit $id\n    set vid $v,$id\n    set cmitlisted($vid) 1\n    set children($vid) {}\n    set parents($vid) [list $p]\n    set a [newvarc $v $id]\n    set varcid($vid) $a\n    lappend vshortids($v,[string range $id 0 3]) $id\n    if {[string compare [lindex $varctok($v) $a] $vtokmod($v)] < 0} {\n        modify_arc $v $a\n    }\n    lappend varccommits($v,$a) $id\n    set vp $v,$p\n    if {[llength [lappend children($vp) $id]] > 1} {\n        set children($vp) [lsort -command [list vtokcmp $v] $children($vp)]\n        unset -nocomplain ordertok\n    }\n    fix_reversal $p $a $v\n    incr commitidx($v)\n    if {$v == $curview} {\n        set numcommits $commitidx($v)\n        setcanvscroll\n        if {[info exists targetid]} {\n            if {![comes_before $targetid $p]} {\n                incr targetrow\n            }\n        }\n    }\n}\n\nproc insertfakerow {id p} {\n    global varcid varccommits parents children cmitlisted\n    global commitidx varctok vtokmod targetid targetrow curview numcommits\n\n    set v $curview\n    set a $varcid($v,$p)\n    set i [lsearch -exact $varccommits($v,$a) $p]\n    if {$i < 0} {\n        puts \"oops: insertfakerow can't find [shortids $p] on arc $a\"\n        return\n    }\n    set children($v,$id) {}\n    set parents($v,$id) [list $p]\n    set varcid($v,$id) $a\n    lappend children($v,$p) $id\n    set cmitlisted($v,$id) 1\n    set numcommits [incr commitidx($v)]\n    # note we deliberately don't update varcstart($v) even if $i == 0\n    set varccommits($v,$a) [linsert $varccommits($v,$a) $i $id]\n    modify_arc $v $a $i\n    if {[info exists targetid]} {\n        if {![comes_before $targetid $p]} {\n            incr targetrow\n        }\n    }\n    setcanvscroll\n    drawvisible\n}\n\nproc removefakerow {id} {\n    global varcid varccommits parents children commitidx\n    global varctok vtokmod cmitlisted currentid selectedline\n    global targetid curview numcommits\n\n    set v $curview\n    if {[llength $parents($v,$id)] != 1} {\n        puts \"oops: removefakerow [shortids $id] has [llength $parents($v,$id)] parents\"\n        return\n    }\n    set p [lindex $parents($v,$id) 0]\n    set a $varcid($v,$id)\n    set i [lsearch -exact $varccommits($v,$a) $id]\n    if {$i < 0} {\n        puts \"oops: removefakerow can't find [shortids $id] on arc $a\"\n        return\n    }\n    unset varcid($v,$id)\n    set varccommits($v,$a) [lreplace $varccommits($v,$a) $i $i]\n    unset parents($v,$id)\n    unset children($v,$id)\n    unset cmitlisted($v,$id)\n    set numcommits [incr commitidx($v) -1]\n    set j [lsearch -exact $children($v,$p) $id]\n    if {$j >= 0} {\n        set children($v,$p) [lreplace $children($v,$p) $j $j]\n    }\n    modify_arc $v $a $i\n    if {[info exist currentid] && $id eq $currentid} {\n        unset currentid\n        set selectedline {}\n    }\n    if {[info exists targetid] && $targetid eq $id} {\n        set targetid $p\n    }\n    setcanvscroll\n    drawvisible\n}\n\nproc real_children {vp} {\n    global children nullid nullid2\n\n    set kids {}\n    foreach id $children($vp) {\n        if {$id ne $nullid && $id ne $nullid2} {\n            lappend kids $id\n        }\n    }\n    return $kids\n}\n\nproc first_real_child {vp} {\n    global children nullid nullid2\n\n    foreach id $children($vp) {\n        if {$id ne $nullid && $id ne $nullid2} {\n            return $id\n        }\n    }\n    return {}\n}\n\nproc last_real_child {vp} {\n    global children nullid nullid2\n\n    set kids $children($vp)\n    for {set i [llength $kids]} {[incr i -1] >= 0} {} {\n        set id [lindex $kids $i]\n        if {$id ne $nullid && $id ne $nullid2} {\n            return $id\n        }\n    }\n    return {}\n}\n\nproc vtokcmp {v a b} {\n    global varctok varcid\n\n    return [string compare [lindex $varctok($v) $varcid($v,$a)] \\\n                [lindex $varctok($v) $varcid($v,$b)]]\n}\n\n# This assumes that if lim is not given, the caller has checked that\n# arc a's token is less than $vtokmod($v)\nproc modify_arc {v a {lim {}}} {\n    global varctok vtokmod varcmod varcrow vupptr curview vrowmod varccommits\n\n    if {$lim ne {}} {\n        set c [string compare [lindex $varctok($v) $a] $vtokmod($v)]\n        if {$c > 0} return\n        if {$c == 0} {\n            set r [lindex $varcrow($v) $a]\n            if {$r ne {} && $vrowmod($v) <= $r + $lim} return\n        }\n    }\n    set vtokmod($v) [lindex $varctok($v) $a]\n    set varcmod($v) $a\n    if {$v == $curview} {\n        while {$a != 0 && [lindex $varcrow($v) $a] eq {}} {\n            set a [lindex $vupptr($v) $a]\n            set lim {}\n        }\n        set r 0\n        if {$a != 0} {\n            if {$lim eq {}} {\n                set lim [llength $varccommits($v,$a)]\n            }\n            set r [expr {[lindex $varcrow($v) $a] + $lim}]\n        }\n        set vrowmod($v) $r\n        undolayout $r\n    }\n}\n\nproc update_arcrows {v} {\n    global vtokmod varcmod vrowmod varcrow commitidx currentid selectedline\n    global varcid vrownum varcorder varcix varccommits\n    global vupptr vdownptr vleftptr varctok\n    global displayorder parentlist curview cached_commitrow\n\n    if {$vrowmod($v) == $commitidx($v)} return\n    if {$v == $curview} {\n        if {[llength $displayorder] > $vrowmod($v)} {\n            set displayorder [lrange $displayorder 0 [expr {$vrowmod($v) - 1}]]\n            set parentlist [lrange $parentlist 0 [expr {$vrowmod($v) - 1}]]\n        }\n        unset -nocomplain cached_commitrow\n    }\n    set narctot [expr {[llength $varctok($v)] - 1}]\n    set a $varcmod($v)\n    while {$a != 0 && [lindex $varcix($v) $a] eq {}} {\n        # go up the tree until we find something that has a row number,\n        # or we get to a seed\n        set a [lindex $vupptr($v) $a]\n    }\n    if {$a == 0} {\n        set a [lindex $vdownptr($v) 0]\n        if {$a == 0} return\n        set vrownum($v) {0}\n        set varcorder($v) [list $a]\n        lset varcix($v) $a 0\n        lset varcrow($v) $a 0\n        set arcn 0\n        set row 0\n    } else {\n        set arcn [lindex $varcix($v) $a]\n        if {[llength $vrownum($v)] > $arcn + 1} {\n            set vrownum($v) [lrange $vrownum($v) 0 $arcn]\n            set varcorder($v) [lrange $varcorder($v) 0 $arcn]\n        }\n        set row [lindex $varcrow($v) $a]\n    }\n    while {1} {\n        set p $a\n        incr row [llength $varccommits($v,$a)]\n        # go down if possible\n        set b [lindex $vdownptr($v) $a]\n        if {$b == 0} {\n            # if not, go left, or go up until we can go left\n            while {$a != 0} {\n                set b [lindex $vleftptr($v) $a]\n                if {$b != 0} break\n                set a [lindex $vupptr($v) $a]\n            }\n            if {$a == 0} break\n        }\n        set a $b\n        incr arcn\n        lappend vrownum($v) $row\n        lappend varcorder($v) $a\n        lset varcix($v) $a $arcn\n        lset varcrow($v) $a $row\n    }\n    set vtokmod($v) [lindex $varctok($v) $p]\n    set varcmod($v) $p\n    set vrowmod($v) $row\n    if {[info exists currentid]} {\n        set selectedline [rowofcommit $currentid]\n    }\n}\n\n# Test whether view $v contains commit $id\nproc commitinview {id v} {\n    global varcid\n\n    return [info exists varcid($v,$id)]\n}\n\n# Return the row number for commit $id in the current view\nproc rowofcommit {id} {\n    global varcid varccommits varcrow curview cached_commitrow\n    global varctok vtokmod\n\n    set v $curview\n    if {![info exists varcid($v,$id)]} {\n        puts \"oops rowofcommit no arc for [shortids $id]\"\n        return {}\n    }\n    set a $varcid($v,$id)\n    if {[string compare [lindex $varctok($v) $a] $vtokmod($v)] >= 0} {\n        update_arcrows $v\n    }\n    if {[info exists cached_commitrow($id)]} {\n        return $cached_commitrow($id)\n    }\n    set i [lsearch -exact $varccommits($v,$a) $id]\n    if {$i < 0} {\n        puts \"oops didn't find commit [shortids $id] in arc $a\"\n        return {}\n    }\n    incr i [lindex $varcrow($v) $a]\n    set cached_commitrow($id) $i\n    return $i\n}\n\n# Returns 1 if a is on an earlier row than b, otherwise 0\nproc comes_before {a b} {\n    global varcid varctok curview\n\n    set v $curview\n    if {$a eq $b || ![info exists varcid($v,$a)] || \\\n            ![info exists varcid($v,$b)]} {\n        return 0\n    }\n    if {$varcid($v,$a) != $varcid($v,$b)} {\n        return [expr {[string compare [lindex $varctok($v) $varcid($v,$a)] \\\n                           [lindex $varctok($v) $varcid($v,$b)]] < 0}]\n    }\n    return [expr {[rowofcommit $a] < [rowofcommit $b]}]\n}\n\nproc bsearch {l elt} {\n    if {[llength $l] == 0 || $elt <= [lindex $l 0]} {\n        return 0\n    }\n    set lo 0\n    set hi [llength $l]\n    while {$hi - $lo > 1} {\n        set mid [expr {int(($lo + $hi) / 2)}]\n        set t [lindex $l $mid]\n        if {$elt < $t} {\n            set hi $mid\n        } elseif {$elt > $t} {\n            set lo $mid\n        } else {\n            return $mid\n        }\n    }\n    return $lo\n}\n\n# Make sure rows $start..$end-1 are valid in displayorder and parentlist\nproc make_disporder {start end} {\n    global vrownum curview commitidx displayorder parentlist\n    global varccommits varcorder parents vrowmod varcrow\n    global d_valid_start d_valid_end\n\n    if {$end > $vrowmod($curview)} {\n        update_arcrows $curview\n    }\n    set ai [bsearch $vrownum($curview) $start]\n    set start [lindex $vrownum($curview) $ai]\n    set narc [llength $vrownum($curview)]\n    for {set r $start} {$ai < $narc && $r < $end} {incr ai} {\n        set a [lindex $varcorder($curview) $ai]\n        set l [llength $displayorder]\n        set al [llength $varccommits($curview,$a)]\n        if {$l < $r + $al} {\n            if {$l < $r} {\n                set pad [ntimes [expr {$r - $l}] {}]\n                set displayorder [concat $displayorder $pad]\n                set parentlist [concat $parentlist $pad]\n            } elseif {$l > $r} {\n                set displayorder [lrange $displayorder 0 [expr {$r - 1}]]\n                set parentlist [lrange $parentlist 0 [expr {$r - 1}]]\n            }\n            foreach id $varccommits($curview,$a) {\n                lappend displayorder $id\n                lappend parentlist $parents($curview,$id)\n            }\n        } elseif {[lindex $displayorder [expr {$r + $al - 1}]] eq {}} {\n            set i $r\n            foreach id $varccommits($curview,$a) {\n                lset displayorder $i $id\n                lset parentlist $i $parents($curview,$id)\n                incr i\n            }\n        }\n        incr r $al\n    }\n}\n\nproc commitonrow {row} {\n    global displayorder\n\n    set id [lindex $displayorder $row]\n    if {$id eq {}} {\n        make_disporder $row [expr {$row + 1}]\n        set id [lindex $displayorder $row]\n    }\n    return $id\n}\n\nproc closevarcs {v} {\n    global varctok varccommits varcid parents children\n    global cmitlisted commitidx vtokmod curview numcommits\n\n    set missing_parents 0\n    set scripts {}\n    set narcs [llength $varctok($v)]\n    for {set a 1} {$a < $narcs} {incr a} {\n        set id [lindex $varccommits($v,$a) end]\n        foreach p $parents($v,$id) {\n            if {[info exists varcid($v,$p)]} continue\n            # add p as a new commit\n            incr missing_parents\n            set cmitlisted($v,$p) 0\n            set parents($v,$p) {}\n            if {[llength $children($v,$p)] == 1 &&\n                [llength $parents($v,$id)] == 1} {\n                set b $a\n            } else {\n                set b [newvarc $v $p]\n            }\n            set varcid($v,$p) $b\n            if {[string compare [lindex $varctok($v) $b] $vtokmod($v)] < 0} {\n                modify_arc $v $b\n            }\n            lappend varccommits($v,$b) $p\n            incr commitidx($v)\n            if {$v == $curview} {\n                set numcommits $commitidx($v)\n            }\n            set scripts [check_interest $p $scripts]\n        }\n    }\n    if {$missing_parents > 0} {\n        foreach s $scripts {\n            eval $s\n        }\n    }\n}\n\n# Use $rwid as a substitute for $id, i.e. reparent $id's children to $rwid\n# Assumes we already have an arc for $rwid.\nproc rewrite_commit {v id rwid} {\n    global children parents varcid varctok vtokmod varccommits\n\n    foreach ch $children($v,$id) {\n        # make $rwid be $ch's parent in place of $id\n        set i [lsearch -exact $parents($v,$ch) $id]\n        if {$i < 0} {\n            puts \"oops rewrite_commit didn't find $id in parent list for $ch\"\n        }\n        set parents($v,$ch) [lreplace $parents($v,$ch) $i $i $rwid]\n        # add $ch to $rwid's children and sort the list if necessary\n        if {[llength [lappend children($v,$rwid) $ch]] > 1} {\n            set children($v,$rwid) [lsort -command [list vtokcmp $v] \\\n                                        $children($v,$rwid)]\n        }\n        # fix the graph after joining $id to $rwid\n        set a $varcid($v,$ch)\n        fix_reversal $rwid $a $v\n        # parentlist is wrong for the last element of arc $a\n        # even if displayorder is right, hence the 3rd arg here\n        modify_arc $v $a [expr {[llength $varccommits($v,$a)] - 1}]\n    }\n}\n\n# Mechanism for registering a command to be executed when we come\n# across a particular commit.  To handle the case when only the\n# prefix of the commit is known, the commitinterest array is now\n# indexed by the first 4 characters of the ID.  Each element is a\n# list of id, cmd pairs.\nproc interestedin {id cmd} {\n    global commitinterest\n\n    lappend commitinterest([string range $id 0 3]) $id $cmd\n}\n\nproc check_interest {id scripts} {\n    global commitinterest\n\n    set prefix [string range $id 0 3]\n    if {[info exists commitinterest($prefix)]} {\n        set newlist {}\n        foreach {i script} $commitinterest($prefix) {\n            if {[string match \"$i*\" $id]} {\n                lappend scripts [string map [list \"%I\" $id \"%P\" $i] $script]\n            } else {\n                lappend newlist $i $script\n            }\n        }\n        if {$newlist ne {}} {\n            set commitinterest($prefix) $newlist\n        } else {\n            unset commitinterest($prefix)\n        }\n    }\n    return $scripts\n}\n\nproc getcommitlines {fd inst view updating}  {\n    global cmitlisted leftover\n    global commitidx commitdata vdatemode\n    global parents children curview hlview\n    global idpending ordertok\n    global varccommits varcid varctok vtokmod vfilelimit vshortids\n\n    set stuff [read $fd 500000]\n    # git log doesn't terminate the last commit with a null...\n    if {$stuff == {} && $leftover($inst) ne {} && [eof $fd]} {\n        set stuff \"\\0\"\n    }\n    if {$stuff == {}} {\n        if {![eof $fd]} {\n            return 1\n        }\n        global commfd viewcomplete viewactive viewname\n        global viewinstances\n        unset commfd($inst)\n        set i [lsearch -exact $viewinstances($view) $inst]\n        if {$i >= 0} {\n            set viewinstances($view) [lreplace $viewinstances($view) $i $i]\n        }\n        # set it blocking so we wait for the process to terminate\n        fconfigure $fd -blocking 1\n        if {[catch {close $fd} err]} {\n            set fv {}\n            if {$view != $curview} {\n                set fv \" for the \\\"$viewname($view)\\\" view\"\n            }\n            if {[string range $err 0 4] == \"usage\"} {\n                set err \"Gitk: error reading commits$fv:\\\n                        bad arguments to git log.\"\n                if {$viewname($view) eq [mc \"Command line\"]} {\n                    append err \\\n                        \"  (Note: arguments to gitk are passed to git log\\\n                         to allow selection of commits to be displayed.)\"\n                }\n            } else {\n                set err \"Error reading commits$fv: $err\"\n            }\n            error_popup $err\n        }\n        if {[incr viewactive($view) -1] <= 0} {\n            set viewcomplete($view) 1\n            # Check if we have seen any ids listed as parents that haven't\n            # appeared in the list\n            closevarcs $view\n            notbusy $view\n        }\n        if {$view == $curview} {\n            run chewcommits\n        }\n        return 0\n    }\n    set start 0\n    set gotsome 0\n    set scripts {}\n    while 1 {\n        set i [string first \"\\0\" $stuff $start]\n        if {$i < 0} {\n            append leftover($inst) [string range $stuff $start end]\n            break\n        }\n        if {$start == 0} {\n            set cmit $leftover($inst)\n            append cmit [string range $stuff 0 [expr {$i - 1}]]\n            set leftover($inst) {}\n        } else {\n            set cmit [string range $stuff $start [expr {$i - 1}]]\n        }\n        set start [expr {$i + 1}]\n        set j [string first \"\\n\" $cmit]\n        set ok 0\n        set listed 1\n        if {$j >= 0 && [string match \"commit *\" $cmit]} {\n            set ids [string range $cmit 7 [expr {$j - 1}]]\n            if {[string match {[-^<>]*} $ids]} {\n                switch -- [string index $ids 0] {\n                    \"-\" {set listed 0}\n                    \"^\" {set listed 2}\n                    \"<\" {set listed 3}\n                    \">\" {set listed 4}\n                }\n                set ids [string range $ids 1 end]\n            }\n            set ok 1\n            foreach id $ids {\n                if {[string length $id] != 40} {\n                    set ok 0\n                    break\n                }\n            }\n        }\n        if {!$ok} {\n            set shortcmit $cmit\n            if {[string length $shortcmit] > 80} {\n                set shortcmit \"[string range $shortcmit 0 80]...\"\n            }\n            error_popup \"[mc \"Can't parse git log output:\"] {$shortcmit}\"\n            exit 1\n        }\n        set id [lindex $ids 0]\n        set vid $view,$id\n\n        lappend vshortids($view,[string range $id 0 3]) $id\n\n        if {!$listed && $updating && ![info exists varcid($vid)] &&\n            $vfilelimit($view) ne {}} {\n            # git log doesn't rewrite parents for unlisted commits\n            # when doing path limiting, so work around that here\n            # by working out the rewritten parent with git rev-list\n            # and if we already know about it, using the rewritten\n            # parent as a substitute parent for $id's children.\n            if {![catch {\n                set rwid [exec git rev-list --first-parent --max-count=1 \\\n                              $id -- $vfilelimit($view)]\n            }]} {\n                if {$rwid ne {} && [info exists varcid($view,$rwid)]} {\n                    # use $rwid in place of $id\n                    rewrite_commit $view $id $rwid\n                    continue\n                }\n            }\n        }\n\n        set a 0\n        if {[info exists varcid($vid)]} {\n            if {$cmitlisted($vid) || !$listed} continue\n            set a $varcid($vid)\n        }\n        if {$listed} {\n            set olds [lrange $ids 1 end]\n        } else {\n            set olds {}\n        }\n        set commitdata($id) [string range $cmit [expr {$j + 1}] end]\n        set cmitlisted($vid) $listed\n        set parents($vid) $olds\n        if {![info exists children($vid)]} {\n            set children($vid) {}\n        } elseif {$a == 0 && [llength $children($vid)] == 1} {\n            set k [lindex $children($vid) 0]\n            if {[llength $parents($view,$k)] == 1 &&\n                (!$vdatemode($view) ||\n                 $varcid($view,$k) == [llength $varctok($view)] - 1)} {\n                set a $varcid($view,$k)\n            }\n        }\n        if {$a == 0} {\n            # new arc\n            set a [newvarc $view $id]\n        }\n        if {[string compare [lindex $varctok($view) $a] $vtokmod($view)] < 0} {\n            modify_arc $view $a\n        }\n        if {![info exists varcid($vid)]} {\n            set varcid($vid) $a\n            lappend varccommits($view,$a) $id\n            incr commitidx($view)\n        }\n\n        set i 0\n        foreach p $olds {\n            if {$i == 0 || [lsearch -exact $olds $p] >= $i} {\n                set vp $view,$p\n                if {[llength [lappend children($vp) $id]] > 1 &&\n                    [vtokcmp $view [lindex $children($vp) end-1] $id] > 0} {\n                    set children($vp) [lsort -command [list vtokcmp $view] \\\n                                           $children($vp)]\n                    unset -nocomplain ordertok\n                }\n                if {[info exists varcid($view,$p)]} {\n                    fix_reversal $p $a $view\n                }\n            }\n            incr i\n        }\n\n        set scripts [check_interest $id $scripts]\n        set gotsome 1\n    }\n    if {$gotsome} {\n        global numcommits hlview\n\n        if {$view == $curview} {\n            set numcommits $commitidx($view)\n            run chewcommits\n        }\n        if {[info exists hlview] && $view == $hlview} {\n            # we never actually get here...\n            run vhighlightmore\n        }\n        foreach s $scripts {\n            eval $s\n        }\n    }\n    return 2\n}\n\nproc chewcommits {} {\n    global curview hlview viewcomplete\n    global pending_select\n\n    layoutmore\n    if {$viewcomplete($curview)} {\n        global commitidx varctok\n        global numcommits startmsecs\n\n        if {[info exists pending_select]} {\n            update\n            reset_pending_select {}\n\n            if {[commitinview $pending_select $curview]} {\n                selectline [rowofcommit $pending_select] 1\n            } else {\n                set row [first_real_row]\n                selectline $row 1\n            }\n        }\n        if {$commitidx($curview) > 0} {\n            #set ms [expr {[clock clicks -milliseconds] - $startmsecs}]\n            #puts \"overall $ms ms for $numcommits commits\"\n            #puts \"[llength $varctok($view)] arcs, $commitidx($view) commits\"\n        } else {\n            show_status [mc \"No commits selected\"]\n        }\n        notbusy layout\n    }\n    return 0\n}\n\nproc do_readcommit {id} {\n    global tclencoding\n\n    # Invoke git-log to handle automatic encoding conversion\n    set fd [open [concat | git log --no-color --pretty=raw -1 $id] r]\n    # Read the results using i18n.logoutputencoding\n    fconfigure $fd -translation lf -eofchar {}\n    if {$tclencoding != {}} {\n        fconfigure $fd -encoding $tclencoding\n    }\n    set contents [read $fd]\n    close $fd\n    # Remove the heading line\n    regsub {^commit [0-9a-f]+\\n} $contents {} contents\n\n    return $contents\n}\n\nproc readcommit {id} {\n    if {[catch {set contents [do_readcommit $id]}]} return\n    parsecommit $id $contents 1\n}\n\nproc parsecommit {id contents listed} {\n    global commitinfo\n\n    set inhdr 1\n    set comment {}\n    set headline {}\n    set auname {}\n    set audate {}\n    set comname {}\n    set comdate {}\n    set hdrend [string first \"\\n\\n\" $contents]\n    if {$hdrend < 0} {\n        # should never happen...\n        set hdrend [string length $contents]\n    }\n    set header [string range $contents 0 [expr {$hdrend - 1}]]\n    set comment [string range $contents [expr {$hdrend + 2}] end]\n    foreach line [split $header \"\\n\"] {\n        set line [split $line \" \"]\n        set tag [lindex $line 0]\n        if {$tag == \"author\"} {\n            set audate [lrange $line end-1 end]\n            set auname [join [lrange $line 1 end-2] \" \"]\n        } elseif {$tag == \"committer\"} {\n            set comdate [lrange $line end-1 end]\n            set comname [join [lrange $line 1 end-2] \" \"]\n        }\n    }\n    set headline {}\n    # take the first non-blank line of the comment as the headline\n    set headline [string trimleft $comment]\n    set i [string first \"\\n\" $headline]\n    if {$i >= 0} {\n        set headline [string range $headline 0 $i]\n    }\n    set headline [string trimright $headline]\n    set i [string first \"\\r\" $headline]\n    if {$i >= 0} {\n        set headline [string trimright [string range $headline 0 $i]]\n    }\n    if {!$listed} {\n        # git log indents the comment by 4 spaces;\n        # if we got this via git cat-file, add the indentation\n        set newcomment {}\n        foreach line [split $comment \"\\n\"] {\n            append newcomment \"    \"\n            append newcomment $line\n            append newcomment \"\\n\"\n        }\n        set comment $newcomment\n    }\n    set hasnote [string first \"\\nNotes:\\n\" $contents]\n    set diff \"\"\n    # If there is diff output shown in the git-log stream, split it\n    # out.  But get rid of the empty line that always precedes the\n    # diff.\n    set i [string first \"\\n\\ndiff\" $comment]\n    if {$i >= 0} {\n        set diff [string range $comment $i+1 end]\n        set comment [string range $comment 0 $i-1]\n    }\n    set commitinfo($id) [list $headline $auname $audate \\\n                             $comname $comdate $comment $hasnote $diff]\n}\n\nproc getcommit {id} {\n    global commitdata commitinfo\n\n    if {[info exists commitdata($id)]} {\n        parsecommit $id $commitdata($id) 1\n    } else {\n        readcommit $id\n        if {![info exists commitinfo($id)]} {\n            set commitinfo($id) [list [mc \"No commit information available\"]]\n        }\n    }\n    return 1\n}\n\n# Expand an abbreviated commit ID to a list of full 40-char IDs that match\n# and are present in the current view.\n# This is fairly slow...\nproc longid {prefix} {\n    global varcid curview vshortids\n\n    set ids {}\n    if {[string length $prefix] >= 4} {\n        set vshortid $curview,[string range $prefix 0 3]\n        if {[info exists vshortids($vshortid)]} {\n            foreach id $vshortids($vshortid) {\n                if {[string match \"$prefix*\" $id]} {\n                    if {[lsearch -exact $ids $id] < 0} {\n                        lappend ids $id\n                        if {[llength $ids] >= 2} break\n                    }\n                }\n            }\n        }\n    } else {\n        foreach match [array names varcid \"$curview,$prefix*\"] {\n            lappend ids [lindex [split $match \",\"] 1]\n            if {[llength $ids] >= 2} break\n        }\n    }\n    return $ids\n}\n\nproc readrefs {} {\n    global tagids idtags headids idheads tagobjid\n    global otherrefids idotherrefs mainhead mainheadid\n    global selecthead selectheadid\n    global hideremotes\n    global tclencoding\n\n    foreach v {tagids idtags headids idheads otherrefids idotherrefs} {\n        unset -nocomplain $v\n    }\n    set refd [open [list | git show-ref -d] r]\n    if {$tclencoding != {}} {\n        fconfigure $refd -encoding $tclencoding\n    }\n    while {[gets $refd line] >= 0} {\n        if {[string index $line 40] ne \" \"} continue\n        set id [string range $line 0 39]\n        set ref [string range $line 41 end]\n        if {![string match \"refs/*\" $ref]} continue\n        set name [string range $ref 5 end]\n        if {[string match \"remotes/*\" $name]} {\n            if {![string match \"*/HEAD\" $name] && !$hideremotes} {\n                set headids($name) $id\n                lappend idheads($id) $name\n            }\n        } elseif {[string match \"heads/*\" $name]} {\n            set name [string range $name 6 end]\n            set headids($name) $id\n            lappend idheads($id) $name\n        } elseif {[string match \"tags/*\" $name]} {\n            # this lets refs/tags/foo^{} overwrite refs/tags/foo,\n            # which is what we want since the former is the commit ID\n            set name [string range $name 5 end]\n            if {[string match \"*^{}\" $name]} {\n                set name [string range $name 0 end-3]\n            } else {\n                set tagobjid($name) $id\n            }\n            set tagids($name) $id\n            lappend idtags($id) $name\n        } else {\n            set otherrefids($name) $id\n            lappend idotherrefs($id) $name\n        }\n    }\n    catch {close $refd}\n    set mainhead {}\n    set mainheadid {}\n    catch {\n        set mainheadid [exec git rev-parse HEAD]\n        set thehead [exec git symbolic-ref HEAD]\n        if {[string match \"refs/heads/*\" $thehead]} {\n            set mainhead [string range $thehead 11 end]\n        }\n    }\n    set selectheadid {}\n    if {$selecthead ne {}} {\n        catch {\n            set selectheadid [exec git rev-parse --verify $selecthead]\n        }\n    }\n}\n\n# skip over fake commits\nproc first_real_row {} {\n    global nullid nullid2 numcommits\n\n    for {set row 0} {$row < $numcommits} {incr row} {\n        set id [commitonrow $row]\n        if {$id ne $nullid && $id ne $nullid2} {\n            break\n        }\n    }\n    return $row\n}\n\n# update things for a head moved to a child of its previous location\nproc movehead {id name} {\n    global headids idheads\n\n    removehead $headids($name) $name\n    set headids($name) $id\n    lappend idheads($id) $name\n}\n\n# update things when a head has been removed\nproc removehead {id name} {\n    global headids idheads\n\n    if {$idheads($id) eq $name} {\n        unset idheads($id)\n    } else {\n        set i [lsearch -exact $idheads($id) $name]\n        if {$i >= 0} {\n            set idheads($id) [lreplace $idheads($id) $i $i]\n        }\n    }\n    unset headids($name)\n}\n\nproc ttk_toplevel {w args} {\n    global use_ttk\n    eval [linsert $args 0 ::toplevel $w]\n    if {$use_ttk} {\n        place [ttk::frame $w._toplevel_background] -x 0 -y 0 -relwidth 1 -relheight 1\n    }\n    return $w\n}\n\nproc make_transient {window origin} {\n    global have_tk85\n\n    # In MacOS Tk 8.4 transient appears to work by setting\n    # overrideredirect, which is utterly useless, since the\n    # windows get no border, and are not even kept above\n    # the parent.\n    if {!$have_tk85 && [tk windowingsystem] eq {aqua}} return\n\n    wm transient $window $origin\n\n    # Windows fails to place transient windows normally, so\n    # schedule a callback to center them on the parent.\n    if {[tk windowingsystem] eq {win32}} {\n        after idle [list tk::PlaceWindow $window widget $origin]\n    }\n}\n\nproc show_error {w top msg} {\n    global NS\n    if {![info exists NS]} {set NS \"\"}\n    if {[wm state $top] eq \"withdrawn\"} { wm deiconify $top }\n    message $w.m -text $msg -justify center -aspect 400\n    pack $w.m -side top -fill x -padx 20 -pady 20\n    ${NS}::button $w.ok -default active -text [mc OK] -command \"destroy $top\"\n    pack $w.ok -side bottom -fill x\n    bind $top <Visibility> \"grab $top; focus $top\"\n    bind $top <Key-Return> \"destroy $top\"\n    bind $top <Key-space>  \"destroy $top\"\n    bind $top <Key-Escape> \"destroy $top\"\n    tkwait window $top\n}\n\nproc error_popup {msg {owner .}} {\n    if {[tk windowingsystem] eq \"win32\"} {\n        tk_messageBox -icon error -type ok -title [wm title .] \\\n            -parent $owner -message $msg\n    } else {\n        set w .error\n        ttk_toplevel $w\n        make_transient $w $owner\n        show_error $w $w $msg\n    }\n}\n\nproc confirm_popup {msg {owner .}} {\n    global confirm_ok NS\n    set confirm_ok 0\n    set w .confirm\n    ttk_toplevel $w\n    make_transient $w $owner\n    message $w.m -text $msg -justify center -aspect 400\n    pack $w.m -side top -fill x -padx 20 -pady 20\n    ${NS}::button $w.ok -text [mc OK] -command \"set confirm_ok 1; destroy $w\"\n    pack $w.ok -side left -fill x\n    ${NS}::button $w.cancel -text [mc Cancel] -command \"destroy $w\"\n    pack $w.cancel -side right -fill x\n    bind $w <Visibility> \"grab $w; focus $w\"\n    bind $w <Key-Return> \"set confirm_ok 1; destroy $w\"\n    bind $w <Key-space>  \"set confirm_ok 1; destroy $w\"\n    bind $w <Key-Escape> \"destroy $w\"\n    tk::PlaceWindow $w widget $owner\n    tkwait window $w\n    return $confirm_ok\n}\n\nproc setoptions {} {\n    global use_ttk\n\n    if {[tk windowingsystem] ne \"win32\"} {\n        option add *Panedwindow.showHandle 1 startupFile\n        option add *Panedwindow.sashRelief raised startupFile\n        if {[tk windowingsystem] ne \"aqua\"} {\n            option add *Menu.font uifont startupFile\n        }\n    } else {\n        option add *Menu.TearOff 0 startupFile\n    }\n    option add *Button.font uifont startupFile\n    option add *Checkbutton.font uifont startupFile\n    option add *Radiobutton.font uifont startupFile\n    option add *Menubutton.font uifont startupFile\n    option add *Label.font uifont startupFile\n    option add *Message.font uifont startupFile\n    option add *Entry.font textfont startupFile\n    option add *Text.font textfont startupFile\n    option add *Labelframe.font uifont startupFile\n    option add *Spinbox.font textfont startupFile\n    option add *Listbox.font mainfont startupFile\n}\n\nproc setttkstyle {} {\n    eval font configure TkDefaultFont [fontflags mainfont]\n    eval font configure TkTextFont [fontflags textfont]\n    eval font configure TkHeadingFont [fontflags mainfont]\n    eval font configure TkCaptionFont [fontflags mainfont] -weight bold\n    eval font configure TkTooltipFont [fontflags uifont]\n    eval font configure TkFixedFont   [fontflags textfont]\n    eval font configure TkIconFont    [fontflags uifont]\n    eval font configure TkMenuFont    [fontflags uifont]\n    eval font configure TkSmallCaptionFont [fontflags uifont]\n}\n\n# Make a menu and submenus.\n# m is the window name for the menu, items is the list of menu items to add.\n# Each item is a list {mc label type description options...}\n# mc is ignored; it's so we can put mc there to alert xgettext\n# label is the string that appears in the menu\n# type is cascade, command or radiobutton (should add checkbutton)\n# description depends on type; it's the sublist for cascade, the\n# command to invoke for command, or {variable value} for radiobutton\nproc makemenu {m items} {\n    menu $m\n    if {[tk windowingsystem] eq {aqua}} {\n        set Meta1 Cmd\n    } else {\n        set Meta1 Ctrl\n    }\n    foreach i $items {\n        set name [mc [lindex $i 1]]\n        set type [lindex $i 2]\n        set thing [lindex $i 3]\n        set params [list $type]\n        if {$name ne {}} {\n            set u [string first \"&\" [string map {&& x} $name]]\n            lappend params -label [string map {&& & & {}} $name]\n            if {$u >= 0} {\n                lappend params -underline $u\n            }\n        }\n        switch -- $type {\n            \"cascade\" {\n                set submenu [string tolower [string map {& \"\"} [lindex $i 1]]]\n                lappend params -menu $m.$submenu\n            }\n            \"command\" {\n                lappend params -command $thing\n            }\n            \"radiobutton\" {\n                lappend params -variable [lindex $thing 0] \\\n                    -value [lindex $thing 1]\n            }\n        }\n        set tail [lrange $i 4 end]\n        regsub -all {\\yMeta1\\y} $tail $Meta1 tail\n        eval $m add $params $tail\n        if {$type eq \"cascade\"} {\n            makemenu $m.$submenu $thing\n        }\n    }\n}\n\n# translate string and remove ampersands\nproc mca {str} {\n    return [string map {&& & & {}} [mc $str]]\n}\n\nproc cleardropsel {w} {\n    $w selection clear\n}\nproc makedroplist {w varname args} {\n    global use_ttk\n    if {$use_ttk} {\n        set width 0\n        foreach label $args {\n            set cx [string length $label]\n            if {$cx > $width} {set width $cx}\n        }\n        set gm [ttk::combobox $w -width $width -state readonly\\\n                    -textvariable $varname -values $args \\\n                    -exportselection false]\n        bind $gm <<ComboboxSelected>> [list $gm selection clear]\n    } else {\n        set gm [eval [linsert $args 0 tk_optionMenu $w $varname]]\n    }\n    return $gm\n}\n\nproc makewindow {} {\n    global canv canv2 canv3 linespc charspc ctext cflist cscroll\n    global tabstop\n    global findtype findtypemenu findloc findstring fstring geometry\n    global entries sha1entry sha1string sha1but\n    global diffcontextstring diffcontext\n    global ignorespace\n    global maincursor textcursor curtextcursor\n    global rowctxmenu fakerowmenu mergemax wrapcomment\n    global highlight_files gdttype\n    global searchstring sstring\n    global bgcolor fgcolor bglist fglist diffcolors diffbgcolors selectbgcolor\n    global uifgcolor uifgdisabledcolor\n    global filesepbgcolor filesepfgcolor\n    global mergecolors foundbgcolor currentsearchhitbgcolor\n    global headctxmenu progresscanv progressitem progresscoords statusw\n    global fprogitem fprogcoord lastprogupdate progupdatepending\n    global rprogitem rprogcoord rownumsel numcommits\n    global have_tk85 have_tk86 use_ttk NS\n    global git_version\n    global worddiff\n\n    # The \"mc\" arguments here are purely so that xgettext\n    # sees the following string as needing to be translated\n    set file {\n        mc \"&File\" cascade {\n            {mc \"&Update\" command updatecommits -accelerator F5}\n            {mc \"&Reload\" command reloadcommits -accelerator Shift-F5}\n            {mc \"Reread re&ferences\" command rereadrefs}\n            {mc \"&List references\" command showrefs -accelerator F2}\n            {xx \"\" separator}\n            {mc \"Start git &gui\" command {exec git gui &}}\n            {xx \"\" separator}\n            {mc \"&Quit\" command doquit -accelerator Meta1-Q}\n        }}\n    set edit {\n        mc \"&Edit\" cascade {\n            {mc \"&Preferences\" command doprefs}\n        }}\n    set view {\n        mc \"&View\" cascade {\n            {mc \"&New view...\" command {newview 0} -accelerator Shift-F4}\n            {mc \"&Edit view...\" command editview -state disabled -accelerator F4}\n            {mc \"&Delete view\" command delview -state disabled}\n            {xx \"\" separator}\n            {mc \"&All files\" radiobutton {selectedview 0} -command {showview 0}}\n        }}\n    if {[tk windowingsystem] ne \"aqua\"} {\n        set help {\n        mc \"&Help\" cascade {\n            {mc \"&About gitk\" command about}\n            {mc \"&Key bindings\" command keys}\n        }}\n        set bar [list $file $edit $view $help]\n    } else {\n        proc ::tk::mac::ShowPreferences {} {doprefs}\n        proc ::tk::mac::Quit {} {doquit}\n        lset file end [lreplace [lindex $file end] end-1 end]\n        set apple {\n        xx \"&Apple\" cascade {\n            {mc \"&About gitk\" command about}\n            {xx \"\" separator}\n        }}\n        set help {\n        mc \"&Help\" cascade {\n            {mc \"&Key bindings\" command keys}\n        }}\n        set bar [list $apple $file $view $help]\n    }\n    makemenu .bar $bar\n    . configure -menu .bar\n\n    if {$use_ttk} {\n        # cover the non-themed toplevel with a themed frame.\n        place [ttk::frame ._main_background] -x 0 -y 0 -relwidth 1 -relheight 1\n    }\n\n    # the gui has upper and lower half, parts of a paned window.\n    ${NS}::panedwindow .ctop -orient vertical\n\n    # possibly use assumed geometry\n    if {![info exists geometry(pwsash0)]} {\n        set geometry(topheight) [expr {15 * $linespc}]\n        set geometry(topwidth) [expr {80 * $charspc}]\n        set geometry(botheight) [expr {15 * $linespc}]\n        set geometry(botwidth) [expr {50 * $charspc}]\n        set geometry(pwsash0) [list [expr {40 * $charspc}] 2]\n        set geometry(pwsash1) [list [expr {60 * $charspc}] 2]\n    }\n\n    # the upper half will have a paned window, a scroll bar to the right, and some stuff below\n    ${NS}::frame .tf -height $geometry(topheight) -width $geometry(topwidth)\n    ${NS}::frame .tf.histframe\n    ${NS}::panedwindow .tf.histframe.pwclist -orient horizontal\n    if {!$use_ttk} {\n        .tf.histframe.pwclist configure -sashpad 0 -handlesize 4\n    }\n\n    # create three canvases\n    set cscroll .tf.histframe.csb\n    set canv .tf.histframe.pwclist.canv\n    canvas $canv \\\n        -selectbackground $selectbgcolor \\\n        -background $bgcolor -bd 0 \\\n        -yscrollincr $linespc -yscrollcommand \"scrollcanv $cscroll\"\n    .tf.histframe.pwclist add $canv\n    set canv2 .tf.histframe.pwclist.canv2\n    canvas $canv2 \\\n        -selectbackground $selectbgcolor \\\n        -background $bgcolor -bd 0 -yscrollincr $linespc\n    .tf.histframe.pwclist add $canv2\n    set canv3 .tf.histframe.pwclist.canv3\n    canvas $canv3 \\\n        -selectbackground $selectbgcolor \\\n        -background $bgcolor -bd 0 -yscrollincr $linespc\n    .tf.histframe.pwclist add $canv3\n    if {$use_ttk} {\n        bind .tf.histframe.pwclist <Map> {\n            bind %W <Map> {}\n            .tf.histframe.pwclist sashpos 1 [lindex $::geometry(pwsash1) 0]\n            .tf.histframe.pwclist sashpos 0 [lindex $::geometry(pwsash0) 0]\n        }\n    } else {\n        eval .tf.histframe.pwclist sash place 0 $geometry(pwsash0)\n        eval .tf.histframe.pwclist sash place 1 $geometry(pwsash1)\n    }\n\n    # a scroll bar to rule them\n    ${NS}::scrollbar $cscroll -command {allcanvs yview}\n    if {!$use_ttk} {$cscroll configure -highlightthickness 0}\n    pack $cscroll -side right -fill y\n    bind .tf.histframe.pwclist <Configure> {resizeclistpanes %W %w}\n    lappend bglist $canv $canv2 $canv3\n    pack .tf.histframe.pwclist -fill both -expand 1 -side left\n\n    # we have two button bars at bottom of top frame. Bar 1\n    ${NS}::frame .tf.bar\n    ${NS}::frame .tf.lbar -height 15\n\n    set sha1entry .tf.bar.sha1\n    set entries $sha1entry\n    set sha1but .tf.bar.sha1label\n    button $sha1but -text \"[mc \"SHA1 ID:\"] \" -state disabled -relief flat \\\n        -command gotocommit -width 8\n    $sha1but conf -disabledforeground [$sha1but cget -foreground]\n    pack .tf.bar.sha1label -side left\n    ${NS}::entry $sha1entry -width 40 -font textfont -textvariable sha1string\n    trace add variable sha1string write sha1change\n    pack $sha1entry -side left -pady 2\n\n    set bm_left_data {\n        #define left_width 16\n        #define left_height 16\n        static unsigned char left_bits[] = {\n        0x00, 0x00, 0xc0, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1c, 0x00,\n        0x0e, 0x00, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x0e, 0x00, 0x1c, 0x00,\n        0x38, 0x00, 0x70, 0x00, 0xe0, 0x00, 0xc0, 0x01};\n    }\n    set bm_right_data {\n        #define right_width 16\n        #define right_height 16\n        static unsigned char right_bits[] = {\n        0x00, 0x00, 0xc0, 0x01, 0x80, 0x03, 0x00, 0x07, 0x00, 0x0e, 0x00, 0x1c,\n        0x00, 0x38, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x00, 0x38, 0x00, 0x1c,\n        0x00, 0x0e, 0x00, 0x07, 0x80, 0x03, 0xc0, 0x01};\n    }\n    image create bitmap bm-left -data $bm_left_data -foreground $uifgcolor\n    image create bitmap bm-left-gray -data $bm_left_data -foreground $uifgdisabledcolor\n    image create bitmap bm-right -data $bm_right_data -foreground $uifgcolor\n    image create bitmap bm-right-gray -data $bm_right_data -foreground $uifgdisabledcolor\n\n    ${NS}::button .tf.bar.leftbut -command goback -state disabled -width 26\n    if {$use_ttk} {\n        .tf.bar.leftbut configure -image [list bm-left disabled bm-left-gray]\n    } else {\n        .tf.bar.leftbut configure -image bm-left\n    }\n    pack .tf.bar.leftbut -side left -fill y\n    ${NS}::button .tf.bar.rightbut -command goforw -state disabled -width 26\n    if {$use_ttk} {\n        .tf.bar.rightbut configure -image [list bm-right disabled bm-right-gray]\n    } else {\n        .tf.bar.rightbut configure -image bm-right\n    }\n    pack .tf.bar.rightbut -side left -fill y\n\n    ${NS}::label .tf.bar.rowlabel -text [mc \"Row\"]\n    set rownumsel {}\n    ${NS}::label .tf.bar.rownum -width 7 -textvariable rownumsel \\\n        -relief sunken -anchor e\n    ${NS}::label .tf.bar.rowlabel2 -text \"/\"\n    ${NS}::label .tf.bar.numcommits -width 7 -textvariable numcommits \\\n        -relief sunken -anchor e\n    pack .tf.bar.rowlabel .tf.bar.rownum .tf.bar.rowlabel2 .tf.bar.numcommits \\\n        -side left\n    if {!$use_ttk} {\n        foreach w {rownum numcommits} {.tf.bar.$w configure -font textfont}\n    }\n    global selectedline\n    trace add variable selectedline write selectedline_change\n\n    # Status label and progress bar\n    set statusw .tf.bar.status\n    ${NS}::label $statusw -width 15 -relief sunken\n    pack $statusw -side left -padx 5\n    if {$use_ttk} {\n        set progresscanv [ttk::progressbar .tf.bar.progress]\n    } else {\n        set h [expr {[font metrics uifont -linespace] + 2}]\n        set progresscanv .tf.bar.progress\n        canvas $progresscanv -relief sunken -height $h -borderwidth 2\n        set progressitem [$progresscanv create rect -1 0 0 $h -fill \"#00ff00\"]\n        set fprogitem [$progresscanv create rect -1 0 0 $h -fill yellow]\n        set rprogitem [$progresscanv create rect -1 0 0 $h -fill red]\n    }\n    pack $progresscanv -side right -expand 1 -fill x -padx {0 2}\n    set progresscoords {0 0}\n    set fprogcoord 0\n    set rprogcoord 0\n    bind $progresscanv <Configure> adjustprogress\n    set lastprogupdate [clock clicks -milliseconds]\n    set progupdatepending 0\n\n    # build up the bottom bar of upper window\n    ${NS}::label .tf.lbar.flabel -text \"[mc \"Find\"] \"\n\n    set bm_down_data {\n        #define down_width 16\n        #define down_height 16\n        static unsigned char down_bits[] = {\n        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01,\n        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01,\n        0x87, 0xe1, 0x8e, 0x71, 0x9c, 0x39, 0xb8, 0x1d,\n        0xf0, 0x0f, 0xe0, 0x07, 0xc0, 0x03, 0x80, 0x01};\n    }\n    image create bitmap bm-down -data $bm_down_data -foreground $uifgcolor\n    ${NS}::button .tf.lbar.fnext -width 26 -command {dofind 1 1}\n    .tf.lbar.fnext configure -image bm-down\n\n    set bm_up_data {\n        #define up_width 16\n        #define up_height 16\n        static unsigned char up_bits[] = {\n        0x80, 0x01, 0xc0, 0x03, 0xe0, 0x07, 0xf0, 0x0f,\n        0xb8, 0x1d, 0x9c, 0x39, 0x8e, 0x71, 0x87, 0xe1,\n        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01,\n        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01};\n    }\n    image create bitmap bm-up -data $bm_up_data -foreground $uifgcolor\n    ${NS}::button .tf.lbar.fprev -width 26 -command {dofind -1 1}\n    .tf.lbar.fprev configure -image bm-up\n\n    ${NS}::label .tf.lbar.flab2 -text \" [mc \"commit\"] \"\n\n    pack .tf.lbar.flabel .tf.lbar.fnext .tf.lbar.fprev .tf.lbar.flab2 \\\n        -side left -fill y\n    set gdttype [mc \"containing:\"]\n    set gm [makedroplist .tf.lbar.gdttype gdttype \\\n                [mc \"containing:\"] \\\n                [mc \"touching paths:\"] \\\n                [mc \"adding/removing string:\"] \\\n                [mc \"changing lines matching:\"]]\n    trace add variable gdttype write gdttype_change\n    pack .tf.lbar.gdttype -side left -fill y\n\n    set findstring {}\n    set fstring .tf.lbar.findstring\n    lappend entries $fstring\n    ${NS}::entry $fstring -width 30 -textvariable findstring\n    trace add variable findstring write find_change\n    set findtype [mc \"Exact\"]\n    set findtypemenu [makedroplist .tf.lbar.findtype \\\n                          findtype [mc \"Exact\"] [mc \"IgnCase\"] [mc \"Regexp\"]]\n    trace add variable findtype write findcom_change\n    set findloc [mc \"All fields\"]\n    makedroplist .tf.lbar.findloc findloc [mc \"All fields\"] [mc \"Headline\"] \\\n        [mc \"Comments\"] [mc \"Author\"] [mc \"Committer\"]\n    trace add variable findloc write find_change\n    pack .tf.lbar.findloc -side right\n    pack .tf.lbar.findtype -side right\n    pack $fstring -side left -expand 1 -fill x\n\n    # Finish putting the upper half of the viewer together\n    pack .tf.lbar -in .tf -side bottom -fill x\n    pack .tf.bar -in .tf -side bottom -fill x\n    pack .tf.histframe -fill both -side top -expand 1\n    .ctop add .tf\n    if {!$use_ttk} {\n        .ctop paneconfigure .tf -height $geometry(topheight)\n        .ctop paneconfigure .tf -width $geometry(topwidth)\n    }\n\n    # now build up the bottom\n    ${NS}::panedwindow .pwbottom -orient horizontal\n\n    # lower left, a text box over search bar, scroll bar to the right\n    # if we know window height, then that will set the lower text height, otherwise\n    # we set lower text height which will drive window height\n    if {[info exists geometry(main)]} {\n        ${NS}::frame .bleft -width $geometry(botwidth)\n    } else {\n        ${NS}::frame .bleft -width $geometry(botwidth) -height $geometry(botheight)\n    }\n    ${NS}::frame .bleft.top\n    ${NS}::frame .bleft.mid\n    ${NS}::frame .bleft.bottom\n\n    # gap between sub-widgets\n    set wgap [font measure uifont \"i\"]\n\n    ${NS}::button .bleft.top.search -text [mc \"Search\"] -command dosearch\n    pack .bleft.top.search -side left -padx 5\n    set sstring .bleft.top.sstring\n    set searchstring \"\"\n    ${NS}::entry $sstring -width 20 -textvariable searchstring\n    lappend entries $sstring\n    trace add variable searchstring write incrsearch\n    pack $sstring -side left -expand 1 -fill x\n    ${NS}::radiobutton .bleft.mid.diff -text [mc \"Diff\"] \\\n        -command changediffdisp -variable diffelide -value {0 0}\n    ${NS}::radiobutton .bleft.mid.old -text [mc \"Old version\"] \\\n        -command changediffdisp -variable diffelide -value {0 1}\n    ${NS}::radiobutton .bleft.mid.new -text [mc \"New version\"] \\\n        -command changediffdisp -variable diffelide -value {1 0}\n\n    ${NS}::label .bleft.mid.labeldiffcontext -text \"      [mc \"Lines of context\"]: \"\n    pack .bleft.mid.diff .bleft.mid.old .bleft.mid.new -side left -ipadx $wgap\n    spinbox .bleft.mid.diffcontext -width 5 \\\n        -from 0 -increment 1 -to 10000000 \\\n        -validate all -validatecommand \"diffcontextvalidate %P\" \\\n        -textvariable diffcontextstring\n    .bleft.mid.diffcontext set $diffcontext\n    trace add variable diffcontextstring write diffcontextchange\n    lappend entries .bleft.mid.diffcontext\n    pack .bleft.mid.labeldiffcontext .bleft.mid.diffcontext -side left -ipadx $wgap\n    ${NS}::checkbutton .bleft.mid.ignspace -text [mc \"Ignore space change\"] \\\n        -command changeignorespace -variable ignorespace\n    pack .bleft.mid.ignspace -side left -padx 5\n\n    set worddiff [mc \"Line diff\"]\n    if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n        makedroplist .bleft.mid.worddiff worddiff [mc \"Line diff\"] \\\n            [mc \"Markup words\"] [mc \"Color words\"]\n        trace add variable worddiff write changeworddiff\n        pack .bleft.mid.worddiff -side left -padx 5\n    }\n\n    set ctext .bleft.bottom.ctext\n    text $ctext -background $bgcolor -foreground $fgcolor \\\n        -state disabled -undo 0 -font textfont \\\n        -yscrollcommand scrolltext -wrap none \\\n        -xscrollcommand \".bleft.bottom.sbhorizontal set\"\n    if {$have_tk85} {\n        $ctext conf -tabstyle wordprocessor\n    }\n    ${NS}::scrollbar .bleft.bottom.sb -command \"$ctext yview\"\n    ${NS}::scrollbar .bleft.bottom.sbhorizontal -command \"$ctext xview\" -orient h\n    pack .bleft.top -side top -fill x\n    pack .bleft.mid -side top -fill x\n    grid $ctext .bleft.bottom.sb -sticky nsew\n    grid .bleft.bottom.sbhorizontal -sticky ew\n    grid columnconfigure .bleft.bottom 0 -weight 1\n    grid rowconfigure .bleft.bottom 0 -weight 1\n    grid rowconfigure .bleft.bottom 1 -weight 0\n    pack .bleft.bottom -side top -fill both -expand 1\n    lappend bglist $ctext\n    lappend fglist $ctext\n\n    $ctext tag conf comment -wrap $wrapcomment\n    $ctext tag conf filesep -font textfontbold -fore $filesepfgcolor -back $filesepbgcolor\n    $ctext tag conf hunksep -fore [lindex $diffcolors 2]\n    $ctext tag conf d0 -fore [lindex $diffcolors 0]\n    $ctext tag conf d0 -back [lindex $diffbgcolors 0]\n    $ctext tag conf dresult -fore [lindex $diffcolors 1]\n    $ctext tag conf dresult -back [lindex $diffbgcolors 1]\n    $ctext tag conf m0 -fore [lindex $mergecolors 0]\n    $ctext tag conf m1 -fore [lindex $mergecolors 1]\n    $ctext tag conf m2 -fore [lindex $mergecolors 2]\n    $ctext tag conf m3 -fore [lindex $mergecolors 3]\n    $ctext tag conf m4 -fore [lindex $mergecolors 4]\n    $ctext tag conf m5 -fore [lindex $mergecolors 5]\n    $ctext tag conf m6 -fore [lindex $mergecolors 6]\n    $ctext tag conf m7 -fore [lindex $mergecolors 7]\n    $ctext tag conf m8 -fore [lindex $mergecolors 8]\n    $ctext tag conf m9 -fore [lindex $mergecolors 9]\n    $ctext tag conf m10 -fore [lindex $mergecolors 10]\n    $ctext tag conf m11 -fore [lindex $mergecolors 11]\n    $ctext tag conf m12 -fore [lindex $mergecolors 12]\n    $ctext tag conf m13 -fore [lindex $mergecolors 13]\n    $ctext tag conf m14 -fore [lindex $mergecolors 14]\n    $ctext tag conf m15 -fore [lindex $mergecolors 15]\n    $ctext tag conf mmax -fore darkgrey\n    set mergemax 16\n    $ctext tag conf mresult -font textfontbold\n    $ctext tag conf msep -font textfontbold\n    $ctext tag conf found -back $foundbgcolor\n    $ctext tag conf currentsearchhit -back $currentsearchhitbgcolor\n    $ctext tag conf wwrap -wrap word -lmargin2 1c\n    $ctext tag conf bold -font textfontbold\n    # set these to the lowest priority:\n    $ctext tag lower currentsearchhit\n    $ctext tag lower found\n    $ctext tag lower filesep\n    $ctext tag lower dresult\n    $ctext tag lower d0\n\n    .pwbottom add .bleft\n    if {!$use_ttk} {\n        .pwbottom paneconfigure .bleft -width $geometry(botwidth)\n    }\n\n    # lower right\n    ${NS}::frame .bright\n    ${NS}::frame .bright.mode\n    ${NS}::radiobutton .bright.mode.patch -text [mc \"Patch\"] \\\n        -command reselectline -variable cmitmode -value \"patch\"\n    ${NS}::radiobutton .bright.mode.tree -text [mc \"Tree\"] \\\n        -command reselectline -variable cmitmode -value \"tree\"\n    grid .bright.mode.patch .bright.mode.tree -sticky ew\n    pack .bright.mode -side top -fill x\n    set cflist .bright.cfiles\n    set indent [font measure mainfont \"nn\"]\n    text $cflist \\\n        -selectbackground $selectbgcolor \\\n        -background $bgcolor -foreground $fgcolor \\\n        -font mainfont \\\n        -tabs [list $indent [expr {2 * $indent}]] \\\n        -yscrollcommand \".bright.sb set\" \\\n        -cursor [. cget -cursor] \\\n        -spacing1 1 -spacing3 1\n    lappend bglist $cflist\n    lappend fglist $cflist\n    ${NS}::scrollbar .bright.sb -command \"$cflist yview\"\n    pack .bright.sb -side right -fill y\n    pack $cflist -side left -fill both -expand 1\n    $cflist tag configure highlight \\\n        -background [$cflist cget -selectbackground]\n    $cflist tag configure bold -font mainfontbold\n\n    .pwbottom add .bright\n    .ctop add .pwbottom\n\n    # restore window width & height if known\n    if {[info exists geometry(main)]} {\n        if {[scan $geometry(main) \"%dx%d\" w h] >= 2} {\n            if {$w > [winfo screenwidth .]} {\n                set w [winfo screenwidth .]\n            }\n            if {$h > [winfo screenheight .]} {\n                set h [winfo screenheight .]\n            }\n            wm geometry . \"${w}x$h\"\n        }\n    }\n\n    if {[info exists geometry(state)] && $geometry(state) eq \"zoomed\"} {\n        wm state . $geometry(state)\n    }\n\n    if {[tk windowingsystem] eq {aqua}} {\n        set M1B M1\n        set ::BM \"3\"\n    } else {\n        set M1B Control\n        set ::BM \"2\"\n    }\n\n    if {$use_ttk} {\n        bind .ctop <Map> {\n            bind %W <Map> {}\n            %W sashpos 0 $::geometry(topheight)\n        }\n        bind .pwbottom <Map> {\n            bind %W <Map> {}\n            %W sashpos 0 $::geometry(botwidth)\n        }\n        bind .pwbottom <Configure> {resizecdetpanes %W %w}\n    }\n\n    pack .ctop -fill both -expand 1\n    bindall <1> {selcanvline %W %x %y}\n    #bindall <B1-Motion> {selcanvline %W %x %y}\n    if {[tk windowingsystem] == \"win32\"} {\n        bind . <MouseWheel> { windows_mousewheel_redirector %W %X %Y %D }\n        bind $ctext <MouseWheel> { windows_mousewheel_redirector %W %X %Y %D ; break }\n    } else {\n        bindall <ButtonRelease-4> \"allcanvs yview scroll -5 units\"\n        bindall <ButtonRelease-5> \"allcanvs yview scroll 5 units\"\n        bind $ctext <Button> {\n            if {\"%b\" eq 6} {\n                $ctext xview scroll -5 units\n            } elseif {\"%b\" eq 7} {\n                $ctext xview scroll 5 units\n            }\n        }\n        if {[tk windowingsystem] eq \"aqua\"} {\n            bindall <MouseWheel> {\n                set delta [expr {- (%D)}]\n                allcanvs yview scroll $delta units\n            }\n            bindall <Shift-MouseWheel> {\n                set delta [expr {- (%D)}]\n                $canv xview scroll $delta units\n            }\n        }\n    }\n    bindall <$::BM> \"canvscan mark %W %x %y\"\n    bindall <B$::BM-Motion> \"canvscan dragto %W %x %y\"\n    bind all <$M1B-Key-w> {destroy [winfo toplevel %W]}\n    bind . <$M1B-Key-w> doquit\n    bindkey <Home> selfirstline\n    bindkey <End> sellastline\n    bind . <Key-Up> \"selnextline -1\"\n    bind . <Key-Down> \"selnextline 1\"\n    bind . <Shift-Key-Up> \"dofind -1 0\"\n    bind . <Shift-Key-Down> \"dofind 1 0\"\n    if {$have_tk86} {\n        bindkey <<NextChar>> \"goforw\"\n        bindkey <<PrevChar>> \"goback\"\n    } else {\n        bindkey <Key-Right> \"goforw\"\n        bindkey <Key-Left> \"goback\"\n    }\n    bind . <Key-Prior> \"selnextpage -1\"\n    bind . <Key-Next> \"selnextpage 1\"\n    bind . <$M1B-Home> \"allcanvs yview moveto 0.0\"\n    bind . <$M1B-End> \"allcanvs yview moveto 1.0\"\n    bind . <$M1B-Key-Up> \"allcanvs yview scroll -1 units\"\n    bind . <$M1B-Key-Down> \"allcanvs yview scroll 1 units\"\n    bind . <$M1B-Key-Prior> \"allcanvs yview scroll -1 pages\"\n    bind . <$M1B-Key-Next> \"allcanvs yview scroll 1 pages\"\n    bindkey <Key-Delete> \"$ctext yview scroll -1 pages\"\n    bindkey <Key-BackSpace> \"$ctext yview scroll -1 pages\"\n    bindkey <Key-space> \"$ctext yview scroll 1 pages\"\n    bindkey p \"selnextline -1\"\n    bindkey n \"selnextline 1\"\n    bindkey z \"goback\"\n    bindkey x \"goforw\"\n    bindkey k \"selnextline -1\"\n    bindkey j \"selnextline 1\"\n    bindkey h \"goback\"\n    bindkey l \"goforw\"\n    bindkey b prevfile\n    bindkey d \"$ctext yview scroll 18 units\"\n    bindkey u \"$ctext yview scroll -18 units\"\n    bindkey g {$sha1entry delete 0 end; focus $sha1entry}\n    bindkey / {focus $fstring}\n    bindkey <Key-KP_Divide> {focus $fstring}\n    bindkey <Key-Return> {dofind 1 1}\n    bindkey ? {dofind -1 1}\n    bindkey f nextfile\n    bind . <F5> updatecommits\n    bindmodfunctionkey Shift 5 reloadcommits\n    bind . <F2> showrefs\n    bindmodfunctionkey Shift 4 {newview 0}\n    bind . <F4> edit_or_newview\n    bind . <$M1B-q> doquit\n    bind . <$M1B-f> {dofind 1 1}\n    bind . <$M1B-g> {dofind 1 0}\n    bind . <$M1B-r> dosearchback\n    bind . <$M1B-s> dosearch\n    bind . <$M1B-equal> {incrfont 1}\n    bind . <$M1B-plus> {incrfont 1}\n    bind . <$M1B-KP_Add> {incrfont 1}\n    bind . <$M1B-minus> {incrfont -1}\n    bind . <$M1B-KP_Subtract> {incrfont -1}\n    wm protocol . WM_DELETE_WINDOW doquit\n    bind . <Destroy> {stop_backends}\n    bind . <Button-1> \"click %W\"\n    bind $fstring <Key-Return> {dofind 1 1}\n    bind $sha1entry <Key-Return> {gotocommit; break}\n    bind $sha1entry <<PasteSelection>> clearsha1\n    bind $sha1entry <<Paste>> clearsha1\n    bind $cflist <1> {sel_flist %W %x %y; break}\n    bind $cflist <B1-Motion> {sel_flist %W %x %y; break}\n    bind $cflist <ButtonRelease-1> {treeclick %W %x %y}\n    global ctxbut\n    bind $cflist $ctxbut {pop_flist_menu %W %X %Y %x %y}\n    bind $ctext $ctxbut {pop_diff_menu %W %X %Y %x %y}\n    bind $ctext <Button-1> {focus %W}\n    bind $ctext <<Selection>> rehighlight_search_results\n    for {set i 1} {$i < 10} {incr i} {\n        bind . <$M1B-Key-$i> [list go_to_parent $i]\n    }\n\n    set maincursor [. cget -cursor]\n    set textcursor [$ctext cget -cursor]\n    set curtextcursor $textcursor\n\n    set rowctxmenu .rowctxmenu\n    makemenu $rowctxmenu {\n        {mc \"Diff this -> selected\" command {diffvssel 0}}\n        {mc \"Diff selected -> this\" command {diffvssel 1}}\n        {mc \"Make patch\" command mkpatch}\n        {mc \"Create tag\" command mktag}\n        {mc \"Copy commit reference\" command copyreference}\n        {mc \"Write commit to file\" command writecommit}\n        {mc \"Create new branch\" command mkbranch}\n        {mc \"Cherry-pick this commit\" command cherrypick}\n        {mc \"Reset HEAD branch to here\" command resethead}\n        {mc \"Mark this commit\" command markhere}\n        {mc \"Return to mark\" command gotomark}\n        {mc \"Find descendant of this and mark\" command find_common_desc}\n        {mc \"Compare with marked commit\" command compare_commits}\n        {mc \"Diff this -> marked commit\" command {diffvsmark 0}}\n        {mc \"Diff marked commit -> this\" command {diffvsmark 1}}\n        {mc \"Revert this commit\" command revert}\n    }\n    $rowctxmenu configure -tearoff 0\n\n    set fakerowmenu .fakerowmenu\n    makemenu $fakerowmenu {\n        {mc \"Diff this -> selected\" command {diffvssel 0}}\n        {mc \"Diff selected -> this\" command {diffvssel 1}}\n        {mc \"Make patch\" command mkpatch}\n        {mc \"Diff this -> marked commit\" command {diffvsmark 0}}\n        {mc \"Diff marked commit -> this\" command {diffvsmark 1}}\n    }\n    $fakerowmenu configure -tearoff 0\n\n    set headctxmenu .headctxmenu\n    makemenu $headctxmenu {\n        {mc \"Check out this branch\" command cobranch}\n        {mc \"Rename this branch\" command mvbranch}\n        {mc \"Remove this branch\" command rmbranch}\n        {mc \"Copy branch name\" command {clipboard clear; clipboard append $headmenuhead}}\n    }\n    $headctxmenu configure -tearoff 0\n\n    global flist_menu\n    set flist_menu .flistctxmenu\n    makemenu $flist_menu {\n        {mc \"Highlight this too\" command {flist_hl 0}}\n        {mc \"Highlight this only\" command {flist_hl 1}}\n        {mc \"External diff\" command {external_diff}}\n        {mc \"Blame parent commit\" command {external_blame 1}}\n        {mc \"Copy path\" command {clipboard clear; clipboard append $flist_menu_file}}\n    }\n    $flist_menu configure -tearoff 0\n\n    global diff_menu\n    set diff_menu .diffctxmenu\n    makemenu $diff_menu {\n        {mc \"Show origin of this line\" command show_line_source}\n        {mc \"Run git gui blame on this line\" command {external_blame_diff}}\n    }\n    $diff_menu configure -tearoff 0\n}\n\n# Windows sends all mouse wheel events to the current focused window, not\n# the one where the mouse hovers, so bind those events here and redirect\n# to the correct window\nproc windows_mousewheel_redirector {W X Y D} {\n    global canv canv2 canv3\n    set w [winfo containing -displayof $W $X $Y]\n    if {$w ne \"\"} {\n        set u [expr {$D < 0 ? 5 : -5}]\n        if {$w == $canv || $w == $canv2 || $w == $canv3} {\n            allcanvs yview scroll $u units\n        } else {\n            catch {\n                $w yview scroll $u units\n            }\n        }\n    }\n}\n\n# Update row number label when selectedline changes\nproc selectedline_change {n1 n2 op} {\n    global selectedline rownumsel\n\n    if {$selectedline eq {}} {\n        set rownumsel {}\n    } else {\n        set rownumsel [expr {$selectedline + 1}]\n    }\n}\n\n# mouse-2 makes all windows scan vertically, but only the one\n# the cursor is in scans horizontally\nproc canvscan {op w x y} {\n    global canv canv2 canv3\n    foreach c [list $canv $canv2 $canv3] {\n        if {$c == $w} {\n            $c scan $op $x $y\n        } else {\n            $c scan $op 0 $y\n        }\n    }\n}\n\nproc scrollcanv {cscroll f0 f1} {\n    $cscroll set $f0 $f1\n    drawvisible\n    flushhighlights\n}\n\n# when we make a key binding for the toplevel, make sure\n# it doesn't get triggered when that key is pressed in the\n# find string entry widget.\nproc bindkey {ev script} {\n    global entries\n    bind . $ev $script\n    set escript [bind Entry $ev]\n    if {$escript == {}} {\n        set escript [bind Entry <Key>]\n    }\n    foreach e $entries {\n        bind $e $ev \"$escript; break\"\n    }\n}\n\nproc bindmodfunctionkey {mod n script} {\n    bind . <$mod-F$n> $script\n    catch { bind . <$mod-XF86_Switch_VT_$n> $script }\n}\n\n# set the focus back to the toplevel for any click outside\n# the entry widgets\nproc click {w} {\n    global ctext entries\n    foreach e [concat $entries $ctext] {\n        if {$w == $e} return\n    }\n    focus .\n}\n\n# Adjust the progress bar for a change in requested extent or canvas size\nproc adjustprogress {} {\n    global progresscanv progressitem progresscoords\n    global fprogitem fprogcoord lastprogupdate progupdatepending\n    global rprogitem rprogcoord use_ttk\n\n    if {$use_ttk} {\n        $progresscanv configure -value [expr {int($fprogcoord * 100)}]\n        return\n    }\n\n    set w [expr {[winfo width $progresscanv] - 4}]\n    set x0 [expr {$w * [lindex $progresscoords 0]}]\n    set x1 [expr {$w * [lindex $progresscoords 1]}]\n    set h [winfo height $progresscanv]\n    $progresscanv coords $progressitem $x0 0 $x1 $h\n    $progresscanv coords $fprogitem 0 0 [expr {$w * $fprogcoord}] $h\n    $progresscanv coords $rprogitem 0 0 [expr {$w * $rprogcoord}] $h\n    set now [clock clicks -milliseconds]\n    if {$now >= $lastprogupdate + 100} {\n        set progupdatepending 0\n        update\n    } elseif {!$progupdatepending} {\n        set progupdatepending 1\n        after [expr {$lastprogupdate + 100 - $now}] doprogupdate\n    }\n}\n\nproc doprogupdate {} {\n    global lastprogupdate progupdatepending\n\n    if {$progupdatepending} {\n        set progupdatepending 0\n        set lastprogupdate [clock clicks -milliseconds]\n        update\n    }\n}\n\nproc config_check_tmp_exists {tries_left} {\n    global config_file_tmp\n\n    if {[file exists $config_file_tmp]} {\n        incr tries_left -1\n        if {$tries_left > 0} {\n            after 100 [list config_check_tmp_exists $tries_left]\n        } else {\n            error_popup \"There appears to be a stale $config_file_tmp\\\n file, which will prevent gitk from saving its configuration on exit.\\\n Please remove it if it is not being used by any existing gitk process.\"\n        }\n    }\n}\n\nproc config_init_trace {name} {\n    global config_variable_changed config_variable_original\n\n    upvar #0 $name var\n    set config_variable_changed($name) 0\n    set config_variable_original($name) $var\n}\n\nproc config_variable_change_cb {name name2 op} {\n    global config_variable_changed config_variable_original\n\n    upvar #0 $name var\n    if {$op eq \"write\" &&\n        (![info exists config_variable_original($name)] ||\n         $config_variable_original($name) ne $var)} {\n        set config_variable_changed($name) 1\n    }\n}\n\nproc savestuff {w} {\n    global stuffsaved\n    global config_file config_file_tmp\n    global config_variables config_variable_changed\n    global viewchanged\n\n    upvar #0 viewname current_viewname\n    upvar #0 viewfiles current_viewfiles\n    upvar #0 viewargs current_viewargs\n    upvar #0 viewargscmd current_viewargscmd\n    upvar #0 viewperm current_viewperm\n    upvar #0 nextviewnum current_nextviewnum\n    upvar #0 use_ttk current_use_ttk\n\n    if {$stuffsaved} return\n    if {![winfo viewable .]} return\n    set remove_tmp 0\n    if {[catch {\n        set try_count 0\n        while {[catch {set f [open $config_file_tmp {WRONLY CREAT EXCL}]}]} {\n            if {[incr try_count] > 50} {\n                error \"Unable to write config file: $config_file_tmp exists\"\n            }\n            after 100\n        }\n        set remove_tmp 1\n        if {$::tcl_platform(platform) eq {windows}} {\n            file attributes $config_file_tmp -hidden true\n        }\n        if {[file exists $config_file]} {\n            source $config_file\n        }\n        foreach var_name $config_variables {\n            upvar #0 $var_name var\n            upvar 0 $var_name old_var\n            if {!$config_variable_changed($var_name) && [info exists old_var]} {\n                puts $f [list set $var_name $old_var]\n            } else {\n                puts $f [list set $var_name $var]\n            }\n        }\n\n        puts $f \"set geometry(main) [wm geometry .]\"\n        puts $f \"set geometry(state) [wm state .]\"\n        puts $f \"set geometry(topwidth) [winfo width .tf]\"\n        puts $f \"set geometry(topheight) [winfo height .tf]\"\n        if {$current_use_ttk} {\n            puts $f \"set geometry(pwsash0) \\\"[.tf.histframe.pwclist sashpos 0] 1\\\"\"\n            puts $f \"set geometry(pwsash1) \\\"[.tf.histframe.pwclist sashpos 1] 1\\\"\"\n        } else {\n            puts $f \"set geometry(pwsash0) \\\"[.tf.histframe.pwclist sash coord 0]\\\"\"\n            puts $f \"set geometry(pwsash1) \\\"[.tf.histframe.pwclist sash coord 1]\\\"\"\n        }\n        puts $f \"set geometry(botwidth) [winfo width .bleft]\"\n        puts $f \"set geometry(botheight) [winfo height .bleft]\"\n\n        array set view_save {}\n        array set views {}\n        if {![info exists permviews]} { set permviews {} }\n        foreach view $permviews {\n            set view_save([lindex $view 0]) 1\n            set views([lindex $view 0]) $view\n        }\n        puts -nonewline $f \"set permviews {\"\n        for {set v 1} {$v < $current_nextviewnum} {incr v} {\n            if {$viewchanged($v)} {\n                if {$current_viewperm($v)} {\n                    set views($current_viewname($v)) [list $current_viewname($v) $current_viewfiles($v) $current_viewargs($v) $current_viewargscmd($v)]\n                } else {\n                    set view_save($current_viewname($v)) 0\n                }\n            }\n        }\n        # write old and updated view to their places and append remaining to the end\n        foreach view $permviews {\n            set view_name [lindex $view 0]\n            if {$view_save($view_name)} {\n                puts $f \"{$views($view_name)}\"\n            }\n            unset views($view_name)\n        }\n        foreach view_name [array names views] {\n            puts $f \"{$views($view_name)}\"\n        }\n        puts $f \"}\"\n        close $f\n        file rename -force $config_file_tmp $config_file\n        set remove_tmp 0\n    } err]} {\n        puts \"Error saving config: $err\"\n    }\n    if {$remove_tmp} {\n        file delete -force $config_file_tmp\n    }\n    set stuffsaved 1\n}\n\nproc resizeclistpanes {win w} {\n    global oldwidth oldsash use_ttk\n    if {[info exists oldwidth($win)]} {\n        if {[info exists oldsash($win)]} {\n            set s0 [lindex $oldsash($win) 0]\n            set s1 [lindex $oldsash($win) 1]\n        } elseif {$use_ttk} {\n            set s0 [$win sashpos 0]\n            set s1 [$win sashpos 1]\n        } else {\n            set s0 [$win sash coord 0]\n            set s1 [$win sash coord 1]\n        }\n        if {$w < 60} {\n            set sash0 [expr {int($w/2 - 2)}]\n            set sash1 [expr {int($w*5/6 - 2)}]\n        } else {\n            set factor [expr {1.0 * $w / $oldwidth($win)}]\n            set sash0 [expr {int($factor * [lindex $s0 0])}]\n            set sash1 [expr {int($factor * [lindex $s1 0])}]\n            if {$sash0 < 30} {\n                set sash0 30\n            }\n            if {$sash1 < $sash0 + 20} {\n                set sash1 [expr {$sash0 + 20}]\n            }\n            if {$sash1 > $w - 10} {\n                set sash1 [expr {$w - 10}]\n                if {$sash0 > $sash1 - 20} {\n                    set sash0 [expr {$sash1 - 20}]\n                }\n            }\n        }\n        if {$use_ttk} {\n            $win sashpos 0 $sash0\n            $win sashpos 1 $sash1\n        } else {\n            $win sash place 0 $sash0 [lindex $s0 1]\n            $win sash place 1 $sash1 [lindex $s1 1]\n            set sash0 [list $sash0 [lindex $s0 1]]\n            set sash1 [list $sash1 [lindex $s1 1]]\n        }\n        set oldsash($win) [list $sash0 $sash1]\n    }\n    set oldwidth($win) $w\n}\n\nproc resizecdetpanes {win w} {\n    global oldwidth oldsash use_ttk\n    if {[info exists oldwidth($win)]} {\n        if {[info exists oldsash($win)]} {\n            set s0 $oldsash($win)\n        } elseif {$use_ttk} {\n            set s0 [$win sashpos 0]\n        } else {\n            set s0 [$win sash coord 0]\n        }\n        if {$w < 60} {\n            set sash0 [expr {int($w*3/4 - 2)}]\n        } else {\n            set factor [expr {1.0 * $w / $oldwidth($win)}]\n            set sash0 [expr {int($factor * [lindex $s0 0])}]\n            if {$sash0 < 45} {\n                set sash0 45\n            }\n            if {$sash0 > $w - 15} {\n                set sash0 [expr {$w - 15}]\n            }\n        }\n        if {$use_ttk} {\n            $win sashpos 0 $sash0\n        } else {\n            $win sash place 0 $sash0 [lindex $s0 1]\n            set sash0 [list $sash0 [lindex $s0 1]]\n        }\n        set oldsash($win) $sash0\n    }\n    set oldwidth($win) $w\n}\n\nproc allcanvs args {\n    global canv canv2 canv3\n    eval $canv $args\n    eval $canv2 $args\n    eval $canv3 $args\n}\n\nproc bindall {event action} {\n    global canv canv2 canv3\n    bind $canv $event $action\n    bind $canv2 $event $action\n    bind $canv3 $event $action\n}\n\nproc about {} {\n    global bgcolor NS\n    set w .about\n    if {[winfo exists $w]} {\n        raise $w\n        return\n    }\n    ttk_toplevel $w\n    wm title $w [mc \"About gitk\"]\n    make_transient $w .\n    message $w.m -text [mc \"\nGitk - a commit viewer for git\n\nCopyright \\u00a9 2005-2016 Paul Mackerras\n\nUse and redistribute under the terms of the GNU General Public License\"] \\\n            -justify center -aspect 400 -border 2 -bg $bgcolor -relief groove\n    pack $w.m -side top -fill x -padx 2 -pady 2\n    ${NS}::button $w.ok -text [mc \"Close\"] -command \"destroy $w\" -default active\n    pack $w.ok -side bottom\n    bind $w <Visibility> \"focus $w.ok\"\n    bind $w <Key-Escape> \"destroy $w\"\n    bind $w <Key-Return> \"destroy $w\"\n    tk::PlaceWindow $w widget .\n}\n\nproc keys {} {\n    global bgcolor NS\n    set w .keys\n    if {[winfo exists $w]} {\n        raise $w\n        return\n    }\n    if {[tk windowingsystem] eq {aqua}} {\n        set M1T Cmd\n    } else {\n        set M1T Ctrl\n    }\n    ttk_toplevel $w\n    wm title $w [mc \"Gitk key bindings\"]\n    make_transient $w .\n    message $w.m -text \"\n[mc \"Gitk key bindings:\"]\n\n[mc \"<%s-Q>\t\tQuit\" $M1T]\n[mc \"<%s-W>\t\tClose window\" $M1T]\n[mc \"<Home>\t\tMove to first commit\"]\n[mc \"<End>\t\tMove to last commit\"]\n[mc \"<Up>, p, k\tMove up one commit\"]\n[mc \"<Down>, n, j\tMove down one commit\"]\n[mc \"<Left>, z, h\tGo back in history list\"]\n[mc \"<Right>, x, l\tGo forward in history list\"]\n[mc \"<%s-n>\tGo to n-th parent of current commit in history list\" $M1T]\n[mc \"<PageUp>\tMove up one page in commit list\"]\n[mc \"<PageDown>\tMove down one page in commit list\"]\n[mc \"<%s-Home>\tScroll to top of commit list\" $M1T]\n[mc \"<%s-End>\tScroll to bottom of commit list\" $M1T]\n[mc \"<%s-Up>\tScroll commit list up one line\" $M1T]\n[mc \"<%s-Down>\tScroll commit list down one line\" $M1T]\n[mc \"<%s-PageUp>\tScroll commit list up one page\" $M1T]\n[mc \"<%s-PageDown>\tScroll commit list down one page\" $M1T]\n[mc \"<Shift-Up>\tFind backwards (upwards, later commits)\"]\n[mc \"<Shift-Down>\tFind forwards (downwards, earlier commits)\"]\n[mc \"<Delete>, b\tScroll diff view up one page\"]\n[mc \"<Backspace>\tScroll diff view up one page\"]\n[mc \"<Space>\t\tScroll diff view down one page\"]\n[mc \"u\t\tScroll diff view up 18 lines\"]\n[mc \"d\t\tScroll diff view down 18 lines\"]\n[mc \"<%s-F>\t\tFind\" $M1T]\n[mc \"<%s-G>\t\tMove to next find hit\" $M1T]\n[mc \"<Return>\tMove to next find hit\"]\n[mc \"g\t\tGo to commit\"]\n[mc \"/\t\tFocus the search box\"]\n[mc \"?\t\tMove to previous find hit\"]\n[mc \"f\t\tScroll diff view to next file\"]\n[mc \"<%s-S>\t\tSearch for next hit in diff view\" $M1T]\n[mc \"<%s-R>\t\tSearch for previous hit in diff view\" $M1T]\n[mc \"<%s-KP+>\tIncrease font size\" $M1T]\n[mc \"<%s-plus>\tIncrease font size\" $M1T]\n[mc \"<%s-KP->\tDecrease font size\" $M1T]\n[mc \"<%s-minus>\tDecrease font size\" $M1T]\n[mc \"<F5>\t\tUpdate\"]\n\" \\\n            -justify left -bg $bgcolor -border 2 -relief groove\n    pack $w.m -side top -fill both -padx 2 -pady 2\n    ${NS}::button $w.ok -text [mc \"Close\"] -command \"destroy $w\" -default active\n    bind $w <Key-Escape> [list destroy $w]\n    pack $w.ok -side bottom\n    bind $w <Visibility> \"focus $w.ok\"\n    bind $w <Key-Escape> \"destroy $w\"\n    bind $w <Key-Return> \"destroy $w\"\n}\n\n# Procedures for manipulating the file list window at the\n# bottom right of the overall window.\n\nproc treeview {w l openlevs} {\n    global treecontents treediropen treeheight treeparent treeindex\n\n    set ix 0\n    set treeindex() 0\n    set lev 0\n    set prefix {}\n    set prefixend -1\n    set prefendstack {}\n    set htstack {}\n    set ht 0\n    set treecontents() {}\n    $w conf -state normal\n    foreach f $l {\n        while {[string range $f 0 $prefixend] ne $prefix} {\n            if {$lev <= $openlevs} {\n                $w mark set e:$treeindex($prefix) \"end -1c\"\n                $w mark gravity e:$treeindex($prefix) left\n            }\n            set treeheight($prefix) $ht\n            incr ht [lindex $htstack end]\n            set htstack [lreplace $htstack end end]\n            set prefixend [lindex $prefendstack end]\n            set prefendstack [lreplace $prefendstack end end]\n            set prefix [string range $prefix 0 $prefixend]\n            incr lev -1\n        }\n        set tail [string range $f [expr {$prefixend+1}] end]\n        while {[set slash [string first \"/\" $tail]] >= 0} {\n            lappend htstack $ht\n            set ht 0\n            lappend prefendstack $prefixend\n            incr prefixend [expr {$slash + 1}]\n            set d [string range $tail 0 $slash]\n            lappend treecontents($prefix) $d\n            set oldprefix $prefix\n            append prefix $d\n            set treecontents($prefix) {}\n            set treeindex($prefix) [incr ix]\n            set treeparent($prefix) $oldprefix\n            set tail [string range $tail [expr {$slash+1}] end]\n            if {$lev <= $openlevs} {\n                set ht 1\n                set treediropen($prefix) [expr {$lev < $openlevs}]\n                set bm [expr {$lev == $openlevs? \"tri-rt\": \"tri-dn\"}]\n                $w mark set d:$ix \"end -1c\"\n                $w mark gravity d:$ix left\n                set str \"\\n\"\n                for {set i 0} {$i < $lev} {incr i} {append str \"\\t\"}\n                $w insert end $str\n                $w image create end -align center -image $bm -padx 1 \\\n                    -name a:$ix\n                $w insert end $d [highlight_tag $prefix]\n                $w mark set s:$ix \"end -1c\"\n                $w mark gravity s:$ix left\n            }\n            incr lev\n        }\n        if {$tail ne {}} {\n            if {$lev <= $openlevs} {\n                incr ht\n                set str \"\\n\"\n                for {set i 0} {$i < $lev} {incr i} {append str \"\\t\"}\n                $w insert end $str\n                $w insert end $tail [highlight_tag $f]\n            }\n            lappend treecontents($prefix) $tail\n        }\n    }\n    while {$htstack ne {}} {\n        set treeheight($prefix) $ht\n        incr ht [lindex $htstack end]\n        set htstack [lreplace $htstack end end]\n        set prefixend [lindex $prefendstack end]\n        set prefendstack [lreplace $prefendstack end end]\n        set prefix [string range $prefix 0 $prefixend]\n    }\n    $w conf -state disabled\n}\n\nproc linetoelt {l} {\n    global treeheight treecontents\n\n    set y 2\n    set prefix {}\n    while {1} {\n        foreach e $treecontents($prefix) {\n            if {$y == $l} {\n                return \"$prefix$e\"\n            }\n            set n 1\n            if {[string index $e end] eq \"/\"} {\n                set n $treeheight($prefix$e)\n                if {$y + $n > $l} {\n                    append prefix $e\n                    incr y\n                    break\n                }\n            }\n            incr y $n\n        }\n    }\n}\n\nproc highlight_tree {y prefix} {\n    global treeheight treecontents cflist\n\n    foreach e $treecontents($prefix) {\n        set path $prefix$e\n        if {[highlight_tag $path] ne {}} {\n            $cflist tag add bold $y.0 \"$y.0 lineend\"\n        }\n        incr y\n        if {[string index $e end] eq \"/\" && $treeheight($path) > 1} {\n            set y [highlight_tree $y $path]\n        }\n    }\n    return $y\n}\n\nproc treeclosedir {w dir} {\n    global treediropen treeheight treeparent treeindex\n\n    set ix $treeindex($dir)\n    $w conf -state normal\n    $w delete s:$ix e:$ix\n    set treediropen($dir) 0\n    $w image configure a:$ix -image tri-rt\n    $w conf -state disabled\n    set n [expr {1 - $treeheight($dir)}]\n    while {$dir ne {}} {\n        incr treeheight($dir) $n\n        set dir $treeparent($dir)\n    }\n}\n\nproc treeopendir {w dir} {\n    global treediropen treeheight treeparent treecontents treeindex\n\n    set ix $treeindex($dir)\n    $w conf -state normal\n    $w image configure a:$ix -image tri-dn\n    $w mark set e:$ix s:$ix\n    $w mark gravity e:$ix right\n    set lev 0\n    set str \"\\n\"\n    set n [llength $treecontents($dir)]\n    for {set x $dir} {$x ne {}} {set x $treeparent($x)} {\n        incr lev\n        append str \"\\t\"\n        incr treeheight($x) $n\n    }\n    foreach e $treecontents($dir) {\n        set de $dir$e\n        if {[string index $e end] eq \"/\"} {\n            set iy $treeindex($de)\n            $w mark set d:$iy e:$ix\n            $w mark gravity d:$iy left\n            $w insert e:$ix $str\n            set treediropen($de) 0\n            $w image create e:$ix -align center -image tri-rt -padx 1 \\\n                -name a:$iy\n            $w insert e:$ix $e [highlight_tag $de]\n            $w mark set s:$iy e:$ix\n            $w mark gravity s:$iy left\n            set treeheight($de) 1\n        } else {\n            $w insert e:$ix $str\n            $w insert e:$ix $e [highlight_tag $de]\n        }\n    }\n    $w mark gravity e:$ix right\n    $w conf -state disabled\n    set treediropen($dir) 1\n    set top [lindex [split [$w index @0,0] .] 0]\n    set ht [$w cget -height]\n    set l [lindex [split [$w index s:$ix] .] 0]\n    if {$l < $top} {\n        $w yview $l.0\n    } elseif {$l + $n + 1 > $top + $ht} {\n        set top [expr {$l + $n + 2 - $ht}]\n        if {$l < $top} {\n            set top $l\n        }\n        $w yview $top.0\n    }\n}\n\nproc treeclick {w x y} {\n    global treediropen cmitmode ctext cflist cflist_top\n\n    if {$cmitmode ne \"tree\"} return\n    if {![info exists cflist_top]} return\n    set l [lindex [split [$w index \"@$x,$y\"] \".\"] 0]\n    $cflist tag remove highlight $cflist_top.0 \"$cflist_top.0 lineend\"\n    $cflist tag add highlight $l.0 \"$l.0 lineend\"\n    set cflist_top $l\n    if {$l == 1} {\n        $ctext yview 1.0\n        return\n    }\n    set e [linetoelt $l]\n    if {[string index $e end] ne \"/\"} {\n        showfile $e\n    } elseif {$treediropen($e)} {\n        treeclosedir $w $e\n    } else {\n        treeopendir $w $e\n    }\n}\n\nproc setfilelist {id} {\n    global treefilelist cflist jump_to_here\n\n    treeview $cflist $treefilelist($id) 0\n    if {$jump_to_here ne {}} {\n        set f [lindex $jump_to_here 0]\n        if {[lsearch -exact $treefilelist($id) $f] >= 0} {\n            showfile $f\n        }\n    }\n}\n\nimage create bitmap tri-rt -background black -foreground blue -data {\n    #define tri-rt_width 13\n    #define tri-rt_height 13\n    static unsigned char tri-rt_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x30, 0x00, 0x70, 0x00, 0xf0, 0x00,\n       0xf0, 0x01, 0xf0, 0x00, 0x70, 0x00, 0x30, 0x00, 0x10, 0x00, 0x00, 0x00,\n       0x00, 0x00};\n} -maskdata {\n    #define tri-rt-mask_width 13\n    #define tri-rt-mask_height 13\n    static unsigned char tri-rt-mask_bits[] = {\n       0x08, 0x00, 0x18, 0x00, 0x38, 0x00, 0x78, 0x00, 0xf8, 0x00, 0xf8, 0x01,\n       0xf8, 0x03, 0xf8, 0x01, 0xf8, 0x00, 0x78, 0x00, 0x38, 0x00, 0x18, 0x00,\n       0x08, 0x00};\n}\nimage create bitmap tri-dn -background black -foreground blue -data {\n    #define tri-dn_width 13\n    #define tri-dn_height 13\n    static unsigned char tri-dn_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x07, 0xf8, 0x03,\n       0xf0, 0x01, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00};\n} -maskdata {\n    #define tri-dn-mask_width 13\n    #define tri-dn-mask_height 13\n    static unsigned char tri-dn-mask_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xfe, 0x0f, 0xfc, 0x07,\n       0xf8, 0x03, 0xf0, 0x01, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00};\n}\n\nimage create bitmap reficon-T -background black -foreground yellow -data {\n    #define tagicon_width 13\n    #define tagicon_height 9\n    static unsigned char tagicon_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0xf8, 0x07,\n       0xfc, 0x07, 0xf8, 0x07, 0xf0, 0x07, 0x00, 0x00, 0x00, 0x00};\n} -maskdata {\n    #define tagicon-mask_width 13\n    #define tagicon-mask_height 9\n    static unsigned char tagicon-mask_bits[] = {\n       0x00, 0x00, 0xf0, 0x0f, 0xf8, 0x0f, 0xfc, 0x0f,\n       0xfe, 0x0f, 0xfc, 0x0f, 0xf8, 0x0f, 0xf0, 0x0f, 0x00, 0x00};\n}\nset rectdata {\n    #define headicon_width 13\n    #define headicon_height 9\n    static unsigned char headicon_bits[] = {\n       0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0xf8, 0x07,\n       0xf8, 0x07, 0xf8, 0x07, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00};\n}\nset rectmask {\n    #define headicon-mask_width 13\n    #define headicon-mask_height 9\n    static unsigned char headicon-mask_bits[] = {\n       0x00, 0x00, 0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f,\n       0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f, 0x00, 0x00};\n}\nimage create bitmap reficon-H -background black -foreground \"#00ff00\" \\\n    -data $rectdata -maskdata $rectmask\nimage create bitmap reficon-R -background black -foreground \"#ffddaa\" \\\n    -data $rectdata -maskdata $rectmask\nimage create bitmap reficon-o -background black -foreground \"#ddddff\" \\\n    -data $rectdata -maskdata $rectmask\n\nproc init_flist {first} {\n    global cflist cflist_top difffilestart\n\n    $cflist conf -state normal\n    $cflist delete 0.0 end\n    if {$first ne {}} {\n        $cflist insert end $first\n        set cflist_top 1\n        $cflist tag add highlight 1.0 \"1.0 lineend\"\n    } else {\n        unset -nocomplain cflist_top\n    }\n    $cflist conf -state disabled\n    set difffilestart {}\n}\n\nproc highlight_tag {f} {\n    global highlight_paths\n\n    foreach p $highlight_paths {\n        if {[string match $p $f]} {\n            return \"bold\"\n        }\n    }\n    return {}\n}\n\nproc highlight_filelist {} {\n    global cmitmode cflist\n\n    $cflist conf -state normal\n    if {$cmitmode ne \"tree\"} {\n        set end [lindex [split [$cflist index end] .] 0]\n        for {set l 2} {$l < $end} {incr l} {\n            set line [$cflist get $l.0 \"$l.0 lineend\"]\n            if {[highlight_tag $line] ne {}} {\n                $cflist tag add bold $l.0 \"$l.0 lineend\"\n            }\n        }\n    } else {\n        highlight_tree 2 {}\n    }\n    $cflist conf -state disabled\n}\n\nproc unhighlight_filelist {} {\n    global cflist\n\n    $cflist conf -state normal\n    $cflist tag remove bold 1.0 end\n    $cflist conf -state disabled\n}\n\nproc add_flist {fl} {\n    global cflist\n\n    $cflist conf -state normal\n    foreach f $fl {\n        $cflist insert end \"\\n\"\n        $cflist insert end $f [highlight_tag $f]\n    }\n    $cflist conf -state disabled\n}\n\nproc sel_flist {w x y} {\n    global ctext difffilestart cflist cflist_top cmitmode\n\n    if {$cmitmode eq \"tree\"} return\n    if {![info exists cflist_top]} return\n    set l [lindex [split [$w index \"@$x,$y\"] \".\"] 0]\n    $cflist tag remove highlight $cflist_top.0 \"$cflist_top.0 lineend\"\n    $cflist tag add highlight $l.0 \"$l.0 lineend\"\n    set cflist_top $l\n    if {$l == 1} {\n        $ctext yview 1.0\n    } else {\n        catch {$ctext yview [lindex $difffilestart [expr {$l - 2}]]}\n    }\n    suppress_highlighting_file_for_current_scrollpos\n}\n\nproc pop_flist_menu {w X Y x y} {\n    global ctext cflist cmitmode flist_menu flist_menu_file\n    global treediffs diffids\n\n    stopfinding\n    set l [lindex [split [$w index \"@$x,$y\"] \".\"] 0]\n    if {$l <= 1} return\n    if {$cmitmode eq \"tree\"} {\n        set e [linetoelt $l]\n        if {[string index $e end] eq \"/\"} return\n    } else {\n        set e [lindex $treediffs($diffids) [expr {$l-2}]]\n    }\n    set flist_menu_file $e\n    set xdiffstate \"normal\"\n    if {$cmitmode eq \"tree\"} {\n        set xdiffstate \"disabled\"\n    }\n    # Disable \"External diff\" item in tree mode\n    $flist_menu entryconf 2 -state $xdiffstate\n    tk_popup $flist_menu $X $Y\n}\n\nproc find_ctext_fileinfo {line} {\n    global ctext_file_names ctext_file_lines\n\n    set ok [bsearch $ctext_file_lines $line]\n    set tline [lindex $ctext_file_lines $ok]\n\n    if {$ok >= [llength $ctext_file_lines] || $line < $tline} {\n        return {}\n    } else {\n        return [list [lindex $ctext_file_names $ok] $tline]\n    }\n}\n\nproc pop_diff_menu {w X Y x y} {\n    global ctext diff_menu flist_menu_file\n    global diff_menu_txtpos diff_menu_line\n    global diff_menu_filebase\n\n    set diff_menu_txtpos [split [$w index \"@$x,$y\"] \".\"]\n    set diff_menu_line [lindex $diff_menu_txtpos 0]\n    # don't pop up the menu on hunk-separator or file-separator lines\n    if {[lsearch -glob [$ctext tag names $diff_menu_line.0] \"*sep\"] >= 0} {\n        return\n    }\n    stopfinding\n    set f [find_ctext_fileinfo $diff_menu_line]\n    if {$f eq {}} return\n    set flist_menu_file [lindex $f 0]\n    set diff_menu_filebase [lindex $f 1]\n    tk_popup $diff_menu $X $Y\n}\n\nproc flist_hl {only} {\n    global flist_menu_file findstring gdttype\n\n    set x [shellquote $flist_menu_file]\n    if {$only || $findstring eq {} || $gdttype ne [mc \"touching paths:\"]} {\n        set findstring $x\n    } else {\n        append findstring \" \" $x\n    }\n    set gdttype [mc \"touching paths:\"]\n}\n\nproc gitknewtmpdir {} {\n    global diffnum gitktmpdir gitdir env\n\n    if {![info exists gitktmpdir]} {\n        if {[info exists env(GITK_TMPDIR)]} {\n            set tmpdir $env(GITK_TMPDIR)\n        } elseif {[info exists env(TMPDIR)]} {\n            set tmpdir $env(TMPDIR)\n        } else {\n            set tmpdir $gitdir\n        }\n        set gitktmpformat [file join $tmpdir \".gitk-tmp.XXXXXX\"]\n        if {[catch {set gitktmpdir [exec mktemp -d $gitktmpformat]}]} {\n            set gitktmpdir [file join $gitdir [format \".gitk-tmp.%s\" [pid]]]\n        }\n        if {[catch {file mkdir $gitktmpdir} err]} {\n            error_popup \"[mc \"Error creating temporary directory %s:\" $gitktmpdir] $err\"\n            unset gitktmpdir\n            return {}\n        }\n        set diffnum 0\n    }\n    incr diffnum\n    set diffdir [file join $gitktmpdir $diffnum]\n    if {[catch {file mkdir $diffdir} err]} {\n        error_popup \"[mc \"Error creating temporary directory %s:\" $diffdir] $err\"\n        return {}\n    }\n    return $diffdir\n}\n\nproc save_file_from_commit {filename output what} {\n    global nullfile\n\n    if {[catch {exec git show $filename -- > $output} err]} {\n        if {[string match \"fatal: bad revision *\" $err]} {\n            return $nullfile\n        }\n        error_popup \"[mc \"Error getting \\\"%s\\\" from %s:\" $filename $what] $err\"\n        return {}\n    }\n    return $output\n}\n\nproc external_diff_get_one_file {diffid filename diffdir} {\n    global nullid nullid2 nullfile\n    global worktree\n\n    if {$diffid == $nullid} {\n        set difffile [file join $worktree $filename]\n        if {[file exists $difffile]} {\n            return $difffile\n        }\n        return $nullfile\n    }\n    if {$diffid == $nullid2} {\n        set difffile [file join $diffdir \"\\[index\\] [file tail $filename]\"]\n        return [save_file_from_commit :$filename $difffile index]\n    }\n    set difffile [file join $diffdir \"\\[$diffid\\] [file tail $filename]\"]\n    return [save_file_from_commit $diffid:$filename $difffile \\\n               \"revision $diffid\"]\n}\n\nproc external_diff {} {\n    global nullid nullid2\n    global flist_menu_file\n    global diffids\n    global extdifftool\n\n    if {[llength $diffids] == 1} {\n        # no reference commit given\n        set diffidto [lindex $diffids 0]\n        if {$diffidto eq $nullid} {\n            # diffing working copy with index\n            set diffidfrom $nullid2\n        } elseif {$diffidto eq $nullid2} {\n            # diffing index with HEAD\n            set diffidfrom \"HEAD\"\n        } else {\n            # use first parent commit\n            global parentlist selectedline\n            set diffidfrom [lindex $parentlist $selectedline 0]\n        }\n    } else {\n        set diffidfrom [lindex $diffids 0]\n        set diffidto [lindex $diffids 1]\n    }\n\n    # make sure that several diffs wont collide\n    set diffdir [gitknewtmpdir]\n    if {$diffdir eq {}} return\n\n    # gather files to diff\n    set difffromfile [external_diff_get_one_file $diffidfrom $flist_menu_file $diffdir]\n    set difftofile [external_diff_get_one_file $diffidto $flist_menu_file $diffdir]\n\n    if {$difffromfile ne {} && $difftofile ne {}} {\n        set cmd [list [shellsplit $extdifftool] $difffromfile $difftofile]\n        if {[catch {set fl [open |$cmd r]} err]} {\n            file delete -force $diffdir\n            error_popup \"$extdifftool: [mc \"command failed:\"] $err\"\n        } else {\n            fconfigure $fl -blocking 0\n            filerun $fl [list delete_at_eof $fl $diffdir]\n        }\n    }\n}\n\nproc find_hunk_blamespec {base line} {\n    global ctext\n\n    # Find and parse the hunk header\n    set s_lix [$ctext search -backwards -regexp ^@@ \"$line.0 lineend\" $base.0]\n    if {$s_lix eq {}} return\n\n    set s_line [$ctext get $s_lix \"$s_lix + 1 lines\"]\n    if {![regexp {^@@@*(( -\\d+(,\\d+)?)+) \\+(\\d+)(,\\d+)? @@} $s_line \\\n            s_line old_specs osz osz1 new_line nsz]} {\n        return\n    }\n\n    # base lines for the parents\n    set base_lines [list $new_line]\n    foreach old_spec [lrange [split $old_specs \" \"] 1 end] {\n        if {![regexp -- {-(\\d+)(,\\d+)?} $old_spec \\\n                old_spec old_line osz]} {\n            return\n        }\n        lappend base_lines $old_line\n    }\n\n    # Now scan the lines to determine offset within the hunk\n    set max_parent [expr {[llength $base_lines]-2}]\n    set dline 0\n    set s_lno [lindex [split $s_lix \".\"] 0]\n\n    # Determine if the line is removed\n    set chunk [$ctext get $line.0 \"$line.1 + $max_parent chars\"]\n    if {[string match {[-+ ]*} $chunk]} {\n        set removed_idx [string first \"-\" $chunk]\n        # Choose a parent index\n        if {$removed_idx >= 0} {\n            set parent $removed_idx\n        } else {\n            set unchanged_idx [string first \" \" $chunk]\n            if {$unchanged_idx >= 0} {\n                set parent $unchanged_idx\n            } else {\n                # blame the current commit\n                set parent -1\n            }\n        }\n        # then count other lines that belong to it\n        for {set i $line} {[incr i -1] > $s_lno} {} {\n            set chunk [$ctext get $i.0 \"$i.1 + $max_parent chars\"]\n            # Determine if the line is removed\n            set removed_idx [string first \"-\" $chunk]\n            if {$parent >= 0} {\n                set code [string index $chunk $parent]\n                if {$code eq \"-\" || ($removed_idx < 0 && $code ne \"+\")} {\n                    incr dline\n                }\n            } else {\n                if {$removed_idx < 0} {\n                    incr dline\n                }\n            }\n        }\n        incr parent\n    } else {\n        set parent 0\n    }\n\n    incr dline [lindex $base_lines $parent]\n    return [list $parent $dline]\n}\n\nproc external_blame_diff {} {\n    global currentid cmitmode\n    global diff_menu_txtpos diff_menu_line\n    global diff_menu_filebase flist_menu_file\n\n    if {$cmitmode eq \"tree\"} {\n        set parent_idx 0\n        set line [expr {$diff_menu_line - $diff_menu_filebase}]\n    } else {\n        set hinfo [find_hunk_blamespec $diff_menu_filebase $diff_menu_line]\n        if {$hinfo ne {}} {\n            set parent_idx [lindex $hinfo 0]\n            set line [lindex $hinfo 1]\n        } else {\n            set parent_idx 0\n            set line 0\n        }\n    }\n\n    external_blame $parent_idx $line\n}\n\n# Find the SHA1 ID of the blob for file $fname in the index\n# at stage 0 or 2\nproc index_sha1 {fname} {\n    set f [open [list | git ls-files -s $fname] r]\n    while {[gets $f line] >= 0} {\n        set info [lindex [split $line \"\\t\"] 0]\n        set stage [lindex $info 2]\n        if {$stage eq \"0\" || $stage eq \"2\"} {\n            close $f\n            return [lindex $info 1]\n        }\n    }\n    close $f\n    return {}\n}\n\n# Turn an absolute path into one relative to the current directory\nproc make_relative {f} {\n    if {[file pathtype $f] eq \"relative\"} {\n        return $f\n    }\n    set elts [file split $f]\n    set here [file split [pwd]]\n    set ei 0\n    set hi 0\n    set res {}\n    foreach d $here {\n        if {$ei < $hi || $ei >= [llength $elts] || [lindex $elts $ei] ne $d} {\n            lappend res \"..\"\n        } else {\n            incr ei\n        }\n        incr hi\n    }\n    set elts [concat $res [lrange $elts $ei end]]\n    return [eval file join $elts]\n}\n\nproc external_blame {parent_idx {line {}}} {\n    global flist_menu_file cdup\n    global nullid nullid2\n    global parentlist selectedline currentid\n\n    if {$parent_idx > 0} {\n        set base_commit [lindex $parentlist $selectedline [expr {$parent_idx-1}]]\n    } else {\n        set base_commit $currentid\n    }\n\n    if {$base_commit eq {} || $base_commit eq $nullid || $base_commit eq $nullid2} {\n        error_popup [mc \"No such commit\"]\n        return\n    }\n\n    set cmdline [list git gui blame]\n    if {$line ne {} && $line > 1} {\n        lappend cmdline \"--line=$line\"\n    }\n    set f [file join $cdup $flist_menu_file]\n    # Unfortunately it seems git gui blame doesn't like\n    # being given an absolute path...\n    set f [make_relative $f]\n    lappend cmdline $base_commit $f\n    if {[catch {eval exec $cmdline &} err]} {\n        error_popup \"[mc \"git gui blame: command failed:\"] $err\"\n    }\n}\n\nproc show_line_source {} {\n    global cmitmode currentid parents curview blamestuff blameinst\n    global diff_menu_line diff_menu_filebase flist_menu_file\n    global nullid nullid2 gitdir cdup\n\n    set from_index {}\n    if {$cmitmode eq \"tree\"} {\n        set id $currentid\n        set line [expr {$diff_menu_line - $diff_menu_filebase}]\n    } else {\n        set h [find_hunk_blamespec $diff_menu_filebase $diff_menu_line]\n        if {$h eq {}} return\n        set pi [lindex $h 0]\n        if {$pi == 0} {\n            mark_ctext_line $diff_menu_line\n            return\n        }\n        incr pi -1\n        if {$currentid eq $nullid} {\n            if {$pi > 0} {\n                # must be a merge in progress...\n                if {[catch {\n                    # get the last line from .git/MERGE_HEAD\n                    set f [open [file join $gitdir MERGE_HEAD] r]\n                    set id [lindex [split [read $f] \"\\n\"] end-1]\n                    close $f\n                } err]} {\n                    error_popup [mc \"Couldn't read merge head: %s\" $err]\n                    return\n                }\n            } elseif {$parents($curview,$currentid) eq $nullid2} {\n                # need to do the blame from the index\n                if {[catch {\n                    set from_index [index_sha1 $flist_menu_file]\n                } err]} {\n                    error_popup [mc \"Error reading index: %s\" $err]\n                    return\n                }\n            } else {\n                set id $parents($curview,$currentid)\n            }\n        } else {\n            set id [lindex $parents($curview,$currentid) $pi]\n        }\n        set line [lindex $h 1]\n    }\n    set blameargs {}\n    if {$from_index ne {}} {\n        lappend blameargs | git cat-file blob $from_index\n    }\n    lappend blameargs | git blame -p -L$line,+1\n    if {$from_index ne {}} {\n        lappend blameargs --contents -\n    } else {\n        lappend blameargs $id\n    }\n    lappend blameargs -- [file join $cdup $flist_menu_file]\n    if {[catch {\n        set f [open $blameargs r]\n    } err]} {\n        error_popup [mc \"Couldn't start git blame: %s\" $err]\n        return\n    }\n    nowbusy blaming [mc \"Searching\"]\n    fconfigure $f -blocking 0\n    set i [reg_instance $f]\n    set blamestuff($i) {}\n    set blameinst $i\n    filerun $f [list read_line_source $f $i]\n}\n\nproc stopblaming {} {\n    global blameinst\n\n    if {[info exists blameinst]} {\n        stop_instance $blameinst\n        unset blameinst\n        notbusy blaming\n    }\n}\n\nproc read_line_source {fd inst} {\n    global blamestuff curview commfd blameinst nullid nullid2\n\n    while {[gets $fd line] >= 0} {\n        lappend blamestuff($inst) $line\n    }\n    if {![eof $fd]} {\n        return 1\n    }\n    unset commfd($inst)\n    unset blameinst\n    notbusy blaming\n    fconfigure $fd -blocking 1\n    if {[catch {close $fd} err]} {\n        error_popup [mc \"Error running git blame: %s\" $err]\n        return 0\n    }\n\n    set fname {}\n    set line [split [lindex $blamestuff($inst) 0] \" \"]\n    set id [lindex $line 0]\n    set lnum [lindex $line 1]\n    if {[string length $id] == 40 && [string is xdigit $id] &&\n        [string is digit -strict $lnum]} {\n        # look for \"filename\" line\n        foreach l $blamestuff($inst) {\n            if {[string match \"filename *\" $l]} {\n                set fname [string range $l 9 end]\n                break\n            }\n        }\n    }\n    if {$fname ne {}} {\n        # all looks good, select it\n        if {$id eq $nullid} {\n            # blame uses all-zeroes to mean not committed,\n            # which would mean a change in the index\n            set id $nullid2\n        }\n        if {[commitinview $id $curview]} {\n            selectline [rowofcommit $id] 1 [list $fname $lnum] 1\n        } else {\n            error_popup [mc \"That line comes from commit %s, \\\n                             which is not in this view\" [shortids $id]]\n        }\n    } else {\n        puts \"oops couldn't parse git blame output\"\n    }\n    return 0\n}\n\n# delete $dir when we see eof on $f (presumably because the child has exited)\nproc delete_at_eof {f dir} {\n    while {[gets $f line] >= 0} {}\n    if {[eof $f]} {\n        if {[catch {close $f} err]} {\n            error_popup \"[mc \"External diff viewer failed:\"] $err\"\n        }\n        file delete -force $dir\n        return 0\n    }\n    return 1\n}\n\n# Functions for adding and removing shell-type quoting\n\nproc shellquote {str} {\n    if {![string match \"*\\['\\\"\\\\ \\t]*\" $str]} {\n        return $str\n    }\n    if {![string match \"*\\['\\\"\\\\]*\" $str]} {\n        return \"\\\"$str\\\"\"\n    }\n    if {![string match \"*'*\" $str]} {\n        return \"'$str'\"\n    }\n    return \"\\\"[string map {\\\" \\\\\\\" \\\\ \\\\\\\\} $str]\\\"\"\n}\n\nproc shellarglist {l} {\n    set str {}\n    foreach a $l {\n        if {$str ne {}} {\n            append str \" \"\n        }\n        append str [shellquote $a]\n    }\n    return $str\n}\n\nproc shelldequote {str} {\n    set ret {}\n    set used -1\n    while {1} {\n        incr used\n        if {![regexp -start $used -indices \"\\['\\\"\\\\\\\\ \\t]\" $str first]} {\n            append ret [string range $str $used end]\n            set used [string length $str]\n            break\n        }\n        set first [lindex $first 0]\n        set ch [string index $str $first]\n        if {$first > $used} {\n            append ret [string range $str $used [expr {$first - 1}]]\n            set used $first\n        }\n        if {$ch eq \" \" || $ch eq \"\\t\"} break\n        incr used\n        if {$ch eq \"'\"} {\n            set first [string first \"'\" $str $used]\n            if {$first < 0} {\n                error \"unmatched single-quote\"\n            }\n            append ret [string range $str $used [expr {$first - 1}]]\n            set used $first\n            continue\n        }\n        if {$ch eq \"\\\\\"} {\n            if {$used >= [string length $str]} {\n                error \"trailing backslash\"\n            }\n            append ret [string index $str $used]\n            continue\n        }\n        # here ch == \"\\\"\"\n        while {1} {\n            if {![regexp -start $used -indices \"\\[\\\"\\\\\\\\]\" $str first]} {\n                error \"unmatched double-quote\"\n            }\n            set first [lindex $first 0]\n            set ch [string index $str $first]\n            if {$first > $used} {\n                append ret [string range $str $used [expr {$first - 1}]]\n                set used $first\n            }\n            if {$ch eq \"\\\"\"} break\n            incr used\n            append ret [string index $str $used]\n            incr used\n        }\n    }\n    return [list $used $ret]\n}\n\nproc shellsplit {str} {\n    set l {}\n    while {1} {\n        set str [string trimleft $str]\n        if {$str eq {}} break\n        set dq [shelldequote $str]\n        set n [lindex $dq 0]\n        set word [lindex $dq 1]\n        set str [string range $str $n end]\n        lappend l $word\n    }\n    return $l\n}\n\nproc set_window_title {} {\n    global appname curview viewname vrevs\n    set rev [mc \"All files\"]\n    if {$curview ne 0} {\n        if {$viewname($curview) eq [mc \"Command line\"]} {\n            set rev [string map {\"--gitk-symmetric-diff-marker\" \"--merge\"} $vrevs($curview)]\n        } else {\n            set rev $viewname($curview)\n        }\n    }\n    wm title . \"[reponame]: $rev - $appname\"\n}\n\n# Code to implement multiple views\n\nproc newview {ishighlight} {\n    global nextviewnum newviewname newishighlight\n    global revtreeargs viewargscmd newviewopts curview\n\n    set newishighlight $ishighlight\n    set top .gitkview\n    if {[winfo exists $top]} {\n        raise $top\n        return\n    }\n    decode_view_opts $nextviewnum $revtreeargs\n    set newviewname($nextviewnum) \"[mc \"View\"] $nextviewnum\"\n    set newviewopts($nextviewnum,perm) 0\n    set newviewopts($nextviewnum,cmd)  $viewargscmd($curview)\n    vieweditor $top $nextviewnum [mc \"Gitk view definition\"]\n}\n\nset known_view_options {\n    {perm      b    .  {}               {mc \"Remember this view\"}}\n    {reflabel  l    +  {}               {mc \"References (space separated list):\"}}\n    {refs      t15  .. {}               {mc \"Branches & tags:\"}}\n    {allrefs   b    *. \"--all\"          {mc \"All refs\"}}\n    {branches  b    .  \"--branches\"     {mc \"All (local) branches\"}}\n    {tags      b    .  \"--tags\"         {mc \"All tags\"}}\n    {remotes   b    .  \"--remotes\"      {mc \"All remote-tracking branches\"}}\n    {commitlbl l    +  {}               {mc \"Commit Info (regular expressions):\"}}\n    {author    t15  .. \"--author=*\"     {mc \"Author:\"}}\n    {committer t15  .  \"--committer=*\"  {mc \"Committer:\"}}\n    {loginfo   t15  .. \"--grep=*\"       {mc \"Commit Message:\"}}\n    {allmatch  b    .. \"--all-match\"    {mc \"Matches all Commit Info criteria\"}}\n    {igrep     b    .. \"--invert-grep\"  {mc \"Matches no Commit Info criteria\"}}\n    {changes_l l    +  {}               {mc \"Changes to Files:\"}}\n    {pickaxe_s r0   .  {}               {mc \"Fixed String\"}}\n    {pickaxe_t r1   .  \"--pickaxe-regex\"  {mc \"Regular Expression\"}}\n    {pickaxe   t15  .. \"-S*\"            {mc \"Search string:\"}}\n    {datelabel l    +  {}               {mc \"Commit Dates (\\\"2 weeks ago\\\", \\\"2009-03-17 15:27:38\\\", \\\"March 17, 2009 15:27:38\\\"):\"}}\n    {since     t15  ..  {\"--since=*\" \"--after=*\"}  {mc \"Since:\"}}\n    {until     t15  .   {\"--until=*\" \"--before=*\"} {mc \"Until:\"}}\n    {limit_lbl l    +  {}               {mc \"Limit and/or skip a number of revisions (positive integer):\"}}\n    {limit     t10  *. \"--max-count=*\"  {mc \"Number to show:\"}}\n    {skip      t10  .  \"--skip=*\"       {mc \"Number to skip:\"}}\n    {misc_lbl  l    +  {}               {mc \"Miscellaneous options:\"}}\n    {dorder    b    *. {\"--date-order\" \"-d\"}      {mc \"Strictly sort by date\"}}\n    {lright    b    .  \"--left-right\"   {mc \"Mark branch sides\"}}\n    {first     b    .  \"--first-parent\" {mc \"Limit to first parent\"}}\n    {smplhst   b    .  \"--simplify-by-decoration\"   {mc \"Simple history\"}}\n    {args      t50  *. {}               {mc \"Additional arguments to git log:\"}}\n    {allpaths  path +  {}               {mc \"Enter files and directories to include, one per line:\"}}\n    {cmd       t50= +  {}               {mc \"Command to generate more commits to include:\"}}\n    }\n\n# Convert $newviewopts($n, ...) into args for git log.\nproc encode_view_opts {n} {\n    global known_view_options newviewopts\n\n    set rargs [list]\n    foreach opt $known_view_options {\n        set patterns [lindex $opt 3]\n        if {$patterns eq {}} continue\n        set pattern [lindex $patterns 0]\n\n        if {[lindex $opt 1] eq \"b\"} {\n            set val $newviewopts($n,[lindex $opt 0])\n            if {$val} {\n                lappend rargs $pattern\n            }\n        } elseif {[regexp {^r(\\d+)$} [lindex $opt 1] type value]} {\n            regexp {^(.*_)} [lindex $opt 0] uselessvar button_id\n            set val $newviewopts($n,$button_id)\n            if {$val eq $value} {\n                lappend rargs $pattern\n            }\n        } else {\n            set val $newviewopts($n,[lindex $opt 0])\n            set val [string trim $val]\n            if {$val ne {}} {\n                set pfix [string range $pattern 0 end-1]\n                lappend rargs $pfix$val\n            }\n        }\n    }\n    set rargs [concat $rargs [shellsplit $newviewopts($n,refs)]]\n    return [concat $rargs [shellsplit $newviewopts($n,args)]]\n}\n\n# Fill $newviewopts($n, ...) based on args for git log.\nproc decode_view_opts {n view_args} {\n    global known_view_options newviewopts\n\n    foreach opt $known_view_options {\n        set id [lindex $opt 0]\n        if {[lindex $opt 1] eq \"b\"} {\n            # Checkboxes\n            set val 0\n        } elseif {[regexp {^r(\\d+)$} [lindex $opt 1]]} {\n            # Radiobuttons\n            regexp {^(.*_)} $id uselessvar id\n            set val 0\n        } else {\n            # Text fields\n            set val {}\n        }\n        set newviewopts($n,$id) $val\n    }\n    set oargs [list]\n    set refargs [list]\n    foreach arg $view_args {\n        if {[regexp -- {^-([0-9]+)$} $arg arg cnt]\n            && ![info exists found(limit)]} {\n            set newviewopts($n,limit) $cnt\n            set found(limit) 1\n            continue\n        }\n        catch { unset val }\n        foreach opt $known_view_options {\n            set id [lindex $opt 0]\n            if {[info exists found($id)]} continue\n            foreach pattern [lindex $opt 3] {\n                if {![string match $pattern $arg]} continue\n                if {[lindex $opt 1] eq \"b\"} {\n                    # Check buttons\n                    set val 1\n                } elseif {[regexp {^r(\\d+)$} [lindex $opt 1] match num]} {\n                    # Radio buttons\n                    regexp {^(.*_)} $id uselessvar id\n                    set val $num\n                } else {\n                    # Text input fields\n                    set size [string length $pattern]\n                    set val [string range $arg [expr {$size-1}] end]\n                }\n                set newviewopts($n,$id) $val\n                set found($id) 1\n                break\n            }\n            if {[info exists val]} break\n        }\n        if {[info exists val]} continue\n        if {[regexp {^-} $arg]} {\n            lappend oargs $arg\n        } else {\n            lappend refargs $arg\n        }\n    }\n    set newviewopts($n,refs) [shellarglist $refargs]\n    set newviewopts($n,args) [shellarglist $oargs]\n}\n\nproc edit_or_newview {} {\n    global curview\n\n    if {$curview > 0} {\n        editview\n    } else {\n        newview 0\n    }\n}\n\nproc editview {} {\n    global curview\n    global viewname viewperm newviewname newviewopts\n    global viewargs viewargscmd\n\n    set top .gitkvedit-$curview\n    if {[winfo exists $top]} {\n        raise $top\n        return\n    }\n    decode_view_opts $curview $viewargs($curview)\n    set newviewname($curview)      $viewname($curview)\n    set newviewopts($curview,perm) $viewperm($curview)\n    set newviewopts($curview,cmd)  $viewargscmd($curview)\n    vieweditor $top $curview \"[mc \"Gitk: edit view\"] $viewname($curview)\"\n}\n\nproc vieweditor {top n title} {\n    global newviewname newviewopts viewfiles bgcolor\n    global known_view_options NS\n\n    ttk_toplevel $top\n    wm title $top [concat $title [mc \"-- criteria for selecting revisions\"]]\n    make_transient $top .\n\n    # View name\n    ${NS}::frame $top.nfr\n    ${NS}::label $top.nl -text [mc \"View Name\"]\n    ${NS}::entry $top.name -width 20 -textvariable newviewname($n)\n    pack $top.nfr -in $top -fill x -pady 5 -padx 3\n    pack $top.nl -in $top.nfr -side left -padx {0 5}\n    pack $top.name -in $top.nfr -side left -padx {0 25}\n\n    # View options\n    set cframe $top.nfr\n    set cexpand 0\n    set cnt 0\n    foreach opt $known_view_options {\n        set id [lindex $opt 0]\n        set type [lindex $opt 1]\n        set flags [lindex $opt 2]\n        set title [eval [lindex $opt 4]]\n        set lxpad 0\n\n        if {$flags eq \"+\" || $flags eq \"*\"} {\n            set cframe $top.fr$cnt\n            incr cnt\n            ${NS}::frame $cframe\n            pack $cframe -in $top -fill x -pady 3 -padx 3\n            set cexpand [expr {$flags eq \"*\"}]\n        } elseif {$flags eq \"..\" || $flags eq \"*.\"} {\n            set cframe $top.fr$cnt\n            incr cnt\n            ${NS}::frame $cframe\n            pack $cframe -in $top -fill x -pady 3 -padx [list 15 3]\n            set cexpand [expr {$flags eq \"*.\"}]\n        } else {\n            set lxpad 5\n        }\n\n        if {$type eq \"l\"} {\n            ${NS}::label $cframe.l_$id -text $title\n            pack $cframe.l_$id -in $cframe -side left -pady [list 3 0] -anchor w\n        } elseif {$type eq \"b\"} {\n            ${NS}::checkbutton $cframe.c_$id -text $title -variable newviewopts($n,$id)\n            pack $cframe.c_$id -in $cframe -side left \\\n                -padx [list $lxpad 0] -expand $cexpand -anchor w\n        } elseif {[regexp {^r(\\d+)$} $type type sz]} {\n            regexp {^(.*_)} $id uselessvar button_id\n            ${NS}::radiobutton $cframe.c_$id -text $title -variable newviewopts($n,$button_id) -value $sz\n            pack $cframe.c_$id -in $cframe -side left \\\n                -padx [list $lxpad 0] -expand $cexpand -anchor w\n        } elseif {[regexp {^t(\\d+)$} $type type sz]} {\n            ${NS}::label $cframe.l_$id -text $title\n            ${NS}::entry $cframe.e_$id -width $sz -background $bgcolor \\\n                -textvariable newviewopts($n,$id)\n            pack $cframe.l_$id -in $cframe -side left -padx [list $lxpad 0]\n            pack $cframe.e_$id -in $cframe -side left -expand 1 -fill x\n        } elseif {[regexp {^t(\\d+)=$} $type type sz]} {\n            ${NS}::label $cframe.l_$id -text $title\n            ${NS}::entry $cframe.e_$id -width $sz -background $bgcolor \\\n                -textvariable newviewopts($n,$id)\n            pack $cframe.l_$id -in $cframe -side top -pady [list 3 0] -anchor w\n            pack $cframe.e_$id -in $cframe -side top -fill x\n        } elseif {$type eq \"path\"} {\n            ${NS}::label $top.l -text $title\n            pack $top.l -in $top -side top -pady [list 3 0] -anchor w -padx 3\n            text $top.t -width 40 -height 5 -background $bgcolor\n            if {[info exists viewfiles($n)]} {\n                foreach f $viewfiles($n) {\n                    $top.t insert end $f\n                    $top.t insert end \"\\n\"\n                }\n                $top.t delete {end - 1c} end\n                $top.t mark set insert 0.0\n            }\n            pack $top.t -in $top -side top -pady [list 0 5] -fill both -expand 1 -padx 3\n        }\n    }\n\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.ok -text [mc \"OK\"] -command [list newviewok $top $n]\n    ${NS}::button $top.buts.apply -text [mc \"Apply (F5)\"] -command [list newviewok $top $n 1]\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command [list destroy $top]\n    bind $top <Control-Return> [list newviewok $top $n]\n    bind $top <F5> [list newviewok $top $n 1]\n    bind $top <Escape> [list destroy $top]\n    grid $top.buts.ok $top.buts.apply $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid columnconfigure $top.buts 2 -weight 1 -uniform a\n    pack $top.buts -in $top -side top -fill x\n    focus $top.t\n}\n\nproc doviewmenu {m first cmd op argv} {\n    set nmenu [$m index end]\n    for {set i $first} {$i <= $nmenu} {incr i} {\n        if {[$m entrycget $i -command] eq $cmd} {\n            eval $m $op $i $argv\n            break\n        }\n    }\n}\n\nproc allviewmenus {n op args} {\n    # global viewhlmenu\n\n    doviewmenu .bar.view 5 [list showview $n] $op $args\n    # doviewmenu $viewhlmenu 1 [list addvhighlight $n] $op $args\n}\n\nproc newviewok {top n {apply 0}} {\n    global nextviewnum newviewperm newviewname newishighlight\n    global viewname viewfiles viewperm viewchanged selectedview curview\n    global viewargs viewargscmd newviewopts viewhlmenu\n\n    if {[catch {\n        set newargs [encode_view_opts $n]\n    } err]} {\n        error_popup \"[mc \"Error in commit selection arguments:\"] $err\" $top\n        return\n    }\n    set files {}\n    foreach f [split [$top.t get 0.0 end] \"\\n\"] {\n        set ft [string trim $f]\n        if {$ft ne {}} {\n            lappend files $ft\n        }\n    }\n    if {![info exists viewfiles($n)]} {\n        # creating a new view\n        incr nextviewnum\n        set viewname($n) $newviewname($n)\n        set viewperm($n) $newviewopts($n,perm)\n        set viewchanged($n) 1\n        set viewfiles($n) $files\n        set viewargs($n) $newargs\n        set viewargscmd($n) $newviewopts($n,cmd)\n        addviewmenu $n\n        if {!$newishighlight} {\n            run showview $n\n        } else {\n            run addvhighlight $n\n        }\n    } else {\n        # editing an existing view\n        set viewperm($n) $newviewopts($n,perm)\n        set viewchanged($n) 1\n        if {$newviewname($n) ne $viewname($n)} {\n            set viewname($n) $newviewname($n)\n            doviewmenu .bar.view 5 [list showview $n] \\\n                entryconf [list -label $viewname($n)]\n            # doviewmenu $viewhlmenu 1 [list addvhighlight $n] \\\n                # entryconf [list -label $viewname($n) -value $viewname($n)]\n        }\n        if {$files ne $viewfiles($n) || $newargs ne $viewargs($n) || \\\n                $newviewopts($n,cmd) ne $viewargscmd($n)} {\n            set viewfiles($n) $files\n            set viewargs($n) $newargs\n            set viewargscmd($n) $newviewopts($n,cmd)\n            if {$curview == $n} {\n                run reloadcommits\n            }\n        }\n    }\n    if {$apply} return\n    catch {destroy $top}\n}\n\nproc delview {} {\n    global curview viewperm hlview selectedhlview viewchanged\n\n    if {$curview == 0} return\n    if {[info exists hlview] && $hlview == $curview} {\n        set selectedhlview [mc \"None\"]\n        unset hlview\n    }\n    allviewmenus $curview delete\n    set viewperm($curview) 0\n    set viewchanged($curview) 1\n    showview 0\n}\n\nproc addviewmenu {n} {\n    global viewname viewhlmenu\n\n    .bar.view add radiobutton -label $viewname($n) \\\n        -command [list showview $n] -variable selectedview -value $n\n    #$viewhlmenu add radiobutton -label $viewname($n) \\\n    #\t-command [list addvhighlight $n] -variable selectedhlview\n}\n\nproc showview {n} {\n    global curview cached_commitrow ordertok\n    global displayorder parentlist rowidlist rowisopt rowfinal\n    global colormap rowtextx nextcolor canvxmax\n    global numcommits viewcomplete\n    global selectedline currentid canv canvy0\n    global treediffs\n    global pending_select mainheadid\n    global commitidx\n    global selectedview\n    global hlview selectedhlview commitinterest\n\n    if {$n == $curview} return\n    set selid {}\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    set span [$canv yview]\n    set ytop [expr {[lindex $span 0] * $ymax}]\n    set ybot [expr {[lindex $span 1] * $ymax}]\n    set yscreen [expr {($ybot - $ytop) / 2}]\n    if {$selectedline ne {}} {\n        set selid $currentid\n        set y [yc $selectedline]\n        if {$ytop < $y && $y < $ybot} {\n            set yscreen [expr {$y - $ytop}]\n        }\n    } elseif {[info exists pending_select]} {\n        set selid $pending_select\n        unset pending_select\n    }\n    unselectline\n    normalline\n    unset -nocomplain treediffs\n    clear_display\n    if {[info exists hlview] && $hlview == $n} {\n        unset hlview\n        set selectedhlview [mc \"None\"]\n    }\n    unset -nocomplain commitinterest\n    unset -nocomplain cached_commitrow\n    unset -nocomplain ordertok\n\n    set curview $n\n    set selectedview $n\n    .bar.view entryconf [mca \"&Edit view...\"] -state [expr {$n == 0? \"disabled\": \"normal\"}]\n    .bar.view entryconf [mca \"&Delete view\"] -state [expr {$n == 0? \"disabled\": \"normal\"}]\n\n    run refill_reflist\n    if {![info exists viewcomplete($n)]} {\n        getcommits $selid\n        return\n    }\n\n    set displayorder {}\n    set parentlist {}\n    set rowidlist {}\n    set rowisopt {}\n    set rowfinal {}\n    set numcommits $commitidx($n)\n\n    unset -nocomplain colormap\n    unset -nocomplain rowtextx\n    set nextcolor 0\n    set canvxmax [$canv cget -width]\n    set curview $n\n    set row 0\n    setcanvscroll\n    set yf 0\n    set row {}\n    if {$selid ne {} && [commitinview $selid $n]} {\n        set row [rowofcommit $selid]\n        # try to get the selected row in the same position on the screen\n        set ymax [lindex [$canv cget -scrollregion] 3]\n        set ytop [expr {[yc $row] - $yscreen}]\n        if {$ytop < 0} {\n            set ytop 0\n        }\n        set yf [expr {$ytop * 1.0 / $ymax}]\n    }\n    allcanvs yview moveto $yf\n    drawvisible\n    if {$row ne {}} {\n        selectline $row 0\n    } elseif {!$viewcomplete($n)} {\n        reset_pending_select $selid\n    } else {\n        reset_pending_select {}\n\n        if {[commitinview $pending_select $curview]} {\n            selectline [rowofcommit $pending_select] 1\n        } else {\n            set row [first_real_row]\n            if {$row < $numcommits} {\n                selectline $row 0\n            }\n        }\n    }\n    if {!$viewcomplete($n)} {\n        if {$numcommits == 0} {\n            show_status [mc \"Reading commits...\"]\n        }\n    } elseif {$numcommits == 0} {\n        show_status [mc \"No commits selected\"]\n    }\n    set_window_title\n}\n\n# Stuff relating to the highlighting facility\n\nproc ishighlighted {id} {\n    global vhighlights fhighlights nhighlights rhighlights\n\n    if {[info exists nhighlights($id)] && $nhighlights($id) > 0} {\n        return $nhighlights($id)\n    }\n    if {[info exists vhighlights($id)] && $vhighlights($id) > 0} {\n        return $vhighlights($id)\n    }\n    if {[info exists fhighlights($id)] && $fhighlights($id) > 0} {\n        return $fhighlights($id)\n    }\n    if {[info exists rhighlights($id)] && $rhighlights($id) > 0} {\n        return $rhighlights($id)\n    }\n    return 0\n}\n\nproc bolden {id font} {\n    global canv linehtag currentid boldids need_redisplay markedid\n\n    # need_redisplay = 1 means the display is stale and about to be redrawn\n    if {$need_redisplay} return\n    lappend boldids $id\n    $canv itemconf $linehtag($id) -font $font\n    if {[info exists currentid] && $id eq $currentid} {\n        $canv delete secsel\n        set t [eval $canv create rect [$canv bbox $linehtag($id)] \\\n                   -outline {{}} -tags secsel \\\n                   -fill [$canv cget -selectbackground]]\n        $canv lower $t\n    }\n    if {[info exists markedid] && $id eq $markedid} {\n        make_idmark $id\n    }\n}\n\nproc bolden_name {id font} {\n    global canv2 linentag currentid boldnameids need_redisplay\n\n    if {$need_redisplay} return\n    lappend boldnameids $id\n    $canv2 itemconf $linentag($id) -font $font\n    if {[info exists currentid] && $id eq $currentid} {\n        $canv2 delete secsel\n        set t [eval $canv2 create rect [$canv2 bbox $linentag($id)] \\\n                   -outline {{}} -tags secsel \\\n                   -fill [$canv2 cget -selectbackground]]\n        $canv2 lower $t\n    }\n}\n\nproc unbolden {} {\n    global boldids\n\n    set stillbold {}\n    foreach id $boldids {\n        if {![ishighlighted $id]} {\n            bolden $id mainfont\n        } else {\n            lappend stillbold $id\n        }\n    }\n    set boldids $stillbold\n}\n\nproc addvhighlight {n} {\n    global hlview viewcomplete curview vhl_done commitidx\n\n    if {[info exists hlview]} {\n        delvhighlight\n    }\n    set hlview $n\n    if {$n != $curview && ![info exists viewcomplete($n)]} {\n        start_rev_list $n\n    }\n    set vhl_done $commitidx($hlview)\n    if {$vhl_done > 0} {\n        drawvisible\n    }\n}\n\nproc delvhighlight {} {\n    global hlview vhighlights\n\n    if {![info exists hlview]} return\n    unset hlview\n    unset -nocomplain vhighlights\n    unbolden\n}\n\nproc vhighlightmore {} {\n    global hlview vhl_done commitidx vhighlights curview\n\n    set max $commitidx($hlview)\n    set vr [visiblerows]\n    set r0 [lindex $vr 0]\n    set r1 [lindex $vr 1]\n    for {set i $vhl_done} {$i < $max} {incr i} {\n        set id [commitonrow $i $hlview]\n        if {[commitinview $id $curview]} {\n            set row [rowofcommit $id]\n            if {$r0 <= $row && $row <= $r1} {\n                if {![highlighted $row]} {\n                    bolden $id mainfontbold\n                }\n                set vhighlights($id) 1\n            }\n        }\n    }\n    set vhl_done $max\n    return 0\n}\n\nproc askvhighlight {row id} {\n    global hlview vhighlights iddrawn\n\n    if {[commitinview $id $hlview]} {\n        if {[info exists iddrawn($id)] && ![ishighlighted $id]} {\n            bolden $id mainfontbold\n        }\n        set vhighlights($id) 1\n    } else {\n        set vhighlights($id) 0\n    }\n}\n\nproc hfiles_change {} {\n    global highlight_files filehighlight fhighlights fh_serial\n    global highlight_paths\n\n    if {[info exists filehighlight]} {\n        # delete previous highlights\n        catch {close $filehighlight}\n        unset filehighlight\n        unset -nocomplain fhighlights\n        unbolden\n        unhighlight_filelist\n    }\n    set highlight_paths {}\n    after cancel do_file_hl $fh_serial\n    incr fh_serial\n    if {$highlight_files ne {}} {\n        after 300 do_file_hl $fh_serial\n    }\n}\n\nproc gdttype_change {name ix op} {\n    global gdttype highlight_files findstring findpattern\n\n    stopfinding\n    if {$findstring ne {}} {\n        if {$gdttype eq [mc \"containing:\"]} {\n            if {$highlight_files ne {}} {\n                set highlight_files {}\n                hfiles_change\n            }\n            findcom_change\n        } else {\n            if {$findpattern ne {}} {\n                set findpattern {}\n                findcom_change\n            }\n            set highlight_files $findstring\n            hfiles_change\n        }\n        drawvisible\n    }\n    # enable/disable findtype/findloc menus too\n}\n\nproc find_change {name ix op} {\n    global gdttype findstring highlight_files\n\n    stopfinding\n    if {$gdttype eq [mc \"containing:\"]} {\n        findcom_change\n    } else {\n        if {$highlight_files ne $findstring} {\n            set highlight_files $findstring\n            hfiles_change\n        }\n    }\n    drawvisible\n}\n\nproc findcom_change args {\n    global nhighlights boldnameids\n    global findpattern findtype findstring gdttype\n\n    stopfinding\n    # delete previous highlights, if any\n    foreach id $boldnameids {\n        bolden_name $id mainfont\n    }\n    set boldnameids {}\n    unset -nocomplain nhighlights\n    unbolden\n    unmarkmatches\n    if {$gdttype ne [mc \"containing:\"] || $findstring eq {}} {\n        set findpattern {}\n    } elseif {$findtype eq [mc \"Regexp\"]} {\n        set findpattern $findstring\n    } else {\n        set e [string map {\"*\" \"\\\\*\" \"?\" \"\\\\?\" \"\\[\" \"\\\\\\[\" \"\\\\\" \"\\\\\\\\\"} \\\n                   $findstring]\n        set findpattern \"*$e*\"\n    }\n}\n\nproc makepatterns {l} {\n    set ret {}\n    foreach e $l {\n        set ee [string map {\"*\" \"\\\\*\" \"?\" \"\\\\?\" \"\\[\" \"\\\\\\[\" \"\\\\\" \"\\\\\\\\\"} $e]\n        if {[string index $ee end] eq \"/\"} {\n            lappend ret \"$ee*\"\n        } else {\n            lappend ret $ee\n            lappend ret \"$ee/*\"\n        }\n    }\n    return $ret\n}\n\nproc do_file_hl {serial} {\n    global highlight_files filehighlight highlight_paths gdttype fhl_list\n    global cdup findtype\n\n    if {$gdttype eq [mc \"touching paths:\"]} {\n        # If \"exact\" match then convert backslashes to forward slashes.\n        # Most useful to support Windows-flavoured file paths.\n        if {$findtype eq [mc \"Exact\"]} {\n            set highlight_files [string map {\"\\\\\" \"/\"} $highlight_files]\n        }\n        if {[catch {set paths [shellsplit $highlight_files]}]} return\n        set highlight_paths [makepatterns $paths]\n        highlight_filelist\n        set relative_paths {}\n        foreach path $paths {\n            lappend relative_paths [file join $cdup $path]\n        }\n        set gdtargs [concat -- $relative_paths]\n    } elseif {$gdttype eq [mc \"adding/removing string:\"]} {\n        set gdtargs [list \"-S$highlight_files\"]\n    } elseif {$gdttype eq [mc \"changing lines matching:\"]} {\n        set gdtargs [list \"-G$highlight_files\"]\n    } else {\n        # must be \"containing:\", i.e. we're searching commit info\n        return\n    }\n    set cmd [concat | git diff-tree -r -s --stdin $gdtargs]\n    set filehighlight [open $cmd r+]\n    fconfigure $filehighlight -blocking 0\n    filerun $filehighlight readfhighlight\n    set fhl_list {}\n    drawvisible\n    flushhighlights\n}\n\nproc flushhighlights {} {\n    global filehighlight fhl_list\n\n    if {[info exists filehighlight]} {\n        lappend fhl_list {}\n        puts $filehighlight \"\"\n        flush $filehighlight\n    }\n}\n\nproc askfilehighlight {row id} {\n    global filehighlight fhighlights fhl_list\n\n    lappend fhl_list $id\n    set fhighlights($id) -1\n    puts $filehighlight $id\n}\n\nproc readfhighlight {} {\n    global filehighlight fhighlights curview iddrawn\n    global fhl_list find_dirn\n\n    if {![info exists filehighlight]} {\n        return 0\n    }\n    set nr 0\n    while {[incr nr] <= 100 && [gets $filehighlight line] >= 0} {\n        set line [string trim $line]\n        set i [lsearch -exact $fhl_list $line]\n        if {$i < 0} continue\n        for {set j 0} {$j < $i} {incr j} {\n            set id [lindex $fhl_list $j]\n            set fhighlights($id) 0\n        }\n        set fhl_list [lrange $fhl_list [expr {$i+1}] end]\n        if {$line eq {}} continue\n        if {![commitinview $line $curview]} continue\n        if {[info exists iddrawn($line)] && ![ishighlighted $line]} {\n            bolden $line mainfontbold\n        }\n        set fhighlights($line) 1\n    }\n    if {[eof $filehighlight]} {\n        # strange...\n        puts \"oops, git diff-tree died\"\n        catch {close $filehighlight}\n        unset filehighlight\n        return 0\n    }\n    if {[info exists find_dirn]} {\n        run findmore\n    }\n    return 1\n}\n\nproc doesmatch {f} {\n    global findtype findpattern\n\n    if {$findtype eq [mc \"Regexp\"]} {\n        return [regexp $findpattern $f]\n    } elseif {$findtype eq [mc \"IgnCase\"]} {\n        return [string match -nocase $findpattern $f]\n    } else {\n        return [string match $findpattern $f]\n    }\n}\n\nproc askfindhighlight {row id} {\n    global nhighlights commitinfo iddrawn\n    global findloc\n    global markingmatches\n\n    if {![info exists commitinfo($id)]} {\n        getcommit $id\n    }\n    set info $commitinfo($id)\n    set isbold 0\n    set fldtypes [list [mc Headline] [mc Author] \"\" [mc Committer] \"\" [mc Comments]]\n    foreach f $info ty $fldtypes {\n        if {$ty eq \"\"} continue\n        if {($findloc eq [mc \"All fields\"] || $findloc eq $ty) &&\n            [doesmatch $f]} {\n            if {$ty eq [mc \"Author\"]} {\n                set isbold 2\n                break\n            }\n            set isbold 1\n        }\n    }\n    if {$isbold && [info exists iddrawn($id)]} {\n        if {![ishighlighted $id]} {\n            bolden $id mainfontbold\n            if {$isbold > 1} {\n                bolden_name $id mainfontbold\n            }\n        }\n        if {$markingmatches} {\n            markrowmatches $row $id\n        }\n    }\n    set nhighlights($id) $isbold\n}\n\nproc markrowmatches {row id} {\n    global canv canv2 linehtag linentag commitinfo findloc\n\n    set headline [lindex $commitinfo($id) 0]\n    set author [lindex $commitinfo($id) 1]\n    $canv delete match$row\n    $canv2 delete match$row\n    if {$findloc eq [mc \"All fields\"] || $findloc eq [mc \"Headline\"]} {\n        set m [findmatches $headline]\n        if {$m ne {}} {\n            markmatches $canv $row $headline $linehtag($id) $m \\\n                [$canv itemcget $linehtag($id) -font] $row\n        }\n    }\n    if {$findloc eq [mc \"All fields\"] || $findloc eq [mc \"Author\"]} {\n        set m [findmatches $author]\n        if {$m ne {}} {\n            markmatches $canv2 $row $author $linentag($id) $m \\\n                [$canv2 itemcget $linentag($id) -font] $row\n        }\n    }\n}\n\nproc vrel_change {name ix op} {\n    global highlight_related\n\n    rhighlight_none\n    if {$highlight_related ne [mc \"None\"]} {\n        run drawvisible\n    }\n}\n\n# prepare for testing whether commits are descendents or ancestors of a\nproc rhighlight_sel {a} {\n    global descendent desc_todo ancestor anc_todo\n    global highlight_related\n\n    unset -nocomplain descendent\n    set desc_todo [list $a]\n    unset -nocomplain ancestor\n    set anc_todo [list $a]\n    if {$highlight_related ne [mc \"None\"]} {\n        rhighlight_none\n        run drawvisible\n    }\n}\n\nproc rhighlight_none {} {\n    global rhighlights\n\n    unset -nocomplain rhighlights\n    unbolden\n}\n\nproc is_descendent {a} {\n    global curview children descendent desc_todo\n\n    set v $curview\n    set la [rowofcommit $a]\n    set todo $desc_todo\n    set leftover {}\n    set done 0\n    for {set i 0} {$i < [llength $todo]} {incr i} {\n        set do [lindex $todo $i]\n        if {[rowofcommit $do] < $la} {\n            lappend leftover $do\n            continue\n        }\n        foreach nk $children($v,$do) {\n            if {![info exists descendent($nk)]} {\n                set descendent($nk) 1\n                lappend todo $nk\n                if {$nk eq $a} {\n                    set done 1\n                }\n            }\n        }\n        if {$done} {\n            set desc_todo [concat $leftover [lrange $todo [expr {$i+1}] end]]\n            return\n        }\n    }\n    set descendent($a) 0\n    set desc_todo $leftover\n}\n\nproc is_ancestor {a} {\n    global curview parents ancestor anc_todo\n\n    set v $curview\n    set la [rowofcommit $a]\n    set todo $anc_todo\n    set leftover {}\n    set done 0\n    for {set i 0} {$i < [llength $todo]} {incr i} {\n        set do [lindex $todo $i]\n        if {![commitinview $do $v] || [rowofcommit $do] > $la} {\n            lappend leftover $do\n            continue\n        }\n        foreach np $parents($v,$do) {\n            if {![info exists ancestor($np)]} {\n                set ancestor($np) 1\n                lappend todo $np\n                if {$np eq $a} {\n                    set done 1\n                }\n            }\n        }\n        if {$done} {\n            set anc_todo [concat $leftover [lrange $todo [expr {$i+1}] end]]\n            return\n        }\n    }\n    set ancestor($a) 0\n    set anc_todo $leftover\n}\n\nproc askrelhighlight {row id} {\n    global descendent highlight_related iddrawn rhighlights\n    global selectedline ancestor\n\n    if {$selectedline eq {}} return\n    set isbold 0\n    if {$highlight_related eq [mc \"Descendant\"] ||\n        $highlight_related eq [mc \"Not descendant\"]} {\n        if {![info exists descendent($id)]} {\n            is_descendent $id\n        }\n        if {$descendent($id) == ($highlight_related eq [mc \"Descendant\"])} {\n            set isbold 1\n        }\n    } elseif {$highlight_related eq [mc \"Ancestor\"] ||\n              $highlight_related eq [mc \"Not ancestor\"]} {\n        if {![info exists ancestor($id)]} {\n            is_ancestor $id\n        }\n        if {$ancestor($id) == ($highlight_related eq [mc \"Ancestor\"])} {\n            set isbold 1\n        }\n    }\n    if {[info exists iddrawn($id)]} {\n        if {$isbold && ![ishighlighted $id]} {\n            bolden $id mainfontbold\n        }\n    }\n    set rhighlights($id) $isbold\n}\n\n# Graph layout functions\n\nproc shortids {ids} {\n    set res {}\n    foreach id $ids {\n        if {[llength $id] > 1} {\n            lappend res [shortids $id]\n        } elseif {[regexp {^[0-9a-f]{40}$} $id]} {\n            lappend res [string range $id 0 7]\n        } else {\n            lappend res $id\n        }\n    }\n    return $res\n}\n\nproc ntimes {n o} {\n    set ret {}\n    set o [list $o]\n    for {set mask 1} {$mask <= $n} {incr mask $mask} {\n        if {($n & $mask) != 0} {\n            set ret [concat $ret $o]\n        }\n        set o [concat $o $o]\n    }\n    return $ret\n}\n\nproc ordertoken {id} {\n    global ordertok curview varcid varcstart varctok curview parents children\n    global nullid nullid2\n\n    if {[info exists ordertok($id)]} {\n        return $ordertok($id)\n    }\n    set origid $id\n    set todo {}\n    while {1} {\n        if {[info exists varcid($curview,$id)]} {\n            set a $varcid($curview,$id)\n            set p [lindex $varcstart($curview) $a]\n        } else {\n            set p [lindex $children($curview,$id) 0]\n        }\n        if {[info exists ordertok($p)]} {\n            set tok $ordertok($p)\n            break\n        }\n        set id [first_real_child $curview,$p]\n        if {$id eq {}} {\n            # it's a root\n            set tok [lindex $varctok($curview) $varcid($curview,$p)]\n            break\n        }\n        if {[llength $parents($curview,$id)] == 1} {\n            lappend todo [list $p {}]\n        } else {\n            set j [lsearch -exact $parents($curview,$id) $p]\n            if {$j < 0} {\n                puts \"oops didn't find [shortids $p] in parents of [shortids $id]\"\n            }\n            lappend todo [list $p [strrep $j]]\n        }\n    }\n    for {set i [llength $todo]} {[incr i -1] >= 0} {} {\n        set p [lindex $todo $i 0]\n        append tok [lindex $todo $i 1]\n        set ordertok($p) $tok\n    }\n    set ordertok($origid) $tok\n    return $tok\n}\n\n# Work out where id should go in idlist so that order-token\n# values increase from left to right\nproc idcol {idlist id {i 0}} {\n    set t [ordertoken $id]\n    if {$i < 0} {\n        set i 0\n    }\n    if {$i >= [llength $idlist] || $t < [ordertoken [lindex $idlist $i]]} {\n        if {$i > [llength $idlist]} {\n            set i [llength $idlist]\n        }\n        while {[incr i -1] >= 0 && $t < [ordertoken [lindex $idlist $i]]} {}\n        incr i\n    } else {\n        if {$t > [ordertoken [lindex $idlist $i]]} {\n            while {[incr i] < [llength $idlist] &&\n                   $t >= [ordertoken [lindex $idlist $i]]} {}\n        }\n    }\n    return $i\n}\n\nproc initlayout {} {\n    global rowidlist rowisopt rowfinal displayorder parentlist\n    global numcommits canvxmax canv\n    global nextcolor\n    global colormap rowtextx\n\n    set numcommits 0\n    set displayorder {}\n    set parentlist {}\n    set nextcolor 0\n    set rowidlist {}\n    set rowisopt {}\n    set rowfinal {}\n    set canvxmax [$canv cget -width]\n    unset -nocomplain colormap\n    unset -nocomplain rowtextx\n    setcanvscroll\n}\n\nproc setcanvscroll {} {\n    global canv canv2 canv3 numcommits linespc canvxmax canvy0\n    global lastscrollset lastscrollrows\n\n    set ymax [expr {$canvy0 + ($numcommits - 0.5) * $linespc + 2}]\n    $canv conf -scrollregion [list 0 0 $canvxmax $ymax]\n    $canv2 conf -scrollregion [list 0 0 0 $ymax]\n    $canv3 conf -scrollregion [list 0 0 0 $ymax]\n    set lastscrollset [clock clicks -milliseconds]\n    set lastscrollrows $numcommits\n}\n\nproc visiblerows {} {\n    global canv numcommits linespc\n\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax eq {} || $ymax == 0} return\n    set f [$canv yview]\n    set y0 [expr {int([lindex $f 0] * $ymax)}]\n    set r0 [expr {int(($y0 - 3) / $linespc) - 1}]\n    if {$r0 < 0} {\n        set r0 0\n    }\n    set y1 [expr {int([lindex $f 1] * $ymax)}]\n    set r1 [expr {int(($y1 - 3) / $linespc) + 1}]\n    if {$r1 >= $numcommits} {\n        set r1 [expr {$numcommits - 1}]\n    }\n    return [list $r0 $r1]\n}\n\nproc layoutmore {} {\n    global commitidx viewcomplete curview\n    global numcommits pending_select curview\n    global lastscrollset lastscrollrows\n\n    if {$lastscrollrows < 100 || $viewcomplete($curview) ||\n        [clock clicks -milliseconds] - $lastscrollset > 500} {\n        setcanvscroll\n    }\n    if {[info exists pending_select] &&\n        [commitinview $pending_select $curview]} {\n        update\n        selectline [rowofcommit $pending_select] 1\n    }\n    drawvisible\n}\n\n# With path limiting, we mightn't get the actual HEAD commit,\n# so ask git rev-list what is the first ancestor of HEAD that\n# touches a file in the path limit.\nproc get_viewmainhead {view} {\n    global viewmainheadid vfilelimit viewinstances mainheadid\n\n    catch {\n        set rfd [open [concat | git rev-list -1 $mainheadid \\\n                           -- $vfilelimit($view)] r]\n        set j [reg_instance $rfd]\n        lappend viewinstances($view) $j\n        fconfigure $rfd -blocking 0\n        filerun $rfd [list getviewhead $rfd $j $view]\n        set viewmainheadid($curview) {}\n    }\n}\n\n# git rev-list should give us just 1 line to use as viewmainheadid($view)\nproc getviewhead {fd inst view} {\n    global viewmainheadid commfd curview viewinstances showlocalchanges\n\n    set id {}\n    if {[gets $fd line] < 0} {\n        if {![eof $fd]} {\n            return 1\n        }\n    } elseif {[string length $line] == 40 && [string is xdigit $line]} {\n        set id $line\n    }\n    set viewmainheadid($view) $id\n    close $fd\n    unset commfd($inst)\n    set i [lsearch -exact $viewinstances($view) $inst]\n    if {$i >= 0} {\n        set viewinstances($view) [lreplace $viewinstances($view) $i $i]\n    }\n    if {$showlocalchanges && $id ne {} && $view == $curview} {\n        doshowlocalchanges\n    }\n    return 0\n}\n\nproc doshowlocalchanges {} {\n    global curview viewmainheadid\n\n    if {$viewmainheadid($curview) eq {}} return\n    if {[commitinview $viewmainheadid($curview) $curview]} {\n        dodiffindex\n    } else {\n        interestedin $viewmainheadid($curview) dodiffindex\n    }\n}\n\nproc dohidelocalchanges {} {\n    global nullid nullid2 lserial curview\n\n    if {[commitinview $nullid $curview]} {\n        removefakerow $nullid\n    }\n    if {[commitinview $nullid2 $curview]} {\n        removefakerow $nullid2\n    }\n    incr lserial\n}\n\n# spawn off a process to do git diff-index --cached HEAD\nproc dodiffindex {} {\n    global lserial showlocalchanges vfilelimit curview\n    global hasworktree git_version\n\n    if {!$showlocalchanges || !$hasworktree} return\n    incr lserial\n    if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n        set cmd \"|git diff-index --cached --ignore-submodules=dirty HEAD\"\n    } else {\n        set cmd \"|git diff-index --cached HEAD\"\n    }\n    if {$vfilelimit($curview) ne {}} {\n        set cmd [concat $cmd -- $vfilelimit($curview)]\n    }\n    set fd [open $cmd r]\n    fconfigure $fd -blocking 0\n    set i [reg_instance $fd]\n    filerun $fd [list readdiffindex $fd $lserial $i]\n}\n\nproc readdiffindex {fd serial inst} {\n    global viewmainheadid nullid nullid2 curview commitinfo commitdata lserial\n    global vfilelimit\n\n    set isdiff 1\n    if {[gets $fd line] < 0} {\n        if {![eof $fd]} {\n            return 1\n        }\n        set isdiff 0\n    }\n    # we only need to see one line and we don't really care what it says...\n    stop_instance $inst\n\n    if {$serial != $lserial} {\n        return 0\n    }\n\n    # now see if there are any local changes not checked in to the index\n    set cmd \"|git diff-files\"\n    if {$vfilelimit($curview) ne {}} {\n        set cmd [concat $cmd -- $vfilelimit($curview)]\n    }\n    set fd [open $cmd r]\n    fconfigure $fd -blocking 0\n    set i [reg_instance $fd]\n    filerun $fd [list readdifffiles $fd $serial $i]\n\n    if {$isdiff && ![commitinview $nullid2 $curview]} {\n        # add the line for the changes in the index to the graph\n        set hl [mc \"Local changes checked in to index but not committed\"]\n        set commitinfo($nullid2) [list  $hl {} {} {} {} \"    $hl\\n\"]\n        set commitdata($nullid2) \"\\n    $hl\\n\"\n        if {[commitinview $nullid $curview]} {\n            removefakerow $nullid\n        }\n        insertfakerow $nullid2 $viewmainheadid($curview)\n    } elseif {!$isdiff && [commitinview $nullid2 $curview]} {\n        if {[commitinview $nullid $curview]} {\n            removefakerow $nullid\n        }\n        removefakerow $nullid2\n    }\n    return 0\n}\n\nproc readdifffiles {fd serial inst} {\n    global viewmainheadid nullid nullid2 curview\n    global commitinfo commitdata lserial\n\n    set isdiff 1\n    if {[gets $fd line] < 0} {\n        if {![eof $fd]} {\n            return 1\n        }\n        set isdiff 0\n    }\n    # we only need to see one line and we don't really care what it says...\n    stop_instance $inst\n\n    if {$serial != $lserial} {\n        return 0\n    }\n\n    if {$isdiff && ![commitinview $nullid $curview]} {\n        # add the line for the local diff to the graph\n        set hl [mc \"Local uncommitted changes, not checked in to index\"]\n        set commitinfo($nullid) [list  $hl {} {} {} {} \"    $hl\\n\"]\n        set commitdata($nullid) \"\\n    $hl\\n\"\n        if {[commitinview $nullid2 $curview]} {\n            set p $nullid2\n        } else {\n            set p $viewmainheadid($curview)\n        }\n        insertfakerow $nullid $p\n    } elseif {!$isdiff && [commitinview $nullid $curview]} {\n        removefakerow $nullid\n    }\n    return 0\n}\n\nproc nextuse {id row} {\n    global curview children\n\n    if {[info exists children($curview,$id)]} {\n        foreach kid $children($curview,$id) {\n            if {![commitinview $kid $curview]} {\n                return -1\n            }\n            if {[rowofcommit $kid] > $row} {\n                return [rowofcommit $kid]\n            }\n        }\n    }\n    if {[commitinview $id $curview]} {\n        return [rowofcommit $id]\n    }\n    return -1\n}\n\nproc prevuse {id row} {\n    global curview children\n\n    set ret -1\n    if {[info exists children($curview,$id)]} {\n        foreach kid $children($curview,$id) {\n            if {![commitinview $kid $curview]} break\n            if {[rowofcommit $kid] < $row} {\n                set ret [rowofcommit $kid]\n            }\n        }\n    }\n    return $ret\n}\n\nproc make_idlist {row} {\n    global displayorder parentlist uparrowlen downarrowlen mingaplen\n    global commitidx curview children\n\n    set r [expr {$row - $mingaplen - $downarrowlen - 1}]\n    if {$r < 0} {\n        set r 0\n    }\n    set ra [expr {$row - $downarrowlen}]\n    if {$ra < 0} {\n        set ra 0\n    }\n    set rb [expr {$row + $uparrowlen}]\n    if {$rb > $commitidx($curview)} {\n        set rb $commitidx($curview)\n    }\n    make_disporder $r [expr {$rb + 1}]\n    set ids {}\n    for {} {$r < $ra} {incr r} {\n        set nextid [lindex $displayorder [expr {$r + 1}]]\n        foreach p [lindex $parentlist $r] {\n            if {$p eq $nextid} continue\n            set rn [nextuse $p $r]\n            if {$rn >= $row &&\n                $rn <= $r + $downarrowlen + $mingaplen + $uparrowlen} {\n                lappend ids [list [ordertoken $p] $p]\n            }\n        }\n    }\n    for {} {$r < $row} {incr r} {\n        set nextid [lindex $displayorder [expr {$r + 1}]]\n        foreach p [lindex $parentlist $r] {\n            if {$p eq $nextid} continue\n            set rn [nextuse $p $r]\n            if {$rn < 0 || $rn >= $row} {\n                lappend ids [list [ordertoken $p] $p]\n            }\n        }\n    }\n    set id [lindex $displayorder $row]\n    lappend ids [list [ordertoken $id] $id]\n    while {$r < $rb} {\n        foreach p [lindex $parentlist $r] {\n            set firstkid [lindex $children($curview,$p) 0]\n            if {[rowofcommit $firstkid] < $row} {\n                lappend ids [list [ordertoken $p] $p]\n            }\n        }\n        incr r\n        set id [lindex $displayorder $r]\n        if {$id ne {}} {\n            set firstkid [lindex $children($curview,$id) 0]\n            if {$firstkid ne {} && [rowofcommit $firstkid] < $row} {\n                lappend ids [list [ordertoken $id] $id]\n            }\n        }\n    }\n    set idlist {}\n    foreach idx [lsort -unique $ids] {\n        lappend idlist [lindex $idx 1]\n    }\n    return $idlist\n}\n\nproc rowsequal {a b} {\n    while {[set i [lsearch -exact $a {}]] >= 0} {\n        set a [lreplace $a $i $i]\n    }\n    while {[set i [lsearch -exact $b {}]] >= 0} {\n        set b [lreplace $b $i $i]\n    }\n    return [expr {$a eq $b}]\n}\n\nproc makeupline {id row rend col} {\n    global rowidlist uparrowlen downarrowlen mingaplen\n\n    for {set r $rend} {1} {set r $rstart} {\n        set rstart [prevuse $id $r]\n        if {$rstart < 0} return\n        if {$rstart < $row} break\n    }\n    if {$rstart + $uparrowlen + $mingaplen + $downarrowlen < $rend} {\n        set rstart [expr {$rend - $uparrowlen - 1}]\n    }\n    for {set r $rstart} {[incr r] <= $row} {} {\n        set idlist [lindex $rowidlist $r]\n        if {$idlist ne {} && [lsearch -exact $idlist $id] < 0} {\n            set col [idcol $idlist $id $col]\n            lset rowidlist $r [linsert $idlist $col $id]\n            changedrow $r\n        }\n    }\n}\n\nproc layoutrows {row endrow} {\n    global rowidlist rowisopt rowfinal displayorder\n    global uparrowlen downarrowlen maxwidth mingaplen\n    global children parentlist\n    global commitidx viewcomplete curview\n\n    make_disporder [expr {$row - 1}] [expr {$endrow + $uparrowlen}]\n    set idlist {}\n    if {$row > 0} {\n        set rm1 [expr {$row - 1}]\n        foreach id [lindex $rowidlist $rm1] {\n            if {$id ne {}} {\n                lappend idlist $id\n            }\n        }\n        set final [lindex $rowfinal $rm1]\n    }\n    for {} {$row < $endrow} {incr row} {\n        set rm1 [expr {$row - 1}]\n        if {$rm1 < 0 || $idlist eq {}} {\n            set idlist [make_idlist $row]\n            set final 1\n        } else {\n            set id [lindex $displayorder $rm1]\n            set col [lsearch -exact $idlist $id]\n            set idlist [lreplace $idlist $col $col]\n            foreach p [lindex $parentlist $rm1] {\n                if {[lsearch -exact $idlist $p] < 0} {\n                    set col [idcol $idlist $p $col]\n                    set idlist [linsert $idlist $col $p]\n                    # if not the first child, we have to insert a line going up\n                    if {$id ne [lindex $children($curview,$p) 0]} {\n                        makeupline $p $rm1 $row $col\n                    }\n                }\n            }\n            set id [lindex $displayorder $row]\n            if {$row > $downarrowlen} {\n                set termrow [expr {$row - $downarrowlen - 1}]\n                foreach p [lindex $parentlist $termrow] {\n                    set i [lsearch -exact $idlist $p]\n                    if {$i < 0} continue\n                    set nr [nextuse $p $termrow]\n                    if {$nr < 0 || $nr >= $row + $mingaplen + $uparrowlen} {\n                        set idlist [lreplace $idlist $i $i]\n                    }\n                }\n            }\n            set col [lsearch -exact $idlist $id]\n            if {$col < 0} {\n                set col [idcol $idlist $id]\n                set idlist [linsert $idlist $col $id]\n                if {$children($curview,$id) ne {}} {\n                    makeupline $id $rm1 $row $col\n                }\n            }\n            set r [expr {$row + $uparrowlen - 1}]\n            if {$r < $commitidx($curview)} {\n                set x $col\n                foreach p [lindex $parentlist $r] {\n                    if {[lsearch -exact $idlist $p] >= 0} continue\n                    set fk [lindex $children($curview,$p) 0]\n                    if {[rowofcommit $fk] < $row} {\n                        set x [idcol $idlist $p $x]\n                        set idlist [linsert $idlist $x $p]\n                    }\n                }\n                if {[incr r] < $commitidx($curview)} {\n                    set p [lindex $displayorder $r]\n                    if {[lsearch -exact $idlist $p] < 0} {\n                        set fk [lindex $children($curview,$p) 0]\n                        if {$fk ne {} && [rowofcommit $fk] < $row} {\n                            set x [idcol $idlist $p $x]\n                            set idlist [linsert $idlist $x $p]\n                        }\n                    }\n                }\n            }\n        }\n        if {$final && !$viewcomplete($curview) &&\n            $row + $uparrowlen + $mingaplen + $downarrowlen\n                >= $commitidx($curview)} {\n            set final 0\n        }\n        set l [llength $rowidlist]\n        if {$row == $l} {\n            lappend rowidlist $idlist\n            lappend rowisopt 0\n            lappend rowfinal $final\n        } elseif {$row < $l} {\n            if {![rowsequal $idlist [lindex $rowidlist $row]]} {\n                lset rowidlist $row $idlist\n                changedrow $row\n            }\n            lset rowfinal $row $final\n        } else {\n            set pad [ntimes [expr {$row - $l}] {}]\n            set rowidlist [concat $rowidlist $pad]\n            lappend rowidlist $idlist\n            set rowfinal [concat $rowfinal $pad]\n            lappend rowfinal $final\n            set rowisopt [concat $rowisopt [ntimes [expr {$row - $l + 1}] 0]]\n        }\n    }\n    return $row\n}\n\nproc changedrow {row} {\n    global displayorder iddrawn rowisopt need_redisplay\n\n    set l [llength $rowisopt]\n    if {$row < $l} {\n        lset rowisopt $row 0\n        if {$row + 1 < $l} {\n            lset rowisopt [expr {$row + 1}] 0\n            if {$row + 2 < $l} {\n                lset rowisopt [expr {$row + 2}] 0\n            }\n        }\n    }\n    set id [lindex $displayorder $row]\n    if {[info exists iddrawn($id)]} {\n        set need_redisplay 1\n    }\n}\n\nproc insert_pad {row col npad} {\n    global rowidlist\n\n    set pad [ntimes $npad {}]\n    set idlist [lindex $rowidlist $row]\n    set bef [lrange $idlist 0 [expr {$col - 1}]]\n    set aft [lrange $idlist $col end]\n    set i [lsearch -exact $aft {}]\n    if {$i > 0} {\n        set aft [lreplace $aft $i $i]\n    }\n    lset rowidlist $row [concat $bef $pad $aft]\n    changedrow $row\n}\n\nproc optimize_rows {row col endrow} {\n    global rowidlist rowisopt displayorder curview children\n\n    if {$row < 1} {\n        set row 1\n    }\n    for {} {$row < $endrow} {incr row; set col 0} {\n        if {[lindex $rowisopt $row]} continue\n        set haspad 0\n        set y0 [expr {$row - 1}]\n        set ym [expr {$row - 2}]\n        set idlist [lindex $rowidlist $row]\n        set previdlist [lindex $rowidlist $y0]\n        if {$idlist eq {} || $previdlist eq {}} continue\n        if {$ym >= 0} {\n            set pprevidlist [lindex $rowidlist $ym]\n            if {$pprevidlist eq {}} continue\n        } else {\n            set pprevidlist {}\n        }\n        set x0 -1\n        set xm -1\n        for {} {$col < [llength $idlist]} {incr col} {\n            set id [lindex $idlist $col]\n            if {[lindex $previdlist $col] eq $id} continue\n            if {$id eq {}} {\n                set haspad 1\n                continue\n            }\n            set x0 [lsearch -exact $previdlist $id]\n            if {$x0 < 0} continue\n            set z [expr {$x0 - $col}]\n            set isarrow 0\n            set z0 {}\n            if {$ym >= 0} {\n                set xm [lsearch -exact $pprevidlist $id]\n                if {$xm >= 0} {\n                    set z0 [expr {$xm - $x0}]\n                }\n            }\n            if {$z0 eq {}} {\n                # if row y0 is the first child of $id then it's not an arrow\n                if {[lindex $children($curview,$id) 0] ne\n                    [lindex $displayorder $y0]} {\n                    set isarrow 1\n                }\n            }\n            if {!$isarrow && $id ne [lindex $displayorder $row] &&\n                [lsearch -exact [lindex $rowidlist [expr {$row+1}]] $id] < 0} {\n                set isarrow 1\n            }\n            # Looking at lines from this row to the previous row,\n            # make them go straight up if they end in an arrow on\n            # the previous row; otherwise make them go straight up\n            # or at 45 degrees.\n            if {$z < -1 || ($z < 0 && $isarrow)} {\n                # Line currently goes left too much;\n                # insert pads in the previous row, then optimize it\n                set npad [expr {-1 - $z + $isarrow}]\n                insert_pad $y0 $x0 $npad\n                if {$y0 > 0} {\n                    optimize_rows $y0 $x0 $row\n                }\n                set previdlist [lindex $rowidlist $y0]\n                set x0 [lsearch -exact $previdlist $id]\n                set z [expr {$x0 - $col}]\n                if {$z0 ne {}} {\n                    set pprevidlist [lindex $rowidlist $ym]\n                    set xm [lsearch -exact $pprevidlist $id]\n                    set z0 [expr {$xm - $x0}]\n                }\n            } elseif {$z > 1 || ($z > 0 && $isarrow)} {\n                # Line currently goes right too much;\n                # insert pads in this line\n                set npad [expr {$z - 1 + $isarrow}]\n                insert_pad $row $col $npad\n                set idlist [lindex $rowidlist $row]\n                incr col $npad\n                set z [expr {$x0 - $col}]\n                set haspad 1\n            }\n            if {$z0 eq {} && !$isarrow && $ym >= 0} {\n                # this line links to its first child on row $row-2\n                set id [lindex $displayorder $ym]\n                set xc [lsearch -exact $pprevidlist $id]\n                if {$xc >= 0} {\n                    set z0 [expr {$xc - $x0}]\n                }\n            }\n            # avoid lines jigging left then immediately right\n            if {$z0 ne {} && $z < 0 && $z0 > 0} {\n                insert_pad $y0 $x0 1\n                incr x0\n                optimize_rows $y0 $x0 $row\n                set previdlist [lindex $rowidlist $y0]\n            }\n        }\n        if {!$haspad} {\n            # Find the first column that doesn't have a line going right\n            for {set col [llength $idlist]} {[incr col -1] >= 0} {} {\n                set id [lindex $idlist $col]\n                if {$id eq {}} break\n                set x0 [lsearch -exact $previdlist $id]\n                if {$x0 < 0} {\n                    # check if this is the link to the first child\n                    set kid [lindex $displayorder $y0]\n                    if {[lindex $children($curview,$id) 0] eq $kid} {\n                        # it is, work out offset to child\n                        set x0 [lsearch -exact $previdlist $kid]\n                    }\n                }\n                if {$x0 <= $col} break\n            }\n            # Insert a pad at that column as long as it has a line and\n            # isn't the last column\n            if {$x0 >= 0 && [incr col] < [llength $idlist]} {\n                set idlist [linsert $idlist $col {}]\n                lset rowidlist $row $idlist\n                changedrow $row\n            }\n        }\n    }\n}\n\nproc xc {row col} {\n    global canvx0 linespc\n    return [expr {$canvx0 + $col * $linespc}]\n}\n\nproc yc {row} {\n    global canvy0 linespc\n    return [expr {$canvy0 + $row * $linespc}]\n}\n\nproc linewidth {id} {\n    global thickerline lthickness\n\n    set wid $lthickness\n    if {[info exists thickerline] && $id eq $thickerline} {\n        set wid [expr {2 * $lthickness}]\n    }\n    return $wid\n}\n\nproc rowranges {id} {\n    global curview children uparrowlen downarrowlen\n    global rowidlist\n\n    set kids $children($curview,$id)\n    if {$kids eq {}} {\n        return {}\n    }\n    set ret {}\n    lappend kids $id\n    foreach child $kids {\n        if {![commitinview $child $curview]} break\n        set row [rowofcommit $child]\n        if {![info exists prev]} {\n            lappend ret [expr {$row + 1}]\n        } else {\n            if {$row <= $prevrow} {\n                puts \"oops children of [shortids $id] out of order [shortids $child] $row <= [shortids $prev] $prevrow\"\n            }\n            # see if the line extends the whole way from prevrow to row\n            if {$row > $prevrow + $uparrowlen + $downarrowlen &&\n                [lsearch -exact [lindex $rowidlist \\\n                            [expr {int(($row + $prevrow) / 2)}]] $id] < 0} {\n                # it doesn't, see where it ends\n                set r [expr {$prevrow + $downarrowlen}]\n                if {[lsearch -exact [lindex $rowidlist $r] $id] < 0} {\n                    while {[incr r -1] > $prevrow &&\n                           [lsearch -exact [lindex $rowidlist $r] $id] < 0} {}\n                } else {\n                    while {[incr r] <= $row &&\n                           [lsearch -exact [lindex $rowidlist $r] $id] >= 0} {}\n                    incr r -1\n                }\n                lappend ret $r\n                # see where it starts up again\n                set r [expr {$row - $uparrowlen}]\n                if {[lsearch -exact [lindex $rowidlist $r] $id] < 0} {\n                    while {[incr r] < $row &&\n                           [lsearch -exact [lindex $rowidlist $r] $id] < 0} {}\n                } else {\n                    while {[incr r -1] >= $prevrow &&\n                           [lsearch -exact [lindex $rowidlist $r] $id] >= 0} {}\n                    incr r\n                }\n                lappend ret $r\n            }\n        }\n        if {$child eq $id} {\n            lappend ret $row\n        }\n        set prev $child\n        set prevrow $row\n    }\n    return $ret\n}\n\nproc drawlineseg {id row endrow arrowlow} {\n    global rowidlist displayorder iddrawn linesegs\n    global canv colormap linespc curview maxlinelen parentlist\n\n    set cols [list [lsearch -exact [lindex $rowidlist $row] $id]]\n    set le [expr {$row + 1}]\n    set arrowhigh 1\n    while {1} {\n        set c [lsearch -exact [lindex $rowidlist $le] $id]\n        if {$c < 0} {\n            incr le -1\n            break\n        }\n        lappend cols $c\n        set x [lindex $displayorder $le]\n        if {$x eq $id} {\n            set arrowhigh 0\n            break\n        }\n        if {[info exists iddrawn($x)] || $le == $endrow} {\n            set c [lsearch -exact [lindex $rowidlist [expr {$le+1}]] $id]\n            if {$c >= 0} {\n                lappend cols $c\n                set arrowhigh 0\n            }\n            break\n        }\n        incr le\n    }\n    if {$le <= $row} {\n        return $row\n    }\n\n    set lines {}\n    set i 0\n    set joinhigh 0\n    if {[info exists linesegs($id)]} {\n        set lines $linesegs($id)\n        foreach li $lines {\n            set r0 [lindex $li 0]\n            if {$r0 > $row} {\n                if {$r0 == $le && [lindex $li 1] - $row <= $maxlinelen} {\n                    set joinhigh 1\n                }\n                break\n            }\n            incr i\n        }\n    }\n    set joinlow 0\n    if {$i > 0} {\n        set li [lindex $lines [expr {$i-1}]]\n        set r1 [lindex $li 1]\n        if {$r1 == $row && $le - [lindex $li 0] <= $maxlinelen} {\n            set joinlow 1\n        }\n    }\n\n    set x [lindex $cols [expr {$le - $row}]]\n    set xp [lindex $cols [expr {$le - 1 - $row}]]\n    set dir [expr {$xp - $x}]\n    if {$joinhigh} {\n        set ith [lindex $lines $i 2]\n        set coords [$canv coords $ith]\n        set ah [$canv itemcget $ith -arrow]\n        set arrowhigh [expr {$ah eq \"first\" || $ah eq \"both\"}]\n        set x2 [lindex $cols [expr {$le + 1 - $row}]]\n        if {$x2 ne {} && $x - $x2 == $dir} {\n            set coords [lrange $coords 0 end-2]\n        }\n    } else {\n        set coords [list [xc $le $x] [yc $le]]\n    }\n    if {$joinlow} {\n        set itl [lindex $lines [expr {$i-1}] 2]\n        set al [$canv itemcget $itl -arrow]\n        set arrowlow [expr {$al eq \"last\" || $al eq \"both\"}]\n    } elseif {$arrowlow} {\n        if {[lsearch -exact [lindex $rowidlist [expr {$row-1}]] $id] >= 0 ||\n            [lsearch -exact [lindex $parentlist [expr {$row-1}]] $id] >= 0} {\n            set arrowlow 0\n        }\n    }\n    set arrow [lindex {none first last both} [expr {$arrowhigh + 2*$arrowlow}]]\n    for {set y $le} {[incr y -1] > $row} {} {\n        set x $xp\n        set xp [lindex $cols [expr {$y - 1 - $row}]]\n        set ndir [expr {$xp - $x}]\n        if {$dir != $ndir || $xp < 0} {\n            lappend coords [xc $y $x] [yc $y]\n        }\n        set dir $ndir\n    }\n    if {!$joinlow} {\n        if {$xp < 0} {\n            # join parent line to first child\n            set ch [lindex $displayorder $row]\n            set xc [lsearch -exact [lindex $rowidlist $row] $ch]\n            if {$xc < 0} {\n                puts \"oops: drawlineseg: child $ch not on row $row\"\n            } elseif {$xc != $x} {\n                if {($arrowhigh && $le == $row + 1) || $dir == 0} {\n                    set d [expr {int(0.5 * $linespc)}]\n                    set x1 [xc $row $x]\n                    if {$xc < $x} {\n                        set x2 [expr {$x1 - $d}]\n                    } else {\n                        set x2 [expr {$x1 + $d}]\n                    }\n                    set y2 [yc $row]\n                    set y1 [expr {$y2 + $d}]\n                    lappend coords $x1 $y1 $x2 $y2\n                } elseif {$xc < $x - 1} {\n                    lappend coords [xc $row [expr {$x-1}]] [yc $row]\n                } elseif {$xc > $x + 1} {\n                    lappend coords [xc $row [expr {$x+1}]] [yc $row]\n                }\n                set x $xc\n            }\n            lappend coords [xc $row $x] [yc $row]\n        } else {\n            set xn [xc $row $xp]\n            set yn [yc $row]\n            lappend coords $xn $yn\n        }\n        if {!$joinhigh} {\n            assigncolor $id\n            set t [$canv create line $coords -width [linewidth $id] \\\n                       -fill $colormap($id) -tags lines.$id -arrow $arrow]\n            $canv lower $t\n            bindline $t $id\n            set lines [linsert $lines $i [list $row $le $t]]\n        } else {\n            $canv coords $ith $coords\n            if {$arrow ne $ah} {\n                $canv itemconf $ith -arrow $arrow\n            }\n            lset lines $i 0 $row\n        }\n    } else {\n        set xo [lsearch -exact [lindex $rowidlist [expr {$row - 1}]] $id]\n        set ndir [expr {$xo - $xp}]\n        set clow [$canv coords $itl]\n        if {$dir == $ndir} {\n            set clow [lrange $clow 2 end]\n        }\n        set coords [concat $coords $clow]\n        if {!$joinhigh} {\n            lset lines [expr {$i-1}] 1 $le\n        } else {\n            # coalesce two pieces\n            $canv delete $ith\n            set b [lindex $lines [expr {$i-1}] 0]\n            set e [lindex $lines $i 1]\n            set lines [lreplace $lines [expr {$i-1}] $i [list $b $e $itl]]\n        }\n        $canv coords $itl $coords\n        if {$arrow ne $al} {\n            $canv itemconf $itl -arrow $arrow\n        }\n    }\n\n    set linesegs($id) $lines\n    return $le\n}\n\nproc drawparentlinks {id row} {\n    global rowidlist canv colormap curview parentlist\n    global idpos linespc\n\n    set rowids [lindex $rowidlist $row]\n    set col [lsearch -exact $rowids $id]\n    if {$col < 0} return\n    set olds [lindex $parentlist $row]\n    set row2 [expr {$row + 1}]\n    set x [xc $row $col]\n    set y [yc $row]\n    set y2 [yc $row2]\n    set d [expr {int(0.5 * $linespc)}]\n    set ymid [expr {$y + $d}]\n    set ids [lindex $rowidlist $row2]\n    # rmx = right-most X coord used\n    set rmx 0\n    foreach p $olds {\n        set i [lsearch -exact $ids $p]\n        if {$i < 0} {\n            puts \"oops, parent $p of $id not in list\"\n            continue\n        }\n        set x2 [xc $row2 $i]\n        if {$x2 > $rmx} {\n            set rmx $x2\n        }\n        set j [lsearch -exact $rowids $p]\n        if {$j < 0} {\n            # drawlineseg will do this one for us\n            continue\n        }\n        assigncolor $p\n        # should handle duplicated parents here...\n        set coords [list $x $y]\n        if {$i != $col} {\n            # if attaching to a vertical segment, draw a smaller\n            # slant for visual distinctness\n            if {$i == $j} {\n                if {$i < $col} {\n                    lappend coords [expr {$x2 + $d}] $y $x2 $ymid\n                } else {\n                    lappend coords [expr {$x2 - $d}] $y $x2 $ymid\n                }\n            } elseif {$i < $col && $i < $j} {\n                # segment slants towards us already\n                lappend coords [xc $row $j] $y\n            } else {\n                if {$i < $col - 1} {\n                    lappend coords [expr {$x2 + $linespc}] $y\n                } elseif {$i > $col + 1} {\n                    lappend coords [expr {$x2 - $linespc}] $y\n                }\n                lappend coords $x2 $y2\n            }\n        } else {\n            lappend coords $x2 $y2\n        }\n        set t [$canv create line $coords -width [linewidth $p] \\\n                   -fill $colormap($p) -tags lines.$p]\n        $canv lower $t\n        bindline $t $p\n    }\n    if {$rmx > [lindex $idpos($id) 1]} {\n        lset idpos($id) 1 $rmx\n        redrawtags $id\n    }\n}\n\nproc drawlines {id} {\n    global canv\n\n    $canv itemconf lines.$id -width [linewidth $id]\n}\n\nproc drawcmittext {id row col} {\n    global linespc canv canv2 canv3 fgcolor curview\n    global cmitlisted commitinfo rowidlist parentlist\n    global rowtextx idpos idtags idheads idotherrefs\n    global linehtag linentag linedtag selectedline\n    global canvxmax boldids boldnameids fgcolor markedid\n    global mainheadid nullid nullid2 circleitem circlecolors ctxbut\n    global mainheadcirclecolor workingfilescirclecolor indexcirclecolor\n    global circleoutlinecolor\n\n    # listed is 0 for boundary, 1 for normal, 2 for negative, 3 for left, 4 for right\n    set listed $cmitlisted($curview,$id)\n    if {$id eq $nullid} {\n        set ofill $workingfilescirclecolor\n    } elseif {$id eq $nullid2} {\n        set ofill $indexcirclecolor\n    } elseif {$id eq $mainheadid} {\n        set ofill $mainheadcirclecolor\n    } else {\n        set ofill [lindex $circlecolors $listed]\n    }\n    set x [xc $row $col]\n    set y [yc $row]\n    set orad [expr {$linespc / 3}]\n    if {$listed <= 2} {\n        set t [$canv create oval [expr {$x - $orad}] [expr {$y - $orad}] \\\n                   [expr {$x + $orad - 1}] [expr {$y + $orad - 1}] \\\n                   -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]\n    } elseif {$listed == 3} {\n        # triangle pointing left for left-side commits\n        set t [$canv create polygon \\\n                   [expr {$x - $orad}] $y \\\n                   [expr {$x + $orad - 1}] [expr {$y - $orad}] \\\n                   [expr {$x + $orad - 1}] [expr {$y + $orad - 1}] \\\n                   -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]\n    } else {\n        # triangle pointing right for right-side commits\n        set t [$canv create polygon \\\n                   [expr {$x + $orad - 1}] $y \\\n                   [expr {$x - $orad}] [expr {$y - $orad}] \\\n                   [expr {$x - $orad}] [expr {$y + $orad - 1}] \\\n                   -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]\n    }\n    set circleitem($row) $t\n    $canv raise $t\n    $canv bind $t <1> {selcanvline {} %x %y}\n    set rmx [llength [lindex $rowidlist $row]]\n    set olds [lindex $parentlist $row]\n    if {$olds ne {}} {\n        set nextids [lindex $rowidlist [expr {$row + 1}]]\n        foreach p $olds {\n            set i [lsearch -exact $nextids $p]\n            if {$i > $rmx} {\n                set rmx $i\n            }\n        }\n    }\n    set xt [xc $row $rmx]\n    set rowtextx($row) $xt\n    set idpos($id) [list $x $xt $y]\n    if {[info exists idtags($id)] || [info exists idheads($id)]\n        || [info exists idotherrefs($id)]} {\n        set xt [drawtags $id $x $xt $y]\n    }\n    if {[lindex $commitinfo($id) 6] > 0} {\n        set xt [drawnotesign $xt $y]\n    }\n    set headline [lindex $commitinfo($id) 0]\n    set name [lindex $commitinfo($id) 1]\n    set date [lindex $commitinfo($id) 2]\n    set date [formatdate $date]\n    set font mainfont\n    set nfont mainfont\n    set isbold [ishighlighted $id]\n    if {$isbold > 0} {\n        lappend boldids $id\n        set font mainfontbold\n        if {$isbold > 1} {\n            lappend boldnameids $id\n            set nfont mainfontbold\n        }\n    }\n    set linehtag($id) [$canv create text $xt $y -anchor w -fill $fgcolor \\\n                           -text $headline -font $font -tags text]\n    $canv bind $linehtag($id) $ctxbut \"rowmenu %X %Y $id\"\n    set linentag($id) [$canv2 create text 3 $y -anchor w -fill $fgcolor \\\n                           -text $name -font $nfont -tags text]\n    set linedtag($id) [$canv3 create text 3 $y -anchor w -fill $fgcolor \\\n                           -text $date -font mainfont -tags text]\n    if {$selectedline == $row} {\n        make_secsel $id\n    }\n    if {[info exists markedid] && $markedid eq $id} {\n        make_idmark $id\n    }\n    set xr [expr {$xt + [font measure $font $headline]}]\n    if {$xr > $canvxmax} {\n        set canvxmax $xr\n        setcanvscroll\n    }\n}\n\nproc drawcmitrow {row} {\n    global displayorder rowidlist nrows_drawn\n    global iddrawn markingmatches\n    global commitinfo numcommits\n    global filehighlight fhighlights findpattern nhighlights\n    global hlview vhighlights\n    global highlight_related rhighlights\n\n    if {$row >= $numcommits} return\n\n    set id [lindex $displayorder $row]\n    if {[info exists hlview] && ![info exists vhighlights($id)]} {\n        askvhighlight $row $id\n    }\n    if {[info exists filehighlight] && ![info exists fhighlights($id)]} {\n        askfilehighlight $row $id\n    }\n    if {$findpattern ne {} && ![info exists nhighlights($id)]} {\n        askfindhighlight $row $id\n    }\n    if {$highlight_related ne [mc \"None\"] && ![info exists rhighlights($id)]} {\n        askrelhighlight $row $id\n    }\n    if {![info exists iddrawn($id)]} {\n        set col [lsearch -exact [lindex $rowidlist $row] $id]\n        if {$col < 0} {\n            puts \"oops, row $row id $id not in list\"\n            return\n        }\n        if {![info exists commitinfo($id)]} {\n            getcommit $id\n        }\n        assigncolor $id\n        drawcmittext $id $row $col\n        set iddrawn($id) 1\n        incr nrows_drawn\n    }\n    if {$markingmatches} {\n        markrowmatches $row $id\n    }\n}\n\nproc drawcommits {row {endrow {}}} {\n    global numcommits iddrawn displayorder curview need_redisplay\n    global parentlist rowidlist rowfinal uparrowlen downarrowlen nrows_drawn\n\n    if {$row < 0} {\n        set row 0\n    }\n    if {$endrow eq {}} {\n        set endrow $row\n    }\n    if {$endrow >= $numcommits} {\n        set endrow [expr {$numcommits - 1}]\n    }\n\n    set rl1 [expr {$row - $downarrowlen - 3}]\n    if {$rl1 < 0} {\n        set rl1 0\n    }\n    set ro1 [expr {$row - 3}]\n    if {$ro1 < 0} {\n        set ro1 0\n    }\n    set r2 [expr {$endrow + $uparrowlen + 3}]\n    if {$r2 > $numcommits} {\n        set r2 $numcommits\n    }\n    for {set r $rl1} {$r < $r2} {incr r} {\n        if {[lindex $rowidlist $r] ne {} && [lindex $rowfinal $r]} {\n            if {$rl1 < $r} {\n                layoutrows $rl1 $r\n            }\n            set rl1 [expr {$r + 1}]\n        }\n    }\n    if {$rl1 < $r} {\n        layoutrows $rl1 $r\n    }\n    optimize_rows $ro1 0 $r2\n    if {$need_redisplay || $nrows_drawn > 2000} {\n        clear_display\n    }\n\n    # make the lines join to already-drawn rows either side\n    set r [expr {$row - 1}]\n    if {$r < 0 || ![info exists iddrawn([lindex $displayorder $r])]} {\n        set r $row\n    }\n    set er [expr {$endrow + 1}]\n    if {$er >= $numcommits ||\n        ![info exists iddrawn([lindex $displayorder $er])]} {\n        set er $endrow\n    }\n    for {} {$r <= $er} {incr r} {\n        set id [lindex $displayorder $r]\n        set wasdrawn [info exists iddrawn($id)]\n        drawcmitrow $r\n        if {$r == $er} break\n        set nextid [lindex $displayorder [expr {$r + 1}]]\n        if {$wasdrawn && [info exists iddrawn($nextid)]} continue\n        drawparentlinks $id $r\n\n        set rowids [lindex $rowidlist $r]\n        foreach lid $rowids {\n            if {$lid eq {}} continue\n            if {[info exists lineend($lid)] && $lineend($lid) > $r} continue\n            if {$lid eq $id} {\n                # see if this is the first child of any of its parents\n                foreach p [lindex $parentlist $r] {\n                    if {[lsearch -exact $rowids $p] < 0} {\n                        # make this line extend up to the child\n                        set lineend($p) [drawlineseg $p $r $er 0]\n                    }\n                }\n            } else {\n                set lineend($lid) [drawlineseg $lid $r $er 1]\n            }\n        }\n    }\n}\n\nproc undolayout {row} {\n    global uparrowlen mingaplen downarrowlen\n    global rowidlist rowisopt rowfinal need_redisplay\n\n    set r [expr {$row - ($uparrowlen + $mingaplen + $downarrowlen)}]\n    if {$r < 0} {\n        set r 0\n    }\n    if {[llength $rowidlist] > $r} {\n        incr r -1\n        set rowidlist [lrange $rowidlist 0 $r]\n        set rowfinal [lrange $rowfinal 0 $r]\n        set rowisopt [lrange $rowisopt 0 $r]\n        set need_redisplay 1\n        run drawvisible\n    }\n}\n\nproc drawvisible {} {\n    global canv linespc curview vrowmod selectedline targetrow targetid\n    global need_redisplay cscroll numcommits\n\n    set fs [$canv yview]\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax eq {} || $ymax == 0 || $numcommits == 0} return\n    set f0 [lindex $fs 0]\n    set f1 [lindex $fs 1]\n    set y0 [expr {int($f0 * $ymax)}]\n    set y1 [expr {int($f1 * $ymax)}]\n\n    if {[info exists targetid]} {\n        if {[commitinview $targetid $curview]} {\n            set r [rowofcommit $targetid]\n            if {$r != $targetrow} {\n                # Fix up the scrollregion and change the scrolling position\n                # now that our target row has moved.\n                set diff [expr {($r - $targetrow) * $linespc}]\n                set targetrow $r\n                setcanvscroll\n                set ymax [lindex [$canv cget -scrollregion] 3]\n                incr y0 $diff\n                incr y1 $diff\n                set f0 [expr {$y0 / $ymax}]\n                set f1 [expr {$y1 / $ymax}]\n                allcanvs yview moveto $f0\n                $cscroll set $f0 $f1\n                set need_redisplay 1\n            }\n        } else {\n            unset targetid\n        }\n    }\n\n    set row [expr {int(($y0 - 3) / $linespc) - 1}]\n    set endrow [expr {int(($y1 - 3) / $linespc) + 1}]\n    if {$endrow >= $vrowmod($curview)} {\n        update_arcrows $curview\n    }\n    if {$selectedline ne {} &&\n        $row <= $selectedline && $selectedline <= $endrow} {\n        set targetrow $selectedline\n    } elseif {[info exists targetid]} {\n        set targetrow [expr {int(($row + $endrow) / 2)}]\n    }\n    if {[info exists targetrow]} {\n        if {$targetrow >= $numcommits} {\n            set targetrow [expr {$numcommits - 1}]\n        }\n        set targetid [commitonrow $targetrow]\n    }\n    drawcommits $row $endrow\n}\n\nproc clear_display {} {\n    global iddrawn linesegs need_redisplay nrows_drawn\n    global vhighlights fhighlights nhighlights rhighlights\n    global linehtag linentag linedtag boldids boldnameids\n\n    allcanvs delete all\n    unset -nocomplain iddrawn\n    unset -nocomplain linesegs\n    unset -nocomplain linehtag\n    unset -nocomplain linentag\n    unset -nocomplain linedtag\n    set boldids {}\n    set boldnameids {}\n    unset -nocomplain vhighlights\n    unset -nocomplain fhighlights\n    unset -nocomplain nhighlights\n    unset -nocomplain rhighlights\n    set need_redisplay 0\n    set nrows_drawn 0\n}\n\nproc findcrossings {id} {\n    global rowidlist parentlist numcommits displayorder\n\n    set cross {}\n    set ccross {}\n    foreach {s e} [rowranges $id] {\n        if {$e >= $numcommits} {\n            set e [expr {$numcommits - 1}]\n        }\n        if {$e <= $s} continue\n        for {set row $e} {[incr row -1] >= $s} {} {\n            set x [lsearch -exact [lindex $rowidlist $row] $id]\n            if {$x < 0} break\n            set olds [lindex $parentlist $row]\n            set kid [lindex $displayorder $row]\n            set kidx [lsearch -exact [lindex $rowidlist $row] $kid]\n            if {$kidx < 0} continue\n            set nextrow [lindex $rowidlist [expr {$row + 1}]]\n            foreach p $olds {\n                set px [lsearch -exact $nextrow $p]\n                if {$px < 0} continue\n                if {($kidx < $x && $x < $px) || ($px < $x && $x < $kidx)} {\n                    if {[lsearch -exact $ccross $p] >= 0} continue\n                    if {$x == $px + ($kidx < $px? -1: 1)} {\n                        lappend ccross $p\n                    } elseif {[lsearch -exact $cross $p] < 0} {\n                        lappend cross $p\n                    }\n                }\n            }\n        }\n    }\n    return [concat $ccross {{}} $cross]\n}\n\nproc assigncolor {id} {\n    global colormap colors nextcolor\n    global parents children children curview\n\n    if {[info exists colormap($id)]} return\n    set ncolors [llength $colors]\n    if {[info exists children($curview,$id)]} {\n        set kids $children($curview,$id)\n    } else {\n        set kids {}\n    }\n    if {[llength $kids] == 1} {\n        set child [lindex $kids 0]\n        if {[info exists colormap($child)]\n            && [llength $parents($curview,$child)] == 1} {\n            set colormap($id) $colormap($child)\n            return\n        }\n    }\n    set badcolors {}\n    set origbad {}\n    foreach x [findcrossings $id] {\n        if {$x eq {}} {\n            # delimiter between corner crossings and other crossings\n            if {[llength $badcolors] >= $ncolors - 1} break\n            set origbad $badcolors\n        }\n        if {[info exists colormap($x)]\n            && [lsearch -exact $badcolors $colormap($x)] < 0} {\n            lappend badcolors $colormap($x)\n        }\n    }\n    if {[llength $badcolors] >= $ncolors} {\n        set badcolors $origbad\n    }\n    set origbad $badcolors\n    if {[llength $badcolors] < $ncolors - 1} {\n        foreach child $kids {\n            if {[info exists colormap($child)]\n                && [lsearch -exact $badcolors $colormap($child)] < 0} {\n                lappend badcolors $colormap($child)\n            }\n            foreach p $parents($curview,$child) {\n                if {[info exists colormap($p)]\n                    && [lsearch -exact $badcolors $colormap($p)] < 0} {\n                    lappend badcolors $colormap($p)\n                }\n            }\n        }\n        if {[llength $badcolors] >= $ncolors} {\n            set badcolors $origbad\n        }\n    }\n    for {set i 0} {$i <= $ncolors} {incr i} {\n        set c [lindex $colors $nextcolor]\n        if {[incr nextcolor] >= $ncolors} {\n            set nextcolor 0\n        }\n        if {[lsearch -exact $badcolors $c]} break\n    }\n    set colormap($id) $c\n}\n\nproc bindline {t id} {\n    global canv\n\n    $canv bind $t <Enter> \"lineenter %x %y $id\"\n    $canv bind $t <Motion> \"linemotion %x %y $id\"\n    $canv bind $t <Leave> \"lineleave $id\"\n    $canv bind $t <Button-1> \"lineclick %x %y $id 1\"\n}\n\nproc graph_pane_width {} {\n    global use_ttk\n\n    if {$use_ttk} {\n        set g [.tf.histframe.pwclist sashpos 0]\n    } else {\n        set g [.tf.histframe.pwclist sash coord 0]\n    }\n    return [lindex $g 0]\n}\n\nproc totalwidth {l font extra} {\n    set tot 0\n    foreach str $l {\n        set tot [expr {$tot + [font measure $font $str] + $extra}]\n    }\n    return $tot\n}\n\nproc drawtags {id x xt y1} {\n    global idtags idheads idotherrefs mainhead\n    global linespc lthickness\n    global canv rowtextx curview fgcolor bgcolor ctxbut\n    global headbgcolor headfgcolor headoutlinecolor remotebgcolor\n    global tagbgcolor tagfgcolor tagoutlinecolor\n    global reflinecolor\n\n    set marks {}\n    set ntags 0\n    set nheads 0\n    set singletag 0\n    set maxtags 3\n    set maxtagpct 25\n    set maxwidth [expr {[graph_pane_width] * $maxtagpct / 100}]\n    set delta [expr {int(0.5 * ($linespc - $lthickness))}]\n    set extra [expr {$delta + $lthickness + $linespc}]\n\n    if {[info exists idtags($id)]} {\n        set marks $idtags($id)\n        set ntags [llength $marks]\n        if {$ntags > $maxtags ||\n            [totalwidth $marks mainfont $extra] > $maxwidth} {\n            # show just a single \"n tags...\" tag\n            set singletag 1\n            if {$ntags == 1} {\n                set marks [list \"tag...\"]\n            } else {\n                set marks [list [format \"%d tags...\" $ntags]]\n            }\n            set ntags 1\n        }\n    }\n    if {[info exists idheads($id)]} {\n        set marks [concat $marks $idheads($id)]\n        set nheads [llength $idheads($id)]\n    }\n    if {[info exists idotherrefs($id)]} {\n        set marks [concat $marks $idotherrefs($id)]\n    }\n    if {$marks eq {}} {\n        return $xt\n    }\n\n    set yt [expr {$y1 - 0.5 * $linespc}]\n    set yb [expr {$yt + $linespc - 1}]\n    set xvals {}\n    set wvals {}\n    set i -1\n    foreach tag $marks {\n        incr i\n        if {$i >= $ntags && $i < $ntags + $nheads && $tag eq $mainhead} {\n            set wid [font measure mainfontbold $tag]\n        } else {\n            set wid [font measure mainfont $tag]\n        }\n        lappend xvals $xt\n        lappend wvals $wid\n        set xt [expr {$xt + $wid + $extra}]\n    }\n    set t [$canv create line $x $y1 [lindex $xvals end] $y1 \\\n               -width $lthickness -fill $reflinecolor -tags tag.$id]\n    $canv lower $t\n    foreach tag $marks x $xvals wid $wvals {\n        set tag_quoted [string map {% %%} $tag]\n        set xl [expr {$x + $delta}]\n        set xr [expr {$x + $delta + $wid + $lthickness}]\n        set font mainfont\n        if {[incr ntags -1] >= 0} {\n            # draw a tag\n            set t [$canv create polygon $x [expr {$yt + $delta}] $xl $yt \\\n                       $xr $yt $xr $yb $xl $yb $x [expr {$yb - $delta}] \\\n                       -width 1 -outline $tagoutlinecolor -fill $tagbgcolor \\\n                       -tags tag.$id]\n            if {$singletag} {\n                set tagclick [list showtags $id 1]\n            } else {\n                set tagclick [list showtag $tag_quoted 1]\n            }\n            $canv bind $t <1> $tagclick\n            set rowtextx([rowofcommit $id]) [expr {$xr + $linespc}]\n        } else {\n            # draw a head or other ref\n            if {[incr nheads -1] >= 0} {\n                set col $headbgcolor\n                if {$tag eq $mainhead} {\n                    set font mainfontbold\n                }\n            } else {\n                set col \"#ddddff\"\n            }\n            set xl [expr {$xl - $delta/2}]\n            $canv create polygon $x $yt $xr $yt $xr $yb $x $yb \\\n                -width 1 -outline black -fill $col -tags tag.$id\n            if {[regexp {^(remotes/.*/|remotes/)} $tag match remoteprefix]} {\n                set rwid [font measure mainfont $remoteprefix]\n                set xi [expr {$x + 1}]\n                set yti [expr {$yt + 1}]\n                set xri [expr {$x + $rwid}]\n                $canv create polygon $xi $yti $xri $yti $xri $yb $xi $yb \\\n                        -width 0 -fill $remotebgcolor -tags tag.$id\n            }\n        }\n        set t [$canv create text $xl $y1 -anchor w -text $tag -fill $headfgcolor \\\n                   -font $font -tags [list tag.$id text]]\n        if {$ntags >= 0} {\n            $canv bind $t <1> $tagclick\n        } elseif {$nheads >= 0} {\n            $canv bind $t $ctxbut [list headmenu %X %Y $id $tag_quoted]\n        }\n    }\n    return $xt\n}\n\nproc drawnotesign {xt y} {\n    global linespc canv fgcolor\n\n    set orad [expr {$linespc / 3}]\n    set t [$canv create rectangle [expr {$xt - $orad}] [expr {$y - $orad}] \\\n               [expr {$xt + $orad - 1}] [expr {$y + $orad - 1}] \\\n               -fill yellow -outline $fgcolor -width 1 -tags circle]\n    set xt [expr {$xt + $orad * 3}]\n    return $xt\n}\n\nproc xcoord {i level ln} {\n    global canvx0 xspc1 xspc2\n\n    set x [expr {$canvx0 + $i * $xspc1($ln)}]\n    if {$i > 0 && $i == $level} {\n        set x [expr {$x + 0.5 * ($xspc2 - $xspc1($ln))}]\n    } elseif {$i > $level} {\n        set x [expr {$x + $xspc2 - $xspc1($ln)}]\n    }\n    return $x\n}\n\nproc show_status {msg} {\n    global canv fgcolor\n\n    clear_display\n    set_window_title\n    $canv create text 3 3 -anchor nw -text $msg -font mainfont \\\n        -tags text -fill $fgcolor\n}\n\n# Don't change the text pane cursor if it is currently the hand cursor,\n# showing that we are over a sha1 ID link.\nproc settextcursor {c} {\n    global ctext curtextcursor\n\n    if {[$ctext cget -cursor] == $curtextcursor} {\n        $ctext config -cursor $c\n    }\n    set curtextcursor $c\n}\n\nproc nowbusy {what {name {}}} {\n    global isbusy busyname statusw\n\n    if {[array names isbusy] eq {}} {\n        . config -cursor watch\n        settextcursor watch\n    }\n    set isbusy($what) 1\n    set busyname($what) $name\n    if {$name ne {}} {\n        $statusw conf -text $name\n    }\n}\n\nproc notbusy {what} {\n    global isbusy maincursor textcursor busyname statusw\n\n    catch {\n        unset isbusy($what)\n        if {$busyname($what) ne {} &&\n            [$statusw cget -text] eq $busyname($what)} {\n            $statusw conf -text {}\n        }\n    }\n    if {[array names isbusy] eq {}} {\n        . config -cursor $maincursor\n        settextcursor $textcursor\n    }\n}\n\nproc findmatches {f} {\n    global findtype findstring\n    if {$findtype == [mc \"Regexp\"]} {\n        set matches [regexp -indices -all -inline $findstring $f]\n    } else {\n        set fs $findstring\n        if {$findtype == [mc \"IgnCase\"]} {\n            set f [string tolower $f]\n            set fs [string tolower $fs]\n        }\n        set matches {}\n        set i 0\n        set l [string length $fs]\n        while {[set j [string first $fs $f $i]] >= 0} {\n            lappend matches [list $j [expr {$j+$l-1}]]\n            set i [expr {$j + $l}]\n        }\n    }\n    return $matches\n}\n\nproc dofind {{dirn 1} {wrap 1}} {\n    global findstring findstartline findcurline selectedline numcommits\n    global gdttype filehighlight fh_serial find_dirn findallowwrap\n\n    if {[info exists find_dirn]} {\n        if {$find_dirn == $dirn} return\n        stopfinding\n    }\n    focus .\n    if {$findstring eq {} || $numcommits == 0} return\n    if {$selectedline eq {}} {\n        set findstartline [lindex [visiblerows] [expr {$dirn < 0}]]\n    } else {\n        set findstartline $selectedline\n    }\n    set findcurline $findstartline\n    nowbusy finding [mc \"Searching\"]\n    if {$gdttype ne [mc \"containing:\"] && ![info exists filehighlight]} {\n        after cancel do_file_hl $fh_serial\n        do_file_hl $fh_serial\n    }\n    set find_dirn $dirn\n    set findallowwrap $wrap\n    run findmore\n}\n\nproc stopfinding {} {\n    global find_dirn findcurline fprogcoord\n\n    if {[info exists find_dirn]} {\n        unset find_dirn\n        unset findcurline\n        notbusy finding\n        set fprogcoord 0\n        adjustprogress\n    }\n    stopblaming\n}\n\nproc findmore {} {\n    global commitdata commitinfo numcommits findpattern findloc\n    global findstartline findcurline findallowwrap\n    global find_dirn gdttype fhighlights fprogcoord\n    global curview varcorder vrownum varccommits vrowmod\n\n    if {![info exists find_dirn]} {\n        return 0\n    }\n    set fldtypes [list [mc \"Headline\"] [mc \"Author\"] \"\" [mc \"Committer\"] \"\" [mc \"Comments\"]]\n    set l $findcurline\n    set moretodo 0\n    if {$find_dirn > 0} {\n        incr l\n        if {$l >= $numcommits} {\n            set l 0\n        }\n        if {$l <= $findstartline} {\n            set lim [expr {$findstartline + 1}]\n        } else {\n            set lim $numcommits\n            set moretodo $findallowwrap\n        }\n    } else {\n        if {$l == 0} {\n            set l $numcommits\n        }\n        incr l -1\n        if {$l >= $findstartline} {\n            set lim [expr {$findstartline - 1}]\n        } else {\n            set lim -1\n            set moretodo $findallowwrap\n        }\n    }\n    set n [expr {($lim - $l) * $find_dirn}]\n    if {$n > 500} {\n        set n 500\n        set moretodo 1\n    }\n    if {$l + ($find_dirn > 0? $n: 1) > $vrowmod($curview)} {\n        update_arcrows $curview\n    }\n    set found 0\n    set domore 1\n    set ai [bsearch $vrownum($curview) $l]\n    set a [lindex $varcorder($curview) $ai]\n    set arow [lindex $vrownum($curview) $ai]\n    set ids [lindex $varccommits($curview,$a)]\n    set arowend [expr {$arow + [llength $ids]}]\n    if {$gdttype eq [mc \"containing:\"]} {\n        for {} {$n > 0} {incr n -1; incr l $find_dirn} {\n            if {$l < $arow || $l >= $arowend} {\n                incr ai $find_dirn\n                set a [lindex $varcorder($curview) $ai]\n                set arow [lindex $vrownum($curview) $ai]\n                set ids [lindex $varccommits($curview,$a)]\n                set arowend [expr {$arow + [llength $ids]}]\n            }\n            set id [lindex $ids [expr {$l - $arow}]]\n            # shouldn't happen unless git log doesn't give all the commits...\n            if {![info exists commitdata($id)] ||\n                ![doesmatch $commitdata($id)]} {\n                continue\n            }\n            if {![info exists commitinfo($id)]} {\n                getcommit $id\n            }\n            set info $commitinfo($id)\n            foreach f $info ty $fldtypes {\n                if {$ty eq \"\"} continue\n                if {($findloc eq [mc \"All fields\"] || $findloc eq $ty) &&\n                    [doesmatch $f]} {\n                    set found 1\n                    break\n                }\n            }\n            if {$found} break\n        }\n    } else {\n        for {} {$n > 0} {incr n -1; incr l $find_dirn} {\n            if {$l < $arow || $l >= $arowend} {\n                incr ai $find_dirn\n                set a [lindex $varcorder($curview) $ai]\n                set arow [lindex $vrownum($curview) $ai]\n                set ids [lindex $varccommits($curview,$a)]\n                set arowend [expr {$arow + [llength $ids]}]\n            }\n            set id [lindex $ids [expr {$l - $arow}]]\n            if {![info exists fhighlights($id)]} {\n                # this sets fhighlights($id) to -1\n                askfilehighlight $l $id\n            }\n            if {$fhighlights($id) > 0} {\n                set found $domore\n                break\n            }\n            if {$fhighlights($id) < 0} {\n                if {$domore} {\n                    set domore 0\n                    set findcurline [expr {$l - $find_dirn}]\n                }\n            }\n        }\n    }\n    if {$found || ($domore && !$moretodo)} {\n        unset findcurline\n        unset find_dirn\n        notbusy finding\n        set fprogcoord 0\n        adjustprogress\n        if {$found} {\n            findselectline $l\n        } else {\n            bell\n        }\n        return 0\n    }\n    if {!$domore} {\n        flushhighlights\n    } else {\n        set findcurline [expr {$l - $find_dirn}]\n    }\n    set n [expr {($findcurline - $findstartline) * $find_dirn - 1}]\n    if {$n < 0} {\n        incr n $numcommits\n    }\n    set fprogcoord [expr {$n * 1.0 / $numcommits}]\n    adjustprogress\n    return $domore\n}\n\nproc findselectline {l} {\n    global findloc commentend ctext findcurline markingmatches gdttype\n\n    set markingmatches [expr {$gdttype eq [mc \"containing:\"]}]\n    set findcurline $l\n    selectline $l 1\n    if {$markingmatches &&\n        ($findloc eq [mc \"All fields\"] || $findloc eq [mc \"Comments\"])} {\n        # highlight the matches in the comments\n        set f [$ctext get 1.0 $commentend]\n        set matches [findmatches $f]\n        foreach match $matches {\n            set start [lindex $match 0]\n            set end [expr {[lindex $match 1] + 1}]\n            $ctext tag add found \"1.0 + $start c\" \"1.0 + $end c\"\n        }\n    }\n    drawvisible\n}\n\n# mark the bits of a headline or author that match a find string\nproc markmatches {canv l str tag matches font row} {\n    global selectedline\n\n    set bbox [$canv bbox $tag]\n    set x0 [lindex $bbox 0]\n    set y0 [lindex $bbox 1]\n    set y1 [lindex $bbox 3]\n    foreach match $matches {\n        set start [lindex $match 0]\n        set end [lindex $match 1]\n        if {$start > $end} continue\n        set xoff [font measure $font [string range $str 0 [expr {$start-1}]]]\n        set xlen [font measure $font [string range $str 0 [expr {$end}]]]\n        set t [$canv create rect [expr {$x0+$xoff}] $y0 \\\n                   [expr {$x0+$xlen+2}] $y1 \\\n                   -outline {} -tags [list match$l matches] -fill yellow]\n        $canv lower $t\n        if {$row == $selectedline} {\n            $canv raise $t secsel\n        }\n    }\n}\n\nproc unmarkmatches {} {\n    global markingmatches\n\n    allcanvs delete matches\n    set markingmatches 0\n    stopfinding\n}\n\nproc selcanvline {w x y} {\n    global canv canvy0 ctext linespc\n    global rowtextx\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax == {}} return\n    set yfrac [lindex [$canv yview] 0]\n    set y [expr {$y + $yfrac * $ymax}]\n    set l [expr {int(($y - $canvy0) / $linespc + 0.5)}]\n    if {$l < 0} {\n        set l 0\n    }\n    if {$w eq $canv} {\n        set xmax [lindex [$canv cget -scrollregion] 2]\n        set xleft [expr {[lindex [$canv xview] 0] * $xmax}]\n        if {![info exists rowtextx($l)] || $xleft + $x < $rowtextx($l)} return\n    }\n    unmarkmatches\n    selectline $l 1\n}\n\nproc commit_descriptor {p} {\n    global commitinfo\n    if {![info exists commitinfo($p)]} {\n        getcommit $p\n    }\n    set l \"...\"\n    if {[llength $commitinfo($p)] > 1} {\n        set l [lindex $commitinfo($p) 0]\n    }\n    return \"$p ($l)\\n\"\n}\n\n# append some text to the ctext widget, and make any SHA1 ID\n# that we know about be a clickable link.\n# Also look for URLs of the form \"http[s]://...\" and make them web links.\nproc appendwithlinks {text tags} {\n    global ctext linknum curview\n\n    set start [$ctext index \"end - 1c\"]\n    $ctext insert end $text $tags\n    set links [regexp -indices -all -inline {(?:\\m|-g)[0-9a-f]{6,40}\\M} $text]\n    foreach l $links {\n        set s [lindex $l 0]\n        set e [lindex $l 1]\n        set linkid [string range $text $s $e]\n        incr e\n        $ctext tag delete link$linknum\n        $ctext tag add link$linknum \"$start + $s c\" \"$start + $e c\"\n        setlink $linkid link$linknum\n        incr linknum\n    }\n    set wlinks [regexp -indices -all -inline -line \\\n                    {https?://[^[:space:]]+} $text]\n    foreach l $wlinks {\n        set s2 [lindex $l 0]\n        set e2 [lindex $l 1]\n        set url [string range $text $s2 $e2]\n        incr e2\n        $ctext tag delete link$linknum\n        $ctext tag add link$linknum \"$start + $s2 c\" \"$start + $e2 c\"\n        setwlink $url link$linknum\n        incr linknum\n    }\n}\n\nproc setlink {id lk} {\n    global curview ctext pendinglinks\n    global linkfgcolor\n\n    if {[string range $id 0 1] eq \"-g\"} {\n      set id [string range $id 2 end]\n    }\n\n    set known 0\n    if {[string length $id] < 40} {\n        set matches [longid $id]\n        if {[llength $matches] > 0} {\n            if {[llength $matches] > 1} return\n            set known 1\n            set id [lindex $matches 0]\n        }\n    } else {\n        set known [commitinview $id $curview]\n    }\n    if {$known} {\n        $ctext tag conf $lk -foreground $linkfgcolor -underline 1\n        $ctext tag bind $lk <1> [list selbyid $id]\n        $ctext tag bind $lk <Enter> {linkcursor %W 1}\n        $ctext tag bind $lk <Leave> {linkcursor %W -1}\n    } else {\n        lappend pendinglinks($id) $lk\n        interestedin $id {makelink %P}\n    }\n}\n\nproc setwlink {url lk} {\n    global ctext\n    global linkfgcolor\n    global web_browser\n\n    if {$web_browser eq {}} return\n    $ctext tag conf $lk -foreground $linkfgcolor -underline 1\n    $ctext tag bind $lk <1> [list browseweb $url]\n    $ctext tag bind $lk <Enter> {linkcursor %W 1}\n    $ctext tag bind $lk <Leave> {linkcursor %W -1}\n}\n\nproc appendshortlink {id {pre {}} {post {}}} {\n    global ctext linknum\n\n    $ctext insert end $pre\n    $ctext tag delete link$linknum\n    $ctext insert end [string range $id 0 7] link$linknum\n    $ctext insert end $post\n    setlink $id link$linknum\n    incr linknum\n}\n\nproc makelink {id} {\n    global pendinglinks\n\n    if {![info exists pendinglinks($id)]} return\n    foreach lk $pendinglinks($id) {\n        setlink $id $lk\n    }\n    unset pendinglinks($id)\n}\n\nproc linkcursor {w inc} {\n    global linkentercount curtextcursor\n\n    if {[incr linkentercount $inc] > 0} {\n        $w configure -cursor hand2\n    } else {\n        $w configure -cursor $curtextcursor\n        if {$linkentercount < 0} {\n            set linkentercount 0\n        }\n    }\n}\n\nproc browseweb {url} {\n    global web_browser\n\n    if {$web_browser eq {}} return\n    # Use eval here in case $web_browser is a command plus some arguments\n    if {[catch {eval exec $web_browser [list $url] &} err]} {\n        error_popup \"[mc \"Error starting web browser:\"] $err\"\n    }\n}\n\nproc viewnextline {dir} {\n    global canv linespc\n\n    $canv delete hover\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    set wnow [$canv yview]\n    set wtop [expr {[lindex $wnow 0] * $ymax}]\n    set newtop [expr {$wtop + $dir * $linespc}]\n    if {$newtop < 0} {\n        set newtop 0\n    } elseif {$newtop > $ymax} {\n        set newtop $ymax\n    }\n    allcanvs yview moveto [expr {$newtop * 1.0 / $ymax}]\n}\n\n# add a list of tag or branch names at position pos\n# returns the number of names inserted\nproc appendrefs {pos ids var} {\n    global ctext linknum curview $var maxrefs visiblerefs mainheadid\n\n    if {[catch {$ctext index $pos}]} {\n        return 0\n    }\n    $ctext conf -state normal\n    $ctext delete $pos \"$pos lineend\"\n    set tags {}\n    foreach id $ids {\n        foreach tag [set $var\\($id\\)] {\n            lappend tags [list $tag $id]\n        }\n    }\n\n    set sep {}\n    set tags [lsort -index 0 -decreasing $tags]\n    set nutags 0\n\n    if {[llength $tags] > $maxrefs} {\n        # If we are displaying heads, and there are too many,\n        # see if there are some important heads to display.\n        # Currently that are the current head and heads listed in $visiblerefs option\n        set itags {}\n        if {$var eq \"idheads\"} {\n            set utags {}\n            foreach ti $tags {\n                set hname [lindex $ti 0]\n                set id [lindex $ti 1]\n                if {([lsearch -exact $visiblerefs $hname] != -1 || $id eq $mainheadid) &&\n                    [llength $itags] < $maxrefs} {\n                    lappend itags $ti\n                } else {\n                    lappend utags $ti\n                }\n            }\n            set tags $utags\n        }\n        if {$itags ne {}} {\n            set str [mc \"and many more\"]\n            set sep \" \"\n        } else {\n            set str [mc \"many\"]\n        }\n        $ctext insert $pos \"$str ([llength $tags])\"\n        set nutags [llength $tags]\n        set tags $itags\n    }\n\n    foreach ti $tags {\n        set id [lindex $ti 1]\n        set lk link$linknum\n        incr linknum\n        $ctext tag delete $lk\n        $ctext insert $pos $sep\n        $ctext insert $pos [lindex $ti 0] $lk\n        setlink $id $lk\n        set sep \", \"\n    }\n    $ctext tag add wwrap \"$pos linestart\" \"$pos lineend\"\n    $ctext conf -state disabled\n    return [expr {[llength $tags] + $nutags}]\n}\n\n# called when we have finished computing the nearby tags\nproc dispneartags {delay} {\n    global selectedline currentid showneartags tagphase\n\n    if {$selectedline eq {} || !$showneartags} return\n    after cancel dispnexttag\n    if {$delay} {\n        after 200 dispnexttag\n        set tagphase -1\n    } else {\n        after idle dispnexttag\n        set tagphase 0\n    }\n}\n\nproc dispnexttag {} {\n    global selectedline currentid showneartags tagphase ctext\n\n    if {$selectedline eq {} || !$showneartags} return\n    switch -- $tagphase {\n        0 {\n            set dtags [desctags $currentid]\n            if {$dtags ne {}} {\n                appendrefs precedes $dtags idtags\n            }\n        }\n        1 {\n            set atags [anctags $currentid]\n            if {$atags ne {}} {\n                appendrefs follows $atags idtags\n            }\n        }\n        2 {\n            set dheads [descheads $currentid]\n            if {$dheads ne {}} {\n                if {[appendrefs branch $dheads idheads] > 1\n                    && [$ctext get \"branch -3c\"] eq \"h\"} {\n                    # turn \"Branch\" into \"Branches\"\n                    $ctext conf -state normal\n                    $ctext insert \"branch -2c\" \"es\"\n                    $ctext conf -state disabled\n                }\n            }\n        }\n    }\n    if {[incr tagphase] <= 2} {\n        after idle dispnexttag\n    }\n}\n\nproc make_secsel {id} {\n    global linehtag linentag linedtag canv canv2 canv3\n\n    if {![info exists linehtag($id)]} return\n    $canv delete secsel\n    set t [eval $canv create rect [$canv bbox $linehtag($id)] -outline {{}} \\\n               -tags secsel -fill [$canv cget -selectbackground]]\n    $canv lower $t\n    $canv2 delete secsel\n    set t [eval $canv2 create rect [$canv2 bbox $linentag($id)] -outline {{}} \\\n               -tags secsel -fill [$canv2 cget -selectbackground]]\n    $canv2 lower $t\n    $canv3 delete secsel\n    set t [eval $canv3 create rect [$canv3 bbox $linedtag($id)] -outline {{}} \\\n               -tags secsel -fill [$canv3 cget -selectbackground]]\n    $canv3 lower $t\n}\n\nproc make_idmark {id} {\n    global linehtag canv fgcolor\n\n    if {![info exists linehtag($id)]} return\n    $canv delete markid\n    set t [eval $canv create rect [$canv bbox $linehtag($id)] \\\n               -tags markid -outline $fgcolor]\n    $canv raise $t\n}\n\nproc selectline {l isnew {desired_loc {}} {switch_to_patch 0}} {\n    global canv ctext commitinfo selectedline\n    global canvy0 linespc parents children curview\n    global currentid sha1entry\n    global commentend idtags linknum\n    global mergemax numcommits pending_select\n    global cmitmode showneartags allcommits\n    global targetrow targetid lastscrollrows\n    global autoselect autosellen jump_to_here\n    global vinlinediff\n\n    unset -nocomplain pending_select\n    $canv delete hover\n    normalline\n    unsel_reflist\n    stopfinding\n    if {$l < 0 || $l >= $numcommits} return\n    set id [commitonrow $l]\n    set targetid $id\n    set targetrow $l\n    set selectedline $l\n    set currentid $id\n    if {$lastscrollrows < $numcommits} {\n        setcanvscroll\n    }\n\n    if {$cmitmode ne \"patch\" && $switch_to_patch} {\n        set cmitmode \"patch\"\n    }\n\n    set y [expr {$canvy0 + $l * $linespc}]\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    set ytop [expr {$y - $linespc - 1}]\n    set ybot [expr {$y + $linespc + 1}]\n    set wnow [$canv yview]\n    set wtop [expr {[lindex $wnow 0] * $ymax}]\n    set wbot [expr {[lindex $wnow 1] * $ymax}]\n    set wh [expr {$wbot - $wtop}]\n    set newtop $wtop\n    if {$ytop < $wtop} {\n        if {$ybot < $wtop} {\n            set newtop [expr {$y - $wh / 2.0}]\n        } else {\n            set newtop $ytop\n            if {$newtop > $wtop - $linespc} {\n                set newtop [expr {$wtop - $linespc}]\n            }\n        }\n    } elseif {$ybot > $wbot} {\n        if {$ytop > $wbot} {\n            set newtop [expr {$y - $wh / 2.0}]\n        } else {\n            set newtop [expr {$ybot - $wh}]\n            if {$newtop < $wtop + $linespc} {\n                set newtop [expr {$wtop + $linespc}]\n            }\n        }\n    }\n    if {$newtop != $wtop} {\n        if {$newtop < 0} {\n            set newtop 0\n        }\n        allcanvs yview moveto [expr {$newtop * 1.0 / $ymax}]\n        drawvisible\n    }\n\n    make_secsel $id\n\n    if {$isnew} {\n        addtohistory [list selbyid $id 0] savecmitpos\n    }\n\n    $sha1entry delete 0 end\n    $sha1entry insert 0 $id\n    if {$autoselect} {\n        $sha1entry selection range 0 $autosellen\n    }\n    rhighlight_sel $id\n\n    $ctext conf -state normal\n    clear_ctext\n    set linknum 0\n    if {![info exists commitinfo($id)]} {\n        getcommit $id\n    }\n    set info $commitinfo($id)\n    set date [formatdate [lindex $info 2]]\n    $ctext insert end \"[mc \"Author\"]: [lindex $info 1]  $date\\n\"\n    set date [formatdate [lindex $info 4]]\n    $ctext insert end \"[mc \"Committer\"]: [lindex $info 3]  $date\\n\"\n    if {[info exists idtags($id)]} {\n        $ctext insert end [mc \"Tags:\"]\n        foreach tag $idtags($id) {\n            $ctext insert end \" $tag\"\n        }\n        $ctext insert end \"\\n\"\n    }\n\n    set headers {}\n    set olds $parents($curview,$id)\n    if {[llength $olds] > 1} {\n        set np 0\n        foreach p $olds {\n            if {$np >= $mergemax} {\n                set tag mmax\n            } else {\n                set tag m$np\n            }\n            $ctext insert end \"[mc \"Parent\"]: \" $tag\n            appendwithlinks [commit_descriptor $p] {}\n            incr np\n        }\n    } else {\n        foreach p $olds {\n            append headers \"[mc \"Parent\"]: [commit_descriptor $p]\"\n        }\n    }\n\n    foreach c $children($curview,$id) {\n        append headers \"[mc \"Child\"]:  [commit_descriptor $c]\"\n    }\n\n    # make anything that looks like a SHA1 ID be a clickable link\n    appendwithlinks $headers {}\n    if {$showneartags} {\n        if {![info exists allcommits]} {\n            getallcommits\n        }\n        $ctext insert end \"[mc \"Branch\"]: \"\n        $ctext mark set branch \"end -1c\"\n        $ctext mark gravity branch left\n        $ctext insert end \"\\n[mc \"Follows\"]: \"\n        $ctext mark set follows \"end -1c\"\n        $ctext mark gravity follows left\n        $ctext insert end \"\\n[mc \"Precedes\"]: \"\n        $ctext mark set precedes \"end -1c\"\n        $ctext mark gravity precedes left\n        $ctext insert end \"\\n\"\n        dispneartags 1\n    }\n    $ctext insert end \"\\n\"\n    set comment [lindex $info 5]\n    if {[string first \"\\r\" $comment] >= 0} {\n        set comment [string map {\"\\r\" \"\\n    \"} $comment]\n    }\n    appendwithlinks $comment {comment}\n\n    $ctext tag remove found 1.0 end\n    $ctext conf -state disabled\n    set commentend [$ctext index \"end - 1c\"]\n\n    set jump_to_here $desired_loc\n    init_flist [mc \"Comments\"]\n    if {$cmitmode eq \"tree\"} {\n        gettree $id\n    } elseif {$vinlinediff($curview) == 1} {\n        showinlinediff $id\n    } elseif {[llength $olds] <= 1} {\n        startdiff $id\n    } else {\n        mergediff $id\n    }\n}\n\nproc selfirstline {} {\n    unmarkmatches\n    selectline 0 1\n}\n\nproc sellastline {} {\n    global numcommits\n    unmarkmatches\n    set l [expr {$numcommits - 1}]\n    selectline $l 1\n}\n\nproc selnextline {dir} {\n    global selectedline\n    focus .\n    if {$selectedline eq {}} return\n    set l [expr {$selectedline + $dir}]\n    unmarkmatches\n    selectline $l 1\n}\n\nproc selnextpage {dir} {\n    global canv linespc selectedline numcommits\n\n    set lpp [expr {([winfo height $canv] - 2) / $linespc}]\n    if {$lpp < 1} {\n        set lpp 1\n    }\n    allcanvs yview scroll [expr {$dir * $lpp}] units\n    drawvisible\n    if {$selectedline eq {}} return\n    set l [expr {$selectedline + $dir * $lpp}]\n    if {$l < 0} {\n        set l 0\n    } elseif {$l >= $numcommits} {\n        set l [expr $numcommits - 1]\n    }\n    unmarkmatches\n    selectline $l 1\n}\n\nproc unselectline {} {\n    global selectedline currentid\n\n    set selectedline {}\n    unset -nocomplain currentid\n    allcanvs delete secsel\n    rhighlight_none\n}\n\nproc reselectline {} {\n    global selectedline\n\n    if {$selectedline ne {}} {\n        selectline $selectedline 0\n    }\n}\n\nproc addtohistory {cmd {saveproc {}}} {\n    global history historyindex curview\n\n    unset_posvars\n    save_position\n    set elt [list $curview $cmd $saveproc {}]\n    if {$historyindex > 0\n        && [lindex $history [expr {$historyindex - 1}]] == $elt} {\n        return\n    }\n\n    if {$historyindex < [llength $history]} {\n        set history [lreplace $history $historyindex end $elt]\n    } else {\n        lappend history $elt\n    }\n    incr historyindex\n    if {$historyindex > 1} {\n        .tf.bar.leftbut conf -state normal\n    } else {\n        .tf.bar.leftbut conf -state disabled\n    }\n    .tf.bar.rightbut conf -state disabled\n}\n\n# save the scrolling position of the diff display pane\nproc save_position {} {\n    global historyindex history\n\n    if {$historyindex < 1} return\n    set hi [expr {$historyindex - 1}]\n    set fn [lindex $history $hi 2]\n    if {$fn ne {}} {\n        lset history $hi 3 [eval $fn]\n    }\n}\n\nproc unset_posvars {} {\n    global last_posvars\n\n    if {[info exists last_posvars]} {\n        foreach {var val} $last_posvars {\n            global $var\n            unset -nocomplain $var\n        }\n        unset last_posvars\n    }\n}\n\nproc godo {elt} {\n    global curview last_posvars\n\n    set view [lindex $elt 0]\n    set cmd [lindex $elt 1]\n    set pv [lindex $elt 3]\n    if {$curview != $view} {\n        showview $view\n    }\n    unset_posvars\n    foreach {var val} $pv {\n        global $var\n        set $var $val\n    }\n    set last_posvars $pv\n    eval $cmd\n}\n\nproc goback {} {\n    global history historyindex\n    focus .\n\n    if {$historyindex > 1} {\n        save_position\n        incr historyindex -1\n        godo [lindex $history [expr {$historyindex - 1}]]\n        .tf.bar.rightbut conf -state normal\n    }\n    if {$historyindex <= 1} {\n        .tf.bar.leftbut conf -state disabled\n    }\n}\n\nproc goforw {} {\n    global history historyindex\n    focus .\n\n    if {$historyindex < [llength $history]} {\n        save_position\n        set cmd [lindex $history $historyindex]\n        incr historyindex\n        godo $cmd\n        .tf.bar.leftbut conf -state normal\n    }\n    if {$historyindex >= [llength $history]} {\n        .tf.bar.rightbut conf -state disabled\n    }\n}\n\nproc go_to_parent {i} {\n    global parents curview targetid\n    set ps $parents($curview,$targetid)\n    if {[llength $ps] >= $i} {\n        selbyid [lindex $ps [expr $i - 1]]\n    }\n}\n\nproc gettree {id} {\n    global treefilelist treeidlist diffids diffmergeid treepending\n    global nullid nullid2\n\n    set diffids $id\n    unset -nocomplain diffmergeid\n    if {![info exists treefilelist($id)]} {\n        if {![info exists treepending]} {\n            if {$id eq $nullid} {\n                set cmd [list | git ls-files]\n            } elseif {$id eq $nullid2} {\n                set cmd [list | git ls-files --stage -t]\n            } else {\n                set cmd [list | git ls-tree -r $id]\n            }\n            if {[catch {set gtf [open $cmd r]}]} {\n                return\n            }\n            set treepending $id\n            set treefilelist($id) {}\n            set treeidlist($id) {}\n            fconfigure $gtf -blocking 0 -encoding binary\n            filerun $gtf [list gettreeline $gtf $id]\n        }\n    } else {\n        setfilelist $id\n    }\n}\n\nproc gettreeline {gtf id} {\n    global treefilelist treeidlist treepending cmitmode diffids nullid nullid2\n\n    set nl 0\n    while {[incr nl] <= 1000 && [gets $gtf line] >= 0} {\n        if {$diffids eq $nullid} {\n            set fname $line\n        } else {\n            set i [string first \"\\t\" $line]\n            if {$i < 0} continue\n            set fname [string range $line [expr {$i+1}] end]\n            set line [string range $line 0 [expr {$i-1}]]\n            if {$diffids ne $nullid2 && [lindex $line 1] ne \"blob\"} continue\n            set sha1 [lindex $line 2]\n            lappend treeidlist($id) $sha1\n        }\n        if {[string index $fname 0] eq \"\\\"\"} {\n            set fname [lindex $fname 0]\n        }\n        set fname [encoding convertfrom utf-8 $fname]\n        lappend treefilelist($id) $fname\n    }\n    if {![eof $gtf]} {\n        return [expr {$nl >= 1000? 2: 1}]\n    }\n    close $gtf\n    unset treepending\n    if {$cmitmode ne \"tree\"} {\n        if {![info exists diffmergeid]} {\n            gettreediffs $diffids\n        }\n    } elseif {$id ne $diffids} {\n        gettree $diffids\n    } else {\n        setfilelist $id\n    }\n    return 0\n}\n\nproc showfile {f} {\n    global treefilelist treeidlist diffids nullid nullid2\n    global ctext_file_names ctext_file_lines\n    global ctext commentend\n\n    set i [lsearch -exact $treefilelist($diffids) $f]\n    if {$i < 0} {\n        puts \"oops, $f not in list for id $diffids\"\n        return\n    }\n    if {$diffids eq $nullid} {\n        if {[catch {set bf [open $f r]} err]} {\n            puts \"oops, can't read $f: $err\"\n            return\n        }\n    } else {\n        set blob [lindex $treeidlist($diffids) $i]\n        if {[catch {set bf [open [concat | git cat-file blob $blob] r]} err]} {\n            puts \"oops, error reading blob $blob: $err\"\n            return\n        }\n    }\n    fconfigure $bf -blocking 0 -encoding [get_path_encoding $f]\n    filerun $bf [list getblobline $bf $diffids]\n    $ctext config -state normal\n    clear_ctext $commentend\n    lappend ctext_file_names $f\n    lappend ctext_file_lines [lindex [split $commentend \".\"] 0]\n    $ctext insert end \"\\n\"\n    $ctext insert end \"$f\\n\" filesep\n    $ctext config -state disabled\n    $ctext yview $commentend\n    settabs 0\n}\n\nproc getblobline {bf id} {\n    global diffids cmitmode ctext\n\n    if {$id ne $diffids || $cmitmode ne \"tree\"} {\n        catch {close $bf}\n        return 0\n    }\n    $ctext config -state normal\n    set nl 0\n    while {[incr nl] <= 1000 && [gets $bf line] >= 0} {\n        $ctext insert end \"$line\\n\"\n    }\n    if {[eof $bf]} {\n        global jump_to_here ctext_file_names commentend\n\n        # delete last newline\n        $ctext delete \"end - 2c\" \"end - 1c\"\n        close $bf\n        if {$jump_to_here ne {} &&\n            [lindex $jump_to_here 0] eq [lindex $ctext_file_names 0]} {\n            set lnum [expr {[lindex $jump_to_here 1] +\n                            [lindex [split $commentend .] 0]}]\n            mark_ctext_line $lnum\n        }\n        $ctext config -state disabled\n        return 0\n    }\n    $ctext config -state disabled\n    return [expr {$nl >= 1000? 2: 1}]\n}\n\nproc mark_ctext_line {lnum} {\n    global ctext markbgcolor\n\n    $ctext tag delete omark\n    $ctext tag add omark $lnum.0 \"$lnum.0 + 1 line\"\n    $ctext tag conf omark -background $markbgcolor\n    $ctext see $lnum.0\n}\n\nproc mergediff {id} {\n    global diffmergeid\n    global diffids treediffs\n    global parents curview\n\n    set diffmergeid $id\n    set diffids $id\n    set treediffs($id) {}\n    set np [llength $parents($curview,$id)]\n    settabs $np\n    getblobdiffs $id\n}\n\nproc startdiff {ids} {\n    global treediffs diffids treepending diffmergeid nullid nullid2\n\n    settabs 1\n    set diffids $ids\n    unset -nocomplain diffmergeid\n    if {![info exists treediffs($ids)] ||\n        [lsearch -exact $ids $nullid] >= 0 ||\n        [lsearch -exact $ids $nullid2] >= 0} {\n        if {![info exists treepending]} {\n            gettreediffs $ids\n        }\n    } else {\n        addtocflist $ids\n    }\n}\n\nproc showinlinediff {ids} {\n    global commitinfo commitdata ctext\n    global treediffs\n\n    set info $commitinfo($ids)\n    set diff [lindex $info 7]\n    set difflines [split $diff \"\\n\"]\n\n    initblobdiffvars\n    set treediff {}\n\n    set inhdr 0\n    foreach line $difflines {\n        if {![string compare -length 5 \"diff \" $line]} {\n            set inhdr 1\n        } elseif {$inhdr && ![string compare -length 4 \"+++ \" $line]} {\n            # offset also accounts for the b/ prefix\n            lappend treediff [string range $line 6 end]\n            set inhdr 0\n        }\n    }\n\n    set treediffs($ids) $treediff\n    add_flist $treediff\n\n    $ctext conf -state normal\n    foreach line $difflines {\n        parseblobdiffline $ids $line\n    }\n    maybe_scroll_ctext 1\n    $ctext conf -state disabled\n}\n\n# If the filename (name) is under any of the passed filter paths\n# then return true to include the file in the listing.\nproc path_filter {filter name} {\n    set worktree [gitworktree]\n    foreach p $filter {\n        set fq_p [file normalize $p]\n        set fq_n [file normalize [file join $worktree $name]]\n        if {[string match [file normalize $fq_p]* $fq_n]} {\n            return 1\n        }\n    }\n    return 0\n}\n\nproc addtocflist {ids} {\n    global treediffs\n\n    add_flist $treediffs($ids)\n    getblobdiffs $ids\n}\n\nproc diffcmd {ids flags} {\n    global log_showroot nullid nullid2 git_version\n\n    set i [lsearch -exact $ids $nullid]\n    set j [lsearch -exact $ids $nullid2]\n    if {$i >= 0} {\n        if {[llength $ids] > 1 && $j < 0} {\n            # comparing working directory with some specific revision\n            set cmd [concat | git diff-index $flags]\n            if {$i == 0} {\n                lappend cmd -R [lindex $ids 1]\n            } else {\n                lappend cmd [lindex $ids 0]\n            }\n        } else {\n            # comparing working directory with index\n            set cmd [concat | git diff-files $flags]\n            if {$j == 1} {\n                lappend cmd -R\n            }\n        }\n    } elseif {$j >= 0} {\n        if {[package vcompare $git_version \"1.7.2\"] >= 0} {\n            set flags \"$flags --ignore-submodules=dirty\"\n        }\n        set cmd [concat | git diff-index --cached $flags]\n        if {[llength $ids] > 1} {\n            # comparing index with specific revision\n            if {$j == 0} {\n                lappend cmd -R [lindex $ids 1]\n            } else {\n                lappend cmd [lindex $ids 0]\n            }\n        } else {\n            # comparing index with HEAD\n            lappend cmd HEAD\n        }\n    } else {\n        if {$log_showroot} {\n            lappend flags --root\n        }\n        set cmd [concat | git diff-tree -r $flags $ids]\n    }\n    return $cmd\n}\n\nproc gettreediffs {ids} {\n    global treediff treepending limitdiffs vfilelimit curview\n\n    set cmd [diffcmd $ids {--no-commit-id}]\n    if {$limitdiffs && $vfilelimit($curview) ne {}} {\n            set cmd [concat $cmd -- $vfilelimit($curview)]\n    }\n    if {[catch {set gdtf [open $cmd r]}]} return\n\n    set treepending $ids\n    set treediff {}\n    fconfigure $gdtf -blocking 0 -encoding binary\n    filerun $gdtf [list gettreediffline $gdtf $ids]\n}\n\nproc gettreediffline {gdtf ids} {\n    global treediff treediffs treepending diffids diffmergeid\n    global cmitmode vfilelimit curview limitdiffs perfile_attrs\n\n    set nr 0\n    set sublist {}\n    set max 1000\n    if {$perfile_attrs} {\n        # cache_gitattr is slow, and even slower on win32 where we\n        # have to invoke it for only about 30 paths at a time\n        set max 500\n        if {[tk windowingsystem] == \"win32\"} {\n            set max 120\n        }\n    }\n    while {[incr nr] <= $max && [gets $gdtf line] >= 0} {\n        set i [string first \"\\t\" $line]\n        if {$i >= 0} {\n            set file [string range $line [expr {$i+1}] end]\n            if {[string index $file 0] eq \"\\\"\"} {\n                set file [lindex $file 0]\n            }\n            set file [encoding convertfrom utf-8 $file]\n            if {$file ne [lindex $treediff end]} {\n                lappend treediff $file\n                lappend sublist $file\n            }\n        }\n    }\n    if {$perfile_attrs} {\n        cache_gitattr encoding $sublist\n    }\n    if {![eof $gdtf]} {\n        return [expr {$nr >= $max? 2: 1}]\n    }\n    close $gdtf\n    set treediffs($ids) $treediff\n    unset treepending\n    if {$cmitmode eq \"tree\" && [llength $diffids] == 1} {\n        gettree $diffids\n    } elseif {$ids != $diffids} {\n        if {![info exists diffmergeid]} {\n            gettreediffs $diffids\n        }\n    } else {\n        addtocflist $ids\n    }\n    return 0\n}\n\n# empty string or positive integer\nproc diffcontextvalidate {v} {\n    return [regexp {^(|[1-9][0-9]*)$} $v]\n}\n\nproc diffcontextchange {n1 n2 op} {\n    global diffcontextstring diffcontext\n\n    if {[string is integer -strict $diffcontextstring]} {\n        if {$diffcontextstring >= 0} {\n            set diffcontext $diffcontextstring\n            reselectline\n        }\n    }\n}\n\nproc changeignorespace {} {\n    reselectline\n}\n\nproc changeworddiff {name ix op} {\n    reselectline\n}\n\nproc initblobdiffvars {} {\n    global diffencoding targetline diffnparents\n    global diffinhdr currdiffsubmod diffseehere\n    set targetline {}\n    set diffnparents 0\n    set diffinhdr 0\n    set diffencoding [get_path_encoding {}]\n    set currdiffsubmod \"\"\n    set diffseehere -1\n}\n\nproc getblobdiffs {ids} {\n    global blobdifffd diffids env\n    global treediffs\n    global diffcontext\n    global ignorespace\n    global worddiff\n    global limitdiffs vfilelimit curview\n    global git_version\n\n    set textconv {}\n    if {[package vcompare $git_version \"1.6.1\"] >= 0} {\n        set textconv \"--textconv\"\n    }\n    set submodule {}\n    if {[package vcompare $git_version \"1.6.6\"] >= 0} {\n        set submodule \"--submodule\"\n    }\n    set cmd [diffcmd $ids \"-p $textconv $submodule  -C --cc --no-commit-id -U$diffcontext\"]\n    if {$ignorespace} {\n        append cmd \" -w\"\n    }\n    if {$worddiff ne [mc \"Line diff\"]} {\n        append cmd \" --word-diff=porcelain\"\n    }\n    if {$limitdiffs && $vfilelimit($curview) ne {}} {\n        set cmd [concat $cmd -- $vfilelimit($curview)]\n    }\n    if {[catch {set bdf [open $cmd r]} err]} {\n        error_popup [mc \"Error getting diffs: %s\" $err]\n        return\n    }\n    fconfigure $bdf -blocking 0 -encoding binary -eofchar {}\n    set blobdifffd($ids) $bdf\n    initblobdiffvars\n    filerun $bdf [list getblobdiffline $bdf $diffids]\n}\n\nproc savecmitpos {} {\n    global ctext cmitmode\n\n    if {$cmitmode eq \"tree\"} {\n        return {}\n    }\n    return [list target_scrollpos [$ctext index @0,0]]\n}\n\nproc savectextpos {} {\n    global ctext\n\n    return [list target_scrollpos [$ctext index @0,0]]\n}\n\nproc maybe_scroll_ctext {ateof} {\n    global ctext target_scrollpos\n\n    if {![info exists target_scrollpos]} return\n    if {!$ateof} {\n        set nlines [expr {[winfo height $ctext]\n                          / [font metrics textfont -linespace]}]\n        if {[$ctext compare \"$target_scrollpos + $nlines lines\" <= end]} return\n    }\n    $ctext yview $target_scrollpos\n    unset target_scrollpos\n}\n\nproc setinlist {var i val} {\n    global $var\n\n    while {[llength [set $var]] < $i} {\n        lappend $var {}\n    }\n    if {[llength [set $var]] == $i} {\n        lappend $var $val\n    } else {\n        lset $var $i $val\n    }\n}\n\nproc makediffhdr {fname ids} {\n    global ctext curdiffstart treediffs diffencoding\n    global ctext_file_names jump_to_here targetline diffline\n\n    set fname [encoding convertfrom utf-8 $fname]\n    set diffencoding [get_path_encoding $fname]\n    set i [lsearch -exact $treediffs($ids) $fname]\n    if {$i >= 0} {\n        setinlist difffilestart $i $curdiffstart\n    }\n    lset ctext_file_names end $fname\n    set l [expr {(78 - [string length $fname]) / 2}]\n    set pad [string range \"----------------------------------------\" 1 $l]\n    $ctext insert $curdiffstart \"$pad $fname $pad\" filesep\n    set targetline {}\n    if {$jump_to_here ne {} && [lindex $jump_to_here 0] eq $fname} {\n        set targetline [lindex $jump_to_here 1]\n    }\n    set diffline 0\n}\n\nproc blobdiffmaybeseehere {ateof} {\n    global diffseehere\n    if {$diffseehere >= 0} {\n        mark_ctext_line [lindex [split $diffseehere .] 0]\n    }\n    maybe_scroll_ctext $ateof\n}\n\nproc getblobdiffline {bdf ids} {\n    global diffids blobdifffd\n    global ctext\n\n    set nr 0\n    $ctext conf -state normal\n    while {[incr nr] <= 1000 && [gets $bdf line] >= 0} {\n        if {$ids != $diffids || $bdf != $blobdifffd($ids)} {\n            # Older diff read. Abort it.\n            catch {close $bdf}\n            if {$ids != $diffids} {\n                array unset blobdifffd $ids\n            }\n            return 0\n        }\n        parseblobdiffline $ids $line\n    }\n    $ctext conf -state disabled\n    blobdiffmaybeseehere [eof $bdf]\n    if {[eof $bdf]} {\n        catch {close $bdf}\n        array unset blobdifffd $ids\n        return 0\n    }\n    return [expr {$nr >= 1000? 2: 1}]\n}\n\nproc parseblobdiffline {ids line} {\n    global ctext curdiffstart\n    global diffnexthead diffnextnote difffilestart\n    global ctext_file_names ctext_file_lines\n    global diffinhdr treediffs mergemax diffnparents\n    global diffencoding jump_to_here targetline diffline currdiffsubmod\n    global worddiff diffseehere\n\n    if {![string compare -length 5 \"diff \" $line]} {\n        if {![regexp {^diff (--cc|--git) } $line m type]} {\n            set line [encoding convertfrom utf-8 $line]\n            $ctext insert end \"$line\\n\" hunksep\n            continue\n        }\n        # start of a new file\n        set diffinhdr 1\n        set currdiffsubmod \"\"\n\n        $ctext insert end \"\\n\"\n        set curdiffstart [$ctext index \"end - 1c\"]\n        lappend ctext_file_names \"\"\n        lappend ctext_file_lines [lindex [split $curdiffstart \".\"] 0]\n        $ctext insert end \"\\n\" filesep\n\n        if {$type eq \"--cc\"} {\n            # start of a new file in a merge diff\n            set fname [string range $line 10 end]\n            if {[lsearch -exact $treediffs($ids) $fname] < 0} {\n                lappend treediffs($ids) $fname\n                add_flist [list $fname]\n            }\n\n        } else {\n            set line [string range $line 11 end]\n            # If the name hasn't changed the length will be odd,\n            # the middle char will be a space, and the two bits either\n            # side will be a/name and b/name, or \"a/name\" and \"b/name\".\n            # If the name has changed we'll get \"rename from\" and\n            # \"rename to\" or \"copy from\" and \"copy to\" lines following\n            # this, and we'll use them to get the filenames.\n            # This complexity is necessary because spaces in the\n            # filename(s) don't get escaped.\n            set l [string length $line]\n            set i [expr {$l / 2}]\n            if {!(($l & 1) && [string index $line $i] eq \" \" &&\n                  [string range $line 2 [expr {$i - 1}]] eq \\\n                      [string range $line [expr {$i + 3}] end])} {\n                return\n            }\n            # unescape if quoted and chop off the a/ from the front\n            if {[string index $line 0] eq \"\\\"\"} {\n                set fname [string range [lindex $line 0] 2 end]\n            } else {\n                set fname [string range $line 2 [expr {$i - 1}]]\n            }\n        }\n        makediffhdr $fname $ids\n\n    } elseif {![string compare -length 16 \"* Unmerged path \" $line]} {\n        set fname [encoding convertfrom utf-8 [string range $line 16 end]]\n        $ctext insert end \"\\n\"\n        set curdiffstart [$ctext index \"end - 1c\"]\n        lappend ctext_file_names $fname\n        lappend ctext_file_lines [lindex [split $curdiffstart \".\"] 0]\n        $ctext insert end \"$line\\n\" filesep\n        set i [lsearch -exact $treediffs($ids) $fname]\n        if {$i >= 0} {\n            setinlist difffilestart $i $curdiffstart\n        }\n\n    } elseif {![string compare -length 2 \"@@\" $line]} {\n        regexp {^@@+} $line ats\n        set line [encoding convertfrom $diffencoding $line]\n        $ctext insert end \"$line\\n\" hunksep\n        if {[regexp { \\+(\\d+),\\d+ @@} $line m nl]} {\n            set diffline $nl\n        }\n        set diffnparents [expr {[string length $ats] - 1}]\n        set diffinhdr 0\n\n    } elseif {![string compare -length 10 \"Submodule \" $line]} {\n        # start of a new submodule\n        if {[regexp -indices \"\\[0-9a-f\\]+\\\\.\\\\.\" $line nameend]} {\n            set fname [string range $line 10 [expr [lindex $nameend 0] - 2]]\n        } else {\n            set fname [string range $line 10 [expr [string first \"contains \" $line] - 2]]\n        }\n        if {$currdiffsubmod != $fname} {\n            $ctext insert end \"\\n\";     # Add newline after commit message\n        }\n        if {$currdiffsubmod != $fname} {\n            set curdiffstart [$ctext index \"end - 1c\"]\n            lappend ctext_file_names \"\"\n            lappend ctext_file_lines [lindex [split $curdiffstart \".\"] 0]\n            makediffhdr $fname $ids\n            set currdiffsubmod $fname\n            $ctext insert end \"\\n$line\\n\" filesep\n        } else {\n            $ctext insert end \"$line\\n\" filesep\n        }\n    } elseif {$currdiffsubmod != \"\" && ![string compare -length 3 \"  >\" $line]} {\n        set line [encoding convertfrom $diffencoding $line]\n        $ctext insert end \"$line\\n\" dresult\n    } elseif {$currdiffsubmod != \"\" && ![string compare -length 3 \"  <\" $line]} {\n        set line [encoding convertfrom $diffencoding $line]\n        $ctext insert end \"$line\\n\" d0\n    } elseif {$diffinhdr} {\n        if {![string compare -length 12 \"rename from \" $line]} {\n            set fname [string range $line [expr 6 + [string first \" from \" $line] ] end]\n            if {[string index $fname 0] eq \"\\\"\"} {\n                set fname [lindex $fname 0]\n            }\n            set fname [encoding convertfrom utf-8 $fname]\n            set i [lsearch -exact $treediffs($ids) $fname]\n            if {$i >= 0} {\n                setinlist difffilestart $i $curdiffstart\n            }\n        } elseif {![string compare -length 10 $line \"rename to \"] ||\n                  ![string compare -length 8 $line \"copy to \"]} {\n            set fname [string range $line [expr 4 + [string first \" to \" $line] ] end]\n            if {[string index $fname 0] eq \"\\\"\"} {\n                set fname [lindex $fname 0]\n            }\n            makediffhdr $fname $ids\n        } elseif {[string compare -length 3 $line \"---\"] == 0} {\n            # do nothing\n            return\n        } elseif {[string compare -length 3 $line \"+++\"] == 0} {\n            set diffinhdr 0\n            return\n        }\n        set line [encoding convertfrom utf-8 $line]\n        $ctext insert end \"$line\\n\" filesep\n\n    } else {\n        set line [string map {\\x1A ^Z} \\\n                      [encoding convertfrom $diffencoding $line]]\n        # parse the prefix - one ' ', '-' or '+' for each parent\n        set prefix [string range $line 0 [expr {$diffnparents - 1}]]\n        set tag [expr {$diffnparents > 1? \"m\": \"d\"}]\n        set dowords [expr {$worddiff ne [mc \"Line diff\"] && $diffnparents == 1}]\n        set words_pre_markup \"\"\n        set words_post_markup \"\"\n        if {[string trim $prefix \" -+\"] eq {}} {\n            # prefix only has \" \", \"-\" and \"+\" in it: normal diff line\n            set num [string first \"-\" $prefix]\n            if {$dowords} {\n                set line [string range $line 1 end]\n            }\n            if {$num >= 0} {\n                # removed line, first parent with line is $num\n                if {$num >= $mergemax} {\n                    set num \"max\"\n                }\n                if {$dowords && $worddiff eq [mc \"Markup words\"]} {\n                    $ctext insert end \"\\[-$line-\\]\" $tag$num\n                } else {\n                    $ctext insert end \"$line\" $tag$num\n                }\n                if {!$dowords} {\n                    $ctext insert end \"\\n\" $tag$num\n                }\n            } else {\n                set tags {}\n                if {[string first \"+\" $prefix] >= 0} {\n                    # added line\n                    lappend tags ${tag}result\n                    if {$diffnparents > 1} {\n                        set num [string first \" \" $prefix]\n                        if {$num >= 0} {\n                            if {$num >= $mergemax} {\n                                set num \"max\"\n                            }\n                            lappend tags m$num\n                        }\n                    }\n                    set words_pre_markup \"{+\"\n                    set words_post_markup \"+}\"\n                }\n                if {$targetline ne {}} {\n                    if {$diffline == $targetline} {\n                        set diffseehere [$ctext index \"end - 1 chars\"]\n                        set targetline {}\n                    } else {\n                        incr diffline\n                    }\n                }\n                if {$dowords && $worddiff eq [mc \"Markup words\"]} {\n                    $ctext insert end \"$words_pre_markup$line$words_post_markup\" $tags\n                } else {\n                    $ctext insert end \"$line\" $tags\n                }\n                if {!$dowords} {\n                    $ctext insert end \"\\n\" $tags\n                }\n            }\n        } elseif {$dowords && $prefix eq \"~\"} {\n            $ctext insert end \"\\n\" {}\n        } else {\n            # \"\\ No newline at end of file\",\n            # or something else we don't recognize\n            $ctext insert end \"$line\\n\" hunksep\n        }\n    }\n}\n\nproc changediffdisp {} {\n    global ctext diffelide\n\n    $ctext tag conf d0 -elide [lindex $diffelide 0]\n    $ctext tag conf dresult -elide [lindex $diffelide 1]\n}\n\nproc highlightfile {cline} {\n    global cflist cflist_top\n\n    if {![info exists cflist_top]} return\n\n    $cflist tag remove highlight $cflist_top.0 \"$cflist_top.0 lineend\"\n    $cflist tag add highlight $cline.0 \"$cline.0 lineend\"\n    $cflist see $cline.0\n    set cflist_top $cline\n}\n\nproc highlightfile_for_scrollpos {topidx} {\n    global cmitmode difffilestart\n\n    if {$cmitmode eq \"tree\"} return\n    if {![info exists difffilestart]} return\n\n    set top [lindex [split $topidx .] 0]\n    if {$difffilestart eq {} || $top < [lindex $difffilestart 0]} {\n        highlightfile 0\n    } else {\n        highlightfile [expr {[bsearch $difffilestart $top] + 2}]\n    }\n}\n\nproc prevfile {} {\n    global difffilestart ctext cmitmode\n\n    if {$cmitmode eq \"tree\"} return\n    set prev 0.0\n    set here [$ctext index @0,0]\n    foreach loc $difffilestart {\n        if {[$ctext compare $loc >= $here]} {\n            $ctext yview $prev\n            return\n        }\n        set prev $loc\n    }\n    $ctext yview $prev\n}\n\nproc nextfile {} {\n    global difffilestart ctext cmitmode\n\n    if {$cmitmode eq \"tree\"} return\n    set here [$ctext index @0,0]\n    foreach loc $difffilestart {\n        if {[$ctext compare $loc > $here]} {\n            $ctext yview $loc\n            return\n        }\n    }\n}\n\nproc clear_ctext {{first 1.0}} {\n    global ctext smarktop smarkbot\n    global ctext_file_names ctext_file_lines\n    global pendinglinks\n\n    set l [lindex [split $first .] 0]\n    if {![info exists smarktop] || [$ctext compare $first < $smarktop.0]} {\n        set smarktop $l\n    }\n    if {![info exists smarkbot] || [$ctext compare $first < $smarkbot.0]} {\n        set smarkbot $l\n    }\n    $ctext delete $first end\n    if {$first eq \"1.0\"} {\n        unset -nocomplain pendinglinks\n    }\n    set ctext_file_names {}\n    set ctext_file_lines {}\n}\n\nproc settabs {{firstab {}}} {\n    global firsttabstop tabstop ctext have_tk85\n\n    if {$firstab ne {} && $have_tk85} {\n        set firsttabstop $firstab\n    }\n    set w [font measure textfont \"0\"]\n    if {$firsttabstop != 0} {\n        $ctext conf -tabs [list [expr {($firsttabstop + $tabstop) * $w}] \\\n                               [expr {($firsttabstop + 2 * $tabstop) * $w}]]\n    } elseif {$have_tk85 || $tabstop != 8} {\n        $ctext conf -tabs [expr {$tabstop * $w}]\n    } else {\n        $ctext conf -tabs {}\n    }\n}\n\nproc incrsearch {name ix op} {\n    global ctext searchstring searchdirn\n\n    if {[catch {$ctext index anchor}]} {\n        # no anchor set, use start of selection, or of visible area\n        set sel [$ctext tag ranges sel]\n        if {$sel ne {}} {\n            $ctext mark set anchor [lindex $sel 0]\n        } elseif {$searchdirn eq \"-forwards\"} {\n            $ctext mark set anchor @0,0\n        } else {\n            $ctext mark set anchor @0,[winfo height $ctext]\n        }\n    }\n    if {$searchstring ne {}} {\n        set here [$ctext search -count mlen $searchdirn -- $searchstring anchor]\n        if {$here ne {}} {\n            $ctext see $here\n            set mend \"$here + $mlen c\"\n            $ctext tag remove sel 1.0 end\n            $ctext tag add sel $here $mend\n            suppress_highlighting_file_for_current_scrollpos\n            highlightfile_for_scrollpos $here\n        }\n    }\n    rehighlight_search_results\n}\n\nproc dosearch {} {\n    global sstring ctext searchstring searchdirn\n\n    focus $sstring\n    $sstring icursor end\n    set searchdirn -forwards\n    if {$searchstring ne {}} {\n        set sel [$ctext tag ranges sel]\n        if {$sel ne {}} {\n            set start \"[lindex $sel 0] + 1c\"\n        } elseif {[catch {set start [$ctext index anchor]}]} {\n            set start \"@0,0\"\n        }\n        set match [$ctext search -count mlen -- $searchstring $start]\n        $ctext tag remove sel 1.0 end\n        if {$match eq {}} {\n            bell\n            return\n        }\n        $ctext see $match\n        suppress_highlighting_file_for_current_scrollpos\n        highlightfile_for_scrollpos $match\n        set mend \"$match + $mlen c\"\n        $ctext tag add sel $match $mend\n        $ctext mark unset anchor\n        rehighlight_search_results\n    }\n}\n\nproc dosearchback {} {\n    global sstring ctext searchstring searchdirn\n\n    focus $sstring\n    $sstring icursor end\n    set searchdirn -backwards\n    if {$searchstring ne {}} {\n        set sel [$ctext tag ranges sel]\n        if {$sel ne {}} {\n            set start [lindex $sel 0]\n        } elseif {[catch {set start [$ctext index anchor]}]} {\n            set start @0,[winfo height $ctext]\n        }\n        set match [$ctext search -backwards -count ml -- $searchstring $start]\n        $ctext tag remove sel 1.0 end\n        if {$match eq {}} {\n            bell\n            return\n        }\n        $ctext see $match\n        suppress_highlighting_file_for_current_scrollpos\n        highlightfile_for_scrollpos $match\n        set mend \"$match + $ml c\"\n        $ctext tag add sel $match $mend\n        $ctext mark unset anchor\n        rehighlight_search_results\n    }\n}\n\nproc rehighlight_search_results {} {\n    global ctext searchstring\n\n    $ctext tag remove found 1.0 end\n    $ctext tag remove currentsearchhit 1.0 end\n\n    if {$searchstring ne {}} {\n        searchmarkvisible 1\n    }\n}\n\nproc searchmark {first last} {\n    global ctext searchstring\n\n    set sel [$ctext tag ranges sel]\n\n    set mend $first.0\n    while {1} {\n        set match [$ctext search -count mlen -- $searchstring $mend $last.end]\n        if {$match eq {}} break\n        set mend \"$match + $mlen c\"\n        if {$sel ne {} && [$ctext compare $match == [lindex $sel 0]]} {\n            $ctext tag add currentsearchhit $match $mend\n        } else {\n            $ctext tag add found $match $mend\n        }\n    }\n}\n\nproc searchmarkvisible {doall} {\n    global ctext smarktop smarkbot\n\n    set topline [lindex [split [$ctext index @0,0] .] 0]\n    set botline [lindex [split [$ctext index @0,[winfo height $ctext]] .] 0]\n    if {$doall || $botline < $smarktop || $topline > $smarkbot} {\n        # no overlap with previous\n        searchmark $topline $botline\n        set smarktop $topline\n        set smarkbot $botline\n    } else {\n        if {$topline < $smarktop} {\n            searchmark $topline [expr {$smarktop-1}]\n            set smarktop $topline\n        }\n        if {$botline > $smarkbot} {\n            searchmark [expr {$smarkbot+1}] $botline\n            set smarkbot $botline\n        }\n    }\n}\n\nproc suppress_highlighting_file_for_current_scrollpos {} {\n    global ctext suppress_highlighting_file_for_this_scrollpos\n\n    set suppress_highlighting_file_for_this_scrollpos [$ctext index @0,0]\n}\n\nproc scrolltext {f0 f1} {\n    global searchstring cmitmode ctext\n    global suppress_highlighting_file_for_this_scrollpos\n\n    set topidx [$ctext index @0,0]\n    if {![info exists suppress_highlighting_file_for_this_scrollpos]\n        || $topidx ne $suppress_highlighting_file_for_this_scrollpos} {\n        highlightfile_for_scrollpos $topidx\n    }\n\n    unset -nocomplain suppress_highlighting_file_for_this_scrollpos\n\n    .bleft.bottom.sb set $f0 $f1\n    if {$searchstring ne {}} {\n        searchmarkvisible 0\n    }\n}\n\nproc setcoords {} {\n    global linespc charspc canvx0 canvy0\n    global xspc1 xspc2 lthickness\n\n    set linespc [font metrics mainfont -linespace]\n    set charspc [font measure mainfont \"m\"]\n    set canvy0 [expr {int(3 + 0.5 * $linespc)}]\n    set canvx0 [expr {int(3 + 0.5 * $linespc)}]\n    set lthickness [expr {int($linespc / 9) + 1}]\n    set xspc1(0) $linespc\n    set xspc2 $linespc\n}\n\nproc redisplay {} {\n    global canv\n    global selectedline\n\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax eq {} || $ymax == 0} return\n    set span [$canv yview]\n    clear_display\n    setcanvscroll\n    allcanvs yview moveto [lindex $span 0]\n    drawvisible\n    if {$selectedline ne {}} {\n        selectline $selectedline 0\n        allcanvs yview moveto [lindex $span 0]\n    }\n}\n\nproc parsefont {f n} {\n    global fontattr\n\n    set fontattr($f,family) [lindex $n 0]\n    set s [lindex $n 1]\n    if {$s eq {} || $s == 0} {\n        set s 10\n    } elseif {$s < 0} {\n        set s [expr {int(-$s / [winfo fpixels . 1p] + 0.5)}]\n    }\n    set fontattr($f,size) $s\n    set fontattr($f,weight) normal\n    set fontattr($f,slant) roman\n    foreach style [lrange $n 2 end] {\n        switch -- $style {\n            \"normal\" -\n            \"bold\"   {set fontattr($f,weight) $style}\n            \"roman\" -\n            \"italic\" {set fontattr($f,slant) $style}\n        }\n    }\n}\n\nproc fontflags {f {isbold 0}} {\n    global fontattr\n\n    return [list -family $fontattr($f,family) -size $fontattr($f,size) \\\n                -weight [expr {$isbold? \"bold\": $fontattr($f,weight)}] \\\n                -slant $fontattr($f,slant)]\n}\n\nproc fontname {f} {\n    global fontattr\n\n    set n [list $fontattr($f,family) $fontattr($f,size)]\n    if {$fontattr($f,weight) eq \"bold\"} {\n        lappend n \"bold\"\n    }\n    if {$fontattr($f,slant) eq \"italic\"} {\n        lappend n \"italic\"\n    }\n    return $n\n}\n\nproc incrfont {inc} {\n    global mainfont textfont ctext canv cflist showrefstop\n    global stopped entries fontattr\n\n    unmarkmatches\n    set s $fontattr(mainfont,size)\n    incr s $inc\n    if {$s < 1} {\n        set s 1\n    }\n    set fontattr(mainfont,size) $s\n    font config mainfont -size $s\n    font config mainfontbold -size $s\n    set mainfont [fontname mainfont]\n    set s $fontattr(textfont,size)\n    incr s $inc\n    if {$s < 1} {\n        set s 1\n    }\n    set fontattr(textfont,size) $s\n    font config textfont -size $s\n    font config textfontbold -size $s\n    set textfont [fontname textfont]\n    setcoords\n    settabs\n    redisplay\n}\n\nproc clearsha1 {} {\n    global sha1entry sha1string\n    if {[string length $sha1string] == 40} {\n        $sha1entry delete 0 end\n    }\n}\n\nproc sha1change {n1 n2 op} {\n    global sha1string currentid sha1but\n    if {$sha1string == {}\n        || ([info exists currentid] && $sha1string == $currentid)} {\n        set state disabled\n    } else {\n        set state normal\n    }\n    if {[$sha1but cget -state] == $state} return\n    if {$state == \"normal\"} {\n        $sha1but conf -state normal -relief raised -text \"[mc \"Goto:\"] \"\n    } else {\n        $sha1but conf -state disabled -relief flat -text \"[mc \"SHA1 ID:\"] \"\n    }\n}\n\nproc gotocommit {} {\n    global sha1string tagids headids curview varcid\n\n    if {$sha1string == {}\n        || ([info exists currentid] && $sha1string == $currentid)} return\n    if {[info exists tagids($sha1string)]} {\n        set id $tagids($sha1string)\n    } elseif {[info exists headids($sha1string)]} {\n        set id $headids($sha1string)\n    } else {\n        set id [string tolower $sha1string]\n        if {[regexp {^[0-9a-f]{4,39}$} $id]} {\n            set matches [longid $id]\n            if {$matches ne {}} {\n                if {[llength $matches] > 1} {\n                    error_popup [mc \"Short SHA1 id %s is ambiguous\" $id]\n                    return\n                }\n                set id [lindex $matches 0]\n            }\n        } else {\n            if {[catch {set id [exec git rev-parse --verify $sha1string]}]} {\n                error_popup [mc \"Revision %s is not known\" $sha1string]\n                return\n            }\n        }\n    }\n    if {[commitinview $id $curview]} {\n        selectline [rowofcommit $id] 1\n        return\n    }\n    if {[regexp {^[0-9a-fA-F]{4,}$} $sha1string]} {\n        set msg [mc \"SHA1 id %s is not known\" $sha1string]\n    } else {\n        set msg [mc \"Revision %s is not in the current view\" $sha1string]\n    }\n    error_popup $msg\n}\n\nproc lineenter {x y id} {\n    global hoverx hovery hoverid hovertimer\n    global commitinfo canv\n\n    if {![info exists commitinfo($id)] && ![getcommit $id]} return\n    set hoverx $x\n    set hovery $y\n    set hoverid $id\n    if {[info exists hovertimer]} {\n        after cancel $hovertimer\n    }\n    set hovertimer [after 500 linehover]\n    $canv delete hover\n}\n\nproc linemotion {x y id} {\n    global hoverx hovery hoverid hovertimer\n\n    if {[info exists hoverid] && $id == $hoverid} {\n        set hoverx $x\n        set hovery $y\n        if {[info exists hovertimer]} {\n            after cancel $hovertimer\n        }\n        set hovertimer [after 500 linehover]\n    }\n}\n\nproc lineleave {id} {\n    global hoverid hovertimer canv\n\n    if {[info exists hoverid] && $id == $hoverid} {\n        $canv delete hover\n        if {[info exists hovertimer]} {\n            after cancel $hovertimer\n            unset hovertimer\n        }\n        unset hoverid\n    }\n}\n\nproc linehover {} {\n    global hoverx hovery hoverid hovertimer\n    global canv linespc lthickness\n    global linehoverbgcolor linehoverfgcolor linehoveroutlinecolor\n\n    global commitinfo\n\n    set text [lindex $commitinfo($hoverid) 0]\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax == {}} return\n    set yfrac [lindex [$canv yview] 0]\n    set x [expr {$hoverx + 2 * $linespc}]\n    set y [expr {$hovery + $yfrac * $ymax - $linespc / 2}]\n    set x0 [expr {$x - 2 * $lthickness}]\n    set y0 [expr {$y - 2 * $lthickness}]\n    set x1 [expr {$x + [font measure mainfont $text] + 2 * $lthickness}]\n    set y1 [expr {$y + $linespc + 2 * $lthickness}]\n    set t [$canv create rectangle $x0 $y0 $x1 $y1 \\\n               -fill $linehoverbgcolor -outline $linehoveroutlinecolor \\\n               -width 1 -tags hover]\n    $canv raise $t\n    set t [$canv create text $x $y -anchor nw -text $text -tags hover \\\n               -font mainfont -fill $linehoverfgcolor]\n    $canv raise $t\n}\n\nproc clickisonarrow {id y} {\n    global lthickness\n\n    set ranges [rowranges $id]\n    set thresh [expr {2 * $lthickness + 6}]\n    set n [expr {[llength $ranges] - 1}]\n    for {set i 1} {$i < $n} {incr i} {\n        set row [lindex $ranges $i]\n        if {abs([yc $row] - $y) < $thresh} {\n            return $i\n        }\n    }\n    return {}\n}\n\nproc arrowjump {id n y} {\n    global canv\n\n    # 1 <-> 2, 3 <-> 4, etc...\n    set n [expr {(($n - 1) ^ 1) + 1}]\n    set row [lindex [rowranges $id] $n]\n    set yt [yc $row]\n    set ymax [lindex [$canv cget -scrollregion] 3]\n    if {$ymax eq {} || $ymax <= 0} return\n    set view [$canv yview]\n    set yspan [expr {[lindex $view 1] - [lindex $view 0]}]\n    set yfrac [expr {$yt / $ymax - $yspan / 2}]\n    if {$yfrac < 0} {\n        set yfrac 0\n    }\n    allcanvs yview moveto $yfrac\n}\n\nproc lineclick {x y id isnew} {\n    global ctext commitinfo children canv thickerline curview\n\n    if {![info exists commitinfo($id)] && ![getcommit $id]} return\n    unmarkmatches\n    unselectline\n    normalline\n    $canv delete hover\n    # draw this line thicker than normal\n    set thickerline $id\n    drawlines $id\n    if {$isnew} {\n        set ymax [lindex [$canv cget -scrollregion] 3]\n        if {$ymax eq {}} return\n        set yfrac [lindex [$canv yview] 0]\n        set y [expr {$y + $yfrac * $ymax}]\n    }\n    set dirn [clickisonarrow $id $y]\n    if {$dirn ne {}} {\n        arrowjump $id $dirn $y\n        return\n    }\n\n    if {$isnew} {\n        addtohistory [list lineclick $x $y $id 0] savectextpos\n    }\n    # fill the details pane with info about this line\n    $ctext conf -state normal\n    clear_ctext\n    settabs 0\n    $ctext insert end \"[mc \"Parent\"]:\\t\"\n    $ctext insert end $id link0\n    setlink $id link0\n    set info $commitinfo($id)\n    $ctext insert end \"\\n\\t[lindex $info 0]\\n\"\n    $ctext insert end \"\\t[mc \"Author\"]:\\t[lindex $info 1]\\n\"\n    set date [formatdate [lindex $info 2]]\n    $ctext insert end \"\\t[mc \"Date\"]:\\t$date\\n\"\n    set kids $children($curview,$id)\n    if {$kids ne {}} {\n        $ctext insert end \"\\n[mc \"Children\"]:\"\n        set i 0\n        foreach child $kids {\n            incr i\n            if {![info exists commitinfo($child)] && ![getcommit $child]} continue\n            set info $commitinfo($child)\n            $ctext insert end \"\\n\\t\"\n            $ctext insert end $child link$i\n            setlink $child link$i\n            $ctext insert end \"\\n\\t[lindex $info 0]\"\n            $ctext insert end \"\\n\\t[mc \"Author\"]:\\t[lindex $info 1]\"\n            set date [formatdate [lindex $info 2]]\n            $ctext insert end \"\\n\\t[mc \"Date\"]:\\t$date\\n\"\n        }\n    }\n    maybe_scroll_ctext 1\n    $ctext conf -state disabled\n    init_flist {}\n}\n\nproc normalline {} {\n    global thickerline\n    if {[info exists thickerline]} {\n        set id $thickerline\n        unset thickerline\n        drawlines $id\n    }\n}\n\nproc selbyid {id {isnew 1}} {\n    global curview\n    if {[commitinview $id $curview]} {\n        selectline [rowofcommit $id] $isnew\n    }\n}\n\nproc mstime {} {\n    global startmstime\n    if {![info exists startmstime]} {\n        set startmstime [clock clicks -milliseconds]\n    }\n    return [format \"%.3f\" [expr {([clock click -milliseconds] - $startmstime) / 1000.0}]]\n}\n\nproc rowmenu {x y id} {\n    global rowctxmenu selectedline rowmenuid curview\n    global nullid nullid2 fakerowmenu mainhead markedid\n\n    stopfinding\n    set rowmenuid $id\n    if {$selectedline eq {} || [rowofcommit $id] eq $selectedline} {\n        set state disabled\n    } else {\n        set state normal\n    }\n    if {[info exists markedid] && $markedid ne $id} {\n        set mstate normal\n    } else {\n        set mstate disabled\n    }\n    if {$id ne $nullid && $id ne $nullid2} {\n        set menu $rowctxmenu\n        if {$mainhead ne {}} {\n            $menu entryconfigure 8 -label [mc \"Reset %s branch to here\" $mainhead] -state normal\n        } else {\n            $menu entryconfigure 8 -label [mc \"Detached head: can't reset\" $mainhead] -state disabled\n        }\n        $menu entryconfigure 10 -state $mstate\n        $menu entryconfigure 11 -state $mstate\n        $menu entryconfigure 12 -state $mstate\n    } else {\n        set menu $fakerowmenu\n    }\n    $menu entryconfigure [mca \"Diff this -> selected\"] -state $state\n    $menu entryconfigure [mca \"Diff selected -> this\"] -state $state\n    $menu entryconfigure [mca \"Make patch\"] -state $state\n    $menu entryconfigure [mca \"Diff this -> marked commit\"] -state $mstate\n    $menu entryconfigure [mca \"Diff marked commit -> this\"] -state $mstate\n    tk_popup $menu $x $y\n}\n\nproc markhere {} {\n    global rowmenuid markedid canv\n\n    set markedid $rowmenuid\n    make_idmark $markedid\n}\n\nproc gotomark {} {\n    global markedid\n\n    if {[info exists markedid]} {\n        selbyid $markedid\n    }\n}\n\nproc replace_by_kids {l r} {\n    global curview children\n\n    set id [commitonrow $r]\n    set l [lreplace $l 0 0]\n    foreach kid $children($curview,$id) {\n        lappend l [rowofcommit $kid]\n    }\n    return [lsort -integer -decreasing -unique $l]\n}\n\nproc find_common_desc {} {\n    global markedid rowmenuid curview children\n\n    if {![info exists markedid]} return\n    if {![commitinview $markedid $curview] ||\n        ![commitinview $rowmenuid $curview]} return\n    #set t1 [clock clicks -milliseconds]\n    set l1 [list [rowofcommit $markedid]]\n    set l2 [list [rowofcommit $rowmenuid]]\n    while 1 {\n        set r1 [lindex $l1 0]\n        set r2 [lindex $l2 0]\n        if {$r1 eq {} || $r2 eq {}} break\n        if {$r1 == $r2} {\n            selectline $r1 1\n            break\n        }\n        if {$r1 > $r2} {\n            set l1 [replace_by_kids $l1 $r1]\n        } else {\n            set l2 [replace_by_kids $l2 $r2]\n        }\n    }\n    #set t2 [clock clicks -milliseconds]\n    #puts \"took [expr {$t2-$t1}]ms\"\n}\n\nproc compare_commits {} {\n    global markedid rowmenuid curview children\n\n    if {![info exists markedid]} return\n    if {![commitinview $markedid $curview]} return\n    addtohistory [list do_cmp_commits $markedid $rowmenuid]\n    do_cmp_commits $markedid $rowmenuid\n}\n\nproc getpatchid {id} {\n    global patchids\n\n    if {![info exists patchids($id)]} {\n        set cmd [diffcmd [list $id] {-p --root}]\n        # trim off the initial \"|\"\n        set cmd [lrange $cmd 1 end]\n        if {[catch {\n            set x [eval exec $cmd | git patch-id]\n            set patchids($id) [lindex $x 0]\n        }]} {\n            set patchids($id) \"error\"\n        }\n    }\n    return $patchids($id)\n}\n\nproc do_cmp_commits {a b} {\n    global ctext curview parents children patchids commitinfo\n\n    $ctext conf -state normal\n    clear_ctext\n    init_flist {}\n    for {set i 0} {$i < 100} {incr i} {\n        set skipa 0\n        set skipb 0\n        if {[llength $parents($curview,$a)] > 1} {\n            appendshortlink $a [mc \"Skipping merge commit \"] \"\\n\"\n            set skipa 1\n        } else {\n            set patcha [getpatchid $a]\n        }\n        if {[llength $parents($curview,$b)] > 1} {\n            appendshortlink $b [mc \"Skipping merge commit \"] \"\\n\"\n            set skipb 1\n        } else {\n            set patchb [getpatchid $b]\n        }\n        if {!$skipa && !$skipb} {\n            set heada [lindex $commitinfo($a) 0]\n            set headb [lindex $commitinfo($b) 0]\n            if {$patcha eq \"error\"} {\n                appendshortlink $a [mc \"Error getting patch ID for \"] \\\n                    [mc \" - stopping\\n\"]\n                break\n            }\n            if {$patchb eq \"error\"} {\n                appendshortlink $b [mc \"Error getting patch ID for \"] \\\n                    [mc \" - stopping\\n\"]\n                break\n            }\n            if {$patcha eq $patchb} {\n                if {$heada eq $headb} {\n                    appendshortlink $a [mc \"Commit \"]\n                    appendshortlink $b \" == \" \"  $heada\\n\"\n                } else {\n                    appendshortlink $a [mc \"Commit \"] \"  $heada\\n\"\n                    appendshortlink $b [mc \" is the same patch as\\n       \"] \\\n                        \"  $headb\\n\"\n                }\n                set skipa 1\n                set skipb 1\n            } else {\n                $ctext insert end \"\\n\"\n                appendshortlink $a [mc \"Commit \"] \"  $heada\\n\"\n                appendshortlink $b [mc \" differs from\\n       \"] \\\n                    \"  $headb\\n\"\n                $ctext insert end [mc \"Diff of commits:\\n\\n\"]\n                $ctext conf -state disabled\n                update\n                diffcommits $a $b\n                return\n            }\n        }\n        if {$skipa} {\n            set kids [real_children $curview,$a]\n            if {[llength $kids] != 1} {\n                $ctext insert end \"\\n\"\n                appendshortlink $a [mc \"Commit \"] \\\n                    [mc \" has %s children - stopping\\n\" [llength $kids]]\n                break\n            }\n            set a [lindex $kids 0]\n        }\n        if {$skipb} {\n            set kids [real_children $curview,$b]\n            if {[llength $kids] != 1} {\n                appendshortlink $b [mc \"Commit \"] \\\n                    [mc \" has %s children - stopping\\n\" [llength $kids]]\n                break\n            }\n            set b [lindex $kids 0]\n        }\n    }\n    $ctext conf -state disabled\n}\n\nproc diffcommits {a b} {\n    global diffcontext diffids blobdifffd diffinhdr currdiffsubmod\n\n    set tmpdir [gitknewtmpdir]\n    set fna [file join $tmpdir \"commit-[string range $a 0 7]\"]\n    set fnb [file join $tmpdir \"commit-[string range $b 0 7]\"]\n    if {[catch {\n        exec git diff-tree -p --pretty $a >$fna\n        exec git diff-tree -p --pretty $b >$fnb\n    } err]} {\n        error_popup [mc \"Error writing commit to file: %s\" $err]\n        return\n    }\n    if {[catch {\n        set fd [open \"| diff -U$diffcontext $fna $fnb\" r]\n    } err]} {\n        error_popup [mc \"Error diffing commits: %s\" $err]\n        return\n    }\n    set diffids [list commits $a $b]\n    set blobdifffd($diffids) $fd\n    set diffinhdr 0\n    set currdiffsubmod \"\"\n    filerun $fd [list getblobdiffline $fd $diffids]\n}\n\nproc diffvssel {dirn} {\n    global rowmenuid selectedline\n\n    if {$selectedline eq {}} return\n    if {$dirn} {\n        set oldid [commitonrow $selectedline]\n        set newid $rowmenuid\n    } else {\n        set oldid $rowmenuid\n        set newid [commitonrow $selectedline]\n    }\n    addtohistory [list doseldiff $oldid $newid] savectextpos\n    doseldiff $oldid $newid\n}\n\nproc diffvsmark {dirn} {\n    global rowmenuid markedid\n\n    if {![info exists markedid]} return\n    if {$dirn} {\n        set oldid $markedid\n        set newid $rowmenuid\n    } else {\n        set oldid $rowmenuid\n        set newid $markedid\n    }\n    addtohistory [list doseldiff $oldid $newid] savectextpos\n    doseldiff $oldid $newid\n}\n\nproc doseldiff {oldid newid} {\n    global ctext\n    global commitinfo\n\n    $ctext conf -state normal\n    clear_ctext\n    init_flist [mc \"Top\"]\n    $ctext insert end \"[mc \"From\"] \"\n    $ctext insert end $oldid link0\n    setlink $oldid link0\n    $ctext insert end \"\\n     \"\n    $ctext insert end [lindex $commitinfo($oldid) 0]\n    $ctext insert end \"\\n\\n[mc \"To\"]   \"\n    $ctext insert end $newid link1\n    setlink $newid link1\n    $ctext insert end \"\\n     \"\n    $ctext insert end [lindex $commitinfo($newid) 0]\n    $ctext insert end \"\\n\"\n    $ctext conf -state disabled\n    $ctext tag remove found 1.0 end\n    startdiff [list $oldid $newid]\n}\n\nproc mkpatch {} {\n    global rowmenuid currentid commitinfo patchtop patchnum NS\n\n    if {![info exists currentid]} return\n    set oldid $currentid\n    set oldhead [lindex $commitinfo($oldid) 0]\n    set newid $rowmenuid\n    set newhead [lindex $commitinfo($newid) 0]\n    set top .patch\n    set patchtop $top\n    catch {destroy $top}\n    ttk_toplevel $top\n    make_transient $top .\n    ${NS}::label $top.title -text [mc \"Generate patch\"]\n    grid $top.title - -pady 10\n    ${NS}::label $top.from -text [mc \"From:\"]\n    ${NS}::entry $top.fromsha1 -width 40\n    $top.fromsha1 insert 0 $oldid\n    $top.fromsha1 conf -state readonly\n    grid $top.from $top.fromsha1 -sticky w\n    ${NS}::entry $top.fromhead -width 60\n    $top.fromhead insert 0 $oldhead\n    $top.fromhead conf -state readonly\n    grid x $top.fromhead -sticky w\n    ${NS}::label $top.to -text [mc \"To:\"]\n    ${NS}::entry $top.tosha1 -width 40\n    $top.tosha1 insert 0 $newid\n    $top.tosha1 conf -state readonly\n    grid $top.to $top.tosha1 -sticky w\n    ${NS}::entry $top.tohead -width 60\n    $top.tohead insert 0 $newhead\n    $top.tohead conf -state readonly\n    grid x $top.tohead -sticky w\n    ${NS}::button $top.rev -text [mc \"Reverse\"] -command mkpatchrev\n    grid $top.rev x -pady 10 -padx 5\n    ${NS}::label $top.flab -text [mc \"Output file:\"]\n    ${NS}::entry $top.fname -width 60\n    $top.fname insert 0 [file normalize \"patch$patchnum.patch\"]\n    incr patchnum\n    grid $top.flab $top.fname -sticky w\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.gen -text [mc \"Generate\"] -command mkpatchgo\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command mkpatchcan\n    bind $top <Key-Return> mkpatchgo\n    bind $top <Key-Escape> mkpatchcan\n    grid $top.buts.gen $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - -pady 10 -sticky ew\n    focus $top.fname\n}\n\nproc mkpatchrev {} {\n    global patchtop\n\n    set oldid [$patchtop.fromsha1 get]\n    set oldhead [$patchtop.fromhead get]\n    set newid [$patchtop.tosha1 get]\n    set newhead [$patchtop.tohead get]\n    foreach e [list fromsha1 fromhead tosha1 tohead] \\\n            v [list $newid $newhead $oldid $oldhead] {\n        $patchtop.$e conf -state normal\n        $patchtop.$e delete 0 end\n        $patchtop.$e insert 0 $v\n        $patchtop.$e conf -state readonly\n    }\n}\n\nproc mkpatchgo {} {\n    global patchtop nullid nullid2\n\n    set oldid [$patchtop.fromsha1 get]\n    set newid [$patchtop.tosha1 get]\n    set fname [$patchtop.fname get]\n    set cmd [diffcmd [list $oldid $newid] -p]\n    # trim off the initial \"|\"\n    set cmd [lrange $cmd 1 end]\n    lappend cmd >$fname &\n    if {[catch {eval exec $cmd} err]} {\n        error_popup \"[mc \"Error creating patch:\"] $err\" $patchtop\n    }\n    catch {destroy $patchtop}\n    unset patchtop\n}\n\nproc mkpatchcan {} {\n    global patchtop\n\n    catch {destroy $patchtop}\n    unset patchtop\n}\n\nproc mktag {} {\n    global rowmenuid mktagtop commitinfo NS\n\n    set top .maketag\n    set mktagtop $top\n    catch {destroy $top}\n    ttk_toplevel $top\n    make_transient $top .\n    ${NS}::label $top.title -text [mc \"Create tag\"]\n    grid $top.title - -pady 10\n    ${NS}::label $top.id -text [mc \"ID:\"]\n    ${NS}::entry $top.sha1 -width 40\n    $top.sha1 insert 0 $rowmenuid\n    $top.sha1 conf -state readonly\n    grid $top.id $top.sha1 -sticky w\n    ${NS}::entry $top.head -width 60\n    $top.head insert 0 [lindex $commitinfo($rowmenuid) 0]\n    $top.head conf -state readonly\n    grid x $top.head -sticky w\n    ${NS}::label $top.tlab -text [mc \"Tag name:\"]\n    ${NS}::entry $top.tag -width 60\n    grid $top.tlab $top.tag -sticky w\n    ${NS}::label $top.op -text [mc \"Tag message is optional\"]\n    grid $top.op -columnspan 2 -sticky we\n    ${NS}::label $top.mlab -text [mc \"Tag message:\"]\n    ${NS}::entry $top.msg -width 60\n    grid $top.mlab $top.msg -sticky w\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.gen -text [mc \"Create\"] -command mktaggo\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command mktagcan\n    bind $top <Key-Return> mktaggo\n    bind $top <Key-Escape> mktagcan\n    grid $top.buts.gen $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - -pady 10 -sticky ew\n    focus $top.tag\n}\n\nproc domktag {} {\n    global mktagtop env tagids idtags\n\n    set id [$mktagtop.sha1 get]\n    set tag [$mktagtop.tag get]\n    set msg [$mktagtop.msg get]\n    if {$tag == {}} {\n        error_popup [mc \"No tag name specified\"] $mktagtop\n        return 0\n    }\n    if {[info exists tagids($tag)]} {\n        error_popup [mc \"Tag \\\"%s\\\" already exists\" $tag] $mktagtop\n        return 0\n    }\n    if {[catch {\n        if {$msg != {}} {\n            exec git tag -a -m $msg $tag $id\n        } else {\n            exec git tag $tag $id\n        }\n    } err]} {\n        error_popup \"[mc \"Error creating tag:\"] $err\" $mktagtop\n        return 0\n    }\n\n    set tagids($tag) $id\n    lappend idtags($id) $tag\n    redrawtags $id\n    addedtag $id\n    dispneartags 0\n    run refill_reflist\n    return 1\n}\n\nproc redrawtags {id} {\n    global canv linehtag idpos currentid curview cmitlisted markedid\n    global canvxmax iddrawn circleitem mainheadid circlecolors\n    global mainheadcirclecolor\n\n    if {![commitinview $id $curview]} return\n    if {![info exists iddrawn($id)]} return\n    set row [rowofcommit $id]\n    if {$id eq $mainheadid} {\n        set ofill $mainheadcirclecolor\n    } else {\n        set ofill [lindex $circlecolors $cmitlisted($curview,$id)]\n    }\n    $canv itemconf $circleitem($row) -fill $ofill\n    $canv delete tag.$id\n    set xt [eval drawtags $id $idpos($id)]\n    $canv coords $linehtag($id) $xt [lindex $idpos($id) 2]\n    set text [$canv itemcget $linehtag($id) -text]\n    set font [$canv itemcget $linehtag($id) -font]\n    set xr [expr {$xt + [font measure $font $text]}]\n    if {$xr > $canvxmax} {\n        set canvxmax $xr\n        setcanvscroll\n    }\n    if {[info exists currentid] && $currentid == $id} {\n        make_secsel $id\n    }\n    if {[info exists markedid] && $markedid eq $id} {\n        make_idmark $id\n    }\n}\n\nproc mktagcan {} {\n    global mktagtop\n\n    catch {destroy $mktagtop}\n    unset mktagtop\n}\n\nproc mktaggo {} {\n    if {![domktag]} return\n    mktagcan\n}\n\nproc copyreference {} {\n    global rowmenuid autosellen\n\n    set format \"%h (\\\"%s\\\", %ad)\"\n    set cmd [list git show -s --pretty=format:$format --date=short]\n    if {$autosellen < 40} {\n        lappend cmd --abbrev=$autosellen\n    }\n    set reference [eval exec $cmd $rowmenuid]\n\n    clipboard clear\n    clipboard append $reference\n}\n\nproc writecommit {} {\n    global rowmenuid wrcomtop commitinfo wrcomcmd NS\n\n    set top .writecommit\n    set wrcomtop $top\n    catch {destroy $top}\n    ttk_toplevel $top\n    make_transient $top .\n    ${NS}::label $top.title -text [mc \"Write commit to file\"]\n    grid $top.title - -pady 10\n    ${NS}::label $top.id -text [mc \"ID:\"]\n    ${NS}::entry $top.sha1 -width 40\n    $top.sha1 insert 0 $rowmenuid\n    $top.sha1 conf -state readonly\n    grid $top.id $top.sha1 -sticky w\n    ${NS}::entry $top.head -width 60\n    $top.head insert 0 [lindex $commitinfo($rowmenuid) 0]\n    $top.head conf -state readonly\n    grid x $top.head -sticky w\n    ${NS}::label $top.clab -text [mc \"Command:\"]\n    ${NS}::entry $top.cmd -width 60 -textvariable wrcomcmd\n    grid $top.clab $top.cmd -sticky w -pady 10\n    ${NS}::label $top.flab -text [mc \"Output file:\"]\n    ${NS}::entry $top.fname -width 60\n    $top.fname insert 0 [file normalize \"commit-[string range $rowmenuid 0 6]\"]\n    grid $top.flab $top.fname -sticky w\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.gen -text [mc \"Write\"] -command wrcomgo\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command wrcomcan\n    bind $top <Key-Return> wrcomgo\n    bind $top <Key-Escape> wrcomcan\n    grid $top.buts.gen $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - -pady 10 -sticky ew\n    focus $top.fname\n}\n\nproc wrcomgo {} {\n    global wrcomtop\n\n    set id [$wrcomtop.sha1 get]\n    set cmd \"echo $id | [$wrcomtop.cmd get]\"\n    set fname [$wrcomtop.fname get]\n    if {[catch {exec sh -c $cmd >$fname &} err]} {\n        error_popup \"[mc \"Error writing commit:\"] $err\" $wrcomtop\n    }\n    catch {destroy $wrcomtop}\n    unset wrcomtop\n}\n\nproc wrcomcan {} {\n    global wrcomtop\n\n    catch {destroy $wrcomtop}\n    unset wrcomtop\n}\n\nproc mkbranch {} {\n    global NS rowmenuid\n\n    set top .branchdialog\n\n    set val(name) \"\"\n    set val(id) $rowmenuid\n    set val(command) [list mkbrgo $top]\n\n    set ui(title) [mc \"Create branch\"]\n    set ui(accept) [mc \"Create\"]\n\n    branchdia $top val ui\n}\n\nproc mvbranch {} {\n    global NS\n    global headmenuid headmenuhead\n\n    set top .branchdialog\n\n    set val(name) $headmenuhead\n    set val(id) $headmenuid\n    set val(command) [list mvbrgo $top $headmenuhead]\n\n    set ui(title) [mc \"Rename branch %s\" $headmenuhead]\n    set ui(accept) [mc \"Rename\"]\n\n    branchdia $top val ui\n}\n\nproc branchdia {top valvar uivar} {\n    global NS commitinfo\n    upvar $valvar val $uivar ui\n\n    catch {destroy $top}\n    ttk_toplevel $top\n    make_transient $top .\n    ${NS}::label $top.title -text $ui(title)\n    grid $top.title - -pady 10\n    ${NS}::label $top.id -text [mc \"ID:\"]\n    ${NS}::entry $top.sha1 -width 40\n    $top.sha1 insert 0 $val(id)\n    $top.sha1 conf -state readonly\n    grid $top.id $top.sha1 -sticky w\n    ${NS}::entry $top.head -width 60\n    $top.head insert 0 [lindex $commitinfo($val(id)) 0]\n    $top.head conf -state readonly\n    grid x $top.head -sticky ew\n    grid columnconfigure $top 1 -weight 1\n    ${NS}::label $top.nlab -text [mc \"Name:\"]\n    ${NS}::entry $top.name -width 40\n    $top.name insert 0 $val(name)\n    grid $top.nlab $top.name -sticky w\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.go -text $ui(accept) -command $val(command)\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command \"catch {destroy $top}\"\n    bind $top <Key-Return> $val(command)\n    bind $top <Key-Escape> \"catch {destroy $top}\"\n    grid $top.buts.go $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - -pady 10 -sticky ew\n    focus $top.name\n}\n\nproc mkbrgo {top} {\n    global headids idheads\n\n    set name [$top.name get]\n    set id [$top.sha1 get]\n    set cmdargs {}\n    set old_id {}\n    if {$name eq {}} {\n        error_popup [mc \"Please specify a name for the new branch\"] $top\n        return\n    }\n    if {[info exists headids($name)]} {\n        if {![confirm_popup [mc \\\n                \"Branch '%s' already exists. Overwrite?\" $name] $top]} {\n            return\n        }\n        set old_id $headids($name)\n        lappend cmdargs -f\n    }\n    catch {destroy $top}\n    lappend cmdargs $name $id\n    nowbusy newbranch\n    update\n    if {[catch {\n        eval exec git branch $cmdargs\n    } err]} {\n        notbusy newbranch\n        error_popup $err\n    } else {\n        notbusy newbranch\n        if {$old_id ne {}} {\n            movehead $id $name\n            movedhead $id $name\n            redrawtags $old_id\n            redrawtags $id\n        } else {\n            set headids($name) $id\n            lappend idheads($id) $name\n            addedhead $id $name\n            redrawtags $id\n        }\n        dispneartags 0\n        run refill_reflist\n    }\n}\n\nproc mvbrgo {top prevname} {\n    global headids idheads mainhead mainheadid\n\n    set name [$top.name get]\n    set id [$top.sha1 get]\n    set cmdargs {}\n    if {$name eq $prevname} {\n        catch {destroy $top}\n        return\n    }\n    if {$name eq {}} {\n        error_popup [mc \"Please specify a new name for the branch\"] $top\n        return\n    }\n    catch {destroy $top}\n    lappend cmdargs -m $prevname $name\n    nowbusy renamebranch\n    update\n    if {[catch {\n        eval exec git branch $cmdargs\n    } err]} {\n        notbusy renamebranch\n        error_popup $err\n    } else {\n        notbusy renamebranch\n        removehead $id $prevname\n        removedhead $id $prevname\n        set headids($name) $id\n        lappend idheads($id) $name\n        addedhead $id $name\n        if {$prevname eq $mainhead} {\n            set mainhead $name\n            set mainheadid $id\n        }\n        redrawtags $id\n        dispneartags 0\n        run refill_reflist\n    }\n}\n\nproc exec_citool {tool_args {baseid {}}} {\n    global commitinfo env\n\n    set save_env [array get env GIT_AUTHOR_*]\n\n    if {$baseid ne {}} {\n        if {![info exists commitinfo($baseid)]} {\n            getcommit $baseid\n        }\n        set author [lindex $commitinfo($baseid) 1]\n        set date [lindex $commitinfo($baseid) 2]\n        if {[regexp {^\\s*(\\S.*\\S|\\S)\\s*<(.*)>\\s*$} \\\n                    $author author name email]\n            && $date ne {}} {\n            set env(GIT_AUTHOR_NAME) $name\n            set env(GIT_AUTHOR_EMAIL) $email\n            set env(GIT_AUTHOR_DATE) $date\n        }\n    }\n\n    eval exec git citool $tool_args &\n\n    array unset env GIT_AUTHOR_*\n    array set env $save_env\n}\n\nproc cherrypick {} {\n    global rowmenuid curview\n    global mainhead mainheadid\n    global gitdir\n\n    set oldhead [exec git rev-parse HEAD]\n    set dheads [descheads $rowmenuid]\n    if {$dheads ne {} && [lsearch -exact $dheads $oldhead] >= 0} {\n        set ok [confirm_popup [mc \"Commit %s is already\\\n                included in branch %s -- really re-apply it?\" \\\n                                   [string range $rowmenuid 0 7] $mainhead]]\n        if {!$ok} return\n    }\n    nowbusy cherrypick [mc \"Cherry-picking\"]\n    update\n    # Unfortunately git-cherry-pick writes stuff to stderr even when\n    # no error occurs, and exec takes that as an indication of error...\n    if {[catch {exec sh -c \"git cherry-pick -r $rowmenuid 2>&1\"} err]} {\n        notbusy cherrypick\n        if {[regexp -line \\\n                 {Entry '(.*)' (would be overwritten by merge|not uptodate)} \\\n                 $err msg fname]} {\n            error_popup [mc \"Cherry-pick failed because of local changes\\\n                        to file '%s'.\\nPlease commit, reset or stash\\\n                        your changes and try again.\" $fname]\n        } elseif {[regexp -line \\\n                       {^(CONFLICT \\(.*\\):|Automatic cherry-pick failed|error: could not apply)} \\\n                       $err]} {\n            if {[confirm_popup [mc \"Cherry-pick failed because of merge\\\n                        conflict.\\nDo you wish to run git citool to\\\n                        resolve it?\"]]} {\n                # Force citool to read MERGE_MSG\n                file delete [file join $gitdir \"GITGUI_MSG\"]\n                exec_citool {} $rowmenuid\n            }\n        } else {\n            error_popup $err\n        }\n        run updatecommits\n        return\n    }\n    set newhead [exec git rev-parse HEAD]\n    if {$newhead eq $oldhead} {\n        notbusy cherrypick\n        error_popup [mc \"No changes committed\"]\n        return\n    }\n    addnewchild $newhead $oldhead\n    if {[commitinview $oldhead $curview]} {\n        # XXX this isn't right if we have a path limit...\n        insertrow $newhead $oldhead $curview\n        if {$mainhead ne {}} {\n            movehead $newhead $mainhead\n            movedhead $newhead $mainhead\n        }\n        set mainheadid $newhead\n        redrawtags $oldhead\n        redrawtags $newhead\n        selbyid $newhead\n    }\n    notbusy cherrypick\n}\n\nproc revert {} {\n    global rowmenuid curview\n    global mainhead mainheadid\n    global gitdir\n\n    set oldhead [exec git rev-parse HEAD]\n    set dheads [descheads $rowmenuid]\n    if { $dheads eq {} || [lsearch -exact $dheads $oldhead] == -1 } {\n       set ok [confirm_popup [mc \"Commit %s is not\\\n           included in branch %s -- really revert it?\" \\\n                      [string range $rowmenuid 0 7] $mainhead]]\n       if {!$ok} return\n    }\n    nowbusy revert [mc \"Reverting\"]\n    update\n\n    if [catch {exec git revert --no-edit $rowmenuid} err] {\n        notbusy revert\n        if [regexp {files would be overwritten by merge:(\\n(( |\\t)+[^\\n]+\\n)+)}\\\n                $err match files] {\n            regsub {\\n( |\\t)+} $files \"\\n\" files\n            error_popup [mc \"Revert failed because of local changes to\\\n                the following files:%s Please commit, reset or stash \\\n                your changes and try again.\" $files]\n        } elseif [regexp {error: could not revert} $err] {\n            if [confirm_popup [mc \"Revert failed because of merge conflict.\\n\\\n                Do you wish to run git citool to resolve it?\"]] {\n                # Force citool to read MERGE_MSG\n                file delete [file join $gitdir \"GITGUI_MSG\"]\n                exec_citool {} $rowmenuid\n            }\n        } else { error_popup $err }\n        run updatecommits\n        return\n    }\n\n    set newhead [exec git rev-parse HEAD]\n    if { $newhead eq $oldhead } {\n        notbusy revert\n        error_popup [mc \"No changes committed\"]\n        return\n    }\n\n    addnewchild $newhead $oldhead\n\n    if [commitinview $oldhead $curview] {\n        # XXX this isn't right if we have a path limit...\n        insertrow $newhead $oldhead $curview\n        if {$mainhead ne {}} {\n            movehead $newhead $mainhead\n            movedhead $newhead $mainhead\n        }\n        set mainheadid $newhead\n        redrawtags $oldhead\n        redrawtags $newhead\n        selbyid $newhead\n    }\n\n    notbusy revert\n}\n\nproc resethead {} {\n    global mainhead rowmenuid confirm_ok resettype NS\n\n    set confirm_ok 0\n    set w \".confirmreset\"\n    ttk_toplevel $w\n    make_transient $w .\n    wm title $w [mc \"Confirm reset\"]\n    ${NS}::label $w.m -text \\\n        [mc \"Reset branch %s to %s?\" $mainhead [string range $rowmenuid 0 7]]\n    pack $w.m -side top -fill x -padx 20 -pady 20\n    ${NS}::labelframe $w.f -text [mc \"Reset type:\"]\n    set resettype mixed\n    ${NS}::radiobutton $w.f.soft -value soft -variable resettype \\\n        -text [mc \"Soft: Leave working tree and index untouched\"]\n    grid $w.f.soft -sticky w\n    ${NS}::radiobutton $w.f.mixed -value mixed -variable resettype \\\n        -text [mc \"Mixed: Leave working tree untouched, reset index\"]\n    grid $w.f.mixed -sticky w\n    ${NS}::radiobutton $w.f.hard -value hard -variable resettype \\\n        -text [mc \"Hard: Reset working tree and index\\n(discard ALL local changes)\"]\n    grid $w.f.hard -sticky w\n    pack $w.f -side top -fill x -padx 4\n    ${NS}::button $w.ok -text [mc OK] -command \"set confirm_ok 1; destroy $w\"\n    pack $w.ok -side left -fill x -padx 20 -pady 20\n    ${NS}::button $w.cancel -text [mc Cancel] -command \"destroy $w\"\n    bind $w <Key-Escape> [list destroy $w]\n    pack $w.cancel -side right -fill x -padx 20 -pady 20\n    bind $w <Visibility> \"grab $w; focus $w\"\n    tkwait window $w\n    if {!$confirm_ok} return\n    if {[catch {set fd [open \\\n            [list | git reset --$resettype $rowmenuid 2>@1] r]} err]} {\n        error_popup $err\n    } else {\n        dohidelocalchanges\n        filerun $fd [list readresetstat $fd]\n        nowbusy reset [mc \"Resetting\"]\n        selbyid $rowmenuid\n    }\n}\n\nproc readresetstat {fd} {\n    global mainhead mainheadid showlocalchanges rprogcoord\n\n    if {[gets $fd line] >= 0} {\n        if {[regexp {([0-9]+)% \\(([0-9]+)/([0-9]+)\\)} $line match p m n]} {\n            set rprogcoord [expr {1.0 * $m / $n}]\n            adjustprogress\n        }\n        return 1\n    }\n    set rprogcoord 0\n    adjustprogress\n    notbusy reset\n    if {[catch {close $fd} err]} {\n        error_popup $err\n    }\n    set oldhead $mainheadid\n    set newhead [exec git rev-parse HEAD]\n    if {$newhead ne $oldhead} {\n        movehead $newhead $mainhead\n        movedhead $newhead $mainhead\n        set mainheadid $newhead\n        redrawtags $oldhead\n        redrawtags $newhead\n    }\n    if {$showlocalchanges} {\n        doshowlocalchanges\n    }\n    return 0\n}\n\n# context menu for a head\nproc headmenu {x y id head} {\n    global headmenuid headmenuhead headctxmenu mainhead headids\n\n    stopfinding\n    set headmenuid $id\n    set headmenuhead $head\n    array set state {0 normal 1 normal 2 normal}\n    if {[string match \"remotes/*\" $head]} {\n        set localhead [string range $head [expr [string last / $head] + 1] end]\n        if {[info exists headids($localhead)]} {\n            set state(0) disabled\n        }\n        array set state {1 disabled 2 disabled}\n    }\n    if {$head eq $mainhead} {\n        array set state {0 disabled 2 disabled}\n    }\n    foreach i {0 1 2} {\n        $headctxmenu entryconfigure $i -state $state($i)\n    }\n    tk_popup $headctxmenu $x $y\n}\n\nproc cobranch {} {\n    global headmenuid headmenuhead headids\n    global showlocalchanges\n\n    # check the tree is clean first??\n    set newhead $headmenuhead\n    set command [list | git checkout]\n    if {[string match \"remotes/*\" $newhead]} {\n        set remote $newhead\n        set newhead [string range $newhead [expr [string last / $newhead] + 1] end]\n        # The following check is redundant - the menu option should\n        # be disabled to begin with...\n        if {[info exists headids($newhead)]} {\n            error_popup [mc \"A local branch named %s exists already\" $newhead]\n            return\n        }\n        lappend command -b $newhead --track $remote\n    } else {\n        lappend command $newhead\n    }\n    lappend command 2>@1\n    nowbusy checkout [mc \"Checking out\"]\n    update\n    dohidelocalchanges\n    if {[catch {\n        set fd [open $command r]\n    } err]} {\n        notbusy checkout\n        error_popup $err\n        if {$showlocalchanges} {\n            dodiffindex\n        }\n    } else {\n        filerun $fd [list readcheckoutstat $fd $newhead $headmenuid]\n    }\n}\n\nproc readcheckoutstat {fd newhead newheadid} {\n    global mainhead mainheadid headids idheads showlocalchanges progresscoords\n    global viewmainheadid curview\n\n    if {[gets $fd line] >= 0} {\n        if {[regexp {([0-9]+)% \\(([0-9]+)/([0-9]+)\\)} $line match p m n]} {\n            set progresscoords [list 0 [expr {1.0 * $m / $n}]]\n            adjustprogress\n        }\n        return 1\n    }\n    set progresscoords {0 0}\n    adjustprogress\n    notbusy checkout\n    if {[catch {close $fd} err]} {\n        error_popup $err\n        return\n    }\n    set oldmainid $mainheadid\n    if {! [info exists headids($newhead)]} {\n        set headids($newhead) $newheadid\n        lappend idheads($newheadid) $newhead\n        addedhead $newheadid $newhead\n    }\n    set mainhead $newhead\n    set mainheadid $newheadid\n    set viewmainheadid($curview) $newheadid\n    redrawtags $oldmainid\n    redrawtags $newheadid\n    selbyid $newheadid\n    if {$showlocalchanges} {\n        dodiffindex\n    }\n}\n\nproc rmbranch {} {\n    global headmenuid headmenuhead mainhead\n    global idheads\n\n    set head $headmenuhead\n    set id $headmenuid\n    # this check shouldn't be needed any more...\n    if {$head eq $mainhead} {\n        error_popup [mc \"Cannot delete the currently checked-out branch\"]\n        return\n    }\n    set dheads [descheads $id]\n    if {[llength $dheads] == 1 && $idheads($dheads) eq $head} {\n        # the stuff on this branch isn't on any other branch\n        if {![confirm_popup [mc \"The commits on branch %s aren't on any other\\\n                        branch.\\nReally delete branch %s?\" $head $head]]} return\n    }\n    nowbusy rmbranch\n    update\n    if {[catch {exec git branch -D $head} err]} {\n        notbusy rmbranch\n        error_popup $err\n        return\n    }\n    removehead $id $head\n    removedhead $id $head\n    redrawtags $id\n    notbusy rmbranch\n    dispneartags 0\n    run refill_reflist\n}\n\n# Display a list of tags and heads\nproc showrefs {} {\n    global showrefstop bgcolor fgcolor selectbgcolor NS\n    global bglist fglist reflistfilter reflist maincursor\n\n    set top .showrefs\n    set showrefstop $top\n    if {[winfo exists $top]} {\n        raise $top\n        refill_reflist\n        return\n    }\n    ttk_toplevel $top\n    wm title $top [mc \"Tags and heads: %s\" [file tail [pwd]]]\n    make_transient $top .\n    text $top.list -background $bgcolor -foreground $fgcolor \\\n        -selectbackground $selectbgcolor -font mainfont \\\n        -xscrollcommand \"$top.xsb set\" -yscrollcommand \"$top.ysb set\" \\\n        -width 60 -height 20 -cursor $maincursor \\\n        -spacing1 1 -spacing3 1 -state disabled\n    $top.list tag configure highlight -background $selectbgcolor\n    if {![lsearch -exact $bglist $top.list]} {\n        lappend bglist $top.list\n        lappend fglist $top.list\n    }\n    ${NS}::scrollbar $top.ysb -command \"$top.list yview\" -orient vertical\n    ${NS}::scrollbar $top.xsb -command \"$top.list xview\" -orient horizontal\n    grid $top.list $top.ysb -sticky nsew\n    grid $top.xsb x -sticky ew\n    ${NS}::frame $top.f\n    ${NS}::label $top.f.l -text \"[mc \"Filter\"]: \"\n    ${NS}::entry $top.f.e -width 20 -textvariable reflistfilter\n    set reflistfilter \"*\"\n    trace add variable reflistfilter write reflistfilter_change\n    pack $top.f.e -side right -fill x -expand 1\n    pack $top.f.l -side left\n    grid $top.f - -sticky ew -pady 2\n    ${NS}::button $top.close -command [list destroy $top] -text [mc \"Close\"]\n    bind $top <Key-Escape> [list destroy $top]\n    grid $top.close -\n    grid columnconfigure $top 0 -weight 1\n    grid rowconfigure $top 0 -weight 1\n    bind $top.list <1> {break}\n    bind $top.list <B1-Motion> {break}\n    bind $top.list <ButtonRelease-1> {sel_reflist %W %x %y; break}\n    set reflist {}\n    refill_reflist\n}\n\nproc sel_reflist {w x y} {\n    global showrefstop reflist headids tagids otherrefids\n\n    if {![winfo exists $showrefstop]} return\n    set l [lindex [split [$w index \"@$x,$y\"] \".\"] 0]\n    set ref [lindex $reflist [expr {$l-1}]]\n    set n [lindex $ref 0]\n    switch -- [lindex $ref 1] {\n        \"H\" {selbyid $headids($n)}\n        \"R\" {selbyid $headids($n)}\n        \"T\" {selbyid $tagids($n)}\n        \"o\" {selbyid $otherrefids($n)}\n    }\n    $showrefstop.list tag add highlight $l.0 \"$l.0 lineend\"\n}\n\nproc unsel_reflist {} {\n    global showrefstop\n\n    if {![info exists showrefstop] || ![winfo exists $showrefstop]} return\n    $showrefstop.list tag remove highlight 0.0 end\n}\n\nproc reflistfilter_change {n1 n2 op} {\n    global reflistfilter\n\n    after cancel refill_reflist\n    after 200 refill_reflist\n}\n\nproc refill_reflist {} {\n    global reflist reflistfilter showrefstop headids tagids otherrefids\n    global curview\n\n    if {![info exists showrefstop] || ![winfo exists $showrefstop]} return\n    set refs {}\n    foreach n [array names headids] {\n        if {[string match $reflistfilter $n]} {\n            if {[commitinview $headids($n) $curview]} {\n                if {[string match \"remotes/*\" $n]} {\n                    lappend refs [list $n R]\n                } else {\n                    lappend refs [list $n H]\n                }\n            } else {\n                interestedin $headids($n) {run refill_reflist}\n            }\n        }\n    }\n    foreach n [array names tagids] {\n        if {[string match $reflistfilter $n]} {\n            if {[commitinview $tagids($n) $curview]} {\n                lappend refs [list $n T]\n            } else {\n                interestedin $tagids($n) {run refill_reflist}\n            }\n        }\n    }\n    foreach n [array names otherrefids] {\n        if {[string match $reflistfilter $n]} {\n            if {[commitinview $otherrefids($n) $curview]} {\n                lappend refs [list $n o]\n            } else {\n                interestedin $otherrefids($n) {run refill_reflist}\n            }\n        }\n    }\n    set refs [lsort -index 0 $refs]\n    if {$refs eq $reflist} return\n\n    # Update the contents of $showrefstop.list according to the\n    # differences between $reflist (old) and $refs (new)\n    $showrefstop.list conf -state normal\n    $showrefstop.list insert end \"\\n\"\n    set i 0\n    set j 0\n    while {$i < [llength $reflist] || $j < [llength $refs]} {\n        if {$i < [llength $reflist]} {\n            if {$j < [llength $refs]} {\n                set cmp [string compare [lindex $reflist $i 0] \\\n                             [lindex $refs $j 0]]\n                if {$cmp == 0} {\n                    set cmp [string compare [lindex $reflist $i 1] \\\n                                 [lindex $refs $j 1]]\n                }\n            } else {\n                set cmp -1\n            }\n        } else {\n            set cmp 1\n        }\n        switch -- $cmp {\n            -1 {\n                $showrefstop.list delete \"[expr {$j+1}].0\" \"[expr {$j+2}].0\"\n                incr i\n            }\n            0 {\n                incr i\n                incr j\n            }\n            1 {\n                set l [expr {$j + 1}]\n                $showrefstop.list image create $l.0 -align baseline \\\n                    -image reficon-[lindex $refs $j 1] -padx 2\n                $showrefstop.list insert $l.1 \"[lindex $refs $j 0]\\n\"\n                incr j\n            }\n        }\n    }\n    set reflist $refs\n    # delete last newline\n    $showrefstop.list delete end-2c end-1c\n    $showrefstop.list conf -state disabled\n}\n\n# Stuff for finding nearby tags\nproc getallcommits {} {\n    global allcommits nextarc seeds allccache allcwait cachedarcs allcupdate\n    global idheads idtags idotherrefs allparents tagobjid\n    global gitdir\n\n    if {![info exists allcommits]} {\n        set nextarc 0\n        set allcommits 0\n        set seeds {}\n        set allcwait 0\n        set cachedarcs 0\n        set allccache [file join $gitdir \"gitk.cache\"]\n        if {![catch {\n            set f [open $allccache r]\n            set allcwait 1\n            getcache $f\n        }]} return\n    }\n\n    if {$allcwait} {\n        return\n    }\n    set cmd [list | git rev-list --parents]\n    set allcupdate [expr {$seeds ne {}}]\n    if {!$allcupdate} {\n        set ids \"--all\"\n    } else {\n        set refs [concat [array names idheads] [array names idtags] \\\n                      [array names idotherrefs]]\n        set ids {}\n        set tagobjs {}\n        foreach name [array names tagobjid] {\n            lappend tagobjs $tagobjid($name)\n        }\n        foreach id [lsort -unique $refs] {\n            if {![info exists allparents($id)] &&\n                [lsearch -exact $tagobjs $id] < 0} {\n                lappend ids $id\n            }\n        }\n        if {$ids ne {}} {\n            foreach id $seeds {\n                lappend ids \"^$id\"\n            }\n            lappend ids \"--\"\n        }\n    }\n    if {$ids ne {}} {\n        if {$ids eq \"--all\"} {\n            set cmd [concat $cmd \"--all\"]\n        } else {\n            set cmd [concat $cmd --stdin \"<<[join $ids \"\\\\n\"]\"]\n        }\n        set fd [open $cmd r]\n        fconfigure $fd -blocking 0\n        incr allcommits\n        nowbusy allcommits\n        filerun $fd [list getallclines $fd]\n    } else {\n        dispneartags 0\n    }\n}\n\n# Since most commits have 1 parent and 1 child, we group strings of\n# such commits into \"arcs\" joining branch/merge points (BMPs), which\n# are commits that either don't have 1 parent or don't have 1 child.\n#\n# arcnos(id) - incoming arcs for BMP, arc we're on for other nodes\n# arcout(id) - outgoing arcs for BMP\n# arcids(a) - list of IDs on arc including end but not start\n# arcstart(a) - BMP ID at start of arc\n# arcend(a) - BMP ID at end of arc\n# growing(a) - arc a is still growing\n# arctags(a) - IDs out of arcids (excluding end) that have tags\n# archeads(a) - IDs out of arcids (excluding end) that have heads\n# The start of an arc is at the descendent end, so \"incoming\" means\n# coming from descendents, and \"outgoing\" means going towards ancestors.\n\nproc getallclines {fd} {\n    global allparents allchildren idtags idheads nextarc\n    global arcnos arcids arctags arcout arcend arcstart archeads growing\n    global seeds allcommits cachedarcs allcupdate\n\n    set nid 0\n    while {[incr nid] <= 1000 && [gets $fd line] >= 0} {\n        set id [lindex $line 0]\n        if {[info exists allparents($id)]} {\n            # seen it already\n            continue\n        }\n        set cachedarcs 0\n        set olds [lrange $line 1 end]\n        set allparents($id) $olds\n        if {![info exists allchildren($id)]} {\n            set allchildren($id) {}\n            set arcnos($id) {}\n            lappend seeds $id\n        } else {\n            set a $arcnos($id)\n            if {[llength $olds] == 1 && [llength $a] == 1} {\n                lappend arcids($a) $id\n                if {[info exists idtags($id)]} {\n                    lappend arctags($a) $id\n                }\n                if {[info exists idheads($id)]} {\n                    lappend archeads($a) $id\n                }\n                if {[info exists allparents($olds)]} {\n                    # seen parent already\n                    if {![info exists arcout($olds)]} {\n                        splitarc $olds\n                    }\n                    lappend arcids($a) $olds\n                    set arcend($a) $olds\n                    unset growing($a)\n                }\n                lappend allchildren($olds) $id\n                lappend arcnos($olds) $a\n                continue\n            }\n        }\n        foreach a $arcnos($id) {\n            lappend arcids($a) $id\n            set arcend($a) $id\n            unset growing($a)\n        }\n\n        set ao {}\n        foreach p $olds {\n            lappend allchildren($p) $id\n            set a [incr nextarc]\n            set arcstart($a) $id\n            set archeads($a) {}\n            set arctags($a) {}\n            set archeads($a) {}\n            set arcids($a) {}\n            lappend ao $a\n            set growing($a) 1\n            if {[info exists allparents($p)]} {\n                # seen it already, may need to make a new branch\n                if {![info exists arcout($p)]} {\n                    splitarc $p\n                }\n                lappend arcids($a) $p\n                set arcend($a) $p\n                unset growing($a)\n            }\n            lappend arcnos($p) $a\n        }\n        set arcout($id) $ao\n    }\n    if {$nid > 0} {\n        global cached_dheads cached_dtags cached_atags\n        unset -nocomplain cached_dheads\n        unset -nocomplain cached_dtags\n        unset -nocomplain cached_atags\n    }\n    if {![eof $fd]} {\n        return [expr {$nid >= 1000? 2: 1}]\n    }\n    set cacheok 1\n    if {[catch {\n        fconfigure $fd -blocking 1\n        close $fd\n    } err]} {\n        # got an error reading the list of commits\n        # if we were updating, try rereading the whole thing again\n        if {$allcupdate} {\n            incr allcommits -1\n            dropcache $err\n            return\n        }\n        error_popup \"[mc \"Error reading commit topology information;\\\n                branch and preceding/following tag information\\\n                will be incomplete.\"]\\n($err)\"\n        set cacheok 0\n    }\n    if {[incr allcommits -1] == 0} {\n        notbusy allcommits\n        if {$cacheok} {\n            run savecache\n        }\n    }\n    dispneartags 0\n    return 0\n}\n\nproc recalcarc {a} {\n    global arctags archeads arcids idtags idheads\n\n    set at {}\n    set ah {}\n    foreach id [lrange $arcids($a) 0 end-1] {\n        if {[info exists idtags($id)]} {\n            lappend at $id\n        }\n        if {[info exists idheads($id)]} {\n            lappend ah $id\n        }\n    }\n    set arctags($a) $at\n    set archeads($a) $ah\n}\n\nproc splitarc {p} {\n    global arcnos arcids nextarc arctags archeads idtags idheads\n    global arcstart arcend arcout allparents growing\n\n    set a $arcnos($p)\n    if {[llength $a] != 1} {\n        puts \"oops splitarc called but [llength $a] arcs already\"\n        return\n    }\n    set a [lindex $a 0]\n    set i [lsearch -exact $arcids($a) $p]\n    if {$i < 0} {\n        puts \"oops splitarc $p not in arc $a\"\n        return\n    }\n    set na [incr nextarc]\n    if {[info exists arcend($a)]} {\n        set arcend($na) $arcend($a)\n    } else {\n        set l [lindex $allparents([lindex $arcids($a) end]) 0]\n        set j [lsearch -exact $arcnos($l) $a]\n        set arcnos($l) [lreplace $arcnos($l) $j $j $na]\n    }\n    set tail [lrange $arcids($a) [expr {$i+1}] end]\n    set arcids($a) [lrange $arcids($a) 0 $i]\n    set arcend($a) $p\n    set arcstart($na) $p\n    set arcout($p) $na\n    set arcids($na) $tail\n    if {[info exists growing($a)]} {\n        set growing($na) 1\n        unset growing($a)\n    }\n\n    foreach id $tail {\n        if {[llength $arcnos($id)] == 1} {\n            set arcnos($id) $na\n        } else {\n            set j [lsearch -exact $arcnos($id) $a]\n            set arcnos($id) [lreplace $arcnos($id) $j $j $na]\n        }\n    }\n\n    # reconstruct tags and heads lists\n    if {$arctags($a) ne {} || $archeads($a) ne {}} {\n        recalcarc $a\n        recalcarc $na\n    } else {\n        set arctags($na) {}\n        set archeads($na) {}\n    }\n}\n\n# Update things for a new commit added that is a child of one\n# existing commit.  Used when cherry-picking.\nproc addnewchild {id p} {\n    global allparents allchildren idtags nextarc\n    global arcnos arcids arctags arcout arcend arcstart archeads growing\n    global seeds allcommits\n\n    if {![info exists allcommits] || ![info exists arcnos($p)]} return\n    set allparents($id) [list $p]\n    set allchildren($id) {}\n    set arcnos($id) {}\n    lappend seeds $id\n    lappend allchildren($p) $id\n    set a [incr nextarc]\n    set arcstart($a) $id\n    set archeads($a) {}\n    set arctags($a) {}\n    set arcids($a) [list $p]\n    set arcend($a) $p\n    if {![info exists arcout($p)]} {\n        splitarc $p\n    }\n    lappend arcnos($p) $a\n    set arcout($id) [list $a]\n}\n\n# This implements a cache for the topology information.\n# The cache saves, for each arc, the start and end of the arc,\n# the ids on the arc, and the outgoing arcs from the end.\nproc readcache {f} {\n    global arcnos arcids arcout arcstart arcend arctags archeads nextarc\n    global idtags idheads allparents cachedarcs possible_seeds seeds growing\n    global allcwait\n\n    set a $nextarc\n    set lim $cachedarcs\n    if {$lim - $a > 500} {\n        set lim [expr {$a + 500}]\n    }\n    if {[catch {\n        if {$a == $lim} {\n            # finish reading the cache and setting up arctags, etc.\n            set line [gets $f]\n            if {$line ne \"1\"} {error \"bad final version\"}\n            close $f\n            foreach id [array names idtags] {\n                if {[info exists arcnos($id)] && [llength $arcnos($id)] == 1 &&\n                    [llength $allparents($id)] == 1} {\n                    set a [lindex $arcnos($id) 0]\n                    if {$arctags($a) eq {}} {\n                        recalcarc $a\n                    }\n                }\n            }\n            foreach id [array names idheads] {\n                if {[info exists arcnos($id)] && [llength $arcnos($id)] == 1 &&\n                    [llength $allparents($id)] == 1} {\n                    set a [lindex $arcnos($id) 0]\n                    if {$archeads($a) eq {}} {\n                        recalcarc $a\n                    }\n                }\n            }\n            foreach id [lsort -unique $possible_seeds] {\n                if {$arcnos($id) eq {}} {\n                    lappend seeds $id\n                }\n            }\n            set allcwait 0\n        } else {\n            while {[incr a] <= $lim} {\n                set line [gets $f]\n                if {[llength $line] != 3} {error \"bad line\"}\n                set s [lindex $line 0]\n                set arcstart($a) $s\n                lappend arcout($s) $a\n                if {![info exists arcnos($s)]} {\n                    lappend possible_seeds $s\n                    set arcnos($s) {}\n                }\n                set e [lindex $line 1]\n                if {$e eq {}} {\n                    set growing($a) 1\n                } else {\n                    set arcend($a) $e\n                    if {![info exists arcout($e)]} {\n                        set arcout($e) {}\n                    }\n                }\n                set arcids($a) [lindex $line 2]\n                foreach id $arcids($a) {\n                    lappend allparents($s) $id\n                    set s $id\n                    lappend arcnos($id) $a\n                }\n                if {![info exists allparents($s)]} {\n                    set allparents($s) {}\n                }\n                set arctags($a) {}\n                set archeads($a) {}\n            }\n            set nextarc [expr {$a - 1}]\n        }\n    } err]} {\n        dropcache $err\n        return 0\n    }\n    if {!$allcwait} {\n        getallcommits\n    }\n    return $allcwait\n}\n\nproc getcache {f} {\n    global nextarc cachedarcs possible_seeds\n\n    if {[catch {\n        set line [gets $f]\n        if {[llength $line] != 2 || [lindex $line 0] ne \"1\"} {error \"bad version\"}\n        # make sure it's an integer\n        set cachedarcs [expr {int([lindex $line 1])}]\n        if {$cachedarcs < 0} {error \"bad number of arcs\"}\n        set nextarc 0\n        set possible_seeds {}\n        run readcache $f\n    } err]} {\n        dropcache $err\n    }\n    return 0\n}\n\nproc dropcache {err} {\n    global allcwait nextarc cachedarcs seeds\n\n    #puts \"dropping cache ($err)\"\n    foreach v {arcnos arcout arcids arcstart arcend growing \\\n                   arctags archeads allparents allchildren} {\n        global $v\n        unset -nocomplain $v\n    }\n    set allcwait 0\n    set nextarc 0\n    set cachedarcs 0\n    set seeds {}\n    getallcommits\n}\n\nproc writecache {f} {\n    global cachearc cachedarcs allccache\n    global arcstart arcend arcnos arcids arcout\n\n    set a $cachearc\n    set lim $cachedarcs\n    if {$lim - $a > 1000} {\n        set lim [expr {$a + 1000}]\n    }\n    if {[catch {\n        while {[incr a] <= $lim} {\n            if {[info exists arcend($a)]} {\n                puts $f [list $arcstart($a) $arcend($a) $arcids($a)]\n            } else {\n                puts $f [list $arcstart($a) {} $arcids($a)]\n            }\n        }\n    } err]} {\n        catch {close $f}\n        catch {file delete $allccache}\n        #puts \"writing cache failed ($err)\"\n        return 0\n    }\n    set cachearc [expr {$a - 1}]\n    if {$a > $cachedarcs} {\n        puts $f \"1\"\n        close $f\n        return 0\n    }\n    return 1\n}\n\nproc savecache {} {\n    global nextarc cachedarcs cachearc allccache\n\n    if {$nextarc == $cachedarcs} return\n    set cachearc 0\n    set cachedarcs $nextarc\n    catch {\n        set f [open $allccache w]\n        puts $f [list 1 $cachedarcs]\n        run writecache $f\n    }\n}\n\n# Returns 1 if a is an ancestor of b, -1 if b is an ancestor of a,\n# or 0 if neither is true.\nproc anc_or_desc {a b} {\n    global arcout arcstart arcend arcnos cached_isanc\n\n    if {$arcnos($a) eq $arcnos($b)} {\n        # Both are on the same arc(s); either both are the same BMP,\n        # or if one is not a BMP, the other is also not a BMP or is\n        # the BMP at end of the arc (and it only has 1 incoming arc).\n        # Or both can be BMPs with no incoming arcs.\n        if {$a eq $b || $arcnos($a) eq {}} {\n            return 0\n        }\n        # assert {[llength $arcnos($a)] == 1}\n        set arc [lindex $arcnos($a) 0]\n        set i [lsearch -exact $arcids($arc) $a]\n        set j [lsearch -exact $arcids($arc) $b]\n        if {$i < 0 || $i > $j} {\n            return 1\n        } else {\n            return -1\n        }\n    }\n\n    if {![info exists arcout($a)]} {\n        set arc [lindex $arcnos($a) 0]\n        if {[info exists arcend($arc)]} {\n            set aend $arcend($arc)\n        } else {\n            set aend {}\n        }\n        set a $arcstart($arc)\n    } else {\n        set aend $a\n    }\n    if {![info exists arcout($b)]} {\n        set arc [lindex $arcnos($b) 0]\n        if {[info exists arcend($arc)]} {\n            set bend $arcend($arc)\n        } else {\n            set bend {}\n        }\n        set b $arcstart($arc)\n    } else {\n        set bend $b\n    }\n    if {$a eq $bend} {\n        return 1\n    }\n    if {$b eq $aend} {\n        return -1\n    }\n    if {[info exists cached_isanc($a,$bend)]} {\n        if {$cached_isanc($a,$bend)} {\n            return 1\n        }\n    }\n    if {[info exists cached_isanc($b,$aend)]} {\n        if {$cached_isanc($b,$aend)} {\n            return -1\n        }\n        if {[info exists cached_isanc($a,$bend)]} {\n            return 0\n        }\n    }\n\n    set todo [list $a $b]\n    set anc($a) a\n    set anc($b) b\n    for {set i 0} {$i < [llength $todo]} {incr i} {\n        set x [lindex $todo $i]\n        if {$anc($x) eq {}} {\n            continue\n        }\n        foreach arc $arcnos($x) {\n            set xd $arcstart($arc)\n            if {$xd eq $bend} {\n                set cached_isanc($a,$bend) 1\n                set cached_isanc($b,$aend) 0\n                return 1\n            } elseif {$xd eq $aend} {\n                set cached_isanc($b,$aend) 1\n                set cached_isanc($a,$bend) 0\n                return -1\n            }\n            if {![info exists anc($xd)]} {\n                set anc($xd) $anc($x)\n                lappend todo $xd\n            } elseif {$anc($xd) ne $anc($x)} {\n                set anc($xd) {}\n            }\n        }\n    }\n    set cached_isanc($a,$bend) 0\n    set cached_isanc($b,$aend) 0\n    return 0\n}\n\n# This identifies whether $desc has an ancestor that is\n# a growing tip of the graph and which is not an ancestor of $anc\n# and returns 0 if so and 1 if not.\n# If we subsequently discover a tag on such a growing tip, and that\n# turns out to be a descendent of $anc (which it could, since we\n# don't necessarily see children before parents), then $desc\n# isn't a good choice to display as a descendent tag of\n# $anc (since it is the descendent of another tag which is\n# a descendent of $anc).  Similarly, $anc isn't a good choice to\n# display as a ancestor tag of $desc.\n#\nproc is_certain {desc anc} {\n    global arcnos arcout arcstart arcend growing problems\n\n    set certain {}\n    if {[llength $arcnos($anc)] == 1} {\n        # tags on the same arc are certain\n        if {$arcnos($desc) eq $arcnos($anc)} {\n            return 1\n        }\n        if {![info exists arcout($anc)]} {\n            # if $anc is partway along an arc, use the start of the arc instead\n            set a [lindex $arcnos($anc) 0]\n            set anc $arcstart($a)\n        }\n    }\n    if {[llength $arcnos($desc)] > 1 || [info exists arcout($desc)]} {\n        set x $desc\n    } else {\n        set a [lindex $arcnos($desc) 0]\n        set x $arcend($a)\n    }\n    if {$x == $anc} {\n        return 1\n    }\n    set anclist [list $x]\n    set dl($x) 1\n    set nnh 1\n    set ngrowanc 0\n    for {set i 0} {$i < [llength $anclist] && ($nnh > 0 || $ngrowanc > 0)} {incr i} {\n        set x [lindex $anclist $i]\n        if {$dl($x)} {\n            incr nnh -1\n        }\n        set done($x) 1\n        foreach a $arcout($x) {\n            if {[info exists growing($a)]} {\n                if {![info exists growanc($x)] && $dl($x)} {\n                    set growanc($x) 1\n                    incr ngrowanc\n                }\n            } else {\n                set y $arcend($a)\n                if {[info exists dl($y)]} {\n                    if {$dl($y)} {\n                        if {!$dl($x)} {\n                            set dl($y) 0\n                            if {![info exists done($y)]} {\n                                incr nnh -1\n                            }\n                            if {[info exists growanc($x)]} {\n                                incr ngrowanc -1\n                            }\n                            set xl [list $y]\n                            for {set k 0} {$k < [llength $xl]} {incr k} {\n                                set z [lindex $xl $k]\n                                foreach c $arcout($z) {\n                                    if {[info exists arcend($c)]} {\n                                        set v $arcend($c)\n                                        if {[info exists dl($v)] && $dl($v)} {\n                                            set dl($v) 0\n                                            if {![info exists done($v)]} {\n                                                incr nnh -1\n                                            }\n                                            if {[info exists growanc($v)]} {\n                                                incr ngrowanc -1\n                                            }\n                                            lappend xl $v\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } elseif {$y eq $anc || !$dl($x)} {\n                    set dl($y) 0\n                    lappend anclist $y\n                } else {\n                    set dl($y) 1\n                    lappend anclist $y\n                    incr nnh\n                }\n            }\n        }\n    }\n    foreach x [array names growanc] {\n        if {$dl($x)} {\n            return 0\n        }\n        return 0\n    }\n    return 1\n}\n\nproc validate_arctags {a} {\n    global arctags idtags\n\n    set i -1\n    set na $arctags($a)\n    foreach id $arctags($a) {\n        incr i\n        if {![info exists idtags($id)]} {\n            set na [lreplace $na $i $i]\n            incr i -1\n        }\n    }\n    set arctags($a) $na\n}\n\nproc validate_archeads {a} {\n    global archeads idheads\n\n    set i -1\n    set na $archeads($a)\n    foreach id $archeads($a) {\n        incr i\n        if {![info exists idheads($id)]} {\n            set na [lreplace $na $i $i]\n            incr i -1\n        }\n    }\n    set archeads($a) $na\n}\n\n# Return the list of IDs that have tags that are descendents of id,\n# ignoring IDs that are descendents of IDs already reported.\nproc desctags {id} {\n    global arcnos arcstart arcids arctags idtags allparents\n    global growing cached_dtags\n\n    if {![info exists allparents($id)]} {\n        return {}\n    }\n    set t1 [clock clicks -milliseconds]\n    set argid $id\n    if {[llength $arcnos($id)] == 1 && [llength $allparents($id)] == 1} {\n        # part-way along an arc; check that arc first\n        set a [lindex $arcnos($id) 0]\n        if {$arctags($a) ne {}} {\n            validate_arctags $a\n            set i [lsearch -exact $arcids($a) $id]\n            set tid {}\n            foreach t $arctags($a) {\n                set j [lsearch -exact $arcids($a) $t]\n                if {$j >= $i} break\n                set tid $t\n            }\n            if {$tid ne {}} {\n                return $tid\n            }\n        }\n        set id $arcstart($a)\n        if {[info exists idtags($id)]} {\n            return $id\n        }\n    }\n    if {[info exists cached_dtags($id)]} {\n        return $cached_dtags($id)\n    }\n\n    set origid $id\n    set todo [list $id]\n    set queued($id) 1\n    set nc 1\n    for {set i 0} {$i < [llength $todo] && $nc > 0} {incr i} {\n        set id [lindex $todo $i]\n        set done($id) 1\n        set ta [info exists hastaggedancestor($id)]\n        if {!$ta} {\n            incr nc -1\n        }\n        # ignore tags on starting node\n        if {!$ta && $i > 0} {\n            if {[info exists idtags($id)]} {\n                set tagloc($id) $id\n                set ta 1\n            } elseif {[info exists cached_dtags($id)]} {\n                set tagloc($id) $cached_dtags($id)\n                set ta 1\n            }\n        }\n        foreach a $arcnos($id) {\n            set d $arcstart($a)\n            if {!$ta && $arctags($a) ne {}} {\n                validate_arctags $a\n                if {$arctags($a) ne {}} {\n                    lappend tagloc($id) [lindex $arctags($a) end]\n                }\n            }\n            if {$ta || $arctags($a) ne {}} {\n                set tomark [list $d]\n                for {set j 0} {$j < [llength $tomark]} {incr j} {\n                    set dd [lindex $tomark $j]\n                    if {![info exists hastaggedancestor($dd)]} {\n                        if {[info exists done($dd)]} {\n                            foreach b $arcnos($dd) {\n                                lappend tomark $arcstart($b)\n                            }\n                            if {[info exists tagloc($dd)]} {\n                                unset tagloc($dd)\n                            }\n                        } elseif {[info exists queued($dd)]} {\n                            incr nc -1\n                        }\n                        set hastaggedancestor($dd) 1\n                    }\n                }\n            }\n            if {![info exists queued($d)]} {\n                lappend todo $d\n                set queued($d) 1\n                if {![info exists hastaggedancestor($d)]} {\n                    incr nc\n                }\n            }\n        }\n    }\n    set tags {}\n    foreach id [array names tagloc] {\n        if {![info exists hastaggedancestor($id)]} {\n            foreach t $tagloc($id) {\n                if {[lsearch -exact $tags $t] < 0} {\n                    lappend tags $t\n                }\n            }\n        }\n    }\n    set t2 [clock clicks -milliseconds]\n    set loopix $i\n\n    # remove tags that are descendents of other tags\n    for {set i 0} {$i < [llength $tags]} {incr i} {\n        set a [lindex $tags $i]\n        for {set j 0} {$j < $i} {incr j} {\n            set b [lindex $tags $j]\n            set r [anc_or_desc $a $b]\n            if {$r == 1} {\n                set tags [lreplace $tags $j $j]\n                incr j -1\n                incr i -1\n            } elseif {$r == -1} {\n                set tags [lreplace $tags $i $i]\n                incr i -1\n                break\n            }\n        }\n    }\n\n    if {[array names growing] ne {}} {\n        # graph isn't finished, need to check if any tag could get\n        # eclipsed by another tag coming later.  Simply ignore any\n        # tags that could later get eclipsed.\n        set ctags {}\n        foreach t $tags {\n            if {[is_certain $t $origid]} {\n                lappend ctags $t\n            }\n        }\n        if {$tags eq $ctags} {\n            set cached_dtags($origid) $tags\n        } else {\n            set tags $ctags\n        }\n    } else {\n        set cached_dtags($origid) $tags\n    }\n    set t3 [clock clicks -milliseconds]\n    if {0 && $t3 - $t1 >= 100} {\n        puts \"iterating descendents ($loopix/[llength $todo] nodes) took\\\n            [expr {$t2-$t1}]+[expr {$t3-$t2}]ms, $nc candidates left\"\n    }\n    return $tags\n}\n\nproc anctags {id} {\n    global arcnos arcids arcout arcend arctags idtags allparents\n    global growing cached_atags\n\n    if {![info exists allparents($id)]} {\n        return {}\n    }\n    set t1 [clock clicks -milliseconds]\n    set argid $id\n    if {[llength $arcnos($id)] == 1 && [llength $allparents($id)] == 1} {\n        # part-way along an arc; check that arc first\n        set a [lindex $arcnos($id) 0]\n        if {$arctags($a) ne {}} {\n            validate_arctags $a\n            set i [lsearch -exact $arcids($a) $id]\n            foreach t $arctags($a) {\n                set j [lsearch -exact $arcids($a) $t]\n                if {$j > $i} {\n                    return $t\n                }\n            }\n        }\n        if {![info exists arcend($a)]} {\n            return {}\n        }\n        set id $arcend($a)\n        if {[info exists idtags($id)]} {\n            return $id\n        }\n    }\n    if {[info exists cached_atags($id)]} {\n        return $cached_atags($id)\n    }\n\n    set origid $id\n    set todo [list $id]\n    set queued($id) 1\n    set taglist {}\n    set nc 1\n    for {set i 0} {$i < [llength $todo] && $nc > 0} {incr i} {\n        set id [lindex $todo $i]\n        set done($id) 1\n        set td [info exists hastaggeddescendent($id)]\n        if {!$td} {\n            incr nc -1\n        }\n        # ignore tags on starting node\n        if {!$td && $i > 0} {\n            if {[info exists idtags($id)]} {\n                set tagloc($id) $id\n                set td 1\n            } elseif {[info exists cached_atags($id)]} {\n                set tagloc($id) $cached_atags($id)\n                set td 1\n            }\n        }\n        foreach a $arcout($id) {\n            if {!$td && $arctags($a) ne {}} {\n                validate_arctags $a\n                if {$arctags($a) ne {}} {\n                    lappend tagloc($id) [lindex $arctags($a) 0]\n                }\n            }\n            if {![info exists arcend($a)]} continue\n            set d $arcend($a)\n            if {$td || $arctags($a) ne {}} {\n                set tomark [list $d]\n                for {set j 0} {$j < [llength $tomark]} {incr j} {\n                    set dd [lindex $tomark $j]\n                    if {![info exists hastaggeddescendent($dd)]} {\n                        if {[info exists done($dd)]} {\n                            foreach b $arcout($dd) {\n                                if {[info exists arcend($b)]} {\n                                    lappend tomark $arcend($b)\n                                }\n                            }\n                            if {[info exists tagloc($dd)]} {\n                                unset tagloc($dd)\n                            }\n                        } elseif {[info exists queued($dd)]} {\n                            incr nc -1\n                        }\n                        set hastaggeddescendent($dd) 1\n                    }\n                }\n            }\n            if {![info exists queued($d)]} {\n                lappend todo $d\n                set queued($d) 1\n                if {![info exists hastaggeddescendent($d)]} {\n                    incr nc\n                }\n            }\n        }\n    }\n    set t2 [clock clicks -milliseconds]\n    set loopix $i\n    set tags {}\n    foreach id [array names tagloc] {\n        if {![info exists hastaggeddescendent($id)]} {\n            foreach t $tagloc($id) {\n                if {[lsearch -exact $tags $t] < 0} {\n                    lappend tags $t\n                }\n            }\n        }\n    }\n\n    # remove tags that are ancestors of other tags\n    for {set i 0} {$i < [llength $tags]} {incr i} {\n        set a [lindex $tags $i]\n        for {set j 0} {$j < $i} {incr j} {\n            set b [lindex $tags $j]\n            set r [anc_or_desc $a $b]\n            if {$r == -1} {\n                set tags [lreplace $tags $j $j]\n                incr j -1\n                incr i -1\n            } elseif {$r == 1} {\n                set tags [lreplace $tags $i $i]\n                incr i -1\n                break\n            }\n        }\n    }\n\n    if {[array names growing] ne {}} {\n        # graph isn't finished, need to check if any tag could get\n        # eclipsed by another tag coming later.  Simply ignore any\n        # tags that could later get eclipsed.\n        set ctags {}\n        foreach t $tags {\n            if {[is_certain $origid $t]} {\n                lappend ctags $t\n            }\n        }\n        if {$tags eq $ctags} {\n            set cached_atags($origid) $tags\n        } else {\n            set tags $ctags\n        }\n    } else {\n        set cached_atags($origid) $tags\n    }\n    set t3 [clock clicks -milliseconds]\n    if {0 && $t3 - $t1 >= 100} {\n        puts \"iterating ancestors ($loopix/[llength $todo] nodes) took\\\n            [expr {$t2-$t1}]+[expr {$t3-$t2}]ms, $nc candidates left\"\n    }\n    return $tags\n}\n\n# Return the list of IDs that have heads that are descendents of id,\n# including id itself if it has a head.\nproc descheads {id} {\n    global arcnos arcstart arcids archeads idheads cached_dheads\n    global allparents arcout\n\n    if {![info exists allparents($id)]} {\n        return {}\n    }\n    set aret {}\n    if {![info exists arcout($id)]} {\n        # part-way along an arc; check it first\n        set a [lindex $arcnos($id) 0]\n        if {$archeads($a) ne {}} {\n            validate_archeads $a\n            set i [lsearch -exact $arcids($a) $id]\n            foreach t $archeads($a) {\n                set j [lsearch -exact $arcids($a) $t]\n                if {$j > $i} break\n                lappend aret $t\n            }\n        }\n        set id $arcstart($a)\n    }\n    set origid $id\n    set todo [list $id]\n    set seen($id) 1\n    set ret {}\n    for {set i 0} {$i < [llength $todo]} {incr i} {\n        set id [lindex $todo $i]\n        if {[info exists cached_dheads($id)]} {\n            set ret [concat $ret $cached_dheads($id)]\n        } else {\n            if {[info exists idheads($id)]} {\n                lappend ret $id\n            }\n            foreach a $arcnos($id) {\n                if {$archeads($a) ne {}} {\n                    validate_archeads $a\n                    if {$archeads($a) ne {}} {\n                        set ret [concat $ret $archeads($a)]\n                    }\n                }\n                set d $arcstart($a)\n                if {![info exists seen($d)]} {\n                    lappend todo $d\n                    set seen($d) 1\n                }\n            }\n        }\n    }\n    set ret [lsort -unique $ret]\n    set cached_dheads($origid) $ret\n    return [concat $ret $aret]\n}\n\nproc addedtag {id} {\n    global arcnos arcout cached_dtags cached_atags\n\n    if {![info exists arcnos($id)]} return\n    if {![info exists arcout($id)]} {\n        recalcarc [lindex $arcnos($id) 0]\n    }\n    unset -nocomplain cached_dtags\n    unset -nocomplain cached_atags\n}\n\nproc addedhead {hid head} {\n    global arcnos arcout cached_dheads\n\n    if {![info exists arcnos($hid)]} return\n    if {![info exists arcout($hid)]} {\n        recalcarc [lindex $arcnos($hid) 0]\n    }\n    unset -nocomplain cached_dheads\n}\n\nproc removedhead {hid head} {\n    global cached_dheads\n\n    unset -nocomplain cached_dheads\n}\n\nproc movedhead {hid head} {\n    global arcnos arcout cached_dheads\n\n    if {![info exists arcnos($hid)]} return\n    if {![info exists arcout($hid)]} {\n        recalcarc [lindex $arcnos($hid) 0]\n    }\n    unset -nocomplain cached_dheads\n}\n\nproc changedrefs {} {\n    global cached_dheads cached_dtags cached_atags cached_tagcontent\n    global arctags archeads arcnos arcout idheads idtags\n\n    foreach id [concat [array names idheads] [array names idtags]] {\n        if {[info exists arcnos($id)] && ![info exists arcout($id)]} {\n            set a [lindex $arcnos($id) 0]\n            if {![info exists donearc($a)]} {\n                recalcarc $a\n                set donearc($a) 1\n            }\n        }\n    }\n    unset -nocomplain cached_tagcontent\n    unset -nocomplain cached_dtags\n    unset -nocomplain cached_atags\n    unset -nocomplain cached_dheads\n}\n\nproc rereadrefs {} {\n    global idtags idheads idotherrefs mainheadid\n\n    set refids [concat [array names idtags] \\\n                    [array names idheads] [array names idotherrefs]]\n    foreach id $refids {\n        if {![info exists ref($id)]} {\n            set ref($id) [listrefs $id]\n        }\n    }\n    set oldmainhead $mainheadid\n    readrefs\n    changedrefs\n    set refids [lsort -unique [concat $refids [array names idtags] \\\n                        [array names idheads] [array names idotherrefs]]]\n    foreach id $refids {\n        set v [listrefs $id]\n        if {![info exists ref($id)] || $ref($id) != $v} {\n            redrawtags $id\n        }\n    }\n    if {$oldmainhead ne $mainheadid} {\n        redrawtags $oldmainhead\n        redrawtags $mainheadid\n    }\n    run refill_reflist\n}\n\nproc listrefs {id} {\n    global idtags idheads idotherrefs\n\n    set x {}\n    if {[info exists idtags($id)]} {\n        set x $idtags($id)\n    }\n    set y {}\n    if {[info exists idheads($id)]} {\n        set y $idheads($id)\n    }\n    set z {}\n    if {[info exists idotherrefs($id)]} {\n        set z $idotherrefs($id)\n    }\n    return [list $x $y $z]\n}\n\nproc add_tag_ctext {tag} {\n    global ctext cached_tagcontent tagids\n\n    if {![info exists cached_tagcontent($tag)]} {\n        catch {\n            set cached_tagcontent($tag) [exec git cat-file -p $tag]\n        }\n    }\n    $ctext insert end \"[mc \"Tag\"]: $tag\\n\" bold\n    if {[info exists cached_tagcontent($tag)]} {\n        set text $cached_tagcontent($tag)\n    } else {\n        set text \"[mc \"Id\"]:  $tagids($tag)\"\n    }\n    appendwithlinks $text {}\n}\n\nproc showtag {tag isnew} {\n    global ctext cached_tagcontent tagids linknum tagobjid\n\n    if {$isnew} {\n        addtohistory [list showtag $tag 0] savectextpos\n    }\n    $ctext conf -state normal\n    clear_ctext\n    settabs 0\n    set linknum 0\n    add_tag_ctext $tag\n    maybe_scroll_ctext 1\n    $ctext conf -state disabled\n    init_flist {}\n}\n\nproc showtags {id isnew} {\n    global idtags ctext linknum\n\n    if {$isnew} {\n        addtohistory [list showtags $id 0] savectextpos\n    }\n    $ctext conf -state normal\n    clear_ctext\n    settabs 0\n    set linknum 0\n    set sep {}\n    foreach tag $idtags($id) {\n        $ctext insert end $sep\n        add_tag_ctext $tag\n        set sep \"\\n\\n\"\n    }\n    maybe_scroll_ctext 1\n    $ctext conf -state disabled\n    init_flist {}\n}\n\nproc doquit {} {\n    global stopped\n    global gitktmpdir\n\n    set stopped 100\n    savestuff .\n    destroy .\n\n    if {[info exists gitktmpdir]} {\n        catch {file delete -force $gitktmpdir}\n    }\n}\n\nproc mkfontdisp {font top which} {\n    global fontattr fontpref $font NS use_ttk\n\n    set fontpref($font) [set $font]\n    ${NS}::button $top.${font}but -text $which \\\n        -command [list choosefont $font $which]\n    ${NS}::label $top.$font -relief flat -font $font \\\n        -text $fontattr($font,family) -justify left\n    grid x $top.${font}but $top.$font -sticky w\n}\n\nproc choosefont {font which} {\n    global fontparam fontlist fonttop fontattr\n    global prefstop NS\n\n    set fontparam(which) $which\n    set fontparam(font) $font\n    set fontparam(family) [font actual $font -family]\n    set fontparam(size) $fontattr($font,size)\n    set fontparam(weight) $fontattr($font,weight)\n    set fontparam(slant) $fontattr($font,slant)\n    set top .gitkfont\n    set fonttop $top\n    if {![winfo exists $top]} {\n        font create sample\n        eval font config sample [font actual $font]\n        ttk_toplevel $top\n        make_transient $top $prefstop\n        wm title $top [mc \"Gitk font chooser\"]\n        ${NS}::label $top.l -textvariable fontparam(which)\n        pack $top.l -side top\n        set fontlist [lsort [font families]]\n        ${NS}::frame $top.f\n        listbox $top.f.fam -listvariable fontlist \\\n            -yscrollcommand [list $top.f.sb set]\n        bind $top.f.fam <<ListboxSelect>> selfontfam\n        ${NS}::scrollbar $top.f.sb -command [list $top.f.fam yview]\n        pack $top.f.sb -side right -fill y\n        pack $top.f.fam -side left -fill both -expand 1\n        pack $top.f -side top -fill both -expand 1\n        ${NS}::frame $top.g\n        spinbox $top.g.size -from 4 -to 40 -width 4 \\\n            -textvariable fontparam(size) \\\n            -validatecommand {string is integer -strict %s}\n        checkbutton $top.g.bold -padx 5 \\\n            -font {{Times New Roman} 12 bold} -text [mc \"B\"] -indicatoron 0 \\\n            -variable fontparam(weight) -onvalue bold -offvalue normal\n        checkbutton $top.g.ital -padx 5 \\\n            -font {{Times New Roman} 12 italic} -text [mc \"I\"] -indicatoron 0  \\\n            -variable fontparam(slant) -onvalue italic -offvalue roman\n        pack $top.g.size $top.g.bold $top.g.ital -side left\n        pack $top.g -side top\n        canvas $top.c -width 150 -height 50 -border 2 -relief sunk \\\n            -background white\n        $top.c create text 100 25 -anchor center -text $which -font sample \\\n            -fill black -tags text\n        bind $top.c <Configure> [list centertext $top.c]\n        pack $top.c -side top -fill x\n        ${NS}::frame $top.buts\n        ${NS}::button $top.buts.ok -text [mc \"OK\"] -command fontok -default active\n        ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command fontcan -default normal\n        bind $top <Key-Return> fontok\n        bind $top <Key-Escape> fontcan\n        grid $top.buts.ok $top.buts.can\n        grid columnconfigure $top.buts 0 -weight 1 -uniform a\n        grid columnconfigure $top.buts 1 -weight 1 -uniform a\n        pack $top.buts -side bottom -fill x\n        trace add variable fontparam write chg_fontparam\n    } else {\n        raise $top\n        $top.c itemconf text -text $which\n    }\n    set i [lsearch -exact $fontlist $fontparam(family)]\n    if {$i >= 0} {\n        $top.f.fam selection set $i\n        $top.f.fam see $i\n    }\n}\n\nproc centertext {w} {\n    $w coords text [expr {[winfo width $w] / 2}] [expr {[winfo height $w] / 2}]\n}\n\nproc fontok {} {\n    global fontparam fontpref prefstop\n\n    set f $fontparam(font)\n    set fontpref($f) [list $fontparam(family) $fontparam(size)]\n    if {$fontparam(weight) eq \"bold\"} {\n        lappend fontpref($f) \"bold\"\n    }\n    if {$fontparam(slant) eq \"italic\"} {\n        lappend fontpref($f) \"italic\"\n    }\n    set w $prefstop.notebook.fonts.$f\n    $w conf -text $fontparam(family) -font $fontpref($f)\n\n    fontcan\n}\n\nproc fontcan {} {\n    global fonttop fontparam\n\n    if {[info exists fonttop]} {\n        catch {destroy $fonttop}\n        catch {font delete sample}\n        unset fonttop\n        unset fontparam\n    }\n}\n\nif {[package vsatisfies [package provide Tk] 8.6]} {\n    # In Tk 8.6 we have a native font chooser dialog. Overwrite the above\n    # function to make use of it.\n    proc choosefont {font which} {\n        tk fontchooser configure -title $which -font $font \\\n            -command [list on_choosefont $font $which]\n        tk fontchooser show\n    }\n    proc on_choosefont {font which newfont} {\n        global fontparam\n        puts stderr \"$font $newfont\"\n        array set f [font actual $newfont]\n        set fontparam(which) $which\n        set fontparam(font) $font\n        set fontparam(family) $f(-family)\n        set fontparam(size) $f(-size)\n        set fontparam(weight) $f(-weight)\n        set fontparam(slant) $f(-slant)\n        fontok\n    }\n}\n\nproc selfontfam {} {\n    global fonttop fontparam\n\n    set i [$fonttop.f.fam curselection]\n    if {$i ne {}} {\n        set fontparam(family) [$fonttop.f.fam get $i]\n    }\n}\n\nproc chg_fontparam {v sub op} {\n    global fontparam\n\n    font config sample -$sub $fontparam($sub)\n}\n\n# Create a property sheet tab page\nproc create_prefs_page {w} {\n    global NS\n    set parent [join [lrange [split $w .] 0 end-1] .]\n    if {[winfo class $parent] eq \"TNotebook\"} {\n        ${NS}::frame $w\n    } else {\n        ${NS}::labelframe $w\n    }\n}\n\nproc prefspage_general {notebook} {\n    global NS maxwidth maxgraphpct showneartags showlocalchanges\n    global tabstop limitdiffs autoselect autosellen extdifftool perfile_attrs\n    global hideremotes want_ttk have_ttk maxrefs web_browser\n\n    set page [create_prefs_page $notebook.general]\n\n    ${NS}::label $page.ldisp -text [mc \"Commit list display options\"]\n    grid $page.ldisp - -sticky w -pady 10\n    ${NS}::label $page.spacer -text \" \"\n    ${NS}::label $page.maxwidthl -text [mc \"Maximum graph width (lines)\"]\n    spinbox $page.maxwidth -from 0 -to 100 -width 4 -textvariable maxwidth\n    grid $page.spacer $page.maxwidthl $page.maxwidth -sticky w\n                                         #xgettext:no-tcl-format\n    ${NS}::label $page.maxpctl -text [mc \"Maximum graph width (% of pane)\"]\n    spinbox $page.maxpct -from 1 -to 100 -width 4 -textvariable maxgraphpct\n    grid x $page.maxpctl $page.maxpct -sticky w\n    ${NS}::checkbutton $page.showlocal -text [mc \"Show local changes\"] \\\n        -variable showlocalchanges\n    grid x $page.showlocal -sticky w\n    ${NS}::checkbutton $page.autoselect -text [mc \"Auto-select SHA1 (length)\"] \\\n        -variable autoselect\n    spinbox $page.autosellen -from 1 -to 40 -width 4 -textvariable autosellen\n    grid x $page.autoselect $page.autosellen -sticky w\n    ${NS}::checkbutton $page.hideremotes -text [mc \"Hide remote refs\"] \\\n        -variable hideremotes\n    grid x $page.hideremotes -sticky w\n\n    ${NS}::label $page.ddisp -text [mc \"Diff display options\"]\n    grid $page.ddisp - -sticky w -pady 10\n    ${NS}::label $page.tabstopl -text [mc \"Tab spacing\"]\n    spinbox $page.tabstop -from 1 -to 20 -width 4 -textvariable tabstop\n    grid x $page.tabstopl $page.tabstop -sticky w\n    ${NS}::checkbutton $page.ntag -text [mc \"Display nearby tags/heads\"] \\\n        -variable showneartags\n    grid x $page.ntag -sticky w\n    ${NS}::label $page.maxrefsl -text [mc \"Maximum # tags/heads to show\"]\n    spinbox $page.maxrefs -from 1 -to 1000 -width 4 -textvariable maxrefs\n    grid x $page.maxrefsl $page.maxrefs -sticky w\n    ${NS}::checkbutton $page.ldiff -text [mc \"Limit diffs to listed paths\"] \\\n        -variable limitdiffs\n    grid x $page.ldiff -sticky w\n    ${NS}::checkbutton $page.lattr -text [mc \"Support per-file encodings\"] \\\n        -variable perfile_attrs\n    grid x $page.lattr -sticky w\n\n    ${NS}::entry $page.extdifft -textvariable extdifftool\n    ${NS}::frame $page.extdifff\n    ${NS}::label $page.extdifff.l -text [mc \"External diff tool\" ]\n    ${NS}::button $page.extdifff.b -text [mc \"Choose...\"] -command choose_extdiff\n    pack $page.extdifff.l $page.extdifff.b -side left\n    pack configure $page.extdifff.l -padx 10\n    grid x $page.extdifff $page.extdifft -sticky ew\n\n    ${NS}::entry $page.webbrowser -textvariable web_browser\n    ${NS}::frame $page.webbrowserf\n    ${NS}::label $page.webbrowserf.l -text [mc \"Web browser\" ]\n    pack $page.webbrowserf.l -side left\n    pack configure $page.webbrowserf.l -padx 10\n    grid x $page.webbrowserf $page.webbrowser -sticky ew\n\n    ${NS}::label $page.lgen -text [mc \"General options\"]\n    grid $page.lgen - -sticky w -pady 10\n    ${NS}::checkbutton $page.want_ttk -variable want_ttk \\\n        -text [mc \"Use themed widgets\"]\n    if {$have_ttk} {\n        ${NS}::label $page.ttk_note -text [mc \"(change requires restart)\"]\n    } else {\n        ${NS}::label $page.ttk_note -text [mc \"(currently unavailable)\"]\n    }\n    grid x $page.want_ttk $page.ttk_note -sticky w\n    return $page\n}\n\nproc prefspage_colors {notebook} {\n    global NS uicolor bgcolor fgcolor ctext diffcolors selectbgcolor markbgcolor\n    global diffbgcolors\n\n    set page [create_prefs_page $notebook.colors]\n\n    ${NS}::label $page.cdisp -text [mc \"Colors: press to choose\"]\n    grid $page.cdisp - -sticky w -pady 10\n    label $page.ui -padx 40 -relief sunk -background $uicolor\n    ${NS}::button $page.uibut -text [mc \"Interface\"] \\\n       -command [list choosecolor uicolor {} $page.ui [mc \"interface\"] setui]\n    grid x $page.uibut $page.ui -sticky w\n    label $page.bg -padx 40 -relief sunk -background $bgcolor\n    ${NS}::button $page.bgbut -text [mc \"Background\"] \\\n        -command [list choosecolor bgcolor {} $page.bg [mc \"background\"] setbg]\n    grid x $page.bgbut $page.bg -sticky w\n    label $page.fg -padx 40 -relief sunk -background $fgcolor\n    ${NS}::button $page.fgbut -text [mc \"Foreground\"] \\\n        -command [list choosecolor fgcolor {} $page.fg [mc \"foreground\"] setfg]\n    grid x $page.fgbut $page.fg -sticky w\n    label $page.diffold -padx 40 -relief sunk -background [lindex $diffcolors 0]\n    ${NS}::button $page.diffoldbut -text [mc \"Diff: old lines\"] \\\n        -command [list choosecolor diffcolors 0 $page.diffold [mc \"diff old lines\"] \\\n                      [list $ctext tag conf d0 -foreground]]\n    grid x $page.diffoldbut $page.diffold -sticky w\n    label $page.diffoldbg -padx 40 -relief sunk -background [lindex $diffbgcolors 0]\n    ${NS}::button $page.diffoldbgbut -text [mc \"Diff: old lines bg\"] \\\n        -command [list choosecolor diffbgcolors 0 $page.diffoldbg \\\n                      [mc \"diff old lines bg\"] \\\n                      [list $ctext tag conf d0 -background]]\n    grid x $page.diffoldbgbut $page.diffoldbg -sticky w\n    label $page.diffnew -padx 40 -relief sunk -background [lindex $diffcolors 1]\n    ${NS}::button $page.diffnewbut -text [mc \"Diff: new lines\"] \\\n        -command [list choosecolor diffcolors 1 $page.diffnew [mc \"diff new lines\"] \\\n                      [list $ctext tag conf dresult -foreground]]\n    grid x $page.diffnewbut $page.diffnew -sticky w\n    label $page.diffnewbg -padx 40 -relief sunk -background [lindex $diffbgcolors 1]\n    ${NS}::button $page.diffnewbgbut -text [mc \"Diff: new lines bg\"] \\\n        -command [list choosecolor diffbgcolors 1 $page.diffnewbg \\\n                      [mc \"diff new lines bg\"] \\\n                      [list $ctext tag conf dresult -background]]\n    grid x $page.diffnewbgbut $page.diffnewbg -sticky w\n    label $page.hunksep -padx 40 -relief sunk -background [lindex $diffcolors 2]\n    ${NS}::button $page.hunksepbut -text [mc \"Diff: hunk header\"] \\\n        -command [list choosecolor diffcolors 2 $page.hunksep \\\n                      [mc \"diff hunk header\"] \\\n                      [list $ctext tag conf hunksep -foreground]]\n    grid x $page.hunksepbut $page.hunksep -sticky w\n    label $page.markbgsep -padx 40 -relief sunk -background $markbgcolor\n    ${NS}::button $page.markbgbut -text [mc \"Marked line bg\"] \\\n        -command [list choosecolor markbgcolor {} $page.markbgsep \\\n                      [mc \"marked line background\"] \\\n                      [list $ctext tag conf omark -background]]\n    grid x $page.markbgbut $page.markbgsep -sticky w\n    label $page.selbgsep -padx 40 -relief sunk -background $selectbgcolor\n    ${NS}::button $page.selbgbut -text [mc \"Select bg\"] \\\n        -command [list choosecolor selectbgcolor {} $page.selbgsep [mc \"background\"] setselbg]\n    grid x $page.selbgbut $page.selbgsep -sticky w\n    return $page\n}\n\nproc prefspage_fonts {notebook} {\n    global NS\n    set page [create_prefs_page $notebook.fonts]\n    ${NS}::label $page.cfont -text [mc \"Fonts: press to choose\"]\n    grid $page.cfont - -sticky w -pady 10\n    mkfontdisp mainfont $page [mc \"Main font\"]\n    mkfontdisp textfont $page [mc \"Diff display font\"]\n    mkfontdisp uifont $page [mc \"User interface font\"]\n    return $page\n}\n\nproc doprefs {} {\n    global maxwidth maxgraphpct use_ttk NS\n    global oldprefs prefstop showneartags showlocalchanges\n    global uicolor bgcolor fgcolor ctext diffcolors selectbgcolor markbgcolor\n    global tabstop limitdiffs autoselect autosellen extdifftool perfile_attrs\n    global hideremotes want_ttk have_ttk\n\n    set top .gitkprefs\n    set prefstop $top\n    if {[winfo exists $top]} {\n        raise $top\n        return\n    }\n    foreach v {maxwidth maxgraphpct showneartags showlocalchanges \\\n                   limitdiffs tabstop perfile_attrs hideremotes want_ttk} {\n        set oldprefs($v) [set $v]\n    }\n    ttk_toplevel $top\n    wm title $top [mc \"Gitk preferences\"]\n    make_transient $top .\n\n    if {[set use_notebook [expr {$use_ttk && [info command ::ttk::notebook] ne \"\"}]]} {\n        set notebook [ttk::notebook $top.notebook]\n    } else {\n        set notebook [${NS}::frame $top.notebook -borderwidth 0 -relief flat]\n    }\n\n    lappend pages [prefspage_general $notebook] [mc \"General\"]\n    lappend pages [prefspage_colors $notebook] [mc \"Colors\"]\n    lappend pages [prefspage_fonts $notebook] [mc \"Fonts\"]\n    set col 0\n    foreach {page title} $pages {\n        if {$use_notebook} {\n            $notebook add $page -text $title\n        } else {\n            set btn [${NS}::button $notebook.b_[string map {. X} $page] \\\n                         -text $title -command [list raise $page]]\n            $page configure -text $title\n            grid $btn -row 0 -column [incr col] -sticky w\n            grid $page -row 1 -column 0 -sticky news -columnspan 100\n        }\n    }\n\n    if {!$use_notebook} {\n        grid columnconfigure $notebook 0 -weight 1\n        grid rowconfigure $notebook 1 -weight 1\n        raise [lindex $pages 0]\n    }\n\n    grid $notebook -sticky news -padx 2 -pady 2\n    grid rowconfigure $top 0 -weight 1\n    grid columnconfigure $top 0 -weight 1\n\n    ${NS}::frame $top.buts\n    ${NS}::button $top.buts.ok -text [mc \"OK\"] -command prefsok -default active\n    ${NS}::button $top.buts.can -text [mc \"Cancel\"] -command prefscan -default normal\n    bind $top <Key-Return> prefsok\n    bind $top <Key-Escape> prefscan\n    grid $top.buts.ok $top.buts.can\n    grid columnconfigure $top.buts 0 -weight 1 -uniform a\n    grid columnconfigure $top.buts 1 -weight 1 -uniform a\n    grid $top.buts - - -pady 10 -sticky ew\n    grid columnconfigure $top 2 -weight 1\n    bind $top <Visibility> [list focus $top.buts.ok]\n}\n\nproc choose_extdiff {} {\n    global extdifftool\n\n    set prog [tk_getOpenFile -title [mc \"External diff tool\"] -multiple false]\n    if {$prog ne {}} {\n        set extdifftool $prog\n    }\n}\n\nproc choosecolor {v vi w x cmd} {\n    global $v\n\n    set c [tk_chooseColor -initialcolor [lindex [set $v] $vi] \\\n               -title [mc \"Gitk: choose color for %s\" $x]]\n    if {$c eq {}} return\n    $w conf -background $c\n    lset $v $vi $c\n    eval $cmd $c\n}\n\nproc setselbg {c} {\n    global bglist cflist\n    foreach w $bglist {\n        if {[winfo exists $w]} {\n            $w configure -selectbackground $c\n        }\n    }\n    $cflist tag configure highlight \\\n        -background [$cflist cget -selectbackground]\n    allcanvs itemconf secsel -fill $c\n}\n\n# This sets the background color and the color scheme for the whole UI.\n# For some reason, tk_setPalette chooses a nasty dark red for selectColor\n# if we don't specify one ourselves, which makes the checkbuttons and\n# radiobuttons look bad.  This chooses white for selectColor if the\n# background color is light, or black if it is dark.\nproc setui {c} {\n    if {[tk windowingsystem] eq \"win32\"} { return }\n    set bg [winfo rgb . $c]\n    set selc black\n    if {[lindex $bg 0] + 1.5 * [lindex $bg 1] + 0.5 * [lindex $bg 2] > 100000} {\n        set selc white\n    }\n    tk_setPalette background $c selectColor $selc\n}\n\nproc setbg {c} {\n    global bglist\n\n    foreach w $bglist {\n        if {[winfo exists $w]} {\n            $w conf -background $c\n        }\n    }\n}\n\nproc setfg {c} {\n    global fglist canv\n\n    foreach w $fglist {\n        if {[winfo exists $w]} {\n            $w conf -foreground $c\n        }\n    }\n    allcanvs itemconf text -fill $c\n    $canv itemconf circle -outline $c\n    $canv itemconf markid -outline $c\n}\n\nproc prefscan {} {\n    global oldprefs prefstop\n\n    foreach v {maxwidth maxgraphpct showneartags showlocalchanges \\\n                   limitdiffs tabstop perfile_attrs hideremotes want_ttk} {\n        global $v\n        set $v $oldprefs($v)\n    }\n    catch {destroy $prefstop}\n    unset prefstop\n    fontcan\n}\n\nproc prefsok {} {\n    global maxwidth maxgraphpct\n    global oldprefs prefstop showneartags showlocalchanges\n    global fontpref mainfont textfont uifont\n    global limitdiffs treediffs perfile_attrs\n    global hideremotes\n\n    catch {destroy $prefstop}\n    unset prefstop\n    fontcan\n    set fontchanged 0\n    if {$mainfont ne $fontpref(mainfont)} {\n        set mainfont $fontpref(mainfont)\n        parsefont mainfont $mainfont\n        eval font configure mainfont [fontflags mainfont]\n        eval font configure mainfontbold [fontflags mainfont 1]\n        setcoords\n        set fontchanged 1\n    }\n    if {$textfont ne $fontpref(textfont)} {\n        set textfont $fontpref(textfont)\n        parsefont textfont $textfont\n        eval font configure textfont [fontflags textfont]\n        eval font configure textfontbold [fontflags textfont 1]\n    }\n    if {$uifont ne $fontpref(uifont)} {\n        set uifont $fontpref(uifont)\n        parsefont uifont $uifont\n        eval font configure uifont [fontflags uifont]\n    }\n    settabs\n    if {$showlocalchanges != $oldprefs(showlocalchanges)} {\n        if {$showlocalchanges} {\n            doshowlocalchanges\n        } else {\n            dohidelocalchanges\n        }\n    }\n    if {$limitdiffs != $oldprefs(limitdiffs) ||\n        ($perfile_attrs && !$oldprefs(perfile_attrs))} {\n        # treediffs elements are limited by path;\n        # won't have encodings cached if perfile_attrs was just turned on\n        unset -nocomplain treediffs\n    }\n    if {$fontchanged || $maxwidth != $oldprefs(maxwidth)\n        || $maxgraphpct != $oldprefs(maxgraphpct)} {\n        redisplay\n    } elseif {$showneartags != $oldprefs(showneartags) ||\n          $limitdiffs != $oldprefs(limitdiffs)} {\n        reselectline\n    }\n    if {$hideremotes != $oldprefs(hideremotes)} {\n        rereadrefs\n    }\n}\n\nproc formatdate {d} {\n    global datetimeformat\n    if {$d ne {}} {\n        # If $datetimeformat includes a timezone, display in the\n        # timezone of the argument.  Otherwise, display in local time.\n        if {[string match {*%[zZ]*} $datetimeformat]} {\n            if {[catch {set d [clock format [lindex $d 0] -timezone [lindex $d 1] -format $datetimeformat]}]} {\n                # Tcl < 8.5 does not support -timezone.  Emulate it by\n                # setting TZ (e.g. TZ=<-0430>+04:30).\n                global env\n                if {[info exists env(TZ)]} {\n                    set savedTZ $env(TZ)\n                }\n                set zone [lindex $d 1]\n                set sign [string map {+ - - +} [string index $zone 0]]\n                set env(TZ) <$zone>$sign[string range $zone 1 2]:[string range $zone 3 4]\n                set d [clock format [lindex $d 0] -format $datetimeformat]\n                if {[info exists savedTZ]} {\n                    set env(TZ) $savedTZ\n                } else {\n                    unset env(TZ)\n                }\n            }\n        } else {\n            set d [clock format [lindex $d 0] -format $datetimeformat]\n        }\n    }\n    return $d\n}\n\n# This list of encoding names and aliases is distilled from\n# http://www.iana.org/assignments/character-sets.\n# Not all of them are supported by Tcl.\nset encoding_aliases {\n    { ANSI_X3.4-1968 iso-ir-6 ANSI_X3.4-1986 ISO_646.irv:1991 ASCII\n      ISO646-US US-ASCII us IBM367 cp367 csASCII }\n    { ISO-10646-UTF-1 csISO10646UTF1 }\n    { ISO_646.basic:1983 ref csISO646basic1983 }\n    { INVARIANT csINVARIANT }\n    { ISO_646.irv:1983 iso-ir-2 irv csISO2IntlRefVersion }\n    { BS_4730 iso-ir-4 ISO646-GB gb uk csISO4UnitedKingdom }\n    { NATS-SEFI iso-ir-8-1 csNATSSEFI }\n    { NATS-SEFI-ADD iso-ir-8-2 csNATSSEFIADD }\n    { NATS-DANO iso-ir-9-1 csNATSDANO }\n    { NATS-DANO-ADD iso-ir-9-2 csNATSDANOADD }\n    { SEN_850200_B iso-ir-10 FI ISO646-FI ISO646-SE se csISO10Swedish }\n    { SEN_850200_C iso-ir-11 ISO646-SE2 se2 csISO11SwedishForNames }\n    { KS_C_5601-1987 iso-ir-149 KS_C_5601-1989 KSC_5601 korean csKSC56011987 }\n    { ISO-2022-KR csISO2022KR }\n    { EUC-KR csEUCKR }\n    { ISO-2022-JP csISO2022JP }\n    { ISO-2022-JP-2 csISO2022JP2 }\n    { JIS_C6220-1969-jp JIS_C6220-1969 iso-ir-13 katakana x0201-7\n      csISO13JISC6220jp }\n    { JIS_C6220-1969-ro iso-ir-14 jp ISO646-JP csISO14JISC6220ro }\n    { IT iso-ir-15 ISO646-IT csISO15Italian }\n    { PT iso-ir-16 ISO646-PT csISO16Portuguese }\n    { ES iso-ir-17 ISO646-ES csISO17Spanish }\n    { greek7-old iso-ir-18 csISO18Greek7Old }\n    { latin-greek iso-ir-19 csISO19LatinGreek }\n    { DIN_66003 iso-ir-21 de ISO646-DE csISO21German }\n    { NF_Z_62-010_(1973) iso-ir-25 ISO646-FR1 csISO25French }\n    { Latin-greek-1 iso-ir-27 csISO27LatinGreek1 }\n    { ISO_5427 iso-ir-37 csISO5427Cyrillic }\n    { JIS_C6226-1978 iso-ir-42 csISO42JISC62261978 }\n    { BS_viewdata iso-ir-47 csISO47BSViewdata }\n    { INIS iso-ir-49 csISO49INIS }\n    { INIS-8 iso-ir-50 csISO50INIS8 }\n    { INIS-cyrillic iso-ir-51 csISO51INISCyrillic }\n    { ISO_5427:1981 iso-ir-54 ISO5427Cyrillic1981 }\n    { ISO_5428:1980 iso-ir-55 csISO5428Greek }\n    { GB_1988-80 iso-ir-57 cn ISO646-CN csISO57GB1988 }\n    { GB_2312-80 iso-ir-58 chinese csISO58GB231280 }\n    { NS_4551-1 iso-ir-60 ISO646-NO no csISO60DanishNorwegian\n      csISO60Norwegian1 }\n    { NS_4551-2 ISO646-NO2 iso-ir-61 no2 csISO61Norwegian2 }\n    { NF_Z_62-010 iso-ir-69 ISO646-FR fr csISO69French }\n    { videotex-suppl iso-ir-70 csISO70VideotexSupp1 }\n    { PT2 iso-ir-84 ISO646-PT2 csISO84Portuguese2 }\n    { ES2 iso-ir-85 ISO646-ES2 csISO85Spanish2 }\n    { MSZ_7795.3 iso-ir-86 ISO646-HU hu csISO86Hungarian }\n    { JIS_C6226-1983 iso-ir-87 x0208 JIS_X0208-1983 csISO87JISX0208 }\n    { greek7 iso-ir-88 csISO88Greek7 }\n    { ASMO_449 ISO_9036 arabic7 iso-ir-89 csISO89ASMO449 }\n    { iso-ir-90 csISO90 }\n    { JIS_C6229-1984-a iso-ir-91 jp-ocr-a csISO91JISC62291984a }\n    { JIS_C6229-1984-b iso-ir-92 ISO646-JP-OCR-B jp-ocr-b\n      csISO92JISC62991984b }\n    { JIS_C6229-1984-b-add iso-ir-93 jp-ocr-b-add csISO93JIS62291984badd }\n    { JIS_C6229-1984-hand iso-ir-94 jp-ocr-hand csISO94JIS62291984hand }\n    { JIS_C6229-1984-hand-add iso-ir-95 jp-ocr-hand-add\n      csISO95JIS62291984handadd }\n    { JIS_C6229-1984-kana iso-ir-96 csISO96JISC62291984kana }\n    { ISO_2033-1983 iso-ir-98 e13b csISO2033 }\n    { ANSI_X3.110-1983 iso-ir-99 CSA_T500-1983 NAPLPS csISO99NAPLPS }\n    { ISO_8859-1:1987 iso-ir-100 ISO_8859-1 ISO-8859-1 latin1 l1 IBM819\n      CP819 csISOLatin1 }\n    { ISO_8859-2:1987 iso-ir-101 ISO_8859-2 ISO-8859-2 latin2 l2 csISOLatin2 }\n    { T.61-7bit iso-ir-102 csISO102T617bit }\n    { T.61-8bit T.61 iso-ir-103 csISO103T618bit }\n    { ISO_8859-3:1988 iso-ir-109 ISO_8859-3 ISO-8859-3 latin3 l3 csISOLatin3 }\n    { ISO_8859-4:1988 iso-ir-110 ISO_8859-4 ISO-8859-4 latin4 l4 csISOLatin4 }\n    { ECMA-cyrillic iso-ir-111 KOI8-E csISO111ECMACyrillic }\n    { CSA_Z243.4-1985-1 iso-ir-121 ISO646-CA csa7-1 ca csISO121Canadian1 }\n    { CSA_Z243.4-1985-2 iso-ir-122 ISO646-CA2 csa7-2 csISO122Canadian2 }\n    { CSA_Z243.4-1985-gr iso-ir-123 csISO123CSAZ24341985gr }\n    { ISO_8859-6:1987 iso-ir-127 ISO_8859-6 ISO-8859-6 ECMA-114 ASMO-708\n      arabic csISOLatinArabic }\n    { ISO_8859-6-E csISO88596E ISO-8859-6-E }\n    { ISO_8859-6-I csISO88596I ISO-8859-6-I }\n    { ISO_8859-7:1987 iso-ir-126 ISO_8859-7 ISO-8859-7 ELOT_928 ECMA-118\n      greek greek8 csISOLatinGreek }\n    { T.101-G2 iso-ir-128 csISO128T101G2 }\n    { ISO_8859-8:1988 iso-ir-138 ISO_8859-8 ISO-8859-8 hebrew\n      csISOLatinHebrew }\n    { ISO_8859-8-E csISO88598E ISO-8859-8-E }\n    { ISO_8859-8-I csISO88598I ISO-8859-8-I }\n    { CSN_369103 iso-ir-139 csISO139CSN369103 }\n    { JUS_I.B1.002 iso-ir-141 ISO646-YU js yu csISO141JUSIB1002 }\n    { ISO_6937-2-add iso-ir-142 csISOTextComm }\n    { IEC_P27-1 iso-ir-143 csISO143IECP271 }\n    { ISO_8859-5:1988 iso-ir-144 ISO_8859-5 ISO-8859-5 cyrillic\n      csISOLatinCyrillic }\n    { JUS_I.B1.003-serb iso-ir-146 serbian csISO146Serbian }\n    { JUS_I.B1.003-mac macedonian iso-ir-147 csISO147Macedonian }\n    { ISO_8859-9:1989 iso-ir-148 ISO_8859-9 ISO-8859-9 latin5 l5 csISOLatin5 }\n    { greek-ccitt iso-ir-150 csISO150 csISO150GreekCCITT }\n    { NC_NC00-10:81 cuba iso-ir-151 ISO646-CU csISO151Cuba }\n    { ISO_6937-2-25 iso-ir-152 csISO6937Add }\n    { GOST_19768-74 ST_SEV_358-88 iso-ir-153 csISO153GOST1976874 }\n    { ISO_8859-supp iso-ir-154 latin1-2-5 csISO8859Supp }\n    { ISO_10367-box iso-ir-155 csISO10367Box }\n    { ISO-8859-10 iso-ir-157 l6 ISO_8859-10:1992 csISOLatin6 latin6 }\n    { latin-lap lap iso-ir-158 csISO158Lap }\n    { JIS_X0212-1990 x0212 iso-ir-159 csISO159JISX02121990 }\n    { DS_2089 DS2089 ISO646-DK dk csISO646Danish }\n    { us-dk csUSDK }\n    { dk-us csDKUS }\n    { JIS_X0201 X0201 csHalfWidthKatakana }\n    { KSC5636 ISO646-KR csKSC5636 }\n    { ISO-10646-UCS-2 csUnicode }\n    { ISO-10646-UCS-4 csUCS4 }\n    { DEC-MCS dec csDECMCS }\n    { hp-roman8 roman8 r8 csHPRoman8 }\n    { macintosh mac csMacintosh }\n    { IBM037 cp037 ebcdic-cp-us ebcdic-cp-ca ebcdic-cp-wt ebcdic-cp-nl\n      csIBM037 }\n    { IBM038 EBCDIC-INT cp038 csIBM038 }\n    { IBM273 CP273 csIBM273 }\n    { IBM274 EBCDIC-BE CP274 csIBM274 }\n    { IBM275 EBCDIC-BR cp275 csIBM275 }\n    { IBM277 EBCDIC-CP-DK EBCDIC-CP-NO csIBM277 }\n    { IBM278 CP278 ebcdic-cp-fi ebcdic-cp-se csIBM278 }\n    { IBM280 CP280 ebcdic-cp-it csIBM280 }\n    { IBM281 EBCDIC-JP-E cp281 csIBM281 }\n    { IBM284 CP284 ebcdic-cp-es csIBM284 }\n    { IBM285 CP285 ebcdic-cp-gb csIBM285 }\n    { IBM290 cp290 EBCDIC-JP-kana csIBM290 }\n    { IBM297 cp297 ebcdic-cp-fr csIBM297 }\n    { IBM420 cp420 ebcdic-cp-ar1 csIBM420 }\n    { IBM423 cp423 ebcdic-cp-gr csIBM423 }\n    { IBM424 cp424 ebcdic-cp-he csIBM424 }\n    { IBM437 cp437 437 csPC8CodePage437 }\n    { IBM500 CP500 ebcdic-cp-be ebcdic-cp-ch csIBM500 }\n    { IBM775 cp775 csPC775Baltic }\n    { IBM850 cp850 850 csPC850Multilingual }\n    { IBM851 cp851 851 csIBM851 }\n    { IBM852 cp852 852 csPCp852 }\n    { IBM855 cp855 855 csIBM855 }\n    { IBM857 cp857 857 csIBM857 }\n    { IBM860 cp860 860 csIBM860 }\n    { IBM861 cp861 861 cp-is csIBM861 }\n    { IBM862 cp862 862 csPC862LatinHebrew }\n    { IBM863 cp863 863 csIBM863 }\n    { IBM864 cp864 csIBM864 }\n    { IBM865 cp865 865 csIBM865 }\n    { IBM866 cp866 866 csIBM866 }\n    { IBM868 CP868 cp-ar csIBM868 }\n    { IBM869 cp869 869 cp-gr csIBM869 }\n    { IBM870 CP870 ebcdic-cp-roece ebcdic-cp-yu csIBM870 }\n    { IBM871 CP871 ebcdic-cp-is csIBM871 }\n    { IBM880 cp880 EBCDIC-Cyrillic csIBM880 }\n    { IBM891 cp891 csIBM891 }\n    { IBM903 cp903 csIBM903 }\n    { IBM904 cp904 904 csIBBM904 }\n    { IBM905 CP905 ebcdic-cp-tr csIBM905 }\n    { IBM918 CP918 ebcdic-cp-ar2 csIBM918 }\n    { IBM1026 CP1026 csIBM1026 }\n    { EBCDIC-AT-DE csIBMEBCDICATDE }\n    { EBCDIC-AT-DE-A csEBCDICATDEA }\n    { EBCDIC-CA-FR csEBCDICCAFR }\n    { EBCDIC-DK-NO csEBCDICDKNO }\n    { EBCDIC-DK-NO-A csEBCDICDKNOA }\n    { EBCDIC-FI-SE csEBCDICFISE }\n    { EBCDIC-FI-SE-A csEBCDICFISEA }\n    { EBCDIC-FR csEBCDICFR }\n    { EBCDIC-IT csEBCDICIT }\n    { EBCDIC-PT csEBCDICPT }\n    { EBCDIC-ES csEBCDICES }\n    { EBCDIC-ES-A csEBCDICESA }\n    { EBCDIC-ES-S csEBCDICESS }\n    { EBCDIC-UK csEBCDICUK }\n    { EBCDIC-US csEBCDICUS }\n    { UNKNOWN-8BIT csUnknown8BiT }\n    { MNEMONIC csMnemonic }\n    { MNEM csMnem }\n    { VISCII csVISCII }\n    { VIQR csVIQR }\n    { KOI8-R csKOI8R }\n    { IBM00858 CCSID00858 CP00858 PC-Multilingual-850+euro }\n    { IBM00924 CCSID00924 CP00924 ebcdic-Latin9--euro }\n    { IBM01140 CCSID01140 CP01140 ebcdic-us-37+euro }\n    { IBM01141 CCSID01141 CP01141 ebcdic-de-273+euro }\n    { IBM01142 CCSID01142 CP01142 ebcdic-dk-277+euro ebcdic-no-277+euro }\n    { IBM01143 CCSID01143 CP01143 ebcdic-fi-278+euro ebcdic-se-278+euro }\n    { IBM01144 CCSID01144 CP01144 ebcdic-it-280+euro }\n    { IBM01145 CCSID01145 CP01145 ebcdic-es-284+euro }\n    { IBM01146 CCSID01146 CP01146 ebcdic-gb-285+euro }\n    { IBM01147 CCSID01147 CP01147 ebcdic-fr-297+euro }\n    { IBM01148 CCSID01148 CP01148 ebcdic-international-500+euro }\n    { IBM01149 CCSID01149 CP01149 ebcdic-is-871+euro }\n    { IBM1047 IBM-1047 }\n    { PTCP154 csPTCP154 PT154 CP154 Cyrillic-Asian }\n    { Amiga-1251 Ami1251 Amiga1251 Ami-1251 }\n    { UNICODE-1-1 csUnicode11 }\n    { CESU-8 csCESU-8 }\n    { BOCU-1 csBOCU-1 }\n    { UNICODE-1-1-UTF-7 csUnicode11UTF7 }\n    { ISO-8859-14 iso-ir-199 ISO_8859-14:1998 ISO_8859-14 latin8 iso-celtic\n      l8 }\n    { ISO-8859-15 ISO_8859-15 Latin-9 }\n    { ISO-8859-16 iso-ir-226 ISO_8859-16:2001 ISO_8859-16 latin10 l10 }\n    { GBK CP936 MS936 windows-936 }\n    { JIS_Encoding csJISEncoding }\n    { Shift_JIS MS_Kanji csShiftJIS ShiftJIS Shift-JIS }\n    { Extended_UNIX_Code_Packed_Format_for_Japanese csEUCPkdFmtJapanese\n      EUC-JP }\n    { Extended_UNIX_Code_Fixed_Width_for_Japanese csEUCFixWidJapanese }\n    { ISO-10646-UCS-Basic csUnicodeASCII }\n    { ISO-10646-Unicode-Latin1 csUnicodeLatin1 ISO-10646 }\n    { ISO-Unicode-IBM-1261 csUnicodeIBM1261 }\n    { ISO-Unicode-IBM-1268 csUnicodeIBM1268 }\n    { ISO-Unicode-IBM-1276 csUnicodeIBM1276 }\n    { ISO-Unicode-IBM-1264 csUnicodeIBM1264 }\n    { ISO-Unicode-IBM-1265 csUnicodeIBM1265 }\n    { ISO-8859-1-Windows-3.0-Latin-1 csWindows30Latin1 }\n    { ISO-8859-1-Windows-3.1-Latin-1 csWindows31Latin1 }\n    { ISO-8859-2-Windows-Latin-2 csWindows31Latin2 }\n    { ISO-8859-9-Windows-Latin-5 csWindows31Latin5 }\n    { Adobe-Standard-Encoding csAdobeStandardEncoding }\n    { Ventura-US csVenturaUS }\n    { Ventura-International csVenturaInternational }\n    { PC8-Danish-Norwegian csPC8DanishNorwegian }\n    { PC8-Turkish csPC8Turkish }\n    { IBM-Symbols csIBMSymbols }\n    { IBM-Thai csIBMThai }\n    { HP-Legal csHPLegal }\n    { HP-Pi-font csHPPiFont }\n    { HP-Math8 csHPMath8 }\n    { Adobe-Symbol-Encoding csHPPSMath }\n    { HP-DeskTop csHPDesktop }\n    { Ventura-Math csVenturaMath }\n    { Microsoft-Publishing csMicrosoftPublishing }\n    { Windows-31J csWindows31J }\n    { GB2312 csGB2312 }\n    { Big5 csBig5 }\n}\n\nproc tcl_encoding {enc} {\n    global encoding_aliases tcl_encoding_cache\n    if {[info exists tcl_encoding_cache($enc)]} {\n        return $tcl_encoding_cache($enc)\n    }\n    set names [encoding names]\n    set lcnames [string tolower $names]\n    set enc [string tolower $enc]\n    set i [lsearch -exact $lcnames $enc]\n    if {$i < 0} {\n        # look for \"isonnn\" instead of \"iso-nnn\" or \"iso_nnn\"\n        if {[regsub {^(iso|cp|ibm|jis)[-_]} $enc {\\1} encx]} {\n            set i [lsearch -exact $lcnames $encx]\n        }\n    }\n    if {$i < 0} {\n        foreach l $encoding_aliases {\n            set ll [string tolower $l]\n            if {[lsearch -exact $ll $enc] < 0} continue\n            # look through the aliases for one that tcl knows about\n            foreach e $ll {\n                set i [lsearch -exact $lcnames $e]\n                if {$i < 0} {\n                    if {[regsub {^(iso|cp|ibm|jis)[-_]} $e {\\1} ex]} {\n                        set i [lsearch -exact $lcnames $ex]\n                    }\n                }\n                if {$i >= 0} break\n            }\n            break\n        }\n    }\n    set tclenc {}\n    if {$i >= 0} {\n        set tclenc [lindex $names $i]\n    }\n    set tcl_encoding_cache($enc) $tclenc\n    return $tclenc\n}\n\nproc gitattr {path attr default} {\n    global path_attr_cache\n    if {[info exists path_attr_cache($attr,$path)]} {\n        set r $path_attr_cache($attr,$path)\n    } else {\n        set r \"unspecified\"\n        if {![catch {set line [exec git check-attr $attr -- $path]}]} {\n            regexp \"(.*): $attr: (.*)\" $line m f r\n        }\n        set path_attr_cache($attr,$path) $r\n    }\n    if {$r eq \"unspecified\"} {\n        return $default\n    }\n    return $r\n}\n\nproc cache_gitattr {attr pathlist} {\n    global path_attr_cache\n    set newlist {}\n    foreach path $pathlist {\n        if {![info exists path_attr_cache($attr,$path)]} {\n            lappend newlist $path\n        }\n    }\n    set lim 1000\n    if {[tk windowingsystem] == \"win32\"} {\n        # windows has a 32k limit on the arguments to a command...\n        set lim 30\n    }\n    while {$newlist ne {}} {\n        set head [lrange $newlist 0 [expr {$lim - 1}]]\n        set newlist [lrange $newlist $lim end]\n        if {![catch {set rlist [eval exec git check-attr $attr -- $head]}]} {\n            foreach row [split $rlist \"\\n\"] {\n                if {[regexp \"(.*): $attr: (.*)\" $row m path value]} {\n                    if {[string index $path 0] eq \"\\\"\"} {\n                        set path [encoding convertfrom utf-8 [lindex $path 0]]\n                    }\n                    set path_attr_cache($attr,$path) $value\n                }\n            }\n        }\n    }\n}\n\nproc get_path_encoding {path} {\n    global gui_encoding perfile_attrs\n    set tcl_enc $gui_encoding\n    if {$path ne {} && $perfile_attrs} {\n        set enc2 [tcl_encoding [gitattr $path encoding $tcl_enc]]\n        if {$enc2 ne {}} {\n            set tcl_enc $enc2\n        }\n    }\n    return $tcl_enc\n}\n\n## For msgcat loading, first locate the installation location.\nif { [info exists ::env(GITK_MSGSDIR)] } {\n    ## Msgsdir was manually set in the environment.\n    set gitk_msgsdir $::env(GITK_MSGSDIR)\n} else {\n    ## Let's guess the prefix from argv0.\n    set gitk_prefix [file dirname [file dirname [file normalize $argv0]]]\n    set gitk_libdir [file join $gitk_prefix share gitk lib]\n    set gitk_msgsdir [file join $gitk_libdir msgs]\n}\n\n## Internationalization (i18n) through msgcat and gettext. See\n## http://www.gnu.org/software/gettext/manual/html_node/Tcl.html\npackage require msgcat\nnamespace import ::msgcat::mc\n## And eventually load the actual message catalog\n::msgcat::mcload $gitk_msgsdir\n\n# First check that Tcl/Tk is recent enough\nif {[catch {package require Tk 8.4} err]} {\n    show_error {} . [mc \"Sorry, gitk cannot run with this version of Tcl/Tk.\\n\\\n                         Gitk requires at least Tcl/Tk 8.4.\"]\n    exit 1\n}\n\n# on OSX bring the current Wish process window to front\nif {[tk windowingsystem] eq \"aqua\"} {\n    exec osascript -e [format {\n        tell application \"System Events\"\n            set frontmost of processes whose unix id is %d to true\n        end tell\n    } [pid] ]\n}\n\n# Unset GIT_TRACE var if set\nif { [info exists ::env(GIT_TRACE)] } {\n    unset ::env(GIT_TRACE)\n}\n\n# defaults...\nset wrcomcmd \"git diff-tree --stdin -p --pretty=email\"\n\nset gitencoding {}\ncatch {\n    set gitencoding [exec git config --get i18n.commitencoding]\n}\ncatch {\n    set gitencoding [exec git config --get i18n.logoutputencoding]\n}\nif {$gitencoding == \"\"} {\n    set gitencoding \"utf-8\"\n}\nset tclencoding [tcl_encoding $gitencoding]\nif {$tclencoding == {}} {\n    puts stderr \"Warning: encoding $gitencoding is not supported by Tcl/Tk\"\n}\n\nset gui_encoding [encoding system]\ncatch {\n    set enc [exec git config --get gui.encoding]\n    if {$enc ne {}} {\n        set tclenc [tcl_encoding $enc]\n        if {$tclenc ne {}} {\n            set gui_encoding $tclenc\n        } else {\n            puts stderr \"Warning: encoding $enc is not supported by Tcl/Tk\"\n        }\n    }\n}\n\nset log_showroot true\ncatch {\n    set log_showroot [exec git config --bool --get log.showroot]\n}\n\nif {[tk windowingsystem] eq \"aqua\"} {\n    set mainfont {{Lucida Grande} 9}\n    set textfont {Monaco 9}\n    set uifont {{Lucida Grande} 9 bold}\n} elseif {![catch {::tk::pkgconfig get fontsystem} xft] && $xft eq \"xft\"} {\n    # fontconfig!\n    set mainfont {sans 9}\n    set textfont {monospace 9}\n    set uifont {sans 9 bold}\n} else {\n    set mainfont {Helvetica 9}\n    set textfont {Courier 9}\n    set uifont {Helvetica 9 bold}\n}\nset tabstop 8\nset findmergefiles 0\nset maxgraphpct 50\nset maxwidth 16\nset revlistorder 0\nset fastdate 0\nset uparrowlen 5\nset downarrowlen 5\nset mingaplen 100\nset cmitmode \"patch\"\nset wrapcomment \"none\"\nset showneartags 1\nset hideremotes 0\nset maxrefs 20\nset visiblerefs {\"master\"}\nset maxlinelen 200\nset showlocalchanges 1\nset limitdiffs 1\nset datetimeformat \"%Y-%m-%d %H:%M:%S\"\nset autoselect 1\nset autosellen 40\nset perfile_attrs 0\nset want_ttk 1\n\nif {[tk windowingsystem] eq \"aqua\"} {\n    set extdifftool \"opendiff\"\n} else {\n    set extdifftool \"meld\"\n}\n\nset colors {\"#00ff00\" red blue magenta darkgrey brown orange}\nif {[tk windowingsystem] eq \"win32\"} {\n    set uicolor SystemButtonFace\n    set uifgcolor SystemButtonText\n    set uifgdisabledcolor SystemDisabledText\n    set bgcolor SystemWindow\n    set fgcolor SystemWindowText\n    set selectbgcolor SystemHighlight\n    set web_browser \"cmd /c start\"\n} else {\n    set uicolor grey85\n    set uifgcolor black\n    set uifgdisabledcolor \"#999\"\n    set bgcolor white\n    set fgcolor black\n    set selectbgcolor gray85\n    if {[tk windowingsystem] eq \"aqua\"} {\n        set web_browser \"open\"\n    } else {\n        set web_browser \"xdg-open\"\n    }\n}\nset diffcolors {\"#c30000\" \"#009800\" blue}\nset diffbgcolors {\"#fff3f3\" \"#f0fff0\"}\nset diffcontext 3\nset mergecolors {red blue \"#00ff00\" purple brown \"#009090\" magenta \"#808000\" \"#009000\" \"#ff0080\" cyan \"#b07070\" \"#70b0f0\" \"#70f0b0\" \"#f0b070\" \"#ff70b0\"}\nset ignorespace 0\nset worddiff \"\"\nset markbgcolor \"#e0e0ff\"\n\nset headbgcolor \"#00ff00\"\nset headfgcolor black\nset headoutlinecolor black\nset remotebgcolor #ffddaa\nset tagbgcolor yellow\nset tagfgcolor black\nset tagoutlinecolor black\nset reflinecolor black\nset filesepbgcolor #aaaaaa\nset filesepfgcolor black\nset linehoverbgcolor #ffff80\nset linehoverfgcolor black\nset linehoveroutlinecolor black\nset mainheadcirclecolor yellow\nset workingfilescirclecolor red\nset indexcirclecolor \"#00ff00\"\nset circlecolors {white blue gray blue blue}\nset linkfgcolor blue\nset circleoutlinecolor $fgcolor\nset foundbgcolor yellow\nset currentsearchhitbgcolor orange\n\n# button for popping up context menus\nif {[tk windowingsystem] eq \"aqua\"} {\n    set ctxbut <Button-2>\n} else {\n    set ctxbut <Button-3>\n}\n\ncatch {\n    # follow the XDG base directory specification by default. See\n    # http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n    if {[info exists env(XDG_CONFIG_HOME)] && $env(XDG_CONFIG_HOME) ne \"\"} {\n        # XDG_CONFIG_HOME environment variable is set\n        set config_file [file join $env(XDG_CONFIG_HOME) git gitk]\n        set config_file_tmp [file join $env(XDG_CONFIG_HOME) git gitk-tmp]\n    } else {\n        # default XDG_CONFIG_HOME\n        set config_file \"~/.config/git/gitk\"\n        set config_file_tmp \"~/.config/git/gitk-tmp\"\n    }\n    if {![file exists $config_file]} {\n        # for backward compatibility use the old config file if it exists\n        if {[file exists \"~/.gitk\"]} {\n            set config_file \"~/.gitk\"\n            set config_file_tmp \"~/.gitk-tmp\"\n        } elseif {![file exists [file dirname $config_file]]} {\n            file mkdir [file dirname $config_file]\n        }\n    }\n    source $config_file\n}\nconfig_check_tmp_exists 50\n\nset config_variables {\n    mainfont textfont uifont tabstop findmergefiles maxgraphpct maxwidth\n    cmitmode wrapcomment autoselect autosellen showneartags maxrefs visiblerefs\n    hideremotes showlocalchanges datetimeformat limitdiffs uicolor want_ttk\n    bgcolor fgcolor uifgcolor uifgdisabledcolor colors diffcolors mergecolors\n    markbgcolor diffcontext selectbgcolor foundbgcolor currentsearchhitbgcolor\n    extdifftool perfile_attrs headbgcolor headfgcolor headoutlinecolor\n    remotebgcolor tagbgcolor tagfgcolor tagoutlinecolor reflinecolor\n    filesepbgcolor filesepfgcolor linehoverbgcolor linehoverfgcolor\n    linehoveroutlinecolor mainheadcirclecolor workingfilescirclecolor\n    indexcirclecolor circlecolors linkfgcolor circleoutlinecolor diffbgcolors\n    web_browser\n}\nforeach var $config_variables {\n    config_init_trace $var\n    trace add variable $var write config_variable_change_cb\n}\n\nparsefont mainfont $mainfont\neval font create mainfont [fontflags mainfont]\neval font create mainfontbold [fontflags mainfont 1]\n\nparsefont textfont $textfont\neval font create textfont [fontflags textfont]\neval font create textfontbold [fontflags textfont 1]\n\nparsefont uifont $uifont\neval font create uifont [fontflags uifont]\n\nsetui $uicolor\n\nsetoptions\n\n# check that we can find a .git directory somewhere...\nif {[catch {set gitdir [exec git rev-parse --git-dir]}]} {\n    show_error {} . [mc \"Cannot find a git repository here.\"]\n    exit 1\n}\n\nset selecthead {}\nset selectheadid {}\n\nset revtreeargs {}\nset cmdline_files {}\nset i 0\nset revtreeargscmd {}\nforeach arg $argv {\n    switch -glob -- $arg {\n        \"\" { }\n        \"--\" {\n            set cmdline_files [lrange $argv [expr {$i + 1}] end]\n            break\n        }\n        \"--select-commit=*\" {\n            set selecthead [string range $arg 16 end]\n        }\n        \"--argscmd=*\" {\n            set revtreeargscmd [string range $arg 10 end]\n        }\n        default {\n            lappend revtreeargs $arg\n        }\n    }\n    incr i\n}\n\nif {$selecthead eq \"HEAD\"} {\n    set selecthead {}\n}\n\nif {$i >= [llength $argv] && $revtreeargs ne {}} {\n    # no -- on command line, but some arguments (other than --argscmd)\n    if {[catch {\n        set f [eval exec git rev-parse --no-revs --no-flags $revtreeargs]\n        set cmdline_files [split $f \"\\n\"]\n        set n [llength $cmdline_files]\n        set revtreeargs [lrange $revtreeargs 0 end-$n]\n        # Unfortunately git rev-parse doesn't produce an error when\n        # something is both a revision and a filename.  To be consistent\n        # with git log and git rev-list, check revtreeargs for filenames.\n        foreach arg $revtreeargs {\n            if {[file exists $arg]} {\n                show_error {} . [mc \"Ambiguous argument '%s': both revision\\\n                                 and filename\" $arg]\n                exit 1\n            }\n        }\n    } err]} {\n        # unfortunately we get both stdout and stderr in $err,\n        # so look for \"fatal:\".\n        set i [string first \"fatal:\" $err]\n        if {$i > 0} {\n            set err [string range $err [expr {$i + 6}] end]\n        }\n        show_error {} . \"[mc \"Bad arguments to gitk:\"]\\n$err\"\n        exit 1\n    }\n}\n\nset nullid \"0000000000000000000000000000000000000000\"\nset nullid2 \"0000000000000000000000000000000000000001\"\nset nullfile \"/dev/null\"\n\nset have_tk85 [expr {[package vcompare $tk_version \"8.5\"] >= 0}]\nset have_tk86 [expr {[package vcompare $tk_version \"8.6\"] >= 0}]\nif {![info exists have_ttk]} {\n    set have_ttk [llength [info commands ::ttk::style]]\n}\nset use_ttk [expr {$have_ttk && $want_ttk}]\nset NS [expr {$use_ttk ? \"ttk\" : \"\"}]\n\nif {$use_ttk} {\n    setttkstyle\n}\n\nregexp {^git version ([\\d.]*\\d)} [exec git version] _ git_version\n\nset show_notes {}\nif {[package vcompare $git_version \"1.6.6.2\"] >= 0} {\n    set show_notes \"--show-notes\"\n}\n\nset appname \"gitk\"\n\nset runq {}\nset history {}\nset historyindex 0\nset fh_serial 0\nset nhl_names {}\nset highlight_paths {}\nset findpattern {}\nset searchdirn -forwards\nset boldids {}\nset boldnameids {}\nset diffelide {0 0}\nset markingmatches 0\nset linkentercount 0\nset need_redisplay 0\nset nrows_drawn 0\nset firsttabstop 0\n\nset nextviewnum 1\nset curview 0\nset selectedview 0\nset selectedhlview [mc \"None\"]\nset highlight_related [mc \"None\"]\nset highlight_files {}\nset viewfiles(0) {}\nset viewperm(0) 0\nset viewchanged(0) 0\nset viewargs(0) {}\nset viewargscmd(0) {}\n\nset selectedline {}\nset numcommits 0\nset loginstance 0\nset cmdlineok 0\nset stopped 0\nset stuffsaved 0\nset patchnum 0\nset lserial 0\nset hasworktree [hasworktree]\nset cdup {}\nif {[expr {[exec git rev-parse --is-inside-work-tree] == \"true\"}]} {\n    set cdup [exec git rev-parse --show-cdup]\n}\nset worktree [gitworktree]\nsetcoords\nmakewindow\nif {$::tcl_platform(platform) eq {windows} && [file exists $gitk_prefix/etc/git.ico]} {\n    wm iconbitmap . -default $gitk_prefix/etc/git.ico\n} else {\n    catch {\n        image create photo gitlogo      -width 16 -height 16\n\n        image create photo gitlogominus -width  4 -height  2\n        gitlogominus put #C00000 -to 0 0 4 2\n        gitlogo copy gitlogominus -to  1 5\n        gitlogo copy gitlogominus -to  6 5\n        gitlogo copy gitlogominus -to 11 5\n        image delete gitlogominus\n\n        image create photo gitlogoplus  -width  4 -height  4\n        gitlogoplus  put #008000 -to 1 0 3 4\n        gitlogoplus  put #008000 -to 0 1 4 3\n        gitlogo copy gitlogoplus  -to  1 9\n        gitlogo copy gitlogoplus  -to  6 9\n        gitlogo copy gitlogoplus  -to 11 9\n        image delete gitlogoplus\n\n        image create photo gitlogo32    -width 32 -height 32\n        gitlogo32 copy gitlogo -zoom 2 2\n\n        wm iconphoto . -default gitlogo gitlogo32\n    }\n}\n# wait for the window to become visible\ntkwait visibility .\nset_window_title\nupdate\nreadrefs\n\nif {$cmdline_files ne {} || $revtreeargs ne {} || $revtreeargscmd ne {}} {\n    # create a view for the files/dirs specified on the command line\n    set curview 1\n    set selectedview 1\n    set nextviewnum 2\n    set viewname(1) [mc \"Command line\"]\n    set viewfiles(1) $cmdline_files\n    set viewargs(1) $revtreeargs\n    set viewargscmd(1) $revtreeargscmd\n    set viewperm(1) 0\n    set viewchanged(1) 0\n    set vdatemode(1) 0\n    addviewmenu 1\n    .bar.view entryconf [mca \"&Edit view...\"] -state normal\n    .bar.view entryconf [mca \"&Delete view\"] -state normal\n}\n\nif {[info exists permviews]} {\n    foreach v $permviews {\n        set n $nextviewnum\n        incr nextviewnum\n        set viewname($n) [lindex $v 0]\n        set viewfiles($n) [lindex $v 1]\n        set viewargs($n) [lindex $v 2]\n        set viewargscmd($n) [lindex $v 3]\n        set viewperm($n) 1\n        set viewchanged($n) 0\n        addviewmenu $n\n    }\n}\n\nif {[tk windowingsystem] eq \"win32\"} {\n    focus -force .\n}\n\ngetcommits {}\n\n# Local variables:\n# mode: tcl\n# indent-tabs-mode: t\n# tab-width: 8\n# End:\n"], "filenames": ["gitk-git/gitk"], "buggy_code_start_loc": [10], "buggy_code_end_loc": [10], "fixing_code_start_loc": [11], "fixing_code_end_loc": [146], "type": "CWE-426", "message": "Git for Windows is the Windows port of the revision control system Git. Prior to Git for Windows version 2.39.2, when `gitk` is run on Windows, it potentially runs executables from the current directory inadvertently, which can be exploited with some social engineering to trick users into running untrusted code. A patch is available in version 2.39.2. As a workaround, avoid using `gitk` (or Git GUI's \"Visualize History\" functionality) in clones of untrusted repositories.", "other": {"cve": {"id": "CVE-2023-23618", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-14T21:15:13.170", "lastModified": "2023-02-23T20:26:12.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Git for Windows is the Windows port of the revision control system Git. Prior to Git for Windows version 2.39.2, when `gitk` is run on Windows, it potentially runs executables from the current directory inadvertently, which can be exploited with some social engineering to trick users into running untrusted code. A patch is available in version 2.39.2. As a workaround, avoid using `gitk` (or Git GUI's \"Visualize History\" functionality) in clones of untrusted repositories."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-426"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-426"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git_for_windows_project:git_for_windows:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.39.2", "matchCriteriaId": "613F976A-860B-4267-8364-74D7BC74030D"}]}]}], "references": [{"url": "https://github.com/git-for-windows/git/commit/49a8ec9dac3cec6602f05fed1b3f80a549c8c05c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/git-for-windows/git/releases/tag/v2.39.2.windows.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/git-for-windows/git/security/advisories/GHSA-wxwv-49qw-35pm", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://wiki.tcl-lang.org/page/exec", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}]}, "github_commit_url": "https://github.com/git-for-windows/git/commit/49a8ec9dac3cec6602f05fed1b3f80a549c8c05c"}}