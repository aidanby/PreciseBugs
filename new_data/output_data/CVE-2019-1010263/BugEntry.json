{"buggy_code": ["NAME\n    Crypt::JWT - JSON Web Token (JWT, JWS, JWE) as defined by RFC7519,\n    RFC7515, RFC7516\n\nSYNOPSIS\n       # encoding\n       use Crypt::JWT qw(encode_jwt);\n       my $jws_token = encode_jwt(payload=>$data, alg=>'HS256', key=>'secret');\n       my $jwe_token = encode_jwt(payload=>$data, alg=>'PBES2-HS256+A128KW', enc=>'A128GCM', key=>'secret');\n\n       # decoding\n       use Crypt::JWT qw(decode_jwt);\n       my $data1 = decode_jwt(token=>$jws_token, key=>'secret');\n       my $data2 = decode_jwt(token=>$jwe_token, key=>'secret');\n\nDESCRIPTION\n    Implements JSON Web Token (JWT) - <https://tools.ietf.org/html/rfc7519>.\n    The implementation covers not only JSON Web Signature (JWS) -\n    <https://tools.ietf.org/html/rfc7515>, but also JSON Web Encryption\n    (JWE) - <https://tools.ietf.org/html/rfc7516>.\n\n    The module implements all (100%) algorithms defined in\n    <https://tools.ietf.org/html/rfc7518> - JSON Web Algorithms (JWA).\n\n    This module supports Compact JWS/JWE and Flattened JWS/JWE JSON\n    serialization, general JSON serialization is not supported yet.\n\nEXPORT\n    Nothing is exported by default.\n\n    You can export selected functions:\n\n      use Crypt::JWT qw(decode_jwt encode_jwt);\n\n    Or all of them at once:\n\n      use Crypt::JWT ':all';\n\nFUNCTIONS\n  decode_jwt\n     my $data = decode_jwt(%named_args);\n\n    Named arguments:\n\n    token\n        Mandatory argument, a string with either JWS or JWE JSON Web Token.\n\n         ### JWS token example (3 segments)\n         $t = \"eyJhbGciOiJIUzI1NiJ9.dGVzdA.ujBihtLSr66CEWqN74SpLUkv28lra_CeHnxLmLNp4Jo\";\n         my $data = decode_jwt(token=>$t, key=>$k);\n\n         ### JWE token example (5 segments)\n         $t = \"eyJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiQTEyOEtXIn0.UusxEbzhGkORxTRq0xkFKhvzPrXb9smw.VGfOuq0Fxt6TsdqLZUpnxw.JajIQQ.pkKZ7MHS0XjyGmRsqgom6w\";\n         my $data = decode_jwt(token=>$t, key=>$k);\n\n    key A key used for token decryption (JWE) or token signature validation\n        (JWS). If not given, and the token header contains a \"jwk\" header\n        value, that value will be used. The value depends on the \"alg\" token\n        header value.\n\n         JWS alg header      key value\n         ------------------  ----------------------------------\n         none                no key required\n         HS256               string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         HS384               dtto\n         HS512               dtto\n         RS256               public RSA key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             object: Crypt::PK::RSA, Crypt::OpenSSL::RSA, Crypt::X509 or Crypt::OpenSSL::X509\n         RS384               public RSA key, see RS256\n         RS512               public RSA key, see RS256\n         PS256               public RSA key, see RS256\n         PS384               public RSA key, see RS256\n         PS512               public RSA key, see RS256\n         ES256               public ECC key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::ECC\n         ES384               public ECC key, see ES256\n         ES512               public ECC key, see ES256\n\n         JWE alg header      key value\n         ------------------  ----------------------------------\n         dir                 string (raw octects) or perl HASH ref with JWK, kty=>'oct', length depends on 'enc' algorithm\n         A128KW              string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A192KW              string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A256KW              string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A128GCMKW           string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A192GCMKW           string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A256GCMKW           string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS256+A128KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS384+A192KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS512+A256KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         RSA-OAEP            private RSA key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::RSA or Crypt::OpenSSL::RSA\n         RSA-OAEP-256        private RSA key, see RSA-OAEP\n         RSA1_5              private RSA key, see RSA-OAEP\n         ECDH-ES             private ECC key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::ECC\n         ECDH-ES+A128KW      private ECC key, see ECDH-ES\n         ECDH-ES+A192KW      private ECC key, see ECDH-ES\n         ECDH-ES+A256KW      private ECC key, see ECDH-ES\n\n        Example with key from \"jwk\" token header:\n\n         my $data = decode_jwt(token=>$t);\n         my ($header, $data) = decode_jwt(token=>$t, decode_header=>1);\n\n        Examples with raw octet keys:\n\n         #string\n         my $data = decode_jwt(token=>$t, key=>'secretkey');\n         #binary key\n         my $data = decode_jwt(token=>$t, key=>pack(\"H*\", \"788A6E38F36B7596EF6A669E94\"));\n         #perl HASH ref with JWK structure (key type 'oct')\n         my $data = decode_jwt(token=>$t, key=>{kty=>'oct', k=>\"GawgguFyGrWKav7AX4VKUg\"});\n\n        Examples with RSA keys:\n\n         my $pem_key_string = <<'EOF';\n         -----BEGIN PRIVATE KEY-----\n         MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCoVm/Sl5r+Ofky\n         jioRSZK26GW6WyjyfWKddsSi13/NOtCn0rRErSF/u3QrgGMpWFqKohqbi1VVC+SZ\n         ...\n         8c1vm2YFafgdkSk9Qd1oU2Fv1aOQy4VovOFzJ3CcR+2r7cbRfcpLGnintHtp9yek\n         02p+d5g4OChfFNDhDtnIqjvY\n         -----END PRIVATE KEY-----\n         EOF\n\n         my $jwk_key_json_string = '{\"kty\":\"RSA\",\"n\":\"0vx7agoebG...L6tSoc_BJECP\",\"e\":\"AQAB\"}';\n\n         #a reference to SCALAR string with PEM or DER or JSON/JWK data,\n         my $data = decode_jwt(token=>$t, key=>\\$pem_key_string);\n         my $data = decode_jwt(token=>$t, key=>\\$der_key_string);\n         my $data = decode_jwt(token=>$t, key=>\\$jwk_key_json_string);\n\n         #instance of Crypt::PK::RSA\n         my $data = decode_jwt(token=>$t, key=>Crypt::PK::RSA->new('keyfile.pem'));\n         my $data = decode_jwt(token=>$t, key=>Crypt::PK::RSA->new(\\$pem_key_string));\n\n         #instance of Crypt::OpenSSL::RSA\n         my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::RSA->new_private_key($pem_key_string));\n\n         #instance of Crypt::X509 (public key only)\n         my $data = decode_jwt(token=>$t, key=>Crypt::X509->new(cert=>$cert));\n\n         #instance of Crypt::OpenSSL::X509 (public key only)\n         my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::X509->new_from_file('cert.pem'));\n         my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::X509->new_from_string($cert));\n\n         #perl HASH ref with JWK structure (key type 'RSA')\n         my $rsa_priv = {\n           kty => \"RSA\",\n           n   => \"0vx7agoebGcQSuuPiLJXZpt...eZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqbw0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw\",\n           e   => \"AQAB\",\n           d   => \"X4cTteJY_gn4FYPsXB8rdXi...FLN5EEaG6RoVH-HLKD9Mdx5ooGURknhnrRwUkC7h5fJLMWbFAKLWY2v7B6NqSzUvx0_YSf\",\n           p   => \"83i-7IvMGXoMXCskv73TKr8...Z27zvoj6pbUQyLPBQxtPnwD20-60eTmD2ujMt5PoMrm8RmNhVWtjjMmMjOpSicFHjXOuVI\",\n           q   => \"3dfOR9cuYq-0S-mkFLzgItg...q3hWeMuG0ouqnb3obLyuqjVZQ1dIrdgTnCdYzBcOW5r37AFXjift_NGiovonzhKpoVVS78\",\n           dp  => \"G4sPXkc6Ya9y8oJW9_ILj4...zi_H7TkS8x5SdX3oE0oiYwxIiemTAu0UOa5pgFGyJ4c8t2VF40XRugKTP8akhFo5tA77Qe\",\n           dq  => \"s9lAH9fggBsoFR8Oac2R_E...T2kGOhvIllTE1efA6huUvMfBcpn8lqW6vzzYY5SSF7pMd_agI3G8IbpBUb0JiraRNUfLhc\",\n           qi  => \"GyM_p6JrXySiz1toFgKbWV...4ypu9bMWx3QJBfm0FoYzUIZEVEcOqwmRN81oDAaaBk0KWGDjJHDdDmFW3AN7I-pux_mHZG\",\n         };\n         my $data = decode_jwt(token=>$t, key=>$rsa_priv});\n\n        Examples with ECC keys:\n\n         my $pem_key_string = <<'EOF';\n         -----BEGIN EC PRIVATE KEY-----\n         MHcCAQEEIBG1c3z52T8XwMsahGVdOZWgKCQJfv+l7djuJjgetdbDoAoGCCqGSM49\n         AwEHoUQDQgAEoBUyo8CQAFPeYPvv78ylh5MwFZjTCLQeb042TjiMJxG+9DLFmRSM\n         lBQ9T/RsLLc+PmpB1+7yPAR+oR5gZn3kJQ==\n         -----END EC PRIVATE KEY-----\n         EOF\n\n         my $jwk_key_json_string = '{\"kty\":\"EC\",\"crv\":\"P-256\",\"x\":\"MKB..7D4\",\"y\":\"4Et..FyM\"}';\n\n         #a reference to SCALAR string with PEM or DER or JSON/JWK data,\n         my $data = decode_jwt(token=>$t, key=>\\$pem_key_string);\n         my $data = decode_jwt(token=>$t, key=>\\$der_key_string);\n         my $data = decode_jwt(token=>$t, key=>\\$jwk_key_json_string);\n\n         #instance of Crypt::PK::ECC\n         my $data = decode_jwt(token=>$t, key=>Crypt::PK::ECC->new('keyfile.pem'));\n         my $data = decode_jwt(token=>$t, key=>Crypt::PK::ECC->new(\\$pem_key_string));\n\n         #perl HASH ref with JWK structure (key type 'EC')\n         my $ecc_priv = {\n           kty => \"EC\",\n           crv => \"P-256\",\n           x   => \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4\",\n           y   => \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n           d   => \"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\",\n         };\n         my $data = decode_jwt(token=>$t, key=>$ecc_priv});\n\n    keypass\n        When 'key' parameter is an encrypted private RSA or ECC key this\n        optional parameter may contain a password for private key\n        decryption.\n\n    kid_keys\n        This parametes can be either a JWK Set JSON string (see RFC7517) or\n        a perl HASH ref with JWK Set structure like this:\n\n          my $keylist = {\n            keys => [\n              { kid=>\"key1\", kty=>\"oct\", k=>\"GawgguFyGrWKav7AX4VKUg\" },\n              { kid=>\"key2\", kty=>\"oct\", k=>\"ulxLGy4XqhbpkR5ObGh1gX\" },\n            ]\n          };\n          my $payload = decode_jwt(token=>$t, kid_keys=>$keylist);\n\n        Since 0.19 we also support:\n\n          use LWP::Simple;\n          my $google_certs = get('https://www.googleapis.com/oauth2/v1/certs');\n          my $payload = decode_jwt(token => $t, kid_keys => $google_certs);\n\n        When the token header contains 'kid' item the corresponding key is\n        looked up in \"kid_keys\" list and used for token decoding (you do not\n        need to pass the explicit key via \"key\" parameter).\n\n    allow_none\n        1 - accept JWS tokens with \"none\" 'alg' header value (which means\n        that token has no signature), BEWARE: DANGEROUS, UNSECURE!!!\n\n        0 (default) - do not allow JWS with \"none\" 'alg' header value\n\n    ignore_signature\n        1 - do not check signature on JWS tokens, BEWARE: DANGEROUS,\n        UNSECURE!!!\n\n        0 (default) - check signature on JWS tokens\n\n    accepted_alg\n        \"undef\" (default) means accept all 'alg' algorithms except 'none'\n        (for accepting 'none' use \"allow_none\")\n\n        \"string\" name of accepted 'alg' algorithm (only one)\n\n        \"ARRAY ref\" a list of accepted 'alg' algorithms\n\n        \"Regexp\" that has to match 'alg' algorithm name\n\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>'HS256');\n         #or\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>['HS256','HS384']);\n         #or\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>qr/^HS(256|384|512)$/);\n\n    accepted_enc\n        \"undef\" (default) means accept all 'enc' algorithms\n\n        \"string\" name of accepted 'enc' algorithm (only one)\n\n        \"ARRAY ref\" a list of accepted 'enc' algorithms\n\n        \"Regexp\" that has to match 'enc' algorithm name\n\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>'A192GCM');\n         #or\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>['A192GCM','A256GCM']);\n         #or\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>qr/^A(128|192|256)GCM$/);\n\n    decode_payload\n        0 - do not decode payload, return it as a raw string (octects).\n\n        1 - decode payload from JSON string, return it as perl hash ref (or\n        array ref) - decode_json failure means fatal error (croak).\n\n        \"undef\" (default) - if possible decode payload from JSON string, if\n        decode_json fails return payload as a raw string (octets).\n\n    decode_header\n        0 (default) - do not return decoded header as a return value of\n        decode_jwt()\n\n        1 - return decoded header as a return value of decode_jwt()\n\n         my $payload = decode_jwt(token=>$t, key=>$k);\n         #or\n         my ($header, $payload) = decode_jwt(token=>$t, key=>$k, decode_header=>1);\n\n    verify_iss\n        \"CODE ref\" - subroutine (with 'iss' claim value passed as argument)\n        should return \"true\" otherwise verification fails\n\n        \"Regexp ref\" - 'iss' claim value has to match given regexp otherwise\n        verification fails\n\n        \"undef\" (default) - do not verify 'iss' claim\n\n    verify_aud\n        \"CODE ref\" - subroutine (with 'aud' claim value passed as argument)\n        should return \"true\" otherwise verification fails\n\n        \"Regexp ref\" - 'aud' claim value has to match given regexp otherwise\n        verification fails\n\n        \"undef\" (default) - do not verify 'aud' claim\n\n    verify_sub\n        \"CODE ref\" - subroutine (with 'sub' claim value passed as argument)\n        should return \"true\" otherwise verification fails\n\n        \"Regexp ref\" - 'sub' claim value has to match given regexp otherwise\n        verification fails\n\n        \"undef\" (default) - do not verify 'sub' claim\n\n    verify_jti\n        \"CODE ref\" - subroutine (with 'jti' claim value passed as argument)\n        should return \"true\" otherwise verification fails\n\n        \"Regexp ref\" - 'jti' claim value has to match given regexp otherwise\n        verification fails\n\n        \"undef\" (default) - do not verify 'jti' claim\n\n    verify_iat\n        \"undef\" - Issued At 'iat' claim must be valid (not in the future) if\n        present\n\n        0 (default) - ignore 'iat' claim\n\n        1 - require valid 'iat' claim\n\n    verify_nbf\n        \"undef\" (default) - Not Before 'nbf' claim must be valid if present\n\n        0 - ignore 'nbf' claim\n\n        1 - require valid 'nbf' claim\n\n    verify_exp\n        \"undef\" (default) - Expiration Time 'exp' claim must be valid if\n        present\n\n        0 - ignore 'exp' claim\n\n        1 - require valid 'exp' claim\n\n    leeway\n        Tolerance in seconds related to \"verify_exp\", \"verify_nbf\" and\n        \"verify_iat\". Default is 0.\n\n    ignore_claims\n        1 - do not check claims (iat, exp, nbf, iss, aud, sub, jti), BEWARE:\n        DANGEROUS, UNSECURE!!!\n\n        0 (default) - check claims\n\n  encode_jwt\n     my $token = encode_jwt(%named_args);\n\n    Named arguments:\n\n    payload\n        Value of this mandatory parameter can be a string/buffer or HASH ref\n        or ARRAY ref\n\n         my $token = encode_jwt(payload=>\"any raw data\", key=>$k, alg=>'HS256');\n         #or\n         my $token = encode_jwt(payload=>{a=>1,b=>2}, key=>$k, alg=>'HS256');\n         #or\n         my $token = encode_jwt(payload=>[11,22,33,44], key=>$k, alg=>'HS256');\n\n        HASH refs and ARRAY refs payloads are serialized as JSON strings\n\n    alg The 'alg' header value is mandatory for both JWE and JWS tokens.\n\n        Supported JWE 'alg' algorithms:\n\n         dir\n         A128KW\n         A192KW\n         A256KW\n         A128GCMKW\n         A192GCMKW\n         A256GCMKW\n         PBES2-HS256+A128KW\n         PBES2-HS384+A192KW\n         PBES2-HS512+A256KW\n         RSA-OAEP\n         RSA-OAEP-256\n         RSA1_5\n         ECDH-ES+A128KW\n         ECDH-ES+A192KW\n         ECDH-ES+A256KW\n         ECDH-ES\n\n        Supported JWS algorithms:\n\n         none   ...  no integrity (NOTE: disabled by default)\n         HS256  ...  HMAC+SHA256 integrity\n         HS384  ...  HMAC+SHA384 integrity\n         HS512  ...  HMAC+SHA512 integrity\n         RS256  ...  RSA+PKCS1-V1_5 + SHA256 signature\n         RS384  ...  RSA+PKCS1-V1_5 + SHA384 signature\n         RS512  ...  RSA+PKCS1-V1_5 + SHA512 signature\n         PS256  ...  RSA+PSS + SHA256 signature\n         PS384  ...  RSA+PSS + SHA384 signature\n         PS512  ...  RSA+PSS + SHA512 signature\n         ES256  ...  ECDSA + SHA256 signature\n         ES384  ...  ECDSA + SHA384 signature\n         ES512  ...  ECDSA + SHA512 signature\n\n    enc The 'enc' header is mandatory for JWE tokens.\n\n        Supported 'enc' algorithms:\n\n         A128GCM\n         A192GCM\n         A256GCM\n         A128CBC-HS256\n         A192CBC-HS384\n         A256CBC-HS512\n\n    key A key used for token encryption (JWE) or token signing (JWS). The\n        value depends on \"alg\" token header value.\n\n         JWS alg header      key value\n         ------------------  ----------------------------------\n         none                no key required\n         HS256               string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         HS384               dtto\n         HS512               dtto\n         RS256               private RSA key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             object: Crypt::PK::RSA, Crypt::OpenSSL::RSA, Crypt::X509 or Crypt::OpenSSL::X509\n         RS384               private RSA key, see RS256\n         RS512               private RSA key, see RS256\n         PS256               private RSA key, see RS256\n         PS384               private RSA key, see RS256\n         PS512               private RSA key, see RS256\n         ES256               private ECC key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::ECC\n         ES384               private ECC key, see ES256\n         ES512               private ECC key, see ES256\n\n         JWE alg header      key value\n         ------------------  ----------------------------------\n         dir                 string (raw octects) or perl HASH ref with JWK, kty=>'oct', length depends on 'enc' algorithm\n         A128KW              string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A192KW              string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A256KW              string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A128GCMKW           string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A192GCMKW           string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A256GCMKW           string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS256+A128KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS384+A192KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS512+A256KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         RSA-OAEP            public RSA key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::RSA or Crypt::OpenSSL::RSA\n         RSA-OAEP-256        public RSA key, see RSA-OAEP\n         RSA1_5              public RSA key, see RSA-OAEP\n         ECDH-ES             public ECC key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::ECC\n         ECDH-ES+A128KW      public ECC key, see ECDH-ES\n         ECDH-ES+A192KW      public ECC key, see ECDH-ES\n         ECDH-ES+A256KW      public ECC key, see ECDH-ES\n\n    keypass\n        When 'key' parameter is an encrypted private RSA or ECC key this\n        optional parameter may contain a password for private key\n        decryption.\n\n    allow_none\n        1 - allow JWS with \"none\" 'alg' header value (which means that token\n        has no signature), BEWARE: DANGEROUS, UNSECURE!!!\n\n        0 (default) - do not allow JWS with \"none\" 'alg' header value\n\n    extra_headers\n        This optional parameter may contain a HASH ref with items that will\n        be added to JWT header.\n\n        If you want to use PBES2-based 'alg' like \"PBES2-HS512+A256KW\" you\n        can set PBES2 salt len (p2s) in bytes and iteration count (p2c) via\n        \"extra_headers\" like this:\n\n         my $token = encode_jwt(payload=>$p, key=>$k, alg=>'PBES2-HS512+A256KW', extra_headers=>{p2c=8000, p2s=>32});\n         #NOTE: handling of p2s header is a special case, in the end it is replaced with the generated salt\n\n    unprotected_headers\n        A hash with additional integrity unprotected headers - JWS and JWE\n        (not available for \"compact\" serialization);\n\n    shared_unprotected_headers\n        A hash with additional integrity unprotected headers - JWE only (not\n        available for \"compact\" serialization);\n\n    aad Additional Authenticated Data - scalar value with any (even raw\n        octects) data - JWE only (not available for \"compact\"\n        serialization);\n\n    serialization\n        Specify serialization method: \"compat\" (= default) for Compact\n        JWS/JWE serialization or \"flattened\" for Flattened JWS/JWE JSON\n        serialization.\n\n        General JSON serialization is not supported yet.\n\n    zip Compression method, currently 'deflate' is the only one supported.\n        \"undef\" (default) means no compression.\n\n         my $token = encode_jwt(payload=>$p, key=>$k, alg=>'HS256', zip=>'deflate');\n         #or define compression level\n         my $token = encode_jwt(payload=>$p, key=>$k, alg=>'HS256', zip=>['deflate', 9]);\n\n    auto_iat\n        1 - set 'iat' (Issued At) claim to current time (epoch seconds since\n        1970) at the moment of token encoding\n\n        0 (default) - do not set 'iat' claim\n\n        NOTE: claims are part of the payload and can be used only if the\n        payload is a HASH ref!\n\n    relative_exp\n        Set 'exp' claim (Expiration Time) to current time + \"relative_exp\"\n        value (in seconds).\n\n        NOTE: claims are part of the payload and can be used only if the\n        payload is a HASH ref!\n\n    relative_nbf\n        Set 'nbf' claim (Not Before) to current time + \"relative_nbf\" value\n        (in seconds).\n\n        NOTE: claims are part of the payload and can be used only if the\n        payload is a HASH ref!\n\nSEE ALSO\n    Crypt::Cipher::AES, Crypt::AuthEnc::GCM, Crypt::PK::RSA, Crypt::PK::ECC,\n    Crypt::KeyDerivation, Crypt::KeyWrap\n\nLICENSE\n    This program is free software; you can redistribute it and/or modify it\n    under the same terms as Perl itself.\n\nCOPYRIGHT\n    Copyright (c) 2015 DCIT, a.s. <http://www.dcit.cz> / Karel Miko\n\n", "package Crypt::JWT;\n\nuse strict;\nuse warnings;\n\nour $VERSION = '0.023';\n\nuse Exporter 'import';\nour %EXPORT_TAGS = ( all => [qw(decode_jwt encode_jwt)] );\nour @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );\nour @EXPORT = qw();\n\nuse Carp;\nuse Crypt::Misc qw(decode_b64u encode_b64u);\nuse JSON::MaybeXS qw(decode_json encode_json);\nuse Crypt::PK::RSA;\nuse Crypt::PK::ECC;\nuse Crypt::PRNG qw(random_bytes);\nuse Crypt::KeyWrap ':all';\nuse Crypt::AuthEnc::GCM qw(gcm_encrypt_authenticate gcm_decrypt_verify);\nuse Crypt::Mac::HMAC qw(hmac);\nuse Compress::Raw::Zlib;\nuse Scalar::Util qw(looks_like_number);\n\n# JWS: https://tools.ietf.org/html/rfc7515\n# JWE: https://tools.ietf.org/html/rfc7516\n# JWK: https://tools.ietf.org/html/rfc7517\n# JWA: https://tools.ietf.org/html/rfc7518\n# JWT: https://tools.ietf.org/html/rfc7519\n\nsub _prepare_rsa_key {\n  my ($key) = @_;\n  croak \"JWT: undefined RSA key\" unless defined $key;\n  croak \"JWT: invalid RSA key (cannot be scalar)\" unless ref $key;\n  # we need Crypt::PK::RSA object\n  return $key                       if ref($key) eq 'Crypt::PK::RSA';\n  return Crypt::PK::RSA->new($key)  if ref($key) eq 'HASH' || ref($key) eq 'SCALAR';\n  return Crypt::PK::RSA->new(@$key) if ref($key) eq 'ARRAY';\n  # handle also: Crypt::OpenSSL::RSA, Crypt::X509, Crypt::OpenSSL::X509\n  my $str;\n  if (ref($key) eq 'Crypt::OpenSSL::RSA') {\n    # https://metacpan.org/pod/Crypt::OpenSSL::RSA\n    $str = $key->is_private ? $key->get_private_key_string : $key->get_public_key_string;\n  }\n  elsif (ref($key) =~ /^Crypt::(X509|OpenSSL::X509)$/) {\n    # https://metacpan.org/pod/Crypt::X509\n    # https://metacpan.org/pod/Crypt::OpenSSL::X509\n    $str = $key->pubkey;\n  }\n  return Crypt::PK::RSA->new(\\$str) if defined $str && !ref($str);\n  croak \"JWT: invalid RSA key\";\n}\n\nsub _prepare_ecc_key {\n  my ($key) = @_;\n  croak \"JWT: undefined ECC key\" unless defined $key;\n  croak \"JWT: invalid ECC key (cannot be scalar)\" unless ref $key;\n  # we need Crypt::PK::ECC object\n  return $key                       if ref($key) eq 'Crypt::PK::ECC';\n  return Crypt::PK::ECC->new($key)  if ref($key) eq 'HASH' || ref($key) eq 'SCALAR';\n  return Crypt::PK::ECC->new(@$key) if ref($key) eq 'ARRAY';\n  croak \"JWT: invalid ECC key\";\n}\n\nsub _prepare_oct_key {\n  my ($key) = @_;\n  croak \"JWT: undefined oct key\" unless defined $key;\n  if (ref $key eq 'HASH' && $key->{k} && $key->{kty} && $key->{kty} eq 'oct') {\n    return decode_b64u($key->{k});\n  }\n  elsif (!ref $key) {\n    return $key;\n  }\n  croak \"JWT: invalid oct key\";\n}\n\nsub _kid_lookup {\n  my ($kid, $kid_keys, $alg) = @_;\n  $kid_keys = eval { decode_json($kid_keys) } unless ref $kid_keys;\n  return undef unless ref $kid_keys eq 'HASH';\n  my $found;\n  if (exists $kid_keys->{keys} && ref $kid_keys->{keys} eq 'ARRAY') {\n    #FORMAT: { keys => [ {kid=>'A', kty=>?, ...}, {kid=>'B', kty=>?, ...} ] }\n    for (@{$kid_keys->{keys}}) {\n      if ($_->{kid} && $_->{kty} && $_->{kid} eq $kid) {\n        $found = $_;\n        last;\n      }\n    }\n  }\n  else {\n    #FORMAT: { hexadec1 => \"----BEGIN CERTIFICATE-----...\", hexadec2 => \"----BEGIN CERTIFICATE-----...\" }\n    #e.g. https://www.googleapis.com/oauth2/v1/certs\n    return \\$kid_keys->{$kid} if $kid_keys->{$kid} && !ref $kid_keys->{$kid};\n  }\n  return undef if !$found;\n  return $found if $found->{kty} eq 'oct' && $alg =~ /^(HS|dir|PBES2-HS|A)/;\n  return $found if $found->{kty} eq 'EC'  && $alg =~ /^(ES|EC)/;\n  return $found if $found->{kty} eq 'RSA' && $alg =~ /^RS/;\n  croak \"JWT: key type '$found->{kty}' cannot be used with alg '$alg'\";\n}\n\nsub _b64u_to_hash {\n  my $b64url = shift;\n  return undef unless $b64url;\n  my $json = decode_b64u($b64url);\n  return undef unless $json;\n  my $hash = eval { decode_json($json) };\n  return undef unless ref $hash eq 'HASH';\n  return $hash;\n}\n\nsub _add_claims {\n  my ($payload, %args) = @_;\n  #### claims (defined for JWS only)\n  # \"exp\"   Expiration Time\n  # \"nbf\"   Not Before\n  # \"iat\"   Issued At\n  # \"iss\"   Issuer\n  # \"sub\"   Subject\n  # \"aud\"   Audience\n  # \"jti\"   JWT ID\n  my $now = time;\n  $payload->{iat} = $now                       if $args{auto_iat};\n  $payload->{exp} = $now + $args{relative_exp} if defined $args{relative_exp};\n  $payload->{nbf} = $now + $args{relative_nbf} if defined $args{relative_nbf};\n}\n\nsub _verify_claims {\n  my ($payload, %args) = @_;\n\n  return if $args{ignore_claims};\n\n  my $leeway = $args{leeway} || 0;\n  my $now = time;\n\n  ### exp\n  if(defined $payload->{exp}) {\n    if (!defined $args{verify_exp} || $args{verify_exp}==1) {\n      croak \"JWT: exp claim check failed ($payload->{exp}/$leeway vs. $now)\" if $payload->{exp} + $leeway <= $now;\n    }\n  }\n  elsif ($args{verify_exp} && $args{verify_exp}==1) {\n    croak \"JWT: exp claim required but missing\"\n  }\n\n  ### nbf\n  if(defined $payload->{nbf}) {\n    if (!defined $args{verify_nbf} || $args{verify_nbf}==1) {\n      croak \"JWT: nbf claim check failed ($payload->{nbf}/$leeway vs. $now)\" if $payload->{nbf} - $leeway > $now;\n    }\n  }\n  elsif ($args{verify_nbf} && $args{verify_nbf}==1) {\n    croak \"JWT: nbf claim required but missing\"\n  }\n\n  ### iat\n  if (exists $args{verify_iat}) { #default (non existing verify_iat) == no iat check\n    if(defined $payload->{iat}) {\n      if (!defined $args{verify_iat} || $args{verify_iat}==1) {\n        croak \"JWT: iat claim check failed ($payload->{iat}/$leeway vs. $now)\" if $payload->{iat} - $leeway > $now;\n      }\n    }\n    elsif ($args{verify_iat} && $args{verify_iat}==1) {\n      croak \"JWT: iat claim required but missing\"\n    }\n  }\n\n  ### iss\n  if(exists $payload->{iss}) {\n    if (ref $args{verify_iss} eq 'Regexp') {\n      croak \"JWT: iss claim re check failed\" unless $payload->{iss} =~ $args{verify_iss};\n    }\n    elsif (ref $args{verify_iss} eq 'CODE') {\n      croak \"JWT: iss claim check failed\" unless $args{verify_iss}->($payload->{iss});\n    }\n  }\n\n  ### sub\n  if(exists $payload->{sub}) {\n    if (ref $args{verify_sub} eq 'Regexp') {\n      croak \"JWT: sub claim re check failed\" unless $payload->{sub} =~ $args{verify_sub};\n    }\n    elsif (ref $args{verify_sub} eq 'CODE') {\n      croak \"JWT: sub claim check failed\" unless $args{verify_sub}->($payload->{sub});\n    }\n  }\n\n  ### aud\n  if(exists $payload->{aud}) {\n    if (ref $args{verify_aud} eq 'Regexp') {\n      croak \"JWT: aud claim re check failed\" unless $payload->{aud} =~ $args{verify_aud};\n    }\n    elsif (ref $args{verify_aud} eq 'CODE') {\n      croak \"JWT: aud claim check failed\" unless $args{verify_aud}->($payload->{aud});\n    }\n  }\n\n  ### jti\n  if(exists $payload->{jti}) {\n    if (ref $args{verify_jti} eq 'Regexp') {\n      croak \"JWT: jti claim re check failed\" unless $payload->{jti} =~ $args{verify_jti};\n    }\n    elsif (ref $args{verify_jti} eq 'CODE') {\n      croak \"JWT: jti claim check failed\" unless $args{verify_jti}->($payload->{jti});\n    }\n  }\n}\n\nsub _payload_zip {\n  my ($payload, $header, $z) = @_;\n  my @zip = ref $z eq 'ARRAY' ? @$z : ($z);\n  if ($zip[0] eq 'deflate') {\n    my $level = defined $zip[1] ? $zip[1] : 6;\n    $header->{zip} = \"DEF\";\n    my $d = Compress::Raw::Zlib::Deflate->new(-Bufsize => 1024, -WindowBits => -&MAX_WBITS(), -AppendOutput => 1, -Level => $level );\n    my $output = '';\n    $d->deflate($payload, $output) == Z_OK or croak \"JWT: deflate failed\";\n    $d->flush($output) == Z_OK             or croak \"JWT: deflate/flush failed\";\n    croak \"JWT: deflate/output failed\" unless $output;\n    $payload = $output;\n  }\n  else {\n    croak \"JWT: unknown zip method '$zip[0]'\";\n  }\n  return $payload;\n}\n\nsub _payload_unzip {\n  my ($payload, $z) = @_;\n  if ($z eq \"DEF\") {\n    my $d = Compress::Raw::Zlib::Inflate->new(-Bufsize => 1024, -WindowBits => -&MAX_WBITS());\n    my $output = '';\n    $d->inflate($payload, $output);\n    croak \"JWT: inflate failed\" unless $output;\n    $payload = $output;\n  }\n  else {\n    croak \"JWT: unknown zip method '$z'\";\n  }\n  return $payload;\n}\n\nsub _payload_enc {\n  my ($payload) = @_;\n  if (ref($payload) =~ /^(HASH|ARRAY)$/) {\n    $payload = encode_json($payload);\n  }\n  else {\n    utf8::downgrade($payload, 1) or croak \"JWT: payload cannot contain wide character\";\n  }\n  return $payload;\n}\n\nsub _payload_dec {\n  my ($payload, $decode_payload) = @_;\n  return $payload if defined $decode_payload && $decode_payload == 0;\n  my $de = $payload;\n  $de = eval { decode_json($de) };\n  if ($decode_payload) {\n    croak \"JWT: payload not a valid JSON\" unless $de;\n    return $de;\n  }\n  else {\n    return defined $de ? $de : $payload;\n  }\n}\n\nsub _encrypt_jwe_cek {\n  my ($key, $hdr) = @_;\n  my $alg = $hdr->{alg};\n  my $enc = $hdr->{enc};\n\n  if ($alg eq 'dir') {\n    return (_prepare_oct_key($key), '');\n  }\n\n  my $cek;\n  my $ecek;\n  if ($enc =~ /^A(128|192|256)GCM/) {\n    $cek = random_bytes($1/8);\n  }\n  elsif ($enc =~ /^A(128|192|256)CBC/) {\n    $cek = random_bytes(2*$1/8);\n  }\n\n  if ($alg =~ /^A(128|192|256)KW$/) {\n    $ecek = aes_key_wrap(_prepare_oct_key($key), $cek);\n    return ($cek, $ecek);\n  }\n  elsif ($alg =~ /^A(128|192|256)GCMKW$/) {\n    my ($t, $i);\n    ($ecek, $t, $i) = gcm_key_wrap(_prepare_oct_key($key), $cek);\n    $hdr->{tag} = encode_b64u($t);\n    $hdr->{iv}  = encode_b64u($i);\n    return ($cek, $ecek);\n  }\n  elsif ($alg =~ /^PBES2-HS(512|384|256)\\+A(128|192|256)KW$/) {\n    my $len = looks_like_number($hdr->{p2s}) && $hdr->{p2s} >= 8 && $hdr->{p2s} <= 9999 ? $hdr->{p2s} : 16;\n    my $salt = random_bytes($len);\n    my $iter = looks_like_number($hdr->{p2c}) ? $hdr->{p2c} : 5000;\n    $ecek = pbes2_key_wrap(_prepare_oct_key($key), $cek, $alg, $salt, $iter);\n    $hdr->{p2s} = encode_b64u($salt);\n    $hdr->{p2c} = $iter;\n    return ($cek, $ecek);\n  }\n  elsif ($alg =~ /^RSA(-OAEP|-OAEP-256|1_5)$/) {\n    $key = _prepare_rsa_key($key);\n    $ecek = rsa_key_wrap($key, $cek, $alg);\n    return ($cek, $ecek);\n  }\n  elsif ($alg =~ /^ECDH-ES\\+A(128|192|256)KW$/) {\n    $key = _prepare_ecc_key($key);\n    ($ecek, $hdr->{epk}) = ecdhaes_key_wrap($key, $cek, $alg, $hdr->{apu}, $hdr->{apv});\n    return ($cek, $ecek);\n  }\n  elsif ($alg eq 'ECDH-ES') {\n    $key = _prepare_ecc_key($key);\n    ($cek, $hdr->{epk}) = ecdh_key_wrap($key, $enc, $hdr->{apu}, $hdr->{apv});\n    return ($cek, '');\n  }\n  croak \"JWE: unknown alg '$alg'\";\n}\n\nsub _decrypt_jwe_cek {\n  my ($ecek, $key, $hdr) = @_;\n  my $alg = $hdr->{alg};\n  my $enc = $hdr->{enc};\n\n  if ($alg eq 'dir') {\n    return _prepare_oct_key($key);\n  }\n  elsif ($alg =~ /^A(128|192|256)KW$/) {\n    return aes_key_unwrap(_prepare_oct_key($key), $ecek);\n  }\n  elsif ($alg =~ /^A(128|192|256)GCMKW$/) {\n    return gcm_key_unwrap(_prepare_oct_key($key), $ecek, decode_b64u($hdr->{tag}), decode_b64u($hdr->{iv}));\n  }\n  elsif ($alg =~ /^PBES2-HS(512|384|256)\\+A(128|192|256)KW$/) {\n    return pbes2_key_unwrap(_prepare_oct_key($key), $ecek, $alg, decode_b64u($hdr->{p2s}), $hdr->{p2c});\n  }\n  elsif ($alg =~ /^RSA(-OAEP|-OAEP-256|1_5)$/) {\n    $key = _prepare_rsa_key($key);\n    return rsa_key_unwrap($key, $ecek, $alg);\n  }\n  elsif ($alg =~ /^ECDH-ES\\+A(128|192|256)KW$/) {\n    $key = _prepare_ecc_key($key);\n    return ecdhaes_key_unwrap($key, $ecek, $alg, $hdr->{epk}, $hdr->{apu}, $hdr->{apv});\n  }\n  elsif ($alg eq 'ECDH-ES') {\n    $key = _prepare_ecc_key($key);\n    return ecdh_key_unwrap($key, $enc, $hdr->{epk}, $hdr->{apu}, $hdr->{apv});\n  }\n  croak \"JWE: unknown alg '$alg'\";\n}\n\nsub _encrypt_jwe_payload {\n  my ($cek, $enc, $b64u_header, $b64u_aad, $payload) = @_;\n  my $aad = defined $b64u_aad ? \"$b64u_header.$b64u_aad\" : $b64u_header;\n  if ($enc =~ /^A(128|192|256)GCM$/) {\n    # https://tools.ietf.org/html/rfc7518#section-5.3\n    my $len1 = $1/8;\n    my $len2 = length($cek);\n    croak \"JWE: wrong AES key length ($len1 vs. $len2) for $enc\" unless $len1 == $len2;\n    my $iv = random_bytes(12); # for AESGCM always 12 (96 bits)\n    my ($ct, $tag) = gcm_encrypt_authenticate('AES', $cek, $iv, $aad, $payload);\n    return ($ct, $iv, $tag);\n  }\n  elsif ($enc =~ /^A(128|192|256)CBC-HS(256|384|512)$/) {\n    # https://tools.ietf.org/html/rfc7518#section-5.2\n    my ($size, $hash) = ($1/8, \"SHA$2\");\n    my $key_len = length($cek) / 2;\n    my $mac_key = substr($cek, 0, $key_len);\n    my $aes_key = substr($cek, $key_len, $key_len);\n    croak \"JWE: wrong AES key length ($key_len vs. $size)\" unless $key_len == $size;\n    my $iv = random_bytes(16); # for AES always 16\n    my $m = Crypt::Mode::CBC->new('AES');\n    my $ct = $m->encrypt($payload, $aes_key, $iv);\n    my $aad_len = length($aad);\n    my $mac_input = $aad . $iv . $ct . pack('N2', ($aad_len / 2147483647)*8, ($aad_len % 2147483647)*8);\n    my $mac = hmac($hash, $mac_key, $mac_input);\n    my $sig_len = length($mac) / 2;\n    my $sig = substr($mac, 0, $sig_len);\n    return ($ct, $iv, $sig);\n  }\n  croak \"JWE: unsupported enc '$enc'\";\n}\n\nsub _decrypt_jwe_payload {\n  my ($cek, $enc, $aad, $ct, $iv, $tag) = @_;\n  if ($enc =~ /^A(128|192|256)GCM$/) {\n    # https://tools.ietf.org/html/rfc7518#section-5.3\n    my $len1 = $1/8;\n    my $len2 = length($cek);\n    croak \"JWE: wrong AES key length ($len1 vs. $len2) for $enc\" unless $len1 == $len2;\n    return gcm_decrypt_verify('AES', $cek, $iv, $aad, $ct, $tag);\n  }\n  elsif ($enc =~ /^A(128|192|256)CBC-HS(256|384|512)$/) {\n    # https://tools.ietf.org/html/rfc7518#section-5.2\n    my ($size, $hash) = ($1/8, \"SHA$2\");\n    my $key_len = length($cek) / 2;\n    my $mac_key = substr($cek, 0, $key_len);\n    my $aes_key = substr($cek, $key_len, $key_len);\n    croak \"JWE: wrong AES key length ($key_len vs. $size)\" unless $key_len == $size;\n    my $aad_len = length($aad); # AAD == original encoded header\n    my $mac_input = $aad . $iv . $ct . pack('N2', ($aad_len / 2147483647)*8, ($aad_len % 2147483647)*8);\n    my $mac = hmac($hash, $mac_key, $mac_input);\n    my $sig_len = length($mac) / 2;\n    my $sig = substr($mac, 0, $sig_len);\n    croak \"JWE: tag mismatch\" unless $sig eq $tag;\n    my $m = Crypt::Mode::CBC->new('AES');\n    my $pt = $m->decrypt($ct, $aes_key, $iv);\n    return $pt;\n  }\n  croak \"JWE: unsupported enc '$enc'\";\n}\n\nsub _encode_jwe {\n  my %args = @_;\n  my $payload = $args{payload};\n  my $alg     = $args{alg};\n  my $enc     = $args{enc};\n  my $header  = $args{extra_headers} ? \\%{$args{extra_headers}} : {};\n  # add claims to payload\n  _add_claims($payload, %args) if ref $payload eq 'HASH';\n  # serialize payload\n  $payload = _payload_enc($payload);\n  # compress payload\n  $payload = _payload_zip($payload, $header, $args{zip}) if $args{zip}; # may set some header items\n  # prepare header\n  $header->{alg} = $alg;\n  $header->{enc} = $enc;\n  #REMOVED: $header->{typ} = 'JWT' if !exists $header->{typ} && $args{auto_typ};\n  # key\n  croak \"JWE: missing 'key'\" if !$args{key};\n  my $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};\n  # prepare cek\n  my ($cek, $ecek) = _encrypt_jwe_cek($key, $header); # adds some header items\n  # encode header\n  my $json_header = encode_json($header);\n  my $b64u_header = encode_b64u($json_header);\n  my $b64u_aad    = defined $args{aad} ? encode_b64u($args{aad}) : undef;\n  # encrypt payload\n  my ($ct, $iv, $tag) = _encrypt_jwe_payload($cek, $enc, $b64u_header, $b64u_aad, $payload);\n  # return token parts\n  return ( $b64u_header,\n           encode_b64u($ecek),\n           encode_b64u($iv),\n           encode_b64u($ct),\n           encode_b64u($tag),\n           $b64u_aad);\n}\n\nsub _decode_jwe {\n  my ($b64u_header, $b64u_ecek, $b64u_iv, $b64u_ct, $b64u_tag, $b64u_aad, $unprotected, $shared_unprotected, %args) = @_;\n  my $header = _b64u_to_hash($b64u_header);\n  my $ecek   = decode_b64u($b64u_ecek);\n  my $ct     = decode_b64u($b64u_ct);\n  my $iv     = decode_b64u($b64u_iv);\n  my $tag    = decode_b64u($b64u_tag);\n  croak \"JWE: invalid header part\" if $b64u_header && !$header;\n  croak \"JWE: invalid ecek part\"   if $b64u_ecek   && !$ecek;\n  croak \"JWE: invalid ct part\"     if $b64u_ct     && !$ct;\n  croak \"JWE: invalid iv part\"     if $b64u_iv     && !$iv;\n  croak \"JWE: invalid tag part\"    if $b64u_tag    && !$tag;\n\n  my $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};\n  if ($header->{kid} && $args{kid_keys}) {\n    my $k = _kid_lookup($header->{kid}, $args{kid_keys}, $header->{alg});\n    $key = $k if defined $k;\n  }\n\n  my $aa = $args{accepted_alg};\n  if (ref($aa) eq 'Regexp') {\n    croak \"JWE: alg '$header->{alg}' does not match accepted_alg\" if $header->{alg} !~ $aa;\n  }\n  elsif ($aa && (ref($aa) eq 'ARRAY' || !ref($aa))) {\n    my %acca = ref $aa ? map { $_ => 1 } @$aa : ( $aa => 1 );\n    croak \"JWE: alg '$header->{alg}' not in accepted_alg\" if !$acca{$header->{alg}};\n  }\n\n  my $ae = $args{accepted_enc};\n  if (ref($ae) eq 'Regexp') {\n    croak \"JWE: enc '$header->{enc}' does not match accepted_enc\" if $header->{enc} !~ $ae;\n  }\n  elsif ($ae && (ref($ae) eq 'ARRAY' || !ref($ae))) {\n    my %acce = ref $ae ? map { $_ => 1 } @$ae : ( $ae => 1 );\n    croak \"JWE: enc '$header->{enc}' not in accepted_enc\" if !$acce{$header->{enc}};\n  }\n\n  croak \"JWE: missing 'key'\" if !$key;\n  $header = { %$shared_unprotected, %$unprotected, %$header }; # merge headers\n  my $cek = _decrypt_jwe_cek($ecek, $key, $header);\n  my $aad = defined $b64u_aad ? \"$b64u_header.$b64u_aad\" : $b64u_header;\n  my $payload = _decrypt_jwe_payload($cek, $header->{enc}, $aad, $ct, $iv, $tag);\n  $payload = _payload_unzip($payload, $header->{zip}) if $header->{zip};\n  $payload = _payload_dec($payload, $args{decode_payload});\n  _verify_claims($payload, %args) if ref $payload eq 'HASH'; # croaks on error\n  return ($header, $payload);\n}\n\nsub _sign_jws {\n  my ($b64u_header, $b64u_payload, $alg, $key) = @_;\n  return '' if $alg eq 'none'; # no integrity\n  my $sig;\n  my $data = \"$b64u_header.$b64u_payload\";\n  if ($alg =~ /^HS(256|384|512)$/) { # HMAC integrity\n    $key = _prepare_oct_key($key);\n    $sig = hmac(\"SHA$1\", $key, $data);\n  }\n  elsif ($alg =~ /^RS(256|384|512)/) { # RSA+PKCS1-V1_5 signatures\n    my $pk = _prepare_rsa_key($key);\n    $sig  = $pk->sign_message($data, \"SHA$1\", 'v1.5');\n  }\n  elsif ($alg =~ /^PS(256|384|512)/) { # RSA+PSS signatures\n    my $hash = \"SHA$1\";\n    my $hashlen = $1/8;\n    my $pk = _prepare_rsa_key($key);\n    $sig  = $pk->sign_message($data, $hash, 'pss', $hashlen);\n  }\n  elsif ($alg =~ /^ES(256|384|512)/) { # ECDSA signatures\n    my $pk = _prepare_ecc_key($key);\n    $sig  = $pk->sign_message_rfc7518($data, \"SHA$1\");\n  }\n  return encode_b64u($sig);\n}\n\nsub _verify_jws {\n  my ($b64u_header, $b64u_payload, $b64u_sig, $alg, $key) = @_;\n  my $sig = decode_b64u($b64u_sig);\n  croak \"JWS: invalid sig part\" if $b64u_sig && !$sig;\n  my $data = \"$b64u_header.$b64u_payload\";\n\n  if ($alg eq 'none' ) { # no integrity\n    return 1;\n  }\n  elsif ($alg =~ /^HS(256|384|512)$/) { # HMAC integrity\n    $key = _prepare_oct_key($key);\n    return 1 if $sig eq hmac(\"SHA$1\", $key, $data);\n  }\n  elsif ($alg =~ /^RS(256|384|512)/) { # RSA+PKCS1-V1_5 signatures\n    my $hash = \"SHA$1\";\n    my $pk = _prepare_rsa_key($key);\n    return 1 if $pk->verify_message($sig, $data, $hash, 'v1.5');\n  }\n  elsif ($alg =~ /^PS(256|384|512)/) { # RSA+PSS signatures\n    my $hash = \"SHA$1\";\n    my $hashlen = $1/8;\n    my $pk = _prepare_rsa_key($key);\n    return 1 if  $pk->verify_message($sig, $data, $hash, 'pss', $hashlen);\n  }\n  elsif ($alg =~ /^ES(256|384|512)/) { # ECDSA signatures\n    my $hash = \"SHA$1\";\n    my $pk = _prepare_ecc_key($key);\n    return 1 if $pk->verify_message_rfc7518($sig, $data, $hash);\n  }\n  return 0;\n}\n\nsub _encode_jws {\n  my %args = @_;\n  my $payload = $args{payload};\n  my $alg     = $args{alg};\n  my $header  = $args{extra_headers} ? \\%{$args{extra_headers}} : {};\n  croak \"JWS: alg 'none' not allowed\" if $alg eq 'none' && !$args{allow_none};\n  # add claims to payload\n  _add_claims($payload, %args) if ref $payload eq 'HASH';\n  # serialize payload\n  $payload = _payload_enc($payload);\n  # compress payload\n  $payload = _payload_zip($payload, $header, $args{zip}) if $args{zip}; # may set some header items\n  # encode payload\n  my $b64u_payload = encode_b64u($payload);\n  # prepare header\n  $header->{alg} = $alg;\n  #REMOVED: $header->{typ} = 'JWT' if !exists $header->{typ} && $args{auto_typ};\n  # encode header\n  my $json_header = encode_json($header);\n  my $b64u_header = encode_b64u($json_header);\n  # key\n  croak \"JWS: missing 'key'\" if !$args{key} && $alg ne 'none';\n  my $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};\n  # sign header\n  my $b64u_signature = _sign_jws($b64u_header, $b64u_payload, $alg, $key);\n  return ($b64u_header, $b64u_payload, $b64u_signature);\n}\n\nsub _decode_jws {\n  my ($b64u_header, $b64u_payload, $b64u_sig, $unprotected_header, %args) = @_;\n  my $header = _b64u_to_hash($b64u_header);\n  croak \"JWS: invalid header part\" if $b64u_header && !$header;\n  $unprotected_header = {} if ref $unprotected_header ne 'HASH';\n\n  if (!$args{ignore_signature}) {\n    my $aa = $args{accepted_alg};\n    if (ref($aa) eq 'Regexp') {\n      croak \"JWS: alg '$header->{alg}' does not match accepted_alg\" if $header->{alg} !~ $aa;\n    }\n    elsif ($aa && (ref($aa) eq 'ARRAY' || !ref($aa))) {\n      my %acca = ref $aa ? map { $_ => 1 } @$aa : ( $aa => 1 );\n      croak \"JWS: alg '$header->{alg}' not in accepted_alg\" if !$acca{$header->{alg}};\n    }\n    my $alg = $header->{alg};\n    croak \"JWS: missing header 'alg'\" unless $alg;\n    croak \"JWS: alg 'none' not allowed\" if $alg eq 'none' && !$args{allow_none};\n    # key\n    my $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};\n    my $kid = exists $header->{kid} ? $header->{kid} : $unprotected_header->{kid};\n    if (!defined $key && defined $kid && $args{kid_keys}) {\n      my $k = _kid_lookup($kid, $args{kid_keys}, $alg);\n      $key = $k if defined $k;\n    }\n    # if no key given, try to use 'jwk' value from header\n    $key = $header->{jwk} if !$key && $header->{jwk};\n    croak \"JWS: missing 'key'\" if !$key && $alg ne 'none';\n    my $valid = _verify_jws($b64u_header, $b64u_payload, $b64u_sig, $alg, $key);\n    croak \"JWS: decode failed\" if !$valid;\n  }\n  my $payload = decode_b64u($b64u_payload);\n  croak \"JWS: invalid payload part\" if $b64u_payload && !$payload;\n  $payload = _payload_unzip($payload, $header->{zip}) if $header->{zip};\n  $payload = _payload_dec($payload, $args{decode_payload});\n  _verify_claims($payload, %args) if ref $payload eq 'HASH'; # croaks on error\n  $header = { %$unprotected_header, %$header }; # merge headers\n  return ($header, $payload);\n}\n\nsub encode_jwt {\n  my %args = @_;\n\n  my $ser = $args{serialization} || 'compact';\n  if ($args{alg} =~ /^(none|((HS|RS|PS|ES)(512|384|256)))$/) {\n    ###JWS\n    my ($b64u_header, $b64u_payload, $b64u_signature) = _encode_jws(%args);\n    if ($ser eq 'compact') { # https://tools.ietf.org/html/rfc7515#section-7.1\n      croak \"JWT: cannot use 'unprotected_headers' with compact serialization\" if defined $args{unprotected_headers};\n      return \"$b64u_header.$b64u_payload.$b64u_signature\";\n    }\n    elsif ($ser eq 'flattened') { # https://tools.ietf.org/html/rfc7515#section-7.2.2\n      my $token = { protected => $b64u_header, payload => $b64u_payload, signature => $b64u_signature };\n      $token->{header} = \\%{$args{unprotected_headers}} if ref $args{unprotected_headers} eq 'HASH';\n      return encode_json($token);\n    }\n    else {\n      croak \"JWT: unsupported JWS serialization '$ser'\";\n    }\n  }\n  else {\n    ### JWE\n    my ($b64u_header, $b64u_ecek, $b64u_iv, $b64u_ct, $b64u_tag, $b64u_aad) = _encode_jwe(%args);\n    if ($ser eq 'compact') { # https://tools.ietf.org/html/rfc7516#section-7.1\n      croak \"JWT: cannot use 'aad' with compact serialization\" if defined $args{aad};\n      croak \"JWT: cannot use 'unprotected_headers' with compact serialization\" if defined $args{unprotected_headers};\n      croak \"JWT: cannot use 'shared_unprotected_headers' with compact serialization\" if defined $args{shared_unprotected_headers};\n      return \"$b64u_header.$b64u_ecek.$b64u_iv.$b64u_ct.$b64u_tag\";\n    }\n    elsif ($ser eq 'flattened') { # https://tools.ietf.org/html/rfc7516#section-7.2.2\n      my $token = {\n        protected     => $b64u_header,\n        encrypted_key => $b64u_ecek,\n        iv            => $b64u_iv,\n        ciphertext    => $b64u_ct,\n        tag           => $b64u_tag,\n      };\n      # header: JWE Per-Recipient Unprotected Header when the JWE Per-Recipient Unprotected Header\n      $token->{header} = \\%{$args{unprotected_headers}} if ref $args{unprotected_headers} eq 'HASH';\n      # unprotected: JWE Shared Unprotected Header\n      $token->{unprotected} = \\%{$args{shared_unprotected_headers}} if ref $args{shared_unprotected_headers} eq 'HASH';\n      # aad: Additional Authenticated Data (AAD)\n      $token->{aad} = $b64u_aad if defined $b64u_aad;\n      return encode_json($token);\n    }\n    else {\n      croak \"JWT: unsupported JWE serialization '$ser'\";\n    }\n  }\n}\n\nsub decode_jwt {\n  my %args = @_;\n  my ($header, $payload);\n\n  if (!$args{token}) {\n    croak \"JWT: missing token\";\n  }\n  elsif ($args{token} =~ /^([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]*)=*\\.([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]+)=*$/) {\n    # JWE token (5 segments)\n    ($header, $payload) = _decode_jwe($1, $2, $3, $4, $5, undef, {}, {}, %args);\n  }\n  elsif ($args{token} =~ /^([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]*)=*$/) {\n    # JWS token (3 segments)\n    ($header, $payload) = _decode_jws($1, $2, $3, {}, %args);\n  }\n  elsif ($args{token} =~ /^\\s*\\{.*?\\}\\s*$/s) {\n    my $hash = decode_json($args{token});\n    if ($hash->{payload} && $hash->{protected}) {\n      # Flattened JWS JSON Serialization\n      ($header, $payload) = _decode_jws($hash->{protected}, $hash->{payload}, $hash->{signature}, $hash->{header}, %args);\n    }\n    elsif ($hash->{ciphertext} && $hash->{protected}) {\n      # Flattened JWE JSON Serialization\n      ($header, $payload) = _decode_jwe($hash->{protected}, $hash->{encrypted_key}, $hash->{iv}, $hash->{ciphertext}, $hash->{tag}, $hash->{aad}, $hash->{header}, $hash->{unprotected}, %args);\n    }\n    else {\n      croak \"JWT: unsupported JWS/JWT JSON Serialization\";\n    }\n  }\n  else {\n    croak \"JWT: invalid token format\";\n  }\n  return ($header, $payload) if $args{decode_header};\n  return $payload;\n}\n\n1;\n\n#### URLs\n# https://metacpan.org/pod/JSON::WebToken\n# https://metacpan.org/pod/Mojo::JWT\n# https://bitbucket.org/b_c/jose4j/wiki/JWE%20Examples\n# https://bitbucket.org/b_c/jose4j/wiki/JWS%20Examples\n# https://github.com/dvsekhvalnov/jose-jwt/tree/master/JWT/jwe\n# https://github.com/progrium/ruby-jwt\n# https://github.com/jpadilla/pyjwt/\n\n=pod\n\n=head1 NAME\n\nCrypt::JWT - JSON Web Token (JWT, JWS, JWE) as defined by RFC7519, RFC7515, RFC7516\n\n=head1 SYNOPSIS\n\n   # encoding\n   use Crypt::JWT qw(encode_jwt);\n   my $jws_token = encode_jwt(payload=>$data, alg=>'HS256', key=>'secret');\n   my $jwe_token = encode_jwt(payload=>$data, alg=>'PBES2-HS256+A128KW', enc=>'A128GCM', key=>'secret');\n\n   # decoding\n   use Crypt::JWT qw(decode_jwt);\n   my $data1 = decode_jwt(token=>$jws_token, key=>'secret');\n   my $data2 = decode_jwt(token=>$jwe_token, key=>'secret');\n\n=head1 DESCRIPTION\n\nImplements B<JSON Web Token (JWT)> - L<https://tools.ietf.org/html/rfc7519>.\nThe implementation covers not only B<JSON Web Signature (JWS)> - L<https://tools.ietf.org/html/rfc7515>,\nbut also B<JSON Web Encryption (JWE)> - L<https://tools.ietf.org/html/rfc7516>.\n\nThe module implements B<all (100%) algorithms> defined in L<https://tools.ietf.org/html/rfc7518> - B<JSON Web Algorithms (JWA)>.\n\nThis module supports B<Compact JWS/JWE> and B<Flattened JWS/JWE JSON> serialization, general JSON serialization is not supported yet.\n\n=head1 EXPORT\n\nNothing is exported by default.\n\nYou can export selected functions:\n\n  use Crypt::JWT qw(decode_jwt encode_jwt);\n\nOr all of them at once:\n\n  use Crypt::JWT ':all';\n\n=head1 FUNCTIONS\n\n=head2 decode_jwt\n\n my $data = decode_jwt(%named_args);\n\nNamed arguments:\n\n=over\n\n=item token\n\nMandatory argument, a string with either JWS or JWE JSON Web Token.\n\n ### JWS token example (3 segments)\n $t = \"eyJhbGciOiJIUzI1NiJ9.dGVzdA.ujBihtLSr66CEWqN74SpLUkv28lra_CeHnxLmLNp4Jo\";\n my $data = decode_jwt(token=>$t, key=>$k);\n\n ### JWE token example (5 segments)\n $t = \"eyJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiQTEyOEtXIn0.UusxEbzhGkORxTRq0xkFKhvzPrXb9smw.VGfOuq0Fxt6TsdqLZUpnxw.JajIQQ.pkKZ7MHS0XjyGmRsqgom6w\";\n my $data = decode_jwt(token=>$t, key=>$k);\n\n=item key\n\nA key used for token decryption (JWE) or token signature validation (JWS).\nIf not given, and the token header contains a C<jwk> header value, that value will be used.\nThe value depends on the C<alg> token header value.\n\n JWS alg header      key value\n ------------------  ----------------------------------\n none                no key required\n HS256               string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n HS384               dtto\n HS512               dtto\n RS256               public RSA key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     object: Crypt::PK::RSA, Crypt::OpenSSL::RSA, Crypt::X509 or Crypt::OpenSSL::X509\n RS384               public RSA key, see RS256\n RS512               public RSA key, see RS256\n PS256               public RSA key, see RS256\n PS384               public RSA key, see RS256\n PS512               public RSA key, see RS256\n ES256               public ECC key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::ECC\n ES384               public ECC key, see ES256\n ES512               public ECC key, see ES256\n\n JWE alg header      key value\n ------------------  ----------------------------------\n dir                 string (raw octects) or perl HASH ref with JWK, kty=>'oct', length depends on 'enc' algorithm\n A128KW              string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n A192KW              string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n A256KW              string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n A128GCMKW           string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n A192GCMKW           string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n A256GCMKW           string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS256+A128KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS384+A192KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS512+A256KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n RSA-OAEP            private RSA key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::RSA or Crypt::OpenSSL::RSA\n RSA-OAEP-256        private RSA key, see RSA-OAEP\n RSA1_5              private RSA key, see RSA-OAEP\n ECDH-ES             private ECC key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::ECC\n ECDH-ES+A128KW      private ECC key, see ECDH-ES\n ECDH-ES+A192KW      private ECC key, see ECDH-ES\n ECDH-ES+A256KW      private ECC key, see ECDH-ES\n\nExample with key from C<jwk> token header:\n\n my $data = decode_jwt(token=>$t);\n my ($header, $data) = decode_jwt(token=>$t, decode_header=>1);\n\nExamples with raw octet keys:\n\n #string\n my $data = decode_jwt(token=>$t, key=>'secretkey');\n #binary key\n my $data = decode_jwt(token=>$t, key=>pack(\"H*\", \"788A6E38F36B7596EF6A669E94\"));\n #perl HASH ref with JWK structure (key type 'oct')\n my $data = decode_jwt(token=>$t, key=>{kty=>'oct', k=>\"GawgguFyGrWKav7AX4VKUg\"});\n\nExamples with RSA keys:\n\n my $pem_key_string = <<'EOF';\n -----BEGIN PRIVATE KEY-----\n MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCoVm/Sl5r+Ofky\n jioRSZK26GW6WyjyfWKddsSi13/NOtCn0rRErSF/u3QrgGMpWFqKohqbi1VVC+SZ\n ...\n 8c1vm2YFafgdkSk9Qd1oU2Fv1aOQy4VovOFzJ3CcR+2r7cbRfcpLGnintHtp9yek\n 02p+d5g4OChfFNDhDtnIqjvY\n -----END PRIVATE KEY-----\n EOF\n\n my $jwk_key_json_string = '{\"kty\":\"RSA\",\"n\":\"0vx7agoebG...L6tSoc_BJECP\",\"e\":\"AQAB\"}';\n\n #a reference to SCALAR string with PEM or DER or JSON/JWK data,\n my $data = decode_jwt(token=>$t, key=>\\$pem_key_string);\n my $data = decode_jwt(token=>$t, key=>\\$der_key_string);\n my $data = decode_jwt(token=>$t, key=>\\$jwk_key_json_string);\n\n #instance of Crypt::PK::RSA\n my $data = decode_jwt(token=>$t, key=>Crypt::PK::RSA->new('keyfile.pem'));\n my $data = decode_jwt(token=>$t, key=>Crypt::PK::RSA->new(\\$pem_key_string));\n\n #instance of Crypt::OpenSSL::RSA\n my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::RSA->new_private_key($pem_key_string));\n\n #instance of Crypt::X509 (public key only)\n my $data = decode_jwt(token=>$t, key=>Crypt::X509->new(cert=>$cert));\n\n #instance of Crypt::OpenSSL::X509 (public key only)\n my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::X509->new_from_file('cert.pem'));\n my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::X509->new_from_string($cert));\n\n #perl HASH ref with JWK structure (key type 'RSA')\n my $rsa_priv = {\n   kty => \"RSA\",\n   n   => \"0vx7agoebGcQSuuPiLJXZpt...eZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqbw0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw\",\n   e   => \"AQAB\",\n   d   => \"X4cTteJY_gn4FYPsXB8rdXi...FLN5EEaG6RoVH-HLKD9Mdx5ooGURknhnrRwUkC7h5fJLMWbFAKLWY2v7B6NqSzUvx0_YSf\",\n   p   => \"83i-7IvMGXoMXCskv73TKr8...Z27zvoj6pbUQyLPBQxtPnwD20-60eTmD2ujMt5PoMrm8RmNhVWtjjMmMjOpSicFHjXOuVI\",\n   q   => \"3dfOR9cuYq-0S-mkFLzgItg...q3hWeMuG0ouqnb3obLyuqjVZQ1dIrdgTnCdYzBcOW5r37AFXjift_NGiovonzhKpoVVS78\",\n   dp  => \"G4sPXkc6Ya9y8oJW9_ILj4...zi_H7TkS8x5SdX3oE0oiYwxIiemTAu0UOa5pgFGyJ4c8t2VF40XRugKTP8akhFo5tA77Qe\",\n   dq  => \"s9lAH9fggBsoFR8Oac2R_E...T2kGOhvIllTE1efA6huUvMfBcpn8lqW6vzzYY5SSF7pMd_agI3G8IbpBUb0JiraRNUfLhc\",\n   qi  => \"GyM_p6JrXySiz1toFgKbWV...4ypu9bMWx3QJBfm0FoYzUIZEVEcOqwmRN81oDAaaBk0KWGDjJHDdDmFW3AN7I-pux_mHZG\",\n };\n my $data = decode_jwt(token=>$t, key=>$rsa_priv});\n\nExamples with ECC keys:\n\n my $pem_key_string = <<'EOF';\n -----BEGIN EC PRIVATE KEY-----\n MHcCAQEEIBG1c3z52T8XwMsahGVdOZWgKCQJfv+l7djuJjgetdbDoAoGCCqGSM49\n AwEHoUQDQgAEoBUyo8CQAFPeYPvv78ylh5MwFZjTCLQeb042TjiMJxG+9DLFmRSM\n lBQ9T/RsLLc+PmpB1+7yPAR+oR5gZn3kJQ==\n -----END EC PRIVATE KEY-----\n EOF\n\n my $jwk_key_json_string = '{\"kty\":\"EC\",\"crv\":\"P-256\",\"x\":\"MKB..7D4\",\"y\":\"4Et..FyM\"}';\n\n #a reference to SCALAR string with PEM or DER or JSON/JWK data,\n my $data = decode_jwt(token=>$t, key=>\\$pem_key_string);\n my $data = decode_jwt(token=>$t, key=>\\$der_key_string);\n my $data = decode_jwt(token=>$t, key=>\\$jwk_key_json_string);\n\n #instance of Crypt::PK::ECC\n my $data = decode_jwt(token=>$t, key=>Crypt::PK::ECC->new('keyfile.pem'));\n my $data = decode_jwt(token=>$t, key=>Crypt::PK::ECC->new(\\$pem_key_string));\n\n #perl HASH ref with JWK structure (key type 'EC')\n my $ecc_priv = {\n   kty => \"EC\",\n   crv => \"P-256\",\n   x   => \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4\",\n   y   => \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n   d   => \"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\",\n };\n my $data = decode_jwt(token=>$t, key=>$ecc_priv});\n\n=item keypass\n\nWhen 'key' parameter is an encrypted private RSA or ECC key this optional parameter may contain a password for private key decryption.\n\n=item kid_keys\n\nThis parametes can be either a JWK Set JSON string (see RFC7517) or a perl HASH ref with JWK Set structure like this:\n\n  my $keylist = {\n    keys => [\n      { kid=>\"key1\", kty=>\"oct\", k=>\"GawgguFyGrWKav7AX4VKUg\" },\n      { kid=>\"key2\", kty=>\"oct\", k=>\"ulxLGy4XqhbpkR5ObGh1gX\" },\n    ]\n  };\n  my $payload = decode_jwt(token=>$t, kid_keys=>$keylist);\n\nSince 0.19 we also support:\n\n  use LWP::Simple;\n  my $google_certs = get('https://www.googleapis.com/oauth2/v1/certs');\n  my $payload = decode_jwt(token => $t, kid_keys => $google_certs);\n\nWhen the token header contains 'kid' item the corresponding key is looked up in C<kid_keys> list and used for token\ndecoding (you do not need to pass the explicit key via C<key> parameter).\n\n=item allow_none\n\nC<1> - accept JWS tokens with C<none> 'alg' header value (which means that token has no signature), B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - do not allow JWS with C<none> 'alg' header value\n\n=item ignore_signature\n\nC<1> - do not check signature on JWS tokens, B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - check signature on JWS tokens\n\n=item accepted_alg\n\nC<undef> (default) means accept all 'alg' algorithms except 'none' (for accepting 'none' use C<allow_none>)\n\nC<string> name of accepted 'alg' algorithm (only one)\n\nC<ARRAY ref> a list of accepted 'alg' algorithms\n\nC<Regexp> that has to match 'alg' algorithm name\n\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>'HS256');\n #or\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>['HS256','HS384']);\n #or\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>qr/^HS(256|384|512)$/);\n\n=item accepted_enc\n\nC<undef> (default) means accept all 'enc' algorithms\n\nC<string> name of accepted 'enc' algorithm (only one)\n\nC<ARRAY ref> a list of accepted 'enc' algorithms\n\nC<Regexp> that has to match 'enc' algorithm name\n\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>'A192GCM');\n #or\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>['A192GCM','A256GCM']);\n #or\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>qr/^A(128|192|256)GCM$/);\n\n=item decode_payload\n\nC<0> - do not decode payload, return it as a raw string (octects).\n\nC<1> - decode payload from JSON string, return it as perl hash ref (or array ref) - decode_json failure means fatal error (croak).\n\nC<undef> (default) - if possible decode payload from JSON string, if decode_json fails return payload as a raw string (octets).\n\n=item decode_header\n\nC<0> (default) - do not return decoded header as a return value of decode_jwt()\n\nC<1> - return decoded header as a return value of decode_jwt()\n\n my $payload = decode_jwt(token=>$t, key=>$k);\n #or\n my ($header, $payload) = decode_jwt(token=>$t, key=>$k, decode_header=>1);\n\n=item verify_iss\n\nC<CODE ref> - subroutine (with 'iss' claim value passed as argument) should return C<true> otherwise verification fails\n\nC<Regexp ref> - 'iss' claim value has to match given regexp otherwise verification fails\n\nC<undef> (default) - do not verify 'iss' claim\n\n=item verify_aud\n\nC<CODE ref> - subroutine (with 'aud' claim value passed as argument) should return C<true> otherwise verification fails\n\nC<Regexp ref> - 'aud' claim value has to match given regexp otherwise verification fails\n\nC<undef> (default) - do not verify 'aud' claim\n\n=item verify_sub\n\nC<CODE ref> - subroutine (with 'sub' claim value passed as argument) should return C<true> otherwise verification fails\n\nC<Regexp ref> - 'sub' claim value has to match given regexp otherwise verification fails\n\nC<undef> (default) - do not verify 'sub' claim\n\n=item verify_jti\n\nC<CODE ref> - subroutine (with 'jti' claim value passed as argument) should return C<true> otherwise verification fails\n\nC<Regexp ref> - 'jti' claim value has to match given regexp otherwise verification fails\n\nC<undef> (default) - do not verify 'jti' claim\n\n=item verify_iat\n\nC<undef> - Issued At 'iat' claim must be valid (not in the future) if present\n\nC<0> (default) - ignore 'iat' claim\n\nC<1> - require valid 'iat' claim\n\n=item verify_nbf\n\nC<undef> (default) - Not Before 'nbf' claim must be valid if present\n\nC<0> - ignore 'nbf' claim\n\nC<1> - require valid 'nbf' claim\n\n=item verify_exp\n\nC<undef> (default) - Expiration Time 'exp' claim must be valid if present\n\nC<0> - ignore 'exp' claim\n\nC<1> - require valid 'exp' claim\n\n=item leeway\n\nTolerance in seconds related to C<verify_exp>, C<verify_nbf> and C<verify_iat>. Default is C<0>.\n\n=item ignore_claims\n\nC<1> - do not check claims (iat, exp, nbf, iss, aud, sub, jti), B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - check claims\n\n=back\n\n=head2 encode_jwt\n\n my $token = encode_jwt(%named_args);\n\nNamed arguments:\n\n=over\n\n=item payload\n\nValue of this mandatory parameter can be a string/buffer or HASH ref or ARRAY ref\n\n my $token = encode_jwt(payload=>\"any raw data\", key=>$k, alg=>'HS256');\n #or\n my $token = encode_jwt(payload=>{a=>1,b=>2}, key=>$k, alg=>'HS256');\n #or\n my $token = encode_jwt(payload=>[11,22,33,44], key=>$k, alg=>'HS256');\n\nHASH refs and ARRAY refs payloads are serialized as JSON strings\n\n=item alg\n\nThe 'alg' header value is mandatory for both JWE and JWS tokens.\n\nSupported JWE 'alg' algorithms:\n\n dir\n A128KW\n A192KW\n A256KW\n A128GCMKW\n A192GCMKW\n A256GCMKW\n PBES2-HS256+A128KW\n PBES2-HS384+A192KW\n PBES2-HS512+A256KW\n RSA-OAEP\n RSA-OAEP-256\n RSA1_5\n ECDH-ES+A128KW\n ECDH-ES+A192KW\n ECDH-ES+A256KW\n ECDH-ES\n\nSupported JWS algorithms:\n\n none   ...  no integrity (NOTE: disabled by default)\n HS256  ...  HMAC+SHA256 integrity\n HS384  ...  HMAC+SHA384 integrity\n HS512  ...  HMAC+SHA512 integrity\n RS256  ...  RSA+PKCS1-V1_5 + SHA256 signature\n RS384  ...  RSA+PKCS1-V1_5 + SHA384 signature\n RS512  ...  RSA+PKCS1-V1_5 + SHA512 signature\n PS256  ...  RSA+PSS + SHA256 signature\n PS384  ...  RSA+PSS + SHA384 signature\n PS512  ...  RSA+PSS + SHA512 signature\n ES256  ...  ECDSA + SHA256 signature\n ES384  ...  ECDSA + SHA384 signature\n ES512  ...  ECDSA + SHA512 signature\n\n=item enc\n\nThe 'enc' header is mandatory for JWE tokens.\n\nSupported 'enc' algorithms:\n\n A128GCM\n A192GCM\n A256GCM\n A128CBC-HS256\n A192CBC-HS384\n A256CBC-HS512\n\n=item key\n\nA key used for token encryption (JWE) or token signing (JWS). The value depends on C<alg> token header value.\n\n JWS alg header      key value\n ------------------  ----------------------------------\n none                no key required\n HS256               string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n HS384               dtto\n HS512               dtto\n RS256               private RSA key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     object: Crypt::PK::RSA, Crypt::OpenSSL::RSA, Crypt::X509 or Crypt::OpenSSL::X509\n RS384               private RSA key, see RS256\n RS512               private RSA key, see RS256\n PS256               private RSA key, see RS256\n PS384               private RSA key, see RS256\n PS512               private RSA key, see RS256\n ES256               private ECC key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::ECC\n ES384               private ECC key, see ES256\n ES512               private ECC key, see ES256\n\n JWE alg header      key value\n ------------------  ----------------------------------\n dir                 string (raw octects) or perl HASH ref with JWK, kty=>'oct', length depends on 'enc' algorithm\n A128KW              string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n A192KW              string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n A256KW              string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n A128GCMKW           string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n A192GCMKW           string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n A256GCMKW           string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS256+A128KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS384+A192KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS512+A256KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n RSA-OAEP            public RSA key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::RSA or Crypt::OpenSSL::RSA\n RSA-OAEP-256        public RSA key, see RSA-OAEP\n RSA1_5              public RSA key, see RSA-OAEP\n ECDH-ES             public ECC key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::ECC\n ECDH-ES+A128KW      public ECC key, see ECDH-ES\n ECDH-ES+A192KW      public ECC key, see ECDH-ES\n ECDH-ES+A256KW      public ECC key, see ECDH-ES\n\n=item keypass\n\nWhen 'key' parameter is an encrypted private RSA or ECC key this optional parameter may contain a password for private key decryption.\n\n=item allow_none\n\nC<1> - allow JWS with C<none> 'alg' header value (which means that token has no signature), B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - do not allow JWS with C<none> 'alg' header value\n\n=item extra_headers\n\nThis optional parameter may contain a HASH ref with items that will be added to JWT header.\n\nIf you want to use PBES2-based 'alg' like C<PBES2-HS512+A256KW> you can set PBES2 salt len (p2s) in bytes and\niteration count (p2c) via C<extra_headers> like this:\n\n my $token = encode_jwt(payload=>$p, key=>$k, alg=>'PBES2-HS512+A256KW', extra_headers=>{p2c=8000, p2s=>32});\n #NOTE: handling of p2s header is a special case, in the end it is replaced with the generated salt\n\n=item unprotected_headers\n\nA hash with additional integrity unprotected headers - JWS and JWE (not available for C<compact> serialization);\n\n=item shared_unprotected_headers\n\nA hash with additional integrity unprotected headers - JWE only (not available for C<compact> serialization);\n\n=item aad\n\nAdditional Authenticated Data - scalar value with any (even raw octects) data - JWE only (not available for C<compact> serialization);\n\n=item serialization\n\nSpecify serialization method: C<compat> (= default) for Compact JWS/JWE serialization or C<flattened> for Flattened JWS/JWE JSON serialization.\n\nGeneral JSON serialization is not supported yet.\n\n=item zip\n\nCompression method, currently 'deflate' is the only one supported. C<undef> (default) means no compression.\n\n my $token = encode_jwt(payload=>$p, key=>$k, alg=>'HS256', zip=>'deflate');\n #or define compression level\n my $token = encode_jwt(payload=>$p, key=>$k, alg=>'HS256', zip=>['deflate', 9]);\n\n=item auto_iat\n\nC<1> - set 'iat' (Issued At) claim to current time (epoch seconds since 1970) at the moment of token encoding\n\nC<0> (default) - do not set 'iat' claim\n\nNOTE: claims are part of the payload and can be used only if the payload is a HASH ref!\n\n=item relative_exp\n\nSet 'exp' claim (Expiration Time) to current time + C<relative_exp> value (in seconds).\n\nNOTE: claims are part of the payload and can be used only if the payload is a HASH ref!\n\n=item relative_nbf\n\nSet 'nbf' claim (Not Before) to current time + C<relative_nbf> value (in seconds).\n\nNOTE: claims are part of the payload and can be used only if the payload is a HASH ref!\n\n=back\n\n=head1 SEE ALSO\n\nL<Crypt::Cipher::AES>, L<Crypt::AuthEnc::GCM>, L<Crypt::PK::RSA>, L<Crypt::PK::ECC>, L<Crypt::KeyDerivation>, L<Crypt::KeyWrap>\n\n=head1 LICENSE\n\nThis program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.\n\n=head1 COPYRIGHT\n\nCopyright (c) 2015 DCIT, a.s. L<http://www.dcit.cz> / Karel Miko\n", "use strict;\nuse warnings;\n\nuse Test::More tests => 2;\n\nuse_ok('Crypt::KeyWrap');\nuse_ok('Crypt::JWT');\n", "use strict;\nuse warnings;\nuse Test::More;\n\nplan tests => 2;\n\nuse Crypt::JWT qw(encode_jwt decode_jwt);\n\nmy $jws =\n  'eyJqd2siOnsiZSI6IkFRQUIiLCJuIjoieVFJdnpEU3h2a2EzQTNhVFYzS2Yza29PeElWMjNqZGlaa1BkOU8xb3RsN0JYLWZJS2dEYk00QnBHSkxZLUhrTG5aZUxpcXgwSFpKaF94U09IVXhWNnVpLUpIU00yZkFrTnEzMHd4QzMycDZmVDk2b3RuT3ZsTEhPTVVpNEZwUFR0NDVFQmcyemlqRXRfRWNFM3g0OFJjT2ZQVGk3SDBmWnhBdXVYcmJrYmU1SHFqczVxVWp2bDFKWUdKdTA1TlItdnE2NUwyUC1oOFA5eUJBT1pRZjhRMVhBSGg1RlFQd08tQjZ3T1p6aTNjeTEtRUhXZkhpWXpxeTMxWU01ZmxIaFZ4QndWRmUyMUlINEh3WWp2SE5KMURFaEl2R2FSQTBWc09ZNlFqVUxPS19XTVlQVnExc211TmdEZThlZ1V4RnV2R2N4aWJ4NTUydHJkSHVBaWFUVGlRIiwia3R5IjoiUlNBIn0sImFsZyI6IlJTMjU2Iiwibm9uY2UiOm51bGx9.eyJjb250YWN0IjpbIm1haWx0bzpmQGcudGxkIl0sInJlc291cmNlIjoibmV3LXJlZyJ9.wrY6y0kvA3qgR38ZuAA471ygN9fmSHdfWDIayjkBKGmeGbn0f30_LQBC9FiFDFgFJ8Owyy3bOkPWvHx7yhRnP5XnEYdzNtKy4t2LyKq_JSEVQf6p1zycsVaxVLCmZ6ZbRidxIFLhbkcmu2uc4BEVGQQEj3UesccIv-AS2JCQFqK5ca-HQeaLEMntXOz5p7DYZtauYjHuXQ60i25mClm51jScJfP-wk7yYnnohGYKDinwiYlH4Nw8p4yElzWL1dI-U8fiFoxnduGaflPIZ80hkk0p7delrZt3RvmaDdu4cLJ16TgrMw_nMZfbAK0IJXByAsbej78HwIAchdzHyRPmgA';\n\nmy ( $header, $payload ) = decode_jwt( token => $jws, decode_header => 1 );\n\nis_deeply(\n    $header,\n    {\n        'alg' => 'RS256',\n        'jwk' => {\n            'e'   => 'AQAB',\n            'kty' => 'RSA',\n            'n' =>\n              'yQIvzDSxvka3A3aTV3Kf3koOxIV23jdiZkPd9O1otl7BX-fIKgDbM4BpGJLY-HkLnZeLiqx0HZJh_xSOHUxV6ui-JHSM2fAkNq30wxC32p6fT96otnOvlLHOMUi4FpPTt45EBg2zijEt_EcE3x48RcOfPTi7H0fZxAuuXrbkbe5Hqjs5qUjvl1JYGJu05NR-vq65L2P-h8P9yBAOZQf8Q1XAHh5FQPwO-B6wOZzi3cy1-EHWfHiYzqy31YM5flHhVxBwVFe21IH4HwYjvHNJ1DEhIvGaRA0VsOY6QjULOK_WMYPVq1smuNgDe8egUxFuvGcxibx552trdHuAiaTTiQ'\n        },\n        'nonce' => undef\n    },\n);\n\nis_deeply(\n    $payload,\n    {\n        'contact'  => ['mailto:f@g.tld'],\n        'resource' => 'new-reg'\n    }\n);\n"], "fixing_code": ["NAME\n    Crypt::JWT - JSON Web Token (JWT, JWS, JWE) as defined by RFC7519,\n    RFC7515, RFC7516\n\nSYNOPSIS\n       # encoding\n       use Crypt::JWT qw(encode_jwt);\n       my $jws_token = encode_jwt(payload=>$data, alg=>'HS256', key=>'secret');\n       my $jwe_token = encode_jwt(payload=>$data, alg=>'PBES2-HS256+A128KW', enc=>'A128GCM', key=>'secret');\n\n       # decoding\n       use Crypt::JWT qw(decode_jwt);\n       my $data1 = decode_jwt(token=>$jws_token, key=>'secret');\n       my $data2 = decode_jwt(token=>$jwe_token, key=>'secret');\n\nDESCRIPTION\n    Implements JSON Web Token (JWT) - <https://tools.ietf.org/html/rfc7519>.\n    The implementation covers not only JSON Web Signature (JWS) -\n    <https://tools.ietf.org/html/rfc7515>, but also JSON Web Encryption\n    (JWE) - <https://tools.ietf.org/html/rfc7516>.\n\n    The module implements all (100%) algorithms defined in\n    <https://tools.ietf.org/html/rfc7518> - JSON Web Algorithms (JWA).\n\n    This module supports Compact JWS/JWE and Flattened JWS/JWE JSON\n    serialization, general JSON serialization is not supported yet.\n\nEXPORT\n    Nothing is exported by default.\n\n    You can export selected functions:\n\n      use Crypt::JWT qw(decode_jwt encode_jwt);\n\n    Or all of them at once:\n\n      use Crypt::JWT ':all';\n\nFUNCTIONS\n  decode_jwt\n     my $data = decode_jwt(%named_args);\n\n    Named arguments:\n\n    token\n        Mandatory argument, a string with either JWS or JWE JSON Web Token.\n\n         ### JWS token example (3 segments)\n         $t = \"eyJhbGciOiJIUzI1NiJ9.dGVzdA.ujBihtLSr66CEWqN74SpLUkv28lra_CeHnxLmLNp4Jo\";\n         my $data = decode_jwt(token=>$t, key=>$k);\n\n         ### JWE token example (5 segments)\n         $t = \"eyJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiQTEyOEtXIn0.UusxEbzhGkORxTRq0xkFKhvzPrXb9smw.VGfOuq0Fxt6TsdqLZUpnxw.JajIQQ.pkKZ7MHS0XjyGmRsqgom6w\";\n         my $data = decode_jwt(token=>$t, key=>$k);\n\n    key A key used for token decryption (JWE) or token signature validation\n        (JWS). If not given, and the token header contains a \"jwk\" header\n        value, that value will be used. The value depends on the \"alg\" token\n        header value.\n\n         JWS alg header      key value\n         ------------------  ----------------------------------\n         none                no key required\n         HS256               string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         HS384               dtto\n         HS512               dtto\n         RS256               public RSA key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             object: Crypt::PK::RSA, Crypt::OpenSSL::RSA, Crypt::X509 or Crypt::OpenSSL::X509\n         RS384               public RSA key, see RS256\n         RS512               public RSA key, see RS256\n         PS256               public RSA key, see RS256\n         PS384               public RSA key, see RS256\n         PS512               public RSA key, see RS256\n         ES256               public ECC key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::ECC\n         ES384               public ECC key, see ES256\n         ES512               public ECC key, see ES256\n\n         JWE alg header      key value\n         ------------------  ----------------------------------\n         dir                 string (raw octects) or perl HASH ref with JWK, kty=>'oct', length depends on 'enc' algorithm\n         A128KW              string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A192KW              string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A256KW              string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A128GCMKW           string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A192GCMKW           string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A256GCMKW           string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS256+A128KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS384+A192KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS512+A256KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         RSA-OAEP            private RSA key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::RSA or Crypt::OpenSSL::RSA\n         RSA-OAEP-256        private RSA key, see RSA-OAEP\n         RSA1_5              private RSA key, see RSA-OAEP\n         ECDH-ES             private ECC key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::ECC\n         ECDH-ES+A128KW      private ECC key, see ECDH-ES\n         ECDH-ES+A192KW      private ECC key, see ECDH-ES\n         ECDH-ES+A256KW      private ECC key, see ECDH-ES\n\n        Example with key from \"jwk\" token header:\n\n         my $data = decode_jwt(token=>$t);\n         my ($header, $data) = decode_jwt(token=>$t, decode_header=>1);\n\n        Examples with raw octet keys:\n\n         #string\n         my $data = decode_jwt(token=>$t, key=>'secretkey');\n         #binary key\n         my $data = decode_jwt(token=>$t, key=>pack(\"H*\", \"788A6E38F36B7596EF6A669E94\"));\n         #perl HASH ref with JWK structure (key type 'oct')\n         my $data = decode_jwt(token=>$t, key=>{kty=>'oct', k=>\"GawgguFyGrWKav7AX4VKUg\"});\n\n        Examples with RSA keys:\n\n         my $pem_key_string = <<'EOF';\n         -----BEGIN PRIVATE KEY-----\n         MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCoVm/Sl5r+Ofky\n         jioRSZK26GW6WyjyfWKddsSi13/NOtCn0rRErSF/u3QrgGMpWFqKohqbi1VVC+SZ\n         ...\n         8c1vm2YFafgdkSk9Qd1oU2Fv1aOQy4VovOFzJ3CcR+2r7cbRfcpLGnintHtp9yek\n         02p+d5g4OChfFNDhDtnIqjvY\n         -----END PRIVATE KEY-----\n         EOF\n\n         my $jwk_key_json_string = '{\"kty\":\"RSA\",\"n\":\"0vx7agoebG...L6tSoc_BJECP\",\"e\":\"AQAB\"}';\n\n         #a reference to SCALAR string with PEM or DER or JSON/JWK data,\n         my $data = decode_jwt(token=>$t, key=>\\$pem_key_string);\n         my $data = decode_jwt(token=>$t, key=>\\$der_key_string);\n         my $data = decode_jwt(token=>$t, key=>\\$jwk_key_json_string);\n\n         #instance of Crypt::PK::RSA\n         my $data = decode_jwt(token=>$t, key=>Crypt::PK::RSA->new('keyfile.pem'));\n         my $data = decode_jwt(token=>$t, key=>Crypt::PK::RSA->new(\\$pem_key_string));\n\n         #instance of Crypt::OpenSSL::RSA\n         my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::RSA->new_private_key($pem_key_string));\n\n         #instance of Crypt::X509 (public key only)\n         my $data = decode_jwt(token=>$t, key=>Crypt::X509->new(cert=>$cert));\n\n         #instance of Crypt::OpenSSL::X509 (public key only)\n         my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::X509->new_from_file('cert.pem'));\n         my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::X509->new_from_string($cert));\n\n         #perl HASH ref with JWK structure (key type 'RSA')\n         my $rsa_priv = {\n           kty => \"RSA\",\n           n   => \"0vx7agoebGcQSuuPiLJXZpt...eZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqbw0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw\",\n           e   => \"AQAB\",\n           d   => \"X4cTteJY_gn4FYPsXB8rdXi...FLN5EEaG6RoVH-HLKD9Mdx5ooGURknhnrRwUkC7h5fJLMWbFAKLWY2v7B6NqSzUvx0_YSf\",\n           p   => \"83i-7IvMGXoMXCskv73TKr8...Z27zvoj6pbUQyLPBQxtPnwD20-60eTmD2ujMt5PoMrm8RmNhVWtjjMmMjOpSicFHjXOuVI\",\n           q   => \"3dfOR9cuYq-0S-mkFLzgItg...q3hWeMuG0ouqnb3obLyuqjVZQ1dIrdgTnCdYzBcOW5r37AFXjift_NGiovonzhKpoVVS78\",\n           dp  => \"G4sPXkc6Ya9y8oJW9_ILj4...zi_H7TkS8x5SdX3oE0oiYwxIiemTAu0UOa5pgFGyJ4c8t2VF40XRugKTP8akhFo5tA77Qe\",\n           dq  => \"s9lAH9fggBsoFR8Oac2R_E...T2kGOhvIllTE1efA6huUvMfBcpn8lqW6vzzYY5SSF7pMd_agI3G8IbpBUb0JiraRNUfLhc\",\n           qi  => \"GyM_p6JrXySiz1toFgKbWV...4ypu9bMWx3QJBfm0FoYzUIZEVEcOqwmRN81oDAaaBk0KWGDjJHDdDmFW3AN7I-pux_mHZG\",\n         };\n         my $data = decode_jwt(token=>$t, key=>$rsa_priv});\n\n        Examples with ECC keys:\n\n         my $pem_key_string = <<'EOF';\n         -----BEGIN EC PRIVATE KEY-----\n         MHcCAQEEIBG1c3z52T8XwMsahGVdOZWgKCQJfv+l7djuJjgetdbDoAoGCCqGSM49\n         AwEHoUQDQgAEoBUyo8CQAFPeYPvv78ylh5MwFZjTCLQeb042TjiMJxG+9DLFmRSM\n         lBQ9T/RsLLc+PmpB1+7yPAR+oR5gZn3kJQ==\n         -----END EC PRIVATE KEY-----\n         EOF\n\n         my $jwk_key_json_string = '{\"kty\":\"EC\",\"crv\":\"P-256\",\"x\":\"MKB..7D4\",\"y\":\"4Et..FyM\"}';\n\n         #a reference to SCALAR string with PEM or DER or JSON/JWK data,\n         my $data = decode_jwt(token=>$t, key=>\\$pem_key_string);\n         my $data = decode_jwt(token=>$t, key=>\\$der_key_string);\n         my $data = decode_jwt(token=>$t, key=>\\$jwk_key_json_string);\n\n         #instance of Crypt::PK::ECC\n         my $data = decode_jwt(token=>$t, key=>Crypt::PK::ECC->new('keyfile.pem'));\n         my $data = decode_jwt(token=>$t, key=>Crypt::PK::ECC->new(\\$pem_key_string));\n\n         #perl HASH ref with JWK structure (key type 'EC')\n         my $ecc_priv = {\n           kty => \"EC\",\n           crv => \"P-256\",\n           x   => \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4\",\n           y   => \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n           d   => \"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\",\n         };\n         my $data = decode_jwt(token=>$t, key=>$ecc_priv});\n\n    keypass\n        When 'key' parameter is an encrypted private RSA or ECC key this\n        optional parameter may contain a password for private key\n        decryption.\n\n    kid_keys\n        This parametes can be either a JWK Set JSON string (see RFC7517) or\n        a perl HASH ref with JWK Set structure like this:\n\n          my $keylist = {\n            keys => [\n              { kid=>\"key1\", kty=>\"oct\", k=>\"GawgguFyGrWKav7AX4VKUg\" },\n              { kid=>\"key2\", kty=>\"oct\", k=>\"ulxLGy4XqhbpkR5ObGh1gX\" },\n            ]\n          };\n          my $payload = decode_jwt(token=>$t, kid_keys=>$keylist);\n\n        Since 0.19 we also support:\n\n          use LWP::Simple;\n          my $google_certs = get('https://www.googleapis.com/oauth2/v1/certs');\n          my $payload = decode_jwt(token => $t, kid_keys => $google_certs);\n\n        When the token header contains \"kid\" item the corresponding key is\n        looked up in \"kid_keys\" list and used for token decoding (you do not\n        need to pass the explicit key via \"key\" parameter).\n\n        CHANGED in 0.23: When \"kid_keys\" is specified it croaks if token\n        header does not contain \"kid\" value or if \"kid\" was not found in\n        \"kid_keys\".\n\n    key_from_jwk_header\n        ADDED in 0.23\n\n        1 - use \"jwk\" header value for validating JWS signature if neither\n        \"key\" nor \"kid_keys\" specified, BEWARE: DANGEROUS, UNSECURE!!!\n\n        0 (default) - ignore \"jwk\" header value when validating JWS\n        signature\n\n        Keep in mind that enabling \"key_from_jwk_header\" requires \"jwk\"\n        header to exist and be an valid RSA/ECDSA public key (otherwise it\n        croaks).\n\n    allow_none\n        1 - accept JWS tokens with \"none\" 'alg' header value (which means\n        that token has no signature), BEWARE: DANGEROUS, UNSECURE!!!\n\n        0 (default) - do not allow JWS with \"none\" 'alg' header value\n\n    ignore_signature\n        1 - do not check signature on JWS tokens, BEWARE: DANGEROUS,\n        UNSECURE!!!\n\n        0 (default) - check signature on JWS tokens\n\n    accepted_alg\n        \"undef\" (default) means accept all 'alg' algorithms except 'none'\n        (for accepting 'none' use \"allow_none\")\n\n        \"string\" name of accepted 'alg' algorithm (only one)\n\n        \"ARRAY ref\" a list of accepted 'alg' algorithms\n\n        \"Regexp\" that has to match 'alg' algorithm name\n\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>'HS256');\n         #or\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>['HS256','HS384']);\n         #or\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>qr/^HS(256|384|512)$/);\n\n    accepted_enc\n        \"undef\" (default) means accept all 'enc' algorithms\n\n        \"string\" name of accepted 'enc' algorithm (only one)\n\n        \"ARRAY ref\" a list of accepted 'enc' algorithms\n\n        \"Regexp\" that has to match 'enc' algorithm name\n\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>'A192GCM');\n         #or\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>['A192GCM','A256GCM']);\n         #or\n         my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>qr/^A(128|192|256)GCM$/);\n\n    decode_payload\n        0 - do not decode payload, return it as a raw string (octects).\n\n        1 - decode payload from JSON string, return it as perl hash ref (or\n        array ref) - decode_json failure means fatal error (croak).\n\n        \"undef\" (default) - if possible decode payload from JSON string, if\n        decode_json fails return payload as a raw string (octets).\n\n    decode_header\n        0 (default) - do not return decoded header as a return value of\n        decode_jwt()\n\n        1 - return decoded header as a return value of decode_jwt()\n\n         my $payload = decode_jwt(token=>$t, key=>$k);\n         #or\n         my ($header, $payload) = decode_jwt(token=>$t, key=>$k, decode_header=>1);\n\n    verify_iss\n        \"CODE ref\" - subroutine (with 'iss' claim value passed as argument)\n        should return \"true\" otherwise verification fails\n\n        \"Regexp ref\" - 'iss' claim value has to match given regexp otherwise\n        verification fails\n\n        \"undef\" (default) - do not verify 'iss' claim\n\n    verify_aud\n        \"CODE ref\" - subroutine (with 'aud' claim value passed as argument)\n        should return \"true\" otherwise verification fails\n\n        \"Regexp ref\" - 'aud' claim value has to match given regexp otherwise\n        verification fails\n\n        \"undef\" (default) - do not verify 'aud' claim\n\n    verify_sub\n        \"CODE ref\" - subroutine (with 'sub' claim value passed as argument)\n        should return \"true\" otherwise verification fails\n\n        \"Regexp ref\" - 'sub' claim value has to match given regexp otherwise\n        verification fails\n\n        \"undef\" (default) - do not verify 'sub' claim\n\n    verify_jti\n        \"CODE ref\" - subroutine (with 'jti' claim value passed as argument)\n        should return \"true\" otherwise verification fails\n\n        \"Regexp ref\" - 'jti' claim value has to match given regexp otherwise\n        verification fails\n\n        \"undef\" (default) - do not verify 'jti' claim\n\n    verify_iat\n        \"undef\" - Issued At 'iat' claim must be valid (not in the future) if\n        present\n\n        0 (default) - ignore 'iat' claim\n\n        1 - require valid 'iat' claim\n\n    verify_nbf\n        \"undef\" (default) - Not Before 'nbf' claim must be valid if present\n\n        0 - ignore 'nbf' claim\n\n        1 - require valid 'nbf' claim\n\n    verify_exp\n        \"undef\" (default) - Expiration Time 'exp' claim must be valid if\n        present\n\n        0 - ignore 'exp' claim\n\n        1 - require valid 'exp' claim\n\n    leeway\n        Tolerance in seconds related to \"verify_exp\", \"verify_nbf\" and\n        \"verify_iat\". Default is 0.\n\n    ignore_claims\n        1 - do not check claims (iat, exp, nbf, iss, aud, sub, jti), BEWARE:\n        DANGEROUS, UNSECURE!!!\n\n        0 (default) - check claims\n\n  encode_jwt\n     my $token = encode_jwt(%named_args);\n\n    Named arguments:\n\n    payload\n        Value of this mandatory parameter can be a string/buffer or HASH ref\n        or ARRAY ref\n\n         my $token = encode_jwt(payload=>\"any raw data\", key=>$k, alg=>'HS256');\n         #or\n         my $token = encode_jwt(payload=>{a=>1,b=>2}, key=>$k, alg=>'HS256');\n         #or\n         my $token = encode_jwt(payload=>[11,22,33,44], key=>$k, alg=>'HS256');\n\n        HASH refs and ARRAY refs payloads are serialized as JSON strings\n\n    alg The 'alg' header value is mandatory for both JWE and JWS tokens.\n\n        Supported JWE 'alg' algorithms:\n\n         dir\n         A128KW\n         A192KW\n         A256KW\n         A128GCMKW\n         A192GCMKW\n         A256GCMKW\n         PBES2-HS256+A128KW\n         PBES2-HS384+A192KW\n         PBES2-HS512+A256KW\n         RSA-OAEP\n         RSA-OAEP-256\n         RSA1_5\n         ECDH-ES+A128KW\n         ECDH-ES+A192KW\n         ECDH-ES+A256KW\n         ECDH-ES\n\n        Supported JWS algorithms:\n\n         none   ...  no integrity (NOTE: disabled by default)\n         HS256  ...  HMAC+SHA256 integrity\n         HS384  ...  HMAC+SHA384 integrity\n         HS512  ...  HMAC+SHA512 integrity\n         RS256  ...  RSA+PKCS1-V1_5 + SHA256 signature\n         RS384  ...  RSA+PKCS1-V1_5 + SHA384 signature\n         RS512  ...  RSA+PKCS1-V1_5 + SHA512 signature\n         PS256  ...  RSA+PSS + SHA256 signature\n         PS384  ...  RSA+PSS + SHA384 signature\n         PS512  ...  RSA+PSS + SHA512 signature\n         ES256  ...  ECDSA + SHA256 signature\n         ES384  ...  ECDSA + SHA384 signature\n         ES512  ...  ECDSA + SHA512 signature\n\n    enc The 'enc' header is mandatory for JWE tokens.\n\n        Supported 'enc' algorithms:\n\n         A128GCM\n         A192GCM\n         A256GCM\n         A128CBC-HS256\n         A192CBC-HS384\n         A256CBC-HS512\n\n    key A key used for token encryption (JWE) or token signing (JWS). The\n        value depends on \"alg\" token header value.\n\n         JWS alg header      key value\n         ------------------  ----------------------------------\n         none                no key required\n         HS256               string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         HS384               dtto\n         HS512               dtto\n         RS256               private RSA key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             object: Crypt::PK::RSA, Crypt::OpenSSL::RSA, Crypt::X509 or Crypt::OpenSSL::X509\n         RS384               private RSA key, see RS256\n         RS512               private RSA key, see RS256\n         PS256               private RSA key, see RS256\n         PS384               private RSA key, see RS256\n         PS512               private RSA key, see RS256\n         ES256               private ECC key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::ECC\n         ES384               private ECC key, see ES256\n         ES512               private ECC key, see ES256\n\n         JWE alg header      key value\n         ------------------  ----------------------------------\n         dir                 string (raw octects) or perl HASH ref with JWK, kty=>'oct', length depends on 'enc' algorithm\n         A128KW              string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A192KW              string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A256KW              string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A128GCMKW           string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A192GCMKW           string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n         A256GCMKW           string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS256+A128KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS384+A192KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         PBES2-HS512+A256KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n         RSA-OAEP            public RSA key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::RSA or Crypt::OpenSSL::RSA\n         RSA-OAEP-256        public RSA key, see RSA-OAEP\n         RSA1_5              public RSA key, see RSA-OAEP\n         ECDH-ES             public ECC key, perl HASH ref with JWK key structure,\n                             a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                             an instance of Crypt::PK::ECC\n         ECDH-ES+A128KW      public ECC key, see ECDH-ES\n         ECDH-ES+A192KW      public ECC key, see ECDH-ES\n         ECDH-ES+A256KW      public ECC key, see ECDH-ES\n\n    keypass\n        When 'key' parameter is an encrypted private RSA or ECC key this\n        optional parameter may contain a password for private key\n        decryption.\n\n    allow_none\n        1 - allow JWS with \"none\" 'alg' header value (which means that token\n        has no signature), BEWARE: DANGEROUS, UNSECURE!!!\n\n        0 (default) - do not allow JWS with \"none\" 'alg' header value\n\n    extra_headers\n        This optional parameter may contain a HASH ref with items that will\n        be added to JWT header.\n\n        If you want to use PBES2-based 'alg' like \"PBES2-HS512+A256KW\" you\n        can set PBES2 salt len (p2s) in bytes and iteration count (p2c) via\n        \"extra_headers\" like this:\n\n         my $token = encode_jwt(payload=>$p, key=>$k, alg=>'PBES2-HS512+A256KW', extra_headers=>{p2c=8000, p2s=>32});\n         #NOTE: handling of p2s header is a special case, in the end it is replaced with the generated salt\n\n    unprotected_headers\n        A hash with additional integrity unprotected headers - JWS and JWE\n        (not available for \"compact\" serialization);\n\n    shared_unprotected_headers\n        A hash with additional integrity unprotected headers - JWE only (not\n        available for \"compact\" serialization);\n\n    aad Additional Authenticated Data - scalar value with any (even raw\n        octects) data - JWE only (not available for \"compact\"\n        serialization);\n\n    serialization\n        Specify serialization method: \"compat\" (= default) for Compact\n        JWS/JWE serialization or \"flattened\" for Flattened JWS/JWE JSON\n        serialization.\n\n        General JSON serialization is not supported yet.\n\n    zip Compression method, currently 'deflate' is the only one supported.\n        \"undef\" (default) means no compression.\n\n         my $token = encode_jwt(payload=>$p, key=>$k, alg=>'HS256', zip=>'deflate');\n         #or define compression level\n         my $token = encode_jwt(payload=>$p, key=>$k, alg=>'HS256', zip=>['deflate', 9]);\n\n    auto_iat\n        1 - set 'iat' (Issued At) claim to current time (epoch seconds since\n        1970) at the moment of token encoding\n\n        0 (default) - do not set 'iat' claim\n\n        NOTE: claims are part of the payload and can be used only if the\n        payload is a HASH ref!\n\n    relative_exp\n        Set 'exp' claim (Expiration Time) to current time + \"relative_exp\"\n        value (in seconds).\n\n        NOTE: claims are part of the payload and can be used only if the\n        payload is a HASH ref!\n\n    relative_nbf\n        Set 'nbf' claim (Not Before) to current time + \"relative_nbf\" value\n        (in seconds).\n\n        NOTE: claims are part of the payload and can be used only if the\n        payload is a HASH ref!\n\nSEE ALSO\n    Crypt::Cipher::AES, Crypt::AuthEnc::GCM, Crypt::PK::RSA, Crypt::PK::ECC,\n    Crypt::KeyDerivation, Crypt::KeyWrap\n\nLICENSE\n    This program is free software; you can redistribute it and/or modify it\n    under the same terms as Perl itself.\n\nCOPYRIGHT\n    Copyright (c) 2015 DCIT, a.s. <http://www.dcit.cz> / Karel Miko\n\n", "package Crypt::JWT;\n\nuse strict;\nuse warnings;\n\nour $VERSION = '0.023';\n\nuse Exporter 'import';\nour %EXPORT_TAGS = ( all => [qw(decode_jwt encode_jwt)] );\nour @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );\nour @EXPORT = qw();\n\nuse Carp;\nuse Crypt::Misc qw(decode_b64u encode_b64u);\nuse JSON::MaybeXS qw(decode_json encode_json);\nuse Crypt::PK::RSA;\nuse Crypt::PK::ECC;\nuse Crypt::PRNG qw(random_bytes);\nuse Crypt::KeyWrap ':all';\nuse Crypt::AuthEnc::GCM qw(gcm_encrypt_authenticate gcm_decrypt_verify);\nuse Crypt::Mac::HMAC qw(hmac);\nuse Compress::Raw::Zlib;\nuse Scalar::Util qw(looks_like_number);\n\n# JWS: https://tools.ietf.org/html/rfc7515\n# JWE: https://tools.ietf.org/html/rfc7516\n# JWK: https://tools.ietf.org/html/rfc7517\n# JWA: https://tools.ietf.org/html/rfc7518\n# JWT: https://tools.ietf.org/html/rfc7519\n\nsub _prepare_rsa_key {\n  my ($key) = @_;\n  croak \"JWT: undefined RSA key\" unless defined $key;\n  croak \"JWT: invalid RSA key (cannot be scalar)\" unless ref $key;\n  # we need Crypt::PK::RSA object\n  return $key                       if ref($key) eq 'Crypt::PK::RSA';\n  return Crypt::PK::RSA->new($key)  if ref($key) eq 'HASH' || ref($key) eq 'SCALAR';\n  return Crypt::PK::RSA->new(@$key) if ref($key) eq 'ARRAY';\n  # handle also: Crypt::OpenSSL::RSA, Crypt::X509, Crypt::OpenSSL::X509\n  my $str;\n  if (ref($key) eq 'Crypt::OpenSSL::RSA') {\n    # https://metacpan.org/pod/Crypt::OpenSSL::RSA\n    $str = $key->is_private ? $key->get_private_key_string : $key->get_public_key_string;\n  }\n  elsif (ref($key) =~ /^Crypt::(X509|OpenSSL::X509)$/) {\n    # https://metacpan.org/pod/Crypt::X509\n    # https://metacpan.org/pod/Crypt::OpenSSL::X509\n    $str = $key->pubkey;\n  }\n  return Crypt::PK::RSA->new(\\$str) if defined $str && !ref($str);\n  croak \"JWT: invalid RSA key\";\n}\n\nsub _prepare_ecc_key {\n  my ($key) = @_;\n  croak \"JWT: undefined ECC key\" unless defined $key;\n  croak \"JWT: invalid ECC key (cannot be scalar)\" unless ref $key;\n  # we need Crypt::PK::ECC object\n  return $key                       if ref($key) eq 'Crypt::PK::ECC';\n  return Crypt::PK::ECC->new($key)  if ref($key) eq 'HASH' || ref($key) eq 'SCALAR';\n  return Crypt::PK::ECC->new(@$key) if ref($key) eq 'ARRAY';\n  croak \"JWT: invalid ECC key\";\n}\n\nsub _prepare_oct_key {\n  my ($key) = @_;\n  croak \"JWT: undefined oct key\" unless defined $key;\n  if (ref $key eq 'HASH' && $key->{k} && $key->{kty} && $key->{kty} eq 'oct') {\n    return decode_b64u($key->{k});\n  }\n  elsif (!ref $key) {\n    return $key;\n  }\n  croak \"JWT: invalid oct key\";\n}\n\nsub _kid_lookup {\n  my ($kid, $kid_keys, $alg) = @_;\n  return undef if !defined $kid || !defined $alg;\n  $kid_keys = eval { decode_json($kid_keys) } if $kid_keys && !ref $kid_keys;\n  croak \"JWT: kid_keys must be a HASHREF or a valid JSON/HASH\" if ref $kid_keys ne 'HASH';\n  my $found;\n  if (exists $kid_keys->{keys} && ref $kid_keys->{keys} eq 'ARRAY') {\n    #FORMAT: { keys => [ {kid=>'A', kty=>?, ...}, {kid=>'B', kty=>?, ...} ] }\n    for (@{$kid_keys->{keys}}) {\n      if ($_->{kid} && $_->{kty} && $_->{kid} eq $kid) {\n        $found = $_;\n        last;\n      }\n    }\n  }\n  else {\n    #FORMAT: { hexadec1 => \"----BEGIN CERTIFICATE-----...\", hexadec2 => \"----BEGIN CERTIFICATE-----...\" }\n    #e.g. https://www.googleapis.com/oauth2/v1/certs\n    return \\$kid_keys->{$kid} if $kid_keys->{$kid} && !ref $kid_keys->{$kid};\n  }\n  return undef if !$found;\n  return $found if $found->{kty} eq 'oct' && $alg =~ /^(HS|dir|PBES2-HS|A)/;\n  return $found if $found->{kty} eq 'EC'  && $alg =~ /^(ES|EC)/;\n  return $found if $found->{kty} eq 'RSA' && $alg =~ /^RS/;\n  croak \"JWT: key type '$found->{kty}' cannot be used with alg '$alg'\";\n}\n\nsub _b64u_to_hash {\n  my $b64url = shift;\n  return undef unless $b64url;\n  my $json = decode_b64u($b64url);\n  return undef unless $json;\n  my $hash = eval { decode_json($json) };\n  return undef unless ref $hash eq 'HASH';\n  return $hash;\n}\n\nsub _add_claims {\n  my ($payload, %args) = @_;\n  #### claims (defined for JWS only)\n  # \"exp\"   Expiration Time\n  # \"nbf\"   Not Before\n  # \"iat\"   Issued At\n  # \"iss\"   Issuer\n  # \"sub\"   Subject\n  # \"aud\"   Audience\n  # \"jti\"   JWT ID\n  my $now = time;\n  $payload->{iat} = $now                       if $args{auto_iat};\n  $payload->{exp} = $now + $args{relative_exp} if defined $args{relative_exp};\n  $payload->{nbf} = $now + $args{relative_nbf} if defined $args{relative_nbf};\n}\n\nsub _verify_claims {\n  my ($payload, %args) = @_;\n\n  return if $args{ignore_claims};\n\n  my $leeway = $args{leeway} || 0;\n  my $now = time;\n\n  ### exp\n  if(defined $payload->{exp}) {\n    if (!defined $args{verify_exp} || $args{verify_exp}==1) {\n      croak \"JWT: exp claim check failed ($payload->{exp}/$leeway vs. $now)\" if $payload->{exp} + $leeway <= $now;\n    }\n  }\n  elsif ($args{verify_exp} && $args{verify_exp}==1) {\n    croak \"JWT: exp claim required but missing\"\n  }\n\n  ### nbf\n  if(defined $payload->{nbf}) {\n    if (!defined $args{verify_nbf} || $args{verify_nbf}==1) {\n      croak \"JWT: nbf claim check failed ($payload->{nbf}/$leeway vs. $now)\" if $payload->{nbf} - $leeway > $now;\n    }\n  }\n  elsif ($args{verify_nbf} && $args{verify_nbf}==1) {\n    croak \"JWT: nbf claim required but missing\"\n  }\n\n  ### iat\n  if (exists $args{verify_iat}) { #default (non existing verify_iat) == no iat check\n    if(defined $payload->{iat}) {\n      if (!defined $args{verify_iat} || $args{verify_iat}==1) {\n        croak \"JWT: iat claim check failed ($payload->{iat}/$leeway vs. $now)\" if $payload->{iat} - $leeway > $now;\n      }\n    }\n    elsif ($args{verify_iat} && $args{verify_iat}==1) {\n      croak \"JWT: iat claim required but missing\"\n    }\n  }\n\n  ### iss\n  if(exists $payload->{iss}) {\n    if (ref $args{verify_iss} eq 'Regexp') {\n      croak \"JWT: iss claim re check failed\" unless $payload->{iss} =~ $args{verify_iss};\n    }\n    elsif (ref $args{verify_iss} eq 'CODE') {\n      croak \"JWT: iss claim check failed\" unless $args{verify_iss}->($payload->{iss});\n    }\n  }\n\n  ### sub\n  if(exists $payload->{sub}) {\n    if (ref $args{verify_sub} eq 'Regexp') {\n      croak \"JWT: sub claim re check failed\" unless $payload->{sub} =~ $args{verify_sub};\n    }\n    elsif (ref $args{verify_sub} eq 'CODE') {\n      croak \"JWT: sub claim check failed\" unless $args{verify_sub}->($payload->{sub});\n    }\n  }\n\n  ### aud\n  if(exists $payload->{aud}) {\n    if (ref $args{verify_aud} eq 'Regexp') {\n      croak \"JWT: aud claim re check failed\" unless $payload->{aud} =~ $args{verify_aud};\n    }\n    elsif (ref $args{verify_aud} eq 'CODE') {\n      croak \"JWT: aud claim check failed\" unless $args{verify_aud}->($payload->{aud});\n    }\n  }\n\n  ### jti\n  if(exists $payload->{jti}) {\n    if (ref $args{verify_jti} eq 'Regexp') {\n      croak \"JWT: jti claim re check failed\" unless $payload->{jti} =~ $args{verify_jti};\n    }\n    elsif (ref $args{verify_jti} eq 'CODE') {\n      croak \"JWT: jti claim check failed\" unless $args{verify_jti}->($payload->{jti});\n    }\n  }\n}\n\nsub _payload_zip {\n  my ($payload, $header, $z) = @_;\n  my @zip = ref $z eq 'ARRAY' ? @$z : ($z);\n  if ($zip[0] eq 'deflate') {\n    my $level = defined $zip[1] ? $zip[1] : 6;\n    $header->{zip} = \"DEF\";\n    my $d = Compress::Raw::Zlib::Deflate->new(-Bufsize => 1024, -WindowBits => -&MAX_WBITS(), -AppendOutput => 1, -Level => $level );\n    my $output = '';\n    $d->deflate($payload, $output) == Z_OK or croak \"JWT: deflate failed\";\n    $d->flush($output) == Z_OK             or croak \"JWT: deflate/flush failed\";\n    croak \"JWT: deflate/output failed\" unless $output;\n    $payload = $output;\n  }\n  else {\n    croak \"JWT: unknown zip method '$zip[0]'\";\n  }\n  return $payload;\n}\n\nsub _payload_unzip {\n  my ($payload, $z) = @_;\n  if ($z eq \"DEF\") {\n    my $d = Compress::Raw::Zlib::Inflate->new(-Bufsize => 1024, -WindowBits => -&MAX_WBITS());\n    my $output = '';\n    $d->inflate($payload, $output);\n    croak \"JWT: inflate failed\" unless $output;\n    $payload = $output;\n  }\n  else {\n    croak \"JWT: unknown zip method '$z'\";\n  }\n  return $payload;\n}\n\nsub _payload_enc {\n  my ($payload) = @_;\n  if (ref($payload) =~ /^(HASH|ARRAY)$/) {\n    $payload = encode_json($payload);\n  }\n  else {\n    utf8::downgrade($payload, 1) or croak \"JWT: payload cannot contain wide character\";\n  }\n  return $payload;\n}\n\nsub _payload_dec {\n  my ($payload, $decode_payload) = @_;\n  return $payload if defined $decode_payload && $decode_payload == 0;\n  my $de = $payload;\n  $de = eval { decode_json($de) };\n  if ($decode_payload) {\n    croak \"JWT: payload not a valid JSON\" unless $de;\n    return $de;\n  }\n  else {\n    return defined $de ? $de : $payload;\n  }\n}\n\nsub _encrypt_jwe_cek {\n  my ($key, $hdr) = @_;\n  my $alg = $hdr->{alg};\n  my $enc = $hdr->{enc};\n\n  if ($alg eq 'dir') {\n    return (_prepare_oct_key($key), '');\n  }\n\n  my $cek;\n  my $ecek;\n  if ($enc =~ /^A(128|192|256)GCM/) {\n    $cek = random_bytes($1/8);\n  }\n  elsif ($enc =~ /^A(128|192|256)CBC/) {\n    $cek = random_bytes(2*$1/8);\n  }\n\n  if ($alg =~ /^A(128|192|256)KW$/) {\n    $ecek = aes_key_wrap(_prepare_oct_key($key), $cek);\n    return ($cek, $ecek);\n  }\n  elsif ($alg =~ /^A(128|192|256)GCMKW$/) {\n    my ($t, $i);\n    ($ecek, $t, $i) = gcm_key_wrap(_prepare_oct_key($key), $cek);\n    $hdr->{tag} = encode_b64u($t);\n    $hdr->{iv}  = encode_b64u($i);\n    return ($cek, $ecek);\n  }\n  elsif ($alg =~ /^PBES2-HS(512|384|256)\\+A(128|192|256)KW$/) {\n    my $len = looks_like_number($hdr->{p2s}) && $hdr->{p2s} >= 8 && $hdr->{p2s} <= 9999 ? $hdr->{p2s} : 16;\n    my $salt = random_bytes($len);\n    my $iter = looks_like_number($hdr->{p2c}) ? $hdr->{p2c} : 5000;\n    $ecek = pbes2_key_wrap(_prepare_oct_key($key), $cek, $alg, $salt, $iter);\n    $hdr->{p2s} = encode_b64u($salt);\n    $hdr->{p2c} = $iter;\n    return ($cek, $ecek);\n  }\n  elsif ($alg =~ /^RSA(-OAEP|-OAEP-256|1_5)$/) {\n    $key = _prepare_rsa_key($key);\n    $ecek = rsa_key_wrap($key, $cek, $alg);\n    return ($cek, $ecek);\n  }\n  elsif ($alg =~ /^ECDH-ES\\+A(128|192|256)KW$/) {\n    $key = _prepare_ecc_key($key);\n    ($ecek, $hdr->{epk}) = ecdhaes_key_wrap($key, $cek, $alg, $hdr->{apu}, $hdr->{apv});\n    return ($cek, $ecek);\n  }\n  elsif ($alg eq 'ECDH-ES') {\n    $key = _prepare_ecc_key($key);\n    ($cek, $hdr->{epk}) = ecdh_key_wrap($key, $enc, $hdr->{apu}, $hdr->{apv});\n    return ($cek, '');\n  }\n  croak \"JWE: unknown alg '$alg'\";\n}\n\nsub _decrypt_jwe_cek {\n  my ($ecek, $key, $hdr) = @_;\n  my $alg = $hdr->{alg};\n  my $enc = $hdr->{enc};\n\n  if ($alg eq 'dir') {\n    return _prepare_oct_key($key);\n  }\n  elsif ($alg =~ /^A(128|192|256)KW$/) {\n    return aes_key_unwrap(_prepare_oct_key($key), $ecek);\n  }\n  elsif ($alg =~ /^A(128|192|256)GCMKW$/) {\n    return gcm_key_unwrap(_prepare_oct_key($key), $ecek, decode_b64u($hdr->{tag}), decode_b64u($hdr->{iv}));\n  }\n  elsif ($alg =~ /^PBES2-HS(512|384|256)\\+A(128|192|256)KW$/) {\n    return pbes2_key_unwrap(_prepare_oct_key($key), $ecek, $alg, decode_b64u($hdr->{p2s}), $hdr->{p2c});\n  }\n  elsif ($alg =~ /^RSA(-OAEP|-OAEP-256|1_5)$/) {\n    $key = _prepare_rsa_key($key);\n    return rsa_key_unwrap($key, $ecek, $alg);\n  }\n  elsif ($alg =~ /^ECDH-ES\\+A(128|192|256)KW$/) {\n    $key = _prepare_ecc_key($key);\n    return ecdhaes_key_unwrap($key, $ecek, $alg, $hdr->{epk}, $hdr->{apu}, $hdr->{apv});\n  }\n  elsif ($alg eq 'ECDH-ES') {\n    $key = _prepare_ecc_key($key);\n    return ecdh_key_unwrap($key, $enc, $hdr->{epk}, $hdr->{apu}, $hdr->{apv});\n  }\n  croak \"JWE: unknown alg '$alg'\";\n}\n\nsub _encrypt_jwe_payload {\n  my ($cek, $enc, $b64u_header, $b64u_aad, $payload) = @_;\n  my $aad = defined $b64u_aad ? \"$b64u_header.$b64u_aad\" : $b64u_header;\n  if ($enc =~ /^A(128|192|256)GCM$/) {\n    # https://tools.ietf.org/html/rfc7518#section-5.3\n    my $len1 = $1/8;\n    my $len2 = length($cek);\n    croak \"JWE: wrong AES key length ($len1 vs. $len2) for $enc\" unless $len1 == $len2;\n    my $iv = random_bytes(12); # for AESGCM always 12 (96 bits)\n    my ($ct, $tag) = gcm_encrypt_authenticate('AES', $cek, $iv, $aad, $payload);\n    return ($ct, $iv, $tag);\n  }\n  elsif ($enc =~ /^A(128|192|256)CBC-HS(256|384|512)$/) {\n    # https://tools.ietf.org/html/rfc7518#section-5.2\n    my ($size, $hash) = ($1/8, \"SHA$2\");\n    my $key_len = length($cek) / 2;\n    my $mac_key = substr($cek, 0, $key_len);\n    my $aes_key = substr($cek, $key_len, $key_len);\n    croak \"JWE: wrong AES key length ($key_len vs. $size)\" unless $key_len == $size;\n    my $iv = random_bytes(16); # for AES always 16\n    my $m = Crypt::Mode::CBC->new('AES');\n    my $ct = $m->encrypt($payload, $aes_key, $iv);\n    my $aad_len = length($aad);\n    my $mac_input = $aad . $iv . $ct . pack('N2', ($aad_len / 2147483647)*8, ($aad_len % 2147483647)*8);\n    my $mac = hmac($hash, $mac_key, $mac_input);\n    my $sig_len = length($mac) / 2;\n    my $sig = substr($mac, 0, $sig_len);\n    return ($ct, $iv, $sig);\n  }\n  croak \"JWE: unsupported enc '$enc'\";\n}\n\nsub _decrypt_jwe_payload {\n  my ($cek, $enc, $aad, $ct, $iv, $tag) = @_;\n  if ($enc =~ /^A(128|192|256)GCM$/) {\n    # https://tools.ietf.org/html/rfc7518#section-5.3\n    my $len1 = $1/8;\n    my $len2 = length($cek);\n    croak \"JWE: wrong AES key length ($len1 vs. $len2) for $enc\" unless $len1 == $len2;\n    return gcm_decrypt_verify('AES', $cek, $iv, $aad, $ct, $tag);\n  }\n  elsif ($enc =~ /^A(128|192|256)CBC-HS(256|384|512)$/) {\n    # https://tools.ietf.org/html/rfc7518#section-5.2\n    my ($size, $hash) = ($1/8, \"SHA$2\");\n    my $key_len = length($cek) / 2;\n    my $mac_key = substr($cek, 0, $key_len);\n    my $aes_key = substr($cek, $key_len, $key_len);\n    croak \"JWE: wrong AES key length ($key_len vs. $size)\" unless $key_len == $size;\n    my $aad_len = length($aad); # AAD == original encoded header\n    my $mac_input = $aad . $iv . $ct . pack('N2', ($aad_len / 2147483647)*8, ($aad_len % 2147483647)*8);\n    my $mac = hmac($hash, $mac_key, $mac_input);\n    my $sig_len = length($mac) / 2;\n    my $sig = substr($mac, 0, $sig_len);\n    croak \"JWE: tag mismatch\" unless $sig eq $tag;\n    my $m = Crypt::Mode::CBC->new('AES');\n    my $pt = $m->decrypt($ct, $aes_key, $iv);\n    return $pt;\n  }\n  croak \"JWE: unsupported enc '$enc'\";\n}\n\nsub _encode_jwe {\n  my %args = @_;\n  my $payload = $args{payload};\n  my $alg     = $args{alg};\n  my $enc     = $args{enc};\n  my $header  = $args{extra_headers} ? \\%{$args{extra_headers}} : {};\n  # add claims to payload\n  _add_claims($payload, %args) if ref $payload eq 'HASH';\n  # serialize payload\n  $payload = _payload_enc($payload);\n  # compress payload\n  $payload = _payload_zip($payload, $header, $args{zip}) if $args{zip}; # may set some header items\n  # prepare header\n  $header->{alg} = $alg;\n  $header->{enc} = $enc;\n  # key\n  croak \"JWE: missing 'key'\" if !$args{key};\n  my $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};\n  # prepare cek\n  my ($cek, $ecek) = _encrypt_jwe_cek($key, $header); # adds some header items\n  # encode header\n  my $json_header = encode_json($header);\n  my $b64u_header = encode_b64u($json_header);\n  my $b64u_aad    = defined $args{aad} ? encode_b64u($args{aad}) : undef;\n  # encrypt payload\n  my ($ct, $iv, $tag) = _encrypt_jwe_payload($cek, $enc, $b64u_header, $b64u_aad, $payload);\n  # return token parts\n  return ( $b64u_header,\n           encode_b64u($ecek),\n           encode_b64u($iv),\n           encode_b64u($ct),\n           encode_b64u($tag),\n           $b64u_aad);\n}\n\nsub _decode_jwe {\n  my ($b64u_header, $b64u_ecek, $b64u_iv, $b64u_ct, $b64u_tag, $b64u_aad, $unprotected, $shared_unprotected, %args) = @_;\n  my $header = _b64u_to_hash($b64u_header);\n  my $ecek   = decode_b64u($b64u_ecek);\n  my $ct     = decode_b64u($b64u_ct);\n  my $iv     = decode_b64u($b64u_iv);\n  my $tag    = decode_b64u($b64u_tag);\n  croak \"JWE: invalid header part\" if $b64u_header && !$header;\n  croak \"JWE: invalid ecek part\"   if $b64u_ecek   && !$ecek;\n  croak \"JWE: invalid ct part\"     if $b64u_ct     && !$ct;\n  croak \"JWE: invalid iv part\"     if $b64u_iv     && !$iv;\n  croak \"JWE: invalid tag part\"    if $b64u_tag    && !$tag;\n\n  my $key;\n  if (exists $args{key}) {\n    $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};\n  }\n  elsif (exists $args{kid_keys}) {\n    # BEWARE: stricter approach since 0.23\n    # when 'kid_keys' specified it croaks if header doesn't contain 'kid' value or if 'kid' wasn't found in 'kid_keys'\n    my $k = _kid_lookup($header->{kid}, $args{kid_keys}, $header->{alg});\n    croak \"JWE: kid_keys lookup failed\" if !defined $k;\n    $key = $k;\n  }\n  croak \"JWE: missing key\" if !defined $key;\n\n  my $aa = $args{accepted_alg};\n  if (ref($aa) eq 'Regexp') {\n    croak \"JWE: alg '$header->{alg}' does not match accepted_alg\" if $header->{alg} !~ $aa;\n  }\n  elsif ($aa && (ref($aa) eq 'ARRAY' || !ref($aa))) {\n    my %acca = ref $aa ? map { $_ => 1 } @$aa : ( $aa => 1 );\n    croak \"JWE: alg '$header->{alg}' not in accepted_alg\" if !$acca{$header->{alg}};\n  }\n\n  my $ae = $args{accepted_enc};\n  if (ref($ae) eq 'Regexp') {\n    croak \"JWE: enc '$header->{enc}' does not match accepted_enc\" if $header->{enc} !~ $ae;\n  }\n  elsif ($ae && (ref($ae) eq 'ARRAY' || !ref($ae))) {\n    my %acce = ref $ae ? map { $_ => 1 } @$ae : ( $ae => 1 );\n    croak \"JWE: enc '$header->{enc}' not in accepted_enc\" if !$acce{$header->{enc}};\n  }\n\n  $header = { %$shared_unprotected, %$unprotected, %$header }; # merge headers\n  my $cek = _decrypt_jwe_cek($ecek, $key, $header);\n  my $aad = defined $b64u_aad ? \"$b64u_header.$b64u_aad\" : $b64u_header;\n  my $payload = _decrypt_jwe_payload($cek, $header->{enc}, $aad, $ct, $iv, $tag);\n  $payload = _payload_unzip($payload, $header->{zip}) if $header->{zip};\n  $payload = _payload_dec($payload, $args{decode_payload});\n  _verify_claims($payload, %args) if ref $payload eq 'HASH'; # croaks on error\n  return ($header, $payload);\n}\n\nsub _sign_jws {\n  my ($b64u_header, $b64u_payload, $alg, $key) = @_;\n  return '' if $alg eq 'none'; # no integrity\n  my $sig;\n  my $data = \"$b64u_header.$b64u_payload\";\n  if ($alg =~ /^HS(256|384|512)$/) { # HMAC integrity\n    $key = _prepare_oct_key($key);\n    $sig = hmac(\"SHA$1\", $key, $data);\n  }\n  elsif ($alg =~ /^RS(256|384|512)/) { # RSA+PKCS1-V1_5 signatures\n    my $pk = _prepare_rsa_key($key);\n    $sig  = $pk->sign_message($data, \"SHA$1\", 'v1.5');\n  }\n  elsif ($alg =~ /^PS(256|384|512)/) { # RSA+PSS signatures\n    my $hash = \"SHA$1\";\n    my $hashlen = $1/8;\n    my $pk = _prepare_rsa_key($key);\n    $sig  = $pk->sign_message($data, $hash, 'pss', $hashlen);\n  }\n  elsif ($alg =~ /^ES(256|384|512)/) { # ECDSA signatures\n    my $pk = _prepare_ecc_key($key);\n    $sig  = $pk->sign_message_rfc7518($data, \"SHA$1\");\n  }\n  return encode_b64u($sig);\n}\n\nsub _verify_jws {\n  my ($b64u_header, $b64u_payload, $b64u_sig, $alg, $key) = @_;\n  my $sig = decode_b64u($b64u_sig);\n  croak \"JWS: invalid sig part\" if $b64u_sig && !$sig;\n  my $data = \"$b64u_header.$b64u_payload\";\n\n  if ($alg eq 'none' ) { # no integrity\n    return 1;\n  }\n  elsif ($alg =~ /^HS(256|384|512)$/) { # HMAC integrity\n    $key = _prepare_oct_key($key);\n    return 1 if $sig eq hmac(\"SHA$1\", $key, $data);\n  }\n  elsif ($alg =~ /^RS(256|384|512)/) { # RSA+PKCS1-V1_5 signatures\n    my $hash = \"SHA$1\";\n    my $pk = _prepare_rsa_key($key);\n    return 1 if $pk->verify_message($sig, $data, $hash, 'v1.5');\n  }\n  elsif ($alg =~ /^PS(256|384|512)/) { # RSA+PSS signatures\n    my $hash = \"SHA$1\";\n    my $hashlen = $1/8;\n    my $pk = _prepare_rsa_key($key);\n    return 1 if  $pk->verify_message($sig, $data, $hash, 'pss', $hashlen);\n  }\n  elsif ($alg =~ /^ES(256|384|512)/) { # ECDSA signatures\n    my $hash = \"SHA$1\";\n    my $pk = _prepare_ecc_key($key);\n    return 1 if $pk->verify_message_rfc7518($sig, $data, $hash);\n  }\n  return 0;\n}\n\nsub _encode_jws {\n  my %args = @_;\n  my $payload = $args{payload};\n  my $alg     = $args{alg};\n  my $header  = $args{extra_headers} ? \\%{$args{extra_headers}} : {};\n  croak \"JWS: alg 'none' not allowed\" if $alg eq 'none' && !$args{allow_none};\n  # add claims to payload\n  _add_claims($payload, %args) if ref $payload eq 'HASH';\n  # serialize payload\n  $payload = _payload_enc($payload);\n  # compress payload\n  $payload = _payload_zip($payload, $header, $args{zip}) if $args{zip}; # may set some header items\n  # encode payload\n  my $b64u_payload = encode_b64u($payload);\n  # prepare header\n  $header->{alg} = $alg;\n  # encode header\n  my $json_header = encode_json($header);\n  my $b64u_header = encode_b64u($json_header);\n  # key\n  croak \"JWS: missing 'key'\" if !$args{key} && $alg ne 'none';\n  my $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};\n  # sign header\n  my $b64u_signature = _sign_jws($b64u_header, $b64u_payload, $alg, $key);\n  return ($b64u_header, $b64u_payload, $b64u_signature);\n}\n\nsub _decode_jws {\n  my ($b64u_header, $b64u_payload, $b64u_sig, $unprotected_header, %args) = @_;\n  my $header = _b64u_to_hash($b64u_header);\n  croak \"JWS: invalid header part\" if $b64u_header && !$header;\n  $unprotected_header = {} if ref $unprotected_header ne 'HASH';\n\n  if (!$args{ignore_signature}) {\n    my $alg = $header->{alg};\n    croak \"JWS: missing header 'alg'\" unless $alg;\n    croak \"JWS: alg 'none' not allowed\" if $alg eq 'none' && !$args{allow_none};\n    croak \"JWS: alg 'none' expects no signature\" if $alg eq 'none' && defined $b64u_sig && length($b64u_sig) > 0;\n\n    my $aa = $args{accepted_alg};\n    if (ref $aa eq 'Regexp') {\n      croak \"JWS: alg '$alg' does not match accepted_alg\" if $alg !~ $aa;\n    }\n    elsif (ref $aa eq 'ARRAY') {\n      my %acca = map { $_ => 1 } @$aa;\n      croak \"JWS: alg '$alg' not in accepted_alg\" if !$acca{$alg};\n    }\n    elsif (defined $aa) {\n      croak \"JWS: alg '$alg' not accepted_alg\" if $aa ne $alg;\n    }\n\n    if ($alg ne 'none') {\n      my $key;\n      if (exists $args{key}) {\n        $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};\n      }\n      elsif (exists $args{kid_keys}) {\n        # BEWARE: stricter approach since 0.23\n        # when 'kid_keys' specified it croaks if header doesn't contain 'kid' value or if 'kid' wasn't found in 'kid_keys'\n        my $kid = exists $header->{kid} ? $header->{kid} : $unprotected_header->{kid};\n        my $k = _kid_lookup($kid, $args{kid_keys}, $alg);\n        croak \"JWS: kid_keys lookup failed\" if !defined $k;\n        $key = $k;\n      }\n      elsif ($args{key_from_jwk_header}) {\n        # BEWARE: stricter approach since 0.23\n        # - header 'jwk' is by default ignored (unless given: key_from_jwk_header => 1)\n        # - only RSA/ECDSA public keys are accepted\n        my $k = $header->{jwk};\n        croak \"JWS: jwk header does not contain a key\" if !defined $k || ref($k) ne 'HASH' || !defined $k->{kty};\n        croak \"JWS: jwk header allowed only for RSA/ECDSA\" if $alg !~ /^(RS|PS|ES)/ || $k->{kty} !~ /^(RSA|EC)$/;\n        croak \"JWS: jwk header must be a public key\" if $k->{d} || $k->{p} || $k->{q} || $k->{dp} || $k->{dq} || $k->{qi};\n        $key = $k;\n      }\n      croak \"JWS: missing key\" if !defined $key;\n\n      my $valid = _verify_jws($b64u_header, $b64u_payload, $b64u_sig, $alg, $key);\n      croak \"JWS: invalid signature\" if !$valid;\n    }\n  }\n  my $payload = decode_b64u($b64u_payload);\n  croak \"JWS: invalid payload part\" if $b64u_payload && !$payload;\n  $payload = _payload_unzip($payload, $header->{zip}) if $header->{zip};\n  $payload = _payload_dec($payload, $args{decode_payload});\n  _verify_claims($payload, %args) if ref $payload eq 'HASH'; # croaks on error\n  $header = { %$unprotected_header, %$header }; # merge headers\n  return ($header, $payload);\n}\n\nsub encode_jwt {\n  my %args = @_;\n\n  my $ser = $args{serialization} || 'compact';\n  if ($args{alg} =~ /^(none|((HS|RS|PS|ES)(512|384|256)))$/) {\n    ###JWS\n    my ($b64u_header, $b64u_payload, $b64u_signature) = _encode_jws(%args);\n    if ($ser eq 'compact') { # https://tools.ietf.org/html/rfc7515#section-7.1\n      croak \"JWT: cannot use 'unprotected_headers' with compact serialization\" if defined $args{unprotected_headers};\n      return \"$b64u_header.$b64u_payload.$b64u_signature\";\n    }\n    elsif ($ser eq 'flattened') { # https://tools.ietf.org/html/rfc7515#section-7.2.2\n      my $token = { protected => $b64u_header, payload => $b64u_payload, signature => $b64u_signature };\n      $token->{header} = \\%{$args{unprotected_headers}} if ref $args{unprotected_headers} eq 'HASH';\n      return encode_json($token);\n    }\n    else {\n      croak \"JWT: unsupported JWS serialization '$ser'\";\n    }\n  }\n  else {\n    ### JWE\n    my ($b64u_header, $b64u_ecek, $b64u_iv, $b64u_ct, $b64u_tag, $b64u_aad) = _encode_jwe(%args);\n    if ($ser eq 'compact') { # https://tools.ietf.org/html/rfc7516#section-7.1\n      croak \"JWT: cannot use 'aad' with compact serialization\" if defined $args{aad};\n      croak \"JWT: cannot use 'unprotected_headers' with compact serialization\" if defined $args{unprotected_headers};\n      croak \"JWT: cannot use 'shared_unprotected_headers' with compact serialization\" if defined $args{shared_unprotected_headers};\n      return \"$b64u_header.$b64u_ecek.$b64u_iv.$b64u_ct.$b64u_tag\";\n    }\n    elsif ($ser eq 'flattened') { # https://tools.ietf.org/html/rfc7516#section-7.2.2\n      my $token = {\n        protected     => $b64u_header,\n        encrypted_key => $b64u_ecek,\n        iv            => $b64u_iv,\n        ciphertext    => $b64u_ct,\n        tag           => $b64u_tag,\n      };\n      # header: JWE Per-Recipient Unprotected Header when the JWE Per-Recipient Unprotected Header\n      $token->{header} = \\%{$args{unprotected_headers}} if ref $args{unprotected_headers} eq 'HASH';\n      # unprotected: JWE Shared Unprotected Header\n      $token->{unprotected} = \\%{$args{shared_unprotected_headers}} if ref $args{shared_unprotected_headers} eq 'HASH';\n      # aad: Additional Authenticated Data (AAD)\n      $token->{aad} = $b64u_aad if defined $b64u_aad;\n      return encode_json($token);\n    }\n    else {\n      croak \"JWT: unsupported JWE serialization '$ser'\";\n    }\n  }\n}\n\nsub decode_jwt {\n  my %args = @_;\n  my ($header, $payload);\n\n  if (!$args{token}) {\n    croak \"JWT: missing token\";\n  }\n  elsif ($args{token} =~ /^([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]*)=*\\.([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]+)=*$/) {\n    # JWE token (5 segments)\n    ($header, $payload) = _decode_jwe($1, $2, $3, $4, $5, undef, {}, {}, %args);\n  }\n  elsif ($args{token} =~ /^([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]+)=*\\.([a-zA-Z0-9_-]*)=*$/) {\n    # JWS token (3 segments)\n    ($header, $payload) = _decode_jws($1, $2, $3, {}, %args);\n  }\n  elsif ($args{token} =~ /^\\s*\\{.*?\\}\\s*$/s) {\n    my $hash = decode_json($args{token});\n    if ($hash->{payload} && $hash->{protected}) {\n      # Flattened JWS JSON Serialization\n      ($header, $payload) = _decode_jws($hash->{protected}, $hash->{payload}, $hash->{signature}, $hash->{header}, %args);\n    }\n    elsif ($hash->{ciphertext} && $hash->{protected}) {\n      # Flattened JWE JSON Serialization\n      ($header, $payload) = _decode_jwe($hash->{protected}, $hash->{encrypted_key}, $hash->{iv}, $hash->{ciphertext}, $hash->{tag}, $hash->{aad}, $hash->{header}, $hash->{unprotected}, %args);\n    }\n    else {\n      croak \"JWT: unsupported JWS/JWT JSON Serialization\";\n    }\n  }\n  else {\n    croak \"JWT: invalid token format\";\n  }\n  return ($header, $payload) if $args{decode_header};\n  return $payload;\n}\n\n1;\n\n#### URLs\n# https://metacpan.org/pod/JSON::WebToken\n# https://metacpan.org/pod/Mojo::JWT\n# https://bitbucket.org/b_c/jose4j/wiki/JWE%20Examples\n# https://bitbucket.org/b_c/jose4j/wiki/JWS%20Examples\n# https://github.com/dvsekhvalnov/jose-jwt/tree/master/JWT/jwe\n# https://github.com/progrium/ruby-jwt\n# https://github.com/jpadilla/pyjwt/\n\n=pod\n\n=head1 NAME\n\nCrypt::JWT - JSON Web Token (JWT, JWS, JWE) as defined by RFC7519, RFC7515, RFC7516\n\n=head1 SYNOPSIS\n\n   # encoding\n   use Crypt::JWT qw(encode_jwt);\n   my $jws_token = encode_jwt(payload=>$data, alg=>'HS256', key=>'secret');\n   my $jwe_token = encode_jwt(payload=>$data, alg=>'PBES2-HS256+A128KW', enc=>'A128GCM', key=>'secret');\n\n   # decoding\n   use Crypt::JWT qw(decode_jwt);\n   my $data1 = decode_jwt(token=>$jws_token, key=>'secret');\n   my $data2 = decode_jwt(token=>$jwe_token, key=>'secret');\n\n=head1 DESCRIPTION\n\nImplements B<JSON Web Token (JWT)> - L<https://tools.ietf.org/html/rfc7519>.\nThe implementation covers not only B<JSON Web Signature (JWS)> - L<https://tools.ietf.org/html/rfc7515>,\nbut also B<JSON Web Encryption (JWE)> - L<https://tools.ietf.org/html/rfc7516>.\n\nThe module implements B<all (100%) algorithms> defined in L<https://tools.ietf.org/html/rfc7518> - B<JSON Web Algorithms (JWA)>.\n\nThis module supports B<Compact JWS/JWE> and B<Flattened JWS/JWE JSON> serialization, general JSON serialization is not supported yet.\n\n=head1 EXPORT\n\nNothing is exported by default.\n\nYou can export selected functions:\n\n  use Crypt::JWT qw(decode_jwt encode_jwt);\n\nOr all of them at once:\n\n  use Crypt::JWT ':all';\n\n=head1 FUNCTIONS\n\n=head2 decode_jwt\n\n my $data = decode_jwt(%named_args);\n\nNamed arguments:\n\n=over\n\n=item token\n\nMandatory argument, a string with either JWS or JWE JSON Web Token.\n\n ### JWS token example (3 segments)\n $t = \"eyJhbGciOiJIUzI1NiJ9.dGVzdA.ujBihtLSr66CEWqN74SpLUkv28lra_CeHnxLmLNp4Jo\";\n my $data = decode_jwt(token=>$t, key=>$k);\n\n ### JWE token example (5 segments)\n $t = \"eyJlbmMiOiJBMTI4R0NNIiwiYWxnIjoiQTEyOEtXIn0.UusxEbzhGkORxTRq0xkFKhvzPrXb9smw.VGfOuq0Fxt6TsdqLZUpnxw.JajIQQ.pkKZ7MHS0XjyGmRsqgom6w\";\n my $data = decode_jwt(token=>$t, key=>$k);\n\n=item key\n\nA key used for token decryption (JWE) or token signature validation (JWS).\nIf not given, and the token header contains a C<jwk> header value, that value will be used.\nThe value depends on the C<alg> token header value.\n\n JWS alg header      key value\n ------------------  ----------------------------------\n none                no key required\n HS256               string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n HS384               dtto\n HS512               dtto\n RS256               public RSA key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     object: Crypt::PK::RSA, Crypt::OpenSSL::RSA, Crypt::X509 or Crypt::OpenSSL::X509\n RS384               public RSA key, see RS256\n RS512               public RSA key, see RS256\n PS256               public RSA key, see RS256\n PS384               public RSA key, see RS256\n PS512               public RSA key, see RS256\n ES256               public ECC key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::ECC\n ES384               public ECC key, see ES256\n ES512               public ECC key, see ES256\n\n JWE alg header      key value\n ------------------  ----------------------------------\n dir                 string (raw octects) or perl HASH ref with JWK, kty=>'oct', length depends on 'enc' algorithm\n A128KW              string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n A192KW              string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n A256KW              string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n A128GCMKW           string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n A192GCMKW           string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n A256GCMKW           string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS256+A128KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS384+A192KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS512+A256KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n RSA-OAEP            private RSA key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::RSA or Crypt::OpenSSL::RSA\n RSA-OAEP-256        private RSA key, see RSA-OAEP\n RSA1_5              private RSA key, see RSA-OAEP\n ECDH-ES             private ECC key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::ECC\n ECDH-ES+A128KW      private ECC key, see ECDH-ES\n ECDH-ES+A192KW      private ECC key, see ECDH-ES\n ECDH-ES+A256KW      private ECC key, see ECDH-ES\n\nExample with key from C<jwk> token header:\n\n my $data = decode_jwt(token=>$t);\n my ($header, $data) = decode_jwt(token=>$t, decode_header=>1);\n\nExamples with raw octet keys:\n\n #string\n my $data = decode_jwt(token=>$t, key=>'secretkey');\n #binary key\n my $data = decode_jwt(token=>$t, key=>pack(\"H*\", \"788A6E38F36B7596EF6A669E94\"));\n #perl HASH ref with JWK structure (key type 'oct')\n my $data = decode_jwt(token=>$t, key=>{kty=>'oct', k=>\"GawgguFyGrWKav7AX4VKUg\"});\n\nExamples with RSA keys:\n\n my $pem_key_string = <<'EOF';\n -----BEGIN PRIVATE KEY-----\n MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCoVm/Sl5r+Ofky\n jioRSZK26GW6WyjyfWKddsSi13/NOtCn0rRErSF/u3QrgGMpWFqKohqbi1VVC+SZ\n ...\n 8c1vm2YFafgdkSk9Qd1oU2Fv1aOQy4VovOFzJ3CcR+2r7cbRfcpLGnintHtp9yek\n 02p+d5g4OChfFNDhDtnIqjvY\n -----END PRIVATE KEY-----\n EOF\n\n my $jwk_key_json_string = '{\"kty\":\"RSA\",\"n\":\"0vx7agoebG...L6tSoc_BJECP\",\"e\":\"AQAB\"}';\n\n #a reference to SCALAR string with PEM or DER or JSON/JWK data,\n my $data = decode_jwt(token=>$t, key=>\\$pem_key_string);\n my $data = decode_jwt(token=>$t, key=>\\$der_key_string);\n my $data = decode_jwt(token=>$t, key=>\\$jwk_key_json_string);\n\n #instance of Crypt::PK::RSA\n my $data = decode_jwt(token=>$t, key=>Crypt::PK::RSA->new('keyfile.pem'));\n my $data = decode_jwt(token=>$t, key=>Crypt::PK::RSA->new(\\$pem_key_string));\n\n #instance of Crypt::OpenSSL::RSA\n my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::RSA->new_private_key($pem_key_string));\n\n #instance of Crypt::X509 (public key only)\n my $data = decode_jwt(token=>$t, key=>Crypt::X509->new(cert=>$cert));\n\n #instance of Crypt::OpenSSL::X509 (public key only)\n my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::X509->new_from_file('cert.pem'));\n my $data = decode_jwt(token=>$t, key=>Crypt::OpenSSL::X509->new_from_string($cert));\n\n #perl HASH ref with JWK structure (key type 'RSA')\n my $rsa_priv = {\n   kty => \"RSA\",\n   n   => \"0vx7agoebGcQSuuPiLJXZpt...eZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqbw0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw\",\n   e   => \"AQAB\",\n   d   => \"X4cTteJY_gn4FYPsXB8rdXi...FLN5EEaG6RoVH-HLKD9Mdx5ooGURknhnrRwUkC7h5fJLMWbFAKLWY2v7B6NqSzUvx0_YSf\",\n   p   => \"83i-7IvMGXoMXCskv73TKr8...Z27zvoj6pbUQyLPBQxtPnwD20-60eTmD2ujMt5PoMrm8RmNhVWtjjMmMjOpSicFHjXOuVI\",\n   q   => \"3dfOR9cuYq-0S-mkFLzgItg...q3hWeMuG0ouqnb3obLyuqjVZQ1dIrdgTnCdYzBcOW5r37AFXjift_NGiovonzhKpoVVS78\",\n   dp  => \"G4sPXkc6Ya9y8oJW9_ILj4...zi_H7TkS8x5SdX3oE0oiYwxIiemTAu0UOa5pgFGyJ4c8t2VF40XRugKTP8akhFo5tA77Qe\",\n   dq  => \"s9lAH9fggBsoFR8Oac2R_E...T2kGOhvIllTE1efA6huUvMfBcpn8lqW6vzzYY5SSF7pMd_agI3G8IbpBUb0JiraRNUfLhc\",\n   qi  => \"GyM_p6JrXySiz1toFgKbWV...4ypu9bMWx3QJBfm0FoYzUIZEVEcOqwmRN81oDAaaBk0KWGDjJHDdDmFW3AN7I-pux_mHZG\",\n };\n my $data = decode_jwt(token=>$t, key=>$rsa_priv});\n\nExamples with ECC keys:\n\n my $pem_key_string = <<'EOF';\n -----BEGIN EC PRIVATE KEY-----\n MHcCAQEEIBG1c3z52T8XwMsahGVdOZWgKCQJfv+l7djuJjgetdbDoAoGCCqGSM49\n AwEHoUQDQgAEoBUyo8CQAFPeYPvv78ylh5MwFZjTCLQeb042TjiMJxG+9DLFmRSM\n lBQ9T/RsLLc+PmpB1+7yPAR+oR5gZn3kJQ==\n -----END EC PRIVATE KEY-----\n EOF\n\n my $jwk_key_json_string = '{\"kty\":\"EC\",\"crv\":\"P-256\",\"x\":\"MKB..7D4\",\"y\":\"4Et..FyM\"}';\n\n #a reference to SCALAR string with PEM or DER or JSON/JWK data,\n my $data = decode_jwt(token=>$t, key=>\\$pem_key_string);\n my $data = decode_jwt(token=>$t, key=>\\$der_key_string);\n my $data = decode_jwt(token=>$t, key=>\\$jwk_key_json_string);\n\n #instance of Crypt::PK::ECC\n my $data = decode_jwt(token=>$t, key=>Crypt::PK::ECC->new('keyfile.pem'));\n my $data = decode_jwt(token=>$t, key=>Crypt::PK::ECC->new(\\$pem_key_string));\n\n #perl HASH ref with JWK structure (key type 'EC')\n my $ecc_priv = {\n   kty => \"EC\",\n   crv => \"P-256\",\n   x   => \"MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4\",\n   y   => \"4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM\",\n   d   => \"870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE\",\n };\n my $data = decode_jwt(token=>$t, key=>$ecc_priv});\n\n=item keypass\n\nWhen 'key' parameter is an encrypted private RSA or ECC key this optional parameter may contain a password for private key decryption.\n\n=item kid_keys\n\nThis parametes can be either a JWK Set JSON string (see RFC7517) or a perl HASH ref with JWK Set structure like this:\n\n  my $keylist = {\n    keys => [\n      { kid=>\"key1\", kty=>\"oct\", k=>\"GawgguFyGrWKav7AX4VKUg\" },\n      { kid=>\"key2\", kty=>\"oct\", k=>\"ulxLGy4XqhbpkR5ObGh1gX\" },\n    ]\n  };\n  my $payload = decode_jwt(token=>$t, kid_keys=>$keylist);\n\nSince 0.19 we also support:\n\n  use LWP::Simple;\n  my $google_certs = get('https://www.googleapis.com/oauth2/v1/certs');\n  my $payload = decode_jwt(token => $t, kid_keys => $google_certs);\n\nWhen the token header contains C<kid> item the corresponding key is looked up in C<kid_keys> list and used for token\ndecoding (you do not need to pass the explicit key via C<key> parameter).\n\nB<CHANGED in 0.23:> When C<kid_keys> is specified it croaks if token header does not contain C<kid> value or\nif C<kid> was not found in C<kid_keys>.\n\n=item key_from_jwk_header\n\nB<ADDED in 0.23>\n\nC<1> - use C<jwk> header value for validating JWS signature if neither C<key> nor C<kid_keys> specified, B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - ignore C<jwk> header value when validating JWS signature\n\nKeep in mind that enabling C<key_from_jwk_header> requires C<jwk> header to exist and be an valid RSA/ECDSA public key (otherwise it croaks).\n\n=item allow_none\n\nC<1> - accept JWS tokens with C<none> 'alg' header value (which means that token has no signature), B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - do not allow JWS with C<none> 'alg' header value\n\n=item ignore_signature\n\nC<1> - do not check signature on JWS tokens, B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - check signature on JWS tokens\n\n=item accepted_alg\n\nC<undef> (default) means accept all 'alg' algorithms except 'none' (for accepting 'none' use C<allow_none>)\n\nC<string> name of accepted 'alg' algorithm (only one)\n\nC<ARRAY ref> a list of accepted 'alg' algorithms\n\nC<Regexp> that has to match 'alg' algorithm name\n\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>'HS256');\n #or\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>['HS256','HS384']);\n #or\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_alg=>qr/^HS(256|384|512)$/);\n\n=item accepted_enc\n\nC<undef> (default) means accept all 'enc' algorithms\n\nC<string> name of accepted 'enc' algorithm (only one)\n\nC<ARRAY ref> a list of accepted 'enc' algorithms\n\nC<Regexp> that has to match 'enc' algorithm name\n\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>'A192GCM');\n #or\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>['A192GCM','A256GCM']);\n #or\n my $payload = decode_jwt(token=>$t, key=>$k, accepted_enc=>qr/^A(128|192|256)GCM$/);\n\n=item decode_payload\n\nC<0> - do not decode payload, return it as a raw string (octects).\n\nC<1> - decode payload from JSON string, return it as perl hash ref (or array ref) - decode_json failure means fatal error (croak).\n\nC<undef> (default) - if possible decode payload from JSON string, if decode_json fails return payload as a raw string (octets).\n\n=item decode_header\n\nC<0> (default) - do not return decoded header as a return value of decode_jwt()\n\nC<1> - return decoded header as a return value of decode_jwt()\n\n my $payload = decode_jwt(token=>$t, key=>$k);\n #or\n my ($header, $payload) = decode_jwt(token=>$t, key=>$k, decode_header=>1);\n\n=item verify_iss\n\nC<CODE ref> - subroutine (with 'iss' claim value passed as argument) should return C<true> otherwise verification fails\n\nC<Regexp ref> - 'iss' claim value has to match given regexp otherwise verification fails\n\nC<undef> (default) - do not verify 'iss' claim\n\n=item verify_aud\n\nC<CODE ref> - subroutine (with 'aud' claim value passed as argument) should return C<true> otherwise verification fails\n\nC<Regexp ref> - 'aud' claim value has to match given regexp otherwise verification fails\n\nC<undef> (default) - do not verify 'aud' claim\n\n=item verify_sub\n\nC<CODE ref> - subroutine (with 'sub' claim value passed as argument) should return C<true> otherwise verification fails\n\nC<Regexp ref> - 'sub' claim value has to match given regexp otherwise verification fails\n\nC<undef> (default) - do not verify 'sub' claim\n\n=item verify_jti\n\nC<CODE ref> - subroutine (with 'jti' claim value passed as argument) should return C<true> otherwise verification fails\n\nC<Regexp ref> - 'jti' claim value has to match given regexp otherwise verification fails\n\nC<undef> (default) - do not verify 'jti' claim\n\n=item verify_iat\n\nC<undef> - Issued At 'iat' claim must be valid (not in the future) if present\n\nC<0> (default) - ignore 'iat' claim\n\nC<1> - require valid 'iat' claim\n\n=item verify_nbf\n\nC<undef> (default) - Not Before 'nbf' claim must be valid if present\n\nC<0> - ignore 'nbf' claim\n\nC<1> - require valid 'nbf' claim\n\n=item verify_exp\n\nC<undef> (default) - Expiration Time 'exp' claim must be valid if present\n\nC<0> - ignore 'exp' claim\n\nC<1> - require valid 'exp' claim\n\n=item leeway\n\nTolerance in seconds related to C<verify_exp>, C<verify_nbf> and C<verify_iat>. Default is C<0>.\n\n=item ignore_claims\n\nC<1> - do not check claims (iat, exp, nbf, iss, aud, sub, jti), B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - check claims\n\n=back\n\n=head2 encode_jwt\n\n my $token = encode_jwt(%named_args);\n\nNamed arguments:\n\n=over\n\n=item payload\n\nValue of this mandatory parameter can be a string/buffer or HASH ref or ARRAY ref\n\n my $token = encode_jwt(payload=>\"any raw data\", key=>$k, alg=>'HS256');\n #or\n my $token = encode_jwt(payload=>{a=>1,b=>2}, key=>$k, alg=>'HS256');\n #or\n my $token = encode_jwt(payload=>[11,22,33,44], key=>$k, alg=>'HS256');\n\nHASH refs and ARRAY refs payloads are serialized as JSON strings\n\n=item alg\n\nThe 'alg' header value is mandatory for both JWE and JWS tokens.\n\nSupported JWE 'alg' algorithms:\n\n dir\n A128KW\n A192KW\n A256KW\n A128GCMKW\n A192GCMKW\n A256GCMKW\n PBES2-HS256+A128KW\n PBES2-HS384+A192KW\n PBES2-HS512+A256KW\n RSA-OAEP\n RSA-OAEP-256\n RSA1_5\n ECDH-ES+A128KW\n ECDH-ES+A192KW\n ECDH-ES+A256KW\n ECDH-ES\n\nSupported JWS algorithms:\n\n none   ...  no integrity (NOTE: disabled by default)\n HS256  ...  HMAC+SHA256 integrity\n HS384  ...  HMAC+SHA384 integrity\n HS512  ...  HMAC+SHA512 integrity\n RS256  ...  RSA+PKCS1-V1_5 + SHA256 signature\n RS384  ...  RSA+PKCS1-V1_5 + SHA384 signature\n RS512  ...  RSA+PKCS1-V1_5 + SHA512 signature\n PS256  ...  RSA+PSS + SHA256 signature\n PS384  ...  RSA+PSS + SHA384 signature\n PS512  ...  RSA+PSS + SHA512 signature\n ES256  ...  ECDSA + SHA256 signature\n ES384  ...  ECDSA + SHA384 signature\n ES512  ...  ECDSA + SHA512 signature\n\n=item enc\n\nThe 'enc' header is mandatory for JWE tokens.\n\nSupported 'enc' algorithms:\n\n A128GCM\n A192GCM\n A256GCM\n A128CBC-HS256\n A192CBC-HS384\n A256CBC-HS512\n\n=item key\n\nA key used for token encryption (JWE) or token signing (JWS). The value depends on C<alg> token header value.\n\n JWS alg header      key value\n ------------------  ----------------------------------\n none                no key required\n HS256               string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n HS384               dtto\n HS512               dtto\n RS256               private RSA key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     object: Crypt::PK::RSA, Crypt::OpenSSL::RSA, Crypt::X509 or Crypt::OpenSSL::X509\n RS384               private RSA key, see RS256\n RS512               private RSA key, see RS256\n PS256               private RSA key, see RS256\n PS384               private RSA key, see RS256\n PS512               private RSA key, see RS256\n ES256               private ECC key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::ECC\n ES384               private ECC key, see ES256\n ES512               private ECC key, see ES256\n\n JWE alg header      key value\n ------------------  ----------------------------------\n dir                 string (raw octects) or perl HASH ref with JWK, kty=>'oct', length depends on 'enc' algorithm\n A128KW              string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n A192KW              string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n A256KW              string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n A128GCMKW           string (raw octects) 16 bytes (or perl HASH ref with JWK, kty=>'oct')\n A192GCMKW           string (raw octects) 24 bytes (or perl HASH ref with JWK, kty=>'oct')\n A256GCMKW           string (raw octects) 32 bytes (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS256+A128KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS384+A192KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n PBES2-HS512+A256KW  string (raw octects) of any length (or perl HASH ref with JWK, kty=>'oct')\n RSA-OAEP            public RSA key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::RSA or Crypt::OpenSSL::RSA\n RSA-OAEP-256        public RSA key, see RSA-OAEP\n RSA1_5              public RSA key, see RSA-OAEP\n ECDH-ES             public ECC key, perl HASH ref with JWK key structure,\n                     a reference to SCALAR string with PEM or DER or JSON/JWK data,\n                     an instance of Crypt::PK::ECC\n ECDH-ES+A128KW      public ECC key, see ECDH-ES\n ECDH-ES+A192KW      public ECC key, see ECDH-ES\n ECDH-ES+A256KW      public ECC key, see ECDH-ES\n\n=item keypass\n\nWhen 'key' parameter is an encrypted private RSA or ECC key this optional parameter may contain a password for private key decryption.\n\n=item allow_none\n\nC<1> - allow JWS with C<none> 'alg' header value (which means that token has no signature), B<BEWARE: DANGEROUS, UNSECURE!!!>\n\nC<0> (default) - do not allow JWS with C<none> 'alg' header value\n\n=item extra_headers\n\nThis optional parameter may contain a HASH ref with items that will be added to JWT header.\n\nIf you want to use PBES2-based 'alg' like C<PBES2-HS512+A256KW> you can set PBES2 salt len (p2s) in bytes and\niteration count (p2c) via C<extra_headers> like this:\n\n my $token = encode_jwt(payload=>$p, key=>$k, alg=>'PBES2-HS512+A256KW', extra_headers=>{p2c=8000, p2s=>32});\n #NOTE: handling of p2s header is a special case, in the end it is replaced with the generated salt\n\n=item unprotected_headers\n\nA hash with additional integrity unprotected headers - JWS and JWE (not available for C<compact> serialization);\n\n=item shared_unprotected_headers\n\nA hash with additional integrity unprotected headers - JWE only (not available for C<compact> serialization);\n\n=item aad\n\nAdditional Authenticated Data - scalar value with any (even raw octects) data - JWE only (not available for C<compact> serialization);\n\n=item serialization\n\nSpecify serialization method: C<compat> (= default) for Compact JWS/JWE serialization or C<flattened> for Flattened JWS/JWE JSON serialization.\n\nGeneral JSON serialization is not supported yet.\n\n=item zip\n\nCompression method, currently 'deflate' is the only one supported. C<undef> (default) means no compression.\n\n my $token = encode_jwt(payload=>$p, key=>$k, alg=>'HS256', zip=>'deflate');\n #or define compression level\n my $token = encode_jwt(payload=>$p, key=>$k, alg=>'HS256', zip=>['deflate', 9]);\n\n=item auto_iat\n\nC<1> - set 'iat' (Issued At) claim to current time (epoch seconds since 1970) at the moment of token encoding\n\nC<0> (default) - do not set 'iat' claim\n\nNOTE: claims are part of the payload and can be used only if the payload is a HASH ref!\n\n=item relative_exp\n\nSet 'exp' claim (Expiration Time) to current time + C<relative_exp> value (in seconds).\n\nNOTE: claims are part of the payload and can be used only if the payload is a HASH ref!\n\n=item relative_nbf\n\nSet 'nbf' claim (Not Before) to current time + C<relative_nbf> value (in seconds).\n\nNOTE: claims are part of the payload and can be used only if the payload is a HASH ref!\n\n=back\n\n=head1 SEE ALSO\n\nL<Crypt::Cipher::AES>, L<Crypt::AuthEnc::GCM>, L<Crypt::PK::RSA>, L<Crypt::PK::ECC>, L<Crypt::KeyDerivation>, L<Crypt::KeyWrap>\n\n=head1 LICENSE\n\nThis program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.\n\n=head1 COPYRIGHT\n\nCopyright (c) 2015 DCIT, a.s. L<http://www.dcit.cz> / Karel Miko\n", "use strict;\nuse warnings;\n\nuse Test::More tests => 3;\n\nuse_ok('Crypt::KeyWrap');\nuse_ok('Crypt::JWT');\n\nis($Crypt::KeyWrap::VERSION, $Crypt::JWT::VERSION, 'consistent version');\n", "use strict;\nuse warnings;\nuse Test::More;\n\nplan tests => 2;\n\nuse Crypt::JWT qw(encode_jwt decode_jwt);\n\nmy $jws =\n  'eyJqd2siOnsiZSI6IkFRQUIiLCJuIjoieVFJdnpEU3h2a2EzQTNhVFYzS2Yza29PeElWMjNqZGlaa1BkOU8xb3RsN0JYLWZJS2dEYk00QnBHSkxZLUhrTG5aZUxpcXgwSFpKaF94U09IVXhWNnVpLUpIU00yZkFrTnEzMHd4QzMycDZmVDk2b3RuT3ZsTEhPTVVpNEZwUFR0NDVFQmcyemlqRXRfRWNFM3g0OFJjT2ZQVGk3SDBmWnhBdXVYcmJrYmU1SHFqczVxVWp2bDFKWUdKdTA1TlItdnE2NUwyUC1oOFA5eUJBT1pRZjhRMVhBSGg1RlFQd08tQjZ3T1p6aTNjeTEtRUhXZkhpWXpxeTMxWU01ZmxIaFZ4QndWRmUyMUlINEh3WWp2SE5KMURFaEl2R2FSQTBWc09ZNlFqVUxPS19XTVlQVnExc211TmdEZThlZ1V4RnV2R2N4aWJ4NTUydHJkSHVBaWFUVGlRIiwia3R5IjoiUlNBIn0sImFsZyI6IlJTMjU2Iiwibm9uY2UiOm51bGx9.eyJjb250YWN0IjpbIm1haWx0bzpmQGcudGxkIl0sInJlc291cmNlIjoibmV3LXJlZyJ9.wrY6y0kvA3qgR38ZuAA471ygN9fmSHdfWDIayjkBKGmeGbn0f30_LQBC9FiFDFgFJ8Owyy3bOkPWvHx7yhRnP5XnEYdzNtKy4t2LyKq_JSEVQf6p1zycsVaxVLCmZ6ZbRidxIFLhbkcmu2uc4BEVGQQEj3UesccIv-AS2JCQFqK5ca-HQeaLEMntXOz5p7DYZtauYjHuXQ60i25mClm51jScJfP-wk7yYnnohGYKDinwiYlH4Nw8p4yElzWL1dI-U8fiFoxnduGaflPIZ80hkk0p7delrZt3RvmaDdu4cLJ16TgrMw_nMZfbAK0IJXByAsbej78HwIAchdzHyRPmgA';\n\nmy ( $header, $payload ) = decode_jwt( token => $jws, decode_header => 1, key_from_jwk_header => 1 );\n\nis_deeply(\n    $header,\n    {\n        'alg' => 'RS256',\n        'jwk' => {\n            'e'   => 'AQAB',\n            'kty' => 'RSA',\n            'n' =>\n              'yQIvzDSxvka3A3aTV3Kf3koOxIV23jdiZkPd9O1otl7BX-fIKgDbM4BpGJLY-HkLnZeLiqx0HZJh_xSOHUxV6ui-JHSM2fAkNq30wxC32p6fT96otnOvlLHOMUi4FpPTt45EBg2zijEt_EcE3x48RcOfPTi7H0fZxAuuXrbkbe5Hqjs5qUjvl1JYGJu05NR-vq65L2P-h8P9yBAOZQf8Q1XAHh5FQPwO-B6wOZzi3cy1-EHWfHiYzqy31YM5flHhVxBwVFe21IH4HwYjvHNJ1DEhIvGaRA0VsOY6QjULOK_WMYPVq1smuNgDe8egUxFuvGcxibx552trdHuAiaTTiQ'\n        },\n        'nonce' => undef\n    },\n);\n\nis_deeply(\n    $payload,\n    {\n        'contact'  => ['mailto:f@g.tld'],\n        'resource' => 'new-reg'\n    }\n);\n"], "filenames": ["README", "lib/Crypt/JWT.pm", "t/compile.t", "t/jws_no_key.t"], "buggy_code_start_loc": [220, 79, 4, 12], "buggy_code_end_loc": [222, 953, 7, 13], "fixing_code_start_loc": [220, 79, 4, 12], "fixing_code_end_loc": [240, 994, 10, 13], "type": "CWE-347", "message": "Perl Crypt::JWT prior to 0.023 is affected by: Incorrect Access Control. The impact is: allow attackers to bypass authentication by providing a token by crafting with hmac(). The component is: JWT.pm, line 614. The attack vector is: network connectivity. The fixed version is: after commit b98a59b42ded9f9e51b2560410106207c2152d6c.", "other": {"cve": {"id": "CVE-2019-1010263", "sourceIdentifier": "josh@bress.net", "published": "2019-07-17T21:15:10.780", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Perl Crypt::JWT prior to 0.023 is affected by: Incorrect Access Control. The impact is: allow attackers to bypass authentication by providing a token by crafting with hmac(). The component is: JWT.pm, line 614. The attack vector is: network connectivity. The fixed version is: after commit b98a59b42ded9f9e51b2560410106207c2152d6c."}, {"lang": "es", "value": "Perl Crypt::JWT anterior a versi\u00f3n 0.023, est\u00e1 afectado por: Control de Acceso Incorrecto. El impacto es: permitir a los atacantes omitir la autenticaci\u00f3n proporcionando un token para dise\u00f1ar con la funci\u00f3n hmac(). El componente es: el archivo JWT.pm, l\u00ednea 614. El vector de ataque es: conectividad de red. La versi\u00f3n corregida es: despu\u00e9s de commit b98a59b42ded9f9e51b2560410106207c2152d6c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:perl_crypt\\:\\:jwt_project:perl_crypt\\:\\:jwt:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.023", "matchCriteriaId": "59B69497-35F7-4591-8B0D-1F1C62E3811C"}]}]}], "references": [{"url": "https://github.com/DCIT/perl-Crypt-JWT/commit/b98a59b42ded9f9e51b2560410106207c2152d6c", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2018/09/07/1", "source": "josh@bress.net", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DCIT/perl-Crypt-JWT/commit/b98a59b42ded9f9e51b2560410106207c2152d6c"}}