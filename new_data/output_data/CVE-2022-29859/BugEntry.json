{"buggy_code": ["\n#include \"dhcps.h\"\n#include \"tcpip.h\"\n\n//static struct dhcp_server_state dhcp_server_state_machine;\nstatic uint8_t dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n/* recorded the client MAC addr(default sudo mac) */\n//static uint8_t dhcps_record_first_client_mac[6] = {0xff,0xff,0xff,0xff,0xff,0xff};\n/* recorded transaction ID (default sudo id)*/\nstatic uint8_t dhcp_recorded_xid[4] = {0xff, 0xff, 0xff, 0xff}; \n\n/* UDP Protocol Control Block(PCB) */\nstatic struct udp_pcb *dhcps_pcb;\n\nstatic struct ip_addr dhcps_send_broadcast_address;\nstatic struct ip_addr dhcps_local_address;\nstatic struct ip_addr dhcps_pool_start;\nstatic struct ip_addr dhcps_pool_end;\nstatic struct ip_addr dhcps_local_mask;\nstatic struct ip_addr dhcps_local_gateway;\nstatic struct ip_addr dhcps_network_id;\nstatic struct ip_addr dhcps_subnet_broadcast; \nstatic struct ip_addr dhcps_allocated_client_address;\nstatic int dhcps_addr_pool_set = 0;\nstatic struct ip_addr dhcps_addr_pool_start;\nstatic struct ip_addr dhcps_addr_pool_end;\n#if 1\nstatic struct ip_addr dhcps_owned_first_ip;\nstatic struct ip_addr dhcps_owned_last_ip;\nstatic uint8_t dhcps_num_of_available_ips;\n#endif\nstatic struct dhcp_msg *dhcp_message_repository;\nstatic int dhcp_message_total_options_lenth;\n\n/* allocated IP range */  \nstatic struct table  ip_table;\nstatic struct ip_addr client_request_ip;\nstatic uint8_t client_addr[6];\n\nstatic xSemaphoreHandle dhcps_ip_table_semaphore;\n\nstatic struct netif * dhcps_netif = NULL;\n/**\n  * @brief  latch the specific ip in the ip table. \n  * @param  d the specific index\n  * @retval None.\n  */\n#if (!IS_USE_FIXED_IP)\nstatic void mark_ip_in_table(uint8_t d)\n{\n#if (debug_dhcps)   \n  \tprintf(\"\\r\\nmark ip %d\\r\\n\",d);\n#endif\t\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tif (0 < d && d <= 32) {\n\t\tip_table.ip_range[0] = MARK_RANGE1_IP_BIT(ip_table, d);\t\n#if (debug_dhcps)\t\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[0] = 0x%x\\r\\n\",ip_table.ip_range[0]);\n#endif\t\n\t} else if (32 < d && d <= 64) {\n\t  \tip_table.ip_range[1] = MARK_RANGE2_IP_BIT(ip_table, (d - 32));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[1] = 0x%x\\r\\n\",ip_table.ip_range[1]);\n#endif\t\n\t} else if (64 < d && d <= 96) {\n\t\tip_table.ip_range[2] = MARK_RANGE3_IP_BIT(ip_table, (d - 64));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[2] = 0x%x\\r\\n\",ip_table.ip_range[2]);\n#endif\t\n\t} else if (96 < d && d <= 128) {\n\t\tip_table.ip_range[3] = MARK_RANGE4_IP_BIT(ip_table, (d - 96));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[3] = 0x%x\\r\\n\",ip_table.ip_range[3]);\n#endif\t\n\t} else if(128 < d && d <= 160) {\n\t\tip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, d);\t\n#if (debug_dhcps)\t\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[4] = 0x%x\\r\\n\",ip_table.ip_range[4]);\n#endif\t\n\t} else if (160 < d && d <= 192) {\n\t\tip_table.ip_range[5] = MARK_RANGE6_IP_BIT(ip_table, (d - 160));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[5] = 0x%x\\r\\n\",ip_table.ip_range[5]);\n#endif\t\n\t} else if (192 < d && d <= 224) {\n\t\tip_table.ip_range[6] = MARK_RANGE7_IP_BIT(ip_table, (d - 192));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[6] = 0x%x\\r\\n\",ip_table.ip_range[6]);\n#endif\t\n\t} else if (224 < d) {\n\t\tip_table.ip_range[7] = MARK_RANGE8_IP_BIT(ip_table, (d - 224));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[7] = 0x%x\\r\\n\",ip_table.ip_range[7]);\n#endif\t\n\t} else {\n\t\tprintf(\"\\r\\n Request ip over the range(1-128) \\r\\n\");\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n\t\n}\n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\nstatic void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n{\n\tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n\t\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n}\n\nstatic uint8_t check_client_request_ip(struct ip_addr *client_req_ip, uint8_t *hwaddr)\n{\n\tint ip_addr4 = 0, i;\n\n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\t\t\tip4_addr1(client_req_ip), ip4_addr2(client_req_ip), ip4_addr3(client_req_ip), ip4_addr4(client_req_ip),\n\t\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tfor(i=DHCP_POOL_START;i<=DHCP_POOL_END;i++)\n\t{\n\t\t//printf(\"client[%d] = %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\",i,ip_table.client_mac[i][0],ip_table.client_mac[i][0],ip_table.client_mac[i][1],ip_table.client_mac[i][2],ip_table.client_mac[i][3],ip_table.client_mac[i][4],ip_table.client_mac[i][5]);\n\t\tif(memcmp(ip_table.client_mac[i], hwaddr, 6) == 0){\n\t\t\tif((ip_table.ip_range[i/32]>>(i%32-1)) & 1){\n\t\t\t\tip_addr4 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n\n\tif(i == DHCP_POOL_END+1)\n\t\tip_addr4 = 0;\n\nExit:\n\treturn ip_addr4;\n}\nstatic void dump_client_table()\n{\n#if 0\n\tint i;\n\tuint8_t *p = NULL;\n\tprintf(\"\\r\\nip_range: %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x\", \n\t\t\tip_table.ip_range[0], ip_table.ip_range[1], ip_table.ip_range[2], ip_table.ip_range[3],\n\t\t\tip_table.ip_range[4], ip_table.ip_range[5], ip_table.ip_range[6], ip_table.ip_range[7]);\n\tfor(i=1; i<=DHCPS_MAX_CLIENT_NUM; i++)\n\t{\n\t\tp = ip_table.client_mac[i];\n\t\tprintf(\"\\r\\nClient[%d]: %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\",\n\t\t\ti, p[0], p[1], p[2], p[3], p[4], p[5]);\n\t}\n\tprintf(\"\\r\\n\");\n#endif\t\n}\n#endif //CONFIG_DHCPS_KEPT_CLIENT_INFO\n#endif\n\n/**\n  * @brief  get one usable ip from the ip table of dhcp server. \n  * @param: None \n  * @retval the usable index which represent the ip4_addr(ip) of allocated ip addr.\n  */\n#if (!IS_USE_FIXED_IP)\nstatic uint8_t search_next_ip(void)\n{       \n\tuint8_t range_count, offset_count;\n\tuint8_t start, end;\n\tuint8_t max_count;\n\tif(dhcps_addr_pool_set){\n\t\tstart = (uint8_t)ip4_addr4(&dhcps_addr_pool_start);\n\t\tend = (uint8_t)ip4_addr4(&dhcps_addr_pool_end);\n\t}else{\n\t\tstart = 0;\n\t\tend = 255;\n\t}\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tfor (range_count = 0; range_count < (max_count = 8); range_count++) {\n\t\tfor (offset_count = 0;offset_count < 32; offset_count++) {\n\t\t\tif ((((ip_table.ip_range[range_count] >> offset_count) & 0x01) == 0) \n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) >= start)\n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) <= end)) {\n\t\t\t\txSemaphoreGive(dhcps_ip_table_semaphore); \n\t\t\t\treturn ((range_count * 32) + (offset_count + 1));\n\t\t\t}\n\t\t}\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore); \n\treturn 0;\n}\n#endif\n\n/**\n  * @brief  fill in the option field with message type of a dhcp message. \n  * @param  msg_option_base_addr: the addr be filled start.\n  *\t    message_type: the type code you want to fill in \n  * @retval the start addr of the next dhcp option.\n  */\nstatic uint8_t *add_msg_type(uint8_t *msg_option_base_addr, uint8_t message_type)\n{\n\tuint8_t *option_start;\n\tmsg_option_base_addr[0] = DHCP_OPTION_CODE_MSG_TYPE;\n\tmsg_option_base_addr[1] = DHCP_OPTION_LENGTH_ONE;\n\tmsg_option_base_addr[2] = message_type;\n\toption_start = msg_option_base_addr + 3;\n\tif (DHCP_MESSAGE_TYPE_NAK == message_type)\n\t\t*option_start++ = DHCP_OPTION_CODE_END;\t\t\n\treturn option_start;\n}\n\n\nstatic uint8_t *fill_one_option_content(uint8_t *option_base_addr,\n\tuint8_t option_code, uint8_t option_length, void *copy_info)\n{\n\tuint8_t *option_data_base_address;\n\tuint8_t *next_option_start_address = NULL;\n\toption_base_addr[0] = option_code;\n\toption_base_addr[1] = option_length;\n\toption_data_base_address = option_base_addr + 2;\n\tswitch (option_length) {\n\tcase DHCP_OPTION_LENGTH_FOUR:\n\t\tmemcpy(option_data_base_address, copy_info, DHCP_OPTION_LENGTH_FOUR);\n\t\tnext_option_start_address = option_data_base_address + 4;\n\t\tbreak;\n\tcase DHCP_OPTION_LENGTH_TWO:\n\t\tmemcpy(option_data_base_address, copy_info, DHCP_OPTION_LENGTH_TWO);\n\t\tnext_option_start_address = option_data_base_address + 2;\n\t\tbreak;\n\tcase DHCP_OPTION_LENGTH_ONE:\n\t\tmemcpy(option_data_base_address, copy_info, DHCP_OPTION_LENGTH_ONE);\n\t\tnext_option_start_address = option_data_base_address + 1;\n\t\tbreak;\n\t}\n\n\treturn next_option_start_address;\n}\n\n/**\n  * @brief  fill in the needed content of the dhcp offer message. \n  * @param  optptr  the addr which the tail of dhcp magic field. \n  * @retval the addr represent to add the end of option.\n  */\nstatic void add_offer_options(uint8_t *option_start_address)\n{\n\tuint8_t *temp_option_addr;\n\t/* add DHCP options 1. \n\tThe subnet mask option specifies the client's subnet mask */\n\ttemp_option_addr = fill_one_option_content(option_start_address,\n\t\t\tDHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_mask);\n\t\n        /* add DHCP options 3 (i.e router(gateway)). The time server option \n        specifies a list of RFC 868 [6] time servers available to the client. */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\n\n\t/* add DHCP options 6 (i.e DNS). \n        The option specifies a list of DNS servers available to the client. */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_DNS_SERVER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\t\n\t/* add DHCP options 51.\n\tThis option is used to request a lease time for the IP address. */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcp_option_lease_time);\n\t/* add DHCP options 54. \n\tThe identifier is the IP address of the selected server. */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_local_address);\n\t/* add DHCP options 28. \n\tThis option specifies the broadcast address in use on client's subnet.*/\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_subnet_broadcast);\n\t/* add DHCP options 26. \n\tThis option specifies the Maximum transmission unit to use */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,\n\t\t\t\t\t(void *) &dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);\n\t/* add DHCP options 31.\n\tThis option specifies whether or not the client should solicit routers */\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY, DHCP_OPTION_LENGTH_ONE,\n\t\t\t\t\t\t\t\tNULL);\n\t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n\n}\n\n\n/**\n  * @brief  fill in common content of a dhcp message.  \n  * @param  m the pointer which point to the dhcp message store in.\n  * @retval None.\n  */\nstatic void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n{\n     \n        dhcp_message_repository->op = DHCP_MESSAGE_OP_REPLY;\n        dhcp_message_repository->htype = DHCP_MESSAGE_HTYPE;\n        dhcp_message_repository->hlen = DHCP_MESSAGE_HLEN; \n        dhcp_message_repository->hops = 0;\t\t\n        memcpy((char *)dhcp_recorded_xid, (char *) dhcp_message_repository->xid,\n\t\t\t\t\tsizeof(dhcp_message_repository->xid));\n        dhcp_message_repository->secs = 0;\n        dhcp_message_repository->flags = htons(BOOTP_BROADCAST);         \n\n\tmemcpy((char *)dhcp_message_repository->yiaddr,\n\t\t\t(char *)&dhcps_allocated_client_address,\n\t\t\t\tsizeof(dhcp_message_repository->yiaddr));\n        \n\tmemset((char *)dhcp_message_repository->ciaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->ciaddr));\n        memset((char *)dhcp_message_repository->siaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->siaddr));\n        memset((char *)dhcp_message_repository->giaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->giaddr));\n        memset((char *)dhcp_message_repository->sname,  0,\n\t\t\t\t\tsizeof(dhcp_message_repository->sname));\n        memset((char *)dhcp_message_repository->file,   0,\n\t\t\t\t\tsizeof(dhcp_message_repository->file));\n        memset((char *)dhcp_message_repository->options, 0,\n\t\t\t\t\tdhcp_message_total_options_lenth);\n        memcpy((char *)dhcp_message_repository->options, (char *)dhcp_magic_cookie,\n\t\t\t\t\tsizeof(dhcp_magic_cookie));\n}\n\n/**\n  * @brief  init and fill in  the needed content of dhcp offer message.  \n  * @param  packet_buffer packet buffer for UDP.\n  * @retval None.\n  */\nstatic void dhcps_send_offer(struct pbuf *packet_buffer)\n{\n\tuint8_t temp_ip = 0;\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\t\n#if (!IS_USE_FIXED_IP) \t\n\ttemp_ip = check_client_request_ip(&client_request_ip, client_addr);\n\t/* create new client ip */\n\tif(temp_ip == 0)\n\t\ttemp_ip = search_next_ip();\n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n temp_ip = %d\",temp_ip);\n#endif\t\n\tif (temp_ip == 0) {\n#if 0\t\n\t  \tmemset(&ip_table, 0, sizeof(struct table));\n\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n\t\tprintf(\"\\r\\n reset ip table!!\\r\\n\");\t\n#endif\t\n\t\tprintf(\"\\r\\n No useable ip!!!!\\r\\n\");\n\t}\n\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),temp_ip);\n\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip);\n#endif   \n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\tDHCP_MESSAGE_TYPE_OFFER));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t\t&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}\n\n/**\n  * @brief  init and fill in  the needed content of dhcp nak message.  \n  * @param  packet buffer packet buffer for UDP.\n  * @retval None.\n  */\nstatic void dhcps_send_nak(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_msg_type(&dhcp_message_repository->options[4], DHCP_MESSAGE_TYPE_NAK);\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}\n\n/**\n  * @brief  init and fill in  the needed content of dhcp ack message.  \n  * @param  packet buffer packet buffer for UDP.\n  * @retval None.\n  */\nstatic void dhcps_send_ack(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}\n\n/**\n  * @brief  according by the input message type to reflect the correspond state.  \n  * @param  option_message_type the input server state\n  * @retval the server state which already transfer to.\n  */\nuint8_t dhcps_handle_state_machine_change(uint8_t option_message_type)\n{\n\tswitch (option_message_type) {\n\tcase DHCP_MESSAGE_TYPE_DECLINE:\n\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\nget message DHCP_MESSAGE_TYPE_DECLINE\\n\");\n\t\t#endif\n\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\t\tbreak;\n\tcase DHCP_MESSAGE_TYPE_DISCOVER:\n\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\nget message DHCP_MESSAGE_TYPE_DISCOVER\\n\");\n\t\t#endif\n\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE) {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_OFFER;\n\t\t}\n\t\tbreak;\n\tcase DHCP_MESSAGE_TYPE_REQUEST:\n\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n[%d]get message DHCP_MESSAGE_TYPE_REQUEST\\n\", xTaskGetTickCount());\n\t\t#endif\n#if (!IS_USE_FIXED_IP) \t\n#if (debug_dhcps)\n\t\tprintf(\"\\r\\ndhcp_server_state_machine=%d\", dhcp_server_state_machine);\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr2(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr3(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr4(&dhcps_allocated_client_address));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(&client_request_ip),\n\t\t\t\tip4_addr2(&client_request_ip),\n\t\t\t\tip4_addr3(&client_request_ip),\n\t\t\t\tip4_addr4(&client_request_ip));\n#endif\t\t\n\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_OFFER) {\n\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0) { \n\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void *)&client_request_ip, 4) == 0) {  \t\n\t\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t  \t} else {\n\t\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t  \t}\n\t\t\t} else {\n\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}  \n\t\t} else if(dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE){\n\t\t\tuint8_t ip_addr4 = check_client_request_ip(&client_request_ip, client_addr);\n\t\t\tif(ip_addr4 > 0){\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t}else{\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}\n\t\t} else {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#else\t\t\n\t\tif (!(dhcp_server_state_machine == DHCP_SERVER_STATE_ACK ||\n\t\t\tdhcp_server_state_machine == DHCP_SERVER_STATE_NAK)) {\n\t\t        dhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#endif\n\t\tbreak;\n\tcase DHCP_MESSAGE_TYPE_RELEASE:\n\t\tprintf(\"get message DHCP_MESSAGE_TYPE_RELEASE\\n\");\n\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\t\tbreak;\n\t}\n\n\treturn dhcp_server_state_machine;\n}\n/**\n  * @brief  parse the dhcp message option part.\n  * @param  optptr: the addr of the first option field. \n  *         len: the total length of all option fields.          \n  * @retval dhcp server state.\n  */\nstatic uint8_t dhcps_handle_msg_options(uint8_t *option_start, int16_t total_option_length)\n{\n       \n\tint16_t option_message_type = 0;\n\tuint8_t *option_end = option_start + total_option_length;\n\t//dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\n\t/* begin process the dhcp option info */\n\twhile (option_start < option_end) {\t\n\t\tswitch ((uint8_t)*option_start) {\n\t\tcase DHCP_OPTION_CODE_MSG_TYPE: \n\t\t\toption_message_type = *(option_start + 2); // 2 => code(1)+lenth(1)\n\t\t\tbreak;\n\t\tcase DHCP_OPTION_CODE_REQUEST_IP_ADDRESS : \n#if IS_USE_FIXED_IP\n\t\t\tif (memcmp((char *)&dhcps_allocated_client_address,\n\t\t\t\t\t(char *)option_start + 2, 4) == 0)\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\telse \n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n#else                   \t\t\n\t\t\tmemcpy((char *)&client_request_ip, (char *)option_start + 2, 4);\t\n#endif\n\t\t\tbreak;\n\t\t} \n\t\t// calculate the options offset to get next option's base addr\n\t\toption_start += option_start[1] + 2; // optptr[1]: length value + (code(1)+ Len(1))\n\t}\n\treturn dhcps_handle_state_machine_change(option_message_type);        \n}\n\n/**\n  * @brief  get message from buffer then check whether it is dhcp related or not.\n  *         if yes , parse it more to undersatnd the client's request.\n  * @param  same as recv callback function definition\n  * @retval if message is dhcp related then return dhcp server state,\n  *\t    otherwise return 0\n  */\nstatic uint8_t dhcps_check_msg_and_handle_options(struct pbuf *packet_buffer)\n{\n\tint dhcp_message_option_offset;\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcp_message_option_offset = ((int)dhcp_message_repository->options \n\t\t\t\t\t\t- (int)packet_buffer->payload);\n\tdhcp_message_total_options_lenth = (packet_buffer->len \n\t\t\t\t\t\t- dhcp_message_option_offset);\n\tmemcpy(client_addr, dhcp_message_repository->chaddr, 6);\n\t/* check the magic number,if correct parse the content of options */\n\tif (memcmp((char *)dhcp_message_repository->options,\n\t\t(char *)dhcp_magic_cookie, sizeof(dhcp_magic_cookie)) == 0) {\n            \treturn dhcps_handle_msg_options(&dhcp_message_repository->options[4],\n            \t\t\t\t(dhcp_message_total_options_lenth - 4));\n\t}\n        \n\treturn 0;\n}\n\n\n/**\n  * @brief  handle imcoming dhcp message and response message to client \n  * @param  same as recv callback function definition\n  * @retval None\n  */\nstatic void dhcps_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\nstruct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n{\t\n  \tint16_t total_length_of_packet_buffer;\n\tstruct pbuf *merged_packet_buffer = NULL;\n\n\tdhcp_message_repository = (struct dhcp_msg *)udp_packet_buffer->payload;\n\tif (udp_packet_buffer == NULL) {\n\t\tprintf(\"\\n\\r Error!!!! System doesn't allocate any buffer \\n\\r\");\n\t\treturn;  \n\t}\n\tif (sender_port == DHCP_CLIENT_PORT) {\n\t\ttotal_length_of_packet_buffer = udp_packet_buffer->tot_len;\n\t\tif (udp_packet_buffer->next != NULL) {\n\t\t\tmerged_packet_buffer = pbuf_coalesce(udp_packet_buffer,\n\t\t\t\t\t\t\t\tPBUF_TRANSPORT);\n\t\t\tif (merged_packet_buffer->tot_len !=\n\t\t\t\t\t\ttotal_length_of_packet_buffer) {\n\t\t\t\tpbuf_free(udp_packet_buffer);\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tswitch (dhcps_check_msg_and_handle_options(udp_packet_buffer)) {\n\t\tcase  DHCP_SERVER_STATE_OFFER:\n\t\t\t#if (debug_dhcps)\t\n\t\t\tprintf(\"%s DHCP_SERVER_STATE_OFFER\\n\",__func__);\n\t\t\t#endif\n\t\t\tdhcps_send_offer(udp_packet_buffer);\n\t\t\tbreak;\n\t\tcase DHCP_SERVER_STATE_ACK:\n\t\t\t#if (debug_dhcps)\t\n\t\t\tprintf(\"%s DHCP_SERVER_STATE_ACK\\n\",__func__);\n\t\t\t#endif\n\t\t\tdhcps_send_ack(udp_packet_buffer);\n#if (!IS_USE_FIXED_IP)\n\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address)); \t\t\t\n\t#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\t\t\tsave_client_addr(&dhcps_allocated_client_address, client_addr);\n\t\t\tmemset(&client_request_ip, 0, sizeof(client_request_ip));\n\t\t\tmemset(&client_addr, 0, sizeof(client_addr));\n\t\t\tmemset(&dhcps_allocated_client_address, 0, sizeof(dhcps_allocated_client_address));\n\t\t\t#if (debug_dhcps)\t\n\t\t\tdump_client_table();\n\t\t\t#endif\n\t#endif\n#endif\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\t\t\tbreak;\n\t\tcase DHCP_SERVER_STATE_NAK:\n\t\t\t#if (debug_dhcps)\t\n\t\t\tprintf(\"%s DHCP_SERVER_STATE_NAK\\n\",__func__);\n\t\t\t#endif\n\t\t\tdhcps_send_nak(udp_packet_buffer);\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\t\t\tbreak;\n\t\tcase DHCP_OPTION_CODE_END:\n\t\t\t#if (debug_dhcps)\t\n\t\t\tprintf(\"%s DHCP_OPTION_CODE_END\\n\",__func__);\n\t\t\t#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/* free the UDP connection, so we can accept new clients */\n\tudp_disconnect(udp_pcb);\n\n\t/* Free the packet buffer */   \n\tif (merged_packet_buffer != NULL)\n\t\tpbuf_free(merged_packet_buffer);\n\telse \n\t\tpbuf_free(udp_packet_buffer);\n}\n\nvoid dhcps_set_addr_pool(int addr_pool_set, struct ip_addr * addr_pool_start, struct ip_addr *addr_pool_end)\n{\n\t//uint8_t *ip;\n\tif(addr_pool_set){\n\t\tdhcps_addr_pool_set = 1;\n\n\t\tmemcpy(&dhcps_addr_pool_start, addr_pool_start,\n\t\t\t\t\t\t\tsizeof(struct ip_addr));\n\t\t//ip = &dhcps_addr_pool_start;\n\t\t//ip[3] = 100;\n\t\tmemcpy(&dhcps_addr_pool_end, addr_pool_end,\n\t\t\t\t\t\t\tsizeof(struct ip_addr));\n\t\t//ip = &dhcps_addr_pool_end;\n\t\t//ip[3] = 200;\n\t}else{\n\t\tdhcps_addr_pool_set = 0;\n\t}\n}\n/** \n  * @brief  Initialize dhcp server.\n  * @param  None.\n  * @retval None.\n  * Note, for now,we assume the server latch ip 192.168.1.1 and support dynamic \n  *       or fixed IP allocation. \n  */\nvoid dhcps_init(struct netif * pnetif)\n{\t\n\tuint8_t *ip;\n//\tprintf(\"dhcps_init,wlan:%c\\n\\r\",pnetif->name[1]);\n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\tmemset(&ip_table, 0, sizeof(struct table));\n//\tint i = 0;\n//\tfor(i=0; i< DHCPS_MAX_CLIENT_NUM+2; i++)\n//\t\tmemset(ip_table.client_mac[i], 0, 6);\n//\tdump_client_table();\n#endif\n\t\n\tdhcps_netif = pnetif;\n\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\n\tdhcps_pcb = udp_new(); \n\tif (dhcps_pcb == NULL) {\n\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n\t\treturn;\n\t}\n\tIP4_ADDR(&dhcps_send_broadcast_address, 255, 255, 255, 255);\n\t/* get net info from net interface */\n\n\tmemcpy(&dhcps_local_address, &pnetif->ip_addr,\n\t\t\t\t\t\t\tsizeof(struct ip_addr));\n\tmemcpy(&dhcps_local_mask, &pnetif->netmask,\n\t\t\t\t\t\tsizeof(struct ip_addr));\n\n\tmemcpy(&dhcps_local_gateway, &pnetif->gw,\n\t\t\t\t\t\tsizeof(struct ip_addr));\n\n\t/* calculate the usable network ip range */\n\tdhcps_network_id.addr = ((pnetif->ip_addr.addr) &\n\t\t\t\t\t(pnetif->netmask.addr));\n\t\n\tdhcps_subnet_broadcast.addr = ((dhcps_network_id.addr |\n\t\t\t\t\t~(pnetif->netmask.addr)));\n#if 1\n\tdhcps_owned_first_ip.addr = htonl((ntohl(dhcps_network_id.addr) + 1));\n\tdhcps_owned_last_ip.addr = htonl(ntohl(dhcps_subnet_broadcast.addr) - 1);\n\tdhcps_num_of_available_ips = ((ntohl(dhcps_owned_last_ip.addr) \n\t\t\t\t- ntohl(dhcps_owned_first_ip.addr)) + 1); \n#endif\n\n#if CONFIG_EXAMPLE_UART_ATCMD || CONFIG_EXAMPLE_SPI_ATCMD \n#if IP_SOF_BROADCAST\n  dhcps_pcb->so_options|=SOF_BROADCAST;\n#endif /* IP_SOF_BROADCAST */\n#endif\n\n#if IS_USE_FIXED_IP\n\tIP4_ADDR(&dhcps_allocated_client_address, ip4_addr1(&dhcps_local_address)\n\t\t, ip4_addr2(&dhcps_local_address), ip4_addr3(&dhcps_local_address),\n\t\t\t\t\t(ip4_addr4(&dhcps_local_address)) + 1 );\n#else\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\n\tdhcps_ip_table_semaphore = xSemaphoreCreateMutex();\n\n\t//dhcps_ip_table = (struct ip_table *)(pvPortMalloc(sizeof(struct ip_table)));\n\tmemset(&ip_table, 0, sizeof(struct table));\n\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_gateway));\n#if 0\n\tfor (i = 1; i < ip4_addr4(&dhcps_local_address); i++) {\n\t\tmark_ip_in_table(i);\n\t}\n#endif\t\n#endif\n\tif(dhcps_addr_pool_start.addr== 0 && dhcps_addr_pool_end.addr == 0)\n\t{\t\t\n\t\tmemcpy(&dhcps_pool_start,&dhcps_local_address,sizeof(struct ip_addr));\n\t\tip = (uint8_t *)&dhcps_pool_start;\n\t\tip[3] = DHCP_POOL_START;\n\t\tmemcpy(&dhcps_pool_end,&dhcps_local_address,sizeof(struct ip_addr));\n\t\tip = (uint8_t *)&dhcps_pool_end;\n\t\tip[3] = DHCP_POOL_END;\n\t\tdhcps_set_addr_pool(1,&dhcps_pool_start,&dhcps_pool_end);\n\t}\n\tudp_bind(dhcps_pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);\n\tudp_recv(dhcps_pcb, dhcps_receive_udp_packet_handler, NULL);\n}\n\nvoid dhcps_deinit(void)\n{\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\t\t\n}\n", "\n#ifndef __DHCPS_H__\n#define __DHCPS_H__\n\n#include \"lwip/arch.h\"\n#include \"lwip/netif.h\"\n#include \"lwip/udp.h\"\n#include \"lwip/stats.h\"\n#include \"lwip/sys.h\"\n\n#include <platform/platform_stdlib.h>\n\n#define CONFIG_DHCPS_KEPT_CLIENT_INFO\n\n#define DHCP_POOL_START\t\t\t100\n#define DHCP_POOL_END\t\t\t200\n\n#define DHCPS_MAX_CLIENT_NUM \t(DHCP_POOL_END-DHCP_POOL_START+1)\n\n#define IS_USE_FIXED_IP\t0\n#define debug_dhcps 0\n\n/* dhcp server states */\n#define DHCP_SERVER_STATE_OFFER \t\t\t(1)\n#define DHCP_SERVER_STATE_DECLINE \t\t\t(2)\n#define DHCP_SERVER_STATE_ACK \t\t\t\t(3)\n#define DHCP_SERVER_STATE_NAK \t\t\t\t(4)\n#define DHCP_SERVER_STATE_IDLE \t\t\t\t(5)\n\n\n#define BOOTP_BROADCAST \t\t\t\t(0x8000)\n\n#define DHCP_MESSAGE_OP_REQUEST        \t\t\t(1)\n#define DHCP_MESSAGE_OP_REPLY          \t\t\t(2)\n\n#define DHCP_MESSAGE_HTYPE \t\t\t\t(1)\n#define DHCP_MESSAGE_HLEN  \t\t\t\t(6)\n\n#define DHCP_SERVER_PORT  \t\t\t\t(67)\n#define DHCP_CLIENT_PORT  \t\t\t\t(68)\n\n#define DHCP_MESSAGE_TYPE_DISCOVER  \t\t\t(1)\n#define DHCP_MESSAGE_TYPE_OFFER     \t\t\t(2)\n#define DHCP_MESSAGE_TYPE_REQUEST   \t\t\t(3)\n#define DHCP_MESSAGE_TYPE_DECLINE   \t\t\t(4)\n#define DHCP_MESSAGE_TYPE_ACK       \t\t\t(5)\n#define DHCP_MESSAGE_TYPE_NAK       \t\t\t(6)\n#define DHCP_MESSAGE_TYPE_RELEASE   \t\t\t(7)\n\n#define DHCP_OPTION_LENGTH_ONE\t\t\t\t(1)\n#define DHCP_OPTION_LENGTH_TWO\t\t\t\t(2)\n#define DHCP_OPTION_LENGTH_THREE\t\t\t(3)\n#define DHCP_OPTION_LENGTH_FOUR\t\t\t\t(4)\n\n#define DHCP_OPTION_CODE_SUBNET_MASK   \t\t\t(1)\n#define DHCP_OPTION_CODE_ROUTER        \t\t\t(3)\n#define DHCP_OPTION_CODE_DNS_SERVER    \t\t\t(6)\n#define DHCP_OPTION_CODE_INTERFACE_MTU \t\t\t(26)\n#define DHCP_OPTION_CODE_BROADCAST_ADDRESS \t\t(28)\n#define DHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY \t(31)\n#define DHCP_OPTION_CODE_REQUEST_IP_ADDRESS   \t\t(50)\n#define DHCP_OPTION_CODE_LEASE_TIME   \t\t\t(51)\n#define DHCP_OPTION_CODE_MSG_TYPE     \t\t\t(53)\n#define DHCP_OPTION_CODE_SERVER_ID    \t\t\t(54)\n#define DHCP_OPTION_CODE_REQ_LIST     \t\t\t(55)\n#define DHCP_OPTION_CODE_END         \t\t\t(255)\n\n#define IP_FREE_TO_USE\t\t                \t(1)\n#define IP_ALREADY_IN_USE\t                \t(0)\n\n#define HW_ADDRESS_LENGTH\t\t\t\t(6)\n\n/* Reference by RFC 2131 */\nstruct dhcp_msg {\n\tuint8_t op; \t\t/* Message op code/message type. 1 = BOOTREQUEST, 2 = BOOTREPLY */\n\tuint8_t\thtype;\t\t/* Hardware address type */\n\tuint8_t hlen;\t\t/* Hardware address length */\n\tuint8_t hops;\t\t/* Client sets to zero, optionally used by relay agents \n\t\t\t\t   when booting via a relay agent */\n\tuint8_t xid[4];\t\t/* Transaction ID, a random number chosen by the client,\n\t\t\t\t   used by the client and server to associate messages and \n\t\t\t\t   responses between a client and a server */\n\tuint16_t secs;\t\t/* Filled in by client, seconds elapsed since client began address\n\t\t\t\t   acquisition or renewal process.*/\n\tuint16_t flags;\t\t/* bit 0: Broadcast flag, bit 1~15:MBZ must 0*/\n\tuint8_t ciaddr[4];\t/* Client IP address; only filled in if client is in BOUND,\n\t\t\t\t   RENEW or REBINDING state and can respond to ARP requests. */\n\tuint8_t yiaddr[4];\t/* 'your' (client) IP address */\n\tuint8_t siaddr[4];\t/* IP address of next server to use in bootstrap;\n\t\t\t\t   returned in DHCPOFFER, DHCPACK by server. */\n\tuint8_t giaddr[4];\t/* Relay agent IP address, used in booting via a relay agent.*/\n\tuint8_t chaddr[16];\t/* Client hardware address */\n\tuint8_t sname[64];\t/* Optional server host name, null terminated string.*/\n\tuint8_t file[128];\t/* Boot file name, null terminated string; \"generic\" name or\n\t\t\t           null in DHCPDISCOVER, fully qualified directory-path name in DHCPOFFER.*/\n\tuint8_t options[312];   /* Optional parameters field. reference the RFC 2132 */\n};\n\n/* use this to check whether the message is dhcp related or not */\nstatic const uint8_t dhcp_magic_cookie[4] = {99, 130, 83, 99};\nstatic const uint8_t dhcp_option_lease_time[] = {0x00, 0x00, 0x1c, 0x20}; //1 day\n//static const uint8_t dhcp_option_lease_time[] = {0x00, 0x00, 0x0e, 0x10}; // one hour\n//static const uint8_t dhcp_option_interface_mtu_576[] = {0x02, 0x40};\nstatic const uint8_t dhcp_option_interface_mtu[] = {0x05, 0xDC};\n\nstruct table {\n\tuint32_t ip_range[8];\n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\tuint8_t client_mac[256][6];\n#endif\n};\n\nstruct address_pool{\n\tuint32_t start;\n\tuint32_t end;\n};\n\n/* 01~32 */\n#define MARK_RANGE1_IP_BIT(table, ip)\t((table.ip_range[0]) | (1 << ((ip) - 1)))\t \n/* 33~64 */\n#define MARK_RANGE2_IP_BIT(table, ip)\t((table.ip_range[1]) | (1 << ((ip) - 1)))\n/* 65~96 */\n#define MARK_RANGE3_IP_BIT(table, ip)\t((table.ip_range[2]) | (1 << ((ip) - 1)))\n/* 97~128 */\n#define MARK_RANGE4_IP_BIT(table, ip)\t((table.ip_range[3]) | (1 << ((ip) - 1)))\n/* 129~160 */\n#define MARK_RANGE5_IP_BIT(table, ip)\t((table.ip_range[4]) | (1 << ((ip) - 1)))\t \n/* 161~192 */\n#define MARK_RANGE6_IP_BIT(table, ip)\t((table.ip_range[5]) | (1 << ((ip) - 1)))\n/* 193~224 */\n#define MARK_RANGE7_IP_BIT(table, ip)\t((table.ip_range[6]) | (1 << ((ip) - 1)))\n/* 225~255 */\n#define MARK_RANGE8_IP_BIT(table, ip)\t((table.ip_range[7]) | (1 << ((ip) - 1)))\n\n/* expose API */\nvoid dhcps_set_addr_pool(int addr_pool_set, struct ip_addr * addr_pool_start, struct ip_addr *addr_pool_end);\nvoid dhcps_init(struct netif * pnetif);\nvoid dhcps_deinit(void);\n\nextern struct netif *netif_default;\n\n#endif\n"], "fixing_code": ["\n#include \"dhcps.h\"\n#include \"tcpip.h\"\n#include \"wifi_constants.h\"\nextern rtw_mode_t wifi_mode;\n//static struct dhcp_server_state dhcp_server_state_machine;\nstatic uint8_t dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n/* recorded the client MAC addr(default sudo mac) */\n//static uint8_t dhcps_record_first_client_mac[6] = {0xff,0xff,0xff,0xff,0xff,0xff};\n/* recorded transaction ID (default sudo id)*/\nstatic uint8_t dhcp_recorded_xid[4] = {0xff, 0xff, 0xff, 0xff}; \n\n/* UDP Protocol Control Block(PCB) */\nstatic struct udp_pcb *dhcps_pcb;\nstatic struct udp_pcb *dns_server_pcb;\n\nstatic struct ip_addr dhcps_send_broadcast_address;\nstatic struct ip_addr dhcps_local_address;\nstatic struct ip_addr dhcps_pool_start;\nstatic struct ip_addr dhcps_pool_end;\nstatic struct ip_addr dhcps_local_mask;\nstatic struct ip_addr dhcps_local_gateway;\nstatic struct ip_addr dhcps_network_id;\nstatic struct ip_addr dhcps_subnet_broadcast; \nstatic struct eth_addr dhcps_allocated_client_ethaddr;\nstatic struct ip_addr dhcps_allocated_client_address;\nstatic int dhcps_addr_pool_set = 0;\nstatic struct ip_addr dhcps_addr_pool_start;\nstatic struct ip_addr dhcps_addr_pool_end;\n#if 1\nstatic struct ip_addr dhcps_owned_first_ip;\nstatic struct ip_addr dhcps_owned_last_ip;\nstatic uint8_t dhcps_num_of_available_ips;\n#endif\nstatic struct dhcp_msg *dhcp_message_repository;\nstatic int dhcp_message_total_options_lenth;\n\n/* allocated IP range */  \nstatic struct table  ip_table;\nstatic struct ip_addr client_request_ip;\nstatic uint8_t client_addr[6];\n\nstatic xSemaphoreHandle dhcps_ip_table_semaphore;\n\nstatic struct netif * dhcps_netif = NULL;\n/**\n  * @brief  latch the specific ip in the ip table. \n  * @param  d the specific index\n  * @retval None.\n  */\n#if (!IS_USE_FIXED_IP)\nstatic void mark_ip_in_table(uint8_t d)\n{\n#if (debug_dhcps)   \n  \tprintf(\"\\r\\nmark ip %d\\r\\n\",d);\n#endif\t\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tif (0 < d && d <= 32) {\n\t\tip_table.ip_range[0] = MARK_RANGE1_IP_BIT(ip_table, d);\t\n#if (debug_dhcps)\t\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[0] = 0x%x\\r\\n\",ip_table.ip_range[0]);\n#endif\t\n\t} else if (32 < d && d <= 64) {\n\t  \tip_table.ip_range[1] = MARK_RANGE2_IP_BIT(ip_table, (d - 32));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[1] = 0x%x\\r\\n\",ip_table.ip_range[1]);\n#endif\t\n\t} else if (64 < d && d <= 96) {\n\t\tip_table.ip_range[2] = MARK_RANGE3_IP_BIT(ip_table, (d - 64));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[2] = 0x%x\\r\\n\",ip_table.ip_range[2]);\n#endif\t\n\t} else if (96 < d && d <= 128) {\n\t\tip_table.ip_range[3] = MARK_RANGE4_IP_BIT(ip_table, (d - 96));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[3] = 0x%x\\r\\n\",ip_table.ip_range[3]);\n#endif\t\n\t} else if(128 < d && d <= 160) {\n\t\tip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, (d - 128));\t\n#if (debug_dhcps)\t\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[4] = 0x%x\\r\\n\",ip_table.ip_range[4]);\n#endif\t\n\t} else if (160 < d && d <= 192) {\n\t\tip_table.ip_range[5] = MARK_RANGE6_IP_BIT(ip_table, (d - 160));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[5] = 0x%x\\r\\n\",ip_table.ip_range[5]);\n#endif\t\n\t} else if (192 < d && d <= 224) {\n\t\tip_table.ip_range[6] = MARK_RANGE7_IP_BIT(ip_table, (d - 192));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[6] = 0x%x\\r\\n\",ip_table.ip_range[6]);\n#endif\t\n\t} else if (224 < d) {\n\t\tip_table.ip_range[7] = MARK_RANGE8_IP_BIT(ip_table, (d - 224));\n#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n ip_table.ip_range[7] = 0x%x\\r\\n\",ip_table.ip_range[7]);\n#endif\t\n\t} else {\n\t\tprintf(\"\\r\\n Request ip over the range(1-128) \\r\\n\");\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n\t\n}\n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\nstatic void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n{\n#if LWIP_VERSION_MAJOR >= 2\n\tuint8_t d = (uint8_t)ip4_addr4(ip_2_ip4(client_ip));\n#else\n\tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n#endif\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n#if (debug_dhcps)\t\n#if LWIP_VERSION_MAJOR >= 2\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", __func__,\n\t\tip4_addr1(ip_2_ip4(client_ip)), ip4_addr2(ip_2_ip4(client_ip)), ip4_addr3(ip_2_ip4(client_ip)), ip4_addr4(ip_2_ip4(client_ip)),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#else\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", __func__,\n\t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\n#endif\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n}\n\nstatic uint8_t check_client_request_ip(struct ip_addr *client_req_ip, uint8_t *hwaddr)\n{\n\tint ip_addr4 = 0, i;\n\n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\t\t\tip4_addr1(client_req_ip), ip4_addr2(client_req_ip), ip4_addr3(client_req_ip), ip4_addr4(client_req_ip),\n\t\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tfor(i=DHCP_POOL_START;i<=DHCP_POOL_END;i++)\n\t{\n\t\t//printf(\"client[%d] = %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\",i,ip_table.client_mac[i][0],ip_table.client_mac[i][0],ip_table.client_mac[i][1],ip_table.client_mac[i][2],ip_table.client_mac[i][3],ip_table.client_mac[i][4],ip_table.client_mac[i][5]);\n\t\tif(memcmp(ip_table.client_mac[i], hwaddr, 6) == 0){\n\t\t\tif((ip_table.ip_range[i/32]>>(i%32-1)) & 1){\n\t\t\t\tip_addr4 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n\n\tif(i == DHCP_POOL_END+1)\n\t\tip_addr4 = 0;\n\nExit:\n\treturn ip_addr4;\n}\n\nstatic uint8_t check_client_direct_request_ip(struct ip_addr *client_req_ip, uint8_t *hwaddr)\n{\n\tint ip_addr4 = 0, i;\n\n#if (debug_dhcps)\t\n#if LWIP_VERSION_MAJOR >= 2\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", __func__,\n\t\t\tip4_addr1(ip_2_ip4(client_req_ip)), ip4_addr2(ip_2_ip4(client_req_ip)), ip4_addr3(ip_2_ip4(client_req_ip)), ip4_addr4(ip_2_ip4(client_req_ip)),\n\t\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#else\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", __func__,\n\t\t\tip4_addr1(client_req_ip), ip4_addr2(client_req_ip), ip4_addr3(client_req_ip), ip4_addr4(client_req_ip),\n\t\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n#endif\n\n#if LWIP_VERSION_MAJOR >= 2\n\tif( (ip4_addr1(ip_2_ip4(&dhcps_network_id)) != ip4_addr1(ip_2_ip4(client_req_ip))) ||\n\t\t(ip4_addr2(ip_2_ip4(&dhcps_network_id)) != ip4_addr2(ip_2_ip4(client_req_ip))) ||\n\t\t(ip4_addr3(ip_2_ip4(&dhcps_network_id)) != ip4_addr3(ip_2_ip4(client_req_ip))))\n#else\n\tif( (ip4_addr1(&dhcps_network_id) != ip4_addr1(client_req_ip)) ||\n\t\t(ip4_addr2(&dhcps_network_id) != ip4_addr2(client_req_ip)) ||\n\t\t(ip4_addr3(&dhcps_network_id) != ip4_addr3(client_req_ip)))\n#endif\n\n\t{\n\t\tip_addr4 = 0;\n\t\tgoto Exit;\n\t}\n\n\t// check if the requested ip is available\n#if LWIP_VERSION_MAJOR >= 2\n\tip_addr4 = ip4_addr4(ip_2_ip4(client_req_ip));\n#else\n\tip_addr4 = ip4_addr4(client_req_ip);\n#endif\n\n\tif (ip_addr4 < DHCP_POOL_START || ip_addr4 > DHCP_POOL_END) {\n\t\tip_addr4 = 0;\n\t\tgoto Exit;\n\t}\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tprintf(\"ip_table[%d] = %x,%x,%x,%x,%x,%x\\n\",ip_addr4,ip_table.client_mac[ip_addr4][0],\n\t\t\t\t\t\t\t\t\t\t  \t\t\t     ip_table.client_mac[ip_addr4][1],\n\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][2],\n\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][3],\n\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][4],\n\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][5]);\n\tif(\t(\tip_table.client_mac[ip_addr4][0] == 0 &&\n\t\t\tip_table.client_mac[ip_addr4][1] == 0 &&\n\t\t\tip_table.client_mac[ip_addr4][2] == 0 &&\n\t\t\tip_table.client_mac[ip_addr4][3] == 0 &&\n\t\t\tip_table.client_mac[ip_addr4][4] == 0 &&\n\t\t\tip_table.client_mac[ip_addr4][5] == 0) ||\n\t\t(\tip_table.client_mac[ip_addr4][0] == hwaddr[0] &&\n\t\t\tip_table.client_mac[ip_addr4][1] == hwaddr[1] &&\n\t\t\tip_table.client_mac[ip_addr4][2] == hwaddr[2] &&\n\t\t\tip_table.client_mac[ip_addr4][3] == hwaddr[3] &&\n\t\t\tip_table.client_mac[ip_addr4][4] == hwaddr[4] &&\n\t\t\tip_table.client_mac[ip_addr4][5] == hwaddr[5]))\n\t{\n\t\t// the ip is available or already allocated to this client\n\t}\n\telse\n\t{\n\t\tip_addr4 = 0; // the ip is used\n\t}\n\t\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n\nExit:\n\treturn ip_addr4;\n}\n\nstatic void dump_client_table()\n{\n#if 0\n\tint i;\n\tuint8_t *p = NULL;\n\tprintf(\"\\r\\nip_range: %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x\", \n\t\t\tip_table.ip_range[0], ip_table.ip_range[1], ip_table.ip_range[2], ip_table.ip_range[3],\n\t\t\tip_table.ip_range[4], ip_table.ip_range[5], ip_table.ip_range[6], ip_table.ip_range[7]);\n\tfor(i=1; i<=DHCPS_MAX_CLIENT_NUM; i++)\n\t{\n\t\tp = ip_table.client_mac[i];\n\t\tprintf(\"\\r\\nClient[%d]: %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\",\n\t\t\ti, p[0], p[1], p[2], p[3], p[4], p[5]);\n\t}\n\tprintf(\"\\r\\n\");\n#endif\t\n}\n#endif //CONFIG_DHCPS_KEPT_CLIENT_INFO\n#endif\n\n/**\n  * @brief  get one usable ip from the ip table of dhcp server. \n  * @param: None \n  * @retval the usable index which represent the ip4_addr(ip) of allocated ip addr.\n  */\n#if (!IS_USE_FIXED_IP)\nstatic uint8_t search_next_ip(void)\n{       \n\tuint8_t range_count, offset_count;\n\tuint8_t start, end;\n\tuint8_t max_count;\n\tif(dhcps_addr_pool_set){\n#if LWIP_VERSION_MAJOR >= 2\n\t\tstart = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_start));\n\t\tend = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_end));\n#else\n\t\tstart = (uint8_t)ip4_addr4(&dhcps_addr_pool_start);\n\t\tend = (uint8_t)ip4_addr4(&dhcps_addr_pool_end);\n#endif\n\n\t}else{\n\t\tstart = 0;\n\t\tend = 255;\n\t}\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tfor (range_count = 0; range_count < (max_count = 8); range_count++) {\n\t\tfor (offset_count = 0;offset_count < 32; offset_count++) {\n\t\t\tif ((((ip_table.ip_range[range_count] >> offset_count) & 0x01) == 0) \n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) >= start)\n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) <= end)) {\n\t\t\t\txSemaphoreGive(dhcps_ip_table_semaphore); \n\t\t\t\treturn ((range_count * 32) + (offset_count + 1));\n\t\t\t}\n\t\t}\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore); \n\treturn 0;\n}\n#endif\n\n/**\n  * @brief  fill in the option field with message type of a dhcp message. \n  * @param  msg_option_base_addr: the addr be filled start.\n  *\t    message_type: the type code you want to fill in \n  * @retval the start addr of the next dhcp option.\n  */\nstatic uint8_t *add_msg_type(uint8_t *msg_option_base_addr, uint8_t message_type)\n{\n\tuint8_t *option_start;\n\tmsg_option_base_addr[0] = DHCP_OPTION_CODE_MSG_TYPE;\n\tmsg_option_base_addr[1] = DHCP_OPTION_LENGTH_ONE;\n\tmsg_option_base_addr[2] = message_type;\n\toption_start = msg_option_base_addr + 3;\n\tif (DHCP_MESSAGE_TYPE_NAK == message_type)\n\t\t*option_start++ = DHCP_OPTION_CODE_END;\t\t\n\treturn option_start;\n}\n\n\nstatic uint8_t *fill_one_option_content(uint8_t *option_base_addr,\n\tuint8_t option_code, uint8_t option_length, void *copy_info)\n{\n\tuint8_t *option_data_base_address;\n\tuint8_t *next_option_start_address = NULL;\n\toption_base_addr[0] = option_code;\n\toption_base_addr[1] = option_length;\n\toption_data_base_address = option_base_addr + 2;\n\tswitch (option_length) {\n\tcase DHCP_OPTION_LENGTH_FOUR:\n\t\tmemcpy(option_data_base_address, copy_info, DHCP_OPTION_LENGTH_FOUR);\n\t\tnext_option_start_address = option_data_base_address + 4;\n\t\tbreak;\n\tcase DHCP_OPTION_LENGTH_TWO:\n\t\tmemcpy(option_data_base_address, copy_info, DHCP_OPTION_LENGTH_TWO);\n\t\tnext_option_start_address = option_data_base_address + 2;\n\t\tbreak;\n\tcase DHCP_OPTION_LENGTH_ONE:\n\t\tmemcpy(option_data_base_address, copy_info, DHCP_OPTION_LENGTH_ONE);\n\t\tnext_option_start_address = option_data_base_address + 1;\n\t\tbreak;\n\t}\n\n\treturn next_option_start_address;\n}\n\n/**\n  * @brief  fill in the needed content of the dhcp offer message. \n  * @param  optptr  the addr which the tail of dhcp magic field. \n  * @retval\t0, add ok\n  *\t\t\t-1, add fail\n  */\nstatic int8_t add_offer_options(uint8_t *option_start_address)\n{\n\t// Total minimum len = 6+6+6+6+6+6+4+3+1 = 44\n\tuint8_t *temp_option_addr = option_start_address;\n\tint max_addable_option_len = dhcp_message_total_options_lenth - 4 - 3;\t// -magic-type\n\n\tif(option_start_address == NULL)\n\t\tgoto ERROR;\n\n\t/* add DHCP options 1. \n\tThe subnet mask option specifies the client's subnet mask */\n\tif(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n\t\ttemp_option_addr = fill_one_option_content(option_start_address, DHCP_OPTION_CODE_SUBNET_MASK,\n\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR,(void *)&dhcps_local_mask);\n\t}else{\n\t\tgoto ERROR;\n\t}\n\t\n        /* add DHCP options 3 (i.e router(gateway)). The time server option \n        specifies a list of RFC 868 [6] time servers available to the client. */\n        if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_ROUTER,\n\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\n\t}else{\n\t\tgoto ERROR;\n\t}\n\n\t/* add DHCP options 6 (i.e DNS). \n        The option specifies a list of DNS servers available to the client. */\n\t if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n\t \ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_DNS_SERVER,\n\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\t\n\t}else{\n\t\tgoto ERROR;\n\t}\n\t\n\t/* add DHCP options 51.\n\tThis option is used to request a lease time for the IP address. */\n\t if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_LEASE_TIME,\n\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcp_option_lease_time);\n\t}else{\n\t\tgoto ERROR;\n\t}\n\t\n\t/* add DHCP options 54. \n\tThe identifier is the IP address of the selected server. */\n\t if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_SERVER_ID,\n\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\n\t}else{\n\t\tgoto ERROR;\n\t}\n\t\n\t/* add DHCP options 28. \n\tThis option specifies the broadcast address in use on client's subnet.*/\n\tif(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_BROADCAST_ADDRESS,\n\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_subnet_broadcast);\n\t}else{\n\t\tgoto ERROR;\n\t}\n\t\n\t/* add DHCP options 26. \n\tThis option specifies the Maximum transmission unit to use */\n\tif(temp_option_addr + 4 -option_start_address <= max_addable_option_len) {\n\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_INTERFACE_MTU,\n\t\t\t\t\t\tDHCP_OPTION_LENGTH_TWO, (void *) &dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);\n\t}else{\n\t\tgoto ERROR;\n\t}\n\t\n\t/* add DHCP options 31.\n\tThis option specifies whether or not the client should solicit routers */\n\tif(temp_option_addr + 3 -option_start_address <= max_addable_option_len) {\n\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY,\n\t\t\t\t\t\tDHCP_OPTION_LENGTH_ONE,\tNULL);\n\t}else{\n\t\tgoto ERROR;\n\t}\n\n\t// END\n\tif(temp_option_addr + 1 -option_start_address <= max_addable_option_len) {\n\t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n\t}else{\n\t\tgoto ERROR;\n\t}\n\treturn 0;\n\nERROR:\n\tprintf(\"\\r\\n[%s] error: add options fail !!\", __func__);\n\treturn -1;\n}\n\n\n/**\n  * @brief  fill in common content of a dhcp message.  \n  * @param  m the pointer which point to the dhcp message store in.\n  * @retval None.\n  */\nstatic void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n{\n     \n        dhcp_message_repository->op = DHCP_MESSAGE_OP_REPLY;\n        dhcp_message_repository->htype = DHCP_MESSAGE_HTYPE;\n        dhcp_message_repository->hlen = DHCP_MESSAGE_HLEN; \n        dhcp_message_repository->hops = 0;\t\t\n        memcpy((char *)dhcp_recorded_xid, (char *) dhcp_message_repository->xid,\n\t\t\t\t\tsizeof(dhcp_message_repository->xid));\n        dhcp_message_repository->secs = 0;\n\n\tmemcpy((char *)dhcp_message_repository->yiaddr,\n\t\t\t(char *)&dhcps_allocated_client_address,\n\t\t\t\tsizeof(dhcp_message_repository->yiaddr));\n        \n\tmemset((char *)dhcp_message_repository->ciaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->ciaddr));\n        memset((char *)dhcp_message_repository->siaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->siaddr));\n        memset((char *)dhcp_message_repository->giaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->giaddr));\n        memset((char *)dhcp_message_repository->sname,  0,\n\t\t\t\t\tsizeof(dhcp_message_repository->sname));\n        memset((char *)dhcp_message_repository->file,   0,\n\t\t\t\t\tsizeof(dhcp_message_repository->file));\n        memset((char *)dhcp_message_repository->options, 0,\n\t\t\t\t\tdhcp_message_total_options_lenth);\n        memcpy((char *)dhcp_message_repository->options, (char *)dhcp_magic_cookie,\n\t\t\t\t\tsizeof(dhcp_magic_cookie));\n}\n\n/**\n  * @brief  init and fill in  the needed content of dhcp offer message.  \n  * @param  packet_buffer packet buffer for UDP.\n  * @retval None.\n  */\nstatic void dhcps_send_offer(struct pbuf *packet_buffer)\n{\n\tuint8_t temp_ip = 0;\n\tstruct pbuf *newly_malloc_packet_buffer = NULL;\n\n\t// newly malloc a longer pbuf for dhcp offer rather than using the short pbuf from dhcp discover\n\tnewly_malloc_packet_buffer = pbuf_alloc(PBUF_TRANSPORT, DHCP_MSG_LEN + DHCP_OPTION_TOTAL_LENGTH_MAX, PBUF_RAM);\n\tif(newly_malloc_packet_buffer == NULL)\n\t{\n\t\tprintf(\"\\r\\n[%s] error:  pbuf alloc fail !\", __func__);\n\t\treturn;\n\t}\n\tif(pbuf_copy(newly_malloc_packet_buffer, packet_buffer) != ERR_OK)\n\t{\n\t\tprintf(\"\\r\\n[%s] error:  pbuf copy fail !\", __func__);\n\t\tpbuf_free(newly_malloc_packet_buffer);\t\n\t\treturn;\n\t}\t\n\tdhcp_message_total_options_lenth = DHCP_OPTION_TOTAL_LENGTH_MAX;\n\tdhcp_message_repository = (struct dhcp_msg *)newly_malloc_packet_buffer->payload;\t\n#if (!IS_USE_FIXED_IP) \n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\ttemp_ip = check_client_request_ip(&client_request_ip, client_addr);\n#endif\n\t/* create new client ip */\n\tif(temp_ip == 0)\n\t\ttemp_ip = search_next_ip();\n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n temp_ip = %d\",temp_ip);\n#endif\t\n\tif (temp_ip == 0) {\n#if 0\t\n\t  \tmemset(&ip_table, 0, sizeof(struct table));\n\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n\t\tprintf(\"\\r\\n reset ip table!!\\r\\n\");\t\n#endif\t\n\t\tprintf(\"\\r\\n No useable ip!!!!\\r\\n\");\n\t}\n#if LWIP_VERSION_MAJOR >= 2\n\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", \\\n\t\t\txTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)), \\\n\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), \\\n\t\t\tip4_addr3(ip_2_ip4(&dhcps_network_id)), temp_ip, \\\n\t\t\tclient_addr[0], client_addr[1], client_addr[2], \\\n\t\t\tclient_addr[3], client_addr[4], client_addr[5]);\n\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), temp_ip);\n#else\n\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", \\\n\t\t\txTaskGetTickCount(), ip4_addr1(&dhcps_network_id), \\\n\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip, \\\n\t\t\tclient_addr[0], client_addr[1], client_addr[2], \\\n\t\t\tclient_addr[3], client_addr[4], client_addr[5]);\n\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip);\n#endif\n\n#endif   \n\tdhcps_initialize_message(dhcp_message_repository);\n\tif(add_offer_options(add_msg_type(&dhcp_message_repository->options[4], DHCP_MESSAGE_TYPE_OFFER)) == 0){\n\t\tif(dhcp_message_repository->flags == 0x0){\n\t\t\t// unicast\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t\tdhcps_allocated_client_ethaddr.addr[i] = dhcp_message_repository->chaddr[i];\n#if ETHARP_SUPPORT_STATIC_ENTRIES\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\tetharp_add_static_entry(ip_2_ip4(&dhcps_allocated_client_address), &dhcps_allocated_client_ethaddr);\n#else\n\t\t\t\tetharp_add_static_entry(&dhcps_allocated_client_address, &dhcps_allocated_client_ethaddr);\n#endif\n#endif\n\t\t\t\tudp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_allocated_client_address, DHCP_CLIENT_PORT, dhcps_netif);\n#if ETHARP_SUPPORT_STATIC_ENTRIES\t\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\tetharp_remove_static_entry(ip_2_ip4(&dhcps_allocated_client_address));\n#else\n\t\t\t\tetharp_remove_static_entry(&dhcps_allocated_client_address);\n#endif\n#endif\n\n\t\t}\n\t\telse\n\t\t\t// broadcast\n\t\t\tudp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n\t}\n\n\tpbuf_free(newly_malloc_packet_buffer);\t\n}\n\n/**\n  * @brief  init and fill in  the needed content of dhcp nak message.  \n  * @param  packet buffer packet buffer for UDP.\n  * @retval None.\n  */\nstatic void dhcps_send_nak(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_msg_type(&dhcp_message_repository->options[4], DHCP_MESSAGE_TYPE_NAK);\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}\n\n/**\n  * @brief  init and fill in  the needed content of dhcp ack message.  \n  * @param  packet buffer packet buffer for UDP.\n  * @retval None.\n  */\nstatic void dhcps_send_ack(struct pbuf *packet_buffer)\n{\n\tstruct pbuf *newly_malloc_packet_buffer = NULL;\n\n\t// newly malloc a longer pbuf for dhcp ack rather than using the short pbuf from dhcp request\n\tnewly_malloc_packet_buffer = pbuf_alloc(PBUF_TRANSPORT, DHCP_MSG_LEN + DHCP_OPTION_TOTAL_LENGTH_MAX, PBUF_RAM);\n\tif(newly_malloc_packet_buffer == NULL)\n\t{\n\t\tprintf(\"\\r\\n[%s] error:  pbuf alloc fail !\", __func__);\n\t\treturn;\n\t}\n\tif(pbuf_copy(newly_malloc_packet_buffer, packet_buffer) != ERR_OK)\n\t{\n\t\tprintf(\"\\r\\n[%s] error:  pbuf copy fail !\", __func__);\n\t\tpbuf_free(newly_malloc_packet_buffer);\t\n\t\treturn;\n\t}\t\n\tdhcp_message_total_options_lenth = DHCP_OPTION_TOTAL_LENGTH_MAX;\n\tdhcp_message_repository = (struct dhcp_msg *)newly_malloc_packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tif(add_offer_options(add_msg_type(&dhcp_message_repository->options[4], DHCP_MESSAGE_TYPE_ACK)) == 0){\n\t\tif(dhcp_message_repository->flags == 0x0){\n\t\t\t// unicast\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t\tdhcps_allocated_client_ethaddr.addr[i] = dhcp_message_repository->chaddr[i];\n#if ETHARP_SUPPORT_STATIC_ENTRIES\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\tetharp_add_static_entry(ip_2_ip4(&dhcps_allocated_client_address), &dhcps_allocated_client_ethaddr);\n#else\n\t\t\tetharp_add_static_entry(&dhcps_allocated_client_address, &dhcps_allocated_client_ethaddr);\n#endif\n#endif\n\t\t\tudp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_allocated_client_address, DHCP_CLIENT_PORT, dhcps_netif);\n#if ETHARP_SUPPORT_STATIC_ENTRIES\t\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\tetharp_remove_static_entry(ip_2_ip4(&dhcps_allocated_client_address));\n#else\n\t\t\tetharp_remove_static_entry(&dhcps_allocated_client_address);\n#endif\n#endif\n\t\t}\n\t\telse\n\t\t\t// broadcast\n\t\t\tudp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n\t}\n\tpbuf_free(newly_malloc_packet_buffer);\n}\n\n/**\n  * @brief  according by the input message type to reflect the correspond state.  \n  * @param  option_message_type the input server state\n  * @retval the server state which already transfer to.\n  */\nuint8_t dhcps_handle_state_machine_change(uint8_t option_message_type)\n{\n\tswitch (option_message_type) {\n\tcase DHCP_MESSAGE_TYPE_DECLINE:\n\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\nget message DHCP_MESSAGE_TYPE_DECLINE\\n\");\n\t\t#endif\n\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\t\tbreak;\n\tcase DHCP_MESSAGE_TYPE_DISCOVER:\n\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\nget message DHCP_MESSAGE_TYPE_DISCOVER\\n\");\n\t\t#endif\n\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE) {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_OFFER;\n\t\t}\n\t\tbreak;\n\tcase DHCP_MESSAGE_TYPE_REQUEST:\n\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n[%d]get message DHCP_MESSAGE_TYPE_REQUEST\\n\", xTaskGetTickCount());\n\t\t#endif\n#if (!IS_USE_FIXED_IP) \t\n#if (debug_dhcps)\n\t\tprintf(\"\\r\\ndhcp_server_state_machine=%d\", dhcp_server_state_machine);\n#if LWIP_VERSION_MAJOR >= 2\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr3(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr2(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr3(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr4(ip_2_ip4(&client_request_ip)));\n#else\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr2(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr3(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr4(&dhcps_allocated_client_address));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(&client_request_ip),\n\t\t\t\tip4_addr2(&client_request_ip),\n\t\t\t\tip4_addr3(&client_request_ip),\n\t\t\t\tip4_addr4(&client_request_ip));\n#endif\n\n#endif\t\t\n\n\t\t// for renew\n\t\tif((*(uint32_t *) dhcp_message_repository->ciaddr != 0) && (*(uint32_t *)&client_request_ip == 0)) {\n\t\t\tmemcpy(&client_request_ip, dhcp_message_repository->ciaddr, sizeof(client_request_ip));\n\t\t}\n\n\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_OFFER) {\n\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip, client_addr);\n\n\t\t\tif(ip_addr4 > 0){\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), ip_addr4);\n#else\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n#endif\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t\tbreak;\n\t\t\t}\n\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\tif (ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)) != 0) \n#else\n\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0) \n#endif \n\t\t\t{ \n\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void *)&client_request_ip, 4) == 0) {  \n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n#else\n\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip4_addr4(&dhcps_allocated_client_address));\n#endif\n\t\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t  \t} else {\n\t\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t  \t}\n\t\t\t} else {\n\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}  \n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\t\t} else if(dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE){\n\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip, client_addr);\n\n\t\t\tif(ip_addr4 > 0){\t\t\t\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), ip_addr4);\n#else\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n#endif\n\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t}else{\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#else\t\t\n\t\tif (!(dhcp_server_state_machine == DHCP_SERVER_STATE_ACK ||\n\t\t\tdhcp_server_state_machine == DHCP_SERVER_STATE_NAK)) {\n\t\t        dhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#endif\n\t\tbreak;\n\tcase DHCP_MESSAGE_TYPE_RELEASE:\n\t\tprintf(\"get message DHCP_MESSAGE_TYPE_RELEASE\\n\");\n\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\t\tbreak;\n\t}\n\n\treturn dhcp_server_state_machine;\n}\n/**\n  * @brief  parse the dhcp message option part.\n  * @param  optptr: the addr of the first option field. \n  *         len: the total length of all option fields.          \n  * @retval dhcp server state.\n  */\nstatic uint8_t dhcps_handle_msg_options(uint8_t *option_start, int16_t total_option_length)\n{\n       \n\tint16_t option_message_type = 0;\n\tuint8_t *option_end = option_start + total_option_length;\n\t//dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\n\t/* begin process the dhcp option info */\n\twhile (option_start < option_end) {\t\n\t\tswitch ((uint8_t)*option_start) {\n\t\tcase DHCP_OPTION_CODE_MSG_TYPE: \n\t\t\toption_message_type = *(option_start + 2); // 2 => code(1)+lenth(1)\n\t\t\tbreak;\n\t\tcase DHCP_OPTION_CODE_REQUEST_IP_ADDRESS : \n#if IS_USE_FIXED_IP\n\t\t\tif (memcmp((char *)&dhcps_allocated_client_address,\n\t\t\t\t\t(char *)option_start + 2, 4) == 0)\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\telse \n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n#else                   \t\t\n\t\t\tmemcpy((char *)&client_request_ip, (char *)option_start + 2, 4);\t\n#endif\n\t\t\tbreak;\n\t\t} \n\t\t// calculate the options offset to get next option's base addr\n\t\toption_start += option_start[1] + 2; // optptr[1]: length value + (code(1)+ Len(1))\n\t}\n\treturn dhcps_handle_state_machine_change(option_message_type);        \n}\n\n/**\n  * @brief  get message from buffer then check whether it is dhcp related or not.\n  *         if yes , parse it more to undersatnd the client's request.\n  * @param  same as recv callback function definition\n  * @retval if message is dhcp related then return dhcp server state,\n  *\t    otherwise return 0\n  */\nstatic uint8_t dhcps_check_msg_and_handle_options(struct pbuf *packet_buffer)\n{\n\tint dhcp_message_option_offset;\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcp_message_option_offset = ((int)dhcp_message_repository->options \n\t\t\t\t\t\t- (int)packet_buffer->payload);\n\tdhcp_message_total_options_lenth = (packet_buffer->len \n\t\t\t\t\t\t- dhcp_message_option_offset);\n\tmemcpy(client_addr, dhcp_message_repository->chaddr, 6);\n\t/* check the magic number,if correct parse the content of options */\n\tif (memcmp((char *)dhcp_message_repository->options,\n\t\t(char *)dhcp_magic_cookie, sizeof(dhcp_magic_cookie)) == 0) {\n            \treturn dhcps_handle_msg_options(&dhcp_message_repository->options[4],\n            \t\t\t\t(dhcp_message_total_options_lenth - 4));\n\t}\n        \n\treturn 0;\n}\n\n\n/**\n  * @brief  handle imcoming dhcp message and response message to client \n  * @param  same as recv callback function definition\n  * @retval None\n  */\nstatic void dhcps_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\nstruct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n{\t\n  \tint16_t total_length_of_packet_buffer;\n\tstruct pbuf *merged_packet_buffer = NULL;\n\n\tdhcp_message_repository = (struct dhcp_msg *)udp_packet_buffer->payload;\n\tif (udp_packet_buffer == NULL) {\n\t\tprintf(\"\\n\\r Error!!!! System doesn't allocate any buffer \\n\\r\");\n\t\treturn;  \n\t}\n\tif (sender_port == DHCP_CLIENT_PORT) {\n#if LWIP_VERSION_MAJOR >= 2\n\t\tif(netif_get_idx(ip_current_input_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP)\n#else\n\t\tif(netif_get_idx(ip_current_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP)\n#endif\n\t\t{\n\t\t\tpbuf_free(udp_packet_buffer);\n\t\t\treturn;\n\t\t}\n\t\ttotal_length_of_packet_buffer = udp_packet_buffer->tot_len;\n\t\tif (udp_packet_buffer->next != NULL) {\n\t\t\tmerged_packet_buffer = pbuf_coalesce(udp_packet_buffer,\n\t\t\t\t\t\t\t\tPBUF_TRANSPORT);\n\t\t\tif (merged_packet_buffer->tot_len !=\n\t\t\t\t\t\ttotal_length_of_packet_buffer) {\n\t\t\t\tpbuf_free(udp_packet_buffer);\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tudp_packet_buffer = merged_packet_buffer;\n\t\t}\n\t\tswitch (dhcps_check_msg_and_handle_options(udp_packet_buffer)) {\n\t\tcase  DHCP_SERVER_STATE_OFFER:\n\t\t\t#if (debug_dhcps)\t\n\t\t\tprintf(\"%s DHCP_SERVER_STATE_OFFER\\n\",__func__);\n\t\t\t#endif\n\t\t\tdhcps_send_offer(udp_packet_buffer);\n\t\t\tbreak;\n\t\tcase DHCP_SERVER_STATE_ACK:\n\t\t\t#if (debug_dhcps)\t\n\t\t\tprintf(\"%s DHCP_SERVER_STATE_ACK\\n\",__func__);\n\t\t\t#endif\n\t\t\tdhcps_send_ack(udp_packet_buffer);\n#if (!IS_USE_FIXED_IP)\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address))); \n#else\n\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address)); \t\n#endif\t\t\t\n\t#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\t\t\tsave_client_addr(&dhcps_allocated_client_address, client_addr);\n\t\t\tmemset(&client_request_ip, 0, sizeof(client_request_ip));\n\t\t\tmemset(&client_addr, 0, sizeof(client_addr));\n\t\t\tmemset(&dhcps_allocated_client_address, 0, sizeof(dhcps_allocated_client_address));\n\t\t\t#if (debug_dhcps)\t\n\t\t\tdump_client_table();\n\t\t\t#endif\n\t#endif\n#endif\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\t\t\tbreak;\n\t\tcase DHCP_SERVER_STATE_NAK:\n\t\t\t#if (debug_dhcps)\t\n\t\t\tprintf(\"%s DHCP_SERVER_STATE_NAK\\n\",__func__);\n\t\t\t#endif\n\t\t\tdhcps_send_nak(udp_packet_buffer);\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\t\t\tbreak;\n\t\tcase DHCP_OPTION_CODE_END:\n\t\t\t#if (debug_dhcps)\t\n\t\t\tprintf(\"%s DHCP_OPTION_CODE_END\\n\",__func__);\n\t\t\t#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/* free the UDP connection, so we can accept new clients */\n\tudp_disconnect(udp_pcb);\n\n\t/* Free the packet buffer */   \n\tif (merged_packet_buffer != NULL)\n\t\tpbuf_free(merged_packet_buffer);\n\telse \n\t\tpbuf_free(udp_packet_buffer);\n}\n\nvoid dhcps_set_addr_pool(int addr_pool_set, struct ip_addr * addr_pool_start, struct ip_addr *addr_pool_end)\n{\n\t//uint8_t *ip;\n\tif(addr_pool_set){\n\t\tdhcps_addr_pool_set = 1;\n\n\t\tmemcpy(&dhcps_addr_pool_start, addr_pool_start,\n\t\t\t\t\t\t\tsizeof(struct ip_addr));\n\t\t//ip = &dhcps_addr_pool_start;\n\t\t//ip[3] = 100;\n\t\tmemcpy(&dhcps_addr_pool_end, addr_pool_end,\n\t\t\t\t\t\t\tsizeof(struct ip_addr));\n\t\t//ip = &dhcps_addr_pool_end;\n\t\t//ip[3] = 200;\n\t}else{\n\t\tdhcps_addr_pool_set = 0;\n\t}\n}\n\n\nstatic void dnss_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\nstruct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n{\n\tint ret=0;\n\tstruct dns_hdr *dns_rsp;\n\n/*\n\tprintf(\"\\n%s: Receive DNS query,ip = %d.%d.%d.%d, port = %d(%x)\\n\",__func__,\\\n\t\t\tsender_addr->addr & 0xff,\\\n\t\t\tsender_addr->addr>>8 & 0xff,\\\n\t\t\tsender_addr->addr>>16 & 0xff,\\\n\t\t\tsender_addr->addr>>24 & 0xff,\\\n\t\t\tsender_port,sender_port);\n*/\n\n\tdns_rsp = (struct dns_hdr*) udp_packet_buffer->payload;\n\n\tdns_rsp->flags1 |= 0x80; // 0x80 : Response;\n\tdns_rsp->flags2 = 0x05;  //0x05 : Reply code (Query Refused)\n\n\tret = udp_sendto(udp_pcb, udp_packet_buffer, sender_addr, sender_port);\n\n\t/* free the UDP connection, so we can accept new clients */\n\tudp_disconnect(udp_pcb);\n\n\t/* Free the packet buffer */\n\tpbuf_free(udp_packet_buffer);\n}\n\n\nvoid dns_server_init(struct netif * pnetif)\n{\n\tuint8_t *ip;\n\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n\n\tdns_server_pcb = udp_new();\n\tif (dns_server_pcb == NULL) {\n\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n\t\treturn;\n\t}\n\n\tudp_bind(dns_server_pcb, IP_ADDR_ANY, DNS_SERVER_PORT);\n\tudp_recv(dns_server_pcb, dnss_receive_udp_packet_handler, NULL);\n}\n\nvoid dns_server_deinit(void)\n{\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n}\n\n/** \n  * @brief  Initialize dhcp server.\n  * @param  None.\n  * @retval None.\n  * Note, for now,we assume the server latch ip 192.168.1.1 and support dynamic \n  *       or fixed IP allocation. \n  */\nvoid dhcps_init(struct netif * pnetif)\n{\t\n\tuint8_t *ip;\n//\tprintf(\"dhcps_init,wlan:%c\\n\\r\",pnetif->name[1]);\n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\tmemset(&ip_table, 0, sizeof(struct table));\n//\tint i = 0;\n//\tfor(i=0; i< DHCPS_MAX_CLIENT_NUM+2; i++)\n//\t\tmemset(ip_table.client_mac[i], 0, 6);\n//\tdump_client_table();\n#endif\n\t\n\tdhcps_netif = pnetif;\n\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\n\tdhcps_pcb = udp_new(); \n\tif (dhcps_pcb == NULL) {\n\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n\t\treturn;\n\t}\n#if LWIP_VERSION_MAJOR >= 2\n\tIP4_ADDR(ip_2_ip4(&dhcps_send_broadcast_address), 255, 255, 255, 255);\n#else\n\tIP4_ADDR(&dhcps_send_broadcast_address, 255, 255, 255, 255);\n#endif\n\n\t/* get net info from net interface */\n\n\tmemcpy(&dhcps_local_address, &pnetif->ip_addr,\n\t\t\t\t\t\t\tsizeof(struct ip_addr));\n\tmemcpy(&dhcps_local_mask, &pnetif->netmask,\n\t\t\t\t\t\tsizeof(struct ip_addr));\n\n\tmemcpy(&dhcps_local_gateway, &pnetif->gw,\n\t\t\t\t\t\tsizeof(struct ip_addr));\n\n\t/* calculate the usable network ip range */\n#if LWIP_VERSION_MAJOR >= 2\n\tip4_addr_set_u32(ip_2_ip4(&dhcps_network_id), (ip_addr_get_ip4_u32(netif_ip_addr4(pnetif))&(ip_addr_get_ip4_u32(netif_ip_netmask4(pnetif)))));\n\tip4_addr_set_u32(ip_2_ip4(&dhcps_subnet_broadcast), (ip4_addr_get_u32(ip_2_ip4(&dhcps_network_id)) | ~(ip_addr_get_ip4_u32(netif_ip_netmask4(pnetif)))));\n#if 1\n\tip4_addr_set_u32(ip_2_ip4(&dhcps_owned_first_ip), htonl(ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_network_id))) + 1));\n\tip4_addr_set_u32(ip_2_ip4(&dhcps_owned_last_ip), htonl(ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_subnet_broadcast))) - 1));\t\n\tdhcps_num_of_available_ips = (ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_owned_last_ip))) - ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_owned_first_ip)))) + 1;\n#endif\n#else\n\tdhcps_network_id.addr = ((pnetif->ip_addr.addr) &\n\t\t\t\t\t(pnetif->netmask.addr));\n\t\n\tdhcps_subnet_broadcast.addr = ((dhcps_network_id.addr |\n\t\t\t\t\t~(pnetif->netmask.addr)));\n#if 1\n\tdhcps_owned_first_ip.addr = htonl((ntohl(dhcps_network_id.addr) + 1));\n\tdhcps_owned_last_ip.addr = htonl(ntohl(dhcps_subnet_broadcast.addr) - 1);\n\tdhcps_num_of_available_ips = ((ntohl(dhcps_owned_last_ip.addr) \n\t\t\t\t- ntohl(dhcps_owned_first_ip.addr)) + 1); \n#endif\n#endif\n\n\n#if CONFIG_EXAMPLE_UART_ATCMD || CONFIG_EXAMPLE_SPI_ATCMD \n#if IP_SOF_BROADCAST\n  dhcps_pcb->so_options|=SOF_BROADCAST;\n#endif /* IP_SOF_BROADCAST */\n#endif\n\n#if IS_USE_FIXED_IP\n#if LWIP_VERSION_MAJOR >= 2\n\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), ip4_addr1(ip_2_ip4(&dhcps_local_address))\n\t\t, ip4_addr2(ip_2_ip4(&dhcps_local_address)), ip4_addr3(ip_2_ip4(&dhcps_local_address)),\n\t\t\t\t\t(ip4_addr4(ip_2_ip4(&dhcps_local_address))) + 1 );\n#else\n\tIP4_ADDR(&dhcps_allocated_client_address, ip4_addr1(&dhcps_local_address)\n\t\t, ip4_addr2(&dhcps_local_address), ip4_addr3(&dhcps_local_address),\n\t\t\t\t\t(ip4_addr4(&dhcps_local_address)) + 1 );\n#endif\n\n#else\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\n\tdhcps_ip_table_semaphore = xSemaphoreCreateMutex();\n\n\t//dhcps_ip_table = (struct ip_table *)(pvPortMalloc(sizeof(struct ip_table)));\n\tmemset(&ip_table, 0, sizeof(struct table));\n#if LWIP_VERSION_MAJOR >= 2\n\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_local_address)));\n\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_local_gateway)));\n#else\n\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_gateway));\n#endif\n\n#if 0\n\tfor (i = 1; i < ip4_addr4(&dhcps_local_address); i++) {\n\t\tmark_ip_in_table(i);\n\t}\n#endif\t\n#endif\n#if LWIP_VERSION_MAJOR >= 2\n\tif(ip4_addr_get_u32(ip_2_ip4(&dhcps_addr_pool_start)) == 0 && ip4_addr_get_u32(ip_2_ip4(&dhcps_addr_pool_end)) == 0)\n#else\n\tif(dhcps_addr_pool_start.addr== 0 && dhcps_addr_pool_end.addr == 0)\n#endif\n\n\t{\t\t\n\t\tmemcpy(&dhcps_pool_start,&dhcps_local_address,sizeof(struct ip_addr));\n\t\tip = (uint8_t *)&dhcps_pool_start;\n\t\tip[3] = DHCP_POOL_START;\n\t\tmemcpy(&dhcps_pool_end,&dhcps_local_address,sizeof(struct ip_addr));\n\t\tip = (uint8_t *)&dhcps_pool_end;\n\t\tip[3] = DHCP_POOL_END;\n\t\tdhcps_set_addr_pool(1,&dhcps_pool_start,&dhcps_pool_end);\n\t}\n\tudp_bind(dhcps_pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);\n\tudp_recv(dhcps_pcb, dhcps_receive_udp_packet_handler, NULL);\n\n\t//DNS server init\n\tdns_server_init(pnetif);\n\n}\n\nvoid dhcps_deinit(void)\n{\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\t\t   \n    //DNS server deinit\n\tdns_server_deinit();\n}\n", "\n#ifndef __DHCPS_H__\n#define __DHCPS_H__\n\n#include \"lwip/arch.h\"\n#include \"lwip/netif.h\"\n#include \"lwip/udp.h\"\n#include \"lwip/stats.h\"\n#include \"lwip/sys.h\"\n#include \"netif/etharp.h\"\n\n#include <platform/platform_stdlib.h>\n\n#define CONFIG_DHCPS_KEPT_CLIENT_INFO\n\n#define DHCP_POOL_START\t\t\t100\n#define DHCP_POOL_END\t\t\t200\n\n#define DHCPS_MAX_CLIENT_NUM \t(DHCP_POOL_END-DHCP_POOL_START+1)\n\n#define IS_USE_FIXED_IP\t0\n#define debug_dhcps 0\n\n/* dhcp server states */\n#define DHCP_SERVER_STATE_OFFER \t\t\t(1)\n#define DHCP_SERVER_STATE_DECLINE \t\t\t(2)\n#define DHCP_SERVER_STATE_ACK \t\t\t\t(3)\n#define DHCP_SERVER_STATE_NAK \t\t\t\t(4)\n#define DHCP_SERVER_STATE_IDLE \t\t\t\t(5)\n\n\n#define BOOTP_BROADCAST \t\t\t\t(0x8000)\n\n#define DHCP_MESSAGE_OP_REQUEST        \t\t\t(1)\n#define DHCP_MESSAGE_OP_REPLY          \t\t\t(2)\n\n#define DHCP_MESSAGE_HTYPE \t\t\t\t(1)\n#define DHCP_MESSAGE_HLEN  \t\t\t\t(6)\n\n#define DNS_SERVER_PORT \t\t\t\t(53)\n#define DHCP_SERVER_PORT  \t\t\t\t(67)\n#define DHCP_CLIENT_PORT  \t\t\t\t(68)\n\n#define DHCP_MESSAGE_TYPE_DISCOVER  \t\t\t(1)\n#define DHCP_MESSAGE_TYPE_OFFER     \t\t\t(2)\n#define DHCP_MESSAGE_TYPE_REQUEST   \t\t\t(3)\n#define DHCP_MESSAGE_TYPE_DECLINE   \t\t\t(4)\n#define DHCP_MESSAGE_TYPE_ACK       \t\t\t(5)\n#define DHCP_MESSAGE_TYPE_NAK       \t\t\t(6)\n#define DHCP_MESSAGE_TYPE_RELEASE   \t\t\t(7)\n\n#define DHCP_OPTION_LENGTH_ONE\t\t\t\t(1)\n#define DHCP_OPTION_LENGTH_TWO\t\t\t\t(2)\n#define DHCP_OPTION_LENGTH_THREE\t\t\t(3)\n#define DHCP_OPTION_LENGTH_FOUR\t\t\t\t(4)\n#ifndef DHCP_MSG_LEN\n#define DHCP_MSG_LEN\t\t\t\t\t\t\t236\n#endif\n#define DHCP_OPTION_TOTAL_LENGTH_MAX\t312\t//(51)= 4(magic)+3(type)+44(option code: 1,3,6,51,54,28,26,32,end)\n\n#define DHCP_OPTION_CODE_SUBNET_MASK   \t\t\t(1)\n#define DHCP_OPTION_CODE_ROUTER        \t\t\t(3)\n#define DHCP_OPTION_CODE_DNS_SERVER    \t\t\t(6)\n#define DHCP_OPTION_CODE_INTERFACE_MTU \t\t\t(26)\n#define DHCP_OPTION_CODE_BROADCAST_ADDRESS \t\t(28)\n#define DHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY \t(31)\n#define DHCP_OPTION_CODE_REQUEST_IP_ADDRESS   \t\t(50)\n#define DHCP_OPTION_CODE_LEASE_TIME   \t\t\t(51)\n#define DHCP_OPTION_CODE_MSG_TYPE     \t\t\t(53)\n#define DHCP_OPTION_CODE_SERVER_ID    \t\t\t(54)\n#define DHCP_OPTION_CODE_REQ_LIST     \t\t\t(55)\n#define DHCP_OPTION_CODE_END         \t\t\t(255)\n\n#define IP_FREE_TO_USE\t\t                \t(1)\n#define IP_ALREADY_IN_USE\t                \t(0)\n\n#define HW_ADDRESS_LENGTH\t\t\t\t(6)\n\n/* Reference by RFC 2131 */\nstruct dhcp_msg {\n\tuint8_t op; \t\t/* Message op code/message type. 1 = BOOTREQUEST, 2 = BOOTREPLY */\n\tuint8_t\thtype;\t\t/* Hardware address type */\n\tuint8_t hlen;\t\t/* Hardware address length */\n\tuint8_t hops;\t\t/* Client sets to zero, optionally used by relay agents \n\t\t\t\t   when booting via a relay agent */\n\tuint8_t xid[4];\t\t/* Transaction ID, a random number chosen by the client,\n\t\t\t\t   used by the client and server to associate messages and \n\t\t\t\t   responses between a client and a server */\n\tuint16_t secs;\t\t/* Filled in by client, seconds elapsed since client began address\n\t\t\t\t   acquisition or renewal process.*/\n\tuint16_t flags;\t\t/* bit 0: Broadcast flag, bit 1~15:MBZ must 0*/\n\tuint8_t ciaddr[4];\t/* Client IP address; only filled in if client is in BOUND,\n\t\t\t\t   RENEW or REBINDING state and can respond to ARP requests. */\n\tuint8_t yiaddr[4];\t/* 'your' (client) IP address */\n\tuint8_t siaddr[4];\t/* IP address of next server to use in bootstrap;\n\t\t\t\t   returned in DHCPOFFER, DHCPACK by server. */\n\tuint8_t giaddr[4];\t/* Relay agent IP address, used in booting via a relay agent.*/\n\tuint8_t chaddr[16];\t/* Client hardware address */\n\tuint8_t sname[64];\t/* Optional server host name, null terminated string.*/\n\tuint8_t file[128];\t/* Boot file name, null terminated string; \"generic\" name or\n\t\t\t           null in DHCPDISCOVER, fully qualified directory-path name in DHCPOFFER.*/\n\tuint8_t options[312];   /* Optional parameters field. reference the RFC 2132 */\n};\n\n/* use this to check whether the message is dhcp related or not */\nstatic const uint8_t dhcp_magic_cookie[4] = {99, 130, 83, 99};\nstatic const uint8_t dhcp_option_lease_time[] = {0x00, 0x00, 0x1c, 0x20}; //1 day\n//static const uint8_t dhcp_option_lease_time[] = {0x00, 0x00, 0x0e, 0x10}; // one hour\n//static const uint8_t dhcp_option_interface_mtu_576[] = {0x02, 0x40};\nstatic const uint8_t dhcp_option_interface_mtu[] = {0x05, 0xDC};\n\nstruct table {\n\tuint32_t ip_range[8];\n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\tuint8_t client_mac[256][6];\n#endif\n};\n\nstruct address_pool{\n\tuint32_t start;\n\tuint32_t end;\n};\n\nPACK_STRUCT_BEGIN\n/** DNS message header */\nstruct dns_hdr {\n  PACK_STRUCT_FIELD(u16_t id);\n  PACK_STRUCT_FIELD(u8_t flags1);\n  PACK_STRUCT_FIELD(u8_t flags2);\n  PACK_STRUCT_FIELD(u16_t numquestions);\n  PACK_STRUCT_FIELD(u16_t numanswers);\n  PACK_STRUCT_FIELD(u16_t numauthrr);\n  PACK_STRUCT_FIELD(u16_t numextrarr);\n} PACK_STRUCT_STRUCT;\nPACK_STRUCT_END\n\n/* 01~32 */\n#define MARK_RANGE1_IP_BIT(table, ip)\t((table.ip_range[0]) | (1 << ((ip) - 1)))\t \n/* 33~64 */\n#define MARK_RANGE2_IP_BIT(table, ip)\t((table.ip_range[1]) | (1 << ((ip) - 1)))\n/* 65~96 */\n#define MARK_RANGE3_IP_BIT(table, ip)\t((table.ip_range[2]) | (1 << ((ip) - 1)))\n/* 97~128 */\n#define MARK_RANGE4_IP_BIT(table, ip)\t((table.ip_range[3]) | (1 << ((ip) - 1)))\n/* 129~160 */\n#define MARK_RANGE5_IP_BIT(table, ip)\t((table.ip_range[4]) | (1 << ((ip) - 1)))\t \n/* 161~192 */\n#define MARK_RANGE6_IP_BIT(table, ip)\t((table.ip_range[5]) | (1 << ((ip) - 1)))\n/* 193~224 */\n#define MARK_RANGE7_IP_BIT(table, ip)\t((table.ip_range[6]) | (1 << ((ip) - 1)))\n/* 225~255 */\n#define MARK_RANGE8_IP_BIT(table, ip)\t((table.ip_range[7]) | (1 << ((ip) - 1)))\n\n/* expose API */\nvoid dhcps_set_addr_pool(int addr_pool_set, struct ip_addr * addr_pool_start, struct ip_addr *addr_pool_end);\nvoid dhcps_init(struct netif * pnetif);\nvoid dhcps_deinit(void);\n\nextern struct netif *netif_default;\n\n#endif\n"], "filenames": ["component/common/network/dhcp/dhcps.c", "component/common/network/dhcp/dhcps.h"], "buggy_code_start_loc": [4, 9], "buggy_code_end_loc": [745, 117], "fixing_code_start_loc": [4, 10], "fixing_code_end_loc": [1150, 137], "type": "NVD-CWE-noinfo", "message": "component/common/network/dhcp/dhcps.c in ambiot amb1_sdk (aka SDK for Ameba1) before 2022-03-11 mishandles data structures for DHCP packet data.", "other": {"cve": {"id": "CVE-2022-29859", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-27T23:15:08.023", "lastModified": "2022-12-13T16:28:52.440", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "component/common/network/dhcp/dhcps.c in ambiot amb1_sdk (aka SDK for Ameba1) before 2022-03-11 mishandles data structures for DHCP packet data."}, {"lang": "es", "value": "el archivo component/common/network/dhcp/dhcps.c en ambiot amb1_sdk (tambi\u00e9n se conoce como SDK para Ameba1) versiones anteriores a 11-03-2022 maneja inapropiadamente las estructuras de datos para los datos de los paquetes DHCP"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:amb1_sdk_project:amb1_sdk:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-03-11", "matchCriteriaId": "9D176A68-9599-4CAA-AA7F-B53E1DF32CB1"}]}]}], "references": [{"url": "https://github.com/ambiot/amb1_sdk/commit/4b73f58f32914d0081d79a79e53a3215c8c1ea56", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.amebaiot.com/zh/security_bulletin/cve-2022-29859/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ambiot/amb1_sdk/commit/4b73f58f32914d0081d79a79e53a3215c8c1ea56"}}