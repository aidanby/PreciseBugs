{"buggy_code": ["'use strict'\n\nfunction _process (v, mod) {\n  var i\n  var r\n\n  if (typeof mod === 'function') {\n    r = mod(v)\n    if (r !== undefined) {\n      v = r\n    }\n  } else if (Array.isArray(mod)) {\n    for (i = 0; i < mod.length; i++) {\n      r = mod[i](v)\n      if (r !== undefined) {\n        v = r\n      }\n    }\n  }\n\n  return v\n}\n\nfunction parseKey (key, val) {\n  // detect negative index notation\n  if (key[0] === '-' && Array.isArray(val) && /^-\\d+$/.test(key)) {\n    return val.length + parseInt(key, 10)\n  }\n  return key\n}\n\nfunction isIndex (k) {\n  return /^\\d+$/.test(k)\n}\n\nfunction isObject (val) {\n  return Object.prototype.toString.call(val) === '[object Object]'\n}\n\nfunction isArrayOrObject (val) {\n  return Object(val) === val\n}\n\nfunction isEmptyObject (val) {\n  return Object.keys(val).length === 0\n}\n\nfunction parsePath (path, sep) {\n  if (path.indexOf('[') >= 0) {\n    path = path.replace(/\\[/g, '.').replace(/]/g, '')\n  }\n  return path.split(sep)\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction DotObject (separator, override, useArray, useBrackets) {\n  if (!(this instanceof DotObject)) {\n    return new DotObject(separator, override, useArray, useBrackets)\n  }\n\n  if (typeof override === 'undefined') override = false\n  if (typeof useArray === 'undefined') useArray = true\n  if (typeof useBrackets === 'undefined') useBrackets = true\n  this.separator = separator || '.'\n  this.override = override\n  this.useArray = useArray\n  this.useBrackets = useBrackets\n  this.keepArray = false\n\n  // contains touched arrays\n  this.cleanup = []\n}\n\nvar dotDefault = new DotObject('.', false, true, true)\nfunction wrap (method) {\n  return function () {\n    return dotDefault[method].apply(dotDefault, arguments)\n  }\n}\n\nDotObject.prototype._fill = function (a, obj, v, mod) {\n  var k = a.shift()\n\n  if (a.length > 0) {\n    obj[k] = obj[k] ||\n      (this.useArray && isIndex(a[0]) ? [] : {})\n\n    if (!isArrayOrObject(obj[k])) {\n      if (this.override) {\n        obj[k] = {}\n      } else {\n        if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n          throw new Error(\n            'Trying to redefine `' + k + '` which is a ' + typeof obj[k]\n          )\n        }\n\n        return\n      }\n    }\n\n    this._fill(a, obj[k], v, mod)\n  } else {\n    if (!this.override &&\n      isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {\n      if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n        throw new Error(\"Trying to redefine non-empty obj['\" + k + \"']\")\n      }\n\n      return\n    }\n\n    obj[k] = _process(v, mod)\n  }\n}\n\n/**\n *\n * Converts an object with dotted-key/value pairs to it's expanded version\n *\n * Optionally transformed by a set of modifiers.\n *\n * Usage:\n *\n *   var row = {\n *     'nr': 200,\n *     'doc.name': '  My Document  '\n *   }\n *\n *   var mods = {\n *     'doc.name': [_s.trim, _s.underscored]\n *   }\n *\n *   dot.object(row, mods)\n *\n * @param {Object} obj\n * @param {Object} mods\n */\nDotObject.prototype.object = function (obj, mods) {\n  var self = this\n\n  Object.keys(obj).forEach(function (k) {\n    var mod = mods === undefined ? null : mods[k]\n    // normalize array notation.\n    var ok = parsePath(k, self.separator).join(self.separator)\n\n    if (ok.indexOf(self.separator) !== -1) {\n      self._fill(ok.split(self.separator), obj, obj[k], mod)\n      delete obj[k]\n    } else {\n      obj[k] = _process(obj[k], mod)\n    }\n  })\n\n  return obj\n}\n\n/**\n * @param {String} path dotted path\n * @param {String} v value to be set\n * @param {Object} obj object to be modified\n * @param {Function|Array} mod optional modifier\n */\nDotObject.prototype.str = function (path, v, obj, mod) {\n  var ok = parsePath(path, this.separator).join(this.separator)\n\n  if (path.indexOf(this.separator) !== -1) {\n    this._fill(ok.split(this.separator), obj, v, mod)\n  } else {\n    obj[path] = _process(v, mod)\n  }\n\n  return obj\n}\n\n/**\n *\n * Pick a value from an object using dot notation.\n *\n * Optionally remove the value\n *\n * @param {String} path\n * @param {Object} obj\n * @param {Boolean} remove\n */\nDotObject.prototype.pick = function (path, obj, remove, reindexArray) {\n  var i\n  var keys\n  var val\n  var key\n  var cp\n\n  keys = parsePath(path, this.separator)\n  for (i = 0; i < keys.length; i++) {\n    key = parseKey(keys[i], obj)\n    if (obj && typeof obj === 'object' && key in obj) {\n      if (i === (keys.length - 1)) {\n        if (remove) {\n          val = obj[key]\n          if (reindexArray && Array.isArray(obj)) {\n            obj.splice(key, 1)\n          } else {\n            delete obj[key]\n          }\n          if (Array.isArray(obj)) {\n            cp = keys.slice(0, -1).join('.')\n            if (this.cleanup.indexOf(cp) === -1) {\n              this.cleanup.push(cp)\n            }\n          }\n          return val\n        } else {\n          return obj[key]\n        }\n      } else {\n        obj = obj[key]\n      }\n    } else {\n      return undefined\n    }\n  }\n  if (remove && Array.isArray(obj)) {\n    obj = obj.filter(function (n) { return n !== undefined })\n  }\n  return obj\n}\n/**\n *\n * Delete value from an object using dot notation.\n *\n * @param {String} path\n * @param {Object} obj\n * @return {any} The removed value\n */\nDotObject.prototype.delete = function (path, obj) {\n  return this.remove(path, obj, true)\n}\n\n/**\n *\n * Remove value from an object using dot notation.\n *\n * Will remove multiple items if path is an array.\n * In this case array indexes will be retained until all\n * removals have been processed.\n *\n * Use dot.delete() to automatically  re-index arrays.\n *\n * @param {String|Array<String>} path\n * @param {Object} obj\n * @param {Boolean} reindexArray\n * @return {any} The removed value\n */\nDotObject.prototype.remove = function (path, obj, reindexArray) {\n  var i\n\n  this.cleanup = []\n  if (Array.isArray(path)) {\n    for (i = 0; i < path.length; i++) {\n      this.pick(path[i], obj, true, reindexArray)\n    }\n    if (!reindexArray) {\n      this._cleanup(obj)\n    }\n    return obj\n  } else {\n    return this.pick(path, obj, true, reindexArray)\n  }\n}\n\nDotObject.prototype._cleanup = function (obj) {\n  var ret\n  var i\n  var keys\n  var root\n  if (this.cleanup.length) {\n    for (i = 0; i < this.cleanup.length; i++) {\n      keys = this.cleanup[i].split('.')\n      root = keys.splice(0, -1).join('.')\n      ret = root ? this.pick(root, obj) : obj\n      ret = ret[keys[0]].filter(function (v) { return v !== undefined })\n      this.set(this.cleanup[i], ret, obj)\n    }\n    this.cleanup = []\n  }\n}\n\n/**\n * Alias method  for `dot.remove`\n *\n * Note: this is not an alias for dot.delete()\n *\n * @param {String|Array<String>} path\n * @param {Object} obj\n * @param {Boolean} reindexArray\n * @return {any} The removed value\n */\nDotObject.prototype.del = DotObject.prototype.remove\n\n/**\n *\n * Move a property from one place to the other.\n *\n * If the source path does not exist (undefined)\n * the target property will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.move = function (source, target, obj, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(target, _process(this.pick(source, obj, true), mods), obj, merge)\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj, true), obj, merge)\n  }\n\n  return obj\n}\n\n/**\n *\n * Transfer a property from one object to another object.\n *\n * If the source path does not exist (undefined)\n * the property on the other object will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.transfer = function (source, target, obj1, obj2, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(target,\n      _process(\n        this.pick(source, obj1, true),\n        mods\n      ), obj2, merge)\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj1, true), obj2, merge)\n  }\n\n  return obj2\n}\n\n/**\n *\n * Copy a property from one object to another object.\n *\n * If the source path does not exist (undefined)\n * the property on the other object will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.copy = function (source, target, obj1, obj2, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(target,\n      _process(\n        // clone what is picked\n        JSON.parse(\n          JSON.stringify(\n            this.pick(source, obj1, false)\n          )\n        ),\n        mods\n      ), obj2, merge)\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj1, false), obj2, merge)\n  }\n\n  return obj2\n}\n\n/**\n *\n * Set a property on an object using dot notation.\n *\n * @param {String} path\n * @param {any} val\n * @param {Object} obj\n * @param {Boolean} merge\n */\nDotObject.prototype.set = function (path, val, obj, merge) {\n  var i\n  var k\n  var keys\n  var key\n\n  // Do not operate if the value is undefined.\n  if (typeof val === 'undefined') {\n    return obj\n  }\n  keys = parsePath(path, this.separator)\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i]\n    if (i === (keys.length - 1)) {\n      if (merge && isObject(val) && isObject(obj[key])) {\n        for (k in val) {\n          if (hasOwnProperty.call(val, k)) {\n            obj[key][k] = val[k]\n          }\n        }\n      } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {\n        for (var j = 0; j < val.length; j++) {\n          obj[keys[i]].push(val[j])\n        }\n      } else {\n        obj[key] = val\n      }\n    } else if (\n      // force the value to be an object\n      !hasOwnProperty.call(obj, key) ||\n      (!isObject(obj[key]) && !Array.isArray(obj[key]))\n    ) {\n      // initialize as array if next key is numeric\n      if (/^\\d+$/.test(keys[i + 1])) {\n        obj[key] = []\n      } else {\n        obj[key] = {}\n      }\n    }\n    obj = obj[key]\n  }\n  return obj\n}\n\n/**\n *\n * Transform an object\n *\n * Usage:\n *\n *   var obj = {\n *     \"id\": 1,\n  *    \"some\": {\n  *      \"thing\": \"else\"\n  *    }\n *   }\n *\n *   var transform = {\n *     \"id\": \"nr\",\n  *    \"some.thing\": \"name\"\n *   }\n *\n *   var tgt = dot.transform(transform, obj)\n *\n * @param {Object} recipe Transform recipe\n * @param {Object} obj Object to be transformed\n * @param {Array} mods modifiers for the target\n */\nDotObject.prototype.transform = function (recipe, obj, tgt) {\n  obj = obj || {}\n  tgt = tgt || {}\n  Object.keys(recipe).forEach(function (key) {\n    this.set(recipe[key], this.pick(key, obj), tgt)\n  }.bind(this))\n  return tgt\n}\n\n/**\n *\n * Convert object to dotted-key/value pair\n *\n * Usage:\n *\n *   var tgt = dot.dot(obj)\n *\n *   or\n *\n *   var tgt = {}\n *   dot.dot(obj, tgt)\n *\n * @param {Object} obj source object\n * @param {Object} tgt target object\n * @param {Array} path path array (internal)\n */\nDotObject.prototype.dot = function (obj, tgt, path) {\n  tgt = tgt || {}\n  path = path || []\n  var isArray = Array.isArray(obj)\n\n  Object.keys(obj).forEach(function (key) {\n    var index = isArray && this.useBrackets ? '[' + key + ']' : key\n    if (\n      (\n        isArrayOrObject(obj[key]) &&\n        (\n          (isObject(obj[key]) && !isEmptyObject(obj[key])) ||\n          (Array.isArray(obj[key]) && (!this.keepArray && (obj[key].length !== 0)))\n        )\n      )\n    ) {\n      if (isArray && this.useBrackets) {\n        var previousKey = path[path.length - 1] || ''\n        return this.dot(obj[key], tgt, path.slice(0, -1).concat(previousKey + index))\n      } else {\n        return this.dot(obj[key], tgt, path.concat(index))\n      }\n    } else {\n      if (isArray && this.useBrackets) {\n        tgt[path.join(this.separator).concat('[' + key + ']')] = obj[key]\n      } else {\n        tgt[path.concat(index).join(this.separator)] = obj[key]\n      }\n    }\n  }.bind(this))\n  return tgt\n}\n\nDotObject.pick = wrap('pick')\nDotObject.move = wrap('move')\nDotObject.transfer = wrap('transfer')\nDotObject.transform = wrap('transform')\nDotObject.copy = wrap('copy')\nDotObject.object = wrap('object')\nDotObject.str = wrap('str')\nDotObject.set = wrap('set')\nDotObject.delete = wrap('delete')\nDotObject.del = DotObject.remove = wrap('remove')\nDotObject.dot = wrap('dot')\n\n;['override', 'overwrite'].forEach(function (prop) {\n  Object.defineProperty(DotObject, prop, {\n    get: function () {\n      return dotDefault.override\n    },\n    set: function (val) {\n      dotDefault.override = !!val\n    }\n  })\n})\n\n;['useArray', 'keepArray', 'useBrackets'].forEach(function (prop) {\n  Object.defineProperty(DotObject, prop, {\n    get: function () {\n      return dotDefault[prop]\n    },\n    set: function (val) {\n      dotDefault[prop] = val\n    }\n  })\n})\n\nDotObject._process = _process\n\nmodule.exports = DotObject\n", "'use strict'\n\nfunction _process (v, mod) {\n  var i\n  var r\n\n  if (typeof mod === 'function') {\n    r = mod(v)\n    if (r !== undefined) {\n      v = r\n    }\n  } else if (Array.isArray(mod)) {\n    for (i = 0; i < mod.length; i++) {\n      r = mod[i](v)\n      if (r !== undefined) {\n        v = r\n      }\n    }\n  }\n\n  return v\n}\n\nfunction parseKey (key, val) {\n  // detect negative index notation\n  if (key[0] === '-' && Array.isArray(val) && /^-\\d+$/.test(key)) {\n    return val.length + parseInt(key, 10)\n  }\n  return key\n}\n\nfunction isIndex (k) {\n  return /^\\d+$/.test(k)\n}\n\nfunction isObject (val) {\n  return Object.prototype.toString.call(val) === '[object Object]'\n}\n\nfunction isArrayOrObject (val) {\n  return Object(val) === val\n}\n\nfunction isEmptyObject (val) {\n  return Object.keys(val).length === 0\n}\n\nfunction parsePath (path, sep) {\n  if (path.indexOf('[') >= 0) {\n    path = path.replace(/\\[/g, '.').replace(/]/g, '')\n  }\n  return path.split(sep)\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction DotObject (separator, override, useArray, useBrackets) {\n  if (!(this instanceof DotObject)) {\n    return new DotObject(separator, override, useArray, useBrackets)\n  }\n\n  if (typeof override === 'undefined') override = false\n  if (typeof useArray === 'undefined') useArray = true\n  if (typeof useBrackets === 'undefined') useBrackets = true\n  this.separator = separator || '.'\n  this.override = override\n  this.useArray = useArray\n  this.useBrackets = useBrackets\n  this.keepArray = false\n\n  // contains touched arrays\n  this.cleanup = []\n}\n\nvar dotDefault = new DotObject('.', false, true, true)\nfunction wrap (method) {\n  return function () {\n    return dotDefault[method].apply(dotDefault, arguments)\n  }\n}\n\nDotObject.prototype._fill = function (a, obj, v, mod) {\n  var k = a.shift()\n\n  if (a.length > 0) {\n    obj[k] = obj[k] ||\n      (this.useArray && isIndex(a[0]) ? [] : {})\n\n    if (!isArrayOrObject(obj[k])) {\n      if (this.override) {\n        obj[k] = {}\n      } else {\n        if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n          throw new Error(\n            'Trying to redefine `' + k + '` which is a ' + typeof obj[k]\n          )\n        }\n\n        return\n      }\n    }\n\n    this._fill(a, obj[k], v, mod)\n  } else {\n    if (!this.override &&\n      isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {\n      if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n        throw new Error(\"Trying to redefine non-empty obj['\" + k + \"']\")\n      }\n\n      return\n    }\n\n    obj[k] = _process(v, mod)\n  }\n}\n\n/**\n *\n * Converts an object with dotted-key/value pairs to it's expanded version\n *\n * Optionally transformed by a set of modifiers.\n *\n * Usage:\n *\n *   var row = {\n *     'nr': 200,\n *     'doc.name': '  My Document  '\n *   }\n *\n *   var mods = {\n *     'doc.name': [_s.trim, _s.underscored]\n *   }\n *\n *   dot.object(row, mods)\n *\n * @param {Object} obj\n * @param {Object} mods\n */\nDotObject.prototype.object = function (obj, mods) {\n  var self = this\n\n  Object.keys(obj).forEach(function (k) {\n    var mod = mods === undefined ? null : mods[k]\n    // normalize array notation.\n    var ok = parsePath(k, self.separator).join(self.separator)\n\n    if (ok.indexOf(self.separator) !== -1) {\n      self._fill(ok.split(self.separator), obj, obj[k], mod)\n      delete obj[k]\n    } else {\n      obj[k] = _process(obj[k], mod)\n    }\n  })\n\n  return obj\n}\n\n/**\n * @param {String} path dotted path\n * @param {String} v value to be set\n * @param {Object} obj object to be modified\n * @param {Function|Array} mod optional modifier\n */\nDotObject.prototype.str = function (path, v, obj, mod) {\n  var ok = parsePath(path, this.separator).join(this.separator)\n\n  if (path.indexOf(this.separator) !== -1) {\n    this._fill(ok.split(this.separator), obj, v, mod)\n  } else {\n    obj[path] = _process(v, mod)\n  }\n\n  return obj\n}\n\n/**\n *\n * Pick a value from an object using dot notation.\n *\n * Optionally remove the value\n *\n * @param {String} path\n * @param {Object} obj\n * @param {Boolean} remove\n */\nDotObject.prototype.pick = function (path, obj, remove, reindexArray) {\n  var i\n  var keys\n  var val\n  var key\n  var cp\n\n  keys = parsePath(path, this.separator)\n  for (i = 0; i < keys.length; i++) {\n    key = parseKey(keys[i], obj)\n    if (obj && typeof obj === 'object' && key in obj) {\n      if (i === (keys.length - 1)) {\n        if (remove) {\n          val = obj[key]\n          if (reindexArray && Array.isArray(obj)) {\n            obj.splice(key, 1)\n          } else {\n            delete obj[key]\n          }\n          if (Array.isArray(obj)) {\n            cp = keys.slice(0, -1).join('.')\n            if (this.cleanup.indexOf(cp) === -1) {\n              this.cleanup.push(cp)\n            }\n          }\n          return val\n        } else {\n          return obj[key]\n        }\n      } else {\n        obj = obj[key]\n      }\n    } else {\n      return undefined\n    }\n  }\n  if (remove && Array.isArray(obj)) {\n    obj = obj.filter(function (n) { return n !== undefined })\n  }\n  return obj\n}\n/**\n *\n * Delete value from an object using dot notation.\n *\n * @param {String} path\n * @param {Object} obj\n * @return {any} The removed value\n */\nDotObject.prototype.delete = function (path, obj) {\n  return this.remove(path, obj, true)\n}\n\n/**\n *\n * Remove value from an object using dot notation.\n *\n * Will remove multiple items if path is an array.\n * In this case array indexes will be retained until all\n * removals have been processed.\n *\n * Use dot.delete() to automatically  re-index arrays.\n *\n * @param {String|Array<String>} path\n * @param {Object} obj\n * @param {Boolean} reindexArray\n * @return {any} The removed value\n */\nDotObject.prototype.remove = function (path, obj, reindexArray) {\n  var i\n\n  this.cleanup = []\n  if (Array.isArray(path)) {\n    for (i = 0; i < path.length; i++) {\n      this.pick(path[i], obj, true, reindexArray)\n    }\n    if (!reindexArray) {\n      this._cleanup(obj)\n    }\n    return obj\n  } else {\n    return this.pick(path, obj, true, reindexArray)\n  }\n}\n\nDotObject.prototype._cleanup = function (obj) {\n  var ret\n  var i\n  var keys\n  var root\n  if (this.cleanup.length) {\n    for (i = 0; i < this.cleanup.length; i++) {\n      keys = this.cleanup[i].split('.')\n      root = keys.splice(0, -1).join('.')\n      ret = root ? this.pick(root, obj) : obj\n      ret = ret[keys[0]].filter(function (v) { return v !== undefined })\n      this.set(this.cleanup[i], ret, obj)\n    }\n    this.cleanup = []\n  }\n}\n\n/**\n * Alias method  for `dot.remove`\n *\n * Note: this is not an alias for dot.delete()\n *\n * @param {String|Array<String>} path\n * @param {Object} obj\n * @param {Boolean} reindexArray\n * @return {any} The removed value\n */\nDotObject.prototype.del = DotObject.prototype.remove\n\n/**\n *\n * Move a property from one place to the other.\n *\n * If the source path does not exist (undefined)\n * the target property will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.move = function (source, target, obj, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(target, _process(this.pick(source, obj, true), mods), obj, merge)\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj, true), obj, merge)\n  }\n\n  return obj\n}\n\n/**\n *\n * Transfer a property from one object to another object.\n *\n * If the source path does not exist (undefined)\n * the property on the other object will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.transfer = function (source, target, obj1, obj2, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(target,\n      _process(\n        this.pick(source, obj1, true),\n        mods\n      ), obj2, merge)\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj1, true), obj2, merge)\n  }\n\n  return obj2\n}\n\n/**\n *\n * Copy a property from one object to another object.\n *\n * If the source path does not exist (undefined)\n * the property on the other object will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.copy = function (source, target, obj1, obj2, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(target,\n      _process(\n        // clone what is picked\n        JSON.parse(\n          JSON.stringify(\n            this.pick(source, obj1, false)\n          )\n        ),\n        mods\n      ), obj2, merge)\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj1, false), obj2, merge)\n  }\n\n  return obj2\n}\n\n/**\n *\n * Set a property on an object using dot notation.\n *\n * @param {String} path\n * @param {any} val\n * @param {Object} obj\n * @param {Boolean} merge\n */\nDotObject.prototype.set = function (path, val, obj, merge) {\n  var i\n  var k\n  var keys\n  var key\n\n  // Do not operate if the value is undefined.\n  if (typeof val === 'undefined') {\n    return obj\n  }\n  keys = parsePath(path, this.separator)\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i]\n    if (i === (keys.length - 1)) {\n      if (merge && isObject(val) && isObject(obj[key])) {\n        for (k in val) {\n          if (hasOwnProperty.call(val, k)) {\n            obj[key][k] = val[k]\n          }\n        }\n      } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {\n        for (var j = 0; j < val.length; j++) {\n          obj[keys[i]].push(val[j])\n        }\n      } else {\n        obj[key] = val\n      }\n    } else if (\n      // force the value to be an object\n      !hasOwnProperty.call(obj, key) ||\n      (!isObject(obj[key]) && !Array.isArray(obj[key]))\n    ) {\n      // initialize as array if next key is numeric\n      if (/^\\d+$/.test(keys[i + 1])) {\n        obj[key] = []\n      } else {\n        obj[key] = {}\n      }\n    }\n    obj = obj[key]\n  }\n  return obj\n}\n\n/**\n *\n * Transform an object\n *\n * Usage:\n *\n *   var obj = {\n *     \"id\": 1,\n  *    \"some\": {\n  *      \"thing\": \"else\"\n  *    }\n *   }\n *\n *   var transform = {\n *     \"id\": \"nr\",\n  *    \"some.thing\": \"name\"\n *   }\n *\n *   var tgt = dot.transform(transform, obj)\n *\n * @param {Object} recipe Transform recipe\n * @param {Object} obj Object to be transformed\n * @param {Array} mods modifiers for the target\n */\nDotObject.prototype.transform = function (recipe, obj, tgt) {\n  obj = obj || {}\n  tgt = tgt || {}\n  Object.keys(recipe).forEach(function (key) {\n    this.set(recipe[key], this.pick(key, obj), tgt)\n  }.bind(this))\n  return tgt\n}\n\n/**\n *\n * Convert object to dotted-key/value pair\n *\n * Usage:\n *\n *   var tgt = dot.dot(obj)\n *\n *   or\n *\n *   var tgt = {}\n *   dot.dot(obj, tgt)\n *\n * @param {Object} obj source object\n * @param {Object} tgt target object\n * @param {Array} path path array (internal)\n */\nDotObject.prototype.dot = function (obj, tgt, path) {\n  tgt = tgt || {}\n  path = path || []\n  var isArray = Array.isArray(obj)\n\n  Object.keys(obj).forEach(function (key) {\n    var index = isArray && this.useBrackets ? '[' + key + ']' : key\n    if (\n      (\n        isArrayOrObject(obj[key]) &&\n        (\n          (isObject(obj[key]) && !isEmptyObject(obj[key])) ||\n          (Array.isArray(obj[key]) && (!this.keepArray && (obj[key].length !== 0)))\n        )\n      )\n    ) {\n      if (isArray && this.useBrackets) {\n        var previousKey = path[path.length - 1] || ''\n        return this.dot(obj[key], tgt, path.slice(0, -1).concat(previousKey + index))\n      } else {\n        return this.dot(obj[key], tgt, path.concat(index))\n      }\n    } else {\n      if (isArray && this.useBrackets) {\n        tgt[path.join(this.separator).concat('[' + key + ']')] = obj[key]\n      } else {\n        tgt[path.concat(index).join(this.separator)] = obj[key]\n      }\n    }\n  }.bind(this))\n  return tgt\n}\n\nDotObject.pick = wrap('pick')\nDotObject.move = wrap('move')\nDotObject.transfer = wrap('transfer')\nDotObject.transform = wrap('transform')\nDotObject.copy = wrap('copy')\nDotObject.object = wrap('object')\nDotObject.str = wrap('str')\nDotObject.set = wrap('set')\nDotObject.delete = wrap('delete')\nDotObject.del = DotObject.remove = wrap('remove')\nDotObject.dot = wrap('dot')\n\n;['override', 'overwrite'].forEach(function (prop) {\n  Object.defineProperty(DotObject, prop, {\n    get: function () {\n      return dotDefault.override\n    },\n    set: function (val) {\n      dotDefault.override = !!val\n    }\n  })\n})\n\n;['useArray', 'keepArray', 'useBrackets'].forEach(function (prop) {\n  Object.defineProperty(DotObject, prop, {\n    get: function () {\n      return dotDefault[prop]\n    },\n    set: function (val) {\n      dotDefault[prop] = val\n    }\n  })\n})\n\nDotObject._process = _process\n", "'use strict'\n\n/* jshint -W030 */\n\nrequire('should')\nvar Dot = require('../index')\n\ndescribe('Dotted Array notation', function () {\n  var src\n\n  beforeEach(function () {\n    src = {\n      path: [{\n        longitude: 5.512482166290283,\n        latitude: 52.5006217956543\n      }, {\n        longitude: 5.512370586395264,\n        latitude: 52.50059509277344\n      }, {\n        longitude: 5.512370586395264,\n        latitude: 52.50059509277344\n      }]\n    }\n  })\n\n  function runVariant (type) {\n    var v = function (v) {\n      if (type === 'bracket') {\n        // rewrite some.prop.1 to some.prop[1]\n        return v.replace(/\\.(-?\\d+)/g, '[$1]')\n      } else {\n        return v\n      }\n    }\n\n    describe('can pick', function () {\n      it('index', function () {\n        Dot.pick(v('path.0'), src).should.eql(src.path[0])\n        Dot.pick(v('path.2'), src).should.eql(src.path[2])\n        ;(typeof Dot.pick(v('path.9'), src)).should.eql('undefined')\n      })\n\n      it('negative index', function () {\n        Dot.pick(v('path.-1'), src).should.eql(src.path[2])\n        Dot.pick(v('path.-2'), src).should.eql(src.path[1])\n        Dot.pick(v('path.-3'), src).should.eql(src.path[0])\n        ;(typeof Dot.pick(v('path.-9'), src)).should.eql('undefined')\n      })\n\n      it('non-array `-` prefixed properties', function () {\n        var src = {\n          path: {\n            '-1': 'test1',\n            '-2': 'test2',\n            '-3': 'test3',\n            '----key': 'test4'\n          }\n        }\n        Dot.pick(v('path.-1'), src).should.eql('test1')\n        Dot.pick(v('path.-2'), src).should.eql('test2')\n        Dot.pick(v('path.-3'), src).should.eql('test3')\n        Dot.pick(v('path.----key'), src).should.eql('test4')\n        ;(typeof Dot.pick(v('path.-9'), src)).should.eql('undefined')\n      })\n\n      it('multiple indexes', function () {\n        var src = {\n          I: [\n            { am: [{ nes: ['ted'] }] },\n            { me: 'too' }\n          ]\n        }\n\n        Dot.pick(v('I.0'), src).should.eql(src.I[0])\n        Dot.pick(v('I.0.am'), src).should.eql(src.I[0].am)\n        Dot.pick(v('I.0.am.0'), src).should.eql(src.I[0].am[0])\n        Dot.pick(v('I.0.am.0.nes'), src).should.eql(src.I[0].am[0].nes)\n        Dot.pick(v('I.0.am.0.nes.0'), src).should.eql('ted')\n        Dot.pick(v('I.1.me'), src).should.eql('too')\n      })\n    })\n\n    describe('can set', function () {\n      it('index at target', function () {\n        var obj = { path: [] }\n\n        Dot.set(v('path.0'), 'test', obj)\n        Dot.set(v('path.1'), 'test2', obj)\n\n        obj.path.should.be.instanceOf(Array)\n        obj.should.eql({ path: ['test', 'test2'] })\n      })\n\n      it('index and set undefined for empty indices', function () {\n        var obj = { path: [] }\n\n        Dot.set(v('path.0'), 'test', obj)\n        Dot.set(v('path.2'), 'test2', obj)\n\n        obj.path.should.be.instanceOf(Array)\n\n        // array will have an undefined index.\n        JSON.stringify(obj)\n          .should.eql(\n            JSON.stringify({ path: ['test', undefined, 'test2'] })\n          )\n\n        // to json will converted it to null\n        JSON.stringify(obj).should.eql('{\"path\":[\"test\",null,\"test2\"]}')\n      })\n\n      it('index and overwrite existing values', function () {\n        var obj = { path: ['still', 'shall', 'be', 'gone', 'here'] }\n\n        Dot.set(v('path.1'), 'x', obj)\n        Dot.set(v('path.2'), 'xx', obj)\n        Dot.set(v('path.3'), 'xxx', obj)\n\n        obj.should.eql({ path: ['still', 'x', 'xx', 'xxx', 'here'] })\n      })\n    })\n\n    describe('can remove', function () {\n      it('indexes one by one leaving traces', function () {\n        var obj = { path: ['still', 'shall', 'really', 'be', 'gone', 'here'] }\n\n        Dot.remove(v('path.1'), obj)\n        Dot.remove(v('path.2'), obj)\n        Dot.del(v('path.3'), obj) // use alias\n        Dot.del(v('path.4'), obj)\n\n        // array will have an undefined index.\n        JSON.stringify(obj)\n          .should.eql(\n            JSON.stringify({\n              path: [\n                'still', undefined, undefined, undefined, undefined, 'here'\n              ]\n            })\n          )\n\n        // to json will converted it to null\n        JSON.stringify(obj).should.eql(\n          '{\"path\":[\"still\",null,null,null,null,\"here\"]}'\n        )\n      })\n\n      it('array of indexes leaving no traces', function () {\n        var obj = { path: ['still', 'shall', 'really', 'be', 'gone', 'here'] }\n\n        Dot.remove([\n          v('path.1'),\n          v('path.2'),\n          v('path.3'),\n          v('path.4')], obj)\n\n        JSON.stringify(obj).should.eql('{\"path\":[\"still\",\"here\"]}')\n      })\n    })\n  }\n\n  describe('with dot notation', function () {\n    runVariant()\n  })\n\n  // extra logic no real benefit.\n  describe('with bracket notation', function () {\n    runVariant('bracket')\n  })\n})\n", "'use strict'\n\nrequire('should')\nvar _s = require('underscore.string')\nvar Dot = require('../index')\n\ndescribe('Object test:', function () {\n  it('Should expand dotted keys', function () {\n    var row = {\n      id: 2,\n      'contact.name.first': 'John',\n      'contact.name.last': 'Doe',\n      'contact.email': 'example@gmail.com',\n      'contact.info.about.me': 'classified'\n    }\n\n    Dot.object(row)\n\n    row.should.eql({\n      id: 2,\n      contact: {\n        name: {\n          first: 'John',\n          last: 'Doe'\n        },\n        email: 'example@gmail.com',\n        info: {\n          about: {\n            me: 'classified'\n          }\n        }\n      }\n    })\n  })\n\n  it('Should expand dotted keys with array notation', function () {\n    var row = {\n      id: 2,\n      'my.arr.0': 'one',\n      'my.arr.1': 'two',\n      'my.arr.2': 'three',\n      'my.arr2[0]': 'one',\n      'my.arr2[1]': 'two',\n      'my.arr2[2]': 'three'\n    }\n\n    Dot.object(row)\n\n    row.should.eql({\n      id: 2,\n      my: {\n        arr: ['one', 'two', 'three'],\n        arr2: ['one', 'two', 'three']\n      }\n    })\n  })\n\n  it('Should allow keys with numbers', function () {\n    var row = {\n      id: 2,\n      '0A': 'a',\n      '0A9': 'b',\n      '0B.1AB.A34C9': 'c'\n    }\n\n    Dot.object(row)\n\n    row.should.eql({\n      id: 2,\n      '0A': 'a',\n      '0A9': 'b',\n      '0B': {\n        '1AB': {\n          A34C9: 'c'\n        }\n      }\n    })\n  })\n\n  it('Should expand dotted string', function () {\n    var tgt = {}\n\n    Dot.str('this.is.my.string', 'value', tgt)\n\n    tgt.should.eql({\n      this: {\n        is: {\n          my: {\n            string: 'value'\n          }\n        }\n      }\n    })\n  })\n\n  it('Dot.str Redefinition should fail', function () {\n    var tgt = {\n      already: 'set'\n    }\n\n    ;(function () {\n      Dot.str('already.new', 'value', tgt)\n    }).should.throw('Trying to redefine `already` which is a string')\n  })\n\n  it('Dot.str should process a modifier', function () {\n    var tgt = {}\n\n    Dot.str('this.is.my.string', 'value', tgt, _s.capitalize)\n\n    tgt.should.eql({\n      this: {\n        is: {\n          my: {\n            string: 'Value'\n          }\n        }\n      }\n    })\n  })\n\n  it('Dot.str should process multiple modifiers', function () {\n    var tgt = {}\n\n    Dot.str(\n      'this.is.my.string',\n      '  this is a test   ',\n      tgt, [_s.trim, _s.underscored]\n    )\n\n    tgt.should.eql({\n      this: {\n        is: {\n          my: {\n            string: 'this_is_a_test'\n          }\n        }\n      }\n    })\n  })\n\n  it('Dot.object should process a modifier', function () {\n    var row = {\n      'page.title': 'my page',\n      'page.slug': 'My Page'\n    }\n\n    var mods = {\n      'page.title': _s.titleize,\n      'page.slug': _s.slugify\n    }\n\n    Dot.object(row, mods)\n\n    row.should.eql({ page: { title: 'My Page', slug: 'my-page' } })\n  })\n\n  it('should process root properties',\n    function () {\n      var row = {\n        nr: 200,\n        'nested.nr': 200\n      }\n\n      var mods = {\n        nr: [val => val * 2],\n        'nested.nr': [val => val * 2]\n      }\n\n      Dot.object(row, mods)\n\n      row.should.eql({ nr: 400, nested: { nr: 400 } })\n    }\n  )\n\n  it('should process non dot value with modifier when override is false',\n    function () {\n      var row = { title: 'my page', slug: 'My Page' }\n\n      var mods = { title: _s.titleize, slug: _s.slugify }\n\n      Dot.object(row, mods)\n\n      row.should.eql({ title: 'My Page', slug: 'my-page' })\n    }\n  )\n\n  it('Dot.object should process multiple modifiers', function () {\n    var row = { 'page.name': '    My Page    ' }\n\n    var mods = { 'page.name': [_s.trim, _s.underscored] }\n\n    Dot.object(row, mods)\n\n    row.should.eql({ page: { name: 'my_page' } })\n  })\n\n  it('Dot.object should work with a different separator', function () {\n    var row = { 'page=>name': '    My Page    ' }\n\n    var mods = { 'page=>name': [_s.trim, _s.underscored] }\n\n    var dot = new Dot('=>', false)\n    dot.object(row, mods)\n\n    row.should.eql({ page: { name: 'my_page' } })\n  })\n})\n", "'use strict'\n\nrequire('should')\nvar Dot = require('../index')\n\ndescribe('str:', function () {\n  it('can set root property', function () {\n    Dot.str('b', 2, {\n      a: 1\n    }).should.deepEqual({\n      a: 1,\n      b: 2\n    })\n  })\n\n  it('can set nested property', function () {\n    Dot.str('b.a', 2, {\n      a: 1\n    }).should.deepEqual({\n      a: 1,\n      b: {\n        a: 2\n      }\n    })\n  })\n\n  it('can set nested with array notation', function () {\n    var obj = {\n      a: 1\n    }\n    Dot.str('object.fields[0].subfield', 'value', obj)\n    Dot.str('object.fields[1].subfield', 'value1', obj)\n\n    obj.should.deepEqual({\n      a: 1,\n      object: {\n        fields: [{\n          subfield: 'value'\n        }, {\n          subfield: 'value1'\n        }]\n      }\n    })\n  })\n\n  it('can set root level property regardless whether override is set', function () {\n    Dot.str('a', 'b', {\n      a: 1\n    }).should.deepEqual({\n      a: 'b'\n    })\n  })\n})\n"], "fixing_code": ["'use strict'\n\nfunction _process (v, mod) {\n  var i\n  var r\n\n  if (typeof mod === 'function') {\n    r = mod(v)\n    if (r !== undefined) {\n      v = r\n    }\n  } else if (Array.isArray(mod)) {\n    for (i = 0; i < mod.length; i++) {\n      r = mod[i](v)\n      if (r !== undefined) {\n        v = r\n      }\n    }\n  }\n\n  return v\n}\n\nfunction parseKey (key, val) {\n  // detect negative index notation\n  if (key[0] === '-' && Array.isArray(val) && /^-\\d+$/.test(key)) {\n    return val.length + parseInt(key, 10)\n  }\n  return key\n}\n\nfunction isIndex (k) {\n  return /^\\d+$/.test(k)\n}\n\nfunction isObject (val) {\n  return Object.prototype.toString.call(val) === '[object Object]'\n}\n\nfunction isArrayOrObject (val) {\n  return Object(val) === val\n}\n\nfunction isEmptyObject (val) {\n  return Object.keys(val).length === 0\n}\n\nconst blacklist = ['__proto__', 'prototype', 'constructor']\n\nfunction parsePath (path, sep) {\n  if (path.indexOf('[') >= 0) {\n    path = path.replace(/\\[/g, '.').replace(/]/g, '')\n  }\n\n  const parts = path.split(sep)\n\n  const check = parts.filter(part => blacklist.indexOf(part) === -1)\n\n  if (check.length !== parts.length) {\n    throw Error('Refusing to update blacklisted property ' + path)\n  }\n\n  return parts\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction DotObject (separator, override, useArray, useBrackets) {\n  if (!(this instanceof DotObject)) {\n    return new DotObject(separator, override, useArray, useBrackets)\n  }\n\n  if (typeof override === 'undefined') override = false\n  if (typeof useArray === 'undefined') useArray = true\n  if (typeof useBrackets === 'undefined') useBrackets = true\n  this.separator = separator || '.'\n  this.override = override\n  this.useArray = useArray\n  this.useBrackets = useBrackets\n  this.keepArray = false\n\n  // contains touched arrays\n  this.cleanup = []\n}\n\nvar dotDefault = new DotObject('.', false, true, true)\nfunction wrap (method) {\n  return function () {\n    return dotDefault[method].apply(dotDefault, arguments)\n  }\n}\n\nDotObject.prototype._fill = function (a, obj, v, mod) {\n  var k = a.shift()\n\n  if (a.length > 0) {\n    obj[k] = obj[k] || (this.useArray && isIndex(a[0]) ? [] : {})\n\n    if (!isArrayOrObject(obj[k])) {\n      if (this.override) {\n        obj[k] = {}\n      } else {\n        if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n          throw new Error(\n            'Trying to redefine `' + k + '` which is a ' + typeof obj[k]\n          )\n        }\n\n        return\n      }\n    }\n\n    this._fill(a, obj[k], v, mod)\n  } else {\n    if (!this.override && isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {\n      if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n        throw new Error(\"Trying to redefine non-empty obj['\" + k + \"']\")\n      }\n\n      return\n    }\n\n    obj[k] = _process(v, mod)\n  }\n}\n\n/**\n *\n * Converts an object with dotted-key/value pairs to it's expanded version\n *\n * Optionally transformed by a set of modifiers.\n *\n * Usage:\n *\n *   var row = {\n *     'nr': 200,\n *     'doc.name': '  My Document  '\n *   }\n *\n *   var mods = {\n *     'doc.name': [_s.trim, _s.underscored]\n *   }\n *\n *   dot.object(row, mods)\n *\n * @param {Object} obj\n * @param {Object} mods\n */\nDotObject.prototype.object = function (obj, mods) {\n  var self = this\n\n  Object.keys(obj).forEach(function (k) {\n    var mod = mods === undefined ? null : mods[k]\n    // normalize array notation.\n    var ok = parsePath(k, self.separator).join(self.separator)\n\n    if (ok.indexOf(self.separator) !== -1) {\n      self._fill(ok.split(self.separator), obj, obj[k], mod)\n      delete obj[k]\n    } else {\n      obj[k] = _process(obj[k], mod)\n    }\n  })\n\n  return obj\n}\n\n/**\n * @param {String} path dotted path\n * @param {String} v value to be set\n * @param {Object} obj object to be modified\n * @param {Function|Array} mod optional modifier\n */\nDotObject.prototype.str = function (path, v, obj, mod) {\n  var ok = parsePath(path, this.separator).join(this.separator)\n\n  if (path.indexOf(this.separator) !== -1) {\n    this._fill(ok.split(this.separator), obj, v, mod)\n  } else {\n    obj[path] = _process(v, mod)\n  }\n\n  return obj\n}\n\n/**\n *\n * Pick a value from an object using dot notation.\n *\n * Optionally remove the value\n *\n * @param {String} path\n * @param {Object} obj\n * @param {Boolean} remove\n */\nDotObject.prototype.pick = function (path, obj, remove, reindexArray) {\n  var i\n  var keys\n  var val\n  var key\n  var cp\n\n  keys = parsePath(path, this.separator)\n  for (i = 0; i < keys.length; i++) {\n    key = parseKey(keys[i], obj)\n    if (obj && typeof obj === 'object' && key in obj) {\n      if (i === keys.length - 1) {\n        if (remove) {\n          val = obj[key]\n          if (reindexArray && Array.isArray(obj)) {\n            obj.splice(key, 1)\n          } else {\n            delete obj[key]\n          }\n          if (Array.isArray(obj)) {\n            cp = keys.slice(0, -1).join('.')\n            if (this.cleanup.indexOf(cp) === -1) {\n              this.cleanup.push(cp)\n            }\n          }\n          return val\n        } else {\n          return obj[key]\n        }\n      } else {\n        obj = obj[key]\n      }\n    } else {\n      return undefined\n    }\n  }\n  if (remove && Array.isArray(obj)) {\n    obj = obj.filter(function (n) {\n      return n !== undefined\n    })\n  }\n  return obj\n}\n/**\n *\n * Delete value from an object using dot notation.\n *\n * @param {String} path\n * @param {Object} obj\n * @return {any} The removed value\n */\nDotObject.prototype.delete = function (path, obj) {\n  return this.remove(path, obj, true)\n}\n\n/**\n *\n * Remove value from an object using dot notation.\n *\n * Will remove multiple items if path is an array.\n * In this case array indexes will be retained until all\n * removals have been processed.\n *\n * Use dot.delete() to automatically  re-index arrays.\n *\n * @param {String|Array<String>} path\n * @param {Object} obj\n * @param {Boolean} reindexArray\n * @return {any} The removed value\n */\nDotObject.prototype.remove = function (path, obj, reindexArray) {\n  var i\n\n  this.cleanup = []\n  if (Array.isArray(path)) {\n    for (i = 0; i < path.length; i++) {\n      this.pick(path[i], obj, true, reindexArray)\n    }\n    if (!reindexArray) {\n      this._cleanup(obj)\n    }\n    return obj\n  } else {\n    return this.pick(path, obj, true, reindexArray)\n  }\n}\n\nDotObject.prototype._cleanup = function (obj) {\n  var ret\n  var i\n  var keys\n  var root\n  if (this.cleanup.length) {\n    for (i = 0; i < this.cleanup.length; i++) {\n      keys = this.cleanup[i].split('.')\n      root = keys.splice(0, -1).join('.')\n      ret = root ? this.pick(root, obj) : obj\n      ret = ret[keys[0]].filter(function (v) {\n        return v !== undefined\n      })\n      this.set(this.cleanup[i], ret, obj)\n    }\n    this.cleanup = []\n  }\n}\n\n/**\n * Alias method  for `dot.remove`\n *\n * Note: this is not an alias for dot.delete()\n *\n * @param {String|Array<String>} path\n * @param {Object} obj\n * @param {Boolean} reindexArray\n * @return {any} The removed value\n */\nDotObject.prototype.del = DotObject.prototype.remove\n\n/**\n *\n * Move a property from one place to the other.\n *\n * If the source path does not exist (undefined)\n * the target property will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.move = function (source, target, obj, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(target, _process(this.pick(source, obj, true), mods), obj, merge)\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj, true), obj, merge)\n  }\n\n  return obj\n}\n\n/**\n *\n * Transfer a property from one object to another object.\n *\n * If the source path does not exist (undefined)\n * the property on the other object will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.transfer = function (\n  source,\n  target,\n  obj1,\n  obj2,\n  mods,\n  merge\n) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(\n      target,\n      _process(this.pick(source, obj1, true), mods),\n      obj2,\n      merge\n    )\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj1, true), obj2, merge)\n  }\n\n  return obj2\n}\n\n/**\n *\n * Copy a property from one object to another object.\n *\n * If the source path does not exist (undefined)\n * the property on the other object will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.copy = function (source, target, obj1, obj2, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(\n      target,\n      _process(\n        // clone what is picked\n        JSON.parse(JSON.stringify(this.pick(source, obj1, false))),\n        mods\n      ),\n      obj2,\n      merge\n    )\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj1, false), obj2, merge)\n  }\n\n  return obj2\n}\n\n/**\n *\n * Set a property on an object using dot notation.\n *\n * @param {String} path\n * @param {any} val\n * @param {Object} obj\n * @param {Boolean} merge\n */\nDotObject.prototype.set = function (path, val, obj, merge) {\n  var i\n  var k\n  var keys\n  var key\n\n  // Do not operate if the value is undefined.\n  if (typeof val === 'undefined') {\n    return obj\n  }\n  keys = parsePath(path, this.separator)\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i]\n    if (i === keys.length - 1) {\n      if (merge && isObject(val) && isObject(obj[key])) {\n        for (k in val) {\n          if (hasOwnProperty.call(val, k)) {\n            obj[key][k] = val[k]\n          }\n        }\n      } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {\n        for (var j = 0; j < val.length; j++) {\n          obj[keys[i]].push(val[j])\n        }\n      } else {\n        obj[key] = val\n      }\n    } else if (\n      // force the value to be an object\n      !hasOwnProperty.call(obj, key) ||\n      (!isObject(obj[key]) && !Array.isArray(obj[key]))\n    ) {\n      // initialize as array if next key is numeric\n      if (/^\\d+$/.test(keys[i + 1])) {\n        obj[key] = []\n      } else {\n        obj[key] = {}\n      }\n    }\n    obj = obj[key]\n  }\n  return obj\n}\n\n/**\n *\n * Transform an object\n *\n * Usage:\n *\n *   var obj = {\n *     \"id\": 1,\n *    \"some\": {\n *      \"thing\": \"else\"\n *    }\n *   }\n *\n *   var transform = {\n *     \"id\": \"nr\",\n *    \"some.thing\": \"name\"\n *   }\n *\n *   var tgt = dot.transform(transform, obj)\n *\n * @param {Object} recipe Transform recipe\n * @param {Object} obj Object to be transformed\n * @param {Array} mods modifiers for the target\n */\nDotObject.prototype.transform = function (recipe, obj, tgt) {\n  obj = obj || {}\n  tgt = tgt || {}\n  Object.keys(recipe).forEach(\n    function (key) {\n      this.set(recipe[key], this.pick(key, obj), tgt)\n    }.bind(this)\n  )\n  return tgt\n}\n\n/**\n *\n * Convert object to dotted-key/value pair\n *\n * Usage:\n *\n *   var tgt = dot.dot(obj)\n *\n *   or\n *\n *   var tgt = {}\n *   dot.dot(obj, tgt)\n *\n * @param {Object} obj source object\n * @param {Object} tgt target object\n * @param {Array} path path array (internal)\n */\nDotObject.prototype.dot = function (obj, tgt, path) {\n  tgt = tgt || {}\n  path = path || []\n  var isArray = Array.isArray(obj)\n\n  Object.keys(obj).forEach(\n    function (key) {\n      var index = isArray && this.useBrackets ? '[' + key + ']' : key\n      if (\n        isArrayOrObject(obj[key]) &&\n        ((isObject(obj[key]) && !isEmptyObject(obj[key])) ||\n          (Array.isArray(obj[key]) && !this.keepArray && obj[key].length !== 0))\n      ) {\n        if (isArray && this.useBrackets) {\n          var previousKey = path[path.length - 1] || ''\n          return this.dot(\n            obj[key],\n            tgt,\n            path.slice(0, -1).concat(previousKey + index)\n          )\n        } else {\n          return this.dot(obj[key], tgt, path.concat(index))\n        }\n      } else {\n        if (isArray && this.useBrackets) {\n          tgt[path.join(this.separator).concat('[' + key + ']')] = obj[key]\n        } else {\n          tgt[path.concat(index).join(this.separator)] = obj[key]\n        }\n      }\n    }.bind(this)\n  )\n  return tgt\n}\n\nDotObject.pick = wrap('pick')\nDotObject.move = wrap('move')\nDotObject.transfer = wrap('transfer')\nDotObject.transform = wrap('transform')\nDotObject.copy = wrap('copy')\nDotObject.object = wrap('object')\nDotObject.str = wrap('str')\nDotObject.set = wrap('set')\nDotObject.delete = wrap('delete')\nDotObject.del = DotObject.remove = wrap('remove')\nDotObject.dot = wrap('dot');\n['override', 'overwrite'].forEach(function (prop) {\n  Object.defineProperty(DotObject, prop, {\n    get: function () {\n      return dotDefault.override\n    },\n    set: function (val) {\n      dotDefault.override = !!val\n    }\n  })\n});\n['useArray', 'keepArray', 'useBrackets'].forEach(function (prop) {\n  Object.defineProperty(DotObject, prop, {\n    get: function () {\n      return dotDefault[prop]\n    },\n    set: function (val) {\n      dotDefault[prop] = val\n    }\n  })\n})\n\nDotObject._process = _process\n\nmodule.exports = DotObject\n", "'use strict'\n\nfunction _process (v, mod) {\n  var i\n  var r\n\n  if (typeof mod === 'function') {\n    r = mod(v)\n    if (r !== undefined) {\n      v = r\n    }\n  } else if (Array.isArray(mod)) {\n    for (i = 0; i < mod.length; i++) {\n      r = mod[i](v)\n      if (r !== undefined) {\n        v = r\n      }\n    }\n  }\n\n  return v\n}\n\nfunction parseKey (key, val) {\n  // detect negative index notation\n  if (key[0] === '-' && Array.isArray(val) && /^-\\d+$/.test(key)) {\n    return val.length + parseInt(key, 10)\n  }\n  return key\n}\n\nfunction isIndex (k) {\n  return /^\\d+$/.test(k)\n}\n\nfunction isObject (val) {\n  return Object.prototype.toString.call(val) === '[object Object]'\n}\n\nfunction isArrayOrObject (val) {\n  return Object(val) === val\n}\n\nfunction isEmptyObject (val) {\n  return Object.keys(val).length === 0\n}\n\nconst blacklist = ['__proto__', 'prototype', 'constructor']\n\nfunction parsePath (path, sep) {\n  if (path.indexOf('[') >= 0) {\n    path = path.replace(/\\[/g, '.').replace(/]/g, '')\n  }\n\n  const parts = path.split(sep)\n\n  const check = parts.filter(part => blacklist.indexOf(part) === -1)\n\n  if (check.length !== parts.length) {\n    throw Error('Refusing to update blacklisted property ' + path)\n  }\n\n  return parts\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction DotObject (separator, override, useArray, useBrackets) {\n  if (!(this instanceof DotObject)) {\n    return new DotObject(separator, override, useArray, useBrackets)\n  }\n\n  if (typeof override === 'undefined') override = false\n  if (typeof useArray === 'undefined') useArray = true\n  if (typeof useBrackets === 'undefined') useBrackets = true\n  this.separator = separator || '.'\n  this.override = override\n  this.useArray = useArray\n  this.useBrackets = useBrackets\n  this.keepArray = false\n\n  // contains touched arrays\n  this.cleanup = []\n}\n\nvar dotDefault = new DotObject('.', false, true, true)\nfunction wrap (method) {\n  return function () {\n    return dotDefault[method].apply(dotDefault, arguments)\n  }\n}\n\nDotObject.prototype._fill = function (a, obj, v, mod) {\n  var k = a.shift()\n\n  if (a.length > 0) {\n    obj[k] = obj[k] || (this.useArray && isIndex(a[0]) ? [] : {})\n\n    if (!isArrayOrObject(obj[k])) {\n      if (this.override) {\n        obj[k] = {}\n      } else {\n        if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n          throw new Error(\n            'Trying to redefine `' + k + '` which is a ' + typeof obj[k]\n          )\n        }\n\n        return\n      }\n    }\n\n    this._fill(a, obj[k], v, mod)\n  } else {\n    if (!this.override && isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {\n      if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n        throw new Error(\"Trying to redefine non-empty obj['\" + k + \"']\")\n      }\n\n      return\n    }\n\n    obj[k] = _process(v, mod)\n  }\n}\n\n/**\n *\n * Converts an object with dotted-key/value pairs to it's expanded version\n *\n * Optionally transformed by a set of modifiers.\n *\n * Usage:\n *\n *   var row = {\n *     'nr': 200,\n *     'doc.name': '  My Document  '\n *   }\n *\n *   var mods = {\n *     'doc.name': [_s.trim, _s.underscored]\n *   }\n *\n *   dot.object(row, mods)\n *\n * @param {Object} obj\n * @param {Object} mods\n */\nDotObject.prototype.object = function (obj, mods) {\n  var self = this\n\n  Object.keys(obj).forEach(function (k) {\n    var mod = mods === undefined ? null : mods[k]\n    // normalize array notation.\n    var ok = parsePath(k, self.separator).join(self.separator)\n\n    if (ok.indexOf(self.separator) !== -1) {\n      self._fill(ok.split(self.separator), obj, obj[k], mod)\n      delete obj[k]\n    } else {\n      obj[k] = _process(obj[k], mod)\n    }\n  })\n\n  return obj\n}\n\n/**\n * @param {String} path dotted path\n * @param {String} v value to be set\n * @param {Object} obj object to be modified\n * @param {Function|Array} mod optional modifier\n */\nDotObject.prototype.str = function (path, v, obj, mod) {\n  var ok = parsePath(path, this.separator).join(this.separator)\n\n  if (path.indexOf(this.separator) !== -1) {\n    this._fill(ok.split(this.separator), obj, v, mod)\n  } else {\n    obj[path] = _process(v, mod)\n  }\n\n  return obj\n}\n\n/**\n *\n * Pick a value from an object using dot notation.\n *\n * Optionally remove the value\n *\n * @param {String} path\n * @param {Object} obj\n * @param {Boolean} remove\n */\nDotObject.prototype.pick = function (path, obj, remove, reindexArray) {\n  var i\n  var keys\n  var val\n  var key\n  var cp\n\n  keys = parsePath(path, this.separator)\n  for (i = 0; i < keys.length; i++) {\n    key = parseKey(keys[i], obj)\n    if (obj && typeof obj === 'object' && key in obj) {\n      if (i === keys.length - 1) {\n        if (remove) {\n          val = obj[key]\n          if (reindexArray && Array.isArray(obj)) {\n            obj.splice(key, 1)\n          } else {\n            delete obj[key]\n          }\n          if (Array.isArray(obj)) {\n            cp = keys.slice(0, -1).join('.')\n            if (this.cleanup.indexOf(cp) === -1) {\n              this.cleanup.push(cp)\n            }\n          }\n          return val\n        } else {\n          return obj[key]\n        }\n      } else {\n        obj = obj[key]\n      }\n    } else {\n      return undefined\n    }\n  }\n  if (remove && Array.isArray(obj)) {\n    obj = obj.filter(function (n) {\n      return n !== undefined\n    })\n  }\n  return obj\n}\n/**\n *\n * Delete value from an object using dot notation.\n *\n * @param {String} path\n * @param {Object} obj\n * @return {any} The removed value\n */\nDotObject.prototype.delete = function (path, obj) {\n  return this.remove(path, obj, true)\n}\n\n/**\n *\n * Remove value from an object using dot notation.\n *\n * Will remove multiple items if path is an array.\n * In this case array indexes will be retained until all\n * removals have been processed.\n *\n * Use dot.delete() to automatically  re-index arrays.\n *\n * @param {String|Array<String>} path\n * @param {Object} obj\n * @param {Boolean} reindexArray\n * @return {any} The removed value\n */\nDotObject.prototype.remove = function (path, obj, reindexArray) {\n  var i\n\n  this.cleanup = []\n  if (Array.isArray(path)) {\n    for (i = 0; i < path.length; i++) {\n      this.pick(path[i], obj, true, reindexArray)\n    }\n    if (!reindexArray) {\n      this._cleanup(obj)\n    }\n    return obj\n  } else {\n    return this.pick(path, obj, true, reindexArray)\n  }\n}\n\nDotObject.prototype._cleanup = function (obj) {\n  var ret\n  var i\n  var keys\n  var root\n  if (this.cleanup.length) {\n    for (i = 0; i < this.cleanup.length; i++) {\n      keys = this.cleanup[i].split('.')\n      root = keys.splice(0, -1).join('.')\n      ret = root ? this.pick(root, obj) : obj\n      ret = ret[keys[0]].filter(function (v) {\n        return v !== undefined\n      })\n      this.set(this.cleanup[i], ret, obj)\n    }\n    this.cleanup = []\n  }\n}\n\n/**\n * Alias method  for `dot.remove`\n *\n * Note: this is not an alias for dot.delete()\n *\n * @param {String|Array<String>} path\n * @param {Object} obj\n * @param {Boolean} reindexArray\n * @return {any} The removed value\n */\nDotObject.prototype.del = DotObject.prototype.remove\n\n/**\n *\n * Move a property from one place to the other.\n *\n * If the source path does not exist (undefined)\n * the target property will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.move = function (source, target, obj, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(target, _process(this.pick(source, obj, true), mods), obj, merge)\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj, true), obj, merge)\n  }\n\n  return obj\n}\n\n/**\n *\n * Transfer a property from one object to another object.\n *\n * If the source path does not exist (undefined)\n * the property on the other object will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.transfer = function (\n  source,\n  target,\n  obj1,\n  obj2,\n  mods,\n  merge\n) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(\n      target,\n      _process(this.pick(source, obj1, true), mods),\n      obj2,\n      merge\n    )\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj1, true), obj2, merge)\n  }\n\n  return obj2\n}\n\n/**\n *\n * Copy a property from one object to another object.\n *\n * If the source path does not exist (undefined)\n * the property on the other object will not be set.\n *\n * @param {String} source\n * @param {String} target\n * @param {Object} obj1\n * @param {Object} obj2\n * @param {Function|Array} mods\n * @param {Boolean} merge\n */\nDotObject.prototype.copy = function (source, target, obj1, obj2, mods, merge) {\n  if (typeof mods === 'function' || Array.isArray(mods)) {\n    this.set(\n      target,\n      _process(\n        // clone what is picked\n        JSON.parse(JSON.stringify(this.pick(source, obj1, false))),\n        mods\n      ),\n      obj2,\n      merge\n    )\n  } else {\n    merge = mods\n    this.set(target, this.pick(source, obj1, false), obj2, merge)\n  }\n\n  return obj2\n}\n\n/**\n *\n * Set a property on an object using dot notation.\n *\n * @param {String} path\n * @param {any} val\n * @param {Object} obj\n * @param {Boolean} merge\n */\nDotObject.prototype.set = function (path, val, obj, merge) {\n  var i\n  var k\n  var keys\n  var key\n\n  // Do not operate if the value is undefined.\n  if (typeof val === 'undefined') {\n    return obj\n  }\n  keys = parsePath(path, this.separator)\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i]\n    if (i === keys.length - 1) {\n      if (merge && isObject(val) && isObject(obj[key])) {\n        for (k in val) {\n          if (hasOwnProperty.call(val, k)) {\n            obj[key][k] = val[k]\n          }\n        }\n      } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {\n        for (var j = 0; j < val.length; j++) {\n          obj[keys[i]].push(val[j])\n        }\n      } else {\n        obj[key] = val\n      }\n    } else if (\n      // force the value to be an object\n      !hasOwnProperty.call(obj, key) ||\n      (!isObject(obj[key]) && !Array.isArray(obj[key]))\n    ) {\n      // initialize as array if next key is numeric\n      if (/^\\d+$/.test(keys[i + 1])) {\n        obj[key] = []\n      } else {\n        obj[key] = {}\n      }\n    }\n    obj = obj[key]\n  }\n  return obj\n}\n\n/**\n *\n * Transform an object\n *\n * Usage:\n *\n *   var obj = {\n *     \"id\": 1,\n *    \"some\": {\n *      \"thing\": \"else\"\n *    }\n *   }\n *\n *   var transform = {\n *     \"id\": \"nr\",\n *    \"some.thing\": \"name\"\n *   }\n *\n *   var tgt = dot.transform(transform, obj)\n *\n * @param {Object} recipe Transform recipe\n * @param {Object} obj Object to be transformed\n * @param {Array} mods modifiers for the target\n */\nDotObject.prototype.transform = function (recipe, obj, tgt) {\n  obj = obj || {}\n  tgt = tgt || {}\n  Object.keys(recipe).forEach(\n    function (key) {\n      this.set(recipe[key], this.pick(key, obj), tgt)\n    }.bind(this)\n  )\n  return tgt\n}\n\n/**\n *\n * Convert object to dotted-key/value pair\n *\n * Usage:\n *\n *   var tgt = dot.dot(obj)\n *\n *   or\n *\n *   var tgt = {}\n *   dot.dot(obj, tgt)\n *\n * @param {Object} obj source object\n * @param {Object} tgt target object\n * @param {Array} path path array (internal)\n */\nDotObject.prototype.dot = function (obj, tgt, path) {\n  tgt = tgt || {}\n  path = path || []\n  var isArray = Array.isArray(obj)\n\n  Object.keys(obj).forEach(\n    function (key) {\n      var index = isArray && this.useBrackets ? '[' + key + ']' : key\n      if (\n        isArrayOrObject(obj[key]) &&\n        ((isObject(obj[key]) && !isEmptyObject(obj[key])) ||\n          (Array.isArray(obj[key]) && !this.keepArray && obj[key].length !== 0))\n      ) {\n        if (isArray && this.useBrackets) {\n          var previousKey = path[path.length - 1] || ''\n          return this.dot(\n            obj[key],\n            tgt,\n            path.slice(0, -1).concat(previousKey + index)\n          )\n        } else {\n          return this.dot(obj[key], tgt, path.concat(index))\n        }\n      } else {\n        if (isArray && this.useBrackets) {\n          tgt[path.join(this.separator).concat('[' + key + ']')] = obj[key]\n        } else {\n          tgt[path.concat(index).join(this.separator)] = obj[key]\n        }\n      }\n    }.bind(this)\n  )\n  return tgt\n}\n\nDotObject.pick = wrap('pick')\nDotObject.move = wrap('move')\nDotObject.transfer = wrap('transfer')\nDotObject.transform = wrap('transform')\nDotObject.copy = wrap('copy')\nDotObject.object = wrap('object')\nDotObject.str = wrap('str')\nDotObject.set = wrap('set')\nDotObject.delete = wrap('delete')\nDotObject.del = DotObject.remove = wrap('remove')\nDotObject.dot = wrap('dot');\n['override', 'overwrite'].forEach(function (prop) {\n  Object.defineProperty(DotObject, prop, {\n    get: function () {\n      return dotDefault.override\n    },\n    set: function (val) {\n      dotDefault.override = !!val\n    }\n  })\n});\n['useArray', 'keepArray', 'useBrackets'].forEach(function (prop) {\n  Object.defineProperty(DotObject, prop, {\n    get: function () {\n      return dotDefault[prop]\n    },\n    set: function (val) {\n      dotDefault[prop] = val\n    }\n  })\n})\n\nDotObject._process = _process\n", "'use strict'\n\n/* jshint -W030 */\n\nrequire('should')\nvar Dot = require('../index')\n\ndescribe('Dotted Array notation', function () {\n  var src\n\n  beforeEach(function () {\n    src = {\n      path: [{\n        longitude: 5.512482166290283,\n        latitude: 52.5006217956543\n      }, {\n        longitude: 5.512370586395264,\n        latitude: 52.50059509277344\n      }, {\n        longitude: 5.512370586395264,\n        latitude: 52.50059509277344\n      }]\n    }\n  })\n\n  function runVariant (type) {\n    var v = function (v) {\n      if (type === 'bracket') {\n        // rewrite some.prop.1 to some.prop[1]\n        return v.replace(/\\.(-?\\d+)/g, '[$1]')\n      } else {\n        return v\n      }\n    }\n\n    describe('can pick', function () {\n      it('index', function () {\n        Dot.pick(v('path.0'), src).should.eql(src.path[0])\n        Dot.pick(v('path.2'), src).should.eql(src.path[2])\n        ;(typeof Dot.pick(v('path.9'), src)).should.eql('undefined')\n      })\n\n      it('negative index', function () {\n        Dot.pick(v('path.-1'), src).should.eql(src.path[2])\n        Dot.pick(v('path.-2'), src).should.eql(src.path[1])\n        Dot.pick(v('path.-3'), src).should.eql(src.path[0])\n        ;(typeof Dot.pick(v('path.-9'), src)).should.eql('undefined')\n      })\n\n      it('non-array `-` prefixed properties', function () {\n        var src = {\n          path: {\n            '-1': 'test1',\n            '-2': 'test2',\n            '-3': 'test3',\n            '----key': 'test4'\n          }\n        }\n        Dot.pick(v('path.-1'), src).should.eql('test1')\n        Dot.pick(v('path.-2'), src).should.eql('test2')\n        Dot.pick(v('path.-3'), src).should.eql('test3')\n        Dot.pick(v('path.----key'), src).should.eql('test4')\n        ;(typeof Dot.pick(v('path.-9'), src)).should.eql('undefined')\n      })\n\n      it('multiple indexes', function () {\n        var src = {\n          I: [\n            { am: [{ nes: ['ted'] }] },\n            { me: 'too' }\n          ]\n        }\n\n        Dot.pick(v('I.0'), src).should.eql(src.I[0])\n        Dot.pick(v('I.0.am'), src).should.eql(src.I[0].am)\n        Dot.pick(v('I.0.am.0'), src).should.eql(src.I[0].am[0])\n        Dot.pick(v('I.0.am.0.nes'), src).should.eql(src.I[0].am[0].nes)\n        Dot.pick(v('I.0.am.0.nes.0'), src).should.eql('ted')\n        Dot.pick(v('I.1.me'), src).should.eql('too')\n      })\n    })\n\n    describe('can set', function () {\n      it('index at target', function () {\n        var obj = { path: [] }\n\n        Dot.set(v('path.0'), 'test', obj)\n        Dot.set(v('path.1'), 'test2', obj)\n\n        obj.path.should.be.instanceOf(Array)\n        obj.should.eql({ path: ['test', 'test2'] })\n      })\n\n      it('index and set undefined for empty indices', function () {\n        var obj = { path: [] }\n\n        Dot.set(v('path.0'), 'test', obj)\n        Dot.set(v('path.2'), 'test2', obj)\n\n        obj.path.should.be.instanceOf(Array)\n\n        // array will have an undefined index.\n        JSON.stringify(obj)\n          .should.eql(\n            JSON.stringify({ path: ['test', undefined, 'test2'] })\n          )\n\n        // to json will converted it to null\n        JSON.stringify(obj).should.eql('{\"path\":[\"test\",null,\"test2\"]}')\n      })\n\n      it('index and overwrite existing values', function () {\n        var obj = { path: ['still', 'shall', 'be', 'gone', 'here'] }\n\n        Dot.set(v('path.1'), 'x', obj)\n        Dot.set(v('path.2'), 'xx', obj)\n        Dot.set(v('path.3'), 'xxx', obj)\n\n        obj.should.eql({ path: ['still', 'x', 'xx', 'xxx', 'here'] })\n      })\n    })\n\n    describe('can remove', function () {\n      it('indexes one by one leaving traces', function () {\n        var obj = { path: ['still', 'shall', 'really', 'be', 'gone', 'here'] }\n\n        Dot.remove(v('path.1'), obj)\n        Dot.remove(v('path.2'), obj)\n        Dot.del(v('path.3'), obj) // use alias\n        Dot.del(v('path.4'), obj)\n\n        // array will have an undefined index.\n        JSON.stringify(obj)\n          .should.eql(\n            JSON.stringify({\n              path: [\n                'still', undefined, undefined, undefined, undefined, 'here'\n              ]\n            })\n          )\n\n        // to json will converted it to null\n        JSON.stringify(obj).should.eql(\n          '{\"path\":[\"still\",null,null,null,null,\"here\"]}'\n        )\n      })\n\n      it('array of indexes leaving no traces', function () {\n        var obj = { path: ['still', 'shall', 'really', 'be', 'gone', 'here'] }\n\n        Dot.remove([\n          v('path.1'),\n          v('path.2'),\n          v('path.3'),\n          v('path.4')], obj)\n\n        JSON.stringify(obj).should.eql('{\"path\":[\"still\",\"here\"]}')\n      })\n    })\n  }\n\n  describe('with dot notation', function () {\n    runVariant()\n  })\n\n  // extra logic no real benefit.\n  describe('with bracket notation', function () {\n    runVariant('bracket')\n  })\n\n  describe('Refuse to update __proto__', function () {\n    var obj = { path: [] }\n\n    ;(() => Dot.set('path[0].__proto__.toString', 'test', obj)).should.throw(/Refusing to update/)\n  })\n})\n", "'use strict'\n\nrequire('should')\nvar _s = require('underscore.string')\nvar Dot = require('../index')\n\ndescribe('Object test:', function () {\n  it('Should expand dotted keys', function () {\n    var row = {\n      id: 2,\n      'contact.name.first': 'John',\n      'contact.name.last': 'Doe',\n      'contact.email': 'example@gmail.com',\n      'contact.info.about.me': 'classified'\n    }\n\n    Dot.object(row)\n\n    row.should.eql({\n      id: 2,\n      contact: {\n        name: {\n          first: 'John',\n          last: 'Doe'\n        },\n        email: 'example@gmail.com',\n        info: {\n          about: {\n            me: 'classified'\n          }\n        }\n      }\n    })\n  })\n\n  it('Should expand dotted keys with array notation', function () {\n    var row = {\n      id: 2,\n      'my.arr.0': 'one',\n      'my.arr.1': 'two',\n      'my.arr.2': 'three',\n      'my.arr2[0]': 'one',\n      'my.arr2[1]': 'two',\n      'my.arr2[2]': 'three'\n    }\n\n    Dot.object(row)\n\n    row.should.eql({\n      id: 2,\n      my: {\n        arr: ['one', 'two', 'three'],\n        arr2: ['one', 'two', 'three']\n      }\n    })\n  })\n\n  it('Should allow keys with numbers', function () {\n    var row = {\n      id: 2,\n      '0A': 'a',\n      '0A9': 'b',\n      '0B.1AB.A34C9': 'c'\n    }\n\n    Dot.object(row)\n\n    row.should.eql({\n      id: 2,\n      '0A': 'a',\n      '0A9': 'b',\n      '0B': {\n        '1AB': {\n          A34C9: 'c'\n        }\n      }\n    })\n  })\n\n  it('Should expand dotted string', function () {\n    var tgt = {}\n\n    Dot.str('this.is.my.string', 'value', tgt)\n\n    tgt.should.eql({\n      this: {\n        is: {\n          my: {\n            string: 'value'\n          }\n        }\n      }\n    })\n  })\n\n  it('Dot.str Redefinition should fail', function () {\n    var tgt = {\n      already: 'set'\n    }\n\n    ;(function () {\n      Dot.str('already.new', 'value', tgt)\n    }).should.throw('Trying to redefine `already` which is a string')\n  })\n\n  it('Dot.str should process a modifier', function () {\n    var tgt = {}\n\n    Dot.str('this.is.my.string', 'value', tgt, _s.capitalize)\n\n    tgt.should.eql({\n      this: {\n        is: {\n          my: {\n            string: 'Value'\n          }\n        }\n      }\n    })\n  })\n\n  it('Dot.str should process multiple modifiers', function () {\n    var tgt = {}\n\n    Dot.str(\n      'this.is.my.string',\n      '  this is a test   ',\n      tgt, [_s.trim, _s.underscored]\n    )\n\n    tgt.should.eql({\n      this: {\n        is: {\n          my: {\n            string: 'this_is_a_test'\n          }\n        }\n      }\n    })\n  })\n\n  it('Dot.object should process a modifier', function () {\n    var row = {\n      'page.title': 'my page',\n      'page.slug': 'My Page'\n    }\n\n    var mods = {\n      'page.title': _s.titleize,\n      'page.slug': _s.slugify\n    }\n\n    Dot.object(row, mods)\n\n    row.should.eql({ page: { title: 'My Page', slug: 'my-page' } })\n  })\n\n  it('should process root properties',\n    function () {\n      var row = {\n        nr: 200,\n        'nested.nr': 200\n      }\n\n      var mods = {\n        nr: [val => val * 2],\n        'nested.nr': [val => val * 2]\n      }\n\n      Dot.object(row, mods)\n\n      row.should.eql({ nr: 400, nested: { nr: 400 } })\n    }\n  )\n\n  it('should process non dot value with modifier when override is false',\n    function () {\n      var row = { title: 'my page', slug: 'My Page' }\n\n      var mods = { title: _s.titleize, slug: _s.slugify }\n\n      Dot.object(row, mods)\n\n      row.should.eql({ title: 'My Page', slug: 'my-page' })\n    }\n  )\n\n  it('Dot.object should process multiple modifiers', function () {\n    var row = { 'page.name': '    My Page    ' }\n\n    var mods = { 'page.name': [_s.trim, _s.underscored] }\n\n    Dot.object(row, mods)\n\n    row.should.eql({ page: { name: 'my_page' } })\n  })\n\n  it('Dot.object should work with a different separator', function () {\n    var row = { 'page=>name': '    My Page    ' }\n\n    var mods = { 'page=>name': [_s.trim, _s.underscored] }\n\n    var dot = new Dot('=>', false)\n    dot.object(row, mods)\n\n    row.should.eql({ page: { name: 'my_page' } })\n  })\n\n  it('Dot.object should disallow to set __proto__', function () {\n    var row = { '__proto__.toString': 'hi' }\n\n    var dot = new Dot()\n    ;(() => dot.object(row)).should.throw(/Refusing to update/)\n  })\n})\n", "'use strict'\n\nrequire('should')\nvar Dot = require('../index')\n\ndescribe('str:', function () {\n  it('can set root property', function () {\n    Dot.str('b', 2, {\n      a: 1\n    }).should.deepEqual({\n      a: 1,\n      b: 2\n    })\n  })\n\n  it('can set nested property', function () {\n    Dot.str('b.a', 2, {\n      a: 1\n    }).should.deepEqual({\n      a: 1,\n      b: {\n        a: 2\n      }\n    })\n  })\n\n  it('can set nested with array notation', function () {\n    var obj = {\n      a: 1\n    }\n    Dot.str('object.fields[0].subfield', 'value', obj)\n    Dot.str('object.fields[1].subfield', 'value1', obj)\n\n    obj.should.deepEqual({\n      a: 1,\n      object: {\n        fields: [\n          {\n            subfield: 'value'\n          },\n          {\n            subfield: 'value1'\n          }\n        ]\n      }\n    })\n  })\n\n  it('can set root level property regardless whether override is set', function () {\n    Dot.str('a', 'b', {\n      a: 1\n    }).should.deepEqual({\n      a: 'b'\n    })\n  })\n\n  it('cannot set __proto__ property', function () {\n    (() => Dot.str('__proto__.toString', 'hi', {})).should.throw(\n      /Refusing to update/\n    );\n    ({}.toString().should.deepEqual('[object Object]'))\n  })\n})\n"], "filenames": ["index.js", "src/dot-object.js", "test/array_notation.js", "test/dot-json.js", "test/str.js"], "buggy_code_start_loc": [47, 47, 169, 207, 37], "buggy_code_end_loc": [549, 549, 169, 207, 52], "fixing_code_start_loc": [48, 48, 170, 208, 37], "fixing_code_end_loc": [572, 572, 176, 215, 63], "type": "CWE-74", "message": "dot-object before 2.1.3 is vulnerable to Prototype Pollution. The set function could be tricked into adding or modifying properties of Object.prototype using a __proto__ payload.", "other": {"cve": {"id": "CVE-2019-10793", "sourceIdentifier": "report@snyk.io", "published": "2020-02-18T16:15:10.327", "lastModified": "2020-02-27T17:00:39.257", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "dot-object before 2.1.3 is vulnerable to Prototype Pollution. The set function could be tricked into adding or modifying properties of Object.prototype using a __proto__ payload."}, {"lang": "es", "value": "dot-object versiones anteriores a 2.1.3, es vulnerable a una Contaminaci\u00f3n por Prototipo (Prototype Pollution). La funci\u00f3n set podr\u00eda ser enga\u00f1ada para agregar o modificar propiedades de Object.prototype usando una carga \u00fatil __proto__."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dot-object_project:dot-object:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.1.3", "matchCriteriaId": "87AFB99E-ECE9-4112-B519-F19647A381A8"}]}]}], "references": [{"url": "https://github.com/rhalff/dot-object/commit/f76cff5fe6d01d30ce110d8f454db2e5bd28a7de", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-DOTOBJECT-548905", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rhalff/dot-object/commit/f76cff5fe6d01d30ce110d8f454db2e5bd28a7de"}}