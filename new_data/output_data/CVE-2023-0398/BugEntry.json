{"buggy_code": ["\"\"\"Domain related views.\"\"\"\n\nfrom functools import reduce\n\nfrom reversion import revisions as reversion\n\nfrom django.contrib.auth import mixins as auth_mixins\nfrom django.contrib.auth.decorators import (\n    login_required, permission_required, user_passes_test\n)\nfrom django.db.models import Q, Sum\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import render\nfrom django.template.loader import render_to_string\nfrom django.urls import reverse\nfrom django.utils.translation import ugettext as _, ungettext\nfrom django.views import generic\nfrom django.views.decorators.csrf import ensure_csrf_cookie\n\nfrom modoboa.core import signals as core_signals\nfrom modoboa.lib.exceptions import PermDeniedException\nfrom modoboa.lib.listing import get_listing_page, get_sort_order\nfrom modoboa.lib.web_utils import render_to_json_response\nfrom modoboa.maillog import models as ml_models\n\nfrom .. import signals\nfrom ..forms import DomainForm, DomainWizard\nfrom ..lib import get_domains\nfrom ..models import Domain, Mailbox\n\n\n@login_required\ndef index(request):\n    return HttpResponseRedirect(reverse(\"admin:domain_list\"))\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"admin.view_domain\") or\n    u.has_perm(\"admin.view_mailbox\")\n)\ndef _domains(request):\n    sort_order, sort_dir = get_sort_order(request.GET, \"name\")\n    extra_filters = signals.extra_domain_filters.send(sender=\"_domains\")\n    if extra_filters:\n        extra_filters = reduce(\n            lambda a, b: a + b, [result[1] for result in extra_filters])\n    filters = {\n        flt: request.GET.get(flt, None)\n        for flt in [\"domfilter\", \"searchquery\"] + extra_filters\n    }\n    request.session[\"domains_filters\"] = filters\n    domainlist = get_domains(request.user, **filters)\n    if sort_order == \"name\":\n        domainlist = sorted(\n            domainlist,\n            key=lambda d: getattr(d, sort_order), reverse=sort_dir == \"-\"\n        )\n    else:\n        domainlist = sorted(domainlist, key=lambda d: d.tags[0][\"name\"],\n                            reverse=sort_dir == \"-\")\n    context = {\n        \"handle_mailboxes\": request.localconfig.parameters.get_value(\n            \"handle_mailboxes\", raise_exception=False),\n        \"auto_account_removal\": request.localconfig.parameters.get_value(\n            \"auto_account_removal\"),\n    }\n    page = get_listing_page(domainlist, request.GET.get(\"page\", 1))\n    parameters = request.localconfig.parameters\n    dns_checks = {\n        \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n        \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n        \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n        \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n        \"enable_autoconfig_checks\": (\n            parameters.get_value(\"enable_autoconfig_checks\")),\n        \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\")\n    }\n    context[\"headers\"] = render_to_string(\n        \"admin/domain_headers.html\", dns_checks, request\n    )\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        tpl_context = {\"domains\": page.object_list}\n        tpl_context.update(dns_checks)\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_table.html\", tpl_context, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@ensure_csrf_cookie\ndef domains(request, tplname=\"admin/domains.html\"):\n    if not request.user.has_perm(\"admin.view_domain\"):\n        if request.user.has_perm(\"admin.view_mailbox\"):\n            return HttpResponseRedirect(\n                reverse(\"admin:identity_list\")\n            )\n        return HttpResponseRedirect(reverse(\"core:user_index\"))\n    parameters = request.localconfig.parameters\n    return render(request, tplname, {\n        \"selection\": \"domains\",\n        \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n        \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n        \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n        \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n        \"enable_autoconfig_checks\": (\n            parameters.get_value(\"enable_autoconfig_checks\")),\n        \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\")\n    })\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"admin.view_domain\") or\n    u.has_perm(\"admin.view_mailbox\") or\n    u.has_perm(\"admin.add_domain\")\n)\ndef get_next_page(request):\n    \"\"\"Return the next page of the domain or quota list.\"\"\"\n    objtype = request.GET.get(\"objtype\", \"domain\")\n    if objtype == \"domain\":\n        return _domains(request)\n    if objtype == \"quota\":\n        return list_quotas(request)\n    return list_logs(request)\n\n\n@login_required\n@permission_required(\"core.add_user\")\ndef domains_list(request):\n    doms = [dom.name for dom in Domain.objects.get_for_admin(request.user)]\n    return render_to_json_response(doms)\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\ndef list_quotas(request):\n    sort_order, sort_dir = get_sort_order(request.GET, \"name\")\n    domains = Domain.objects.get_for_admin(request.user)\n    domains = domains.exclude(quota=0)\n    if sort_order in [\"name\", \"quota\"]:\n        domains = domains.order_by(\"{}{}\".format(sort_dir, sort_order))\n    elif sort_order == \"allocated_quota\":\n        domains = (\n            domains.annotate(allocated_quota=Sum(\"mailbox__quota\"))\n            .order_by(\"{}{}\".format(sort_dir, sort_order))\n        )\n    page = get_listing_page(domains, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/domains_quota_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_quotas.html\", {\"domains\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\ndef list_logs(request):\n    \"\"\"List all Maillog entries.\"\"\"\n    sort_order, sort_dir = get_sort_order(request.GET, \"date\")\n    search = request.GET.get(\"searchquery\")\n    if not request.user.is_superuser:\n        domains = Domain.objects.get_for_admin(request.user)\n        logs = ml_models.Maillog.objects.filter(\n            Q(from_domain__in=domains) | Q(to_domain__in=domains)\n        )\n    else:\n        logs = ml_models.Maillog.objects.all()\n    logs = logs.order_by(\"{}{}\".format(sort_dir, sort_order))\n    if search:\n        logs = logs.filter(\n            Q(sender__icontains=search) |\n            Q(rcpt__icontains=search) |\n            Q(queue_id__icontains=search) |\n            Q(status__icontains=search)\n        )\n    page = get_listing_page(logs, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/domains_log_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_logs.html\", {\"logs\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.add_domain\")\n@reversion.create_revision()\ndef newdomain(request):\n    core_signals.can_create_object.send(\n        \"newdomain\", context=request.user, klass=Domain)\n    return DomainWizard(request).process()\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\n@reversion.create_revision()\ndef editdomain(request, dom_id):\n    \"\"\"Edit domain view.\"\"\"\n    domain = Domain.objects.get(pk=dom_id)\n    if not request.user.can_access(domain):\n        raise PermDeniedException\n\n    instances = {\"general\": domain}\n    results = signals.get_domain_form_instances.send(\n        sender=\"editdomain\", user=request.user, domain=domain)\n    for result in results:\n        instances.update(result[1])\n    return DomainForm(request, instances=instances).process()\n\n\n@login_required\n@permission_required(\"admin.delete_domain\")\ndef deldomain(request, dom_id):\n    keepdir = request.POST.get(\"keepdir\", \"false\") == \"true\"\n    try:\n        mb = Mailbox.objects.get(user__id=request.user.id)\n    except Mailbox.DoesNotExist:\n        mb = None\n\n    dom = Domain.objects.get(pk=dom_id)\n    if not request.user.can_access(dom):\n        raise PermDeniedException\n    if mb and mb.domain == dom:\n        raise PermDeniedException(_(\"You can't delete your own domain\"))\n    dom.delete(request.user, keepdir)\n\n    msg = ungettext(\"Domain deleted\", \"Domains deleted\", 1)\n    return render_to_json_response(msg)\n\n\nclass DomainDetailView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"DetailView for Domain.\"\"\"\n\n    model = Domain\n    permission_required = \"admin.view_domain\"\n\n    def get_queryset(self):\n        \"\"\"Add some prefetching.\"\"\"\n        return (\n            Domain.objects.get_for_admin(self.request.user)\n            .prefetch_related(\"domainalias_set\", \"mailbox_set\", \"alias_set\")\n        )\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Include extra widgets.\"\"\"\n        context = super(DomainDetailView, self).get_context_data(**kwargs)\n        result = signals.extra_domain_dashboard_widgets.send(\n            self.__class__, user=self.request.user, domain=self.object)\n        parameters = self.request.localconfig.parameters\n        context.update({\n            \"templates\": {\"left\": [], \"right\": []},\n            \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n            \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n            \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n            \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n            \"enable_autoconfig_checks\": (\n                parameters.get_value(\"enable_autoconfig_checks\")),\n            \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\"),\n        })\n        for _receiver, widgets in result:\n            for widget in widgets:\n                context[\"templates\"][widget[\"column\"]].append(\n                    widget[\"template\"])\n                # FIXME: can raise conflicts...\n                context.update(widget[\"context\"])\n\n        return context\n\n\nclass DomainAlarmsView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"A view to list domain alarms.\"\"\"\n\n    model = Domain\n    permission_required = \"admin.view_domain\"\n    template_name = \"admin/domain_alarms.html\"\n\n    def get_queryset(self):\n        \"\"\"Add some prefetching.\"\"\"\n        return (\n            Domain.objects.get_for_admin(self.request.user)\n            .prefetch_related(\"alarms\")\n        )\n"], "fixing_code": ["\"\"\"Domain related views.\"\"\"\n\nfrom functools import reduce\n\nfrom reversion import revisions as reversion\n\nfrom django.contrib.auth import mixins as auth_mixins\nfrom django.contrib.auth.decorators import (\n    login_required, permission_required, user_passes_test\n)\nfrom django.db.models import Q, Sum\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import render\nfrom django.template.loader import render_to_string\nfrom django.urls import reverse\nfrom django.utils.translation import ugettext as _, ungettext\nfrom django.views import generic\nfrom django.views.decorators.csrf import ensure_csrf_cookie\nfrom django.views.decorators.http import require_http_methods\n\nfrom modoboa.core import signals as core_signals\nfrom modoboa.lib.exceptions import PermDeniedException\nfrom modoboa.lib.listing import get_listing_page, get_sort_order\nfrom modoboa.lib.web_utils import render_to_json_response\nfrom modoboa.maillog import models as ml_models\n\nfrom .. import signals\nfrom ..forms import DomainForm, DomainWizard\nfrom ..lib import get_domains\nfrom ..models import Domain, Mailbox\n\n\n@login_required\ndef index(request):\n    return HttpResponseRedirect(reverse(\"admin:domain_list\"))\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"admin.view_domain\") or\n    u.has_perm(\"admin.view_mailbox\")\n)\ndef _domains(request):\n    sort_order, sort_dir = get_sort_order(request.GET, \"name\")\n    extra_filters = signals.extra_domain_filters.send(sender=\"_domains\")\n    if extra_filters:\n        extra_filters = reduce(\n            lambda a, b: a + b, [result[1] for result in extra_filters])\n    filters = {\n        flt: request.GET.get(flt, None)\n        for flt in [\"domfilter\", \"searchquery\"] + extra_filters\n    }\n    request.session[\"domains_filters\"] = filters\n    domainlist = get_domains(request.user, **filters)\n    if sort_order == \"name\":\n        domainlist = sorted(\n            domainlist,\n            key=lambda d: getattr(d, sort_order), reverse=sort_dir == \"-\"\n        )\n    else:\n        domainlist = sorted(domainlist, key=lambda d: d.tags[0][\"name\"],\n                            reverse=sort_dir == \"-\")\n    context = {\n        \"handle_mailboxes\": request.localconfig.parameters.get_value(\n            \"handle_mailboxes\", raise_exception=False),\n        \"auto_account_removal\": request.localconfig.parameters.get_value(\n            \"auto_account_removal\"),\n    }\n    page = get_listing_page(domainlist, request.GET.get(\"page\", 1))\n    parameters = request.localconfig.parameters\n    dns_checks = {\n        \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n        \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n        \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n        \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n        \"enable_autoconfig_checks\": (\n            parameters.get_value(\"enable_autoconfig_checks\")),\n        \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\")\n    }\n    context[\"headers\"] = render_to_string(\n        \"admin/domain_headers.html\", dns_checks, request\n    )\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        tpl_context = {\"domains\": page.object_list}\n        tpl_context.update(dns_checks)\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_table.html\", tpl_context, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@ensure_csrf_cookie\ndef domains(request, tplname=\"admin/domains.html\"):\n    if not request.user.has_perm(\"admin.view_domain\"):\n        if request.user.has_perm(\"admin.view_mailbox\"):\n            return HttpResponseRedirect(\n                reverse(\"admin:identity_list\")\n            )\n        return HttpResponseRedirect(reverse(\"core:user_index\"))\n    parameters = request.localconfig.parameters\n    return render(request, tplname, {\n        \"selection\": \"domains\",\n        \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n        \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n        \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n        \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n        \"enable_autoconfig_checks\": (\n            parameters.get_value(\"enable_autoconfig_checks\")),\n        \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\")\n    })\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"admin.view_domain\") or\n    u.has_perm(\"admin.view_mailbox\") or\n    u.has_perm(\"admin.add_domain\")\n)\ndef get_next_page(request):\n    \"\"\"Return the next page of the domain or quota list.\"\"\"\n    objtype = request.GET.get(\"objtype\", \"domain\")\n    if objtype == \"domain\":\n        return _domains(request)\n    if objtype == \"quota\":\n        return list_quotas(request)\n    return list_logs(request)\n\n\n@login_required\n@permission_required(\"core.add_user\")\ndef domains_list(request):\n    doms = [dom.name for dom in Domain.objects.get_for_admin(request.user)]\n    return render_to_json_response(doms)\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\ndef list_quotas(request):\n    sort_order, sort_dir = get_sort_order(request.GET, \"name\")\n    domains = Domain.objects.get_for_admin(request.user)\n    domains = domains.exclude(quota=0)\n    if sort_order in [\"name\", \"quota\"]:\n        domains = domains.order_by(\"{}{}\".format(sort_dir, sort_order))\n    elif sort_order == \"allocated_quota\":\n        domains = (\n            domains.annotate(allocated_quota=Sum(\"mailbox__quota\"))\n            .order_by(\"{}{}\".format(sort_dir, sort_order))\n        )\n    page = get_listing_page(domains, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/domains_quota_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_quotas.html\", {\"domains\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\ndef list_logs(request):\n    \"\"\"List all Maillog entries.\"\"\"\n    sort_order, sort_dir = get_sort_order(request.GET, \"date\")\n    search = request.GET.get(\"searchquery\")\n    if not request.user.is_superuser:\n        domains = Domain.objects.get_for_admin(request.user)\n        logs = ml_models.Maillog.objects.filter(\n            Q(from_domain__in=domains) | Q(to_domain__in=domains)\n        )\n    else:\n        logs = ml_models.Maillog.objects.all()\n    logs = logs.order_by(\"{}{}\".format(sort_dir, sort_order))\n    if search:\n        logs = logs.filter(\n            Q(sender__icontains=search) |\n            Q(rcpt__icontains=search) |\n            Q(queue_id__icontains=search) |\n            Q(status__icontains=search)\n        )\n    page = get_listing_page(logs, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/domains_log_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/domains_logs.html\", {\"logs\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.add_domain\")\n@reversion.create_revision()\ndef newdomain(request):\n    core_signals.can_create_object.send(\n        \"newdomain\", context=request.user, klass=Domain)\n    return DomainWizard(request).process()\n\n\n@login_required\n@permission_required(\"admin.view_domain\")\n@reversion.create_revision()\ndef editdomain(request, dom_id):\n    \"\"\"Edit domain view.\"\"\"\n    domain = Domain.objects.get(pk=dom_id)\n    if not request.user.can_access(domain):\n        raise PermDeniedException\n\n    instances = {\"general\": domain}\n    results = signals.get_domain_form_instances.send(\n        sender=\"editdomain\", user=request.user, domain=domain)\n    for result in results:\n        instances.update(result[1])\n    return DomainForm(request, instances=instances).process()\n\n\n@login_required\n@permission_required(\"admin.delete_domain\")\n@require_http_methods([\"POST\"])\ndef deldomain(request, dom_id):\n    keepdir = request.POST.get(\"keepdir\", \"false\") == \"true\"\n    try:\n        mb = Mailbox.objects.get(user__id=request.user.id)\n    except Mailbox.DoesNotExist:\n        mb = None\n\n    dom = Domain.objects.get(pk=dom_id)\n    if not request.user.can_access(dom):\n        raise PermDeniedException\n    if mb and mb.domain == dom:\n        raise PermDeniedException(_(\"You can't delete your own domain\"))\n    dom.delete(request.user, keepdir)\n\n    msg = ungettext(\"Domain deleted\", \"Domains deleted\", 1)\n    return render_to_json_response(msg)\n\n\nclass DomainDetailView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"DetailView for Domain.\"\"\"\n\n    model = Domain\n    permission_required = \"admin.view_domain\"\n\n    def get_queryset(self):\n        \"\"\"Add some prefetching.\"\"\"\n        return (\n            Domain.objects.get_for_admin(self.request.user)\n            .prefetch_related(\"domainalias_set\", \"mailbox_set\", \"alias_set\")\n        )\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Include extra widgets.\"\"\"\n        context = super(DomainDetailView, self).get_context_data(**kwargs)\n        result = signals.extra_domain_dashboard_widgets.send(\n            self.__class__, user=self.request.user, domain=self.object)\n        parameters = self.request.localconfig.parameters\n        context.update({\n            \"templates\": {\"left\": [], \"right\": []},\n            \"enable_mx_checks\": parameters.get_value(\"enable_mx_checks\"),\n            \"enable_spf_checks\": parameters.get_value(\"enable_spf_checks\"),\n            \"enable_dkim_checks\": parameters.get_value(\"enable_dkim_checks\"),\n            \"enable_dmarc_checks\": parameters.get_value(\"enable_dmarc_checks\"),\n            \"enable_autoconfig_checks\": (\n                parameters.get_value(\"enable_autoconfig_checks\")),\n            \"enable_dnsbl_checks\": parameters.get_value(\"enable_dnsbl_checks\"),\n        })\n        for _receiver, widgets in result:\n            for widget in widgets:\n                context[\"templates\"][widget[\"column\"]].append(\n                    widget[\"template\"])\n                # FIXME: can raise conflicts...\n                context.update(widget[\"context\"])\n\n        return context\n\n\nclass DomainAlarmsView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"A view to list domain alarms.\"\"\"\n\n    model = Domain\n    permission_required = \"admin.view_domain\"\n    template_name = \"admin/domain_alarms.html\"\n\n    def get_queryset(self):\n        \"\"\"Add some prefetching.\"\"\"\n        return (\n            Domain.objects.get_for_admin(self.request.user)\n            .prefetch_related(\"alarms\")\n        )\n"], "filenames": ["modoboa/admin/views/domain.py"], "buggy_code_start_loc": [18], "buggy_code_end_loc": [232], "fixing_code_start_loc": [19], "fixing_code_end_loc": [235], "type": "CWE-352", "message": "Cross-Site Request Forgery (CSRF) in GitHub repository modoboa/modoboa prior to 2.0.4.", "other": {"cve": {"id": "CVE-2023-0398", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-19T09:15:09.367", "lastModified": "2023-01-27T14:43:18.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-Site Request Forgery (CSRF) in GitHub repository modoboa/modoboa prior to 2.0.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:modoboa:modoboa:*:*:*:*:*:modoboa:*:*", "versionEndExcluding": "2.0.4", "matchCriteriaId": "4781FBB6-EAE1-4AF9-A51F-5BEE3E8DFA16"}]}]}], "references": [{"url": "https://github.com/modoboa/modoboa/commit/8e14ac93669df4f35fcdebd55dc9d2f0fed3ed48", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/0a852351-00ed-44d2-a650-9055b7beed58", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/modoboa/modoboa/commit/8e14ac93669df4f35fcdebd55dc9d2f0fed3ed48"}}