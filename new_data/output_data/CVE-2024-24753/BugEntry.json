{"buggy_code": ["<?php declare(strict_types=1);\n\nnamespace Bref\\Event\\Http;\n\n/**\n * Formats the response expected by AWS Lambda and the API Gateway integration.\n */\nfinal class HttpResponse\n{\n    private int $statusCode;\n    private array $headers;\n    private string $body;\n\n    /**\n     * @param array<string|string[]> $headers\n     */\n    public function __construct(string $body, array $headers = [], int $statusCode = 200)\n    {\n        $this->body = $body;\n        $this->headers = $headers;\n        $this->statusCode = $statusCode;\n    }\n\n    public function toApiGatewayFormat(bool $multiHeaders = false): array\n    {\n        $base64Encoding = (bool) getenv('BREF_BINARY_RESPONSES');\n\n        $headers = [];\n        foreach ($this->headers as $name => $values) {\n            $name = $this->capitalizeHeaderName($name);\n\n            if ($multiHeaders) {\n                // Make sure the values are always arrays\n                $headers[$name] = is_array($values) ? $values : [$values];\n            } else {\n                // Make sure the values are never arrays\n                $headers[$name] = is_array($values) ? end($values) : $values;\n            }\n        }\n\n        // The headers must be a JSON object. If the PHP array is empty it is\n        // serialized to `[]` (we want `{}`) so we force it to an empty object.\n        $headers = empty($headers) ? new \\stdClass : $headers;\n\n        // Support for multi-value headers (only in version 1.0 of the http payload)\n        $headersKey = $multiHeaders ? 'multiValueHeaders' : 'headers';\n\n        // This is the format required by the AWS_PROXY lambda integration\n        // See https://stackoverflow.com/questions/43708017/aws-lambda-api-gateway-error-malformed-lambda-proxy-response\n        return [\n            'isBase64Encoded' => $base64Encoding,\n            'statusCode' => $this->statusCode,\n            $headersKey => $headers,\n            'body' => $base64Encoding ? base64_encode($this->body) : $this->body,\n        ];\n    }\n\n    /**\n     * See https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html#http-api-develop-integrations-lambda.response\n     */\n    public function toApiGatewayFormatV2(): array\n    {\n        $base64Encoding = (bool) getenv('BREF_BINARY_RESPONSES');\n\n        $headers = [];\n        $cookies = [];\n        foreach ($this->headers as $name => $values) {\n            $name = $this->capitalizeHeaderName($name);\n\n            if ($name === 'Set-Cookie') {\n                $cookies = is_array($values) ? $values : [$values];\n            } else {\n                // Make sure the values are never arrays\n                // because API Gateway v2 does not support multi-value headers\n                $headers[$name] = is_array($values) ? end($values) : $values;\n            }\n        }\n\n        // The headers must be a JSON object. If the PHP array is empty it is\n        // serialized to `[]` (we want `{}`) so we force it to an empty object.\n        $headers = empty($headers) ? new \\stdClass : $headers;\n\n        return [\n            'cookies' => $cookies,\n            'isBase64Encoded' => $base64Encoding,\n            'statusCode' => $this->statusCode,\n            'headers' => $headers,\n            'body' => $base64Encoding ? base64_encode($this->body) : $this->body,\n        ];\n    }\n\n    /**\n     * See https://github.com/zendframework/zend-diactoros/blob/754a2ceb7ab753aafe6e3a70a1fb0370bde8995c/src/Response/SapiEmitterTrait.php#L96\n     */\n    private function capitalizeHeaderName(string $name): string\n    {\n        $name = str_replace('-', ' ', $name);\n        $name = ucwords($name);\n        return str_replace(' ', '-', $name);\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Test\\Event\\Http;\n\nuse Bref\\Event\\Http\\HttpResponse;\nuse PHPUnit\\Framework\\TestCase;\nuse stdClass;\n\nclass HttpResponseTest extends TestCase\n{\n    public function test\u00a0conversion\u00a0to\u00a0API\u00a0Gateway\u00a0format()\n    {\n        $response = new HttpResponse(\n            '<p>Hello world!</p>',\n            [\n                'Content-Type' => 'text/html; charset=utf-8',\n            ]\n        );\n        self::assertSame([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => [\n                'Content-Type' => 'text/html; charset=utf-8',\n            ],\n            'body' => '<p>Hello world!</p>',\n        ], $response->toApiGatewayFormat());\n\n        self::assertSame([\n            'cookies' => [],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => [\n                'Content-Type' => 'text/html; charset=utf-8',\n            ],\n            'body' => '<p>Hello world!</p>',\n        ], $response->toApiGatewayFormatV2());\n    }\n\n    public function test\u00a0headers\u00a0are\u00a0capitalized()\n    {\n        $response = new HttpResponse('', [\n            'x-foo-bar' => 'baz',\n        ]);\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => ['X-Foo-Bar' => 'baz'],\n            'body' => '',\n        ], $response->toApiGatewayFormat());\n\n        self::assertEquals([\n            'cookies' => [],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => ['X-Foo-Bar' => 'baz'],\n            'body' => '',\n        ], $response->toApiGatewayFormatV2());\n    }\n\n    public function test\u00a0nested\u00a0arrays\u00a0in\u00a0headers\u00a0are\u00a0flattened()\n    {\n        $response = new HttpResponse('', [\n            'foo' => ['bar', 'baz'],\n        ]);\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            // The last value is kept (when multiheaders are not enabled)\n            'headers' => ['Foo' => 'baz'],\n            'body' => '',\n        ], $response->toApiGatewayFormat());\n\n        self::assertEquals([\n            'cookies' => [],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            // The last value is kept (when multiheaders are not enabled)\n            'headers' => ['Foo' => 'baz'],\n            'body' => '',\n        ], $response->toApiGatewayFormatV2());\n    }\n\n    public function test\u00a0empty\u00a0headers\u00a0are\u00a0considered\u00a0objects()\n    {\n        $response = new HttpResponse('');\n\n        // Make sure that the headers are `\"headers\":{}` (object) and not `\"headers\":[]` (array)\n        self::assertEquals('{\"isBase64Encoded\":false,\"statusCode\":200,\"headers\":{},\"body\":\"\"}', json_encode($response->toApiGatewayFormat()));\n        self::assertEquals('{\"cookies\":[],\"isBase64Encoded\":false,\"statusCode\":200,\"headers\":{},\"body\":\"\"}', json_encode($response->toApiGatewayFormatV2()));\n    }\n\n    /**\n     * @see https://github.com/brefphp/bref/issues/534\n     */\n    public function test\u00a0header\u00a0values\u00a0are\u00a0forced\u00a0as\u00a0arrays\u00a0for\u00a0multiheaders()\n    {\n        $response = new HttpResponse('', [\n            'foo' => 'bar',\n        ]);\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'multiValueHeaders' => [\n                'Foo' => ['bar'],\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat(true));\n    }\n\n    public function test\u00a0response\u00a0with\u00a0single\u00a0cookie()\n    {\n        $response = new HttpResponse('', [\n            'set-cookie' => 'foo',\n        ]);\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => [\n                'Set-Cookie' => 'foo',\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat());\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'multiValueHeaders' => [\n                'Set-Cookie' => ['foo'],\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat(true));\n\n        self::assertEquals([\n            'cookies' => ['foo'],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => new stdClass,\n            'body' => '',\n        ], $response->toApiGatewayFormatV2());\n    }\n\n    public function test\u00a0response\u00a0with\u00a0multiple\u00a0cookies()\n    {\n        $response = new HttpResponse('', [\n            'set-cookie' => ['foo', 'bar'],\n        ]);\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => [\n                // Keep only the last value in v1 without multi-headers\n                'Set-Cookie' => 'bar',\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat());\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'multiValueHeaders' => [\n                'Set-Cookie' => ['foo', 'bar'],\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat(true));\n\n        self::assertEquals([\n            'cookies' => ['foo', 'bar'],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => new stdClass,\n            'body' => '',\n        ], $response->toApiGatewayFormatV2());\n    }\n}\n"], "fixing_code": ["<?php declare(strict_types=1);\n\nnamespace Bref\\Event\\Http;\n\n/**\n * Formats the response expected by AWS Lambda and the API Gateway integration.\n */\nfinal class HttpResponse\n{\n    private int $statusCode;\n    private array $headers;\n    private string $body;\n\n    /**\n     * @param array<string|string[]> $headers\n     */\n    public function __construct(string $body, array $headers = [], int $statusCode = 200)\n    {\n        $this->body = $body;\n        $this->headers = $headers;\n        $this->statusCode = $statusCode;\n    }\n\n    public function toApiGatewayFormat(bool $multiHeaders = false): array\n    {\n        $base64Encoding = (bool) getenv('BREF_BINARY_RESPONSES');\n\n        $headers = [];\n        foreach ($this->headers as $name => $values) {\n            $name = $this->capitalizeHeaderName($name);\n\n            if ($multiHeaders) {\n                // Make sure the values are always arrays\n                $headers[$name] = is_array($values) ? $values : [$values];\n            } else {\n                // Make sure the values are never arrays\n                $headers[$name] = is_array($values) ? end($values) : $values;\n            }\n        }\n\n        // The headers must be a JSON object. If the PHP array is empty it is\n        // serialized to `[]` (we want `{}`) so we force it to an empty object.\n        $headers = empty($headers) ? new \\stdClass : $headers;\n\n        // Support for multi-value headers (only in version 1.0 of the http payload)\n        $headersKey = $multiHeaders ? 'multiValueHeaders' : 'headers';\n\n        // This is the format required by the AWS_PROXY lambda integration\n        // See https://stackoverflow.com/questions/43708017/aws-lambda-api-gateway-error-malformed-lambda-proxy-response\n        return [\n            'isBase64Encoded' => $base64Encoding,\n            'statusCode' => $this->statusCode,\n            $headersKey => $headers,\n            'body' => $base64Encoding ? base64_encode($this->body) : $this->body,\n        ];\n    }\n\n    /**\n     * See https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html#http-api-develop-integrations-lambda.response\n     */\n    public function toApiGatewayFormatV2(): array\n    {\n        $base64Encoding = (bool) getenv('BREF_BINARY_RESPONSES');\n\n        $headers = [];\n        $cookies = [];\n        foreach ($this->headers as $name => $values) {\n            $name = $this->capitalizeHeaderName($name);\n\n            if ($name === 'Set-Cookie') {\n                $cookies = is_array($values) ? $values : [$values];\n            } else {\n                // Make sure the values are never arrays\n                // because API Gateway v2 does not support multi-value headers\n                $headers[$name] = is_array($values) ? implode(', ', $values) : $values;\n            }\n        }\n\n        // The headers must be a JSON object. If the PHP array is empty it is\n        // serialized to `[]` (we want `{}`) so we force it to an empty object.\n        $headers = empty($headers) ? new \\stdClass : $headers;\n\n        return [\n            'cookies' => $cookies,\n            'isBase64Encoded' => $base64Encoding,\n            'statusCode' => $this->statusCode,\n            'headers' => $headers,\n            'body' => $base64Encoding ? base64_encode($this->body) : $this->body,\n        ];\n    }\n\n    /**\n     * See https://github.com/zendframework/zend-diactoros/blob/754a2ceb7ab753aafe6e3a70a1fb0370bde8995c/src/Response/SapiEmitterTrait.php#L96\n     */\n    private function capitalizeHeaderName(string $name): string\n    {\n        $name = str_replace('-', ' ', $name);\n        $name = ucwords($name);\n        return str_replace(' ', '-', $name);\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Test\\Event\\Http;\n\nuse Bref\\Event\\Http\\HttpResponse;\nuse PHPUnit\\Framework\\TestCase;\nuse stdClass;\n\nclass HttpResponseTest extends TestCase\n{\n    public function test\u00a0conversion\u00a0to\u00a0API\u00a0Gateway\u00a0format()\n    {\n        $response = new HttpResponse(\n            '<p>Hello world!</p>',\n            [\n                'Content-Type' => 'text/html; charset=utf-8',\n            ]\n        );\n        self::assertSame([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => [\n                'Content-Type' => 'text/html; charset=utf-8',\n            ],\n            'body' => '<p>Hello world!</p>',\n        ], $response->toApiGatewayFormat());\n\n        self::assertSame([\n            'cookies' => [],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => [\n                'Content-Type' => 'text/html; charset=utf-8',\n            ],\n            'body' => '<p>Hello world!</p>',\n        ], $response->toApiGatewayFormatV2());\n    }\n\n    public function test\u00a0headers\u00a0are\u00a0capitalized()\n    {\n        $response = new HttpResponse('', [\n            'x-foo-bar' => 'baz',\n        ]);\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => ['X-Foo-Bar' => 'baz'],\n            'body' => '',\n        ], $response->toApiGatewayFormat());\n\n        self::assertEquals([\n            'cookies' => [],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => ['X-Foo-Bar' => 'baz'],\n            'body' => '',\n        ], $response->toApiGatewayFormatV2());\n    }\n\n    public function test\u00a0multi\u00a0value\u00a0headers()\n    {\n        $response = new HttpResponse('', [\n            'foo' => ['bar', 'baz'],\n        ]);\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            // The last value is kept (when multiheaders are not enabled)\n            'headers' => ['Foo' => 'baz'],\n            'body' => '',\n        ], $response->toApiGatewayFormat());\n\n        self::assertEquals([\n            'cookies' => [],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            // Headers are joined with a comma\n            // See https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.2\n            // API Gateway v2 does not support multi-value headers\n            'headers' => ['Foo' => 'bar, baz'],\n            'body' => '',\n        ], $response->toApiGatewayFormatV2());\n    }\n\n    public function test\u00a0empty\u00a0headers\u00a0are\u00a0considered\u00a0objects()\n    {\n        $response = new HttpResponse('');\n\n        // Make sure that the headers are `\"headers\":{}` (object) and not `\"headers\":[]` (array)\n        self::assertEquals('{\"isBase64Encoded\":false,\"statusCode\":200,\"headers\":{},\"body\":\"\"}', json_encode($response->toApiGatewayFormat()));\n        self::assertEquals('{\"cookies\":[],\"isBase64Encoded\":false,\"statusCode\":200,\"headers\":{},\"body\":\"\"}', json_encode($response->toApiGatewayFormatV2()));\n    }\n\n    /**\n     * @see https://github.com/brefphp/bref/issues/534\n     */\n    public function test\u00a0header\u00a0values\u00a0are\u00a0forced\u00a0as\u00a0arrays\u00a0for\u00a0multiheaders()\n    {\n        $response = new HttpResponse('', [\n            'foo' => 'bar',\n        ]);\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'multiValueHeaders' => [\n                'Foo' => ['bar'],\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat(true));\n    }\n\n    public function test\u00a0response\u00a0with\u00a0single\u00a0cookie()\n    {\n        $response = new HttpResponse('', [\n            'set-cookie' => 'foo',\n        ]);\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => [\n                'Set-Cookie' => 'foo',\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat());\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'multiValueHeaders' => [\n                'Set-Cookie' => ['foo'],\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat(true));\n\n        self::assertEquals([\n            'cookies' => ['foo'],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => new stdClass,\n            'body' => '',\n        ], $response->toApiGatewayFormatV2());\n    }\n\n    public function test\u00a0response\u00a0with\u00a0multiple\u00a0cookies()\n    {\n        $response = new HttpResponse('', [\n            'set-cookie' => ['foo', 'bar'],\n        ]);\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => [\n                // Keep only the last value in v1 without multi-headers\n                'Set-Cookie' => 'bar',\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat());\n\n        self::assertEquals([\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'multiValueHeaders' => [\n                'Set-Cookie' => ['foo', 'bar'],\n            ],\n            'body' => '',\n        ], $response->toApiGatewayFormat(true));\n\n        self::assertEquals([\n            'cookies' => ['foo', 'bar'],\n            'isBase64Encoded' => false,\n            'statusCode' => 200,\n            'headers' => new stdClass,\n            'body' => '',\n        ], $response->toApiGatewayFormatV2());\n    }\n}\n"], "filenames": ["src/Event/Http/HttpResponse.php", "tests/Event/Http/HttpResponseTest.php"], "buggy_code_start_loc": [75, 61], "buggy_code_end_loc": [76, 81], "fixing_code_start_loc": [75, 61], "fixing_code_end_loc": [76, 83], "type": "CWE-436", "message": "Bref enable serverless PHP on AWS Lambda. When Bref is used in combination with an API Gateway with the v2 format, it does not handle multiple values headers. If PHP generates a response with two headers having the same key but different values only the latest one is kept. If an application relies on multiple headers with the same key being set for security reasons, then Bref would lower the application security. For example, if an application sets multiple `Content-Security-Policy` headers, then Bref would just reflect the latest one. This vulnerability is patched in 2.1.13.", "other": {"cve": {"id": "CVE-2024-24753", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-01T16:17:14.690", "lastModified": "2024-02-09T01:46:12.560", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Bref enable serverless PHP on AWS Lambda. When Bref is used in combination with an API Gateway with the v2 format, it does not handle multiple values headers. If PHP generates a response with two headers having the same key but different values only the latest one is kept. If an application relies on multiple headers with the same key being set for security reasons, then Bref would lower the application security. For example, if an application sets multiple `Content-Security-Policy` headers, then Bref would just reflect the latest one. This vulnerability is patched in 2.1.13."}, {"lang": "es", "value": "Bref habilita PHP sin servidor en AWS Lambda. Cuando Bref se usa en combinaci\u00f3n con una API Gateway con el formato v2, no maneja encabezados de valores m\u00faltiples. Si PHP genera una respuesta con dos encabezados que tienen la misma clave pero valores diferentes, solo se conserva el \u00faltimo. Si una aplicaci\u00f3n se basa en varios encabezados con la misma clave configurada por razones de seguridad, Bref reducir\u00eda la seguridad de la aplicaci\u00f3n. Por ejemplo, si una aplicaci\u00f3n establece varios encabezados \"Content-Security-Policy\", Bref solo reflejar\u00e1 el \u00faltimo. Esta vulnerabilidad est\u00e1 parcheada en 2.1.13."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-436"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mnapoli:bref:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.13", "matchCriteriaId": "D8473D9F-5007-4ADC-B256-FD331BB522A0"}]}]}], "references": [{"url": "https://github.com/brefphp/bref/commit/f834027aaf88b3885f4aa8edf6944ae920daf2dc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/brefphp/bref/security/advisories/GHSA-99f9-gv72-fw9r", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/brefphp/bref/commit/f834027aaf88b3885f4aa8edf6944ae920daf2dc"}}