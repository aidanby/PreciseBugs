{"buggy_code": ["iowow (1.4.16) UNRELEASED; urgency=medium\n\n  * Added additional IW_ERROR_XX codes (iwlog.h)\n  * Added VERBOSE log level (iwlog.h)\n  * Added iwhmap_put_str() (iwhmap.h)\n  * Added iwulist_remove_first_by(), iwulist_find_first() (iwarr.h)\n  * Added iwxstr_new_printf() (iwxstr.h)\n  * Reduced iwkv code complexity. Removed in-memory db cache since benchmarks shows only minor perf imprivements with cache.\n  * Fixed many of UB errors (eg: misaligned access)\n  * Removed dependency on kbtree.h replaced with iwavl.h\n  * Added json module (migrated from ejdb) (iwjson.h, iwbinn.h)\n  * Added platform neutral iwp_basename() and iwp_dirname() (iwp.h)\n  * Added iwu_file_read_as_buf_len() (iwutils.h)\n  * Added IW_NORET (basedefs.h)\n  * iwxstr_destroy_keep_ptr() now returns pointer to underlying buffer\n  * IWHMAP can operate in LRU cache mode (iwhmap.h)\n  * Added .ini file parsing utility module (iwini.h)\n  * Added iw_cond_timed_wait_ms() (iwth.h)\n  * Added iwstw_set_on_task_discard(), iwstw_schedule_only() (iwstw.h)\n  * Fixed iwp_exec_path() on FreeBSD sinceprocfs(5) is not mounted by default in FreeBSD.\n  * iwp_exec_path() implemented for FreeBSD & Macos\n  * Added `int64_t iwatoi2(const char *str, size_t len)` (iwconv.h)\n  * iwpool_split_xx() now returns const pointer (iwpool.h)\n  * Fixed iwre() regexp compilation error.\n  * Added new regexp API implementation (iwre.h) based on https://github.com/jserv/cregex/\n  * Removed iwsha256() from sources. Use iwnet/beassl for hashing instead.\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 24 Feb 2022 09:18:55 +0700\n\niowow (1.4.15) testing; urgency=medium\n\n  * Added format checking __attribute__ to all printf like functions.\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 18 Feb 2022 21:54:04 +0700\n\niowow (1.4.14) testing; urgency=medium\n\n  * Used ftruncate() instead of posix_fallocate() due to EINVAL on ZFS (unix.c)\n  * Enable XOPEN_SOURCE only for linux\n  * Fixed incorrect selection of `strerror_r` for musl builds.\n  * Set appropriate _XOPEN_SOURCE=700 level for `nftw` (unix.c)\n  * iwxstr_printf() now conforms to stdlib printf function (iwxstr.h)\n  * Moved some useful defs from iwutil.h into basedefs.h\n  * Fixed iwre_match() function signatute allowing `const  char* input`\n  (iwre.h)\n  * Added lightweight regexp implementation (iwre.h)\n  * Added `size_t iwxstr_asize(IWXSTR*)` (iwxstr.h)\n  * Added locale independed strtod: iwstrtod() (iwconv.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 14 Feb 2022 18:01:17 +0700\n\niowow (1.4.13) testing; urgency=medium\n\n  * Fixed SEGV in iwkv_cursor_open with zero-length key and IWDB_VNUM64_KEYS (#42)\n  * Fixed Heap UAF in iwkv_close after invoking iwkv_db_set_meta on a database (#41)\n  * Added `iwxstr_wrap()` (iwxstr.h)\n  * Added `RCT()` checker for pthread routines (basedefs.h)\n  * Added iwbin2hex() (iwconv.h)\n  * iwxstr_clear() sets value of intgernal string buffer to zero (iwxstr.h)\n  * Added user data store capability to iwxstr (iwxstr.h)\n  * Added iwpool_strdup2(), iwpool_strndup2() (iwpool.h)\n  * Added iwp_set_current_thread_name() (iwp.h)\n  * Added RCENO define (basedefs.h)\n  * Thread poll, single thread worker fixes\n  * Added IW_MIN, IW_MAX, IW_XSTR defines\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 03 Sep 2021 16:03:05 +0700\n\niowow (1.4.12) testing; urgency=medium\n\n  * Added IW_ERROR_UNSUPPORTED error code\n  * Added  IW_ALLOC __attribute__((malloc)) optimization\n  * Added ring buffer implementation (iwrb.h)\n  * Added `queue_blocking` argument `iwstw_start()` (iwstw.h)\n  * Minor changes in iwlog.h api\n  * `memcpy` replaced by `memmove` for overlaping cases (iwarr.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 19 Jul 2021 10:09:05 +0700\n\niowow (1.4.11) testing; urgency=medium\n\n  * Fixed typo (qsort_r => sort_r) (iwarr.c)\n  * Added simple threads pool implementation (iwtp.h)\n  * Added IW_ERROR_NOT_ALLOWED error code (iwlog.h)\n  * Added RCR() error checking macro (basedefs.h)\n  * Added iwlist_sort(), iwulist_sort() (iwarr.h)\n  * Added iwstw_schedule_empty_only() (iwstw.h)\n  * Added iwstw_queue_size() (iwstw.h)\n  * Set O_CLOEXEC flag on all file open() calls\n  * Added IW_ERROR_UNEXPECTED_RESPONSE error code (iwlog.h)\n  * Added iwxstr_set_size(), iwxstr_destroy_keep_ptr() (iwxstr.h)\n  * Added iwlist_at2() (iwarr.h)\n  * Added handy ZRET definition (basedefs.h)\n  * Added handy ZGO definition (basedefs.h)\n  * Project code reformatted using uncrustify\n  * Updated copyright headers\n  * Fixed build errors on macOS\n  * Removed dependency on glibc specific features\n  * Added new iwxstr_pop() (iwxstr.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 10 May 2021 16:43:52 +0700\n\niowow (1.4.10) testing; urgency=medium\n\n  * Tuned iwkv file resizing policy\n  * Fixed misuse of `IWKV_OPTS.file_lock_fail_fast` (#35)\n  * Correct handling of EINTR, EAGAIN in read/write functions (unix.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 22 Dec 2020 23:55:36 +0700\n\niowow (1.4.9) testing; urgency=medium\n\n  * Code review of iwkv cache keys comparison, related issue: https://github.com/Softmotions/ejdb/issues/291\n  * Added `bool iwu_uuid_valid(const char *uuid)` (iwuuid.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 18 Nov 2020 15:04:03 +0700\n\niowow (1.4.8) testing; urgency=medium\n\n  * Fixed serios bug concerning non-unique ejdb2 indexes, details: https://github.com/Softmotions/ejdb/issues/291\n  * Fixed potencial memory leak in `iwlist_create()` (iwarr.h)\n  * Fixed wrong `iwulist_clear()` behaviour (iwarr.h)\n  * Code cleanup\n  * Added `iwulist_at2()` (iwarr.h)\n  * Removed not needed assertion (iwstree.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Sun, 08 Nov 2020 21:51:49 +0700\n\niowow (1.4.7) testing; urgency=medium\n\n  * Correct handling of EINTR, EAGAIN in read/write functions (unix.c)\n  * Minor fixes on iwhmap\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 21 Sep 2020 12:14:06 +0700\n\niowow (1.4.6) testing; urgency=medium\n\n  * Added `iwpool_user_data_detach()` (iwpool.h)\n  * Added `iwpool_create_empty()` (iwpool.h)\n  * Added simple hashmap implementation (iwhmap.h)\n  * `IWPOOL` is able to store associated user data (iwpool.h)\n  * `pthread_barrierattr` shim for android API < 24\n  * Added `iwsha256()` SHA-256 hash implementation (iwsha2.h)\n  * Added single thread worker (iwstw.h)\n  * Added `iwstree_clear()` (iwstree.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 24 Jun 2020 18:32:24 +0700\n\niowow (1.4.5) testing; urgency=medium\n\n  * Added `iwulist_clear` (iwarr.h)\n  * Added `RCIF` (basedefs.h)\n  * Fix assertion error in `iwstree_remove()` (iwstree.h)\n  * Allows zero key/value placeholders in `iwstree_iter_next()` (iwstree.h)\n  * Added `iwstree_put_overwrite` (iwstree.h)\n  * Added  iwstree iteration API (iwstree.h)\n  * Added `iwpool_used_size` (iwpool.h)\n  * Added `iwstree_int64_cmp` (iwstree.h)\n  * Added `IW_DEPRECATED` (basedefs.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 18 Jun 2020 14:19:32 +0700\n\niowow (1.4.4) testing; urgency=medium\n\n  * Fixed incorrect copying of cursor key data in `IWDB_COMPOUND_KEYS` mode (iwkv.c)\n  * Adde compound key example code (compoundkeys1.c)\n  * Added `iwstree_visit` (iwstree.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 02 May 2020 19:38:31 +0700\n\niowow (1.4.3) testing; urgency=medium\n\n  * Fixed errors found by PVS studio\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 24 Apr 2020 00:16:42 +0700\n\niowow (1.4.2) testing; urgency=medium\n\n  * Added IWULIST, IWLIST implementation (iwarr.h)\n  * Added iwpool_split_string (iwpool.h)\n  * Added iwpool_printf (iwpool.h)\n  * Added iwpool_printf_split (iwpool.h)\n  * Added iwxstr_shift (iwxstr.h)\n  * Added `#define RCHECK` (basedefs.h)\n  * Better error handling of `kh_put`\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 20 Apr 2020 16:23:50 +0700\n\niowow (1.4.1) testing; urgency=medium\n\n  * Fixed possible data corruption in `_fsm_blk_allocate_aligned_lw` (iwfsmfile.c)\n  * Better new SBLK blocks locality  (performance)\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 07 Mar 2020 23:23:13 +0700\n\niowow (1.4.0) testing; urgency=medium\n\n  * Implemented new compact and performant data storage format v2\n  * Added WiredTiger v3.2.1 benchmarks\n  * Added BerkeleyDB v5.3.28 benchmarks\n  * Added TokyoCabinet v1.4.48 benchmarks\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 06 Mar 2020 23:23:16 +0700\n\niowow (1.3.37) testing; urgency=medium\n\n  * Added iwrc iwp_mkdirs(const char *path) (iwp.h)\n  * Added uint32_t iwu_x31_u32_hash(const char *s) (iwutils.h)\n  * Added iwu_replace() (iwutils.h)\n  * Added RCA( macro definition\n  * Removed IW_EXPORT iwrc iwkv_db_last_access_time(IWDB db, uint64_t *ts)\n    for performance and simplicity reasons\n  * Added `IW_ERROR_INVALID_VALUE`\n  * Added iwstree - splay tree imlementation (iwstree.h)\n  * Pointers allocated by iwpool are now 8-byte aligned\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 17 Feb 2020 23:16:31 +0700\n\niowow (1.3.36) testing; urgency=medium\n\n  * Safer iowow initialization bootstrap process.\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 16 Jan 2020 12:44:31 +0700\n\niowow (1.3.35) testing; urgency=medium\n\n  * Added specific checks for TARGET_OS_IPHONE\n  * Ported to iOS\n  * Added wal locking interceptor to WAL opts\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 15 Jan 2020 13:10:51 +0700\n\niowow (1.3.32) testing; urgency=medium\n\n  * Improved WAL durability\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 19 Dec 2019 10:49:08 +0700\n\niowow (1.3.31) testing; urgency=medium\n\n  * Keys comparison refactoring\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 20 Nov 2019 00:41:15 +0700\n\niowow (1.3.30) testing; urgency=medium\n\n  * Added check if  __unused is already defined in `iwth.c`\n  * CRITICAL Comparsions keys fix #30\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 19 Nov 2019 20:23:41 +0700\n\niowow (1.3.29) testing; urgency=medium\n\n  * FIXED iwkv_open assertion fail on opening garbage file #29\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 13 Nov 2019 23:55:35 +0700\n\niowow (1.3.28) testing; urgency=medium\n\n  * iwlog now supports ANDROID NDK logging (iwlog.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 07 Nov 2019 14:44:59 +0700\n\niowow (1.3.27) testing; urgency=medium\n\n  * CRITICAL WAL durability fixes\n  * Support of online backups #24\n  * Windows platform functions fixes\n  * CLion project files added\n  * WAL recovering fixes\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 28 Oct 2019 19:08:59 +0700\n\niowow (1.3.25) testing; urgency=medium\n\n  * CRITICAL Fixed heap corruption due incorrect usage of khash API in `_db_destroy_lw` (iwkv.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 29 Aug 2019 12:20:25 +0700\n\niowow (1.3.24) testing; urgency=medium\n\n  * CRITICAL Fixed race condition in WAL rollforward\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 22 Aug 2019 02:04:08 +0700\n\niowow (1.3.23) testing; urgency=medium\n\n  * WAL refactoring, better stability\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 17 Aug 2019 21:17:05 +0700\n\niowow (1.3.22) testing; urgency=medium\n\n  * Small optimizations in `iwfsmfile.c`\n  * Added `iwp_clock_get_time` as  portable version of `clock_gettime`\n  * `static_assert` is  set to `_Static_assert` if not defined\n  * Added `__USE_MINGW_ANSI_STDIO` for MinGW build\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 18 Jul 2019 17:50:14 +0700\n\niowow (1.3.20) testing; urgency=medium\n\n  * CRITICAL Fixed incorrect keys allocation in IWDB_COMPOUND_KEYS mode\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 13 Jun 2019 21:43:47 +0700\n\niowow (1.3.19) testing; urgency=medium\n\n  * CRITICAL: Fixed assertion fail in iwkv records cache\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 13 Jun 2019 19:08:48 +0700\n\niowow (1.3.18) testing; urgency=medium\n\n  * Limit one time file allocation step to 2G\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 12 Jun 2019 16:42:47 +0700\n\niowow (1.3.17) testing; urgency=medium\n\n  * CRITICAL: State of previously deleted database may have influence on newly created dbs\n  * BUG: Fixed database metadata blocks leak (db->meta_blk) on database destroy\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 03 May 2019 18:20:39 +0700\n\niowow (1.3.16) testing; urgency=medium\n\n  * CRITICAL: Fixed deadlock on database removal\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 03 May 2019 11:56:29 +0700\n\niowow (1.3.15) testing; urgency=medium\n\n  * CRITICAL: Fixed database file corruption during sequential records deletion with `iwkv_cursor_del` (iwkv.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 01 May 2019 23:29:18 +0700\n\niowow (1.3.14) testing; urgency=medium\n\n  * CRITICAL: Fixed unexpected database file truncation and data loss on close.\n  * Adjusted default WAL options for Android\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 27 Apr 2019 01:04:28 +0700\n\niowow (1.3.13) testing; urgency=medium\n\n  * Performance impovements in Write Ahead Logging (iwal.c)\n  * BUG: WAL file was not truncated after `wal->checkpoint_timeout_sec` timeout (iwal.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 25 Apr 2019 17:43:06 +0700\n\niowow (1.3.12) testing; urgency=medium\n\n  * Android NDK support (#23)\n  * Pthreads `PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP` is used by default\n\n -- Anton Adamansky <adamansky@gmail.com>  Sun, 21 Apr 2019 12:18:16 +0700\n\niowow (1.3.11) testing; urgency=medium\n\n  * Added size_t iwpool_allocated_size(IWPOOL *pool) (iwpool.h)\n  * Added `file_lock_fail_fast` iwkv open option.\n    If `true` - do not wait and raise error if database is locked by another process\n  * Fixed meaningful PVP studio errors:\n    - kv/iwkv.c:593:1: error: V774\n    - kv/iwkv.c:1375:1: warning: V649\n    - kv/iwkv.c:3357:1: warning: V581\n    - utils/iwxstr.c:59:1: warning: V701\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 08 Apr 2019 11:47:59 +0700\n\niowow (1.3.10) testing; urgency=medium\n\n  * Added cmake `OWNER_PROJECT_NAME` option used to install header files in `CMAKE_INSTALL_INCLUDEDIR}/OWNER_PROJECT_NAME/PROJECT_NAME`\n  * Removed `-fvisibility=hidden` C flag when building shared library\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 05 Apr 2019 11:53:34 +0700\n\niowow (1.3.9) testing; urgency=medium\n\n  * BUG `IW_HAVE_PTHREAD_CONDATTR_SETCLOCK` was not properly set for `iwal.c` hence high CPU usage when `wal` mode is on.\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 29 Mar 2019 23:56:25 +0700\n\niowow (1.3.8) testing; urgency=medium\n\n  * BUG Fixed incorrect call of `_kvblk_kv_get` in `iwkv_cursor_seth`.\n    See https://github.com/Softmotions/ejdb/issues/231\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 27 Mar 2019 12:34:10 +0700\n\niowow (1.3.7) testing; urgency=medium\n\n  * Added `iwkv_cursor_del()` (#22)\n  * Fixed memory corruption during simultaneous cursor iteration and value updating\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 26 Mar 2019 18:24:35 +0700\n\niowow (1.3.6) testing; urgency=medium\n\n  * BUG: Memory leak in `iwkv_cursor_open` on error (#21)\n  * BUG: `iwxstr_new2()` with zero size argument causes illegal memory write (#20)\n  * Added `iwkv_cursor_seth()` record update handle supported by `iwkv_cursor_set`\n  * Avoided deadlocks with `iwkv_del()` - now this function does't escalate exclusive lock on storage\n  * More consistent error reporting using cursor functions\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 22 Mar 2019 16:29:32 +0700\n\niowow (1.3.5) testing; urgency=medium\n\n  * BUG: Data from deleted database can interfere with newly created db (#19)\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 20 Mar 2019 20:26:22 +0700\n\niowow (1.3.4) testing; urgency=medium\n\n  * Code documentation improvements\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 11 Mar 2019 22:42:51 +0700\n\niowow (1.3.3) testing; urgency=medium\n\n  * BUG: `iwkv_puth` called with incorrect previous value (iwkv.h)\n  * _kvblk_getvalue renamed to _kvblk_value_get (iwkv.c)\n  * _kvblk_peek_val renamed to _kvblk_value_peek (iwkv.c)\n  * _kvblk_getkey renamed to _kvblk_key_get (iwkv.c)\n  * _kvblk_getkv renamed to _kvblk_kv_get (iwkv.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 08 Mar 2019 17:02:46 +0700\n\niowow (1.3.2) testing; urgency=medium\n\n  * Added `iwkv_cursor_is_matched_key` (iwkv.h)\n  * `iwkv_cursor_copy_key` now aware of `IWDB_COMPOUND_KEYS` mode (iwkv.h)\n  * `iwkv_cursor_copy_key` can accept zero kbuf,kbufsz only compound part will returned in this case (iwkv.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 04 Mar 2019 20:50:03 +0700\n\niowow (1.3.1) testing; urgency=medium\n\n  * Eliminate adaptive `IWDB_VNUM64_KEYS` key sizing in `_unpack_effective_key` for the sake of API simplicity (iwkv.c)\n  * BUG: incorrect key handling in `iwkv_del` - key was not unpacked before. (iwkv.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 28 Feb 2019 10:40:11 +0700\n\niowow (1.3.0) testing; urgency=medium\n\n  * `IWKV_PUT_HANDLER` called for insert operations (not only for updates)\n  * Added `IWFS_OUNLINK` flag. Unlink(delete) file on close (iwfile.h)\n  * Added `IWFS_OTMP` flag. Create tmp file (iwfile.h)\n  * Added UUID v4 generation function (iwuuid.h)\n  * Added iwp_tmpdir() (iwp.h)\n  * Added iwp_allocate_tmpfile_path() (iwp.h)\n  * Added iwxstr_printf() (iwxstr.h)\n  * Added iwxstr_cat2() (iwxstr.h)\n  * Added `IWKV_VAL_INCREMENT` mode for `iwkv_put()` and test case (iwkv.h)\n  * Added support of variable-length encoded integer keys `IWDB_VNUM64_KEYS` (iwkv.h)\n  * Added support of compound keys (`IWDB_COMPOUND_KEYS`) (#18)\n  * Removed `dup` integer value routines\n  * Code cleanup and refactoring\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 27 Feb 2019 12:11:48 +0700\n\niowow (1.2.14) testing; urgency=medium\n\n  * BUG: Fix WAL checkpoint workflow to avoid deadlocks with cursor threads\n  * BUG: Clang6 fatal error: variable 'cur' is used uninitialized  (#15)\n  * Implemented new multithreaded stress test (iwkv_test6.c) used OMP stack\n  * Added iwkv_new_db(IWKV iwkv, iwdb_flags_t dbflg, uint32_t *odbid, IWDB *dbp) (iwkv.h)\n  * Removed unused `IWKV_NOLOCKS` option.\n  * Added `IW_EXPORT` to `iowow_version_*` API functions  (iowow.h)\n  * Added iwrc iwkv_state(IWKV iwkv, IWFS_FSM_STATE *out) (iwkv.h)\n  * Do not check `IWKV_NO_OVERWRITE` for databases in `IWDB_DUP_UINTXX_VALS` mode\n  * Added iwkv_puth() with provided old value interceptor: `IWKV_PUT_HANDLER` (iwkv.h)\n  * Added `IWKV_RC_DUP_ARRAY_EMPTY` flag and `IWKV_DUP_REPORT_EMPTY` opflag for `iwkv_put()` (iwkv.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 06 Nov 2018 23:14:39 +0700\n\niowow (1.2.13) testing; urgency=medium\n\n  * BUG: Correct cursors adjustments during db update operations (#13)\n  * BUG: Fixed WAL integration for updates in IWDB_DUP_UINT32_VALS|IWDB_DUP_UINT64_VALS mode\n  * Store arbitrary data blocks associated with iwkv internal databases (#12)\n  * Checking of max key/value size (IWKV_MAX_KVSZ) for updates in IWDB_DUP_UINT32_VALS|IWDB_DUP_UINT64_VALS mode\n  * Minor allocation performance optimizations in _kvblk_addkv()\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 02 Aug 2018 20:29:08 +0700\n\niowow (1.2.12) testing; urgency=medium\n\n  * Set terminating '\\0' in iwitoa() (iwconv.h)\n  * Added MAP_NORESERVE option for PRIVATE mmaping on Linux (#11)\n  * Added iwu_file_read_as_buf() (iwutils.h)\n  * Optimized cmake config files generation\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 21 Jul 2018 01:59:40 +0700\n\niowow (1.2.11) testing; urgency=medium\n  * iwpool refactoring fixed pool memory corruption (iwpool.h)\n  * Fixed set terminating `\\0` in iwpool_strdup() (iwpool.h)\n  * Fixed wrong `if` in iwpool_calloc() (iwpool.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 15 Jun 2018 17:58:20 +0700\n\niowow (1.2.10) testing; urgency=medium\n\n  * Added iwpool_calloc() (iwpool.h)\n  * Added iwpool_strdup(), iwpool_strndup() (iwpool.h)\n  * Fixed memory leak in iwpool_destroy() (iwpool.h)\n  * Renamed platform/linux/linux.c to platform/unix/unix.c (#9)\n  * Added iwu_replace_char() (iwutils.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 11 Jun 2018 23:00:21 +0700\n\niowow (1.2.9) testing; urgency=medium\n\n  * Rewrite of iwftoa() (iwconv.h)\n  * Fixed typo: iwtoa renamed to iwitoa (iwconv.h)\n  * Added iwu_cmp_files (iwutils.h)\n  * Return type of iwxstr_ptr() changed to char* (iwxstr.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 29 May 2018 01:01:56 +0700\n\niowow (1.2.8) testing; urgency=medium\n\n  * IOWOW Ported to MIPS32 (big-endian) tested on Debian GNU/Linux 9.4\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 19 May 2018 21:09:04 +0700\n\niowow (1.2.7) testing; urgency=medium\n\n  * Fixed incorrect exclusive locking in iwkv_del()\"\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 17 May 2018 11:27:58 +0700\n\niowow (1.2.6) testing; urgency=medium\n\n  * Fixed: database file is not created automatically if no open modes specified in opts\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 16 May 2018 19:57:35 +0700\n\niowow (1.2.5) testing; urgency=medium\n\n  * Added iwkv_opflags opflags into iwkv_del\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 16 May 2018 19:33:16 +0700\n\niowow (1.2.4) testing; urgency=medium\n\n  * Fixed race conditions in iwkv_cursor_to()\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 14 May 2018 09:28:13 +0700\n\niowow (1.2.3) testing; urgency=medium\n\n  *  Fixed race conditions in iwkv_cursor_set()\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 11 May 2018 23:17:13 +0700\n\niowow (1.2.2) testing; urgency=medium\n\n  * Added static iowow_s libraries to the default CMake exports.\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 08 May 2018 22:58:41 +0700\n\niowow (1.2.1) testing; urgency=medium\n\n  * Removed unistd.h from src/fs/iwdlsnr.h since it is not portable.\n  * C++ friendly header files\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 07 May 2018 12:47:46 +0700\n\niowow (1.2.0) testing; urgency=medium\n\n  * IOWOW ported to Windows x86-64 platform #1\n\n -- Anton Adamansky <adamansky@gmail.com>  Sun, 06 May 2018 20:35:14 +0700\n\niowow (1.1.0) testing; urgency=medium\n\n  * Write Ahead Log (WAL) implemented #2\n  * Changed database block size to 128 bytes so max db size 512Gb\n    WARNING: Database format of version 1.1.x is incompatible with previous versions.\n  * Better basename/basename_r detection in iwlog.c #4\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 02 May 2018 17:28:14 +0700\n\niowow (1.0.6) testing; urgency=medium\n\n  * src/CMakeLists.txt cleanups #3\n  * x86-specific code in src/platform/iwp.c is not guarded #7\n  * Database size limited to 2GB on 32 bit CPUs #5\n  * Database block size changed: 64 to 128 bytes #8\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 16 Apr 2018 10:21:00 +0700\n\niowow (1.0.5) testing; urgency=medium\n\n  * iwextfile: do msync before munmap on file resizing\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 12 Apr 2018 20:48:26 +0700\n\niowow (1.0.4) testing; urgency=medium\n\n  * Added IWFSM_SYNC_BMAP option to iwfs_fsm_aflags\n  * Removed IWFS_NO_MMASYNC since it does noop on many platforms\n  * Set exclusive iwkv write lock in iwkv_sync()\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 12 Apr 2018 12:33:53 +0700\n\niowow (1.0.3) testing; urgency=medium\n\n  * Added basic iowow.3 man page to distribution archive\n  * Use posix_fallocate() to extend iwkv file instead of ftruncate() on Linux/FreeBSD\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 10 Apr 2018 18:56:11 +0700\n\niowow (1.0.2) testing; urgency=medium\n\n  * Removed unneeded -D_LARGE_FILE_SOURCE from iowow.h\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 09 Apr 2018 13:56:53 +0700\n\niowow (1.0.1) testing; urgency=medium\n\n  * Fix export flags iwlog2 method\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 09 Apr 2018 12:44:23 +0700\n\niowow (1.0.0) testing; urgency=medium\n\n  * Initial release.\n\n -- Anton Adamansky <adamansky@gmail.com>  Sun, 08 Apr 2018 14:21:43 +0700\n", "#include \"iwjson.h\"\n#include \"iwconv.h\"\n#include \"utf8proc.h\"\n#include \"iwjson_internal.h\"\n\n#include <ctype.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <assert.h>\n\n#define _STRX(x) #x\n#define _STR(x)  _STRX(x)\n\nIW_INLINE int _jbl_printf_estimate_size(const char *format, va_list ap) {\n  char buf[1];\n  int ret = vsnprintf(buf, sizeof(buf), format, ap);\n  if (ret < 0) {\n    return ret;\n  } else {\n    return ret + 1;\n  }\n}\n\nIW_INLINE void _jbn_remove_item(JBL_NODE parent, JBL_NODE child);\nstatic void _jbn_add_item(JBL_NODE parent, JBL_NODE node);\n\nvoid iwjson_ftoa(long double val, char buf[static IWNUMBUF_SIZE], size_t *out_len) {\n  // TODO: review\n  int len = snprintf(buf, 64, \"%.8Lf\", val);\n  if (len <= 0) {\n    buf[0] = '\\0';\n    *out_len = 0;\n    return;\n  }\n  while (len > 0 && buf[len - 1] == '0') { // trim zeroes from right\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  if ((len > 0) && (buf[len - 1] == '.')) {\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  *out_len = (size_t) len;\n}\n\niwrc jbl_create_empty_object(JBL *jblp) {\n  *jblp = calloc(1, sizeof(**jblp));\n  if (!*jblp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  binn_create(&(*jblp)->bn, BINN_OBJECT, 0, 0);\n  return 0;\n}\n\niwrc jbl_create_empty_array(JBL *jblp) {\n  *jblp = calloc(1, sizeof(**jblp));\n  if (!*jblp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  binn_create(&(*jblp)->bn, BINN_LIST, 0, 0);\n  return 0;\n}\n\nvoid jbl_set_user_data(JBL jbl, void *user_data, void (*user_data_free_fn)(void*)) {\n  binn_set_user_data(&jbl->bn, user_data, user_data_free_fn);\n}\n\nvoid* jbl_get_user_data(JBL jbl) {\n  return jbl->bn.user_data;\n}\n\niwrc jbl_set_int64(JBL jbl, const char *key, int64_t v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_int64(bv, key, v)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_int64(bv, v)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_f64(JBL jbl, const char *key, double v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_double(bv, key, v)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_double(bv, v)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_string(JBL jbl, const char *key, const char *v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_str(bv, key, v)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_const_str(bv, v)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_string_printf(JBL jbl, const char *key, const char *format, ...) {\n  iwrc rc = 0;\n  va_list ap;\n\n  va_start(ap, format);\n  int size = _jbl_printf_estimate_size(format, ap);\n  if (size < 0) {\n    va_end(ap);\n    return IW_ERROR_INVALID_ARGS;\n  }\n  va_end(ap);\n\n  va_start(ap, format);\n  char *buf = malloc(size);\n  RCGA(buf, finish);\n  vsnprintf(buf, size, format, ap);\n  va_end(ap);\n\n  rc = jbl_set_string(jbl, key, buf);\nfinish:\n  free(buf);\n  return rc;\n}\n\niwrc jbl_from_json_printf_va(JBL *jblp, const char *format, va_list va) {\n  iwrc rc = 0;\n  va_list cva;\n\n  va_copy(cva, va);\n  int size = _jbl_printf_estimate_size(format, va);\n  if (size < 0) {\n    va_end(cva);\n    return IW_ERROR_INVALID_ARGS;\n  }\n  char *buf = malloc(size);\n  RCGA(buf, finish);\n  vsnprintf(buf, size, format, cva);\n  va_end(cva);\n\n  rc = jbl_from_json(jblp, buf);\n\nfinish:\n  free(buf);\n  return rc;\n}\n\niwrc jbl_from_json_printf(JBL *jblp, const char *format, ...) {\n  va_list ap;\n\n  va_start(ap, format);\n  iwrc rc = jbl_from_json_printf_va(jblp, format, ap);\n  va_end(ap);\n  return rc;\n}\n\niwrc jbn_from_json_printf_va(JBL_NODE *node, IWPOOL *pool, const char *format, va_list va) {\n  iwrc rc = 0;\n  va_list cva;\n\n  va_copy(cva, va);\n  int size = _jbl_printf_estimate_size(format, va);\n  if (size < 0) {\n    va_end(cva);\n    return IW_ERROR_INVALID_ARGS;\n  }\n  char *buf = malloc(size);\n  RCGA(buf, finish);\n  vsnprintf(buf, size, format, cva);\n  va_end(cva);\n\n  rc = jbn_from_json(buf, node, pool);\n\nfinish:\n  free(buf);\n  return rc;\n}\n\niwrc jbn_from_json_printf(JBL_NODE *node, IWPOOL *pool, const char *format, ...) {\n  va_list ap;\n\n  va_start(ap, format);\n  iwrc rc = jbn_from_json_printf_va(node, pool, format, ap);\n  va_end(ap);\n  return rc;\n}\n\niwrc jbl_set_bool(JBL jbl, const char *key, bool v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_bool(bv, key, v)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_bool(bv, v)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_null(JBL jbl, const char *key) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_null(bv, key)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_null(bv)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_empty_array(JBL jbl, const char *key) {\n  JBL v = 0;\n  iwrc rc = jbl_create_empty_array(&v);\n  RCGO(rc, finish);\n  rc = jbl_set_nested(jbl, key, v);\nfinish:\n  jbl_destroy(&v);\n  return rc;\n}\n\niwrc jbl_set_empty_object(JBL jbl, const char *key) {\n  JBL v = 0;\n  iwrc rc = jbl_create_empty_object(&v);\n  RCGO(rc, finish);\n  rc = jbl_set_nested(jbl, key, v);\nfinish:\n  jbl_destroy(&v);\n  return rc;\n}\n\niwrc jbl_set_nested(JBL jbl, const char *key, JBL v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_value(bv, key, &v->bn)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_value(bv, &v->bn)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_from_buf_keep(JBL *jblp, void *buf, size_t bufsz, bool keep_on_destroy) {\n  int type, size = 0, count = 0;\n  if ((bufsz < MIN_BINN_SIZE) || !binn_is_valid_header(buf, &type, &count, &size, NULL)) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  if (size > bufsz) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  *jblp = calloc(1, sizeof(**jblp));\n  if (!*jblp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  JBL jbl = *jblp;\n  jbl->bn.header = BINN_MAGIC;\n  jbl->bn.type = type;\n  jbl->bn.ptr = buf;\n  jbl->bn.size = size;\n  jbl->bn.count = count;\n  jbl->bn.freefn = keep_on_destroy ? 0 : free;\n  return 0;\n}\n\niwrc jbl_clone(JBL src, JBL *targetp) {\n  *targetp = calloc(1, sizeof(**targetp));\n  JBL t = *targetp;\n  if (!t) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  binn *bn = binn_copy(&src->bn);\n  if (!bn) {\n    return JBL_ERROR_CREATION;\n  }\n  t->node = 0;\n  bn->allocated = 0;\n  memcpy(&t->bn, bn, sizeof(*bn));\n  free(bn);\n  return 0;\n}\n\nIW_EXPORT iwrc jbl_object_copy_to(JBL src, JBL target) {\n  iwrc rc = 0;\n  // According to binn spec keys are not null terminated\n  // and key length is not more than 255 bytes\n  char *key, kbuf[256];\n  int klen;\n  JBL holder = 0;\n  JBL_iterator it;\n\n  if ((jbl_type(src) != JBV_OBJECT) || (jbl_type(target) != JBV_OBJECT)) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  RCC(rc, finish, jbl_create_iterator_holder(&holder));\n  RCC(rc, finish, jbl_iterator_init(src, &it));\n  while (jbl_iterator_next(&it, holder, &key, &klen)) {\n    memcpy(kbuf, key, klen);\n    kbuf[klen] = '\\0';\n    RCC(rc, finish, jbl_set_nested(target, kbuf, holder));\n  }\n\nfinish:\n  jbl_destroy(&holder);\n  return rc;\n}\n\niwrc jbl_clone_into_pool(JBL src, JBL *targetp, IWPOOL *pool) {\n  *targetp = 0;\n  if (src->bn.writable && src->bn.dirty) {\n    if (!binn_save_header(&src->bn)) {\n      return JBL_ERROR_INVALID;\n    }\n  }\n  JBL jbl = iwpool_alloc(sizeof(*jbl) + src->bn.size, pool);\n  if (!jbl) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  jbl->node = 0;\n  memcpy(&jbl->bn, &src->bn, sizeof(jbl->bn));\n  jbl->bn.ptr = (char*) jbl + sizeof(*jbl);\n  memcpy(jbl->bn.ptr, src->bn.ptr, src->bn.size);\n  jbl->bn.freefn = 0;\n  *targetp = jbl;\n  return 0;\n}\n\niwrc jbl_from_buf_keep_onstack(JBL jbl, void *buf, size_t bufsz) {\n  int type, size = 0, count = 0;\n  if ((bufsz < MIN_BINN_SIZE) || !binn_is_valid_header(buf, &type, &count, &size, NULL)) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  if (size > bufsz) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  memset(jbl, 0, sizeof(*jbl));\n  jbl->bn.header = BINN_MAGIC;\n  jbl->bn.type = type;\n  jbl->bn.ptr = buf;\n  jbl->bn.size = size;\n  jbl->bn.count = count;\n  return 0;\n}\n\niwrc jbl_from_buf_keep_onstack2(JBL jbl, void *buf) {\n  int type, size = 0, count = 0;\n  if (!binn_is_valid_header(buf, &type, &count, &size, NULL)) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  memset(jbl, 0, sizeof(*jbl));\n  jbl->bn.header = BINN_MAGIC;\n  jbl->bn.type = type;\n  jbl->bn.ptr = buf;\n  jbl->bn.size = size;\n  jbl->bn.count = count;\n  return 0;\n}\n\nvoid jbl_destroy(JBL *jblp) {\n  if (*jblp) {\n    JBL jbl = *jblp;\n    binn_free(&jbl->bn);\n    free(jbl);\n    *jblp = 0;\n  }\n}\n\niwrc jbl_create_iterator_holder(JBL *jblp) {\n  *jblp = calloc(1, sizeof(**jblp));\n  if (!*jblp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  return 0;\n}\n\niwrc jbl_iterator_init(JBL jbl, JBL_iterator *iter) {\n  int btype = jbl->bn.type;\n  if ((btype != BINN_OBJECT) && (btype != BINN_LIST) && (btype != BINN_MAP)) {\n    memset(iter, 0, sizeof(*iter));\n    return 0;\n  }\n  binn_iter *biter = (binn_iter*) iter;\n  if (!binn_iter_init(biter, &jbl->bn, btype)) {\n    return JBL_ERROR_CREATION;\n  }\n  return 0;\n}\n\nbool jbl_iterator_next(JBL_iterator *iter, JBL holder, char **pkey, int *klen) {\n  binn_iter *biter = (binn_iter*) iter;\n  if (pkey) {\n    *pkey = 0;\n  }\n  if (klen) {\n    *klen = 0;\n  }\n  if (!iter || (iter->type == 0)) {\n    return false;\n  }\n  if (iter->type == BINN_LIST) {\n    if (klen) {\n      *klen = iter->current;\n    }\n    return binn_list_next(biter, &holder->bn);\n  } else {\n    return binn_read_next_pair2(iter->type, biter, klen, pkey, &holder->bn);\n  }\n  return false;\n}\n\nIW_INLINE jbl_type_t _jbl_binn_type(int btype) {\n  switch (btype) {\n    case BINN_NULL:\n      return JBV_NULL;\n    case BINN_STRING:\n      return JBV_STR;\n    case BINN_OBJECT:\n    case BINN_MAP:\n      return JBV_OBJECT;\n    case BINN_LIST:\n      return JBV_ARRAY;\n    case BINN_BOOL:\n    case BINN_TRUE:\n    case BINN_FALSE:\n      return JBV_BOOL;\n    case BINN_UINT8:\n    case BINN_UINT16:\n    case BINN_UINT32:\n    case BINN_UINT64:\n    case BINN_INT8:\n    case BINN_INT16:\n    case BINN_INT32:\n    case BINN_INT64:\n      return JBV_I64;\n    case BINN_FLOAT32:\n    case BINN_FLOAT64:\n      return JBV_F64;\n    default:\n      return JBV_NONE;\n  }\n}\n\njbl_type_t jbl_type(JBL jbl) {\n  if (jbl) {\n    return _jbl_binn_type(jbl->bn.type);\n  }\n  return JBV_NONE;\n}\n\nsize_t jbl_count(JBL jbl) {\n  return (size_t) jbl->bn.count;\n}\n\nsize_t jbl_size(JBL jbl) {\n  return (size_t) jbl->bn.size;\n}\n\nsize_t jbl_structure_size(void) {\n  return sizeof(struct _JBL);\n}\n\niwrc jbl_from_json(JBL *jblp, const char *jsonstr) {\n  *jblp = 0;\n  iwrc rc = 0;\n  IWPOOL *pool = iwpool_create(2 * strlen(jsonstr));\n  if (!pool) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  JBL jbl;\n  JBL_NODE node;\n  rc = jbn_from_json(jsonstr, &node, pool);\n  RCGO(rc, finish);\n  if (node->type == JBV_OBJECT) {\n    rc = jbl_create_empty_object(&jbl);\n    RCGO(rc, finish);\n  } else if (node->type == JBV_ARRAY) {\n    rc = jbl_create_empty_array(&jbl);\n    RCGO(rc, finish);\n  } else {\n    // TODO: Review\n    rc = JBL_ERROR_CREATION;\n    goto finish;\n  }\n  rc = jbl_fill_from_node(jbl, node);\n  if (!rc) {\n    *jblp = jbl;\n  }\n\nfinish:\n  iwpool_destroy(pool);\n  return rc;\n}\n\niwrc _jbl_write_double(double num, jbl_json_printer pt, void *op) {\n  size_t sz;\n  char buf[IWNUMBUF_SIZE];\n  iwjson_ftoa(num, buf, &sz);\n  return pt(buf, -1, 0, 0, op);\n}\n\niwrc _jbl_write_int(int64_t num, jbl_json_printer pt, void *op) {\n  char buf[IWNUMBUF_SIZE];\n  int sz = iwitoa(num, buf, sizeof(buf));\n  return pt(buf, sz, 0, 0, op);\n}\n\niwrc _jbl_write_string(const char *str, int len, jbl_json_printer pt, void *op, jbl_print_flags_t pf) {\n  iwrc rc = pt(0, 0, '\"', 1, op);\n  RCRET(rc);\n  static const char *specials = \"btnvfr\";\n  const uint8_t *p = (const uint8_t*) str;\n\n#define PT(data_, size_, ch_, count_) do { \\\n    rc = pt((const char*) (data_), size_, ch_, count_, op); \\\n    RCRET(rc); \\\n} while (0)\n\n  if (len < 0) {\n    len = (int) strlen(str);\n  }\n  for (size_t i = 0; i < len; i++) {\n    uint8_t ch = p[i];\n    if ((ch == '\"') || (ch == '\\\\')) {\n      PT(0, 0, '\\\\', 1);\n      PT(0, 0, ch, 1);\n    } else if ((ch >= '\\b') && (ch <= '\\r')) {\n      PT(0, 0, '\\\\', 1);\n      PT(0, 0, specials[ch - '\\b'], 1);\n    } else if (isprint(ch)) {\n      PT(0, 0, ch, 1);\n    } else if (pf & JBL_PRINT_CODEPOINTS) {\n      char sbuf[7]; // escaped unicode seq\n      utf8proc_int32_t cp;\n      utf8proc_ssize_t sz = utf8proc_iterate(p + i, len - i, &cp);\n      if (sz < 0) {\n        return JBL_ERROR_PARSE_INVALID_UTF8;\n      }\n      if (cp > 0x0010000UL) {\n        uint32_t hs = 0xD800, ls = 0xDC00; // surrogates\n        cp -= 0x0010000UL;\n        hs |= ((cp >> 10) & 0x3FF);\n        ls |= (cp & 0x3FF);\n        snprintf(sbuf, 7, \"\\\\u%04X\", hs);\n        PT(sbuf, 6, 0, 0);\n        snprintf(sbuf, 7, \"\\\\u%04X\", ls);\n        PT(sbuf, 6, 0, 0);\n      } else {\n        snprintf(sbuf, 7, \"\\\\u%04X\", cp);\n        PT(sbuf, 6, 0, 0);\n      }\n      i += sz - 1;\n    } else {\n      PT(0, 0, ch, 1);\n    }\n  }\n  rc = pt(0, 0, '\"', 1, op);\n  return rc;\n#undef PT\n}\n\nstatic iwrc _jbl_as_json(binn *bn, jbl_json_printer pt, void *op, int lvl, jbl_print_flags_t pf) {\n  iwrc rc = 0;\n  binn bv;\n  binn_iter iter;\n  int lv;\n  int64_t llv;\n  double dv;\n  char key[MAX_BIN_KEY_LEN + 1];\n  bool pretty = pf & JBL_PRINT_PRETTY;\n\n#define PT(data_, size_, ch_, count_) do { \\\n    rc = pt(data_, size_, ch_, count_, op); \\\n    RCGO(rc, finish); \\\n} while (0)\n\n  switch (bn->type) {\n    case BINN_LIST:\n      if (!binn_iter_init(&iter, bn, bn->type)) {\n        rc = JBL_ERROR_INVALID;\n        goto finish;\n      }\n      PT(0, 0, '[', 1);\n      if (bn->count && pretty) {\n        PT(0, 0, '\\n', 1);\n      }\n      for (int i = 0; binn_list_next(&iter, &bv); ++i) {\n        if (pretty) {\n          PT(0, 0, ' ', lvl + 1);\n        }\n        rc = _jbl_as_json(&bv, pt, op, lvl + 1, pf);\n        RCGO(rc, finish);\n        if (i < bn->count - 1) {\n          PT(0, 0, ',', 1);\n        }\n        if (pretty) {\n          PT(0, 0, '\\n', 1);\n        }\n      }\n      if (bn->count && pretty) {\n        PT(0, 0, ' ', lvl);\n      }\n      PT(0, 0, ']', 1);\n      break;\n\n    case BINN_OBJECT:\n    case BINN_MAP:\n      if (!binn_iter_init(&iter, bn, bn->type)) {\n        rc = JBL_ERROR_INVALID;\n        goto finish;\n      }\n      PT(0, 0, '{', 1);\n      if (bn->count && pretty) {\n        PT(0, 0, '\\n', 1);\n      }\n      if (bn->type == BINN_OBJECT) {\n        for (int i = 0; binn_object_next(&iter, key, &bv); ++i) {\n          if (pretty) {\n            PT(0, 0, ' ', lvl + 1);\n          }\n          rc = _jbl_write_string(key, -1, pt, op, pf);\n          RCGO(rc, finish);\n          if (pretty) {\n            PT(\": \", -1, 0, 0);\n          } else {\n            PT(0, 0, ':', 1);\n          }\n          rc = _jbl_as_json(&bv, pt, op, lvl + 1, pf);\n          RCGO(rc, finish);\n          if (i < bn->count - 1) {\n            PT(0, 0, ',', 1);\n          }\n          if (pretty) {\n            PT(0, 0, '\\n', 1);\n          }\n        }\n      } else {\n        for (int i = 0; binn_map_next(&iter, &lv, &bv); ++i) {\n          if (pretty) {\n            PT(0, 0, ' ', lvl + 1);\n          }\n          PT(0, 0, '\"', 1);\n          rc = _jbl_write_int(lv, pt, op);\n          RCGO(rc, finish);\n          PT(0, 0, '\"', 1);\n          if (pretty) {\n            PT(\": \", -1, 0, 0);\n          } else {\n            PT(0, 0, ':', 1);\n          }\n          rc = _jbl_as_json(&bv, pt, op, lvl + 1, pf);\n          RCGO(rc, finish);\n          if (i < bn->count - 1) {\n            PT(0, 0, ',', 1);\n          }\n          if (pretty) {\n            PT(0, 0, '\\n', 1);\n          }\n        }\n      }\n      if (bn->count && pretty) {\n        PT(0, 0, ' ', lvl);\n      }\n      PT(0, 0, '}', 1);\n      break;\n\n    case BINN_STRING:\n      rc = _jbl_write_string(bn->ptr, -1, pt, op, pf);\n      break;\n    case BINN_UINT8:\n      llv = bn->vuint8;\n      goto loc_int;\n    case BINN_UINT16:\n      llv = bn->vuint16;\n      goto loc_int;\n    case BINN_UINT32:\n      llv = bn->vuint32;\n      goto loc_int;\n    case BINN_INT8:\n      llv = bn->vint8; // NOLINT(bugprone-signed-char-misuse)\n      goto loc_int;\n    case BINN_INT16:\n      llv = bn->vint16;\n      goto loc_int;\n    case BINN_INT32:\n      llv = bn->vint32;\n      goto loc_int;\n    case BINN_INT64:\n      llv = bn->vint64;\n      goto loc_int;\n    case BINN_UINT64: // overflow?\n      llv = (int64_t) bn->vuint64;\nloc_int:\n      rc = _jbl_write_int(llv, pt, op);\n      break;\n\n    case BINN_FLOAT32:\n      dv = bn->vfloat;\n      goto loc_float;\n    case BINN_FLOAT64:\n      dv = bn->vdouble;\nloc_float:\n      rc = _jbl_write_double(dv, pt, op);\n      break;\n\n    case BINN_TRUE:\n      PT(\"true\", 4, 0, 0);\n      break;\n    case BINN_FALSE:\n      PT(\"false\", 5, 0, 0);\n      break;\n    case BINN_BOOL:\n      PT(bn->vbool ? \"true\" : \"false\", -1, 0, 1);\n      break;\n    case BINN_NULL:\n      PT(\"null\", 4, 0, 0);\n      break;\n    default:\n      iwlog_ecode_error3(IW_ERROR_ASSERTION);\n      rc = IW_ERROR_ASSERTION;\n      break;\n  }\n\nfinish:\n  return rc;\n#undef PT\n}\n\niwrc jbl_as_json(JBL jbl, jbl_json_printer pt, void *op, jbl_print_flags_t pf) {\n  if (!jbl || !pt) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  return _jbl_as_json(&jbl->bn, pt, op, 0, pf);\n}\n\niwrc jbl_fstream_json_printer(const char *data, int size, char ch, int count, void *op) {\n  FILE *file = op;\n  if (!file) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  if (!data) {\n    if (count) {\n      char cbuf[count]; // TODO: review overflow\n      memset(cbuf, ch, sizeof(cbuf));\n      size_t wc = fwrite(cbuf, 1, count, file);\n      if (wc != sizeof(cbuf)) {\n        return iwrc_set_errno(IW_ERROR_IO_ERRNO, errno);\n      }\n    }\n  } else {\n    if (size < 0) {\n      size = (int) strlen(data);\n    }\n    if (!count) {\n      count = 1;\n    }\n    for (int i = 0; i < count; ++i) {\n      if (fprintf(file, \"%.*s\", size, data) < 0) {\n        return iwrc_set_errno(IW_ERROR_IO_ERRNO, errno);\n      }\n    }\n  }\n  return 0;\n}\n\niwrc jbl_xstr_json_printer(const char *data, int size, char ch, int count, void *op) {\n  IWXSTR *xstr = op;\n  if (!xstr) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  if (!data) {\n    if (count) {\n      for (int i = 0; i < count; ++i) {\n        iwrc rc = iwxstr_cat(xstr, &ch, 1);\n        RCRET(rc);\n      }\n    }\n  } else {\n    if (size < 0) {\n      size = (int) strlen(data);\n    }\n    if (!count) {\n      count = 1;\n    }\n    for (int i = 0; i < count; ++i) {\n      iwrc rc = iwxstr_cat(xstr, data, size);\n      RCRET(rc);\n    }\n  }\n  return 0;\n}\n\niwrc jbl_count_json_printer(const char *data, int size, char ch, int count, void *op) {\n  int *cnt = op;\n  if (!data) {\n    *cnt = *cnt + count;\n  } else {\n    if (size < 0) {\n      size = (int) strlen(data);\n    }\n    if (!count) {\n      count = 1;\n    }\n    *cnt = *cnt + count * size;\n  }\n  return 0;\n}\n\nint64_t jbl_get_i64(JBL jbl) {\n  assert(jbl);\n  switch (jbl->bn.type) {\n    case BINN_UINT8:\n      return jbl->bn.vuint8;\n    case BINN_UINT16:\n      return jbl->bn.vuint16;\n    case BINN_UINT32:\n      return jbl->bn.vuint32;\n    case BINN_UINT64:\n      return jbl->bn.vuint64;\n    case BINN_INT8:\n      return jbl->bn.vint8;\n    case BINN_INT16:\n      return jbl->bn.vint16;\n    case BINN_INT32:\n      return jbl->bn.vint32;\n    case BINN_INT64:\n      return jbl->bn.vint64;\n    case BINN_BOOL:\n      return jbl->bn.vbool;\n    case BINN_FLOAT32:\n      return (int64_t) jbl->bn.vfloat;\n    case BINN_FLOAT64:\n      return (int64_t) jbl->bn.vdouble;\n    default:\n      return 0;\n  }\n}\n\nint32_t jbl_get_i32(JBL jbl) {\n  return (int32_t) jbl_get_i64(jbl);\n}\n\ndouble jbl_get_f64(JBL jbl) {\n  assert(jbl);\n  switch (jbl->bn.type) {\n    case BINN_FLOAT64:\n      return jbl->bn.vdouble;\n    case BINN_FLOAT32:\n      return jbl->bn.vfloat;\n    case BINN_UINT8:\n      return jbl->bn.vuint8;\n    case BINN_UINT16:\n      return jbl->bn.vuint16;\n    case BINN_UINT32:\n      return jbl->bn.vuint32;\n    case BINN_UINT64:\n      return jbl->bn.vuint64;\n    case BINN_INT8:\n      return jbl->bn.vint8;\n    case BINN_INT16:\n      return jbl->bn.vint16;\n    case BINN_INT32:\n      return jbl->bn.vint32;\n    case BINN_INT64:\n      return jbl->bn.vint64;\n    case BINN_BOOL:\n      return jbl->bn.vbool;\n    default:\n      return 0.0;\n  }\n}\n\nconst char* jbl_get_str(JBL jbl) {\n  assert(jbl && jbl->bn.type == BINN_STRING);\n  if (jbl->bn.type != BINN_STRING) {\n    return 0;\n  } else {\n    return jbl->bn.ptr;\n  }\n}\n\nsize_t jbl_copy_strn(JBL jbl, char *buf, size_t bufsz) {\n  assert(jbl && buf && jbl->bn.type == BINN_STRING);\n  if (jbl->bn.type != BINN_STRING) {\n    return 0;\n  }\n  size_t slen = strlen(jbl->bn.ptr);\n  size_t ret = MIN(slen, bufsz);\n  memcpy(buf, jbl->bn.ptr, ret);\n  return ret;\n}\n\njbl_type_t jbl_object_get_type(JBL jbl, const char *key) {\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBV_NONE;\n  }\n  binn bv;\n  if (!binn_object_get_value(&jbl->bn, key, &bv)) {\n    return JBV_NONE;\n  }\n  return _jbl_binn_type(bv.type);\n}\n\niwrc jbl_object_get_i64(JBL jbl, const char *key, int64_t *out) {\n  *out = 0;\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  int64 v;\n  if (!binn_object_get_int64(&jbl->bn, key, &v)) {\n    return JBL_ERROR_CREATION;\n  }\n  *out = v;\n  return 0;\n}\n\niwrc jbl_object_get_f64(JBL jbl, const char *key, double *out) {\n  *out = 0.0;\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  if (!binn_object_get_double(&jbl->bn, key, out)) {\n    return JBL_ERROR_CREATION;\n  }\n  return 0;\n}\n\niwrc jbl_object_get_bool(JBL jbl, const char *key, bool *out) {\n  *out = false;\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  BOOL v;\n  if (!binn_object_get_bool(&jbl->bn, key, &v)) {\n    return JBL_ERROR_CREATION;\n  }\n  *out = v;\n  return 0;\n}\n\niwrc jbl_object_get_str(JBL jbl, const char *key, const char **out) {\n  *out = 0;\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  if (!binn_object_get_str(&jbl->bn, key, (char**) out)) {\n    return JBL_ERROR_CREATION;\n  }\n  return 0;\n}\n\niwrc jbl_object_get_fill_jbl(JBL jbl, const char *key, JBL out) {\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  binn_free(&out->bn);\n  if (!binn_object_get_value(&jbl->bn, key, &out->bn)) {\n    return JBL_ERROR_CREATION;\n  }\n  return 0;\n}\n\niwrc jbl_as_buf(JBL jbl, void **buf, size_t *size) {\n  assert(jbl && buf && size);\n  if (jbl->bn.writable && jbl->bn.dirty) {\n    if (!binn_save_header(&jbl->bn)) {\n      return JBL_ERROR_INVALID;\n    }\n  }\n  *buf = jbl->bn.ptr;\n  *size = (size_t) jbl->bn.size;\n  return 0;\n}\n\n//----------------------------------------------------------------------------------------------------------\n\nstatic iwrc _jbl_ptr_pool(const char *path, JBL_PTR *jpp, IWPOOL *pool) {\n  iwrc rc = 0;\n  int cnt = 0, len, sz, doff;\n  int i, j, k;\n  JBL_PTR jp;\n  char *jpr; // raw pointer to jp\n  *jpp = 0;\n  if (!path || (path[0] != '/')) {\n    return JBL_ERROR_JSON_POINTER;\n  }\n  for (i = 0; path[i]; ++i) {\n    if (path[i] == '/') {\n      ++cnt;\n    }\n  }\n  len = i;\n  if ((len > 1) && (path[len - 1] == '/')) {\n    return JBL_ERROR_JSON_POINTER;\n  }\n  sz = (int) (sizeof(struct _JBL_PTR) + cnt * sizeof(char*) + len);\n  if (pool) {\n    jp = iwpool_alloc(sz, pool);\n  } else {\n    jp = malloc(sz);\n  }\n  if (!jp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  jpr = (char*) jp;\n  jp->cnt = cnt;\n  jp->sz = sz;\n\n  doff = offsetof(struct _JBL_PTR, n) + cnt * sizeof(char*);\n  assert(sz - doff >= len);\n\n  for (i = 0, j = 0, cnt = 0; path[i] && cnt < jp->cnt; ++i, ++j) {\n    if (path[i++] == '/') {\n      jp->n[cnt] = jpr + doff + j;\n      for (k = 0; ; ++i, ++k) {\n        if (!path[i] || (path[i] == '/')) {\n          --i;\n          *(jp->n[cnt] + k) = '\\0';\n          break;\n        }\n        if (path[i] == '~') {\n          if (path[i + 1] == '0') {\n            *(jp->n[cnt] + k) = '~';\n          } else if (path[i + 1] == '1') {\n            *(jp->n[cnt] + k) = '/';\n          }\n          ++i;\n        } else {\n          *(jp->n[cnt] + k) = path[i];\n        }\n      }\n      j += k;\n      ++cnt;\n    }\n  }\n  *jpp = jp;\n  return rc;\n}\n\niwrc jbl_ptr_alloc(const char *path, JBL_PTR *jpp) {\n  return _jbl_ptr_pool(path, jpp, 0);\n}\n\niwrc jbl_ptr_alloc_pool(const char *path, JBL_PTR *jpp, IWPOOL *pool) {\n  return _jbl_ptr_pool(path, jpp, pool);\n}\n\nint jbl_ptr_cmp(JBL_PTR p1, JBL_PTR p2) {\n  if (p1->sz != p2->sz) {\n    return p1->sz - p2->sz;\n  }\n  if (p1->cnt != p2->cnt) {\n    return p1->cnt - p2->cnt;\n  }\n  for (int i = 0; i < p1->cnt; ++i) {\n    int r = strcmp(p1->n[i], p2->n[i]);\n    if (r) {\n      return r;\n    }\n  }\n  return 0;\n}\n\niwrc jbl_ptr_serialize(JBL_PTR ptr, IWXSTR *xstr) {\n  for (int i = 0; i < ptr->cnt; ++i) {\n    iwrc rc = iwxstr_cat(xstr, \"/\", 1);\n    RCRET(rc);\n    rc = iwxstr_cat(xstr, ptr->n[i], strlen(ptr->n[i]));\n    RCRET(rc);\n  }\n  return 0;\n}\n\niwrc _jbl_visit(binn_iter *iter, int lvl, JBL_VCTX *vctx, JBL_VISITOR visitor) {\n  iwrc rc = 0;\n  binn *bn = vctx->bn;\n  jbl_visitor_cmd_t cmd;\n  int idx;\n  binn bv;\n\n  if (lvl > JBL_MAX_NESTING_LEVEL) {\n    return JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED;\n  }\n  if (!iter) {\n    binn_iter it;\n    if (!BINN_IS_CONTAINER_TYPE(bn->type)) {\n      return JBL_ERROR_INVALID;\n    }\n    if (!binn_iter_init(&it, bn, bn->type)) {\n      return JBL_ERROR_INVALID;\n    }\n    rc = _jbl_visit(&it, 0, vctx, visitor);\n    return rc;\n  }\n\n  switch (iter->type) {\n    case BINN_OBJECT: {\n      char key[MAX_BIN_KEY_LEN + 1];\n      while (!vctx->terminate && binn_object_next(iter, key, &bv)) {\n        cmd = visitor(lvl, &bv, key, -1, vctx, &rc);\n        RCRET(rc);\n        if (cmd & JBL_VCMD_TERMINATE) {\n          vctx->terminate = true;\n          break;\n        }\n        if (!(cmd & JBL_VCMD_SKIP_NESTED) && BINN_IS_CONTAINER_TYPE(bv.type)) {\n          binn_iter it;\n          if (!binn_iter_init(&it, &bv, bv.type)) {\n            return JBL_ERROR_INVALID;\n          }\n          rc = _jbl_visit(&it, lvl + 1, vctx, visitor);\n          RCRET(rc);\n        }\n      }\n      break;\n    }\n    case BINN_MAP: {\n      while (!vctx->terminate && binn_map_next(iter, &idx, &bv)) {\n        cmd = visitor(lvl, &bv, 0, idx, vctx, &rc);\n        RCRET(rc);\n        if (cmd & JBL_VCMD_TERMINATE) {\n          vctx->terminate = true;\n          break;\n        }\n        if (!(cmd & JBL_VCMD_SKIP_NESTED) && BINN_IS_CONTAINER_TYPE(bv.type)) {\n          binn_iter it;\n          if (!binn_iter_init(&it, &bv, bv.type)) {\n            return JBL_ERROR_INVALID;\n          }\n          rc = _jbl_visit(&it, lvl + 1, vctx, visitor);\n          RCRET(rc);\n        }\n      }\n      break;\n    }\n    case BINN_LIST: {\n      for (idx = 0; !vctx->terminate && binn_list_next(iter, &bv); ++idx) {\n        cmd = visitor(lvl, &bv, 0, idx, vctx, &rc);\n        RCRET(rc);\n        if (cmd & JBL_VCMD_TERMINATE) {\n          vctx->terminate = true;\n          break;\n        }\n        if (!(cmd & JBL_VCMD_SKIP_NESTED) && BINN_IS_CONTAINER_TYPE(bv.type)) {\n          binn_iter it;\n          if (!binn_iter_init(&it, &bv, bv.type)) {\n            return JBL_ERROR_INVALID;\n          }\n          rc = _jbl_visit(&it, lvl + 1, vctx, visitor);\n          RCRET(rc);\n        }\n      }\n      break;\n    }\n  }\n  return rc;\n}\n\niwrc jbn_visit(JBL_NODE node, int lvl, JBN_VCTX *vctx, JBN_VISITOR visitor) {\n  iwrc rc = 0;\n  if (lvl > JBL_MAX_NESTING_LEVEL) {\n    return JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED;\n  }\n  if (!node) {\n    node = vctx->root;\n    lvl = 0;\n    if (!node) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n  }\n  JBL_NODE n = node;\n  switch (node->type) {\n    case JBV_OBJECT:\n    case JBV_ARRAY: {\n      for (n = n->child; !vctx->terminate && n; n = n->next) {\n        jbn_visitor_cmd_t cmd = visitor(lvl, n, n->key, n->klidx, vctx, &rc);\n        RCRET(rc);\n        if (cmd & JBL_VCMD_TERMINATE) {\n          vctx->terminate = true;\n        }\n        if (cmd & JBN_VCMD_DELETE) {\n          JBL_NODE nn = n->next; // Keep pointer to next\n          _jbn_remove_item(node, n);\n          n->next = nn;\n        } else if (!(cmd & JBL_VCMD_SKIP_NESTED) && (n->type >= JBV_OBJECT)) {\n          rc = jbn_visit(n, lvl + 1, vctx, visitor);\n          RCRET(rc);\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  RCRET(rc);\n  if (lvl == 0) {\n    visitor(-1, node, 0, 0, vctx, &rc);\n  }\n  return rc;\n}\n\nIW_INLINE bool _jbl_visitor_update_jptr_cursor(JBL_VCTX *vctx, int lvl, const char *key, int idx) {\n  JBL_PTR jp = vctx->op;\n  if (lvl < jp->cnt) {\n    if (vctx->pos >= lvl) {\n      vctx->pos = lvl - 1;\n    }\n    if (vctx->pos + 1 == lvl) {\n      const char *keyptr;\n      char buf[IWNUMBUF_SIZE];\n      if (key) {\n        keyptr = key;\n      } else {\n        iwitoa(idx, buf, IWNUMBUF_SIZE);\n        keyptr = buf;\n      }\n      if (!strcmp(keyptr, jp->n[lvl]) || ((jp->n[lvl][0] == '*') && (jp->n[lvl][1] == '\\0'))) {\n        vctx->pos = lvl;\n        return (jp->cnt == lvl + 1);\n      }\n    }\n  }\n  return false;\n}\n\nIW_INLINE bool _jbn_visitor_update_jptr_cursor(JBN_VCTX *vctx, int lvl, const char *key, int idx) {\n  JBL_PTR jp = vctx->op;\n  if (lvl < jp->cnt) {\n    if (vctx->pos >= lvl) {\n      vctx->pos = lvl - 1;\n    }\n    if (vctx->pos + 1 == lvl) {\n      const char *keyptr;\n      char buf[IWNUMBUF_SIZE];\n      if (key) {\n        keyptr = key;\n      } else {\n        iwitoa(idx, buf, IWNUMBUF_SIZE);\n        keyptr = buf;\n        idx = (int) strlen(keyptr);\n      }\n      int jplen = (int) strlen(jp->n[lvl]);\n      if ((  (idx == jplen)\n          && !strncmp(keyptr, jp->n[lvl], idx)) || ((jp->n[lvl][0] == '*') && (jp->n[lvl][1] == '\\0'))) {\n        vctx->pos = lvl;\n        return (jp->cnt == lvl + 1);\n      }\n    }\n  }\n  return false;\n}\n\nstatic jbl_visitor_cmd_t _jbl_get_visitor2(int lvl, binn *bv, const char *key, int idx, JBL_VCTX *vctx, iwrc *rc) {\n  JBL_PTR jp = vctx->op;\n  assert(jp);\n  if (_jbl_visitor_update_jptr_cursor(vctx, lvl, key, idx)) { // Pointer matched\n    JBL jbl = vctx->result;\n    memcpy(&jbl->bn, bv, sizeof(*bv));\n    vctx->found = true;\n    return JBL_VCMD_TERMINATE;\n  } else if (jp->cnt < lvl + 1) {\n    return JBL_VCMD_SKIP_NESTED;\n  }\n  return JBL_VCMD_OK;\n}\n\nstatic jbl_visitor_cmd_t _jbl_get_visitor(int lvl, binn *bv, const char *key, int idx, JBL_VCTX *vctx, iwrc *rc) {\n  JBL_PTR jp = vctx->op;\n  assert(jp);\n  if (_jbl_visitor_update_jptr_cursor(vctx, lvl, key, idx)) { // Pointer matched\n    JBL jbl = malloc(sizeof(struct _JBL));\n    if (!jbl) {\n      *rc = iwrc_set_errno(IW_ERROR_ALLOC, errno);\n      return JBL_VCMD_TERMINATE;\n    }\n    memcpy(&jbl->bn, bv, sizeof(*bv));\n    vctx->result = jbl;\n    return JBL_VCMD_TERMINATE;\n  } else if (jp->cnt < lvl + 1) {\n    return JBL_VCMD_SKIP_NESTED;\n  }\n  return JBL_VCMD_OK;\n}\n\nbool _jbl_at(JBL jbl, JBL_PTR jp, JBL res) {\n  JBL_VCTX vctx = {\n    .bn     = &jbl->bn,\n    .op     = jp,\n    .pos    = -1,\n    .result = res\n  };\n  _jbl_visit(0, 0, &vctx, _jbl_get_visitor2);\n  return vctx.found;\n}\n\niwrc jbl_at2(JBL jbl, JBL_PTR jp, JBL *res) {\n  JBL_VCTX vctx = {\n    .bn  = &jbl->bn,\n    .op  = jp,\n    .pos = -1\n  };\n  iwrc rc = _jbl_visit(0, 0, &vctx, _jbl_get_visitor);\n  if (rc) {\n    *res = 0;\n  } else {\n    if (!vctx.result) {\n      rc = JBL_ERROR_PATH_NOTFOUND;\n      *res = 0;\n    } else {\n      *res = (JBL) vctx.result;\n    }\n  }\n  return rc;\n}\n\niwrc jbl_at(JBL jbl, const char *path, JBL *res) {\n  JBL_PTR jp;\n  iwrc rc = _jbl_ptr_pool(path, &jp, 0);\n  if (rc) {\n    *res = 0;\n    return rc;\n  }\n  rc = jbl_at2(jbl, jp, res);\n  free(jp);\n  return rc;\n}\n\nstatic jbn_visitor_cmd_t _jbn_get_visitor(int lvl, JBL_NODE n, const char *key, int klidx, JBN_VCTX *vctx, iwrc *rc) {\n  if (lvl < 0) { // EOF\n    return JBL_VCMD_OK;\n  }\n  JBL_PTR jp = vctx->op;\n  assert(jp);\n  if (_jbn_visitor_update_jptr_cursor(vctx, lvl, key, klidx)) { // Pointer matched\n    vctx->result = n;\n    return JBL_VCMD_TERMINATE;\n  } else if (jp->cnt < lvl + 1) {\n    return JBL_VCMD_SKIP_NESTED;\n  }\n  return JBL_VCMD_OK;\n}\n\niwrc jbn_at2(JBL_NODE node, JBL_PTR jp, JBL_NODE *res) {\n  JBN_VCTX vctx = {\n    .root = node,\n    .op   = jp,\n    .pos  = -1\n  };\n  iwrc rc = jbn_visit(node, 0, &vctx, _jbn_get_visitor);\n  if (rc) {\n    *res = 0;\n  } else {\n    if (!vctx.result) {\n      rc = JBL_ERROR_PATH_NOTFOUND;\n      *res = 0;\n    } else {\n      *res = (JBL_NODE) vctx.result;\n    }\n  }\n  return rc;\n}\n\niwrc jbn_at(JBL_NODE node, const char *path, JBL_NODE *res) {\n  JBL_PTR jp;\n  iwrc rc = _jbl_ptr_pool(path, &jp, 0);\n  if (rc) {\n    *res = 0;\n    return rc;\n  }\n  rc = jbn_at2(node, jp, res);\n  free(jp);\n  return rc;\n}\n\nint jbn_paths_compare(JBL_NODE n1, const char *n1path, JBL_NODE n2, const char *n2path, jbl_type_t vtype, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v1 = 0, v2 = 0;\n  iwrc rc = jbn_at(n1, n1path, &v1);\n  if (rc && (rc != JBL_ERROR_PATH_NOTFOUND)) {\n    *rcp = rc;\n    return -2;\n  }\n  rc = jbn_at(n2, n2path, &v2);\n  if (rc && (rc != JBL_ERROR_PATH_NOTFOUND)) {\n    *rcp = rc;\n    return -2;\n  }\n  if (vtype) {\n    if (((v1 == 0) || (v1->type != vtype)) || ((v2 == 0) || (v2->type != vtype))) {\n      *rcp = JBL_ERROR_TYPE_MISMATCHED;\n      return -2;\n    }\n  }\n  return _jbl_compare_nodes(v1, v2, rcp);\n}\n\nint jbn_path_compare(JBL_NODE n1, JBL_NODE n2, const char *path, jbl_type_t vtype, iwrc *rcp) {\n  return jbn_paths_compare(n1, path, n2, path, vtype, rcp);\n}\n\nint jbn_path_compare_str(JBL_NODE n, const char *path, const char *sv, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v;\n  iwrc rc = jbn_at(n, path, &v);\n  if (rc) {\n    *rcp = rc;\n    return -2;\n  }\n  struct _JBL_NODE cn = {\n    .type  = JBV_STR,\n    .vptr  = sv,\n    .vsize = (int) strlen(sv)\n  };\n  return _jbl_compare_nodes(v, &cn, rcp);\n}\n\nint jbn_path_compare_i64(JBL_NODE n, const char *path, int64_t iv, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v;\n  iwrc rc = jbn_at(n, path, &v);\n  if (rc) {\n    *rcp = rc;\n    return -2;\n  }\n  struct _JBL_NODE cn = {\n    .type = JBV_I64,\n    .vi64 = iv\n  };\n  return _jbl_compare_nodes(v, &cn, rcp);\n}\n\nint jbn_path_compare_f64(JBL_NODE n, const char *path, double fv, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v;\n  iwrc rc = jbn_at(n, path, &v);\n  if (rc) {\n    *rcp = rc;\n    return -2;\n  }\n  struct _JBL_NODE cn = {\n    .type = JBV_F64,\n    .vf64 = fv\n  };\n  return _jbl_compare_nodes(v, &cn, rcp);\n}\n\nint jbn_path_compare_bool(JBL_NODE n, const char *path, bool bv, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v;\n  iwrc rc = jbn_at(n, path, &v);\n  if (rc) {\n    *rcp = rc;\n    return -2;\n  }\n  struct _JBL_NODE cn = {\n    .type  = JBV_BOOL,\n    .vbool = bv\n  };\n  return _jbl_compare_nodes(v, &cn, rcp);\n}\n\nIW_INLINE void _jbl_node_reset_data(JBL_NODE target) {\n  jbl_type_t t = target->type;\n  memset(((uint8_t*) target) + offsetof(struct _JBL_NODE, child),\n         0,\n         sizeof(struct _JBL_NODE) - offsetof(struct _JBL_NODE, child));\n  target->type = t;\n}\n\nIW_INLINE void _jbl_copy_node_data(JBL_NODE target, JBL_NODE value) {\n  memcpy(((uint8_t*) target) + offsetof(struct _JBL_NODE, child),\n         ((uint8_t*) value) + offsetof(struct _JBL_NODE, child),\n         sizeof(struct _JBL_NODE) - offsetof(struct _JBL_NODE, child));\n}\n\niwrc _jbl_increment_node_data(JBL_NODE target, JBL_NODE value) {\n  if ((value->type != JBV_I64) && (value->type != JBV_F64)) {\n    return JBL_ERROR_PATCH_INVALID_VALUE;\n  }\n  if (target->type == JBV_I64) {\n    if (value->type == JBV_I64) {\n      target->vi64 += value->vi64;\n    } else {\n      target->vi64 += (int64_t) value->vf64;\n    }\n    return 0;\n  } else if (target->type == JBV_F64) {\n    if (value->type == JBV_F64) {\n      target->vf64 += value->vf64;\n    } else {\n      target->vf64 += (double) value->vi64;\n    }\n    return 0;\n  } else {\n    return JBL_ERROR_PATCH_TARGET_INVALID;\n  }\n}\n\nvoid jbn_data(JBL_NODE node) {\n  _jbl_node_reset_data(node);\n}\n\nint jbn_length(JBL_NODE node) {\n  int ret = 0;\n  for (JBL_NODE n = node->child; n; n = n->next) {\n    ++ret;\n  }\n  return ret;\n}\n\nstatic void _jbn_add_item(JBL_NODE parent, JBL_NODE node) {\n  assert(parent && node);\n  node->next = 0;\n  node->prev = 0;\n  node->parent = parent;\n  if (parent->child) {\n    JBL_NODE prev = parent->child->prev;\n    parent->child->prev = node;\n    if (prev) { // -V1051\n      prev->next = node;\n      node->prev = prev;\n    } else {\n      parent->child->next = node;\n      node->prev = parent->child;\n    }\n  } else {\n    parent->child = node;\n  }\n  if (parent->type == JBV_ARRAY) {\n    node->key = 0;\n    if (node->prev) {\n      node->klidx = node->prev->klidx + 1;\n    } else {\n      node->klidx = 0;\n    }\n  }\n}\n\nvoid jbn_add_item(JBL_NODE parent, JBL_NODE node) {\n  _jbn_add_item(parent, node);\n}\n\niwrc jbn_add_item_str(JBL_NODE parent, const char *key, const char *val, int vlen, JBL_NODE *node_out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_STR;\n  if (val) {\n    if (vlen < 0) {\n      vlen = (int) strlen(val);\n    }\n    n->vptr = iwpool_strndup(pool, val, vlen, &rc);\n    RCGO(rc, finish);\n    n->vsize = vlen;\n  }\n  jbn_add_item(parent, n);\n  if (node_out) {\n    *node_out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_null(JBL_NODE parent, const char *key, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_NULL;\n  jbn_add_item(parent, n);\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_i64(JBL_NODE parent, const char *key, int64_t val, JBL_NODE *node_out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_I64;\n  n->vi64 = val;\n  jbn_add_item(parent, n);\n  if (node_out) {\n    *node_out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_f64(JBL_NODE parent, const char *key, double val, JBL_NODE *node_out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_F64;\n  n->vf64 = val;\n  jbn_add_item(parent, n);\n  if (node_out) {\n    *node_out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_bool(JBL_NODE parent, const char *key, bool val, JBL_NODE *node_out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_BOOL;\n  n->vbool = val;\n  jbn_add_item(parent, n);\n  if (node_out) {\n    *node_out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_obj(JBL_NODE parent, const char *key, JBL_NODE *out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_OBJECT;\n  jbn_add_item(parent, n);\n  if (out) {\n    *out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_arr(JBL_NODE parent, const char *key, JBL_NODE *out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_ARRAY;\n  jbn_add_item(parent, n);\n  if (out) {\n    *out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_copy_path(\n  JBL_NODE    src,\n  const char *src_path,\n  JBL_NODE    target,\n  const char *target_path,\n  bool        overwrite_on_nulls,\n  bool        no_src_clone,\n  IWPOOL     *pool\n  ) {\n  if (!src || !src_path || !target || !target_path || !pool) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n1, n2;\n  jbp_patch_t op = JBP_REPLACE;\n\n  if (strcmp(\"/\", src_path) != 0) { // -V526\n    rc = jbn_at(src, src_path, &n1);\n    if (rc == JBL_ERROR_PATH_NOTFOUND) {\n      return 0;\n    }\n    RCRET(rc);\n  } else {\n    n1 = src;\n  }\n  if (!overwrite_on_nulls && (n1->type <= JBV_NULL)) {\n    return 0;\n  }\n  if (no_src_clone) {\n    n2 = n1;\n  } else {\n    rc = jbn_clone(n1, &n2, pool);\n    RCRET(rc);\n  }\n\n  rc = jbn_at(target, target_path, &n1);\n  if (rc == JBL_ERROR_PATH_NOTFOUND) {\n    rc = 0;\n    op = JBP_ADD_CREATE;\n  }\n  JBL_PATCH p[] = {\n    {\n      .op = op,\n      .path = target_path,\n      .vnode = n2\n    }\n  };\n  return jbn_patch(target, p, sizeof(p) / sizeof(p[0]), pool);\n}\n\nIW_EXPORT iwrc jbn_copy_paths(\n  JBL_NODE     src,\n  JBL_NODE     target,\n  const char **paths,\n  bool         overwrite_on_nulls,\n  bool         no_src_clone,\n  IWPOOL      *pool\n  ) {\n  if (!target || !src || !paths || !pool) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  for (const char **p = paths; *p; ++p) {\n    const char *path = *p;\n    rc = jbn_copy_path(src, path, target, path, overwrite_on_nulls, no_src_clone, pool);\n    RCBREAK(rc);\n  }\n  return rc;\n}\n\nIW_INLINE void _jbn_remove_item(JBL_NODE parent, JBL_NODE child) {\n  assert(parent->child);\n  if (parent->child == child) {                 // First element\n    if (child->next) {\n      parent->child = child->next;\n      parent->child->prev = child->prev;\n      if (child->prev) {\n        child->prev->next = 0;\n      }\n    } else {\n      parent->child = 0;\n    }\n  } else if (parent->child->prev == child) {    // Last element\n    parent->child->prev = child->prev;\n    if (child->prev) {\n      child->prev->next = 0;\n    }\n  } else { // Somewhere in middle\n    if (child->next) {\n      child->next->prev = child->prev;\n    }\n    if (child->prev) {\n      child->prev->next = child->next;\n    }\n  }\n  child->next = 0;\n  child->prev = 0;\n  child->child = 0;\n  child->parent = 0;\n}\n\nvoid jbn_remove_item(JBL_NODE parent, JBL_NODE child) {\n  _jbn_remove_item(parent, child);\n}\n\nstatic iwrc _jbl_create_node(\n  JBLDRCTX   *ctx,\n  const binn *bv,\n  JBL_NODE    parent,\n  const char *key,\n  int         klidx,\n  JBL_NODE   *node,\n  bool        clone_strings\n  ) {\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_alloc(sizeof(*n), ctx->pool);\n  if (node) {\n    *node = 0;\n  }\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  memset(n, 0, sizeof(*n));\n  if (key && clone_strings) {\n    n->key = iwpool_strndup(ctx->pool, key, klidx, &rc);\n    RCGO(rc, finish);\n  } else {\n    n->key = key;\n  }\n  n->klidx = klidx;\n  n->parent = parent;\n  switch (bv->type) {\n    case BINN_NULL:\n      n->type = JBV_NULL;\n      break;\n    case BINN_STRING:\n      n->type = JBV_STR;\n      if (!clone_strings) {\n        n->vptr = bv->ptr;\n        n->vsize = bv->size;\n      } else {\n        n->vptr = iwpool_strndup(ctx->pool, bv->ptr, bv->size, &rc);\n        n->vsize = bv->size;\n        RCGO(rc, finish);\n      }\n      break;\n    case BINN_OBJECT:\n    case BINN_MAP:\n      n->type = JBV_OBJECT;\n      break;\n    case BINN_LIST:\n      n->type = JBV_ARRAY;\n      break;\n    case BINN_TRUE:\n      n->type = JBV_BOOL;\n      n->vbool = true;\n      break;\n    case BINN_FALSE:\n      n->type = JBV_BOOL;\n      n->vbool = false;\n      break;\n    case BINN_BOOL:\n      n->type = JBV_BOOL;\n      n->vbool = bv->vbool;\n      break;\n    case BINN_UINT8:\n      n->vi64 = bv->vuint8;\n      n->type = JBV_I64;\n      break;\n    case BINN_UINT16:\n      n->vi64 = bv->vuint16;\n      n->type = JBV_I64;\n      break;\n    case BINN_UINT32:\n      n->vi64 = bv->vuint32;\n      n->type = JBV_I64;\n      break;\n    case BINN_UINT64:\n      n->vi64 = bv->vuint64;\n      n->type = JBV_I64;\n      break;\n    case BINN_INT8:\n      n->vi64 = bv->vint8; // NOLINT(bugprone-signed-char-misuse)\n      n->type = JBV_I64;\n      break;\n    case BINN_INT16:\n      n->vi64 = bv->vint16;\n      n->type = JBV_I64;\n      break;\n    case BINN_INT32:\n      n->vi64 = bv->vint32;\n      n->type = JBV_I64;\n      break;\n    case BINN_INT64:\n      n->vi64 = bv->vint64;\n      n->type = JBV_I64;\n      break;\n    case BINN_FLOAT32:\n    case BINN_FLOAT64:\n      n->vf64 = bv->vdouble;\n      n->type = JBV_F64;\n      break;\n    default:\n      rc = JBL_ERROR_CREATION;\n      goto finish;\n  }\n  if (parent) {\n    _jbn_add_item(parent, n);\n  }\n\nfinish:\n  if (rc) {\n    free(n);\n  } else {\n    if (node) {\n      *node = n;\n    }\n  }\n  return rc;\n}\n\nstatic iwrc _jbl_node_from_binn_impl(\n  JBLDRCTX   *ctx,\n  const binn *bn,\n  JBL_NODE    parent,\n  char       *key,\n  int         klidx,\n  bool        clone_strings\n  ) {\n  binn bv;\n  binn_iter iter;\n  iwrc rc = 0;\n\n  switch (bn->type) {\n    case BINN_OBJECT:\n    case BINN_MAP:\n      rc = _jbl_create_node(ctx, bn, parent, key, klidx, &parent, clone_strings);\n      RCRET(rc);\n      if (!ctx->root) {\n        ctx->root = parent;\n      }\n      if (!binn_iter_init(&iter, (binn*) bn, bn->type)) {\n        return JBL_ERROR_INVALID;\n      }\n      if (bn->type == BINN_OBJECT) {\n        while (binn_object_next2(&iter, &key, &klidx, &bv)) {\n          rc = _jbl_node_from_binn_impl(ctx, &bv, parent, key, klidx, clone_strings);\n          RCRET(rc);\n        }\n      } else if (bn->type == BINN_MAP) {\n        while (binn_map_next(&iter, &klidx, &bv)) {\n          rc = _jbl_node_from_binn_impl(ctx, &bv, parent, 0, klidx, clone_strings);\n          RCRET(rc);\n        }\n      }\n      break;\n    case BINN_LIST:\n      rc = _jbl_create_node(ctx, bn, parent, key, klidx, &parent, clone_strings);\n      RCRET(rc);\n      if (!ctx->root) {\n        ctx->root = parent;\n      }\n      if (!binn_iter_init(&iter, (binn*) bn, bn->type)) {\n        return JBL_ERROR_INVALID;\n      }\n      for (int i = 0; binn_list_next(&iter, &bv); ++i) {\n        rc = _jbl_node_from_binn_impl(ctx, &bv, parent, 0, i, clone_strings);\n        RCRET(rc);\n      }\n      break;\n    default: {\n      rc = _jbl_create_node(ctx, bn, parent, key, klidx, 0, clone_strings);\n      RCRET(rc);\n      break;\n    }\n  }\n  return rc;\n}\n\niwrc _jbl_node_from_binn(const binn *bn, JBL_NODE *node, bool clone_strings, IWPOOL *pool) {\n  JBLDRCTX ctx = {\n    .pool = pool\n  };\n  iwrc rc = _jbl_node_from_binn_impl(&ctx, bn, 0, 0, -1, clone_strings);\n  if (rc) {\n    *node = 0;\n  } else {\n    *node = ctx.root;\n  }\n  return rc;\n}\n\nstatic JBL_NODE _jbl_node_find(JBL_NODE node, JBL_PTR ptr, int from, int to) {\n  if (!ptr || !node) {\n    return 0;\n  }\n  JBL_NODE n = node;\n\n  for (int i = from; n && i < ptr->cnt && i < to; ++i) {\n    if (n->type == JBV_OBJECT) {\n      int ptrnlen = (int) strlen(ptr->n[i]);\n      for (n = n->child; n; n = n->next) {\n        if (!strncmp(n->key, ptr->n[i], n->klidx) && (ptrnlen == n->klidx)) {\n          break;\n        }\n      }\n    } else if (n->type == JBV_ARRAY) {\n      int64_t idx = iwatoi(ptr->n[i]);\n      for (n = n->child; n; n = n->next) {\n        if (idx == n->klidx) {\n          break;\n        }\n      }\n    } else {\n      return 0;\n    }\n  }\n  return n;\n}\n\nIW_INLINE JBL_NODE _jbl_node_find2(JBL_NODE node, JBL_PTR ptr) {\n  if (!node || !ptr || !ptr->cnt) {\n    return 0;\n  }\n  return _jbl_node_find(node, ptr, 0, ptr->cnt - 1);\n}\n\nstatic JBL_NODE _jbl_node_detach(JBL_NODE target, JBL_PTR path) {\n  if (!path) {\n    return 0;\n  }\n  JBL_NODE parent = (path->cnt > 1) ? _jbl_node_find(target, path, 0, path->cnt - 1) : target;\n  if (!parent) {\n    return 0;\n  }\n  JBL_NODE child = _jbl_node_find(parent, path, path->cnt - 1, path->cnt);\n  if (!child) {\n    return 0;\n  }\n  _jbn_remove_item(parent, child);\n  return child;\n}\n\nJBL_NODE jbn_detach2(JBL_NODE target, JBL_PTR path) {\n  return _jbl_node_detach(target, path);\n}\n\nJBL_NODE jbn_detach(JBL_NODE target, const char *path) {\n  JBL_PTR jp;\n  iwrc rc = _jbl_ptr_pool(path, &jp, 0);\n  if (rc) {\n    return 0;\n  }\n  JBL_NODE res = jbn_detach2(target, jp);\n  free(jp);\n  return res;\n}\n\nstatic int _jbl_cmp_node_keys(const void *o1, const void *o2) {\n  JBL_NODE n1 = *((JBL_NODE*) o1);\n  JBL_NODE n2 = *((JBL_NODE*) o2);\n  if (!n1 && !n2) {\n    return 0;\n  }\n  if (!n2 || (n1->klidx > n2->klidx)) { // -V522\n    return 1;\n  } else if (!n1 || (n1->klidx < n2->klidx)) { // -V522\n    return -1;\n  }\n  return strncmp(n1->key, n2->key, n1->klidx);\n}\n\nstatic uint32_t _jbl_node_count(JBL_NODE n) {\n  uint32_t ret = 0;\n  n = n->child;\n  while (n) {\n    ret++;\n    n = n->next;\n  }\n  return ret;\n}\n\nstatic int _jbl_compare_objects(JBL_NODE n1, JBL_NODE n2, iwrc *rcp) {\n  int ret = 0;\n  uint32_t cnt = _jbl_node_count(n1);\n  uint32_t i = _jbl_node_count(n2);\n  if (cnt > i) {\n    return 1;\n  } else if (cnt < i) {\n    return -1;\n  } else if (cnt == 0) {\n    return 0;\n  }\n  JBL_NODE *s1 = malloc(2 * sizeof(JBL_NODE) * cnt);\n  if (!s1) {\n    *rcp = iwrc_set_errno(IW_ERROR_ALLOC, errno);\n    return 0;\n  }\n  JBL_NODE *s2 = s1 + cnt;\n\n  i = 0;\n  n1 = n1->child;\n  n2 = n2->child;\n  while (n1 && n2) {\n    s1[i] = n1;\n    s2[i] = n2;\n    n1 = n1->next;\n    n2 = n2->next;\n    ++i;\n  }\n  qsort(s1, cnt, sizeof(JBL_NODE), _jbl_cmp_node_keys);\n  qsort(s2, cnt, sizeof(JBL_NODE), _jbl_cmp_node_keys);\n  for (i = 0; i < cnt; ++i) {\n    ret = _jbl_cmp_node_keys(s1 + i, s2 + i);\n    if (ret) {\n      goto finish;\n    }\n    ret = _jbl_compare_nodes(s1[i], s2[i], rcp);\n    if (*rcp || ret) {\n      goto finish;\n    }\n  }\n\nfinish:\n  free(s1);\n  return ret;\n}\n\nint _jbl_compare_nodes(JBL_NODE n1, JBL_NODE n2, iwrc *rcp) {\n  if (!n1 && !n2) {\n    return 0;\n  } else if (!n1) {\n    return -1;\n  } else if (!n2) {\n    return 1;\n  } else if (n1->type != n2->type) {\n    return (int) n1->type - (int) n2->type;\n  }\n  switch (n1->type) {\n    case JBV_BOOL:\n      return n1->vbool - n2->vbool;\n    case JBV_I64:\n      return n1->vi64 > n2->vi64 ? 1 : n1->vi64 < n2->vi64 ? -1 : 0;\n    case JBV_F64: {\n      size_t sz1, sz2;\n      char b1[IWNUMBUF_SIZE];\n      char b2[IWNUMBUF_SIZE];\n      iwjson_ftoa(n1->vf64, b1, &sz1);\n      iwjson_ftoa(n2->vf64, b2, &sz2);\n      return iwafcmp(b1, sz1, b2, sz2);\n    }\n    case JBV_STR:\n      if (n1->vsize != n2->vsize) {\n        return n1->vsize - n2->vsize;\n      }\n      return strncmp(n1->vptr, n2->vptr, n1->vsize);\n    case JBV_ARRAY:\n      for (n1 = n1->child, n2 = n2->child; n1 && n2; n1 = n1->next, n2 = n2->next) {\n        int res = _jbl_compare_nodes(n1, n2, rcp);\n        if (res) {\n          return res;\n        }\n      }\n      if (n1) {\n        return 1;\n      } else if (n2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    case JBV_OBJECT:\n      return _jbl_compare_objects(n1, n2, rcp);\n    case JBV_NULL:\n    case JBV_NONE:\n      break;\n  }\n  return 0;\n}\n\nint jbn_compare_nodes(JBL_NODE n1, JBL_NODE n2, iwrc *rcp) {\n  return _jbl_compare_nodes(n1, n2, rcp);\n}\n\nstatic iwrc _jbl_target_apply_patch(JBL_NODE target, const JBL_PATCHEXT *ex, IWPOOL *pool) {\n  struct _JBL_NODE *ntmp;\n  jbp_patch_t op = ex->p->op;\n  JBL_PTR path = ex->path;\n  JBL_NODE value = ex->p->vnode;\n  bool oproot = ex->path->cnt == 1 && *ex->path->n[0] == '\\0';\n\n  if (op == JBP_TEST) {\n    iwrc rc = 0;\n    if (!value) {\n      return JBL_ERROR_PATCH_NOVALUE;\n    }\n    if (_jbl_compare_nodes(oproot ? target : _jbl_node_find(target, path, 0, path->cnt), value, &rc)) {\n      RCRET(rc);\n      return JBL_ERROR_PATCH_TEST_FAILED;\n    } else {\n      return rc;\n    }\n  }\n  if (oproot) { // Root operation\n    if (op == JBP_REMOVE) {\n      memset(target, 0, sizeof(*target));\n    } else if ((op == JBP_REPLACE) || (op == JBP_ADD) || (op == JBP_ADD_CREATE)) {\n      if (!value) {\n        return JBL_ERROR_PATCH_NOVALUE;\n      }\n      memmove(target, value, sizeof(*value));\n    }\n  } else { // Not a root\n    if ((op == JBP_REMOVE) || (op == JBP_REPLACE)) {\n      _jbl_node_detach(target, ex->path);\n    }\n    if (op == JBP_REMOVE) {\n      return 0;\n    } else if ((op == JBP_MOVE) || (op == JBP_COPY) || (op == JBP_SWAP)) {\n      if (op == JBP_MOVE) {\n        value = _jbl_node_detach(target, ex->from);\n      } else {\n        value = _jbl_node_find(target, ex->from, 0, ex->from->cnt);\n      }\n      if (!value) {\n        return JBL_ERROR_PATH_NOTFOUND;\n      }\n      if (op == JBP_SWAP) {\n        ntmp = iwpool_calloc(sizeof(*ntmp), pool);\n        if (!ntmp) {\n          return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n        }\n      }\n    } else { // ADD/REPLACE/INCREMENT\n      if (!value) {\n        return JBL_ERROR_PATCH_NOVALUE;\n      }\n    }\n    int lastidx = path->cnt - 1;\n    JBL_NODE parent = (path->cnt > 1) ? _jbl_node_find(target, path, 0, lastidx) : target;\n    if (!parent) {\n      if (op == JBP_ADD_CREATE) {\n        parent = target;\n        for (int i = 0; i < lastidx; ++i) {\n          JBL_NODE pn = _jbl_node_find(parent, path, i, i + 1);\n          if (!pn) {\n            pn = iwpool_calloc(sizeof(*pn), pool);\n            if (!pn) {\n              return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n            }\n            pn->type = JBV_OBJECT;\n            pn->key = path->n[i];\n            pn->klidx = (int) strlen(pn->key);\n            _jbn_add_item(parent, pn);\n          } else if (pn->type != JBV_OBJECT) {\n            return JBL_ERROR_PATCH_TARGET_INVALID;\n          }\n          parent = pn;\n        }\n      } else {\n        return JBL_ERROR_PATCH_TARGET_INVALID;\n      }\n    }\n    if (parent->type == JBV_ARRAY) {\n      if ((path->n[lastidx][0] == '-') && (path->n[lastidx][1] == '\\0')) {\n        if (op == JBP_SWAP) {\n          value = _jbl_node_detach(target, ex->from);\n        }\n        _jbn_add_item(parent, value); // Add to end of array\n      } else {                        // Insert into the specified index\n        int idx = iwatoi(path->n[lastidx]);\n        int cnt = idx;\n        JBL_NODE child = parent->child;\n        while (child && cnt > 0) {\n          cnt--;\n          child = child->next;\n        }\n        if (cnt > 0) {\n          return JBL_ERROR_PATCH_INVALID_ARRAY_INDEX;\n        }\n        value->klidx = idx;\n        if (child) {\n          if (op == JBP_SWAP) {\n            _jbl_copy_node_data(ntmp, value);\n            _jbl_copy_node_data(value, child);\n            _jbl_copy_node_data(child, ntmp);\n          } else {\n            value->parent = parent;\n            value->next = child;\n            value->prev = child->prev;\n            child->prev = value;\n            if (child == parent->child) {\n              parent->child = value;\n            } else {\n              value->prev->next = value;\n            }\n            while (child) {\n              child->klidx++;\n              child = child->next;\n            }\n          }\n        } else {\n          if (op == JBP_SWAP) {\n            value = _jbl_node_detach(target, ex->from);\n          }\n          _jbn_add_item(parent, value);\n        }\n      }\n    } else if (parent->type == JBV_OBJECT) {\n      JBL_NODE child = _jbl_node_find(parent, path, path->cnt - 1, path->cnt);\n      if (child) {\n        if (op == JBP_INCREMENT) {\n          return _jbl_increment_node_data(child, value);\n        } else {\n          if (op == JBP_SWAP) {\n            _jbl_copy_node_data(ntmp, value);\n            _jbl_copy_node_data(value, child);\n            _jbl_copy_node_data(child, ntmp);\n          } else {\n            _jbl_copy_node_data(child, value);\n          }\n        }\n      } else if (op != JBP_INCREMENT) {\n        if (op == JBP_SWAP) {\n          value = _jbl_node_detach(target, ex->from);\n        }\n        value->key = path->n[path->cnt - 1];\n        value->klidx = (int) strlen(value->key);\n        _jbn_add_item(parent, value);\n      } else {\n        return JBL_ERROR_PATCH_TARGET_INVALID;\n      }\n    } else {\n      return JBL_ERROR_PATCH_TARGET_INVALID;\n    }\n  }\n  return 0;\n}\n\nstatic iwrc _jbl_from_node_impl(binn *res, JBL_NODE node) {\n  iwrc rc = 0;\n  switch (node->type) {\n    case JBV_OBJECT:\n      if (!binn_create(res, BINN_OBJECT, 0, NULL)) {\n        return JBL_ERROR_CREATION;\n      }\n      for (JBL_NODE n = node->child; n; n = n->next) {\n        binn bv;\n        rc = _jbl_from_node_impl(&bv, n);\n        RCRET(rc);\n        if (!binn_object_set_value2(res, n->key, n->klidx, &bv)) {\n          rc = JBL_ERROR_CREATION;\n        }\n        binn_free(&bv);\n        RCRET(rc);\n      }\n      break;\n    case JBV_ARRAY:\n      if (!binn_create(res, BINN_LIST, 0, NULL)) {\n        return JBL_ERROR_CREATION;\n      }\n      for (JBL_NODE n = node->child; n; n = n->next) {\n        binn bv;\n        rc = _jbl_from_node_impl(&bv, n);\n        RCRET(rc);\n        if (!binn_list_add_value(res, &bv)) {\n          rc = JBL_ERROR_CREATION;\n        }\n        binn_free(&bv);\n        RCRET(rc);\n      }\n      break;\n    case JBV_STR:\n      binn_init_item(res);\n      binn_set_string(res, node->vptr, node->vsize);\n      break;\n    case JBV_I64:\n      binn_init_item(res);\n      binn_set_int64(res, node->vi64);\n      break;\n    case JBV_F64:\n      binn_init_item(res);\n      binn_set_double(res, node->vf64);\n      break;\n    case JBV_BOOL:\n      binn_init_item(res);\n      binn_set_bool(res, node->vbool);\n      break;\n    case JBV_NULL:\n      binn_init_item(res);\n      binn_set_null(res);\n      break;\n    case JBV_NONE:\n      rc = JBL_ERROR_CREATION;\n      break;\n  }\n  return rc;\n}\n\niwrc _jbl_binn_from_node(binn *res, JBL_NODE node) {\n  iwrc rc = _jbl_from_node_impl(res, node);\n  if (!rc) {\n    if (res->writable && res->dirty) {\n      binn_save_header(res);\n    }\n  }\n  return rc;\n}\n\niwrc _jbl_from_node(JBL jbl, JBL_NODE node) {\n  jbl->node = node;\n  return _jbl_binn_from_node(&jbl->bn, node);\n}\n\nstatic iwrc _jbl_patch_node(JBL_NODE root, const JBL_PATCH *p, size_t cnt, IWPOOL *pool) {\n  if (cnt < 1) {\n    return 0;\n  }\n  if (!root || !p) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  size_t i = 0;\n  JBL_PATCHEXT parr[cnt];\n  memset(parr, 0, cnt * sizeof(JBL_PATCHEXT));\n  for (i = 0; i < cnt; ++i) {\n    JBL_PATCHEXT *ext = &parr[i];\n    ext->p = &p[i];\n    rc = _jbl_ptr_pool(p[i].path, &ext->path, pool);\n    RCRET(rc);\n    if (p[i].from) {\n      rc = _jbl_ptr_pool(p[i].from, &ext->from, pool);\n      RCRET(rc);\n    }\n  }\n  for (i = 0; i < cnt; ++i) {\n    rc = _jbl_target_apply_patch(root, &parr[i], pool);\n    RCRET(rc);\n  }\n  return rc;\n}\n\nstatic iwrc _jbl_patch(JBL jbl, const JBL_PATCH *p, size_t cnt, IWPOOL *pool) {\n  if (cnt < 1) {\n    return 0;\n  }\n  if (!jbl || !p) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  binn bv;\n  binn *bn;\n  JBL_NODE root;\n  iwrc rc = _jbl_node_from_binn(&jbl->bn, &root, false, pool);\n  RCRET(rc);\n  rc = _jbl_patch_node(root, p, cnt, pool);\n  RCRET(rc);\n  if (root->type != JBV_NONE) {\n    rc = _jbl_from_node_impl(&bv, root);\n    RCRET(rc);\n    bn = &bv;\n  } else {\n    bn = 0;\n  }\n  binn_free(&jbl->bn);\n  if (bn) {\n    if (bn->writable && bn->dirty) {\n      binn_save_header(bn);\n    }\n    memcpy(&jbl->bn, bn, sizeof(jbl->bn));\n    jbl->bn.allocated = 0;\n  } else {\n    memset(&jbl->bn, 0, sizeof(jbl->bn));\n    root->type = JBV_NONE;\n  }\n  return rc;\n}\n\nint _jbl_cmp_atomic_values(JBL v1, JBL v2) {\n  jbl_type_t t1 = jbl_type(v1);\n  jbl_type_t t2 = jbl_type(v2);\n  if (t1 != t2) {\n    return (int) t1 - (int) t2;\n  }\n  switch (t1) {\n    case JBV_BOOL:\n    case JBV_I64: {\n      int64_t vv1 = jbl_get_i64(v1);\n      int64_t vv2 = jbl_get_i64(v2);\n      return vv1 > vv2 ? 1 : vv1 < vv2 ? -1 : 0;\n    }\n    case JBV_STR:\n      return strcmp(jbl_get_str(v1), jbl_get_str(v2)); // -V575\n    case JBV_F64: {\n      double vv1 = jbl_get_f64(v1);\n      double vv2 = jbl_get_f64(v2);\n      return vv1 > vv2 ? 1 : vv1 < vv2 ? -1 : 0;\n    }\n    default:\n      return 0;\n  }\n}\n\nbool _jbl_is_eq_atomic_values(JBL v1, JBL v2) {\n  jbl_type_t t1 = jbl_type(v1);\n  jbl_type_t t2 = jbl_type(v2);\n  if (t1 != t2) {\n    return false;\n  }\n  switch (t1) {\n    case JBV_BOOL:\n    case JBV_I64:\n      return jbl_get_i64(v1) == jbl_get_i64(v2);\n    case JBV_STR:\n      return !strcmp(jbl_get_str(v1), jbl_get_str(v2)); // -V575\n    case JBV_F64:\n      return jbl_get_f64(v1) == jbl_get_f64(v2); // -V550\n    case JBV_OBJECT:\n    case JBV_ARRAY:\n      return false;\n    default:\n      return true;\n  }\n}\n\n// --------------------------- Public API\n\nvoid jbn_apply_from(JBL_NODE target, JBL_NODE from) {\n  const int off = offsetof(struct _JBL_NODE, child);\n  memcpy((char*) target + off,\n         (char*) from + off,\n         sizeof(struct _JBL_NODE) - off);\n}\n\niwrc jbl_to_node(JBL jbl, JBL_NODE *node, bool clone_strings, IWPOOL *pool) {\n  if (jbl->node) {\n    *node = jbl->node;\n    return 0;\n  }\n  return _jbl_node_from_binn(&jbl->bn, node, clone_strings, pool);\n}\n\niwrc jbn_patch(JBL_NODE root, const JBL_PATCH *p, size_t cnt, IWPOOL *pool) {\n  return _jbl_patch_node(root, p, cnt, pool);\n}\n\niwrc jbl_patch(JBL jbl, const JBL_PATCH *p, size_t cnt) {\n  if (cnt < 1) {\n    return 0;\n  }\n  if (!jbl || !p) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  IWPOOL *pool = iwpool_create(jbl->bn.size);\n  if (!pool) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  iwrc rc = _jbl_patch(jbl, p, cnt, pool);\n  iwpool_destroy(pool);\n  return rc;\n}\n\nstatic iwrc _jbl_create_patch(JBL_NODE node, JBL_PATCH **pptr, int *cntp, IWPOOL *pool) {\n  *pptr = 0;\n  *cntp = 0;\n  int i = 0;\n  for (JBL_NODE n = node->child; n; n = n->next) {\n    if (n->type != JBV_OBJECT) {\n      return JBL_ERROR_PATCH_INVALID;\n    }\n    ++i;\n  }\n  JBL_PATCH *p = iwpool_alloc(i * sizeof(*p), pool);\n  if (!p) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  memset(p, 0, i * sizeof(*p));\n  i = 0;\n  for (JBL_NODE n = node->child; n; n = n->next, ++i) {\n    JBL_PATCH *pp = p + i;\n    for (JBL_NODE n2 = n->child; n2; n2 = n2->next) {\n      if (!strncmp(\"op\", n2->key, n2->klidx)) {\n        if (n2->type != JBV_STR) {\n          return JBL_ERROR_PATCH_INVALID;\n        }\n        if (!strncmp(\"add\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_ADD;\n        } else if (!strncmp(\"remove\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_REMOVE;\n        } else if (!strncmp(\"replace\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_REPLACE;\n        } else if (!strncmp(\"copy\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_COPY;\n        } else if (!strncmp(\"move\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_MOVE;\n        } else if (!strncmp(\"test\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_TEST;\n        } else if (!strncmp(\"increment\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_INCREMENT;\n        } else if (!strncmp(\"add_create\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_ADD_CREATE;\n        } else if (!strncmp(\"swap\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_SWAP;\n        } else {\n          return JBL_ERROR_PATCH_INVALID_OP;\n        }\n      } else if (!strncmp(\"value\", n2->key, n2->klidx)) {\n        pp->vnode = n2;\n      } else if (!strncmp(\"path\", n2->key, n2->klidx)) {\n        if (n2->type != JBV_STR) {\n          return JBL_ERROR_PATCH_INVALID;\n        }\n        pp->path = n2->vptr;\n      } else if (!strncmp(\"from\", n2->key, n2->klidx)) {\n        if (n2->type != JBV_STR) {\n          return JBL_ERROR_PATCH_INVALID;\n        }\n        pp->from = n2->vptr;\n      }\n    }\n  }\n  *cntp = i;\n  *pptr = p;\n  return 0;\n}\n\niwrc jbl_patch_from_json(JBL jbl, const char *patchjson) {\n  if (!jbl || !patchjson) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  JBL_PATCH *p;\n  JBL_NODE patch;\n  int cnt = (int) strlen(patchjson);\n  IWPOOL *pool = iwpool_create(MAX(cnt, 1024U));\n  if (!pool) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  iwrc rc = jbn_from_json(patchjson, &patch, pool);\n  RCGO(rc, finish);\n  if (patch->type == JBV_ARRAY) {\n    rc = _jbl_create_patch(patch, &p, &cnt, pool);\n    RCGO(rc, finish);\n    rc = _jbl_patch(jbl, p, cnt, pool);\n  } else if (patch->type == JBV_OBJECT) {\n    // FIXME: Merge patch not implemented\n    //_jbl_merge_patch_node()\n    rc = IW_ERROR_NOT_IMPLEMENTED;\n  } else {\n    rc = JBL_ERROR_PATCH_INVALID;\n  }\n\nfinish:\n  iwpool_destroy(pool);\n  return rc;\n}\n\niwrc jbl_fill_from_node(JBL jbl, JBL_NODE node) {\n  if (!jbl || !node) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  if (node->type == JBV_NONE) {\n    memset(jbl, 0, sizeof(*jbl));\n    return 0;\n  }\n  binn bv = { 0 };\n  iwrc rc = _jbl_binn_from_node(&bv, node);\n  RCRET(rc);\n  binn_free(&jbl->bn);\n  memcpy(&jbl->bn, &bv, sizeof(jbl->bn));\n  jbl->bn.allocated = 0;\n  return rc;\n}\n\niwrc jbl_from_node(JBL *jblp, JBL_NODE node) {\n  if (!jblp || !node) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  if (node->type == JBV_OBJECT) {\n    rc = jbl_create_empty_object(jblp);\n  } else if (node->type == JBV_ARRAY) {\n    rc = jbl_create_empty_array(jblp);\n  } else {\n    rc = IW_ERROR_INVALID_ARGS;\n  }\n  RCRET(rc);\n  return jbl_fill_from_node(*jblp, node);\n}\n\nstatic JBL_NODE _jbl_merge_patch_node(JBL_NODE target, JBL_NODE patch, IWPOOL *pool, iwrc *rcp) {\n  *rcp = 0;\n  if (!patch) {\n    return 0;\n  }\n  if (patch->type == JBV_OBJECT) {\n    if (!target) {\n      target = iwpool_alloc(sizeof(*target), pool);\n      if (!target) {\n        *rcp = iwrc_set_errno(IW_ERROR_ALLOC, errno);\n        return 0;\n      }\n      memset(target, 0, sizeof(*target));\n      target->type = JBV_OBJECT;\n      target->key = patch->key;\n      target->klidx = patch->klidx;\n    } else if (target->type != JBV_OBJECT) {\n      _jbl_node_reset_data(target);\n      target->type = JBV_OBJECT;\n    }\n    patch = patch->child;\n    while (patch) {\n      JBL_NODE patch_next = patch->next;\n      if (patch->type == JBV_NULL) {\n        JBL_NODE node = target->child;\n        while (node) {\n          if ((node->klidx == patch->klidx) && !strncmp(node->key, patch->key, node->klidx)) {\n            _jbn_remove_item(target, node);\n            break;\n          }\n          node = node->next;\n        }\n      } else {\n        JBL_NODE node = target->child;\n        while (node) {\n          if ((node->klidx == patch->klidx) && !strncmp(node->key, patch->key, node->klidx)) {\n            _jbl_copy_node_data(node, _jbl_merge_patch_node(node, patch, pool, rcp));\n            break;\n          }\n          node = node->next;\n        }\n        if (!node) {\n          _jbn_add_item(target, _jbl_merge_patch_node(0, patch, pool, rcp));\n        }\n      }\n      patch = patch_next;\n    }\n    return target;\n  } else {\n    return patch;\n  }\n}\n\niwrc jbn_merge_patch_from_json(JBL_NODE root, const char *patchjson, IWPOOL *pool) {\n  if (!root || !patchjson || !pool) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  JBL_NODE patch, res;\n  iwrc rc = jbn_from_json(patchjson, &patch, pool);\n  RCRET(rc);\n  res = _jbl_merge_patch_node(root, patch, pool, &rc);\n  RCGO(rc, finish);\n  if (res != root) {\n    memcpy(root, res, sizeof(*root)); // -V575\n  }\n\nfinish:\n  return rc;\n}\n\niwrc jbl_merge_patch(JBL jbl, const char *patchjson) {\n  if (!jbl || !patchjson) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  binn bv;\n  JBL_NODE target;\n  IWPOOL *pool = iwpool_create(jbl->bn.size * 2);\n  if (!pool) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  iwrc rc = _jbl_node_from_binn(&jbl->bn, &target, false, pool);\n  RCGO(rc, finish);\n  rc = jbn_merge_patch_from_json(target, patchjson, pool);\n  RCGO(rc, finish);\n\n  rc = _jbl_binn_from_node(&bv, target);\n  RCGO(rc, finish);\n\n  binn_free(&jbl->bn);\n  memcpy(&jbl->bn, &bv, sizeof(jbl->bn));\n  jbl->bn.allocated = 0;\n\nfinish:\n  iwpool_destroy(pool);\n  return 0;\n}\n\niwrc jbl_merge_patch_jbl(JBL jbl, JBL patch) {\n  IWXSTR *xstr = iwxstr_new();\n  if (!xstr) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  iwrc rc = jbl_as_json(patch, jbl_xstr_json_printer, xstr, 0);\n  RCGO(rc, finish);\n  rc = jbl_merge_patch(jbl, iwxstr_ptr(xstr));\nfinish:\n  iwxstr_destroy(xstr);\n  return rc;\n}\n\niwrc jbn_patch_auto(JBL_NODE root, JBL_NODE patch, IWPOOL *pool) {\n  if (!root || !patch || !pool) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  if (patch->type == JBV_OBJECT) {\n    _jbl_merge_patch_node(root, patch, pool, &rc);\n  } else if (patch->type == JBV_ARRAY) {\n    int cnt;\n    JBL_PATCH *p;\n    rc = _jbl_create_patch(patch, &p, &cnt, pool);\n    RCRET(rc);\n    rc = _jbl_patch_node(root, p, cnt, pool);\n  } else {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  return rc;\n}\n\niwrc jbn_merge_patch(JBL_NODE root, JBL_NODE patch, IWPOOL *pool) {\n  if (!root || !patch || !pool || (root->type != JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  _jbl_merge_patch_node(root, patch, pool, &rc);\n  return rc;\n}\n\nstatic const char* _jbl_ecodefn(locale_t locale, uint32_t ecode) {\n  if (!((ecode > _JBL_ERROR_START) && (ecode < _JBL_ERROR_END))) {\n    return 0;\n  }\n  switch (ecode) {\n    case JBL_ERROR_INVALID_BUFFER:\n      return \"Invalid JBL buffer (JBL_ERROR_INVALID_BUFFER)\";\n    case JBL_ERROR_CREATION:\n      return \"Cannot create JBL object (JBL_ERROR_CREATION)\";\n    case JBL_ERROR_INVALID:\n      return \"Invalid JBL object (JBL_ERROR_INVALID)\";\n    case JBL_ERROR_PARSE_JSON:\n      return \"Failed to parse JSON string (JBL_ERROR_PARSE_JSON)\";\n    case JBL_ERROR_PARSE_UNQUOTED_STRING:\n      return \"Unquoted JSON string (JBL_ERROR_PARSE_UNQUOTED_STRING)\";\n    case JBL_ERROR_PARSE_INVALID_CODEPOINT:\n      return \"Invalid unicode codepoint/escape sequence (JBL_ERROR_PARSE_INVALID_CODEPOINT)\";\n    case JBL_ERROR_PARSE_INVALID_UTF8:\n      return \"Invalid utf8 string (JBL_ERROR_PARSE_INVALID_UTF8)\";\n    case JBL_ERROR_JSON_POINTER:\n      return \"Invalid JSON pointer (rfc6901) path (JBL_ERROR_JSON_POINTER)\";\n    case JBL_ERROR_PATH_NOTFOUND:\n      return \"JSON object not matched the path specified (JBL_ERROR_PATH_NOTFOUND)\";\n    case JBL_ERROR_PATCH_INVALID:\n      return \"Invalid JSON patch specified (JBL_ERROR_PATCH_INVALID)\";\n    case JBL_ERROR_PATCH_INVALID_OP:\n      return \"Invalid JSON patch operation specified (JBL_ERROR_PATCH_INVALID_OP)\";\n    case JBL_ERROR_PATCH_NOVALUE:\n      return \"No value specified in JSON patch (JBL_ERROR_PATCH_NOVALUE)\";\n    case JBL_ERROR_PATCH_TARGET_INVALID:\n      return \"Could not find target object to set value (JBL_ERROR_PATCH_TARGET_INVALID)\";\n    case JBL_ERROR_PATCH_INVALID_VALUE:\n      return \"Invalid value specified by patch (JBL_ERROR_PATCH_INVALID_VALUE)\";\n    case JBL_ERROR_PATCH_INVALID_ARRAY_INDEX:\n      return \"Invalid array index in JSON patch path (JBL_ERROR_PATCH_INVALID_ARRAY_INDEX)\";\n    case JBL_ERROR_PATCH_TEST_FAILED:\n      return \"JSON patch test operation failed (JBL_ERROR_PATCH_TEST_FAILED)\";\n    case JBL_ERROR_NOT_AN_OBJECT:\n      return \"JBL is not an object (JBL_ERROR_NOT_AN_OBJECT)\";\n    case JBL_ERROR_TYPE_MISMATCHED:\n      return \"Type of JBL object mismatched user type constraints (JBL_ERROR_TYPE_MISMATCHED)\";\n    case JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED:\n      return \"Exceeded the maximal object nesting level: \" _STR(JBL_MAX_NESTING_LEVEL)\n             \" (JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED)\";\n  }\n  return 0;\n}\n\niwrc jbl_init(void) {\n  static int _jbl_initialized = 0;\n  if (!__sync_bool_compare_and_swap(&_jbl_initialized, 0, 1)) {\n    return 0;\n  }\n  return iwlog_register_ecodefn(_jbl_ecodefn);\n}\n"], "fixing_code": ["iowow (1.4.16) UNRELEASED; urgency=medium\n\n  * Fixed Github Vulnerability Report GHSL-2022-066\n  * Added additional IW_ERROR_XX codes (iwlog.h)\n  * Added VERBOSE log level (iwlog.h)\n  * Added iwhmap_put_str() (iwhmap.h)\n  * Added iwulist_remove_first_by(), iwulist_find_first() (iwarr.h)\n  * Added iwxstr_new_printf() (iwxstr.h)\n  * Reduced iwkv code complexity. Removed in-memory db cache since benchmarks shows only minor perf imprivements with cache.\n  * Fixed many of UB errors (eg: misaligned access)\n  * Removed dependency on kbtree.h replaced with iwavl.h\n  * Added json module (migrated from ejdb) (iwjson.h, iwbinn.h)\n  * Added platform neutral iwp_basename() and iwp_dirname() (iwp.h)\n  * Added iwu_file_read_as_buf_len() (iwutils.h)\n  * Added IW_NORET (basedefs.h)\n  * iwxstr_destroy_keep_ptr() now returns pointer to underlying buffer\n  * IWHMAP can operate in LRU cache mode (iwhmap.h)\n  * Added .ini file parsing utility module (iwini.h)\n  * Added iw_cond_timed_wait_ms() (iwth.h)\n  * Added iwstw_set_on_task_discard(), iwstw_schedule_only() (iwstw.h)\n  * Fixed iwp_exec_path() on FreeBSD sinceprocfs(5) is not mounted by default in FreeBSD.\n  * iwp_exec_path() implemented for FreeBSD & Macos\n  * Added `int64_t iwatoi2(const char *str, size_t len)` (iwconv.h)\n  * iwpool_split_xx() now returns const pointer (iwpool.h)\n  * Fixed iwre() regexp compilation error.\n  * Added new regexp API implementation (iwre.h) based on https://github.com/jserv/cregex/\n  * Removed iwsha256() from sources. Use iwnet/beassl for hashing instead.\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 24 Feb 2022 09:18:55 +0700\n\niowow (1.4.15) testing; urgency=medium\n\n  * Added format checking __attribute__ to all printf like functions.\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 18 Feb 2022 21:54:04 +0700\n\niowow (1.4.14) testing; urgency=medium\n\n  * Used ftruncate() instead of posix_fallocate() due to EINVAL on ZFS (unix.c)\n  * Enable XOPEN_SOURCE only for linux\n  * Fixed incorrect selection of `strerror_r` for musl builds.\n  * Set appropriate _XOPEN_SOURCE=700 level for `nftw` (unix.c)\n  * iwxstr_printf() now conforms to stdlib printf function (iwxstr.h)\n  * Moved some useful defs from iwutil.h into basedefs.h\n  * Fixed iwre_match() function signatute allowing `const  char* input`\n  (iwre.h)\n  * Added lightweight regexp implementation (iwre.h)\n  * Added `size_t iwxstr_asize(IWXSTR*)` (iwxstr.h)\n  * Added locale independed strtod: iwstrtod() (iwconv.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 14 Feb 2022 18:01:17 +0700\n\niowow (1.4.13) testing; urgency=medium\n\n  * Fixed SEGV in iwkv_cursor_open with zero-length key and IWDB_VNUM64_KEYS (#42)\n  * Fixed Heap UAF in iwkv_close after invoking iwkv_db_set_meta on a database (#41)\n  * Added `iwxstr_wrap()` (iwxstr.h)\n  * Added `RCT()` checker for pthread routines (basedefs.h)\n  * Added iwbin2hex() (iwconv.h)\n  * iwxstr_clear() sets value of intgernal string buffer to zero (iwxstr.h)\n  * Added user data store capability to iwxstr (iwxstr.h)\n  * Added iwpool_strdup2(), iwpool_strndup2() (iwpool.h)\n  * Added iwp_set_current_thread_name() (iwp.h)\n  * Added RCENO define (basedefs.h)\n  * Thread poll, single thread worker fixes\n  * Added IW_MIN, IW_MAX, IW_XSTR defines\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 03 Sep 2021 16:03:05 +0700\n\niowow (1.4.12) testing; urgency=medium\n\n  * Added IW_ERROR_UNSUPPORTED error code\n  * Added  IW_ALLOC __attribute__((malloc)) optimization\n  * Added ring buffer implementation (iwrb.h)\n  * Added `queue_blocking` argument `iwstw_start()` (iwstw.h)\n  * Minor changes in iwlog.h api\n  * `memcpy` replaced by `memmove` for overlaping cases (iwarr.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 19 Jul 2021 10:09:05 +0700\n\niowow (1.4.11) testing; urgency=medium\n\n  * Fixed typo (qsort_r => sort_r) (iwarr.c)\n  * Added simple threads pool implementation (iwtp.h)\n  * Added IW_ERROR_NOT_ALLOWED error code (iwlog.h)\n  * Added RCR() error checking macro (basedefs.h)\n  * Added iwlist_sort(), iwulist_sort() (iwarr.h)\n  * Added iwstw_schedule_empty_only() (iwstw.h)\n  * Added iwstw_queue_size() (iwstw.h)\n  * Set O_CLOEXEC flag on all file open() calls\n  * Added IW_ERROR_UNEXPECTED_RESPONSE error code (iwlog.h)\n  * Added iwxstr_set_size(), iwxstr_destroy_keep_ptr() (iwxstr.h)\n  * Added iwlist_at2() (iwarr.h)\n  * Added handy ZRET definition (basedefs.h)\n  * Added handy ZGO definition (basedefs.h)\n  * Project code reformatted using uncrustify\n  * Updated copyright headers\n  * Fixed build errors on macOS\n  * Removed dependency on glibc specific features\n  * Added new iwxstr_pop() (iwxstr.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 10 May 2021 16:43:52 +0700\n\niowow (1.4.10) testing; urgency=medium\n\n  * Tuned iwkv file resizing policy\n  * Fixed misuse of `IWKV_OPTS.file_lock_fail_fast` (#35)\n  * Correct handling of EINTR, EAGAIN in read/write functions (unix.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 22 Dec 2020 23:55:36 +0700\n\niowow (1.4.9) testing; urgency=medium\n\n  * Code review of iwkv cache keys comparison, related issue: https://github.com/Softmotions/ejdb/issues/291\n  * Added `bool iwu_uuid_valid(const char *uuid)` (iwuuid.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 18 Nov 2020 15:04:03 +0700\n\niowow (1.4.8) testing; urgency=medium\n\n  * Fixed serios bug concerning non-unique ejdb2 indexes, details: https://github.com/Softmotions/ejdb/issues/291\n  * Fixed potencial memory leak in `iwlist_create()` (iwarr.h)\n  * Fixed wrong `iwulist_clear()` behaviour (iwarr.h)\n  * Code cleanup\n  * Added `iwulist_at2()` (iwarr.h)\n  * Removed not needed assertion (iwstree.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Sun, 08 Nov 2020 21:51:49 +0700\n\niowow (1.4.7) testing; urgency=medium\n\n  * Correct handling of EINTR, EAGAIN in read/write functions (unix.c)\n  * Minor fixes on iwhmap\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 21 Sep 2020 12:14:06 +0700\n\niowow (1.4.6) testing; urgency=medium\n\n  * Added `iwpool_user_data_detach()` (iwpool.h)\n  * Added `iwpool_create_empty()` (iwpool.h)\n  * Added simple hashmap implementation (iwhmap.h)\n  * `IWPOOL` is able to store associated user data (iwpool.h)\n  * `pthread_barrierattr` shim for android API < 24\n  * Added `iwsha256()` SHA-256 hash implementation (iwsha2.h)\n  * Added single thread worker (iwstw.h)\n  * Added `iwstree_clear()` (iwstree.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 24 Jun 2020 18:32:24 +0700\n\niowow (1.4.5) testing; urgency=medium\n\n  * Added `iwulist_clear` (iwarr.h)\n  * Added `RCIF` (basedefs.h)\n  * Fix assertion error in `iwstree_remove()` (iwstree.h)\n  * Allows zero key/value placeholders in `iwstree_iter_next()` (iwstree.h)\n  * Added `iwstree_put_overwrite` (iwstree.h)\n  * Added  iwstree iteration API (iwstree.h)\n  * Added `iwpool_used_size` (iwpool.h)\n  * Added `iwstree_int64_cmp` (iwstree.h)\n  * Added `IW_DEPRECATED` (basedefs.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 18 Jun 2020 14:19:32 +0700\n\niowow (1.4.4) testing; urgency=medium\n\n  * Fixed incorrect copying of cursor key data in `IWDB_COMPOUND_KEYS` mode (iwkv.c)\n  * Adde compound key example code (compoundkeys1.c)\n  * Added `iwstree_visit` (iwstree.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 02 May 2020 19:38:31 +0700\n\niowow (1.4.3) testing; urgency=medium\n\n  * Fixed errors found by PVS studio\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 24 Apr 2020 00:16:42 +0700\n\niowow (1.4.2) testing; urgency=medium\n\n  * Added IWULIST, IWLIST implementation (iwarr.h)\n  * Added iwpool_split_string (iwpool.h)\n  * Added iwpool_printf (iwpool.h)\n  * Added iwpool_printf_split (iwpool.h)\n  * Added iwxstr_shift (iwxstr.h)\n  * Added `#define RCHECK` (basedefs.h)\n  * Better error handling of `kh_put`\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 20 Apr 2020 16:23:50 +0700\n\niowow (1.4.1) testing; urgency=medium\n\n  * Fixed possible data corruption in `_fsm_blk_allocate_aligned_lw` (iwfsmfile.c)\n  * Better new SBLK blocks locality  (performance)\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 07 Mar 2020 23:23:13 +0700\n\niowow (1.4.0) testing; urgency=medium\n\n  * Implemented new compact and performant data storage format v2\n  * Added WiredTiger v3.2.1 benchmarks\n  * Added BerkeleyDB v5.3.28 benchmarks\n  * Added TokyoCabinet v1.4.48 benchmarks\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 06 Mar 2020 23:23:16 +0700\n\niowow (1.3.37) testing; urgency=medium\n\n  * Added iwrc iwp_mkdirs(const char *path) (iwp.h)\n  * Added uint32_t iwu_x31_u32_hash(const char *s) (iwutils.h)\n  * Added iwu_replace() (iwutils.h)\n  * Added RCA( macro definition\n  * Removed IW_EXPORT iwrc iwkv_db_last_access_time(IWDB db, uint64_t *ts)\n    for performance and simplicity reasons\n  * Added `IW_ERROR_INVALID_VALUE`\n  * Added iwstree - splay tree imlementation (iwstree.h)\n  * Pointers allocated by iwpool are now 8-byte aligned\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 17 Feb 2020 23:16:31 +0700\n\niowow (1.3.36) testing; urgency=medium\n\n  * Safer iowow initialization bootstrap process.\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 16 Jan 2020 12:44:31 +0700\n\niowow (1.3.35) testing; urgency=medium\n\n  * Added specific checks for TARGET_OS_IPHONE\n  * Ported to iOS\n  * Added wal locking interceptor to WAL opts\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 15 Jan 2020 13:10:51 +0700\n\niowow (1.3.32) testing; urgency=medium\n\n  * Improved WAL durability\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 19 Dec 2019 10:49:08 +0700\n\niowow (1.3.31) testing; urgency=medium\n\n  * Keys comparison refactoring\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 20 Nov 2019 00:41:15 +0700\n\niowow (1.3.30) testing; urgency=medium\n\n  * Added check if  __unused is already defined in `iwth.c`\n  * CRITICAL Comparsions keys fix #30\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 19 Nov 2019 20:23:41 +0700\n\niowow (1.3.29) testing; urgency=medium\n\n  * FIXED iwkv_open assertion fail on opening garbage file #29\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 13 Nov 2019 23:55:35 +0700\n\niowow (1.3.28) testing; urgency=medium\n\n  * iwlog now supports ANDROID NDK logging (iwlog.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 07 Nov 2019 14:44:59 +0700\n\niowow (1.3.27) testing; urgency=medium\n\n  * CRITICAL WAL durability fixes\n  * Support of online backups #24\n  * Windows platform functions fixes\n  * CLion project files added\n  * WAL recovering fixes\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 28 Oct 2019 19:08:59 +0700\n\niowow (1.3.25) testing; urgency=medium\n\n  * CRITICAL Fixed heap corruption due incorrect usage of khash API in `_db_destroy_lw` (iwkv.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 29 Aug 2019 12:20:25 +0700\n\niowow (1.3.24) testing; urgency=medium\n\n  * CRITICAL Fixed race condition in WAL rollforward\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 22 Aug 2019 02:04:08 +0700\n\niowow (1.3.23) testing; urgency=medium\n\n  * WAL refactoring, better stability\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 17 Aug 2019 21:17:05 +0700\n\niowow (1.3.22) testing; urgency=medium\n\n  * Small optimizations in `iwfsmfile.c`\n  * Added `iwp_clock_get_time` as  portable version of `clock_gettime`\n  * `static_assert` is  set to `_Static_assert` if not defined\n  * Added `__USE_MINGW_ANSI_STDIO` for MinGW build\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 18 Jul 2019 17:50:14 +0700\n\niowow (1.3.20) testing; urgency=medium\n\n  * CRITICAL Fixed incorrect keys allocation in IWDB_COMPOUND_KEYS mode\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 13 Jun 2019 21:43:47 +0700\n\niowow (1.3.19) testing; urgency=medium\n\n  * CRITICAL: Fixed assertion fail in iwkv records cache\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 13 Jun 2019 19:08:48 +0700\n\niowow (1.3.18) testing; urgency=medium\n\n  * Limit one time file allocation step to 2G\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 12 Jun 2019 16:42:47 +0700\n\niowow (1.3.17) testing; urgency=medium\n\n  * CRITICAL: State of previously deleted database may have influence on newly created dbs\n  * BUG: Fixed database metadata blocks leak (db->meta_blk) on database destroy\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 03 May 2019 18:20:39 +0700\n\niowow (1.3.16) testing; urgency=medium\n\n  * CRITICAL: Fixed deadlock on database removal\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 03 May 2019 11:56:29 +0700\n\niowow (1.3.15) testing; urgency=medium\n\n  * CRITICAL: Fixed database file corruption during sequential records deletion with `iwkv_cursor_del` (iwkv.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 01 May 2019 23:29:18 +0700\n\niowow (1.3.14) testing; urgency=medium\n\n  * CRITICAL: Fixed unexpected database file truncation and data loss on close.\n  * Adjusted default WAL options for Android\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 27 Apr 2019 01:04:28 +0700\n\niowow (1.3.13) testing; urgency=medium\n\n  * Performance impovements in Write Ahead Logging (iwal.c)\n  * BUG: WAL file was not truncated after `wal->checkpoint_timeout_sec` timeout (iwal.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 25 Apr 2019 17:43:06 +0700\n\niowow (1.3.12) testing; urgency=medium\n\n  * Android NDK support (#23)\n  * Pthreads `PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP` is used by default\n\n -- Anton Adamansky <adamansky@gmail.com>  Sun, 21 Apr 2019 12:18:16 +0700\n\niowow (1.3.11) testing; urgency=medium\n\n  * Added size_t iwpool_allocated_size(IWPOOL *pool) (iwpool.h)\n  * Added `file_lock_fail_fast` iwkv open option.\n    If `true` - do not wait and raise error if database is locked by another process\n  * Fixed meaningful PVP studio errors:\n    - kv/iwkv.c:593:1: error: V774\n    - kv/iwkv.c:1375:1: warning: V649\n    - kv/iwkv.c:3357:1: warning: V581\n    - utils/iwxstr.c:59:1: warning: V701\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 08 Apr 2019 11:47:59 +0700\n\niowow (1.3.10) testing; urgency=medium\n\n  * Added cmake `OWNER_PROJECT_NAME` option used to install header files in `CMAKE_INSTALL_INCLUDEDIR}/OWNER_PROJECT_NAME/PROJECT_NAME`\n  * Removed `-fvisibility=hidden` C flag when building shared library\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 05 Apr 2019 11:53:34 +0700\n\niowow (1.3.9) testing; urgency=medium\n\n  * BUG `IW_HAVE_PTHREAD_CONDATTR_SETCLOCK` was not properly set for `iwal.c` hence high CPU usage when `wal` mode is on.\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 29 Mar 2019 23:56:25 +0700\n\niowow (1.3.8) testing; urgency=medium\n\n  * BUG Fixed incorrect call of `_kvblk_kv_get` in `iwkv_cursor_seth`.\n    See https://github.com/Softmotions/ejdb/issues/231\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 27 Mar 2019 12:34:10 +0700\n\niowow (1.3.7) testing; urgency=medium\n\n  * Added `iwkv_cursor_del()` (#22)\n  * Fixed memory corruption during simultaneous cursor iteration and value updating\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 26 Mar 2019 18:24:35 +0700\n\niowow (1.3.6) testing; urgency=medium\n\n  * BUG: Memory leak in `iwkv_cursor_open` on error (#21)\n  * BUG: `iwxstr_new2()` with zero size argument causes illegal memory write (#20)\n  * Added `iwkv_cursor_seth()` record update handle supported by `iwkv_cursor_set`\n  * Avoided deadlocks with `iwkv_del()` - now this function does't escalate exclusive lock on storage\n  * More consistent error reporting using cursor functions\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 22 Mar 2019 16:29:32 +0700\n\niowow (1.3.5) testing; urgency=medium\n\n  * BUG: Data from deleted database can interfere with newly created db (#19)\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 20 Mar 2019 20:26:22 +0700\n\niowow (1.3.4) testing; urgency=medium\n\n  * Code documentation improvements\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 11 Mar 2019 22:42:51 +0700\n\niowow (1.3.3) testing; urgency=medium\n\n  * BUG: `iwkv_puth` called with incorrect previous value (iwkv.h)\n  * _kvblk_getvalue renamed to _kvblk_value_get (iwkv.c)\n  * _kvblk_peek_val renamed to _kvblk_value_peek (iwkv.c)\n  * _kvblk_getkey renamed to _kvblk_key_get (iwkv.c)\n  * _kvblk_getkv renamed to _kvblk_kv_get (iwkv.c)\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 08 Mar 2019 17:02:46 +0700\n\niowow (1.3.2) testing; urgency=medium\n\n  * Added `iwkv_cursor_is_matched_key` (iwkv.h)\n  * `iwkv_cursor_copy_key` now aware of `IWDB_COMPOUND_KEYS` mode (iwkv.h)\n  * `iwkv_cursor_copy_key` can accept zero kbuf,kbufsz only compound part will returned in this case (iwkv.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 04 Mar 2019 20:50:03 +0700\n\niowow (1.3.1) testing; urgency=medium\n\n  * Eliminate adaptive `IWDB_VNUM64_KEYS` key sizing in `_unpack_effective_key` for the sake of API simplicity (iwkv.c)\n  * BUG: incorrect key handling in `iwkv_del` - key was not unpacked before. (iwkv.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 28 Feb 2019 10:40:11 +0700\n\niowow (1.3.0) testing; urgency=medium\n\n  * `IWKV_PUT_HANDLER` called for insert operations (not only for updates)\n  * Added `IWFS_OUNLINK` flag. Unlink(delete) file on close (iwfile.h)\n  * Added `IWFS_OTMP` flag. Create tmp file (iwfile.h)\n  * Added UUID v4 generation function (iwuuid.h)\n  * Added iwp_tmpdir() (iwp.h)\n  * Added iwp_allocate_tmpfile_path() (iwp.h)\n  * Added iwxstr_printf() (iwxstr.h)\n  * Added iwxstr_cat2() (iwxstr.h)\n  * Added `IWKV_VAL_INCREMENT` mode for `iwkv_put()` and test case (iwkv.h)\n  * Added support of variable-length encoded integer keys `IWDB_VNUM64_KEYS` (iwkv.h)\n  * Added support of compound keys (`IWDB_COMPOUND_KEYS`) (#18)\n  * Removed `dup` integer value routines\n  * Code cleanup and refactoring\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 27 Feb 2019 12:11:48 +0700\n\niowow (1.2.14) testing; urgency=medium\n\n  * BUG: Fix WAL checkpoint workflow to avoid deadlocks with cursor threads\n  * BUG: Clang6 fatal error: variable 'cur' is used uninitialized  (#15)\n  * Implemented new multithreaded stress test (iwkv_test6.c) used OMP stack\n  * Added iwkv_new_db(IWKV iwkv, iwdb_flags_t dbflg, uint32_t *odbid, IWDB *dbp) (iwkv.h)\n  * Removed unused `IWKV_NOLOCKS` option.\n  * Added `IW_EXPORT` to `iowow_version_*` API functions  (iowow.h)\n  * Added iwrc iwkv_state(IWKV iwkv, IWFS_FSM_STATE *out) (iwkv.h)\n  * Do not check `IWKV_NO_OVERWRITE` for databases in `IWDB_DUP_UINTXX_VALS` mode\n  * Added iwkv_puth() with provided old value interceptor: `IWKV_PUT_HANDLER` (iwkv.h)\n  * Added `IWKV_RC_DUP_ARRAY_EMPTY` flag and `IWKV_DUP_REPORT_EMPTY` opflag for `iwkv_put()` (iwkv.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 06 Nov 2018 23:14:39 +0700\n\niowow (1.2.13) testing; urgency=medium\n\n  * BUG: Correct cursors adjustments during db update operations (#13)\n  * BUG: Fixed WAL integration for updates in IWDB_DUP_UINT32_VALS|IWDB_DUP_UINT64_VALS mode\n  * Store arbitrary data blocks associated with iwkv internal databases (#12)\n  * Checking of max key/value size (IWKV_MAX_KVSZ) for updates in IWDB_DUP_UINT32_VALS|IWDB_DUP_UINT64_VALS mode\n  * Minor allocation performance optimizations in _kvblk_addkv()\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 02 Aug 2018 20:29:08 +0700\n\niowow (1.2.12) testing; urgency=medium\n\n  * Set terminating '\\0' in iwitoa() (iwconv.h)\n  * Added MAP_NORESERVE option for PRIVATE mmaping on Linux (#11)\n  * Added iwu_file_read_as_buf() (iwutils.h)\n  * Optimized cmake config files generation\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 21 Jul 2018 01:59:40 +0700\n\niowow (1.2.11) testing; urgency=medium\n  * iwpool refactoring fixed pool memory corruption (iwpool.h)\n  * Fixed set terminating `\\0` in iwpool_strdup() (iwpool.h)\n  * Fixed wrong `if` in iwpool_calloc() (iwpool.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 15 Jun 2018 17:58:20 +0700\n\niowow (1.2.10) testing; urgency=medium\n\n  * Added iwpool_calloc() (iwpool.h)\n  * Added iwpool_strdup(), iwpool_strndup() (iwpool.h)\n  * Fixed memory leak in iwpool_destroy() (iwpool.h)\n  * Renamed platform/linux/linux.c to platform/unix/unix.c (#9)\n  * Added iwu_replace_char() (iwutils.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 11 Jun 2018 23:00:21 +0700\n\niowow (1.2.9) testing; urgency=medium\n\n  * Rewrite of iwftoa() (iwconv.h)\n  * Fixed typo: iwtoa renamed to iwitoa (iwconv.h)\n  * Added iwu_cmp_files (iwutils.h)\n  * Return type of iwxstr_ptr() changed to char* (iwxstr.h)\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 29 May 2018 01:01:56 +0700\n\niowow (1.2.8) testing; urgency=medium\n\n  * IOWOW Ported to MIPS32 (big-endian) tested on Debian GNU/Linux 9.4\n\n -- Anton Adamansky <adamansky@gmail.com>  Sat, 19 May 2018 21:09:04 +0700\n\niowow (1.2.7) testing; urgency=medium\n\n  * Fixed incorrect exclusive locking in iwkv_del()\"\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 17 May 2018 11:27:58 +0700\n\niowow (1.2.6) testing; urgency=medium\n\n  * Fixed: database file is not created automatically if no open modes specified in opts\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 16 May 2018 19:57:35 +0700\n\niowow (1.2.5) testing; urgency=medium\n\n  * Added iwkv_opflags opflags into iwkv_del\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 16 May 2018 19:33:16 +0700\n\niowow (1.2.4) testing; urgency=medium\n\n  * Fixed race conditions in iwkv_cursor_to()\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 14 May 2018 09:28:13 +0700\n\niowow (1.2.3) testing; urgency=medium\n\n  *  Fixed race conditions in iwkv_cursor_set()\n\n -- Anton Adamansky <adamansky@gmail.com>  Fri, 11 May 2018 23:17:13 +0700\n\niowow (1.2.2) testing; urgency=medium\n\n  * Added static iowow_s libraries to the default CMake exports.\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 08 May 2018 22:58:41 +0700\n\niowow (1.2.1) testing; urgency=medium\n\n  * Removed unistd.h from src/fs/iwdlsnr.h since it is not portable.\n  * C++ friendly header files\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 07 May 2018 12:47:46 +0700\n\niowow (1.2.0) testing; urgency=medium\n\n  * IOWOW ported to Windows x86-64 platform #1\n\n -- Anton Adamansky <adamansky@gmail.com>  Sun, 06 May 2018 20:35:14 +0700\n\niowow (1.1.0) testing; urgency=medium\n\n  * Write Ahead Log (WAL) implemented #2\n  * Changed database block size to 128 bytes so max db size 512Gb\n    WARNING: Database format of version 1.1.x is incompatible with previous versions.\n  * Better basename/basename_r detection in iwlog.c #4\n\n -- Anton Adamansky <adamansky@gmail.com>  Wed, 02 May 2018 17:28:14 +0700\n\niowow (1.0.6) testing; urgency=medium\n\n  * src/CMakeLists.txt cleanups #3\n  * x86-specific code in src/platform/iwp.c is not guarded #7\n  * Database size limited to 2GB on 32 bit CPUs #5\n  * Database block size changed: 64 to 128 bytes #8\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 16 Apr 2018 10:21:00 +0700\n\niowow (1.0.5) testing; urgency=medium\n\n  * iwextfile: do msync before munmap on file resizing\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 12 Apr 2018 20:48:26 +0700\n\niowow (1.0.4) testing; urgency=medium\n\n  * Added IWFSM_SYNC_BMAP option to iwfs_fsm_aflags\n  * Removed IWFS_NO_MMASYNC since it does noop on many platforms\n  * Set exclusive iwkv write lock in iwkv_sync()\n\n -- Anton Adamansky <adamansky@gmail.com>  Thu, 12 Apr 2018 12:33:53 +0700\n\niowow (1.0.3) testing; urgency=medium\n\n  * Added basic iowow.3 man page to distribution archive\n  * Use posix_fallocate() to extend iwkv file instead of ftruncate() on Linux/FreeBSD\n\n -- Anton Adamansky <adamansky@gmail.com>  Tue, 10 Apr 2018 18:56:11 +0700\n\niowow (1.0.2) testing; urgency=medium\n\n  * Removed unneeded -D_LARGE_FILE_SOURCE from iowow.h\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 09 Apr 2018 13:56:53 +0700\n\niowow (1.0.1) testing; urgency=medium\n\n  * Fix export flags iwlog2 method\n\n -- Anton Adamansky <adamansky@gmail.com>  Mon, 09 Apr 2018 12:44:23 +0700\n\niowow (1.0.0) testing; urgency=medium\n\n  * Initial release.\n\n -- Anton Adamansky <adamansky@gmail.com>  Sun, 08 Apr 2018 14:21:43 +0700\n", "#include \"iwjson.h\"\n#include \"iwconv.h\"\n#include \"utf8proc.h\"\n#include \"iwjson_internal.h\"\n\n#include <ctype.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <assert.h>\n\n#define _STRX(x) #x\n#define _STR(x)  _STRX(x)\n\nIW_INLINE int _jbl_printf_estimate_size(const char *format, va_list ap) {\n  char buf[1];\n  int ret = vsnprintf(buf, sizeof(buf), format, ap);\n  if (ret < 0) {\n    return ret;\n  } else {\n    return ret + 1;\n  }\n}\n\nIW_INLINE void _jbn_remove_item(JBL_NODE parent, JBL_NODE child);\nstatic void _jbn_add_item(JBL_NODE parent, JBL_NODE node);\n\nvoid iwjson_ftoa(long double val, char buf[static IWNUMBUF_SIZE], size_t *out_len) {\n  // TODO: review\n  int len = snprintf(buf, IWNUMBUF_SIZE, \"%.8Lf\", val);\n  if (len <= 0) {\n    buf[0] = '\\0';\n    *out_len = 0;\n    return;\n  }\n  while (len > 0 && buf[len - 1] == '0') { // trim zeroes from right\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  if ((len > 0) && (buf[len - 1] == '.')) {\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  *out_len = (size_t) len;\n}\n\niwrc jbl_create_empty_object(JBL *jblp) {\n  *jblp = calloc(1, sizeof(**jblp));\n  if (!*jblp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  binn_create(&(*jblp)->bn, BINN_OBJECT, 0, 0);\n  return 0;\n}\n\niwrc jbl_create_empty_array(JBL *jblp) {\n  *jblp = calloc(1, sizeof(**jblp));\n  if (!*jblp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  binn_create(&(*jblp)->bn, BINN_LIST, 0, 0);\n  return 0;\n}\n\nvoid jbl_set_user_data(JBL jbl, void *user_data, void (*user_data_free_fn)(void*)) {\n  binn_set_user_data(&jbl->bn, user_data, user_data_free_fn);\n}\n\nvoid* jbl_get_user_data(JBL jbl) {\n  return jbl->bn.user_data;\n}\n\niwrc jbl_set_int64(JBL jbl, const char *key, int64_t v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_int64(bv, key, v)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_int64(bv, v)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_f64(JBL jbl, const char *key, double v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_double(bv, key, v)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_double(bv, v)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_string(JBL jbl, const char *key, const char *v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_str(bv, key, v)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_const_str(bv, v)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_string_printf(JBL jbl, const char *key, const char *format, ...) {\n  iwrc rc = 0;\n  va_list ap;\n\n  va_start(ap, format);\n  int size = _jbl_printf_estimate_size(format, ap);\n  if (size < 0) {\n    va_end(ap);\n    return IW_ERROR_INVALID_ARGS;\n  }\n  va_end(ap);\n\n  va_start(ap, format);\n  char *buf = malloc(size);\n  RCGA(buf, finish);\n  vsnprintf(buf, size, format, ap);\n  va_end(ap);\n\n  rc = jbl_set_string(jbl, key, buf);\nfinish:\n  free(buf);\n  return rc;\n}\n\niwrc jbl_from_json_printf_va(JBL *jblp, const char *format, va_list va) {\n  iwrc rc = 0;\n  va_list cva;\n\n  va_copy(cva, va);\n  int size = _jbl_printf_estimate_size(format, va);\n  if (size < 0) {\n    va_end(cva);\n    return IW_ERROR_INVALID_ARGS;\n  }\n  char *buf = malloc(size);\n  RCGA(buf, finish);\n  vsnprintf(buf, size, format, cva);\n  va_end(cva);\n\n  rc = jbl_from_json(jblp, buf);\n\nfinish:\n  free(buf);\n  return rc;\n}\n\niwrc jbl_from_json_printf(JBL *jblp, const char *format, ...) {\n  va_list ap;\n\n  va_start(ap, format);\n  iwrc rc = jbl_from_json_printf_va(jblp, format, ap);\n  va_end(ap);\n  return rc;\n}\n\niwrc jbn_from_json_printf_va(JBL_NODE *node, IWPOOL *pool, const char *format, va_list va) {\n  iwrc rc = 0;\n  va_list cva;\n\n  va_copy(cva, va);\n  int size = _jbl_printf_estimate_size(format, va);\n  if (size < 0) {\n    va_end(cva);\n    return IW_ERROR_INVALID_ARGS;\n  }\n  char *buf = malloc(size);\n  RCGA(buf, finish);\n  vsnprintf(buf, size, format, cva);\n  va_end(cva);\n\n  rc = jbn_from_json(buf, node, pool);\n\nfinish:\n  free(buf);\n  return rc;\n}\n\niwrc jbn_from_json_printf(JBL_NODE *node, IWPOOL *pool, const char *format, ...) {\n  va_list ap;\n\n  va_start(ap, format);\n  iwrc rc = jbn_from_json_printf_va(node, pool, format, ap);\n  va_end(ap);\n  return rc;\n}\n\niwrc jbl_set_bool(JBL jbl, const char *key, bool v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_bool(bv, key, v)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_bool(bv, v)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_null(JBL jbl, const char *key) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_null(bv, key)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_null(bv)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_set_empty_array(JBL jbl, const char *key) {\n  JBL v = 0;\n  iwrc rc = jbl_create_empty_array(&v);\n  RCGO(rc, finish);\n  rc = jbl_set_nested(jbl, key, v);\nfinish:\n  jbl_destroy(&v);\n  return rc;\n}\n\niwrc jbl_set_empty_object(JBL jbl, const char *key) {\n  JBL v = 0;\n  iwrc rc = jbl_create_empty_object(&v);\n  RCGO(rc, finish);\n  rc = jbl_set_nested(jbl, key, v);\nfinish:\n  jbl_destroy(&v);\n  return rc;\n}\n\niwrc jbl_set_nested(JBL jbl, const char *key, JBL v) {\n  jbl_type_t t = jbl_type(jbl);\n  if (((t != JBV_OBJECT) && (t != JBV_ARRAY)) || !jbl->bn.writable) {\n    return JBL_ERROR_CREATION;\n  }\n  binn *bv = &jbl->bn;\n  if (key) {\n    if (t == JBV_OBJECT) {\n      if (!binn_object_set_value(bv, key, &v->bn)) {\n        return JBL_ERROR_CREATION;\n      }\n    } else {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  } else if (t == JBV_ARRAY) {\n    if (!binn_list_add_value(bv, &v->bn)) {\n      return JBL_ERROR_CREATION;\n    }\n    return 0;\n  }\n  return JBL_ERROR_INVALID;\n}\n\niwrc jbl_from_buf_keep(JBL *jblp, void *buf, size_t bufsz, bool keep_on_destroy) {\n  int type, size = 0, count = 0;\n  if ((bufsz < MIN_BINN_SIZE) || !binn_is_valid_header(buf, &type, &count, &size, NULL)) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  if (size > bufsz) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  *jblp = calloc(1, sizeof(**jblp));\n  if (!*jblp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  JBL jbl = *jblp;\n  jbl->bn.header = BINN_MAGIC;\n  jbl->bn.type = type;\n  jbl->bn.ptr = buf;\n  jbl->bn.size = size;\n  jbl->bn.count = count;\n  jbl->bn.freefn = keep_on_destroy ? 0 : free;\n  return 0;\n}\n\niwrc jbl_clone(JBL src, JBL *targetp) {\n  *targetp = calloc(1, sizeof(**targetp));\n  JBL t = *targetp;\n  if (!t) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  binn *bn = binn_copy(&src->bn);\n  if (!bn) {\n    return JBL_ERROR_CREATION;\n  }\n  t->node = 0;\n  bn->allocated = 0;\n  memcpy(&t->bn, bn, sizeof(*bn));\n  free(bn);\n  return 0;\n}\n\nIW_EXPORT iwrc jbl_object_copy_to(JBL src, JBL target) {\n  iwrc rc = 0;\n  // According to binn spec keys are not null terminated\n  // and key length is not more than 255 bytes\n  char *key, kbuf[256];\n  int klen;\n  JBL holder = 0;\n  JBL_iterator it;\n\n  if ((jbl_type(src) != JBV_OBJECT) || (jbl_type(target) != JBV_OBJECT)) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  RCC(rc, finish, jbl_create_iterator_holder(&holder));\n  RCC(rc, finish, jbl_iterator_init(src, &it));\n  while (jbl_iterator_next(&it, holder, &key, &klen)) {\n    memcpy(kbuf, key, klen);\n    kbuf[klen] = '\\0';\n    RCC(rc, finish, jbl_set_nested(target, kbuf, holder));\n  }\n\nfinish:\n  jbl_destroy(&holder);\n  return rc;\n}\n\niwrc jbl_clone_into_pool(JBL src, JBL *targetp, IWPOOL *pool) {\n  *targetp = 0;\n  if (src->bn.writable && src->bn.dirty) {\n    if (!binn_save_header(&src->bn)) {\n      return JBL_ERROR_INVALID;\n    }\n  }\n  JBL jbl = iwpool_alloc(sizeof(*jbl) + src->bn.size, pool);\n  if (!jbl) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  jbl->node = 0;\n  memcpy(&jbl->bn, &src->bn, sizeof(jbl->bn));\n  jbl->bn.ptr = (char*) jbl + sizeof(*jbl);\n  memcpy(jbl->bn.ptr, src->bn.ptr, src->bn.size);\n  jbl->bn.freefn = 0;\n  *targetp = jbl;\n  return 0;\n}\n\niwrc jbl_from_buf_keep_onstack(JBL jbl, void *buf, size_t bufsz) {\n  int type, size = 0, count = 0;\n  if ((bufsz < MIN_BINN_SIZE) || !binn_is_valid_header(buf, &type, &count, &size, NULL)) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  if (size > bufsz) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  memset(jbl, 0, sizeof(*jbl));\n  jbl->bn.header = BINN_MAGIC;\n  jbl->bn.type = type;\n  jbl->bn.ptr = buf;\n  jbl->bn.size = size;\n  jbl->bn.count = count;\n  return 0;\n}\n\niwrc jbl_from_buf_keep_onstack2(JBL jbl, void *buf) {\n  int type, size = 0, count = 0;\n  if (!binn_is_valid_header(buf, &type, &count, &size, NULL)) {\n    return JBL_ERROR_INVALID_BUFFER;\n  }\n  memset(jbl, 0, sizeof(*jbl));\n  jbl->bn.header = BINN_MAGIC;\n  jbl->bn.type = type;\n  jbl->bn.ptr = buf;\n  jbl->bn.size = size;\n  jbl->bn.count = count;\n  return 0;\n}\n\nvoid jbl_destroy(JBL *jblp) {\n  if (*jblp) {\n    JBL jbl = *jblp;\n    binn_free(&jbl->bn);\n    free(jbl);\n    *jblp = 0;\n  }\n}\n\niwrc jbl_create_iterator_holder(JBL *jblp) {\n  *jblp = calloc(1, sizeof(**jblp));\n  if (!*jblp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  return 0;\n}\n\niwrc jbl_iterator_init(JBL jbl, JBL_iterator *iter) {\n  int btype = jbl->bn.type;\n  if ((btype != BINN_OBJECT) && (btype != BINN_LIST) && (btype != BINN_MAP)) {\n    memset(iter, 0, sizeof(*iter));\n    return 0;\n  }\n  binn_iter *biter = (binn_iter*) iter;\n  if (!binn_iter_init(biter, &jbl->bn, btype)) {\n    return JBL_ERROR_CREATION;\n  }\n  return 0;\n}\n\nbool jbl_iterator_next(JBL_iterator *iter, JBL holder, char **pkey, int *klen) {\n  binn_iter *biter = (binn_iter*) iter;\n  if (pkey) {\n    *pkey = 0;\n  }\n  if (klen) {\n    *klen = 0;\n  }\n  if (!iter || (iter->type == 0)) {\n    return false;\n  }\n  if (iter->type == BINN_LIST) {\n    if (klen) {\n      *klen = iter->current;\n    }\n    return binn_list_next(biter, &holder->bn);\n  } else {\n    return binn_read_next_pair2(iter->type, biter, klen, pkey, &holder->bn);\n  }\n  return false;\n}\n\nIW_INLINE jbl_type_t _jbl_binn_type(int btype) {\n  switch (btype) {\n    case BINN_NULL:\n      return JBV_NULL;\n    case BINN_STRING:\n      return JBV_STR;\n    case BINN_OBJECT:\n    case BINN_MAP:\n      return JBV_OBJECT;\n    case BINN_LIST:\n      return JBV_ARRAY;\n    case BINN_BOOL:\n    case BINN_TRUE:\n    case BINN_FALSE:\n      return JBV_BOOL;\n    case BINN_UINT8:\n    case BINN_UINT16:\n    case BINN_UINT32:\n    case BINN_UINT64:\n    case BINN_INT8:\n    case BINN_INT16:\n    case BINN_INT32:\n    case BINN_INT64:\n      return JBV_I64;\n    case BINN_FLOAT32:\n    case BINN_FLOAT64:\n      return JBV_F64;\n    default:\n      return JBV_NONE;\n  }\n}\n\njbl_type_t jbl_type(JBL jbl) {\n  if (jbl) {\n    return _jbl_binn_type(jbl->bn.type);\n  }\n  return JBV_NONE;\n}\n\nsize_t jbl_count(JBL jbl) {\n  return (size_t) jbl->bn.count;\n}\n\nsize_t jbl_size(JBL jbl) {\n  return (size_t) jbl->bn.size;\n}\n\nsize_t jbl_structure_size(void) {\n  return sizeof(struct _JBL);\n}\n\niwrc jbl_from_json(JBL *jblp, const char *jsonstr) {\n  *jblp = 0;\n  iwrc rc = 0;\n  IWPOOL *pool = iwpool_create(2 * strlen(jsonstr));\n  if (!pool) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  JBL jbl;\n  JBL_NODE node;\n  rc = jbn_from_json(jsonstr, &node, pool);\n  RCGO(rc, finish);\n  if (node->type == JBV_OBJECT) {\n    rc = jbl_create_empty_object(&jbl);\n    RCGO(rc, finish);\n  } else if (node->type == JBV_ARRAY) {\n    rc = jbl_create_empty_array(&jbl);\n    RCGO(rc, finish);\n  } else {\n    // TODO: Review\n    rc = JBL_ERROR_CREATION;\n    goto finish;\n  }\n  rc = jbl_fill_from_node(jbl, node);\n  if (!rc) {\n    *jblp = jbl;\n  }\n\nfinish:\n  iwpool_destroy(pool);\n  return rc;\n}\n\niwrc _jbl_write_double(double num, jbl_json_printer pt, void *op) {\n  size_t sz;\n  char buf[IWNUMBUF_SIZE];\n  iwjson_ftoa(num, buf, &sz);\n  return pt(buf, -1, 0, 0, op);\n}\n\niwrc _jbl_write_int(int64_t num, jbl_json_printer pt, void *op) {\n  char buf[IWNUMBUF_SIZE];\n  int sz = iwitoa(num, buf, sizeof(buf));\n  return pt(buf, sz, 0, 0, op);\n}\n\niwrc _jbl_write_string(const char *str, int len, jbl_json_printer pt, void *op, jbl_print_flags_t pf) {\n  iwrc rc = pt(0, 0, '\"', 1, op);\n  RCRET(rc);\n  static const char *specials = \"btnvfr\";\n  const uint8_t *p = (const uint8_t*) str;\n\n#define PT(data_, size_, ch_, count_) do { \\\n    rc = pt((const char*) (data_), size_, ch_, count_, op); \\\n    RCRET(rc); \\\n} while (0)\n\n  if (len < 0) {\n    len = (int) strlen(str);\n  }\n  for (size_t i = 0; i < len; i++) {\n    uint8_t ch = p[i];\n    if ((ch == '\"') || (ch == '\\\\')) {\n      PT(0, 0, '\\\\', 1);\n      PT(0, 0, ch, 1);\n    } else if ((ch >= '\\b') && (ch <= '\\r')) {\n      PT(0, 0, '\\\\', 1);\n      PT(0, 0, specials[ch - '\\b'], 1);\n    } else if (isprint(ch)) {\n      PT(0, 0, ch, 1);\n    } else if (pf & JBL_PRINT_CODEPOINTS) {\n      char sbuf[7]; // escaped unicode seq\n      utf8proc_int32_t cp;\n      utf8proc_ssize_t sz = utf8proc_iterate(p + i, len - i, &cp);\n      if (sz < 0) {\n        return JBL_ERROR_PARSE_INVALID_UTF8;\n      }\n      if (cp > 0x0010000UL) {\n        uint32_t hs = 0xD800, ls = 0xDC00; // surrogates\n        cp -= 0x0010000UL;\n        hs |= ((cp >> 10) & 0x3FF);\n        ls |= (cp & 0x3FF);\n        snprintf(sbuf, 7, \"\\\\u%04X\", hs);\n        PT(sbuf, 6, 0, 0);\n        snprintf(sbuf, 7, \"\\\\u%04X\", ls);\n        PT(sbuf, 6, 0, 0);\n      } else {\n        snprintf(sbuf, 7, \"\\\\u%04X\", cp);\n        PT(sbuf, 6, 0, 0);\n      }\n      i += sz - 1;\n    } else {\n      PT(0, 0, ch, 1);\n    }\n  }\n  rc = pt(0, 0, '\"', 1, op);\n  return rc;\n#undef PT\n}\n\nstatic iwrc _jbl_as_json(binn *bn, jbl_json_printer pt, void *op, int lvl, jbl_print_flags_t pf) {\n  iwrc rc = 0;\n  binn bv;\n  binn_iter iter;\n  int lv;\n  int64_t llv;\n  double dv;\n  char key[MAX_BIN_KEY_LEN + 1];\n  bool pretty = pf & JBL_PRINT_PRETTY;\n\n#define PT(data_, size_, ch_, count_) do { \\\n    rc = pt(data_, size_, ch_, count_, op); \\\n    RCGO(rc, finish); \\\n} while (0)\n\n  switch (bn->type) {\n    case BINN_LIST:\n      if (!binn_iter_init(&iter, bn, bn->type)) {\n        rc = JBL_ERROR_INVALID;\n        goto finish;\n      }\n      PT(0, 0, '[', 1);\n      if (bn->count && pretty) {\n        PT(0, 0, '\\n', 1);\n      }\n      for (int i = 0; binn_list_next(&iter, &bv); ++i) {\n        if (pretty) {\n          PT(0, 0, ' ', lvl + 1);\n        }\n        rc = _jbl_as_json(&bv, pt, op, lvl + 1, pf);\n        RCGO(rc, finish);\n        if (i < bn->count - 1) {\n          PT(0, 0, ',', 1);\n        }\n        if (pretty) {\n          PT(0, 0, '\\n', 1);\n        }\n      }\n      if (bn->count && pretty) {\n        PT(0, 0, ' ', lvl);\n      }\n      PT(0, 0, ']', 1);\n      break;\n\n    case BINN_OBJECT:\n    case BINN_MAP:\n      if (!binn_iter_init(&iter, bn, bn->type)) {\n        rc = JBL_ERROR_INVALID;\n        goto finish;\n      }\n      PT(0, 0, '{', 1);\n      if (bn->count && pretty) {\n        PT(0, 0, '\\n', 1);\n      }\n      if (bn->type == BINN_OBJECT) {\n        for (int i = 0; binn_object_next(&iter, key, &bv); ++i) {\n          if (pretty) {\n            PT(0, 0, ' ', lvl + 1);\n          }\n          rc = _jbl_write_string(key, -1, pt, op, pf);\n          RCGO(rc, finish);\n          if (pretty) {\n            PT(\": \", -1, 0, 0);\n          } else {\n            PT(0, 0, ':', 1);\n          }\n          rc = _jbl_as_json(&bv, pt, op, lvl + 1, pf);\n          RCGO(rc, finish);\n          if (i < bn->count - 1) {\n            PT(0, 0, ',', 1);\n          }\n          if (pretty) {\n            PT(0, 0, '\\n', 1);\n          }\n        }\n      } else {\n        for (int i = 0; binn_map_next(&iter, &lv, &bv); ++i) {\n          if (pretty) {\n            PT(0, 0, ' ', lvl + 1);\n          }\n          PT(0, 0, '\"', 1);\n          rc = _jbl_write_int(lv, pt, op);\n          RCGO(rc, finish);\n          PT(0, 0, '\"', 1);\n          if (pretty) {\n            PT(\": \", -1, 0, 0);\n          } else {\n            PT(0, 0, ':', 1);\n          }\n          rc = _jbl_as_json(&bv, pt, op, lvl + 1, pf);\n          RCGO(rc, finish);\n          if (i < bn->count - 1) {\n            PT(0, 0, ',', 1);\n          }\n          if (pretty) {\n            PT(0, 0, '\\n', 1);\n          }\n        }\n      }\n      if (bn->count && pretty) {\n        PT(0, 0, ' ', lvl);\n      }\n      PT(0, 0, '}', 1);\n      break;\n\n    case BINN_STRING:\n      rc = _jbl_write_string(bn->ptr, -1, pt, op, pf);\n      break;\n    case BINN_UINT8:\n      llv = bn->vuint8;\n      goto loc_int;\n    case BINN_UINT16:\n      llv = bn->vuint16;\n      goto loc_int;\n    case BINN_UINT32:\n      llv = bn->vuint32;\n      goto loc_int;\n    case BINN_INT8:\n      llv = bn->vint8; // NOLINT(bugprone-signed-char-misuse)\n      goto loc_int;\n    case BINN_INT16:\n      llv = bn->vint16;\n      goto loc_int;\n    case BINN_INT32:\n      llv = bn->vint32;\n      goto loc_int;\n    case BINN_INT64:\n      llv = bn->vint64;\n      goto loc_int;\n    case BINN_UINT64: // overflow?\n      llv = (int64_t) bn->vuint64;\nloc_int:\n      rc = _jbl_write_int(llv, pt, op);\n      break;\n\n    case BINN_FLOAT32:\n      dv = bn->vfloat;\n      goto loc_float;\n    case BINN_FLOAT64:\n      dv = bn->vdouble;\nloc_float:\n      rc = _jbl_write_double(dv, pt, op);\n      break;\n\n    case BINN_TRUE:\n      PT(\"true\", 4, 0, 0);\n      break;\n    case BINN_FALSE:\n      PT(\"false\", 5, 0, 0);\n      break;\n    case BINN_BOOL:\n      PT(bn->vbool ? \"true\" : \"false\", -1, 0, 1);\n      break;\n    case BINN_NULL:\n      PT(\"null\", 4, 0, 0);\n      break;\n    default:\n      iwlog_ecode_error3(IW_ERROR_ASSERTION);\n      rc = IW_ERROR_ASSERTION;\n      break;\n  }\n\nfinish:\n  return rc;\n#undef PT\n}\n\niwrc jbl_as_json(JBL jbl, jbl_json_printer pt, void *op, jbl_print_flags_t pf) {\n  if (!jbl || !pt) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  return _jbl_as_json(&jbl->bn, pt, op, 0, pf);\n}\n\niwrc jbl_fstream_json_printer(const char *data, int size, char ch, int count, void *op) {\n  FILE *file = op;\n  if (!file) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  if (!data) {\n    if (count) {\n      char cbuf[count]; // TODO: review overflow\n      memset(cbuf, ch, sizeof(cbuf));\n      size_t wc = fwrite(cbuf, 1, count, file);\n      if (wc != sizeof(cbuf)) {\n        return iwrc_set_errno(IW_ERROR_IO_ERRNO, errno);\n      }\n    }\n  } else {\n    if (size < 0) {\n      size = (int) strlen(data);\n    }\n    if (!count) {\n      count = 1;\n    }\n    for (int i = 0; i < count; ++i) {\n      if (fprintf(file, \"%.*s\", size, data) < 0) {\n        return iwrc_set_errno(IW_ERROR_IO_ERRNO, errno);\n      }\n    }\n  }\n  return 0;\n}\n\niwrc jbl_xstr_json_printer(const char *data, int size, char ch, int count, void *op) {\n  IWXSTR *xstr = op;\n  if (!xstr) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  if (!data) {\n    if (count) {\n      for (int i = 0; i < count; ++i) {\n        iwrc rc = iwxstr_cat(xstr, &ch, 1);\n        RCRET(rc);\n      }\n    }\n  } else {\n    if (size < 0) {\n      size = (int) strlen(data);\n    }\n    if (!count) {\n      count = 1;\n    }\n    for (int i = 0; i < count; ++i) {\n      iwrc rc = iwxstr_cat(xstr, data, size);\n      RCRET(rc);\n    }\n  }\n  return 0;\n}\n\niwrc jbl_count_json_printer(const char *data, int size, char ch, int count, void *op) {\n  int *cnt = op;\n  if (!data) {\n    *cnt = *cnt + count;\n  } else {\n    if (size < 0) {\n      size = (int) strlen(data);\n    }\n    if (!count) {\n      count = 1;\n    }\n    *cnt = *cnt + count * size;\n  }\n  return 0;\n}\n\nint64_t jbl_get_i64(JBL jbl) {\n  assert(jbl);\n  switch (jbl->bn.type) {\n    case BINN_UINT8:\n      return jbl->bn.vuint8;\n    case BINN_UINT16:\n      return jbl->bn.vuint16;\n    case BINN_UINT32:\n      return jbl->bn.vuint32;\n    case BINN_UINT64:\n      return jbl->bn.vuint64;\n    case BINN_INT8:\n      return jbl->bn.vint8;\n    case BINN_INT16:\n      return jbl->bn.vint16;\n    case BINN_INT32:\n      return jbl->bn.vint32;\n    case BINN_INT64:\n      return jbl->bn.vint64;\n    case BINN_BOOL:\n      return jbl->bn.vbool;\n    case BINN_FLOAT32:\n      return (int64_t) jbl->bn.vfloat;\n    case BINN_FLOAT64:\n      return (int64_t) jbl->bn.vdouble;\n    default:\n      return 0;\n  }\n}\n\nint32_t jbl_get_i32(JBL jbl) {\n  return (int32_t) jbl_get_i64(jbl);\n}\n\ndouble jbl_get_f64(JBL jbl) {\n  assert(jbl);\n  switch (jbl->bn.type) {\n    case BINN_FLOAT64:\n      return jbl->bn.vdouble;\n    case BINN_FLOAT32:\n      return jbl->bn.vfloat;\n    case BINN_UINT8:\n      return jbl->bn.vuint8;\n    case BINN_UINT16:\n      return jbl->bn.vuint16;\n    case BINN_UINT32:\n      return jbl->bn.vuint32;\n    case BINN_UINT64:\n      return jbl->bn.vuint64;\n    case BINN_INT8:\n      return jbl->bn.vint8;\n    case BINN_INT16:\n      return jbl->bn.vint16;\n    case BINN_INT32:\n      return jbl->bn.vint32;\n    case BINN_INT64:\n      return jbl->bn.vint64;\n    case BINN_BOOL:\n      return jbl->bn.vbool;\n    default:\n      return 0.0;\n  }\n}\n\nconst char* jbl_get_str(JBL jbl) {\n  assert(jbl && jbl->bn.type == BINN_STRING);\n  if (jbl->bn.type != BINN_STRING) {\n    return 0;\n  } else {\n    return jbl->bn.ptr;\n  }\n}\n\nsize_t jbl_copy_strn(JBL jbl, char *buf, size_t bufsz) {\n  assert(jbl && buf && jbl->bn.type == BINN_STRING);\n  if (jbl->bn.type != BINN_STRING) {\n    return 0;\n  }\n  size_t slen = strlen(jbl->bn.ptr);\n  size_t ret = MIN(slen, bufsz);\n  memcpy(buf, jbl->bn.ptr, ret);\n  return ret;\n}\n\njbl_type_t jbl_object_get_type(JBL jbl, const char *key) {\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBV_NONE;\n  }\n  binn bv;\n  if (!binn_object_get_value(&jbl->bn, key, &bv)) {\n    return JBV_NONE;\n  }\n  return _jbl_binn_type(bv.type);\n}\n\niwrc jbl_object_get_i64(JBL jbl, const char *key, int64_t *out) {\n  *out = 0;\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  int64 v;\n  if (!binn_object_get_int64(&jbl->bn, key, &v)) {\n    return JBL_ERROR_CREATION;\n  }\n  *out = v;\n  return 0;\n}\n\niwrc jbl_object_get_f64(JBL jbl, const char *key, double *out) {\n  *out = 0.0;\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  if (!binn_object_get_double(&jbl->bn, key, out)) {\n    return JBL_ERROR_CREATION;\n  }\n  return 0;\n}\n\niwrc jbl_object_get_bool(JBL jbl, const char *key, bool *out) {\n  *out = false;\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  BOOL v;\n  if (!binn_object_get_bool(&jbl->bn, key, &v)) {\n    return JBL_ERROR_CREATION;\n  }\n  *out = v;\n  return 0;\n}\n\niwrc jbl_object_get_str(JBL jbl, const char *key, const char **out) {\n  *out = 0;\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  if (!binn_object_get_str(&jbl->bn, key, (char**) out)) {\n    return JBL_ERROR_CREATION;\n  }\n  return 0;\n}\n\niwrc jbl_object_get_fill_jbl(JBL jbl, const char *key, JBL out) {\n  if (jbl->bn.type != BINN_OBJECT) {\n    return JBL_ERROR_NOT_AN_OBJECT;\n  }\n  binn_free(&out->bn);\n  if (!binn_object_get_value(&jbl->bn, key, &out->bn)) {\n    return JBL_ERROR_CREATION;\n  }\n  return 0;\n}\n\niwrc jbl_as_buf(JBL jbl, void **buf, size_t *size) {\n  assert(jbl && buf && size);\n  if (jbl->bn.writable && jbl->bn.dirty) {\n    if (!binn_save_header(&jbl->bn)) {\n      return JBL_ERROR_INVALID;\n    }\n  }\n  *buf = jbl->bn.ptr;\n  *size = (size_t) jbl->bn.size;\n  return 0;\n}\n\n//----------------------------------------------------------------------------------------------------------\n\nstatic iwrc _jbl_ptr_pool(const char *path, JBL_PTR *jpp, IWPOOL *pool) {\n  iwrc rc = 0;\n  int cnt = 0, len, sz, doff;\n  int i, j, k;\n  JBL_PTR jp;\n  char *jpr; // raw pointer to jp\n  *jpp = 0;\n  if (!path || (path[0] != '/')) {\n    return JBL_ERROR_JSON_POINTER;\n  }\n  for (i = 0; path[i]; ++i) {\n    if (path[i] == '/') {\n      ++cnt;\n    }\n  }\n  len = i;\n  if ((len > 1) && (path[len - 1] == '/')) {\n    return JBL_ERROR_JSON_POINTER;\n  }\n  sz = (int) (sizeof(struct _JBL_PTR) + cnt * sizeof(char*) + len);\n  if (pool) {\n    jp = iwpool_alloc(sz, pool);\n  } else {\n    jp = malloc(sz);\n  }\n  if (!jp) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  jpr = (char*) jp;\n  jp->cnt = cnt;\n  jp->sz = sz;\n\n  doff = offsetof(struct _JBL_PTR, n) + cnt * sizeof(char*);\n  assert(sz - doff >= len);\n\n  for (i = 0, j = 0, cnt = 0; path[i] && cnt < jp->cnt; ++i, ++j) {\n    if (path[i++] == '/') {\n      jp->n[cnt] = jpr + doff + j;\n      for (k = 0; ; ++i, ++k) {\n        if (!path[i] || (path[i] == '/')) {\n          --i;\n          *(jp->n[cnt] + k) = '\\0';\n          break;\n        }\n        if (path[i] == '~') {\n          if (path[i + 1] == '0') {\n            *(jp->n[cnt] + k) = '~';\n          } else if (path[i + 1] == '1') {\n            *(jp->n[cnt] + k) = '/';\n          }\n          ++i;\n        } else {\n          *(jp->n[cnt] + k) = path[i];\n        }\n      }\n      j += k;\n      ++cnt;\n    }\n  }\n  *jpp = jp;\n  return rc;\n}\n\niwrc jbl_ptr_alloc(const char *path, JBL_PTR *jpp) {\n  return _jbl_ptr_pool(path, jpp, 0);\n}\n\niwrc jbl_ptr_alloc_pool(const char *path, JBL_PTR *jpp, IWPOOL *pool) {\n  return _jbl_ptr_pool(path, jpp, pool);\n}\n\nint jbl_ptr_cmp(JBL_PTR p1, JBL_PTR p2) {\n  if (p1->sz != p2->sz) {\n    return p1->sz - p2->sz;\n  }\n  if (p1->cnt != p2->cnt) {\n    return p1->cnt - p2->cnt;\n  }\n  for (int i = 0; i < p1->cnt; ++i) {\n    int r = strcmp(p1->n[i], p2->n[i]);\n    if (r) {\n      return r;\n    }\n  }\n  return 0;\n}\n\niwrc jbl_ptr_serialize(JBL_PTR ptr, IWXSTR *xstr) {\n  for (int i = 0; i < ptr->cnt; ++i) {\n    iwrc rc = iwxstr_cat(xstr, \"/\", 1);\n    RCRET(rc);\n    rc = iwxstr_cat(xstr, ptr->n[i], strlen(ptr->n[i]));\n    RCRET(rc);\n  }\n  return 0;\n}\n\niwrc _jbl_visit(binn_iter *iter, int lvl, JBL_VCTX *vctx, JBL_VISITOR visitor) {\n  iwrc rc = 0;\n  binn *bn = vctx->bn;\n  jbl_visitor_cmd_t cmd;\n  int idx;\n  binn bv;\n\n  if (lvl > JBL_MAX_NESTING_LEVEL) {\n    return JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED;\n  }\n  if (!iter) {\n    binn_iter it;\n    if (!BINN_IS_CONTAINER_TYPE(bn->type)) {\n      return JBL_ERROR_INVALID;\n    }\n    if (!binn_iter_init(&it, bn, bn->type)) {\n      return JBL_ERROR_INVALID;\n    }\n    rc = _jbl_visit(&it, 0, vctx, visitor);\n    return rc;\n  }\n\n  switch (iter->type) {\n    case BINN_OBJECT: {\n      char key[MAX_BIN_KEY_LEN + 1];\n      while (!vctx->terminate && binn_object_next(iter, key, &bv)) {\n        cmd = visitor(lvl, &bv, key, -1, vctx, &rc);\n        RCRET(rc);\n        if (cmd & JBL_VCMD_TERMINATE) {\n          vctx->terminate = true;\n          break;\n        }\n        if (!(cmd & JBL_VCMD_SKIP_NESTED) && BINN_IS_CONTAINER_TYPE(bv.type)) {\n          binn_iter it;\n          if (!binn_iter_init(&it, &bv, bv.type)) {\n            return JBL_ERROR_INVALID;\n          }\n          rc = _jbl_visit(&it, lvl + 1, vctx, visitor);\n          RCRET(rc);\n        }\n      }\n      break;\n    }\n    case BINN_MAP: {\n      while (!vctx->terminate && binn_map_next(iter, &idx, &bv)) {\n        cmd = visitor(lvl, &bv, 0, idx, vctx, &rc);\n        RCRET(rc);\n        if (cmd & JBL_VCMD_TERMINATE) {\n          vctx->terminate = true;\n          break;\n        }\n        if (!(cmd & JBL_VCMD_SKIP_NESTED) && BINN_IS_CONTAINER_TYPE(bv.type)) {\n          binn_iter it;\n          if (!binn_iter_init(&it, &bv, bv.type)) {\n            return JBL_ERROR_INVALID;\n          }\n          rc = _jbl_visit(&it, lvl + 1, vctx, visitor);\n          RCRET(rc);\n        }\n      }\n      break;\n    }\n    case BINN_LIST: {\n      for (idx = 0; !vctx->terminate && binn_list_next(iter, &bv); ++idx) {\n        cmd = visitor(lvl, &bv, 0, idx, vctx, &rc);\n        RCRET(rc);\n        if (cmd & JBL_VCMD_TERMINATE) {\n          vctx->terminate = true;\n          break;\n        }\n        if (!(cmd & JBL_VCMD_SKIP_NESTED) && BINN_IS_CONTAINER_TYPE(bv.type)) {\n          binn_iter it;\n          if (!binn_iter_init(&it, &bv, bv.type)) {\n            return JBL_ERROR_INVALID;\n          }\n          rc = _jbl_visit(&it, lvl + 1, vctx, visitor);\n          RCRET(rc);\n        }\n      }\n      break;\n    }\n  }\n  return rc;\n}\n\niwrc jbn_visit(JBL_NODE node, int lvl, JBN_VCTX *vctx, JBN_VISITOR visitor) {\n  iwrc rc = 0;\n  if (lvl > JBL_MAX_NESTING_LEVEL) {\n    return JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED;\n  }\n  if (!node) {\n    node = vctx->root;\n    lvl = 0;\n    if (!node) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n  }\n  JBL_NODE n = node;\n  switch (node->type) {\n    case JBV_OBJECT:\n    case JBV_ARRAY: {\n      for (n = n->child; !vctx->terminate && n; n = n->next) {\n        jbn_visitor_cmd_t cmd = visitor(lvl, n, n->key, n->klidx, vctx, &rc);\n        RCRET(rc);\n        if (cmd & JBL_VCMD_TERMINATE) {\n          vctx->terminate = true;\n        }\n        if (cmd & JBN_VCMD_DELETE) {\n          JBL_NODE nn = n->next; // Keep pointer to next\n          _jbn_remove_item(node, n);\n          n->next = nn;\n        } else if (!(cmd & JBL_VCMD_SKIP_NESTED) && (n->type >= JBV_OBJECT)) {\n          rc = jbn_visit(n, lvl + 1, vctx, visitor);\n          RCRET(rc);\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  RCRET(rc);\n  if (lvl == 0) {\n    visitor(-1, node, 0, 0, vctx, &rc);\n  }\n  return rc;\n}\n\nIW_INLINE bool _jbl_visitor_update_jptr_cursor(JBL_VCTX *vctx, int lvl, const char *key, int idx) {\n  JBL_PTR jp = vctx->op;\n  if (lvl < jp->cnt) {\n    if (vctx->pos >= lvl) {\n      vctx->pos = lvl - 1;\n    }\n    if (vctx->pos + 1 == lvl) {\n      const char *keyptr;\n      char buf[IWNUMBUF_SIZE];\n      if (key) {\n        keyptr = key;\n      } else {\n        iwitoa(idx, buf, IWNUMBUF_SIZE);\n        keyptr = buf;\n      }\n      if (!strcmp(keyptr, jp->n[lvl]) || ((jp->n[lvl][0] == '*') && (jp->n[lvl][1] == '\\0'))) {\n        vctx->pos = lvl;\n        return (jp->cnt == lvl + 1);\n      }\n    }\n  }\n  return false;\n}\n\nIW_INLINE bool _jbn_visitor_update_jptr_cursor(JBN_VCTX *vctx, int lvl, const char *key, int idx) {\n  JBL_PTR jp = vctx->op;\n  if (lvl < jp->cnt) {\n    if (vctx->pos >= lvl) {\n      vctx->pos = lvl - 1;\n    }\n    if (vctx->pos + 1 == lvl) {\n      const char *keyptr;\n      char buf[IWNUMBUF_SIZE];\n      if (key) {\n        keyptr = key;\n      } else {\n        iwitoa(idx, buf, IWNUMBUF_SIZE);\n        keyptr = buf;\n        idx = (int) strlen(keyptr);\n      }\n      int jplen = (int) strlen(jp->n[lvl]);\n      if ((  (idx == jplen)\n          && !strncmp(keyptr, jp->n[lvl], idx)) || ((jp->n[lvl][0] == '*') && (jp->n[lvl][1] == '\\0'))) {\n        vctx->pos = lvl;\n        return (jp->cnt == lvl + 1);\n      }\n    }\n  }\n  return false;\n}\n\nstatic jbl_visitor_cmd_t _jbl_get_visitor2(int lvl, binn *bv, const char *key, int idx, JBL_VCTX *vctx, iwrc *rc) {\n  JBL_PTR jp = vctx->op;\n  assert(jp);\n  if (_jbl_visitor_update_jptr_cursor(vctx, lvl, key, idx)) { // Pointer matched\n    JBL jbl = vctx->result;\n    memcpy(&jbl->bn, bv, sizeof(*bv));\n    vctx->found = true;\n    return JBL_VCMD_TERMINATE;\n  } else if (jp->cnt < lvl + 1) {\n    return JBL_VCMD_SKIP_NESTED;\n  }\n  return JBL_VCMD_OK;\n}\n\nstatic jbl_visitor_cmd_t _jbl_get_visitor(int lvl, binn *bv, const char *key, int idx, JBL_VCTX *vctx, iwrc *rc) {\n  JBL_PTR jp = vctx->op;\n  assert(jp);\n  if (_jbl_visitor_update_jptr_cursor(vctx, lvl, key, idx)) { // Pointer matched\n    JBL jbl = malloc(sizeof(struct _JBL));\n    if (!jbl) {\n      *rc = iwrc_set_errno(IW_ERROR_ALLOC, errno);\n      return JBL_VCMD_TERMINATE;\n    }\n    memcpy(&jbl->bn, bv, sizeof(*bv));\n    vctx->result = jbl;\n    return JBL_VCMD_TERMINATE;\n  } else if (jp->cnt < lvl + 1) {\n    return JBL_VCMD_SKIP_NESTED;\n  }\n  return JBL_VCMD_OK;\n}\n\nbool _jbl_at(JBL jbl, JBL_PTR jp, JBL res) {\n  JBL_VCTX vctx = {\n    .bn     = &jbl->bn,\n    .op     = jp,\n    .pos    = -1,\n    .result = res\n  };\n  _jbl_visit(0, 0, &vctx, _jbl_get_visitor2);\n  return vctx.found;\n}\n\niwrc jbl_at2(JBL jbl, JBL_PTR jp, JBL *res) {\n  JBL_VCTX vctx = {\n    .bn  = &jbl->bn,\n    .op  = jp,\n    .pos = -1\n  };\n  iwrc rc = _jbl_visit(0, 0, &vctx, _jbl_get_visitor);\n  if (rc) {\n    *res = 0;\n  } else {\n    if (!vctx.result) {\n      rc = JBL_ERROR_PATH_NOTFOUND;\n      *res = 0;\n    } else {\n      *res = (JBL) vctx.result;\n    }\n  }\n  return rc;\n}\n\niwrc jbl_at(JBL jbl, const char *path, JBL *res) {\n  JBL_PTR jp;\n  iwrc rc = _jbl_ptr_pool(path, &jp, 0);\n  if (rc) {\n    *res = 0;\n    return rc;\n  }\n  rc = jbl_at2(jbl, jp, res);\n  free(jp);\n  return rc;\n}\n\nstatic jbn_visitor_cmd_t _jbn_get_visitor(int lvl, JBL_NODE n, const char *key, int klidx, JBN_VCTX *vctx, iwrc *rc) {\n  if (lvl < 0) { // EOF\n    return JBL_VCMD_OK;\n  }\n  JBL_PTR jp = vctx->op;\n  assert(jp);\n  if (_jbn_visitor_update_jptr_cursor(vctx, lvl, key, klidx)) { // Pointer matched\n    vctx->result = n;\n    return JBL_VCMD_TERMINATE;\n  } else if (jp->cnt < lvl + 1) {\n    return JBL_VCMD_SKIP_NESTED;\n  }\n  return JBL_VCMD_OK;\n}\n\niwrc jbn_at2(JBL_NODE node, JBL_PTR jp, JBL_NODE *res) {\n  JBN_VCTX vctx = {\n    .root = node,\n    .op   = jp,\n    .pos  = -1\n  };\n  iwrc rc = jbn_visit(node, 0, &vctx, _jbn_get_visitor);\n  if (rc) {\n    *res = 0;\n  } else {\n    if (!vctx.result) {\n      rc = JBL_ERROR_PATH_NOTFOUND;\n      *res = 0;\n    } else {\n      *res = (JBL_NODE) vctx.result;\n    }\n  }\n  return rc;\n}\n\niwrc jbn_at(JBL_NODE node, const char *path, JBL_NODE *res) {\n  JBL_PTR jp;\n  iwrc rc = _jbl_ptr_pool(path, &jp, 0);\n  if (rc) {\n    *res = 0;\n    return rc;\n  }\n  rc = jbn_at2(node, jp, res);\n  free(jp);\n  return rc;\n}\n\nint jbn_paths_compare(JBL_NODE n1, const char *n1path, JBL_NODE n2, const char *n2path, jbl_type_t vtype, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v1 = 0, v2 = 0;\n  iwrc rc = jbn_at(n1, n1path, &v1);\n  if (rc && (rc != JBL_ERROR_PATH_NOTFOUND)) {\n    *rcp = rc;\n    return -2;\n  }\n  rc = jbn_at(n2, n2path, &v2);\n  if (rc && (rc != JBL_ERROR_PATH_NOTFOUND)) {\n    *rcp = rc;\n    return -2;\n  }\n  if (vtype) {\n    if (((v1 == 0) || (v1->type != vtype)) || ((v2 == 0) || (v2->type != vtype))) {\n      *rcp = JBL_ERROR_TYPE_MISMATCHED;\n      return -2;\n    }\n  }\n  return _jbl_compare_nodes(v1, v2, rcp);\n}\n\nint jbn_path_compare(JBL_NODE n1, JBL_NODE n2, const char *path, jbl_type_t vtype, iwrc *rcp) {\n  return jbn_paths_compare(n1, path, n2, path, vtype, rcp);\n}\n\nint jbn_path_compare_str(JBL_NODE n, const char *path, const char *sv, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v;\n  iwrc rc = jbn_at(n, path, &v);\n  if (rc) {\n    *rcp = rc;\n    return -2;\n  }\n  struct _JBL_NODE cn = {\n    .type  = JBV_STR,\n    .vptr  = sv,\n    .vsize = (int) strlen(sv)\n  };\n  return _jbl_compare_nodes(v, &cn, rcp);\n}\n\nint jbn_path_compare_i64(JBL_NODE n, const char *path, int64_t iv, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v;\n  iwrc rc = jbn_at(n, path, &v);\n  if (rc) {\n    *rcp = rc;\n    return -2;\n  }\n  struct _JBL_NODE cn = {\n    .type = JBV_I64,\n    .vi64 = iv\n  };\n  return _jbl_compare_nodes(v, &cn, rcp);\n}\n\nint jbn_path_compare_f64(JBL_NODE n, const char *path, double fv, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v;\n  iwrc rc = jbn_at(n, path, &v);\n  if (rc) {\n    *rcp = rc;\n    return -2;\n  }\n  struct _JBL_NODE cn = {\n    .type = JBV_F64,\n    .vf64 = fv\n  };\n  return _jbl_compare_nodes(v, &cn, rcp);\n}\n\nint jbn_path_compare_bool(JBL_NODE n, const char *path, bool bv, iwrc *rcp) {\n  *rcp = 0;\n  JBL_NODE v;\n  iwrc rc = jbn_at(n, path, &v);\n  if (rc) {\n    *rcp = rc;\n    return -2;\n  }\n  struct _JBL_NODE cn = {\n    .type  = JBV_BOOL,\n    .vbool = bv\n  };\n  return _jbl_compare_nodes(v, &cn, rcp);\n}\n\nIW_INLINE void _jbl_node_reset_data(JBL_NODE target) {\n  jbl_type_t t = target->type;\n  memset(((uint8_t*) target) + offsetof(struct _JBL_NODE, child),\n         0,\n         sizeof(struct _JBL_NODE) - offsetof(struct _JBL_NODE, child));\n  target->type = t;\n}\n\nIW_INLINE void _jbl_copy_node_data(JBL_NODE target, JBL_NODE value) {\n  memcpy(((uint8_t*) target) + offsetof(struct _JBL_NODE, child),\n         ((uint8_t*) value) + offsetof(struct _JBL_NODE, child),\n         sizeof(struct _JBL_NODE) - offsetof(struct _JBL_NODE, child));\n}\n\niwrc _jbl_increment_node_data(JBL_NODE target, JBL_NODE value) {\n  if ((value->type != JBV_I64) && (value->type != JBV_F64)) {\n    return JBL_ERROR_PATCH_INVALID_VALUE;\n  }\n  if (target->type == JBV_I64) {\n    if (value->type == JBV_I64) {\n      target->vi64 += value->vi64;\n    } else {\n      target->vi64 += (int64_t) value->vf64;\n    }\n    return 0;\n  } else if (target->type == JBV_F64) {\n    if (value->type == JBV_F64) {\n      target->vf64 += value->vf64;\n    } else {\n      target->vf64 += (double) value->vi64;\n    }\n    return 0;\n  } else {\n    return JBL_ERROR_PATCH_TARGET_INVALID;\n  }\n}\n\nvoid jbn_data(JBL_NODE node) {\n  _jbl_node_reset_data(node);\n}\n\nint jbn_length(JBL_NODE node) {\n  int ret = 0;\n  for (JBL_NODE n = node->child; n; n = n->next) {\n    ++ret;\n  }\n  return ret;\n}\n\nstatic void _jbn_add_item(JBL_NODE parent, JBL_NODE node) {\n  assert(parent && node);\n  node->next = 0;\n  node->prev = 0;\n  node->parent = parent;\n  if (parent->child) {\n    JBL_NODE prev = parent->child->prev;\n    parent->child->prev = node;\n    if (prev) { // -V1051\n      prev->next = node;\n      node->prev = prev;\n    } else {\n      parent->child->next = node;\n      node->prev = parent->child;\n    }\n  } else {\n    parent->child = node;\n  }\n  if (parent->type == JBV_ARRAY) {\n    node->key = 0;\n    if (node->prev) {\n      node->klidx = node->prev->klidx + 1;\n    } else {\n      node->klidx = 0;\n    }\n  }\n}\n\nvoid jbn_add_item(JBL_NODE parent, JBL_NODE node) {\n  _jbn_add_item(parent, node);\n}\n\niwrc jbn_add_item_str(JBL_NODE parent, const char *key, const char *val, int vlen, JBL_NODE *node_out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_STR;\n  if (val) {\n    if (vlen < 0) {\n      vlen = (int) strlen(val);\n    }\n    n->vptr = iwpool_strndup(pool, val, vlen, &rc);\n    RCGO(rc, finish);\n    n->vsize = vlen;\n  }\n  jbn_add_item(parent, n);\n  if (node_out) {\n    *node_out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_null(JBL_NODE parent, const char *key, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_NULL;\n  jbn_add_item(parent, n);\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_i64(JBL_NODE parent, const char *key, int64_t val, JBL_NODE *node_out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_I64;\n  n->vi64 = val;\n  jbn_add_item(parent, n);\n  if (node_out) {\n    *node_out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_f64(JBL_NODE parent, const char *key, double val, JBL_NODE *node_out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_F64;\n  n->vf64 = val;\n  jbn_add_item(parent, n);\n  if (node_out) {\n    *node_out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_bool(JBL_NODE parent, const char *key, bool val, JBL_NODE *node_out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_BOOL;\n  n->vbool = val;\n  jbn_add_item(parent, n);\n  if (node_out) {\n    *node_out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_obj(JBL_NODE parent, const char *key, JBL_NODE *out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_OBJECT;\n  jbn_add_item(parent, n);\n  if (out) {\n    *out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_add_item_arr(JBL_NODE parent, const char *key, JBL_NODE *out, IWPOOL *pool) {\n  if (!parent || !pool || (parent->type < JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_calloc(sizeof(*n), pool);\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  if (parent->type == JBV_OBJECT) {\n    if (!key) {\n      return IW_ERROR_INVALID_ARGS;\n    }\n    n->key = iwpool_strdup(pool, key, &rc);\n    RCGO(rc, finish);\n    n->klidx = (int) strlen(n->key);\n  }\n  n->type = JBV_ARRAY;\n  jbn_add_item(parent, n);\n  if (out) {\n    *out = n;\n  }\nfinish:\n  return rc;\n}\n\niwrc jbn_copy_path(\n  JBL_NODE    src,\n  const char *src_path,\n  JBL_NODE    target,\n  const char *target_path,\n  bool        overwrite_on_nulls,\n  bool        no_src_clone,\n  IWPOOL     *pool\n  ) {\n  if (!src || !src_path || !target || !target_path || !pool) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  JBL_NODE n1, n2;\n  jbp_patch_t op = JBP_REPLACE;\n\n  if (strcmp(\"/\", src_path) != 0) { // -V526\n    rc = jbn_at(src, src_path, &n1);\n    if (rc == JBL_ERROR_PATH_NOTFOUND) {\n      return 0;\n    }\n    RCRET(rc);\n  } else {\n    n1 = src;\n  }\n  if (!overwrite_on_nulls && (n1->type <= JBV_NULL)) {\n    return 0;\n  }\n  if (no_src_clone) {\n    n2 = n1;\n  } else {\n    rc = jbn_clone(n1, &n2, pool);\n    RCRET(rc);\n  }\n\n  rc = jbn_at(target, target_path, &n1);\n  if (rc == JBL_ERROR_PATH_NOTFOUND) {\n    rc = 0;\n    op = JBP_ADD_CREATE;\n  }\n  JBL_PATCH p[] = {\n    {\n      .op = op,\n      .path = target_path,\n      .vnode = n2\n    }\n  };\n  return jbn_patch(target, p, sizeof(p) / sizeof(p[0]), pool);\n}\n\nIW_EXPORT iwrc jbn_copy_paths(\n  JBL_NODE     src,\n  JBL_NODE     target,\n  const char **paths,\n  bool         overwrite_on_nulls,\n  bool         no_src_clone,\n  IWPOOL      *pool\n  ) {\n  if (!target || !src || !paths || !pool) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  for (const char **p = paths; *p; ++p) {\n    const char *path = *p;\n    rc = jbn_copy_path(src, path, target, path, overwrite_on_nulls, no_src_clone, pool);\n    RCBREAK(rc);\n  }\n  return rc;\n}\n\nIW_INLINE void _jbn_remove_item(JBL_NODE parent, JBL_NODE child) {\n  assert(parent->child);\n  if (parent->child == child) {                 // First element\n    if (child->next) {\n      parent->child = child->next;\n      parent->child->prev = child->prev;\n      if (child->prev) {\n        child->prev->next = 0;\n      }\n    } else {\n      parent->child = 0;\n    }\n  } else if (parent->child->prev == child) {    // Last element\n    parent->child->prev = child->prev;\n    if (child->prev) {\n      child->prev->next = 0;\n    }\n  } else { // Somewhere in middle\n    if (child->next) {\n      child->next->prev = child->prev;\n    }\n    if (child->prev) {\n      child->prev->next = child->next;\n    }\n  }\n  child->next = 0;\n  child->prev = 0;\n  child->child = 0;\n  child->parent = 0;\n}\n\nvoid jbn_remove_item(JBL_NODE parent, JBL_NODE child) {\n  _jbn_remove_item(parent, child);\n}\n\nstatic iwrc _jbl_create_node(\n  JBLDRCTX   *ctx,\n  const binn *bv,\n  JBL_NODE    parent,\n  const char *key,\n  int         klidx,\n  JBL_NODE   *node,\n  bool        clone_strings\n  ) {\n  iwrc rc = 0;\n  JBL_NODE n = iwpool_alloc(sizeof(*n), ctx->pool);\n  if (node) {\n    *node = 0;\n  }\n  if (!n) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  memset(n, 0, sizeof(*n));\n  if (key && clone_strings) {\n    n->key = iwpool_strndup(ctx->pool, key, klidx, &rc);\n    RCGO(rc, finish);\n  } else {\n    n->key = key;\n  }\n  n->klidx = klidx;\n  n->parent = parent;\n  switch (bv->type) {\n    case BINN_NULL:\n      n->type = JBV_NULL;\n      break;\n    case BINN_STRING:\n      n->type = JBV_STR;\n      if (!clone_strings) {\n        n->vptr = bv->ptr;\n        n->vsize = bv->size;\n      } else {\n        n->vptr = iwpool_strndup(ctx->pool, bv->ptr, bv->size, &rc);\n        n->vsize = bv->size;\n        RCGO(rc, finish);\n      }\n      break;\n    case BINN_OBJECT:\n    case BINN_MAP:\n      n->type = JBV_OBJECT;\n      break;\n    case BINN_LIST:\n      n->type = JBV_ARRAY;\n      break;\n    case BINN_TRUE:\n      n->type = JBV_BOOL;\n      n->vbool = true;\n      break;\n    case BINN_FALSE:\n      n->type = JBV_BOOL;\n      n->vbool = false;\n      break;\n    case BINN_BOOL:\n      n->type = JBV_BOOL;\n      n->vbool = bv->vbool;\n      break;\n    case BINN_UINT8:\n      n->vi64 = bv->vuint8;\n      n->type = JBV_I64;\n      break;\n    case BINN_UINT16:\n      n->vi64 = bv->vuint16;\n      n->type = JBV_I64;\n      break;\n    case BINN_UINT32:\n      n->vi64 = bv->vuint32;\n      n->type = JBV_I64;\n      break;\n    case BINN_UINT64:\n      n->vi64 = bv->vuint64;\n      n->type = JBV_I64;\n      break;\n    case BINN_INT8:\n      n->vi64 = bv->vint8; // NOLINT(bugprone-signed-char-misuse)\n      n->type = JBV_I64;\n      break;\n    case BINN_INT16:\n      n->vi64 = bv->vint16;\n      n->type = JBV_I64;\n      break;\n    case BINN_INT32:\n      n->vi64 = bv->vint32;\n      n->type = JBV_I64;\n      break;\n    case BINN_INT64:\n      n->vi64 = bv->vint64;\n      n->type = JBV_I64;\n      break;\n    case BINN_FLOAT32:\n    case BINN_FLOAT64:\n      n->vf64 = bv->vdouble;\n      n->type = JBV_F64;\n      break;\n    default:\n      rc = JBL_ERROR_CREATION;\n      goto finish;\n  }\n  if (parent) {\n    _jbn_add_item(parent, n);\n  }\n\nfinish:\n  if (rc) {\n    free(n);\n  } else {\n    if (node) {\n      *node = n;\n    }\n  }\n  return rc;\n}\n\nstatic iwrc _jbl_node_from_binn_impl(\n  JBLDRCTX   *ctx,\n  const binn *bn,\n  JBL_NODE    parent,\n  char       *key,\n  int         klidx,\n  bool        clone_strings\n  ) {\n  binn bv;\n  binn_iter iter;\n  iwrc rc = 0;\n\n  switch (bn->type) {\n    case BINN_OBJECT:\n    case BINN_MAP:\n      rc = _jbl_create_node(ctx, bn, parent, key, klidx, &parent, clone_strings);\n      RCRET(rc);\n      if (!ctx->root) {\n        ctx->root = parent;\n      }\n      if (!binn_iter_init(&iter, (binn*) bn, bn->type)) {\n        return JBL_ERROR_INVALID;\n      }\n      if (bn->type == BINN_OBJECT) {\n        while (binn_object_next2(&iter, &key, &klidx, &bv)) {\n          rc = _jbl_node_from_binn_impl(ctx, &bv, parent, key, klidx, clone_strings);\n          RCRET(rc);\n        }\n      } else if (bn->type == BINN_MAP) {\n        while (binn_map_next(&iter, &klidx, &bv)) {\n          rc = _jbl_node_from_binn_impl(ctx, &bv, parent, 0, klidx, clone_strings);\n          RCRET(rc);\n        }\n      }\n      break;\n    case BINN_LIST:\n      rc = _jbl_create_node(ctx, bn, parent, key, klidx, &parent, clone_strings);\n      RCRET(rc);\n      if (!ctx->root) {\n        ctx->root = parent;\n      }\n      if (!binn_iter_init(&iter, (binn*) bn, bn->type)) {\n        return JBL_ERROR_INVALID;\n      }\n      for (int i = 0; binn_list_next(&iter, &bv); ++i) {\n        rc = _jbl_node_from_binn_impl(ctx, &bv, parent, 0, i, clone_strings);\n        RCRET(rc);\n      }\n      break;\n    default: {\n      rc = _jbl_create_node(ctx, bn, parent, key, klidx, 0, clone_strings);\n      RCRET(rc);\n      break;\n    }\n  }\n  return rc;\n}\n\niwrc _jbl_node_from_binn(const binn *bn, JBL_NODE *node, bool clone_strings, IWPOOL *pool) {\n  JBLDRCTX ctx = {\n    .pool = pool\n  };\n  iwrc rc = _jbl_node_from_binn_impl(&ctx, bn, 0, 0, -1, clone_strings);\n  if (rc) {\n    *node = 0;\n  } else {\n    *node = ctx.root;\n  }\n  return rc;\n}\n\nstatic JBL_NODE _jbl_node_find(JBL_NODE node, JBL_PTR ptr, int from, int to) {\n  if (!ptr || !node) {\n    return 0;\n  }\n  JBL_NODE n = node;\n\n  for (int i = from; n && i < ptr->cnt && i < to; ++i) {\n    if (n->type == JBV_OBJECT) {\n      int ptrnlen = (int) strlen(ptr->n[i]);\n      for (n = n->child; n; n = n->next) {\n        if (!strncmp(n->key, ptr->n[i], n->klidx) && (ptrnlen == n->klidx)) {\n          break;\n        }\n      }\n    } else if (n->type == JBV_ARRAY) {\n      int64_t idx = iwatoi(ptr->n[i]);\n      for (n = n->child; n; n = n->next) {\n        if (idx == n->klidx) {\n          break;\n        }\n      }\n    } else {\n      return 0;\n    }\n  }\n  return n;\n}\n\nIW_INLINE JBL_NODE _jbl_node_find2(JBL_NODE node, JBL_PTR ptr) {\n  if (!node || !ptr || !ptr->cnt) {\n    return 0;\n  }\n  return _jbl_node_find(node, ptr, 0, ptr->cnt - 1);\n}\n\nstatic JBL_NODE _jbl_node_detach(JBL_NODE target, JBL_PTR path) {\n  if (!path) {\n    return 0;\n  }\n  JBL_NODE parent = (path->cnt > 1) ? _jbl_node_find(target, path, 0, path->cnt - 1) : target;\n  if (!parent) {\n    return 0;\n  }\n  JBL_NODE child = _jbl_node_find(parent, path, path->cnt - 1, path->cnt);\n  if (!child) {\n    return 0;\n  }\n  _jbn_remove_item(parent, child);\n  return child;\n}\n\nJBL_NODE jbn_detach2(JBL_NODE target, JBL_PTR path) {\n  return _jbl_node_detach(target, path);\n}\n\nJBL_NODE jbn_detach(JBL_NODE target, const char *path) {\n  JBL_PTR jp;\n  iwrc rc = _jbl_ptr_pool(path, &jp, 0);\n  if (rc) {\n    return 0;\n  }\n  JBL_NODE res = jbn_detach2(target, jp);\n  free(jp);\n  return res;\n}\n\nstatic int _jbl_cmp_node_keys(const void *o1, const void *o2) {\n  JBL_NODE n1 = *((JBL_NODE*) o1);\n  JBL_NODE n2 = *((JBL_NODE*) o2);\n  if (!n1 && !n2) {\n    return 0;\n  }\n  if (!n2 || (n1->klidx > n2->klidx)) { // -V522\n    return 1;\n  } else if (!n1 || (n1->klidx < n2->klidx)) { // -V522\n    return -1;\n  }\n  return strncmp(n1->key, n2->key, n1->klidx);\n}\n\nstatic uint32_t _jbl_node_count(JBL_NODE n) {\n  uint32_t ret = 0;\n  n = n->child;\n  while (n) {\n    ret++;\n    n = n->next;\n  }\n  return ret;\n}\n\nstatic int _jbl_compare_objects(JBL_NODE n1, JBL_NODE n2, iwrc *rcp) {\n  int ret = 0;\n  uint32_t cnt = _jbl_node_count(n1);\n  uint32_t i = _jbl_node_count(n2);\n  if (cnt > i) {\n    return 1;\n  } else if (cnt < i) {\n    return -1;\n  } else if (cnt == 0) {\n    return 0;\n  }\n  JBL_NODE *s1 = malloc(2 * sizeof(JBL_NODE) * cnt);\n  if (!s1) {\n    *rcp = iwrc_set_errno(IW_ERROR_ALLOC, errno);\n    return 0;\n  }\n  JBL_NODE *s2 = s1 + cnt;\n\n  i = 0;\n  n1 = n1->child;\n  n2 = n2->child;\n  while (n1 && n2) {\n    s1[i] = n1;\n    s2[i] = n2;\n    n1 = n1->next;\n    n2 = n2->next;\n    ++i;\n  }\n  qsort(s1, cnt, sizeof(JBL_NODE), _jbl_cmp_node_keys);\n  qsort(s2, cnt, sizeof(JBL_NODE), _jbl_cmp_node_keys);\n  for (i = 0; i < cnt; ++i) {\n    ret = _jbl_cmp_node_keys(s1 + i, s2 + i);\n    if (ret) {\n      goto finish;\n    }\n    ret = _jbl_compare_nodes(s1[i], s2[i], rcp);\n    if (*rcp || ret) {\n      goto finish;\n    }\n  }\n\nfinish:\n  free(s1);\n  return ret;\n}\n\nint _jbl_compare_nodes(JBL_NODE n1, JBL_NODE n2, iwrc *rcp) {\n  if (!n1 && !n2) {\n    return 0;\n  } else if (!n1) {\n    return -1;\n  } else if (!n2) {\n    return 1;\n  } else if (n1->type != n2->type) {\n    return (int) n1->type - (int) n2->type;\n  }\n  switch (n1->type) {\n    case JBV_BOOL:\n      return n1->vbool - n2->vbool;\n    case JBV_I64:\n      return n1->vi64 > n2->vi64 ? 1 : n1->vi64 < n2->vi64 ? -1 : 0;\n    case JBV_F64: {\n      size_t sz1, sz2;\n      char b1[IWNUMBUF_SIZE];\n      char b2[IWNUMBUF_SIZE];\n      iwjson_ftoa(n1->vf64, b1, &sz1);\n      iwjson_ftoa(n2->vf64, b2, &sz2);\n      return iwafcmp(b1, sz1, b2, sz2);\n    }\n    case JBV_STR:\n      if (n1->vsize != n2->vsize) {\n        return n1->vsize - n2->vsize;\n      }\n      return strncmp(n1->vptr, n2->vptr, n1->vsize);\n    case JBV_ARRAY:\n      for (n1 = n1->child, n2 = n2->child; n1 && n2; n1 = n1->next, n2 = n2->next) {\n        int res = _jbl_compare_nodes(n1, n2, rcp);\n        if (res) {\n          return res;\n        }\n      }\n      if (n1) {\n        return 1;\n      } else if (n2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    case JBV_OBJECT:\n      return _jbl_compare_objects(n1, n2, rcp);\n    case JBV_NULL:\n    case JBV_NONE:\n      break;\n  }\n  return 0;\n}\n\nint jbn_compare_nodes(JBL_NODE n1, JBL_NODE n2, iwrc *rcp) {\n  return _jbl_compare_nodes(n1, n2, rcp);\n}\n\nstatic iwrc _jbl_target_apply_patch(JBL_NODE target, const JBL_PATCHEXT *ex, IWPOOL *pool) {\n  struct _JBL_NODE *ntmp;\n  jbp_patch_t op = ex->p->op;\n  JBL_PTR path = ex->path;\n  JBL_NODE value = ex->p->vnode;\n  bool oproot = ex->path->cnt == 1 && *ex->path->n[0] == '\\0';\n\n  if (op == JBP_TEST) {\n    iwrc rc = 0;\n    if (!value) {\n      return JBL_ERROR_PATCH_NOVALUE;\n    }\n    if (_jbl_compare_nodes(oproot ? target : _jbl_node_find(target, path, 0, path->cnt), value, &rc)) {\n      RCRET(rc);\n      return JBL_ERROR_PATCH_TEST_FAILED;\n    } else {\n      return rc;\n    }\n  }\n  if (oproot) { // Root operation\n    if (op == JBP_REMOVE) {\n      memset(target, 0, sizeof(*target));\n    } else if ((op == JBP_REPLACE) || (op == JBP_ADD) || (op == JBP_ADD_CREATE)) {\n      if (!value) {\n        return JBL_ERROR_PATCH_NOVALUE;\n      }\n      memmove(target, value, sizeof(*value));\n    }\n  } else { // Not a root\n    if ((op == JBP_REMOVE) || (op == JBP_REPLACE)) {\n      _jbl_node_detach(target, ex->path);\n    }\n    if (op == JBP_REMOVE) {\n      return 0;\n    } else if ((op == JBP_MOVE) || (op == JBP_COPY) || (op == JBP_SWAP)) {\n      if (op == JBP_MOVE) {\n        value = _jbl_node_detach(target, ex->from);\n      } else {\n        value = _jbl_node_find(target, ex->from, 0, ex->from->cnt);\n      }\n      if (!value) {\n        return JBL_ERROR_PATH_NOTFOUND;\n      }\n      if (op == JBP_SWAP) {\n        ntmp = iwpool_calloc(sizeof(*ntmp), pool);\n        if (!ntmp) {\n          return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n        }\n      }\n    } else { // ADD/REPLACE/INCREMENT\n      if (!value) {\n        return JBL_ERROR_PATCH_NOVALUE;\n      }\n    }\n    int lastidx = path->cnt - 1;\n    JBL_NODE parent = (path->cnt > 1) ? _jbl_node_find(target, path, 0, lastidx) : target;\n    if (!parent) {\n      if (op == JBP_ADD_CREATE) {\n        parent = target;\n        for (int i = 0; i < lastidx; ++i) {\n          JBL_NODE pn = _jbl_node_find(parent, path, i, i + 1);\n          if (!pn) {\n            pn = iwpool_calloc(sizeof(*pn), pool);\n            if (!pn) {\n              return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n            }\n            pn->type = JBV_OBJECT;\n            pn->key = path->n[i];\n            pn->klidx = (int) strlen(pn->key);\n            _jbn_add_item(parent, pn);\n          } else if (pn->type != JBV_OBJECT) {\n            return JBL_ERROR_PATCH_TARGET_INVALID;\n          }\n          parent = pn;\n        }\n      } else {\n        return JBL_ERROR_PATCH_TARGET_INVALID;\n      }\n    }\n    if (parent->type == JBV_ARRAY) {\n      if ((path->n[lastidx][0] == '-') && (path->n[lastidx][1] == '\\0')) {\n        if (op == JBP_SWAP) {\n          value = _jbl_node_detach(target, ex->from);\n        }\n        _jbn_add_item(parent, value); // Add to end of array\n      } else {                        // Insert into the specified index\n        int idx = iwatoi(path->n[lastidx]);\n        int cnt = idx;\n        JBL_NODE child = parent->child;\n        while (child && cnt > 0) {\n          cnt--;\n          child = child->next;\n        }\n        if (cnt > 0) {\n          return JBL_ERROR_PATCH_INVALID_ARRAY_INDEX;\n        }\n        value->klidx = idx;\n        if (child) {\n          if (op == JBP_SWAP) {\n            _jbl_copy_node_data(ntmp, value);\n            _jbl_copy_node_data(value, child);\n            _jbl_copy_node_data(child, ntmp);\n          } else {\n            value->parent = parent;\n            value->next = child;\n            value->prev = child->prev;\n            child->prev = value;\n            if (child == parent->child) {\n              parent->child = value;\n            } else {\n              value->prev->next = value;\n            }\n            while (child) {\n              child->klidx++;\n              child = child->next;\n            }\n          }\n        } else {\n          if (op == JBP_SWAP) {\n            value = _jbl_node_detach(target, ex->from);\n          }\n          _jbn_add_item(parent, value);\n        }\n      }\n    } else if (parent->type == JBV_OBJECT) {\n      JBL_NODE child = _jbl_node_find(parent, path, path->cnt - 1, path->cnt);\n      if (child) {\n        if (op == JBP_INCREMENT) {\n          return _jbl_increment_node_data(child, value);\n        } else {\n          if (op == JBP_SWAP) {\n            _jbl_copy_node_data(ntmp, value);\n            _jbl_copy_node_data(value, child);\n            _jbl_copy_node_data(child, ntmp);\n          } else {\n            _jbl_copy_node_data(child, value);\n          }\n        }\n      } else if (op != JBP_INCREMENT) {\n        if (op == JBP_SWAP) {\n          value = _jbl_node_detach(target, ex->from);\n        }\n        value->key = path->n[path->cnt - 1];\n        value->klidx = (int) strlen(value->key);\n        _jbn_add_item(parent, value);\n      } else {\n        return JBL_ERROR_PATCH_TARGET_INVALID;\n      }\n    } else {\n      return JBL_ERROR_PATCH_TARGET_INVALID;\n    }\n  }\n  return 0;\n}\n\nstatic iwrc _jbl_from_node_impl(binn *res, JBL_NODE node) {\n  iwrc rc = 0;\n  switch (node->type) {\n    case JBV_OBJECT:\n      if (!binn_create(res, BINN_OBJECT, 0, NULL)) {\n        return JBL_ERROR_CREATION;\n      }\n      for (JBL_NODE n = node->child; n; n = n->next) {\n        binn bv;\n        rc = _jbl_from_node_impl(&bv, n);\n        RCRET(rc);\n        if (!binn_object_set_value2(res, n->key, n->klidx, &bv)) {\n          rc = JBL_ERROR_CREATION;\n        }\n        binn_free(&bv);\n        RCRET(rc);\n      }\n      break;\n    case JBV_ARRAY:\n      if (!binn_create(res, BINN_LIST, 0, NULL)) {\n        return JBL_ERROR_CREATION;\n      }\n      for (JBL_NODE n = node->child; n; n = n->next) {\n        binn bv;\n        rc = _jbl_from_node_impl(&bv, n);\n        RCRET(rc);\n        if (!binn_list_add_value(res, &bv)) {\n          rc = JBL_ERROR_CREATION;\n        }\n        binn_free(&bv);\n        RCRET(rc);\n      }\n      break;\n    case JBV_STR:\n      binn_init_item(res);\n      binn_set_string(res, node->vptr, node->vsize);\n      break;\n    case JBV_I64:\n      binn_init_item(res);\n      binn_set_int64(res, node->vi64);\n      break;\n    case JBV_F64:\n      binn_init_item(res);\n      binn_set_double(res, node->vf64);\n      break;\n    case JBV_BOOL:\n      binn_init_item(res);\n      binn_set_bool(res, node->vbool);\n      break;\n    case JBV_NULL:\n      binn_init_item(res);\n      binn_set_null(res);\n      break;\n    case JBV_NONE:\n      rc = JBL_ERROR_CREATION;\n      break;\n  }\n  return rc;\n}\n\niwrc _jbl_binn_from_node(binn *res, JBL_NODE node) {\n  iwrc rc = _jbl_from_node_impl(res, node);\n  if (!rc) {\n    if (res->writable && res->dirty) {\n      binn_save_header(res);\n    }\n  }\n  return rc;\n}\n\niwrc _jbl_from_node(JBL jbl, JBL_NODE node) {\n  jbl->node = node;\n  return _jbl_binn_from_node(&jbl->bn, node);\n}\n\nstatic iwrc _jbl_patch_node(JBL_NODE root, const JBL_PATCH *p, size_t cnt, IWPOOL *pool) {\n  if (cnt < 1) {\n    return 0;\n  }\n  if (!root || !p) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  size_t i = 0;\n  JBL_PATCHEXT parr[cnt];\n  memset(parr, 0, cnt * sizeof(JBL_PATCHEXT));\n  for (i = 0; i < cnt; ++i) {\n    JBL_PATCHEXT *ext = &parr[i];\n    ext->p = &p[i];\n    rc = _jbl_ptr_pool(p[i].path, &ext->path, pool);\n    RCRET(rc);\n    if (p[i].from) {\n      rc = _jbl_ptr_pool(p[i].from, &ext->from, pool);\n      RCRET(rc);\n    }\n  }\n  for (i = 0; i < cnt; ++i) {\n    rc = _jbl_target_apply_patch(root, &parr[i], pool);\n    RCRET(rc);\n  }\n  return rc;\n}\n\nstatic iwrc _jbl_patch(JBL jbl, const JBL_PATCH *p, size_t cnt, IWPOOL *pool) {\n  if (cnt < 1) {\n    return 0;\n  }\n  if (!jbl || !p) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  binn bv;\n  binn *bn;\n  JBL_NODE root;\n  iwrc rc = _jbl_node_from_binn(&jbl->bn, &root, false, pool);\n  RCRET(rc);\n  rc = _jbl_patch_node(root, p, cnt, pool);\n  RCRET(rc);\n  if (root->type != JBV_NONE) {\n    rc = _jbl_from_node_impl(&bv, root);\n    RCRET(rc);\n    bn = &bv;\n  } else {\n    bn = 0;\n  }\n  binn_free(&jbl->bn);\n  if (bn) {\n    if (bn->writable && bn->dirty) {\n      binn_save_header(bn);\n    }\n    memcpy(&jbl->bn, bn, sizeof(jbl->bn));\n    jbl->bn.allocated = 0;\n  } else {\n    memset(&jbl->bn, 0, sizeof(jbl->bn));\n    root->type = JBV_NONE;\n  }\n  return rc;\n}\n\nint _jbl_cmp_atomic_values(JBL v1, JBL v2) {\n  jbl_type_t t1 = jbl_type(v1);\n  jbl_type_t t2 = jbl_type(v2);\n  if (t1 != t2) {\n    return (int) t1 - (int) t2;\n  }\n  switch (t1) {\n    case JBV_BOOL:\n    case JBV_I64: {\n      int64_t vv1 = jbl_get_i64(v1);\n      int64_t vv2 = jbl_get_i64(v2);\n      return vv1 > vv2 ? 1 : vv1 < vv2 ? -1 : 0;\n    }\n    case JBV_STR:\n      return strcmp(jbl_get_str(v1), jbl_get_str(v2)); // -V575\n    case JBV_F64: {\n      double vv1 = jbl_get_f64(v1);\n      double vv2 = jbl_get_f64(v2);\n      return vv1 > vv2 ? 1 : vv1 < vv2 ? -1 : 0;\n    }\n    default:\n      return 0;\n  }\n}\n\nbool _jbl_is_eq_atomic_values(JBL v1, JBL v2) {\n  jbl_type_t t1 = jbl_type(v1);\n  jbl_type_t t2 = jbl_type(v2);\n  if (t1 != t2) {\n    return false;\n  }\n  switch (t1) {\n    case JBV_BOOL:\n    case JBV_I64:\n      return jbl_get_i64(v1) == jbl_get_i64(v2);\n    case JBV_STR:\n      return !strcmp(jbl_get_str(v1), jbl_get_str(v2)); // -V575\n    case JBV_F64:\n      return jbl_get_f64(v1) == jbl_get_f64(v2); // -V550\n    case JBV_OBJECT:\n    case JBV_ARRAY:\n      return false;\n    default:\n      return true;\n  }\n}\n\n// --------------------------- Public API\n\nvoid jbn_apply_from(JBL_NODE target, JBL_NODE from) {\n  const int off = offsetof(struct _JBL_NODE, child);\n  memcpy((char*) target + off,\n         (char*) from + off,\n         sizeof(struct _JBL_NODE) - off);\n}\n\niwrc jbl_to_node(JBL jbl, JBL_NODE *node, bool clone_strings, IWPOOL *pool) {\n  if (jbl->node) {\n    *node = jbl->node;\n    return 0;\n  }\n  return _jbl_node_from_binn(&jbl->bn, node, clone_strings, pool);\n}\n\niwrc jbn_patch(JBL_NODE root, const JBL_PATCH *p, size_t cnt, IWPOOL *pool) {\n  return _jbl_patch_node(root, p, cnt, pool);\n}\n\niwrc jbl_patch(JBL jbl, const JBL_PATCH *p, size_t cnt) {\n  if (cnt < 1) {\n    return 0;\n  }\n  if (!jbl || !p) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  IWPOOL *pool = iwpool_create(jbl->bn.size);\n  if (!pool) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  iwrc rc = _jbl_patch(jbl, p, cnt, pool);\n  iwpool_destroy(pool);\n  return rc;\n}\n\nstatic iwrc _jbl_create_patch(JBL_NODE node, JBL_PATCH **pptr, int *cntp, IWPOOL *pool) {\n  *pptr = 0;\n  *cntp = 0;\n  int i = 0;\n  for (JBL_NODE n = node->child; n; n = n->next) {\n    if (n->type != JBV_OBJECT) {\n      return JBL_ERROR_PATCH_INVALID;\n    }\n    ++i;\n  }\n  JBL_PATCH *p = iwpool_alloc(i * sizeof(*p), pool);\n  if (!p) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  memset(p, 0, i * sizeof(*p));\n  i = 0;\n  for (JBL_NODE n = node->child; n; n = n->next, ++i) {\n    JBL_PATCH *pp = p + i;\n    for (JBL_NODE n2 = n->child; n2; n2 = n2->next) {\n      if (!strncmp(\"op\", n2->key, n2->klidx)) {\n        if (n2->type != JBV_STR) {\n          return JBL_ERROR_PATCH_INVALID;\n        }\n        if (!strncmp(\"add\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_ADD;\n        } else if (!strncmp(\"remove\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_REMOVE;\n        } else if (!strncmp(\"replace\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_REPLACE;\n        } else if (!strncmp(\"copy\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_COPY;\n        } else if (!strncmp(\"move\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_MOVE;\n        } else if (!strncmp(\"test\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_TEST;\n        } else if (!strncmp(\"increment\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_INCREMENT;\n        } else if (!strncmp(\"add_create\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_ADD_CREATE;\n        } else if (!strncmp(\"swap\", n2->vptr, n2->vsize)) {\n          pp->op = JBP_SWAP;\n        } else {\n          return JBL_ERROR_PATCH_INVALID_OP;\n        }\n      } else if (!strncmp(\"value\", n2->key, n2->klidx)) {\n        pp->vnode = n2;\n      } else if (!strncmp(\"path\", n2->key, n2->klidx)) {\n        if (n2->type != JBV_STR) {\n          return JBL_ERROR_PATCH_INVALID;\n        }\n        pp->path = n2->vptr;\n      } else if (!strncmp(\"from\", n2->key, n2->klidx)) {\n        if (n2->type != JBV_STR) {\n          return JBL_ERROR_PATCH_INVALID;\n        }\n        pp->from = n2->vptr;\n      }\n    }\n  }\n  *cntp = i;\n  *pptr = p;\n  return 0;\n}\n\niwrc jbl_patch_from_json(JBL jbl, const char *patchjson) {\n  if (!jbl || !patchjson) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  JBL_PATCH *p;\n  JBL_NODE patch;\n  int cnt = (int) strlen(patchjson);\n  IWPOOL *pool = iwpool_create(MAX(cnt, 1024U));\n  if (!pool) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  iwrc rc = jbn_from_json(patchjson, &patch, pool);\n  RCGO(rc, finish);\n  if (patch->type == JBV_ARRAY) {\n    rc = _jbl_create_patch(patch, &p, &cnt, pool);\n    RCGO(rc, finish);\n    rc = _jbl_patch(jbl, p, cnt, pool);\n  } else if (patch->type == JBV_OBJECT) {\n    // FIXME: Merge patch not implemented\n    //_jbl_merge_patch_node()\n    rc = IW_ERROR_NOT_IMPLEMENTED;\n  } else {\n    rc = JBL_ERROR_PATCH_INVALID;\n  }\n\nfinish:\n  iwpool_destroy(pool);\n  return rc;\n}\n\niwrc jbl_fill_from_node(JBL jbl, JBL_NODE node) {\n  if (!jbl || !node) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  if (node->type == JBV_NONE) {\n    memset(jbl, 0, sizeof(*jbl));\n    return 0;\n  }\n  binn bv = { 0 };\n  iwrc rc = _jbl_binn_from_node(&bv, node);\n  RCRET(rc);\n  binn_free(&jbl->bn);\n  memcpy(&jbl->bn, &bv, sizeof(jbl->bn));\n  jbl->bn.allocated = 0;\n  return rc;\n}\n\niwrc jbl_from_node(JBL *jblp, JBL_NODE node) {\n  if (!jblp || !node) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  if (node->type == JBV_OBJECT) {\n    rc = jbl_create_empty_object(jblp);\n  } else if (node->type == JBV_ARRAY) {\n    rc = jbl_create_empty_array(jblp);\n  } else {\n    rc = IW_ERROR_INVALID_ARGS;\n  }\n  RCRET(rc);\n  return jbl_fill_from_node(*jblp, node);\n}\n\nstatic JBL_NODE _jbl_merge_patch_node(JBL_NODE target, JBL_NODE patch, IWPOOL *pool, iwrc *rcp) {\n  *rcp = 0;\n  if (!patch) {\n    return 0;\n  }\n  if (patch->type == JBV_OBJECT) {\n    if (!target) {\n      target = iwpool_alloc(sizeof(*target), pool);\n      if (!target) {\n        *rcp = iwrc_set_errno(IW_ERROR_ALLOC, errno);\n        return 0;\n      }\n      memset(target, 0, sizeof(*target));\n      target->type = JBV_OBJECT;\n      target->key = patch->key;\n      target->klidx = patch->klidx;\n    } else if (target->type != JBV_OBJECT) {\n      _jbl_node_reset_data(target);\n      target->type = JBV_OBJECT;\n    }\n    patch = patch->child;\n    while (patch) {\n      JBL_NODE patch_next = patch->next;\n      if (patch->type == JBV_NULL) {\n        JBL_NODE node = target->child;\n        while (node) {\n          if ((node->klidx == patch->klidx) && !strncmp(node->key, patch->key, node->klidx)) {\n            _jbn_remove_item(target, node);\n            break;\n          }\n          node = node->next;\n        }\n      } else {\n        JBL_NODE node = target->child;\n        while (node) {\n          if ((node->klidx == patch->klidx) && !strncmp(node->key, patch->key, node->klidx)) {\n            _jbl_copy_node_data(node, _jbl_merge_patch_node(node, patch, pool, rcp));\n            break;\n          }\n          node = node->next;\n        }\n        if (!node) {\n          _jbn_add_item(target, _jbl_merge_patch_node(0, patch, pool, rcp));\n        }\n      }\n      patch = patch_next;\n    }\n    return target;\n  } else {\n    return patch;\n  }\n}\n\niwrc jbn_merge_patch_from_json(JBL_NODE root, const char *patchjson, IWPOOL *pool) {\n  if (!root || !patchjson || !pool) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  JBL_NODE patch, res;\n  iwrc rc = jbn_from_json(patchjson, &patch, pool);\n  RCRET(rc);\n  res = _jbl_merge_patch_node(root, patch, pool, &rc);\n  RCGO(rc, finish);\n  if (res != root) {\n    memcpy(root, res, sizeof(*root)); // -V575\n  }\n\nfinish:\n  return rc;\n}\n\niwrc jbl_merge_patch(JBL jbl, const char *patchjson) {\n  if (!jbl || !patchjson) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  binn bv;\n  JBL_NODE target;\n  IWPOOL *pool = iwpool_create(jbl->bn.size * 2);\n  if (!pool) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  iwrc rc = _jbl_node_from_binn(&jbl->bn, &target, false, pool);\n  RCGO(rc, finish);\n  rc = jbn_merge_patch_from_json(target, patchjson, pool);\n  RCGO(rc, finish);\n\n  rc = _jbl_binn_from_node(&bv, target);\n  RCGO(rc, finish);\n\n  binn_free(&jbl->bn);\n  memcpy(&jbl->bn, &bv, sizeof(jbl->bn));\n  jbl->bn.allocated = 0;\n\nfinish:\n  iwpool_destroy(pool);\n  return 0;\n}\n\niwrc jbl_merge_patch_jbl(JBL jbl, JBL patch) {\n  IWXSTR *xstr = iwxstr_new();\n  if (!xstr) {\n    return iwrc_set_errno(IW_ERROR_ALLOC, errno);\n  }\n  iwrc rc = jbl_as_json(patch, jbl_xstr_json_printer, xstr, 0);\n  RCGO(rc, finish);\n  rc = jbl_merge_patch(jbl, iwxstr_ptr(xstr));\nfinish:\n  iwxstr_destroy(xstr);\n  return rc;\n}\n\niwrc jbn_patch_auto(JBL_NODE root, JBL_NODE patch, IWPOOL *pool) {\n  if (!root || !patch || !pool) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  if (patch->type == JBV_OBJECT) {\n    _jbl_merge_patch_node(root, patch, pool, &rc);\n  } else if (patch->type == JBV_ARRAY) {\n    int cnt;\n    JBL_PATCH *p;\n    rc = _jbl_create_patch(patch, &p, &cnt, pool);\n    RCRET(rc);\n    rc = _jbl_patch_node(root, p, cnt, pool);\n  } else {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  return rc;\n}\n\niwrc jbn_merge_patch(JBL_NODE root, JBL_NODE patch, IWPOOL *pool) {\n  if (!root || !patch || !pool || (root->type != JBV_OBJECT)) {\n    return IW_ERROR_INVALID_ARGS;\n  }\n  iwrc rc = 0;\n  _jbl_merge_patch_node(root, patch, pool, &rc);\n  return rc;\n}\n\nstatic const char* _jbl_ecodefn(locale_t locale, uint32_t ecode) {\n  if (!((ecode > _JBL_ERROR_START) && (ecode < _JBL_ERROR_END))) {\n    return 0;\n  }\n  switch (ecode) {\n    case JBL_ERROR_INVALID_BUFFER:\n      return \"Invalid JBL buffer (JBL_ERROR_INVALID_BUFFER)\";\n    case JBL_ERROR_CREATION:\n      return \"Cannot create JBL object (JBL_ERROR_CREATION)\";\n    case JBL_ERROR_INVALID:\n      return \"Invalid JBL object (JBL_ERROR_INVALID)\";\n    case JBL_ERROR_PARSE_JSON:\n      return \"Failed to parse JSON string (JBL_ERROR_PARSE_JSON)\";\n    case JBL_ERROR_PARSE_UNQUOTED_STRING:\n      return \"Unquoted JSON string (JBL_ERROR_PARSE_UNQUOTED_STRING)\";\n    case JBL_ERROR_PARSE_INVALID_CODEPOINT:\n      return \"Invalid unicode codepoint/escape sequence (JBL_ERROR_PARSE_INVALID_CODEPOINT)\";\n    case JBL_ERROR_PARSE_INVALID_UTF8:\n      return \"Invalid utf8 string (JBL_ERROR_PARSE_INVALID_UTF8)\";\n    case JBL_ERROR_JSON_POINTER:\n      return \"Invalid JSON pointer (rfc6901) path (JBL_ERROR_JSON_POINTER)\";\n    case JBL_ERROR_PATH_NOTFOUND:\n      return \"JSON object not matched the path specified (JBL_ERROR_PATH_NOTFOUND)\";\n    case JBL_ERROR_PATCH_INVALID:\n      return \"Invalid JSON patch specified (JBL_ERROR_PATCH_INVALID)\";\n    case JBL_ERROR_PATCH_INVALID_OP:\n      return \"Invalid JSON patch operation specified (JBL_ERROR_PATCH_INVALID_OP)\";\n    case JBL_ERROR_PATCH_NOVALUE:\n      return \"No value specified in JSON patch (JBL_ERROR_PATCH_NOVALUE)\";\n    case JBL_ERROR_PATCH_TARGET_INVALID:\n      return \"Could not find target object to set value (JBL_ERROR_PATCH_TARGET_INVALID)\";\n    case JBL_ERROR_PATCH_INVALID_VALUE:\n      return \"Invalid value specified by patch (JBL_ERROR_PATCH_INVALID_VALUE)\";\n    case JBL_ERROR_PATCH_INVALID_ARRAY_INDEX:\n      return \"Invalid array index in JSON patch path (JBL_ERROR_PATCH_INVALID_ARRAY_INDEX)\";\n    case JBL_ERROR_PATCH_TEST_FAILED:\n      return \"JSON patch test operation failed (JBL_ERROR_PATCH_TEST_FAILED)\";\n    case JBL_ERROR_NOT_AN_OBJECT:\n      return \"JBL is not an object (JBL_ERROR_NOT_AN_OBJECT)\";\n    case JBL_ERROR_TYPE_MISMATCHED:\n      return \"Type of JBL object mismatched user type constraints (JBL_ERROR_TYPE_MISMATCHED)\";\n    case JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED:\n      return \"Exceeded the maximal object nesting level: \" _STR(JBL_MAX_NESTING_LEVEL)\n             \" (JBL_ERROR_MAX_NESTING_LEVEL_EXCEEDED)\";\n  }\n  return 0;\n}\n\niwrc jbl_init(void) {\n  static int _jbl_initialized = 0;\n  if (!__sync_bool_compare_and_swap(&_jbl_initialized, 0, 1)) {\n    return 0;\n  }\n  return iwlog_register_ecodefn(_jbl_ecodefn);\n}\n"], "filenames": ["Changelog", "src/json/iwjson.c"], "buggy_code_start_loc": [2, 29], "buggy_code_end_loc": [2, 30], "fixing_code_start_loc": [3, 29], "fixing_code_end_loc": [4, 30], "type": "CWE-787", "message": "IOWOW is a C utility library and persistent key/value storage engine. Versions 1.4.15 and prior contain a stack buffer overflow vulnerability that allows for Denial of Service (DOS) when it parses scientific notation numbers present in JSON. A patch for this issue is available at commit a79d31e4cff1d5a08f665574b29fd885897a28fd in the `master` branch of the repository. There are no workarounds other than applying the patch.", "other": {"cve": {"id": "CVE-2022-23462", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-21T22:15:09.540", "lastModified": "2022-10-24T16:08:21.933", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "IOWOW is a C utility library and persistent key/value storage engine. Versions 1.4.15 and prior contain a stack buffer overflow vulnerability that allows for Denial of Service (DOS) when it parses scientific notation numbers present in JSON. A patch for this issue is available at commit a79d31e4cff1d5a08f665574b29fd885897a28fd in the `master` branch of the repository. There are no workarounds other than applying the patch."}, {"lang": "es", "value": "IOWOW es una biblioteca de utilidades en C y un motor de almacenamiento persistente de claves/valores. Las versiones 1.4.15 y anteriores contienen una vulnerabilidad de desbordamiento del b\u00fafer de la pila que permite una Denegaci\u00f3n de Servicio (DOS) cuando analiza los n\u00fameros de notaci\u00f3n cient\u00edfica presentes en JSON. Un parche para este problema est\u00e1 disponible en el commit a79d31e4cff1d5a08f665574b29fd885897a28fd en la rama \"master\" del repositorio. No se presentan m\u00e1s mitigaciones que aplicar el parche"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}, {"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:softmotions:iowow:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.15", "matchCriteriaId": "8A5227C4-FC98-4CF6-8965-8CA15FEA3695"}]}]}], "references": [{"url": "https://github.com/Softmotions/iowow/commit/a79d31e4cff1d5a08f665574b29fd885897a28fd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2022-066_iowow/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Softmotions/iowow/commit/a79d31e4cff1d5a08f665574b29fd885897a28fd"}}