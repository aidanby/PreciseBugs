{"buggy_code": ["/*-*- Mode: C; c-basic-offset: 8; indent-tabs-mode: nil -*-*/\n\n/***\n  This file is part of systemd.\n\n  Copyright 2010 Lennart Poettering\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <http://www.gnu.org/licenses/>.\n***/\n\n#include <dirent.h>\n#include <errno.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"dirent-util.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"fs-util.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"missing.h\"\n#include \"mkdir.h\"\n#include \"parse-util.h\"\n#include \"path-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"time-util.h\"\n#include \"user-util.h\"\n#include \"util.h\"\n\nint unlink_noerrno(const char *path) {\n        PROTECT_ERRNO;\n        int r;\n\n        r = unlink(path);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}\n\nint rmdir_parents(const char *path, const char *stop) {\n        size_t l;\n        int r = 0;\n\n        assert(path);\n        assert(stop);\n\n        l = strlen(path);\n\n        /* Skip trailing slashes */\n        while (l > 0 && path[l-1] == '/')\n                l--;\n\n        while (l > 0) {\n                char *t;\n\n                /* Skip last component */\n                while (l > 0 && path[l-1] != '/')\n                        l--;\n\n                /* Skip trailing slashes */\n                while (l > 0 && path[l-1] == '/')\n                        l--;\n\n                if (l <= 0)\n                        break;\n\n                t = strndup(path, l);\n                if (!t)\n                        return -ENOMEM;\n\n                if (path_startswith(stop, t)) {\n                        free(t);\n                        return 0;\n                }\n\n                r = rmdir(t);\n                free(t);\n\n                if (r < 0)\n                        if (errno != ENOENT)\n                                return -errno;\n        }\n\n        return 0;\n}\n\n\nint rename_noreplace(int olddirfd, const char *oldpath, int newdirfd, const char *newpath) {\n        struct stat buf;\n        int ret;\n\n        ret = renameat2(olddirfd, oldpath, newdirfd, newpath, RENAME_NOREPLACE);\n        if (ret >= 0)\n                return 0;\n\n        /* renameat2() exists since Linux 3.15, btrfs added support for it later.\n         * If it is not implemented, fallback to another method. */\n        if (!IN_SET(errno, EINVAL, ENOSYS))\n                return -errno;\n\n        /* The link()/unlink() fallback does not work on directories. But\n         * renameat() without RENAME_NOREPLACE gives the same semantics on\n         * directories, except when newpath is an *empty* directory. This is\n         * good enough. */\n        ret = fstatat(olddirfd, oldpath, &buf, AT_SYMLINK_NOFOLLOW);\n        if (ret >= 0 && S_ISDIR(buf.st_mode)) {\n                ret = renameat(olddirfd, oldpath, newdirfd, newpath);\n                return ret >= 0 ? 0 : -errno;\n        }\n\n        /* If it is not a directory, use the link()/unlink() fallback. */\n        ret = linkat(olddirfd, oldpath, newdirfd, newpath, 0);\n        if (ret < 0)\n                return -errno;\n\n        ret = unlinkat(olddirfd, oldpath, 0);\n        if (ret < 0) {\n                /* backup errno before the following unlinkat() alters it */\n                ret = errno;\n                (void) unlinkat(newdirfd, newpath, 0);\n                errno = ret;\n                return -errno;\n        }\n\n        return 0;\n}\n\nint readlinkat_malloc(int fd, const char *p, char **ret) {\n        size_t l = 100;\n        int r;\n\n        assert(p);\n        assert(ret);\n\n        for (;;) {\n                char *c;\n                ssize_t n;\n\n                c = new(char, l);\n                if (!c)\n                        return -ENOMEM;\n\n                n = readlinkat(fd, p, c, l-1);\n                if (n < 0) {\n                        r = -errno;\n                        free(c);\n                        return r;\n                }\n\n                if ((size_t) n < l-1) {\n                        c[n] = 0;\n                        *ret = c;\n                        return 0;\n                }\n\n                free(c);\n                l *= 2;\n        }\n}\n\nint readlink_malloc(const char *p, char **ret) {\n        return readlinkat_malloc(AT_FDCWD, p, ret);\n}\n\nint readlink_value(const char *p, char **ret) {\n        _cleanup_free_ char *link = NULL;\n        char *value;\n        int r;\n\n        r = readlink_malloc(p, &link);\n        if (r < 0)\n                return r;\n\n        value = basename(link);\n        if (!value)\n                return -ENOENT;\n\n        value = strdup(value);\n        if (!value)\n                return -ENOMEM;\n\n        *ret = value;\n\n        return 0;\n}\n\nint readlink_and_make_absolute(const char *p, char **r) {\n        _cleanup_free_ char *target = NULL;\n        char *k;\n        int j;\n\n        assert(p);\n        assert(r);\n\n        j = readlink_malloc(p, &target);\n        if (j < 0)\n                return j;\n\n        k = file_in_same_dir(p, target);\n        if (!k)\n                return -ENOMEM;\n\n        *r = k;\n        return 0;\n}\n\nint readlink_and_canonicalize(const char *p, char **r) {\n        char *t, *s;\n        int j;\n\n        assert(p);\n        assert(r);\n\n        j = readlink_and_make_absolute(p, &t);\n        if (j < 0)\n                return j;\n\n        s = canonicalize_file_name(t);\n        if (s) {\n                free(t);\n                *r = s;\n        } else\n                *r = t;\n\n        path_kill_slashes(*r);\n\n        return 0;\n}\n\nint readlink_and_make_absolute_root(const char *root, const char *path, char **ret) {\n        _cleanup_free_ char *target = NULL, *t = NULL;\n        const char *full;\n        int r;\n\n        full = prefix_roota(root, path);\n        r = readlink_malloc(full, &target);\n        if (r < 0)\n                return r;\n\n        t = file_in_same_dir(path, target);\n        if (!t)\n                return -ENOMEM;\n\n        *ret = t;\n        t = NULL;\n\n        return 0;\n}\n\nint chmod_and_chown(const char *path, mode_t mode, uid_t uid, gid_t gid) {\n        assert(path);\n\n        /* Under the assumption that we are running privileged we\n         * first change the access mode and only then hand out\n         * ownership to avoid a window where access is too open. */\n\n        if (mode != MODE_INVALID)\n                if (chmod(path, mode) < 0)\n                        return -errno;\n\n        if (uid != UID_INVALID || gid != GID_INVALID)\n                if (chown(path, uid, gid) < 0)\n                        return -errno;\n\n        return 0;\n}\n\nint fchmod_and_fchown(int fd, mode_t mode, uid_t uid, gid_t gid) {\n        assert(fd >= 0);\n\n        /* Under the assumption that we are running privileged we\n         * first change the access mode and only then hand out\n         * ownership to avoid a window where access is too open. */\n\n        if (mode != MODE_INVALID)\n                if (fchmod(fd, mode) < 0)\n                        return -errno;\n\n        if (uid != UID_INVALID || gid != GID_INVALID)\n                if (fchown(fd, uid, gid) < 0)\n                        return -errno;\n\n        return 0;\n}\n\nint fchmod_umask(int fd, mode_t m) {\n        mode_t u;\n        int r;\n\n        u = umask(0777);\n        r = fchmod(fd, m & (~u)) < 0 ? -errno : 0;\n        umask(u);\n\n        return r;\n}\n\nint fd_warn_permissions(const char *path, int fd) {\n        struct stat st;\n\n        if (fstat(fd, &st) < 0)\n                return -errno;\n\n        if (st.st_mode & 0111)\n                log_warning(\"Configuration file %s is marked executable. Please remove executable permission bits. Proceeding anyway.\", path);\n\n        if (st.st_mode & 0002)\n                log_warning(\"Configuration file %s is marked world-writable. Please remove world writability permission bits. Proceeding anyway.\", path);\n\n        if (getpid() == 1 && (st.st_mode & 0044) != 0044)\n                log_warning(\"Configuration file %s is marked world-inaccessible. This has no effect as configuration data is accessible via APIs without restrictions. Proceeding anyway.\", path);\n\n        return 0;\n}\n\nint touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n\n        assert(path);\n\n        if (parents)\n                mkdir_parents(path, 0755);\n\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}\n\nint touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);\n}\n\nint symlink_idempotent(const char *from, const char *to) {\n        _cleanup_free_ char *p = NULL;\n        int r;\n\n        assert(from);\n        assert(to);\n\n        if (symlink(from, to) < 0) {\n                if (errno != EEXIST)\n                        return -errno;\n\n                r = readlink_malloc(to, &p);\n                if (r < 0)\n                        return r;\n\n                if (!streq(p, from))\n                        return -EINVAL;\n        }\n\n        return 0;\n}\n\nint symlink_atomic(const char *from, const char *to) {\n        _cleanup_free_ char *t = NULL;\n        int r;\n\n        assert(from);\n        assert(to);\n\n        r = tempfn_random(to, NULL, &t);\n        if (r < 0)\n                return r;\n\n        if (symlink(from, t) < 0)\n                return -errno;\n\n        if (rename(t, to) < 0) {\n                unlink_noerrno(t);\n                return -errno;\n        }\n\n        return 0;\n}\n\nint mknod_atomic(const char *path, mode_t mode, dev_t dev) {\n        _cleanup_free_ char *t = NULL;\n        int r;\n\n        assert(path);\n\n        r = tempfn_random(path, NULL, &t);\n        if (r < 0)\n                return r;\n\n        if (mknod(t, mode, dev) < 0)\n                return -errno;\n\n        if (rename(t, path) < 0) {\n                unlink_noerrno(t);\n                return -errno;\n        }\n\n        return 0;\n}\n\nint mkfifo_atomic(const char *path, mode_t mode) {\n        _cleanup_free_ char *t = NULL;\n        int r;\n\n        assert(path);\n\n        r = tempfn_random(path, NULL, &t);\n        if (r < 0)\n                return r;\n\n        if (mkfifo(t, mode) < 0)\n                return -errno;\n\n        if (rename(t, path) < 0) {\n                unlink_noerrno(t);\n                return -errno;\n        }\n\n        return 0;\n}\n\nint get_files_in_directory(const char *path, char ***list) {\n        _cleanup_closedir_ DIR *d = NULL;\n        size_t bufsize = 0, n = 0;\n        _cleanup_strv_free_ char **l = NULL;\n\n        assert(path);\n\n        /* Returns all files in a directory in *list, and the number\n         * of files as return value. If list is NULL returns only the\n         * number. */\n\n        d = opendir(path);\n        if (!d)\n                return -errno;\n\n        for (;;) {\n                struct dirent *de;\n\n                errno = 0;\n                de = readdir(d);\n                if (!de && errno > 0)\n                        return -errno;\n                if (!de)\n                        break;\n\n                dirent_ensure_type(d, de);\n\n                if (!dirent_is_file(de))\n                        continue;\n\n                if (list) {\n                        /* one extra slot is needed for the terminating NULL */\n                        if (!GREEDY_REALLOC(l, bufsize, n + 2))\n                                return -ENOMEM;\n\n                        l[n] = strdup(de->d_name);\n                        if (!l[n])\n                                return -ENOMEM;\n\n                        l[++n] = NULL;\n                } else\n                        n++;\n        }\n\n        if (list) {\n                *list = l;\n                l = NULL; /* avoid freeing */\n        }\n\n        return n;\n}\n"], "fixing_code": ["/*-*- Mode: C; c-basic-offset: 8; indent-tabs-mode: nil -*-*/\n\n/***\n  This file is part of systemd.\n\n  Copyright 2010 Lennart Poettering\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <http://www.gnu.org/licenses/>.\n***/\n\n#include <dirent.h>\n#include <errno.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"dirent-util.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"fs-util.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"missing.h\"\n#include \"mkdir.h\"\n#include \"parse-util.h\"\n#include \"path-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"time-util.h\"\n#include \"user-util.h\"\n#include \"util.h\"\n\nint unlink_noerrno(const char *path) {\n        PROTECT_ERRNO;\n        int r;\n\n        r = unlink(path);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}\n\nint rmdir_parents(const char *path, const char *stop) {\n        size_t l;\n        int r = 0;\n\n        assert(path);\n        assert(stop);\n\n        l = strlen(path);\n\n        /* Skip trailing slashes */\n        while (l > 0 && path[l-1] == '/')\n                l--;\n\n        while (l > 0) {\n                char *t;\n\n                /* Skip last component */\n                while (l > 0 && path[l-1] != '/')\n                        l--;\n\n                /* Skip trailing slashes */\n                while (l > 0 && path[l-1] == '/')\n                        l--;\n\n                if (l <= 0)\n                        break;\n\n                t = strndup(path, l);\n                if (!t)\n                        return -ENOMEM;\n\n                if (path_startswith(stop, t)) {\n                        free(t);\n                        return 0;\n                }\n\n                r = rmdir(t);\n                free(t);\n\n                if (r < 0)\n                        if (errno != ENOENT)\n                                return -errno;\n        }\n\n        return 0;\n}\n\n\nint rename_noreplace(int olddirfd, const char *oldpath, int newdirfd, const char *newpath) {\n        struct stat buf;\n        int ret;\n\n        ret = renameat2(olddirfd, oldpath, newdirfd, newpath, RENAME_NOREPLACE);\n        if (ret >= 0)\n                return 0;\n\n        /* renameat2() exists since Linux 3.15, btrfs added support for it later.\n         * If it is not implemented, fallback to another method. */\n        if (!IN_SET(errno, EINVAL, ENOSYS))\n                return -errno;\n\n        /* The link()/unlink() fallback does not work on directories. But\n         * renameat() without RENAME_NOREPLACE gives the same semantics on\n         * directories, except when newpath is an *empty* directory. This is\n         * good enough. */\n        ret = fstatat(olddirfd, oldpath, &buf, AT_SYMLINK_NOFOLLOW);\n        if (ret >= 0 && S_ISDIR(buf.st_mode)) {\n                ret = renameat(olddirfd, oldpath, newdirfd, newpath);\n                return ret >= 0 ? 0 : -errno;\n        }\n\n        /* If it is not a directory, use the link()/unlink() fallback. */\n        ret = linkat(olddirfd, oldpath, newdirfd, newpath, 0);\n        if (ret < 0)\n                return -errno;\n\n        ret = unlinkat(olddirfd, oldpath, 0);\n        if (ret < 0) {\n                /* backup errno before the following unlinkat() alters it */\n                ret = errno;\n                (void) unlinkat(newdirfd, newpath, 0);\n                errno = ret;\n                return -errno;\n        }\n\n        return 0;\n}\n\nint readlinkat_malloc(int fd, const char *p, char **ret) {\n        size_t l = 100;\n        int r;\n\n        assert(p);\n        assert(ret);\n\n        for (;;) {\n                char *c;\n                ssize_t n;\n\n                c = new(char, l);\n                if (!c)\n                        return -ENOMEM;\n\n                n = readlinkat(fd, p, c, l-1);\n                if (n < 0) {\n                        r = -errno;\n                        free(c);\n                        return r;\n                }\n\n                if ((size_t) n < l-1) {\n                        c[n] = 0;\n                        *ret = c;\n                        return 0;\n                }\n\n                free(c);\n                l *= 2;\n        }\n}\n\nint readlink_malloc(const char *p, char **ret) {\n        return readlinkat_malloc(AT_FDCWD, p, ret);\n}\n\nint readlink_value(const char *p, char **ret) {\n        _cleanup_free_ char *link = NULL;\n        char *value;\n        int r;\n\n        r = readlink_malloc(p, &link);\n        if (r < 0)\n                return r;\n\n        value = basename(link);\n        if (!value)\n                return -ENOENT;\n\n        value = strdup(value);\n        if (!value)\n                return -ENOMEM;\n\n        *ret = value;\n\n        return 0;\n}\n\nint readlink_and_make_absolute(const char *p, char **r) {\n        _cleanup_free_ char *target = NULL;\n        char *k;\n        int j;\n\n        assert(p);\n        assert(r);\n\n        j = readlink_malloc(p, &target);\n        if (j < 0)\n                return j;\n\n        k = file_in_same_dir(p, target);\n        if (!k)\n                return -ENOMEM;\n\n        *r = k;\n        return 0;\n}\n\nint readlink_and_canonicalize(const char *p, char **r) {\n        char *t, *s;\n        int j;\n\n        assert(p);\n        assert(r);\n\n        j = readlink_and_make_absolute(p, &t);\n        if (j < 0)\n                return j;\n\n        s = canonicalize_file_name(t);\n        if (s) {\n                free(t);\n                *r = s;\n        } else\n                *r = t;\n\n        path_kill_slashes(*r);\n\n        return 0;\n}\n\nint readlink_and_make_absolute_root(const char *root, const char *path, char **ret) {\n        _cleanup_free_ char *target = NULL, *t = NULL;\n        const char *full;\n        int r;\n\n        full = prefix_roota(root, path);\n        r = readlink_malloc(full, &target);\n        if (r < 0)\n                return r;\n\n        t = file_in_same_dir(path, target);\n        if (!t)\n                return -ENOMEM;\n\n        *ret = t;\n        t = NULL;\n\n        return 0;\n}\n\nint chmod_and_chown(const char *path, mode_t mode, uid_t uid, gid_t gid) {\n        assert(path);\n\n        /* Under the assumption that we are running privileged we\n         * first change the access mode and only then hand out\n         * ownership to avoid a window where access is too open. */\n\n        if (mode != MODE_INVALID)\n                if (chmod(path, mode) < 0)\n                        return -errno;\n\n        if (uid != UID_INVALID || gid != GID_INVALID)\n                if (chown(path, uid, gid) < 0)\n                        return -errno;\n\n        return 0;\n}\n\nint fchmod_and_fchown(int fd, mode_t mode, uid_t uid, gid_t gid) {\n        assert(fd >= 0);\n\n        /* Under the assumption that we are running privileged we\n         * first change the access mode and only then hand out\n         * ownership to avoid a window where access is too open. */\n\n        if (mode != MODE_INVALID)\n                if (fchmod(fd, mode) < 0)\n                        return -errno;\n\n        if (uid != UID_INVALID || gid != GID_INVALID)\n                if (fchown(fd, uid, gid) < 0)\n                        return -errno;\n\n        return 0;\n}\n\nint fchmod_umask(int fd, mode_t m) {\n        mode_t u;\n        int r;\n\n        u = umask(0777);\n        r = fchmod(fd, m & (~u)) < 0 ? -errno : 0;\n        umask(u);\n\n        return r;\n}\n\nint fd_warn_permissions(const char *path, int fd) {\n        struct stat st;\n\n        if (fstat(fd, &st) < 0)\n                return -errno;\n\n        if (st.st_mode & 0111)\n                log_warning(\"Configuration file %s is marked executable. Please remove executable permission bits. Proceeding anyway.\", path);\n\n        if (st.st_mode & 0002)\n                log_warning(\"Configuration file %s is marked world-writable. Please remove world writability permission bits. Proceeding anyway.\", path);\n\n        if (getpid() == 1 && (st.st_mode & 0044) != 0044)\n                log_warning(\"Configuration file %s is marked world-inaccessible. This has no effect as configuration data is accessible via APIs without restrictions. Proceeding anyway.\", path);\n\n        return 0;\n}\n\nint touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n\n        assert(path);\n\n        if (parents)\n                mkdir_parents(path, 0755);\n\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n        if (fd < 0)\n                return -errno;\n\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}\n\nint touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);\n}\n\nint symlink_idempotent(const char *from, const char *to) {\n        _cleanup_free_ char *p = NULL;\n        int r;\n\n        assert(from);\n        assert(to);\n\n        if (symlink(from, to) < 0) {\n                if (errno != EEXIST)\n                        return -errno;\n\n                r = readlink_malloc(to, &p);\n                if (r < 0)\n                        return r;\n\n                if (!streq(p, from))\n                        return -EINVAL;\n        }\n\n        return 0;\n}\n\nint symlink_atomic(const char *from, const char *to) {\n        _cleanup_free_ char *t = NULL;\n        int r;\n\n        assert(from);\n        assert(to);\n\n        r = tempfn_random(to, NULL, &t);\n        if (r < 0)\n                return r;\n\n        if (symlink(from, t) < 0)\n                return -errno;\n\n        if (rename(t, to) < 0) {\n                unlink_noerrno(t);\n                return -errno;\n        }\n\n        return 0;\n}\n\nint mknod_atomic(const char *path, mode_t mode, dev_t dev) {\n        _cleanup_free_ char *t = NULL;\n        int r;\n\n        assert(path);\n\n        r = tempfn_random(path, NULL, &t);\n        if (r < 0)\n                return r;\n\n        if (mknod(t, mode, dev) < 0)\n                return -errno;\n\n        if (rename(t, path) < 0) {\n                unlink_noerrno(t);\n                return -errno;\n        }\n\n        return 0;\n}\n\nint mkfifo_atomic(const char *path, mode_t mode) {\n        _cleanup_free_ char *t = NULL;\n        int r;\n\n        assert(path);\n\n        r = tempfn_random(path, NULL, &t);\n        if (r < 0)\n                return r;\n\n        if (mkfifo(t, mode) < 0)\n                return -errno;\n\n        if (rename(t, path) < 0) {\n                unlink_noerrno(t);\n                return -errno;\n        }\n\n        return 0;\n}\n\nint get_files_in_directory(const char *path, char ***list) {\n        _cleanup_closedir_ DIR *d = NULL;\n        size_t bufsize = 0, n = 0;\n        _cleanup_strv_free_ char **l = NULL;\n\n        assert(path);\n\n        /* Returns all files in a directory in *list, and the number\n         * of files as return value. If list is NULL returns only the\n         * number. */\n\n        d = opendir(path);\n        if (!d)\n                return -errno;\n\n        for (;;) {\n                struct dirent *de;\n\n                errno = 0;\n                de = readdir(d);\n                if (!de && errno > 0)\n                        return -errno;\n                if (!de)\n                        break;\n\n                dirent_ensure_type(d, de);\n\n                if (!dirent_is_file(de))\n                        continue;\n\n                if (list) {\n                        /* one extra slot is needed for the terminating NULL */\n                        if (!GREEDY_REALLOC(l, bufsize, n + 2))\n                                return -ENOMEM;\n\n                        l[n] = strdup(de->d_name);\n                        if (!l[n])\n                                return -ENOMEM;\n\n                        l[++n] = NULL;\n                } else\n                        n++;\n        }\n\n        if (list) {\n                *list = l;\n                l = NULL; /* avoid freeing */\n        }\n\n        return n;\n}\n"], "filenames": ["src/basic/fs-util.c"], "buggy_code_start_loc": [344], "buggy_code_end_loc": [345], "fixing_code_start_loc": [344], "fixing_code_end_loc": [346], "type": "CWE-264", "message": "A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229.", "other": {"cve": {"id": "CVE-2016-10156", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-23T07:59:00.347", "lastModified": "2017-07-26T01:29:00.573", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229."}, {"lang": "es", "value": "Un fallo en systemd v228 en /src/basic/fs-util.c caus\u00f3 que los archivos suid de escritura universal se crearan cuando se usan las caracter\u00edsticas de los temporizadores systemd, permitiendo a atacantes locales escalar sus privilegios a root. Esto se soluciona en v229."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:228:*:*:*:*:*:*:*", "matchCriteriaId": "15362470-BF82-4CDB-988A-E077251B8673"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95790", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037686", "source": "cve@mitre.org"}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1020601", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/systemd/systemd/commit/06eeacb6fe029804f296b065b3ce91e796e1cd0e", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/41171/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/06eeacb6fe029804f296b065b3ce91e796e1cd0e"}}