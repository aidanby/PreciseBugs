{"buggy_code": ["/*\n * slcan.c - serial line CAN interface driver (using tty line discipline)\n *\n * This file is derived from linux/drivers/net/slip/slip.c\n *\n * slip.c Authors  : Laurence Culhane <loz@holmes.demon.co.uk>\n *                   Fred N. van Kempen <waltje@uwalt.nl.mugnet.org>\n * slcan.c Author  : Oliver Hartkopp <socketcan@hartkopp.net>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, see http://www.gnu.org/licenses/gpl.html\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n */\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/can.h>\n#include <linux/can/skb.h>\n#include <linux/can/can-ml.h>\n\nMODULE_ALIAS_LDISC(N_SLCAN);\nMODULE_DESCRIPTION(\"serial line CAN interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <socketcan@hartkopp.net>\");\n\n#define SLCAN_MAGIC 0x53CA\n\nstatic int maxdev = 10;\t\t/* MAX number of SLCAN channels;\n\t\t\t\t   This can be overridden with\n\t\t\t\t   insmod slcan.ko maxdev=nnn\t*/\nmodule_param(maxdev, int, 0);\nMODULE_PARM_DESC(maxdev, \"Maximum number of slcan interfaces\");\n\n/* maximum rx buffer len: extended CAN frame with timestamp */\n#define SLC_MTU (sizeof(\"T1111222281122334455667788EA5F\\r\")+1)\n\n#define SLC_CMD_LEN 1\n#define SLC_SFF_ID_LEN 3\n#define SLC_EFF_ID_LEN 8\n\nstruct slcan {\n\tint\t\t\tmagic;\n\n\t/* Various fields. */\n\tstruct tty_struct\t*tty;\t\t/* ptr to TTY structure\t     */\n\tstruct net_device\t*dev;\t\t/* easy for intr handling    */\n\tspinlock_t\t\tlock;\n\tstruct work_struct\ttx_work;\t/* Flushes transmit buffer   */\n\n\t/* These are pointers to the malloc()ed frame buffers. */\n\tunsigned char\t\trbuff[SLC_MTU];\t/* receiver buffer\t     */\n\tint\t\t\trcount;         /* received chars counter    */\n\tunsigned char\t\txbuff[SLC_MTU];\t/* transmitter buffer\t     */\n\tunsigned char\t\t*xhead;         /* pointer to next XMIT byte */\n\tint\t\t\txleft;          /* bytes left in XMIT queue  */\n\n\tunsigned long\t\tflags;\t\t/* Flag values/ mode etc     */\n#define SLF_INUSE\t\t0\t\t/* Channel in use            */\n#define SLF_ERROR\t\t1               /* Parity, etc. error        */\n};\n\nstatic struct net_device **slcan_devs;\n\n /************************************************************************\n  *\t\t\tSLCAN ENCAPSULATION FORMAT\t\t\t *\n  ************************************************************************/\n\n/*\n * A CAN frame has a can_id (11 bit standard frame format OR 29 bit extended\n * frame format) a data length code (can_dlc) which can be from 0 to 8\n * and up to <can_dlc> data bytes as payload.\n * Additionally a CAN frame may become a remote transmission frame if the\n * RTR-bit is set. This causes another ECU to send a CAN frame with the\n * given can_id.\n *\n * The SLCAN ASCII representation of these different frame types is:\n * <type> <id> <dlc> <data>*\n *\n * Extended frames (29 bit) are defined by capital characters in the type.\n * RTR frames are defined as 'r' types - normal frames have 't' type:\n * t => 11 bit data frame\n * r => 11 bit RTR frame\n * T => 29 bit data frame\n * R => 29 bit RTR frame\n *\n * The <id> is 3 (standard) or 8 (extended) bytes in ASCII Hex (base64).\n * The <dlc> is a one byte ASCII number ('0' - '8')\n * The <data> section has at much ASCII Hex bytes as defined by the <dlc>\n *\n * Examples:\n *\n * t1230 : can_id 0x123, can_dlc 0, no data\n * t4563112233 : can_id 0x456, can_dlc 3, data 0x11 0x22 0x33\n * T12ABCDEF2AA55 : extended can_id 0x12ABCDEF, can_dlc 2, data 0xAA 0x55\n * r1230 : can_id 0x123, can_dlc 0, no data, remote transmission request\n *\n */\n\n /************************************************************************\n  *\t\t\tSTANDARD SLCAN DECAPSULATION\t\t\t *\n  ************************************************************************/\n\n/* Send one completely decapsulated can_frame to the network layer */\nstatic void slc_bump(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tcf.can_id = 0;\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 't':\n\t\t/* store dlc ASCII value and terminate SFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 'T':\n\t\tcf.can_id |= CAN_EFF_FLAG;\n\t\t/* store dlc ASCII value and terminate EFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n\t\treturn;\n\n\tcf.can_id |= tmpid;\n\n\t/* get can_dlc from sanitized ASCII value */\n\tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n\t\tcf.can_dlc -= '0';\n\telse\n\t\treturn;\n\n\t*(u64 *) (&cf.data) = 0; /* clear payload */\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf.can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf.can_dlc; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] |= tmp;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(sizeof(struct can_frame) +\n\t\t\t    sizeof(struct can_skb_priv));\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = sl->dev;\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tskb_put_data(skb, &cf, sizeof(struct can_frame));\n\n\tsl->dev->stats.rx_packets++;\n\tsl->dev->stats.rx_bytes += cf.can_dlc;\n\tnetif_rx_ni(skb);\n}\n\n/* parse tty input stream */\nstatic void slcan_unesc(struct slcan *sl, unsigned char s)\n{\n\tif ((s == '\\r') || (s == '\\a')) { /* CR or BEL ends the pdu */\n\t\tif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\n\t\t    (sl->rcount > 4))  {\n\t\t\tslc_bump(sl);\n\t\t}\n\t\tsl->rcount = 0;\n\t} else {\n\t\tif (!test_bit(SLF_ERROR, &sl->flags))  {\n\t\t\tif (sl->rcount < SLC_MTU)  {\n\t\t\t\tsl->rbuff[sl->rcount++] = s;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tsl->dev->stats.rx_over_errors++;\n\t\t\t\tset_bit(SLF_ERROR, &sl->flags);\n\t\t\t}\n\t\t}\n\t}\n}\n\n /************************************************************************\n  *\t\t\tSTANDARD SLCAN ENCAPSULATION\t\t\t *\n  ************************************************************************/\n\n/* Encapsulate one can_frame and stuff into a TTY queue. */\nstatic void slc_encaps(struct slcan *sl, struct can_frame *cf)\n{\n\tint actual, i;\n\tunsigned char *pos;\n\tunsigned char *endpos;\n\tcanid_t id = cf->can_id;\n\n\tpos = sl->xbuff;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t*pos = 'R'; /* becomes 'r' in standard frame format (SFF) */\n\telse\n\t\t*pos = 'T'; /* becomes 't' in standard frame format (SSF) */\n\n\t/* determine number of chars for the CAN-identifier */\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tid &= CAN_EFF_MASK;\n\t\tendpos = pos + SLC_EFF_ID_LEN;\n\t} else {\n\t\t*pos |= 0x20; /* convert R/T to lower case for SFF */\n\t\tid &= CAN_SFF_MASK;\n\t\tendpos = pos + SLC_SFF_ID_LEN;\n\t}\n\n\t/* build 3 (SFF) or 8 (EFF) digit CAN identifier */\n\tpos++;\n\twhile (endpos >= pos) {\n\t\t*endpos-- = hex_asc_upper[id & 0xf];\n\t\tid >>= 4;\n\t}\n\n\tpos += (cf->can_id & CAN_EFF_FLAG) ? SLC_EFF_ID_LEN : SLC_SFF_ID_LEN;\n\n\t*pos++ = cf->can_dlc + '0';\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf->can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf->can_dlc; i++)\n\t\t\tpos = hex_byte_pack_upper(pos, cf->data[i]);\n\t}\n\n\t*pos++ = '\\r';\n\n\t/* Order of next two lines is *very* important.\n\t * When we are sending a little amount of data,\n\t * the transfer may be completed inside the ops->write()\n\t * routine, because it's running with interrupts enabled.\n\t * In this case we *never* got WRITE_WAKEUP event,\n\t * if we did not request it before write operation.\n\t *       14 Oct 1994  Dmitry Gorodchanin.\n\t */\n\tset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tactual = sl->tty->ops->write(sl->tty, sl->xbuff, pos - sl->xbuff);\n\tsl->xleft = (pos - sl->xbuff) - actual;\n\tsl->xhead = sl->xbuff + actual;\n\tsl->dev->stats.tx_bytes += cf->can_dlc;\n}\n\n/* Write out any remaining transmit buffer. Scheduled when tty is writable */\nstatic void slcan_transmit(struct work_struct *work)\n{\n\tstruct slcan *sl = container_of(work, struct slcan, tx_work);\n\tint actual;\n\n\tspin_lock_bh(&sl->lock);\n\t/* First make sure we're connected. */\n\tif (!sl->tty || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev)) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn;\n\t}\n\n\tif (sl->xleft <= 0)  {\n\t\t/* Now serial buffer is almost free & we can start\n\t\t * transmission of another packet */\n\t\tsl->dev->stats.tx_packets++;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t\tspin_unlock_bh(&sl->lock);\n\t\tnetif_wake_queue(sl->dev);\n\t\treturn;\n\t}\n\n\tactual = sl->tty->ops->write(sl->tty, sl->xhead, sl->xleft);\n\tsl->xleft -= actual;\n\tsl->xhead += actual;\n\tspin_unlock_bh(&sl->lock);\n}\n\n/*\n * Called by the driver when there's room for more data.\n * Schedule the transmit.\n */\nstatic void slcan_write_wakeup(struct tty_struct *tty)\n{\n\tstruct slcan *sl;\n\n\trcu_read_lock();\n\tsl = rcu_dereference(tty->disc_data);\n\tif (sl)\n\t\tschedule_work(&sl->tx_work);\n\trcu_read_unlock();\n}\n\n/* Send a can_frame to a TTY queue. */\nstatic netdev_tx_t slc_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\n\tif (skb->len != CAN_MTU)\n\t\tgoto out;\n\n\tspin_lock(&sl->lock);\n\tif (!netif_running(dev))  {\n\t\tspin_unlock(&sl->lock);\n\t\tprintk(KERN_WARNING \"%s: xmit: iface is down\\n\", dev->name);\n\t\tgoto out;\n\t}\n\tif (sl->tty == NULL) {\n\t\tspin_unlock(&sl->lock);\n\t\tgoto out;\n\t}\n\n\tnetif_stop_queue(sl->dev);\n\tslc_encaps(sl, (struct can_frame *) skb->data); /* encaps & send */\n\tspin_unlock(&sl->lock);\n\nout:\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n/******************************************\n *   Routines looking at netdevice side.\n ******************************************/\n\n/* Netdevice UP -> DOWN routine */\nstatic int slc_close(struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\n\tspin_lock_bh(&sl->lock);\n\tif (sl->tty) {\n\t\t/* TTY discipline is running. */\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t}\n\tnetif_stop_queue(dev);\n\tsl->rcount   = 0;\n\tsl->xleft    = 0;\n\tspin_unlock_bh(&sl->lock);\n\n\treturn 0;\n}\n\n/* Netdevice DOWN -> UP routine */\nstatic int slc_open(struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\n\tif (sl->tty == NULL)\n\t\treturn -ENODEV;\n\n\tsl->flags &= (1 << SLF_INUSE);\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n/* Hook the destructor so we can free slcan devs at the right point in time */\nstatic void slc_free_netdev(struct net_device *dev)\n{\n\tint i = dev->base_addr;\n\n\tslcan_devs[i] = NULL;\n}\n\nstatic int slcan_change_mtu(struct net_device *dev, int new_mtu)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct net_device_ops slc_netdev_ops = {\n\t.ndo_open               = slc_open,\n\t.ndo_stop               = slc_close,\n\t.ndo_start_xmit         = slc_xmit,\n\t.ndo_change_mtu         = slcan_change_mtu,\n};\n\nstatic void slc_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &slc_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= slc_free_netdev;\n\n\tdev->hard_header_len\t= 0;\n\tdev->addr_len\t\t= 0;\n\tdev->tx_queue_len\t= 10;\n\n\tdev->mtu\t\t= CAN_MTU;\n\tdev->type\t\t= ARPHRD_CAN;\n\n\t/* New-style flags. */\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->features           = NETIF_F_HW_CSUM;\n}\n\n/******************************************\n  Routines looking at TTY side.\n ******************************************/\n\n/*\n * Handle the 'receiver data ready' interrupt.\n * This function is called by the 'tty_io' module in the kernel when\n * a block of SLCAN data has been received, which can now be decapsulated\n * and sent on to some IP layer for further processing. This will not\n * be re-entered while running but other ldisc functions may be called\n * in parallel\n */\n\nstatic void slcan_receive_buf(struct tty_struct *tty,\n\t\t\t      const unsigned char *cp, char *fp, int count)\n{\n\tstruct slcan *sl = (struct slcan *) tty->disc_data;\n\n\tif (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev))\n\t\treturn;\n\n\t/* Read the characters out of the buffer */\n\twhile (count--) {\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SLF_ERROR, &sl->flags))\n\t\t\t\tsl->dev->stats.rx_errors++;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tslcan_unesc(sl, *cp++);\n\t}\n}\n\n/************************************\n *  slcan_open helper routines.\n ************************************/\n\n/* Collect hanged up channels */\nstatic void slc_sync(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slcan\t  *sl;\n\n\tfor (i = 0; i < maxdev; i++) {\n\t\tdev = slcan_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty)\n\t\t\tcontinue;\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_close(dev);\n\t}\n}\n\n/* Find a free SLCAN channel, and link in this `tty' line. */\nstatic struct slcan *slc_alloc(void)\n{\n\tint i;\n\tchar name[IFNAMSIZ];\n\tstruct net_device *dev = NULL;\n\tstruct slcan       *sl;\n\tint size;\n\n\tfor (i = 0; i < maxdev; i++) {\n\t\tdev = slcan_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\n\t}\n\n\t/* Sorry, too many, all slots in use */\n\tif (i >= maxdev)\n\t\treturn NULL;\n\n\tsprintf(name, \"slcan%d\", i);\n\tsize = ALIGN(sizeof(*sl), NETDEV_ALIGN) + sizeof(struct can_ml_priv);\n\tdev = alloc_netdev(size, name, NET_NAME_UNKNOWN, slc_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->base_addr  = i;\n\tsl = netdev_priv(dev);\n\tdev->ml_priv = (void *)sl + ALIGN(sizeof(*sl), NETDEV_ALIGN);\n\n\t/* Initialize channel control data */\n\tsl->magic = SLCAN_MAGIC;\n\tsl->dev\t= dev;\n\tspin_lock_init(&sl->lock);\n\tINIT_WORK(&sl->tx_work, slcan_transmit);\n\tslcan_devs[i] = dev;\n\n\treturn sl;\n}\n\n/*\n * Open the high-level part of the SLCAN channel.\n * This function is called by the TTY module when the\n * SLCAN line discipline is called for.  Because we are\n * sure the tty line exists, we only have to link it to\n * a free SLCAN channel...\n *\n * Called in process context serialized from other ldisc calls.\n */\n\nstatic int slcan_open(struct tty_struct *tty)\n{\n\tstruct slcan *sl;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* RTnetlink lock is misused here to serialize concurrent\n\t   opens of slcan channels. There are better ways, but it is\n\t   the simplest one.\n\t */\n\trtnl_lock();\n\n\t/* Collect hanged up channels. */\n\tslc_sync();\n\n\tsl = tty->disc_data;\n\n\terr = -EEXIST;\n\t/* First make sure we're not already connected. */\n\tif (sl && sl->magic == SLCAN_MAGIC)\n\t\tgoto err_exit;\n\n\t/* OK.  Find a free SLCAN channel to use. */\n\terr = -ENFILE;\n\tsl = slc_alloc();\n\tif (sl == NULL)\n\t\tgoto err_exit;\n\n\tsl->tty = tty;\n\ttty->disc_data = sl;\n\n\tif (!test_bit(SLF_INUSE, &sl->flags)) {\n\t\t/* Perform the low-level SLCAN initialization. */\n\t\tsl->rcount   = 0;\n\t\tsl->xleft    = 0;\n\n\t\tset_bit(SLF_INUSE, &sl->flags);\n\n\t\terr = register_netdevice(sl->dev);\n\t\tif (err)\n\t\t\tgoto err_free_chan;\n\t}\n\n\t/* Done.  We have linked the TTY line to a channel. */\n\trtnl_unlock();\n\ttty->receive_room = 65536;\t/* We don't flow control */\n\n\t/* TTY layer expects 0 on success */\n\treturn 0;\n\nerr_free_chan:\n\tsl->tty = NULL;\n\ttty->disc_data = NULL;\n\tclear_bit(SLF_INUSE, &sl->flags);\n\tslc_free_netdev(sl->dev);\n\t/* do not call free_netdev before rtnl_unlock */\n\trtnl_unlock();\n\tfree_netdev(sl->dev);\n\treturn err;\n\nerr_exit:\n\trtnl_unlock();\n\n\t/* Count references from TTY module */\n\treturn err;\n}\n\n/*\n * Close down a SLCAN channel.\n * This means flushing out any pending queues, and then returning. This\n * call is serialized against other ldisc functions.\n *\n * We also use this method for a hangup event.\n */\n\nstatic void slcan_close(struct tty_struct *tty)\n{\n\tstruct slcan *sl = (struct slcan *) tty->disc_data;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLCAN_MAGIC || sl->tty != tty)\n\t\treturn;\n\n\tspin_lock_bh(&sl->lock);\n\trcu_assign_pointer(tty->disc_data, NULL);\n\tsl->tty = NULL;\n\tspin_unlock_bh(&sl->lock);\n\n\tsynchronize_rcu();\n\tflush_work(&sl->tx_work);\n\n\t/* Flush network side */\n\tunregister_netdev(sl->dev);\n\t/* This will complete via sl_free_netdev */\n}\n\nstatic int slcan_hangup(struct tty_struct *tty)\n{\n\tslcan_close(tty);\n\treturn 0;\n}\n\n/* Perform I/O control on an active SLCAN channel. */\nstatic int slcan_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct slcan *sl = (struct slcan *) tty->disc_data;\n\tunsigned int tmp;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLCAN_MAGIC)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGIFNAME:\n\t\ttmp = strlen(sl->dev->name) + 1;\n\t\tif (copy_to_user((void __user *)arg, sl->dev->name, tmp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCSIFHWADDR:\n\t\treturn -EINVAL;\n\n\tdefault:\n\t\treturn tty_mode_ioctl(tty, file, cmd, arg);\n\t}\n}\n\nstatic struct tty_ldisc_ops slc_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.magic\t\t= TTY_LDISC_MAGIC,\n\t.name\t\t= \"slcan\",\n\t.open\t\t= slcan_open,\n\t.close\t\t= slcan_close,\n\t.hangup\t\t= slcan_hangup,\n\t.ioctl\t\t= slcan_ioctl,\n\t.receive_buf\t= slcan_receive_buf,\n\t.write_wakeup\t= slcan_write_wakeup,\n};\n\nstatic int __init slcan_init(void)\n{\n\tint status;\n\n\tif (maxdev < 4)\n\t\tmaxdev = 4; /* Sanity */\n\n\tpr_info(\"slcan: serial line CAN interface driver\\n\");\n\tpr_info(\"slcan: %d dynamic interface channels.\\n\", maxdev);\n\n\tslcan_devs = kcalloc(maxdev, sizeof(struct net_device *), GFP_KERNEL);\n\tif (!slcan_devs)\n\t\treturn -ENOMEM;\n\n\t/* Fill in our line protocol discipline, and register it */\n\tstatus = tty_register_ldisc(N_SLCAN, &slc_ldisc);\n\tif (status)  {\n\t\tprintk(KERN_ERR \"slcan: can't register line discipline\\n\");\n\t\tkfree(slcan_devs);\n\t}\n\treturn status;\n}\n\nstatic void __exit slcan_exit(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slcan *sl;\n\tunsigned long timeout = jiffies + HZ;\n\tint busy = 0;\n\n\tif (slcan_devs == NULL)\n\t\treturn;\n\n\t/* First of all: check for active disciplines and hangup them.\n\t */\n\tdo {\n\t\tif (busy)\n\t\t\tmsleep_interruptible(100);\n\n\t\tbusy = 0;\n\t\tfor (i = 0; i < maxdev; i++) {\n\t\t\tdev = slcan_devs[i];\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\t\t\tsl = netdev_priv(dev);\n\t\t\tspin_lock_bh(&sl->lock);\n\t\t\tif (sl->tty) {\n\t\t\t\tbusy++;\n\t\t\t\ttty_hangup(sl->tty);\n\t\t\t}\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t}\n\t} while (busy && time_before(jiffies, timeout));\n\n\t/* FIXME: hangup is async so we should wait when doing this second\n\t   phase */\n\n\tfor (i = 0; i < maxdev; i++) {\n\t\tdev = slcan_devs[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tslcan_devs[i] = NULL;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty) {\n\t\t\tprintk(KERN_ERR \"%s: tty discipline still running\\n\",\n\t\t\t       dev->name);\n\t\t}\n\n\t\tunregister_netdev(dev);\n\t}\n\n\tkfree(slcan_devs);\n\tslcan_devs = NULL;\n\n\ti = tty_unregister_ldisc(N_SLCAN);\n\tif (i)\n\t\tprintk(KERN_ERR \"slcan: can't unregister ldisc (err %d)\\n\", i);\n}\n\nmodule_init(slcan_init);\nmodule_exit(slcan_exit);\n"], "fixing_code": ["/*\n * slcan.c - serial line CAN interface driver (using tty line discipline)\n *\n * This file is derived from linux/drivers/net/slip/slip.c\n *\n * slip.c Authors  : Laurence Culhane <loz@holmes.demon.co.uk>\n *                   Fred N. van Kempen <waltje@uwalt.nl.mugnet.org>\n * slcan.c Author  : Oliver Hartkopp <socketcan@hartkopp.net>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, see http://www.gnu.org/licenses/gpl.html\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n */\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/can.h>\n#include <linux/can/skb.h>\n#include <linux/can/can-ml.h>\n\nMODULE_ALIAS_LDISC(N_SLCAN);\nMODULE_DESCRIPTION(\"serial line CAN interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <socketcan@hartkopp.net>\");\n\n#define SLCAN_MAGIC 0x53CA\n\nstatic int maxdev = 10;\t\t/* MAX number of SLCAN channels;\n\t\t\t\t   This can be overridden with\n\t\t\t\t   insmod slcan.ko maxdev=nnn\t*/\nmodule_param(maxdev, int, 0);\nMODULE_PARM_DESC(maxdev, \"Maximum number of slcan interfaces\");\n\n/* maximum rx buffer len: extended CAN frame with timestamp */\n#define SLC_MTU (sizeof(\"T1111222281122334455667788EA5F\\r\")+1)\n\n#define SLC_CMD_LEN 1\n#define SLC_SFF_ID_LEN 3\n#define SLC_EFF_ID_LEN 8\n\nstruct slcan {\n\tint\t\t\tmagic;\n\n\t/* Various fields. */\n\tstruct tty_struct\t*tty;\t\t/* ptr to TTY structure\t     */\n\tstruct net_device\t*dev;\t\t/* easy for intr handling    */\n\tspinlock_t\t\tlock;\n\tstruct work_struct\ttx_work;\t/* Flushes transmit buffer   */\n\n\t/* These are pointers to the malloc()ed frame buffers. */\n\tunsigned char\t\trbuff[SLC_MTU];\t/* receiver buffer\t     */\n\tint\t\t\trcount;         /* received chars counter    */\n\tunsigned char\t\txbuff[SLC_MTU];\t/* transmitter buffer\t     */\n\tunsigned char\t\t*xhead;         /* pointer to next XMIT byte */\n\tint\t\t\txleft;          /* bytes left in XMIT queue  */\n\n\tunsigned long\t\tflags;\t\t/* Flag values/ mode etc     */\n#define SLF_INUSE\t\t0\t\t/* Channel in use            */\n#define SLF_ERROR\t\t1               /* Parity, etc. error        */\n};\n\nstatic struct net_device **slcan_devs;\n\n /************************************************************************\n  *\t\t\tSLCAN ENCAPSULATION FORMAT\t\t\t *\n  ************************************************************************/\n\n/*\n * A CAN frame has a can_id (11 bit standard frame format OR 29 bit extended\n * frame format) a data length code (can_dlc) which can be from 0 to 8\n * and up to <can_dlc> data bytes as payload.\n * Additionally a CAN frame may become a remote transmission frame if the\n * RTR-bit is set. This causes another ECU to send a CAN frame with the\n * given can_id.\n *\n * The SLCAN ASCII representation of these different frame types is:\n * <type> <id> <dlc> <data>*\n *\n * Extended frames (29 bit) are defined by capital characters in the type.\n * RTR frames are defined as 'r' types - normal frames have 't' type:\n * t => 11 bit data frame\n * r => 11 bit RTR frame\n * T => 29 bit data frame\n * R => 29 bit RTR frame\n *\n * The <id> is 3 (standard) or 8 (extended) bytes in ASCII Hex (base64).\n * The <dlc> is a one byte ASCII number ('0' - '8')\n * The <data> section has at much ASCII Hex bytes as defined by the <dlc>\n *\n * Examples:\n *\n * t1230 : can_id 0x123, can_dlc 0, no data\n * t4563112233 : can_id 0x456, can_dlc 3, data 0x11 0x22 0x33\n * T12ABCDEF2AA55 : extended can_id 0x12ABCDEF, can_dlc 2, data 0xAA 0x55\n * r1230 : can_id 0x123, can_dlc 0, no data, remote transmission request\n *\n */\n\n /************************************************************************\n  *\t\t\tSTANDARD SLCAN DECAPSULATION\t\t\t *\n  ************************************************************************/\n\n/* Send one completely decapsulated can_frame to the network layer */\nstatic void slc_bump(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 't':\n\t\t/* store dlc ASCII value and terminate SFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 'T':\n\t\tcf.can_id |= CAN_EFF_FLAG;\n\t\t/* store dlc ASCII value and terminate EFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n\t\treturn;\n\n\tcf.can_id |= tmpid;\n\n\t/* get can_dlc from sanitized ASCII value */\n\tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n\t\tcf.can_dlc -= '0';\n\telse\n\t\treturn;\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf.can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf.can_dlc; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] |= tmp;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(sizeof(struct can_frame) +\n\t\t\t    sizeof(struct can_skb_priv));\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = sl->dev;\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tskb_put_data(skb, &cf, sizeof(struct can_frame));\n\n\tsl->dev->stats.rx_packets++;\n\tsl->dev->stats.rx_bytes += cf.can_dlc;\n\tnetif_rx_ni(skb);\n}\n\n/* parse tty input stream */\nstatic void slcan_unesc(struct slcan *sl, unsigned char s)\n{\n\tif ((s == '\\r') || (s == '\\a')) { /* CR or BEL ends the pdu */\n\t\tif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\n\t\t    (sl->rcount > 4))  {\n\t\t\tslc_bump(sl);\n\t\t}\n\t\tsl->rcount = 0;\n\t} else {\n\t\tif (!test_bit(SLF_ERROR, &sl->flags))  {\n\t\t\tif (sl->rcount < SLC_MTU)  {\n\t\t\t\tsl->rbuff[sl->rcount++] = s;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tsl->dev->stats.rx_over_errors++;\n\t\t\t\tset_bit(SLF_ERROR, &sl->flags);\n\t\t\t}\n\t\t}\n\t}\n}\n\n /************************************************************************\n  *\t\t\tSTANDARD SLCAN ENCAPSULATION\t\t\t *\n  ************************************************************************/\n\n/* Encapsulate one can_frame and stuff into a TTY queue. */\nstatic void slc_encaps(struct slcan *sl, struct can_frame *cf)\n{\n\tint actual, i;\n\tunsigned char *pos;\n\tunsigned char *endpos;\n\tcanid_t id = cf->can_id;\n\n\tpos = sl->xbuff;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t*pos = 'R'; /* becomes 'r' in standard frame format (SFF) */\n\telse\n\t\t*pos = 'T'; /* becomes 't' in standard frame format (SSF) */\n\n\t/* determine number of chars for the CAN-identifier */\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tid &= CAN_EFF_MASK;\n\t\tendpos = pos + SLC_EFF_ID_LEN;\n\t} else {\n\t\t*pos |= 0x20; /* convert R/T to lower case for SFF */\n\t\tid &= CAN_SFF_MASK;\n\t\tendpos = pos + SLC_SFF_ID_LEN;\n\t}\n\n\t/* build 3 (SFF) or 8 (EFF) digit CAN identifier */\n\tpos++;\n\twhile (endpos >= pos) {\n\t\t*endpos-- = hex_asc_upper[id & 0xf];\n\t\tid >>= 4;\n\t}\n\n\tpos += (cf->can_id & CAN_EFF_FLAG) ? SLC_EFF_ID_LEN : SLC_SFF_ID_LEN;\n\n\t*pos++ = cf->can_dlc + '0';\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf->can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf->can_dlc; i++)\n\t\t\tpos = hex_byte_pack_upper(pos, cf->data[i]);\n\t}\n\n\t*pos++ = '\\r';\n\n\t/* Order of next two lines is *very* important.\n\t * When we are sending a little amount of data,\n\t * the transfer may be completed inside the ops->write()\n\t * routine, because it's running with interrupts enabled.\n\t * In this case we *never* got WRITE_WAKEUP event,\n\t * if we did not request it before write operation.\n\t *       14 Oct 1994  Dmitry Gorodchanin.\n\t */\n\tset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tactual = sl->tty->ops->write(sl->tty, sl->xbuff, pos - sl->xbuff);\n\tsl->xleft = (pos - sl->xbuff) - actual;\n\tsl->xhead = sl->xbuff + actual;\n\tsl->dev->stats.tx_bytes += cf->can_dlc;\n}\n\n/* Write out any remaining transmit buffer. Scheduled when tty is writable */\nstatic void slcan_transmit(struct work_struct *work)\n{\n\tstruct slcan *sl = container_of(work, struct slcan, tx_work);\n\tint actual;\n\n\tspin_lock_bh(&sl->lock);\n\t/* First make sure we're connected. */\n\tif (!sl->tty || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev)) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn;\n\t}\n\n\tif (sl->xleft <= 0)  {\n\t\t/* Now serial buffer is almost free & we can start\n\t\t * transmission of another packet */\n\t\tsl->dev->stats.tx_packets++;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t\tspin_unlock_bh(&sl->lock);\n\t\tnetif_wake_queue(sl->dev);\n\t\treturn;\n\t}\n\n\tactual = sl->tty->ops->write(sl->tty, sl->xhead, sl->xleft);\n\tsl->xleft -= actual;\n\tsl->xhead += actual;\n\tspin_unlock_bh(&sl->lock);\n}\n\n/*\n * Called by the driver when there's room for more data.\n * Schedule the transmit.\n */\nstatic void slcan_write_wakeup(struct tty_struct *tty)\n{\n\tstruct slcan *sl;\n\n\trcu_read_lock();\n\tsl = rcu_dereference(tty->disc_data);\n\tif (sl)\n\t\tschedule_work(&sl->tx_work);\n\trcu_read_unlock();\n}\n\n/* Send a can_frame to a TTY queue. */\nstatic netdev_tx_t slc_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\n\tif (skb->len != CAN_MTU)\n\t\tgoto out;\n\n\tspin_lock(&sl->lock);\n\tif (!netif_running(dev))  {\n\t\tspin_unlock(&sl->lock);\n\t\tprintk(KERN_WARNING \"%s: xmit: iface is down\\n\", dev->name);\n\t\tgoto out;\n\t}\n\tif (sl->tty == NULL) {\n\t\tspin_unlock(&sl->lock);\n\t\tgoto out;\n\t}\n\n\tnetif_stop_queue(sl->dev);\n\tslc_encaps(sl, (struct can_frame *) skb->data); /* encaps & send */\n\tspin_unlock(&sl->lock);\n\nout:\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n/******************************************\n *   Routines looking at netdevice side.\n ******************************************/\n\n/* Netdevice UP -> DOWN routine */\nstatic int slc_close(struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\n\tspin_lock_bh(&sl->lock);\n\tif (sl->tty) {\n\t\t/* TTY discipline is running. */\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t}\n\tnetif_stop_queue(dev);\n\tsl->rcount   = 0;\n\tsl->xleft    = 0;\n\tspin_unlock_bh(&sl->lock);\n\n\treturn 0;\n}\n\n/* Netdevice DOWN -> UP routine */\nstatic int slc_open(struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\n\tif (sl->tty == NULL)\n\t\treturn -ENODEV;\n\n\tsl->flags &= (1 << SLF_INUSE);\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n/* Hook the destructor so we can free slcan devs at the right point in time */\nstatic void slc_free_netdev(struct net_device *dev)\n{\n\tint i = dev->base_addr;\n\n\tslcan_devs[i] = NULL;\n}\n\nstatic int slcan_change_mtu(struct net_device *dev, int new_mtu)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct net_device_ops slc_netdev_ops = {\n\t.ndo_open               = slc_open,\n\t.ndo_stop               = slc_close,\n\t.ndo_start_xmit         = slc_xmit,\n\t.ndo_change_mtu         = slcan_change_mtu,\n};\n\nstatic void slc_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &slc_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= slc_free_netdev;\n\n\tdev->hard_header_len\t= 0;\n\tdev->addr_len\t\t= 0;\n\tdev->tx_queue_len\t= 10;\n\n\tdev->mtu\t\t= CAN_MTU;\n\tdev->type\t\t= ARPHRD_CAN;\n\n\t/* New-style flags. */\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->features           = NETIF_F_HW_CSUM;\n}\n\n/******************************************\n  Routines looking at TTY side.\n ******************************************/\n\n/*\n * Handle the 'receiver data ready' interrupt.\n * This function is called by the 'tty_io' module in the kernel when\n * a block of SLCAN data has been received, which can now be decapsulated\n * and sent on to some IP layer for further processing. This will not\n * be re-entered while running but other ldisc functions may be called\n * in parallel\n */\n\nstatic void slcan_receive_buf(struct tty_struct *tty,\n\t\t\t      const unsigned char *cp, char *fp, int count)\n{\n\tstruct slcan *sl = (struct slcan *) tty->disc_data;\n\n\tif (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev))\n\t\treturn;\n\n\t/* Read the characters out of the buffer */\n\twhile (count--) {\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SLF_ERROR, &sl->flags))\n\t\t\t\tsl->dev->stats.rx_errors++;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tslcan_unesc(sl, *cp++);\n\t}\n}\n\n/************************************\n *  slcan_open helper routines.\n ************************************/\n\n/* Collect hanged up channels */\nstatic void slc_sync(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slcan\t  *sl;\n\n\tfor (i = 0; i < maxdev; i++) {\n\t\tdev = slcan_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty)\n\t\t\tcontinue;\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_close(dev);\n\t}\n}\n\n/* Find a free SLCAN channel, and link in this `tty' line. */\nstatic struct slcan *slc_alloc(void)\n{\n\tint i;\n\tchar name[IFNAMSIZ];\n\tstruct net_device *dev = NULL;\n\tstruct slcan       *sl;\n\tint size;\n\n\tfor (i = 0; i < maxdev; i++) {\n\t\tdev = slcan_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\n\t}\n\n\t/* Sorry, too many, all slots in use */\n\tif (i >= maxdev)\n\t\treturn NULL;\n\n\tsprintf(name, \"slcan%d\", i);\n\tsize = ALIGN(sizeof(*sl), NETDEV_ALIGN) + sizeof(struct can_ml_priv);\n\tdev = alloc_netdev(size, name, NET_NAME_UNKNOWN, slc_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->base_addr  = i;\n\tsl = netdev_priv(dev);\n\tdev->ml_priv = (void *)sl + ALIGN(sizeof(*sl), NETDEV_ALIGN);\n\n\t/* Initialize channel control data */\n\tsl->magic = SLCAN_MAGIC;\n\tsl->dev\t= dev;\n\tspin_lock_init(&sl->lock);\n\tINIT_WORK(&sl->tx_work, slcan_transmit);\n\tslcan_devs[i] = dev;\n\n\treturn sl;\n}\n\n/*\n * Open the high-level part of the SLCAN channel.\n * This function is called by the TTY module when the\n * SLCAN line discipline is called for.  Because we are\n * sure the tty line exists, we only have to link it to\n * a free SLCAN channel...\n *\n * Called in process context serialized from other ldisc calls.\n */\n\nstatic int slcan_open(struct tty_struct *tty)\n{\n\tstruct slcan *sl;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* RTnetlink lock is misused here to serialize concurrent\n\t   opens of slcan channels. There are better ways, but it is\n\t   the simplest one.\n\t */\n\trtnl_lock();\n\n\t/* Collect hanged up channels. */\n\tslc_sync();\n\n\tsl = tty->disc_data;\n\n\terr = -EEXIST;\n\t/* First make sure we're not already connected. */\n\tif (sl && sl->magic == SLCAN_MAGIC)\n\t\tgoto err_exit;\n\n\t/* OK.  Find a free SLCAN channel to use. */\n\terr = -ENFILE;\n\tsl = slc_alloc();\n\tif (sl == NULL)\n\t\tgoto err_exit;\n\n\tsl->tty = tty;\n\ttty->disc_data = sl;\n\n\tif (!test_bit(SLF_INUSE, &sl->flags)) {\n\t\t/* Perform the low-level SLCAN initialization. */\n\t\tsl->rcount   = 0;\n\t\tsl->xleft    = 0;\n\n\t\tset_bit(SLF_INUSE, &sl->flags);\n\n\t\terr = register_netdevice(sl->dev);\n\t\tif (err)\n\t\t\tgoto err_free_chan;\n\t}\n\n\t/* Done.  We have linked the TTY line to a channel. */\n\trtnl_unlock();\n\ttty->receive_room = 65536;\t/* We don't flow control */\n\n\t/* TTY layer expects 0 on success */\n\treturn 0;\n\nerr_free_chan:\n\tsl->tty = NULL;\n\ttty->disc_data = NULL;\n\tclear_bit(SLF_INUSE, &sl->flags);\n\tslc_free_netdev(sl->dev);\n\t/* do not call free_netdev before rtnl_unlock */\n\trtnl_unlock();\n\tfree_netdev(sl->dev);\n\treturn err;\n\nerr_exit:\n\trtnl_unlock();\n\n\t/* Count references from TTY module */\n\treturn err;\n}\n\n/*\n * Close down a SLCAN channel.\n * This means flushing out any pending queues, and then returning. This\n * call is serialized against other ldisc functions.\n *\n * We also use this method for a hangup event.\n */\n\nstatic void slcan_close(struct tty_struct *tty)\n{\n\tstruct slcan *sl = (struct slcan *) tty->disc_data;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLCAN_MAGIC || sl->tty != tty)\n\t\treturn;\n\n\tspin_lock_bh(&sl->lock);\n\trcu_assign_pointer(tty->disc_data, NULL);\n\tsl->tty = NULL;\n\tspin_unlock_bh(&sl->lock);\n\n\tsynchronize_rcu();\n\tflush_work(&sl->tx_work);\n\n\t/* Flush network side */\n\tunregister_netdev(sl->dev);\n\t/* This will complete via sl_free_netdev */\n}\n\nstatic int slcan_hangup(struct tty_struct *tty)\n{\n\tslcan_close(tty);\n\treturn 0;\n}\n\n/* Perform I/O control on an active SLCAN channel. */\nstatic int slcan_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct slcan *sl = (struct slcan *) tty->disc_data;\n\tunsigned int tmp;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLCAN_MAGIC)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGIFNAME:\n\t\ttmp = strlen(sl->dev->name) + 1;\n\t\tif (copy_to_user((void __user *)arg, sl->dev->name, tmp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCSIFHWADDR:\n\t\treturn -EINVAL;\n\n\tdefault:\n\t\treturn tty_mode_ioctl(tty, file, cmd, arg);\n\t}\n}\n\nstatic struct tty_ldisc_ops slc_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.magic\t\t= TTY_LDISC_MAGIC,\n\t.name\t\t= \"slcan\",\n\t.open\t\t= slcan_open,\n\t.close\t\t= slcan_close,\n\t.hangup\t\t= slcan_hangup,\n\t.ioctl\t\t= slcan_ioctl,\n\t.receive_buf\t= slcan_receive_buf,\n\t.write_wakeup\t= slcan_write_wakeup,\n};\n\nstatic int __init slcan_init(void)\n{\n\tint status;\n\n\tif (maxdev < 4)\n\t\tmaxdev = 4; /* Sanity */\n\n\tpr_info(\"slcan: serial line CAN interface driver\\n\");\n\tpr_info(\"slcan: %d dynamic interface channels.\\n\", maxdev);\n\n\tslcan_devs = kcalloc(maxdev, sizeof(struct net_device *), GFP_KERNEL);\n\tif (!slcan_devs)\n\t\treturn -ENOMEM;\n\n\t/* Fill in our line protocol discipline, and register it */\n\tstatus = tty_register_ldisc(N_SLCAN, &slc_ldisc);\n\tif (status)  {\n\t\tprintk(KERN_ERR \"slcan: can't register line discipline\\n\");\n\t\tkfree(slcan_devs);\n\t}\n\treturn status;\n}\n\nstatic void __exit slcan_exit(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slcan *sl;\n\tunsigned long timeout = jiffies + HZ;\n\tint busy = 0;\n\n\tif (slcan_devs == NULL)\n\t\treturn;\n\n\t/* First of all: check for active disciplines and hangup them.\n\t */\n\tdo {\n\t\tif (busy)\n\t\t\tmsleep_interruptible(100);\n\n\t\tbusy = 0;\n\t\tfor (i = 0; i < maxdev; i++) {\n\t\t\tdev = slcan_devs[i];\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\t\t\tsl = netdev_priv(dev);\n\t\t\tspin_lock_bh(&sl->lock);\n\t\t\tif (sl->tty) {\n\t\t\t\tbusy++;\n\t\t\t\ttty_hangup(sl->tty);\n\t\t\t}\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t}\n\t} while (busy && time_before(jiffies, timeout));\n\n\t/* FIXME: hangup is async so we should wait when doing this second\n\t   phase */\n\n\tfor (i = 0; i < maxdev; i++) {\n\t\tdev = slcan_devs[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tslcan_devs[i] = NULL;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty) {\n\t\t\tprintk(KERN_ERR \"%s: tty discipline still running\\n\",\n\t\t\t       dev->name);\n\t\t}\n\n\t\tunregister_netdev(dev);\n\t}\n\n\tkfree(slcan_devs);\n\tslcan_devs = NULL;\n\n\ti = tty_unregister_ldisc(N_SLCAN);\n\tif (i)\n\t\tprintk(KERN_ERR \"slcan: can't unregister ldisc (err %d)\\n\", i);\n}\n\nmodule_init(slcan_init);\nmodule_exit(slcan_exit);\n"], "filenames": ["drivers/net/can/slcan.c"], "buggy_code_start_loc": [151], "buggy_code_end_loc": [192], "fixing_code_start_loc": [151], "fixing_code_end_loc": [189], "type": "CWE-908", "message": "An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4.", "other": {"cve": {"id": "CVE-2020-11494", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-02T21:15:13.613", "lastModified": "2022-04-29T13:26:22.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4."}, {"lang": "es", "value": "Se detect\u00f3 un problema en la funci\u00f3n slc_bump en el archivo drivers/net/can/slcan.c en el kernel de Linux versi\u00f3n 3.16 hasta la versi\u00f3n 5.6.2. Permite a atacantes leer datos de can_frame no inicializados, conteniendo potencialmente informaci\u00f3n confidencial de la memoria de la pila del kernel, si la configuraci\u00f3n carece de CONFIG_INIT_STACK_ALL, tambi\u00e9n se conoce como CID-b9258a2cece4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}, {"lang": "en", "value": "CWE-909"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.16", "versionEndIncluding": "5.6.2", "matchCriteriaId": "60BE7542-AEBA-426E-8C70-3F1635B2D871"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-04/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/159565/Kernel-Live-Patch-Security-Notice-LSN-0072-1.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=08fadc32ce6239dc75fd5e869590e29bc62bbc28", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b9258a2cece4ec1f020715fe3554bc2e360f6264", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200430-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4363-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4364-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4368-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4369-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b9258a2cece4ec1f020715fe3554bc2e360f6264"}}