{"buggy_code": ["// Package exec can execute commands on the OS.\npackage exec\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\n\t\"github.com/caarlos0/go-shellwords\"\n\t\"github.com/caarlos0/log\"\n\t\"github.com/goreleaser/goreleaser/internal/artifact\"\n\t\"github.com/goreleaser/goreleaser/internal/extrafiles\"\n\t\"github.com/goreleaser/goreleaser/internal/gio\"\n\t\"github.com/goreleaser/goreleaser/internal/logext\"\n\t\"github.com/goreleaser/goreleaser/internal/pipe\"\n\t\"github.com/goreleaser/goreleaser/internal/semerrgroup\"\n\t\"github.com/goreleaser/goreleaser/internal/tmpl\"\n\t\"github.com/goreleaser/goreleaser/pkg/config\"\n\t\"github.com/goreleaser/goreleaser/pkg/context\"\n)\n\n// Environment variables to pass through to exec\nvar passthroughEnvVars = []string{\"HOME\", \"USER\", \"USERPROFILE\", \"TMPDIR\", \"TMP\", \"TEMP\", \"PATH\"}\n\n// Execute the given publisher\nfunc Execute(ctx *context.Context, publishers []config.Publisher) error {\n\tskips := pipe.SkipMemento{}\n\tfor _, p := range publishers {\n\t\tlog.WithField(\"name\", p.Name).Debug(\"executing custom publisher\")\n\t\terr := executePublisher(ctx, p)\n\t\tif err != nil && pipe.IsSkip(err) {\n\t\t\tskips.Remember(err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn skips.Evaluate()\n}\n\nfunc executePublisher(ctx *context.Context, publisher config.Publisher) error {\n\tdisabled, err := tmpl.New(ctx).Bool(publisher.Disable)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif disabled {\n\t\treturn pipe.Skip(\"publisher is disabled\")\n\t}\n\n\tlog.Debugf(\"filtering %d artifacts\", len(ctx.Artifacts.List()))\n\tartifacts := filterArtifacts(ctx.Artifacts, publisher)\n\n\textraFiles, err := extrafiles.Find(ctx, publisher.ExtraFiles)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor name, path := range extraFiles {\n\t\tartifacts = append(artifacts, &artifact.Artifact{\n\t\t\tName: name,\n\t\t\tPath: path,\n\t\t\tType: artifact.UploadableFile,\n\t\t})\n\t}\n\n\tlog.Debugf(\"will execute custom publisher with %d artifacts\", len(artifacts))\n\n\tg := semerrgroup.New(ctx.Parallelism)\n\tfor _, artifact := range artifacts {\n\t\tartifact := artifact\n\t\tg.Go(func() error {\n\t\t\tc, err := resolveCommand(ctx, publisher, artifact)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn executeCommand(c, artifact)\n\t\t})\n\t}\n\n\treturn g.Wait()\n}\n\nfunc executeCommand(c *command, artifact *artifact.Artifact) error {\n\tlog.WithField(\"args\", c.Args).\n\t\tWithField(\"env\", c.Env).\n\t\tWithField(\"artifact\", artifact.Name).\n\t\tDebug(\"executing command\")\n\n\t// nolint: gosec\n\tcmd := exec.CommandContext(c.Ctx, c.Args[0], c.Args[1:]...)\n\tcmd.Env = []string{}\n\tfor _, key := range passthroughEnvVars {\n\t\tif value := os.Getenv(key); value != \"\" {\n\t\t\tcmd.Env = append(cmd.Env, key+\"=\"+value)\n\t\t}\n\t}\n\tcmd.Env = append(cmd.Env, c.Env...)\n\n\tif c.Dir != \"\" {\n\t\tcmd.Dir = c.Dir\n\t}\n\n\tvar b bytes.Buffer\n\tw := gio.Safe(&b)\n\tcmd.Stderr = io.MultiWriter(logext.NewWriter(), w)\n\tcmd.Stdout = io.MultiWriter(logext.NewWriter(), w)\n\n\tlog := log.WithField(\"cmd\", c.Args[0]).\n\t\tWithField(\"artifact\", artifact.Name)\n\n\tlog.Info(\"publishing\")\n\tif err := cmd.Run(); err != nil {\n\t\treturn fmt.Errorf(\"publishing: %s failed: %w: %s\", c.Args[0], err, b.String())\n\t}\n\n\tlog.Debug(\"command finished successfully\")\n\treturn nil\n}\n\nfunc filterArtifacts(artifacts *artifact.Artifacts, publisher config.Publisher) []*artifact.Artifact {\n\tfilters := []artifact.Filter{\n\t\tartifact.ByType(artifact.UploadableArchive),\n\t\tartifact.ByType(artifact.UploadableFile),\n\t\tartifact.ByType(artifact.LinuxPackage),\n\t\tartifact.ByType(artifact.UploadableBinary),\n\t\tartifact.ByType(artifact.DockerImage),\n\t\tartifact.ByType(artifact.DockerManifest),\n\t}\n\n\tif publisher.Checksum {\n\t\tfilters = append(filters, artifact.ByType(artifact.Checksum))\n\t}\n\n\tif publisher.Signature {\n\t\tfilters = append(filters, artifact.ByType(artifact.Signature), artifact.ByType(artifact.Certificate))\n\t}\n\n\tfilter := artifact.Or(filters...)\n\n\tif len(publisher.IDs) > 0 {\n\t\tfilter = artifact.And(filter, artifact.ByIDs(publisher.IDs...))\n\t}\n\n\treturn artifacts.Filter(filter).List()\n}\n\ntype command struct {\n\tCtx  *context.Context\n\tDir  string\n\tEnv  []string\n\tArgs []string\n}\n\n// resolveCommand returns the a command based on publisher template with replaced variables\n// Those variables can be replaced by the given context, goos, goarch, goarm and more.\nfunc resolveCommand(ctx *context.Context, publisher config.Publisher, artifact *artifact.Artifact) (*command, error) {\n\tvar err error\n\tdir := publisher.Dir\n\n\t// nolint:staticcheck\n\ttpl := tmpl.New(ctx).WithArtifact(artifact)\n\tif dir != \"\" {\n\t\tdir, err = tpl.Apply(dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tcmd := publisher.Cmd\n\tif cmd != \"\" {\n\t\tcmd, err = tpl.Apply(cmd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\targs, err := shellwords.Parse(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tenv := make([]string, len(publisher.Env))\n\tfor i, e := range publisher.Env {\n\t\te, err = tpl.Apply(e)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tenv[i] = e\n\t}\n\n\treturn &command{\n\t\tCtx:  ctx,\n\t\tDir:  dir,\n\t\tEnv:  env,\n\t\tArgs: args,\n\t}, nil\n}\n", "package sbom\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/caarlos0/log\"\n\t\"github.com/goreleaser/goreleaser/internal/artifact\"\n\t\"github.com/goreleaser/goreleaser/internal/gio\"\n\t\"github.com/goreleaser/goreleaser/internal/ids\"\n\t\"github.com/goreleaser/goreleaser/internal/logext\"\n\t\"github.com/goreleaser/goreleaser/internal/semerrgroup\"\n\t\"github.com/goreleaser/goreleaser/internal/skips\"\n\t\"github.com/goreleaser/goreleaser/internal/tmpl\"\n\t\"github.com/goreleaser/goreleaser/pkg/config\"\n\t\"github.com/goreleaser/goreleaser/pkg/context\"\n)\n\n// Environment variables to pass through to exec\nvar passthroughEnvVars = []string{\"HOME\", \"USER\", \"USERPROFILE\", \"TMPDIR\", \"TMP\", \"TEMP\", \"PATH\", \"LOCALAPPDATA\"}\n\n// Pipe that catalogs common artifacts as an SBOM.\ntype Pipe struct{}\n\nfunc (Pipe) String() string { return \"cataloging artifacts\" }\nfunc (Pipe) Skip(ctx *context.Context) bool {\n\treturn skips.Any(ctx, skips.SBOM) || len(ctx.Config.SBOMs) == 0\n}\n\nfunc (Pipe) Dependencies(ctx *context.Context) []string {\n\tvar cmds []string\n\tfor _, s := range ctx.Config.SBOMs {\n\t\tcmds = append(cmds, s.Cmd)\n\t}\n\treturn cmds\n}\n\n// Default sets the Pipes defaults.\nfunc (Pipe) Default(ctx *context.Context) error {\n\tids := ids.New(\"sboms\")\n\tfor i := range ctx.Config.SBOMs {\n\t\tcfg := &ctx.Config.SBOMs[i]\n\t\tif err := setConfigDefaults(cfg); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tids.Inc(cfg.ID)\n\t}\n\treturn ids.Validate()\n}\n\nfunc setConfigDefaults(cfg *config.SBOM) error {\n\tif cfg.Cmd == \"\" {\n\t\tcfg.Cmd = \"syft\"\n\t}\n\tif cfg.Artifacts == \"\" {\n\t\tcfg.Artifacts = \"archive\"\n\t}\n\tif len(cfg.Documents) == 0 {\n\t\tswitch cfg.Artifacts {\n\t\tcase \"binary\":\n\t\t\tcfg.Documents = []string{\"{{ .Binary }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}.sbom\"}\n\t\tcase \"any\":\n\t\t\tcfg.Documents = []string{}\n\t\tdefault:\n\t\t\tcfg.Documents = []string{\"{{ .ArtifactName }}.sbom\"}\n\t\t}\n\t}\n\tif cfg.Cmd == \"syft\" {\n\t\tif len(cfg.Args) == 0 {\n\t\t\tcfg.Args = []string{\"$artifact\", \"--output\", \"spdx-json=$document\"}\n\t\t}\n\t\tif len(cfg.Env) == 0 && (cfg.Artifacts == \"source\" || cfg.Artifacts == \"archive\") {\n\t\t\tcfg.Env = []string{\n\t\t\t\t\"SYFT_FILE_METADATA_CATALOGER_ENABLED=true\",\n\t\t\t}\n\t\t}\n\t}\n\tif cfg.ID == \"\" {\n\t\tcfg.ID = \"default\"\n\t}\n\n\tif cfg.Artifacts != \"any\" && len(cfg.Documents) > 1 {\n\t\treturn fmt.Errorf(\"multiple SBOM outputs when artifacts=%q is unsupported\", cfg.Artifacts)\n\t}\n\treturn nil\n}\n\n// Run executes the Pipe.\nfunc (Pipe) Run(ctx *context.Context) error {\n\tg := semerrgroup.New(ctx.Parallelism)\n\tfor _, cfg := range ctx.Config.SBOMs {\n\t\tg.Go(catalogTask(ctx, cfg))\n\t}\n\treturn g.Wait()\n}\n\nfunc catalogTask(ctx *context.Context, cfg config.SBOM) func() error {\n\treturn func() error {\n\t\tvar filters []artifact.Filter\n\t\tswitch cfg.Artifacts {\n\t\tcase \"source\":\n\t\t\tfilters = append(filters, artifact.ByType(artifact.UploadableSourceArchive))\n\t\t\tif len(cfg.IDs) > 0 {\n\t\t\t\tlog.Warn(\"when artifacts is `source`, `ids` has no effect. ignoring\")\n\t\t\t}\n\t\tcase \"archive\":\n\t\t\tfilters = append(filters, artifact.ByType(artifact.UploadableArchive))\n\t\tcase \"binary\":\n\t\t\tfilters = append(filters, artifact.ByBinaryLikeArtifacts(ctx.Artifacts))\n\t\tcase \"package\":\n\t\t\tfilters = append(filters, artifact.ByType(artifact.LinuxPackage))\n\t\tcase \"any\":\n\t\t\tnewArtifacts, err := catalogArtifact(ctx, cfg, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor _, newArtifact := range newArtifacts {\n\t\t\t\tctx.Artifacts.Add(newArtifact)\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid list of artifacts to catalog: %s\", cfg.Artifacts)\n\t\t}\n\n\t\tif len(cfg.IDs) > 0 {\n\t\t\tfilters = append(filters, artifact.ByIDs(cfg.IDs...))\n\t\t}\n\t\tartifacts := ctx.Artifacts.Filter(artifact.And(filters...)).List()\n\t\tif len(artifacts) == 0 {\n\t\t\tlog.Warn(\"no artifacts matching current filters\")\n\t\t}\n\t\treturn catalog(ctx, cfg, artifacts)\n\t}\n}\n\nfunc catalog(ctx *context.Context, cfg config.SBOM, artifacts []*artifact.Artifact) error {\n\tfor _, a := range artifacts {\n\t\tnewArtifacts, err := catalogArtifact(ctx, cfg, a)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, newArtifact := range newArtifacts {\n\t\t\tctx.Artifacts.Add(newArtifact)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc subprocessDistPath(distDir string, pathRelativeToCwd string) (string, error) {\n\tdistDir = filepath.Clean(distDir)\n\tpathRelativeToCwd = filepath.Clean(pathRelativeToCwd)\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif !filepath.IsAbs(distDir) {\n\t\tdistDir, err = filepath.Abs(distDir)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\trelativePath, err := filepath.Rel(cwd, distDir)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn strings.TrimPrefix(pathRelativeToCwd, relativePath+string(filepath.Separator)), nil\n}\n\nfunc catalogArtifact(ctx *context.Context, cfg config.SBOM, a *artifact.Artifact) ([]*artifact.Artifact, error) {\n\tartifactDisplayName := \"(any)\"\n\targs, envs, paths, err := applyTemplate(ctx, cfg, a)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cataloging artifacts failed: %w\", err)\n\t}\n\n\tif a != nil {\n\t\tartifactDisplayName = a.Path\n\t}\n\n\tvar names []string\n\tfor _, p := range paths {\n\t\tnames = append(names, filepath.Base(p))\n\t}\n\n\t// The GoASTScanner flags this as a security risk.\n\t// However, this works as intended. The nosec annotation\n\t// tells the scanner to ignore this.\n\t// #nosec\n\tcmd := exec.CommandContext(ctx, cfg.Cmd, args...)\n\tcmd.Env = []string{}\n\tfor _, key := range passthroughEnvVars {\n\t\tif value := os.Getenv(key); value != \"\" {\n\t\t\tcmd.Env = append(cmd.Env, fmt.Sprintf(\"%s=%s\", key, value))\n\t\t}\n\t}\n\tcmd.Env = append(cmd.Env, envs...)\n\tcmd.Dir = ctx.Config.Dist\n\n\tlog.WithField(\"env\", cmd.Env).\n\t\tWithField(\"dir\", cmd.Dir).\n\t\tWithField(\"cmd\", cmd.Args).\n\t\tDebug(\"running\")\n\n\tvar b bytes.Buffer\n\tw := gio.Safe(&b)\n\tcmd.Stderr = io.MultiWriter(logext.NewWriter(), w)\n\tcmd.Stdout = io.MultiWriter(logext.NewWriter(), w)\n\n\tlog.WithField(\"cmd\", cfg.Cmd).\n\t\tWithField(\"artifact\", artifactDisplayName).\n\t\tWithField(\"sbom\", names).\n\t\tInfo(\"cataloging\")\n\tif err := cmd.Run(); err != nil {\n\t\treturn nil, fmt.Errorf(\"cataloging artifacts: %s failed: %w: %s\", cfg.Cmd, err, b.String())\n\t}\n\n\tvar artifacts []*artifact.Artifact\n\n\tfor _, path := range paths {\n\t\tif !filepath.IsAbs(path) {\n\t\t\tpath = filepath.Join(ctx.Config.Dist, path)\n\t\t}\n\n\t\tmatches, err := filepath.Glob(path)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cataloging artifacts: failed to find SBOM artifact %q: %w\", path, err)\n\t\t}\n\t\tfor _, match := range matches {\n\t\t\tartifacts = append(artifacts, &artifact.Artifact{\n\t\t\t\tType: artifact.SBOM,\n\t\t\t\tName: filepath.Base(path),\n\t\t\t\tPath: match,\n\t\t\t\tExtra: map[string]interface{}{\n\t\t\t\t\tartifact.ExtraID: cfg.ID,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\n\t}\n\n\tif len(artifacts) == 0 {\n\t\treturn nil, fmt.Errorf(\"cataloging artifacts: command did not write any files, check your configuration\")\n\t}\n\n\treturn artifacts, nil\n}\n\nfunc applyTemplate(ctx *context.Context, cfg config.SBOM, a *artifact.Artifact) ([]string, []string, []string, error) {\n\tenv := ctx.Env.Copy()\n\tvar extraEnvs []string\n\ttemplater := tmpl.New(ctx).WithEnv(env)\n\n\tif a != nil {\n\t\tprocPath, err := subprocessDistPath(ctx.Config.Dist, a.Path)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"cataloging artifacts failed: cannot determine artifact path for %q: %w\", a.Path, err)\n\t\t}\n\t\textraEnvs = appendExtraEnv(\"artifact\", procPath, extraEnvs, env)\n\t\textraEnvs = appendExtraEnv(\"artifactID\", a.ID(), extraEnvs, env)\n\t\ttemplater = templater.WithArtifact(a)\n\t}\n\n\tfor _, keyValue := range cfg.Env {\n\t\trenderedKeyValue, err := templater.Apply(expand(keyValue, env))\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"env %q: invalid template: %w\", keyValue, err)\n\t\t}\n\t\textraEnvs = append(extraEnvs, renderedKeyValue)\n\n\t\tk, v, _ := strings.Cut(renderedKeyValue, \"=\")\n\t\tenv[k] = v\n\t}\n\n\tvar paths []string\n\tfor idx, sbom := range cfg.Documents {\n\t\tinput := expand(sbom, env)\n\t\tif !filepath.IsAbs(input) {\n\t\t\t// assume any absolute path is handled correctly and assume that any relative path is not already\n\t\t\t// adjusted to reference the dist path\n\t\t\tinput = filepath.Join(ctx.Config.Dist, input)\n\t\t}\n\n\t\tpath, err := templater.Apply(input)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"input %q: invalid template: %w\", input, err)\n\t\t}\n\n\t\tpath, err = filepath.Abs(path)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"unable to create artifact path %q: %w\", sbom, err)\n\t\t}\n\n\t\tprocPath, err := subprocessDistPath(ctx.Config.Dist, path)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"cannot determine document path for %q: %w\", path, err)\n\t\t}\n\n\t\textraEnvs = appendExtraEnv(fmt.Sprintf(\"document%d\", idx), procPath, extraEnvs, env)\n\t\tif idx == 0 {\n\t\t\textraEnvs = appendExtraEnv(\"document\", procPath, extraEnvs, env)\n\t\t}\n\n\t\tpaths = append(paths, procPath)\n\t}\n\n\t// nolint:prealloc\n\tvar args []string\n\tfor _, arg := range cfg.Args {\n\t\trenderedArg, err := templater.Apply(expand(arg, env))\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"arg %q: invalid template: %w\", arg, err)\n\t\t}\n\t\targs = append(args, renderedArg)\n\t}\n\n\treturn args, extraEnvs, paths, nil\n}\n\nfunc appendExtraEnv(key, value string, envs []string, env map[string]string) []string {\n\tenv[key] = value\n\treturn append(envs, fmt.Sprintf(\"%s=%s\", key, value))\n}\n\nfunc expand(s string, env map[string]string) string {\n\treturn os.Expand(s, func(key string) string {\n\t\treturn env[key]\n\t})\n}\n", "package shell\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"github.com/caarlos0/log\"\n\t\"github.com/charmbracelet/x/exp/ordered\"\n\t\"github.com/goreleaser/goreleaser/internal/gio\"\n\t\"github.com/goreleaser/goreleaser/internal/logext\"\n\t\"github.com/goreleaser/goreleaser/pkg/context\"\n)\n\n// Run a shell command with given arguments and envs\nfunc Run(ctx *context.Context, dir string, command, env []string, output bool) error {\n\tlog := log.\n\t\tWithField(\"cmd\", command).\n\t\tWithField(\"env\", env).\n\t\tWithField(\"dir\", dir)\n\n\t/* #nosec */\n\tcmd := exec.CommandContext(ctx, command[0], command[1:]...)\n\tcmd.Env = env\n\n\tvar b bytes.Buffer\n\tw := gio.Safe(&b)\n\n\tcmd.Stderr = io.MultiWriter(logext.NewConditionalWriter(output), w)\n\tcmd.Stdout = io.MultiWriter(logext.NewConditionalWriter(output), w)\n\n\tif dir != \"\" {\n\t\tcmd.Dir = dir\n\t}\n\n\tlog.Debug(\"running\")\n\tif err := cmd.Run(); err != nil {\n\t\treturn fmt.Errorf(\n\t\t\t\"shell: '%s': %w: %s\",\n\t\t\tstrings.Join(command, \" \"),\n\t\t\terr,\n\t\t\tordered.First(\n\t\t\t\tstrings.TrimSpace(b.String()),\n\t\t\t\t\"[no output]\",\n\t\t\t),\n\t\t)\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["// Package exec can execute commands on the OS.\npackage exec\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\n\t\"github.com/caarlos0/go-shellwords\"\n\t\"github.com/caarlos0/log\"\n\t\"github.com/goreleaser/goreleaser/internal/artifact\"\n\t\"github.com/goreleaser/goreleaser/internal/extrafiles\"\n\t\"github.com/goreleaser/goreleaser/internal/gio\"\n\t\"github.com/goreleaser/goreleaser/internal/logext\"\n\t\"github.com/goreleaser/goreleaser/internal/pipe\"\n\t\"github.com/goreleaser/goreleaser/internal/semerrgroup\"\n\t\"github.com/goreleaser/goreleaser/internal/tmpl\"\n\t\"github.com/goreleaser/goreleaser/pkg/config\"\n\t\"github.com/goreleaser/goreleaser/pkg/context\"\n)\n\n// Environment variables to pass through to exec\nvar passthroughEnvVars = []string{\"HOME\", \"USER\", \"USERPROFILE\", \"TMPDIR\", \"TMP\", \"TEMP\", \"PATH\"}\n\n// Execute the given publisher\nfunc Execute(ctx *context.Context, publishers []config.Publisher) error {\n\tskips := pipe.SkipMemento{}\n\tfor _, p := range publishers {\n\t\tlog.WithField(\"name\", p.Name).Debug(\"executing custom publisher\")\n\t\terr := executePublisher(ctx, p)\n\t\tif err != nil && pipe.IsSkip(err) {\n\t\t\tskips.Remember(err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn skips.Evaluate()\n}\n\nfunc executePublisher(ctx *context.Context, publisher config.Publisher) error {\n\tdisabled, err := tmpl.New(ctx).Bool(publisher.Disable)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif disabled {\n\t\treturn pipe.Skip(\"publisher is disabled\")\n\t}\n\n\tlog.Debugf(\"filtering %d artifacts\", len(ctx.Artifacts.List()))\n\tartifacts := filterArtifacts(ctx.Artifacts, publisher)\n\n\textraFiles, err := extrafiles.Find(ctx, publisher.ExtraFiles)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor name, path := range extraFiles {\n\t\tartifacts = append(artifacts, &artifact.Artifact{\n\t\t\tName: name,\n\t\t\tPath: path,\n\t\t\tType: artifact.UploadableFile,\n\t\t})\n\t}\n\n\tlog.Debugf(\"will execute custom publisher with %d artifacts\", len(artifacts))\n\n\tg := semerrgroup.New(ctx.Parallelism)\n\tfor _, artifact := range artifacts {\n\t\tartifact := artifact\n\t\tg.Go(func() error {\n\t\t\tc, err := resolveCommand(ctx, publisher, artifact)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn executeCommand(c, artifact)\n\t\t})\n\t}\n\n\treturn g.Wait()\n}\n\nfunc executeCommand(c *command, artifact *artifact.Artifact) error {\n\tlog.WithField(\"args\", c.Args).\n\t\tWithField(\"artifact\", artifact.Name).\n\t\tDebug(\"executing command\")\n\n\t// nolint: gosec\n\tcmd := exec.CommandContext(c.Ctx, c.Args[0], c.Args[1:]...)\n\tcmd.Env = []string{}\n\tfor _, key := range passthroughEnvVars {\n\t\tif value := os.Getenv(key); value != \"\" {\n\t\t\tcmd.Env = append(cmd.Env, key+\"=\"+value)\n\t\t}\n\t}\n\tcmd.Env = append(cmd.Env, c.Env...)\n\n\tif c.Dir != \"\" {\n\t\tcmd.Dir = c.Dir\n\t}\n\n\tvar b bytes.Buffer\n\tw := gio.Safe(&b)\n\tcmd.Stderr = io.MultiWriter(logext.NewWriter(), w)\n\tcmd.Stdout = io.MultiWriter(logext.NewWriter(), w)\n\n\tlog := log.WithField(\"cmd\", c.Args[0]).\n\t\tWithField(\"artifact\", artifact.Name)\n\n\tlog.Info(\"publishing\")\n\tif err := cmd.Run(); err != nil {\n\t\treturn fmt.Errorf(\"publishing: %s failed: %w: %s\", c.Args[0], err, b.String())\n\t}\n\n\tlog.Debug(\"command finished successfully\")\n\treturn nil\n}\n\nfunc filterArtifacts(artifacts *artifact.Artifacts, publisher config.Publisher) []*artifact.Artifact {\n\tfilters := []artifact.Filter{\n\t\tartifact.ByType(artifact.UploadableArchive),\n\t\tartifact.ByType(artifact.UploadableFile),\n\t\tartifact.ByType(artifact.LinuxPackage),\n\t\tartifact.ByType(artifact.UploadableBinary),\n\t\tartifact.ByType(artifact.DockerImage),\n\t\tartifact.ByType(artifact.DockerManifest),\n\t}\n\n\tif publisher.Checksum {\n\t\tfilters = append(filters, artifact.ByType(artifact.Checksum))\n\t}\n\n\tif publisher.Signature {\n\t\tfilters = append(filters, artifact.ByType(artifact.Signature), artifact.ByType(artifact.Certificate))\n\t}\n\n\tfilter := artifact.Or(filters...)\n\n\tif len(publisher.IDs) > 0 {\n\t\tfilter = artifact.And(filter, artifact.ByIDs(publisher.IDs...))\n\t}\n\n\treturn artifacts.Filter(filter).List()\n}\n\ntype command struct {\n\tCtx  *context.Context\n\tDir  string\n\tEnv  []string\n\tArgs []string\n}\n\n// resolveCommand returns the a command based on publisher template with replaced variables\n// Those variables can be replaced by the given context, goos, goarch, goarm and more.\nfunc resolveCommand(ctx *context.Context, publisher config.Publisher, artifact *artifact.Artifact) (*command, error) {\n\tvar err error\n\tdir := publisher.Dir\n\n\t// nolint:staticcheck\n\ttpl := tmpl.New(ctx).WithArtifact(artifact)\n\tif dir != \"\" {\n\t\tdir, err = tpl.Apply(dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tcmd := publisher.Cmd\n\tif cmd != \"\" {\n\t\tcmd, err = tpl.Apply(cmd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\targs, err := shellwords.Parse(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tenv := make([]string, len(publisher.Env))\n\tfor i, e := range publisher.Env {\n\t\te, err = tpl.Apply(e)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tenv[i] = e\n\t}\n\n\treturn &command{\n\t\tCtx:  ctx,\n\t\tDir:  dir,\n\t\tEnv:  env,\n\t\tArgs: args,\n\t}, nil\n}\n", "package sbom\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/caarlos0/log\"\n\t\"github.com/goreleaser/goreleaser/internal/artifact\"\n\t\"github.com/goreleaser/goreleaser/internal/gio\"\n\t\"github.com/goreleaser/goreleaser/internal/ids\"\n\t\"github.com/goreleaser/goreleaser/internal/logext\"\n\t\"github.com/goreleaser/goreleaser/internal/semerrgroup\"\n\t\"github.com/goreleaser/goreleaser/internal/skips\"\n\t\"github.com/goreleaser/goreleaser/internal/tmpl\"\n\t\"github.com/goreleaser/goreleaser/pkg/config\"\n\t\"github.com/goreleaser/goreleaser/pkg/context\"\n)\n\n// Environment variables to pass through to exec\nvar passthroughEnvVars = []string{\"HOME\", \"USER\", \"USERPROFILE\", \"TMPDIR\", \"TMP\", \"TEMP\", \"PATH\", \"LOCALAPPDATA\"}\n\n// Pipe that catalogs common artifacts as an SBOM.\ntype Pipe struct{}\n\nfunc (Pipe) String() string { return \"cataloging artifacts\" }\nfunc (Pipe) Skip(ctx *context.Context) bool {\n\treturn skips.Any(ctx, skips.SBOM) || len(ctx.Config.SBOMs) == 0\n}\n\nfunc (Pipe) Dependencies(ctx *context.Context) []string {\n\tvar cmds []string\n\tfor _, s := range ctx.Config.SBOMs {\n\t\tcmds = append(cmds, s.Cmd)\n\t}\n\treturn cmds\n}\n\n// Default sets the Pipes defaults.\nfunc (Pipe) Default(ctx *context.Context) error {\n\tids := ids.New(\"sboms\")\n\tfor i := range ctx.Config.SBOMs {\n\t\tcfg := &ctx.Config.SBOMs[i]\n\t\tif err := setConfigDefaults(cfg); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tids.Inc(cfg.ID)\n\t}\n\treturn ids.Validate()\n}\n\nfunc setConfigDefaults(cfg *config.SBOM) error {\n\tif cfg.Cmd == \"\" {\n\t\tcfg.Cmd = \"syft\"\n\t}\n\tif cfg.Artifacts == \"\" {\n\t\tcfg.Artifacts = \"archive\"\n\t}\n\tif len(cfg.Documents) == 0 {\n\t\tswitch cfg.Artifacts {\n\t\tcase \"binary\":\n\t\t\tcfg.Documents = []string{\"{{ .Binary }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}.sbom\"}\n\t\tcase \"any\":\n\t\t\tcfg.Documents = []string{}\n\t\tdefault:\n\t\t\tcfg.Documents = []string{\"{{ .ArtifactName }}.sbom\"}\n\t\t}\n\t}\n\tif cfg.Cmd == \"syft\" {\n\t\tif len(cfg.Args) == 0 {\n\t\t\tcfg.Args = []string{\"$artifact\", \"--output\", \"spdx-json=$document\"}\n\t\t}\n\t\tif len(cfg.Env) == 0 && (cfg.Artifacts == \"source\" || cfg.Artifacts == \"archive\") {\n\t\t\tcfg.Env = []string{\n\t\t\t\t\"SYFT_FILE_METADATA_CATALOGER_ENABLED=true\",\n\t\t\t}\n\t\t}\n\t}\n\tif cfg.ID == \"\" {\n\t\tcfg.ID = \"default\"\n\t}\n\n\tif cfg.Artifacts != \"any\" && len(cfg.Documents) > 1 {\n\t\treturn fmt.Errorf(\"multiple SBOM outputs when artifacts=%q is unsupported\", cfg.Artifacts)\n\t}\n\treturn nil\n}\n\n// Run executes the Pipe.\nfunc (Pipe) Run(ctx *context.Context) error {\n\tg := semerrgroup.New(ctx.Parallelism)\n\tfor _, cfg := range ctx.Config.SBOMs {\n\t\tg.Go(catalogTask(ctx, cfg))\n\t}\n\treturn g.Wait()\n}\n\nfunc catalogTask(ctx *context.Context, cfg config.SBOM) func() error {\n\treturn func() error {\n\t\tvar filters []artifact.Filter\n\t\tswitch cfg.Artifacts {\n\t\tcase \"source\":\n\t\t\tfilters = append(filters, artifact.ByType(artifact.UploadableSourceArchive))\n\t\t\tif len(cfg.IDs) > 0 {\n\t\t\t\tlog.Warn(\"when artifacts is `source`, `ids` has no effect. ignoring\")\n\t\t\t}\n\t\tcase \"archive\":\n\t\t\tfilters = append(filters, artifact.ByType(artifact.UploadableArchive))\n\t\tcase \"binary\":\n\t\t\tfilters = append(filters, artifact.ByBinaryLikeArtifacts(ctx.Artifacts))\n\t\tcase \"package\":\n\t\t\tfilters = append(filters, artifact.ByType(artifact.LinuxPackage))\n\t\tcase \"any\":\n\t\t\tnewArtifacts, err := catalogArtifact(ctx, cfg, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor _, newArtifact := range newArtifacts {\n\t\t\t\tctx.Artifacts.Add(newArtifact)\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid list of artifacts to catalog: %s\", cfg.Artifacts)\n\t\t}\n\n\t\tif len(cfg.IDs) > 0 {\n\t\t\tfilters = append(filters, artifact.ByIDs(cfg.IDs...))\n\t\t}\n\t\tartifacts := ctx.Artifacts.Filter(artifact.And(filters...)).List()\n\t\tif len(artifacts) == 0 {\n\t\t\tlog.Warn(\"no artifacts matching current filters\")\n\t\t}\n\t\treturn catalog(ctx, cfg, artifacts)\n\t}\n}\n\nfunc catalog(ctx *context.Context, cfg config.SBOM, artifacts []*artifact.Artifact) error {\n\tfor _, a := range artifacts {\n\t\tnewArtifacts, err := catalogArtifact(ctx, cfg, a)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, newArtifact := range newArtifacts {\n\t\t\tctx.Artifacts.Add(newArtifact)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc subprocessDistPath(distDir string, pathRelativeToCwd string) (string, error) {\n\tdistDir = filepath.Clean(distDir)\n\tpathRelativeToCwd = filepath.Clean(pathRelativeToCwd)\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif !filepath.IsAbs(distDir) {\n\t\tdistDir, err = filepath.Abs(distDir)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\trelativePath, err := filepath.Rel(cwd, distDir)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn strings.TrimPrefix(pathRelativeToCwd, relativePath+string(filepath.Separator)), nil\n}\n\nfunc catalogArtifact(ctx *context.Context, cfg config.SBOM, a *artifact.Artifact) ([]*artifact.Artifact, error) {\n\tartifactDisplayName := \"(any)\"\n\targs, envs, paths, err := applyTemplate(ctx, cfg, a)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cataloging artifacts failed: %w\", err)\n\t}\n\n\tif a != nil {\n\t\tartifactDisplayName = a.Path\n\t}\n\n\tvar names []string\n\tfor _, p := range paths {\n\t\tnames = append(names, filepath.Base(p))\n\t}\n\n\t// The GoASTScanner flags this as a security risk.\n\t// However, this works as intended. The nosec annotation\n\t// tells the scanner to ignore this.\n\t// #nosec\n\tcmd := exec.CommandContext(ctx, cfg.Cmd, args...)\n\tcmd.Env = []string{}\n\tfor _, key := range passthroughEnvVars {\n\t\tif value := os.Getenv(key); value != \"\" {\n\t\t\tcmd.Env = append(cmd.Env, fmt.Sprintf(\"%s=%s\", key, value))\n\t\t}\n\t}\n\tcmd.Env = append(cmd.Env, envs...)\n\tcmd.Dir = ctx.Config.Dist\n\n\tlog.WithField(\"dir\", cmd.Dir).\n\t\tWithField(\"cmd\", cmd.Args).\n\t\tDebug(\"running\")\n\n\tvar b bytes.Buffer\n\tw := gio.Safe(&b)\n\tcmd.Stderr = io.MultiWriter(logext.NewWriter(), w)\n\tcmd.Stdout = io.MultiWriter(logext.NewWriter(), w)\n\n\tlog.WithField(\"cmd\", cfg.Cmd).\n\t\tWithField(\"artifact\", artifactDisplayName).\n\t\tWithField(\"sbom\", names).\n\t\tInfo(\"cataloging\")\n\tif err := cmd.Run(); err != nil {\n\t\treturn nil, fmt.Errorf(\"cataloging artifacts: %s failed: %w: %s\", cfg.Cmd, err, b.String())\n\t}\n\n\tvar artifacts []*artifact.Artifact\n\n\tfor _, path := range paths {\n\t\tif !filepath.IsAbs(path) {\n\t\t\tpath = filepath.Join(ctx.Config.Dist, path)\n\t\t}\n\n\t\tmatches, err := filepath.Glob(path)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cataloging artifacts: failed to find SBOM artifact %q: %w\", path, err)\n\t\t}\n\t\tfor _, match := range matches {\n\t\t\tartifacts = append(artifacts, &artifact.Artifact{\n\t\t\t\tType: artifact.SBOM,\n\t\t\t\tName: filepath.Base(path),\n\t\t\t\tPath: match,\n\t\t\t\tExtra: map[string]interface{}{\n\t\t\t\t\tartifact.ExtraID: cfg.ID,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\n\t}\n\n\tif len(artifacts) == 0 {\n\t\treturn nil, fmt.Errorf(\"cataloging artifacts: command did not write any files, check your configuration\")\n\t}\n\n\treturn artifacts, nil\n}\n\nfunc applyTemplate(ctx *context.Context, cfg config.SBOM, a *artifact.Artifact) ([]string, []string, []string, error) {\n\tenv := ctx.Env.Copy()\n\tvar extraEnvs []string\n\ttemplater := tmpl.New(ctx).WithEnv(env)\n\n\tif a != nil {\n\t\tprocPath, err := subprocessDistPath(ctx.Config.Dist, a.Path)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"cataloging artifacts failed: cannot determine artifact path for %q: %w\", a.Path, err)\n\t\t}\n\t\textraEnvs = appendExtraEnv(\"artifact\", procPath, extraEnvs, env)\n\t\textraEnvs = appendExtraEnv(\"artifactID\", a.ID(), extraEnvs, env)\n\t\ttemplater = templater.WithArtifact(a)\n\t}\n\n\tfor _, keyValue := range cfg.Env {\n\t\trenderedKeyValue, err := templater.Apply(expand(keyValue, env))\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"env %q: invalid template: %w\", keyValue, err)\n\t\t}\n\t\textraEnvs = append(extraEnvs, renderedKeyValue)\n\n\t\tk, v, _ := strings.Cut(renderedKeyValue, \"=\")\n\t\tenv[k] = v\n\t}\n\n\tvar paths []string\n\tfor idx, sbom := range cfg.Documents {\n\t\tinput := expand(sbom, env)\n\t\tif !filepath.IsAbs(input) {\n\t\t\t// assume any absolute path is handled correctly and assume that any relative path is not already\n\t\t\t// adjusted to reference the dist path\n\t\t\tinput = filepath.Join(ctx.Config.Dist, input)\n\t\t}\n\n\t\tpath, err := templater.Apply(input)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"input %q: invalid template: %w\", input, err)\n\t\t}\n\n\t\tpath, err = filepath.Abs(path)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"unable to create artifact path %q: %w\", sbom, err)\n\t\t}\n\n\t\tprocPath, err := subprocessDistPath(ctx.Config.Dist, path)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"cannot determine document path for %q: %w\", path, err)\n\t\t}\n\n\t\textraEnvs = appendExtraEnv(fmt.Sprintf(\"document%d\", idx), procPath, extraEnvs, env)\n\t\tif idx == 0 {\n\t\t\textraEnvs = appendExtraEnv(\"document\", procPath, extraEnvs, env)\n\t\t}\n\n\t\tpaths = append(paths, procPath)\n\t}\n\n\t// nolint:prealloc\n\tvar args []string\n\tfor _, arg := range cfg.Args {\n\t\trenderedArg, err := templater.Apply(expand(arg, env))\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"arg %q: invalid template: %w\", arg, err)\n\t\t}\n\t\targs = append(args, renderedArg)\n\t}\n\n\treturn args, extraEnvs, paths, nil\n}\n\nfunc appendExtraEnv(key, value string, envs []string, env map[string]string) []string {\n\tenv[key] = value\n\treturn append(envs, fmt.Sprintf(\"%s=%s\", key, value))\n}\n\nfunc expand(s string, env map[string]string) string {\n\treturn os.Expand(s, func(key string) string {\n\t\treturn env[key]\n\t})\n}\n", "package shell\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"github.com/caarlos0/log\"\n\t\"github.com/charmbracelet/x/exp/ordered\"\n\t\"github.com/goreleaser/goreleaser/internal/gio\"\n\t\"github.com/goreleaser/goreleaser/internal/logext\"\n\t\"github.com/goreleaser/goreleaser/pkg/context\"\n)\n\n// Run a shell command with given arguments and envs\nfunc Run(ctx *context.Context, dir string, command, env []string, output bool) error {\n\tlog := log.\n\t\tWithField(\"cmd\", command).\n\t\tWithField(\"dir\", dir)\n\n\t/* #nosec */\n\tcmd := exec.CommandContext(ctx, command[0], command[1:]...)\n\tcmd.Env = env\n\n\tvar b bytes.Buffer\n\tw := gio.Safe(&b)\n\n\tcmd.Stderr = io.MultiWriter(logext.NewConditionalWriter(output), w)\n\tcmd.Stdout = io.MultiWriter(logext.NewConditionalWriter(output), w)\n\n\tif dir != \"\" {\n\t\tcmd.Dir = dir\n\t}\n\n\tlog.Debug(\"running\")\n\tif err := cmd.Run(); err != nil {\n\t\treturn fmt.Errorf(\n\t\t\t\"shell: '%s': %w: %s\",\n\t\t\tstrings.Join(command, \" \"),\n\t\t\terr,\n\t\t\tordered.First(\n\t\t\t\tstrings.TrimSpace(b.String()),\n\t\t\t\t\"[no output]\",\n\t\t\t),\n\t\t)\n\t}\n\n\treturn nil\n}\n"], "filenames": ["internal/exec/exec.go", "internal/pipe/sbom/sbom.go", "internal/shell/shell.go"], "buggy_code_start_loc": [89, 204, 21], "buggy_code_end_loc": [90, 206, 22], "fixing_code_start_loc": [88, 204, 20], "fixing_code_end_loc": [88, 205, 20], "type": "CWE-532", "message": "GoReleaser builds Go binaries for several platforms, creates a GitHub release and then pushes a Homebrew formula to a tap repository. `goreleaser release --debug` log shows secret values used in the in the custom publisher. This vulnerability is fixed in 1.24.0.", "other": {"cve": {"id": "CVE-2024-23840", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-30T17:15:11.810", "lastModified": "2024-02-05T20:56:21.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GoReleaser builds Go binaries for several platforms, creates a GitHub release and then pushes a Homebrew formula to a tap repository. `goreleaser release --debug` log shows secret values used in the in the custom publisher. This vulnerability is fixed in 1.24.0."}, {"lang": "es", "value": "GoReleaser crea archivos binarios de Go para varias plataformas, crea una versi\u00f3n de GitHub y luego env\u00eda una f\u00f3rmula Homebrew a un repositorio tap. El registro `goreleaser release --debug` muestra los valores secretos utilizados en el editor personalizado. Esta vulnerabilidad se solucion\u00f3 en 1.24.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:goreleaser:goreleaser:1.23.0:*:*:*:*:go:*:*", "matchCriteriaId": "876998FE-22A3-446E-ADF8-0C5BF63A1F96"}]}]}], "references": [{"url": "https://github.com/goreleaser/goreleaser/commit/d5b6a533ca1dc3366983d5d31ee2d2b6232b83c0", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/goreleaser/goreleaser/security/advisories/GHSA-h3q2-8whx-c29h", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/goreleaser/goreleaser/commit/d5b6a533ca1dc3366983d5d31ee2d2b6232b83c0"}}