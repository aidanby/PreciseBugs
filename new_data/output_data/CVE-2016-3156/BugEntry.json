{"buggy_code": ["/*\n *\tNET3\tIP device support routines.\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\tDerived from the IP parts of dev.c 1.0.19\n * \t\tAuthors:\tRoss Biro\n *\t\t\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\t\t\tMark Evans, <evansmp@uhura.aston.ac.uk>\n *\n *\tAdditional Authors:\n *\t\tAlan Cox, <gw4pts@gw4pts.ampr.org>\n *\t\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n *\tChanges:\n *\t\tAlexey Kuznetsov:\tpa_* fields are replaced with ifaddr\n *\t\t\t\t\tlists.\n *\t\tCyrus Durgin:\t\tupdated for kmod\n *\t\tMatthias Andree:\tin devinet_ioctl, compare label and\n *\t\t\t\t\taddress (4.4BSD alias style support),\n *\t\t\t\t\tfall back to comparing just the label\n *\t\t\t\t\tif no match found.\n */\n\n\n#include <asm/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/if_addr.h>\n#include <linux/if_ether.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/notifier.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n#include <linux/kmod.h>\n#include <linux/netconf.h>\n\n#include <net/arp.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/ip_fib.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/addrconf.h>\n\n#include \"fib_lookup.h\"\n\nstatic struct ipv4_devconf ipv4_devconf = {\n\t.data = {\n\t\t[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SEND_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SECURE_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,\n\t\t[IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL - 1] = 10000 /*ms*/,\n\t\t[IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL - 1] =  1000 /*ms*/,\n\t},\n};\n\nstatic struct ipv4_devconf ipv4_devconf_dflt = {\n\t.data = {\n\t\t[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SEND_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SECURE_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,\n\t\t[IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE - 1] = 1,\n\t\t[IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL - 1] = 10000 /*ms*/,\n\t\t[IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL - 1] =  1000 /*ms*/,\n\t},\n};\n\n#define IPV4_DEVCONF_DFLT(net, attr) \\\n\tIPV4_DEVCONF((*net->ipv4.devconf_dflt), attr)\n\nstatic const struct nla_policy ifa_ipv4_policy[IFA_MAX+1] = {\n\t[IFA_LOCAL]     \t= { .type = NLA_U32 },\n\t[IFA_ADDRESS]   \t= { .type = NLA_U32 },\n\t[IFA_BROADCAST] \t= { .type = NLA_U32 },\n\t[IFA_LABEL]     \t= { .type = NLA_STRING, .len = IFNAMSIZ - 1 },\n\t[IFA_CACHEINFO]\t\t= { .len = sizeof(struct ifa_cacheinfo) },\n\t[IFA_FLAGS]\t\t= { .type = NLA_U32 },\n};\n\n#define IN4_ADDR_HSIZE_SHIFT\t8\n#define IN4_ADDR_HSIZE\t\t(1U << IN4_ADDR_HSIZE_SHIFT)\n\nstatic struct hlist_head inet_addr_lst[IN4_ADDR_HSIZE];\n\nstatic u32 inet_addr_hash(const struct net *net, __be32 addr)\n{\n\tu32 val = (__force u32) addr ^ net_hash_mix(net);\n\n\treturn hash_32(val, IN4_ADDR_HSIZE_SHIFT);\n}\n\nstatic void inet_hash_insert(struct net *net, struct in_ifaddr *ifa)\n{\n\tu32 hash = inet_addr_hash(net, ifa->ifa_local);\n\n\tASSERT_RTNL();\n\thlist_add_head_rcu(&ifa->hash, &inet_addr_lst[hash]);\n}\n\nstatic void inet_hash_remove(struct in_ifaddr *ifa)\n{\n\tASSERT_RTNL();\n\thlist_del_init_rcu(&ifa->hash);\n}\n\n/**\n * __ip_dev_find - find the first device with a given source address.\n * @net: the net namespace\n * @addr: the source address\n * @devref: if true, take a reference on the found device\n *\n * If a caller uses devref=false, it should be protected by RCU, or RTNL\n */\nstruct net_device *__ip_dev_find(struct net *net, __be32 addr, bool devref)\n{\n\tu32 hash = inet_addr_hash(net, addr);\n\tstruct net_device *result = NULL;\n\tstruct in_ifaddr *ifa;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(ifa, &inet_addr_lst[hash], hash) {\n\t\tif (ifa->ifa_local == addr) {\n\t\t\tstruct net_device *dev = ifa->ifa_dev->dev;\n\n\t\t\tif (!net_eq(dev_net(dev), net))\n\t\t\t\tcontinue;\n\t\t\tresult = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result) {\n\t\tstruct flowi4 fl4 = { .daddr = addr };\n\t\tstruct fib_result res = { 0 };\n\t\tstruct fib_table *local;\n\n\t\t/* Fallback to FIB local table so that communication\n\t\t * over loopback subnets work.\n\t\t */\n\t\tlocal = fib_get_table(net, RT_TABLE_LOCAL);\n\t\tif (local &&\n\t\t    !fib_table_lookup(local, &fl4, &res, FIB_LOOKUP_NOREF) &&\n\t\t    res.type == RTN_LOCAL)\n\t\t\tresult = FIB_RES_DEV(res);\n\t}\n\tif (result && devref)\n\t\tdev_hold(result);\n\trcu_read_unlock();\n\treturn result;\n}\nEXPORT_SYMBOL(__ip_dev_find);\n\nstatic void rtmsg_ifa(int event, struct in_ifaddr *, struct nlmsghdr *, u32);\n\nstatic BLOCKING_NOTIFIER_HEAD(inetaddr_chain);\nstatic void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n\t\t\t int destroy);\n#ifdef CONFIG_SYSCTL\nstatic int devinet_sysctl_register(struct in_device *idev);\nstatic void devinet_sysctl_unregister(struct in_device *idev);\n#else\nstatic int devinet_sysctl_register(struct in_device *idev)\n{\n\treturn 0;\n}\nstatic void devinet_sysctl_unregister(struct in_device *idev)\n{\n}\n#endif\n\n/* Locks all the inet devices. */\n\nstatic struct in_ifaddr *inet_alloc_ifa(void)\n{\n\treturn kzalloc(sizeof(struct in_ifaddr), GFP_KERNEL);\n}\n\nstatic void inet_rcu_free_ifa(struct rcu_head *head)\n{\n\tstruct in_ifaddr *ifa = container_of(head, struct in_ifaddr, rcu_head);\n\tif (ifa->ifa_dev)\n\t\tin_dev_put(ifa->ifa_dev);\n\tkfree(ifa);\n}\n\nstatic void inet_free_ifa(struct in_ifaddr *ifa)\n{\n\tcall_rcu(&ifa->rcu_head, inet_rcu_free_ifa);\n}\n\nvoid in_dev_finish_destroy(struct in_device *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\n\tWARN_ON(idev->ifa_list);\n\tWARN_ON(idev->mc_list);\n\tkfree(rcu_dereference_protected(idev->mc_hash, 1));\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %p=%s\\n\", __func__, idev, dev ? dev->name : \"NIL\");\n#endif\n\tdev_put(dev);\n\tif (!idev->dead)\n\t\tpr_err(\"Freeing alive in_device %p\\n\", idev);\n\telse\n\t\tkfree(idev);\n}\nEXPORT_SYMBOL(in_dev_finish_destroy);\n\nstatic struct in_device *inetdev_init(struct net_device *dev)\n{\n\tstruct in_device *in_dev;\n\tint err = -ENOMEM;\n\n\tASSERT_RTNL();\n\n\tin_dev = kzalloc(sizeof(*in_dev), GFP_KERNEL);\n\tif (!in_dev)\n\t\tgoto out;\n\tmemcpy(&in_dev->cnf, dev_net(dev)->ipv4.devconf_dflt,\n\t\t\tsizeof(in_dev->cnf));\n\tin_dev->cnf.sysctl = NULL;\n\tin_dev->dev = dev;\n\tin_dev->arp_parms = neigh_parms_alloc(dev, &arp_tbl);\n\tif (!in_dev->arp_parms)\n\t\tgoto out_kfree;\n\tif (IPV4_DEVCONF(in_dev->cnf, FORWARDING))\n\t\tdev_disable_lro(dev);\n\t/* Reference in_dev->dev */\n\tdev_hold(dev);\n\t/* Account for reference dev->ip_ptr (below) */\n\tin_dev_hold(in_dev);\n\n\terr = devinet_sysctl_register(in_dev);\n\tif (err) {\n\t\tin_dev->dead = 1;\n\t\tin_dev_put(in_dev);\n\t\tin_dev = NULL;\n\t\tgoto out;\n\t}\n\tip_mc_init_dev(in_dev);\n\tif (dev->flags & IFF_UP)\n\t\tip_mc_up(in_dev);\n\n\t/* we can receive as soon as ip_ptr is set -- do this last */\n\trcu_assign_pointer(dev->ip_ptr, in_dev);\nout:\n\treturn in_dev ?: ERR_PTR(err);\nout_kfree:\n\tkfree(in_dev);\n\tin_dev = NULL;\n\tgoto out;\n}\n\nstatic void in_dev_rcu_put(struct rcu_head *head)\n{\n\tstruct in_device *idev = container_of(head, struct in_device, rcu_head);\n\tin_dev_put(idev);\n}\n\nstatic void inetdev_destroy(struct in_device *in_dev)\n{\n\tstruct in_ifaddr *ifa;\n\tstruct net_device *dev;\n\n\tASSERT_RTNL();\n\n\tdev = in_dev->dev;\n\n\tin_dev->dead = 1;\n\n\tip_mc_destroy_dev(in_dev);\n\n\twhile ((ifa = in_dev->ifa_list) != NULL) {\n\t\tinet_del_ifa(in_dev, &in_dev->ifa_list, 0);\n\t\tinet_free_ifa(ifa);\n\t}\n\n\tRCU_INIT_POINTER(dev->ip_ptr, NULL);\n\n\tdevinet_sysctl_unregister(in_dev);\n\tneigh_parms_release(&arp_tbl, in_dev->arp_parms);\n\tarp_ifdown(dev);\n\n\tcall_rcu(&in_dev->rcu_head, in_dev_rcu_put);\n}\n\nint inet_addr_onlink(struct in_device *in_dev, __be32 a, __be32 b)\n{\n\trcu_read_lock();\n\tfor_primary_ifa(in_dev) {\n\t\tif (inet_ifa_match(a, ifa)) {\n\t\t\tif (!b || inet_ifa_match(b, ifa)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} endfor_ifa(in_dev);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n\t\t\t int destroy, struct nlmsghdr *nlh, u32 portid)\n{\n\tstruct in_ifaddr *promote = NULL;\n\tstruct in_ifaddr *ifa, *ifa1 = *ifap;\n\tstruct in_ifaddr *last_prim = in_dev->ifa_list;\n\tstruct in_ifaddr *prev_prom = NULL;\n\tint do_promote = IN_DEV_PROMOTE_SECONDARIES(in_dev);\n\n\tASSERT_RTNL();\n\n\t/* 1. Deleting primary ifaddr forces deletion all secondaries\n\t * unless alias promotion is set\n\t **/\n\n\tif (!(ifa1->ifa_flags & IFA_F_SECONDARY)) {\n\t\tstruct in_ifaddr **ifap1 = &ifa1->ifa_next;\n\n\t\twhile ((ifa = *ifap1) != NULL) {\n\t\t\tif (!(ifa->ifa_flags & IFA_F_SECONDARY) &&\n\t\t\t    ifa1->ifa_scope <= ifa->ifa_scope)\n\t\t\t\tlast_prim = ifa;\n\n\t\t\tif (!(ifa->ifa_flags & IFA_F_SECONDARY) ||\n\t\t\t    ifa1->ifa_mask != ifa->ifa_mask ||\n\t\t\t    !inet_ifa_match(ifa1->ifa_address, ifa)) {\n\t\t\t\tifap1 = &ifa->ifa_next;\n\t\t\t\tprev_prom = ifa;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!do_promote) {\n\t\t\t\tinet_hash_remove(ifa);\n\t\t\t\t*ifap1 = ifa->ifa_next;\n\n\t\t\t\trtmsg_ifa(RTM_DELADDR, ifa, nlh, portid);\n\t\t\t\tblocking_notifier_call_chain(&inetaddr_chain,\n\t\t\t\t\t\tNETDEV_DOWN, ifa);\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t} else {\n\t\t\t\tpromote = ifa;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* On promotion all secondaries from subnet are changing\n\t * the primary IP, we must remove all their routes silently\n\t * and later to add them back with new prefsrc. Do this\n\t * while all addresses are on the device list.\n\t */\n\tfor (ifa = promote; ifa; ifa = ifa->ifa_next) {\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa))\n\t\t\tfib_del_ifaddr(ifa, ifa1);\n\t}\n\n\t/* 2. Unlink it */\n\n\t*ifap = ifa1->ifa_next;\n\tinet_hash_remove(ifa1);\n\n\t/* 3. Announce address deletion */\n\n\t/* Send message first, then call notifier.\n\t   At first sight, FIB update triggered by notifier\n\t   will refer to already deleted ifaddr, that could confuse\n\t   netlink listeners. It is not true: look, gated sees\n\t   that route deleted and if it still thinks that ifaddr\n\t   is valid, it will try to restore deleted routes... Grr.\n\t   So that, this order is correct.\n\t */\n\trtmsg_ifa(RTM_DELADDR, ifa1, nlh, portid);\n\tblocking_notifier_call_chain(&inetaddr_chain, NETDEV_DOWN, ifa1);\n\n\tif (promote) {\n\t\tstruct in_ifaddr *next_sec = promote->ifa_next;\n\n\t\tif (prev_prom) {\n\t\t\tprev_prom->ifa_next = promote->ifa_next;\n\t\t\tpromote->ifa_next = last_prim->ifa_next;\n\t\t\tlast_prim->ifa_next = promote;\n\t\t}\n\n\t\tpromote->ifa_flags &= ~IFA_F_SECONDARY;\n\t\trtmsg_ifa(RTM_NEWADDR, promote, nlh, portid);\n\t\tblocking_notifier_call_chain(&inetaddr_chain,\n\t\t\t\tNETDEV_UP, promote);\n\t\tfor (ifa = next_sec; ifa; ifa = ifa->ifa_next) {\n\t\t\tif (ifa1->ifa_mask != ifa->ifa_mask ||\n\t\t\t    !inet_ifa_match(ifa1->ifa_address, ifa))\n\t\t\t\t\tcontinue;\n\t\t\tfib_add_ifaddr(ifa);\n\t\t}\n\n\t}\n\tif (destroy)\n\t\tinet_free_ifa(ifa1);\n}\n\nstatic void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n\t\t\t int destroy)\n{\n\t__inet_del_ifa(in_dev, ifap, destroy, NULL, 0);\n}\n\nstatic void check_lifetime(struct work_struct *work);\n\nstatic DECLARE_DELAYED_WORK(check_lifetime_work, check_lifetime);\n\nstatic int __inet_insert_ifa(struct in_ifaddr *ifa, struct nlmsghdr *nlh,\n\t\t\t     u32 portid)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct in_ifaddr *ifa1, **ifap, **last_primary;\n\n\tASSERT_RTNL();\n\n\tif (!ifa->ifa_local) {\n\t\tinet_free_ifa(ifa);\n\t\treturn 0;\n\t}\n\n\tifa->ifa_flags &= ~IFA_F_SECONDARY;\n\tlast_primary = &in_dev->ifa_list;\n\n\tfor (ifap = &in_dev->ifa_list; (ifa1 = *ifap) != NULL;\n\t     ifap = &ifa1->ifa_next) {\n\t\tif (!(ifa1->ifa_flags & IFA_F_SECONDARY) &&\n\t\t    ifa->ifa_scope <= ifa1->ifa_scope)\n\t\t\tlast_primary = &ifa1->ifa_next;\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa)) {\n\t\t\tif (ifa1->ifa_local == ifa->ifa_local) {\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tif (ifa1->ifa_scope != ifa->ifa_scope) {\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tifa->ifa_flags |= IFA_F_SECONDARY;\n\t\t}\n\t}\n\n\tif (!(ifa->ifa_flags & IFA_F_SECONDARY)) {\n\t\tprandom_seed((__force u32) ifa->ifa_local);\n\t\tifap = last_primary;\n\t}\n\n\tifa->ifa_next = *ifap;\n\t*ifap = ifa;\n\n\tinet_hash_insert(dev_net(in_dev->dev), ifa);\n\n\tcancel_delayed_work(&check_lifetime_work);\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\n\n\t/* Send message first, then call notifier.\n\t   Notifier will trigger FIB update, so that\n\t   listeners of netlink will know about new ifaddr */\n\trtmsg_ifa(RTM_NEWADDR, ifa, nlh, portid);\n\tblocking_notifier_call_chain(&inetaddr_chain, NETDEV_UP, ifa);\n\n\treturn 0;\n}\n\nstatic int inet_insert_ifa(struct in_ifaddr *ifa)\n{\n\treturn __inet_insert_ifa(ifa, NULL, 0);\n}\n\nstatic int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\n\tASSERT_RTNL();\n\n\tif (!in_dev) {\n\t\tinet_free_ifa(ifa);\n\t\treturn -ENOBUFS;\n\t}\n\tipv4_devconf_setall(in_dev);\n\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\tif (ifa->ifa_dev != in_dev) {\n\t\tWARN_ON(ifa->ifa_dev);\n\t\tin_dev_hold(in_dev);\n\t\tifa->ifa_dev = in_dev;\n\t}\n\tif (ipv4_is_loopback(ifa->ifa_local))\n\t\tifa->ifa_scope = RT_SCOPE_HOST;\n\treturn inet_insert_ifa(ifa);\n}\n\n/* Caller must hold RCU or RTNL :\n * We dont take a reference on found in_device\n */\nstruct in_device *inetdev_by_index(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tstruct in_device *in_dev = NULL;\n\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (dev)\n\t\tin_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\trcu_read_unlock();\n\treturn in_dev;\n}\nEXPORT_SYMBOL(inetdev_by_index);\n\n/* Called only from RTNL semaphored context. No locks. */\n\nstruct in_ifaddr *inet_ifa_byprefix(struct in_device *in_dev, __be32 prefix,\n\t\t\t\t    __be32 mask)\n{\n\tASSERT_RTNL();\n\n\tfor_primary_ifa(in_dev) {\n\t\tif (ifa->ifa_mask == mask && inet_ifa_match(prefix, ifa))\n\t\t\treturn ifa;\n\t} endfor_ifa(in_dev);\n\treturn NULL;\n}\n\nstatic int ip_mc_config(struct sock *sk, bool join, const struct in_ifaddr *ifa)\n{\n\tstruct ip_mreqn mreq = {\n\t\t.imr_multiaddr.s_addr = ifa->ifa_address,\n\t\t.imr_ifindex = ifa->ifa_dev->dev->ifindex,\n\t};\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tlock_sock(sk);\n\tif (join)\n\t\tret = ip_mc_join_group(sk, &mreq);\n\telse\n\t\tret = ip_mc_leave_group(sk, &mreq);\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int inet_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in_device *in_dev;\n\tstruct ifaddrmsg *ifm;\n\tstruct in_ifaddr *ifa, **ifap;\n\tint err = -EINVAL;\n\n\tASSERT_RTNL();\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tifm = nlmsg_data(nlh);\n\tin_dev = inetdev_by_index(net, ifm->ifa_index);\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto errout;\n\t}\n\n\tfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\n\t     ifap = &ifa->ifa_next) {\n\t\tif (tb[IFA_LOCAL] &&\n\t\t    ifa->ifa_local != nla_get_in_addr(tb[IFA_LOCAL]))\n\t\t\tcontinue;\n\n\t\tif (tb[IFA_LABEL] && nla_strcmp(tb[IFA_LABEL], ifa->ifa_label))\n\t\t\tcontinue;\n\n\t\tif (tb[IFA_ADDRESS] &&\n\t\t    (ifm->ifa_prefixlen != ifa->ifa_prefixlen ||\n\t\t    !inet_ifa_match(nla_get_in_addr(tb[IFA_ADDRESS]), ifa)))\n\t\t\tcontinue;\n\n\t\tif (ipv4_is_multicast(ifa->ifa_address))\n\t\t\tip_mc_config(net->ipv4.mc_autojoin_sk, false, ifa);\n\t\t__inet_del_ifa(in_dev, ifap, 1, nlh, NETLINK_CB(skb).portid);\n\t\treturn 0;\n\t}\n\n\terr = -EADDRNOTAVAIL;\nerrout:\n\treturn err;\n}\n\n#define INFINITY_LIFE_TIME\t0xFFFFFFFF\n\nstatic void check_lifetime(struct work_struct *work)\n{\n\tunsigned long now, next, next_sec, next_sched;\n\tstruct in_ifaddr *ifa;\n\tstruct hlist_node *n;\n\tint i;\n\n\tnow = jiffies;\n\tnext = round_jiffies_up(now + ADDR_CHECK_FREQUENCY);\n\n\tfor (i = 0; i < IN4_ADDR_HSIZE; i++) {\n\t\tbool change_needed = false;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(ifa, &inet_addr_lst[i], hash) {\n\t\t\tunsigned long age;\n\n\t\t\tif (ifa->ifa_flags & IFA_F_PERMANENT)\n\t\t\t\tcontinue;\n\n\t\t\t/* We try to batch several events at once. */\n\t\t\tage = (now - ifa->ifa_tstamp +\n\t\t\t       ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\n\t\t\tif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\n\t\t\t    age >= ifa->ifa_valid_lft) {\n\t\t\t\tchange_needed = true;\n\t\t\t} else if (ifa->ifa_preferred_lft ==\n\t\t\t\t   INFINITY_LIFE_TIME) {\n\t\t\t\tcontinue;\n\t\t\t} else if (age >= ifa->ifa_preferred_lft) {\n\t\t\t\tif (time_before(ifa->ifa_tstamp +\n\t\t\t\t\t\tifa->ifa_valid_lft * HZ, next))\n\t\t\t\t\tnext = ifa->ifa_tstamp +\n\t\t\t\t\t       ifa->ifa_valid_lft * HZ;\n\n\t\t\t\tif (!(ifa->ifa_flags & IFA_F_DEPRECATED))\n\t\t\t\t\tchange_needed = true;\n\t\t\t} else if (time_before(ifa->ifa_tstamp +\n\t\t\t\t\t       ifa->ifa_preferred_lft * HZ,\n\t\t\t\t\t       next)) {\n\t\t\t\tnext = ifa->ifa_tstamp +\n\t\t\t\t       ifa->ifa_preferred_lft * HZ;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!change_needed)\n\t\t\tcontinue;\n\t\trtnl_lock();\n\t\thlist_for_each_entry_safe(ifa, n, &inet_addr_lst[i], hash) {\n\t\t\tunsigned long age;\n\n\t\t\tif (ifa->ifa_flags & IFA_F_PERMANENT)\n\t\t\t\tcontinue;\n\n\t\t\t/* We try to batch several events at once. */\n\t\t\tage = (now - ifa->ifa_tstamp +\n\t\t\t       ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\n\t\t\tif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\n\t\t\t    age >= ifa->ifa_valid_lft) {\n\t\t\t\tstruct in_ifaddr **ifap;\n\n\t\t\t\tfor (ifap = &ifa->ifa_dev->ifa_list;\n\t\t\t\t     *ifap != NULL; ifap = &(*ifap)->ifa_next) {\n\t\t\t\t\tif (*ifap == ifa) {\n\t\t\t\t\t\tinet_del_ifa(ifa->ifa_dev,\n\t\t\t\t\t\t\t     ifap, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (ifa->ifa_preferred_lft !=\n\t\t\t\t   INFINITY_LIFE_TIME &&\n\t\t\t\t   age >= ifa->ifa_preferred_lft &&\n\t\t\t\t   !(ifa->ifa_flags & IFA_F_DEPRECATED)) {\n\t\t\t\tifa->ifa_flags |= IFA_F_DEPRECATED;\n\t\t\t\trtmsg_ifa(RTM_NEWADDR, ifa, NULL, 0);\n\t\t\t}\n\t\t}\n\t\trtnl_unlock();\n\t}\n\n\tnext_sec = round_jiffies_up(next);\n\tnext_sched = next;\n\n\t/* If rounded timeout is accurate enough, accept it. */\n\tif (time_before(next_sec, next + ADDRCONF_TIMER_FUZZ))\n\t\tnext_sched = next_sec;\n\n\tnow = jiffies;\n\t/* And minimum interval is ADDRCONF_TIMER_FUZZ_MAX. */\n\tif (time_before(next_sched, now + ADDRCONF_TIMER_FUZZ_MAX))\n\t\tnext_sched = now + ADDRCONF_TIMER_FUZZ_MAX;\n\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work,\n\t\t\tnext_sched - now);\n}\n\nstatic void set_ifa_lifetime(struct in_ifaddr *ifa, __u32 valid_lft,\n\t\t\t     __u32 prefered_lft)\n{\n\tunsigned long timeout;\n\n\tifa->ifa_flags &= ~(IFA_F_PERMANENT | IFA_F_DEPRECATED);\n\n\ttimeout = addrconf_timeout_fixup(valid_lft, HZ);\n\tif (addrconf_finite_timeout(timeout))\n\t\tifa->ifa_valid_lft = timeout;\n\telse\n\t\tifa->ifa_flags |= IFA_F_PERMANENT;\n\n\ttimeout = addrconf_timeout_fixup(prefered_lft, HZ);\n\tif (addrconf_finite_timeout(timeout)) {\n\t\tif (timeout == 0)\n\t\t\tifa->ifa_flags |= IFA_F_DEPRECATED;\n\t\tifa->ifa_preferred_lft = timeout;\n\t}\n\tifa->ifa_tstamp = jiffies;\n\tif (!ifa->ifa_cstamp)\n\t\tifa->ifa_cstamp = ifa->ifa_tstamp;\n}\n\nstatic struct in_ifaddr *rtm_to_ifaddr(struct net *net, struct nlmsghdr *nlh,\n\t\t\t\t       __u32 *pvalid_lft, __u32 *pprefered_lft)\n{\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in_ifaddr *ifa;\n\tstruct ifaddrmsg *ifm;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tifm = nlmsg_data(nlh);\n\terr = -EINVAL;\n\tif (ifm->ifa_prefixlen > 32 || !tb[IFA_LOCAL])\n\t\tgoto errout;\n\n\tdev = __dev_get_by_index(net, ifm->ifa_index);\n\terr = -ENODEV;\n\tif (!dev)\n\t\tgoto errout;\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\terr = -ENOBUFS;\n\tif (!in_dev)\n\t\tgoto errout;\n\n\tifa = inet_alloc_ifa();\n\tif (!ifa)\n\t\t/*\n\t\t * A potential indev allocation can be left alive, it stays\n\t\t * assigned to its device and is destroy with it.\n\t\t */\n\t\tgoto errout;\n\n\tipv4_devconf_setall(in_dev);\n\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\tin_dev_hold(in_dev);\n\n\tif (!tb[IFA_ADDRESS])\n\t\ttb[IFA_ADDRESS] = tb[IFA_LOCAL];\n\n\tINIT_HLIST_NODE(&ifa->hash);\n\tifa->ifa_prefixlen = ifm->ifa_prefixlen;\n\tifa->ifa_mask = inet_make_mask(ifm->ifa_prefixlen);\n\tifa->ifa_flags = tb[IFA_FLAGS] ? nla_get_u32(tb[IFA_FLAGS]) :\n\t\t\t\t\t ifm->ifa_flags;\n\tifa->ifa_scope = ifm->ifa_scope;\n\tifa->ifa_dev = in_dev;\n\n\tifa->ifa_local = nla_get_in_addr(tb[IFA_LOCAL]);\n\tifa->ifa_address = nla_get_in_addr(tb[IFA_ADDRESS]);\n\n\tif (tb[IFA_BROADCAST])\n\t\tifa->ifa_broadcast = nla_get_in_addr(tb[IFA_BROADCAST]);\n\n\tif (tb[IFA_LABEL])\n\t\tnla_strlcpy(ifa->ifa_label, tb[IFA_LABEL], IFNAMSIZ);\n\telse\n\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\n\tif (tb[IFA_CACHEINFO]) {\n\t\tstruct ifa_cacheinfo *ci;\n\n\t\tci = nla_data(tb[IFA_CACHEINFO]);\n\t\tif (!ci->ifa_valid || ci->ifa_prefered > ci->ifa_valid) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_free;\n\t\t}\n\t\t*pvalid_lft = ci->ifa_valid;\n\t\t*pprefered_lft = ci->ifa_prefered;\n\t}\n\n\treturn ifa;\n\nerrout_free:\n\tinet_free_ifa(ifa);\nerrout:\n\treturn ERR_PTR(err);\n}\n\nstatic struct in_ifaddr *find_matching_ifa(struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct in_ifaddr *ifa1, **ifap;\n\n\tif (!ifa->ifa_local)\n\t\treturn NULL;\n\n\tfor (ifap = &in_dev->ifa_list; (ifa1 = *ifap) != NULL;\n\t     ifap = &ifa1->ifa_next) {\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa) &&\n\t\t    ifa1->ifa_local == ifa->ifa_local)\n\t\t\treturn ifa1;\n\t}\n\treturn NULL;\n}\n\nstatic int inet_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct in_ifaddr *ifa;\n\tstruct in_ifaddr *ifa_existing;\n\t__u32 valid_lft = INFINITY_LIFE_TIME;\n\t__u32 prefered_lft = INFINITY_LIFE_TIME;\n\n\tASSERT_RTNL();\n\n\tifa = rtm_to_ifaddr(net, nlh, &valid_lft, &prefered_lft);\n\tif (IS_ERR(ifa))\n\t\treturn PTR_ERR(ifa);\n\n\tifa_existing = find_matching_ifa(ifa);\n\tif (!ifa_existing) {\n\t\t/* It would be best to check for !NLM_F_CREATE here but\n\t\t * userspace already relies on not having to provide this.\n\t\t */\n\t\tset_ifa_lifetime(ifa, valid_lft, prefered_lft);\n\t\tif (ifa->ifa_flags & IFA_F_MCAUTOJOIN) {\n\t\t\tint ret = ip_mc_config(net->ipv4.mc_autojoin_sk,\n\t\t\t\t\t       true, ifa);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn __inet_insert_ifa(ifa, nlh, NETLINK_CB(skb).portid);\n\t} else {\n\t\tinet_free_ifa(ifa);\n\n\t\tif (nlh->nlmsg_flags & NLM_F_EXCL ||\n\t\t    !(nlh->nlmsg_flags & NLM_F_REPLACE))\n\t\t\treturn -EEXIST;\n\t\tifa = ifa_existing;\n\t\tset_ifa_lifetime(ifa, valid_lft, prefered_lft);\n\t\tcancel_delayed_work(&check_lifetime_work);\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&check_lifetime_work, 0);\n\t\trtmsg_ifa(RTM_NEWADDR, ifa, nlh, NETLINK_CB(skb).portid);\n\t}\n\treturn 0;\n}\n\n/*\n *\tDetermine a default network mask, based on the IP address.\n */\n\nstatic int inet_abc_len(__be32 addr)\n{\n\tint rc = -1;\t/* Something else, probably a multicast. */\n\n\tif (ipv4_is_zeronet(addr))\n\t\trc = 0;\n\telse {\n\t\t__u32 haddr = ntohl(addr);\n\n\t\tif (IN_CLASSA(haddr))\n\t\t\trc = 8;\n\t\telse if (IN_CLASSB(haddr))\n\t\t\trc = 16;\n\t\telse if (IN_CLASSC(haddr))\n\t\t\trc = 24;\n\t}\n\n\treturn rc;\n}\n\n\nint devinet_ioctl(struct net *net, unsigned int cmd, void __user *arg)\n{\n\tstruct ifreq ifr;\n\tstruct sockaddr_in sin_orig;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)&ifr.ifr_addr;\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr **ifap = NULL;\n\tstruct in_ifaddr *ifa = NULL;\n\tstruct net_device *dev;\n\tchar *colon;\n\tint ret = -EFAULT;\n\tint tryaddrmatch = 0;\n\n\t/*\n\t *\tFetch the caller's info block into kernel space\n\t */\n\n\tif (copy_from_user(&ifr, arg, sizeof(struct ifreq)))\n\t\tgoto out;\n\tifr.ifr_name[IFNAMSIZ - 1] = 0;\n\n\t/* save original address for comparison */\n\tmemcpy(&sin_orig, sin, sizeof(*sin));\n\n\tcolon = strchr(ifr.ifr_name, ':');\n\tif (colon)\n\t\t*colon = 0;\n\n\tdev_load(net, ifr.ifr_name);\n\n\tswitch (cmd) {\n\tcase SIOCGIFADDR:\t/* Get interface address */\n\tcase SIOCGIFBRDADDR:\t/* Get the broadcast address */\n\tcase SIOCGIFDSTADDR:\t/* Get the destination address */\n\tcase SIOCGIFNETMASK:\t/* Get the netmask for the interface */\n\t\t/* Note that these ioctls will not sleep,\n\t\t   so that we do not impose a lock.\n\t\t   One day we will be forced to put shlock here (I mean SMP)\n\t\t */\n\t\ttryaddrmatch = (sin_orig.sin_family == AF_INET);\n\t\tmemset(sin, 0, sizeof(*sin));\n\t\tsin->sin_family = AF_INET;\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tret = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SIOCSIFADDR:\t/* Set interface address (and family) */\n\tcase SIOCSIFBRDADDR:\t/* Set the broadcast address */\n\tcase SIOCSIFDSTADDR:\t/* Set the destination address */\n\tcase SIOCSIFNETMASK: \t/* Set the netmask for the interface */\n\t\tret = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t\tif (sin->sin_family != AF_INET)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trtnl_lock();\n\n\tret = -ENODEV;\n\tdev = __dev_get_by_name(net, ifr.ifr_name);\n\tif (!dev)\n\t\tgoto done;\n\n\tif (colon)\n\t\t*colon = ':';\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\tif (in_dev) {\n\t\tif (tryaddrmatch) {\n\t\t\t/* Matthias Andree */\n\t\t\t/* compare label and address (4.4BSD style) */\n\t\t\t/* note: we only do this for a limited set of ioctls\n\t\t\t   and only if the original address family was AF_INET.\n\t\t\t   This is checked above. */\n\t\t\tfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\n\t\t\t     ifap = &ifa->ifa_next) {\n\t\t\t\tif (!strcmp(ifr.ifr_name, ifa->ifa_label) &&\n\t\t\t\t    sin_orig.sin_addr.s_addr ==\n\t\t\t\t\t\t\tifa->ifa_local) {\n\t\t\t\t\tbreak; /* found */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* we didn't get a match, maybe the application is\n\t\t   4.3BSD-style and passed in junk so we fall back to\n\t\t   comparing just the label */\n\t\tif (!ifa) {\n\t\t\tfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\n\t\t\t     ifap = &ifa->ifa_next)\n\t\t\t\tif (!strcmp(ifr.ifr_name, ifa->ifa_label))\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = -EADDRNOTAVAIL;\n\tif (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)\n\t\tgoto done;\n\n\tswitch (cmd) {\n\tcase SIOCGIFADDR:\t/* Get interface address */\n\t\tsin->sin_addr.s_addr = ifa->ifa_local;\n\t\tgoto rarok;\n\n\tcase SIOCGIFBRDADDR:\t/* Get the broadcast address */\n\t\tsin->sin_addr.s_addr = ifa->ifa_broadcast;\n\t\tgoto rarok;\n\n\tcase SIOCGIFDSTADDR:\t/* Get the destination address */\n\t\tsin->sin_addr.s_addr = ifa->ifa_address;\n\t\tgoto rarok;\n\n\tcase SIOCGIFNETMASK:\t/* Get the netmask for the interface */\n\t\tsin->sin_addr.s_addr = ifa->ifa_mask;\n\t\tgoto rarok;\n\n\tcase SIOCSIFFLAGS:\n\t\tif (colon) {\n\t\t\tret = -EADDRNOTAVAIL;\n\t\t\tif (!ifa)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tif (!(ifr.ifr_flags & IFF_UP))\n\t\t\t\tinet_del_ifa(in_dev, ifap, 1);\n\t\t\tbreak;\n\t\t}\n\t\tret = dev_change_flags(dev, ifr.ifr_flags);\n\t\tbreak;\n\n\tcase SIOCSIFADDR:\t/* Set interface address (and family) */\n\t\tret = -EINVAL;\n\t\tif (inet_abc_len(sin->sin_addr.s_addr) < 0)\n\t\t\tbreak;\n\n\t\tif (!ifa) {\n\t\t\tret = -ENOBUFS;\n\t\t\tifa = inet_alloc_ifa();\n\t\t\tif (!ifa)\n\t\t\t\tbreak;\n\t\t\tINIT_HLIST_NODE(&ifa->hash);\n\t\t\tif (colon)\n\t\t\t\tmemcpy(ifa->ifa_label, ifr.ifr_name, IFNAMSIZ);\n\t\t\telse\n\t\t\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\t} else {\n\t\t\tret = 0;\n\t\t\tif (ifa->ifa_local == sin->sin_addr.s_addr)\n\t\t\t\tbreak;\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_broadcast = 0;\n\t\t\tifa->ifa_scope = 0;\n\t\t}\n\n\t\tifa->ifa_address = ifa->ifa_local = sin->sin_addr.s_addr;\n\n\t\tif (!(dev->flags & IFF_POINTOPOINT)) {\n\t\t\tifa->ifa_prefixlen = inet_abc_len(ifa->ifa_address);\n\t\t\tifa->ifa_mask = inet_make_mask(ifa->ifa_prefixlen);\n\t\t\tif ((dev->flags & IFF_BROADCAST) &&\n\t\t\t    ifa->ifa_prefixlen < 31)\n\t\t\t\tifa->ifa_broadcast = ifa->ifa_address |\n\t\t\t\t\t\t     ~ifa->ifa_mask;\n\t\t} else {\n\t\t\tifa->ifa_prefixlen = 32;\n\t\t\tifa->ifa_mask = inet_make_mask(32);\n\t\t}\n\t\tset_ifa_lifetime(ifa, INFINITY_LIFE_TIME, INFINITY_LIFE_TIME);\n\t\tret = inet_set_ifa(dev, ifa);\n\t\tbreak;\n\n\tcase SIOCSIFBRDADDR:\t/* Set the broadcast address */\n\t\tret = 0;\n\t\tif (ifa->ifa_broadcast != sin->sin_addr.s_addr) {\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_broadcast = sin->sin_addr.s_addr;\n\t\t\tinet_insert_ifa(ifa);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFDSTADDR:\t/* Set the destination address */\n\t\tret = 0;\n\t\tif (ifa->ifa_address == sin->sin_addr.s_addr)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (inet_abc_len(sin->sin_addr.s_addr) < 0)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\tifa->ifa_address = sin->sin_addr.s_addr;\n\t\tinet_insert_ifa(ifa);\n\t\tbreak;\n\n\tcase SIOCSIFNETMASK: \t/* Set the netmask for the interface */\n\n\t\t/*\n\t\t *\tThe mask we set must be legal.\n\t\t */\n\t\tret = -EINVAL;\n\t\tif (bad_mask(sin->sin_addr.s_addr, 0))\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (ifa->ifa_mask != sin->sin_addr.s_addr) {\n\t\t\t__be32 old_mask = ifa->ifa_mask;\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_mask = sin->sin_addr.s_addr;\n\t\t\tifa->ifa_prefixlen = inet_mask_len(ifa->ifa_mask);\n\n\t\t\t/* See if current broadcast address matches\n\t\t\t * with current netmask, then recalculate\n\t\t\t * the broadcast address. Otherwise it's a\n\t\t\t * funny address, so don't touch it since\n\t\t\t * the user seems to know what (s)he's doing...\n\t\t\t */\n\t\t\tif ((dev->flags & IFF_BROADCAST) &&\n\t\t\t    (ifa->ifa_prefixlen < 31) &&\n\t\t\t    (ifa->ifa_broadcast ==\n\t\t\t     (ifa->ifa_local|~old_mask))) {\n\t\t\t\tifa->ifa_broadcast = (ifa->ifa_local |\n\t\t\t\t\t\t      ~sin->sin_addr.s_addr);\n\t\t\t}\n\t\t\tinet_insert_ifa(ifa);\n\t\t}\n\t\tbreak;\n\t}\ndone:\n\trtnl_unlock();\nout:\n\treturn ret;\nrarok:\n\trtnl_unlock();\n\tret = copy_to_user(arg, &ifr, sizeof(struct ifreq)) ? -EFAULT : 0;\n\tgoto out;\n}\n\nstatic int inet_gifconf(struct net_device *dev, char __user *buf, int len)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\tstruct in_ifaddr *ifa;\n\tstruct ifreq ifr;\n\tint done = 0;\n\n\tif (!in_dev)\n\t\tgoto out;\n\n\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\n\t\tif (!buf) {\n\t\t\tdone += sizeof(ifr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (len < (int) sizeof(ifr))\n\t\t\tbreak;\n\t\tmemset(&ifr, 0, sizeof(struct ifreq));\n\t\tstrcpy(ifr.ifr_name, ifa->ifa_label);\n\n\t\t(*(struct sockaddr_in *)&ifr.ifr_addr).sin_family = AF_INET;\n\t\t(*(struct sockaddr_in *)&ifr.ifr_addr).sin_addr.s_addr =\n\t\t\t\t\t\t\t\tifa->ifa_local;\n\n\t\tif (copy_to_user(buf, &ifr, sizeof(struct ifreq))) {\n\t\t\tdone = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuf  += sizeof(struct ifreq);\n\t\tlen  -= sizeof(struct ifreq);\n\t\tdone += sizeof(struct ifreq);\n\t}\nout:\n\treturn done;\n}\n\n__be32 inet_select_addr(const struct net_device *dev, __be32 dst, int scope)\n{\n\t__be32 addr = 0;\n\tstruct in_device *in_dev;\n\tstruct net *net = dev_net(dev);\n\tint master_idx;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (!in_dev)\n\t\tgoto no_in_dev;\n\n\tfor_primary_ifa(in_dev) {\n\t\tif (ifa->ifa_scope > scope)\n\t\t\tcontinue;\n\t\tif (!dst || inet_ifa_match(dst, ifa)) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tbreak;\n\t\t}\n\t\tif (!addr)\n\t\t\taddr = ifa->ifa_local;\n\t} endfor_ifa(in_dev);\n\n\tif (addr)\n\t\tgoto out_unlock;\nno_in_dev:\n\tmaster_idx = l3mdev_master_ifindex_rcu(dev);\n\n\t/* For VRFs, the VRF device takes the place of the loopback device,\n\t * with addresses on it being preferred.  Note in such cases the\n\t * loopback device will be among the devices that fail the master_idx\n\t * equality check in the loop below.\n\t */\n\tif (master_idx &&\n\t    (dev = dev_get_by_index_rcu(net, master_idx)) &&\n\t    (in_dev = __in_dev_get_rcu(dev))) {\n\t\tfor_primary_ifa(in_dev) {\n\t\t\tif (ifa->ifa_scope != RT_SCOPE_LINK &&\n\t\t\t    ifa->ifa_scope <= scope) {\n\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} endfor_ifa(in_dev);\n\t}\n\n\t/* Not loopback addresses on loopback should be preferred\n\t   in this case. It is important that lo is the first interface\n\t   in dev_base list.\n\t */\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (l3mdev_master_ifindex_rcu(dev) != master_idx)\n\t\t\tcontinue;\n\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (!in_dev)\n\t\t\tcontinue;\n\n\t\tfor_primary_ifa(in_dev) {\n\t\t\tif (ifa->ifa_scope != RT_SCOPE_LINK &&\n\t\t\t    ifa->ifa_scope <= scope) {\n\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} endfor_ifa(in_dev);\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn addr;\n}\nEXPORT_SYMBOL(inet_select_addr);\n\nstatic __be32 confirm_addr_indev(struct in_device *in_dev, __be32 dst,\n\t\t\t      __be32 local, int scope)\n{\n\tint same = 0;\n\t__be32 addr = 0;\n\n\tfor_ifa(in_dev) {\n\t\tif (!addr &&\n\t\t    (local == ifa->ifa_local || !local) &&\n\t\t    ifa->ifa_scope <= scope) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tif (same)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!same) {\n\t\t\tsame = (!local || inet_ifa_match(local, ifa)) &&\n\t\t\t\t(!dst || inet_ifa_match(dst, ifa));\n\t\t\tif (same && addr) {\n\t\t\t\tif (local || !dst)\n\t\t\t\t\tbreak;\n\t\t\t\t/* Is the selected addr into dst subnet? */\n\t\t\t\tif (inet_ifa_match(addr, ifa))\n\t\t\t\t\tbreak;\n\t\t\t\t/* No, then can we use new local src? */\n\t\t\t\tif (ifa->ifa_scope <= scope) {\n\t\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* search for large dst subnet for addr */\n\t\t\t\tsame = 0;\n\t\t\t}\n\t\t}\n\t} endfor_ifa(in_dev);\n\n\treturn same ? addr : 0;\n}\n\n/*\n * Confirm that local IP address exists using wildcards:\n * - net: netns to check, cannot be NULL\n * - in_dev: only on this interface, NULL=any interface\n * - dst: only in the same subnet as dst, 0=any dst\n * - local: address, 0=autoselect the local address\n * - scope: maximum allowed scope value for the local address\n */\n__be32 inet_confirm_addr(struct net *net, struct in_device *in_dev,\n\t\t\t __be32 dst, __be32 local, int scope)\n{\n\t__be32 addr = 0;\n\tstruct net_device *dev;\n\n\tif (in_dev)\n\t\treturn confirm_addr_indev(in_dev, dst, local, scope);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev) {\n\t\t\taddr = confirm_addr_indev(in_dev, dst, local, scope);\n\t\t\tif (addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn addr;\n}\nEXPORT_SYMBOL(inet_confirm_addr);\n\n/*\n *\tDevice notifier\n */\n\nint register_inetaddr_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&inetaddr_chain, nb);\n}\nEXPORT_SYMBOL(register_inetaddr_notifier);\n\nint unregister_inetaddr_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&inetaddr_chain, nb);\n}\nEXPORT_SYMBOL(unregister_inetaddr_notifier);\n\n/* Rename ifa_labels for a device name change. Make some effort to preserve\n * existing alias numbering and to create unique labels if possible.\n*/\nstatic void inetdev_changename(struct net_device *dev, struct in_device *in_dev)\n{\n\tstruct in_ifaddr *ifa;\n\tint named = 0;\n\n\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\n\t\tchar old[IFNAMSIZ], *dot;\n\n\t\tmemcpy(old, ifa->ifa_label, IFNAMSIZ);\n\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\tif (named++ == 0)\n\t\t\tgoto skip;\n\t\tdot = strchr(old, ':');\n\t\tif (!dot) {\n\t\t\tsprintf(old, \":%d\", named);\n\t\t\tdot = old;\n\t\t}\n\t\tif (strlen(dot) + strlen(dev->name) < IFNAMSIZ)\n\t\t\tstrcat(ifa->ifa_label, dot);\n\t\telse\n\t\t\tstrcpy(ifa->ifa_label + (IFNAMSIZ - strlen(dot) - 1), dot);\nskip:\n\t\trtmsg_ifa(RTM_NEWADDR, ifa, NULL, 0);\n\t}\n}\n\nstatic bool inetdev_valid_mtu(unsigned int mtu)\n{\n\treturn mtu >= 68;\n}\n\nstatic void inetdev_send_gratuitous_arp(struct net_device *dev,\n\t\t\t\t\tstruct in_device *in_dev)\n\n{\n\tstruct in_ifaddr *ifa;\n\n\tfor (ifa = in_dev->ifa_list; ifa;\n\t     ifa = ifa->ifa_next) {\n\t\tarp_send(ARPOP_REQUEST, ETH_P_ARP,\n\t\t\t ifa->ifa_local, dev,\n\t\t\t ifa->ifa_local, NULL,\n\t\t\t dev->dev_addr, NULL);\n\t}\n}\n\n/* Called only under RTNL semaphore */\n\nstatic int inetdev_event(struct notifier_block *this, unsigned long event,\n\t\t\t void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\n\tASSERT_RTNL();\n\n\tif (!in_dev) {\n\t\tif (event == NETDEV_REGISTER) {\n\t\t\tin_dev = inetdev_init(dev);\n\t\t\tif (IS_ERR(in_dev))\n\t\t\t\treturn notifier_from_errno(PTR_ERR(in_dev));\n\t\t\tif (dev->flags & IFF_LOOPBACK) {\n\t\t\t\tIN_DEV_CONF_SET(in_dev, NOXFRM, 1);\n\t\t\t\tIN_DEV_CONF_SET(in_dev, NOPOLICY, 1);\n\t\t\t}\n\t\t} else if (event == NETDEV_CHANGEMTU) {\n\t\t\t/* Re-enabling IP */\n\t\t\tif (inetdev_valid_mtu(dev->mtu))\n\t\t\t\tin_dev = inetdev_init(dev);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tpr_debug(\"%s: bug\\n\", __func__);\n\t\tRCU_INIT_POINTER(dev->ip_ptr, NULL);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tif (!inetdev_valid_mtu(dev->mtu))\n\t\t\tbreak;\n\t\tif (dev->flags & IFF_LOOPBACK) {\n\t\t\tstruct in_ifaddr *ifa = inet_alloc_ifa();\n\n\t\t\tif (ifa) {\n\t\t\t\tINIT_HLIST_NODE(&ifa->hash);\n\t\t\t\tifa->ifa_local =\n\t\t\t\t  ifa->ifa_address = htonl(INADDR_LOOPBACK);\n\t\t\t\tifa->ifa_prefixlen = 8;\n\t\t\t\tifa->ifa_mask = inet_make_mask(8);\n\t\t\t\tin_dev_hold(in_dev);\n\t\t\t\tifa->ifa_dev = in_dev;\n\t\t\t\tifa->ifa_scope = RT_SCOPE_HOST;\n\t\t\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\t\t\tset_ifa_lifetime(ifa, INFINITY_LIFE_TIME,\n\t\t\t\t\t\t INFINITY_LIFE_TIME);\n\t\t\t\tipv4_devconf_setall(in_dev);\n\t\t\t\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\t\t\t\tinet_insert_ifa(ifa);\n\t\t\t}\n\t\t}\n\t\tip_mc_up(in_dev);\n\t\t/* fall through */\n\tcase NETDEV_CHANGEADDR:\n\t\tif (!IN_DEV_ARP_NOTIFY(in_dev))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase NETDEV_NOTIFY_PEERS:\n\t\t/* Send gratuitous ARP to notify of link change */\n\t\tinetdev_send_gratuitous_arp(dev, in_dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tip_mc_down(in_dev);\n\t\tbreak;\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\tip_mc_unmap(in_dev);\n\t\tbreak;\n\tcase NETDEV_POST_TYPE_CHANGE:\n\t\tip_mc_remap(in_dev);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (inetdev_valid_mtu(dev->mtu))\n\t\t\tbreak;\n\t\t/* disable IP when MTU is not enough */\n\tcase NETDEV_UNREGISTER:\n\t\tinetdev_destroy(in_dev);\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\t/* Do not notify about label change, this event is\n\t\t * not interesting to applications using netlink.\n\t\t */\n\t\tinetdev_changename(dev, in_dev);\n\n\t\tdevinet_sysctl_unregister(in_dev);\n\t\tdevinet_sysctl_register(in_dev);\n\t\tbreak;\n\t}\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ip_netdev_notifier = {\n\t.notifier_call = inetdev_event,\n};\n\nstatic size_t inet_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\n\t       + nla_total_size(4) /* IFA_ADDRESS */\n\t       + nla_total_size(4) /* IFA_LOCAL */\n\t       + nla_total_size(4) /* IFA_BROADCAST */\n\t       + nla_total_size(IFNAMSIZ) /* IFA_LABEL */\n\t       + nla_total_size(4)  /* IFA_FLAGS */\n\t       + nla_total_size(sizeof(struct ifa_cacheinfo)); /* IFA_CACHEINFO */\n}\n\nstatic inline u32 cstamp_delta(unsigned long cstamp)\n{\n\treturn (cstamp - INITIAL_JIFFIES) * 100UL / HZ;\n}\n\nstatic int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,\n\t\t\t unsigned long tstamp, u32 preferred, u32 valid)\n{\n\tstruct ifa_cacheinfo ci;\n\n\tci.cstamp = cstamp_delta(cstamp);\n\tci.tstamp = cstamp_delta(tstamp);\n\tci.ifa_prefered = preferred;\n\tci.ifa_valid = valid;\n\n\treturn nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);\n}\n\nstatic int inet_fill_ifaddr(struct sk_buff *skb, struct in_ifaddr *ifa,\n\t\t\t    u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct ifaddrmsg *ifm;\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*ifm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifa_family = AF_INET;\n\tifm->ifa_prefixlen = ifa->ifa_prefixlen;\n\tifm->ifa_flags = ifa->ifa_flags;\n\tifm->ifa_scope = ifa->ifa_scope;\n\tifm->ifa_index = ifa->ifa_dev->dev->ifindex;\n\n\tif (!(ifm->ifa_flags & IFA_F_PERMANENT)) {\n\t\tpreferred = ifa->ifa_preferred_lft;\n\t\tvalid = ifa->ifa_valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->ifa_tstamp) / HZ;\n\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\tif ((ifa->ifa_address &&\n\t     nla_put_in_addr(skb, IFA_ADDRESS, ifa->ifa_address)) ||\n\t    (ifa->ifa_local &&\n\t     nla_put_in_addr(skb, IFA_LOCAL, ifa->ifa_local)) ||\n\t    (ifa->ifa_broadcast &&\n\t     nla_put_in_addr(skb, IFA_BROADCAST, ifa->ifa_broadcast)) ||\n\t    (ifa->ifa_label[0] &&\n\t     nla_put_string(skb, IFA_LABEL, ifa->ifa_label)) ||\n\t    nla_put_u32(skb, IFA_FLAGS, ifa->ifa_flags) ||\n\t    put_cacheinfo(skb, ifa->ifa_cstamp, ifa->ifa_tstamp,\n\t\t\t  preferred, valid))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int inet_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx, s_idx;\n\tint ip_idx, s_ip_idx;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr *ifa;\n\tstruct hlist_head *head;\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\ts_ip_idx = ip_idx = cb->args[2];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = atomic_read(&net->ipv4.dev_addr_genid) ^\n\t\t\t  net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (h > s_h || idx > s_idx)\n\t\t\t\ts_ip_idx = 0;\n\t\t\tin_dev = __in_dev_get_rcu(dev);\n\t\t\tif (!in_dev)\n\t\t\t\tgoto cont;\n\n\t\t\tfor (ifa = in_dev->ifa_list, ip_idx = 0; ifa;\n\t\t\t     ifa = ifa->ifa_next, ip_idx++) {\n\t\t\t\tif (ip_idx < s_ip_idx)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (inet_fill_ifaddr(skb, ifa,\n\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq,\n\t\t\t\t\t     RTM_NEWADDR, NLM_F_MULTI) < 0) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\n\t\t\t}\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\tcb->args[2] = ip_idx;\n\n\treturn skb->len;\n}\n\nstatic void rtmsg_ifa(int event, struct in_ifaddr *ifa, struct nlmsghdr *nlh,\n\t\t      u32 portid)\n{\n\tstruct sk_buff *skb;\n\tu32 seq = nlh ? nlh->nlmsg_seq : 0;\n\tint err = -ENOBUFS;\n\tstruct net *net;\n\n\tnet = dev_net(ifa->ifa_dev->dev);\n\tskb = nlmsg_new(inet_nlmsg_size(), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_fill_ifaddr(skb, ifa, portid, seq, event, 0);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in inet_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, portid, RTNLGRP_IPV4_IFADDR, nlh, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_IFADDR, err);\n}\n\nstatic size_t inet_get_link_af_size(const struct net_device *dev,\n\t\t\t\t    u32 ext_filter_mask)\n{\n\tstruct in_device *in_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\n\tif (!in_dev)\n\t\treturn 0;\n\n\treturn nla_total_size(IPV4_DEVCONF_MAX * 4); /* IFLA_INET_CONF */\n}\n\nstatic int inet_fill_link_af(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tstruct in_device *in_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\tstruct nlattr *nla;\n\tint i;\n\n\tif (!in_dev)\n\t\treturn -ENODATA;\n\n\tnla = nla_reserve(skb, IFLA_INET_CONF, IPV4_DEVCONF_MAX * 4);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < IPV4_DEVCONF_MAX; i++)\n\t\t((u32 *) nla_data(nla))[i] = in_dev->cnf.data[i];\n\n\treturn 0;\n}\n\nstatic const struct nla_policy inet_af_policy[IFLA_INET_MAX+1] = {\n\t[IFLA_INET_CONF]\t= { .type = NLA_NESTED },\n};\n\nstatic int inet_validate_link_af(const struct net_device *dev,\n\t\t\t\t const struct nlattr *nla)\n{\n\tstruct nlattr *a, *tb[IFLA_INET_MAX+1];\n\tint err, rem;\n\n\tif (dev && !__in_dev_get_rtnl(dev))\n\t\treturn -EAFNOSUPPORT;\n\n\terr = nla_parse_nested(tb, IFLA_INET_MAX, nla, inet_af_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_INET_CONF]) {\n\t\tnla_for_each_nested(a, tb[IFLA_INET_CONF], rem) {\n\t\t\tint cfgid = nla_type(a);\n\n\t\t\tif (nla_len(a) < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (cfgid <= 0 || cfgid > IPV4_DEVCONF_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet_set_link_af(struct net_device *dev, const struct nlattr *nla)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\tstruct nlattr *a, *tb[IFLA_INET_MAX+1];\n\tint rem;\n\n\tif (!in_dev)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_parse_nested(tb, IFLA_INET_MAX, nla, NULL) < 0)\n\t\tBUG();\n\n\tif (tb[IFLA_INET_CONF]) {\n\t\tnla_for_each_nested(a, tb[IFLA_INET_CONF], rem)\n\t\t\tipv4_devconf_set(in_dev, nla_type(a), nla_get_u32(a));\n\t}\n\n\treturn 0;\n}\n\nstatic int inet_netconf_msgsize_devconf(int type)\n{\n\tint size = NLMSG_ALIGN(sizeof(struct netconfmsg))\n\t\t   + nla_total_size(4);\t/* NETCONFA_IFINDEX */\n\tbool all = false;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tif (all || type == NETCONFA_FORWARDING)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_RP_FILTER)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_MC_FORWARDING)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_PROXY_NEIGH)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN)\n\t\tsize += nla_total_size(4);\n\n\treturn size;\n}\n\nstatic int inet_netconf_fill_devconf(struct sk_buff *skb, int ifindex,\n\t\t\t\t     struct ipv4_devconf *devconf, u32 portid,\n\t\t\t\t     u32 seq, int event, unsigned int flags,\n\t\t\t\t     int type)\n{\n\tstruct nlmsghdr  *nlh;\n\tstruct netconfmsg *ncm;\n\tbool all = false;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct netconfmsg),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tncm = nlmsg_data(nlh);\n\tncm->ncm_family = AF_INET;\n\n\tif (nla_put_s32(skb, NETCONFA_IFINDEX, ifindex) < 0)\n\t\tgoto nla_put_failure;\n\n\tif ((all || type == NETCONFA_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_FORWARDING,\n\t\t\tIPV4_DEVCONF(*devconf, FORWARDING)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_RP_FILTER) &&\n\t    nla_put_s32(skb, NETCONFA_RP_FILTER,\n\t\t\tIPV4_DEVCONF(*devconf, RP_FILTER)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_MC_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_MC_FORWARDING,\n\t\t\tIPV4_DEVCONF(*devconf, MC_FORWARDING)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_PROXY_NEIGH) &&\n\t    nla_put_s32(skb, NETCONFA_PROXY_NEIGH,\n\t\t\tIPV4_DEVCONF(*devconf, PROXY_ARP)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN) &&\n\t    nla_put_s32(skb, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\tIPV4_DEVCONF(*devconf, IGNORE_ROUTES_WITH_LINKDOWN)) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nvoid inet_netconf_notify_devconf(struct net *net, int type, int ifindex,\n\t\t\t\t struct ipv4_devconf *devconf)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(inet_netconf_msgsize_devconf(type), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_netconf_fill_devconf(skb, ifindex, devconf, 0, 0,\n\t\t\t\t\tRTM_NEWNETCONF, 0, type);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in inet_netconf_msgsize_devconf() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_NETCONF, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_NETCONF, err);\n}\n\nstatic const struct nla_policy devconf_ipv4_policy[NETCONFA_MAX+1] = {\n\t[NETCONFA_IFINDEX]\t= { .len = sizeof(int) },\n\t[NETCONFA_FORWARDING]\t= { .len = sizeof(int) },\n\t[NETCONFA_RP_FILTER]\t= { .len = sizeof(int) },\n\t[NETCONFA_PROXY_NEIGH]\t= { .len = sizeof(int) },\n\t[NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN]\t= { .len = sizeof(int) },\n};\n\nstatic int inet_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t    struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct netconfmsg *ncm;\n\tstruct sk_buff *skb;\n\tstruct ipv4_devconf *devconf;\n\tstruct in_device *in_dev;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\n\t\t\t  devconf_ipv4_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tswitch (ifindex) {\n\tcase NETCONFA_IFINDEX_ALL:\n\t\tdevconf = net->ipv4.devconf_all;\n\t\tbreak;\n\tcase NETCONFA_IFINDEX_DEFAULT:\n\t\tdevconf = net->ipv4.devconf_dflt;\n\t\tbreak;\n\tdefault:\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t\tif (!dev)\n\t\t\tgoto errout;\n\t\tin_dev = __in_dev_get_rtnl(dev);\n\t\tif (!in_dev)\n\t\t\tgoto errout;\n\t\tdevconf = &in_dev->cnf;\n\t\tbreak;\n\t}\n\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(inet_netconf_msgsize_devconf(NETCONFA_ALL), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_netconf_fill_devconf(skb, ifindex, devconf,\n\t\t\t\t\tNETLINK_CB(in_skb).portid,\n\t\t\t\t\tnlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\tNETCONFA_ALL);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in inet_netconf_msgsize_devconf() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}\n\nstatic int inet_netconf_dump_devconf(struct sk_buff *skb,\n\t\t\t\t     struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx, s_idx;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tstruct hlist_head *head;\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = atomic_read(&net->ipv4.dev_addr_genid) ^\n\t\t\t  net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tin_dev = __in_dev_get_rcu(dev);\n\t\t\tif (!in_dev)\n\t\t\t\tgoto cont;\n\n\t\t\tif (inet_netconf_fill_devconf(skb, dev->ifindex,\n\t\t\t\t\t\t      &in_dev->cnf,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t      RTM_NEWNETCONF,\n\t\t\t\t\t\t      NLM_F_MULTI,\n\t\t\t\t\t\t      NETCONFA_ALL) < 0) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (h == NETDEV_HASHENTRIES) {\n\t\tif (inet_netconf_fill_devconf(skb, NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t      net->ipv4.devconf_all,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      RTM_NEWNETCONF, NLM_F_MULTI,\n\t\t\t\t\t      NETCONFA_ALL) < 0)\n\t\t\tgoto done;\n\t\telse\n\t\t\th++;\n\t}\n\tif (h == NETDEV_HASHENTRIES + 1) {\n\t\tif (inet_netconf_fill_devconf(skb, NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t      net->ipv4.devconf_dflt,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      RTM_NEWNETCONF, NLM_F_MULTI,\n\t\t\t\t\t      NETCONFA_ALL) < 0)\n\t\t\tgoto done;\n\t\telse\n\t\t\th++;\n\t}\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\n\treturn skb->len;\n}\n\n#ifdef CONFIG_SYSCTL\n\nstatic void devinet_copy_dflt_conf(struct net *net, int i)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tstruct in_device *in_dev;\n\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !test_bit(i, in_dev->cnf.state))\n\t\t\tin_dev->cnf.data[i] = net->ipv4.devconf_dflt->data[i];\n\t}\n\trcu_read_unlock();\n}\n\n/* called with RTNL locked */\nstatic void inet_forward_change(struct net *net)\n{\n\tstruct net_device *dev;\n\tint on = IPV4_DEVCONF_ALL(net, FORWARDING);\n\n\tIPV4_DEVCONF_ALL(net, ACCEPT_REDIRECTS) = !on;\n\tIPV4_DEVCONF_DFLT(net, FORWARDING) = on;\n\tinet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\n\t\t\t\t    NETCONFA_IFINDEX_ALL,\n\t\t\t\t    net->ipv4.devconf_all);\n\tinet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\n\t\t\t\t    NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t    net->ipv4.devconf_dflt);\n\n\tfor_each_netdev(net, dev) {\n\t\tstruct in_device *in_dev;\n\t\tif (on)\n\t\t\tdev_disable_lro(dev);\n\t\trcu_read_lock();\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev) {\n\t\t\tIN_DEV_CONF_SET(in_dev, FORWARDING, on);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\n\t\t\t\t\t\t    dev->ifindex, &in_dev->cnf);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic int devinet_conf_ifindex(struct net *net, struct ipv4_devconf *cnf)\n{\n\tif (cnf == net->ipv4.devconf_dflt)\n\t\treturn NETCONFA_IFINDEX_DEFAULT;\n\telse if (cnf == net->ipv4.devconf_all)\n\t\treturn NETCONFA_IFINDEX_ALL;\n\telse {\n\t\tstruct in_device *idev\n\t\t\t= container_of(cnf, struct in_device, cnf);\n\t\treturn idev->dev->ifindex;\n\t}\n}\n\nstatic int devinet_conf_proc(struct ctl_table *ctl, int write,\n\t\t\t     void __user *buffer,\n\t\t\t     size_t *lenp, loff_t *ppos)\n{\n\tint old_value = *(int *)ctl->data;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tint new_value = *(int *)ctl->data;\n\n\tif (write) {\n\t\tstruct ipv4_devconf *cnf = ctl->extra1;\n\t\tstruct net *net = ctl->extra2;\n\t\tint i = (int *)ctl->data - cnf->data;\n\t\tint ifindex;\n\n\t\tset_bit(i, cnf->state);\n\n\t\tif (cnf == net->ipv4.devconf_dflt)\n\t\t\tdevinet_copy_dflt_conf(net, i);\n\t\tif (i == IPV4_DEVCONF_ACCEPT_LOCAL - 1 ||\n\t\t    i == IPV4_DEVCONF_ROUTE_LOCALNET - 1)\n\t\t\tif ((new_value == 0) && (old_value != 0))\n\t\t\t\trt_cache_flush(net);\n\n\t\tif (i == IPV4_DEVCONF_RP_FILTER - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_RP_FILTER,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t\tif (i == IPV4_DEVCONF_PROXY_ARP - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t\tif (i == IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int devinet_sysctl_forward(struct ctl_table *ctl, int write,\n\t\t\t\t  void __user *buffer,\n\t\t\t\t  size_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tloff_t pos = *ppos;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write && *valp != val) {\n\t\tstruct net *net = ctl->extra2;\n\n\t\tif (valp != &IPV4_DEVCONF_DFLT(net, FORWARDING)) {\n\t\t\tif (!rtnl_trylock()) {\n\t\t\t\t/* Restore the original values before restarting */\n\t\t\t\t*valp = val;\n\t\t\t\t*ppos = pos;\n\t\t\t\treturn restart_syscall();\n\t\t\t}\n\t\t\tif (valp == &IPV4_DEVCONF_ALL(net, FORWARDING)) {\n\t\t\t\tinet_forward_change(net);\n\t\t\t} else {\n\t\t\t\tstruct ipv4_devconf *cnf = ctl->extra1;\n\t\t\t\tstruct in_device *idev =\n\t\t\t\t\tcontainer_of(cnf, struct in_device, cnf);\n\t\t\t\tif (*valp)\n\t\t\t\t\tdev_disable_lro(idev->dev);\n\t\t\t\tinet_netconf_notify_devconf(net,\n\t\t\t\t\t\t\t    NETCONFA_FORWARDING,\n\t\t\t\t\t\t\t    idev->dev->ifindex,\n\t\t\t\t\t\t\t    cnf);\n\t\t\t}\n\t\t\trtnl_unlock();\n\t\t\trt_cache_flush(net);\n\t\t} else\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\n\t\t\t\t\t\t    NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t\t    net->ipv4.devconf_dflt);\n\t}\n\n\treturn ret;\n}\n\nstatic int ipv4_doint_and_flush(struct ctl_table *ctl, int write,\n\t\t\t\tvoid __user *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tstruct net *net = ctl->extra2;\n\n\tif (write && *valp != val)\n\t\trt_cache_flush(net);\n\n\treturn ret;\n}\n\n#define DEVINET_SYSCTL_ENTRY(attr, name, mval, proc) \\\n\t{ \\\n\t\t.procname\t= name, \\\n\t\t.data\t\t= ipv4_devconf.data + \\\n\t\t\t\t  IPV4_DEVCONF_ ## attr - 1, \\\n\t\t.maxlen\t\t= sizeof(int), \\\n\t\t.mode\t\t= mval, \\\n\t\t.proc_handler\t= proc, \\\n\t\t.extra1\t\t= &ipv4_devconf, \\\n\t}\n\n#define DEVINET_SYSCTL_RW_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0644, devinet_conf_proc)\n\n#define DEVINET_SYSCTL_RO_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0444, devinet_conf_proc)\n\n#define DEVINET_SYSCTL_COMPLEX_ENTRY(attr, name, proc) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0644, proc)\n\n#define DEVINET_SYSCTL_FLUSHING_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_COMPLEX_ENTRY(attr, name, ipv4_doint_and_flush)\n\nstatic struct devinet_sysctl_table {\n\tstruct ctl_table_header *sysctl_header;\n\tstruct ctl_table devinet_vars[__IPV4_DEVCONF_MAX];\n} devinet_sysctl = {\n\t.devinet_vars = {\n\t\tDEVINET_SYSCTL_COMPLEX_ENTRY(FORWARDING, \"forwarding\",\n\t\t\t\t\t     devinet_sysctl_forward),\n\t\tDEVINET_SYSCTL_RO_ENTRY(MC_FORWARDING, \"mc_forwarding\"),\n\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_REDIRECTS, \"accept_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SECURE_REDIRECTS, \"secure_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SHARED_MEDIA, \"shared_media\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(RP_FILTER, \"rp_filter\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SEND_REDIRECTS, \"send_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_SOURCE_ROUTE,\n\t\t\t\t\t\"accept_source_route\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_LOCAL, \"accept_local\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SRC_VMARK, \"src_valid_mark\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(PROXY_ARP, \"proxy_arp\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(MEDIUM_ID, \"medium_id\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(BOOTP_RELAY, \"bootp_relay\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(LOG_MARTIANS, \"log_martians\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(TAG, \"tag\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARPFILTER, \"arp_filter\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_ANNOUNCE, \"arp_announce\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_IGNORE, \"arp_ignore\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_ACCEPT, \"arp_accept\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_NOTIFY, \"arp_notify\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(PROXY_ARP_PVLAN, \"proxy_arp_pvlan\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(FORCE_IGMP_VERSION,\n\t\t\t\t\t\"force_igmp_version\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGMPV2_UNSOLICITED_REPORT_INTERVAL,\n\t\t\t\t\t\"igmpv2_unsolicited_report_interval\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGMPV3_UNSOLICITED_REPORT_INTERVAL,\n\t\t\t\t\t\"igmpv3_unsolicited_report_interval\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\"ignore_routes_with_linkdown\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(DROP_GRATUITOUS_ARP,\n\t\t\t\t\t\"drop_gratuitous_arp\"),\n\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(NOXFRM, \"disable_xfrm\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(NOPOLICY, \"disable_policy\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(PROMOTE_SECONDARIES,\n\t\t\t\t\t      \"promote_secondaries\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(ROUTE_LOCALNET,\n\t\t\t\t\t      \"route_localnet\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(DROP_UNICAST_IN_L2_MULTICAST,\n\t\t\t\t\t      \"drop_unicast_in_l2_multicast\"),\n\t},\n};\n\nstatic int __devinet_sysctl_register(struct net *net, char *dev_name,\n\t\t\t\t\tstruct ipv4_devconf *p)\n{\n\tint i;\n\tstruct devinet_sysctl_table *t;\n\tchar path[sizeof(\"net/ipv4/conf/\") + IFNAMSIZ];\n\n\tt = kmemdup(&devinet_sysctl, sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(t->devinet_vars) - 1; i++) {\n\t\tt->devinet_vars[i].data += (char *)p - (char *)&ipv4_devconf;\n\t\tt->devinet_vars[i].extra1 = p;\n\t\tt->devinet_vars[i].extra2 = net;\n\t}\n\n\tsnprintf(path, sizeof(path), \"net/ipv4/conf/%s\", dev_name);\n\n\tt->sysctl_header = register_net_sysctl(net, path, t->devinet_vars);\n\tif (!t->sysctl_header)\n\t\tgoto free;\n\n\tp->sysctl = t;\n\treturn 0;\n\nfree:\n\tkfree(t);\nout:\n\treturn -ENOBUFS;\n}\n\nstatic void __devinet_sysctl_unregister(struct ipv4_devconf *cnf)\n{\n\tstruct devinet_sysctl_table *t = cnf->sysctl;\n\n\tif (!t)\n\t\treturn;\n\n\tcnf->sysctl = NULL;\n\tunregister_net_sysctl_table(t->sysctl_header);\n\tkfree(t);\n}\n\nstatic int devinet_sysctl_register(struct in_device *idev)\n{\n\tint err;\n\n\tif (!sysctl_dev_name_is_allowed(idev->dev->name))\n\t\treturn -EINVAL;\n\n\terr = neigh_sysctl_register(idev->dev, idev->arp_parms, NULL);\n\tif (err)\n\t\treturn err;\n\terr = __devinet_sysctl_register(dev_net(idev->dev), idev->dev->name,\n\t\t\t\t\t&idev->cnf);\n\tif (err)\n\t\tneigh_sysctl_unregister(idev->arp_parms);\n\treturn err;\n}\n\nstatic void devinet_sysctl_unregister(struct in_device *idev)\n{\n\t__devinet_sysctl_unregister(&idev->cnf);\n\tneigh_sysctl_unregister(idev->arp_parms);\n}\n\nstatic struct ctl_table ctl_forward_entry[] = {\n\t{\n\t\t.procname\t= \"ip_forward\",\n\t\t.data\t\t= &ipv4_devconf.data[\n\t\t\t\t\tIPV4_DEVCONF_FORWARDING - 1],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= devinet_sysctl_forward,\n\t\t.extra1\t\t= &ipv4_devconf,\n\t\t.extra2\t\t= &init_net,\n\t},\n\t{ },\n};\n#endif\n\nstatic __net_init int devinet_init_net(struct net *net)\n{\n\tint err;\n\tstruct ipv4_devconf *all, *dflt;\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl = ctl_forward_entry;\n\tstruct ctl_table_header *forw_hdr;\n#endif\n\n\terr = -ENOMEM;\n\tall = &ipv4_devconf;\n\tdflt = &ipv4_devconf_dflt;\n\n\tif (!net_eq(net, &init_net)) {\n\t\tall = kmemdup(all, sizeof(ipv4_devconf), GFP_KERNEL);\n\t\tif (!all)\n\t\t\tgoto err_alloc_all;\n\n\t\tdflt = kmemdup(dflt, sizeof(ipv4_devconf_dflt), GFP_KERNEL);\n\t\tif (!dflt)\n\t\t\tgoto err_alloc_dflt;\n\n#ifdef CONFIG_SYSCTL\n\t\ttbl = kmemdup(tbl, sizeof(ctl_forward_entry), GFP_KERNEL);\n\t\tif (!tbl)\n\t\t\tgoto err_alloc_ctl;\n\n\t\ttbl[0].data = &all->data[IPV4_DEVCONF_FORWARDING - 1];\n\t\ttbl[0].extra1 = all;\n\t\ttbl[0].extra2 = net;\n#endif\n\t}\n\n#ifdef CONFIG_SYSCTL\n\terr = __devinet_sysctl_register(net, \"all\", all);\n\tif (err < 0)\n\t\tgoto err_reg_all;\n\n\terr = __devinet_sysctl_register(net, \"default\", dflt);\n\tif (err < 0)\n\t\tgoto err_reg_dflt;\n\n\terr = -ENOMEM;\n\tforw_hdr = register_net_sysctl(net, \"net/ipv4\", tbl);\n\tif (!forw_hdr)\n\t\tgoto err_reg_ctl;\n\tnet->ipv4.forw_hdr = forw_hdr;\n#endif\n\n\tnet->ipv4.devconf_all = all;\n\tnet->ipv4.devconf_dflt = dflt;\n\treturn 0;\n\n#ifdef CONFIG_SYSCTL\nerr_reg_ctl:\n\t__devinet_sysctl_unregister(dflt);\nerr_reg_dflt:\n\t__devinet_sysctl_unregister(all);\nerr_reg_all:\n\tif (tbl != ctl_forward_entry)\n\t\tkfree(tbl);\nerr_alloc_ctl:\n#endif\n\tif (dflt != &ipv4_devconf_dflt)\n\t\tkfree(dflt);\nerr_alloc_dflt:\n\tif (all != &ipv4_devconf)\n\t\tkfree(all);\nerr_alloc_all:\n\treturn err;\n}\n\nstatic __net_exit void devinet_exit_net(struct net *net)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = net->ipv4.forw_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv4.forw_hdr);\n\t__devinet_sysctl_unregister(net->ipv4.devconf_dflt);\n\t__devinet_sysctl_unregister(net->ipv4.devconf_all);\n\tkfree(tbl);\n#endif\n\tkfree(net->ipv4.devconf_dflt);\n\tkfree(net->ipv4.devconf_all);\n}\n\nstatic __net_initdata struct pernet_operations devinet_ops = {\n\t.init = devinet_init_net,\n\t.exit = devinet_exit_net,\n};\n\nstatic struct rtnl_af_ops inet_af_ops __read_mostly = {\n\t.family\t\t  = AF_INET,\n\t.fill_link_af\t  = inet_fill_link_af,\n\t.get_link_af_size = inet_get_link_af_size,\n\t.validate_link_af = inet_validate_link_af,\n\t.set_link_af\t  = inet_set_link_af,\n};\n\nvoid __init devinet_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < IN4_ADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&inet_addr_lst[i]);\n\n\tregister_pernet_subsys(&devinet_ops);\n\n\tregister_gifconf(PF_INET, inet_gifconf);\n\tregister_netdevice_notifier(&ip_netdev_notifier);\n\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\n\n\trtnl_af_register(&inet_af_ops);\n\n\trtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL, NULL);\n\trtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL, NULL);\n\trtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr, NULL);\n\trtnl_register(PF_INET, RTM_GETNETCONF, inet_netconf_get_devconf,\n\t\t      inet_netconf_dump_devconf, NULL);\n}\n", "/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tIPv4 Forwarding Information Base: FIB frontend.\n *\n * Authors:\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <asm/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/if_addr.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/cache.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/arp.h>\n#include <net/ip_fib.h>\n#include <net/rtnetlink.h>\n#include <net/xfrm.h>\n#include <net/l3mdev.h>\n#include <trace/events/fib.h>\n\n#ifndef CONFIG_IP_MULTIPLE_TABLES\n\nstatic int __net_init fib4_rules_init(struct net *net)\n{\n\tstruct fib_table *local_table, *main_table;\n\n\tmain_table  = fib_trie_table(RT_TABLE_MAIN, NULL);\n\tif (!main_table)\n\t\treturn -ENOMEM;\n\n\tlocal_table = fib_trie_table(RT_TABLE_LOCAL, main_table);\n\tif (!local_table)\n\t\tgoto fail;\n\n\thlist_add_head_rcu(&local_table->tb_hlist,\n\t\t\t\t&net->ipv4.fib_table_hash[TABLE_LOCAL_INDEX]);\n\thlist_add_head_rcu(&main_table->tb_hlist,\n\t\t\t\t&net->ipv4.fib_table_hash[TABLE_MAIN_INDEX]);\n\treturn 0;\n\nfail:\n\tfib_free_table(main_table);\n\treturn -ENOMEM;\n}\n#else\n\nstruct fib_table *fib_new_table(struct net *net, u32 id)\n{\n\tstruct fib_table *tb, *alias = NULL;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT_TABLE_MAIN;\n\ttb = fib_get_table(net, id);\n\tif (tb)\n\t\treturn tb;\n\n\tif (id == RT_TABLE_LOCAL)\n\t\talias = fib_new_table(net, RT_TABLE_MAIN);\n\n\ttb = fib_trie_table(id, alias);\n\tif (!tb)\n\t\treturn NULL;\n\n\tswitch (id) {\n\tcase RT_TABLE_LOCAL:\n\t\trcu_assign_pointer(net->ipv4.fib_local, tb);\n\t\tbreak;\n\tcase RT_TABLE_MAIN:\n\t\trcu_assign_pointer(net->ipv4.fib_main, tb);\n\t\tbreak;\n\tcase RT_TABLE_DEFAULT:\n\t\trcu_assign_pointer(net->ipv4.fib_default, tb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\th = id & (FIB_TABLE_HASHSZ - 1);\n\thlist_add_head_rcu(&tb->tb_hlist, &net->ipv4.fib_table_hash[h]);\n\treturn tb;\n}\n\n/* caller must hold either rtnl or rcu read lock */\nstruct fib_table *fib_get_table(struct net *net, u32 id)\n{\n\tstruct fib_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT_TABLE_MAIN;\n\th = id & (FIB_TABLE_HASHSZ - 1);\n\n\thead = &net->ipv4.fib_table_hash[h];\n\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\tif (tb->tb_id == id)\n\t\t\treturn tb;\n\t}\n\treturn NULL;\n}\n#endif /* CONFIG_IP_MULTIPLE_TABLES */\n\nstatic void fib_replace_table(struct net *net, struct fib_table *old,\n\t\t\t      struct fib_table *new)\n{\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tswitch (new->tb_id) {\n\tcase RT_TABLE_LOCAL:\n\t\trcu_assign_pointer(net->ipv4.fib_local, new);\n\t\tbreak;\n\tcase RT_TABLE_MAIN:\n\t\trcu_assign_pointer(net->ipv4.fib_main, new);\n\t\tbreak;\n\tcase RT_TABLE_DEFAULT:\n\t\trcu_assign_pointer(net->ipv4.fib_default, new);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n#endif\n\t/* replace the old table in the hlist */\n\thlist_replace_rcu(&old->tb_hlist, &new->tb_hlist);\n}\n\nint fib_unmerge(struct net *net)\n{\n\tstruct fib_table *old, *new;\n\n\t/* attempt to fetch local table if it has been allocated */\n\told = fib_get_table(net, RT_TABLE_LOCAL);\n\tif (!old)\n\t\treturn 0;\n\n\tnew = fib_trie_unmerge(old);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/* replace merged table with clean table */\n\tif (new != old) {\n\t\tfib_replace_table(net, old, new);\n\t\tfib_free_table(old);\n\t}\n\n\treturn 0;\n}\n\nstatic void fib_flush(struct net *net)\n{\n\tint flushed = 0;\n\tunsigned int h;\n\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb_hlist)\n\t\t\tflushed += fib_table_flush(tb);\n\t}\n\n\tif (flushed)\n\t\trt_cache_flush(net);\n}\n\nvoid fib_flush_external(struct net *net)\n{\n\tstruct fib_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv4.fib_table_hash[h];\n\t\thlist_for_each_entry(tb, head, tb_hlist)\n\t\t\tfib_table_flush_external(tb);\n\t}\n}\n\n/*\n * Find address type as if only \"dev\" was present in the system. If\n * on_dev is NULL then all interfaces are taken into consideration.\n */\nstatic inline unsigned int __inet_dev_addr_type(struct net *net,\n\t\t\t\t\t\tconst struct net_device *dev,\n\t\t\t\t\t\t__be32 addr, u32 tb_id)\n{\n\tstruct flowi4\t\tfl4 = { .daddr = addr };\n\tstruct fib_result\tres;\n\tunsigned int ret = RTN_BROADCAST;\n\tstruct fib_table *table;\n\n\tif (ipv4_is_zeronet(addr) || ipv4_is_lbcast(addr))\n\t\treturn RTN_BROADCAST;\n\tif (ipv4_is_multicast(addr))\n\t\treturn RTN_MULTICAST;\n\n\trcu_read_lock();\n\n\ttable = fib_get_table(net, tb_id);\n\tif (table) {\n\t\tret = RTN_UNICAST;\n\t\tif (!fib_table_lookup(table, &fl4, &res, FIB_LOOKUP_NOREF)) {\n\t\t\tif (!dev || dev == res.fi->fib_dev)\n\t\t\t\tret = res.type;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\nunsigned int inet_addr_type_table(struct net *net, __be32 addr, u32 tb_id)\n{\n\treturn __inet_dev_addr_type(net, NULL, addr, tb_id);\n}\nEXPORT_SYMBOL(inet_addr_type_table);\n\nunsigned int inet_addr_type(struct net *net, __be32 addr)\n{\n\treturn __inet_dev_addr_type(net, NULL, addr, RT_TABLE_LOCAL);\n}\nEXPORT_SYMBOL(inet_addr_type);\n\nunsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,\n\t\t\t\t__be32 addr)\n{\n\tu32 rt_table = l3mdev_fib_table(dev) ? : RT_TABLE_LOCAL;\n\n\treturn __inet_dev_addr_type(net, dev, addr, rt_table);\n}\nEXPORT_SYMBOL(inet_dev_addr_type);\n\n/* inet_addr_type with dev == NULL but using the table from a dev\n * if one is associated\n */\nunsigned int inet_addr_type_dev_table(struct net *net,\n\t\t\t\t      const struct net_device *dev,\n\t\t\t\t      __be32 addr)\n{\n\tu32 rt_table = l3mdev_fib_table(dev) ? : RT_TABLE_LOCAL;\n\n\treturn __inet_dev_addr_type(net, NULL, addr, rt_table);\n}\nEXPORT_SYMBOL(inet_addr_type_dev_table);\n\n__be32 fib_compute_spec_dst(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct in_device *in_dev;\n\tstruct fib_result res;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tstruct net *net;\n\tint scope;\n\n\trt = skb_rtable(skb);\n\tif ((rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST | RTCF_LOCAL)) ==\n\t    RTCF_LOCAL)\n\t\treturn ip_hdr(skb)->daddr;\n\n\tin_dev = __in_dev_get_rcu(dev);\n\tBUG_ON(!in_dev);\n\n\tnet = dev_net(dev);\n\n\tscope = RT_SCOPE_UNIVERSE;\n\tif (!ipv4_is_zeronet(ip_hdr(skb)->saddr)) {\n\t\tfl4.flowi4_oif = 0;\n\t\tfl4.flowi4_iif = LOOPBACK_IFINDEX;\n\t\tfl4.daddr = ip_hdr(skb)->saddr;\n\t\tfl4.saddr = 0;\n\t\tfl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);\n\t\tfl4.flowi4_scope = scope;\n\t\tfl4.flowi4_mark = IN_DEV_SRC_VMARK(in_dev) ? skb->mark : 0;\n\t\tfl4.flowi4_tun_key.tun_id = 0;\n\t\tif (!fib_lookup(net, &fl4, &res, 0))\n\t\t\treturn FIB_RES_PREFSRC(net, res);\n\t} else {\n\t\tscope = RT_SCOPE_LINK;\n\t}\n\n\treturn inet_select_addr(dev, ip_hdr(skb)->saddr, scope);\n}\n\n/* Given (packet source, input interface) and optional (dst, oif, tos):\n * - (main) check, that source is valid i.e. not broadcast or our local\n *   address.\n * - figure out what \"logical\" interface this packet arrived\n *   and calculate \"specific destination\" address.\n * - check, that packet arrived from expected physical interface.\n * called with rcu_read_lock()\n */\nstatic int __fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\n\t\t\t\t u8 tos, int oif, struct net_device *dev,\n\t\t\t\t int rpf, struct in_device *idev, u32 *itag)\n{\n\tint ret, no_addr;\n\tstruct fib_result res;\n\tstruct flowi4 fl4;\n\tstruct net *net;\n\tbool dev_match;\n\n\tfl4.flowi4_oif = 0;\n\tfl4.flowi4_iif = l3mdev_master_ifindex_rcu(dev);\n\tif (!fl4.flowi4_iif)\n\t\tfl4.flowi4_iif = oif ? : LOOPBACK_IFINDEX;\n\tfl4.daddr = src;\n\tfl4.saddr = dst;\n\tfl4.flowi4_tos = tos;\n\tfl4.flowi4_scope = RT_SCOPE_UNIVERSE;\n\tfl4.flowi4_tun_key.tun_id = 0;\n\tfl4.flowi4_flags = 0;\n\n\tno_addr = idev->ifa_list == NULL;\n\n\tfl4.flowi4_mark = IN_DEV_SRC_VMARK(idev) ? skb->mark : 0;\n\n\ttrace_fib_validate_source(dev, &fl4);\n\n\tnet = dev_net(dev);\n\tif (fib_lookup(net, &fl4, &res, 0))\n\t\tgoto last_resort;\n\tif (res.type != RTN_UNICAST &&\n\t    (res.type != RTN_LOCAL || !IN_DEV_ACCEPT_LOCAL(idev)))\n\t\tgoto e_inval;\n\tif (!rpf && !fib_num_tclassid_users(dev_net(dev)) &&\n\t    (dev->ifindex != oif || !IN_DEV_TX_REDIRECTS(idev)))\n\t\tgoto last_resort;\n\tfib_combine_itag(itag, &res);\n\tdev_match = false;\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tfor (ret = 0; ret < res.fi->fib_nhs; ret++) {\n\t\tstruct fib_nh *nh = &res.fi->fib_nh[ret];\n\n\t\tif (nh->nh_dev == dev) {\n\t\t\tdev_match = true;\n\t\t\tbreak;\n\t\t} else if (l3mdev_master_ifindex_rcu(nh->nh_dev) == dev->ifindex) {\n\t\t\tdev_match = true;\n\t\t\tbreak;\n\t\t}\n\t}\n#else\n\tif (FIB_RES_DEV(res) == dev)\n\t\tdev_match = true;\n#endif\n\tif (dev_match) {\n\t\tret = FIB_RES_NH(res).nh_scope >= RT_SCOPE_HOST;\n\t\treturn ret;\n\t}\n\tif (no_addr)\n\t\tgoto last_resort;\n\tif (rpf == 1)\n\t\tgoto e_rpf;\n\tfl4.flowi4_oif = dev->ifindex;\n\n\tret = 0;\n\tif (fib_lookup(net, &fl4, &res, FIB_LOOKUP_IGNORE_LINKSTATE) == 0) {\n\t\tif (res.type == RTN_UNICAST)\n\t\t\tret = FIB_RES_NH(res).nh_scope >= RT_SCOPE_HOST;\n\t}\n\treturn ret;\n\nlast_resort:\n\tif (rpf)\n\t\tgoto e_rpf;\n\t*itag = 0;\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\ne_rpf:\n\treturn -EXDEV;\n}\n\n/* Ignore rp_filter for packets protected by IPsec. */\nint fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\n\t\t\tu8 tos, int oif, struct net_device *dev,\n\t\t\tstruct in_device *idev, u32 *itag)\n{\n\tint r = secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);\n\n\tif (!r && !fib_num_tclassid_users(dev_net(dev)) &&\n\t    IN_DEV_ACCEPT_LOCAL(idev) &&\n\t    (dev->ifindex != oif || !IN_DEV_TX_REDIRECTS(idev))) {\n\t\t*itag = 0;\n\t\treturn 0;\n\t}\n\treturn __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);\n}\n\nstatic inline __be32 sk_extract_addr(struct sockaddr *addr)\n{\n\treturn ((struct sockaddr_in *) addr)->sin_addr.s_addr;\n}\n\nstatic int put_rtax(struct nlattr *mx, int len, int type, u32 value)\n{\n\tstruct nlattr *nla;\n\n\tnla = (struct nlattr *) ((char *) mx + len);\n\tnla->nla_type = type;\n\tnla->nla_len = nla_attr_size(4);\n\t*(u32 *) nla_data(nla) = value;\n\n\treturn len + nla_total_size(4);\n}\n\nstatic int rtentry_to_fib_config(struct net *net, int cmd, struct rtentry *rt,\n\t\t\t\t struct fib_config *cfg)\n{\n\t__be32 addr;\n\tint plen;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\tcfg->fc_nlinfo.nl_net = net;\n\n\tif (rt->rt_dst.sa_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * Check mask for validity:\n\t * a) it must be contiguous.\n\t * b) destination must have all host bits clear.\n\t * c) if application forgot to set correct family (AF_INET),\n\t *    reject request unless it is absolutely clear i.e.\n\t *    both family and mask are zero.\n\t */\n\tplen = 32;\n\taddr = sk_extract_addr(&rt->rt_dst);\n\tif (!(rt->rt_flags & RTF_HOST)) {\n\t\t__be32 mask = sk_extract_addr(&rt->rt_genmask);\n\n\t\tif (rt->rt_genmask.sa_family != AF_INET) {\n\t\t\tif (mask || rt->rt_genmask.sa_family)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tif (bad_mask(mask, addr))\n\t\t\treturn -EINVAL;\n\n\t\tplen = inet_mask_len(mask);\n\t}\n\n\tcfg->fc_dst_len = plen;\n\tcfg->fc_dst = addr;\n\n\tif (cmd != SIOCDELRT) {\n\t\tcfg->fc_nlflags = NLM_F_CREATE;\n\t\tcfg->fc_protocol = RTPROT_BOOT;\n\t}\n\n\tif (rt->rt_metric)\n\t\tcfg->fc_priority = rt->rt_metric - 1;\n\n\tif (rt->rt_flags & RTF_REJECT) {\n\t\tcfg->fc_scope = RT_SCOPE_HOST;\n\t\tcfg->fc_type = RTN_UNREACHABLE;\n\t\treturn 0;\n\t}\n\n\tcfg->fc_scope = RT_SCOPE_NOWHERE;\n\tcfg->fc_type = RTN_UNICAST;\n\n\tif (rt->rt_dev) {\n\t\tchar *colon;\n\t\tstruct net_device *dev;\n\t\tchar devname[IFNAMSIZ];\n\n\t\tif (copy_from_user(devname, rt->rt_dev, IFNAMSIZ-1))\n\t\t\treturn -EFAULT;\n\n\t\tdevname[IFNAMSIZ-1] = 0;\n\t\tcolon = strchr(devname, ':');\n\t\tif (colon)\n\t\t\t*colon = 0;\n\t\tdev = __dev_get_by_name(net, devname);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\t\tcfg->fc_oif = dev->ifindex;\n\t\tif (colon) {\n\t\t\tstruct in_ifaddr *ifa;\n\t\t\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\t\t\tif (!in_dev)\n\t\t\t\treturn -ENODEV;\n\t\t\t*colon = ':';\n\t\t\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next)\n\t\t\t\tif (strcmp(ifa->ifa_label, devname) == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (!ifa)\n\t\t\t\treturn -ENODEV;\n\t\t\tcfg->fc_prefsrc = ifa->ifa_local;\n\t\t}\n\t}\n\n\taddr = sk_extract_addr(&rt->rt_gateway);\n\tif (rt->rt_gateway.sa_family == AF_INET && addr) {\n\t\tunsigned int addr_type;\n\n\t\tcfg->fc_gw = addr;\n\t\taddr_type = inet_addr_type_table(net, addr, cfg->fc_table);\n\t\tif (rt->rt_flags & RTF_GATEWAY &&\n\t\t    addr_type == RTN_UNICAST)\n\t\t\tcfg->fc_scope = RT_SCOPE_UNIVERSE;\n\t}\n\n\tif (cmd == SIOCDELRT)\n\t\treturn 0;\n\n\tif (rt->rt_flags & RTF_GATEWAY && !cfg->fc_gw)\n\t\treturn -EINVAL;\n\n\tif (cfg->fc_scope == RT_SCOPE_NOWHERE)\n\t\tcfg->fc_scope = RT_SCOPE_LINK;\n\n\tif (rt->rt_flags & (RTF_MTU | RTF_WINDOW | RTF_IRTT)) {\n\t\tstruct nlattr *mx;\n\t\tint len = 0;\n\n\t\tmx = kzalloc(3 * nla_total_size(4), GFP_KERNEL);\n\t\tif (!mx)\n\t\t\treturn -ENOMEM;\n\n\t\tif (rt->rt_flags & RTF_MTU)\n\t\t\tlen = put_rtax(mx, len, RTAX_ADVMSS, rt->rt_mtu - 40);\n\n\t\tif (rt->rt_flags & RTF_WINDOW)\n\t\t\tlen = put_rtax(mx, len, RTAX_WINDOW, rt->rt_window);\n\n\t\tif (rt->rt_flags & RTF_IRTT)\n\t\t\tlen = put_rtax(mx, len, RTAX_RTT, rt->rt_irtt << 3);\n\n\t\tcfg->fc_mx = mx;\n\t\tcfg->fc_mx_len = len;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Handle IP routing ioctl calls.\n * These are used to manipulate the routing tables\n */\nint ip_rt_ioctl(struct net *net, unsigned int cmd, void __user *arg)\n{\n\tstruct fib_config cfg;\n\tstruct rtentry rt;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\t\t/* Add a route */\n\tcase SIOCDELRT:\t\t/* Delete a route */\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&rt, arg, sizeof(rt)))\n\t\t\treturn -EFAULT;\n\n\t\trtnl_lock();\n\t\terr = rtentry_to_fib_config(net, cmd, &rt, &cfg);\n\t\tif (err == 0) {\n\t\t\tstruct fib_table *tb;\n\n\t\t\tif (cmd == SIOCDELRT) {\n\t\t\t\ttb = fib_get_table(net, cfg.fc_table);\n\t\t\t\tif (tb)\n\t\t\t\t\terr = fib_table_delete(tb, &cfg);\n\t\t\t\telse\n\t\t\t\t\terr = -ESRCH;\n\t\t\t} else {\n\t\t\t\ttb = fib_new_table(net, cfg.fc_table);\n\t\t\t\tif (tb)\n\t\t\t\t\terr = fib_table_insert(tb, &cfg);\n\t\t\t\telse\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\n\t\t\t/* allocated by rtentry_to_fib_config() */\n\t\t\tkfree(cfg.fc_mx);\n\t\t}\n\t\trtnl_unlock();\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}\n\nconst struct nla_policy rtm_ipv4_policy[RTA_MAX + 1] = {\n\t[RTA_DST]\t\t= { .type = NLA_U32 },\n\t[RTA_SRC]\t\t= { .type = NLA_U32 },\n\t[RTA_IIF]\t\t= { .type = NLA_U32 },\n\t[RTA_OIF]\t\t= { .type = NLA_U32 },\n\t[RTA_GATEWAY]\t\t= { .type = NLA_U32 },\n\t[RTA_PRIORITY]\t\t= { .type = NLA_U32 },\n\t[RTA_PREFSRC]\t\t= { .type = NLA_U32 },\n\t[RTA_METRICS]\t\t= { .type = NLA_NESTED },\n\t[RTA_MULTIPATH]\t\t= { .len = sizeof(struct rtnexthop) },\n\t[RTA_FLOW]\t\t= { .type = NLA_U32 },\n\t[RTA_ENCAP_TYPE]\t= { .type = NLA_U16 },\n\t[RTA_ENCAP]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int rtm_to_fib_config(struct net *net, struct sk_buff *skb,\n\t\t\t     struct nlmsghdr *nlh, struct fib_config *cfg)\n{\n\tstruct nlattr *attr;\n\tint err, remaining;\n\tstruct rtmsg *rtm;\n\n\terr = nlmsg_validate(nlh, sizeof(*rtm), RTA_MAX, rtm_ipv4_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\trtm = nlmsg_data(nlh);\n\tcfg->fc_dst_len = rtm->rtm_dst_len;\n\tcfg->fc_tos = rtm->rtm_tos;\n\tcfg->fc_table = rtm->rtm_table;\n\tcfg->fc_protocol = rtm->rtm_protocol;\n\tcfg->fc_scope = rtm->rtm_scope;\n\tcfg->fc_type = rtm->rtm_type;\n\tcfg->fc_flags = rtm->rtm_flags;\n\tcfg->fc_nlflags = nlh->nlmsg_flags;\n\n\tcfg->fc_nlinfo.portid = NETLINK_CB(skb).portid;\n\tcfg->fc_nlinfo.nlh = nlh;\n\tcfg->fc_nlinfo.nl_net = net;\n\n\tif (cfg->fc_type > RTN_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tnlmsg_for_each_attr(attr, nlh, sizeof(struct rtmsg), remaining) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase RTA_DST:\n\t\t\tcfg->fc_dst = nla_get_be32(attr);\n\t\t\tbreak;\n\t\tcase RTA_OIF:\n\t\t\tcfg->fc_oif = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_GATEWAY:\n\t\t\tcfg->fc_gw = nla_get_be32(attr);\n\t\t\tbreak;\n\t\tcase RTA_PRIORITY:\n\t\t\tcfg->fc_priority = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_PREFSRC:\n\t\t\tcfg->fc_prefsrc = nla_get_be32(attr);\n\t\t\tbreak;\n\t\tcase RTA_METRICS:\n\t\t\tcfg->fc_mx = nla_data(attr);\n\t\t\tcfg->fc_mx_len = nla_len(attr);\n\t\t\tbreak;\n\t\tcase RTA_MULTIPATH:\n\t\t\tcfg->fc_mp = nla_data(attr);\n\t\t\tcfg->fc_mp_len = nla_len(attr);\n\t\t\tbreak;\n\t\tcase RTA_FLOW:\n\t\t\tcfg->fc_flow = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_TABLE:\n\t\t\tcfg->fc_table = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_ENCAP:\n\t\t\tcfg->fc_encap = attr;\n\t\t\tbreak;\n\t\tcase RTA_ENCAP_TYPE:\n\t\t\tcfg->fc_encap_type = nla_get_u16(attr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\nerrout:\n\treturn err;\n}\n\nstatic int inet_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_config cfg;\n\tstruct fib_table *tb;\n\tint err;\n\n\terr = rtm_to_fib_config(net, skb, nlh, &cfg);\n\tif (err < 0)\n\t\tgoto errout;\n\n\ttb = fib_get_table(net, cfg.fc_table);\n\tif (!tb) {\n\t\terr = -ESRCH;\n\t\tgoto errout;\n\t}\n\n\terr = fib_table_delete(tb, &cfg);\nerrout:\n\treturn err;\n}\n\nstatic int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_config cfg;\n\tstruct fib_table *tb;\n\tint err;\n\n\terr = rtm_to_fib_config(net, skb, nlh, &cfg);\n\tif (err < 0)\n\t\tgoto errout;\n\n\ttb = fib_new_table(net, cfg.fc_table);\n\tif (!tb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\terr = fib_table_insert(tb, &cfg);\nerrout:\n\treturn err;\n}\n\nstatic int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int h, s_h;\n\tunsigned int e = 0, s_e;\n\tstruct fib_table *tb;\n\tstruct hlist_head *head;\n\tint dumped = 0;\n\n\tif (nlmsg_len(cb->nlh) >= sizeof(struct rtmsg) &&\n\t    ((struct rtmsg *) nlmsg_data(cb->nlh))->rtm_flags & RTM_F_CLONED)\n\t\treturn skb->len;\n\n\ts_h = cb->args[0];\n\ts_e = cb->args[1];\n\n\trcu_read_lock();\n\n\tfor (h = s_h; h < FIB_TABLE_HASHSZ; h++, s_e = 0) {\n\t\te = 0;\n\t\thead = &net->ipv4.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next;\n\t\t\tif (dumped)\n\t\t\t\tmemset(&cb->args[2], 0, sizeof(cb->args) -\n\t\t\t\t\t\t 2 * sizeof(cb->args[0]));\n\t\t\tif (fib_table_dump(tb, skb, cb) < 0)\n\t\t\t\tgoto out;\n\t\t\tdumped = 1;\nnext:\n\t\t\te++;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\n\tcb->args[1] = e;\n\tcb->args[0] = h;\n\n\treturn skb->len;\n}\n\n/* Prepare and feed intra-kernel routing request.\n * Really, it should be netlink message, but :-( netlink\n * can be not configured, so that we feed it directly\n * to fib engine. It is legal, because all events occur\n * only when netlink is already locked.\n */\nstatic void fib_magic(int cmd, int type, __be32 dst, int dst_len, struct in_ifaddr *ifa)\n{\n\tstruct net *net = dev_net(ifa->ifa_dev->dev);\n\tu32 tb_id = l3mdev_fib_table(ifa->ifa_dev->dev);\n\tstruct fib_table *tb;\n\tstruct fib_config cfg = {\n\t\t.fc_protocol = RTPROT_KERNEL,\n\t\t.fc_type = type,\n\t\t.fc_dst = dst,\n\t\t.fc_dst_len = dst_len,\n\t\t.fc_prefsrc = ifa->ifa_local,\n\t\t.fc_oif = ifa->ifa_dev->dev->ifindex,\n\t\t.fc_nlflags = NLM_F_CREATE | NLM_F_APPEND,\n\t\t.fc_nlinfo = {\n\t\t\t.nl_net = net,\n\t\t},\n\t};\n\n\tif (!tb_id)\n\t\ttb_id = (type == RTN_UNICAST) ? RT_TABLE_MAIN : RT_TABLE_LOCAL;\n\n\ttb = fib_new_table(net, tb_id);\n\tif (!tb)\n\t\treturn;\n\n\tcfg.fc_table = tb->tb_id;\n\n\tif (type != RTN_LOCAL)\n\t\tcfg.fc_scope = RT_SCOPE_LINK;\n\telse\n\t\tcfg.fc_scope = RT_SCOPE_HOST;\n\n\tif (cmd == RTM_NEWROUTE)\n\t\tfib_table_insert(tb, &cfg);\n\telse\n\t\tfib_table_delete(tb, &cfg);\n}\n\nvoid fib_add_ifaddr(struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct in_ifaddr *prim = ifa;\n\t__be32 mask = ifa->ifa_mask;\n\t__be32 addr = ifa->ifa_local;\n\t__be32 prefix = ifa->ifa_address & mask;\n\n\tif (ifa->ifa_flags & IFA_F_SECONDARY) {\n\t\tprim = inet_ifa_byprefix(in_dev, prefix, mask);\n\t\tif (!prim) {\n\t\t\tpr_warn(\"%s: bug: prim == NULL\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfib_magic(RTM_NEWROUTE, RTN_LOCAL, addr, 32, prim);\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn;\n\n\t/* Add broadcast address, if it is explicitly assigned. */\n\tif (ifa->ifa_broadcast && ifa->ifa_broadcast != htonl(0xFFFFFFFF))\n\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);\n\n\tif (!ipv4_is_zeronet(prefix) && !(ifa->ifa_flags & IFA_F_SECONDARY) &&\n\t    (prefix != addr || ifa->ifa_prefixlen < 32)) {\n\t\tif (!(ifa->ifa_flags & IFA_F_NOPREFIXROUTE))\n\t\t\tfib_magic(RTM_NEWROUTE,\n\t\t\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t\t\t  prefix, ifa->ifa_prefixlen, prim);\n\n\t\t/* Add network specific broadcasts, when it takes a sense */\n\t\tif (ifa->ifa_prefixlen < 31) {\n\t\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix, 32, prim);\n\t\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix | ~mask,\n\t\t\t\t  32, prim);\n\t\t}\n\t}\n}\n\n/* Delete primary or secondary address.\n * Optionally, on secondary address promotion consider the addresses\n * from subnet iprim as deleted, even if they are in device list.\n * In this case the secondary ifa can be in device list.\n */\nvoid fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct in_ifaddr *ifa1;\n\tstruct in_ifaddr *prim = ifa, *prim1 = NULL;\n\t__be32 brd = ifa->ifa_address | ~ifa->ifa_mask;\n\t__be32 any = ifa->ifa_address & ifa->ifa_mask;\n#define LOCAL_OK\t1\n#define BRD_OK\t\t2\n#define BRD0_OK\t\t4\n#define BRD1_OK\t\t8\n\tunsigned int ok = 0;\n\tint subnet = 0;\t\t/* Primary network */\n\tint gone = 1;\t\t/* Address is missing */\n\tint same_prefsrc = 0;\t/* Another primary with same IP */\n\n\tif (ifa->ifa_flags & IFA_F_SECONDARY) {\n\t\tprim = inet_ifa_byprefix(in_dev, any, ifa->ifa_mask);\n\t\tif (!prim) {\n\t\t\tpr_warn(\"%s: bug: prim == NULL\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif (iprim && iprim != prim) {\n\t\t\tpr_warn(\"%s: bug: iprim != prim\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t} else if (!ipv4_is_zeronet(any) &&\n\t\t   (any != ifa->ifa_local || ifa->ifa_prefixlen < 32)) {\n\t\tif (!(ifa->ifa_flags & IFA_F_NOPREFIXROUTE))\n\t\t\tfib_magic(RTM_DELROUTE,\n\t\t\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t\t\t  any, ifa->ifa_prefixlen, prim);\n\t\tsubnet = 1;\n\t}\n\n\t/* Deletion is more complicated than add.\n\t * We should take care of not to delete too much :-)\n\t *\n\t * Scan address list to be sure that addresses are really gone.\n\t */\n\n\tfor (ifa1 = in_dev->ifa_list; ifa1; ifa1 = ifa1->ifa_next) {\n\t\tif (ifa1 == ifa) {\n\t\t\t/* promotion, keep the IP */\n\t\t\tgone = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ignore IFAs from our subnet */\n\t\tif (iprim && ifa1->ifa_mask == iprim->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, iprim))\n\t\t\tcontinue;\n\n\t\t/* Ignore ifa1 if it uses different primary IP (prefsrc) */\n\t\tif (ifa1->ifa_flags & IFA_F_SECONDARY) {\n\t\t\t/* Another address from our subnet? */\n\t\t\tif (ifa1->ifa_mask == prim->ifa_mask &&\n\t\t\t    inet_ifa_match(ifa1->ifa_address, prim))\n\t\t\t\tprim1 = prim;\n\t\t\telse {\n\t\t\t\t/* We reached the secondaries, so\n\t\t\t\t * same_prefsrc should be determined.\n\t\t\t\t */\n\t\t\t\tif (!same_prefsrc)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Search new prim1 if ifa1 is not\n\t\t\t\t * using the current prim1\n\t\t\t\t */\n\t\t\t\tif (!prim1 ||\n\t\t\t\t    ifa1->ifa_mask != prim1->ifa_mask ||\n\t\t\t\t    !inet_ifa_match(ifa1->ifa_address, prim1))\n\t\t\t\t\tprim1 = inet_ifa_byprefix(in_dev,\n\t\t\t\t\t\t\tifa1->ifa_address,\n\t\t\t\t\t\t\tifa1->ifa_mask);\n\t\t\t\tif (!prim1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (prim1->ifa_local != prim->ifa_local)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (prim->ifa_local != ifa1->ifa_local)\n\t\t\t\tcontinue;\n\t\t\tprim1 = ifa1;\n\t\t\tif (prim != prim1)\n\t\t\t\tsame_prefsrc = 1;\n\t\t}\n\t\tif (ifa->ifa_local == ifa1->ifa_local)\n\t\t\tok |= LOCAL_OK;\n\t\tif (ifa->ifa_broadcast == ifa1->ifa_broadcast)\n\t\t\tok |= BRD_OK;\n\t\tif (brd == ifa1->ifa_broadcast)\n\t\t\tok |= BRD1_OK;\n\t\tif (any == ifa1->ifa_broadcast)\n\t\t\tok |= BRD0_OK;\n\t\t/* primary has network specific broadcasts */\n\t\tif (prim1 == ifa1 && ifa1->ifa_prefixlen < 31) {\n\t\t\t__be32 brd1 = ifa1->ifa_address | ~ifa1->ifa_mask;\n\t\t\t__be32 any1 = ifa1->ifa_address & ifa1->ifa_mask;\n\n\t\t\tif (!ipv4_is_zeronet(any1)) {\n\t\t\t\tif (ifa->ifa_broadcast == brd1 ||\n\t\t\t\t    ifa->ifa_broadcast == any1)\n\t\t\t\t\tok |= BRD_OK;\n\t\t\t\tif (brd == brd1 || brd == any1)\n\t\t\t\t\tok |= BRD1_OK;\n\t\t\t\tif (any == brd1 || any == any1)\n\t\t\t\t\tok |= BRD0_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(ok & BRD_OK))\n\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);\n\tif (subnet && ifa->ifa_prefixlen < 31) {\n\t\tif (!(ok & BRD1_OK))\n\t\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, brd, 32, prim);\n\t\tif (!(ok & BRD0_OK))\n\t\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, any, 32, prim);\n\t}\n\tif (!(ok & LOCAL_OK)) {\n\t\tunsigned int addr_type;\n\n\t\tfib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 32, prim);\n\n\t\t/* Check, that this local address finally disappeared. */\n\t\taddr_type = inet_addr_type_dev_table(dev_net(dev), dev,\n\t\t\t\t\t\t     ifa->ifa_local);\n\t\tif (gone && addr_type != RTN_LOCAL) {\n\t\t\t/* And the last, but not the least thing.\n\t\t\t * We must flush stray FIB entries.\n\t\t\t *\n\t\t\t * First of all, we scan fib_info list searching\n\t\t\t * for stray nexthop entries, then ignite fib_flush.\n\t\t\t */\n\t\t\tif (fib_sync_down_addr(dev_net(dev), ifa->ifa_local))\n\t\t\t\tfib_flush(dev_net(dev));\n\t\t}\n\t}\n#undef LOCAL_OK\n#undef BRD_OK\n#undef BRD0_OK\n#undef BRD1_OK\n}\n\nstatic void nl_fib_lookup(struct net *net, struct fib_result_nl *frn)\n{\n\n\tstruct fib_result       res;\n\tstruct flowi4           fl4 = {\n\t\t.flowi4_mark = frn->fl_mark,\n\t\t.daddr = frn->fl_addr,\n\t\t.flowi4_tos = frn->fl_tos,\n\t\t.flowi4_scope = frn->fl_scope,\n\t};\n\tstruct fib_table *tb;\n\n\trcu_read_lock();\n\n\ttb = fib_get_table(net, frn->tb_id_in);\n\n\tfrn->err = -ENOENT;\n\tif (tb) {\n\t\tlocal_bh_disable();\n\n\t\tfrn->tb_id = tb->tb_id;\n\t\tfrn->err = fib_table_lookup(tb, &fl4, &res, FIB_LOOKUP_NOREF);\n\n\t\tif (!frn->err) {\n\t\t\tfrn->prefixlen = res.prefixlen;\n\t\t\tfrn->nh_sel = res.nh_sel;\n\t\t\tfrn->type = res.type;\n\t\t\tfrn->scope = res.scope;\n\t\t}\n\t\tlocal_bh_enable();\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void nl_fib_input(struct sk_buff *skb)\n{\n\tstruct net *net;\n\tstruct fib_result_nl *frn;\n\tstruct nlmsghdr *nlh;\n\tu32 portid;\n\n\tnet = sock_net(skb->sk);\n\tnlh = nlmsg_hdr(skb);\n\tif (skb->len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len ||\n\t    nlmsg_len(nlh) < sizeof(*frn))\n\t\treturn;\n\n\tskb = netlink_skb_clone(skb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\tnlh = nlmsg_hdr(skb);\n\n\tfrn = (struct fib_result_nl *) nlmsg_data(nlh);\n\tnl_fib_lookup(net, frn);\n\n\tportid = NETLINK_CB(skb).portid;      /* netlink portid */\n\tNETLINK_CB(skb).portid = 0;        /* from kernel */\n\tNETLINK_CB(skb).dst_group = 0;  /* unicast */\n\tnetlink_unicast(net->ipv4.fibnl, skb, portid, MSG_DONTWAIT);\n}\n\nstatic int __net_init nl_fib_lookup_init(struct net *net)\n{\n\tstruct sock *sk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= nl_fib_input,\n\t};\n\n\tsk = netlink_kernel_create(net, NETLINK_FIB_LOOKUP, &cfg);\n\tif (!sk)\n\t\treturn -EAFNOSUPPORT;\n\tnet->ipv4.fibnl = sk;\n\treturn 0;\n}\n\nstatic void nl_fib_lookup_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->ipv4.fibnl);\n\tnet->ipv4.fibnl = NULL;\n}\n\nstatic void fib_disable_ip(struct net_device *dev, unsigned long event,\n\t\t\t   bool force)\n{\n\tif (fib_sync_down_dev(dev, event, force))\n\t\tfib_flush(dev_net(dev));\n\trt_cache_flush(dev_net(dev));\n\tarp_ifdown(dev);\n}\n\nstatic int fib_inetaddr_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct net *net = dev_net(dev);\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tfib_add_ifaddr(ifa);\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t\tfib_sync_up(dev, RTNH_F_DEAD);\n#endif\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\trt_cache_flush(dev_net(dev));\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tfib_del_ifaddr(ifa, NULL);\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\tif (!ifa->ifa_dev->ifa_list) {\n\t\t\t/* Last address was deleted from this interface.\n\t\t\t * Disable IP.\n\t\t\t */\n\t\t\tfib_disable_ip(dev, event, true);\n\t\t} else {\n\t\t\trt_cache_flush(dev_net(dev));\n\t\t}\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic int fib_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info;\n\tstruct in_device *in_dev;\n\tstruct net *net = dev_net(dev);\n\tunsigned int flags;\n\n\tif (event == NETDEV_UNREGISTER) {\n\t\tfib_disable_ip(dev, event, true);\n\t\trt_flush_dev(dev);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\tif (!in_dev)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tfor_ifa(in_dev) {\n\t\t\tfib_add_ifaddr(ifa);\n\t\t} endfor_ifa(in_dev);\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t\tfib_sync_up(dev, RTNH_F_DEAD);\n#endif\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\trt_cache_flush(net);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tfib_disable_ip(dev, event, false);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tflags = dev_get_flags(dev);\n\t\tif (flags & (IFF_RUNNING | IFF_LOWER_UP))\n\t\t\tfib_sync_up(dev, RTNH_F_LINKDOWN);\n\t\telse\n\t\t\tfib_sync_down_dev(dev, event, false);\n\t\t/* fall through */\n\tcase NETDEV_CHANGEMTU:\n\t\trt_cache_flush(net);\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tinfo = ptr;\n\t\t/* flush all routes if dev is linked to or unlinked from\n\t\t * an L3 master device (e.g., VRF)\n\t\t */\n\t\tif (info->upper_dev && netif_is_l3_master(info->upper_dev))\n\t\t\tfib_disable_ip(dev, NETDEV_DOWN, true);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block fib_inetaddr_notifier = {\n\t.notifier_call = fib_inetaddr_event,\n};\n\nstatic struct notifier_block fib_netdev_notifier = {\n\t.notifier_call = fib_netdev_event,\n};\n\nstatic int __net_init ip_fib_net_init(struct net *net)\n{\n\tint err;\n\tsize_t size = sizeof(struct hlist_head) * FIB_TABLE_HASHSZ;\n\n\t/* Avoid false sharing : Use at least a full cache line */\n\tsize = max_t(size_t, size, L1_CACHE_BYTES);\n\n\tnet->ipv4.fib_table_hash = kzalloc(size, GFP_KERNEL);\n\tif (!net->ipv4.fib_table_hash)\n\t\treturn -ENOMEM;\n\n\terr = fib4_rules_init(net);\n\tif (err < 0)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tkfree(net->ipv4.fib_table_hash);\n\treturn err;\n}\n\nstatic void ip_fib_net_exit(struct net *net)\n{\n\tunsigned int i;\n\n\trtnl_lock();\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tRCU_INIT_POINTER(net->ipv4.fib_local, NULL);\n\tRCU_INIT_POINTER(net->ipv4.fib_main, NULL);\n\tRCU_INIT_POINTER(net->ipv4.fib_default, NULL);\n#endif\n\tfor (i = 0; i < FIB_TABLE_HASHSZ; i++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[i];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb_hlist) {\n\t\t\thlist_del(&tb->tb_hlist);\n\t\t\tfib_table_flush(tb);\n\t\t\tfib_free_table(tb);\n\t\t}\n\t}\n\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tfib4_rules_exit(net);\n#endif\n\trtnl_unlock();\n\tkfree(net->ipv4.fib_table_hash);\n}\n\nstatic int __net_init fib_net_init(struct net *net)\n{\n\tint error;\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tnet->ipv4.fib_num_tclassid_users = 0;\n#endif\n\terror = ip_fib_net_init(net);\n\tif (error < 0)\n\t\tgoto out;\n\terror = nl_fib_lookup_init(net);\n\tif (error < 0)\n\t\tgoto out_nlfl;\n\terror = fib_proc_init(net);\n\tif (error < 0)\n\t\tgoto out_proc;\nout:\n\treturn error;\n\nout_proc:\n\tnl_fib_lookup_exit(net);\nout_nlfl:\n\tip_fib_net_exit(net);\n\tgoto out;\n}\n\nstatic void __net_exit fib_net_exit(struct net *net)\n{\n\tfib_proc_exit(net);\n\tnl_fib_lookup_exit(net);\n\tip_fib_net_exit(net);\n}\n\nstatic struct pernet_operations fib_net_ops = {\n\t.init = fib_net_init,\n\t.exit = fib_net_exit,\n};\n\nvoid __init ip_fib_init(void)\n{\n\trtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);\n\trtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);\n\trtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);\n\n\tregister_pernet_subsys(&fib_net_ops);\n\tregister_netdevice_notifier(&fib_netdev_notifier);\n\tregister_inetaddr_notifier(&fib_inetaddr_notifier);\n\n\tfib_trie_init();\n}\n", "/* (C) 1999-2001 Paul `Rusty' Russell\n * (C) 2002-2006 Netfilter Core Team <coreteam@netfilter.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/inetdevice.h>\n#include <linux/ip.h>\n#include <linux/timer.h>\n#include <linux/netfilter.h>\n#include <net/protocol.h>\n#include <net/ip.h>\n#include <net/checksum.h>\n#include <net/route.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter/x_tables.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/ipv4/nf_nat_masquerade.h>\n\nunsigned int\nnf_nat_masquerade_ipv4(struct sk_buff *skb, unsigned int hooknum,\n\t\t       const struct nf_nat_range *range,\n\t\t       const struct net_device *out)\n{\n\tstruct nf_conn *ct;\n\tstruct nf_conn_nat *nat;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_nat_range newrange;\n\tconst struct rtable *rt;\n\t__be32 newsrc, nh;\n\n\tNF_CT_ASSERT(hooknum == NF_INET_POST_ROUTING);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tnat = nfct_nat(ct);\n\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\n\t\t\t    ctinfo == IP_CT_RELATED_REPLY));\n\n\t/* Source address is 0.0.0.0 - locally generated packet that is\n\t * probably not supposed to be masqueraded.\n\t */\n\tif (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip == 0)\n\t\treturn NF_ACCEPT;\n\n\trt = skb_rtable(skb);\n\tnh = rt_nexthop(rt, ip_hdr(skb)->daddr);\n\tnewsrc = inet_select_addr(out, nh, RT_SCOPE_UNIVERSE);\n\tif (!newsrc) {\n\t\tpr_info(\"%s ate my IP address\\n\", out->name);\n\t\treturn NF_DROP;\n\t}\n\n\tnat->masq_index = out->ifindex;\n\n\t/* Transfer from original range. */\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags       = range->flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newsrc;\n\tnewrange.max_addr.ip = newsrc;\n\tnewrange.min_proto   = range->min_proto;\n\tnewrange.max_proto   = range->max_proto;\n\n\t/* Hand modified range to generic setup. */\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_SRC);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4);\n\nstatic int device_cmp(struct nf_conn *i, void *ifindex)\n{\n\tconst struct nf_conn_nat *nat = nfct_nat(i);\n\n\tif (!nat)\n\t\treturn 0;\n\tif (nf_ct_l3num(i) != NFPROTO_IPV4)\n\t\treturn 0;\n\treturn nat->masq_index == (int)(long)ifindex;\n}\n\nstatic int masq_device_event(struct notifier_block *this,\n\t\t\t     unsigned long event,\n\t\t\t     void *ptr)\n{\n\tconst struct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\n\tif (event == NETDEV_DOWN) {\n\t\t/* Device was downed.  Search entire table for\n\t\t * conntracks which were associated with that device,\n\t\t * and forget them.\n\t\t */\n\t\tNF_CT_ASSERT(dev->ifindex != 0);\n\n\t\tnf_ct_iterate_cleanup(net, device_cmp,\n\t\t\t\t      (void *)(long)dev->ifindex, 0, 0);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}\n\nstatic struct notifier_block masq_dev_notifier = {\n\t.notifier_call\t= masq_device_event,\n};\n\nstatic struct notifier_block masq_inet_notifier = {\n\t.notifier_call\t= masq_inet_event,\n};\n\nstatic atomic_t masquerade_notifier_refcount = ATOMIC_INIT(0);\n\nvoid nf_nat_masquerade_ipv4_register_notifier(void)\n{\n\t/* check if the notifier was already set */\n\tif (atomic_inc_return(&masquerade_notifier_refcount) > 1)\n\t\treturn;\n\n\t/* Register for device down reports */\n\tregister_netdevice_notifier(&masq_dev_notifier);\n\t/* Register IP address change reports */\n\tregister_inetaddr_notifier(&masq_inet_notifier);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4_register_notifier);\n\nvoid nf_nat_masquerade_ipv4_unregister_notifier(void)\n{\n\t/* check if the notifier still has clients */\n\tif (atomic_dec_return(&masquerade_notifier_refcount) > 0)\n\t\treturn;\n\n\tunregister_netdevice_notifier(&masq_dev_notifier);\n\tunregister_inetaddr_notifier(&masq_inet_notifier);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4_unregister_notifier);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Rusty Russell <rusty@rustcorp.com.au>\");\n"], "fixing_code": ["/*\n *\tNET3\tIP device support routines.\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\tDerived from the IP parts of dev.c 1.0.19\n * \t\tAuthors:\tRoss Biro\n *\t\t\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\t\t\tMark Evans, <evansmp@uhura.aston.ac.uk>\n *\n *\tAdditional Authors:\n *\t\tAlan Cox, <gw4pts@gw4pts.ampr.org>\n *\t\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n *\tChanges:\n *\t\tAlexey Kuznetsov:\tpa_* fields are replaced with ifaddr\n *\t\t\t\t\tlists.\n *\t\tCyrus Durgin:\t\tupdated for kmod\n *\t\tMatthias Andree:\tin devinet_ioctl, compare label and\n *\t\t\t\t\taddress (4.4BSD alias style support),\n *\t\t\t\t\tfall back to comparing just the label\n *\t\t\t\t\tif no match found.\n */\n\n\n#include <asm/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/if_addr.h>\n#include <linux/if_ether.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/notifier.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n#include <linux/kmod.h>\n#include <linux/netconf.h>\n\n#include <net/arp.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/ip_fib.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/addrconf.h>\n\n#include \"fib_lookup.h\"\n\nstatic struct ipv4_devconf ipv4_devconf = {\n\t.data = {\n\t\t[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SEND_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SECURE_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,\n\t\t[IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL - 1] = 10000 /*ms*/,\n\t\t[IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL - 1] =  1000 /*ms*/,\n\t},\n};\n\nstatic struct ipv4_devconf ipv4_devconf_dflt = {\n\t.data = {\n\t\t[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SEND_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SECURE_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,\n\t\t[IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE - 1] = 1,\n\t\t[IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL - 1] = 10000 /*ms*/,\n\t\t[IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL - 1] =  1000 /*ms*/,\n\t},\n};\n\n#define IPV4_DEVCONF_DFLT(net, attr) \\\n\tIPV4_DEVCONF((*net->ipv4.devconf_dflt), attr)\n\nstatic const struct nla_policy ifa_ipv4_policy[IFA_MAX+1] = {\n\t[IFA_LOCAL]     \t= { .type = NLA_U32 },\n\t[IFA_ADDRESS]   \t= { .type = NLA_U32 },\n\t[IFA_BROADCAST] \t= { .type = NLA_U32 },\n\t[IFA_LABEL]     \t= { .type = NLA_STRING, .len = IFNAMSIZ - 1 },\n\t[IFA_CACHEINFO]\t\t= { .len = sizeof(struct ifa_cacheinfo) },\n\t[IFA_FLAGS]\t\t= { .type = NLA_U32 },\n};\n\n#define IN4_ADDR_HSIZE_SHIFT\t8\n#define IN4_ADDR_HSIZE\t\t(1U << IN4_ADDR_HSIZE_SHIFT)\n\nstatic struct hlist_head inet_addr_lst[IN4_ADDR_HSIZE];\n\nstatic u32 inet_addr_hash(const struct net *net, __be32 addr)\n{\n\tu32 val = (__force u32) addr ^ net_hash_mix(net);\n\n\treturn hash_32(val, IN4_ADDR_HSIZE_SHIFT);\n}\n\nstatic void inet_hash_insert(struct net *net, struct in_ifaddr *ifa)\n{\n\tu32 hash = inet_addr_hash(net, ifa->ifa_local);\n\n\tASSERT_RTNL();\n\thlist_add_head_rcu(&ifa->hash, &inet_addr_lst[hash]);\n}\n\nstatic void inet_hash_remove(struct in_ifaddr *ifa)\n{\n\tASSERT_RTNL();\n\thlist_del_init_rcu(&ifa->hash);\n}\n\n/**\n * __ip_dev_find - find the first device with a given source address.\n * @net: the net namespace\n * @addr: the source address\n * @devref: if true, take a reference on the found device\n *\n * If a caller uses devref=false, it should be protected by RCU, or RTNL\n */\nstruct net_device *__ip_dev_find(struct net *net, __be32 addr, bool devref)\n{\n\tu32 hash = inet_addr_hash(net, addr);\n\tstruct net_device *result = NULL;\n\tstruct in_ifaddr *ifa;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(ifa, &inet_addr_lst[hash], hash) {\n\t\tif (ifa->ifa_local == addr) {\n\t\t\tstruct net_device *dev = ifa->ifa_dev->dev;\n\n\t\t\tif (!net_eq(dev_net(dev), net))\n\t\t\t\tcontinue;\n\t\t\tresult = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result) {\n\t\tstruct flowi4 fl4 = { .daddr = addr };\n\t\tstruct fib_result res = { 0 };\n\t\tstruct fib_table *local;\n\n\t\t/* Fallback to FIB local table so that communication\n\t\t * over loopback subnets work.\n\t\t */\n\t\tlocal = fib_get_table(net, RT_TABLE_LOCAL);\n\t\tif (local &&\n\t\t    !fib_table_lookup(local, &fl4, &res, FIB_LOOKUP_NOREF) &&\n\t\t    res.type == RTN_LOCAL)\n\t\t\tresult = FIB_RES_DEV(res);\n\t}\n\tif (result && devref)\n\t\tdev_hold(result);\n\trcu_read_unlock();\n\treturn result;\n}\nEXPORT_SYMBOL(__ip_dev_find);\n\nstatic void rtmsg_ifa(int event, struct in_ifaddr *, struct nlmsghdr *, u32);\n\nstatic BLOCKING_NOTIFIER_HEAD(inetaddr_chain);\nstatic void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n\t\t\t int destroy);\n#ifdef CONFIG_SYSCTL\nstatic int devinet_sysctl_register(struct in_device *idev);\nstatic void devinet_sysctl_unregister(struct in_device *idev);\n#else\nstatic int devinet_sysctl_register(struct in_device *idev)\n{\n\treturn 0;\n}\nstatic void devinet_sysctl_unregister(struct in_device *idev)\n{\n}\n#endif\n\n/* Locks all the inet devices. */\n\nstatic struct in_ifaddr *inet_alloc_ifa(void)\n{\n\treturn kzalloc(sizeof(struct in_ifaddr), GFP_KERNEL);\n}\n\nstatic void inet_rcu_free_ifa(struct rcu_head *head)\n{\n\tstruct in_ifaddr *ifa = container_of(head, struct in_ifaddr, rcu_head);\n\tif (ifa->ifa_dev)\n\t\tin_dev_put(ifa->ifa_dev);\n\tkfree(ifa);\n}\n\nstatic void inet_free_ifa(struct in_ifaddr *ifa)\n{\n\tcall_rcu(&ifa->rcu_head, inet_rcu_free_ifa);\n}\n\nvoid in_dev_finish_destroy(struct in_device *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\n\tWARN_ON(idev->ifa_list);\n\tWARN_ON(idev->mc_list);\n\tkfree(rcu_dereference_protected(idev->mc_hash, 1));\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %p=%s\\n\", __func__, idev, dev ? dev->name : \"NIL\");\n#endif\n\tdev_put(dev);\n\tif (!idev->dead)\n\t\tpr_err(\"Freeing alive in_device %p\\n\", idev);\n\telse\n\t\tkfree(idev);\n}\nEXPORT_SYMBOL(in_dev_finish_destroy);\n\nstatic struct in_device *inetdev_init(struct net_device *dev)\n{\n\tstruct in_device *in_dev;\n\tint err = -ENOMEM;\n\n\tASSERT_RTNL();\n\n\tin_dev = kzalloc(sizeof(*in_dev), GFP_KERNEL);\n\tif (!in_dev)\n\t\tgoto out;\n\tmemcpy(&in_dev->cnf, dev_net(dev)->ipv4.devconf_dflt,\n\t\t\tsizeof(in_dev->cnf));\n\tin_dev->cnf.sysctl = NULL;\n\tin_dev->dev = dev;\n\tin_dev->arp_parms = neigh_parms_alloc(dev, &arp_tbl);\n\tif (!in_dev->arp_parms)\n\t\tgoto out_kfree;\n\tif (IPV4_DEVCONF(in_dev->cnf, FORWARDING))\n\t\tdev_disable_lro(dev);\n\t/* Reference in_dev->dev */\n\tdev_hold(dev);\n\t/* Account for reference dev->ip_ptr (below) */\n\tin_dev_hold(in_dev);\n\n\terr = devinet_sysctl_register(in_dev);\n\tif (err) {\n\t\tin_dev->dead = 1;\n\t\tin_dev_put(in_dev);\n\t\tin_dev = NULL;\n\t\tgoto out;\n\t}\n\tip_mc_init_dev(in_dev);\n\tif (dev->flags & IFF_UP)\n\t\tip_mc_up(in_dev);\n\n\t/* we can receive as soon as ip_ptr is set -- do this last */\n\trcu_assign_pointer(dev->ip_ptr, in_dev);\nout:\n\treturn in_dev ?: ERR_PTR(err);\nout_kfree:\n\tkfree(in_dev);\n\tin_dev = NULL;\n\tgoto out;\n}\n\nstatic void in_dev_rcu_put(struct rcu_head *head)\n{\n\tstruct in_device *idev = container_of(head, struct in_device, rcu_head);\n\tin_dev_put(idev);\n}\n\nstatic void inetdev_destroy(struct in_device *in_dev)\n{\n\tstruct in_ifaddr *ifa;\n\tstruct net_device *dev;\n\n\tASSERT_RTNL();\n\n\tdev = in_dev->dev;\n\n\tin_dev->dead = 1;\n\n\tip_mc_destroy_dev(in_dev);\n\n\twhile ((ifa = in_dev->ifa_list) != NULL) {\n\t\tinet_del_ifa(in_dev, &in_dev->ifa_list, 0);\n\t\tinet_free_ifa(ifa);\n\t}\n\n\tRCU_INIT_POINTER(dev->ip_ptr, NULL);\n\n\tdevinet_sysctl_unregister(in_dev);\n\tneigh_parms_release(&arp_tbl, in_dev->arp_parms);\n\tarp_ifdown(dev);\n\n\tcall_rcu(&in_dev->rcu_head, in_dev_rcu_put);\n}\n\nint inet_addr_onlink(struct in_device *in_dev, __be32 a, __be32 b)\n{\n\trcu_read_lock();\n\tfor_primary_ifa(in_dev) {\n\t\tif (inet_ifa_match(a, ifa)) {\n\t\t\tif (!b || inet_ifa_match(b, ifa)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} endfor_ifa(in_dev);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n\t\t\t int destroy, struct nlmsghdr *nlh, u32 portid)\n{\n\tstruct in_ifaddr *promote = NULL;\n\tstruct in_ifaddr *ifa, *ifa1 = *ifap;\n\tstruct in_ifaddr *last_prim = in_dev->ifa_list;\n\tstruct in_ifaddr *prev_prom = NULL;\n\tint do_promote = IN_DEV_PROMOTE_SECONDARIES(in_dev);\n\n\tASSERT_RTNL();\n\n\tif (in_dev->dead)\n\t\tgoto no_promotions;\n\n\t/* 1. Deleting primary ifaddr forces deletion all secondaries\n\t * unless alias promotion is set\n\t **/\n\n\tif (!(ifa1->ifa_flags & IFA_F_SECONDARY)) {\n\t\tstruct in_ifaddr **ifap1 = &ifa1->ifa_next;\n\n\t\twhile ((ifa = *ifap1) != NULL) {\n\t\t\tif (!(ifa->ifa_flags & IFA_F_SECONDARY) &&\n\t\t\t    ifa1->ifa_scope <= ifa->ifa_scope)\n\t\t\t\tlast_prim = ifa;\n\n\t\t\tif (!(ifa->ifa_flags & IFA_F_SECONDARY) ||\n\t\t\t    ifa1->ifa_mask != ifa->ifa_mask ||\n\t\t\t    !inet_ifa_match(ifa1->ifa_address, ifa)) {\n\t\t\t\tifap1 = &ifa->ifa_next;\n\t\t\t\tprev_prom = ifa;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!do_promote) {\n\t\t\t\tinet_hash_remove(ifa);\n\t\t\t\t*ifap1 = ifa->ifa_next;\n\n\t\t\t\trtmsg_ifa(RTM_DELADDR, ifa, nlh, portid);\n\t\t\t\tblocking_notifier_call_chain(&inetaddr_chain,\n\t\t\t\t\t\tNETDEV_DOWN, ifa);\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t} else {\n\t\t\t\tpromote = ifa;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* On promotion all secondaries from subnet are changing\n\t * the primary IP, we must remove all their routes silently\n\t * and later to add them back with new prefsrc. Do this\n\t * while all addresses are on the device list.\n\t */\n\tfor (ifa = promote; ifa; ifa = ifa->ifa_next) {\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa))\n\t\t\tfib_del_ifaddr(ifa, ifa1);\n\t}\n\nno_promotions:\n\t/* 2. Unlink it */\n\n\t*ifap = ifa1->ifa_next;\n\tinet_hash_remove(ifa1);\n\n\t/* 3. Announce address deletion */\n\n\t/* Send message first, then call notifier.\n\t   At first sight, FIB update triggered by notifier\n\t   will refer to already deleted ifaddr, that could confuse\n\t   netlink listeners. It is not true: look, gated sees\n\t   that route deleted and if it still thinks that ifaddr\n\t   is valid, it will try to restore deleted routes... Grr.\n\t   So that, this order is correct.\n\t */\n\trtmsg_ifa(RTM_DELADDR, ifa1, nlh, portid);\n\tblocking_notifier_call_chain(&inetaddr_chain, NETDEV_DOWN, ifa1);\n\n\tif (promote) {\n\t\tstruct in_ifaddr *next_sec = promote->ifa_next;\n\n\t\tif (prev_prom) {\n\t\t\tprev_prom->ifa_next = promote->ifa_next;\n\t\t\tpromote->ifa_next = last_prim->ifa_next;\n\t\t\tlast_prim->ifa_next = promote;\n\t\t}\n\n\t\tpromote->ifa_flags &= ~IFA_F_SECONDARY;\n\t\trtmsg_ifa(RTM_NEWADDR, promote, nlh, portid);\n\t\tblocking_notifier_call_chain(&inetaddr_chain,\n\t\t\t\tNETDEV_UP, promote);\n\t\tfor (ifa = next_sec; ifa; ifa = ifa->ifa_next) {\n\t\t\tif (ifa1->ifa_mask != ifa->ifa_mask ||\n\t\t\t    !inet_ifa_match(ifa1->ifa_address, ifa))\n\t\t\t\t\tcontinue;\n\t\t\tfib_add_ifaddr(ifa);\n\t\t}\n\n\t}\n\tif (destroy)\n\t\tinet_free_ifa(ifa1);\n}\n\nstatic void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n\t\t\t int destroy)\n{\n\t__inet_del_ifa(in_dev, ifap, destroy, NULL, 0);\n}\n\nstatic void check_lifetime(struct work_struct *work);\n\nstatic DECLARE_DELAYED_WORK(check_lifetime_work, check_lifetime);\n\nstatic int __inet_insert_ifa(struct in_ifaddr *ifa, struct nlmsghdr *nlh,\n\t\t\t     u32 portid)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct in_ifaddr *ifa1, **ifap, **last_primary;\n\n\tASSERT_RTNL();\n\n\tif (!ifa->ifa_local) {\n\t\tinet_free_ifa(ifa);\n\t\treturn 0;\n\t}\n\n\tifa->ifa_flags &= ~IFA_F_SECONDARY;\n\tlast_primary = &in_dev->ifa_list;\n\n\tfor (ifap = &in_dev->ifa_list; (ifa1 = *ifap) != NULL;\n\t     ifap = &ifa1->ifa_next) {\n\t\tif (!(ifa1->ifa_flags & IFA_F_SECONDARY) &&\n\t\t    ifa->ifa_scope <= ifa1->ifa_scope)\n\t\t\tlast_primary = &ifa1->ifa_next;\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa)) {\n\t\t\tif (ifa1->ifa_local == ifa->ifa_local) {\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tif (ifa1->ifa_scope != ifa->ifa_scope) {\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tifa->ifa_flags |= IFA_F_SECONDARY;\n\t\t}\n\t}\n\n\tif (!(ifa->ifa_flags & IFA_F_SECONDARY)) {\n\t\tprandom_seed((__force u32) ifa->ifa_local);\n\t\tifap = last_primary;\n\t}\n\n\tifa->ifa_next = *ifap;\n\t*ifap = ifa;\n\n\tinet_hash_insert(dev_net(in_dev->dev), ifa);\n\n\tcancel_delayed_work(&check_lifetime_work);\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\n\n\t/* Send message first, then call notifier.\n\t   Notifier will trigger FIB update, so that\n\t   listeners of netlink will know about new ifaddr */\n\trtmsg_ifa(RTM_NEWADDR, ifa, nlh, portid);\n\tblocking_notifier_call_chain(&inetaddr_chain, NETDEV_UP, ifa);\n\n\treturn 0;\n}\n\nstatic int inet_insert_ifa(struct in_ifaddr *ifa)\n{\n\treturn __inet_insert_ifa(ifa, NULL, 0);\n}\n\nstatic int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\n\tASSERT_RTNL();\n\n\tif (!in_dev) {\n\t\tinet_free_ifa(ifa);\n\t\treturn -ENOBUFS;\n\t}\n\tipv4_devconf_setall(in_dev);\n\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\tif (ifa->ifa_dev != in_dev) {\n\t\tWARN_ON(ifa->ifa_dev);\n\t\tin_dev_hold(in_dev);\n\t\tifa->ifa_dev = in_dev;\n\t}\n\tif (ipv4_is_loopback(ifa->ifa_local))\n\t\tifa->ifa_scope = RT_SCOPE_HOST;\n\treturn inet_insert_ifa(ifa);\n}\n\n/* Caller must hold RCU or RTNL :\n * We dont take a reference on found in_device\n */\nstruct in_device *inetdev_by_index(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tstruct in_device *in_dev = NULL;\n\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (dev)\n\t\tin_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\trcu_read_unlock();\n\treturn in_dev;\n}\nEXPORT_SYMBOL(inetdev_by_index);\n\n/* Called only from RTNL semaphored context. No locks. */\n\nstruct in_ifaddr *inet_ifa_byprefix(struct in_device *in_dev, __be32 prefix,\n\t\t\t\t    __be32 mask)\n{\n\tASSERT_RTNL();\n\n\tfor_primary_ifa(in_dev) {\n\t\tif (ifa->ifa_mask == mask && inet_ifa_match(prefix, ifa))\n\t\t\treturn ifa;\n\t} endfor_ifa(in_dev);\n\treturn NULL;\n}\n\nstatic int ip_mc_config(struct sock *sk, bool join, const struct in_ifaddr *ifa)\n{\n\tstruct ip_mreqn mreq = {\n\t\t.imr_multiaddr.s_addr = ifa->ifa_address,\n\t\t.imr_ifindex = ifa->ifa_dev->dev->ifindex,\n\t};\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tlock_sock(sk);\n\tif (join)\n\t\tret = ip_mc_join_group(sk, &mreq);\n\telse\n\t\tret = ip_mc_leave_group(sk, &mreq);\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int inet_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in_device *in_dev;\n\tstruct ifaddrmsg *ifm;\n\tstruct in_ifaddr *ifa, **ifap;\n\tint err = -EINVAL;\n\n\tASSERT_RTNL();\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tifm = nlmsg_data(nlh);\n\tin_dev = inetdev_by_index(net, ifm->ifa_index);\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto errout;\n\t}\n\n\tfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\n\t     ifap = &ifa->ifa_next) {\n\t\tif (tb[IFA_LOCAL] &&\n\t\t    ifa->ifa_local != nla_get_in_addr(tb[IFA_LOCAL]))\n\t\t\tcontinue;\n\n\t\tif (tb[IFA_LABEL] && nla_strcmp(tb[IFA_LABEL], ifa->ifa_label))\n\t\t\tcontinue;\n\n\t\tif (tb[IFA_ADDRESS] &&\n\t\t    (ifm->ifa_prefixlen != ifa->ifa_prefixlen ||\n\t\t    !inet_ifa_match(nla_get_in_addr(tb[IFA_ADDRESS]), ifa)))\n\t\t\tcontinue;\n\n\t\tif (ipv4_is_multicast(ifa->ifa_address))\n\t\t\tip_mc_config(net->ipv4.mc_autojoin_sk, false, ifa);\n\t\t__inet_del_ifa(in_dev, ifap, 1, nlh, NETLINK_CB(skb).portid);\n\t\treturn 0;\n\t}\n\n\terr = -EADDRNOTAVAIL;\nerrout:\n\treturn err;\n}\n\n#define INFINITY_LIFE_TIME\t0xFFFFFFFF\n\nstatic void check_lifetime(struct work_struct *work)\n{\n\tunsigned long now, next, next_sec, next_sched;\n\tstruct in_ifaddr *ifa;\n\tstruct hlist_node *n;\n\tint i;\n\n\tnow = jiffies;\n\tnext = round_jiffies_up(now + ADDR_CHECK_FREQUENCY);\n\n\tfor (i = 0; i < IN4_ADDR_HSIZE; i++) {\n\t\tbool change_needed = false;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(ifa, &inet_addr_lst[i], hash) {\n\t\t\tunsigned long age;\n\n\t\t\tif (ifa->ifa_flags & IFA_F_PERMANENT)\n\t\t\t\tcontinue;\n\n\t\t\t/* We try to batch several events at once. */\n\t\t\tage = (now - ifa->ifa_tstamp +\n\t\t\t       ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\n\t\t\tif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\n\t\t\t    age >= ifa->ifa_valid_lft) {\n\t\t\t\tchange_needed = true;\n\t\t\t} else if (ifa->ifa_preferred_lft ==\n\t\t\t\t   INFINITY_LIFE_TIME) {\n\t\t\t\tcontinue;\n\t\t\t} else if (age >= ifa->ifa_preferred_lft) {\n\t\t\t\tif (time_before(ifa->ifa_tstamp +\n\t\t\t\t\t\tifa->ifa_valid_lft * HZ, next))\n\t\t\t\t\tnext = ifa->ifa_tstamp +\n\t\t\t\t\t       ifa->ifa_valid_lft * HZ;\n\n\t\t\t\tif (!(ifa->ifa_flags & IFA_F_DEPRECATED))\n\t\t\t\t\tchange_needed = true;\n\t\t\t} else if (time_before(ifa->ifa_tstamp +\n\t\t\t\t\t       ifa->ifa_preferred_lft * HZ,\n\t\t\t\t\t       next)) {\n\t\t\t\tnext = ifa->ifa_tstamp +\n\t\t\t\t       ifa->ifa_preferred_lft * HZ;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!change_needed)\n\t\t\tcontinue;\n\t\trtnl_lock();\n\t\thlist_for_each_entry_safe(ifa, n, &inet_addr_lst[i], hash) {\n\t\t\tunsigned long age;\n\n\t\t\tif (ifa->ifa_flags & IFA_F_PERMANENT)\n\t\t\t\tcontinue;\n\n\t\t\t/* We try to batch several events at once. */\n\t\t\tage = (now - ifa->ifa_tstamp +\n\t\t\t       ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\n\t\t\tif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\n\t\t\t    age >= ifa->ifa_valid_lft) {\n\t\t\t\tstruct in_ifaddr **ifap;\n\n\t\t\t\tfor (ifap = &ifa->ifa_dev->ifa_list;\n\t\t\t\t     *ifap != NULL; ifap = &(*ifap)->ifa_next) {\n\t\t\t\t\tif (*ifap == ifa) {\n\t\t\t\t\t\tinet_del_ifa(ifa->ifa_dev,\n\t\t\t\t\t\t\t     ifap, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (ifa->ifa_preferred_lft !=\n\t\t\t\t   INFINITY_LIFE_TIME &&\n\t\t\t\t   age >= ifa->ifa_preferred_lft &&\n\t\t\t\t   !(ifa->ifa_flags & IFA_F_DEPRECATED)) {\n\t\t\t\tifa->ifa_flags |= IFA_F_DEPRECATED;\n\t\t\t\trtmsg_ifa(RTM_NEWADDR, ifa, NULL, 0);\n\t\t\t}\n\t\t}\n\t\trtnl_unlock();\n\t}\n\n\tnext_sec = round_jiffies_up(next);\n\tnext_sched = next;\n\n\t/* If rounded timeout is accurate enough, accept it. */\n\tif (time_before(next_sec, next + ADDRCONF_TIMER_FUZZ))\n\t\tnext_sched = next_sec;\n\n\tnow = jiffies;\n\t/* And minimum interval is ADDRCONF_TIMER_FUZZ_MAX. */\n\tif (time_before(next_sched, now + ADDRCONF_TIMER_FUZZ_MAX))\n\t\tnext_sched = now + ADDRCONF_TIMER_FUZZ_MAX;\n\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work,\n\t\t\tnext_sched - now);\n}\n\nstatic void set_ifa_lifetime(struct in_ifaddr *ifa, __u32 valid_lft,\n\t\t\t     __u32 prefered_lft)\n{\n\tunsigned long timeout;\n\n\tifa->ifa_flags &= ~(IFA_F_PERMANENT | IFA_F_DEPRECATED);\n\n\ttimeout = addrconf_timeout_fixup(valid_lft, HZ);\n\tif (addrconf_finite_timeout(timeout))\n\t\tifa->ifa_valid_lft = timeout;\n\telse\n\t\tifa->ifa_flags |= IFA_F_PERMANENT;\n\n\ttimeout = addrconf_timeout_fixup(prefered_lft, HZ);\n\tif (addrconf_finite_timeout(timeout)) {\n\t\tif (timeout == 0)\n\t\t\tifa->ifa_flags |= IFA_F_DEPRECATED;\n\t\tifa->ifa_preferred_lft = timeout;\n\t}\n\tifa->ifa_tstamp = jiffies;\n\tif (!ifa->ifa_cstamp)\n\t\tifa->ifa_cstamp = ifa->ifa_tstamp;\n}\n\nstatic struct in_ifaddr *rtm_to_ifaddr(struct net *net, struct nlmsghdr *nlh,\n\t\t\t\t       __u32 *pvalid_lft, __u32 *pprefered_lft)\n{\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in_ifaddr *ifa;\n\tstruct ifaddrmsg *ifm;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tifm = nlmsg_data(nlh);\n\terr = -EINVAL;\n\tif (ifm->ifa_prefixlen > 32 || !tb[IFA_LOCAL])\n\t\tgoto errout;\n\n\tdev = __dev_get_by_index(net, ifm->ifa_index);\n\terr = -ENODEV;\n\tif (!dev)\n\t\tgoto errout;\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\terr = -ENOBUFS;\n\tif (!in_dev)\n\t\tgoto errout;\n\n\tifa = inet_alloc_ifa();\n\tif (!ifa)\n\t\t/*\n\t\t * A potential indev allocation can be left alive, it stays\n\t\t * assigned to its device and is destroy with it.\n\t\t */\n\t\tgoto errout;\n\n\tipv4_devconf_setall(in_dev);\n\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\tin_dev_hold(in_dev);\n\n\tif (!tb[IFA_ADDRESS])\n\t\ttb[IFA_ADDRESS] = tb[IFA_LOCAL];\n\n\tINIT_HLIST_NODE(&ifa->hash);\n\tifa->ifa_prefixlen = ifm->ifa_prefixlen;\n\tifa->ifa_mask = inet_make_mask(ifm->ifa_prefixlen);\n\tifa->ifa_flags = tb[IFA_FLAGS] ? nla_get_u32(tb[IFA_FLAGS]) :\n\t\t\t\t\t ifm->ifa_flags;\n\tifa->ifa_scope = ifm->ifa_scope;\n\tifa->ifa_dev = in_dev;\n\n\tifa->ifa_local = nla_get_in_addr(tb[IFA_LOCAL]);\n\tifa->ifa_address = nla_get_in_addr(tb[IFA_ADDRESS]);\n\n\tif (tb[IFA_BROADCAST])\n\t\tifa->ifa_broadcast = nla_get_in_addr(tb[IFA_BROADCAST]);\n\n\tif (tb[IFA_LABEL])\n\t\tnla_strlcpy(ifa->ifa_label, tb[IFA_LABEL], IFNAMSIZ);\n\telse\n\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\n\tif (tb[IFA_CACHEINFO]) {\n\t\tstruct ifa_cacheinfo *ci;\n\n\t\tci = nla_data(tb[IFA_CACHEINFO]);\n\t\tif (!ci->ifa_valid || ci->ifa_prefered > ci->ifa_valid) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_free;\n\t\t}\n\t\t*pvalid_lft = ci->ifa_valid;\n\t\t*pprefered_lft = ci->ifa_prefered;\n\t}\n\n\treturn ifa;\n\nerrout_free:\n\tinet_free_ifa(ifa);\nerrout:\n\treturn ERR_PTR(err);\n}\n\nstatic struct in_ifaddr *find_matching_ifa(struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct in_ifaddr *ifa1, **ifap;\n\n\tif (!ifa->ifa_local)\n\t\treturn NULL;\n\n\tfor (ifap = &in_dev->ifa_list; (ifa1 = *ifap) != NULL;\n\t     ifap = &ifa1->ifa_next) {\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa) &&\n\t\t    ifa1->ifa_local == ifa->ifa_local)\n\t\t\treturn ifa1;\n\t}\n\treturn NULL;\n}\n\nstatic int inet_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct in_ifaddr *ifa;\n\tstruct in_ifaddr *ifa_existing;\n\t__u32 valid_lft = INFINITY_LIFE_TIME;\n\t__u32 prefered_lft = INFINITY_LIFE_TIME;\n\n\tASSERT_RTNL();\n\n\tifa = rtm_to_ifaddr(net, nlh, &valid_lft, &prefered_lft);\n\tif (IS_ERR(ifa))\n\t\treturn PTR_ERR(ifa);\n\n\tifa_existing = find_matching_ifa(ifa);\n\tif (!ifa_existing) {\n\t\t/* It would be best to check for !NLM_F_CREATE here but\n\t\t * userspace already relies on not having to provide this.\n\t\t */\n\t\tset_ifa_lifetime(ifa, valid_lft, prefered_lft);\n\t\tif (ifa->ifa_flags & IFA_F_MCAUTOJOIN) {\n\t\t\tint ret = ip_mc_config(net->ipv4.mc_autojoin_sk,\n\t\t\t\t\t       true, ifa);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn __inet_insert_ifa(ifa, nlh, NETLINK_CB(skb).portid);\n\t} else {\n\t\tinet_free_ifa(ifa);\n\n\t\tif (nlh->nlmsg_flags & NLM_F_EXCL ||\n\t\t    !(nlh->nlmsg_flags & NLM_F_REPLACE))\n\t\t\treturn -EEXIST;\n\t\tifa = ifa_existing;\n\t\tset_ifa_lifetime(ifa, valid_lft, prefered_lft);\n\t\tcancel_delayed_work(&check_lifetime_work);\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&check_lifetime_work, 0);\n\t\trtmsg_ifa(RTM_NEWADDR, ifa, nlh, NETLINK_CB(skb).portid);\n\t}\n\treturn 0;\n}\n\n/*\n *\tDetermine a default network mask, based on the IP address.\n */\n\nstatic int inet_abc_len(__be32 addr)\n{\n\tint rc = -1;\t/* Something else, probably a multicast. */\n\n\tif (ipv4_is_zeronet(addr))\n\t\trc = 0;\n\telse {\n\t\t__u32 haddr = ntohl(addr);\n\n\t\tif (IN_CLASSA(haddr))\n\t\t\trc = 8;\n\t\telse if (IN_CLASSB(haddr))\n\t\t\trc = 16;\n\t\telse if (IN_CLASSC(haddr))\n\t\t\trc = 24;\n\t}\n\n\treturn rc;\n}\n\n\nint devinet_ioctl(struct net *net, unsigned int cmd, void __user *arg)\n{\n\tstruct ifreq ifr;\n\tstruct sockaddr_in sin_orig;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)&ifr.ifr_addr;\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr **ifap = NULL;\n\tstruct in_ifaddr *ifa = NULL;\n\tstruct net_device *dev;\n\tchar *colon;\n\tint ret = -EFAULT;\n\tint tryaddrmatch = 0;\n\n\t/*\n\t *\tFetch the caller's info block into kernel space\n\t */\n\n\tif (copy_from_user(&ifr, arg, sizeof(struct ifreq)))\n\t\tgoto out;\n\tifr.ifr_name[IFNAMSIZ - 1] = 0;\n\n\t/* save original address for comparison */\n\tmemcpy(&sin_orig, sin, sizeof(*sin));\n\n\tcolon = strchr(ifr.ifr_name, ':');\n\tif (colon)\n\t\t*colon = 0;\n\n\tdev_load(net, ifr.ifr_name);\n\n\tswitch (cmd) {\n\tcase SIOCGIFADDR:\t/* Get interface address */\n\tcase SIOCGIFBRDADDR:\t/* Get the broadcast address */\n\tcase SIOCGIFDSTADDR:\t/* Get the destination address */\n\tcase SIOCGIFNETMASK:\t/* Get the netmask for the interface */\n\t\t/* Note that these ioctls will not sleep,\n\t\t   so that we do not impose a lock.\n\t\t   One day we will be forced to put shlock here (I mean SMP)\n\t\t */\n\t\ttryaddrmatch = (sin_orig.sin_family == AF_INET);\n\t\tmemset(sin, 0, sizeof(*sin));\n\t\tsin->sin_family = AF_INET;\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tret = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SIOCSIFADDR:\t/* Set interface address (and family) */\n\tcase SIOCSIFBRDADDR:\t/* Set the broadcast address */\n\tcase SIOCSIFDSTADDR:\t/* Set the destination address */\n\tcase SIOCSIFNETMASK: \t/* Set the netmask for the interface */\n\t\tret = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t\tif (sin->sin_family != AF_INET)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trtnl_lock();\n\n\tret = -ENODEV;\n\tdev = __dev_get_by_name(net, ifr.ifr_name);\n\tif (!dev)\n\t\tgoto done;\n\n\tif (colon)\n\t\t*colon = ':';\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\tif (in_dev) {\n\t\tif (tryaddrmatch) {\n\t\t\t/* Matthias Andree */\n\t\t\t/* compare label and address (4.4BSD style) */\n\t\t\t/* note: we only do this for a limited set of ioctls\n\t\t\t   and only if the original address family was AF_INET.\n\t\t\t   This is checked above. */\n\t\t\tfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\n\t\t\t     ifap = &ifa->ifa_next) {\n\t\t\t\tif (!strcmp(ifr.ifr_name, ifa->ifa_label) &&\n\t\t\t\t    sin_orig.sin_addr.s_addr ==\n\t\t\t\t\t\t\tifa->ifa_local) {\n\t\t\t\t\tbreak; /* found */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* we didn't get a match, maybe the application is\n\t\t   4.3BSD-style and passed in junk so we fall back to\n\t\t   comparing just the label */\n\t\tif (!ifa) {\n\t\t\tfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\n\t\t\t     ifap = &ifa->ifa_next)\n\t\t\t\tif (!strcmp(ifr.ifr_name, ifa->ifa_label))\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = -EADDRNOTAVAIL;\n\tif (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)\n\t\tgoto done;\n\n\tswitch (cmd) {\n\tcase SIOCGIFADDR:\t/* Get interface address */\n\t\tsin->sin_addr.s_addr = ifa->ifa_local;\n\t\tgoto rarok;\n\n\tcase SIOCGIFBRDADDR:\t/* Get the broadcast address */\n\t\tsin->sin_addr.s_addr = ifa->ifa_broadcast;\n\t\tgoto rarok;\n\n\tcase SIOCGIFDSTADDR:\t/* Get the destination address */\n\t\tsin->sin_addr.s_addr = ifa->ifa_address;\n\t\tgoto rarok;\n\n\tcase SIOCGIFNETMASK:\t/* Get the netmask for the interface */\n\t\tsin->sin_addr.s_addr = ifa->ifa_mask;\n\t\tgoto rarok;\n\n\tcase SIOCSIFFLAGS:\n\t\tif (colon) {\n\t\t\tret = -EADDRNOTAVAIL;\n\t\t\tif (!ifa)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tif (!(ifr.ifr_flags & IFF_UP))\n\t\t\t\tinet_del_ifa(in_dev, ifap, 1);\n\t\t\tbreak;\n\t\t}\n\t\tret = dev_change_flags(dev, ifr.ifr_flags);\n\t\tbreak;\n\n\tcase SIOCSIFADDR:\t/* Set interface address (and family) */\n\t\tret = -EINVAL;\n\t\tif (inet_abc_len(sin->sin_addr.s_addr) < 0)\n\t\t\tbreak;\n\n\t\tif (!ifa) {\n\t\t\tret = -ENOBUFS;\n\t\t\tifa = inet_alloc_ifa();\n\t\t\tif (!ifa)\n\t\t\t\tbreak;\n\t\t\tINIT_HLIST_NODE(&ifa->hash);\n\t\t\tif (colon)\n\t\t\t\tmemcpy(ifa->ifa_label, ifr.ifr_name, IFNAMSIZ);\n\t\t\telse\n\t\t\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\t} else {\n\t\t\tret = 0;\n\t\t\tif (ifa->ifa_local == sin->sin_addr.s_addr)\n\t\t\t\tbreak;\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_broadcast = 0;\n\t\t\tifa->ifa_scope = 0;\n\t\t}\n\n\t\tifa->ifa_address = ifa->ifa_local = sin->sin_addr.s_addr;\n\n\t\tif (!(dev->flags & IFF_POINTOPOINT)) {\n\t\t\tifa->ifa_prefixlen = inet_abc_len(ifa->ifa_address);\n\t\t\tifa->ifa_mask = inet_make_mask(ifa->ifa_prefixlen);\n\t\t\tif ((dev->flags & IFF_BROADCAST) &&\n\t\t\t    ifa->ifa_prefixlen < 31)\n\t\t\t\tifa->ifa_broadcast = ifa->ifa_address |\n\t\t\t\t\t\t     ~ifa->ifa_mask;\n\t\t} else {\n\t\t\tifa->ifa_prefixlen = 32;\n\t\t\tifa->ifa_mask = inet_make_mask(32);\n\t\t}\n\t\tset_ifa_lifetime(ifa, INFINITY_LIFE_TIME, INFINITY_LIFE_TIME);\n\t\tret = inet_set_ifa(dev, ifa);\n\t\tbreak;\n\n\tcase SIOCSIFBRDADDR:\t/* Set the broadcast address */\n\t\tret = 0;\n\t\tif (ifa->ifa_broadcast != sin->sin_addr.s_addr) {\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_broadcast = sin->sin_addr.s_addr;\n\t\t\tinet_insert_ifa(ifa);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFDSTADDR:\t/* Set the destination address */\n\t\tret = 0;\n\t\tif (ifa->ifa_address == sin->sin_addr.s_addr)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (inet_abc_len(sin->sin_addr.s_addr) < 0)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\tifa->ifa_address = sin->sin_addr.s_addr;\n\t\tinet_insert_ifa(ifa);\n\t\tbreak;\n\n\tcase SIOCSIFNETMASK: \t/* Set the netmask for the interface */\n\n\t\t/*\n\t\t *\tThe mask we set must be legal.\n\t\t */\n\t\tret = -EINVAL;\n\t\tif (bad_mask(sin->sin_addr.s_addr, 0))\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (ifa->ifa_mask != sin->sin_addr.s_addr) {\n\t\t\t__be32 old_mask = ifa->ifa_mask;\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_mask = sin->sin_addr.s_addr;\n\t\t\tifa->ifa_prefixlen = inet_mask_len(ifa->ifa_mask);\n\n\t\t\t/* See if current broadcast address matches\n\t\t\t * with current netmask, then recalculate\n\t\t\t * the broadcast address. Otherwise it's a\n\t\t\t * funny address, so don't touch it since\n\t\t\t * the user seems to know what (s)he's doing...\n\t\t\t */\n\t\t\tif ((dev->flags & IFF_BROADCAST) &&\n\t\t\t    (ifa->ifa_prefixlen < 31) &&\n\t\t\t    (ifa->ifa_broadcast ==\n\t\t\t     (ifa->ifa_local|~old_mask))) {\n\t\t\t\tifa->ifa_broadcast = (ifa->ifa_local |\n\t\t\t\t\t\t      ~sin->sin_addr.s_addr);\n\t\t\t}\n\t\t\tinet_insert_ifa(ifa);\n\t\t}\n\t\tbreak;\n\t}\ndone:\n\trtnl_unlock();\nout:\n\treturn ret;\nrarok:\n\trtnl_unlock();\n\tret = copy_to_user(arg, &ifr, sizeof(struct ifreq)) ? -EFAULT : 0;\n\tgoto out;\n}\n\nstatic int inet_gifconf(struct net_device *dev, char __user *buf, int len)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\tstruct in_ifaddr *ifa;\n\tstruct ifreq ifr;\n\tint done = 0;\n\n\tif (!in_dev)\n\t\tgoto out;\n\n\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\n\t\tif (!buf) {\n\t\t\tdone += sizeof(ifr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (len < (int) sizeof(ifr))\n\t\t\tbreak;\n\t\tmemset(&ifr, 0, sizeof(struct ifreq));\n\t\tstrcpy(ifr.ifr_name, ifa->ifa_label);\n\n\t\t(*(struct sockaddr_in *)&ifr.ifr_addr).sin_family = AF_INET;\n\t\t(*(struct sockaddr_in *)&ifr.ifr_addr).sin_addr.s_addr =\n\t\t\t\t\t\t\t\tifa->ifa_local;\n\n\t\tif (copy_to_user(buf, &ifr, sizeof(struct ifreq))) {\n\t\t\tdone = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuf  += sizeof(struct ifreq);\n\t\tlen  -= sizeof(struct ifreq);\n\t\tdone += sizeof(struct ifreq);\n\t}\nout:\n\treturn done;\n}\n\n__be32 inet_select_addr(const struct net_device *dev, __be32 dst, int scope)\n{\n\t__be32 addr = 0;\n\tstruct in_device *in_dev;\n\tstruct net *net = dev_net(dev);\n\tint master_idx;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (!in_dev)\n\t\tgoto no_in_dev;\n\n\tfor_primary_ifa(in_dev) {\n\t\tif (ifa->ifa_scope > scope)\n\t\t\tcontinue;\n\t\tif (!dst || inet_ifa_match(dst, ifa)) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tbreak;\n\t\t}\n\t\tif (!addr)\n\t\t\taddr = ifa->ifa_local;\n\t} endfor_ifa(in_dev);\n\n\tif (addr)\n\t\tgoto out_unlock;\nno_in_dev:\n\tmaster_idx = l3mdev_master_ifindex_rcu(dev);\n\n\t/* For VRFs, the VRF device takes the place of the loopback device,\n\t * with addresses on it being preferred.  Note in such cases the\n\t * loopback device will be among the devices that fail the master_idx\n\t * equality check in the loop below.\n\t */\n\tif (master_idx &&\n\t    (dev = dev_get_by_index_rcu(net, master_idx)) &&\n\t    (in_dev = __in_dev_get_rcu(dev))) {\n\t\tfor_primary_ifa(in_dev) {\n\t\t\tif (ifa->ifa_scope != RT_SCOPE_LINK &&\n\t\t\t    ifa->ifa_scope <= scope) {\n\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} endfor_ifa(in_dev);\n\t}\n\n\t/* Not loopback addresses on loopback should be preferred\n\t   in this case. It is important that lo is the first interface\n\t   in dev_base list.\n\t */\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (l3mdev_master_ifindex_rcu(dev) != master_idx)\n\t\t\tcontinue;\n\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (!in_dev)\n\t\t\tcontinue;\n\n\t\tfor_primary_ifa(in_dev) {\n\t\t\tif (ifa->ifa_scope != RT_SCOPE_LINK &&\n\t\t\t    ifa->ifa_scope <= scope) {\n\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} endfor_ifa(in_dev);\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn addr;\n}\nEXPORT_SYMBOL(inet_select_addr);\n\nstatic __be32 confirm_addr_indev(struct in_device *in_dev, __be32 dst,\n\t\t\t      __be32 local, int scope)\n{\n\tint same = 0;\n\t__be32 addr = 0;\n\n\tfor_ifa(in_dev) {\n\t\tif (!addr &&\n\t\t    (local == ifa->ifa_local || !local) &&\n\t\t    ifa->ifa_scope <= scope) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tif (same)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!same) {\n\t\t\tsame = (!local || inet_ifa_match(local, ifa)) &&\n\t\t\t\t(!dst || inet_ifa_match(dst, ifa));\n\t\t\tif (same && addr) {\n\t\t\t\tif (local || !dst)\n\t\t\t\t\tbreak;\n\t\t\t\t/* Is the selected addr into dst subnet? */\n\t\t\t\tif (inet_ifa_match(addr, ifa))\n\t\t\t\t\tbreak;\n\t\t\t\t/* No, then can we use new local src? */\n\t\t\t\tif (ifa->ifa_scope <= scope) {\n\t\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* search for large dst subnet for addr */\n\t\t\t\tsame = 0;\n\t\t\t}\n\t\t}\n\t} endfor_ifa(in_dev);\n\n\treturn same ? addr : 0;\n}\n\n/*\n * Confirm that local IP address exists using wildcards:\n * - net: netns to check, cannot be NULL\n * - in_dev: only on this interface, NULL=any interface\n * - dst: only in the same subnet as dst, 0=any dst\n * - local: address, 0=autoselect the local address\n * - scope: maximum allowed scope value for the local address\n */\n__be32 inet_confirm_addr(struct net *net, struct in_device *in_dev,\n\t\t\t __be32 dst, __be32 local, int scope)\n{\n\t__be32 addr = 0;\n\tstruct net_device *dev;\n\n\tif (in_dev)\n\t\treturn confirm_addr_indev(in_dev, dst, local, scope);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev) {\n\t\t\taddr = confirm_addr_indev(in_dev, dst, local, scope);\n\t\t\tif (addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn addr;\n}\nEXPORT_SYMBOL(inet_confirm_addr);\n\n/*\n *\tDevice notifier\n */\n\nint register_inetaddr_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&inetaddr_chain, nb);\n}\nEXPORT_SYMBOL(register_inetaddr_notifier);\n\nint unregister_inetaddr_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&inetaddr_chain, nb);\n}\nEXPORT_SYMBOL(unregister_inetaddr_notifier);\n\n/* Rename ifa_labels for a device name change. Make some effort to preserve\n * existing alias numbering and to create unique labels if possible.\n*/\nstatic void inetdev_changename(struct net_device *dev, struct in_device *in_dev)\n{\n\tstruct in_ifaddr *ifa;\n\tint named = 0;\n\n\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\n\t\tchar old[IFNAMSIZ], *dot;\n\n\t\tmemcpy(old, ifa->ifa_label, IFNAMSIZ);\n\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\tif (named++ == 0)\n\t\t\tgoto skip;\n\t\tdot = strchr(old, ':');\n\t\tif (!dot) {\n\t\t\tsprintf(old, \":%d\", named);\n\t\t\tdot = old;\n\t\t}\n\t\tif (strlen(dot) + strlen(dev->name) < IFNAMSIZ)\n\t\t\tstrcat(ifa->ifa_label, dot);\n\t\telse\n\t\t\tstrcpy(ifa->ifa_label + (IFNAMSIZ - strlen(dot) - 1), dot);\nskip:\n\t\trtmsg_ifa(RTM_NEWADDR, ifa, NULL, 0);\n\t}\n}\n\nstatic bool inetdev_valid_mtu(unsigned int mtu)\n{\n\treturn mtu >= 68;\n}\n\nstatic void inetdev_send_gratuitous_arp(struct net_device *dev,\n\t\t\t\t\tstruct in_device *in_dev)\n\n{\n\tstruct in_ifaddr *ifa;\n\n\tfor (ifa = in_dev->ifa_list; ifa;\n\t     ifa = ifa->ifa_next) {\n\t\tarp_send(ARPOP_REQUEST, ETH_P_ARP,\n\t\t\t ifa->ifa_local, dev,\n\t\t\t ifa->ifa_local, NULL,\n\t\t\t dev->dev_addr, NULL);\n\t}\n}\n\n/* Called only under RTNL semaphore */\n\nstatic int inetdev_event(struct notifier_block *this, unsigned long event,\n\t\t\t void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\n\tASSERT_RTNL();\n\n\tif (!in_dev) {\n\t\tif (event == NETDEV_REGISTER) {\n\t\t\tin_dev = inetdev_init(dev);\n\t\t\tif (IS_ERR(in_dev))\n\t\t\t\treturn notifier_from_errno(PTR_ERR(in_dev));\n\t\t\tif (dev->flags & IFF_LOOPBACK) {\n\t\t\t\tIN_DEV_CONF_SET(in_dev, NOXFRM, 1);\n\t\t\t\tIN_DEV_CONF_SET(in_dev, NOPOLICY, 1);\n\t\t\t}\n\t\t} else if (event == NETDEV_CHANGEMTU) {\n\t\t\t/* Re-enabling IP */\n\t\t\tif (inetdev_valid_mtu(dev->mtu))\n\t\t\t\tin_dev = inetdev_init(dev);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tpr_debug(\"%s: bug\\n\", __func__);\n\t\tRCU_INIT_POINTER(dev->ip_ptr, NULL);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tif (!inetdev_valid_mtu(dev->mtu))\n\t\t\tbreak;\n\t\tif (dev->flags & IFF_LOOPBACK) {\n\t\t\tstruct in_ifaddr *ifa = inet_alloc_ifa();\n\n\t\t\tif (ifa) {\n\t\t\t\tINIT_HLIST_NODE(&ifa->hash);\n\t\t\t\tifa->ifa_local =\n\t\t\t\t  ifa->ifa_address = htonl(INADDR_LOOPBACK);\n\t\t\t\tifa->ifa_prefixlen = 8;\n\t\t\t\tifa->ifa_mask = inet_make_mask(8);\n\t\t\t\tin_dev_hold(in_dev);\n\t\t\t\tifa->ifa_dev = in_dev;\n\t\t\t\tifa->ifa_scope = RT_SCOPE_HOST;\n\t\t\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\t\t\tset_ifa_lifetime(ifa, INFINITY_LIFE_TIME,\n\t\t\t\t\t\t INFINITY_LIFE_TIME);\n\t\t\t\tipv4_devconf_setall(in_dev);\n\t\t\t\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\t\t\t\tinet_insert_ifa(ifa);\n\t\t\t}\n\t\t}\n\t\tip_mc_up(in_dev);\n\t\t/* fall through */\n\tcase NETDEV_CHANGEADDR:\n\t\tif (!IN_DEV_ARP_NOTIFY(in_dev))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase NETDEV_NOTIFY_PEERS:\n\t\t/* Send gratuitous ARP to notify of link change */\n\t\tinetdev_send_gratuitous_arp(dev, in_dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tip_mc_down(in_dev);\n\t\tbreak;\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\tip_mc_unmap(in_dev);\n\t\tbreak;\n\tcase NETDEV_POST_TYPE_CHANGE:\n\t\tip_mc_remap(in_dev);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (inetdev_valid_mtu(dev->mtu))\n\t\t\tbreak;\n\t\t/* disable IP when MTU is not enough */\n\tcase NETDEV_UNREGISTER:\n\t\tinetdev_destroy(in_dev);\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\t/* Do not notify about label change, this event is\n\t\t * not interesting to applications using netlink.\n\t\t */\n\t\tinetdev_changename(dev, in_dev);\n\n\t\tdevinet_sysctl_unregister(in_dev);\n\t\tdevinet_sysctl_register(in_dev);\n\t\tbreak;\n\t}\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ip_netdev_notifier = {\n\t.notifier_call = inetdev_event,\n};\n\nstatic size_t inet_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\n\t       + nla_total_size(4) /* IFA_ADDRESS */\n\t       + nla_total_size(4) /* IFA_LOCAL */\n\t       + nla_total_size(4) /* IFA_BROADCAST */\n\t       + nla_total_size(IFNAMSIZ) /* IFA_LABEL */\n\t       + nla_total_size(4)  /* IFA_FLAGS */\n\t       + nla_total_size(sizeof(struct ifa_cacheinfo)); /* IFA_CACHEINFO */\n}\n\nstatic inline u32 cstamp_delta(unsigned long cstamp)\n{\n\treturn (cstamp - INITIAL_JIFFIES) * 100UL / HZ;\n}\n\nstatic int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,\n\t\t\t unsigned long tstamp, u32 preferred, u32 valid)\n{\n\tstruct ifa_cacheinfo ci;\n\n\tci.cstamp = cstamp_delta(cstamp);\n\tci.tstamp = cstamp_delta(tstamp);\n\tci.ifa_prefered = preferred;\n\tci.ifa_valid = valid;\n\n\treturn nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);\n}\n\nstatic int inet_fill_ifaddr(struct sk_buff *skb, struct in_ifaddr *ifa,\n\t\t\t    u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct ifaddrmsg *ifm;\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*ifm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifa_family = AF_INET;\n\tifm->ifa_prefixlen = ifa->ifa_prefixlen;\n\tifm->ifa_flags = ifa->ifa_flags;\n\tifm->ifa_scope = ifa->ifa_scope;\n\tifm->ifa_index = ifa->ifa_dev->dev->ifindex;\n\n\tif (!(ifm->ifa_flags & IFA_F_PERMANENT)) {\n\t\tpreferred = ifa->ifa_preferred_lft;\n\t\tvalid = ifa->ifa_valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->ifa_tstamp) / HZ;\n\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\tif ((ifa->ifa_address &&\n\t     nla_put_in_addr(skb, IFA_ADDRESS, ifa->ifa_address)) ||\n\t    (ifa->ifa_local &&\n\t     nla_put_in_addr(skb, IFA_LOCAL, ifa->ifa_local)) ||\n\t    (ifa->ifa_broadcast &&\n\t     nla_put_in_addr(skb, IFA_BROADCAST, ifa->ifa_broadcast)) ||\n\t    (ifa->ifa_label[0] &&\n\t     nla_put_string(skb, IFA_LABEL, ifa->ifa_label)) ||\n\t    nla_put_u32(skb, IFA_FLAGS, ifa->ifa_flags) ||\n\t    put_cacheinfo(skb, ifa->ifa_cstamp, ifa->ifa_tstamp,\n\t\t\t  preferred, valid))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int inet_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx, s_idx;\n\tint ip_idx, s_ip_idx;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr *ifa;\n\tstruct hlist_head *head;\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\ts_ip_idx = ip_idx = cb->args[2];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = atomic_read(&net->ipv4.dev_addr_genid) ^\n\t\t\t  net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (h > s_h || idx > s_idx)\n\t\t\t\ts_ip_idx = 0;\n\t\t\tin_dev = __in_dev_get_rcu(dev);\n\t\t\tif (!in_dev)\n\t\t\t\tgoto cont;\n\n\t\t\tfor (ifa = in_dev->ifa_list, ip_idx = 0; ifa;\n\t\t\t     ifa = ifa->ifa_next, ip_idx++) {\n\t\t\t\tif (ip_idx < s_ip_idx)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (inet_fill_ifaddr(skb, ifa,\n\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq,\n\t\t\t\t\t     RTM_NEWADDR, NLM_F_MULTI) < 0) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\n\t\t\t}\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\tcb->args[2] = ip_idx;\n\n\treturn skb->len;\n}\n\nstatic void rtmsg_ifa(int event, struct in_ifaddr *ifa, struct nlmsghdr *nlh,\n\t\t      u32 portid)\n{\n\tstruct sk_buff *skb;\n\tu32 seq = nlh ? nlh->nlmsg_seq : 0;\n\tint err = -ENOBUFS;\n\tstruct net *net;\n\n\tnet = dev_net(ifa->ifa_dev->dev);\n\tskb = nlmsg_new(inet_nlmsg_size(), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_fill_ifaddr(skb, ifa, portid, seq, event, 0);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in inet_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, portid, RTNLGRP_IPV4_IFADDR, nlh, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_IFADDR, err);\n}\n\nstatic size_t inet_get_link_af_size(const struct net_device *dev,\n\t\t\t\t    u32 ext_filter_mask)\n{\n\tstruct in_device *in_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\n\tif (!in_dev)\n\t\treturn 0;\n\n\treturn nla_total_size(IPV4_DEVCONF_MAX * 4); /* IFLA_INET_CONF */\n}\n\nstatic int inet_fill_link_af(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tstruct in_device *in_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\tstruct nlattr *nla;\n\tint i;\n\n\tif (!in_dev)\n\t\treturn -ENODATA;\n\n\tnla = nla_reserve(skb, IFLA_INET_CONF, IPV4_DEVCONF_MAX * 4);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < IPV4_DEVCONF_MAX; i++)\n\t\t((u32 *) nla_data(nla))[i] = in_dev->cnf.data[i];\n\n\treturn 0;\n}\n\nstatic const struct nla_policy inet_af_policy[IFLA_INET_MAX+1] = {\n\t[IFLA_INET_CONF]\t= { .type = NLA_NESTED },\n};\n\nstatic int inet_validate_link_af(const struct net_device *dev,\n\t\t\t\t const struct nlattr *nla)\n{\n\tstruct nlattr *a, *tb[IFLA_INET_MAX+1];\n\tint err, rem;\n\n\tif (dev && !__in_dev_get_rtnl(dev))\n\t\treturn -EAFNOSUPPORT;\n\n\terr = nla_parse_nested(tb, IFLA_INET_MAX, nla, inet_af_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_INET_CONF]) {\n\t\tnla_for_each_nested(a, tb[IFLA_INET_CONF], rem) {\n\t\t\tint cfgid = nla_type(a);\n\n\t\t\tif (nla_len(a) < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (cfgid <= 0 || cfgid > IPV4_DEVCONF_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet_set_link_af(struct net_device *dev, const struct nlattr *nla)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\tstruct nlattr *a, *tb[IFLA_INET_MAX+1];\n\tint rem;\n\n\tif (!in_dev)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_parse_nested(tb, IFLA_INET_MAX, nla, NULL) < 0)\n\t\tBUG();\n\n\tif (tb[IFLA_INET_CONF]) {\n\t\tnla_for_each_nested(a, tb[IFLA_INET_CONF], rem)\n\t\t\tipv4_devconf_set(in_dev, nla_type(a), nla_get_u32(a));\n\t}\n\n\treturn 0;\n}\n\nstatic int inet_netconf_msgsize_devconf(int type)\n{\n\tint size = NLMSG_ALIGN(sizeof(struct netconfmsg))\n\t\t   + nla_total_size(4);\t/* NETCONFA_IFINDEX */\n\tbool all = false;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tif (all || type == NETCONFA_FORWARDING)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_RP_FILTER)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_MC_FORWARDING)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_PROXY_NEIGH)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN)\n\t\tsize += nla_total_size(4);\n\n\treturn size;\n}\n\nstatic int inet_netconf_fill_devconf(struct sk_buff *skb, int ifindex,\n\t\t\t\t     struct ipv4_devconf *devconf, u32 portid,\n\t\t\t\t     u32 seq, int event, unsigned int flags,\n\t\t\t\t     int type)\n{\n\tstruct nlmsghdr  *nlh;\n\tstruct netconfmsg *ncm;\n\tbool all = false;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct netconfmsg),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tncm = nlmsg_data(nlh);\n\tncm->ncm_family = AF_INET;\n\n\tif (nla_put_s32(skb, NETCONFA_IFINDEX, ifindex) < 0)\n\t\tgoto nla_put_failure;\n\n\tif ((all || type == NETCONFA_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_FORWARDING,\n\t\t\tIPV4_DEVCONF(*devconf, FORWARDING)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_RP_FILTER) &&\n\t    nla_put_s32(skb, NETCONFA_RP_FILTER,\n\t\t\tIPV4_DEVCONF(*devconf, RP_FILTER)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_MC_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_MC_FORWARDING,\n\t\t\tIPV4_DEVCONF(*devconf, MC_FORWARDING)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_PROXY_NEIGH) &&\n\t    nla_put_s32(skb, NETCONFA_PROXY_NEIGH,\n\t\t\tIPV4_DEVCONF(*devconf, PROXY_ARP)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN) &&\n\t    nla_put_s32(skb, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\tIPV4_DEVCONF(*devconf, IGNORE_ROUTES_WITH_LINKDOWN)) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nvoid inet_netconf_notify_devconf(struct net *net, int type, int ifindex,\n\t\t\t\t struct ipv4_devconf *devconf)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(inet_netconf_msgsize_devconf(type), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_netconf_fill_devconf(skb, ifindex, devconf, 0, 0,\n\t\t\t\t\tRTM_NEWNETCONF, 0, type);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in inet_netconf_msgsize_devconf() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_NETCONF, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_NETCONF, err);\n}\n\nstatic const struct nla_policy devconf_ipv4_policy[NETCONFA_MAX+1] = {\n\t[NETCONFA_IFINDEX]\t= { .len = sizeof(int) },\n\t[NETCONFA_FORWARDING]\t= { .len = sizeof(int) },\n\t[NETCONFA_RP_FILTER]\t= { .len = sizeof(int) },\n\t[NETCONFA_PROXY_NEIGH]\t= { .len = sizeof(int) },\n\t[NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN]\t= { .len = sizeof(int) },\n};\n\nstatic int inet_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t    struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct netconfmsg *ncm;\n\tstruct sk_buff *skb;\n\tstruct ipv4_devconf *devconf;\n\tstruct in_device *in_dev;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\n\t\t\t  devconf_ipv4_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tswitch (ifindex) {\n\tcase NETCONFA_IFINDEX_ALL:\n\t\tdevconf = net->ipv4.devconf_all;\n\t\tbreak;\n\tcase NETCONFA_IFINDEX_DEFAULT:\n\t\tdevconf = net->ipv4.devconf_dflt;\n\t\tbreak;\n\tdefault:\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t\tif (!dev)\n\t\t\tgoto errout;\n\t\tin_dev = __in_dev_get_rtnl(dev);\n\t\tif (!in_dev)\n\t\t\tgoto errout;\n\t\tdevconf = &in_dev->cnf;\n\t\tbreak;\n\t}\n\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(inet_netconf_msgsize_devconf(NETCONFA_ALL), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_netconf_fill_devconf(skb, ifindex, devconf,\n\t\t\t\t\tNETLINK_CB(in_skb).portid,\n\t\t\t\t\tnlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\tNETCONFA_ALL);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in inet_netconf_msgsize_devconf() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}\n\nstatic int inet_netconf_dump_devconf(struct sk_buff *skb,\n\t\t\t\t     struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx, s_idx;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tstruct hlist_head *head;\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = atomic_read(&net->ipv4.dev_addr_genid) ^\n\t\t\t  net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tin_dev = __in_dev_get_rcu(dev);\n\t\t\tif (!in_dev)\n\t\t\t\tgoto cont;\n\n\t\t\tif (inet_netconf_fill_devconf(skb, dev->ifindex,\n\t\t\t\t\t\t      &in_dev->cnf,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t      RTM_NEWNETCONF,\n\t\t\t\t\t\t      NLM_F_MULTI,\n\t\t\t\t\t\t      NETCONFA_ALL) < 0) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (h == NETDEV_HASHENTRIES) {\n\t\tif (inet_netconf_fill_devconf(skb, NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t      net->ipv4.devconf_all,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      RTM_NEWNETCONF, NLM_F_MULTI,\n\t\t\t\t\t      NETCONFA_ALL) < 0)\n\t\t\tgoto done;\n\t\telse\n\t\t\th++;\n\t}\n\tif (h == NETDEV_HASHENTRIES + 1) {\n\t\tif (inet_netconf_fill_devconf(skb, NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t      net->ipv4.devconf_dflt,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      RTM_NEWNETCONF, NLM_F_MULTI,\n\t\t\t\t\t      NETCONFA_ALL) < 0)\n\t\t\tgoto done;\n\t\telse\n\t\t\th++;\n\t}\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\n\treturn skb->len;\n}\n\n#ifdef CONFIG_SYSCTL\n\nstatic void devinet_copy_dflt_conf(struct net *net, int i)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tstruct in_device *in_dev;\n\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !test_bit(i, in_dev->cnf.state))\n\t\t\tin_dev->cnf.data[i] = net->ipv4.devconf_dflt->data[i];\n\t}\n\trcu_read_unlock();\n}\n\n/* called with RTNL locked */\nstatic void inet_forward_change(struct net *net)\n{\n\tstruct net_device *dev;\n\tint on = IPV4_DEVCONF_ALL(net, FORWARDING);\n\n\tIPV4_DEVCONF_ALL(net, ACCEPT_REDIRECTS) = !on;\n\tIPV4_DEVCONF_DFLT(net, FORWARDING) = on;\n\tinet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\n\t\t\t\t    NETCONFA_IFINDEX_ALL,\n\t\t\t\t    net->ipv4.devconf_all);\n\tinet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\n\t\t\t\t    NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t    net->ipv4.devconf_dflt);\n\n\tfor_each_netdev(net, dev) {\n\t\tstruct in_device *in_dev;\n\t\tif (on)\n\t\t\tdev_disable_lro(dev);\n\t\trcu_read_lock();\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev) {\n\t\t\tIN_DEV_CONF_SET(in_dev, FORWARDING, on);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\n\t\t\t\t\t\t    dev->ifindex, &in_dev->cnf);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic int devinet_conf_ifindex(struct net *net, struct ipv4_devconf *cnf)\n{\n\tif (cnf == net->ipv4.devconf_dflt)\n\t\treturn NETCONFA_IFINDEX_DEFAULT;\n\telse if (cnf == net->ipv4.devconf_all)\n\t\treturn NETCONFA_IFINDEX_ALL;\n\telse {\n\t\tstruct in_device *idev\n\t\t\t= container_of(cnf, struct in_device, cnf);\n\t\treturn idev->dev->ifindex;\n\t}\n}\n\nstatic int devinet_conf_proc(struct ctl_table *ctl, int write,\n\t\t\t     void __user *buffer,\n\t\t\t     size_t *lenp, loff_t *ppos)\n{\n\tint old_value = *(int *)ctl->data;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tint new_value = *(int *)ctl->data;\n\n\tif (write) {\n\t\tstruct ipv4_devconf *cnf = ctl->extra1;\n\t\tstruct net *net = ctl->extra2;\n\t\tint i = (int *)ctl->data - cnf->data;\n\t\tint ifindex;\n\n\t\tset_bit(i, cnf->state);\n\n\t\tif (cnf == net->ipv4.devconf_dflt)\n\t\t\tdevinet_copy_dflt_conf(net, i);\n\t\tif (i == IPV4_DEVCONF_ACCEPT_LOCAL - 1 ||\n\t\t    i == IPV4_DEVCONF_ROUTE_LOCALNET - 1)\n\t\t\tif ((new_value == 0) && (old_value != 0))\n\t\t\t\trt_cache_flush(net);\n\n\t\tif (i == IPV4_DEVCONF_RP_FILTER - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_RP_FILTER,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t\tif (i == IPV4_DEVCONF_PROXY_ARP - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t\tif (i == IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int devinet_sysctl_forward(struct ctl_table *ctl, int write,\n\t\t\t\t  void __user *buffer,\n\t\t\t\t  size_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tloff_t pos = *ppos;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write && *valp != val) {\n\t\tstruct net *net = ctl->extra2;\n\n\t\tif (valp != &IPV4_DEVCONF_DFLT(net, FORWARDING)) {\n\t\t\tif (!rtnl_trylock()) {\n\t\t\t\t/* Restore the original values before restarting */\n\t\t\t\t*valp = val;\n\t\t\t\t*ppos = pos;\n\t\t\t\treturn restart_syscall();\n\t\t\t}\n\t\t\tif (valp == &IPV4_DEVCONF_ALL(net, FORWARDING)) {\n\t\t\t\tinet_forward_change(net);\n\t\t\t} else {\n\t\t\t\tstruct ipv4_devconf *cnf = ctl->extra1;\n\t\t\t\tstruct in_device *idev =\n\t\t\t\t\tcontainer_of(cnf, struct in_device, cnf);\n\t\t\t\tif (*valp)\n\t\t\t\t\tdev_disable_lro(idev->dev);\n\t\t\t\tinet_netconf_notify_devconf(net,\n\t\t\t\t\t\t\t    NETCONFA_FORWARDING,\n\t\t\t\t\t\t\t    idev->dev->ifindex,\n\t\t\t\t\t\t\t    cnf);\n\t\t\t}\n\t\t\trtnl_unlock();\n\t\t\trt_cache_flush(net);\n\t\t} else\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\n\t\t\t\t\t\t    NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t\t    net->ipv4.devconf_dflt);\n\t}\n\n\treturn ret;\n}\n\nstatic int ipv4_doint_and_flush(struct ctl_table *ctl, int write,\n\t\t\t\tvoid __user *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tstruct net *net = ctl->extra2;\n\n\tif (write && *valp != val)\n\t\trt_cache_flush(net);\n\n\treturn ret;\n}\n\n#define DEVINET_SYSCTL_ENTRY(attr, name, mval, proc) \\\n\t{ \\\n\t\t.procname\t= name, \\\n\t\t.data\t\t= ipv4_devconf.data + \\\n\t\t\t\t  IPV4_DEVCONF_ ## attr - 1, \\\n\t\t.maxlen\t\t= sizeof(int), \\\n\t\t.mode\t\t= mval, \\\n\t\t.proc_handler\t= proc, \\\n\t\t.extra1\t\t= &ipv4_devconf, \\\n\t}\n\n#define DEVINET_SYSCTL_RW_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0644, devinet_conf_proc)\n\n#define DEVINET_SYSCTL_RO_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0444, devinet_conf_proc)\n\n#define DEVINET_SYSCTL_COMPLEX_ENTRY(attr, name, proc) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0644, proc)\n\n#define DEVINET_SYSCTL_FLUSHING_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_COMPLEX_ENTRY(attr, name, ipv4_doint_and_flush)\n\nstatic struct devinet_sysctl_table {\n\tstruct ctl_table_header *sysctl_header;\n\tstruct ctl_table devinet_vars[__IPV4_DEVCONF_MAX];\n} devinet_sysctl = {\n\t.devinet_vars = {\n\t\tDEVINET_SYSCTL_COMPLEX_ENTRY(FORWARDING, \"forwarding\",\n\t\t\t\t\t     devinet_sysctl_forward),\n\t\tDEVINET_SYSCTL_RO_ENTRY(MC_FORWARDING, \"mc_forwarding\"),\n\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_REDIRECTS, \"accept_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SECURE_REDIRECTS, \"secure_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SHARED_MEDIA, \"shared_media\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(RP_FILTER, \"rp_filter\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SEND_REDIRECTS, \"send_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_SOURCE_ROUTE,\n\t\t\t\t\t\"accept_source_route\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_LOCAL, \"accept_local\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SRC_VMARK, \"src_valid_mark\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(PROXY_ARP, \"proxy_arp\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(MEDIUM_ID, \"medium_id\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(BOOTP_RELAY, \"bootp_relay\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(LOG_MARTIANS, \"log_martians\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(TAG, \"tag\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARPFILTER, \"arp_filter\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_ANNOUNCE, \"arp_announce\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_IGNORE, \"arp_ignore\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_ACCEPT, \"arp_accept\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_NOTIFY, \"arp_notify\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(PROXY_ARP_PVLAN, \"proxy_arp_pvlan\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(FORCE_IGMP_VERSION,\n\t\t\t\t\t\"force_igmp_version\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGMPV2_UNSOLICITED_REPORT_INTERVAL,\n\t\t\t\t\t\"igmpv2_unsolicited_report_interval\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGMPV3_UNSOLICITED_REPORT_INTERVAL,\n\t\t\t\t\t\"igmpv3_unsolicited_report_interval\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\"ignore_routes_with_linkdown\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(DROP_GRATUITOUS_ARP,\n\t\t\t\t\t\"drop_gratuitous_arp\"),\n\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(NOXFRM, \"disable_xfrm\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(NOPOLICY, \"disable_policy\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(PROMOTE_SECONDARIES,\n\t\t\t\t\t      \"promote_secondaries\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(ROUTE_LOCALNET,\n\t\t\t\t\t      \"route_localnet\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(DROP_UNICAST_IN_L2_MULTICAST,\n\t\t\t\t\t      \"drop_unicast_in_l2_multicast\"),\n\t},\n};\n\nstatic int __devinet_sysctl_register(struct net *net, char *dev_name,\n\t\t\t\t\tstruct ipv4_devconf *p)\n{\n\tint i;\n\tstruct devinet_sysctl_table *t;\n\tchar path[sizeof(\"net/ipv4/conf/\") + IFNAMSIZ];\n\n\tt = kmemdup(&devinet_sysctl, sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(t->devinet_vars) - 1; i++) {\n\t\tt->devinet_vars[i].data += (char *)p - (char *)&ipv4_devconf;\n\t\tt->devinet_vars[i].extra1 = p;\n\t\tt->devinet_vars[i].extra2 = net;\n\t}\n\n\tsnprintf(path, sizeof(path), \"net/ipv4/conf/%s\", dev_name);\n\n\tt->sysctl_header = register_net_sysctl(net, path, t->devinet_vars);\n\tif (!t->sysctl_header)\n\t\tgoto free;\n\n\tp->sysctl = t;\n\treturn 0;\n\nfree:\n\tkfree(t);\nout:\n\treturn -ENOBUFS;\n}\n\nstatic void __devinet_sysctl_unregister(struct ipv4_devconf *cnf)\n{\n\tstruct devinet_sysctl_table *t = cnf->sysctl;\n\n\tif (!t)\n\t\treturn;\n\n\tcnf->sysctl = NULL;\n\tunregister_net_sysctl_table(t->sysctl_header);\n\tkfree(t);\n}\n\nstatic int devinet_sysctl_register(struct in_device *idev)\n{\n\tint err;\n\n\tif (!sysctl_dev_name_is_allowed(idev->dev->name))\n\t\treturn -EINVAL;\n\n\terr = neigh_sysctl_register(idev->dev, idev->arp_parms, NULL);\n\tif (err)\n\t\treturn err;\n\terr = __devinet_sysctl_register(dev_net(idev->dev), idev->dev->name,\n\t\t\t\t\t&idev->cnf);\n\tif (err)\n\t\tneigh_sysctl_unregister(idev->arp_parms);\n\treturn err;\n}\n\nstatic void devinet_sysctl_unregister(struct in_device *idev)\n{\n\t__devinet_sysctl_unregister(&idev->cnf);\n\tneigh_sysctl_unregister(idev->arp_parms);\n}\n\nstatic struct ctl_table ctl_forward_entry[] = {\n\t{\n\t\t.procname\t= \"ip_forward\",\n\t\t.data\t\t= &ipv4_devconf.data[\n\t\t\t\t\tIPV4_DEVCONF_FORWARDING - 1],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= devinet_sysctl_forward,\n\t\t.extra1\t\t= &ipv4_devconf,\n\t\t.extra2\t\t= &init_net,\n\t},\n\t{ },\n};\n#endif\n\nstatic __net_init int devinet_init_net(struct net *net)\n{\n\tint err;\n\tstruct ipv4_devconf *all, *dflt;\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl = ctl_forward_entry;\n\tstruct ctl_table_header *forw_hdr;\n#endif\n\n\terr = -ENOMEM;\n\tall = &ipv4_devconf;\n\tdflt = &ipv4_devconf_dflt;\n\n\tif (!net_eq(net, &init_net)) {\n\t\tall = kmemdup(all, sizeof(ipv4_devconf), GFP_KERNEL);\n\t\tif (!all)\n\t\t\tgoto err_alloc_all;\n\n\t\tdflt = kmemdup(dflt, sizeof(ipv4_devconf_dflt), GFP_KERNEL);\n\t\tif (!dflt)\n\t\t\tgoto err_alloc_dflt;\n\n#ifdef CONFIG_SYSCTL\n\t\ttbl = kmemdup(tbl, sizeof(ctl_forward_entry), GFP_KERNEL);\n\t\tif (!tbl)\n\t\t\tgoto err_alloc_ctl;\n\n\t\ttbl[0].data = &all->data[IPV4_DEVCONF_FORWARDING - 1];\n\t\ttbl[0].extra1 = all;\n\t\ttbl[0].extra2 = net;\n#endif\n\t}\n\n#ifdef CONFIG_SYSCTL\n\terr = __devinet_sysctl_register(net, \"all\", all);\n\tif (err < 0)\n\t\tgoto err_reg_all;\n\n\terr = __devinet_sysctl_register(net, \"default\", dflt);\n\tif (err < 0)\n\t\tgoto err_reg_dflt;\n\n\terr = -ENOMEM;\n\tforw_hdr = register_net_sysctl(net, \"net/ipv4\", tbl);\n\tif (!forw_hdr)\n\t\tgoto err_reg_ctl;\n\tnet->ipv4.forw_hdr = forw_hdr;\n#endif\n\n\tnet->ipv4.devconf_all = all;\n\tnet->ipv4.devconf_dflt = dflt;\n\treturn 0;\n\n#ifdef CONFIG_SYSCTL\nerr_reg_ctl:\n\t__devinet_sysctl_unregister(dflt);\nerr_reg_dflt:\n\t__devinet_sysctl_unregister(all);\nerr_reg_all:\n\tif (tbl != ctl_forward_entry)\n\t\tkfree(tbl);\nerr_alloc_ctl:\n#endif\n\tif (dflt != &ipv4_devconf_dflt)\n\t\tkfree(dflt);\nerr_alloc_dflt:\n\tif (all != &ipv4_devconf)\n\t\tkfree(all);\nerr_alloc_all:\n\treturn err;\n}\n\nstatic __net_exit void devinet_exit_net(struct net *net)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = net->ipv4.forw_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv4.forw_hdr);\n\t__devinet_sysctl_unregister(net->ipv4.devconf_dflt);\n\t__devinet_sysctl_unregister(net->ipv4.devconf_all);\n\tkfree(tbl);\n#endif\n\tkfree(net->ipv4.devconf_dflt);\n\tkfree(net->ipv4.devconf_all);\n}\n\nstatic __net_initdata struct pernet_operations devinet_ops = {\n\t.init = devinet_init_net,\n\t.exit = devinet_exit_net,\n};\n\nstatic struct rtnl_af_ops inet_af_ops __read_mostly = {\n\t.family\t\t  = AF_INET,\n\t.fill_link_af\t  = inet_fill_link_af,\n\t.get_link_af_size = inet_get_link_af_size,\n\t.validate_link_af = inet_validate_link_af,\n\t.set_link_af\t  = inet_set_link_af,\n};\n\nvoid __init devinet_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < IN4_ADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&inet_addr_lst[i]);\n\n\tregister_pernet_subsys(&devinet_ops);\n\n\tregister_gifconf(PF_INET, inet_gifconf);\n\tregister_netdevice_notifier(&ip_netdev_notifier);\n\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\n\n\trtnl_af_register(&inet_af_ops);\n\n\trtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL, NULL);\n\trtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL, NULL);\n\trtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr, NULL);\n\trtnl_register(PF_INET, RTM_GETNETCONF, inet_netconf_get_devconf,\n\t\t      inet_netconf_dump_devconf, NULL);\n}\n", "/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tIPv4 Forwarding Information Base: FIB frontend.\n *\n * Authors:\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <asm/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/if_addr.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/cache.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/arp.h>\n#include <net/ip_fib.h>\n#include <net/rtnetlink.h>\n#include <net/xfrm.h>\n#include <net/l3mdev.h>\n#include <trace/events/fib.h>\n\n#ifndef CONFIG_IP_MULTIPLE_TABLES\n\nstatic int __net_init fib4_rules_init(struct net *net)\n{\n\tstruct fib_table *local_table, *main_table;\n\n\tmain_table  = fib_trie_table(RT_TABLE_MAIN, NULL);\n\tif (!main_table)\n\t\treturn -ENOMEM;\n\n\tlocal_table = fib_trie_table(RT_TABLE_LOCAL, main_table);\n\tif (!local_table)\n\t\tgoto fail;\n\n\thlist_add_head_rcu(&local_table->tb_hlist,\n\t\t\t\t&net->ipv4.fib_table_hash[TABLE_LOCAL_INDEX]);\n\thlist_add_head_rcu(&main_table->tb_hlist,\n\t\t\t\t&net->ipv4.fib_table_hash[TABLE_MAIN_INDEX]);\n\treturn 0;\n\nfail:\n\tfib_free_table(main_table);\n\treturn -ENOMEM;\n}\n#else\n\nstruct fib_table *fib_new_table(struct net *net, u32 id)\n{\n\tstruct fib_table *tb, *alias = NULL;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT_TABLE_MAIN;\n\ttb = fib_get_table(net, id);\n\tif (tb)\n\t\treturn tb;\n\n\tif (id == RT_TABLE_LOCAL)\n\t\talias = fib_new_table(net, RT_TABLE_MAIN);\n\n\ttb = fib_trie_table(id, alias);\n\tif (!tb)\n\t\treturn NULL;\n\n\tswitch (id) {\n\tcase RT_TABLE_LOCAL:\n\t\trcu_assign_pointer(net->ipv4.fib_local, tb);\n\t\tbreak;\n\tcase RT_TABLE_MAIN:\n\t\trcu_assign_pointer(net->ipv4.fib_main, tb);\n\t\tbreak;\n\tcase RT_TABLE_DEFAULT:\n\t\trcu_assign_pointer(net->ipv4.fib_default, tb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\th = id & (FIB_TABLE_HASHSZ - 1);\n\thlist_add_head_rcu(&tb->tb_hlist, &net->ipv4.fib_table_hash[h]);\n\treturn tb;\n}\n\n/* caller must hold either rtnl or rcu read lock */\nstruct fib_table *fib_get_table(struct net *net, u32 id)\n{\n\tstruct fib_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT_TABLE_MAIN;\n\th = id & (FIB_TABLE_HASHSZ - 1);\n\n\thead = &net->ipv4.fib_table_hash[h];\n\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\tif (tb->tb_id == id)\n\t\t\treturn tb;\n\t}\n\treturn NULL;\n}\n#endif /* CONFIG_IP_MULTIPLE_TABLES */\n\nstatic void fib_replace_table(struct net *net, struct fib_table *old,\n\t\t\t      struct fib_table *new)\n{\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tswitch (new->tb_id) {\n\tcase RT_TABLE_LOCAL:\n\t\trcu_assign_pointer(net->ipv4.fib_local, new);\n\t\tbreak;\n\tcase RT_TABLE_MAIN:\n\t\trcu_assign_pointer(net->ipv4.fib_main, new);\n\t\tbreak;\n\tcase RT_TABLE_DEFAULT:\n\t\trcu_assign_pointer(net->ipv4.fib_default, new);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n#endif\n\t/* replace the old table in the hlist */\n\thlist_replace_rcu(&old->tb_hlist, &new->tb_hlist);\n}\n\nint fib_unmerge(struct net *net)\n{\n\tstruct fib_table *old, *new;\n\n\t/* attempt to fetch local table if it has been allocated */\n\told = fib_get_table(net, RT_TABLE_LOCAL);\n\tif (!old)\n\t\treturn 0;\n\n\tnew = fib_trie_unmerge(old);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/* replace merged table with clean table */\n\tif (new != old) {\n\t\tfib_replace_table(net, old, new);\n\t\tfib_free_table(old);\n\t}\n\n\treturn 0;\n}\n\nstatic void fib_flush(struct net *net)\n{\n\tint flushed = 0;\n\tunsigned int h;\n\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb_hlist)\n\t\t\tflushed += fib_table_flush(tb);\n\t}\n\n\tif (flushed)\n\t\trt_cache_flush(net);\n}\n\nvoid fib_flush_external(struct net *net)\n{\n\tstruct fib_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv4.fib_table_hash[h];\n\t\thlist_for_each_entry(tb, head, tb_hlist)\n\t\t\tfib_table_flush_external(tb);\n\t}\n}\n\n/*\n * Find address type as if only \"dev\" was present in the system. If\n * on_dev is NULL then all interfaces are taken into consideration.\n */\nstatic inline unsigned int __inet_dev_addr_type(struct net *net,\n\t\t\t\t\t\tconst struct net_device *dev,\n\t\t\t\t\t\t__be32 addr, u32 tb_id)\n{\n\tstruct flowi4\t\tfl4 = { .daddr = addr };\n\tstruct fib_result\tres;\n\tunsigned int ret = RTN_BROADCAST;\n\tstruct fib_table *table;\n\n\tif (ipv4_is_zeronet(addr) || ipv4_is_lbcast(addr))\n\t\treturn RTN_BROADCAST;\n\tif (ipv4_is_multicast(addr))\n\t\treturn RTN_MULTICAST;\n\n\trcu_read_lock();\n\n\ttable = fib_get_table(net, tb_id);\n\tif (table) {\n\t\tret = RTN_UNICAST;\n\t\tif (!fib_table_lookup(table, &fl4, &res, FIB_LOOKUP_NOREF)) {\n\t\t\tif (!dev || dev == res.fi->fib_dev)\n\t\t\t\tret = res.type;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\nunsigned int inet_addr_type_table(struct net *net, __be32 addr, u32 tb_id)\n{\n\treturn __inet_dev_addr_type(net, NULL, addr, tb_id);\n}\nEXPORT_SYMBOL(inet_addr_type_table);\n\nunsigned int inet_addr_type(struct net *net, __be32 addr)\n{\n\treturn __inet_dev_addr_type(net, NULL, addr, RT_TABLE_LOCAL);\n}\nEXPORT_SYMBOL(inet_addr_type);\n\nunsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,\n\t\t\t\t__be32 addr)\n{\n\tu32 rt_table = l3mdev_fib_table(dev) ? : RT_TABLE_LOCAL;\n\n\treturn __inet_dev_addr_type(net, dev, addr, rt_table);\n}\nEXPORT_SYMBOL(inet_dev_addr_type);\n\n/* inet_addr_type with dev == NULL but using the table from a dev\n * if one is associated\n */\nunsigned int inet_addr_type_dev_table(struct net *net,\n\t\t\t\t      const struct net_device *dev,\n\t\t\t\t      __be32 addr)\n{\n\tu32 rt_table = l3mdev_fib_table(dev) ? : RT_TABLE_LOCAL;\n\n\treturn __inet_dev_addr_type(net, NULL, addr, rt_table);\n}\nEXPORT_SYMBOL(inet_addr_type_dev_table);\n\n__be32 fib_compute_spec_dst(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct in_device *in_dev;\n\tstruct fib_result res;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tstruct net *net;\n\tint scope;\n\n\trt = skb_rtable(skb);\n\tif ((rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST | RTCF_LOCAL)) ==\n\t    RTCF_LOCAL)\n\t\treturn ip_hdr(skb)->daddr;\n\n\tin_dev = __in_dev_get_rcu(dev);\n\tBUG_ON(!in_dev);\n\n\tnet = dev_net(dev);\n\n\tscope = RT_SCOPE_UNIVERSE;\n\tif (!ipv4_is_zeronet(ip_hdr(skb)->saddr)) {\n\t\tfl4.flowi4_oif = 0;\n\t\tfl4.flowi4_iif = LOOPBACK_IFINDEX;\n\t\tfl4.daddr = ip_hdr(skb)->saddr;\n\t\tfl4.saddr = 0;\n\t\tfl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);\n\t\tfl4.flowi4_scope = scope;\n\t\tfl4.flowi4_mark = IN_DEV_SRC_VMARK(in_dev) ? skb->mark : 0;\n\t\tfl4.flowi4_tun_key.tun_id = 0;\n\t\tif (!fib_lookup(net, &fl4, &res, 0))\n\t\t\treturn FIB_RES_PREFSRC(net, res);\n\t} else {\n\t\tscope = RT_SCOPE_LINK;\n\t}\n\n\treturn inet_select_addr(dev, ip_hdr(skb)->saddr, scope);\n}\n\n/* Given (packet source, input interface) and optional (dst, oif, tos):\n * - (main) check, that source is valid i.e. not broadcast or our local\n *   address.\n * - figure out what \"logical\" interface this packet arrived\n *   and calculate \"specific destination\" address.\n * - check, that packet arrived from expected physical interface.\n * called with rcu_read_lock()\n */\nstatic int __fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\n\t\t\t\t u8 tos, int oif, struct net_device *dev,\n\t\t\t\t int rpf, struct in_device *idev, u32 *itag)\n{\n\tint ret, no_addr;\n\tstruct fib_result res;\n\tstruct flowi4 fl4;\n\tstruct net *net;\n\tbool dev_match;\n\n\tfl4.flowi4_oif = 0;\n\tfl4.flowi4_iif = l3mdev_master_ifindex_rcu(dev);\n\tif (!fl4.flowi4_iif)\n\t\tfl4.flowi4_iif = oif ? : LOOPBACK_IFINDEX;\n\tfl4.daddr = src;\n\tfl4.saddr = dst;\n\tfl4.flowi4_tos = tos;\n\tfl4.flowi4_scope = RT_SCOPE_UNIVERSE;\n\tfl4.flowi4_tun_key.tun_id = 0;\n\tfl4.flowi4_flags = 0;\n\n\tno_addr = idev->ifa_list == NULL;\n\n\tfl4.flowi4_mark = IN_DEV_SRC_VMARK(idev) ? skb->mark : 0;\n\n\ttrace_fib_validate_source(dev, &fl4);\n\n\tnet = dev_net(dev);\n\tif (fib_lookup(net, &fl4, &res, 0))\n\t\tgoto last_resort;\n\tif (res.type != RTN_UNICAST &&\n\t    (res.type != RTN_LOCAL || !IN_DEV_ACCEPT_LOCAL(idev)))\n\t\tgoto e_inval;\n\tif (!rpf && !fib_num_tclassid_users(dev_net(dev)) &&\n\t    (dev->ifindex != oif || !IN_DEV_TX_REDIRECTS(idev)))\n\t\tgoto last_resort;\n\tfib_combine_itag(itag, &res);\n\tdev_match = false;\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tfor (ret = 0; ret < res.fi->fib_nhs; ret++) {\n\t\tstruct fib_nh *nh = &res.fi->fib_nh[ret];\n\n\t\tif (nh->nh_dev == dev) {\n\t\t\tdev_match = true;\n\t\t\tbreak;\n\t\t} else if (l3mdev_master_ifindex_rcu(nh->nh_dev) == dev->ifindex) {\n\t\t\tdev_match = true;\n\t\t\tbreak;\n\t\t}\n\t}\n#else\n\tif (FIB_RES_DEV(res) == dev)\n\t\tdev_match = true;\n#endif\n\tif (dev_match) {\n\t\tret = FIB_RES_NH(res).nh_scope >= RT_SCOPE_HOST;\n\t\treturn ret;\n\t}\n\tif (no_addr)\n\t\tgoto last_resort;\n\tif (rpf == 1)\n\t\tgoto e_rpf;\n\tfl4.flowi4_oif = dev->ifindex;\n\n\tret = 0;\n\tif (fib_lookup(net, &fl4, &res, FIB_LOOKUP_IGNORE_LINKSTATE) == 0) {\n\t\tif (res.type == RTN_UNICAST)\n\t\t\tret = FIB_RES_NH(res).nh_scope >= RT_SCOPE_HOST;\n\t}\n\treturn ret;\n\nlast_resort:\n\tif (rpf)\n\t\tgoto e_rpf;\n\t*itag = 0;\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\ne_rpf:\n\treturn -EXDEV;\n}\n\n/* Ignore rp_filter for packets protected by IPsec. */\nint fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\n\t\t\tu8 tos, int oif, struct net_device *dev,\n\t\t\tstruct in_device *idev, u32 *itag)\n{\n\tint r = secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);\n\n\tif (!r && !fib_num_tclassid_users(dev_net(dev)) &&\n\t    IN_DEV_ACCEPT_LOCAL(idev) &&\n\t    (dev->ifindex != oif || !IN_DEV_TX_REDIRECTS(idev))) {\n\t\t*itag = 0;\n\t\treturn 0;\n\t}\n\treturn __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);\n}\n\nstatic inline __be32 sk_extract_addr(struct sockaddr *addr)\n{\n\treturn ((struct sockaddr_in *) addr)->sin_addr.s_addr;\n}\n\nstatic int put_rtax(struct nlattr *mx, int len, int type, u32 value)\n{\n\tstruct nlattr *nla;\n\n\tnla = (struct nlattr *) ((char *) mx + len);\n\tnla->nla_type = type;\n\tnla->nla_len = nla_attr_size(4);\n\t*(u32 *) nla_data(nla) = value;\n\n\treturn len + nla_total_size(4);\n}\n\nstatic int rtentry_to_fib_config(struct net *net, int cmd, struct rtentry *rt,\n\t\t\t\t struct fib_config *cfg)\n{\n\t__be32 addr;\n\tint plen;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\tcfg->fc_nlinfo.nl_net = net;\n\n\tif (rt->rt_dst.sa_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * Check mask for validity:\n\t * a) it must be contiguous.\n\t * b) destination must have all host bits clear.\n\t * c) if application forgot to set correct family (AF_INET),\n\t *    reject request unless it is absolutely clear i.e.\n\t *    both family and mask are zero.\n\t */\n\tplen = 32;\n\taddr = sk_extract_addr(&rt->rt_dst);\n\tif (!(rt->rt_flags & RTF_HOST)) {\n\t\t__be32 mask = sk_extract_addr(&rt->rt_genmask);\n\n\t\tif (rt->rt_genmask.sa_family != AF_INET) {\n\t\t\tif (mask || rt->rt_genmask.sa_family)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tif (bad_mask(mask, addr))\n\t\t\treturn -EINVAL;\n\n\t\tplen = inet_mask_len(mask);\n\t}\n\n\tcfg->fc_dst_len = plen;\n\tcfg->fc_dst = addr;\n\n\tif (cmd != SIOCDELRT) {\n\t\tcfg->fc_nlflags = NLM_F_CREATE;\n\t\tcfg->fc_protocol = RTPROT_BOOT;\n\t}\n\n\tif (rt->rt_metric)\n\t\tcfg->fc_priority = rt->rt_metric - 1;\n\n\tif (rt->rt_flags & RTF_REJECT) {\n\t\tcfg->fc_scope = RT_SCOPE_HOST;\n\t\tcfg->fc_type = RTN_UNREACHABLE;\n\t\treturn 0;\n\t}\n\n\tcfg->fc_scope = RT_SCOPE_NOWHERE;\n\tcfg->fc_type = RTN_UNICAST;\n\n\tif (rt->rt_dev) {\n\t\tchar *colon;\n\t\tstruct net_device *dev;\n\t\tchar devname[IFNAMSIZ];\n\n\t\tif (copy_from_user(devname, rt->rt_dev, IFNAMSIZ-1))\n\t\t\treturn -EFAULT;\n\n\t\tdevname[IFNAMSIZ-1] = 0;\n\t\tcolon = strchr(devname, ':');\n\t\tif (colon)\n\t\t\t*colon = 0;\n\t\tdev = __dev_get_by_name(net, devname);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\t\tcfg->fc_oif = dev->ifindex;\n\t\tif (colon) {\n\t\t\tstruct in_ifaddr *ifa;\n\t\t\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\t\t\tif (!in_dev)\n\t\t\t\treturn -ENODEV;\n\t\t\t*colon = ':';\n\t\t\tfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next)\n\t\t\t\tif (strcmp(ifa->ifa_label, devname) == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (!ifa)\n\t\t\t\treturn -ENODEV;\n\t\t\tcfg->fc_prefsrc = ifa->ifa_local;\n\t\t}\n\t}\n\n\taddr = sk_extract_addr(&rt->rt_gateway);\n\tif (rt->rt_gateway.sa_family == AF_INET && addr) {\n\t\tunsigned int addr_type;\n\n\t\tcfg->fc_gw = addr;\n\t\taddr_type = inet_addr_type_table(net, addr, cfg->fc_table);\n\t\tif (rt->rt_flags & RTF_GATEWAY &&\n\t\t    addr_type == RTN_UNICAST)\n\t\t\tcfg->fc_scope = RT_SCOPE_UNIVERSE;\n\t}\n\n\tif (cmd == SIOCDELRT)\n\t\treturn 0;\n\n\tif (rt->rt_flags & RTF_GATEWAY && !cfg->fc_gw)\n\t\treturn -EINVAL;\n\n\tif (cfg->fc_scope == RT_SCOPE_NOWHERE)\n\t\tcfg->fc_scope = RT_SCOPE_LINK;\n\n\tif (rt->rt_flags & (RTF_MTU | RTF_WINDOW | RTF_IRTT)) {\n\t\tstruct nlattr *mx;\n\t\tint len = 0;\n\n\t\tmx = kzalloc(3 * nla_total_size(4), GFP_KERNEL);\n\t\tif (!mx)\n\t\t\treturn -ENOMEM;\n\n\t\tif (rt->rt_flags & RTF_MTU)\n\t\t\tlen = put_rtax(mx, len, RTAX_ADVMSS, rt->rt_mtu - 40);\n\n\t\tif (rt->rt_flags & RTF_WINDOW)\n\t\t\tlen = put_rtax(mx, len, RTAX_WINDOW, rt->rt_window);\n\n\t\tif (rt->rt_flags & RTF_IRTT)\n\t\t\tlen = put_rtax(mx, len, RTAX_RTT, rt->rt_irtt << 3);\n\n\t\tcfg->fc_mx = mx;\n\t\tcfg->fc_mx_len = len;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Handle IP routing ioctl calls.\n * These are used to manipulate the routing tables\n */\nint ip_rt_ioctl(struct net *net, unsigned int cmd, void __user *arg)\n{\n\tstruct fib_config cfg;\n\tstruct rtentry rt;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\t\t/* Add a route */\n\tcase SIOCDELRT:\t\t/* Delete a route */\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&rt, arg, sizeof(rt)))\n\t\t\treturn -EFAULT;\n\n\t\trtnl_lock();\n\t\terr = rtentry_to_fib_config(net, cmd, &rt, &cfg);\n\t\tif (err == 0) {\n\t\t\tstruct fib_table *tb;\n\n\t\t\tif (cmd == SIOCDELRT) {\n\t\t\t\ttb = fib_get_table(net, cfg.fc_table);\n\t\t\t\tif (tb)\n\t\t\t\t\terr = fib_table_delete(tb, &cfg);\n\t\t\t\telse\n\t\t\t\t\terr = -ESRCH;\n\t\t\t} else {\n\t\t\t\ttb = fib_new_table(net, cfg.fc_table);\n\t\t\t\tif (tb)\n\t\t\t\t\terr = fib_table_insert(tb, &cfg);\n\t\t\t\telse\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\n\t\t\t/* allocated by rtentry_to_fib_config() */\n\t\t\tkfree(cfg.fc_mx);\n\t\t}\n\t\trtnl_unlock();\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}\n\nconst struct nla_policy rtm_ipv4_policy[RTA_MAX + 1] = {\n\t[RTA_DST]\t\t= { .type = NLA_U32 },\n\t[RTA_SRC]\t\t= { .type = NLA_U32 },\n\t[RTA_IIF]\t\t= { .type = NLA_U32 },\n\t[RTA_OIF]\t\t= { .type = NLA_U32 },\n\t[RTA_GATEWAY]\t\t= { .type = NLA_U32 },\n\t[RTA_PRIORITY]\t\t= { .type = NLA_U32 },\n\t[RTA_PREFSRC]\t\t= { .type = NLA_U32 },\n\t[RTA_METRICS]\t\t= { .type = NLA_NESTED },\n\t[RTA_MULTIPATH]\t\t= { .len = sizeof(struct rtnexthop) },\n\t[RTA_FLOW]\t\t= { .type = NLA_U32 },\n\t[RTA_ENCAP_TYPE]\t= { .type = NLA_U16 },\n\t[RTA_ENCAP]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int rtm_to_fib_config(struct net *net, struct sk_buff *skb,\n\t\t\t     struct nlmsghdr *nlh, struct fib_config *cfg)\n{\n\tstruct nlattr *attr;\n\tint err, remaining;\n\tstruct rtmsg *rtm;\n\n\terr = nlmsg_validate(nlh, sizeof(*rtm), RTA_MAX, rtm_ipv4_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\trtm = nlmsg_data(nlh);\n\tcfg->fc_dst_len = rtm->rtm_dst_len;\n\tcfg->fc_tos = rtm->rtm_tos;\n\tcfg->fc_table = rtm->rtm_table;\n\tcfg->fc_protocol = rtm->rtm_protocol;\n\tcfg->fc_scope = rtm->rtm_scope;\n\tcfg->fc_type = rtm->rtm_type;\n\tcfg->fc_flags = rtm->rtm_flags;\n\tcfg->fc_nlflags = nlh->nlmsg_flags;\n\n\tcfg->fc_nlinfo.portid = NETLINK_CB(skb).portid;\n\tcfg->fc_nlinfo.nlh = nlh;\n\tcfg->fc_nlinfo.nl_net = net;\n\n\tif (cfg->fc_type > RTN_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tnlmsg_for_each_attr(attr, nlh, sizeof(struct rtmsg), remaining) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase RTA_DST:\n\t\t\tcfg->fc_dst = nla_get_be32(attr);\n\t\t\tbreak;\n\t\tcase RTA_OIF:\n\t\t\tcfg->fc_oif = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_GATEWAY:\n\t\t\tcfg->fc_gw = nla_get_be32(attr);\n\t\t\tbreak;\n\t\tcase RTA_PRIORITY:\n\t\t\tcfg->fc_priority = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_PREFSRC:\n\t\t\tcfg->fc_prefsrc = nla_get_be32(attr);\n\t\t\tbreak;\n\t\tcase RTA_METRICS:\n\t\t\tcfg->fc_mx = nla_data(attr);\n\t\t\tcfg->fc_mx_len = nla_len(attr);\n\t\t\tbreak;\n\t\tcase RTA_MULTIPATH:\n\t\t\tcfg->fc_mp = nla_data(attr);\n\t\t\tcfg->fc_mp_len = nla_len(attr);\n\t\t\tbreak;\n\t\tcase RTA_FLOW:\n\t\t\tcfg->fc_flow = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_TABLE:\n\t\t\tcfg->fc_table = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_ENCAP:\n\t\t\tcfg->fc_encap = attr;\n\t\t\tbreak;\n\t\tcase RTA_ENCAP_TYPE:\n\t\t\tcfg->fc_encap_type = nla_get_u16(attr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\nerrout:\n\treturn err;\n}\n\nstatic int inet_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_config cfg;\n\tstruct fib_table *tb;\n\tint err;\n\n\terr = rtm_to_fib_config(net, skb, nlh, &cfg);\n\tif (err < 0)\n\t\tgoto errout;\n\n\ttb = fib_get_table(net, cfg.fc_table);\n\tif (!tb) {\n\t\terr = -ESRCH;\n\t\tgoto errout;\n\t}\n\n\terr = fib_table_delete(tb, &cfg);\nerrout:\n\treturn err;\n}\n\nstatic int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_config cfg;\n\tstruct fib_table *tb;\n\tint err;\n\n\terr = rtm_to_fib_config(net, skb, nlh, &cfg);\n\tif (err < 0)\n\t\tgoto errout;\n\n\ttb = fib_new_table(net, cfg.fc_table);\n\tif (!tb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\terr = fib_table_insert(tb, &cfg);\nerrout:\n\treturn err;\n}\n\nstatic int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int h, s_h;\n\tunsigned int e = 0, s_e;\n\tstruct fib_table *tb;\n\tstruct hlist_head *head;\n\tint dumped = 0;\n\n\tif (nlmsg_len(cb->nlh) >= sizeof(struct rtmsg) &&\n\t    ((struct rtmsg *) nlmsg_data(cb->nlh))->rtm_flags & RTM_F_CLONED)\n\t\treturn skb->len;\n\n\ts_h = cb->args[0];\n\ts_e = cb->args[1];\n\n\trcu_read_lock();\n\n\tfor (h = s_h; h < FIB_TABLE_HASHSZ; h++, s_e = 0) {\n\t\te = 0;\n\t\thead = &net->ipv4.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next;\n\t\t\tif (dumped)\n\t\t\t\tmemset(&cb->args[2], 0, sizeof(cb->args) -\n\t\t\t\t\t\t 2 * sizeof(cb->args[0]));\n\t\t\tif (fib_table_dump(tb, skb, cb) < 0)\n\t\t\t\tgoto out;\n\t\t\tdumped = 1;\nnext:\n\t\t\te++;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\n\tcb->args[1] = e;\n\tcb->args[0] = h;\n\n\treturn skb->len;\n}\n\n/* Prepare and feed intra-kernel routing request.\n * Really, it should be netlink message, but :-( netlink\n * can be not configured, so that we feed it directly\n * to fib engine. It is legal, because all events occur\n * only when netlink is already locked.\n */\nstatic void fib_magic(int cmd, int type, __be32 dst, int dst_len, struct in_ifaddr *ifa)\n{\n\tstruct net *net = dev_net(ifa->ifa_dev->dev);\n\tu32 tb_id = l3mdev_fib_table(ifa->ifa_dev->dev);\n\tstruct fib_table *tb;\n\tstruct fib_config cfg = {\n\t\t.fc_protocol = RTPROT_KERNEL,\n\t\t.fc_type = type,\n\t\t.fc_dst = dst,\n\t\t.fc_dst_len = dst_len,\n\t\t.fc_prefsrc = ifa->ifa_local,\n\t\t.fc_oif = ifa->ifa_dev->dev->ifindex,\n\t\t.fc_nlflags = NLM_F_CREATE | NLM_F_APPEND,\n\t\t.fc_nlinfo = {\n\t\t\t.nl_net = net,\n\t\t},\n\t};\n\n\tif (!tb_id)\n\t\ttb_id = (type == RTN_UNICAST) ? RT_TABLE_MAIN : RT_TABLE_LOCAL;\n\n\ttb = fib_new_table(net, tb_id);\n\tif (!tb)\n\t\treturn;\n\n\tcfg.fc_table = tb->tb_id;\n\n\tif (type != RTN_LOCAL)\n\t\tcfg.fc_scope = RT_SCOPE_LINK;\n\telse\n\t\tcfg.fc_scope = RT_SCOPE_HOST;\n\n\tif (cmd == RTM_NEWROUTE)\n\t\tfib_table_insert(tb, &cfg);\n\telse\n\t\tfib_table_delete(tb, &cfg);\n}\n\nvoid fib_add_ifaddr(struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct in_ifaddr *prim = ifa;\n\t__be32 mask = ifa->ifa_mask;\n\t__be32 addr = ifa->ifa_local;\n\t__be32 prefix = ifa->ifa_address & mask;\n\n\tif (ifa->ifa_flags & IFA_F_SECONDARY) {\n\t\tprim = inet_ifa_byprefix(in_dev, prefix, mask);\n\t\tif (!prim) {\n\t\t\tpr_warn(\"%s: bug: prim == NULL\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfib_magic(RTM_NEWROUTE, RTN_LOCAL, addr, 32, prim);\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn;\n\n\t/* Add broadcast address, if it is explicitly assigned. */\n\tif (ifa->ifa_broadcast && ifa->ifa_broadcast != htonl(0xFFFFFFFF))\n\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);\n\n\tif (!ipv4_is_zeronet(prefix) && !(ifa->ifa_flags & IFA_F_SECONDARY) &&\n\t    (prefix != addr || ifa->ifa_prefixlen < 32)) {\n\t\tif (!(ifa->ifa_flags & IFA_F_NOPREFIXROUTE))\n\t\t\tfib_magic(RTM_NEWROUTE,\n\t\t\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t\t\t  prefix, ifa->ifa_prefixlen, prim);\n\n\t\t/* Add network specific broadcasts, when it takes a sense */\n\t\tif (ifa->ifa_prefixlen < 31) {\n\t\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix, 32, prim);\n\t\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix | ~mask,\n\t\t\t\t  32, prim);\n\t\t}\n\t}\n}\n\n/* Delete primary or secondary address.\n * Optionally, on secondary address promotion consider the addresses\n * from subnet iprim as deleted, even if they are in device list.\n * In this case the secondary ifa can be in device list.\n */\nvoid fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct in_ifaddr *ifa1;\n\tstruct in_ifaddr *prim = ifa, *prim1 = NULL;\n\t__be32 brd = ifa->ifa_address | ~ifa->ifa_mask;\n\t__be32 any = ifa->ifa_address & ifa->ifa_mask;\n#define LOCAL_OK\t1\n#define BRD_OK\t\t2\n#define BRD0_OK\t\t4\n#define BRD1_OK\t\t8\n\tunsigned int ok = 0;\n\tint subnet = 0;\t\t/* Primary network */\n\tint gone = 1;\t\t/* Address is missing */\n\tint same_prefsrc = 0;\t/* Another primary with same IP */\n\n\tif (ifa->ifa_flags & IFA_F_SECONDARY) {\n\t\tprim = inet_ifa_byprefix(in_dev, any, ifa->ifa_mask);\n\t\tif (!prim) {\n\t\t\tpr_warn(\"%s: bug: prim == NULL\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif (iprim && iprim != prim) {\n\t\t\tpr_warn(\"%s: bug: iprim != prim\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t} else if (!ipv4_is_zeronet(any) &&\n\t\t   (any != ifa->ifa_local || ifa->ifa_prefixlen < 32)) {\n\t\tif (!(ifa->ifa_flags & IFA_F_NOPREFIXROUTE))\n\t\t\tfib_magic(RTM_DELROUTE,\n\t\t\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t\t\t  any, ifa->ifa_prefixlen, prim);\n\t\tsubnet = 1;\n\t}\n\n\tif (in_dev->dead)\n\t\tgoto no_promotions;\n\n\t/* Deletion is more complicated than add.\n\t * We should take care of not to delete too much :-)\n\t *\n\t * Scan address list to be sure that addresses are really gone.\n\t */\n\n\tfor (ifa1 = in_dev->ifa_list; ifa1; ifa1 = ifa1->ifa_next) {\n\t\tif (ifa1 == ifa) {\n\t\t\t/* promotion, keep the IP */\n\t\t\tgone = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ignore IFAs from our subnet */\n\t\tif (iprim && ifa1->ifa_mask == iprim->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, iprim))\n\t\t\tcontinue;\n\n\t\t/* Ignore ifa1 if it uses different primary IP (prefsrc) */\n\t\tif (ifa1->ifa_flags & IFA_F_SECONDARY) {\n\t\t\t/* Another address from our subnet? */\n\t\t\tif (ifa1->ifa_mask == prim->ifa_mask &&\n\t\t\t    inet_ifa_match(ifa1->ifa_address, prim))\n\t\t\t\tprim1 = prim;\n\t\t\telse {\n\t\t\t\t/* We reached the secondaries, so\n\t\t\t\t * same_prefsrc should be determined.\n\t\t\t\t */\n\t\t\t\tif (!same_prefsrc)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Search new prim1 if ifa1 is not\n\t\t\t\t * using the current prim1\n\t\t\t\t */\n\t\t\t\tif (!prim1 ||\n\t\t\t\t    ifa1->ifa_mask != prim1->ifa_mask ||\n\t\t\t\t    !inet_ifa_match(ifa1->ifa_address, prim1))\n\t\t\t\t\tprim1 = inet_ifa_byprefix(in_dev,\n\t\t\t\t\t\t\tifa1->ifa_address,\n\t\t\t\t\t\t\tifa1->ifa_mask);\n\t\t\t\tif (!prim1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (prim1->ifa_local != prim->ifa_local)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (prim->ifa_local != ifa1->ifa_local)\n\t\t\t\tcontinue;\n\t\t\tprim1 = ifa1;\n\t\t\tif (prim != prim1)\n\t\t\t\tsame_prefsrc = 1;\n\t\t}\n\t\tif (ifa->ifa_local == ifa1->ifa_local)\n\t\t\tok |= LOCAL_OK;\n\t\tif (ifa->ifa_broadcast == ifa1->ifa_broadcast)\n\t\t\tok |= BRD_OK;\n\t\tif (brd == ifa1->ifa_broadcast)\n\t\t\tok |= BRD1_OK;\n\t\tif (any == ifa1->ifa_broadcast)\n\t\t\tok |= BRD0_OK;\n\t\t/* primary has network specific broadcasts */\n\t\tif (prim1 == ifa1 && ifa1->ifa_prefixlen < 31) {\n\t\t\t__be32 brd1 = ifa1->ifa_address | ~ifa1->ifa_mask;\n\t\t\t__be32 any1 = ifa1->ifa_address & ifa1->ifa_mask;\n\n\t\t\tif (!ipv4_is_zeronet(any1)) {\n\t\t\t\tif (ifa->ifa_broadcast == brd1 ||\n\t\t\t\t    ifa->ifa_broadcast == any1)\n\t\t\t\t\tok |= BRD_OK;\n\t\t\t\tif (brd == brd1 || brd == any1)\n\t\t\t\t\tok |= BRD1_OK;\n\t\t\t\tif (any == brd1 || any == any1)\n\t\t\t\t\tok |= BRD0_OK;\n\t\t\t}\n\t\t}\n\t}\n\nno_promotions:\n\tif (!(ok & BRD_OK))\n\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);\n\tif (subnet && ifa->ifa_prefixlen < 31) {\n\t\tif (!(ok & BRD1_OK))\n\t\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, brd, 32, prim);\n\t\tif (!(ok & BRD0_OK))\n\t\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, any, 32, prim);\n\t}\n\tif (!(ok & LOCAL_OK)) {\n\t\tunsigned int addr_type;\n\n\t\tfib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 32, prim);\n\n\t\t/* Check, that this local address finally disappeared. */\n\t\taddr_type = inet_addr_type_dev_table(dev_net(dev), dev,\n\t\t\t\t\t\t     ifa->ifa_local);\n\t\tif (gone && addr_type != RTN_LOCAL) {\n\t\t\t/* And the last, but not the least thing.\n\t\t\t * We must flush stray FIB entries.\n\t\t\t *\n\t\t\t * First of all, we scan fib_info list searching\n\t\t\t * for stray nexthop entries, then ignite fib_flush.\n\t\t\t */\n\t\t\tif (fib_sync_down_addr(dev_net(dev), ifa->ifa_local))\n\t\t\t\tfib_flush(dev_net(dev));\n\t\t}\n\t}\n#undef LOCAL_OK\n#undef BRD_OK\n#undef BRD0_OK\n#undef BRD1_OK\n}\n\nstatic void nl_fib_lookup(struct net *net, struct fib_result_nl *frn)\n{\n\n\tstruct fib_result       res;\n\tstruct flowi4           fl4 = {\n\t\t.flowi4_mark = frn->fl_mark,\n\t\t.daddr = frn->fl_addr,\n\t\t.flowi4_tos = frn->fl_tos,\n\t\t.flowi4_scope = frn->fl_scope,\n\t};\n\tstruct fib_table *tb;\n\n\trcu_read_lock();\n\n\ttb = fib_get_table(net, frn->tb_id_in);\n\n\tfrn->err = -ENOENT;\n\tif (tb) {\n\t\tlocal_bh_disable();\n\n\t\tfrn->tb_id = tb->tb_id;\n\t\tfrn->err = fib_table_lookup(tb, &fl4, &res, FIB_LOOKUP_NOREF);\n\n\t\tif (!frn->err) {\n\t\t\tfrn->prefixlen = res.prefixlen;\n\t\t\tfrn->nh_sel = res.nh_sel;\n\t\t\tfrn->type = res.type;\n\t\t\tfrn->scope = res.scope;\n\t\t}\n\t\tlocal_bh_enable();\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void nl_fib_input(struct sk_buff *skb)\n{\n\tstruct net *net;\n\tstruct fib_result_nl *frn;\n\tstruct nlmsghdr *nlh;\n\tu32 portid;\n\n\tnet = sock_net(skb->sk);\n\tnlh = nlmsg_hdr(skb);\n\tif (skb->len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len ||\n\t    nlmsg_len(nlh) < sizeof(*frn))\n\t\treturn;\n\n\tskb = netlink_skb_clone(skb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\tnlh = nlmsg_hdr(skb);\n\n\tfrn = (struct fib_result_nl *) nlmsg_data(nlh);\n\tnl_fib_lookup(net, frn);\n\n\tportid = NETLINK_CB(skb).portid;      /* netlink portid */\n\tNETLINK_CB(skb).portid = 0;        /* from kernel */\n\tNETLINK_CB(skb).dst_group = 0;  /* unicast */\n\tnetlink_unicast(net->ipv4.fibnl, skb, portid, MSG_DONTWAIT);\n}\n\nstatic int __net_init nl_fib_lookup_init(struct net *net)\n{\n\tstruct sock *sk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= nl_fib_input,\n\t};\n\n\tsk = netlink_kernel_create(net, NETLINK_FIB_LOOKUP, &cfg);\n\tif (!sk)\n\t\treturn -EAFNOSUPPORT;\n\tnet->ipv4.fibnl = sk;\n\treturn 0;\n}\n\nstatic void nl_fib_lookup_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->ipv4.fibnl);\n\tnet->ipv4.fibnl = NULL;\n}\n\nstatic void fib_disable_ip(struct net_device *dev, unsigned long event,\n\t\t\t   bool force)\n{\n\tif (fib_sync_down_dev(dev, event, force))\n\t\tfib_flush(dev_net(dev));\n\trt_cache_flush(dev_net(dev));\n\tarp_ifdown(dev);\n}\n\nstatic int fib_inetaddr_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct net *net = dev_net(dev);\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tfib_add_ifaddr(ifa);\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t\tfib_sync_up(dev, RTNH_F_DEAD);\n#endif\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\trt_cache_flush(dev_net(dev));\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tfib_del_ifaddr(ifa, NULL);\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\tif (!ifa->ifa_dev->ifa_list) {\n\t\t\t/* Last address was deleted from this interface.\n\t\t\t * Disable IP.\n\t\t\t */\n\t\t\tfib_disable_ip(dev, event, true);\n\t\t} else {\n\t\t\trt_cache_flush(dev_net(dev));\n\t\t}\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic int fib_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info;\n\tstruct in_device *in_dev;\n\tstruct net *net = dev_net(dev);\n\tunsigned int flags;\n\n\tif (event == NETDEV_UNREGISTER) {\n\t\tfib_disable_ip(dev, event, true);\n\t\trt_flush_dev(dev);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\tif (!in_dev)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tfor_ifa(in_dev) {\n\t\t\tfib_add_ifaddr(ifa);\n\t\t} endfor_ifa(in_dev);\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t\tfib_sync_up(dev, RTNH_F_DEAD);\n#endif\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\trt_cache_flush(net);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tfib_disable_ip(dev, event, false);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tflags = dev_get_flags(dev);\n\t\tif (flags & (IFF_RUNNING | IFF_LOWER_UP))\n\t\t\tfib_sync_up(dev, RTNH_F_LINKDOWN);\n\t\telse\n\t\t\tfib_sync_down_dev(dev, event, false);\n\t\t/* fall through */\n\tcase NETDEV_CHANGEMTU:\n\t\trt_cache_flush(net);\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tinfo = ptr;\n\t\t/* flush all routes if dev is linked to or unlinked from\n\t\t * an L3 master device (e.g., VRF)\n\t\t */\n\t\tif (info->upper_dev && netif_is_l3_master(info->upper_dev))\n\t\t\tfib_disable_ip(dev, NETDEV_DOWN, true);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block fib_inetaddr_notifier = {\n\t.notifier_call = fib_inetaddr_event,\n};\n\nstatic struct notifier_block fib_netdev_notifier = {\n\t.notifier_call = fib_netdev_event,\n};\n\nstatic int __net_init ip_fib_net_init(struct net *net)\n{\n\tint err;\n\tsize_t size = sizeof(struct hlist_head) * FIB_TABLE_HASHSZ;\n\n\t/* Avoid false sharing : Use at least a full cache line */\n\tsize = max_t(size_t, size, L1_CACHE_BYTES);\n\n\tnet->ipv4.fib_table_hash = kzalloc(size, GFP_KERNEL);\n\tif (!net->ipv4.fib_table_hash)\n\t\treturn -ENOMEM;\n\n\terr = fib4_rules_init(net);\n\tif (err < 0)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tkfree(net->ipv4.fib_table_hash);\n\treturn err;\n}\n\nstatic void ip_fib_net_exit(struct net *net)\n{\n\tunsigned int i;\n\n\trtnl_lock();\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tRCU_INIT_POINTER(net->ipv4.fib_local, NULL);\n\tRCU_INIT_POINTER(net->ipv4.fib_main, NULL);\n\tRCU_INIT_POINTER(net->ipv4.fib_default, NULL);\n#endif\n\tfor (i = 0; i < FIB_TABLE_HASHSZ; i++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[i];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb_hlist) {\n\t\t\thlist_del(&tb->tb_hlist);\n\t\t\tfib_table_flush(tb);\n\t\t\tfib_free_table(tb);\n\t\t}\n\t}\n\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tfib4_rules_exit(net);\n#endif\n\trtnl_unlock();\n\tkfree(net->ipv4.fib_table_hash);\n}\n\nstatic int __net_init fib_net_init(struct net *net)\n{\n\tint error;\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tnet->ipv4.fib_num_tclassid_users = 0;\n#endif\n\terror = ip_fib_net_init(net);\n\tif (error < 0)\n\t\tgoto out;\n\terror = nl_fib_lookup_init(net);\n\tif (error < 0)\n\t\tgoto out_nlfl;\n\terror = fib_proc_init(net);\n\tif (error < 0)\n\t\tgoto out_proc;\nout:\n\treturn error;\n\nout_proc:\n\tnl_fib_lookup_exit(net);\nout_nlfl:\n\tip_fib_net_exit(net);\n\tgoto out;\n}\n\nstatic void __net_exit fib_net_exit(struct net *net)\n{\n\tfib_proc_exit(net);\n\tnl_fib_lookup_exit(net);\n\tip_fib_net_exit(net);\n}\n\nstatic struct pernet_operations fib_net_ops = {\n\t.init = fib_net_init,\n\t.exit = fib_net_exit,\n};\n\nvoid __init ip_fib_init(void)\n{\n\trtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);\n\trtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);\n\trtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);\n\n\tregister_pernet_subsys(&fib_net_ops);\n\tregister_netdevice_notifier(&fib_netdev_notifier);\n\tregister_inetaddr_notifier(&fib_inetaddr_notifier);\n\n\tfib_trie_init();\n}\n", "/* (C) 1999-2001 Paul `Rusty' Russell\n * (C) 2002-2006 Netfilter Core Team <coreteam@netfilter.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/inetdevice.h>\n#include <linux/ip.h>\n#include <linux/timer.h>\n#include <linux/netfilter.h>\n#include <net/protocol.h>\n#include <net/ip.h>\n#include <net/checksum.h>\n#include <net/route.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter/x_tables.h>\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/ipv4/nf_nat_masquerade.h>\n\nunsigned int\nnf_nat_masquerade_ipv4(struct sk_buff *skb, unsigned int hooknum,\n\t\t       const struct nf_nat_range *range,\n\t\t       const struct net_device *out)\n{\n\tstruct nf_conn *ct;\n\tstruct nf_conn_nat *nat;\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_nat_range newrange;\n\tconst struct rtable *rt;\n\t__be32 newsrc, nh;\n\n\tNF_CT_ASSERT(hooknum == NF_INET_POST_ROUTING);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tnat = nfct_nat(ct);\n\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\n\t\t\t    ctinfo == IP_CT_RELATED_REPLY));\n\n\t/* Source address is 0.0.0.0 - locally generated packet that is\n\t * probably not supposed to be masqueraded.\n\t */\n\tif (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip == 0)\n\t\treturn NF_ACCEPT;\n\n\trt = skb_rtable(skb);\n\tnh = rt_nexthop(rt, ip_hdr(skb)->daddr);\n\tnewsrc = inet_select_addr(out, nh, RT_SCOPE_UNIVERSE);\n\tif (!newsrc) {\n\t\tpr_info(\"%s ate my IP address\\n\", out->name);\n\t\treturn NF_DROP;\n\t}\n\n\tnat->masq_index = out->ifindex;\n\n\t/* Transfer from original range. */\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags       = range->flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newsrc;\n\tnewrange.max_addr.ip = newsrc;\n\tnewrange.min_proto   = range->min_proto;\n\tnewrange.max_proto   = range->max_proto;\n\n\t/* Hand modified range to generic setup. */\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_SRC);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4);\n\nstatic int device_cmp(struct nf_conn *i, void *ifindex)\n{\n\tconst struct nf_conn_nat *nat = nfct_nat(i);\n\n\tif (!nat)\n\t\treturn 0;\n\tif (nf_ct_l3num(i) != NFPROTO_IPV4)\n\t\treturn 0;\n\treturn nat->masq_index == (int)(long)ifindex;\n}\n\nstatic int masq_device_event(struct notifier_block *this,\n\t\t\t     unsigned long event,\n\t\t\t     void *ptr)\n{\n\tconst struct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\n\tif (event == NETDEV_DOWN) {\n\t\t/* Device was downed.  Search entire table for\n\t\t * conntracks which were associated with that device,\n\t\t * and forget them.\n\t\t */\n\t\tNF_CT_ASSERT(dev->ifindex != 0);\n\n\t\tnf_ct_iterate_cleanup(net, device_cmp,\n\t\t\t\t      (void *)(long)dev->ifindex, 0, 0);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;\n\tstruct netdev_notifier_info info;\n\n\t/* The masq_dev_notifier will catch the case of the device going\n\t * down.  So if the inetdev is dead and being destroyed we have\n\t * no work to do.  Otherwise this is an individual address removal\n\t * and we have to perform the flush.\n\t */\n\tif (idev->dead)\n\t\treturn NOTIFY_DONE;\n\n\tnetdev_notifier_info_init(&info, idev->dev);\n\treturn masq_device_event(this, event, &info);\n}\n\nstatic struct notifier_block masq_dev_notifier = {\n\t.notifier_call\t= masq_device_event,\n};\n\nstatic struct notifier_block masq_inet_notifier = {\n\t.notifier_call\t= masq_inet_event,\n};\n\nstatic atomic_t masquerade_notifier_refcount = ATOMIC_INIT(0);\n\nvoid nf_nat_masquerade_ipv4_register_notifier(void)\n{\n\t/* check if the notifier was already set */\n\tif (atomic_inc_return(&masquerade_notifier_refcount) > 1)\n\t\treturn;\n\n\t/* Register for device down reports */\n\tregister_netdevice_notifier(&masq_dev_notifier);\n\t/* Register IP address change reports */\n\tregister_inetaddr_notifier(&masq_inet_notifier);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4_register_notifier);\n\nvoid nf_nat_masquerade_ipv4_unregister_notifier(void)\n{\n\t/* check if the notifier still has clients */\n\tif (atomic_dec_return(&masquerade_notifier_refcount) > 0)\n\t\treturn;\n\n\tunregister_netdevice_notifier(&masq_dev_notifier);\n\tunregister_inetaddr_notifier(&masq_inet_notifier);\n}\nEXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4_unregister_notifier);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Rusty Russell <rusty@rustcorp.com.au>\");\n"], "filenames": ["net/ipv4/devinet.c", "net/ipv4/fib_frontend.c", "net/ipv4/netfilter/nf_nat_masquerade_ipv4.c"], "buggy_code_start_loc": [336, 924, 111], "buggy_code_end_loc": [382, 999, 115], "fixing_code_start_loc": [337, 925, 111], "fixing_code_end_loc": [387, 1004, 123], "type": "CWE-399", "message": "The IPv4 implementation in the Linux kernel before 4.5.2 mishandles destruction of device objects, which allows guest OS users to cause a denial of service (host OS networking outage) by arranging for a large number of IP addresses.", "other": {"cve": {"id": "CVE-2016-3156", "sourceIdentifier": "cve@mitre.org", "published": "2016-04-27T17:59:26.430", "lastModified": "2018-01-05T02:30:41.353", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The IPv4 implementation in the Linux kernel before 4.5.2 mishandles destruction of device objects, which allows guest OS users to cause a denial of service (host OS networking outage) by arranging for a large number of IP addresses."}, {"lang": "es", "value": "La implementaci\u00f3n IPv4 en el kernel de Linux en versiones anteriores a 4.5.2 no maneja adecuadamente la destrucci\u00f3n de objetos de dispositivo, lo que permite a usuarios del SO invitado provocar una denegaci\u00f3n de servicio (corte de la red del sistema operativo anfitri\u00f3n) disponiendo un gran n\u00famero de direcciones IP."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_debuginfo:11.0:sp4:*:*:*:*:*:*", "matchCriteriaId": "E090E7B3-2346-463D-8A0C-8B482500CB42"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_desktop:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "EA04C9F1-6257-4D82-BA0B-37DE66D94736"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_live_patching:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "CCAAE4A1-D542-43F3-B7FC-685BCDB248D5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_module_for_public_cloud:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "A961CBC6-3CA1-4A0F-BBE0-8F6315781B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_real_time_extension:11.0:sp4:*:*:*:*:*:*", "matchCriteriaId": "5BFCA0A7-8EB8-4C6F-9039-2B6A224080D3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_real_time_extension:12.0:sp1:*:*:*:*:*:*", "matchCriteriaId": "B2905A9C-3E00-4188-8341-E5C2F62EF405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:11.0:extra:*:*:*:*:*:*", "matchCriteriaId": "A8877923-3E50-4F71-B501-E6997894D07E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:11.0:sp4:*:*:*:*:*:*", "matchCriteriaId": "ADE9D807-6690-4D67-A6B3-68BBC9B50153"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "C384D0B6-8A5C-45CA-8CD9-7F4E967FE4F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_software_development_kit:11.0:sp4:*:*:*:*:*:*", "matchCriteriaId": "F1E42F04-5E14-4CF6-BD26-C54A4ECD99CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_software_development_kit:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "E85AFCCA-8B55-4F7C-A282-691CCA624D79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_workstation_extension:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "DF461FB4-8BA5-4065-9A69-DC017D3611C3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.1", "matchCriteriaId": "6498A032-754F-41B0-A8C8-4EBB71ABEEE2"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=fbd40ea0180a2d328c5adc61414dc8bab9335ce2", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00019.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-05/msg00060.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00052.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00054.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00059.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-07/msg00005.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2574.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2584.html", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2016/dsa-3607", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/03/15/3", "source": "cve@mitre.org"}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html", "source": "cve@mitre.org"}, {"url": "http://www.oracle.com/technetwork/topics/security/ovmbulletinoct2016-3090547.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/84428", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2968-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2968-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2969-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2970-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2971-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2971-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2971-3", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2996-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2997-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1318172", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2"}}