{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Cliprdr common\n *\n * Copyright 2013 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2019 Kobi Mizrachi <kmizrachi18@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <winpr/crt.h>\n#include <winpr/stream.h>\n#include <freerdp/channels/log.h>\n\n#define TAG CHANNELS_TAG(\"cliprdr.common\")\n\n#include \"cliprdr_common.h\"\n\nstatic BOOL cliprdr_validate_file_contents_request(const CLIPRDR_FILE_CONTENTS_REQUEST* request)\n{\n\t/*\n\t * [MS-RDPECLIP] 2.2.5.3 File Contents Request PDU (CLIPRDR_FILECONTENTS_REQUEST).\n\t *\n\t * A request for the size of the file identified by the lindex field. The size MUST be\n\t * returned as a 64-bit, unsigned integer. The cbRequested field MUST be set to\n\t * 0x00000008 and both the nPositionLow and nPositionHigh fields MUST be\n\t * set to 0x00000000.\n\t */\n\n\tif (request->dwFlags & FILECONTENTS_SIZE)\n\t{\n\t\tif (request->cbRequested != sizeof(UINT64))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"[%s]: cbRequested must be %\" PRIu32 \", got %\" PRIu32 \"\", __FUNCTION__,\n\t\t\t         sizeof(UINT64), request->cbRequested);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (request->nPositionHigh != 0 || request->nPositionLow != 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"[%s]: nPositionHigh and nPositionLow must be set to 0\", __FUNCTION__);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nwStream* cliprdr_packet_new(UINT16 msgType, UINT16 msgFlags, UINT32 dataLen)\n{\n\twStream* s;\n\ts = Stream_New(NULL, dataLen + 8);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn NULL;\n\t}\n\n\tStream_Write_UINT16(s, msgType);\n\tStream_Write_UINT16(s, msgFlags);\n\t/* Write actual length after the entire packet has been constructed. */\n\tStream_Seek(s, 4);\n\treturn s;\n}\n\nstatic void cliprdr_write_file_contents_request(wStream* s,\n                                                const CLIPRDR_FILE_CONTENTS_REQUEST* request)\n{\n\tStream_Write_UINT32(s, request->streamId);      /* streamId (4 bytes) */\n\tStream_Write_UINT32(s, request->listIndex);     /* listIndex (4 bytes) */\n\tStream_Write_UINT32(s, request->dwFlags);       /* dwFlags (4 bytes) */\n\tStream_Write_UINT32(s, request->nPositionLow);  /* nPositionLow (4 bytes) */\n\tStream_Write_UINT32(s, request->nPositionHigh); /* nPositionHigh (4 bytes) */\n\tStream_Write_UINT32(s, request->cbRequested);   /* cbRequested (4 bytes) */\n\n\tif (request->haveClipDataId)\n\t\tStream_Write_UINT32(s, request->clipDataId); /* clipDataId (4 bytes) */\n}\n\nstatic INLINE void cliprdr_write_lock_unlock_clipdata(wStream* s, UINT32 clipDataId)\n{\n\tStream_Write_UINT32(s, clipDataId);\n}\n\nstatic void cliprdr_write_lock_clipdata(wStream* s,\n                                        const CLIPRDR_LOCK_CLIPBOARD_DATA* lockClipboardData)\n{\n\tcliprdr_write_lock_unlock_clipdata(s, lockClipboardData->clipDataId);\n}\n\nstatic void cliprdr_write_unlock_clipdata(wStream* s,\n                                          const CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)\n{\n\tcliprdr_write_lock_unlock_clipdata(s, unlockClipboardData->clipDataId);\n}\n\nstatic void cliprdr_write_file_contents_response(wStream* s,\n                                                 const CLIPRDR_FILE_CONTENTS_RESPONSE* response)\n{\n\tStream_Write_UINT32(s, response->streamId); /* streamId (4 bytes) */\n\tStream_Write(s, response->requestedData, response->cbRequested);\n}\n\nwStream* cliprdr_packet_lock_clipdata_new(const CLIPRDR_LOCK_CLIPBOARD_DATA* lockClipboardData)\n{\n\twStream* s;\n\n\tif (!lockClipboardData)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_LOCK_CLIPDATA, 0, 4);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_lock_clipdata(s, lockClipboardData);\n\treturn s;\n}\n\nwStream*\ncliprdr_packet_unlock_clipdata_new(const CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)\n{\n\twStream* s;\n\n\tif (!unlockClipboardData)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_LOCK_CLIPDATA, 0, 4);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_unlock_clipdata(s, unlockClipboardData);\n\treturn s;\n}\n\nwStream* cliprdr_packet_file_contents_request_new(const CLIPRDR_FILE_CONTENTS_REQUEST* request)\n{\n\twStream* s;\n\n\tif (!request)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_FILECONTENTS_REQUEST, 0, 28);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_file_contents_request(s, request);\n\treturn s;\n}\n\nwStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)\n{\n\twStream* s;\n\n\tif (!response)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_file_contents_response(s, response);\n\treturn s;\n}\n\nwStream* cliprdr_packet_format_list_new(const CLIPRDR_FORMAT_LIST* formatList,\n                                        BOOL useLongFormatNames)\n{\n\twStream* s;\n\tUINT32 index;\n\tint cchWideChar;\n\tLPWSTR lpWideCharStr;\n\tint formatNameSize;\n\tchar* szFormatName;\n\tWCHAR* wszFormatName;\n\tBOOL asciiNames = FALSE;\n\tCLIPRDR_FORMAT* format;\n\n\tif (formatList->msgType != CB_FORMAT_LIST)\n\t\tWLog_WARN(TAG, \"[%s] called with invalid type %08\" PRIx32, __FUNCTION__,\n\t\t          formatList->msgType);\n\n\tif (!useLongFormatNames)\n\t{\n\t\tUINT32 length = formatList->numFormats * 36;\n\t\ts = cliprdr_packet_new(CB_FORMAT_LIST, 0, length);\n\n\t\tif (!s)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"cliprdr_packet_new failed!\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tsize_t formatNameLength = 0;\n\t\t\tformat = (CLIPRDR_FORMAT*)&(formatList->formats[index]);\n\t\t\tStream_Write_UINT32(s, format->formatId); /* formatId (4 bytes) */\n\t\t\tformatNameSize = 0;\n\n\t\t\tszFormatName = format->formatName;\n\n\t\t\tif (asciiNames)\n\t\t\t{\n\t\t\t\tif (szFormatName)\n\t\t\t\t\tformatNameLength = strnlen(szFormatName, 32);\n\n\t\t\t\tif (formatNameLength > 31)\n\t\t\t\t\tformatNameLength = 31;\n\n\t\t\t\tStream_Write(s, szFormatName, formatNameLength);\n\t\t\t\tStream_Zero(s, 32 - formatNameLength);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twszFormatName = NULL;\n\n\t\t\t\tif (szFormatName)\n\t\t\t\t\tformatNameSize =\n\t\t\t\t\t    ConvertToUnicode(CP_UTF8, 0, szFormatName, -1, &wszFormatName, 0);\n\n\t\t\t\tif (formatNameSize < 0)\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tif (formatNameSize > 15)\n\t\t\t\t\tformatNameSize = 15;\n\n\t\t\t\t/* size in bytes  instead of wchar */\n\t\t\t\tformatNameSize *= 2;\n\n\t\t\t\tif (wszFormatName)\n\t\t\t\t\tStream_Write(s, wszFormatName, (size_t)formatNameSize);\n\n\t\t\t\tStream_Zero(s, (size_t)(32 - formatNameSize));\n\t\t\t\tfree(wszFormatName);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tUINT32 length = 0;\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tformat = (CLIPRDR_FORMAT*)&(formatList->formats[index]);\n\t\t\tlength += 4;\n\t\t\tformatNameSize = 2;\n\n\t\t\tif (format->formatName)\n\t\t\t\tformatNameSize =\n\t\t\t\t    MultiByteToWideChar(CP_UTF8, 0, format->formatName, -1, NULL, 0) * 2;\n\n\t\t\tif (formatNameSize < 0)\n\t\t\t\treturn NULL;\n\n\t\t\tlength += (UINT32)formatNameSize;\n\t\t}\n\n\t\ts = cliprdr_packet_new(CB_FORMAT_LIST, 0, length);\n\n\t\tif (!s)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"cliprdr_packet_new failed!\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tformat = (CLIPRDR_FORMAT*)&(formatList->formats[index]);\n\t\t\tStream_Write_UINT32(s, format->formatId); /* formatId (4 bytes) */\n\n\t\t\tif (format->formatName)\n\t\t\t{\n\t\t\t\tconst size_t cap = Stream_Capacity(s);\n\t\t\t\tconst size_t pos = Stream_GetPosition(s);\n\t\t\t\tconst size_t rem = cap - pos;\n\t\t\t\tif ((cap < pos) || ((rem / 2) > INT_MAX))\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tlpWideCharStr = (LPWSTR)Stream_Pointer(s);\n\t\t\t\tcchWideChar = (int)(rem / 2);\n\t\t\t\tformatNameSize = MultiByteToWideChar(CP_UTF8, 0, format->formatName, -1,\n\t\t\t\t                                     lpWideCharStr, cchWideChar) *\n\t\t\t\t                 2;\n\t\t\t\tif (formatNameSize < 0)\n\t\t\t\t\treturn NULL;\n\t\t\t\tStream_Seek(s, (size_t)formatNameSize);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStream_Write_UINT16(s, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s;\n}\nUINT cliprdr_read_unlock_clipdata(wStream* s, CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tWLog_ERR(TAG, \"not enough remaining data\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tStream_Read_UINT32(s, unlockClipboardData->clipDataId); /* clipDataId (4 bytes) */\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_format_data_request(wStream* s, CLIPRDR_FORMAT_DATA_REQUEST* request)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data in stream!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tStream_Read_UINT32(s, request->requestedFormatId); /* requestedFormatId (4 bytes) */\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_format_data_response(wStream* s, CLIPRDR_FORMAT_DATA_RESPONSE* response)\n{\n\tresponse->requestedFormatData = NULL;\n\n\tif (Stream_GetRemainingLength(s) < response->dataLen)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data in stream!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tif (response->dataLen)\n\t\tresponse->requestedFormatData = Stream_Pointer(s);\n\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_file_contents_request(wStream* s, CLIPRDR_FILE_CONTENTS_REQUEST* request)\n{\n\tif (Stream_GetRemainingLength(s) < 24)\n\t{\n\t\tWLog_ERR(TAG, \"not enough remaining data\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\trequest->haveClipDataId = FALSE;\n\tStream_Read_UINT32(s, request->streamId);      /* streamId (4 bytes) */\n\tStream_Read_UINT32(s, request->listIndex);     /* listIndex (4 bytes) */\n\tStream_Read_UINT32(s, request->dwFlags);       /* dwFlags (4 bytes) */\n\tStream_Read_UINT32(s, request->nPositionLow);  /* nPositionLow (4 bytes) */\n\tStream_Read_UINT32(s, request->nPositionHigh); /* nPositionHigh (4 bytes) */\n\tStream_Read_UINT32(s, request->cbRequested);   /* cbRequested (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) >= 4)\n\t{\n\t\tStream_Read_UINT32(s, request->clipDataId); /* clipDataId (4 bytes) */\n\t\trequest->haveClipDataId = TRUE;\n\t}\n\n\tif (!cliprdr_validate_file_contents_request(request))\n\t\treturn ERROR_BAD_ARGUMENTS;\n\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_file_contents_response(wStream* s, CLIPRDR_FILE_CONTENTS_RESPONSE* response)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tWLog_ERR(TAG, \"not enough remaining data\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tStream_Read_UINT32(s, response->streamId);   /* streamId (4 bytes) */\n\tresponse->requestedData = Stream_Pointer(s); /* requestedFileContentsData */\n\tresponse->cbRequested = response->dataLen - 4;\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_format_list(wStream* s, CLIPRDR_FORMAT_LIST* formatList, BOOL useLongFormatNames)\n{\n\tUINT32 index;\n\tsize_t position;\n\tBOOL asciiNames;\n\tint formatNameLength;\n\tchar* szFormatName;\n\tWCHAR* wszFormatName;\n\tUINT32 dataLen = formatList->dataLen;\n\tCLIPRDR_FORMAT* formats = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\n\tasciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;\n\n\tindex = 0;\n\tformatList->numFormats = 0;\n\tposition = Stream_GetPosition(s);\n\n\tif (!formatList->dataLen)\n\t{\n\t\t/* empty format list */\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n\t}\n\telse if (!useLongFormatNames)\n\t{\n\t\tformatList->numFormats = (dataLen / 36);\n\n\t\tif ((formatList->numFormats * 36) != dataLen)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Invalid short format list length: %\" PRIu32 \"\", dataLen);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tif (formatList->numFormats)\n\t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tformatList->formats = formats;\n\n\t\twhile (dataLen)\n\t\t{\n\t\t\tStream_Read_UINT32(s, formats[index].formatId); /* formatId (4 bytes) */\n\t\t\tdataLen -= 4;\n\n\t\t\tformats[index].formatName = NULL;\n\n\t\t\t/* According to MS-RDPECLIP 2.2.3.1.1.1 formatName is \"a 32-byte block containing\n\t\t\t * the *null-terminated* name assigned to the Clipboard Format: (32 ASCII 8 characters\n\t\t\t * or 16 Unicode characters)\"\n\t\t\t * However, both Windows RDSH and mstsc violate this specs as seen in the following\n\t\t\t * example of a transferred short format name string: [R.i.c.h. .T.e.x.t. .F.o.r.m.a.t.]\n\t\t\t * These are 16 unicode charaters - *without* terminating null !\n\t\t\t */\n\n\t\t\tif (asciiNames)\n\t\t\t{\n\t\t\t\tszFormatName = (char*)Stream_Pointer(s);\n\n\t\t\t\tif (szFormatName[0])\n\t\t\t\t{\n\t\t\t\t\t/* ensure null termination */\n\t\t\t\t\tformats[index].formatName = (char*)malloc(32 + 1);\n\t\t\t\t\tif (!formats[index].formatName)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\t\t\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t\tCopyMemory(formats[index].formatName, szFormatName, 32);\n\t\t\t\t\tformats[index].formatName[32] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n\n\t\t\t\tif (wszFormatName[0])\n\t\t\t\t{\n\t\t\t\t\t/* ConvertFromUnicode always returns a null-terminated\n\t\t\t\t\t * string on success, even if the source string isn't.\n\t\t\t\t\t */\n\t\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, 16,\n\t\t\t\t\t                       &(formats[index].formatName), 0, NULL, NULL) < 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"failed to convert short clipboard format name\");\n\t\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStream_Seek(s, 32);\n\t\t\tdataLen -= 32;\n\t\t\tindex++;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (dataLen)\n\t\t{\n\t\t\tStream_Seek(s, 4); /* formatId (4 bytes) */\n\t\t\tdataLen -= 4;\n\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n\n\t\t\tif (!wszFormatName[0])\n\t\t\t\tformatNameLength = 0;\n\t\t\telse\n\t\t\t\tformatNameLength = _wcslen(wszFormatName);\n\n\t\t\tStream_Seek(s, (formatNameLength + 1) * 2);\n\t\t\tdataLen -= ((formatNameLength + 1) * 2);\n\n\t\t\tformatList->numFormats++;\n\t\t}\n\n\t\tdataLen = formatList->dataLen;\n\t\tStream_SetPosition(s, position);\n\n\t\tif (formatList->numFormats)\n\t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tformatList->formats = formats;\n\n\t\twhile (dataLen)\n\t\t{\n\t\t\tStream_Read_UINT32(s, formats[index].formatId); /* formatId (4 bytes) */\n\t\t\tdataLen -= 4;\n\n\t\t\tformats[index].formatName = NULL;\n\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n\n\t\t\tif (!wszFormatName[0])\n\t\t\t\tformatNameLength = 0;\n\t\t\telse\n\t\t\t\tformatNameLength = _wcslen(wszFormatName);\n\n\t\t\tif (formatNameLength)\n\t\t\t{\n\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, -1, &(formats[index].formatName),\n\t\t\t\t                       0, NULL, NULL) < 1)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"failed to convert long clipboard format name\");\n\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStream_Seek(s, (formatNameLength + 1) * 2);\n\t\t\tdataLen -= ((formatNameLength + 1) * 2);\n\n\t\t\tindex++;\n\t\t}\n\t}\n\n\treturn error;\n\nerror_out:\n\tcliprdr_free_format_list(formatList);\n\treturn error;\n}\n\nvoid cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList)\n{\n\tUINT index = 0;\n\n\tif (formatList == NULL)\n\t\treturn;\n\n\tif (formatList->formats)\n\t{\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tfree(formatList->formats[index].formatName);\n\t\t}\n\n\t\tfree(formatList->formats);\n\t}\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Cliprdr common\n *\n * Copyright 2013 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n * Copyright 2019 Kobi Mizrachi <kmizrachi18@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <winpr/crt.h>\n#include <winpr/stream.h>\n#include <freerdp/channels/log.h>\n\n#define TAG CHANNELS_TAG(\"cliprdr.common\")\n\n#include \"cliprdr_common.h\"\n\nstatic BOOL cliprdr_validate_file_contents_request(const CLIPRDR_FILE_CONTENTS_REQUEST* request)\n{\n\t/*\n\t * [MS-RDPECLIP] 2.2.5.3 File Contents Request PDU (CLIPRDR_FILECONTENTS_REQUEST).\n\t *\n\t * A request for the size of the file identified by the lindex field. The size MUST be\n\t * returned as a 64-bit, unsigned integer. The cbRequested field MUST be set to\n\t * 0x00000008 and both the nPositionLow and nPositionHigh fields MUST be\n\t * set to 0x00000000.\n\t */\n\n\tif (request->dwFlags & FILECONTENTS_SIZE)\n\t{\n\t\tif (request->cbRequested != sizeof(UINT64))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"[%s]: cbRequested must be %\" PRIu32 \", got %\" PRIu32 \"\", __FUNCTION__,\n\t\t\t         sizeof(UINT64), request->cbRequested);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (request->nPositionHigh != 0 || request->nPositionLow != 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"[%s]: nPositionHigh and nPositionLow must be set to 0\", __FUNCTION__);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nwStream* cliprdr_packet_new(UINT16 msgType, UINT16 msgFlags, UINT32 dataLen)\n{\n\twStream* s;\n\ts = Stream_New(NULL, dataLen + 8);\n\n\tif (!s)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_New failed!\");\n\t\treturn NULL;\n\t}\n\n\tStream_Write_UINT16(s, msgType);\n\tStream_Write_UINT16(s, msgFlags);\n\t/* Write actual length after the entire packet has been constructed. */\n\tStream_Seek(s, 4);\n\treturn s;\n}\n\nstatic void cliprdr_write_file_contents_request(wStream* s,\n                                                const CLIPRDR_FILE_CONTENTS_REQUEST* request)\n{\n\tStream_Write_UINT32(s, request->streamId);      /* streamId (4 bytes) */\n\tStream_Write_UINT32(s, request->listIndex);     /* listIndex (4 bytes) */\n\tStream_Write_UINT32(s, request->dwFlags);       /* dwFlags (4 bytes) */\n\tStream_Write_UINT32(s, request->nPositionLow);  /* nPositionLow (4 bytes) */\n\tStream_Write_UINT32(s, request->nPositionHigh); /* nPositionHigh (4 bytes) */\n\tStream_Write_UINT32(s, request->cbRequested);   /* cbRequested (4 bytes) */\n\n\tif (request->haveClipDataId)\n\t\tStream_Write_UINT32(s, request->clipDataId); /* clipDataId (4 bytes) */\n}\n\nstatic INLINE void cliprdr_write_lock_unlock_clipdata(wStream* s, UINT32 clipDataId)\n{\n\tStream_Write_UINT32(s, clipDataId);\n}\n\nstatic void cliprdr_write_lock_clipdata(wStream* s,\n                                        const CLIPRDR_LOCK_CLIPBOARD_DATA* lockClipboardData)\n{\n\tcliprdr_write_lock_unlock_clipdata(s, lockClipboardData->clipDataId);\n}\n\nstatic void cliprdr_write_unlock_clipdata(wStream* s,\n                                          const CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)\n{\n\tcliprdr_write_lock_unlock_clipdata(s, unlockClipboardData->clipDataId);\n}\n\nstatic void cliprdr_write_file_contents_response(wStream* s,\n                                                 const CLIPRDR_FILE_CONTENTS_RESPONSE* response)\n{\n\tStream_Write_UINT32(s, response->streamId); /* streamId (4 bytes) */\n\tStream_Write(s, response->requestedData, response->cbRequested);\n}\n\nwStream* cliprdr_packet_lock_clipdata_new(const CLIPRDR_LOCK_CLIPBOARD_DATA* lockClipboardData)\n{\n\twStream* s;\n\n\tif (!lockClipboardData)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_LOCK_CLIPDATA, 0, 4);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_lock_clipdata(s, lockClipboardData);\n\treturn s;\n}\n\nwStream*\ncliprdr_packet_unlock_clipdata_new(const CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)\n{\n\twStream* s;\n\n\tif (!unlockClipboardData)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_LOCK_CLIPDATA, 0, 4);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_unlock_clipdata(s, unlockClipboardData);\n\treturn s;\n}\n\nwStream* cliprdr_packet_file_contents_request_new(const CLIPRDR_FILE_CONTENTS_REQUEST* request)\n{\n\twStream* s;\n\n\tif (!request)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_FILECONTENTS_REQUEST, 0, 28);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_file_contents_request(s, request);\n\treturn s;\n}\n\nwStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)\n{\n\twStream* s;\n\n\tif (!response)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_file_contents_response(s, response);\n\treturn s;\n}\n\nwStream* cliprdr_packet_format_list_new(const CLIPRDR_FORMAT_LIST* formatList,\n                                        BOOL useLongFormatNames)\n{\n\twStream* s;\n\tUINT32 index;\n\tint cchWideChar;\n\tLPWSTR lpWideCharStr;\n\tint formatNameSize;\n\tchar* szFormatName;\n\tWCHAR* wszFormatName;\n\tBOOL asciiNames = FALSE;\n\tCLIPRDR_FORMAT* format;\n\n\tif (formatList->msgType != CB_FORMAT_LIST)\n\t\tWLog_WARN(TAG, \"[%s] called with invalid type %08\" PRIx32, __FUNCTION__,\n\t\t          formatList->msgType);\n\n\tif (!useLongFormatNames)\n\t{\n\t\tUINT32 length = formatList->numFormats * 36;\n\t\ts = cliprdr_packet_new(CB_FORMAT_LIST, 0, length);\n\n\t\tif (!s)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"cliprdr_packet_new failed!\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tsize_t formatNameLength = 0;\n\t\t\tformat = (CLIPRDR_FORMAT*)&(formatList->formats[index]);\n\t\t\tStream_Write_UINT32(s, format->formatId); /* formatId (4 bytes) */\n\t\t\tformatNameSize = 0;\n\n\t\t\tszFormatName = format->formatName;\n\n\t\t\tif (asciiNames)\n\t\t\t{\n\t\t\t\tif (szFormatName)\n\t\t\t\t\tformatNameLength = strnlen(szFormatName, 32);\n\n\t\t\t\tif (formatNameLength > 31)\n\t\t\t\t\tformatNameLength = 31;\n\n\t\t\t\tStream_Write(s, szFormatName, formatNameLength);\n\t\t\t\tStream_Zero(s, 32 - formatNameLength);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twszFormatName = NULL;\n\n\t\t\t\tif (szFormatName)\n\t\t\t\t\tformatNameSize =\n\t\t\t\t\t    ConvertToUnicode(CP_UTF8, 0, szFormatName, -1, &wszFormatName, 0);\n\n\t\t\t\tif (formatNameSize < 0)\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tif (formatNameSize > 15)\n\t\t\t\t\tformatNameSize = 15;\n\n\t\t\t\t/* size in bytes  instead of wchar */\n\t\t\t\tformatNameSize *= 2;\n\n\t\t\t\tif (wszFormatName)\n\t\t\t\t\tStream_Write(s, wszFormatName, (size_t)formatNameSize);\n\n\t\t\t\tStream_Zero(s, (size_t)(32 - formatNameSize));\n\t\t\t\tfree(wszFormatName);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tUINT32 length = 0;\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tformat = (CLIPRDR_FORMAT*)&(formatList->formats[index]);\n\t\t\tlength += 4;\n\t\t\tformatNameSize = 2;\n\n\t\t\tif (format->formatName)\n\t\t\t\tformatNameSize =\n\t\t\t\t    MultiByteToWideChar(CP_UTF8, 0, format->formatName, -1, NULL, 0) * 2;\n\n\t\t\tif (formatNameSize < 0)\n\t\t\t\treturn NULL;\n\n\t\t\tlength += (UINT32)formatNameSize;\n\t\t}\n\n\t\ts = cliprdr_packet_new(CB_FORMAT_LIST, 0, length);\n\n\t\tif (!s)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"cliprdr_packet_new failed!\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tformat = (CLIPRDR_FORMAT*)&(formatList->formats[index]);\n\t\t\tStream_Write_UINT32(s, format->formatId); /* formatId (4 bytes) */\n\n\t\t\tif (format->formatName)\n\t\t\t{\n\t\t\t\tconst size_t cap = Stream_Capacity(s);\n\t\t\t\tconst size_t pos = Stream_GetPosition(s);\n\t\t\t\tconst size_t rem = cap - pos;\n\t\t\t\tif ((cap < pos) || ((rem / 2) > INT_MAX))\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tlpWideCharStr = (LPWSTR)Stream_Pointer(s);\n\t\t\t\tcchWideChar = (int)(rem / 2);\n\t\t\t\tformatNameSize = MultiByteToWideChar(CP_UTF8, 0, format->formatName, -1,\n\t\t\t\t                                     lpWideCharStr, cchWideChar) *\n\t\t\t\t                 2;\n\t\t\t\tif (formatNameSize < 0)\n\t\t\t\t\treturn NULL;\n\t\t\t\tStream_Seek(s, (size_t)formatNameSize);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStream_Write_UINT16(s, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s;\n}\nUINT cliprdr_read_unlock_clipdata(wStream* s, CLIPRDR_UNLOCK_CLIPBOARD_DATA* unlockClipboardData)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tWLog_ERR(TAG, \"not enough remaining data\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tStream_Read_UINT32(s, unlockClipboardData->clipDataId); /* clipDataId (4 bytes) */\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_format_data_request(wStream* s, CLIPRDR_FORMAT_DATA_REQUEST* request)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data in stream!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tStream_Read_UINT32(s, request->requestedFormatId); /* requestedFormatId (4 bytes) */\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_format_data_response(wStream* s, CLIPRDR_FORMAT_DATA_RESPONSE* response)\n{\n\tresponse->requestedFormatData = NULL;\n\n\tif (Stream_GetRemainingLength(s) < response->dataLen)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data in stream!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tif (response->dataLen)\n\t\tresponse->requestedFormatData = Stream_Pointer(s);\n\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_file_contents_request(wStream* s, CLIPRDR_FILE_CONTENTS_REQUEST* request)\n{\n\tif (Stream_GetRemainingLength(s) < 24)\n\t{\n\t\tWLog_ERR(TAG, \"not enough remaining data\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\trequest->haveClipDataId = FALSE;\n\tStream_Read_UINT32(s, request->streamId);      /* streamId (4 bytes) */\n\tStream_Read_UINT32(s, request->listIndex);     /* listIndex (4 bytes) */\n\tStream_Read_UINT32(s, request->dwFlags);       /* dwFlags (4 bytes) */\n\tStream_Read_UINT32(s, request->nPositionLow);  /* nPositionLow (4 bytes) */\n\tStream_Read_UINT32(s, request->nPositionHigh); /* nPositionHigh (4 bytes) */\n\tStream_Read_UINT32(s, request->cbRequested);   /* cbRequested (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) >= 4)\n\t{\n\t\tStream_Read_UINT32(s, request->clipDataId); /* clipDataId (4 bytes) */\n\t\trequest->haveClipDataId = TRUE;\n\t}\n\n\tif (!cliprdr_validate_file_contents_request(request))\n\t\treturn ERROR_BAD_ARGUMENTS;\n\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_file_contents_response(wStream* s, CLIPRDR_FILE_CONTENTS_RESPONSE* response)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tWLog_ERR(TAG, \"not enough remaining data\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tStream_Read_UINT32(s, response->streamId);   /* streamId (4 bytes) */\n\tresponse->requestedData = Stream_Pointer(s); /* requestedFileContentsData */\n\tresponse->cbRequested = response->dataLen - 4;\n\treturn CHANNEL_RC_OK;\n}\n\nUINT cliprdr_read_format_list(wStream* s, CLIPRDR_FORMAT_LIST* formatList, BOOL useLongFormatNames)\n{\n\tUINT32 index;\n\tsize_t position;\n\tBOOL asciiNames;\n\tint formatNameLength;\n\tchar* szFormatName;\n\tWCHAR* wszFormatName;\n\twStream sub1, sub2;\n\tCLIPRDR_FORMAT* formats = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\n\tasciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;\n\n\tindex = 0;\n\t/* empty format list */\n\tformatList->formats = NULL;\n\tformatList->numFormats = 0;\n\n\tStream_StaticInit(&sub1, Stream_Pointer(s), formatList->dataLen);\n\tif (!Stream_SafeSeek(s, formatList->dataLen))\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (!formatList->dataLen)\n\t{\n\t}\n\telse if (!useLongFormatNames)\n\t{\n\t\tconst size_t cap = Stream_Capacity(&sub1);\n\t\tformatList->numFormats = (cap / 36);\n\n\t\tif ((formatList->numFormats * 36) != cap)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Invalid short format list length: %\" PRIuz \"\", cap);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tif (formatList->numFormats)\n\t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tformatList->formats = formats;\n\n\t\twhile (Stream_GetRemainingLength(&sub1) >= 4)\n\t\t{\n\t\t\tStream_Read_UINT32(&sub1, formats[index].formatId); /* formatId (4 bytes) */\n\n\t\t\tformats[index].formatName = NULL;\n\n\t\t\t/* According to MS-RDPECLIP 2.2.3.1.1.1 formatName is \"a 32-byte block containing\n\t\t\t * the *null-terminated* name assigned to the Clipboard Format: (32 ASCII 8 characters\n\t\t\t * or 16 Unicode characters)\"\n\t\t\t * However, both Windows RDSH and mstsc violate this specs as seen in the following\n\t\t\t * example of a transferred short format name string: [R.i.c.h. .T.e.x.t. .F.o.r.m.a.t.]\n\t\t\t * These are 16 unicode charaters - *without* terminating null !\n\t\t\t */\n\n\t\t\tszFormatName = (char*)Stream_Pointer(&sub1);\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub1);\n\t\t\tif (!Stream_SafeSeek(&sub1, 32))\n\t\t\t\tgoto error_out;\n\t\t\tif (asciiNames)\n\t\t\t{\n\t\t\t\tif (szFormatName[0])\n\t\t\t\t{\n\t\t\t\t\t/* ensure null termination */\n\t\t\t\t\tformats[index].formatName = (char*)malloc(32 + 1);\n\t\t\t\t\tif (!formats[index].formatName)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\t\t\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t\tCopyMemory(formats[index].formatName, szFormatName, 32);\n\t\t\t\t\tformats[index].formatName[32] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (wszFormatName[0])\n\t\t\t\t{\n\t\t\t\t\t/* ConvertFromUnicode always returns a null-terminated\n\t\t\t\t\t * string on success, even if the source string isn't.\n\t\t\t\t\t */\n\t\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, 16,\n\t\t\t\t\t                       &(formats[index].formatName), 0, NULL, NULL) < 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"failed to convert short clipboard format name\");\n\t\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\t}\n\telse\n\t{\n\t\tsub2 = sub1;\n\t\twhile (Stream_GetRemainingLength(&sub1) > 0)\n\t\t{\n\t\t\tsize_t rest;\n\t\t\tif (!Stream_SafeSeek(&sub1, 4)) /* formatId (4 bytes) */\n\t\t\t\tgoto error_out;\n\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub1);\n\t\t\trest = Stream_GetRemainingLength(&sub1);\n\t\t\tformatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));\n\n\t\t\tif (!Stream_SafeSeek(&sub1, (formatNameLength + 1) * sizeof(WCHAR)))\n\t\t\t\tgoto error_out;\n\t\t\tformatList->numFormats++;\n\t\t}\n\n\t\tif (formatList->numFormats)\n\t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tformatList->formats = formats;\n\n\t\twhile (Stream_GetRemainingLength(&sub2) >= 4)\n\t\t{\n\t\t\tsize_t rest;\n\t\t\tStream_Read_UINT32(&sub2, formats[index].formatId); /* formatId (4 bytes) */\n\n\t\t\tformats[index].formatName = NULL;\n\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub2);\n\t\t\trest = Stream_GetRemainingLength(&sub2);\n\t\t\tformatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));\n\t\t\tif (!Stream_SafeSeek(&sub2, (formatNameLength + 1) * sizeof(WCHAR)))\n\t\t\t\tgoto error_out;\n\n\t\t\tif (formatNameLength)\n\t\t\t{\n\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, formatNameLength,\n\t\t\t\t                       &(formats[index].formatName), 0, NULL, NULL) < 1)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"failed to convert long clipboard format name\");\n\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\t}\n\n\treturn error;\n\nerror_out:\n\tcliprdr_free_format_list(formatList);\n\treturn error;\n}\n\nvoid cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList)\n{\n\tUINT index = 0;\n\n\tif (formatList == NULL)\n\t\treturn;\n\n\tif (formatList->formats)\n\t{\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tfree(formatList->formats[index].formatName);\n\t\t}\n\n\t\tfree(formatList->formats);\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n\t}\n}\n"], "filenames": ["channels/cliprdr/cliprdr_common.c"], "buggy_code_start_loc": [403], "buggy_code_end_loc": [587], "fixing_code_start_loc": [403], "fixing_code_end_loc": [580], "type": "CWE-125", "message": "In FreeRDP before 2.1.0, there is an out-of-bounds read in cliprdr_read_format_list. Clipboard format data read (by client or server) might read data out-of-bounds. This has been fixed in 2.1.0.", "other": {"cve": {"id": "CVE-2020-11085", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-29T20:15:10.670", "lastModified": "2022-07-19T11:19:54.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before 2.1.0, there is an out-of-bounds read in cliprdr_read_format_list. Clipboard format data read (by client or server) might read data out-of-bounds. This has been fixed in 2.1.0."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.1.0, se presenta una lectura fuera de l\u00edmites en la funci\u00f3n cliprdr_read_format_list. Los datos de formato Clipboard le\u00eddos (por el cliente o el servidor) podr\u00edan leer datos fuera de l\u00edmites. Esto ha sido corregido en la versi\u00f3n 2.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "5C5F8D57-1D22-42B4-9E08-9131F7BE8FA5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/b73143cf7ee5fe4cdabcbf56908aa15d8a883821", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-2j4w-v45m-95hf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/b73143cf7ee5fe4cdabcbf56908aa15d8a883821"}}