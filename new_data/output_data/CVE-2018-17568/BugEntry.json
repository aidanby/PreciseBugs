{"buggy_code": ["/*\n * Description: network buf manager\n *     History: yang@haipo.me, 2016/03/16, create\n */\n\n# include <errno.h>\n# include <string.h>\n# include \"nw_buf.h\"\n\n# define NW_BUF_POOL_INIT_SIZE 64\n# define NW_CACHE_INIT_SIZE    64\n\nsize_t nw_buf_size(nw_buf *buf)\n{\n    return buf->wpos - buf->rpos;\n}\n\nsize_t nw_buf_avail(nw_buf *buf)\n{\n    return buf->size - buf->wpos;\n}\n\nsize_t nw_buf_write(nw_buf *buf, const void *data, size_t len)\n{\n    size_t available = buf->size - buf->wpos;\n    size_t wlen = len > available ? available : len;\n    memcpy(buf->data + buf->wpos, data, wlen);\n    buf->wpos += wlen;\n    return wlen;\n}\n\nvoid nw_buf_shift(nw_buf *buf)\n{\n    if (buf->rpos == buf->wpos) {\n        buf->rpos = buf->wpos = 0;\n    } else if (buf->rpos != 0) {\n        memmove(buf->data, buf->data + buf->rpos, buf->wpos - buf->rpos);\n        buf->wpos -= buf->rpos;\n        buf->rpos = 0;\n    }\n}\n\nnw_buf_pool *nw_buf_pool_create(uint32_t size)\n{\n    nw_buf_pool *pool = malloc(sizeof(nw_buf_pool));\n    if (pool == NULL)\n        return NULL;\n\n    pool->size = size;\n    pool->used = 0;\n    pool->free = 0;\n    pool->free_total = NW_BUF_POOL_INIT_SIZE;\n    pool->free_arr = malloc(pool->free_total * sizeof(nw_buf *));\n    if (pool->free_arr == NULL) {\n        free(pool);\n        return NULL;\n    }\n\n    return pool;\n}\n\nnw_buf *nw_buf_alloc(nw_buf_pool *pool)\n{\n    if (pool->free) {\n        nw_buf *buf = pool->free_arr[--pool->free];\n        buf->size = pool->size;\n        buf->rpos = 0;\n        buf->wpos = 0;\n        buf->next = NULL;\n        return buf;\n    }\n\n    nw_buf *buf = malloc(sizeof(nw_buf) + pool->size);\n    if (buf == NULL)\n        return NULL;\n    buf->size = pool->size;\n    buf->rpos = 0;\n    buf->wpos = 0;\n    buf->next = NULL;\n\n    return buf;\n}\n\nvoid nw_buf_free(nw_buf_pool *pool, nw_buf *buf)\n{\n    if (pool->free < pool->free_total) {\n        pool->free_arr[pool->free++] = buf;\n    } else {\n        uint32_t new_free_total = pool->free_total * 2;\n        void *new_arr = realloc(pool->free_arr, new_free_total * sizeof(nw_buf *));\n        if (new_arr) {\n            pool->free_total = new_free_total;\n            pool->free_arr = new_arr;\n            pool->free_arr[pool->free++] = buf;\n        } else {\n            free(buf);\n        }\n    }\n}\n\nvoid nw_buf_pool_release(nw_buf_pool *pool)\n{\n    for (uint32_t i = 0; i < pool->free; ++i) {\n        free(pool->free_arr[i]);\n    }\n    free(pool->free_arr);\n    free(pool);\n}\n\nnw_buf_list *nw_buf_list_create(nw_buf_pool *pool, uint32_t limit)\n{\n    nw_buf_list *list = malloc(sizeof(nw_buf_list));\n    if (list == NULL)\n        return NULL;\n    list->pool = pool;\n    list->count = 0;\n    list->limit = limit;\n    list->head = NULL;\n    list->tail = NULL;\n\n    return list;\n}\n\nsize_t nw_buf_list_write(nw_buf_list *list, const void *data, size_t len)\n{\n    const void *pos = data;\n    size_t left = len;\n\n    if (list->tail && nw_buf_avail(list->tail)) {\n        size_t ret = nw_buf_write(list->tail, pos, left);\n        left -= ret;\n        pos += ret;\n    }\n\n    while (left) {\n        if (list->limit && list->count >= list->limit)\n            return len - left;\n        nw_buf *buf = nw_buf_alloc(list->pool);\n        if (buf == NULL)\n            return len - left;\n        if (list->head == NULL)\n            list->head = buf;\n        if (list->tail != NULL)\n            list->tail->next = buf;\n        list->tail = buf;\n        list->count++;\n        size_t ret = nw_buf_write(list->tail, pos, left);\n        left -= ret;\n        pos += ret;\n    }\n\n    return len;\n}\n\nsize_t nw_buf_list_append(nw_buf_list *list, const void *data, size_t len)\n{\n    if (list->limit && list->count >= list->limit)\n        return 0;\n    nw_buf *buf = nw_buf_alloc(list->pool);\n    if (buf == NULL)\n        return 0;\n    if (len > buf->size) {\n        nw_buf_free(list->pool, buf);\n        return 0;\n    }\n    nw_buf_write(buf, data, len);\n    if (list->head == NULL)\n        list->head = buf;\n    if (list->tail != NULL)\n        list->tail->next = buf;\n    list->tail = buf;\n    list->count++;\n\n    return len;\n}\n\nvoid nw_buf_list_shift(nw_buf_list *list)\n{\n    if (list->head) {\n        nw_buf *tmp = list->head;\n        list->head = tmp->next;\n        if (list->head == NULL) {\n            list->tail = NULL;\n        }\n        list->count--;\n        nw_buf_free(list->pool, tmp);\n    }\n}\n\nvoid nw_buf_list_release(nw_buf_list *list)\n{\n    nw_buf *curr = list->head;\n    nw_buf *next = NULL;\n    while (curr) {\n        next = curr->next;\n        nw_buf_free(list->pool, curr);\n        curr = next;\n    }\n    free(list);\n}\n\n\nnw_cache *nw_cache_create(uint32_t size)\n{\n    nw_cache *cache = malloc(sizeof(nw_cache));\n    if (cache == NULL)\n        return NULL;\n\n    cache->size = size;\n    cache->used = 0;\n    cache->free = 0;\n    cache->free_total = NW_CACHE_INIT_SIZE;\n    cache->free_arr = malloc(cache->free_total * sizeof(void *));\n    if (cache->free_arr == NULL) {\n        free(cache);\n        return NULL;\n    }\n\n    return cache;\n}\n\nvoid *nw_cache_alloc(nw_cache *cache)\n{\n    if (cache->free)\n        return cache->free_arr[--cache->free];\n    return malloc(cache->size);\n}\n\nvoid nw_cache_free(nw_cache *cache, void *obj)\n{\n    if (cache->free < cache->free_total) {\n        cache->free_arr[cache->free++] = obj;\n    } else {\n        uint32_t new_free_total = cache->free_total * 2;\n        void *new_arr = realloc(cache->free_arr, new_free_total * sizeof(void *));\n        if (new_arr) {\n            cache->free_total = new_free_total;\n            cache->free_arr = new_arr;\n            cache->free_arr[cache->free++] = obj;\n        } else {\n            free(obj);\n        }\n    }\n}\n\nvoid nw_cache_release(nw_cache *cache)\n{\n    for (uint32_t i = 0; i < cache->free; ++i) {\n        free(cache->free_arr[i]);\n    }\n    free(cache->free_arr);\n    free(cache);\n}\n\n", "/*\n * Description: \n *     History: yang@haipo.me, 2016/03/30, create\n */\n\n# include <stdlib.h>\n# include <assert.h>\n\n# include \"ut_rpc.h\"\n# include \"ut_crc32.h\"\n# include \"ut_misc.h\"\n\nint rpc_decode(nw_ses *ses, void *data, size_t max)\n{\n    if (max < RPC_PKG_HEAD_SIZE)\n        return 0;\n\n    rpc_pkg *pkg = data;\n    if (le32toh(pkg->magic) != RPC_PKG_MAGIC)\n        return -1;\n    uint32_t pkg_size = RPC_PKG_HEAD_SIZE + le16toh(pkg->ext_size) + le32toh(pkg->body_size);\n    if (max < pkg_size)\n        return 0;\n\n    uint32_t crc32 = le32toh(pkg->crc32);\n    pkg->crc32 = 0;\n    if (crc32 != generate_crc32c(data, pkg_size))\n        return -3;\n    pkg->crc32 = crc32;\n\n    pkg->magic     = le32toh(pkg->magic);\n    pkg->command   = le32toh(pkg->command);\n    pkg->pkg_type  = le16toh(pkg->pkg_type);\n    pkg->result    = le32toh(pkg->result);\n    pkg->sequence  = le32toh(pkg->sequence);\n    pkg->req_id    = le64toh(pkg->req_id);\n    pkg->body_size = le32toh(pkg->body_size);\n    pkg->ext_size  = le16toh(pkg->ext_size);\n\n    return pkg_size;\n}\n\nint rpc_pack(rpc_pkg *pkg, void **data, uint32_t *size)\n{\n    static void *send_buf;\n    static size_t send_buf_size;\n    uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg->ext_size + pkg->body_size;\n    if (send_buf_size < pkg_size) {\n        if (send_buf)\n            free(send_buf);\n        send_buf_size = pkg_size * 2;\n        send_buf = malloc(send_buf_size);\n        assert(send_buf != NULL);\n    }\n\n    memcpy(send_buf, pkg, RPC_PKG_HEAD_SIZE);\n    if (pkg->ext_size)\n        memcpy(send_buf + RPC_PKG_HEAD_SIZE, pkg->ext, pkg->ext_size);\n    if (pkg->body_size)\n        memcpy(send_buf + RPC_PKG_HEAD_SIZE + pkg->ext_size, pkg->body, pkg->body_size);\n\n    pkg = send_buf;\n    pkg->magic     = htole32(RPC_PKG_MAGIC);\n    pkg->command   = htole32(pkg->command);\n    pkg->pkg_type  = htole16(pkg->pkg_type);\n    pkg->result    = htole32(pkg->result);\n    pkg->sequence  = htole32(pkg->sequence);\n    pkg->req_id    = htole64(pkg->req_id);\n    pkg->body_size = htole32(pkg->body_size);\n    pkg->ext_size  = htole16(pkg->ext_size);\n\n    pkg->crc32 = 0;\n    pkg->crc32 = htole32(generate_crc32c(send_buf, pkg_size));\n\n    *data = send_buf;\n    *size = pkg_size;\n\n    return 0;\n}\n\nint rpc_send(nw_ses *ses, rpc_pkg *pkg)\n{\n    void *data;\n    uint32_t size;\n    int ret = rpc_pack(pkg, &data, &size);\n    if (ret < 0)\n        return ret;\n    return nw_ses_send(ses, data, size);\n}\n\n", "/*\n * Description: \n *     History: yang@haipo.me, 2016/03/29, create\n */\n\n# ifndef _UT_RPC_H_\n# define _UT_RPC_H_\n\n# include <stdint.h>\n# include \"nw_ses.h\"\n\n# define RPC_PKG_MAGIC 0x70656562\n\n# define RPC_PKG_TYPE_REQUEST 0\n# define RPC_PKG_TYPE_REPLY   1\n# define RPC_PKG_TYPE_PUSH    2\n\n# pragma pack(1)\ntypedef struct rpc_pkg {\n    uint32_t magic;\n    uint32_t command;\n    uint16_t pkg_type;\n    uint32_t result;\n    uint32_t crc32;\n    uint32_t sequence;\n    uint64_t req_id;\n    uint32_t body_size;\n    uint16_t ext_size;\n    void   * ext;\n    void   * body;\n} rpc_pkg;\n# pragma pack()\n\n# define RPC_PKG_HEAD_SIZE (sizeof(rpc_pkg) - sizeof(void *) * 2)\n\nint rpc_decode(nw_ses *ses, void *data, size_t max);\nint rpc_pack(rpc_pkg *pkg, void **data, uint32_t *size);\nint rpc_send(nw_ses *ses, rpc_pkg *pkg);\n\n# define RPC_CMD_HEARTBEAT 0\n\n# define RPC_HEARTBEAT_INTERVAL         1.0\n# define RPC_HEARTBEAT_TIMEOUT_DEFAULT  3.0\n# define RPC_HEARTBEAT_TIMEOUT_MIN      2.0\n# define RPC_HEARTBEAT_TIMEOUT_MAX      600\n\n# define RPC_HEARTBEAT_TYPE_TIMEOUT     1\n\n# endif\n\n", "/*\n * Description: \n *     History: yang@haipo.me, 2017/04/26, create\n */\n\n# include <stdbool.h>\n# include <openssl/sha.h>  \n\n# include \"ut_log.h\"\n# include \"ut_misc.h\"\n# include \"ut_base64.h\"\n# include \"ut_ws_svr.h\"\n\nstruct ws_frame {\n    uint8_t     fin;\n    uint8_t     opcode;\n    uint64_t    payload_len;\n    void        *payload;\n};\n\nstruct clt_info {\n    nw_ses      *ses;\n    void        *privdata;\n    double      last_activity;\n    struct      http_parser parser;\n    sds         field;\n    bool        field_set;\n    sds         value;\n    bool        value_set;\n    bool        upgrade;\n    sds         remote;\n    sds         url;\n    sds         message;\n    http_request_t *request;\n    struct ws_frame frame;\n};\n\nstatic int on_http_message_begin(http_parser* parser)\n{\n    struct clt_info *info = parser->data;\n    if (info->request)\n        http_request_release(info->request);\n    info->request = http_request_new();\n    if (info->request == NULL) {\n        return -__LINE__;\n    }\n\n    return 0;\n}\n\nstatic int send_hand_shake_reply(nw_ses *ses, char *protocol, const char *key)\n{\n    unsigned char hash[20];\n    sds data = sdsnew(key);\n    data = sdscat(data, \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    SHA1((const unsigned char *)data, sdslen(data), hash);\n    sdsfree(data);\n\n    sds b4message;\n    base64_encode(hash, sizeof(hash), &b4message);\n\n    http_response_t *response = http_response_new();\n    http_response_set_header(response, \"Upgrade\", \"websocket\");\n    http_response_set_header(response, \"Connection\", \"Upgrade\");\n    http_response_set_header(response, \"Sec-WebSocket-Accept\", b4message);\n    if (protocol) {\n        http_response_set_header(response, \"Sec-WebSocket-Protocol\", protocol);\n    }\n    response->status = 101;\n\n    sds message = http_response_encode(response);\n    nw_ses_send(ses, message, sdslen(message));\n\n    sdsfree(message);\n    sdsfree(b4message);\n\n    return 0;\n}\n\nstatic bool is_good_protocol(const char *protocol_list, const char *protocol)\n{\n    char *tmp = strdup(protocol_list);\n    char *pch = strtok(tmp, \", \");\n    while (pch != NULL) {\n        if (strcmp(pch, protocol) == 0) {\n            free(tmp);\n            return true;\n        }\n        pch = strtok(NULL, \", \");\n    }\n    free(tmp);\n    return false;\n}\n\nstatic bool is_good_origin(const char *origin, const char *require)\n{\n    size_t origin_len  = strlen(origin);\n    size_t require_len = strlen(require);\n    if (origin_len < require_len)\n        return false;\n    if (memcmp(origin + (origin_len - require_len), require, require_len) != 0)\n        return false;\n    return true;\n}\n\nstatic int on_http_message_complete(http_parser* parser)\n{\n    struct clt_info *info = parser->data;\n    ws_svr *svr = ws_svr_from_ses(info->ses);\n    info->request->version_major = parser->http_major;\n    info->request->version_minor = parser->http_minor;\n    info->request->method = parser->method;\n\n    dict_entry *entry;\n    dict_iterator *iter = dict_get_iterator(info->request->headers);\n    while ((entry = dict_next(iter)) != NULL) {\n        log_trace(\"Header: %s: %s\", (char *)entry->key, (char *)entry->val);\n    }\n    dict_release_iterator(iter);\n\n    if (info->request->method != HTTP_GET)\n        goto error;\n    if (http_request_get_header(info->request, \"Host\") == NULL)\n        goto error;\n    double version = info->request->version_major + info->request->version_minor * 0.1;\n    if (version < 1.1)\n        goto error;\n    const char *upgrade = http_request_get_header(info->request, \"Upgrade\");\n    if (upgrade == NULL || strcasecmp(upgrade, \"websocket\") != 0)\n        goto error;\n    const char *connection = http_request_get_header(info->request, \"Connection\");\n    if (connection == NULL)\n        goto error;\n    else {\n        bool found_upgrade = false;\n        int count;\n        sds *tokens = sdssplitlen(connection, strlen(connection), \",\", 1, &count); \n        if (tokens == NULL)\n            goto error;\n        for (int i = 0; i < count; i++) {\n            sds token = tokens[i];\n            sdstrim(token, \" \");\n            if (strcasecmp(token, \"Upgrade\") == 0) {\n                found_upgrade = true;\n                break;\n            }\n        }\n        sdsfreesplitres(tokens, count);\n        if (!found_upgrade)\n            goto error;\n    }\n    const char *ws_version = http_request_get_header(info->request, \"Sec-WebSocket-Version\");\n    if (ws_version == NULL || strcmp(ws_version, \"13\") != 0)\n        goto error;\n    const char *ws_key = http_request_get_header(info->request, \"Sec-WebSocket-Key\");\n    if (ws_key == NULL)\n        goto error;\n    const char *protocol_list = http_request_get_header(info->request, \"Sec-WebSocket-Protocol\");\n    if (protocol_list && !is_good_protocol(protocol_list, svr->protocol))\n        goto error;\n    if (strlen(svr->origin) > 0) {\n        const char *origin = http_request_get_header(info->request, \"Origin\");\n        if (origin == NULL || !is_good_origin(origin, svr->origin))\n            goto error;\n    }\n\n    if (svr->type.on_privdata_alloc) {\n        info->privdata = svr->type.on_privdata_alloc(svr);\n        if (info->privdata == NULL)\n            goto error;\n    }\n    info->upgrade = true;\n    info->remote = sdsnew(http_get_remote_ip(info->ses, info->request));\n    info->url = sdsnew(info->request->url);\n    if (svr->type.on_upgrade) {\n        svr->type.on_upgrade(info->ses, info->remote);\n    }\n    if (protocol_list) {\n        send_hand_shake_reply(info->ses, svr->protocol, ws_key);\n    } else {\n        send_hand_shake_reply(info->ses, NULL, ws_key);\n    }\n\n    return 0;\n\nerror:\n    ws_svr_close_clt(ws_svr_from_ses(info->ses), info->ses);\n    return -1;\n}\n\nstatic int on_http_url(http_parser* parser, const char* at, size_t length)\n{\n    struct clt_info *info = parser->data;\n    if (info->request->url)\n        sdsfree(info->request->url);\n    info->request->url = sdsnewlen(at, length);\n\n    return 0;\n}\n\nstatic int on_http_header_field(http_parser* parser, const char* at, size_t length)\n{\n    struct clt_info *info = parser->data;\n    info->field_set = true;\n    if (info->field == NULL) {\n        info->field = sdsnewlen(at, length);\n    } else {\n        info->field = sdscpylen(info->field, at, length);\n    }\n\n    return 0;\n}\n\nstatic int on_http_header_value(http_parser* parser, const char* at, size_t length)\n{\n    struct clt_info *info = parser->data;\n    info->value_set = true;\n    if (info->value == NULL) {\n        info->value = sdsnewlen(at, length);\n    } else {\n        info->value = sdscpylen(info->value, at, length);\n    }\n\n    if (info->field_set && info->value_set) {\n        http_request_set_header(info->request, info->field, info->value);\n        info->field_set = false;\n        info->value_set = false;\n    }\n\n    return 0;\n}\n\nstatic int on_http_body(http_parser* parser, const char* at, size_t length)\n{\n    struct clt_info *info = parser->data;\n    info->request->body = sdsnewlen(at, length);\n\n    return 0;\n}\n\nstatic bool is_good_opcode(uint8_t opcode)\n{\n    static uint8_t good_list[] = { 0x0, 0x1, 0x2, 0x8, 0x9, 0xa };\n    for (size_t i = 0; i < sizeof(good_list); ++i) {\n        if (opcode == good_list[i])\n            return true;\n    }\n    return false;\n}\n\nstatic int decode_pkg(nw_ses *ses, void *data, size_t max)\n{\n    struct clt_info *info = ses->privdata;\n    if (!info->upgrade) {\n        return max;\n    }\n\n    if (max < 2)\n        return 0;\n\n    uint8_t *p = data;\n    size_t pkg_size = 0;\n    memset(&info->frame, 0, sizeof(info->frame));\n    info->frame.fin = p[0] & 0x80;\n    info->frame.opcode = p[0] & 0x0f;\n    if (!is_good_opcode(info->frame.opcode))\n        return -1;\n    uint8_t mask = p[1] & 0x80;\n    if (mask == 0)\n        return -1;\n\n    uint8_t len = p[1] & 0x7f;\n    if (len < 126) {\n        pkg_size = 2;\n        info->frame.payload_len = len;\n    } else if (len == 126) {\n        pkg_size = 2 + 2;\n        if (max < pkg_size)\n            return 0;\n        info->frame.payload_len = be16toh(*(uint16_t *)(p + 2));\n    } else if (len == 127) {\n        pkg_size = 2 + 8;\n        if (max < pkg_size)\n            return 0;\n        info->frame.payload_len = be64toh(*(uint64_t *)(p + 2));\n    }\n\n    uint8_t masks[4];\n    memcpy(masks, p + pkg_size, sizeof(masks));\n    pkg_size += sizeof(masks);\n    info->frame.payload = p + pkg_size;\n    pkg_size += info->frame.payload_len;\n    if (max < pkg_size)\n        return 0;\n\n    p = info->frame.payload;\n    for (size_t i = 0; i < info->frame.payload_len; ++i) {\n        p[i] = p[i] ^ masks[i & 3];\n    }\n\n    return pkg_size;\n}\n\nstatic void on_error_msg(nw_ses *ses, const char *msg)\n{\n    log_error(\"peer: %s: %s\", nw_sock_human_addr(&ses->peer_addr), msg);\n}\n\nstatic void on_new_connection(nw_ses *ses)\n{\n    log_trace(\"new connection from: %s\", nw_sock_human_addr(&ses->peer_addr));\n    struct clt_info *info = ses->privdata;\n    memset(info, 0, sizeof(struct clt_info));\n    info->ses = ses;\n    info->last_activity = current_timestamp();\n    http_parser_init(&info->parser, HTTP_REQUEST);\n    info->parser.data = info;\n}\n\nstatic void on_connection_close(nw_ses *ses)\n{\n    log_trace(\"connection %s close\", nw_sock_human_addr(&ses->peer_addr));\n    struct clt_info *info = ses->privdata;\n    struct ws_svr *svr = ws_svr_from_ses(ses);\n    if (info->upgrade) {\n        if (svr->type.on_close) {\n            svr->type.on_close(ses, info->remote);\n        }\n        if (svr->type.on_privdata_free) {\n            svr->type.on_privdata_free(svr, info->privdata);\n        }\n    }\n}\n\nstatic void *on_privdata_alloc(void *svr)\n{\n    ws_svr *w_svr = ((nw_svr *)svr)->privdata;\n    return nw_cache_alloc(w_svr->privdata_cache);\n}\n\nstatic void on_privdata_free(void *svr, void *privdata)\n{\n    struct clt_info *info = privdata;\n    if (info->field) {\n        sdsfree(info->field);\n    }\n    if (info->value) {\n        sdsfree(info->value);\n    }\n    if (info->remote) {\n        sdsfree(info->remote);\n    }\n    if (info->url) {\n        sdsfree(info->url);\n    }\n    if (info->message) {\n        sdsfree(info->message);\n    }\n    if (info->request) {\n        http_request_release(info->request);\n    }\n    ws_svr *w_svr = ((nw_svr *)svr)->privdata;\n    nw_cache_free(w_svr->privdata_cache, privdata);\n}\n\nstatic int send_reply(nw_ses *ses, uint8_t opcode, void *payload, size_t payload_len)\n{\n    if (payload == NULL)\n        payload_len = 0;\n\n    static void *buf;\n    static size_t buf_size = 1024;\n    if (buf == NULL) {\n        buf = malloc(1024);\n        if (buf == NULL)\n            return -1;\n    }\n    size_t require_len = 10 + payload_len;\n    if (buf_size < require_len) {\n        void *new = realloc(buf, require_len);\n        if (new == NULL)\n            return -1;\n        buf = new;\n        buf_size = require_len;\n    }\n\n    size_t pkg_len = 0;\n    uint8_t *p = buf;\n    p[0] = 0;\n    p[0] |= 0x1 << 7;\n    p[0] |= opcode;\n    p[1] = 0;\n    if (payload_len < 126) {\n        uint8_t len = payload_len;\n        p[1] |= len;\n        pkg_len = 2;\n    } else if (payload_len <= 0xffff) {\n        p[1] |= 126;\n        uint16_t len = htobe16((uint16_t)payload_len);\n        memcpy(p + 2, &len, sizeof(len));\n        pkg_len = 2 + sizeof(len);\n    } else {\n        p[1] |= 127;\n        uint64_t len = htobe64(payload_len);\n        memcpy(p + 2, &len, sizeof(len));\n        pkg_len = 2 + sizeof(len);\n    }\n\n    if (payload) {\n        memcpy(p + pkg_len, payload, payload_len);\n        pkg_len += payload_len;\n    }\n\n    return nw_ses_send(ses, buf, pkg_len);\n}\n\nstatic int send_pong_message(nw_ses *ses)\n{\n    return send_reply(ses, 0xa, NULL, 0);\n}\n\nstatic void on_recv_pkg(nw_ses *ses, void *data, size_t size)\n{\n    struct clt_info *info = ses->privdata;\n    ws_svr *svr = ws_svr_from_ses(ses);\n    info->last_activity = current_timestamp();\n    if (!info->upgrade) {\n        size_t nparsed = http_parser_execute(&info->parser, &svr->settings, data, size);\n        if (!info->parser.upgrade && nparsed != size) {\n            log_error(\"peer: %s http parse error: %s (%s)\", nw_sock_human_addr(&ses->peer_addr),\n                    http_errno_description(HTTP_PARSER_ERRNO(&info->parser)),\n                    http_errno_name(HTTP_PARSER_ERRNO(&info->parser)));\n            nw_svr_close_clt(svr->raw_svr, ses);\n        }\n        return;\n    }\n\n    switch (info->frame.opcode) {\n    case 0x8:\n        nw_svr_close_clt(svr->raw_svr, ses);\n        return;\n    case 0x9:\n        send_pong_message(ses);\n        return;\n    case 0xa:\n        return;\n    }\n\n    if (info->message == NULL)\n        info->message = sdsempty();\n    info->message = sdscatlen(info->message, info->frame.payload, info->frame.payload_len);\n    if (info->frame.fin) {\n        int ret = svr->type.on_message(ses, info->remote, info->url, info->message, sdslen(info->message));\n        if (ses->id != 0) {\n            if (ret < 0) {\n                nw_svr_close_clt(svr->raw_svr, ses);\n            } else {\n                sdsfree(info->message);\n                info->message = NULL;\n            }\n        }\n    }\n}\n\nstatic void on_timer(nw_timer *timer, void *privdata)\n{\n   ws_svr *svr = privdata;\n   double now = current_timestamp();\n\n   nw_ses *curr = svr->raw_svr->clt_list_head;\n   nw_ses *next;\n   while (curr) {\n       next = curr->next;\n       struct clt_info *info = curr->privdata;\n       if (now - info->last_activity > svr->keep_alive) {\n           log_error(\"peer: %s: last_activity: %f, idle too long\", nw_sock_human_addr(&curr->peer_addr), info->last_activity);\n           nw_svr_close_clt(svr->raw_svr, curr);\n       }\n       curr = next;\n   }\n}\n\nws_svr *ws_svr_create(ws_svr_cfg *cfg, ws_svr_type *type)\n{\n    if (type->on_message == NULL)\n        return NULL;\n    if (type->on_privdata_alloc && !type->on_privdata_free)\n        return NULL;\n\n    ws_svr *svr = malloc(sizeof(ws_svr));\n    memset(svr, 0, sizeof(ws_svr));\n\n    nw_svr_cfg raw_cfg;\n    memset(&raw_cfg, 0, sizeof(raw_cfg));\n    raw_cfg.bind_count = cfg->bind_count;\n    raw_cfg.bind_arr = cfg->bind_arr;\n    raw_cfg.max_pkg_size = cfg->max_pkg_size;\n    raw_cfg.buf_limit = cfg->buf_limit;\n    raw_cfg.read_mem = cfg->read_mem;\n    raw_cfg.write_mem = cfg->write_mem;\n\n    nw_svr_type st;\n    memset(&st, 0, sizeof(st));\n    st.decode_pkg = decode_pkg;\n    st.on_error_msg = on_error_msg;\n    st.on_new_connection = on_new_connection;\n    st.on_connection_close = on_connection_close;\n    st.on_recv_pkg = on_recv_pkg;\n    st.on_privdata_alloc = on_privdata_alloc;\n    st.on_privdata_free = on_privdata_free;\n\n    svr->raw_svr = nw_svr_create(&raw_cfg, &st, svr);\n    if (svr->raw_svr == NULL) {\n        free(svr);\n        return NULL;\n    }\n\n    memset(&svr->settings, 0, sizeof(http_parser_settings));\n    svr->settings.on_message_begin = on_http_message_begin;\n    svr->settings.on_url = on_http_url;\n    svr->settings.on_header_field = on_http_header_field;\n    svr->settings.on_header_value = on_http_header_value;\n    svr->settings.on_body = on_http_body;\n    svr->settings.on_message_complete = on_http_message_complete;\n\n    svr->keep_alive = cfg->keep_alive;\n    svr->protocol = strdup(cfg->protocol);\n    svr->origin   = strdup(cfg->origin);\n    svr->privdata_cache = nw_cache_create(sizeof(struct clt_info));\n    memcpy(&svr->type, type, sizeof(ws_svr_type));\n\n    if (cfg->keep_alive > 0) {\n        nw_timer_set(&svr->timer, 60, true, on_timer, svr);\n        nw_timer_start(&svr->timer);\n    }\n\n    return svr;\n}\n\nint ws_svr_start(ws_svr *svr)\n{\n    int ret = nw_svr_start(svr->raw_svr);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nint ws_svr_stop(ws_svr *svr)\n{\n    int ret = nw_svr_stop(svr->raw_svr);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nws_svr *ws_svr_from_ses(nw_ses *ses)\n{\n    return ((nw_svr *)ses->svr)->privdata;\n}\n\nvoid *ws_ses_privdata(nw_ses *ses)\n{\n    struct clt_info *info = ses->privdata;\n    return info->privdata;\n}\n\nint ws_send_text(nw_ses *ses, char *message)\n{\n    return send_reply(ses, 0x1, message, strlen(message));\n}\n\nint ws_send_binary(nw_ses *ses, void *data, size_t size)\n{\n    return send_reply(ses, 0x2, data, size);\n}\n\nstatic int broadcast_message(ws_svr *svr, uint8_t opcode, void *data, size_t size)\n{\n    nw_ses *curr = svr->raw_svr->clt_list_head;\n    while (curr) {\n        nw_ses *next = curr->next;\n        struct clt_info *info = curr->privdata;\n        if (info->upgrade) {\n            int ret = send_reply(curr, opcode, data, size);\n            if (ret < 0)\n                return ret;\n        }\n        curr = next;\n    }\n\n    return 0;\n}\n\nint ws_svr_broadcast_text(ws_svr *svr, char *message)\n{\n    return broadcast_message(svr, 0x1, message, strlen(message));\n}\n\nint ws_svr_broadcast_binary(ws_svr *svr, void *data, size_t size)\n{\n    return broadcast_message(svr, 0x2, data, size);\n}\n\nvoid ws_svr_close_clt(ws_svr *svr, nw_ses *ses)\n{\n    nw_svr_close_clt(svr->raw_svr, ses);\n}\n\nvoid ws_svr_release(ws_svr *svr)\n{\n    nw_svr_release(svr->raw_svr);\n    nw_timer_stop(&svr->timer);\n    nw_cache_release(svr->privdata_cache);\n    free(svr->protocol);\n    free(svr);\n}\n\n", "/*\n * Description: Websocket server\n *              https://tools.ietf.org/html/rfc6455\n *     History: yang@haipo.me, 2017/04/26, create\n */\n\n# ifndef _UT_WS_SVR_H_\n# define _UT_WS_SVR_H_\n\n# include \"ut_http.h\"\n# include \"nw_svr.h\"\n# include \"nw_buf.h\"\n# include \"nw_timer.h\"\n\ntypedef struct ws_svr_cfg {\n    uint32_t bind_count;\n    nw_svr_bind *bind_arr;\n    uint32_t max_pkg_size;\n    uint32_t buf_limit;\n    uint32_t read_mem;\n    uint32_t write_mem;\n    int keep_alive;\n    char *protocol;\n    char *origin;\n} ws_svr_cfg;\n\ntypedef struct ws_svr_type {\n    void (*on_upgrade)(nw_ses *ses, const char *remote);\n    void (*on_close)(nw_ses *ses, const char *remote);\n    int (*on_message)(nw_ses *ses, const char *remote, const char *url, void *message, size_t size);\n    void *(*on_privdata_alloc)(void *svr);\n    void (*on_privdata_free)(void *svr, void *privdata);\n} ws_svr_type;\n\ntypedef struct ws_svr {\n    nw_svr *raw_svr;\n    nw_timer timer;\n    nw_cache *privdata_cache;\n    int keep_alive;\n    char *protocol;\n    char *origin;\n    http_parser_settings settings;\n    ws_svr_type type;\n} ws_svr;\n\nws_svr *ws_svr_create(ws_svr_cfg *cfg, ws_svr_type *type);\nint ws_svr_start(ws_svr *svr);\nint ws_svr_stop(ws_svr *svr);\nws_svr *ws_svr_from_ses(nw_ses *ses);\nvoid *ws_ses_privdata(nw_ses *ses);\nint ws_send_text(nw_ses *ses, char *message);\nint ws_send_binary(nw_ses *ses, void *data, size_t size);\nint ws_svr_broadcast_text(ws_svr *svr, char *message);\nint ws_svr_broadcast_binary(ws_svr *svr, void *data, size_t size);\nvoid ws_svr_release(ws_svr *svr);\nvoid ws_svr_close_clt(ws_svr *svr, nw_ses *ses);\n\n# endif\n\n"], "fixing_code": ["/*\n * Description: network buf manager\n *     History: yang@haipo.me, 2016/03/16, create\n */\n\n# include <errno.h>\n# include <string.h>\n# include \"nw_buf.h\"\n\n# define NW_BUF_POOL_INIT_SIZE 64\n# define NW_BUF_POOL_MAX_SIZE  65535\n# define NW_CACHE_INIT_SIZE    64\n# define NW_CACHE_MAX_SIZE     65535\n\nsize_t nw_buf_size(nw_buf *buf)\n{\n    return buf->wpos - buf->rpos;\n}\n\nsize_t nw_buf_avail(nw_buf *buf)\n{\n    return buf->size - buf->wpos;\n}\n\nsize_t nw_buf_write(nw_buf *buf, const void *data, size_t len)\n{\n    size_t available = buf->size - buf->wpos;\n    size_t wlen = len > available ? available : len;\n    memcpy(buf->data + buf->wpos, data, wlen);\n    buf->wpos += wlen;\n    return wlen;\n}\n\nvoid nw_buf_shift(nw_buf *buf)\n{\n    if (buf->rpos == buf->wpos) {\n        buf->rpos = buf->wpos = 0;\n    } else if (buf->rpos != 0) {\n        memmove(buf->data, buf->data + buf->rpos, buf->wpos - buf->rpos);\n        buf->wpos -= buf->rpos;\n        buf->rpos = 0;\n    }\n}\n\nnw_buf_pool *nw_buf_pool_create(uint32_t size)\n{\n    nw_buf_pool *pool = malloc(sizeof(nw_buf_pool));\n    if (pool == NULL)\n        return NULL;\n\n    pool->size = size;\n    pool->used = 0;\n    pool->free = 0;\n    pool->free_total = NW_BUF_POOL_INIT_SIZE;\n    pool->free_arr = malloc(pool->free_total * sizeof(nw_buf *));\n    if (pool->free_arr == NULL) {\n        free(pool);\n        return NULL;\n    }\n\n    return pool;\n}\n\nnw_buf *nw_buf_alloc(nw_buf_pool *pool)\n{\n    if (pool->free) {\n        nw_buf *buf = pool->free_arr[--pool->free];\n        buf->size = pool->size;\n        buf->rpos = 0;\n        buf->wpos = 0;\n        buf->next = NULL;\n        return buf;\n    }\n\n    nw_buf *buf = malloc(sizeof(nw_buf) + pool->size);\n    if (buf == NULL)\n        return NULL;\n    buf->size = pool->size;\n    buf->rpos = 0;\n    buf->wpos = 0;\n    buf->next = NULL;\n\n    return buf;\n}\n\nvoid nw_buf_free(nw_buf_pool *pool, nw_buf *buf)\n{\n    if (pool->free < pool->free_total) {\n        pool->free_arr[pool->free++] = buf;\n    } else if (pool->free_total < NW_BUF_POOL_MAX_SIZE) {\n        uint32_t new_free_total = pool->free_total * 2;\n        void *new_arr = realloc(pool->free_arr, new_free_total * sizeof(nw_buf *));\n        if (new_arr) {\n            pool->free_total = new_free_total;\n            pool->free_arr = new_arr;\n            pool->free_arr[pool->free++] = buf;\n        } else {\n            free(buf);\n        }\n    } else {\n        free(buf);\n    }\n}\n\nvoid nw_buf_pool_release(nw_buf_pool *pool)\n{\n    for (uint32_t i = 0; i < pool->free; ++i) {\n        free(pool->free_arr[i]);\n    }\n    free(pool->free_arr);\n    free(pool);\n}\n\nnw_buf_list *nw_buf_list_create(nw_buf_pool *pool, uint32_t limit)\n{\n    nw_buf_list *list = malloc(sizeof(nw_buf_list));\n    if (list == NULL)\n        return NULL;\n    list->pool = pool;\n    list->count = 0;\n    list->limit = limit;\n    list->head = NULL;\n    list->tail = NULL;\n\n    return list;\n}\n\nsize_t nw_buf_list_write(nw_buf_list *list, const void *data, size_t len)\n{\n    const void *pos = data;\n    size_t left = len;\n\n    if (list->tail && nw_buf_avail(list->tail)) {\n        size_t ret = nw_buf_write(list->tail, pos, left);\n        left -= ret;\n        pos += ret;\n    }\n\n    while (left) {\n        if (list->limit && list->count >= list->limit)\n            return len - left;\n        nw_buf *buf = nw_buf_alloc(list->pool);\n        if (buf == NULL)\n            return len - left;\n        if (list->head == NULL)\n            list->head = buf;\n        if (list->tail != NULL)\n            list->tail->next = buf;\n        list->tail = buf;\n        list->count++;\n        size_t ret = nw_buf_write(list->tail, pos, left);\n        left -= ret;\n        pos += ret;\n    }\n\n    return len;\n}\n\nsize_t nw_buf_list_append(nw_buf_list *list, const void *data, size_t len)\n{\n    if (list->limit && list->count >= list->limit)\n        return 0;\n    nw_buf *buf = nw_buf_alloc(list->pool);\n    if (buf == NULL)\n        return 0;\n    if (len > buf->size) {\n        nw_buf_free(list->pool, buf);\n        return 0;\n    }\n    nw_buf_write(buf, data, len);\n    if (list->head == NULL)\n        list->head = buf;\n    if (list->tail != NULL)\n        list->tail->next = buf;\n    list->tail = buf;\n    list->count++;\n\n    return len;\n}\n\nvoid nw_buf_list_shift(nw_buf_list *list)\n{\n    if (list->head) {\n        nw_buf *tmp = list->head;\n        list->head = tmp->next;\n        if (list->head == NULL) {\n            list->tail = NULL;\n        }\n        list->count--;\n        nw_buf_free(list->pool, tmp);\n    }\n}\n\nvoid nw_buf_list_release(nw_buf_list *list)\n{\n    nw_buf *curr = list->head;\n    nw_buf *next = NULL;\n    while (curr) {\n        next = curr->next;\n        nw_buf_free(list->pool, curr);\n        curr = next;\n    }\n    free(list);\n}\n\n\nnw_cache *nw_cache_create(uint32_t size)\n{\n    nw_cache *cache = malloc(sizeof(nw_cache));\n    if (cache == NULL)\n        return NULL;\n\n    cache->size = size;\n    cache->used = 0;\n    cache->free = 0;\n    cache->free_total = NW_CACHE_INIT_SIZE;\n    cache->free_arr = malloc(cache->free_total * sizeof(void *));\n    if (cache->free_arr == NULL) {\n        free(cache);\n        return NULL;\n    }\n\n    return cache;\n}\n\nvoid *nw_cache_alloc(nw_cache *cache)\n{\n    if (cache->free)\n        return cache->free_arr[--cache->free];\n    return malloc(cache->size);\n}\n\nvoid nw_cache_free(nw_cache *cache, void *obj)\n{\n    if (cache->free < cache->free_total) {\n        cache->free_arr[cache->free++] = obj;\n    } else if (cache->free_total < NW_CACHE_MAX_SIZE) {\n        uint32_t new_free_total = cache->free_total * 2;\n        void *new_arr = realloc(cache->free_arr, new_free_total * sizeof(void *));\n        if (new_arr) {\n            cache->free_total = new_free_total;\n            cache->free_arr = new_arr;\n            cache->free_arr[cache->free++] = obj;\n        } else {\n            free(obj);\n        }\n    } else {\n        free(obj);\n    }\n}\n\nvoid nw_cache_release(nw_cache *cache)\n{\n    for (uint32_t i = 0; i < cache->free; ++i) {\n        free(cache->free_arr[i]);\n    }\n    free(cache->free_arr);\n    free(cache);\n}\n\n", "/*\n * Description: \n *     History: yang@haipo.me, 2016/03/30, create\n */\n\n# include <stdlib.h>\n# include <assert.h>\n\n# include \"ut_rpc.h\"\n# include \"ut_crc32.h\"\n# include \"ut_misc.h\"\n\nint rpc_decode(nw_ses *ses, void *data, size_t max)\n{\n    if (max < RPC_PKG_HEAD_SIZE)\n        return 0;\n\n    rpc_pkg *pkg = data;\n    if (le32toh(pkg->magic) != RPC_PKG_MAGIC)\n        return -1;\n    uint32_t pkg_size = RPC_PKG_HEAD_SIZE + le16toh(pkg->ext_size) + le32toh(pkg->body_size);\n    if (max < pkg_size)\n        return 0;\n\n    uint32_t crc32 = le32toh(pkg->crc32);\n    pkg->crc32 = 0;\n    if (crc32 != generate_crc32c(data, pkg_size))\n        return -3;\n    pkg->crc32 = crc32;\n\n    pkg->magic     = le32toh(pkg->magic);\n    pkg->command   = le32toh(pkg->command);\n    pkg->pkg_type  = le16toh(pkg->pkg_type);\n    pkg->result    = le32toh(pkg->result);\n    pkg->sequence  = le32toh(pkg->sequence);\n    pkg->req_id    = le64toh(pkg->req_id);\n    pkg->body_size = le32toh(pkg->body_size);\n    pkg->ext_size  = le16toh(pkg->ext_size);\n\n    return pkg_size;\n}\n\nint rpc_pack(rpc_pkg *pkg, void **data, uint32_t *size)\n{\n    static void *send_buf;\n    static size_t send_buf_size;\n    uint32_t pkg_size;\n    if (pkg->body_size > RPC_PKG_MAX_BODY_SIZE) {\n        return -1;\n    }\n    pkg_size = RPC_PKG_HEAD_SIZE + pkg->ext_size + pkg->body_size;\n    if (send_buf_size < pkg_size) {\n        if (send_buf)\n            free(send_buf);\n        send_buf_size = pkg_size * 2;\n        send_buf = malloc(send_buf_size);\n        if (send_buf == NULL) {\n            return -1;\n        }\n    }\n\n    memcpy(send_buf, pkg, RPC_PKG_HEAD_SIZE);\n    if (pkg->ext_size)\n        memcpy(send_buf + RPC_PKG_HEAD_SIZE, pkg->ext, pkg->ext_size);\n    if (pkg->body_size)\n        memcpy(send_buf + RPC_PKG_HEAD_SIZE + pkg->ext_size, pkg->body, pkg->body_size);\n\n    pkg = send_buf;\n    pkg->magic     = htole32(RPC_PKG_MAGIC);\n    pkg->command   = htole32(pkg->command);\n    pkg->pkg_type  = htole16(pkg->pkg_type);\n    pkg->result    = htole32(pkg->result);\n    pkg->sequence  = htole32(pkg->sequence);\n    pkg->req_id    = htole64(pkg->req_id);\n    pkg->body_size = htole32(pkg->body_size);\n    pkg->ext_size  = htole16(pkg->ext_size);\n\n    pkg->crc32 = 0;\n    pkg->crc32 = htole32(generate_crc32c(send_buf, pkg_size));\n\n    *data = send_buf;\n    *size = pkg_size;\n\n    return 0;\n}\n\nint rpc_send(nw_ses *ses, rpc_pkg *pkg)\n{\n    void *data;\n    uint32_t size;\n    int ret = rpc_pack(pkg, &data, &size);\n    if (ret < 0)\n        return ret;\n    return nw_ses_send(ses, data, size);\n}\n\n", "/*\n * Description: \n *     History: yang@haipo.me, 2016/03/29, create\n */\n\n# ifndef _UT_RPC_H_\n# define _UT_RPC_H_\n\n# include <stdint.h>\n# include \"nw_ses.h\"\n\n# define RPC_PKG_MAGIC 0x70656562\n\n# define RPC_PKG_TYPE_REQUEST 0\n# define RPC_PKG_TYPE_REPLY   1\n# define RPC_PKG_TYPE_PUSH    2\n\n# pragma pack(1)\ntypedef struct rpc_pkg {\n    uint32_t magic;\n    uint32_t command;\n    uint16_t pkg_type;\n    uint32_t result;\n    uint32_t crc32;\n    uint32_t sequence;\n    uint64_t req_id;\n    uint32_t body_size;\n    uint16_t ext_size;\n    void   * ext;\n    void   * body;\n} rpc_pkg;\n# pragma pack()\n\n# define RPC_PKG_HEAD_SIZE (sizeof(rpc_pkg) - sizeof(void *) * 2)\n# define RPC_PKG_MAX_BODY_SIZE ((UINT32_MAX / 2) - UINT16_MAX - sizeof(rpc_pkg))\n\nint rpc_decode(nw_ses *ses, void *data, size_t max);\nint rpc_pack(rpc_pkg *pkg, void **data, uint32_t *size);\nint rpc_send(nw_ses *ses, rpc_pkg *pkg);\n\n# define RPC_CMD_HEARTBEAT 0\n\n# define RPC_HEARTBEAT_INTERVAL         1.0\n# define RPC_HEARTBEAT_TIMEOUT_DEFAULT  3.0\n# define RPC_HEARTBEAT_TIMEOUT_MIN      2.0\n# define RPC_HEARTBEAT_TIMEOUT_MAX      600\n\n# define RPC_HEARTBEAT_TYPE_TIMEOUT     1\n\n# endif\n\n", "/*\n * Description: \n *     History: yang@haipo.me, 2017/04/26, create\n */\n\n# include <stdbool.h>\n# include <openssl/sha.h>  \n\n# include \"ut_log.h\"\n# include \"ut_misc.h\"\n# include \"ut_base64.h\"\n# include \"ut_ws_svr.h\"\n\nstruct ws_frame {\n    uint8_t     fin;\n    uint8_t     opcode;\n    uint64_t    payload_len;\n    void        *payload;\n};\n\nstruct clt_info {\n    nw_ses      *ses;\n    void        *privdata;\n    double      last_activity;\n    struct      http_parser parser;\n    sds         field;\n    bool        field_set;\n    sds         value;\n    bool        value_set;\n    bool        upgrade;\n    sds         remote;\n    sds         url;\n    sds         message;\n    http_request_t *request;\n    struct ws_frame frame;\n};\n\nstatic int on_http_message_begin(http_parser* parser)\n{\n    struct clt_info *info = parser->data;\n    if (info->request)\n        http_request_release(info->request);\n    info->request = http_request_new();\n    if (info->request == NULL) {\n        return -__LINE__;\n    }\n\n    return 0;\n}\n\nstatic int send_hand_shake_reply(nw_ses *ses, char *protocol, const char *key)\n{\n    unsigned char hash[20];\n    sds data = sdsnew(key);\n    data = sdscat(data, \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    SHA1((const unsigned char *)data, sdslen(data), hash);\n    sdsfree(data);\n\n    sds b4message;\n    base64_encode(hash, sizeof(hash), &b4message);\n\n    http_response_t *response = http_response_new();\n    http_response_set_header(response, \"Upgrade\", \"websocket\");\n    http_response_set_header(response, \"Connection\", \"Upgrade\");\n    http_response_set_header(response, \"Sec-WebSocket-Accept\", b4message);\n    if (protocol) {\n        http_response_set_header(response, \"Sec-WebSocket-Protocol\", protocol);\n    }\n    response->status = 101;\n\n    sds message = http_response_encode(response);\n    nw_ses_send(ses, message, sdslen(message));\n\n    sdsfree(message);\n    sdsfree(b4message);\n\n    return 0;\n}\n\nstatic bool is_good_protocol(const char *protocol_list, const char *protocol)\n{\n    char *tmp = strdup(protocol_list);\n    char *pch = strtok(tmp, \", \");\n    while (pch != NULL) {\n        if (strcmp(pch, protocol) == 0) {\n            free(tmp);\n            return true;\n        }\n        pch = strtok(NULL, \", \");\n    }\n    free(tmp);\n    return false;\n}\n\nstatic bool is_good_origin(const char *origin, const char *require)\n{\n    size_t origin_len  = strlen(origin);\n    size_t require_len = strlen(require);\n    if (origin_len < require_len)\n        return false;\n    if (memcmp(origin + (origin_len - require_len), require, require_len) != 0)\n        return false;\n    return true;\n}\n\nstatic int on_http_message_complete(http_parser* parser)\n{\n    struct clt_info *info = parser->data;\n    ws_svr *svr = ws_svr_from_ses(info->ses);\n    info->request->version_major = parser->http_major;\n    info->request->version_minor = parser->http_minor;\n    info->request->method = parser->method;\n\n    dict_entry *entry;\n    dict_iterator *iter = dict_get_iterator(info->request->headers);\n    while ((entry = dict_next(iter)) != NULL) {\n        log_trace(\"Header: %s: %s\", (char *)entry->key, (char *)entry->val);\n    }\n    dict_release_iterator(iter);\n\n    if (info->request->method != HTTP_GET)\n        goto error;\n    if (http_request_get_header(info->request, \"Host\") == NULL)\n        goto error;\n    double version = info->request->version_major + info->request->version_minor * 0.1;\n    if (version < 1.1)\n        goto error;\n    const char *upgrade = http_request_get_header(info->request, \"Upgrade\");\n    if (upgrade == NULL || strcasecmp(upgrade, \"websocket\") != 0)\n        goto error;\n    const char *connection = http_request_get_header(info->request, \"Connection\");\n    if (connection == NULL || strlen(connection) > UT_WS_SVR_MAX_HEADER_SIZE)\n        goto error;\n    else {\n        bool found_upgrade = false;\n        int count;\n        sds *tokens = sdssplitlen(connection, strlen(connection), \",\", 1, &count); \n        if (tokens == NULL)\n            goto error;\n        for (int i = 0; i < count; i++) {\n            sds token = tokens[i];\n            sdstrim(token, \" \");\n            if (strcasecmp(token, \"Upgrade\") == 0) {\n                found_upgrade = true;\n                break;\n            }\n        }\n        sdsfreesplitres(tokens, count);\n        if (!found_upgrade)\n            goto error;\n    }\n    const char *ws_version = http_request_get_header(info->request, \"Sec-WebSocket-Version\");\n    if (ws_version == NULL || strcmp(ws_version, \"13\") != 0)\n        goto error;\n    const char *ws_key = http_request_get_header(info->request, \"Sec-WebSocket-Key\");\n    if (ws_key == NULL)\n        goto error;\n    const char *protocol_list = http_request_get_header(info->request, \"Sec-WebSocket-Protocol\");\n    if (protocol_list && !is_good_protocol(protocol_list, svr->protocol))\n        goto error;\n    if (strlen(svr->origin) > 0) {\n        const char *origin = http_request_get_header(info->request, \"Origin\");\n        if (origin == NULL || !is_good_origin(origin, svr->origin))\n            goto error;\n    }\n\n    if (svr->type.on_privdata_alloc) {\n        info->privdata = svr->type.on_privdata_alloc(svr);\n        if (info->privdata == NULL)\n            goto error;\n    }\n    info->upgrade = true;\n    info->remote = sdsnew(http_get_remote_ip(info->ses, info->request));\n    info->url = sdsnew(info->request->url);\n    if (svr->type.on_upgrade) {\n        svr->type.on_upgrade(info->ses, info->remote);\n    }\n    if (protocol_list) {\n        send_hand_shake_reply(info->ses, svr->protocol, ws_key);\n    } else {\n        send_hand_shake_reply(info->ses, NULL, ws_key);\n    }\n\n    return 0;\n\nerror:\n    ws_svr_close_clt(ws_svr_from_ses(info->ses), info->ses);\n    return -1;\n}\n\nstatic int on_http_url(http_parser* parser, const char* at, size_t length)\n{\n    struct clt_info *info = parser->data;\n    if (info->request->url)\n        sdsfree(info->request->url);\n    info->request->url = sdsnewlen(at, length);\n\n    return 0;\n}\n\nstatic int on_http_header_field(http_parser* parser, const char* at, size_t length)\n{\n    struct clt_info *info = parser->data;\n    info->field_set = true;\n    if (info->field == NULL) {\n        info->field = sdsnewlen(at, length);\n    } else {\n        info->field = sdscpylen(info->field, at, length);\n    }\n\n    return 0;\n}\n\nstatic int on_http_header_value(http_parser* parser, const char* at, size_t length)\n{\n    struct clt_info *info = parser->data;\n    info->value_set = true;\n    if (info->value == NULL) {\n        info->value = sdsnewlen(at, length);\n    } else {\n        info->value = sdscpylen(info->value, at, length);\n    }\n\n    if (info->field_set && info->value_set) {\n        http_request_set_header(info->request, info->field, info->value);\n        info->field_set = false;\n        info->value_set = false;\n    }\n\n    return 0;\n}\n\nstatic int on_http_body(http_parser* parser, const char* at, size_t length)\n{\n    struct clt_info *info = parser->data;\n    info->request->body = sdsnewlen(at, length);\n\n    return 0;\n}\n\nstatic bool is_good_opcode(uint8_t opcode)\n{\n    static uint8_t good_list[] = { 0x0, 0x1, 0x2, 0x8, 0x9, 0xa };\n    for (size_t i = 0; i < sizeof(good_list); ++i) {\n        if (opcode == good_list[i])\n            return true;\n    }\n    return false;\n}\n\nstatic int decode_pkg(nw_ses *ses, void *data, size_t max)\n{\n    struct clt_info *info = ses->privdata;\n    if (!info->upgrade) {\n        return max;\n    }\n\n    if (max < 2)\n        return 0;\n\n    uint8_t *p = data;\n    size_t pkg_size = 0;\n    memset(&info->frame, 0, sizeof(info->frame));\n    info->frame.fin = p[0] & 0x80;\n    info->frame.opcode = p[0] & 0x0f;\n    if (!is_good_opcode(info->frame.opcode))\n        return -1;\n    uint8_t mask = p[1] & 0x80;\n    if (mask == 0)\n        return -1;\n\n    uint8_t len = p[1] & 0x7f;\n    if (len < 126) {\n        pkg_size = 2;\n        info->frame.payload_len = len;\n    } else if (len == 126) {\n        pkg_size = 2 + 2;\n        if (max < pkg_size)\n            return 0;\n        info->frame.payload_len = be16toh(*(uint16_t *)(p + 2));\n    } else if (len == 127) {\n        pkg_size = 2 + 8;\n        if (max < pkg_size)\n            return 0;\n        info->frame.payload_len = be64toh(*(uint64_t *)(p + 2));\n    }\n\n    uint8_t masks[4];\n    memcpy(masks, p + pkg_size, sizeof(masks));\n    pkg_size += sizeof(masks);\n    info->frame.payload = p + pkg_size;\n    pkg_size += info->frame.payload_len;\n    if (max < pkg_size)\n        return 0;\n\n    p = info->frame.payload;\n    for (size_t i = 0; i < info->frame.payload_len; ++i) {\n        p[i] = p[i] ^ masks[i & 3];\n    }\n\n    return pkg_size;\n}\n\nstatic void on_error_msg(nw_ses *ses, const char *msg)\n{\n    log_error(\"peer: %s: %s\", nw_sock_human_addr(&ses->peer_addr), msg);\n}\n\nstatic void on_new_connection(nw_ses *ses)\n{\n    log_trace(\"new connection from: %s\", nw_sock_human_addr(&ses->peer_addr));\n    struct clt_info *info = ses->privdata;\n    memset(info, 0, sizeof(struct clt_info));\n    info->ses = ses;\n    info->last_activity = current_timestamp();\n    http_parser_init(&info->parser, HTTP_REQUEST);\n    info->parser.data = info;\n}\n\nstatic void on_connection_close(nw_ses *ses)\n{\n    log_trace(\"connection %s close\", nw_sock_human_addr(&ses->peer_addr));\n    struct clt_info *info = ses->privdata;\n    struct ws_svr *svr = ws_svr_from_ses(ses);\n    if (info->upgrade) {\n        if (svr->type.on_close) {\n            svr->type.on_close(ses, info->remote);\n        }\n        if (svr->type.on_privdata_free) {\n            svr->type.on_privdata_free(svr, info->privdata);\n        }\n    }\n}\n\nstatic void *on_privdata_alloc(void *svr)\n{\n    ws_svr *w_svr = ((nw_svr *)svr)->privdata;\n    return nw_cache_alloc(w_svr->privdata_cache);\n}\n\nstatic void on_privdata_free(void *svr, void *privdata)\n{\n    struct clt_info *info = privdata;\n    if (info->field) {\n        sdsfree(info->field);\n    }\n    if (info->value) {\n        sdsfree(info->value);\n    }\n    if (info->remote) {\n        sdsfree(info->remote);\n    }\n    if (info->url) {\n        sdsfree(info->url);\n    }\n    if (info->message) {\n        sdsfree(info->message);\n    }\n    if (info->request) {\n        http_request_release(info->request);\n    }\n    ws_svr *w_svr = ((nw_svr *)svr)->privdata;\n    nw_cache_free(w_svr->privdata_cache, privdata);\n}\n\nstatic int send_reply(nw_ses *ses, uint8_t opcode, void *payload, size_t payload_len)\n{\n    if (payload == NULL)\n        payload_len = 0;\n\n    static void *buf;\n    static size_t buf_size = 1024;\n    if (buf == NULL) {\n        buf = malloc(1024);\n        if (buf == NULL)\n            return -1;\n    }\n    size_t require_len = 10 + payload_len;\n    if (buf_size < require_len) {\n        void *new = realloc(buf, require_len);\n        if (new == NULL)\n            return -1;\n        buf = new;\n        buf_size = require_len;\n    }\n\n    size_t pkg_len = 0;\n    uint8_t *p = buf;\n    p[0] = 0;\n    p[0] |= 0x1 << 7;\n    p[0] |= opcode;\n    p[1] = 0;\n    if (payload_len < 126) {\n        uint8_t len = payload_len;\n        p[1] |= len;\n        pkg_len = 2;\n    } else if (payload_len <= 0xffff) {\n        p[1] |= 126;\n        uint16_t len = htobe16((uint16_t)payload_len);\n        memcpy(p + 2, &len, sizeof(len));\n        pkg_len = 2 + sizeof(len);\n    } else {\n        p[1] |= 127;\n        uint64_t len = htobe64(payload_len);\n        memcpy(p + 2, &len, sizeof(len));\n        pkg_len = 2 + sizeof(len);\n    }\n\n    if (payload) {\n        memcpy(p + pkg_len, payload, payload_len);\n        pkg_len += payload_len;\n    }\n\n    return nw_ses_send(ses, buf, pkg_len);\n}\n\nstatic int send_pong_message(nw_ses *ses)\n{\n    return send_reply(ses, 0xa, NULL, 0);\n}\n\nstatic void on_recv_pkg(nw_ses *ses, void *data, size_t size)\n{\n    struct clt_info *info = ses->privdata;\n    ws_svr *svr = ws_svr_from_ses(ses);\n    info->last_activity = current_timestamp();\n    if (!info->upgrade) {\n        size_t nparsed = http_parser_execute(&info->parser, &svr->settings, data, size);\n        if (!info->parser.upgrade && nparsed != size) {\n            log_error(\"peer: %s http parse error: %s (%s)\", nw_sock_human_addr(&ses->peer_addr),\n                    http_errno_description(HTTP_PARSER_ERRNO(&info->parser)),\n                    http_errno_name(HTTP_PARSER_ERRNO(&info->parser)));\n            nw_svr_close_clt(svr->raw_svr, ses);\n        }\n        return;\n    }\n\n    switch (info->frame.opcode) {\n    case 0x8:\n        nw_svr_close_clt(svr->raw_svr, ses);\n        return;\n    case 0x9:\n        send_pong_message(ses);\n        return;\n    case 0xa:\n        return;\n    }\n\n    if (info->message == NULL)\n        info->message = sdsempty();\n    info->message = sdscatlen(info->message, info->frame.payload, info->frame.payload_len);\n    if (info->frame.fin) {\n        int ret = svr->type.on_message(ses, info->remote, info->url, info->message, sdslen(info->message));\n        if (ses->id != 0) {\n            if (ret < 0) {\n                nw_svr_close_clt(svr->raw_svr, ses);\n            } else {\n                sdsfree(info->message);\n                info->message = NULL;\n            }\n        }\n    }\n}\n\nstatic void on_timer(nw_timer *timer, void *privdata)\n{\n   ws_svr *svr = privdata;\n   double now = current_timestamp();\n\n   nw_ses *curr = svr->raw_svr->clt_list_head;\n   nw_ses *next;\n   while (curr) {\n       next = curr->next;\n       struct clt_info *info = curr->privdata;\n       if (now - info->last_activity > svr->keep_alive) {\n           log_error(\"peer: %s: last_activity: %f, idle too long\", nw_sock_human_addr(&curr->peer_addr), info->last_activity);\n           nw_svr_close_clt(svr->raw_svr, curr);\n       }\n       curr = next;\n   }\n}\n\nws_svr *ws_svr_create(ws_svr_cfg *cfg, ws_svr_type *type)\n{\n    if (type->on_message == NULL)\n        return NULL;\n    if (type->on_privdata_alloc && !type->on_privdata_free)\n        return NULL;\n\n    ws_svr *svr = malloc(sizeof(ws_svr));\n    memset(svr, 0, sizeof(ws_svr));\n\n    nw_svr_cfg raw_cfg;\n    memset(&raw_cfg, 0, sizeof(raw_cfg));\n    raw_cfg.bind_count = cfg->bind_count;\n    raw_cfg.bind_arr = cfg->bind_arr;\n    raw_cfg.max_pkg_size = cfg->max_pkg_size;\n    raw_cfg.buf_limit = cfg->buf_limit;\n    raw_cfg.read_mem = cfg->read_mem;\n    raw_cfg.write_mem = cfg->write_mem;\n\n    nw_svr_type st;\n    memset(&st, 0, sizeof(st));\n    st.decode_pkg = decode_pkg;\n    st.on_error_msg = on_error_msg;\n    st.on_new_connection = on_new_connection;\n    st.on_connection_close = on_connection_close;\n    st.on_recv_pkg = on_recv_pkg;\n    st.on_privdata_alloc = on_privdata_alloc;\n    st.on_privdata_free = on_privdata_free;\n\n    svr->raw_svr = nw_svr_create(&raw_cfg, &st, svr);\n    if (svr->raw_svr == NULL) {\n        free(svr);\n        return NULL;\n    }\n\n    memset(&svr->settings, 0, sizeof(http_parser_settings));\n    svr->settings.on_message_begin = on_http_message_begin;\n    svr->settings.on_url = on_http_url;\n    svr->settings.on_header_field = on_http_header_field;\n    svr->settings.on_header_value = on_http_header_value;\n    svr->settings.on_body = on_http_body;\n    svr->settings.on_message_complete = on_http_message_complete;\n\n    svr->keep_alive = cfg->keep_alive;\n    svr->protocol = strdup(cfg->protocol);\n    svr->origin   = strdup(cfg->origin);\n    svr->privdata_cache = nw_cache_create(sizeof(struct clt_info));\n    memcpy(&svr->type, type, sizeof(ws_svr_type));\n\n    if (cfg->keep_alive > 0) {\n        nw_timer_set(&svr->timer, 60, true, on_timer, svr);\n        nw_timer_start(&svr->timer);\n    }\n\n    return svr;\n}\n\nint ws_svr_start(ws_svr *svr)\n{\n    int ret = nw_svr_start(svr->raw_svr);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nint ws_svr_stop(ws_svr *svr)\n{\n    int ret = nw_svr_stop(svr->raw_svr);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nws_svr *ws_svr_from_ses(nw_ses *ses)\n{\n    return ((nw_svr *)ses->svr)->privdata;\n}\n\nvoid *ws_ses_privdata(nw_ses *ses)\n{\n    struct clt_info *info = ses->privdata;\n    return info->privdata;\n}\n\nint ws_send_text(nw_ses *ses, char *message)\n{\n    return send_reply(ses, 0x1, message, strlen(message));\n}\n\nint ws_send_binary(nw_ses *ses, void *data, size_t size)\n{\n    return send_reply(ses, 0x2, data, size);\n}\n\nstatic int broadcast_message(ws_svr *svr, uint8_t opcode, void *data, size_t size)\n{\n    nw_ses *curr = svr->raw_svr->clt_list_head;\n    while (curr) {\n        nw_ses *next = curr->next;\n        struct clt_info *info = curr->privdata;\n        if (info->upgrade) {\n            int ret = send_reply(curr, opcode, data, size);\n            if (ret < 0)\n                return ret;\n        }\n        curr = next;\n    }\n\n    return 0;\n}\n\nint ws_svr_broadcast_text(ws_svr *svr, char *message)\n{\n    return broadcast_message(svr, 0x1, message, strlen(message));\n}\n\nint ws_svr_broadcast_binary(ws_svr *svr, void *data, size_t size)\n{\n    return broadcast_message(svr, 0x2, data, size);\n}\n\nvoid ws_svr_close_clt(ws_svr *svr, nw_ses *ses)\n{\n    nw_svr_close_clt(svr->raw_svr, ses);\n}\n\nvoid ws_svr_release(ws_svr *svr)\n{\n    nw_svr_release(svr->raw_svr);\n    nw_timer_stop(&svr->timer);\n    nw_cache_release(svr->privdata_cache);\n    free(svr->protocol);\n    free(svr);\n}\n\n", "/*\n * Description: Websocket server\n *              https://tools.ietf.org/html/rfc6455\n *     History: yang@haipo.me, 2017/04/26, create\n */\n\n# ifndef _UT_WS_SVR_H_\n# define _UT_WS_SVR_H_\n\n# include \"ut_http.h\"\n# include \"nw_svr.h\"\n# include \"nw_buf.h\"\n# include \"nw_timer.h\"\n\n# define UT_WS_SVR_MAX_HEADER_SIZE 1024\n\ntypedef struct ws_svr_cfg {\n    uint32_t bind_count;\n    nw_svr_bind *bind_arr;\n    uint32_t max_pkg_size;\n    uint32_t buf_limit;\n    uint32_t read_mem;\n    uint32_t write_mem;\n    int keep_alive;\n    char *protocol;\n    char *origin;\n} ws_svr_cfg;\n\ntypedef struct ws_svr_type {\n    void (*on_upgrade)(nw_ses *ses, const char *remote);\n    void (*on_close)(nw_ses *ses, const char *remote);\n    int (*on_message)(nw_ses *ses, const char *remote, const char *url, void *message, size_t size);\n    void *(*on_privdata_alloc)(void *svr);\n    void (*on_privdata_free)(void *svr, void *privdata);\n} ws_svr_type;\n\ntypedef struct ws_svr {\n    nw_svr *raw_svr;\n    nw_timer timer;\n    nw_cache *privdata_cache;\n    int keep_alive;\n    char *protocol;\n    char *origin;\n    http_parser_settings settings;\n    ws_svr_type type;\n} ws_svr;\n\nws_svr *ws_svr_create(ws_svr_cfg *cfg, ws_svr_type *type);\nint ws_svr_start(ws_svr *svr);\nint ws_svr_stop(ws_svr *svr);\nws_svr *ws_svr_from_ses(nw_ses *ses);\nvoid *ws_ses_privdata(nw_ses *ses);\nint ws_send_text(nw_ses *ses, char *message);\nint ws_send_binary(nw_ses *ses, void *data, size_t size);\nint ws_svr_broadcast_text(ws_svr *svr, char *message);\nint ws_svr_broadcast_binary(ws_svr *svr, void *data, size_t size);\nvoid ws_svr_release(ws_svr *svr);\nvoid ws_svr_close_clt(ws_svr *svr, nw_ses *ses);\n\n# endif\n\n"], "filenames": ["network/nw_buf.c", "utils/ut_rpc.c", "utils/ut_rpc.h", "utils/ut_ws_svr.c", "utils/ut_ws_svr.h"], "buggy_code_start_loc": [10, 47, 34, 132, 13], "buggy_code_end_loc": [242, 54, 34, 133, 13], "fixing_code_start_loc": [11, 47, 35, 132, 14], "fixing_code_end_loc": [249, 60, 36, 133, 16], "type": "CWE-190", "message": "utils/ut_rpc.c in ViaBTC Exchange Server before 2018-08-21 has an integer overflow leading to memory corruption.", "other": {"cve": {"id": "CVE-2018-17568", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-26T22:29:02.373", "lastModified": "2018-11-20T19:51:04.463", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "utils/ut_rpc.c in ViaBTC Exchange Server before 2018-08-21 has an integer overflow leading to memory corruption."}, {"lang": "es", "value": "utils/ut_rpc.c en ViaBTC Exchange Server en versiones anteriores al 21/08/2018 tiene un desbordamiento de enteros que conduce a una corrupci\u00f3n de memoria."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:viabtc:viabtc_exchange_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-08-21", "matchCriteriaId": "6C281882-FDF8-4D41-8FC0-F90079381090"}]}]}], "references": [{"url": "https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/viabtc/viabtc_exchange_server/pull/131", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8"}}