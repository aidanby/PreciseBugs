{"buggy_code": ["/*\n * Copyright (C) 2007-2011 B.A.T.M.A.N. contributors:\n *\n * Marek Lindner\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA\n *\n */\n\n#include \"main.h\"\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include \"icmp_socket.h\"\n#include \"send.h\"\n#include \"hash.h\"\n#include \"originator.h\"\n#include \"hard-interface.h\"\n\nstatic struct socket_client *socket_client_hash[256];\n\nstatic void bat_socket_add_packet(struct socket_client *socket_client,\n\t\t\t\t  struct icmp_packet_rr *icmp_packet,\n\t\t\t\t  size_t icmp_len);\n\nvoid bat_socket_init(void)\n{\n\tmemset(socket_client_hash, 0, sizeof(socket_client_hash));\n}\n\nstatic int bat_socket_open(struct inode *inode, struct file *file)\n{\n\tunsigned int i;\n\tstruct socket_client *socket_client;\n\n\tnonseekable_open(inode, file);\n\n\tsocket_client = kmalloc(sizeof(*socket_client), GFP_KERNEL);\n\n\tif (!socket_client)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(socket_client_hash); i++) {\n\t\tif (!socket_client_hash[i]) {\n\t\t\tsocket_client_hash[i] = socket_client;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(socket_client_hash)) {\n\t\tpr_err(\"Error - can't add another packet client: \"\n\t\t       \"maximum number of clients reached\\n\");\n\t\tkfree(socket_client);\n\t\treturn -EXFULL;\n\t}\n\n\tINIT_LIST_HEAD(&socket_client->queue_list);\n\tsocket_client->queue_len = 0;\n\tsocket_client->index = i;\n\tsocket_client->bat_priv = inode->i_private;\n\tspin_lock_init(&socket_client->lock);\n\tinit_waitqueue_head(&socket_client->queue_wait);\n\n\tfile->private_data = socket_client;\n\n\tinc_module_count();\n\treturn 0;\n}\n\nstatic int bat_socket_release(struct inode *inode, struct file *file)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tstruct list_head *list_pos, *list_pos_tmp;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\t/* for all packets in the queue ... */\n\tlist_for_each_safe(list_pos, list_pos_tmp, &socket_client->queue_list) {\n\t\tsocket_packet = list_entry(list_pos,\n\t\t\t\t\t   struct socket_packet, list);\n\n\t\tlist_del(list_pos);\n\t\tkfree(socket_packet);\n\t}\n\n\tsocket_client_hash[socket_client->index] = NULL;\n\tspin_unlock_bh(&socket_client->lock);\n\n\tkfree(socket_client);\n\tdec_module_count();\n\n\treturn 0;\n}\n\nstatic ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}\n\nstatic ssize_t bat_socket_write(struct file *file, const char __user *buff,\n\t\t\t\tsize_t len, loff_t *off)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct bat_priv *bat_priv = socket_client->bat_priv;\n\tstruct hard_iface *primary_if = NULL;\n\tstruct sk_buff *skb;\n\tstruct icmp_packet_rr *icmp_packet;\n\n\tstruct orig_node *orig_node = NULL;\n\tstruct neigh_node *neigh_node = NULL;\n\tsize_t packet_len = sizeof(struct icmp_packet);\n\n\tif (len < sizeof(struct icmp_packet)) {\n\t\tbat_dbg(DBG_BATMAN, bat_priv,\n\t\t\t\"Error - can't send packet from char device: \"\n\t\t\t\"invalid packet size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprimary_if = primary_if_get_selected(bat_priv);\n\n\tif (!primary_if) {\n\t\tlen = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (len >= sizeof(struct icmp_packet_rr))\n\t\tpacket_len = sizeof(struct icmp_packet_rr);\n\n\tskb = dev_alloc_skb(packet_len + sizeof(struct ethhdr));\n\tif (!skb) {\n\t\tlen = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskb_reserve(skb, sizeof(struct ethhdr));\n\ticmp_packet = (struct icmp_packet_rr *)skb_put(skb, packet_len);\n\n\tif (copy_from_user(icmp_packet, buff, packet_len)) {\n\t\tlen = -EFAULT;\n\t\tgoto free_skb;\n\t}\n\n\tif (icmp_packet->packet_type != BAT_ICMP) {\n\t\tbat_dbg(DBG_BATMAN, bat_priv,\n\t\t\t\"Error - can't send packet from char device: \"\n\t\t\t\"got bogus packet type (expected: BAT_ICMP)\\n\");\n\t\tlen = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\tif (icmp_packet->msg_type != ECHO_REQUEST) {\n\t\tbat_dbg(DBG_BATMAN, bat_priv,\n\t\t\t\"Error - can't send packet from char device: \"\n\t\t\t\"got bogus message type (expected: ECHO_REQUEST)\\n\");\n\t\tlen = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\ticmp_packet->uid = socket_client->index;\n\n\tif (icmp_packet->version != COMPAT_VERSION) {\n\t\ticmp_packet->msg_type = PARAMETER_PROBLEM;\n\t\ticmp_packet->version = COMPAT_VERSION;\n\t\tbat_socket_add_packet(socket_client, icmp_packet, packet_len);\n\t\tgoto free_skb;\n\t}\n\n\tif (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)\n\t\tgoto dst_unreach;\n\n\torig_node = orig_hash_find(bat_priv, icmp_packet->dst);\n\tif (!orig_node)\n\t\tgoto dst_unreach;\n\n\tneigh_node = orig_node_get_router(orig_node);\n\tif (!neigh_node)\n\t\tgoto dst_unreach;\n\n\tif (!neigh_node->if_incoming)\n\t\tgoto dst_unreach;\n\n\tif (neigh_node->if_incoming->if_status != IF_ACTIVE)\n\t\tgoto dst_unreach;\n\n\tmemcpy(icmp_packet->orig,\n\t       primary_if->net_dev->dev_addr, ETH_ALEN);\n\n\tif (packet_len == sizeof(struct icmp_packet_rr))\n\t\tmemcpy(icmp_packet->rr,\n\t\t       neigh_node->if_incoming->net_dev->dev_addr, ETH_ALEN);\n\n\tsend_skb_packet(skb, neigh_node->if_incoming, neigh_node->addr);\n\tgoto out;\n\ndst_unreach:\n\ticmp_packet->msg_type = DESTINATION_UNREACHABLE;\n\tbat_socket_add_packet(socket_client, icmp_packet, packet_len);\nfree_skb:\n\tkfree_skb(skb);\nout:\n\tif (primary_if)\n\t\thardif_free_ref(primary_if);\n\tif (neigh_node)\n\t\tneigh_node_free_ref(neigh_node);\n\tif (orig_node)\n\t\torig_node_free_ref(orig_node);\n\treturn len;\n}\n\nstatic unsigned int bat_socket_poll(struct file *file, poll_table *wait)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\n\tpoll_wait(file, &socket_client->queue_wait, wait);\n\n\tif (socket_client->queue_len > 0)\n\t\treturn POLLIN | POLLRDNORM;\n\n\treturn 0;\n}\n\nstatic const struct file_operations fops = {\n\t.owner = THIS_MODULE,\n\t.open = bat_socket_open,\n\t.release = bat_socket_release,\n\t.read = bat_socket_read,\n\t.write = bat_socket_write,\n\t.poll = bat_socket_poll,\n\t.llseek = no_llseek,\n};\n\nint bat_socket_setup(struct bat_priv *bat_priv)\n{\n\tstruct dentry *d;\n\n\tif (!bat_priv->debug_dir)\n\t\tgoto err;\n\n\td = debugfs_create_file(ICMP_SOCKET, S_IFREG | S_IWUSR | S_IRUSR,\n\t\t\t\tbat_priv->debug_dir, bat_priv, &fops);\n\tif (d)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn 1;\n}\n\nstatic void bat_socket_add_packet(struct socket_client *socket_client,\n\t\t\t\t  struct icmp_packet_rr *icmp_packet,\n\t\t\t\t  size_t icmp_len)\n{\n\tstruct socket_packet *socket_packet;\n\n\tsocket_packet = kmalloc(sizeof(*socket_packet), GFP_ATOMIC);\n\n\tif (!socket_packet)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&socket_packet->list);\n\tmemcpy(&socket_packet->icmp_packet, icmp_packet, icmp_len);\n\tsocket_packet->icmp_len = icmp_len;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\t/* while waiting for the lock the socket_client could have been\n\t * deleted */\n\tif (!socket_client_hash[icmp_packet->uid]) {\n\t\tspin_unlock_bh(&socket_client->lock);\n\t\tkfree(socket_packet);\n\t\treturn;\n\t}\n\n\tlist_add_tail(&socket_packet->list, &socket_client->queue_list);\n\tsocket_client->queue_len++;\n\n\tif (socket_client->queue_len > 100) {\n\t\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t\t struct socket_packet, list);\n\n\t\tlist_del(&socket_packet->list);\n\t\tkfree(socket_packet);\n\t\tsocket_client->queue_len--;\n\t}\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\twake_up(&socket_client->queue_wait);\n}\n\nvoid bat_socket_receive_packet(struct icmp_packet_rr *icmp_packet,\n\t\t\t       size_t icmp_len)\n{\n\tstruct socket_client *hash = socket_client_hash[icmp_packet->uid];\n\n\tif (hash)\n\t\tbat_socket_add_packet(hash, icmp_packet, icmp_len);\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2007-2011 B.A.T.M.A.N. contributors:\n *\n * Marek Lindner\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA\n *\n */\n\n#include \"main.h\"\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include \"icmp_socket.h\"\n#include \"send.h\"\n#include \"hash.h\"\n#include \"originator.h\"\n#include \"hard-interface.h\"\n\nstatic struct socket_client *socket_client_hash[256];\n\nstatic void bat_socket_add_packet(struct socket_client *socket_client,\n\t\t\t\t  struct icmp_packet_rr *icmp_packet,\n\t\t\t\t  size_t icmp_len);\n\nvoid bat_socket_init(void)\n{\n\tmemset(socket_client_hash, 0, sizeof(socket_client_hash));\n}\n\nstatic int bat_socket_open(struct inode *inode, struct file *file)\n{\n\tunsigned int i;\n\tstruct socket_client *socket_client;\n\n\tnonseekable_open(inode, file);\n\n\tsocket_client = kmalloc(sizeof(*socket_client), GFP_KERNEL);\n\n\tif (!socket_client)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(socket_client_hash); i++) {\n\t\tif (!socket_client_hash[i]) {\n\t\t\tsocket_client_hash[i] = socket_client;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(socket_client_hash)) {\n\t\tpr_err(\"Error - can't add another packet client: \"\n\t\t       \"maximum number of clients reached\\n\");\n\t\tkfree(socket_client);\n\t\treturn -EXFULL;\n\t}\n\n\tINIT_LIST_HEAD(&socket_client->queue_list);\n\tsocket_client->queue_len = 0;\n\tsocket_client->index = i;\n\tsocket_client->bat_priv = inode->i_private;\n\tspin_lock_init(&socket_client->lock);\n\tinit_waitqueue_head(&socket_client->queue_wait);\n\n\tfile->private_data = socket_client;\n\n\tinc_module_count();\n\treturn 0;\n}\n\nstatic int bat_socket_release(struct inode *inode, struct file *file)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tstruct list_head *list_pos, *list_pos_tmp;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\t/* for all packets in the queue ... */\n\tlist_for_each_safe(list_pos, list_pos_tmp, &socket_client->queue_list) {\n\t\tsocket_packet = list_entry(list_pos,\n\t\t\t\t\t   struct socket_packet, list);\n\n\t\tlist_del(list_pos);\n\t\tkfree(socket_packet);\n\t}\n\n\tsocket_client_hash[socket_client->index] = NULL;\n\tspin_unlock_bh(&socket_client->lock);\n\n\tkfree(socket_client);\n\tdec_module_count();\n\n\treturn 0;\n}\n\nstatic ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\tpacket_len = min(count, socket_packet->icmp_len);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet, packet_len);\n\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}\n\nstatic ssize_t bat_socket_write(struct file *file, const char __user *buff,\n\t\t\t\tsize_t len, loff_t *off)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct bat_priv *bat_priv = socket_client->bat_priv;\n\tstruct hard_iface *primary_if = NULL;\n\tstruct sk_buff *skb;\n\tstruct icmp_packet_rr *icmp_packet;\n\n\tstruct orig_node *orig_node = NULL;\n\tstruct neigh_node *neigh_node = NULL;\n\tsize_t packet_len = sizeof(struct icmp_packet);\n\n\tif (len < sizeof(struct icmp_packet)) {\n\t\tbat_dbg(DBG_BATMAN, bat_priv,\n\t\t\t\"Error - can't send packet from char device: \"\n\t\t\t\"invalid packet size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprimary_if = primary_if_get_selected(bat_priv);\n\n\tif (!primary_if) {\n\t\tlen = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (len >= sizeof(struct icmp_packet_rr))\n\t\tpacket_len = sizeof(struct icmp_packet_rr);\n\n\tskb = dev_alloc_skb(packet_len + sizeof(struct ethhdr));\n\tif (!skb) {\n\t\tlen = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskb_reserve(skb, sizeof(struct ethhdr));\n\ticmp_packet = (struct icmp_packet_rr *)skb_put(skb, packet_len);\n\n\tif (copy_from_user(icmp_packet, buff, packet_len)) {\n\t\tlen = -EFAULT;\n\t\tgoto free_skb;\n\t}\n\n\tif (icmp_packet->packet_type != BAT_ICMP) {\n\t\tbat_dbg(DBG_BATMAN, bat_priv,\n\t\t\t\"Error - can't send packet from char device: \"\n\t\t\t\"got bogus packet type (expected: BAT_ICMP)\\n\");\n\t\tlen = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\tif (icmp_packet->msg_type != ECHO_REQUEST) {\n\t\tbat_dbg(DBG_BATMAN, bat_priv,\n\t\t\t\"Error - can't send packet from char device: \"\n\t\t\t\"got bogus message type (expected: ECHO_REQUEST)\\n\");\n\t\tlen = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\ticmp_packet->uid = socket_client->index;\n\n\tif (icmp_packet->version != COMPAT_VERSION) {\n\t\ticmp_packet->msg_type = PARAMETER_PROBLEM;\n\t\ticmp_packet->version = COMPAT_VERSION;\n\t\tbat_socket_add_packet(socket_client, icmp_packet, packet_len);\n\t\tgoto free_skb;\n\t}\n\n\tif (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)\n\t\tgoto dst_unreach;\n\n\torig_node = orig_hash_find(bat_priv, icmp_packet->dst);\n\tif (!orig_node)\n\t\tgoto dst_unreach;\n\n\tneigh_node = orig_node_get_router(orig_node);\n\tif (!neigh_node)\n\t\tgoto dst_unreach;\n\n\tif (!neigh_node->if_incoming)\n\t\tgoto dst_unreach;\n\n\tif (neigh_node->if_incoming->if_status != IF_ACTIVE)\n\t\tgoto dst_unreach;\n\n\tmemcpy(icmp_packet->orig,\n\t       primary_if->net_dev->dev_addr, ETH_ALEN);\n\n\tif (packet_len == sizeof(struct icmp_packet_rr))\n\t\tmemcpy(icmp_packet->rr,\n\t\t       neigh_node->if_incoming->net_dev->dev_addr, ETH_ALEN);\n\n\tsend_skb_packet(skb, neigh_node->if_incoming, neigh_node->addr);\n\tgoto out;\n\ndst_unreach:\n\ticmp_packet->msg_type = DESTINATION_UNREACHABLE;\n\tbat_socket_add_packet(socket_client, icmp_packet, packet_len);\nfree_skb:\n\tkfree_skb(skb);\nout:\n\tif (primary_if)\n\t\thardif_free_ref(primary_if);\n\tif (neigh_node)\n\t\tneigh_node_free_ref(neigh_node);\n\tif (orig_node)\n\t\torig_node_free_ref(orig_node);\n\treturn len;\n}\n\nstatic unsigned int bat_socket_poll(struct file *file, poll_table *wait)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\n\tpoll_wait(file, &socket_client->queue_wait, wait);\n\n\tif (socket_client->queue_len > 0)\n\t\treturn POLLIN | POLLRDNORM;\n\n\treturn 0;\n}\n\nstatic const struct file_operations fops = {\n\t.owner = THIS_MODULE,\n\t.open = bat_socket_open,\n\t.release = bat_socket_release,\n\t.read = bat_socket_read,\n\t.write = bat_socket_write,\n\t.poll = bat_socket_poll,\n\t.llseek = no_llseek,\n};\n\nint bat_socket_setup(struct bat_priv *bat_priv)\n{\n\tstruct dentry *d;\n\n\tif (!bat_priv->debug_dir)\n\t\tgoto err;\n\n\td = debugfs_create_file(ICMP_SOCKET, S_IFREG | S_IWUSR | S_IRUSR,\n\t\t\t\tbat_priv->debug_dir, bat_priv, &fops);\n\tif (d)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn 1;\n}\n\nstatic void bat_socket_add_packet(struct socket_client *socket_client,\n\t\t\t\t  struct icmp_packet_rr *icmp_packet,\n\t\t\t\t  size_t icmp_len)\n{\n\tstruct socket_packet *socket_packet;\n\n\tsocket_packet = kmalloc(sizeof(*socket_packet), GFP_ATOMIC);\n\n\tif (!socket_packet)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&socket_packet->list);\n\tmemcpy(&socket_packet->icmp_packet, icmp_packet, icmp_len);\n\tsocket_packet->icmp_len = icmp_len;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\t/* while waiting for the lock the socket_client could have been\n\t * deleted */\n\tif (!socket_client_hash[icmp_packet->uid]) {\n\t\tspin_unlock_bh(&socket_client->lock);\n\t\tkfree(socket_packet);\n\t\treturn;\n\t}\n\n\tlist_add_tail(&socket_packet->list, &socket_client->queue_list);\n\tsocket_client->queue_len++;\n\n\tif (socket_client->queue_len > 100) {\n\t\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t\t struct socket_packet, list);\n\n\t\tlist_del(&socket_packet->list);\n\t\tkfree(socket_packet);\n\t\tsocket_client->queue_len--;\n\t}\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\twake_up(&socket_client->queue_wait);\n}\n\nvoid bat_socket_receive_packet(struct icmp_packet_rr *icmp_packet,\n\t\t\t       size_t icmp_len)\n{\n\tstruct socket_client *hash = socket_client_hash[icmp_packet->uid];\n\n\tif (hash)\n\t\tbat_socket_add_packet(hash, icmp_packet, icmp_len);\n}\n"], "filenames": ["net/batman-adv/icmp_socket.c"], "buggy_code_start_loc": [139], "buggy_code_end_loc": [143], "fixing_code_start_loc": [139], "fixing_code_end_loc": [142], "type": "CWE-119", "message": "The bat_socket_read function in net/batman-adv/icmp_socket.c in the Linux kernel before 3.3 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted batman-adv ICMP packet.", "other": {"cve": {"id": "CVE-2011-4604", "sourceIdentifier": "secalert@redhat.com", "published": "2013-06-07T14:03:18.347", "lastModified": "2023-02-13T00:21:49.200", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The bat_socket_read function in net/batman-adv/icmp_socket.c in the Linux kernel before 3.3 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted batman-adv ICMP packet."}, {"lang": "es", "value": "La funci\u00f3n bat_socket_read en net/batman-adv/icmp_socket.c en el kernel de Linux anterior a v3.3 permite a atacantes remotos causar una denegaci\u00f3n de servicio (consumo de memoria) o posiblemente tener otro impacto sin especificar a trav\u00e9s de paquetes batman-adv ICMP manipulados"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.46", "matchCriteriaId": "D0E17148-F44D-4632-80A1-81ABB9A1FF6F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:x86:*", "matchCriteriaId": "7D47A395-821D-4BFF-996E-E849D9A40217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:x86:*", "matchCriteriaId": "8A603291-33B4-4195-B52D-D2A9938089C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.31:*:*:*:*:*:*:*", "matchCriteriaId": "2FEFEB26-F810-4998-B3FB-1503A410DC18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.32:*:*:*:*:*:*:*", "matchCriteriaId": "B7C3A120-3118-4BAA-902D-3916B52BC0D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.33:*:*:*:*:*:*:*", "matchCriteriaId": "BB849D68-728A-4251-A8EF-86880D899416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.34:*:*:*:*:*:*:*", "matchCriteriaId": "DC95E791-7723-43B4-B201-F0800DD4E8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.35:*:*:*:*:*:*:*", "matchCriteriaId": "0E19EBEF-1E81-4B5B-B9FA-FBBB7A175FA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.36:*:*:*:*:*:*:*", "matchCriteriaId": "0FB55642-480B-46BC-BEA4-509287AA6FAB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.37:*:*:*:*:*:*:*", "matchCriteriaId": "FBFDF03D-79F0-43CD-9B4B-35202D6FCA06"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.38:*:*:*:*:*:*:*", "matchCriteriaId": "EB44B030-5A02-42A1-9913-5D4E01A2F1E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.39:*:*:*:*:*:*:*", "matchCriteriaId": "A1881D93-8E12-49BE-B685-956C3472F6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.40:*:*:*:*:*:*:*", "matchCriteriaId": "8D2C30CC-FAE9-4CE9-B0C4-0910B51F3C84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.41:*:*:*:*:*:*:*", "matchCriteriaId": "D35B09BB-6027-463D-8A9B-4EEE92921FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.42:*:*:*:*:*:*:*", "matchCriteriaId": "1A2E2C3B-B2BC-4B33-A317-6CC25DCDA26D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.43:*:*:*:*:*:*:*", "matchCriteriaId": "9B654B47-FDC4-4822-A535-4F93023DF9DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.44:*:*:*:*:*:*:*", "matchCriteriaId": "BA4FBF31-5002-4A1C-8139-29681A246B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.45:*:*:*:*:*:*:*", "matchCriteriaId": "8E767A54-CDEB-4E0B-B275-DC8267239568"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-06/msg00005.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/patch-3.3.bz2", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/12/12/1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=767495", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://lists.open-mesh.org/pipermail/b.a.t.m.a.n/2011-December/005904.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c"}}