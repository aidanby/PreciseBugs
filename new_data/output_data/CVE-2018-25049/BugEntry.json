{"buggy_code": ["var dns = require('dns'),\n    net = require('net'),\n    os = require('os'),\n\tasync = require('async');\n\nmodule.exports = function (email, callback, timeout, from_email) {\n\ttimeout = timeout || 5000;\n\tfrom_email = from_email || email;\n\tif (!/^\\S+@\\S+$/.test(email)) {\n\t\tcallback(null, false);\n\t\treturn;\n\t}\n\tdns.resolveMx(email.split('@')[1], function(err, addresses){\n\t\tif (err || addresses.length === 0) {\n\t\t\tcallback(err, false);\n\t\t\treturn;\n\t\t}\n\t\taddresses = addresses.sort(function (a,b) {\n\t\t\treturn a.priority - b.priority\n\t\t})\n\t\tvar res,undetermined;\n\t\tvar cond = false, j =0;\n\t\tasync.doWhilst(function (done) {\n\t\t\tvar conn = net.createConnection(25, addresses[j].exchange);\n\t\t\tvar commands = [ \"helo \" + addresses[j].exchange, \"mail from: <\"+from_email+\">\", \"rcpt to: <\"+email+\">\" ];\n\t\t\t// console.log(commands);\n\t\t\tvar i = 0;\n\t\t\tconn.setEncoding('ascii');\n\t\t\tconn.setTimeout(timeout);\n\t\t\tconn.on('error', function() {\n\t\t\t\tconn.emit('false');\n\t\t\t});\n\t\t\tconn.on('false', function () {\n\t\t\t\tres = false\n\t\t\t\tundetermined = false;\n\t\t\t\tcond = false;\n\t\t\t\tdone(err, false);\n\t\t\t\tconn.removeAllListeners();\n\t\t\t\tconn.destroy();\n\t\t\t});\n\t\t\tconn.on('connect', function() {\n\t\t\t\tconn.on('prompt', function () {\n\t\t\t\t\tif(i < 3){\n\t\t\t\t\t\tconn.write(commands[i]);\n\t\t\t\t\t\tconn.write('\\r\\n');\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tundetermined = false;\n\t\t\t\t\t\tcond = false;\n\t\t\t\t\t\tdone(err, true);\n\t\t\t\t\t\tconn.removeAllListeners();\n\t\t\t\t\t\tconn.destroy(); //destroy socket manually\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconn.on('undetermined', function () {\n\t\t\t\t\tj++;\n\t\t\t\t\t//in case of an unrecognisable response tell the callback we're not sure\n\t\t\t\t\tcond = true;\n\t\t\t\t\tres = false;\n\t\t\t\t\tundetermined = true;\n\t\t\t\t\tdone(err, false, true);\n\n\t\t\t\t\tconn.removeAllListeners();\n\t\t\t\t\tconn.destroy(); //destroy socket manually\n\n\t\t\t\t});\n\t\t\t\tconn.on('timeout', function () {\n\t\t\t\t\tconn.emit('undetermined');\n\t\t\t\t});\n\t\t\t\tconn.on('data', function(data) {\n\t\t\t\t\tif(data.indexOf(\"220\") == 0 || data.indexOf(\"250\") == 0 || data.indexOf(\"\\n220\") != -1 || data.indexOf(\"\\n250\") != -1) {\n\t\t\t\t\t\tconn.emit('prompt');\n\t\t\t\t\t} else if(data.indexOf(\"\\n550\") != -1 || data.indexOf(\"550\") == 0) {\n\t\t\t\t\t\tconn.emit('false');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconn.emit('undetermined');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}, function () {\n\t\t\treturn j < addresses.length && cond\n\t\t},function (err) {\n\t\t\tcallback(err, res, undetermined);\n\t\t})\n\t});\n};\n\n// compatibility\nmodule.exports.check = module.exports;\n"], "fixing_code": ["var dns = require('dns'),\n    net = require('net'),\n    os = require('os'),\n\tasync = require('async');\n\nmodule.exports = function (email, callback, timeout, from_email) {\n\ttimeout = timeout || 5000;\n\tfrom_email = from_email || email;\n\n\t/* Does it look like a valid email? */\n\n\t/* Our email regex is vulnerable to REDOS on very large input.\n\t *  Valid emails shouldn't be more than 300 characters anyway.\n\t *  https://www.rfc-editor.org/errata_search.php?eid=1690 */\n\tconst MAX_EMAIL_LEN = 300;\n\tif (MAX_EMAIL_LEN < email.length) {\n\t\tcallback(null, false);\n\t\treturn;\n\t}\n\tif (!/^\\S+@\\S+$/.test(email)) {\n\t\tcallback(null, false);\n\t\treturn;\n\t}\n\n\tdns.resolveMx(email.split('@')[1], function(err, addresses){\n\t\tif (err || addresses.length === 0) {\n\t\t\tcallback(err, false);\n\t\t\treturn;\n\t\t}\n\t\taddresses = addresses.sort(function (a,b) {\n\t\t\treturn a.priority - b.priority\n\t\t})\n\t\tvar res,undetermined;\n\t\tvar cond = false, j =0;\n\t\tasync.doWhilst(function (done) {\n\t\t\tvar conn = net.createConnection(25, addresses[j].exchange);\n\t\t\tvar commands = [ \"helo \" + addresses[j].exchange, \"mail from: <\"+from_email+\">\", \"rcpt to: <\"+email+\">\" ];\n\t\t\t// console.log(commands);\n\t\t\tvar i = 0;\n\t\t\tconn.setEncoding('ascii');\n\t\t\tconn.setTimeout(timeout);\n\t\t\tconn.on('error', function() {\n\t\t\t\tconn.emit('false');\n\t\t\t});\n\t\t\tconn.on('false', function () {\n\t\t\t\tres = false\n\t\t\t\tundetermined = false;\n\t\t\t\tcond = false;\n\t\t\t\tdone(err, false);\n\t\t\t\tconn.removeAllListeners();\n\t\t\t\tconn.destroy();\n\t\t\t});\n\t\t\tconn.on('connect', function() {\n\t\t\t\tconn.on('prompt', function () {\n\t\t\t\t\tif(i < 3){\n\t\t\t\t\t\tconn.write(commands[i]);\n\t\t\t\t\t\tconn.write('\\r\\n');\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tundetermined = false;\n\t\t\t\t\t\tcond = false;\n\t\t\t\t\t\tdone(err, true);\n\t\t\t\t\t\tconn.removeAllListeners();\n\t\t\t\t\t\tconn.destroy(); //destroy socket manually\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconn.on('undetermined', function () {\n\t\t\t\t\tj++;\n\t\t\t\t\t//in case of an unrecognisable response tell the callback we're not sure\n\t\t\t\t\tcond = true;\n\t\t\t\t\tres = false;\n\t\t\t\t\tundetermined = true;\n\t\t\t\t\tdone(err, false, true);\n\n\t\t\t\t\tconn.removeAllListeners();\n\t\t\t\t\tconn.destroy(); //destroy socket manually\n\n\t\t\t\t});\n\t\t\t\tconn.on('timeout', function () {\n\t\t\t\t\tconn.emit('undetermined');\n\t\t\t\t});\n\t\t\t\tconn.on('data', function(data) {\n\t\t\t\t\tif(data.indexOf(\"220\") == 0 || data.indexOf(\"250\") == 0 || data.indexOf(\"\\n220\") != -1 || data.indexOf(\"\\n250\") != -1) {\n\t\t\t\t\t\tconn.emit('prompt');\n\t\t\t\t\t} else if(data.indexOf(\"\\n550\") != -1 || data.indexOf(\"550\") == 0) {\n\t\t\t\t\t\tconn.emit('false');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconn.emit('undetermined');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}, function () {\n\t\t\treturn j < addresses.length && cond\n\t\t},function (err) {\n\t\t\tcallback(err, res, undetermined);\n\t\t})\n\t});\n};\n\n// compatibility\nmodule.exports.check = module.exports;\n"], "filenames": ["index.js"], "buggy_code_start_loc": [8], "buggy_code_end_loc": [12], "fixing_code_start_loc": [9], "fixing_code_end_loc": [25], "type": "CWE-1333", "message": "A vulnerability was found in email-existence. It has been rated as problematic. Affected by this issue is some unknown functionality of the file index.js. The manipulation leads to inefficient regular expression complexity. The name of the patch is 0029ba71b6ad0d8ec0baa2ecc6256d038bdd9b56. It is recommended to apply a patch to fix this issue. VDB-216854 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2018-25049", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-27T09:15:09.557", "lastModified": "2023-01-10T20:08:58.630", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in email-existence. It has been rated as problematic. Affected by this issue is some unknown functionality of the file index.js. The manipulation leads to inefficient regular expression complexity. The name of the patch is 0029ba71b6ad0d8ec0baa2ecc6256d038bdd9b56. It is recommended to apply a patch to fix this issue. VDB-216854 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.0, "baseSeverity": "LOW"}, "exploitabilityScore": 1.5, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:email-existence_project:email-existence:-:*:*:*:*:*:*:*", "matchCriteriaId": "E3F66DD7-452E-4059-A6D2-3E26B69E53B1"}]}]}], "references": [{"url": "https://github.com/nmanousos/email-existence/commit/0029ba71b6ad0d8ec0baa2ecc6256d038bdd9b56", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nmanousos/email-existence/pull/37", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216854", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216854", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nmanousos/email-existence/commit/0029ba71b6ad0d8ec0baa2ecc6256d038bdd9b56"}}