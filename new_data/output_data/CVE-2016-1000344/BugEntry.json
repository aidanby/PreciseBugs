{"buggy_code": ["package org.bouncycastle.jcajce.provider.asymmetric;\n\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.asymmetric.dh.KeyFactorySpi;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jcajce.provider.util.AsymmetricAlgorithmProvider;\n\npublic class DH\n{\n    private static final String PREFIX = \"org.bouncycastle.jcajce.provider.asymmetric\" + \".dh.\";\n\n    public static class Mappings\n        extends AsymmetricAlgorithmProvider\n    {\n        public Mappings()\n        {\n        }\n\n        public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"KeyPairGenerator.DH\", PREFIX + \"KeyPairGeneratorSpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyPairGenerator.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"KeyAgreement.DH\", PREFIX + \"KeyAgreementSpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyAgreement.DIFFIEHELLMAN\", \"DH\");\n            provider.addAlgorithm(\"KeyAgreement\", PKCSObjectIdentifiers.id_alg_ESDH, PREFIX + \"KeyAgreementSpi$DHwithRFC2631KDF\");\n            provider.addAlgorithm(\"KeyAgreement\", PKCSObjectIdentifiers.id_alg_SSDH, PREFIX + \"KeyAgreementSpi$DHwithRFC2631KDF\");\n\n            provider.addAlgorithm(\"KeyFactory.DH\", PREFIX + \"KeyFactorySpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyFactory.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"AlgorithmParameters.DH\", PREFIX + \"AlgorithmParametersSpi\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.DH\", PREFIX + \"AlgorithmParameterGeneratorSpi\");\n\n            provider.addAlgorithm(\"Cipher.IES\", PREFIX + \"IESCipher$IES\");\n            provider.addAlgorithm(\"Cipher.IESwithAES\", PREFIX + \"IESCipher$IESwithAES\");\n            provider.addAlgorithm(\"Cipher.IESWITHAES\", PREFIX + \"IESCipher$IESwithAES\");\n            provider.addAlgorithm(\"Cipher.IESWITHDESEDE\", PREFIX + \"IESCipher$IESwithDESede\");\n\n            provider.addAlgorithm(\"Cipher.DHIES\", PREFIX + \"IESCipher$IES\");\n            provider.addAlgorithm(\"Cipher.DHIESwithAES\", PREFIX + \"IESCipher$IESwithAES\");\n            provider.addAlgorithm(\"Cipher.DHIESWITHAES\", PREFIX + \"IESCipher$IESwithAES\");\n            provider.addAlgorithm(\"Cipher.DHIESWITHDESEDE\", PREFIX + \"IESCipher$IESwithDESede\");\n\n            provider.addAlgorithm(\"Cipher.OLDDHIES\", PREFIX + \"IESCipher$OldIES\");\n            provider.addAlgorithm(\"Cipher.OLDDHIESwithAES\", PREFIX + \"IESCipher$OldIESwithAES\");\n            provider.addAlgorithm(\"Cipher.OLDDHIESWITHAES\", PREFIX + \"IESCipher$OldIESwithAES\");\n            provider.addAlgorithm(\"Cipher.OLDDHIESWITHDESEDE\", PREFIX + \"IESCipher$OldIESwithDESede\");\n\n            registerOid(provider, PKCSObjectIdentifiers.dhKeyAgreement, \"DH\", new KeyFactorySpi());\n            registerOid(provider, X9ObjectIdentifiers.dhpublicnumber, \"DH\", new KeyFactorySpi());\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric;\n\nimport org.bouncycastle.asn1.bsi.BSIObjectIdentifiers;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.sec.SECObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.asymmetric.ec.KeyFactorySpi;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jcajce.provider.util.AsymmetricAlgorithmProvider;\nimport org.bouncycastle.util.Properties;\n\npublic class EC\n{\n    private static final String PREFIX = \"org.bouncycastle.jcajce.provider.asymmetric\" + \".ec.\";\n\n    public static class Mappings\n        extends AsymmetricAlgorithmProvider\n    {\n        public Mappings()\n        {\n        }\n\n        public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"AlgorithmParameters.EC\", PREFIX + \"AlgorithmParametersSpi\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECDH\", PREFIX + \"KeyAgreementSpi$DH\");\n            provider.addAlgorithm(\"KeyAgreement.ECDHC\", PREFIX + \"KeyAgreementSpi$DHC\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDH\", PREFIX + \"KeyAgreementSpi$DHC\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA1KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA1KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA224KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA224KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA256KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA256KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA384KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA384KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA512KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA512KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECDHWITHSHA1KDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA1KDF\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA1CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA1CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA256CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA256CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA384CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA384CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA512CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA512CKDF\");\n\n            registerOid(provider, X9ObjectIdentifiers.id_ecPublicKey, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.id_ecPublicKey, \"EC\");\n\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, \"EC\");\n\n            if (!Properties.isOverrideSet(\"org.bouncycastle.ec.disable_mqv\"))\n            {\n                provider.addAlgorithm(\"KeyAgreement.ECMQV\", PREFIX + \"KeyAgreementSpi$MQV\");\n\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA1CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA1CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA224CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA224CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA256CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA256CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA384CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA384CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA512CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA512CKDF\");\n\n                provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA1KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA224KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA256KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA384KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA512KDFAndSharedInfo\");\n\n                registerOid(provider, X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n                registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, \"EC\");\n\n                provider.addAlgorithm(\"KeyFactory.ECMQV\", PREFIX + \"KeyFactorySpi$ECMQV\");\n                provider.addAlgorithm(\"KeyPairGenerator.ECMQV\", PREFIX + \"KeyPairGeneratorSpi$ECMQV\");\n            }\n\n            provider.addAlgorithm(\"KeyFactory.EC\", PREFIX + \"KeyFactorySpi$EC\");\n            provider.addAlgorithm(\"KeyFactory.ECDSA\", PREFIX + \"KeyFactorySpi$ECDSA\");\n            provider.addAlgorithm(\"KeyFactory.ECDH\", PREFIX + \"KeyFactorySpi$ECDH\");\n            provider.addAlgorithm(\"KeyFactory.ECDHC\", PREFIX + \"KeyFactorySpi$ECDHC\");\n\n            provider.addAlgorithm(\"KeyPairGenerator.EC\", PREFIX + \"KeyPairGeneratorSpi$EC\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDSA\", PREFIX + \"KeyPairGeneratorSpi$ECDSA\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDH\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDHWITHSHA1KDF\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDHC\", PREFIX + \"KeyPairGeneratorSpi$ECDHC\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECIES\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n\n            provider.addAlgorithm(\"Cipher.ECIES\", PREFIX + \"IESCipher$ECIES\");\n            provider.addAlgorithm(\"Cipher.ECIESwithAES\", PREFIX + \"IESCipher$ECIESwithAES\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHAES\", PREFIX + \"IESCipher$ECIESwithAES\");\n            provider.addAlgorithm(\"Cipher.ECIESwithDESEDE\", PREFIX + \"IESCipher$ECIESwithDESede\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHDESEDE\", PREFIX + \"IESCipher$ECIESwithDESede\");\n            provider.addAlgorithm(\"Cipher.ECIESwithAES-CBC\", PREFIX + \"IESCipher$ECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHAES-CBC\", PREFIX + \"IESCipher$ECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESwithDESEDE-CBC\", PREFIX + \"IESCipher$ECIESwithDESedeCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHDESEDE-CBC\", PREFIX + \"IESCipher$ECIESwithDESedeCBC\");\n\n            provider.addAlgorithm(\"Cipher.OldECIES\", PREFIX + \"IESCipher$OldECIES\");\n            provider.addAlgorithm(\"Cipher.OldECIESwithAES\", PREFIX + \"IESCipher$OldECIESwithAES\");\n            provider.addAlgorithm(\"Cipher.OldECIESWITHAES\", PREFIX + \"IESCipher$OldECIESwithAES\");\n            provider.addAlgorithm(\"Cipher.OldECIESwithDESEDE\", PREFIX + \"IESCipher$OldECIESwithDESede\");\n            provider.addAlgorithm(\"Cipher.OldECIESWITHDESEDE\", PREFIX + \"IESCipher$OldECIESwithDESede\");\n            provider.addAlgorithm(\"Cipher.OldECIESwithAES-CBC\", PREFIX + \"IESCipher$OldECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.OldECIESWITHAES-CBC\", PREFIX + \"IESCipher$OldECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.OldECIESwithDESEDE-CBC\", PREFIX + \"IESCipher$OldECIESwithDESedeCBC\");\n            provider.addAlgorithm(\"Cipher.OldECIESWITHDESEDE-CBC\", PREFIX + \"IESCipher$OldECIESwithDESedeCBC\");\n\n            provider.addAlgorithm(\"Signature.ECDSA\", PREFIX + \"SignatureSpi$ecDSA\");\n            provider.addAlgorithm(\"Signature.NONEwithECDSA\", PREFIX + \"SignatureSpi$ecDSAnone\");\n\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1withECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAwithSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WITHECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAWITHSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WithECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAWithSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.1.2.840.10045.4.1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.\" + TeleTrusTObjectIdentifiers.ecSignWithSha1, \"ECDSA\");\n\n            provider.addAlgorithm(\"Signature.ECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA\");\n            provider.addAlgorithm(\"Signature.SHA1WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA\");\n            provider.addAlgorithm(\"Signature.SHA224WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA224\");\n            provider.addAlgorithm(\"Signature.SHA256WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA256\");\n            provider.addAlgorithm(\"Signature.SHA384WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA384\");\n            provider.addAlgorithm(\"Signature.SHA512WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA512\");\n            provider.addAlgorithm(\"Signature.SHA3-224WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_224\");\n            provider.addAlgorithm(\"Signature.SHA3-256WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_256\");\n            provider.addAlgorithm(\"Signature.SHA3-384WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_384\");\n            provider.addAlgorithm(\"Signature.SHA3-512WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_512\");\n\n            provider.addAlgorithm(\"Alg.Alias.Signature.DETECDSA\", \"ECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WITHDETECDSA\", \"SHA1WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA224WITHDETECDSA\", \"SHA224WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA256WITHDETECDSA\", \"SHA256WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA384WITHDETECDSA\", \"SHA384WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA512WITHDETECDSA\", \"SHA512WITHECDDSA\");\n\n            addSignatureAlgorithm(provider, \"SHA224\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA224\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA256\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA384\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA512\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n            addSignatureAlgorithm(provider, \"SHA3-224\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_224\", NISTObjectIdentifiers.id_ecdsa_with_sha3_224);\n            addSignatureAlgorithm(provider, \"SHA3-256\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_256\", NISTObjectIdentifiers.id_ecdsa_with_sha3_256);\n            addSignatureAlgorithm(provider, \"SHA3-384\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_384\", NISTObjectIdentifiers.id_ecdsa_with_sha3_384);\n            addSignatureAlgorithm(provider, \"SHA3-512\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_512\", NISTObjectIdentifiers.id_ecdsa_with_sha3_512);\n\n            addSignatureAlgorithm(provider, \"RIPEMD160\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSARipeMD160\",TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n\n            provider.addAlgorithm(\"Signature.SHA1WITHECNR\", PREFIX + \"SignatureSpi$ecNR\");\n            provider.addAlgorithm(\"Signature.SHA224WITHECNR\", PREFIX + \"SignatureSpi$ecNR224\");\n            provider.addAlgorithm(\"Signature.SHA256WITHECNR\", PREFIX + \"SignatureSpi$ecNR256\");\n            provider.addAlgorithm(\"Signature.SHA384WITHECNR\", PREFIX + \"SignatureSpi$ecNR384\");\n            provider.addAlgorithm(\"Signature.SHA512WITHECNR\", PREFIX + \"SignatureSpi$ecNR512\");\n\n            addSignatureAlgorithm(provider, \"SHA1\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n            addSignatureAlgorithm(provider, \"SHA224\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA224\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA256\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA384\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA512\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n            addSignatureAlgorithm(provider, \"SHA1\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA\", BSIObjectIdentifiers.ecdsa_plain_SHA1);\n            addSignatureAlgorithm(provider, \"SHA224\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA224\", BSIObjectIdentifiers.ecdsa_plain_SHA224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA256\", BSIObjectIdentifiers.ecdsa_plain_SHA256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA384\", BSIObjectIdentifiers.ecdsa_plain_SHA384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA512\", BSIObjectIdentifiers.ecdsa_plain_SHA512);\n            addSignatureAlgorithm(provider, \"RIPEMD160\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecPlainDSARP160\", BSIObjectIdentifiers.ecdsa_plain_RIPEMD160);\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.io.ByteArrayOutputStream;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherSpi;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.interfaces.DHKey;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyEncoder;\nimport org.bouncycastle.crypto.agreement.DHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.AESEngine;\nimport org.bouncycastle.crypto.engines.DESedeEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.engines.OldIESEngine;\nimport org.bouncycastle.crypto.generators.DHKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.DHKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.DHKeyParameters;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.crypto.params.IESParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.parsers.DHIESPublicKeyParser;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.DHUtil;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;\nimport org.bouncycastle.jcajce.util.BCJcaJceHelper;\nimport org.bouncycastle.jcajce.util.JcaJceHelper;\nimport org.bouncycastle.jce.interfaces.IESKey;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\n\n\npublic class IESCipher\n    extends CipherSpi\n{\n    private final JcaJceHelper helper = new BCJcaJceHelper();\n\n    private IESEngine engine;\n    private int state = -1;\n    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    private AlgorithmParameters engineParam = null;\n    private IESParameterSpec engineSpec = null;\n    private AsymmetricKeyParameter key;\n    private SecureRandom random;\n    private boolean dhaesMode = false;\n    private AsymmetricKeyParameter otherKeyParameter = null;\n\n    public IESCipher(IESEngine engine)\n    {\n        this.engine = engine;\n    }\n\n    public IESCipher(OldIESEngine engine)\n    {\n        this.engine = engine;\n    }\n\n    public int engineGetBlockSize()\n    {\n        if (engine.getCipher() != null)\n        {\n            return engine.getCipher().getBlockSize();\n        }\n        else\n        {\n            return 0;\n        }\n    }\n\n\n    public int engineGetKeySize(Key key)\n    {\n        if (key instanceof DHKey)\n        {\n            return ((DHKey)key).getParams().getP().bitLength();\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"not a DH key\");\n        }\n    }\n\n\n    public byte[] engineGetIV()\n    {\n        return null;\n    }\n\n    public AlgorithmParameters engineGetParameters()\n    {\n        if (engineParam == null && engineSpec != null)\n        {\n            try\n            {\n                engineParam = helper.createAlgorithmParameters(\"IES\");\n                engineParam.init(engineSpec);\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.toString());\n            }\n        }\n\n        return engineParam;\n    }\n\n\n    public void engineSetMode(String mode)\n        throws NoSuchAlgorithmException\n    {\n        String modeName = Strings.toUpperCase(mode);\n\n        if (modeName.equals(\"NONE\"))\n        {\n            dhaesMode = false;\n        }\n        else if (modeName.equals(\"DHAES\"))\n        {\n            dhaesMode = true;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"can't support mode \" + mode);\n        }\n    }\n\n    public int engineGetOutputSize(int inputLen)\n    {\n        int len1, len2, len3;\n\n        if (key == null)\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        len1 = engine.getMac().getMacSize();\n\n        if (otherKeyParameter == null)\n        {\n            len2 = 1 + 2 * (((DHKeyParameters)key).getParameters().getP().bitLength() + 7) / 8;\n        }\n        else\n        {\n            len2 = 0;\n        }\n\n        if (engine.getCipher() == null)\n        {\n            len3 = inputLen;\n        }\n        else if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen);\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen - len1 - len2);\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            return buffer.size() + len1 + len2 + len3;\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            return buffer.size() - len1 - len2 + len3;\n        }\n        else\n        {\n            throw new IllegalStateException(\"IESCipher not initialised\");\n        }\n\n    }\n\n    public void engineSetPadding(String padding)\n        throws NoSuchPaddingException\n    {\n        String paddingName = Strings.toUpperCase(padding);\n\n        // TDOD: make this meaningful...\n        if (paddingName.equals(\"NOPADDING\"))\n        {\n\n        }\n        else if (paddingName.equals(\"PKCS5PADDING\") || paddingName.equals(\"PKCS7PADDING\"))\n        {\n\n        }\n        else\n        {\n            throw new NoSuchPaddingException(\"padding not available with IESCipher\");\n        }\n    }\n\n    // Initialisation methods\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameters params,\n        SecureRandom random)\n        throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        AlgorithmParameterSpec paramSpec = null;\n\n        if (params != null)\n        {\n            try\n            {\n                paramSpec = params.getParameterSpec(IESParameterSpec.class);\n            }\n            catch (Exception e)\n            {\n                throw new InvalidAlgorithmParameterException(\"cannot recognise parameters: \" + e.toString());\n            }\n        }\n\n        engineParam = params;\n        engineInit(opmode, key, paramSpec, random);\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameterSpec engineSpec,\n        SecureRandom random)\n        throws InvalidAlgorithmParameterException, InvalidKeyException\n    {\n        // Use default parameters (including cipher key size) if none are specified\n        if (engineSpec == null)\n        {\n            this.engineSpec = IESUtil.guessParameterSpec(engine.getCipher());\n        }\n        else if (engineSpec instanceof IESParameterSpec)\n        {\n            this.engineSpec = (IESParameterSpec)engineSpec;\n        }\n        else\n        {\n            throw new InvalidAlgorithmParameterException(\"must be passed IES parameters\");\n        }\n\n        // Parse the recipient's key\n        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE)\n        {\n            if (key instanceof DHPublicKey)\n            {\n                this.key = DHUtil.generatePublicKeyParameter((PublicKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.key = DHUtil.generatePublicKeyParameter(ieKey.getPublic());\n                this.otherKeyParameter = DHUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's public DH key for encryption\");\n            }\n        }\n        else if (opmode == Cipher.DECRYPT_MODE || opmode == Cipher.UNWRAP_MODE)\n        {\n            if (key instanceof DHPrivateKey)\n            {\n                this.key = DHUtil.generatePrivateKeyParameter((PrivateKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.otherKeyParameter = DHUtil.generatePublicKeyParameter(ieKey.getPublic());\n                this.key = DHUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's private DH key for decryption\");\n            }\n        }\n        else\n        {\n            throw new InvalidKeyException(\"must be passed EC key\");\n        }\n\n        this.random = random;\n        this.state = opmode;\n        buffer.reset();\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        SecureRandom random)\n        throws InvalidKeyException\n    {\n        try\n        {\n            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            throw new IllegalArgumentException(\"can't handle supplied parameter spec\");\n        }\n\n    }\n\n\n    // Update methods - buffer the input\n\n    public byte[] engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return null;\n    }\n\n\n    public int engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen,\n        byte[] output,\n        int outputOffset)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return 0;\n    }\n\n\n    // Finalisation methods\n\n    public byte[] engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n        throws IllegalBlockSizeException, BadPaddingException\n    {\n        if (inputLen != 0)\n        {\n            buffer.write(input, inputOffset, inputLen);\n        }\n\n        byte[] in = buffer.toByteArray();\n        buffer.reset();\n\n        // Convert parameters for use in IESEngine\n        IESParameters params = new IESWithCipherParameters(engineSpec.getDerivationV(),\n            engineSpec.getEncodingV(),\n            engineSpec.getMacKeySize(),\n            engineSpec.getCipherKeySize());\n\n        DHParameters dhParams = ((DHKeyParameters)key).getParameters();\n\n        byte[] V;\n        if (otherKeyParameter != null)\n        {\n            try\n            {\n                if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n                {\n                    engine.init(true, otherKeyParameter, key, params);\n                }\n                else\n                {\n                    engine.init(false, key, otherKeyParameter, params);\n                }\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            // Generate the ephemeral key pair\n            DHKeyPairGenerator gen = new DHKeyPairGenerator();\n            gen.init(new DHKeyGenerationParameters(random, dhParams));\n\n            EphemeralKeyPairGenerator kGen = new EphemeralKeyPairGenerator(gen, new KeyEncoder()\n            {\n                public byte[] getEncoded(AsymmetricKeyParameter keyParameter)\n                {\n                    byte[] Vloc = new byte[(((DHKeyParameters)keyParameter).getParameters().getP().bitLength() + 7) / 8];\n                    byte[] Vtmp = BigIntegers.asUnsignedByteArray(((DHPublicKeyParameters)keyParameter).getY());\n\n                    if (Vtmp.length > Vloc.length)\n                    {\n                        throw new IllegalArgumentException(\"Senders's public key longer than expected.\");\n                    }\n                    else\n                    {\n                        System.arraycopy(Vtmp, 0, Vloc, Vloc.length - Vtmp.length, Vtmp.length);\n                    }\n\n                    return Vloc;\n                }\n            });\n\n            // Encrypt the buffer\n            try\n            {\n                engine.init(key, params, kGen);\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            // Decrypt the buffer\n            try\n            {\n                engine.init(key, params, new DHIESPublicKeyParser(((DHKeyParameters)key).getParameters()));\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (InvalidCipherTextException e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n        else\n        {\n            throw new IllegalStateException(\"IESCipher not initialised\");\n        }\n\n    }\n\n\n    public int engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLength,\n        byte[] output,\n        int outputOffset)\n        throws ShortBufferException, IllegalBlockSizeException, BadPaddingException\n    {\n\n        byte[] buf = engineDoFinal(input, inputOffset, inputLength);\n        System.arraycopy(buf, 0, output, outputOffset, buf.length);\n        return buf.length;\n\n    }\n\n    /**\n     * Classes that inherit from us\n     */\n\n    static public class IES\n        extends IESCipher\n    {\n        public IES()\n        {\n            super(new IESEngine(new DHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest())));\n        }\n    }\n\n    static public class IESwithDESede\n        extends IESCipher\n    {\n        public IESwithDESede()\n        {\n            super(new IESEngine(new DHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESedeEngine())));\n        }\n    }\n\n    static public class IESwithAES\n        extends IESCipher\n    {\n        public IESwithAES()\n        {\n            super(new IESEngine(new DHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new AESEngine())));\n        }\n    }\n\n    /**\n     * Backwards compatibility.\n     */\n    static public class OldIESwithCipher\n        extends IESCipher\n    {\n        public OldIESwithCipher(BlockCipher baseCipher)\n        {\n            super(new OldIESEngine(new DHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(baseCipher)));\n        }\n    }\n\n    static public class OldIES\n        extends IESCipher\n    {\n        public OldIES()\n        {\n            super(new OldIESEngine(new DHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest())));\n        }\n    }\n\n    static public class OldIESwithDESede\n        extends OldIESwithCipher\n    {\n        public OldIESwithDESede()\n        {\n            super(new DESedeEngine());\n        }\n    }\n\n    static public class OldIESwithAES\n        extends OldIESwithCipher\n    {\n        public OldIESwithAES()\n        {\n            super(new AESEngine());\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.ec;\n\nimport java.io.ByteArrayOutputStream;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherSpi;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyEncoder;\nimport org.bouncycastle.crypto.agreement.ECDHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.AESEngine;\nimport org.bouncycastle.crypto.engines.DESedeEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.engines.OldIESEngine;\nimport org.bouncycastle.crypto.generators.ECKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.params.ECKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.ECKeyParameters;\nimport org.bouncycastle.crypto.params.ECPublicKeyParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.crypto.parsers.ECIESPublicKeyParser;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;\nimport org.bouncycastle.jcajce.util.BCJcaJceHelper;\nimport org.bouncycastle.jcajce.util.JcaJceHelper;\nimport org.bouncycastle.jce.interfaces.ECKey;\nimport org.bouncycastle.jce.interfaces.IESKey;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.Strings;\n\n\npublic class IESCipher\n    extends CipherSpi\n{\n    private final JcaJceHelper helper = new BCJcaJceHelper();\n\n    private int ivLength;\n    private IESEngine engine;\n    private int state = -1;\n    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    private AlgorithmParameters engineParam = null;\n    private IESParameterSpec engineSpec = null;\n    private AsymmetricKeyParameter key;\n    private SecureRandom random;\n    private boolean dhaesMode = false;\n    private AsymmetricKeyParameter otherKeyParameter = null;\n\n    public IESCipher(IESEngine engine)\n    {\n        this.engine = engine;\n        this.ivLength = 0;\n    }\n\n    public IESCipher(IESEngine engine, int ivLength)\n    {\n        this.engine = engine;\n        this.ivLength = ivLength;\n    }\n\n    public int engineGetBlockSize()\n    {\n        if (engine.getCipher() != null)\n        {\n            return engine.getCipher().getBlockSize();\n        }\n        else\n        {\n            return 0;\n        }\n    }\n\n\n    public int engineGetKeySize(Key key)\n    {\n        if (key instanceof ECKey)\n        {\n            return ((ECKey)key).getParameters().getCurve().getFieldSize();\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"not an EC key\");\n        }\n    }\n\n\n    public byte[] engineGetIV()\n    {\n        return null;\n    }\n\n    public AlgorithmParameters engineGetParameters()\n    {\n        if (engineParam == null && engineSpec != null)\n        {\n            try\n            {\n                engineParam = helper.createAlgorithmParameters(\"IES\");\n                engineParam.init(engineSpec);\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.toString());\n            }\n        }\n\n        return engineParam;\n    }\n\n\n    public void engineSetMode(String mode)\n        throws NoSuchAlgorithmException\n    {\n        String modeName = Strings.toUpperCase(mode);\n\n        if (modeName.equals(\"NONE\"))\n        {\n            dhaesMode = false;\n        }\n        else if (modeName.equals(\"DHAES\"))\n        {\n            dhaesMode = true;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"can't support mode \" + mode);\n        }\n    }\n\n\n    public int engineGetOutputSize(int inputLen)\n    {\n        int len1, len2, len3;\n\n        if (key == null)\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        len1 = engine.getMac().getMacSize();\n\n        if (otherKeyParameter == null)\n        {\n            len2 = 2 * (((ECKeyParameters)key).getParameters().getCurve().getFieldSize() + 7) / 8;\n        }\n        else\n        {\n            len2 = 0;\n        }\n\n        if (engine.getCipher() == null)\n        {\n            len3 = inputLen;\n        }\n        else if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen);\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen - len1 - len2);\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            return buffer.size() + len1 + 1 + len2 + len3;\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            return buffer.size() - len1 - len2 + len3;\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n    }\n\n    public void engineSetPadding(String padding)\n        throws NoSuchPaddingException\n    {\n        String paddingName = Strings.toUpperCase(padding);\n\n        // TDOD: make this meaningful...\n        if (paddingName.equals(\"NOPADDING\"))\n        {\n\n        }\n        else if (paddingName.equals(\"PKCS5PADDING\") || paddingName.equals(\"PKCS7PADDING\"))\n        {\n\n        }\n        else\n        {\n            throw new NoSuchPaddingException(\"padding not available with IESCipher\");\n        }\n    }\n\n\n    // Initialisation methods\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameters params,\n        SecureRandom random)\n        throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        AlgorithmParameterSpec paramSpec = null;\n\n        if (params != null)\n        {\n            try\n            {\n                paramSpec = params.getParameterSpec(IESParameterSpec.class);\n            }\n            catch (Exception e)\n            {\n                throw new InvalidAlgorithmParameterException(\"cannot recognise parameters: \" + e.toString());\n            }\n        }\n\n        engineParam = params;\n        engineInit(opmode, key, paramSpec, random);\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameterSpec engineSpec,\n        SecureRandom random)\n        throws InvalidAlgorithmParameterException, InvalidKeyException\n    {\n        otherKeyParameter = null;\n\n        // Use default parameters (including cipher key size) if none are specified\n        if (engineSpec == null)\n        {\n            this.engineSpec = IESUtil.guessParameterSpec(engine.getCipher());\n        }\n        else if (engineSpec instanceof IESParameterSpec)\n        {\n            this.engineSpec = (IESParameterSpec)engineSpec;\n        }\n        else\n        {\n            throw new InvalidAlgorithmParameterException(\"must be passed IES parameters\");\n        }\n\n        byte[] nonce = this.engineSpec.getNonce();\n\n        if (nonce != null)\n        {\n            if (ivLength == 0)\n            {\n                throw new InvalidAlgorithmParameterException(\"NONCE present in IES Parameters when none required\");\n            }\n            else if (nonce.length != ivLength)\n            {\n                throw new InvalidAlgorithmParameterException(\"NONCE in IES Parameters needs to be \" + ivLength + \" bytes long\");\n            }\n        }\n\n        // Parse the recipient's key\n        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE)\n        {\n            if (key instanceof PublicKey)\n            {\n                this.key = ECUtils.generatePublicKeyParameter((PublicKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.key = ECUtils.generatePublicKeyParameter(ieKey.getPublic());\n                this.otherKeyParameter = ECUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's public EC key for encryption\");\n            }\n        }\n        else if (opmode == Cipher.DECRYPT_MODE || opmode == Cipher.UNWRAP_MODE)\n        {\n            if (key instanceof PrivateKey)\n            {\n                this.key = ECUtil.generatePrivateKeyParameter((PrivateKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.otherKeyParameter = ECUtils.generatePublicKeyParameter(ieKey.getPublic());\n                this.key = ECUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's private EC key for decryption\");\n            }\n        }\n        else\n        {\n            throw new InvalidKeyException(\"must be passed EC key\");\n        }\n\n\n        this.random = random;\n        this.state = opmode;\n        buffer.reset();\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        SecureRandom random)\n        throws InvalidKeyException\n    {\n        try\n        {\n            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            throw new IllegalArgumentException(\"can't handle supplied parameter spec\");\n        }\n\n    }\n\n\n    // Update methods - buffer the input\n\n    public byte[] engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return null;\n    }\n\n\n    public int engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen,\n        byte[] output,\n        int outputOffset)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return 0;\n    }\n\n\n    // Finalisation methods\n\n    public byte[] engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n        throws IllegalBlockSizeException, BadPaddingException\n    {\n        if (inputLen != 0)\n        {\n            buffer.write(input, inputOffset, inputLen);\n        }\n\n        final byte[] in = buffer.toByteArray();\n        buffer.reset();\n\n        // Convert parameters for use in IESEngine\n        CipherParameters params = new IESWithCipherParameters(engineSpec.getDerivationV(),\n            engineSpec.getEncodingV(),\n            engineSpec.getMacKeySize(),\n            engineSpec.getCipherKeySize());\n\n        if (engineSpec.getNonce() != null)\n        {\n            params = new ParametersWithIV(params, engineSpec.getNonce());\n        }\n\n        final ECDomainParameters ecParams = ((ECKeyParameters)key).getParameters();\n\n        final byte[] V;\n\n        if (otherKeyParameter != null)\n        {\n            try\n            {\n                if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n                {\n                    engine.init(true, otherKeyParameter, key, params);\n                }\n                else\n                {\n                    engine.init(false, key, otherKeyParameter, params);\n                }\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            // Generate the ephemeral key pair\n            ECKeyPairGenerator gen = new ECKeyPairGenerator();\n            gen.init(new ECKeyGenerationParameters(ecParams, random));\n\n            final boolean usePointCompression = engineSpec.getPointCompression();\n            EphemeralKeyPairGenerator kGen = new EphemeralKeyPairGenerator(gen, new KeyEncoder()\n            {\n                public byte[] getEncoded(AsymmetricKeyParameter keyParameter)\n                {\n                    return ((ECPublicKeyParameters)keyParameter).getQ().getEncoded(usePointCompression);\n                }\n            });\n\n            // Encrypt the buffer\n            try\n            {\n                engine.init(key, params, kGen);\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            // Decrypt the buffer\n            try\n            {\n                engine.init(key, params, new ECIESPublicKeyParser(ecParams));\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (InvalidCipherTextException e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n    }\n\n    public int engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLength,\n        byte[] output,\n        int outputOffset)\n        throws ShortBufferException, IllegalBlockSizeException, BadPaddingException\n    {\n\n        byte[] buf = engineDoFinal(input, inputOffset, inputLength);\n        System.arraycopy(buf, 0, output, outputOffset, buf.length);\n        return buf.length;\n    }\n\n    /**\n     * Classes that inherit from us\n     */\n\n    static public class ECIES\n        extends IESCipher\n    {\n        public ECIES()\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest())));\n        }\n    }\n\n    static public class ECIESwithCipher\n        extends IESCipher\n    {\n        public ECIESwithCipher(BlockCipher cipher)\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                            new KDF2BytesGenerator(new SHA1Digest()),\n                            new HMac(new SHA1Digest()),\n                            new PaddedBufferedBlockCipher(cipher)));\n        }\n\n        public ECIESwithCipher(BlockCipher cipher, int ivLength)\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                            new KDF2BytesGenerator(new SHA1Digest()),\n                            new HMac(new SHA1Digest()),\n                            new PaddedBufferedBlockCipher(cipher)), ivLength);\n        }\n    }\n\n    static public class ECIESwithDESede\n        extends ECIESwithCipher\n    {\n        public ECIESwithDESede()\n        {\n            super(new DESedeEngine());\n        }\n    }\n\n    static public class ECIESwithAES\n        extends ECIESwithCipher\n    {\n        public ECIESwithAES()\n        {\n            super(new AESEngine());\n        }\n    }\n\n    static public class ECIESwithDESedeCBC\n        extends ECIESwithCipher\n    {\n        public ECIESwithDESedeCBC()\n        {\n            super(new CBCBlockCipher(new DESedeEngine()), 8);\n        }\n    }\n\n    static public class ECIESwithAESCBC\n        extends ECIESwithCipher\n    {\n        public ECIESwithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESEngine()), 16);\n        }\n    }\n\n    /**\n     * Backwards compatibility\n     */\n    static public class OldECIES\n        extends IESCipher\n    {\n        public OldECIES()\n        {\n            super(new OldIESEngine(new ECDHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest())));\n        }\n    }\n\n    static public class OldECIESwithCipher\n        extends IESCipher\n    {\n        public OldECIESwithCipher(BlockCipher baseCipher)\n        {\n            super(new OldIESEngine(new ECDHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(baseCipher)));\n        }\n\n        public OldECIESwithCipher(BlockCipher baseCipher, int ivLength)\n        {\n            super(new OldIESEngine(new ECDHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(baseCipher)), ivLength);\n        }\n    }\n\n    static public class OldECIESwithDESede\n        extends OldECIESwithCipher\n    {\n        public OldECIESwithDESede()\n        {\n            super(new DESedeEngine());\n        }\n    }\n\n    static public class OldECIESwithAES\n        extends OldECIESwithCipher\n    {\n        public OldECIESwithAES()\n        {\n            super(new AESEngine());\n        }\n    }\n\n    static public class OldECIESwithDESedeCBC\n        extends OldECIESwithCipher\n    {\n        public OldECIESwithDESedeCBC()\n        {\n            super(new CBCBlockCipher(new DESedeEngine()), 8);\n        }\n    }\n\n    static public class OldECIESwithAESCBC\n        extends OldECIESwithCipher\n    {\n        public OldECIESwithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESEngine()), 16);\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.ies;\n\nimport java.io.IOException;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\n\nimport org.bouncycastle.asn1.ASN1EncodableVector;\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1OctetString;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.ASN1TaggedObject;\nimport org.bouncycastle.asn1.DEROctetString;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.DERTaggedObject;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\n\npublic class AlgorithmParametersSpi\n    extends java.security.AlgorithmParametersSpi\n{\n    protected boolean isASN1FormatString(String format)\n    {\n        return format == null || format.equals(\"ASN.1\");\n    }\n\n    protected AlgorithmParameterSpec engineGetParameterSpec(\n        Class paramSpec)\n        throws InvalidParameterSpecException\n    {\n        if (paramSpec == null)\n        {\n            throw new NullPointerException(\"argument to getParameterSpec must not be null\");\n        }\n\n        return localEngineGetParameterSpec(paramSpec);\n    }\n\n    IESParameterSpec currentSpec;\n\n    /**\n     * in the absence of a standard way of doing it this will do for\n     * now...\n     */\n    protected byte[] engineGetEncoded()\n    {\n        try\n        {\n            ASN1EncodableVector v = new ASN1EncodableVector();\n\n            if (currentSpec.getDerivationV() != null)\n            {\n                v.add(new DERTaggedObject(false, 0, new DEROctetString(currentSpec.getDerivationV())));\n            }\n            if (currentSpec.getEncodingV() != null)\n            {\n                v.add(new DERTaggedObject(false, 1, new DEROctetString(currentSpec.getEncodingV())));\n            }\n            v.add(new ASN1Integer(currentSpec.getMacKeySize()));\n\n            return new DERSequence(v).getEncoded(ASN1Encoding.DER);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Error encoding IESParameters\");\n        }\n    }\n\n    protected byte[] engineGetEncoded(\n        String format)\n    {\n        if (isASN1FormatString(format) || format.equalsIgnoreCase(\"X.509\"))\n        {\n            return engineGetEncoded();\n        }\n\n        return null;\n    }\n\n    protected AlgorithmParameterSpec localEngineGetParameterSpec(\n        Class paramSpec)\n        throws InvalidParameterSpecException\n    {\n        if (paramSpec == IESParameterSpec.class || paramSpec == AlgorithmParameterSpec.class)\n        {\n            return currentSpec;\n        }\n\n        throw new InvalidParameterSpecException(\"unknown parameter spec passed to ElGamal parameters object.\");\n    }\n\n    protected void engineInit(\n        AlgorithmParameterSpec paramSpec)\n        throws InvalidParameterSpecException\n    {\n        if (!(paramSpec instanceof IESParameterSpec))\n        {\n            throw new InvalidParameterSpecException(\"IESParameterSpec required to initialise a IES algorithm parameters object\");\n        }\n\n        this.currentSpec = (IESParameterSpec)paramSpec;\n    }\n\n    protected void engineInit(\n        byte[] params)\n        throws IOException\n    {\n        try\n        {\n            ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(params);\n\n            if (s.size() == 1)\n            {\n                this.currentSpec = new IESParameterSpec(null, null, ASN1Integer.getInstance(s.getObjectAt(0)).getValue().intValue());\n            }\n            else if (s.size() == 2)\n            {\n                ASN1TaggedObject tagged = ASN1TaggedObject.getInstance(s.getObjectAt(0));\n\n                if (tagged.getTagNo() == 0)\n                {\n                    this.currentSpec = new IESParameterSpec(ASN1OctetString.getInstance(tagged, false).getOctets(), null, ASN1Integer.getInstance(s.getObjectAt(1)).getValue().intValue());\n                }\n                else\n                {\n                    this.currentSpec = new IESParameterSpec(null, ASN1OctetString.getInstance(tagged, false).getOctets(), ASN1Integer.getInstance(s.getObjectAt(1)).getValue().intValue());\n                }\n            }\n            else\n            {\n                ASN1TaggedObject tagged1 = ASN1TaggedObject.getInstance(s.getObjectAt(0));\n                ASN1TaggedObject tagged2 = ASN1TaggedObject.getInstance(s.getObjectAt(1));\n\n                this.currentSpec = new IESParameterSpec(ASN1OctetString.getInstance(tagged1, false).getOctets(), ASN1OctetString.getInstance(tagged2, false).getOctets(), ASN1Integer.getInstance(s.getObjectAt(2)).getValue().intValue());\n            }\n        }\n        catch (ClassCastException e)\n        {\n            throw new IOException(\"Not a valid IES Parameter encoding.\");\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new IOException(\"Not a valid IES Parameter encoding.\");\n        }\n    }\n\n    protected void engineInit(\n        byte[] params,\n        String format)\n        throws IOException\n    {\n        if (isASN1FormatString(format) || format.equalsIgnoreCase(\"X.509\"))\n        {\n            engineInit(params);\n        }\n        else\n        {\n            throw new IOException(\"Unknown parameter format \" + format);\n        }\n    }\n\n    protected String engineToString()\n    {\n        return \"IES Parameters\";\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.util;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\n\npublic class IESUtil\n{\n    public static IESParameterSpec guessParameterSpec(BufferedBlockCipher iesBlockCipher)\n    {\n        if (iesBlockCipher == null)\n        {\n            return new IESParameterSpec(null, null, 128);\n        }\n        else\n        {\n            BlockCipher underlyingCipher = iesBlockCipher.getUnderlyingCipher();\n\n            if (underlyingCipher.getAlgorithmName().equals(\"DES\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC2\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC5-32\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC5-64\"))\n            {\n                return new IESParameterSpec(null, null, 64, 64);\n            }\n            else if (underlyingCipher.getAlgorithmName().equals(\"SKIPJACK\"))\n            {\n                return new IESParameterSpec(null, null, 80, 80);\n            }\n            else if (underlyingCipher.getAlgorithmName().equals(\"GOST28147\"))\n            {\n                return new IESParameterSpec(null, null, 256, 256);\n            }\n\n            return new IESParameterSpec(null, null, 128, 128);\n        }\n    }\n}\n", "package org.bouncycastle.jce.spec;\n\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Parameter spec for an integrated encryptor, as in IEEE P1363a\n */\npublic class IESParameterSpec\n    implements AlgorithmParameterSpec\n{\n    private byte[] derivation;\n    private byte[] encoding;\n    private int macKeySize;\n    private int cipherKeySize;\n    private byte[] nonce;\n    private boolean usePointCompression;\n\n\n    /**\n     * Set the IES engine parameters.\n     *\n     * @param derivation the optional derivation vector for the KDF.\n     * @param encoding   the optional encoding vector for the KDF.\n     * @param macKeySize the key size (in bits) for the MAC.\n     */\n    public IESParameterSpec(\n        byte[] derivation,\n        byte[] encoding,\n        int macKeySize)\n    {\n        this(derivation, encoding, macKeySize, -1, null, false);\n    }\n\n\n    /**\n     * Set the IES engine parameters.\n     *\n     * @param derivation    the optional derivation vector for the KDF.\n     * @param encoding      the optional encoding vector for the KDF.\n     * @param macKeySize    the key size (in bits) for the MAC.\n     * @param cipherKeySize the key size (in bits) for the block cipher.\n     */\n    public IESParameterSpec(\n        byte[] derivation,\n        byte[] encoding,\n        int macKeySize,\n        int cipherKeySize)\n    {\n        this(derivation, encoding, macKeySize, cipherKeySize, null, false);\n    }\n\n    /**\n     * Set the IES engine parameters.\n     *\n     * @param derivation    the optional derivation vector for the KDF.\n     * @param encoding      the optional encoding vector for the KDF.\n     * @param macKeySize    the key size (in bits) for the MAC.\n     * @param cipherKeySize the key size (in bits) for the block cipher.\n     * @param nonce         an IV to use initialising the block cipher.\n     */\n    public IESParameterSpec(\n        byte[] derivation,\n        byte[] encoding,\n        int macKeySize,\n        int cipherKeySize,\n        byte[] nonce)\n    {\n        this(derivation, encoding, macKeySize, cipherKeySize, nonce, false);\n    }\n\n    /**\n     * Set the IES engine parameters.\n     *\n     * @param derivation    the optional derivation vector for the KDF.\n     * @param encoding      the optional encoding vector for the KDF.\n     * @param macKeySize    the key size (in bits) for the MAC.\n     * @param cipherKeySize the key size (in bits) for the block cipher.\n     * @param nonce         an IV to use initialising the block cipher.\n     * @param usePointCompression whether to use EC point compression or not (false by default)\n     */\n    public IESParameterSpec(\n        byte[] derivation,\n        byte[] encoding,\n        int macKeySize,\n        int cipherKeySize,\n        byte[] nonce,\n        boolean usePointCompression)\n    {\n        if (derivation != null)\n        {\n            this.derivation = new byte[derivation.length];\n            System.arraycopy(derivation, 0, this.derivation, 0, derivation.length);\n        }\n        else\n        {\n            this.derivation = null;\n        }\n\n        if (encoding != null)\n        {\n            this.encoding = new byte[encoding.length];\n            System.arraycopy(encoding, 0, this.encoding, 0, encoding.length);\n        }\n        else\n        {\n            this.encoding = null;\n        }\n\n        this.macKeySize = macKeySize;\n        this.cipherKeySize = cipherKeySize;\n        this.nonce = Arrays.clone(nonce);\n        this.usePointCompression = usePointCompression;\n    }\n\n    /**\n     * return the derivation vector.\n     */\n    public byte[] getDerivationV()\n    {\n        return Arrays.clone(derivation);\n    }\n\n    /**\n     * return the encoding vector.\n     */\n    public byte[] getEncodingV()\n    {\n        return Arrays.clone(encoding);\n    }\n\n    /**\n     * return the key size in bits for the MAC used with the message\n     */\n    public int getMacKeySize()\n    {\n        return macKeySize;\n    }\n\n    /**\n     * return the key size in bits for the block cipher used with the message\n     */\n    public int getCipherKeySize()\n    {\n        return cipherKeySize;\n    }\n\n    /**\n     * Return the nonce (IV) value to be associated with message.\n     *\n     * @return block cipher IV for message.\n     */\n    public byte[] getNonce()\n    {\n        return Arrays.clone(nonce);\n    }\n\n    /**\n     * Set the 'point compression' flag.\n     */\n    public void setPointCompression(boolean usePointCompression)\n    {\n        this.usePointCompression = usePointCompression;\n    }\n\n    /**\n     * Return the 'point compression' flag.\n     *\n     * @return the point compression flag\n     */\n    public boolean getPointCompression()\n    {\n        return usePointCompression;\n    }\n}", "package org.bouncycastle.jce.provider.test;\n\nimport java.math.BigInteger;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.SecureRandom;\nimport java.security.Security;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHParameterSpec;\n\nimport org.bouncycastle.crypto.agreement.DHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.DESEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\n/**\n * Test for DHIES - Diffie-Hellman Integrated Encryption Scheme\n */\npublic class DHIESTest\n    extends SimpleTest\n{\n    // Oakley group 2 - RFC 5996\n    BigInteger p1024 = new BigInteger(\n                    \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\" +\n                    \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\" +\n                    \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\" +\n                    \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\" +\n                    \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381\" +\n                    \"FFFFFFFFFFFFFFFF\",16);\n\n    BigInteger g1024 = new BigInteger(\"2\",16);\n\n    DHParameterSpec param = new DHParameterSpec(p1024, g1024);\n\n    DHIESTest()\n    {\n    }\n\n    public String getName()\n    {\n        return \"DHIES\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        byte[] derivation = Hex.decode(\"202122232425262728292a2b2c2d2e2f\");\n        byte[] encoding   = Hex.decode(\"303132333435363738393a3b3c3d3e3f\");\n\n        \n        IESCipher c1 = new org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher.IES();\n        IESCipher c2 = new org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher.IES();\n        IESParameterSpec params = new IESParameterSpec(derivation,encoding,128);\n\n        // Testing DHIES with default prime in streaming mode\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        g.initialize(param);\n\n        doTest(\"DHIES with default\", g, \"DHIES\", params);\n        \n        // Testing DHIES with 512-bit prime in streaming mode\n        g.initialize(512, new SecureRandom());\n        doTest(\"DHIES with 512-bit\", g, \"DHIES\", params);\n\n        // Testing ECIES with 1024-bit prime in streaming mode \n        g.initialize(1024, new SecureRandom());\n        doTest(\"DHIES with 1024-bit\", g, \"DHIES\", params);\n\n        c1 = new IESCipher(new IESEngine(new DHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));\n        \n        c2 = new IESCipher(new IESEngine(new DHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));  \n    \n        params = new IESParameterSpec(derivation, encoding, 128, 192);\n      \n        // Testing DHIES with default prime using DESEDE\n        g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        doTest(\"DHIESwithDES default\", g, \"DHIESwithDESEDE\", params);\n        \n        // Testing DHIES with 512-bit prime using DESEDE\n        g.initialize(512, new SecureRandom());\n        doTest(\"DHIESwithDES 512-bit\", g, \"DHIESwithDESEDE\", params);\n        \n        // Testing DHIES with 1024-bit prime using DESEDE\n        g.initialize(1024, new SecureRandom());\n        doTest(\"DHIESwithDES 1024-bit\", g, \"DHIESwithDESEDE\", params);\n\n        g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        g.initialize(param);\n\n        c1 = new IESCipher.IESwithAES();\n        c2 = new IESCipher.IESwithAES();\n        params = new IESParameterSpec(derivation, encoding, 128, 128);\n        \n        // Testing DHIES with default curve using AES\n        doTest(\"DHIESwithAES default\", g, \"DHIESwithAES\", params);\n        \n        // Testing DHIES with 512-bit curve using AES\n        g.initialize(512, new SecureRandom());\n        doTest(\"DHIESwithAES 512-bit\", g, \"DHIESwithAES\", params);\n        \n        // Testing DHIES with 1024-bit curve using AES\n        g.initialize(1024, new SecureRandom());\n        doTest(\"DHIESwithAES 1024-bit\", g, \"DHIESwithAES\", params);\n        \n    }\n\n    public void doTest(\n        String                testname,\n        KeyPairGenerator     g,\n        String              cipher,\n        IESParameterSpec    p)\n        throws Exception\n    {\n        \n        byte[] message = Hex.decode(\"0102030405060708090a0b0c0d0e0f10111213141516\");\n        byte[] out1, out2;\n  \n        Cipher        c1 = Cipher.getInstance(cipher, \"BC\");\n        Cipher        c2 = Cipher.getInstance(cipher, \"BC\");\n        // Generate static key pair\n        KeyPair       keyPair = g.generateKeyPair();\n        DHPublicKey   pub = (DHPublicKey)keyPair.getPublic();\n        DHPrivateKey  priv = (DHPrivateKey)keyPair.getPrivate();\n       \n\n        // Testing with null parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, new SecureRandom());\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n        {\n            fail(testname + \" test failed with null parameters, DHAES mode false.\");\n        }\n    \n        \n        // Testing with given parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, p, new SecureRandom());\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode false.\");\n        \n        // Testing with null parameters and DHAES mode on\n        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c1.init(Cipher.ENCRYPT_MODE, pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, new SecureRandom());\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with null parameters, DHAES mode true.\");\n     \n        \n        // Testing with given parameters and DHAES mode on\n        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n\n        c1.init(Cipher.ENCRYPT_MODE, pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, p, new SecureRandom());\n\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode true.\");\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DHIESTest());\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.spec.ECGenParameterSpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SealedObject;\n\nimport org.bouncycastle.crypto.agreement.ECDHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.DESEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher;\nimport org.bouncycastle.jce.interfaces.ECPrivateKey;\nimport org.bouncycastle.jce.interfaces.ECPublicKey;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\n/**\n * Test for ECIES - Elliptic Curve Integrated Encryption Scheme\n */\npublic class ECIESTest\n    extends SimpleTest\n{\n\n    ECIESTest()\n    {\n    }\n\n    public String getName()\n    {\n        return \"ECIES\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        byte[] derivation = Hex.decode(\"202122232425262728292a2b2c2d2e2f\");\n        byte[] encoding   = Hex.decode(\"303132333435363738393a3b3c3d3e3f\");\n        \n        \n        IESCipher c1 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIES();\n        IESCipher c2 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIES();\n        IESParameterSpec params = new IESParameterSpec(derivation,encoding,128);\n\n        // Testing ECIES with default curve in streaming mode\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        doTest(\"ECIES with default\", g, \"ECIES\", params);\n        \n        // Testing ECIES with 192-bit curve in streaming mode \n        g.initialize(192, new SecureRandom());\n        doTest(\"ECIES with 192-bit\", g, \"ECIES\", params);\n\n        // Testing ECIES with 256-bit curve in streaming mode \n        g.initialize(256, new SecureRandom());\n        doTest(\"ECIES with 256-bit\", g, \"ECIES\", params);\n\n        \n        c1 = new IESCipher(new IESEngine(new ECDHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));\n        \n        c2 = new IESCipher(new IESEngine(new ECDHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));  \n    \n        params = new IESParameterSpec(derivation, encoding, 128, 128);\n      \n        // Testing ECIES with default curve using DES\n        g = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        doTest(\"default\", g, \"ECIESwithDESEDE\", params);\n        \n        // Testing ECIES with 192-bit curve using DES\n        g.initialize(192, new SecureRandom());\n        doTest(\"192-bit\", g, \"ECIESwithDESEDE\", params);\n        \n        // Testing ECIES with 256-bit curve using DES\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithDESEDE\", params);\n\n        // Testing ECIES with 256-bit curve using DES-CBC\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"0001020304050607\"));\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n\n        try\n        {\n            params = new IESParameterSpec(derivation, encoding, 128, 128, new byte[10]);\n            g.initialize(256, new SecureRandom());\n            doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n            fail(\"DESEDE no exception!\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!e.getMessage().equals(\"NONCE in IES Parameters needs to be 8 bytes long\"))\n            {\n                fail(\"DESEDE wrong message!\");\n            }\n        }\n\n        c1 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIESwithAES();\n        c2 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIESwithAES();\n        params = new IESParameterSpec(derivation, encoding, 128, 128);\n        \n        // Testing ECIES with default curve using AES \n        g = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        doTest(\"default\", g, \"ECIESwithAES\", params);\n        \n        // Testing ECIES with 192-bit curve using AES\n        g.initialize(192, new SecureRandom());\n        doTest(\"192-bit\", g, \"ECIESwithAES\", params);\n        \n        // Testing ECIES with 256-bit curve using AES\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithAES\", params);\n\n        // Testing ECIES with 256-bit curve using AES-CBC\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"000102030405060708090a0b0c0d0e0f\"));\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n\n        try\n        {\n            params = new IESParameterSpec(derivation, encoding, 128, 128, new byte[10]);\n            g.initialize(256, new SecureRandom());\n            doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n            fail(\"AES no exception!\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!e.getMessage().equals(\"NONCE in IES Parameters needs to be 16 bytes long\"))\n            {\n                fail(\"AES wrong message!\");\n            }\n        }\n\n        sealedObjectTest();\n    }\n\n    private void sealedObjectTest()\n        throws Exception\n    {\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECIES\");\n        kpg.initialize(new ECGenParameterSpec(\"secp256r1\"));\n        KeyPair keyPair = kpg.generateKeyPair();\n\n        Cipher cipher = Cipher.getInstance(\"ECIES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n\n        String toEncrypt = \"Hello\";\n\n        // Check that cipher works ok\n        cipher.doFinal(toEncrypt.getBytes());\n\n        // Using a SealedObject to encrypt the same string fails with a NullPointerException\n        SealedObject sealedObject = new SealedObject(toEncrypt, cipher);\n\n        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n\n        String result = (String)sealedObject.getObject(cipher);\n\n        isTrue(\"result wrong\", result.equals(toEncrypt));\n\n        result = (String)sealedObject.getObject(keyPair.getPrivate());\n\n        isTrue(\"result wrong\", result.equals(toEncrypt));\n    }\n\n    public void doTest(\n        String                testname,\n        KeyPairGenerator     g,\n        String              cipher,\n        IESParameterSpec    p)\n        throws Exception\n    {\n\n        byte[] message = Hex.decode(\"0102030405060708090a0b0c0d0e0f10111213141516\");\n        byte[] out1, out2;\n\n        // Generate static key pair\n        KeyPair     KeyPair = g.generateKeyPair();\n        ECPublicKey   Pub = (ECPublicKey) KeyPair.getPublic();\n        ECPrivateKey  Priv = (ECPrivateKey) KeyPair.getPrivate();\n\n        Cipher c1 = Cipher.getInstance(cipher);\n        Cipher c2 = Cipher.getInstance(cipher);\n\n        // Testing with null parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, Priv, new SecureRandom());\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with null parameters, DHAES mode false.\");\n    \n        \n        // Testing with given parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, Priv, p, new SecureRandom());\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode false.\");\n        \n\n// TODO: DHAES mode is not currently implemented, perhaps it shouldn't be...\n//        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n//        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n//\n//        // Testing with null parameters and DHAES mode on\n//        c1.init(Cipher.ENCRYPT_MODE, Pub, new SecureRandom());\n//        c2.init(Cipher.DECRYPT_MODE, Priv, new SecureRandom());\n//\n//        out1 = c1.doFinal(message, 0, message.length);\n//        out2 = c2.doFinal(out1, 0, out1.length);\n//        if (!areEqual(out2, message))\n//            fail(testname + \" test failed with null parameters, DHAES mode true.\");\n//\n//        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\");\n//        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\");\n//\n//        // Testing with given parameters and DHAES mode on\n//        c1.init(Cipher.ENCRYPT_MODE, Pub, p, new SecureRandom());\n//        c2.init(Cipher.DECRYPT_MODE, Priv, p, new SecureRandom());\n//\n//        out1 = c1.doFinal(message, 0, message.length);\n//        out2 = c2.doFinal(out1, 0, out1.length);\n//        if (!areEqual(out2, message))\n//            fail(testname + \" test failed with non-null parameters, DHAES mode true.\");\n        \n    }\n\n   \n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECIESTest());\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.Security;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.Cipher;\n\nimport org.bouncycastle.crypto.prng.FixedSecureRandom;\nimport org.bouncycastle.jce.interfaces.ECPrivateKey;\nimport org.bouncycastle.jce.interfaces.ECPublicKey;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\n/**\n * Test for ECIES - Elliptic Curve Integrated Encryption Scheme\n */\npublic class ECIESVectorTest\n    extends SimpleTest\n{\n    static byte[] message = Hex.decode(\"0102030405060708090a0b0c0d0e0f10111213141516\");\n\n    static byte[] derivation1 = Hex.decode(\"202122232425262728292a2b2c2d2e2f\");\n    static byte[] derivation2 = Hex.decode(\"202122232425262728292a2b2c2d2e2f404142434445464748\");\n\n    static byte[] encoding1 = Hex.decode(\"af\");\n    static byte[] encoding2 = Hex.decode(\"303132333435363738393a3b3c3d3e3f\");\n    static byte[] encoding3 = Hex.decode(\"101112131415161718191a1b1c1d1e1f303132333435363738393a3b3c3d3e3f\");\n\n    static byte[] p256_1_pub = Base64.decode(\"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEGVoxUX5AiyggqzcaXG3yG6cH6PKSX6fVOnCo5SKolfR8kwc6S8zmADXlpnjzMLNUVvGDL805VKIXNJHijq4+gw==\");\n    static byte[] p256_1_pri = Base64.decode(\"MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQg+dn4oLSJcx5lxZhVxJCip13O/OblrNzNyCj2b9sNbQegCgYIKoZIzj0DAQehRANCAAQZWjFRfkCLKCCrNxpcbfIbpwfo8pJfp9U6cKjlIqiV9HyTBzpLzOYANeWmePMws1RW8YMvzTlUohc0keKOrj6D\");\n    static byte[] p256_1_eph = Hex.decode(\"35ee388194396b5febbddb7e3618eaaba44f3bae766dac70f75ae7b84b210948\");\n\n    static byte[] p256_1_no_params = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae43dfbe605c746ba0c546c0c25ba5a00304587fbed07a35ca06415cf6ad4d6a69d01122c99e2c854fe818f\");\n\n    static byte[] p256_1_with_params11 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a33c5d1948ee93ea5dc7577d42d7c2e41ab08f85835\");\n    static byte[] p256_1_with_params12 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a3394725300acb7855f71a149d3f51a2e6fbd7f5389\");\n    static byte[] p256_1_with_params13 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a33920872328f8d05ec561ba8c6e58d82b79c360078\");\n    static byte[] p256_1_with_params21 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4499a4f4b6726651fb5e88178f01d831d9e5be0c1\");\n    static byte[] p256_1_with_params22 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df457c384a0e6402a5bb073120f08c706b49a4775d0\");\n    static byte[] p256_1_with_params23 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4039427c24c55a2627df0ebea00f9d1eded9dd64b\");\n\n    static byte[] p256_2_pub = Base64.decode(\"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAER4gx8nnRAkP+u76j0COZD81Cu9CTw3vczLnu1DG7ObI/VCzrDzJuswfzNWmxOFYXiXmZMAAkkEFA40nDSGOoqA==\");\n    static byte[] p256_2_pri = Base64.decode(\"MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgkflw6MQj4RbyuPFHoDE3i1dEaROS9uDSjGvrvPjqL7mgCgYIKoZIzj0DAQehRANCAARHiDHyedECQ/67vqPQI5kPzUK70JPDe9zMue7UMbs5sj9ULOsPMm6zB/M1abE4VheJeZkwACSQQUDjScNIY6io\");\n    static byte[] p256_2_eph = Hex.decode(\"0c37e1e0559a60d0b9c5b7b139a3f2df022b23abbd194bd95c8eff0aab1fd544\");\n\n    static byte[] p256_2_no_params = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dacd99a5cadfe82652a18c6058fc5ef7ffca626235fdbf7e2537f494d049d6f4e53d3d3df489cefb31101e1\");\n\n    static byte[] p256_2_with_params11 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dace0e423753f63e054824edbc298a5645d7a4010cc7e65947090625dc0d750c50b2d563f264718d95818d4\");\n    static byte[] p256_2_with_params12 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dace0e423753f63e054824edbc298a5645d7a4010cc7e6502850f65c7a2c466444dea69d95a2df9a4b6cf2c\");\n    static byte[] p256_2_with_params13 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dace0e423753f63e054824edbc298a5645d7a4010cc7e651188a654e47322a60e53ea20a9e02f0e78bf8a32\");\n    static byte[] p256_2_with_params21 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dacdbdbe5e5f72245f4b5c28ee1ae21442868aef592d4047c8149babf4e7faffb5474bd6d84d6b9f1c9faf5\");\n    static byte[] p256_2_with_params22 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dacdbdbe5e5f72245f4b5c28ee1ae21442868aef592d40471190bd9b4bddd63983e4963378c9f55c703a7e6\");\n    static byte[] p256_2_with_params23 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dacdbdbe5e5f72245f4b5c28ee1ae21442868aef592d404ca4307e077a693c6410815c7985b0678a42cbd84\");\n    \n    static byte[] p521_1_pub = Base64.decode(\"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBLNtLEbQBq2YGA2Q+eCwulIDggr1dCj8CqY/Yj/HuzicYGmVkNpr/gRfZHX4FRrh9HsGrS7tW+UA1pCQmn3p3aeEADiaXGIybDBsnuU20xntomQG/d/OHDkEaPee9nFNbi9Oha7BHTA/x2yyLMhQHeUlMgjz0DQqRxrwGJmvI85eNZpM=\");\n    static byte[] p521_1_pri = Base64.decode(\"MIH3AgEAMBAGByqGSM49AgEGBSuBBAAjBIHfMIHcAgEBBEIA1QAfnUvK1fAaENAArV0YnNGvnu2H1vGHNgsG3QV7p16gjd6UOgmGCZVM9SLlRH3fi9K1Xreyl4sQH3NeY+ZnInqgBwYFK4EEACOhgYkDgYYABAEs20sRtAGrZgYDZD54LC6UgOCCvV0KPwKpj9iP8e7OJxgaZWQ2mv+BF9kdfgVGuH0ewatLu1b5QDWkJCafendp4QAOJpcYjJsMGye5TbTGe2iZAb9384cOQRo9572cU1uL06FrsEdMD/HbLIsyFAd5SUyCPPQNCpHGvAYma8jzl41mkw==\");\n    static byte[] p521_1_eph = Hex.decode(\"d25c44819712555824360eef5afda947373ec462c2a0fd5bebbe0b0e4e40b4ebf483bc5b5eeb84542fc226dc2e5307ceec59fe7c557522b77589210b434295aabfc7\");\n\n    static byte[] p521_1_no_params = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7ee2102423e67f5ee7f46e87a26370b7734548f3baee7729c5ff1c1638b93f068628320c7c56b7a68fb86d\");\n\n    static byte[] p521_1_with_params11 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e49225382108fb5bdd6b4ad57fee63c2819d10c1bc7517bd0a5070c123d4e24d66f9f0bf21ec105629cb2\");\n    static byte[] p521_1_with_params12 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e49225382108fb5bdd6b4ad57fee63c2819d10c1bc751a51c6c78d905b0b7702d2edf89d0cf30f0d21c93\");\n    static byte[] p521_1_with_params13 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e49225382108fb5bdd6b4ad57fee63c2819d10c1bc7513a9fb7f21f78ef3467b54153b8e2998de5f46724\");\n    static byte[] p521_1_with_params21 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e1e0e7ac9ade1646519a365ef578f0bbe3556a818c83a0ce6226db7a3f3964e7a18955f9150fb030dcb09\");\n    static byte[] p521_1_with_params22 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e1e0e7ac9ade1646519a365ef578f0bbe3556a818c83ade9180b72d7d2e9218395ea7d83c00cf03c6b39d\");\n    static byte[] p521_1_with_params23 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e1e0e7ac9ade1646519a365ef578f0bbe3556a818c83a605f2a4ef486f9215e546d618eb7624443ee1a7d\");\n\n    static byte[] p521_2_pub = Base64.decode(\"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQACXj0hmGm68PQxI12y5sKMn4mN6mIMOEn1l6PBOeGtk8QuJHt1AS3X5DcPorJTxhuhdcdDHA3if1utfAw9hl7tCIBQELwgw2Vo3gYkdbG7Hj6O9kf8WpqIEJ3UsC4S0hITMY1knO41BaO4UdO+nUiN+PZPRRSqFwm3C5v3fffLSGbpIQ=\");\n    static byte[] p521_2_pri = Base64.decode(\"MIH3AgEAMBAGByqGSM49AgEGBSuBBAAjBIHfMIHcAgEBBEIB6s6VR/8WgiOvSjHT/n5Y91wESyI9e4GABUNWMXMPhNspwb9++7fyanbeliHNz9K61SjDG7rLXs90K1iRvHPJwmygBwYFK4EEACOhgYkDgYYABAAJePSGYabrw9DEjXbLmwoyfiY3qYgw4SfWXo8E54a2TxC4ke3UBLdfkNw+islPGG6F1x0McDeJ/W618DD2GXu0IgFAQvCDDZWjeBiR1sbsePo72R/xamogQndSwLhLSEhMxjWSc7jUFo7hR076dSI349k9FFKoXCbcLm/d998tIZukhA==\");\n    static byte[] p521_2_eph = Hex.decode(\"c9ee178c7f200a51a0053931c697001205f8923fd04b538c3fd5df2be43a6f304581f57138906bba0be631f7e0fd2804d00b5cb053559f080c13c913358f6e1fcc6d\");\n\n    static byte[] p521_2_no_params = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace65922842dba0351c1cebde53ee4ba9afadbd3a03a88507046f62c7383f96142c09df58be5b0a661893d41\");\n\n    static byte[] p521_2_with_params11 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace674ccf084d69e0bc9a728548d887a162ddf53a0002ed034b51a5406b831ce9ea713be7df54934b77dcc84\");\n    static byte[] p521_2_with_params12 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace674ccf084d69e0bc9a728548d887a162ddf53a0002ed0767534663184e99c0958451ea417729e29e02a60\");\n    static byte[] p521_2_with_params13 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace674ccf084d69e0bc9a728548d887a162ddf53a0002ed0517e1040bf7d57f2c8f9c3ce69e5a05a9a292700\");\n    static byte[] p521_2_with_params21 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace68a9e28bb5d49c07d5f5f59a27311619103aea50e48ddc66e0f20686c8d0c329db510facc1c014f800920\");\n    static byte[] p521_2_with_params22 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace68a9e28bb5d49c07d5f5f59a27311619103aea50e48ddbc970a66c80886782713e25ece75a23dec995121\");\n    static byte[] p521_2_with_params23 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace68a9e28bb5d49c07d5f5f59a27311619103aea50e48dd7c3d8a51a95f88813d04a0c681355f6e86bb44e5\");\n\n    static byte[] old_p256_1_no_params = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae43dfbe605c746ba0c546c0c25ba5a00304587fbed07a3ebe44837c43b86025cc08e333b1631a8227b8d49\");\n\n    static byte[] old_p256_1_with_params11 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a332ce23d272262d47a528057eb5b0b11631707b28f\");\n    static byte[] old_p256_1_with_params12 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a3331e3e514868c771270632c9a9b852f2060d415da\");\n    static byte[] old_p256_1_with_params13 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a3353e10e6260e937bcdd244201a0de1d3941439076\");\n    static byte[] old_p256_1_with_params21 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4912a36ccc3c49de7d3d6b1fb312aeacf2d0b30e7\");\n    static byte[] old_p256_1_with_params22 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4171c056b90a3badd0bb689403ab214546b5f6411\");\n    static byte[] old_p256_1_with_params23 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4ad1a6a561fe0582495cd14ac4494e4610ecddef1\");\n\n    ECIESVectorTest()\n    {\n    }\n\n    public String getName()\n    {\n        return \"ECIESVectorTest\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        KeyFactory ecFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        KeyPair keyPair = new KeyPair(ecFact.generatePublic(new X509EncodedKeySpec(p256_1_pub)), ecFact.generatePrivate(new PKCS8EncodedKeySpec(p256_1_pri)));\n\n        doTestNoParams(\"ECIES with P-256 None\", keyPair, \"ECIES\", p256_1_eph, p256_1_no_params);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding1, 128), p256_1_with_params11);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding2, 128), p256_1_with_params12);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding3, 128), p256_1_with_params13);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding1, 128), p256_1_with_params21);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding2, 128), p256_1_with_params22);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding3, 128), p256_1_with_params23);\n\n        doTestNoParams(\"ECIES with P-256 None\", keyPair, \"OldECIES\", p256_1_eph, old_p256_1_no_params);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding1, 128), old_p256_1_with_params11);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding2, 128), old_p256_1_with_params12);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding3, 128), old_p256_1_with_params13);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding1, 128), old_p256_1_with_params21);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding2, 128), old_p256_1_with_params22);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding3, 128), old_p256_1_with_params23);\n\n        keyPair = new KeyPair(ecFact.generatePublic(new X509EncodedKeySpec(p256_2_pub)), ecFact.generatePrivate(new PKCS8EncodedKeySpec(p256_2_pri)));\n\n        doTestNoParams(\"ECIES with P-256 None\", keyPair, \"ECIES\", p256_2_eph, p256_2_no_params);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation1, encoding1, 128), p256_2_with_params11);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation1, encoding2, 128), p256_2_with_params12);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation1, encoding3, 128), p256_2_with_params13);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation2, encoding1, 128), p256_2_with_params21);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation2, encoding2, 128), p256_2_with_params22);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation2, encoding3, 128), p256_2_with_params23);\n\n        keyPair = new KeyPair(ecFact.generatePublic(new X509EncodedKeySpec(p521_1_pub)), ecFact.generatePrivate(new PKCS8EncodedKeySpec(p521_1_pri)));\n\n        doTestNoParams(\"ECIES with P-521 None\", keyPair, \"ECIES\", p521_1_eph, p521_1_no_params);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation1, encoding1, 128), p521_1_with_params11);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation1, encoding2, 128), p521_1_with_params12);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation1, encoding3, 128), p521_1_with_params13);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation2, encoding1, 128), p521_1_with_params21);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation2, encoding2, 128), p521_1_with_params22);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation2, encoding3, 128), p521_1_with_params23);\n\n        keyPair = new KeyPair(ecFact.generatePublic(new X509EncodedKeySpec(p521_2_pub)), ecFact.generatePrivate(new PKCS8EncodedKeySpec(p521_2_pri)));\n\n        doTestNoParams(\"ECIES with default\", keyPair, \"ECIES\", p521_2_eph, p521_2_no_params);\n        doTestWithParams(\"ECIES with P-521 KP2 P11\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation1, encoding1, 128), p521_2_with_params11);\n        doTestWithParams(\"ECIES with P-521 KP2 P12\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation1, encoding2, 128), p521_2_with_params12);\n        doTestWithParams(\"ECIES with P-521 KP2 P13\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation1, encoding3, 128), p521_2_with_params13);\n        doTestWithParams(\"ECIES with P-521 KP2 P21\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation2, encoding1, 128), p521_2_with_params21);\n        doTestWithParams(\"ECIES with P-521 KP2 P21\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation2, encoding2, 128), p521_2_with_params22);\n        doTestWithParams(\"ECIES with P-521 KP2 P21\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation2, encoding3, 128), p521_2_with_params23);\n    }\n\n    public void doTestNoParams(\n        String testname,\n        KeyPair keyPair,\n        String cipher,\n        byte[] ephPrivateValue,\n        byte[] expected)\n        throws Exception\n    {\n\n\n        byte[] out1, out2;\n\n        // Generate static key pair\n        ECPublicKey   Pub = (ECPublicKey)keyPair.getPublic();\n        ECPrivateKey  Priv = (ECPrivateKey)keyPair.getPrivate();\n\n        Cipher c1 = Cipher.getInstance(cipher);\n        Cipher c2 = Cipher.getInstance(cipher);\n\n        // Testing with null parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, new FixedSecureRandom(ephPrivateValue));\n        c2.init(Cipher.DECRYPT_MODE, Priv, new FixedSecureRandom(ephPrivateValue));\n        out1 = c1.doFinal(message, 0, message.length);\n\n        if (!areEqual(out1, expected))\n        {\n            fail(testname + \" test failed encrypt with null parameters, DHAES mode false.\");\n        }\n\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n        {\n            fail(testname + \" test failed decrypt with null parameters, DHAES mode false.\");\n        }\n    }\n\n    public void doTestWithParams(\n        String testname,\n        KeyPair keyPair,\n        String cipher,\n        byte[] ephPrivateValue,\n        IESParameterSpec p,\n        byte[] expected)\n        throws Exception\n    {\n        byte[] out1, out2;\n\n        // Generate static key pair\n        ECPublicKey   Pub = (ECPublicKey)keyPair.getPublic();\n        ECPrivateKey  Priv = (ECPrivateKey)keyPair.getPrivate();\n\n        Cipher c1 = Cipher.getInstance(cipher);\n        Cipher c2 = Cipher.getInstance(cipher);\n\n        // Testing with given parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, p, new FixedSecureRandom(ephPrivateValue));\n        c2.init(Cipher.DECRYPT_MODE, Priv, p, new FixedSecureRandom(ephPrivateValue));\n        out1 = c1.doFinal(message, 0, message.length);\n\n        if (!areEqual(out1, expected))\n        {\n            fail(testname + \" test failed encrypt with non-null parameters, DHAES mode false.\");\n        }\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n        {\n            fail(testname + \" test failed decrypt with non-null parameters, DHAES mode false.\");\n        }\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECIESVectorTest());\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.jcajce.provider.asymmetric;\n\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.asymmetric.dh.KeyFactorySpi;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jcajce.provider.util.AsymmetricAlgorithmProvider;\n\npublic class DH\n{\n    private static final String PREFIX = \"org.bouncycastle.jcajce.provider.asymmetric\" + \".dh.\";\n\n    public static class Mappings\n        extends AsymmetricAlgorithmProvider\n    {\n        public Mappings()\n        {\n        }\n\n        public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"KeyPairGenerator.DH\", PREFIX + \"KeyPairGeneratorSpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyPairGenerator.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"KeyAgreement.DH\", PREFIX + \"KeyAgreementSpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyAgreement.DIFFIEHELLMAN\", \"DH\");\n            provider.addAlgorithm(\"KeyAgreement\", PKCSObjectIdentifiers.id_alg_ESDH, PREFIX + \"KeyAgreementSpi$DHwithRFC2631KDF\");\n            provider.addAlgorithm(\"KeyAgreement\", PKCSObjectIdentifiers.id_alg_SSDH, PREFIX + \"KeyAgreementSpi$DHwithRFC2631KDF\");\n\n            provider.addAlgorithm(\"KeyFactory.DH\", PREFIX + \"KeyFactorySpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyFactory.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"AlgorithmParameters.DH\", PREFIX + \"AlgorithmParametersSpi\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.DH\", PREFIX + \"AlgorithmParameterGeneratorSpi\");\n\n            provider.addAlgorithm(\"Cipher.IES\", PREFIX + \"IESCipher$IES\");\n            provider.addAlgorithm(\"Cipher.IESwithAES-CBC\", PREFIX + \"IESCipher$IESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.IESWITHAES-CBC\", PREFIX + \"IESCipher$IESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.IESWITHDESEDE-CBC\", PREFIX + \"IESCipher$IESwithDESedeCBC\");\n\n            provider.addAlgorithm(\"Cipher.DHIES\", PREFIX + \"IESCipher$IES\");\n            provider.addAlgorithm(\"Cipher.DHIESwithAES-CBC\", PREFIX + \"IESCipher$IESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.DHIESWITHAES-CBC\", PREFIX + \"IESCipher$IESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.DHIESWITHDESEDE-CBC\", PREFIX + \"IESCipher$IESwithDESedeCBC\");\n\n            registerOid(provider, PKCSObjectIdentifiers.dhKeyAgreement, \"DH\", new KeyFactorySpi());\n            registerOid(provider, X9ObjectIdentifiers.dhpublicnumber, \"DH\", new KeyFactorySpi());\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric;\n\nimport org.bouncycastle.asn1.bsi.BSIObjectIdentifiers;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.sec.SECObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.asymmetric.ec.KeyFactorySpi;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jcajce.provider.util.AsymmetricAlgorithmProvider;\nimport org.bouncycastle.util.Properties;\n\npublic class EC\n{\n    private static final String PREFIX = \"org.bouncycastle.jcajce.provider.asymmetric\" + \".ec.\";\n\n    public static class Mappings\n        extends AsymmetricAlgorithmProvider\n    {\n        public Mappings()\n        {\n        }\n\n        public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"AlgorithmParameters.EC\", PREFIX + \"AlgorithmParametersSpi\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECDH\", PREFIX + \"KeyAgreementSpi$DH\");\n            provider.addAlgorithm(\"KeyAgreement.ECDHC\", PREFIX + \"KeyAgreementSpi$DHC\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDH\", PREFIX + \"KeyAgreementSpi$DHC\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA1KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA1KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA224KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA224KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA256KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA256KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA384KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA384KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA512KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA512KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECDHWITHSHA1KDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA1KDF\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA1CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA1CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA256CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA256CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA384CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA384CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA512CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA512CKDF\");\n\n            registerOid(provider, X9ObjectIdentifiers.id_ecPublicKey, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.id_ecPublicKey, \"EC\");\n\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, \"EC\");\n\n            if (!Properties.isOverrideSet(\"org.bouncycastle.ec.disable_mqv\"))\n            {\n                provider.addAlgorithm(\"KeyAgreement.ECMQV\", PREFIX + \"KeyAgreementSpi$MQV\");\n\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA1CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA1CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA224CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA224CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA256CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA256CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA384CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA384CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA512CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA512CKDF\");\n\n                provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA1KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA224KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA256KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA384KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA512KDFAndSharedInfo\");\n\n                registerOid(provider, X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n                registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, \"EC\");\n\n                provider.addAlgorithm(\"KeyFactory.ECMQV\", PREFIX + \"KeyFactorySpi$ECMQV\");\n                provider.addAlgorithm(\"KeyPairGenerator.ECMQV\", PREFIX + \"KeyPairGeneratorSpi$ECMQV\");\n            }\n\n            provider.addAlgorithm(\"KeyFactory.EC\", PREFIX + \"KeyFactorySpi$EC\");\n            provider.addAlgorithm(\"KeyFactory.ECDSA\", PREFIX + \"KeyFactorySpi$ECDSA\");\n            provider.addAlgorithm(\"KeyFactory.ECDH\", PREFIX + \"KeyFactorySpi$ECDH\");\n            provider.addAlgorithm(\"KeyFactory.ECDHC\", PREFIX + \"KeyFactorySpi$ECDHC\");\n\n            provider.addAlgorithm(\"KeyPairGenerator.EC\", PREFIX + \"KeyPairGeneratorSpi$EC\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDSA\", PREFIX + \"KeyPairGeneratorSpi$ECDSA\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDH\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDHWITHSHA1KDF\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDHC\", PREFIX + \"KeyPairGeneratorSpi$ECDHC\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECIES\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n\n            provider.addAlgorithm(\"Cipher.ECIES\", PREFIX + \"IESCipher$ECIES\");\n\n            provider.addAlgorithm(\"Cipher.ECIESwithAES-CBC\", PREFIX + \"IESCipher$ECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHAES-CBC\", PREFIX + \"IESCipher$ECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESwithDESEDE-CBC\", PREFIX + \"IESCipher$ECIESwithDESedeCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHDESEDE-CBC\", PREFIX + \"IESCipher$ECIESwithDESedeCBC\");\n\n            provider.addAlgorithm(\"Signature.ECDSA\", PREFIX + \"SignatureSpi$ecDSA\");\n            provider.addAlgorithm(\"Signature.NONEwithECDSA\", PREFIX + \"SignatureSpi$ecDSAnone\");\n\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1withECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAwithSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WITHECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAWITHSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WithECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAWithSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.1.2.840.10045.4.1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.\" + TeleTrusTObjectIdentifiers.ecSignWithSha1, \"ECDSA\");\n\n            provider.addAlgorithm(\"Signature.ECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA\");\n            provider.addAlgorithm(\"Signature.SHA1WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA\");\n            provider.addAlgorithm(\"Signature.SHA224WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA224\");\n            provider.addAlgorithm(\"Signature.SHA256WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA256\");\n            provider.addAlgorithm(\"Signature.SHA384WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA384\");\n            provider.addAlgorithm(\"Signature.SHA512WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA512\");\n            provider.addAlgorithm(\"Signature.SHA3-224WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_224\");\n            provider.addAlgorithm(\"Signature.SHA3-256WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_256\");\n            provider.addAlgorithm(\"Signature.SHA3-384WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_384\");\n            provider.addAlgorithm(\"Signature.SHA3-512WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_512\");\n\n            provider.addAlgorithm(\"Alg.Alias.Signature.DETECDSA\", \"ECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WITHDETECDSA\", \"SHA1WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA224WITHDETECDSA\", \"SHA224WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA256WITHDETECDSA\", \"SHA256WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA384WITHDETECDSA\", \"SHA384WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA512WITHDETECDSA\", \"SHA512WITHECDDSA\");\n\n            addSignatureAlgorithm(provider, \"SHA224\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA224\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA256\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA384\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA512\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n            addSignatureAlgorithm(provider, \"SHA3-224\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_224\", NISTObjectIdentifiers.id_ecdsa_with_sha3_224);\n            addSignatureAlgorithm(provider, \"SHA3-256\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_256\", NISTObjectIdentifiers.id_ecdsa_with_sha3_256);\n            addSignatureAlgorithm(provider, \"SHA3-384\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_384\", NISTObjectIdentifiers.id_ecdsa_with_sha3_384);\n            addSignatureAlgorithm(provider, \"SHA3-512\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_512\", NISTObjectIdentifiers.id_ecdsa_with_sha3_512);\n\n            addSignatureAlgorithm(provider, \"RIPEMD160\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSARipeMD160\",TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n\n            provider.addAlgorithm(\"Signature.SHA1WITHECNR\", PREFIX + \"SignatureSpi$ecNR\");\n            provider.addAlgorithm(\"Signature.SHA224WITHECNR\", PREFIX + \"SignatureSpi$ecNR224\");\n            provider.addAlgorithm(\"Signature.SHA256WITHECNR\", PREFIX + \"SignatureSpi$ecNR256\");\n            provider.addAlgorithm(\"Signature.SHA384WITHECNR\", PREFIX + \"SignatureSpi$ecNR384\");\n            provider.addAlgorithm(\"Signature.SHA512WITHECNR\", PREFIX + \"SignatureSpi$ecNR512\");\n\n            addSignatureAlgorithm(provider, \"SHA1\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n            addSignatureAlgorithm(provider, \"SHA224\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA224\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA256\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA384\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA512\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n            addSignatureAlgorithm(provider, \"SHA1\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA\", BSIObjectIdentifiers.ecdsa_plain_SHA1);\n            addSignatureAlgorithm(provider, \"SHA224\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA224\", BSIObjectIdentifiers.ecdsa_plain_SHA224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA256\", BSIObjectIdentifiers.ecdsa_plain_SHA256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA384\", BSIObjectIdentifiers.ecdsa_plain_SHA384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA512\", BSIObjectIdentifiers.ecdsa_plain_SHA512);\n            addSignatureAlgorithm(provider, \"RIPEMD160\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecPlainDSARP160\", BSIObjectIdentifiers.ecdsa_plain_RIPEMD160);\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.io.ByteArrayOutputStream;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherSpi;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.interfaces.DHKey;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\n\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyEncoder;\nimport org.bouncycastle.crypto.agreement.DHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.AESFastEngine;\nimport org.bouncycastle.crypto.engines.DESedeEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.DHKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.DHKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.DHKeyParameters;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.crypto.parsers.DHIESPublicKeyParser;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.DHUtil;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;\nimport org.bouncycastle.jcajce.util.BCJcaJceHelper;\nimport org.bouncycastle.jcajce.util.JcaJceHelper;\nimport org.bouncycastle.jce.interfaces.IESKey;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\n\n\npublic class IESCipher\n    extends CipherSpi\n{\n    private final JcaJceHelper helper = new BCJcaJceHelper();\n    private final int ivLength;\n\n    private IESEngine engine;\n    private int state = -1;\n    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    private AlgorithmParameters engineParam = null;\n    private IESParameterSpec engineSpec = null;\n    private AsymmetricKeyParameter key;\n    private SecureRandom random;\n    private boolean dhaesMode = false;\n    private AsymmetricKeyParameter otherKeyParameter = null;\n\n    public IESCipher(IESEngine engine)\n    {\n        this.engine = engine;\n        this.ivLength = 0;\n    }\n\n    public IESCipher(IESEngine engine, int ivLength)\n    {\n        this.engine = engine;\n        this.ivLength = ivLength;\n    }\n\n    public int engineGetBlockSize()\n    {\n        if (engine.getCipher() != null)\n        {\n            return engine.getCipher().getBlockSize();\n        }\n        else\n        {\n            return 0;\n        }\n    }\n\n\n    public int engineGetKeySize(Key key)\n    {\n        if (key instanceof DHKey)\n        {\n            return ((DHKey)key).getParams().getP().bitLength();\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"not a DH key\");\n        }\n    }\n\n\n    public byte[] engineGetIV()\n    {\n        if (engineSpec != null)\n        {\n            return engineSpec.getNonce();\n        }\n        return null;\n    }\n\n    public AlgorithmParameters engineGetParameters()\n    {\n        if (engineParam == null && engineSpec != null)\n        {\n            try\n            {\n                engineParam = helper.createAlgorithmParameters(\"IES\");\n                engineParam.init(engineSpec);\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.toString());\n            }\n        }\n\n        return engineParam;\n    }\n\n\n    public void engineSetMode(String mode)\n        throws NoSuchAlgorithmException\n    {\n        String modeName = Strings.toUpperCase(mode);\n\n        if (modeName.equals(\"NONE\"))\n        {\n            dhaesMode = false;\n        }\n        else if (modeName.equals(\"DHAES\"))\n        {\n            dhaesMode = true;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"can't support mode \" + mode);\n        }\n    }\n\n    public int engineGetOutputSize(int inputLen)\n    {\n        int len1, len2, len3;\n\n        if (key == null)\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        len1 = engine.getMac().getMacSize();\n\n        if (otherKeyParameter == null)\n        {\n            len2 = 1 + 2 * (((DHKeyParameters)key).getParameters().getP().bitLength() + 7) / 8;\n        }\n        else\n        {\n            len2 = 0;\n        }\n\n        if (engine.getCipher() == null)\n        {\n            len3 = inputLen;\n        }\n        else if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen);\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen - len1 - len2);\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            return buffer.size() + len1 + len2 + len3;\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            return buffer.size() - len1 - len2 + len3;\n        }\n        else\n        {\n            throw new IllegalStateException(\"IESCipher not initialised\");\n        }\n\n    }\n\n    public void engineSetPadding(String padding)\n        throws NoSuchPaddingException\n    {\n        String paddingName = Strings.toUpperCase(padding);\n\n        // TDOD: make this meaningful...\n        if (paddingName.equals(\"NOPADDING\"))\n        {\n\n        }\n        else if (paddingName.equals(\"PKCS5PADDING\") || paddingName.equals(\"PKCS7PADDING\"))\n        {\n\n        }\n        else\n        {\n            throw new NoSuchPaddingException(\"padding not available with IESCipher\");\n        }\n    }\n\n    // Initialisation methods\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameters params,\n        SecureRandom random)\n        throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        AlgorithmParameterSpec paramSpec = null;\n\n        if (params != null)\n        {\n            try\n            {\n                paramSpec = params.getParameterSpec(IESParameterSpec.class);\n            }\n            catch (Exception e)\n            {\n                throw new InvalidAlgorithmParameterException(\"cannot recognise parameters: \" + e.toString());\n            }\n        }\n\n        engineParam = params;\n        engineInit(opmode, key, paramSpec, random);\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameterSpec engineSpec,\n        SecureRandom random)\n        throws InvalidAlgorithmParameterException, InvalidKeyException\n    {\n        // Use default parameters (including cipher key size) if none are specified\n        if (engineSpec == null)\n        {\n            byte[] nonce = null;\n            if (ivLength != 0 && opmode == Cipher.ENCRYPT_MODE)\n            {\n                nonce = new byte[ivLength];\n                random.nextBytes(nonce);\n            }\n            this.engineSpec = IESUtil.guessParameterSpec(engine.getCipher(), nonce);\n        }\n        else if (engineSpec instanceof IESParameterSpec)\n        {\n            this.engineSpec = (IESParameterSpec)engineSpec;\n        }\n        else\n        {\n            throw new InvalidAlgorithmParameterException(\"must be passed IES parameters\");\n        }\n\n        byte[] nonce = this.engineSpec.getNonce();\n\n        if (ivLength != 0 && (nonce == null || nonce.length != ivLength))\n        {\n            throw new InvalidAlgorithmParameterException(\"NONCE in IES Parameters needs to be \" + ivLength + \" bytes long\");\n        }\n\n        // Parse the recipient's key\n        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE)\n        {\n            if (key instanceof DHPublicKey)\n            {\n                this.key = DHUtil.generatePublicKeyParameter((PublicKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.key = DHUtil.generatePublicKeyParameter(ieKey.getPublic());\n                this.otherKeyParameter = DHUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's public DH key for encryption\");\n            }\n        }\n        else if (opmode == Cipher.DECRYPT_MODE || opmode == Cipher.UNWRAP_MODE)\n        {\n            if (key instanceof DHPrivateKey)\n            {\n                this.key = DHUtil.generatePrivateKeyParameter((PrivateKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.otherKeyParameter = DHUtil.generatePublicKeyParameter(ieKey.getPublic());\n                this.key = DHUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's private DH key for decryption\");\n            }\n        }\n        else\n        {\n            throw new InvalidKeyException(\"must be passed EC key\");\n        }\n\n        this.random = random;\n        this.state = opmode;\n        buffer.reset();\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        SecureRandom random)\n        throws InvalidKeyException\n    {\n        try\n        {\n            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            throw new IllegalArgumentException(\"cannot handle supplied parameter spec: \" + e.getMessage());\n        }\n\n    }\n\n\n    // Update methods - buffer the input\n\n    public byte[] engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return null;\n    }\n\n\n    public int engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen,\n        byte[] output,\n        int outputOffset)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return 0;\n    }\n\n\n    // Finalisation methods\n\n    public byte[] engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n        throws IllegalBlockSizeException, BadPaddingException\n    {\n        if (inputLen != 0)\n        {\n            buffer.write(input, inputOffset, inputLen);\n        }\n\n        byte[] in = buffer.toByteArray();\n        buffer.reset();\n\n        // Convert parameters for use in IESEngine\n        CipherParameters params = new IESWithCipherParameters(engineSpec.getDerivationV(),\n            engineSpec.getEncodingV(),\n            engineSpec.getMacKeySize(),\n            engineSpec.getCipherKeySize());\n\n        if (engineSpec.getNonce() != null)\n        {\n            params = new ParametersWithIV(params, engineSpec.getNonce());\n        }\n\n        DHParameters dhParams = ((DHKeyParameters)key).getParameters();\n\n        byte[] V;\n        if (otherKeyParameter != null)\n        {\n            try\n            {\n                if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n                {\n                    engine.init(true, otherKeyParameter, key, params);\n                }\n                else\n                {\n                    engine.init(false, key, otherKeyParameter, params);\n                }\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            // Generate the ephemeral key pair\n            DHKeyPairGenerator gen = new DHKeyPairGenerator();\n            gen.init(new DHKeyGenerationParameters(random, dhParams));\n\n            EphemeralKeyPairGenerator kGen = new EphemeralKeyPairGenerator(gen, new KeyEncoder()\n            {\n                public byte[] getEncoded(AsymmetricKeyParameter keyParameter)\n                {\n                    byte[] Vloc = new byte[(((DHKeyParameters)keyParameter).getParameters().getP().bitLength() + 7) / 8];\n                    byte[] Vtmp = BigIntegers.asUnsignedByteArray(((DHPublicKeyParameters)keyParameter).getY());\n\n                    if (Vtmp.length > Vloc.length)\n                    {\n                        throw new IllegalArgumentException(\"Senders's public key longer than expected.\");\n                    }\n                    else\n                    {\n                        System.arraycopy(Vtmp, 0, Vloc, Vloc.length - Vtmp.length, Vtmp.length);\n                    }\n\n                    return Vloc;\n                }\n            });\n\n            // Encrypt the buffer\n            try\n            {\n                engine.init(key, params, kGen);\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            // Decrypt the buffer\n            try\n            {\n                engine.init(key, params, new DHIESPublicKeyParser(((DHKeyParameters)key).getParameters()));\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (InvalidCipherTextException e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n        else\n        {\n            throw new IllegalStateException(\"IESCipher not initialised\");\n        }\n\n    }\n\n\n    public int engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLength,\n        byte[] output,\n        int outputOffset)\n        throws ShortBufferException, IllegalBlockSizeException, BadPaddingException\n    {\n\n        byte[] buf = engineDoFinal(input, inputOffset, inputLength);\n        System.arraycopy(buf, 0, output, outputOffset, buf.length);\n        return buf.length;\n\n    }\n\n    /**\n     * Classes that inherit from us\n     */\n\n    static public class IES\n        extends IESCipher\n    {\n        public IES()\n        {\n            super(new IESEngine(new DHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest())));\n        }\n    }\n\n    static public class IESwithDESedeCBC\n        extends IESCipher\n    {\n        public IESwithDESedeCBC()\n        {\n            super(new IESEngine(new DHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new CBCBlockCipher(new DESedeEngine()))), 8);\n        }\n    }\n\n    static public class IESwithAESCBC\n        extends IESCipher\n    {\n        public IESwithAESCBC()\n        {\n            super(new IESEngine(new DHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()))), 16);\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.ec;\n\nimport java.io.ByteArrayOutputStream;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherSpi;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyEncoder;\nimport org.bouncycastle.crypto.agreement.ECDHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.AESFastEngine;\nimport org.bouncycastle.crypto.engines.DESedeEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.ECKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.params.ECKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.ECKeyParameters;\nimport org.bouncycastle.crypto.params.ECPublicKeyParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.crypto.parsers.ECIESPublicKeyParser;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;\nimport org.bouncycastle.jcajce.util.BCJcaJceHelper;\nimport org.bouncycastle.jcajce.util.JcaJceHelper;\nimport org.bouncycastle.jce.interfaces.ECKey;\nimport org.bouncycastle.jce.interfaces.IESKey;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.Strings;\n\n\npublic class IESCipher\n    extends CipherSpi\n{\n    private final JcaJceHelper helper = new BCJcaJceHelper();\n\n    private int ivLength;\n    private IESEngine engine;\n    private int state = -1;\n    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    private AlgorithmParameters engineParam = null;\n    private IESParameterSpec engineSpec = null;\n    private AsymmetricKeyParameter key;\n    private SecureRandom random;\n    private boolean dhaesMode = false;\n    private AsymmetricKeyParameter otherKeyParameter = null;\n\n    public IESCipher(IESEngine engine)\n    {\n        this.engine = engine;\n        this.ivLength = 0;\n    }\n\n    public IESCipher(IESEngine engine, int ivLength)\n    {\n        this.engine = engine;\n        this.ivLength = ivLength;\n    }\n\n    public int engineGetBlockSize()\n    {\n        if (engine.getCipher() != null)\n        {\n            return engine.getCipher().getBlockSize();\n        }\n        else\n        {\n            return 0;\n        }\n    }\n\n\n    public int engineGetKeySize(Key key)\n    {\n        if (key instanceof ECKey)\n        {\n            return ((ECKey)key).getParameters().getCurve().getFieldSize();\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"not an EC key\");\n        }\n    }\n\n\n    public byte[] engineGetIV()\n    {\n        if (engineSpec != null)\n        {\n            return engineSpec.getNonce();\n        }\n        return null;\n    }\n\n    public AlgorithmParameters engineGetParameters()\n    {\n        if (engineParam == null && engineSpec != null)\n        {\n            try\n            {\n                engineParam = helper.createAlgorithmParameters(\"IES\");\n                engineParam.init(engineSpec);\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.toString());\n            }\n        }\n\n        return engineParam;\n    }\n\n\n    public void engineSetMode(String mode)\n        throws NoSuchAlgorithmException\n    {\n        String modeName = Strings.toUpperCase(mode);\n\n        if (modeName.equals(\"NONE\"))\n        {\n            dhaesMode = false;\n        }\n        else if (modeName.equals(\"DHAES\"))\n        {\n            dhaesMode = true;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"can't support mode \" + mode);\n        }\n    }\n\n\n    public int engineGetOutputSize(int inputLen)\n    {\n        int len1, len2, len3;\n\n        if (key == null)\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        len1 = engine.getMac().getMacSize();\n\n        if (otherKeyParameter == null)\n        {\n            len2 = 2 * (((ECKeyParameters)key).getParameters().getCurve().getFieldSize() + 7) / 8;\n        }\n        else\n        {\n            len2 = 0;\n        }\n\n        if (engine.getCipher() == null)\n        {\n            len3 = inputLen;\n        }\n        else if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen);\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen - len1 - len2);\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            return buffer.size() + len1 + 1 + len2 + len3;\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            return buffer.size() - len1 - len2 + len3;\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n    }\n\n    public void engineSetPadding(String padding)\n        throws NoSuchPaddingException\n    {\n        String paddingName = Strings.toUpperCase(padding);\n\n        // TDOD: make this meaningful...\n        if (paddingName.equals(\"NOPADDING\"))\n        {\n\n        }\n        else if (paddingName.equals(\"PKCS5PADDING\") || paddingName.equals(\"PKCS7PADDING\"))\n        {\n\n        }\n        else\n        {\n            throw new NoSuchPaddingException(\"padding not available with IESCipher\");\n        }\n    }\n\n\n    // Initialisation methods\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameters params,\n        SecureRandom random)\n        throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        AlgorithmParameterSpec paramSpec = null;\n\n        if (params != null)\n        {\n            try\n            {\n                paramSpec = params.getParameterSpec(IESParameterSpec.class);\n            }\n            catch (Exception e)\n            {\n                throw new InvalidAlgorithmParameterException(\"cannot recognise parameters: \" + e.toString());\n            }\n        }\n\n        engineParam = params;\n        engineInit(opmode, key, paramSpec, random);\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameterSpec engineSpec,\n        SecureRandom random)\n        throws InvalidAlgorithmParameterException, InvalidKeyException\n    {\n        otherKeyParameter = null;\n\n        // Use default parameters (including cipher key size) if none are specified\n        if (engineSpec == null)\n        {\n            byte[] nonce = null;\n            if (ivLength != 0 && opmode == Cipher.ENCRYPT_MODE)\n            {\n                nonce = new byte[ivLength];\n                random.nextBytes(nonce);\n            }\n            this.engineSpec = IESUtil.guessParameterSpec(engine.getCipher(), nonce);\n        }\n        else if (engineSpec instanceof IESParameterSpec)\n        {\n            this.engineSpec = (IESParameterSpec)engineSpec;\n        }\n        else\n        {\n            throw new InvalidAlgorithmParameterException(\"must be passed IES parameters\");\n        }\n\n        byte[] nonce = this.engineSpec.getNonce();\n\n        if (ivLength != 0 && (nonce == null || nonce.length != ivLength))\n        {\n            throw new InvalidAlgorithmParameterException(\"NONCE in IES Parameters needs to be \" + ivLength + \" bytes long\");\n        }\n\n        // Parse the recipient's key\n        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE)\n        {\n            if (key instanceof PublicKey)\n            {\n                this.key = ECUtils.generatePublicKeyParameter((PublicKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.key = ECUtils.generatePublicKeyParameter(ieKey.getPublic());\n                this.otherKeyParameter = ECUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's public EC key for encryption\");\n            }\n        }\n        else if (opmode == Cipher.DECRYPT_MODE || opmode == Cipher.UNWRAP_MODE)\n        {\n            if (key instanceof PrivateKey)\n            {\n                this.key = ECUtil.generatePrivateKeyParameter((PrivateKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.otherKeyParameter = ECUtils.generatePublicKeyParameter(ieKey.getPublic());\n                this.key = ECUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's private EC key for decryption\");\n            }\n        }\n        else\n        {\n            throw new InvalidKeyException(\"must be passed EC key\");\n        }\n\n\n        this.random = random;\n        this.state = opmode;\n        buffer.reset();\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        SecureRandom random)\n        throws InvalidKeyException\n    {\n        try\n        {\n            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            throw new IllegalArgumentException(\"cannot handle supplied parameter spec: \" + e.getMessage());\n        }\n\n    }\n\n\n    // Update methods - buffer the input\n\n    public byte[] engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return null;\n    }\n\n\n    public int engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen,\n        byte[] output,\n        int outputOffset)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return 0;\n    }\n\n\n    // Finalisation methods\n\n    public byte[] engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n        throws IllegalBlockSizeException, BadPaddingException\n    {\n        if (inputLen != 0)\n        {\n            buffer.write(input, inputOffset, inputLen);\n        }\n\n        final byte[] in = buffer.toByteArray();\n        buffer.reset();\n\n        // Convert parameters for use in IESEngine\n        CipherParameters params = new IESWithCipherParameters(engineSpec.getDerivationV(),\n            engineSpec.getEncodingV(),\n            engineSpec.getMacKeySize(),\n            engineSpec.getCipherKeySize());\n\n        if (engineSpec.getNonce() != null)\n        {\n            params = new ParametersWithIV(params, engineSpec.getNonce());\n        }\n\n        final ECDomainParameters ecParams = ((ECKeyParameters)key).getParameters();\n\n        final byte[] V;\n\n        if (otherKeyParameter != null)\n        {\n            try\n            {\n                if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n                {\n                    engine.init(true, otherKeyParameter, key, params);\n                }\n                else\n                {\n                    engine.init(false, key, otherKeyParameter, params);\n                }\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            // Generate the ephemeral key pair\n            ECKeyPairGenerator gen = new ECKeyPairGenerator();\n            gen.init(new ECKeyGenerationParameters(ecParams, random));\n\n            final boolean usePointCompression = engineSpec.getPointCompression();\n            EphemeralKeyPairGenerator kGen = new EphemeralKeyPairGenerator(gen, new KeyEncoder()\n            {\n                public byte[] getEncoded(AsymmetricKeyParameter keyParameter)\n                {\n                    return ((ECPublicKeyParameters)keyParameter).getQ().getEncoded(usePointCompression);\n                }\n            });\n\n            // Encrypt the buffer\n            try\n            {\n                engine.init(key, params, kGen);\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            // Decrypt the buffer\n            try\n            {\n                engine.init(key, params, new ECIESPublicKeyParser(ecParams));\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (InvalidCipherTextException e)\n            {\n                throw new BadPaddingException(e.getMessage());\n            }\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n    }\n\n    public int engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLength,\n        byte[] output,\n        int outputOffset)\n        throws ShortBufferException, IllegalBlockSizeException, BadPaddingException\n    {\n\n        byte[] buf = engineDoFinal(input, inputOffset, inputLength);\n        System.arraycopy(buf, 0, output, outputOffset, buf.length);\n        return buf.length;\n    }\n\n    /**\n     * Classes that inherit from us\n     */\n\n    static public class ECIES\n        extends IESCipher\n    {\n        public ECIES()\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest())));\n        }\n    }\n\n    static public class ECIESwithCipher\n        extends IESCipher\n    {\n        public ECIESwithCipher(BlockCipher cipher, int ivLength)\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                            new KDF2BytesGenerator(new SHA1Digest()),\n                            new HMac(new SHA1Digest()),\n                            new PaddedBufferedBlockCipher(cipher)), ivLength);\n        }\n    }\n\n    static public class ECIESwithDESedeCBC\n        extends ECIESwithCipher\n    {\n        public ECIESwithDESedeCBC()\n        {\n            super(new CBCBlockCipher(new DESedeEngine()), 8);\n        }\n    }\n\n    static public class ECIESwithAESCBC\n        extends ECIESwithCipher\n    {\n        public ECIESwithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), 16);\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.ies;\n\nimport java.io.IOException;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\n\nimport org.bouncycastle.asn1.ASN1EncodableVector;\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1OctetString;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.ASN1TaggedObject;\nimport org.bouncycastle.asn1.DEROctetString;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.DERTaggedObject;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\n\npublic class AlgorithmParametersSpi\n    extends java.security.AlgorithmParametersSpi\n{\n    protected boolean isASN1FormatString(String format)\n    {\n        return format == null || format.equals(\"ASN.1\");\n    }\n\n    protected AlgorithmParameterSpec engineGetParameterSpec(\n        Class paramSpec)\n        throws InvalidParameterSpecException\n    {\n        if (paramSpec == null)\n        {\n            throw new NullPointerException(\"argument to getParameterSpec must not be null\");\n        }\n\n        return localEngineGetParameterSpec(paramSpec);\n    }\n\n    IESParameterSpec currentSpec;\n\n    /**\n     * in the absence of a standard way of doing it this will do for\n     * now...\n     */\n    protected byte[] engineGetEncoded()\n    {\n        try\n        {\n            ASN1EncodableVector v = new ASN1EncodableVector();\n\n            if (currentSpec.getDerivationV() != null)\n            {\n                v.add(new DERTaggedObject(false, 0, new DEROctetString(currentSpec.getDerivationV())));\n            }\n            if (currentSpec.getEncodingV() != null)\n            {\n                v.add(new DERTaggedObject(false, 1, new DEROctetString(currentSpec.getEncodingV())));\n            }\n            v.add(new ASN1Integer(currentSpec.getMacKeySize()));\n            if (currentSpec.getNonce() != null)\n            {\n                ASN1EncodableVector cV = new ASN1EncodableVector();\n\n                cV.add(new ASN1Integer(currentSpec.getCipherKeySize()));\n                cV.add(new ASN1Integer(currentSpec.getNonce()));\n\n                v.add(new DERSequence(cV));\n            }\n            return new DERSequence(v).getEncoded(ASN1Encoding.DER);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Error encoding IESParameters\");\n        }\n    }\n\n    protected byte[] engineGetEncoded(\n        String format)\n    {\n        if (isASN1FormatString(format) || format.equalsIgnoreCase(\"X.509\"))\n        {\n            return engineGetEncoded();\n        }\n\n        return null;\n    }\n\n    protected AlgorithmParameterSpec localEngineGetParameterSpec(\n        Class paramSpec)\n        throws InvalidParameterSpecException\n    {\n        if (paramSpec == IESParameterSpec.class || paramSpec == AlgorithmParameterSpec.class)\n        {\n            return currentSpec;\n        }\n\n        throw new InvalidParameterSpecException(\"unknown parameter spec passed to ElGamal parameters object.\");\n    }\n\n    protected void engineInit(\n        AlgorithmParameterSpec paramSpec)\n        throws InvalidParameterSpecException\n    {\n        if (!(paramSpec instanceof IESParameterSpec))\n        {\n            throw new InvalidParameterSpecException(\"IESParameterSpec required to initialise a IES algorithm parameters object\");\n        }\n\n        this.currentSpec = (IESParameterSpec)paramSpec;\n    }\n\n    protected void engineInit(\n        byte[] params)\n        throws IOException\n    {\n        try\n        {\n            ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(params);\n\n            if (s.size() == 1)\n            {\n                this.currentSpec = new IESParameterSpec(null, null, ASN1Integer.getInstance(s.getObjectAt(0)).getValue().intValue());\n            }\n            else if (s.size() == 2)\n            {\n                ASN1TaggedObject tagged = ASN1TaggedObject.getInstance(s.getObjectAt(0));\n\n                if (tagged.getTagNo() == 0)\n                {\n                    this.currentSpec = new IESParameterSpec(ASN1OctetString.getInstance(tagged, false).getOctets(), null, ASN1Integer.getInstance(s.getObjectAt(1)).getValue().intValue());\n                }\n                else\n                {\n                    this.currentSpec = new IESParameterSpec(null, ASN1OctetString.getInstance(tagged, false).getOctets(), ASN1Integer.getInstance(s.getObjectAt(1)).getValue().intValue());\n                }\n            }\n            else if (s.size() == 3)\n            {\n                ASN1TaggedObject tagged1 = ASN1TaggedObject.getInstance(s.getObjectAt(0));\n                ASN1TaggedObject tagged2 = ASN1TaggedObject.getInstance(s.getObjectAt(1));\n\n                this.currentSpec = new IESParameterSpec(ASN1OctetString.getInstance(tagged1, false).getOctets(), ASN1OctetString.getInstance(tagged2, false).getOctets(), ASN1Integer.getInstance(s.getObjectAt(2)).getValue().intValue());\n            }\n            else if (s.size() == 4)\n            {\n                ASN1TaggedObject tagged1 = ASN1TaggedObject.getInstance(s.getObjectAt(0));\n                ASN1TaggedObject tagged2 = ASN1TaggedObject.getInstance(s.getObjectAt(1));\n                ASN1Sequence     cipherDet = ASN1Sequence.getInstance(s.getObjectAt(3));\n\n                this.currentSpec = new IESParameterSpec(ASN1OctetString.getInstance(tagged1, false).getOctets(), ASN1OctetString.getInstance(tagged2, false).getOctets(), ASN1Integer.getInstance(s.getObjectAt(2)).getValue().intValue(),\n                    ASN1Integer.getInstance(cipherDet.getObjectAt(0)).getValue().intValue(),\n                    ASN1OctetString.getInstance(cipherDet.getObjectAt(1)).getOctets());\n            }\n        }\n        catch (ClassCastException e)\n        {\n            throw new IOException(\"Not a valid IES Parameter encoding.\");\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new IOException(\"Not a valid IES Parameter encoding.\");\n        }\n    }\n\n    protected void engineInit(\n        byte[] params,\n        String format)\n        throws IOException\n    {\n        if (isASN1FormatString(format) || format.equalsIgnoreCase(\"X.509\"))\n        {\n            engineInit(params);\n        }\n        else\n        {\n            throw new IOException(\"Unknown parameter format \" + format);\n        }\n    }\n\n    protected String engineToString()\n    {\n        return \"IES Parameters\";\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.util;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\n\npublic class IESUtil\n{\n    public static IESParameterSpec guessParameterSpec(BufferedBlockCipher iesBlockCipher, byte[] nonce)\n    {\n        if (iesBlockCipher == null)\n        {\n            return new IESParameterSpec(null, null, 128);\n        }\n        else\n        {\n            BlockCipher underlyingCipher = iesBlockCipher.getUnderlyingCipher();\n\n            if (underlyingCipher.getAlgorithmName().equals(\"DES\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC2\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC5-32\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC5-64\"))\n            {\n                return new IESParameterSpec(null, null, 64, 64, nonce);\n            }\n            else if (underlyingCipher.getAlgorithmName().equals(\"SKIPJACK\"))\n            {\n                return new IESParameterSpec(null, null, 80, 80, nonce);\n            }\n            else if (underlyingCipher.getAlgorithmName().equals(\"GOST28147\"))\n            {\n                return new IESParameterSpec(null, null, 256, 256, nonce);\n            }\n\n            return new IESParameterSpec(null, null, 128, 128, nonce);\n        }\n    }\n}\n", "package org.bouncycastle.jce.spec;\n\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Parameter spec for an integrated encryptor, as in IEEE P1363a\n */\npublic class IESParameterSpec\n    implements AlgorithmParameterSpec\n{\n    private byte[] derivation;\n    private byte[] encoding;\n    private int macKeySize;\n    private int cipherKeySize;\n    private byte[] nonce;\n    private boolean usePointCompression;\n\n\n    /**\n     * Set the IES engine parameters.\n     *\n     * @param derivation the optional derivation vector for the KDF.\n     * @param encoding   the optional encoding vector for the KDF.\n     * @param macKeySize the key size (in bits) for the MAC.\n     */\n    public IESParameterSpec(\n        byte[] derivation,\n        byte[] encoding,\n        int macKeySize)\n    {\n        this(derivation, encoding, macKeySize, -1, null, false);\n    }\n\n    /**\n     * Set the IES engine parameters.\n     *\n     * @param derivation    the optional derivation vector for the KDF.\n     * @param encoding      the optional encoding vector for the KDF.\n     * @param macKeySize    the key size (in bits) for the MAC.\n     * @param cipherKeySize the key size (in bits) for the block cipher.\n     * @param nonce         an IV to use initialising the block cipher.\n     */\n    public IESParameterSpec(\n        byte[] derivation,\n        byte[] encoding,\n        int macKeySize,\n        int cipherKeySize,\n        byte[] nonce)\n    {\n        this(derivation, encoding, macKeySize, cipherKeySize, nonce, false);\n    }\n\n    /**\n     * Set the IES engine parameters.\n     *\n     * @param derivation    the optional derivation vector for the KDF.\n     * @param encoding      the optional encoding vector for the KDF.\n     * @param macKeySize    the key size (in bits) for the MAC.\n     * @param cipherKeySize the key size (in bits) for the block cipher.\n     * @param nonce         an IV to use initialising the block cipher.\n     * @param usePointCompression whether to use EC point compression or not (false by default)\n     */\n    public IESParameterSpec(\n        byte[] derivation,\n        byte[] encoding,\n        int macKeySize,\n        int cipherKeySize,\n        byte[] nonce,\n        boolean usePointCompression)\n    {\n        if (derivation != null)\n        {\n            this.derivation = new byte[derivation.length];\n            System.arraycopy(derivation, 0, this.derivation, 0, derivation.length);\n        }\n        else\n        {\n            this.derivation = null;\n        }\n\n        if (encoding != null)\n        {\n            this.encoding = new byte[encoding.length];\n            System.arraycopy(encoding, 0, this.encoding, 0, encoding.length);\n        }\n        else\n        {\n            this.encoding = null;\n        }\n\n        this.macKeySize = macKeySize;\n        this.cipherKeySize = cipherKeySize;\n        this.nonce = Arrays.clone(nonce);\n        this.usePointCompression = usePointCompression;\n    }\n\n    /**\n     * return the derivation vector.\n     */\n    public byte[] getDerivationV()\n    {\n        return Arrays.clone(derivation);\n    }\n\n    /**\n     * return the encoding vector.\n     */\n    public byte[] getEncodingV()\n    {\n        return Arrays.clone(encoding);\n    }\n\n    /**\n     * return the key size in bits for the MAC used with the message\n     */\n    public int getMacKeySize()\n    {\n        return macKeySize;\n    }\n\n    /**\n     * return the key size in bits for the block cipher used with the message\n     */\n    public int getCipherKeySize()\n    {\n        return cipherKeySize;\n    }\n\n    /**\n     * Return the nonce (IV) value to be associated with message.\n     *\n     * @return block cipher IV for message.\n     */\n    public byte[] getNonce()\n    {\n        return Arrays.clone(nonce);\n    }\n\n    /**\n     * Set the 'point compression' flag.\n     */\n    public void setPointCompression(boolean usePointCompression)\n    {\n        this.usePointCompression = usePointCompression;\n    }\n\n    /**\n     * Return the 'point compression' flag.\n     *\n     * @return the point compression flag\n     */\n    public boolean getPointCompression()\n    {\n        return usePointCompression;\n    }\n}", "package org.bouncycastle.jce.provider.test;\n\nimport java.math.BigInteger;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.SecureRandom;\nimport java.security.Security;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHParameterSpec;\n\nimport org.bouncycastle.crypto.agreement.DHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.DESEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\n/**\n * Test for DHIES - Diffie-Hellman Integrated Encryption Scheme\n */\npublic class DHIESTest\n    extends SimpleTest\n{\n    // Oakley group 2 - RFC 5996\n    BigInteger p1024 = new BigInteger(\n                    \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\" +\n                    \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\" +\n                    \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\" +\n                    \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\" +\n                    \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381\" +\n                    \"FFFFFFFFFFFFFFFF\",16);\n\n    BigInteger g1024 = new BigInteger(\"2\",16);\n\n    DHParameterSpec param = new DHParameterSpec(p1024, g1024);\n\n    DHIESTest()\n    {\n    }\n\n    public String getName()\n    {\n        return \"DHIES\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        byte[] derivation = Hex.decode(\"202122232425262728292a2b2c2d2e2f\");\n        byte[] encoding   = Hex.decode(\"303132333435363738393a3b3c3d3e3f\");\n\n        \n        IESCipher c1 = new org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher.IES();\n        IESCipher c2 = new org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher.IES();\n        IESParameterSpec params = new IESParameterSpec(derivation,encoding,128);\n\n        // Testing DHIES with default prime in streaming mode\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        KeyPairGenerator    g512 = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        g.initialize(param);\n\n        doTest(\"DHIES with default\", g, \"DHIES\", params);\n        \n        // Testing DHIES with 512-bit prime in streaming mode\n        g512.initialize(512, new SecureRandom());\n        doTest(\"DHIES with 512-bit\", g512, \"DHIES\", params);\n\n        // Testing ECIES with 1024-bit prime in streaming mode \n        g.initialize(param, new SecureRandom());\n        doTest(\"DHIES with 1024-bit\", g, \"DHIES\", params);\n\n        c1 = new IESCipher(new IESEngine(new DHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));\n        \n        c2 = new IESCipher(new IESEngine(new DHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));  \n    \n        params = new IESParameterSpec(derivation, encoding, 128, 192, Hex.decode(\"0001020304050607\"));\n      \n        // Testing DHIES with default prime using DESEDE\n        g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        doTest(\"DHIESwithDES default\", g, \"DHIESwithDESEDE-CBC\", params);\n        \n        // Testing DHIES with 512-bit prime using DESEDE\n        doTest(\"DHIESwithDES 512-bit\", g512, \"DHIESwithDESEDE-CBC\", params);\n        \n        // Testing DHIES with 1024-bit prime using DESEDE\n        g.initialize(param, new SecureRandom());\n        doTest(\"DHIESwithDES 1024-bit\", g, \"DHIESwithDESEDE-CBC\", params);\n\n        g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        g.initialize(param);\n\n        c1 = new IESCipher.IESwithAESCBC();\n        c2 = new IESCipher.IESwithAESCBC();\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"00010203040506070001020304050607\"));\n        \n        // Testing DHIES with default prime using AES\n        doTest(\"DHIESwithAES default\", g, \"DHIESwithAES-CBC\", params);\n        \n        // Testing DHIES with 512-bit prime using AES\n        doTest(\"DHIESwithAES 512-bit\", g512, \"DHIESwithAES-CBC\", params);\n        \n        // Testing DHIES with 1024-bit prime using AES\n        g.initialize(param, new SecureRandom());\n        doTest(\"DHIESwithAES 1024-bit\", g, \"DHIESwithAES-CBC\", params);\n\n        KeyPair       keyPair = g.generateKeyPair();\n        DHPublicKey   pub = (DHPublicKey)keyPair.getPublic();\n        DHPrivateKey  priv = (DHPrivateKey)keyPair.getPrivate();\n\n        Cipher c = Cipher.getInstance(\"DHIESwithAES-CBC\", \"BC\");\n\n        try\n        {\n            c.init(Cipher.ENCRYPT_MODE, pub, new IESParameterSpec(derivation, encoding, 128, 128, null));\n\n            fail(\"no exception\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            isTrue(\"message \", \"NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            c.init(Cipher.DECRYPT_MODE, priv);\n\n            fail(\"no exception\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            isTrue(\"message \", \"cannot handle supplied parameter spec: NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            c.init(Cipher.DECRYPT_MODE, priv, new IESParameterSpec(derivation, encoding, 128, 128, null));\n\n            fail(\"no exception\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            isTrue(\"message \", \"NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n    }\n\n    public void doTest(\n        String              testname,\n        KeyPairGenerator    g,\n        String              cipher,\n        IESParameterSpec    p)\n        throws Exception\n    {\n        \n        byte[] message = Hex.decode(\"0102030405060708090a0b0c0d0e0f10111213141516\");\n        byte[] out1, out2;\n  \n        Cipher        c1 = Cipher.getInstance(cipher, \"BC\");\n        Cipher        c2 = Cipher.getInstance(cipher, \"BC\");\n        // Generate static key pair\n        KeyPair       keyPair = g.generateKeyPair();\n        DHPublicKey   pub = (DHPublicKey)keyPair.getPublic();\n        DHPrivateKey  priv = (DHPrivateKey)keyPair.getPrivate();\n\n        // Testing with default parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, c1.getParameters());\n\n        isTrue(\"nonce mismatch\", Arrays.areEqual(c1.getIV(), c2.getIV()));\n\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n        {\n            fail(testname + \" test failed with default parameters, DHAES mode false.\");\n        }\n        \n        // Testing with given parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, p);\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode false.\");\n        \n        // Testing with null parameters and DHAES mode on\n        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c1.init(Cipher.ENCRYPT_MODE, pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, c1.getParameters(), new SecureRandom());\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with null parameters, DHAES mode true.\");\n     \n        \n        // Testing with given parameters and DHAES mode on\n        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n\n        c1.init(Cipher.ENCRYPT_MODE, pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, p, new SecureRandom());\n\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode true.\");\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DHIESTest());\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.spec.ECGenParameterSpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SealedObject;\n\nimport org.bouncycastle.crypto.agreement.ECDHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.DESEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher;\nimport org.bouncycastle.jce.interfaces.ECPrivateKey;\nimport org.bouncycastle.jce.interfaces.ECPublicKey;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\n/**\n * Test for ECIES - Elliptic Curve Integrated Encryption Scheme\n */\npublic class ECIESTest\n    extends SimpleTest\n{\n\n    ECIESTest()\n    {\n    }\n\n    public String getName()\n    {\n        return \"ECIES\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        byte[] derivation = Hex.decode(\"202122232425262728292a2b2c2d2e2f\");\n        byte[] encoding   = Hex.decode(\"303132333435363738393a3b3c3d3e3f\");\n        \n        \n        IESCipher c1 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIES();\n        IESCipher c2 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIES();\n        IESParameterSpec params = new IESParameterSpec(derivation,encoding,128);\n\n        // Testing ECIES with default curve in streaming mode\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        doTest(\"ECIES with default\", g, \"ECIES\", params);\n        \n        // Testing ECIES with 192-bit curve in streaming mode \n        g.initialize(192, new SecureRandom());\n        doTest(\"ECIES with 192-bit\", g, \"ECIES\", params);\n\n        // Testing ECIES with 256-bit curve in streaming mode \n        g.initialize(256, new SecureRandom());\n        doTest(\"ECIES with 256-bit\", g, \"ECIES\", params);\n\n        \n        c1 = new IESCipher(new IESEngine(new ECDHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));\n        \n        c2 = new IESCipher(new IESEngine(new ECDHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));  \n    \n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"0001020304050607\"));\n      \n        // Testing ECIES with default curve using DES\n        g = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n\n        // Testing ECIES with 256-bit curve using DES-CBC\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"0001020304050607\"));\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n\n        try\n        {\n            params = new IESParameterSpec(derivation, encoding, 128, 128, new byte[10]);\n            g.initialize(256, new SecureRandom());\n            doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n            fail(\"DESEDE no exception!\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!e.getMessage().equals(\"NONCE in IES Parameters needs to be 8 bytes long\"))\n            {\n                fail(\"DESEDE wrong message!\");\n            }\n        }\n\n        c1 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIESwithAESCBC();\n        c2 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIESwithAESCBC();\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"000102030405060708090a0b0c0d0e0f\"));\n\n        // Testing ECIES with 256-bit curve using AES-CBC\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"000102030405060708090a0b0c0d0e0f\"));\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n\n        try\n        {\n            params = new IESParameterSpec(derivation, encoding, 128, 128, new byte[10]);\n            g.initialize(256, new SecureRandom());\n            doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n            fail(\"AES no exception!\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!e.getMessage().equals(\"NONCE in IES Parameters needs to be 16 bytes long\"))\n            {\n                fail(\"AES wrong message!\");\n            }\n        }\n\n        KeyPair       keyPair = g.generateKeyPair();\n        ECPublicKey pub = (ECPublicKey)keyPair.getPublic();\n        ECPrivateKey priv = (ECPrivateKey)keyPair.getPrivate();\n\n        Cipher c = Cipher.getInstance(\"ECIESwithAES-CBC\", \"BC\");\n\n        try\n        {\n            c.init(Cipher.ENCRYPT_MODE, pub, new IESParameterSpec(derivation, encoding, 128, 128, null));\n\n            fail(\"no exception\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            isTrue(\"message \", \"NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            c.init(Cipher.DECRYPT_MODE, priv);\n\n            fail(\"no exception\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            isTrue(\"message \", \"cannot handle supplied parameter spec: NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            c.init(Cipher.DECRYPT_MODE, priv, new IESParameterSpec(derivation, encoding, 128, 128, null));\n\n            fail(\"no exception\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            isTrue(\"message \", \"NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        sealedObjectTest();\n    }\n\n    private void sealedObjectTest()\n        throws Exception\n    {\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECIES\");\n        kpg.initialize(new ECGenParameterSpec(\"secp256r1\"));\n        KeyPair keyPair = kpg.generateKeyPair();\n\n        Cipher cipher = Cipher.getInstance(\"ECIES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n\n        String toEncrypt = \"Hello\";\n\n        // Check that cipher works ok\n        cipher.doFinal(toEncrypt.getBytes());\n\n        // Using a SealedObject to encrypt the same string fails with a NullPointerException\n        SealedObject sealedObject = new SealedObject(toEncrypt, cipher);\n\n        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n\n        String result = (String)sealedObject.getObject(cipher);\n\n        isTrue(\"result wrong\", result.equals(toEncrypt));\n\n        result = (String)sealedObject.getObject(keyPair.getPrivate());\n\n        isTrue(\"result wrong\", result.equals(toEncrypt));\n    }\n\n    public void doTest(\n        String                testname,\n        KeyPairGenerator     g,\n        String              cipher,\n        IESParameterSpec    p)\n        throws Exception\n    {\n\n        byte[] message = Hex.decode(\"0102030405060708090a0b0c0d0e0f10111213141516\");\n        byte[] out1, out2;\n\n        // Generate static key pair\n        KeyPair     KeyPair = g.generateKeyPair();\n        ECPublicKey   Pub = (ECPublicKey) KeyPair.getPublic();\n        ECPrivateKey  Priv = (ECPrivateKey) KeyPair.getPrivate();\n\n        Cipher c1 = Cipher.getInstance(cipher);\n        Cipher c2 = Cipher.getInstance(cipher);\n\n        // Testing with null parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, Priv, c1.getParameters());\n\n        isTrue(\"nonce mismatch\", Arrays.areEqual(c1.getIV(), c2.getIV()));\n\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with null parameters, DHAES mode false.\");\n    \n        \n        // Testing with given parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, Priv, p);\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode false.\");\n        \n\n// TODO: DHAES mode is not currently implemented, perhaps it shouldn't be...\n//        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n//        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n//\n//        // Testing with null parameters and DHAES mode on\n//        c1.init(Cipher.ENCRYPT_MODE, Pub, new SecureRandom());\n//        c2.init(Cipher.DECRYPT_MODE, Priv, new SecureRandom());\n//\n//        out1 = c1.doFinal(message, 0, message.length);\n//        out2 = c2.doFinal(out1, 0, out1.length);\n//        if (!areEqual(out2, message))\n//            fail(testname + \" test failed with null parameters, DHAES mode true.\");\n//\n//        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\");\n//        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\");\n//\n//        // Testing with given parameters and DHAES mode on\n//        c1.init(Cipher.ENCRYPT_MODE, Pub, p, new SecureRandom());\n//        c2.init(Cipher.DECRYPT_MODE, Priv, p, new SecureRandom());\n//\n//        out1 = c1.doFinal(message, 0, message.length);\n//        out2 = c2.doFinal(out1, 0, out1.length);\n//        if (!areEqual(out2, message))\n//            fail(testname + \" test failed with non-null parameters, DHAES mode true.\");\n        \n    }\n\n   \n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECIESTest());\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.Security;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.Cipher;\n\nimport org.bouncycastle.crypto.prng.FixedSecureRandom;\nimport org.bouncycastle.jce.interfaces.ECPrivateKey;\nimport org.bouncycastle.jce.interfaces.ECPublicKey;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\n/**\n * Test for ECIES - Elliptic Curve Integrated Encryption Scheme\n */\npublic class ECIESVectorTest\n    extends SimpleTest\n{\n    static byte[] message = Hex.decode(\"0102030405060708090a0b0c0d0e0f10111213141516\");\n\n    static byte[] derivation1 = Hex.decode(\"202122232425262728292a2b2c2d2e2f\");\n    static byte[] derivation2 = Hex.decode(\"202122232425262728292a2b2c2d2e2f404142434445464748\");\n\n    static byte[] encoding1 = Hex.decode(\"af\");\n    static byte[] encoding2 = Hex.decode(\"303132333435363738393a3b3c3d3e3f\");\n    static byte[] encoding3 = Hex.decode(\"101112131415161718191a1b1c1d1e1f303132333435363738393a3b3c3d3e3f\");\n\n    static byte[] p256_1_pub = Base64.decode(\"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEGVoxUX5AiyggqzcaXG3yG6cH6PKSX6fVOnCo5SKolfR8kwc6S8zmADXlpnjzMLNUVvGDL805VKIXNJHijq4+gw==\");\n    static byte[] p256_1_pri = Base64.decode(\"MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQg+dn4oLSJcx5lxZhVxJCip13O/OblrNzNyCj2b9sNbQegCgYIKoZIzj0DAQehRANCAAQZWjFRfkCLKCCrNxpcbfIbpwfo8pJfp9U6cKjlIqiV9HyTBzpLzOYANeWmePMws1RW8YMvzTlUohc0keKOrj6D\");\n    static byte[] p256_1_eph = Hex.decode(\"35ee388194396b5febbddb7e3618eaaba44f3bae766dac70f75ae7b84b210948\");\n\n    static byte[] p256_1_no_params = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae43dfbe605c746ba0c546c0c25ba5a00304587fbed07a35ca06415cf6ad4d6a69d01122c99e2c854fe818f\");\n\n    static byte[] p256_1_with_params11 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a33c5d1948ee93ea5dc7577d42d7c2e41ab08f85835\");\n    static byte[] p256_1_with_params12 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a3394725300acb7855f71a149d3f51a2e6fbd7f5389\");\n    static byte[] p256_1_with_params13 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a33920872328f8d05ec561ba8c6e58d82b79c360078\");\n    static byte[] p256_1_with_params21 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4499a4f4b6726651fb5e88178f01d831d9e5be0c1\");\n    static byte[] p256_1_with_params22 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df457c384a0e6402a5bb073120f08c706b49a4775d0\");\n    static byte[] p256_1_with_params23 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4039427c24c55a2627df0ebea00f9d1eded9dd64b\");\n\n    static byte[] p256_2_pub = Base64.decode(\"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAER4gx8nnRAkP+u76j0COZD81Cu9CTw3vczLnu1DG7ObI/VCzrDzJuswfzNWmxOFYXiXmZMAAkkEFA40nDSGOoqA==\");\n    static byte[] p256_2_pri = Base64.decode(\"MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgkflw6MQj4RbyuPFHoDE3i1dEaROS9uDSjGvrvPjqL7mgCgYIKoZIzj0DAQehRANCAARHiDHyedECQ/67vqPQI5kPzUK70JPDe9zMue7UMbs5sj9ULOsPMm6zB/M1abE4VheJeZkwACSQQUDjScNIY6io\");\n    static byte[] p256_2_eph = Hex.decode(\"0c37e1e0559a60d0b9c5b7b139a3f2df022b23abbd194bd95c8eff0aab1fd544\");\n\n    static byte[] p256_2_no_params = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dacd99a5cadfe82652a18c6058fc5ef7ffca626235fdbf7e2537f494d049d6f4e53d3d3df489cefb31101e1\");\n\n    static byte[] p256_2_with_params11 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dace0e423753f63e054824edbc298a5645d7a4010cc7e65947090625dc0d750c50b2d563f264718d95818d4\");\n    static byte[] p256_2_with_params12 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dace0e423753f63e054824edbc298a5645d7a4010cc7e6502850f65c7a2c466444dea69d95a2df9a4b6cf2c\");\n    static byte[] p256_2_with_params13 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dace0e423753f63e054824edbc298a5645d7a4010cc7e651188a654e47322a60e53ea20a9e02f0e78bf8a32\");\n    static byte[] p256_2_with_params21 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dacdbdbe5e5f72245f4b5c28ee1ae21442868aef592d4047c8149babf4e7faffb5474bd6d84d6b9f1c9faf5\");\n    static byte[] p256_2_with_params22 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dacdbdbe5e5f72245f4b5c28ee1ae21442868aef592d40471190bd9b4bddd63983e4963378c9f55c703a7e6\");\n    static byte[] p256_2_with_params23 = Hex.decode(\"04d1ef981f81edae5e2e517b498504105b636d950cc13a9e1e31c607d8f0adc00c2152f2abae4870274f8788c08be35a7908f5547416405f24818ef4e8e3ae8dacdbdbe5e5f72245f4b5c28ee1ae21442868aef592d404ca4307e077a693c6410815c7985b0678a42cbd84\");\n    \n    static byte[] p521_1_pub = Base64.decode(\"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBLNtLEbQBq2YGA2Q+eCwulIDggr1dCj8CqY/Yj/HuzicYGmVkNpr/gRfZHX4FRrh9HsGrS7tW+UA1pCQmn3p3aeEADiaXGIybDBsnuU20xntomQG/d/OHDkEaPee9nFNbi9Oha7BHTA/x2yyLMhQHeUlMgjz0DQqRxrwGJmvI85eNZpM=\");\n    static byte[] p521_1_pri = Base64.decode(\"MIH3AgEAMBAGByqGSM49AgEGBSuBBAAjBIHfMIHcAgEBBEIA1QAfnUvK1fAaENAArV0YnNGvnu2H1vGHNgsG3QV7p16gjd6UOgmGCZVM9SLlRH3fi9K1Xreyl4sQH3NeY+ZnInqgBwYFK4EEACOhgYkDgYYABAEs20sRtAGrZgYDZD54LC6UgOCCvV0KPwKpj9iP8e7OJxgaZWQ2mv+BF9kdfgVGuH0ewatLu1b5QDWkJCafendp4QAOJpcYjJsMGye5TbTGe2iZAb9384cOQRo9572cU1uL06FrsEdMD/HbLIsyFAd5SUyCPPQNCpHGvAYma8jzl41mkw==\");\n    static byte[] p521_1_eph = Hex.decode(\"d25c44819712555824360eef5afda947373ec462c2a0fd5bebbe0b0e4e40b4ebf483bc5b5eeb84542fc226dc2e5307ceec59fe7c557522b77589210b434295aabfc7\");\n\n    static byte[] p521_1_no_params = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7ee2102423e67f5ee7f46e87a26370b7734548f3baee7729c5ff1c1638b93f068628320c7c56b7a68fb86d\");\n\n    static byte[] p521_1_with_params11 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e49225382108fb5bdd6b4ad57fee63c2819d10c1bc7517bd0a5070c123d4e24d66f9f0bf21ec105629cb2\");\n    static byte[] p521_1_with_params12 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e49225382108fb5bdd6b4ad57fee63c2819d10c1bc751a51c6c78d905b0b7702d2edf89d0cf30f0d21c93\");\n    static byte[] p521_1_with_params13 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e49225382108fb5bdd6b4ad57fee63c2819d10c1bc7513a9fb7f21f78ef3467b54153b8e2998de5f46724\");\n    static byte[] p521_1_with_params21 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e1e0e7ac9ade1646519a365ef578f0bbe3556a818c83a0ce6226db7a3f3964e7a18955f9150fb030dcb09\");\n    static byte[] p521_1_with_params22 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e1e0e7ac9ade1646519a365ef578f0bbe3556a818c83ade9180b72d7d2e9218395ea7d83c00cf03c6b39d\");\n    static byte[] p521_1_with_params23 = Hex.decode(\"04009d332615586356df7caaabb4ddd1c7902f35595c0a708acf570659061313e44a5d581b0e646e0c623b737327ed2a6fb7391ed76ee5fdceb9480f8b414e37be786301f7f6162afa812f45c15aba6887c6559b4c379c98fddd95af179c457a6a0e414cd921fd3b5736068f2ce6bec2fbf28e0e230784a38bf6f7b6e42672e52959db1b7e1e0e7ac9ade1646519a365ef578f0bbe3556a818c83a605f2a4ef486f9215e546d618eb7624443ee1a7d\");\n\n    static byte[] p521_2_pub = Base64.decode(\"MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQACXj0hmGm68PQxI12y5sKMn4mN6mIMOEn1l6PBOeGtk8QuJHt1AS3X5DcPorJTxhuhdcdDHA3if1utfAw9hl7tCIBQELwgw2Vo3gYkdbG7Hj6O9kf8WpqIEJ3UsC4S0hITMY1knO41BaO4UdO+nUiN+PZPRRSqFwm3C5v3fffLSGbpIQ=\");\n    static byte[] p521_2_pri = Base64.decode(\"MIH3AgEAMBAGByqGSM49AgEGBSuBBAAjBIHfMIHcAgEBBEIB6s6VR/8WgiOvSjHT/n5Y91wESyI9e4GABUNWMXMPhNspwb9++7fyanbeliHNz9K61SjDG7rLXs90K1iRvHPJwmygBwYFK4EEACOhgYkDgYYABAAJePSGYabrw9DEjXbLmwoyfiY3qYgw4SfWXo8E54a2TxC4ke3UBLdfkNw+islPGG6F1x0McDeJ/W618DD2GXu0IgFAQvCDDZWjeBiR1sbsePo72R/xamogQndSwLhLSEhMxjWSc7jUFo7hR076dSI349k9FFKoXCbcLm/d998tIZukhA==\");\n    static byte[] p521_2_eph = Hex.decode(\"c9ee178c7f200a51a0053931c697001205f8923fd04b538c3fd5df2be43a6f304581f57138906bba0be631f7e0fd2804d00b5cb053559f080c13c913358f6e1fcc6d\");\n\n    static byte[] p521_2_no_params = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace65922842dba0351c1cebde53ee4ba9afadbd3a03a88507046f62c7383f96142c09df58be5b0a661893d41\");\n\n    static byte[] p521_2_with_params11 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace674ccf084d69e0bc9a728548d887a162ddf53a0002ed034b51a5406b831ce9ea713be7df54934b77dcc84\");\n    static byte[] p521_2_with_params12 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace674ccf084d69e0bc9a728548d887a162ddf53a0002ed0767534663184e99c0958451ea417729e29e02a60\");\n    static byte[] p521_2_with_params13 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace674ccf084d69e0bc9a728548d887a162ddf53a0002ed0517e1040bf7d57f2c8f9c3ce69e5a05a9a292700\");\n    static byte[] p521_2_with_params21 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace68a9e28bb5d49c07d5f5f59a27311619103aea50e48ddc66e0f20686c8d0c329db510facc1c014f800920\");\n    static byte[] p521_2_with_params22 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace68a9e28bb5d49c07d5f5f59a27311619103aea50e48ddbc970a66c80886782713e25ece75a23dec995121\");\n    static byte[] p521_2_with_params23 = Hex.decode(\"0400ddfd813bbba275fec8896a140036c9ee2fee49793cadc0a4d976d1b7827357b846e1e5aa9326b449c6ab268e3b2d145894cc02d33d849c108db1f696db6e867c2c01d129fcc80937aeb2beff58ebc9e9777ba864546aed12d86c5e6a89767cf5321ec323283032278698642c238b3fda4a5d5e9ea2f0b91ef7d979fda529687931ace68a9e28bb5d49c07d5f5f59a27311619103aea50e48dd7c3d8a51a95f88813d04a0c681355f6e86bb44e5\");\n\n    static byte[] old_p256_1_no_params = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae43dfbe605c746ba0c546c0c25ba5a00304587fbed07a3ebe44837c43b86025cc08e333b1631a8227b8d49\");\n\n    static byte[] old_p256_1_with_params11 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a332ce23d272262d47a528057eb5b0b11631707b28f\");\n    static byte[] old_p256_1_with_params12 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a3331e3e514868c771270632c9a9b852f2060d415da\");\n    static byte[] old_p256_1_with_params13 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4a57474b50621e97254c1f3b32635f694feb57e873a3353e10e6260e937bcdd244201a0de1d3941439076\");\n    static byte[] old_p256_1_with_params21 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4912a36ccc3c49de7d3d6b1fb312aeacf2d0b30e7\");\n    static byte[] old_p256_1_with_params22 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4171c056b90a3badd0bb689403ab214546b5f6411\");\n    static byte[] old_p256_1_with_params23 = Hex.decode(\"04bc8f4da6ea423c0698744b927ec71b67126d97ef9dd804c141a0dfcb466cc1c7df25539375ddb3ae7d08cc46fa2a78434c9f6123b108e39a5fe614729c3d8ae4da4d2bb723cd2ca918d1835dc2716a767085facd5df4ad1a6a561fe0582495cd14ac4494e4610ecddef1\");\n\n    ECIESVectorTest()\n    {\n    }\n\n    public String getName()\n    {\n        return \"ECIESVectorTest\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        KeyFactory ecFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        KeyPair keyPair = new KeyPair(ecFact.generatePublic(new X509EncodedKeySpec(p256_1_pub)), ecFact.generatePrivate(new PKCS8EncodedKeySpec(p256_1_pri)));\n\n        doTestNoParams(\"ECIES with P-256 None\", keyPair, \"ECIES\", p256_1_eph, p256_1_no_params);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding1, 128), p256_1_with_params11);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding2, 128), p256_1_with_params12);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding3, 128), p256_1_with_params13);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding1, 128), p256_1_with_params21);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding2, 128), p256_1_with_params22);\n        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"ECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding3, 128), p256_1_with_params23);\n\n        // no longer supported\n//        doTestNoParams(\"ECIES with P-256 None\", keyPair, \"OldECIES\", p256_1_eph, old_p256_1_no_params);\n//        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding1, 128), old_p256_1_with_params11);\n//        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding2, 128), old_p256_1_with_params12);\n//        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation1, encoding3, 128), old_p256_1_with_params13);\n//        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding1, 128), old_p256_1_with_params21);\n//        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding2, 128), old_p256_1_with_params22);\n//        doTestWithParams(\"ECIES with P-256 KP1 P11\", keyPair, \"OldECIES\", p256_1_eph, new IESParameterSpec(derivation2, encoding3, 128), old_p256_1_with_params23);\n\n        keyPair = new KeyPair(ecFact.generatePublic(new X509EncodedKeySpec(p256_2_pub)), ecFact.generatePrivate(new PKCS8EncodedKeySpec(p256_2_pri)));\n\n        doTestNoParams(\"ECIES with P-256 None\", keyPair, \"ECIES\", p256_2_eph, p256_2_no_params);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation1, encoding1, 128), p256_2_with_params11);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation1, encoding2, 128), p256_2_with_params12);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation1, encoding3, 128), p256_2_with_params13);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation2, encoding1, 128), p256_2_with_params21);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation2, encoding2, 128), p256_2_with_params22);\n        doTestWithParams(\"ECIES with P-256 KP2 P11\", keyPair, \"ECIES\", p256_2_eph, new IESParameterSpec(derivation2, encoding3, 128), p256_2_with_params23);\n\n        keyPair = new KeyPair(ecFact.generatePublic(new X509EncodedKeySpec(p521_1_pub)), ecFact.generatePrivate(new PKCS8EncodedKeySpec(p521_1_pri)));\n\n        doTestNoParams(\"ECIES with P-521 None\", keyPair, \"ECIES\", p521_1_eph, p521_1_no_params);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation1, encoding1, 128), p521_1_with_params11);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation1, encoding2, 128), p521_1_with_params12);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation1, encoding3, 128), p521_1_with_params13);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation2, encoding1, 128), p521_1_with_params21);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation2, encoding2, 128), p521_1_with_params22);\n        doTestWithParams(\"ECIES with P-521 KP1 P11\", keyPair, \"ECIES\", p521_1_eph, new IESParameterSpec(derivation2, encoding3, 128), p521_1_with_params23);\n\n        keyPair = new KeyPair(ecFact.generatePublic(new X509EncodedKeySpec(p521_2_pub)), ecFact.generatePrivate(new PKCS8EncodedKeySpec(p521_2_pri)));\n\n        doTestNoParams(\"ECIES with default\", keyPair, \"ECIES\", p521_2_eph, p521_2_no_params);\n        doTestWithParams(\"ECIES with P-521 KP2 P11\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation1, encoding1, 128), p521_2_with_params11);\n        doTestWithParams(\"ECIES with P-521 KP2 P12\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation1, encoding2, 128), p521_2_with_params12);\n        doTestWithParams(\"ECIES with P-521 KP2 P13\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation1, encoding3, 128), p521_2_with_params13);\n        doTestWithParams(\"ECIES with P-521 KP2 P21\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation2, encoding1, 128), p521_2_with_params21);\n        doTestWithParams(\"ECIES with P-521 KP2 P21\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation2, encoding2, 128), p521_2_with_params22);\n        doTestWithParams(\"ECIES with P-521 KP2 P21\", keyPair, \"ECIES\", p521_2_eph, new IESParameterSpec(derivation2, encoding3, 128), p521_2_with_params23);\n    }\n\n    public void doTestNoParams(\n        String testname,\n        KeyPair keyPair,\n        String cipher,\n        byte[] ephPrivateValue,\n        byte[] expected)\n        throws Exception\n    {\n\n\n        byte[] out1, out2;\n\n        // Generate static key pair\n        ECPublicKey   Pub = (ECPublicKey)keyPair.getPublic();\n        ECPrivateKey  Priv = (ECPrivateKey)keyPair.getPrivate();\n\n        Cipher c1 = Cipher.getInstance(cipher);\n        Cipher c2 = Cipher.getInstance(cipher);\n\n        // Testing with null parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, new FixedSecureRandom(ephPrivateValue));\n        c2.init(Cipher.DECRYPT_MODE, Priv, new FixedSecureRandom(ephPrivateValue));\n        out1 = c1.doFinal(message, 0, message.length);\n\n        if (!areEqual(out1, expected))\n        {\n            fail(testname + \" test failed encrypt with null parameters, DHAES mode false.\");\n        }\n\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n        {\n            fail(testname + \" test failed decrypt with null parameters, DHAES mode false.\");\n        }\n    }\n\n    public void doTestWithParams(\n        String testname,\n        KeyPair keyPair,\n        String cipher,\n        byte[] ephPrivateValue,\n        IESParameterSpec p,\n        byte[] expected)\n        throws Exception\n    {\n        byte[] out1, out2;\n\n        // Generate static key pair\n        ECPublicKey   Pub = (ECPublicKey)keyPair.getPublic();\n        ECPrivateKey  Priv = (ECPrivateKey)keyPair.getPrivate();\n\n        Cipher c1 = Cipher.getInstance(cipher);\n        Cipher c2 = Cipher.getInstance(cipher);\n\n        // Testing with given parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, p, new FixedSecureRandom(ephPrivateValue));\n        c2.init(Cipher.DECRYPT_MODE, Priv, p, new FixedSecureRandom(ephPrivateValue));\n        out1 = c1.doFinal(message, 0, message.length);\n\n        if (!areEqual(out1, expected))\n        {\n            fail(testname + \" test failed encrypt with non-null parameters, DHAES mode false.\");\n        }\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n        {\n            fail(testname + \" test failed decrypt with non-null parameters, DHAES mode false.\");\n        }\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECIESVectorTest());\n    }\n}\n"], "filenames": ["prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/DH.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/EC.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dh/IESCipher.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/ec/IESCipher.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/ies/AlgorithmParametersSpi.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/util/IESUtil.java", "prov/src/main/java/org/bouncycastle/jce/spec/IESParameterSpec.java", "prov/src/test/java/org/bouncycastle/jce/provider/test/DHIESTest.java", "prov/src/test/java/org/bouncycastle/jce/provider/test/ECIESTest.java", "prov/src/test/java/org/bouncycastle/jce/provider/test/ECIESVectorTest.java"], "buggy_code_start_loc": [41, 137, 24, 27, 59, 9, 34, 3, 24, 120], "buggy_code_end_loc": [54, 155, 562, 636, 134, 36, 52, 168, 217, 127], "fixing_code_start_loc": [41, 137, 24, 27, 60, 9, 33, 4, 25, 120], "fixing_code_end_loc": [49, 141, 543, 542, 153, 36, 33, 208, 239, 128], "type": "CWE-310", "message": "In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider.", "other": {"cve": {"id": "CVE-2016-1000344", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-04T21:29:00.223", "lastModified": "2020-10-20T22:15:17.577", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider."}, {"lang": "es", "value": "En la versi\u00f3n 1.55 y anteriores de Bouncy Castle JCE Provider, la implementaci\u00f3n DHIES permit\u00eda el uso del modo ECB. Este modo se considera inseguro y el fabricante le ha retirado el soporte."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-310"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.55", "matchCriteriaId": "946393A6-EEE2-4502-9309-81514DB5755B"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:2669", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:2927", "source": "cve@mitre.org"}, {"url": "https://github.com/bcgit/bc-java/commit/9385b0ebd277724b167fe1d1456e3c112112be1f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20181127-0004/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/9385b0ebd277724b167fe1d1456e3c112112be1f"}}