{"buggy_code": ["// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\").\n//\n// You may not use this file except in compliance with the License. A copy\n// of the License is located at\n//\n// http://aws.amazon.com/apache2.0/\n//\n// or in the \"license\" file accompanying this file. This file is distributed\n// on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n// either express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\n/* ESLint file-level overrides */\n/* global AWS bootbox document moment window $ angular:true */\n/* eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }] */\n/* eslint-disable no-console */\n/* eslint no-plusplus: \"off\" */\n/* eslint-env es6 */\n\nconst s3ExplorerColumns = {\n    check: 0, object: 1, folder: 2, date: 3, timestamp: 4, storageclass: 5, size: 6,\n};\n\n// Cache frequently-used selectors and data table\nconst $tb = $('#s3objects-table');\nconst $bc = $('#breadcrumb');\nconst $bl = $('#bucket-loader');\n\n// Map S3 storage types to text\nconst mapStorage = {\n    STANDARD: 'Standard',\n    STANDARD_IA: 'Standard IA',\n    ONEZONE_IA: 'One Zone-IA',\n    REDUCED_REDUNDANCY: 'Reduced Redundancy',\n    GLACIER: 'Glacier',\n    INTELLIGENT_TIERING: 'Intelligent Tiering',\n    DEEP_ARCHIVE: 'Deep Archive',\n};\n\n// Debug utility to complement console.log\nconst DEBUG = (() => {\n    const timestamp = () => {};\n    timestamp.toString = () => `[DEBUG ${moment().format()}]`;\n\n    return {\n        log: console.log.bind(console, '%s', timestamp),\n    };\n})();\n\n// Utility to convert bytes to readable text e.g. \"2 KB\" or \"5 MB\"\nfunction bytesToSize(bytes) {\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    if (bytes === 0) return '0 Bytes';\n    const ii = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)), 10);\n    return `${Math.round(bytes / (1024 ** ii), 2)} ${sizes[ii]}`;\n}\n\n// Convert cars/vw/golf.png to golf.png\nfunction fullpath2filename(path) {\n    return path.replace(/^.*[\\\\/]/, '');\n}\n\n// Convert cars/vw/golf.png to cars/vw/\nfunction fullpath2pathname(path) {\n    const index = path.lastIndexOf('/');\n    return index === -1 ? '/' : path.substring(0, index + 1);\n}\n\n// Convert cars/vw/ to vw/\nfunction prefix2folder(prefix) {\n    const parts = prefix.split('/');\n    return `${parts[parts.length - 2]}/`;\n}\n\n// Convert cars/vw/sedans/ to cars/vw/\nfunction prefix2parentfolder(prefix) {\n    const parts = prefix.split('/');\n    parts.splice(parts.length - 2, 1);\n    return parts.join('/');\n}\n\n// Convert cars/vw/golf.png to  cars/.../golf.png\nconst pathLimit = 80; // Max allowed path length\nconst pathHellip = String.fromCharCode(8230); // '&hellip;' char\nfunction path2short(path) {\n    if (path.length < pathLimit) return path;\n    const soft = `${prefix2parentfolder(fullpath2pathname(path)) + pathHellip}/${fullpath2filename(path)}`;\n    if (soft.length < pathLimit && soft.length > 2) return soft;\n    const hard = `${path.substring(0, path.indexOf('/') + 1) + pathHellip}/${fullpath2filename(path)}`;\n    return hard.length < pathLimit ? hard : path.substring(0, pathLimit) + pathHellip;\n}\n\n// Virtual-hosted-style URL, ex: https://mybucket1.s3.amazonaws.com/index.html\nfunction object2hrefvirt(bucket, key) {\n    const enckey = key.split('/').map(x => encodeURIComponent(x)).join('/');\n    return `${document.location.protocol}//${bucket}.s3.amazonaws.com/${enckey}`;\n}\n\n// Path-style URLs, ex: https://s3.amazonaws.com/mybucket1/index.html\n// eslint-disable-next-line no-unused-vars\nfunction object2hrefpath(bucket, key) {\n    const enckey = key.split('/').map(x => encodeURIComponent(x)).join('/');\n    return `${document.location.protocol}//s3.amazonaws.com/${bucket}/${enckey}`;\n}\n\nfunction isfolder(path) {\n    return path.endsWith('/');\n}\n\nfunction stripLeadTrailSlash(s) {\n    return s.replace(/^\\/+/g, '').replace(/\\/+$/g, '');\n}\n\n//\n// Shared service that all controllers can use\n//\nfunction SharedService($rootScope) {\n    DEBUG.log('SharedService init');\n\n    const shared = {\n        settings: null, viewprefix: null, skew: true,\n    };\n\n    shared.getSettings = () => this.settings;\n\n    shared.addFiles = (files) => { this.added_files = files; };\n\n    shared.getAddedFiles = () => this.added_files;\n\n    shared.hasAddedFiles = () => Object.prototype.hasOwnProperty.call(this, 'added_files');\n\n    shared.resetAddedFiles = () => { delete this.added_files; };\n\n    shared.changeSettings = (settings) => {\n        DEBUG.log('SharedService::changeSettings');\n        DEBUG.log('SharedService::changeSettings settings', settings);\n\n        this.settings = settings;\n        this.viewprefix = null;\n        $.fn.dataTableExt.afnFiltering.length = 0;\n\n        // AWS.config.update(settings.cred);\n        // AWS.config.update({ region: settings.region });\n        AWS.config.update(Object.assign(settings.cred, { region: settings.region }));\n\n        if (this.skew) {\n            this.correctClockSkew(settings.bucket);\n            this.skew = false;\n        }\n\n        if (settings.mfa.use === 'yes') {\n            const iam = new AWS.IAM();\n            DEBUG.log('listMFADevices');\n\n            iam.listMFADevices({}, (err1, data1) => {\n                if (err1) {\n                    DEBUG.log('listMFADevices error:', err1);\n                } else {\n                    const sts = new AWS.STS();\n                    DEBUG.log('listMFADevices data:', data1);\n\n                    const params = {\n                        DurationSeconds: 3600,\n                        SerialNumber: data1.MFADevices[0].SerialNumber,\n                        TokenCode: settings.mfa.code,\n                    };\n\n                    DEBUG.log('getSessionToken params:', params);\n                    sts.getSessionToken(params, (err2, data2) => {\n                        if (err2) {\n                            DEBUG.log('getSessionToken error:', err2);\n                        } else {\n                            DEBUG.log('getSessionToken data:', data2);\n                            this.settings.stscred = {\n                                accessKeyId: data2.Credentials.AccessKeyId,\n                                secretAccessKey: data2.Credentials.SecretAccessKey,\n                                sessionToken: data2.Credentials.SessionToken,\n                            };\n                            AWS.config.update(this.settings.stscred);\n                            $rootScope.$broadcast('broadcastChangeSettings', { settings: this.settings });\n                        }\n                    });\n                }\n            });\n        } else {\n            $rootScope.$broadcast('broadcastChangeSettings', { settings });\n        }\n    };\n\n    shared.changeViewPrefix = (prefix) => {\n        DEBUG.log('SharedService::changeViewPrefix');\n\n        if (this.settings.delimiter) {\n            // Folder-level view\n            this.settings.prefix = prefix;\n            this.viewprefix = null;\n            $.fn.dataTableExt.afnFiltering.length = 0;\n            $rootScope.$broadcast('broadcastChangePrefix', { prefix });\n        } else {\n            // Bucket-level view\n            this.viewprefix = prefix;\n            $rootScope.$broadcast('broadcastChangePrefix', { viewprefix: prefix });\n        }\n    };\n\n    shared.getViewPrefix = () => this.viewprefix || this.settings.prefix;\n\n    shared.viewRefresh = () => $rootScope.$broadcast('broadcastViewRefresh');\n\n    shared.trashObjects = (bucket, keys) => $rootScope.$broadcast('broadcastTrashObjects', { bucket, keys });\n\n    shared.addFolder = (_bucket, _folder) => $rootScope.$broadcast('broadcastViewRefresh');\n\n    // We use pre-signed URLs so that the user can securely download\n    // objects. For security reasons, we make these URLs time-limited and in\n    // order to do that we need the client's clock to be in sync with the AWS\n    // S3 endpoint otherwise we might create URLs that are immediately invalid,\n    // for example if the client's browser time is 55 minutes behind S3's time.\n    shared.correctClockSkew = (Bucket) => {\n        const s3 = new AWS.S3();\n        DEBUG.log('Invoke headBucket:', Bucket);\n\n        // Head the bucket to get a Date response. The 'date' header will need\n        // to be exposed in S3 CORS configuration.\n        s3.headBucket({ Bucket }, (err, data) => {\n            if (err) {\n                DEBUG.log('headBucket error:', err);\n            } else {\n                DEBUG.log('headBucket data:', JSON.stringify(data));\n                DEBUG.log('headBucket headers:', JSON.stringify(this.httpResponse.headers));\n\n                if (this.httpResponse.headers.date) {\n                    const date = Date.parse(this.httpResponse.headers.date);\n                    DEBUG.log('headers date:', date);\n                    AWS.config.systemClockOffset = new Date() - date;\n                    DEBUG.log('clock offset:', AWS.config.systemClockOffset);\n                    // Can now safely generate presigned urls\n                }\n            }\n        });\n    };\n\n    // Common error handling is done here in the shared service.\n    shared.showError = (params, err) => {\n        DEBUG.log(err);\n        const { message, code } = err;\n        const errors = Object.entries(err).map(([key, value]) => ({ key, value }));\n        const args = {\n            params, message, code, errors,\n        };\n        $rootScope.$broadcast('broadcastError', args);\n    };\n\n    return shared;\n}\n\n//\n// ViewController: code associated with the main S3 Explorer table that shows\n// the contents of the current bucket/folder and allows the user to downloads\n// files, delete files, and do various other S3 functions.\n//\n// eslint-disable-next-line no-shadow\nfunction ViewController($scope, SharedService) {\n    DEBUG.log('ViewController init');\n    window.viewScope = $scope; // for debugging\n    $scope.view = {\n        bucket: null, prefix: null, settings: null, objectCount: 0, keys_selected: [],\n    };\n    $scope.stop = false;\n\n    // Delegated event handler for S3 object/folder clicks. This is delegated\n    // because the object/folder rows are added dynamically and we do not want\n    // to have to assign click handlers to each and every row.\n    $tb.on('click', 'a', (e) => {\n        const { currentTarget: target } = e;\n        e.preventDefault();\n        DEBUG.log('target href:', target.href);\n        DEBUG.log('target dataset:', JSON.stringify(target.dataset));\n\n        if (target.dataset.s3 === 'folder') {\n            // User has clicked on a folder so navigate into that folder\n            SharedService.changeViewPrefix(target.dataset.s3key);\n        } else if ($scope.view.settings.auth === 'anon') {\n            // Unauthenticated user has clicked on an object so download it\n            // in new window/tab\n            window.open(target.href, '_blank');\n        } else {\n            // Authenticated ser has clicked on an object so create pre-signed\n            // URL and download it in new window/tab\n            const s3 = new AWS.S3();\n            const params = {\n                Bucket: $scope.view.settings.bucket, Key: target.dataset.s3key, Expires: 15,\n            };\n            DEBUG.log('params:', params);\n            s3.getSignedUrl('getObject', params, (err, url) => {\n                if (err) {\n                    DEBUG.log('err:', err);\n                    SharedService.showError(params, err);\n                } else {\n                    DEBUG.log('url:', url);\n                    window.open(url, '_blank');\n                }\n            });\n        }\n        return false;\n    });\n\n    // Delegated event handler for breadcrumb clicks.\n    $bc.on('click', 'a', (e) => {\n        DEBUG.log('breadcrumb li click');\n        e.preventDefault();\n        const { currentTarget: target } = e;\n        DEBUG.log('target dataset:', JSON.stringify(target.dataset));\n        SharedService.changeViewPrefix(target.dataset.prefix);\n        return false;\n    });\n\n    $scope.$on('broadcastChangeSettings', (e, args) => {\n        DEBUG.log('ViewController', 'broadcast change settings:', args.settings);\n        $scope.view.objectCount = 0;\n        $scope.view.settings = args.settings;\n        $scope.refresh();\n    });\n\n    $scope.$on('broadcastChangePrefix', (e, args) => {\n        DEBUG.log('ViewController', 'broadcast change prefix args:', args);\n        $scope.$apply(() => {\n            // Create breadcrumbs from current path (S3 bucket plus folder hierarchy)\n            $scope.folder2breadcrumbs($scope.view.settings.bucket, args.viewprefix || args.prefix);\n\n            if (args.viewprefix !== undefined && args.viewprefix !== null) {\n                // In bucket-level view we already have the data so we just need to\n                // filter it on prefix.\n                $.fn.dataTableExt.afnFiltering.length = 0;\n\n                $.fn.dataTableExt.afnFiltering.push(\n                    // Filter function returns true to include item in view\n                    (_o, d, _i) => d[1] !== args.viewprefix && d[1].startsWith(args.viewprefix),\n                );\n\n                // Re-draw the table\n                $tb.DataTable().draw();\n            } else {\n                // In folder-level view, we actually need to query the data for the\n                // the newly-selected folder.\n                $.fn.dataTableExt.afnFiltering.length = 0;\n                $scope.view.settings.prefix = args.prefix;\n                $scope.refresh();\n            }\n        });\n    });\n\n    $scope.$on('broadcastViewRefresh', () => {\n        DEBUG.log('ViewController', 'broadcast view refresh');\n        $scope.$apply(() => {\n            $scope.refresh();\n        });\n    });\n\n    $scope.renderObject = (data, _type, full) => {\n        // DEBUG.log(\"renderObject:\", JSON.stringify(full));\n        const href = object2hrefvirt($scope.view.settings.bucket, data);\n\n        function render(d, href2, text, download) {\n            if (download) {\n                return `<a data-s3=\"object\" data-s3key=\"${d}\" href=\"${href2}\" download=\"${download}\">${text}</a>`;\n            }\n            return `<a data-s3=\"folder\" data-s3key=\"${d}\" href=\"${href2}\">${text}</a>`;\n        }\n\n        if (full.CommonPrefix) {\n            // DEBUG.log(\"is folder: \" + data);\n            if ($scope.view.settings.prefix) {\n                return render(data, href, prefix2folder(data));\n            }\n\n            return render(data, href, data);\n        }\n\n        return render(data, href, fullpath2filename(data), fullpath2filename(data));\n    };\n\n    $scope.renderFolder = (data, _type, full) => (full.CommonPrefix ? '' : fullpath2pathname(data));\n\n    $scope.progresscb = (objects, folders) => {\n        DEBUG.log('ViewController', 'Progress cb objects:', objects);\n        DEBUG.log('ViewController', 'Progress cb folders:', folders);\n        $scope.$apply(() => {\n            $scope.view.objectCount += objects + folders;\n        });\n    };\n\n    $scope.refresh = () => {\n        DEBUG.log('refresh');\n        if ($scope.running()) {\n            DEBUG.log('running, stop');\n            $scope.listobjectsstop();\n        } else {\n            DEBUG.log('refresh', $scope.view.settings);\n            $scope.view.objectCount = 0;\n            $scope.folder2breadcrumbs(\n                $scope.view.settings.bucket,\n                SharedService.getViewPrefix(),\n            );\n            $scope.listobjects(\n                $scope.view.settings.bucket,\n                $scope.view.settings.prefix,\n                $scope.view.settings.delimiter,\n            );\n        }\n    };\n\n    $scope.upload = () => {\n        DEBUG.log('Add files');\n        $('#addedFiles').trigger('click');\n    };\n\n    $scope.trash = () => {\n        DEBUG.log('Trash:', $scope.view.keys_selected);\n        if ($scope.view.keys_selected.length > 0) {\n            SharedService.trashObjects($scope.view.settings.bucket, $scope.view.keys_selected);\n        }\n    };\n\n    $scope.running = () => $bl.hasClass('fa-spin');\n\n    $scope.folder2breadcrumbs = (bucket, prefix) => {\n        DEBUG.log('Breadcrumbs bucket:', bucket);\n        DEBUG.log('Breadcrumbs prefix:', prefix);\n\n        // Empty the current breadcrumb list\n        $('#breadcrumb li').remove();\n\n        // This array will contain the needed prefixes for each folder level.\n        const prefixes = [''];\n        let buildprefix = '';\n\n        if (prefix) {\n            prefixes.push(...prefix.replace(/\\/$/g, '').split('/'));\n        }\n\n        // Add bucket followed by prefix segments to make breadcrumbs\n        for (let ii = 0; ii < prefixes.length; ii++) {\n            let li;\n\n            // Bucket\n            if (ii === 0) {\n                const a1 = $('<a>').attr('href', '#').text(bucket);\n                li = $('<li>').append(a1);\n            // Followed by n - 1 intermediate folders\n            } else if (ii < prefixes.length - 1) {\n                const a2 = $('<a>').attr('href', '#').text(prefixes[ii]);\n                li = $('<li>').append(a2);\n            // Followed by current folder\n            } else {\n                li = $('<li>').text(prefixes[ii]);\n            }\n\n            // Accumulate prefix\n            if (ii) {\n                buildprefix = `${buildprefix}${prefixes[ii]}/`;\n            }\n\n            // Save prefix & bucket data for later click handler\n            li.children('a').attr('data-prefix', buildprefix).attr('data-bucket', bucket);\n\n            // Add to breadcrumbs\n            $bc.append(li);\n        }\n\n        // Make last breadcrumb active\n        $('#breadcrumb li:last').addClass('active');\n    };\n\n    $scope.listobjectsstop = (stop) => {\n        DEBUG.log('ViewController', 'listobjectsstop:', stop || true);\n        $scope.stop = stop || true;\n    };\n\n    // This is the listObjects callback\n    $scope.listobjectscb = (err, data) => {\n        DEBUG.log('Enter listobjectscb');\n        if (err) {\n            DEBUG.log('Error:', JSON.stringify(err));\n            DEBUG.log('Error:', err.stack);\n            $bl.removeClass('fa-spin');\n            const params = { bucket: $scope.view.bucket, prefix: $scope.view.prefix };\n            SharedService.showError(params, err);\n        } else {\n            let marker;\n\n            // Store marker before filtering data. Note that Marker is the\n            // previous request marker, not the marker to use on the next call\n            // to listObject. For the one to use on the next invocation you\n            // need to use NextMarker or retrieve the key of the last item.\n            if (data.IsTruncated) {\n                if (data.NextMarker) {\n                    marker = data.NextMarker;\n                } else if (data.Contents.length > 0) {\n                    marker = data.Contents[data.Contents.length - 1].Key;\n                }\n            }\n\n            const count = { objects: 0, folders: 0 };\n\n            // NOTE: folders are returned in CommonPrefixes if delimiter is\n            // supplied on the listObjects call and in Contents if delimiter\n            // is not supplied on the listObjects call, so we may need to\n            // source our DataTable folders from Contents or CommonPrefixes.\n            // DEBUG.log(\"Contents\", data.Contents);\n            $.each(data.Contents, (index, value) => {\n                if (value.Key === data.Prefix) {\n                    // ignore this folder\n                } else if (isfolder(value.Key)) {\n                    $tb.DataTable().row.add({\n                        CommonPrefix: true, Key: value.Key, StorageClass: null,\n                    });\n                    count.folders++;\n                } else {\n                    $tb.DataTable().row.add(value);\n                    count.objects++;\n                }\n            });\n\n            // Add folders to the datatable. Note that folder entries in the\n            // DataTable will have different content to object entries and the\n            // folders can be identified by CommonPrefix=true.\n            // DEBUG.log(\"CommonPrefixes:\", data.CommonPrefixes);\n            $.each(data.CommonPrefixes, (index, value) => {\n                $tb.DataTable().rows.add([\n                    { CommonPrefix: true, Key: value.Prefix, StorageClass: null },\n                ]);\n                count.objects++;\n            });\n\n            // Re-draw the table\n            $tb.DataTable().draw();\n\n            // Make progress callback to report objects read so far\n            $scope.progresscb(count.objects, count.folders);\n\n            const params = {\n                Bucket: data.Name, Prefix: data.Prefix, Delimiter: data.Delimiter, Marker: marker,\n            };\n\n            // DEBUG.log(\"AWS.config:\", JSON.stringify(AWS.config));\n\n            if ($scope.stop) {\n                DEBUG.log('Bucket', data.Name, 'stopped');\n                $bl.removeClass('fa-spin');\n            } else if (data.IsTruncated) {\n                DEBUG.log('Bucket', data.Name, 'truncated');\n                const s3 = new AWS.S3(AWS.config);\n                if (AWS.config.credentials && AWS.config.credentials.accessKeyId) {\n                    DEBUG.log('Make S3 authenticated call to listObjects');\n                    s3.listObjects(params, $scope.listobjectscb);\n                } else {\n                    DEBUG.log('Make S3 unauthenticated call to listObjects');\n                    s3.makeUnauthenticatedRequest('listObjects', params, $scope.listobjectscb);\n                }\n            } else {\n                DEBUG.log('Bucket', data.Name, 'listing complete');\n                $bl.removeClass('fa-spin');\n            }\n        }\n    };\n\n    // Start the spinner, clear the table, make an S3 listObjects request\n    $scope.listobjects = (Bucket, Prefix, Delimiter, Marker) => {\n        DEBUG.log('Enter listobjects');\n\n        // If this is the initial listObjects\n        if (!Marker) {\n            // Checked on each event cycle to stop list prematurely\n            $scope.stop = false;\n\n            // Start spinner and clear table\n            $scope.view.keys_selected = [];\n            $bl.addClass('fa-spin');\n            $tb.DataTable().clear();\n            $tb.DataTable().column(s3ExplorerColumns.folder).visible(!Delimiter);\n        }\n\n        const s3 = new AWS.S3(AWS.config);\n        const params = {\n            Bucket, Prefix, Delimiter, Marker,\n        };\n\n        // DEBUG.log(\"AWS.config:\", JSON.stringify(AWS.config));\n\n        // Now make S3 listObjects call(s)\n        if (AWS.config.credentials && AWS.config.credentials.accessKeyId) {\n            DEBUG.log('Make S3 authenticated call to listObjects, params:', params);\n            s3.listObjects(params, $scope.listobjectscb);\n        } else {\n            DEBUG.log('Make S3 unauthenticated call to listObjects, params:', params);\n            s3.makeUnauthenticatedRequest('listObjects', params, $scope.listobjectscb);\n        }\n    };\n\n    this.isfolder = path => path.endsWith('/');\n\n    // Individual render functions so that we can control how column data appears\n    this.renderSelect = (data, type, _full) => {\n        if (type === 'display') {\n            return '<span class=\"text-center\"><input type=\"checkbox\"></span>';\n        }\n\n        return '';\n    };\n\n    this.renderObject = (data, type, full) => {\n        if (type === 'display') {\n            return $scope.renderObject(data, type, full);\n        }\n\n        return data;\n    };\n\n    this.renderFolder = (data, type, full) => $scope.renderFolder(data, type, full);\n\n    this.renderLastModified = (data, _type, _full) => {\n        if (data) {\n            return moment(data).fromNow();\n        }\n\n        return '';\n    };\n\n    this.renderTimestamp = (data, _type, _full) => {\n        if (data) {\n            return moment(data).local().format('YYYY-MM-DD HH:mm:ss');\n        }\n\n        return '';\n    };\n\n    this.renderStorageClass = (data, _type, _full) => {\n        if (data) {\n            return mapStorage[data];\n        }\n\n        return '';\n    };\n\n    // Object sizes are displayed in nicer format e.g. 1.2 MB but are otherwise\n    // handled as simple number of bytes e.g. for sorting purposes\n    this.dataSize = (source, type, _val) => {\n        if (source.Size) {\n            return (type === 'display') ? bytesToSize(source.Size) : source.Size;\n        }\n\n        return '';\n    };\n\n    // Initial DataTable settings (must only do this one time)\n    $tb.DataTable({\n        iDisplayLength: 25,\n        order: [[2, 'asc'], [1, 'asc']],\n        aoColumnDefs: [\n            {\n                aTargets: [0], mData: null, mRender: this.renderSelect, sClass: 'text-center', sWidth: '20px', bSortable: false,\n            },\n            {\n                aTargets: [1], mData: 'Key', mRender: this.renderObject, sType: 'key',\n            },\n            {\n                aTargets: [2], mData: 'Key', mRender: this.renderFolder,\n            },\n            {\n                aTargets: [3], mData: 'LastModified', mRender: this.renderLastModified,\n            },\n            {\n                aTargets: [4], mData: 'LastModified', mRender: this.renderTimestamp,\n            },\n            {\n                aTargets: [5], mData: 'StorageClass', mRender: this.renderStorageClass,\n            },\n            {\n                aTargets: [6], mData: this.dataSize,\n            },\n        ],\n    });\n\n    // Custom ascending sort for Key column so folders appear before objects\n    $.fn.dataTableExt.oSort['key-asc'] = (a, b) => {\n        const x = (isfolder(a) ? `0-${a}` : `1-${a}`).toLowerCase();\n        const y = (isfolder(b) ? `0-${b}` : `1-${b}`).toLowerCase();\n        if (x < y) return -1;\n        if (x > y) return 1;\n        return 0;\n    };\n\n    // Custom descending sort for Key column so folders appear before objects\n    $.fn.dataTableExt.oSort['key-desc'] = (a, b) => {\n        const x = (isfolder(a) ? `1-${a}` : `0-${a}`).toLowerCase();\n        const y = (isfolder(b) ? `1-${b}` : `0-${b}`).toLowerCase();\n        if (x < y) return 1;\n        if (x > y) return -1;\n        return 0;\n    };\n\n    // Handle click on selection checkbox\n    $('#s3objects-table tbody').on('click', 'input[type=\"checkbox\"]', (e1) => {\n        const checkbox = e1.currentTarget;\n        const $row = $(checkbox).closest('tr');\n        const data = $tb.DataTable().row($row).data();\n        let index = -1;\n\n        // Prevent click event from propagating to parent\n        e1.stopPropagation();\n\n        // Find matching key in currently checked rows\n        index = $scope.view.keys_selected.findIndex(e2 => e2.Key === data.Key);\n\n        // Remove or add checked row as appropriate\n        if (checkbox.checked && index === -1) {\n            $scope.view.keys_selected.push(data);\n        } else if (!checkbox.checked && index !== -1) {\n            $scope.view.keys_selected.splice(index, 1);\n        }\n\n        $scope.$apply(() => {\n            // Doing this to force Angular to update models\n            DEBUG.log('Selected rows:', $scope.view.keys_selected);\n        });\n\n        if (checkbox.checked) {\n            $row.addClass('selected');\n        } else {\n            $row.removeClass('selected');\n        }\n    });\n\n    // Handle click on table cells\n    $('#s3objects-table tbody').on('click', 'td', (e) => {\n        $(e.currentTarget).parent().find('input[type=\"checkbox\"]').trigger('click');\n    });\n}\n\n//\n// AddFolderController: code associated with the add folder function.\n//\n// eslint-disable-next-line no-shadow\nfunction AddFolderController($scope, SharedService) {\n    DEBUG.log('AddFolderController init');\n    $scope.add_folder = {\n        settings: null, bucket: null, entered_folder: '', view_prefix: '/',\n    };\n    window.addFolderScope = $scope; // for debugging\n    DEBUG.log('AddFolderController add_folder init', $scope.add_folder);\n\n    $scope.$on('broadcastChangeSettings', (e, args) => {\n        DEBUG.log('AddFolderController', 'broadcast change settings bucket:', args.settings.bucket);\n        $scope.add_folder.settings = args.settings;\n        $scope.add_folder.bucket = args.settings.bucket;\n        DEBUG.log('AddFolderController add_folder bcs', $scope.add_folder);\n    });\n\n    $scope.$on('broadcastChangePrefix', (e, args) => {\n        DEBUG.log('AddFolderController', 'broadcast change prefix args:', args);\n        $scope.add_folder.view_prefix = args.prefix || args.viewprefix || '/';\n        DEBUG.log('AddFolderController add_folder bcp', $scope.add_folder);\n    });\n\n    $scope.addFolder = () => {\n        DEBUG.log('Add folder');\n        DEBUG.log('Current prefix:', $scope.add_folder.view_prefix);\n\n        const ef = stripLeadTrailSlash($scope.add_folder.entered_folder);\n        const vpef = $scope.add_folder.view_prefix + ef;\n        const folder = `${stripLeadTrailSlash(vpef)}/`;\n        DEBUG.log('Calculated folder:', folder);\n\n        const s3 = new AWS.S3(AWS.config);\n        const params = { Bucket: $scope.add_folder.bucket, Key: folder };\n\n        DEBUG.log('Invoke headObject:', params);\n\n        // Test if an object with this key already exists\n        s3.headObject(params, (err1, _data1) => {\n            if (err1 && err1.code === 'NotFound') {\n                DEBUG.log('Invoke putObject:', params);\n\n                // Create a zero-sized object to simulate a folder\n                s3.putObject(params, (err2, _data2) => {\n                    if (err2) {\n                        DEBUG.log('putObject error:', err2);\n                        bootbox.alert('Error creating folder:', err2);\n                    } else {\n                        SharedService.addFolder(params.Bucket, params.Key);\n                        $('#AddFolderModal').modal('hide');\n                        $scope.add_folder.entered_folder = '';\n                    }\n                });\n            } else if (err1) {\n                bootbox.alert('Error checking existence of folder:', err1);\n            } else {\n                bootbox.alert('Error: folder or object already exists at', params.Key);\n            }\n        });\n    };\n}\n\n//\n// InfoController: code associated with the Info modal where the user can\n// view bucket policies, CORS configuration and About text.\n//\n// Note: do not be tempted to correct the eslint no-unused-vars error\n// with SharedService below. Doing so will break injection.\n//\n// eslint-disable-next-line no-shadow\nfunction InfoController($scope) {\n    DEBUG.log('InfoController init');\n    window.infoScope = $scope; // for debugging\n    $scope.info = {\n        cors: null, policy: null, bucket: null, settings: null,\n    };\n\n    $scope.$on('broadcastChangeSettings', (e, args) => {\n        DEBUG.log('InfoController', 'broadcast change settings bucket:', args.settings.bucket);\n        $scope.info.settings = args.settings;\n        $scope.info.bucket = args.settings.bucket;\n        $scope.getBucketCors(args.settings.bucket);\n        $scope.getBucketPolicy(args.settings.bucket);\n    });\n\n    $scope.getBucketPolicy = (Bucket) => {\n        const params = { Bucket };\n        $scope.info.policy = null;\n        DEBUG.log('call getBucketPolicy:', Bucket);\n\n        new AWS.S3(AWS.config).getBucketPolicy(params, (err, data) => {\n            let text;\n            if (err && err.code === 'NoSuchBucketPolicy') {\n                DEBUG.log(err);\n                text = 'No bucket policy.';\n            } else if (err) {\n                DEBUG.log(err);\n                text = JSON.stringify(err);\n            } else {\n                DEBUG.log(data.Policy);\n                $scope.info.policy = data.Policy;\n                DEBUG.log('Info:', $scope.info);\n                text = JSON.stringify(JSON.parse(data.Policy.trim()), null, 2);\n            }\n            $('#info-policy').text(text);\n        });\n    };\n\n    $scope.getBucketCors = (Bucket) => {\n        const params = { Bucket };\n        $scope.info.cors = null;\n        DEBUG.log('call getBucketCors:', Bucket);\n\n        new AWS.S3(AWS.config).getBucketCors(params, (err, data) => {\n            let text;\n            if (err && err.code === 'NoSuchCORSConfiguration') {\n                DEBUG.log(err);\n                text = 'This bucket has no CORS configuration.';\n            } else if (err) {\n                DEBUG.log(err);\n                text = JSON.stringify(err);\n            } else {\n                DEBUG.log(data.CORSRules);\n                [$scope.info.cors] = data.CORSRules;\n                DEBUG.log('Info:', $scope.info);\n                text = JSON.stringify(data.CORSRules, null, 2);\n            }\n            $('#info-cors').text(text);\n        });\n    };\n}\n\n//\n// SettingsController: code associated with the Settings dialog where the\n// user provides credentials and bucket information.\n//\n// eslint-disable-next-line no-shadow\nfunction SettingsController($scope, SharedService) {\n    DEBUG.log('SettingsController init');\n    window.settingsScope = $scope; // for debugging\n\n    // Initialized for an unauthenticated user exploring the current bucket\n    // TODO: calculate current bucket and initialize below\n    $scope.settings = {\n        auth: 'anon', region: '', bucket: '', entered_bucket: '', selected_bucket: '', view: 'folder', delimiter: '/', prefix: '',\n    };\n    $scope.settings.mfa = { use: 'no', code: '' };\n    $scope.settings.cred = { accessKeyId: '', secretAccessKey: '', sessionToken: '' };\n    $scope.settings.stscred = null;\n\n    // TODO: at present the Settings dialog closes after credentials have been supplied\n    // even if the subsequent AWS calls fail with networking or permissions errors. It\n    // would be better for the Settings dialog to synchronously make the necessary API\n    // calls and ensure they succeed before closing the modal dialog.\n    $scope.update = () => {\n        DEBUG.log('Settings updated');\n        $('#SettingsModal').modal('hide');\n        $scope.settings.bucket = $scope.settings.selected_bucket || $scope.settings.entered_bucket;\n\n        // If manually entered bucket then add it to list of buckets for future\n        if ($scope.settings.entered_bucket) {\n            if (!$scope.settings.buckets) {\n                $scope.settings.buckets = [];\n            }\n            if ($.inArray($scope.settings.entered_bucket, $scope.settings.buckets) === -1) {\n                $scope.settings.buckets.push($scope.settings.entered_bucket);\n                $scope.settings.buckets = $scope.settings.buckets.sort();\n            }\n        }\n\n        // If anonymous usage then create empty set of credentials\n        if ($scope.settings.auth === 'anon') {\n            $scope.settings.cred = { accessKeyId: null, secretAccessKey: null };\n        }\n\n        SharedService.changeSettings($scope.settings);\n    };\n}\n\n//\n// UploadController: code associated with the Upload dialog where the\n// user reviews the list of dropped files and request upload to S3.\n//\n// eslint-disable-next-line no-shadow\nfunction UploadController($scope, SharedService) {\n    DEBUG.log('UploadController init');\n    window.uploadScope = $scope; // for debugging\n    $scope.upload = {\n        button: null, title: null, files: [],\n    };\n\n    // Cache jquery selectors\n    const $btnUpload = $('#upload-btn-upload');\n    const $btnCancel = $('#upload-btn-cancel');\n\n    //\n    // Upload a list of local files to the provided bucket and prefix\n    //\n    $scope.uploadFiles = (Bucket, prefix) => {\n        $scope.$apply(() => {\n            $scope.upload.uploading = true;\n        });\n\n        DEBUG.log('Dropped files:', $scope.upload.files);\n\n        $scope.upload.files.forEach((file, ii) => {\n            DEBUG.log('File:', file);\n            DEBUG.log('Index:', ii);\n\n            $(`#upload-td-${ii}`).html(\n                `<div class=\"progress\"><span id=\"upload-td-progress-${ii}\" class=\"progress-bar\" data-percent=\"0\">0%</span></div>`,\n            );\n\n            const s3 = new AWS.S3(AWS.config);\n            const params = {\n                Body: file.file, Bucket, Key: (prefix || '') + (file.file.fullPath ? file.file.fullPath : file.file.name), ContentType: file.file.type,\n            };\n\n            const funcprogress = (evt) => {\n                DEBUG.log('Part:', evt.part, evt.loaded, evt.total);\n                const pc = evt.total ? ((evt.loaded * 100.0) / evt.total) : 0;\n                const pct = Math.round(pc);\n                const pcts = `${pct}%`;\n                const col = $(`#upload-td-progress-${ii}`);\n                col.attr('data-percent', pct);\n                col.css('width', pcts).text(pcts);\n            };\n\n            const funcsend = (err, data) => {\n                if (err) {\n                    // AccessDenied is a normal consequence of lack of permission\n                    // and we do not treat this as completely unexpected\n                    if (err.code === 'AccessDenied') {\n                        $(`#upload-td-${ii}`).html('<span class=\"uploaderror\">Access Denied</span>');\n                    } else {\n                        DEBUG.log(JSON.stringify(err));\n                        $(`#upload-td-${ii}`).html(`<span class=\"uploaderror\">Failed:&nbsp${err.code}</span>`);\n                        SharedService.showError(params, err);\n                    }\n                } else {\n                    DEBUG.log('Uploaded', file.file.name, 'to', data.Location);\n                    let count = $btnUpload.attr('data-filecount');\n                    $btnUpload.attr('data-filecount', --count);\n                    $(`#upload-td-progress-${ii}`).addClass('progress-bar-success');\n\n                    $scope.$apply(() => {\n                        $scope.upload.button = `Upload (${count})`;\n                    });\n\n                    // If all files uploaded then refresh underlying folder view\n                    if (count === 0) {\n                        $btnUpload.hide();\n                        $btnCancel.text('Close');\n                        SharedService.viewRefresh();\n                    }\n                }\n            };\n\n            s3.upload(params)\n                .on('httpUploadProgress', funcprogress)\n                .send(funcsend);\n        });\n    };\n\n    // Wrap readEntries in a promise to make working with readEntries easier\n    async function readEntriesPromise(directoryReader) {\n        try {\n            return await new Promise((resolve, reject) => {\n                directoryReader.readEntries(resolve, reject);\n            });\n        } catch (err) {\n            DEBUG.log(err);\n            return undefined;\n        }\n    }\n\n    // Get all the entries (files or sub-directories) in a directory\n    // by calling readEntries until it returns empty array\n    async function readAllDirectoryEntries(directoryReader) {\n        const entries = [];\n        let readEntries = await readEntriesPromise(directoryReader);\n        while (readEntries.length > 0) {\n            entries.push(...readEntries);\n            readEntries = await readEntriesPromise(directoryReader);\n        }\n        return entries;\n    }\n\n    // Retrieve File object from FileEntry\n    async function filePromise(fileEntry) {\n        try {\n            return await new Promise((resolve, reject) => {\n                fileEntry.file(resolve, reject);\n            });\n        } catch (err) {\n            DEBUG.log(err);\n            return undefined;\n        }\n    }\n\n    // Get all files recursively\n    async function getAllFileEntries(dataTransferItemList) {\n        const fileEntries = [];\n        const queue = [];\n        for (let i = 0; i < dataTransferItemList.length; i++) {\n            const dtItem = dataTransferItemList[i];\n            queue.push(typeof dtItem.webkitGetAsEntry === 'function' ? dtItem.webkitGetAsEntry() : dtItem.getAsEntry());\n        }\n        while (queue.length > 0) {\n            const entry = queue.shift();\n            if (entry.isFile) {\n                const file = await filePromise(entry);\n                file.fullPath = entry.fullPath.substring(1);\n                fileEntries.push(file);\n            } else if (entry.isDirectory) {\n                const reader = entry.createReader();\n                queue.push(...await readAllDirectoryEntries(reader));\n            }\n        }\n        return fileEntries;\n    }\n\n    // Wrapper to get files safe\n    async function getFilesList(dataTransfer) {\n        if (dataTransfer.items.length > 0) {\n            if (typeof dataTransfer.items[0].webkitGetAsEntry === 'function'\n               || typeof dataTransfer.items[0].getAsEntry === 'function') return getAllFileEntries(dataTransfer.items);\n            DEBUG.log('Can not do folders upload, falling back to files only');\n            return dataTransfer.files;\n        } return [];\n    }\n\n    //\n    // Drag/drop handler for files to be uploaded\n    //\n    $scope.dropZone = (target) => {\n        target\n            .on('dragover', () => {\n                target.addClass('dragover');\n                return false;\n            })\n            .on('dragend dragleave', () => {\n                target.removeClass('dragover');\n                return false;\n            })\n            .on('drop', async (e) => {\n                DEBUG.log('Dropped files');\n                e.stopPropagation();\n                e.preventDefault();\n\n                target.removeClass('dragover');\n\n                $bl.addClass('fa-spin');\n                const files = SharedService.hasAddedFiles()\n                    ? SharedService.getAddedFiles()\n                    : await getFilesList(e.originalEvent.dataTransfer);\n                $bl.removeClass('fa-spin');\n\n                $scope.$apply(() => {\n                    $scope.upload.files = [];\n                    for (let ii = 0; ii < files.length; ii++) {\n                        const fileii = files[ii];\n                        if (fileii.type || fileii.size % 4096 !== 0 || fileii.size > 1048576) {\n                            DEBUG.log('File:', fileii.name, 'Size:', fileii.size, 'Type:', fileii.type);\n                            $scope.upload.files.push({\n                                file: fileii,\n                                name: fileii.fullPath ? fileii.fullPath : fileii.name,\n                                type: fileii.type,\n                                size: bytesToSize(fileii.size),\n                                short: path2short(fileii.fullPath ? fileii.fullPath : fileii.name),\n                            });\n                        }\n                    }\n                });\n\n                const { bucket } = SharedService.getSettings();\n                const prefix = SharedService.getViewPrefix();\n\n                // Remove any prior click handler from Upload button\n                $btnUpload.unbind('click');\n\n                // Add new click handler for Upload button\n                $btnUpload.click((e2) => {\n                    e2.preventDefault();\n                    $scope.uploadFiles(bucket, prefix);\n                });\n\n                // Reset buttons for initial use\n                $btnUpload.show();\n                $btnCancel.text('Cancel');\n\n                // Bind file count into button\n                $btnUpload.attr('data-filecount', files.length);\n                $scope.$apply(() => {\n                    $scope.upload.title = `${bucket}/${prefix || ''}`;\n                    $scope.upload.button = `Upload (${files.length})`;\n                    $scope.upload.uploading = false;\n                });\n\n                // Reset files selector\n                if (SharedService.hasAddedFiles()) {\n                    SharedService.resetAddedFiles();\n                    $('#addedFiles').val('');\n                }\n\n                // Launch the uploader modal\n                $('#UploadModal').modal({ keyboard: true, backdrop: 'static' });\n            });\n    };\n\n    // Enable dropzone behavior and highlighting\n    $scope.dropZone($('.dropzone'));\n\n    // Simulate drop event on change of files selector\n    $('#addedFiles').on('change', (e) => {\n        SharedService.addFiles(e.target.files);\n        $('.dropzone').trigger('drop');\n    });\n}\n\n//\n// ErrorController: code associated with displaying runtime errors.\n//\nfunction ErrorController($scope) {\n    DEBUG.log('ErrorController init');\n    window.errorScope = $scope; // for debugging\n    $scope.error = {\n        errors: [], message: '',\n    };\n\n    $scope.$on('broadcastError', (e, args) => {\n        DEBUG.log('ErrorController', 'broadcast error', args);\n\n        $scope.$apply(() => {\n            Object.assign($scope.error, args);\n            DEBUG.log('scope errors', $scope.error.errors);\n        });\n\n        // Launch the error modal\n        $('#ErrorModal').modal({ keyboard: true, backdrop: 'static' });\n    });\n}\n\n//\n// TrashController: code associated with the Trash modal where the user can\n// delete objects.\n//\n// eslint-disable-next-line no-shadow\nfunction TrashController($scope, SharedService) {\n    DEBUG.log('TrashController init');\n    window.trashScope = $scope; // for debugging\n    $scope.trash = { title: null, button: null };\n\n    // Cache jquery selectors\n    const $btnDelete = $('#trash-btn-delete');\n    const $btnCancel = $('#trash-btn-cancel');\n\n    //\n    // Delete a list of objects from the provided S3 bucket\n    //\n    $scope.deleteFiles = (Bucket, objects, recursion) => {\n        DEBUG.log('Delete files:', objects);\n\n        $scope.$apply(() => {\n            $scope.trash.trashing = true;\n        });\n\n        for (let ii = 0; ii < objects.length; ii++) {\n            DEBUG.log('Delete key:', objects[ii].Key);\n            DEBUG.log('Object:', objects[ii]);\n            DEBUG.log('Index:', ii);\n\n            const s3 = new AWS.S3(AWS.config);\n\n            // If the user is deleting a folder then recursively list\n            // objects and delete them\n            if (isfolder(objects[ii].Key) && SharedService.getSettings().delimiter) {\n                const params = { Bucket, Prefix: objects[ii].Key };\n                s3.listObjects(params, (err, data) => {\n                    if (err) {\n                        if (!recursion) {\n                            // AccessDenied is a normal consequence of lack of permission\n                            // and we do not treat this as completely unexpected\n                            if (err.code === 'AccessDenied') {\n                                $(`#trash-td-${ii}`).html('<span class=\"trasherror\">Access Denied</span>');\n                            } else {\n                                DEBUG.log(JSON.stringify(err));\n                                $(`#trash-td-${ii}`).html(`<span class=\"trasherror\">Failed:&nbsp${err.code}</span>`);\n                                SharedService.showError(params, err);\n                            }\n                        } else {\n                            DEBUG.log(JSON.stringify(err));\n                            SharedService.showError(params, err);\n                        }\n                    } else if (data.Contents.length > 0) {\n                        $scope.deleteFiles(Bucket, data.Contents, true);\n                    }\n                });\n            }\n\n            const params = { Bucket, Key: objects[ii].Key };\n\n            DEBUG.log('Delete params:', params);\n            s3.deleteObject(params, (err, _data) => {\n                if (err) {\n                    if (!recursion) {\n                        // AccessDenied is a normal consequence of lack of permission\n                        // and we do not treat this as completely unexpected\n                        if (err.code === 'AccessDenied') {\n                            $(`#trash-td-${ii}`).html('<span class=\"trasherror\">Access Denied</span>');\n                        } else {\n                            DEBUG.log(JSON.stringify(err));\n                            $(`#trash-td-${ii}`).html(`<span class=\"trasherror\">Failed:&nbsp${err.code}</span>`);\n                            SharedService.showError(params, err);\n                        }\n                    } else {\n                        DEBUG.log(JSON.stringify(err));\n                        SharedService.showError(params, err);\n                    }\n                } else {\n                    DEBUG.log('Deleted', objects[ii].Key, 'from', Bucket);\n                    let count = $btnDelete.attr('data-filecount');\n\n                    if (!recursion) {\n                        $(`#trash-td-${ii}`).html('<span class=\"trashdeleted\">Deleted</span>');\n                        $btnDelete.attr('data-filecount', --count);\n                    }\n\n                    // Update count in Delete button\n                    $scope.$apply(() => {\n                        $scope.trash.button = `Delete (${count})`;\n                    });\n\n                    // If all files deleted then update buttons\n                    if (count === 0) {\n                        $btnDelete.hide();\n                        $btnCancel.text('Close');\n                    }\n\n                    // Refresh underlying folder view\n                    SharedService.viewRefresh();\n                }\n            });\n        }\n    };\n\n    $scope.$on('broadcastTrashObjects', (e, args) => {\n        DEBUG.log('TrashController', 'broadcast trash objects', args);\n\n        $('#trash-tbody tr').remove();\n\n        for (let ii = 0; ii < args.keys.length; ii++) {\n            const obj = args.keys[ii];\n            DEBUG.log('Object to be deleted:', obj);\n\n            const td = [\n                $('<td>').append(ii + 1),\n                $('<td>').append(path2short(isfolder(obj.Key) ? prefix2folder(obj.Key) : fullpath2filename(obj.Key))),\n                $('<td>').append(path2short(isfolder(obj.Key) ? prefix2parentfolder(obj.Key) : fullpath2pathname(obj.Key))),\n                $('<td>').append(isfolder(obj.Key) ? '' : moment(obj.LastModified).fromNow()),\n                $('<td>').append(obj.LastModified ? moment(obj.LastModified).local().format('YYYY-MM-DD HH:mm:ss') : ''),\n                $('<td>').append(isfolder(obj.Key) ? '' : mapStorage[obj.StorageClass]),\n                $('<td>').append(isfolder(obj.Key) ? '' : bytesToSize(obj.Size)),\n                $('<td>').attr('id', `trash-td-${ii}`).append($('<i>').append('n/a')),\n            ];\n\n            const tr = $('<tr>').attr('id', `trash-tr-${ii}`);\n            td.reduce((trac, item) => trac.append(item), tr);\n            $('#trash-tbody').append(tr);\n        }\n\n        // Remove any prior click handler from Delete button\n        $btnDelete.unbind('click');\n\n        // Add new click handler for Delete button\n        $btnDelete.click((e2) => {\n            e2.preventDefault();\n            $scope.deleteFiles(args.bucket, args.keys);\n        });\n\n        // Reset buttons for initial use\n        $btnDelete.show();\n        $btnCancel.text('Cancel');\n\n        // Bind file count into button\n        $btnDelete.attr('data-filecount', args.keys.length);\n        $scope.trash.count = args.keys.length;\n        $scope.trash.button = `Delete (${args.keys.length})`;\n        $scope.trash.trashing = false;\n\n        $('#TrashModal').modal({ keyboard: true, backdrop: 'static' });\n    });\n}\n\n// Create Angular module and attach factory and controllers\nangular.module('aws-js-s3-explorer', [])\n    .factory('SharedService', SharedService)\n    .controller('ErrorController', ErrorController)\n    .controller('ViewController', ViewController)\n    .controller('AddFolderController', AddFolderController)\n    .controller('InfoController', InfoController)\n    .controller('SettingsController', SettingsController)\n    .controller('UploadController', UploadController)\n    .controller('TrashController', TrashController);\n\n$(document).ready(() => {\n    DEBUG.log('Version jQuery', $.fn.jquery);\n\n    // Default AWS region and v4 signature\n    AWS.config.update({ region: '' });\n    AWS.config.update({ signatureVersion: 'v4' });\n\n    // Show navbuttons\n    $('#navbuttons').removeClass('hidden');\n\n    // Close handler for the alert\n    $('[data-hide]').on('click', (e) => {\n        $(e.currentTarget).parent().hide();\n    });\n\n    // Initialize the moment library (for time formatting utilities) and\n    // launch the initial Settings dialog requesting bucket & credentials.\n    moment().format();\n    $('#SettingsModal').modal({ keyboard: true, backdrop: 'static' });\n});\n"], "fixing_code": ["// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\").\n//\n// You may not use this file except in compliance with the License. A copy\n// of the License is located at\n//\n// http://aws.amazon.com/apache2.0/\n//\n// or in the \"license\" file accompanying this file. This file is distributed\n// on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n// either express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\n/* ESLint file-level overrides */\n/* global AWS bootbox document moment window $ angular:true */\n/* eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }] */\n/* eslint-disable no-console */\n/* eslint no-plusplus: \"off\" */\n/* eslint-env es6 */\n\nconst s3ExplorerColumns = {\n    check: 0, object: 1, folder: 2, date: 3, timestamp: 4, storageclass: 5, size: 6,\n};\n\n// Cache frequently-used selectors and data table\nconst $tb = $('#s3objects-table');\nconst $bc = $('#breadcrumb');\nconst $bl = $('#bucket-loader');\n\n// Map S3 storage types to text\nconst mapStorage = {\n    STANDARD: 'Standard',\n    STANDARD_IA: 'Standard IA',\n    ONEZONE_IA: 'One Zone-IA',\n    REDUCED_REDUNDANCY: 'Reduced Redundancy',\n    GLACIER: 'Glacier',\n    INTELLIGENT_TIERING: 'Intelligent Tiering',\n    DEEP_ARCHIVE: 'Deep Archive',\n};\n\n// Debug utility to complement console.log\nconst DEBUG = (() => {\n    const timestamp = () => {};\n    timestamp.toString = () => `[DEBUG ${moment().format()}]`;\n\n    return {\n        log: console.log.bind(console, '%s', timestamp),\n    };\n})();\n\n// Utility to convert bytes to readable text e.g. \"2 KB\" or \"5 MB\"\nfunction bytesToSize(bytes) {\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    if (bytes === 0) return '0 Bytes';\n    const ii = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)), 10);\n    return `${Math.round(bytes / (1024 ** ii), 2)} ${sizes[ii]}`;\n}\n\n// Escape strings of HTML\nfunction htmlEscape(str) {\n    return str\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;')\n        .replace(/\\//g, '&#x2F;')\n        .replace(/`/g, '&#x60;')\n        .replace(/=/g, '&#x3D;');\n}\n\n// Convert cars/vw/golf.png to golf.png\nfunction fullpath2filename(path) {\n    return htmlEscape(path.replace(/^.*[\\\\/]/, ''));\n}\n\n// Convert cars/vw/golf.png to cars/vw/\nfunction fullpath2pathname(path) {\n    const index = path.lastIndexOf('/');\n    return index === -1 ? '/' : htmlEscape(path.substring(0, index + 1));\n}\n\n// Convert cars/vw/ to vw/\nfunction prefix2folder(prefix) {\n    const parts = prefix.split('/');\n    return htmlEscape(`${parts[parts.length - 2]}/`);\n}\n\n// Convert cars/vw/sedans/ to cars/vw/\nfunction prefix2parentfolder(prefix) {\n    const parts = prefix.split('/');\n    parts.splice(parts.length - 2, 1);\n    return htmlEscape(parts.join('/'));\n}\n\n// Convert cars/vw/golf.png to  cars/.../golf.png\nconst pathLimit = 80; // Max allowed path length\nconst pathHellip = String.fromCharCode(8230); // '&hellip;' char\nfunction path2short(path) {\n    if (path.length < pathLimit) return path;\n    const soft = `${prefix2parentfolder(fullpath2pathname(path)) + pathHellip}/${fullpath2filename(path)}`;\n    if (soft.length < pathLimit && soft.length > 2) return soft;\n    const hard = `${path.substring(0, path.indexOf('/') + 1) + pathHellip}/${fullpath2filename(path)}`;\n    return hard.length < pathLimit ? htmlEscape(hard) : htmlEscape(path.substring(0, pathLimit) + pathHellip);\n}\n\n// Virtual-hosted-style URL, ex: https://mybucket1.s3.amazonaws.com/index.html\nfunction object2hrefvirt(bucket, key) {\n    const enckey = key.split('/').map(x => encodeURIComponent(x)).join('/');\n    return `${document.location.protocol}//${bucket}.s3.amazonaws.com/${enckey}`;\n}\n\n// Path-style URLs, ex: https://s3.amazonaws.com/mybucket1/index.html\n// eslint-disable-next-line no-unused-vars\nfunction object2hrefpath(bucket, key) {\n    const enckey = key.split('/').map(x => encodeURIComponent(x)).join('/');\n    return `${document.location.protocol}//s3.amazonaws.com/${bucket}/${enckey}`;\n}\n\nfunction isfolder(path) {\n    return path.endsWith('/');\n}\n\nfunction stripLeadTrailSlash(s) {\n    return s.replace(/^\\/+/g, '').replace(/\\/+$/g, '');\n}\n\n//\n// Shared service that all controllers can use\n//\nfunction SharedService($rootScope) {\n    DEBUG.log('SharedService init');\n\n    const shared = {\n        settings: null, viewprefix: null, skew: true,\n    };\n\n    shared.getSettings = () => this.settings;\n\n    shared.addFiles = (files) => { this.added_files = files; };\n\n    shared.getAddedFiles = () => this.added_files;\n\n    shared.hasAddedFiles = () => Object.prototype.hasOwnProperty.call(this, 'added_files');\n\n    shared.resetAddedFiles = () => { delete this.added_files; };\n\n    shared.changeSettings = (settings) => {\n        DEBUG.log('SharedService::changeSettings');\n        DEBUG.log('SharedService::changeSettings settings', settings);\n\n        this.settings = settings;\n        this.viewprefix = null;\n        $.fn.dataTableExt.afnFiltering.length = 0;\n\n        // AWS.config.update(settings.cred);\n        // AWS.config.update({ region: settings.region });\n        AWS.config.update(Object.assign(settings.cred, { region: settings.region }));\n\n        if (this.skew) {\n            this.correctClockSkew(settings.bucket);\n            this.skew = false;\n        }\n\n        if (settings.mfa.use === 'yes') {\n            const iam = new AWS.IAM();\n            DEBUG.log('listMFADevices');\n\n            iam.listMFADevices({}, (err1, data1) => {\n                if (err1) {\n                    DEBUG.log('listMFADevices error:', err1);\n                } else {\n                    const sts = new AWS.STS();\n                    DEBUG.log('listMFADevices data:', data1);\n\n                    const params = {\n                        DurationSeconds: 3600,\n                        SerialNumber: data1.MFADevices[0].SerialNumber,\n                        TokenCode: settings.mfa.code,\n                    };\n\n                    DEBUG.log('getSessionToken params:', params);\n                    sts.getSessionToken(params, (err2, data2) => {\n                        if (err2) {\n                            DEBUG.log('getSessionToken error:', err2);\n                        } else {\n                            DEBUG.log('getSessionToken data:', data2);\n                            this.settings.stscred = {\n                                accessKeyId: data2.Credentials.AccessKeyId,\n                                secretAccessKey: data2.Credentials.SecretAccessKey,\n                                sessionToken: data2.Credentials.SessionToken,\n                            };\n                            AWS.config.update(this.settings.stscred);\n                            $rootScope.$broadcast('broadcastChangeSettings', { settings: this.settings });\n                        }\n                    });\n                }\n            });\n        } else {\n            $rootScope.$broadcast('broadcastChangeSettings', { settings });\n        }\n    };\n\n    shared.changeViewPrefix = (prefix) => {\n        DEBUG.log('SharedService::changeViewPrefix');\n\n        if (this.settings.delimiter) {\n            // Folder-level view\n            this.settings.prefix = prefix;\n            this.viewprefix = null;\n            $.fn.dataTableExt.afnFiltering.length = 0;\n            $rootScope.$broadcast('broadcastChangePrefix', { prefix });\n        } else {\n            // Bucket-level view\n            this.viewprefix = prefix;\n            $rootScope.$broadcast('broadcastChangePrefix', { viewprefix: prefix });\n        }\n    };\n\n    shared.getViewPrefix = () => this.viewprefix || this.settings.prefix;\n\n    shared.viewRefresh = () => $rootScope.$broadcast('broadcastViewRefresh');\n\n    shared.trashObjects = (bucket, keys) => $rootScope.$broadcast('broadcastTrashObjects', { bucket, keys });\n\n    shared.addFolder = (_bucket, _folder) => $rootScope.$broadcast('broadcastViewRefresh');\n\n    // We use pre-signed URLs so that the user can securely download\n    // objects. For security reasons, we make these URLs time-limited and in\n    // order to do that we need the client's clock to be in sync with the AWS\n    // S3 endpoint otherwise we might create URLs that are immediately invalid,\n    // for example if the client's browser time is 55 minutes behind S3's time.\n    shared.correctClockSkew = (Bucket) => {\n        const s3 = new AWS.S3();\n        DEBUG.log('Invoke headBucket:', Bucket);\n\n        // Head the bucket to get a Date response. The 'date' header will need\n        // to be exposed in S3 CORS configuration.\n        s3.headBucket({ Bucket }, (err, data) => {\n            if (err) {\n                DEBUG.log('headBucket error:', err);\n            } else {\n                DEBUG.log('headBucket data:', JSON.stringify(data));\n                DEBUG.log('headBucket headers:', JSON.stringify(this.httpResponse.headers));\n\n                if (this.httpResponse.headers.date) {\n                    const date = Date.parse(this.httpResponse.headers.date);\n                    DEBUG.log('headers date:', date);\n                    AWS.config.systemClockOffset = new Date() - date;\n                    DEBUG.log('clock offset:', AWS.config.systemClockOffset);\n                    // Can now safely generate presigned urls\n                }\n            }\n        });\n    };\n\n    // Common error handling is done here in the shared service.\n    shared.showError = (params, err) => {\n        DEBUG.log(err);\n        const { message, code } = err;\n        const errors = Object.entries(err).map(([key, value]) => ({ key, value }));\n        const args = {\n            params, message, code, errors,\n        };\n        $rootScope.$broadcast('broadcastError', args);\n    };\n\n    return shared;\n}\n\n//\n// ViewController: code associated with the main S3 Explorer table that shows\n// the contents of the current bucket/folder and allows the user to downloads\n// files, delete files, and do various other S3 functions.\n//\n// eslint-disable-next-line no-shadow\nfunction ViewController($scope, SharedService) {\n    DEBUG.log('ViewController init');\n    window.viewScope = $scope; // for debugging\n    $scope.view = {\n        bucket: null, prefix: null, settings: null, objectCount: 0, keys_selected: [],\n    };\n    $scope.stop = false;\n\n    // Delegated event handler for S3 object/folder clicks. This is delegated\n    // because the object/folder rows are added dynamically and we do not want\n    // to have to assign click handlers to each and every row.\n    $tb.on('click', 'a', (e) => {\n        const { currentTarget: target } = e;\n        e.preventDefault();\n        DEBUG.log('target href:', target.href);\n        DEBUG.log('target dataset:', JSON.stringify(target.dataset));\n\n        if (target.dataset.s3 === 'folder') {\n            // User has clicked on a folder so navigate into that folder\n            SharedService.changeViewPrefix(target.dataset.s3key);\n        } else if ($scope.view.settings.auth === 'anon') {\n            // Unauthenticated user has clicked on an object so download it\n            // in new window/tab\n            window.open(target.href, '_blank');\n        } else {\n            // Authenticated ser has clicked on an object so create pre-signed\n            // URL and download it in new window/tab\n            const s3 = new AWS.S3();\n            const params = {\n                Bucket: $scope.view.settings.bucket, Key: target.dataset.s3key, Expires: 15,\n            };\n            DEBUG.log('params:', params);\n            s3.getSignedUrl('getObject', params, (err, url) => {\n                if (err) {\n                    DEBUG.log('err:', err);\n                    SharedService.showError(params, err);\n                } else {\n                    DEBUG.log('url:', url);\n                    window.open(url, '_blank');\n                }\n            });\n        }\n        return false;\n    });\n\n    // Delegated event handler for breadcrumb clicks.\n    $bc.on('click', 'a', (e) => {\n        DEBUG.log('breadcrumb li click');\n        e.preventDefault();\n        const { currentTarget: target } = e;\n        DEBUG.log('target dataset:', JSON.stringify(target.dataset));\n        SharedService.changeViewPrefix(target.dataset.prefix);\n        return false;\n    });\n\n    $scope.$on('broadcastChangeSettings', (e, args) => {\n        DEBUG.log('ViewController', 'broadcast change settings:', args.settings);\n        $scope.view.objectCount = 0;\n        $scope.view.settings = args.settings;\n        $scope.refresh();\n    });\n\n    $scope.$on('broadcastChangePrefix', (e, args) => {\n        DEBUG.log('ViewController', 'broadcast change prefix args:', args);\n        $scope.$apply(() => {\n            // Create breadcrumbs from current path (S3 bucket plus folder hierarchy)\n            $scope.folder2breadcrumbs($scope.view.settings.bucket, args.viewprefix || args.prefix);\n\n            if (args.viewprefix !== undefined && args.viewprefix !== null) {\n                // In bucket-level view we already have the data so we just need to\n                // filter it on prefix.\n                $.fn.dataTableExt.afnFiltering.length = 0;\n\n                $.fn.dataTableExt.afnFiltering.push(\n                    // Filter function returns true to include item in view\n                    (_o, d, _i) => d[1] !== args.viewprefix && d[1].startsWith(args.viewprefix),\n                );\n\n                // Re-draw the table\n                $tb.DataTable().draw();\n            } else {\n                // In folder-level view, we actually need to query the data for the\n                // the newly-selected folder.\n                $.fn.dataTableExt.afnFiltering.length = 0;\n                $scope.view.settings.prefix = args.prefix;\n                $scope.refresh();\n            }\n        });\n    });\n\n    $scope.$on('broadcastViewRefresh', () => {\n        DEBUG.log('ViewController', 'broadcast view refresh');\n        $scope.$apply(() => {\n            $scope.refresh();\n        });\n    });\n\n    $scope.renderObject = (data, _type, full) => {\n        // DEBUG.log(\"renderObject:\", JSON.stringify(full));\n        const href = object2hrefvirt($scope.view.settings.bucket, data);\n\n        function render(d, href2, text, download) {\n            const d2 = htmlEscape(d);\n            if (download) {\n                return `<a data-s3=\"object\" data-s3key=\"${d2}\" href=\"${href2}\" download=\"${download}\">${text}</a>`;\n            }\n            return `<a data-s3=\"folder\" data-s3key=\"${d2}\" href=\"${href2}\">${text}</a>`;\n        }\n\n        if (full.CommonPrefix) {\n            // DEBUG.log(\"is folder: \" + data);\n            if ($scope.view.settings.prefix) {\n                return render(data, href, prefix2folder(data));\n            }\n\n            return render(data, href, data);\n        }\n\n        return render(data, href, fullpath2filename(data), fullpath2filename(data));\n    };\n\n    $scope.renderFolder = (data, _type, full) => (full.CommonPrefix ? '' : fullpath2pathname(data));\n\n    $scope.progresscb = (objects, folders) => {\n        DEBUG.log('ViewController', 'Progress cb objects:', objects);\n        DEBUG.log('ViewController', 'Progress cb folders:', folders);\n        $scope.$apply(() => {\n            $scope.view.objectCount += objects + folders;\n        });\n    };\n\n    $scope.refresh = () => {\n        DEBUG.log('refresh');\n        if ($scope.running()) {\n            DEBUG.log('running, stop');\n            $scope.listobjectsstop();\n        } else {\n            DEBUG.log('refresh', $scope.view.settings);\n            $scope.view.objectCount = 0;\n            $scope.folder2breadcrumbs(\n                $scope.view.settings.bucket,\n                SharedService.getViewPrefix(),\n            );\n            $scope.listobjects(\n                $scope.view.settings.bucket,\n                $scope.view.settings.prefix,\n                $scope.view.settings.delimiter,\n            );\n        }\n    };\n\n    $scope.upload = () => {\n        DEBUG.log('Add files');\n        $('#addedFiles').trigger('click');\n    };\n\n    $scope.trash = () => {\n        DEBUG.log('Trash:', $scope.view.keys_selected);\n        if ($scope.view.keys_selected.length > 0) {\n            SharedService.trashObjects($scope.view.settings.bucket, $scope.view.keys_selected);\n        }\n    };\n\n    $scope.running = () => $bl.hasClass('fa-spin');\n\n    $scope.folder2breadcrumbs = (bucket, prefix) => {\n        DEBUG.log('Breadcrumbs bucket:', bucket);\n        DEBUG.log('Breadcrumbs prefix:', prefix);\n\n        // Empty the current breadcrumb list\n        $('#breadcrumb li').remove();\n\n        // This array will contain the needed prefixes for each folder level.\n        const prefixes = [''];\n        let buildprefix = '';\n\n        if (prefix) {\n            prefixes.push(...prefix.replace(/\\/$/g, '').split('/'));\n        }\n\n        // Add bucket followed by prefix segments to make breadcrumbs\n        for (let ii = 0; ii < prefixes.length; ii++) {\n            let li;\n\n            // Bucket\n            if (ii === 0) {\n                const a1 = $('<a>').attr('href', '#').text(bucket);\n                li = $('<li>').append(a1);\n            // Followed by n - 1 intermediate folders\n            } else if (ii < prefixes.length - 1) {\n                const a2 = $('<a>').attr('href', '#').text(prefixes[ii]);\n                li = $('<li>').append(a2);\n            // Followed by current folder\n            } else {\n                li = $('<li>').text(prefixes[ii]);\n            }\n\n            // Accumulate prefix\n            if (ii) {\n                buildprefix = `${buildprefix}${prefixes[ii]}/`;\n            }\n\n            // Save prefix & bucket data for later click handler\n            li.children('a').attr('data-prefix', buildprefix).attr('data-bucket', bucket);\n\n            // Add to breadcrumbs\n            $bc.append(li);\n        }\n\n        // Make last breadcrumb active\n        $('#breadcrumb li:last').addClass('active');\n    };\n\n    $scope.listobjectsstop = (stop) => {\n        DEBUG.log('ViewController', 'listobjectsstop:', stop || true);\n        $scope.stop = stop || true;\n    };\n\n    // This is the listObjects callback\n    $scope.listobjectscb = (err, data) => {\n        DEBUG.log('Enter listobjectscb');\n        if (err) {\n            DEBUG.log('Error:', JSON.stringify(err));\n            DEBUG.log('Error:', err.stack);\n            $bl.removeClass('fa-spin');\n            const params = { bucket: $scope.view.bucket, prefix: $scope.view.prefix };\n            SharedService.showError(params, err);\n        } else {\n            let marker;\n\n            // Store marker before filtering data. Note that Marker is the\n            // previous request marker, not the marker to use on the next call\n            // to listObject. For the one to use on the next invocation you\n            // need to use NextMarker or retrieve the key of the last item.\n            if (data.IsTruncated) {\n                if (data.NextMarker) {\n                    marker = data.NextMarker;\n                } else if (data.Contents.length > 0) {\n                    marker = data.Contents[data.Contents.length - 1].Key;\n                }\n            }\n\n            const count = { objects: 0, folders: 0 };\n\n            // NOTE: folders are returned in CommonPrefixes if delimiter is\n            // supplied on the listObjects call and in Contents if delimiter\n            // is not supplied on the listObjects call, so we may need to\n            // source our DataTable folders from Contents or CommonPrefixes.\n            // DEBUG.log(\"Contents\", data.Contents);\n            $.each(data.Contents, (index, value) => {\n                if (value.Key === data.Prefix) {\n                    // ignore this folder\n                } else if (isfolder(value.Key)) {\n                    $tb.DataTable().row.add({\n                        CommonPrefix: true, Key: value.Key, StorageClass: null,\n                    });\n                    count.folders++;\n                } else {\n                    $tb.DataTable().row.add(value);\n                    count.objects++;\n                }\n            });\n\n            // Add folders to the datatable. Note that folder entries in the\n            // DataTable will have different content to object entries and the\n            // folders can be identified by CommonPrefix=true.\n            // DEBUG.log(\"CommonPrefixes:\", data.CommonPrefixes);\n            $.each(data.CommonPrefixes, (index, value) => {\n                $tb.DataTable().rows.add([\n                    { CommonPrefix: true, Key: value.Prefix, StorageClass: null },\n                ]);\n                count.objects++;\n            });\n\n            // Re-draw the table\n            $tb.DataTable().draw();\n\n            // Make progress callback to report objects read so far\n            $scope.progresscb(count.objects, count.folders);\n\n            const params = {\n                Bucket: data.Name, Prefix: data.Prefix, Delimiter: data.Delimiter, Marker: marker,\n            };\n\n            // DEBUG.log(\"AWS.config:\", JSON.stringify(AWS.config));\n\n            if ($scope.stop) {\n                DEBUG.log('Bucket', data.Name, 'stopped');\n                $bl.removeClass('fa-spin');\n            } else if (data.IsTruncated) {\n                DEBUG.log('Bucket', data.Name, 'truncated');\n                const s3 = new AWS.S3(AWS.config);\n                if (AWS.config.credentials && AWS.config.credentials.accessKeyId) {\n                    DEBUG.log('Make S3 authenticated call to listObjects');\n                    s3.listObjects(params, $scope.listobjectscb);\n                } else {\n                    DEBUG.log('Make S3 unauthenticated call to listObjects');\n                    s3.makeUnauthenticatedRequest('listObjects', params, $scope.listobjectscb);\n                }\n            } else {\n                DEBUG.log('Bucket', data.Name, 'listing complete');\n                $bl.removeClass('fa-spin');\n            }\n        }\n    };\n\n    // Start the spinner, clear the table, make an S3 listObjects request\n    $scope.listobjects = (Bucket, Prefix, Delimiter, Marker) => {\n        DEBUG.log('Enter listobjects');\n\n        // If this is the initial listObjects\n        if (!Marker) {\n            // Checked on each event cycle to stop list prematurely\n            $scope.stop = false;\n\n            // Start spinner and clear table\n            $scope.view.keys_selected = [];\n            $bl.addClass('fa-spin');\n            $tb.DataTable().clear();\n            $tb.DataTable().column(s3ExplorerColumns.folder).visible(!Delimiter);\n        }\n\n        const s3 = new AWS.S3(AWS.config);\n        const params = {\n            Bucket, Prefix, Delimiter, Marker,\n        };\n\n        // DEBUG.log(\"AWS.config:\", JSON.stringify(AWS.config));\n\n        // Now make S3 listObjects call(s)\n        if (AWS.config.credentials && AWS.config.credentials.accessKeyId) {\n            DEBUG.log('Make S3 authenticated call to listObjects, params:', params);\n            s3.listObjects(params, $scope.listobjectscb);\n        } else {\n            DEBUG.log('Make S3 unauthenticated call to listObjects, params:', params);\n            s3.makeUnauthenticatedRequest('listObjects', params, $scope.listobjectscb);\n        }\n    };\n\n    this.isfolder = path => path.endsWith('/');\n\n    // Individual render functions so that we can control how column data appears\n    this.renderSelect = (data, type, _full) => {\n        if (type === 'display') {\n            return '<span class=\"text-center\"><input type=\"checkbox\"></span>';\n        }\n\n        return '';\n    };\n\n    this.renderObject = (data, type, full) => {\n        if (type === 'display') {\n            return $scope.renderObject(data, type, full);\n        }\n\n        return data;\n    };\n\n    this.renderFolder = (data, type, full) => $scope.renderFolder(data, type, full);\n\n    this.renderLastModified = (data, _type, _full) => {\n        if (data) {\n            return moment(data).fromNow();\n        }\n\n        return '';\n    };\n\n    this.renderTimestamp = (data, _type, _full) => {\n        if (data) {\n            return moment(data).local().format('YYYY-MM-DD HH:mm:ss');\n        }\n\n        return '';\n    };\n\n    this.renderStorageClass = (data, _type, _full) => {\n        if (data) {\n            return mapStorage[data];\n        }\n\n        return '';\n    };\n\n    // Object sizes are displayed in nicer format e.g. 1.2 MB but are otherwise\n    // handled as simple number of bytes e.g. for sorting purposes\n    this.dataSize = (source, type, _val) => {\n        if (source.Size) {\n            return (type === 'display') ? bytesToSize(source.Size) : source.Size;\n        }\n\n        return '';\n    };\n\n    // Initial DataTable settings (must only do this one time)\n    $tb.DataTable({\n        iDisplayLength: 25,\n        order: [[2, 'asc'], [1, 'asc']],\n        aoColumnDefs: [\n            {\n                aTargets: [0], mData: null, mRender: this.renderSelect, sClass: 'text-center', sWidth: '20px', bSortable: false,\n            },\n            {\n                aTargets: [1], mData: 'Key', mRender: this.renderObject, sType: 'key',\n            },\n            {\n                aTargets: [2], mData: 'Key', mRender: this.renderFolder,\n            },\n            {\n                aTargets: [3], mData: 'LastModified', mRender: this.renderLastModified,\n            },\n            {\n                aTargets: [4], mData: 'LastModified', mRender: this.renderTimestamp,\n            },\n            {\n                aTargets: [5], mData: 'StorageClass', mRender: this.renderStorageClass,\n            },\n            {\n                aTargets: [6], mData: this.dataSize,\n            },\n        ],\n    });\n\n    // Custom ascending sort for Key column so folders appear before objects\n    $.fn.dataTableExt.oSort['key-asc'] = (a, b) => {\n        const x = (isfolder(a) ? `0-${a}` : `1-${a}`).toLowerCase();\n        const y = (isfolder(b) ? `0-${b}` : `1-${b}`).toLowerCase();\n        if (x < y) return -1;\n        if (x > y) return 1;\n        return 0;\n    };\n\n    // Custom descending sort for Key column so folders appear before objects\n    $.fn.dataTableExt.oSort['key-desc'] = (a, b) => {\n        const x = (isfolder(a) ? `1-${a}` : `0-${a}`).toLowerCase();\n        const y = (isfolder(b) ? `1-${b}` : `0-${b}`).toLowerCase();\n        if (x < y) return 1;\n        if (x > y) return -1;\n        return 0;\n    };\n\n    // Handle click on selection checkbox\n    $('#s3objects-table tbody').on('click', 'input[type=\"checkbox\"]', (e1) => {\n        const checkbox = e1.currentTarget;\n        const $row = $(checkbox).closest('tr');\n        const data = $tb.DataTable().row($row).data();\n        let index = -1;\n\n        // Prevent click event from propagating to parent\n        e1.stopPropagation();\n\n        // Find matching key in currently checked rows\n        index = $scope.view.keys_selected.findIndex(e2 => e2.Key === data.Key);\n\n        // Remove or add checked row as appropriate\n        if (checkbox.checked && index === -1) {\n            $scope.view.keys_selected.push(data);\n        } else if (!checkbox.checked && index !== -1) {\n            $scope.view.keys_selected.splice(index, 1);\n        }\n\n        $scope.$apply(() => {\n            // Doing this to force Angular to update models\n            DEBUG.log('Selected rows:', $scope.view.keys_selected);\n        });\n\n        if (checkbox.checked) {\n            $row.addClass('selected');\n        } else {\n            $row.removeClass('selected');\n        }\n    });\n\n    // Handle click on table cells\n    $('#s3objects-table tbody').on('click', 'td', (e) => {\n        $(e.currentTarget).parent().find('input[type=\"checkbox\"]').trigger('click');\n    });\n}\n\n//\n// AddFolderController: code associated with the add folder function.\n//\n// eslint-disable-next-line no-shadow\nfunction AddFolderController($scope, SharedService) {\n    DEBUG.log('AddFolderController init');\n    $scope.add_folder = {\n        settings: null, bucket: null, entered_folder: '', view_prefix: '/',\n    };\n    window.addFolderScope = $scope; // for debugging\n    DEBUG.log('AddFolderController add_folder init', $scope.add_folder);\n\n    $scope.$on('broadcastChangeSettings', (e, args) => {\n        DEBUG.log('AddFolderController', 'broadcast change settings bucket:', args.settings.bucket);\n        $scope.add_folder.settings = args.settings;\n        $scope.add_folder.bucket = args.settings.bucket;\n        DEBUG.log('AddFolderController add_folder bcs', $scope.add_folder);\n    });\n\n    $scope.$on('broadcastChangePrefix', (e, args) => {\n        DEBUG.log('AddFolderController', 'broadcast change prefix args:', args);\n        $scope.add_folder.view_prefix = args.prefix || args.viewprefix || '/';\n        DEBUG.log('AddFolderController add_folder bcp', $scope.add_folder);\n    });\n\n    $scope.addFolder = () => {\n        DEBUG.log('Add folder');\n        DEBUG.log('Current prefix:', $scope.add_folder.view_prefix);\n\n        const ef = stripLeadTrailSlash($scope.add_folder.entered_folder);\n        const vpef = $scope.add_folder.view_prefix + ef;\n        const folder = `${stripLeadTrailSlash(vpef)}/`;\n        DEBUG.log('Calculated folder:', folder);\n\n        const s3 = new AWS.S3(AWS.config);\n        const params = { Bucket: $scope.add_folder.bucket, Key: folder };\n\n        DEBUG.log('Invoke headObject:', params);\n\n        // Test if an object with this key already exists\n        s3.headObject(params, (err1, _data1) => {\n            if (err1 && err1.code === 'NotFound') {\n                DEBUG.log('Invoke putObject:', params);\n\n                // Create a zero-sized object to simulate a folder\n                s3.putObject(params, (err2, _data2) => {\n                    if (err2) {\n                        DEBUG.log('putObject error:', err2);\n                        bootbox.alert('Error creating folder:', err2);\n                    } else {\n                        SharedService.addFolder(params.Bucket, params.Key);\n                        $('#AddFolderModal').modal('hide');\n                        $scope.add_folder.entered_folder = '';\n                    }\n                });\n            } else if (err1) {\n                bootbox.alert('Error checking existence of folder:', err1);\n            } else {\n                bootbox.alert('Error: folder or object already exists at', params.Key);\n            }\n        });\n    };\n}\n\n//\n// InfoController: code associated with the Info modal where the user can\n// view bucket policies, CORS configuration and About text.\n//\n// Note: do not be tempted to correct the eslint no-unused-vars error\n// with SharedService below. Doing so will break injection.\n//\n// eslint-disable-next-line no-shadow\nfunction InfoController($scope) {\n    DEBUG.log('InfoController init');\n    window.infoScope = $scope; // for debugging\n    $scope.info = {\n        cors: null, policy: null, bucket: null, settings: null,\n    };\n\n    $scope.$on('broadcastChangeSettings', (e, args) => {\n        DEBUG.log('InfoController', 'broadcast change settings bucket:', args.settings.bucket);\n        $scope.info.settings = args.settings;\n        $scope.info.bucket = args.settings.bucket;\n        $scope.getBucketCors(args.settings.bucket);\n        $scope.getBucketPolicy(args.settings.bucket);\n    });\n\n    $scope.getBucketPolicy = (Bucket) => {\n        const params = { Bucket };\n        $scope.info.policy = null;\n        DEBUG.log('call getBucketPolicy:', Bucket);\n\n        new AWS.S3(AWS.config).getBucketPolicy(params, (err, data) => {\n            let text;\n            if (err && err.code === 'NoSuchBucketPolicy') {\n                DEBUG.log(err);\n                text = 'No bucket policy.';\n            } else if (err) {\n                DEBUG.log(err);\n                text = JSON.stringify(err);\n            } else {\n                DEBUG.log(data.Policy);\n                $scope.info.policy = data.Policy;\n                DEBUG.log('Info:', $scope.info);\n                text = JSON.stringify(JSON.parse(data.Policy.trim()), null, 2);\n            }\n            $('#info-policy').text(text);\n        });\n    };\n\n    $scope.getBucketCors = (Bucket) => {\n        const params = { Bucket };\n        $scope.info.cors = null;\n        DEBUG.log('call getBucketCors:', Bucket);\n\n        new AWS.S3(AWS.config).getBucketCors(params, (err, data) => {\n            let text;\n            if (err && err.code === 'NoSuchCORSConfiguration') {\n                DEBUG.log(err);\n                text = 'This bucket has no CORS configuration.';\n            } else if (err) {\n                DEBUG.log(err);\n                text = JSON.stringify(err);\n            } else {\n                DEBUG.log(data.CORSRules);\n                [$scope.info.cors] = data.CORSRules;\n                DEBUG.log('Info:', $scope.info);\n                text = JSON.stringify(data.CORSRules, null, 2);\n            }\n            $('#info-cors').text(text);\n        });\n    };\n}\n\n//\n// SettingsController: code associated with the Settings dialog where the\n// user provides credentials and bucket information.\n//\n// eslint-disable-next-line no-shadow\nfunction SettingsController($scope, SharedService) {\n    DEBUG.log('SettingsController init');\n    window.settingsScope = $scope; // for debugging\n\n    // Initialized for an unauthenticated user exploring the current bucket\n    // TODO: calculate current bucket and initialize below\n    $scope.settings = {\n        auth: 'anon', region: '', bucket: '', entered_bucket: '', selected_bucket: '', view: 'folder', delimiter: '/', prefix: '',\n    };\n    $scope.settings.mfa = { use: 'no', code: '' };\n    $scope.settings.cred = { accessKeyId: '', secretAccessKey: '', sessionToken: '' };\n    $scope.settings.stscred = null;\n\n    // TODO: at present the Settings dialog closes after credentials have been supplied\n    // even if the subsequent AWS calls fail with networking or permissions errors. It\n    // would be better for the Settings dialog to synchronously make the necessary API\n    // calls and ensure they succeed before closing the modal dialog.\n    $scope.update = () => {\n        DEBUG.log('Settings updated');\n        $('#SettingsModal').modal('hide');\n        $scope.settings.bucket = $scope.settings.selected_bucket || $scope.settings.entered_bucket;\n\n        // If manually entered bucket then add it to list of buckets for future\n        if ($scope.settings.entered_bucket) {\n            if (!$scope.settings.buckets) {\n                $scope.settings.buckets = [];\n            }\n            if ($.inArray($scope.settings.entered_bucket, $scope.settings.buckets) === -1) {\n                $scope.settings.buckets.push($scope.settings.entered_bucket);\n                $scope.settings.buckets = $scope.settings.buckets.sort();\n            }\n        }\n\n        // If anonymous usage then create empty set of credentials\n        if ($scope.settings.auth === 'anon') {\n            $scope.settings.cred = { accessKeyId: null, secretAccessKey: null };\n        }\n\n        SharedService.changeSettings($scope.settings);\n    };\n}\n\n//\n// UploadController: code associated with the Upload dialog where the\n// user reviews the list of dropped files and request upload to S3.\n//\n// eslint-disable-next-line no-shadow\nfunction UploadController($scope, SharedService) {\n    DEBUG.log('UploadController init');\n    window.uploadScope = $scope; // for debugging\n    $scope.upload = {\n        button: null, title: null, files: [],\n    };\n\n    // Cache jquery selectors\n    const $btnUpload = $('#upload-btn-upload');\n    const $btnCancel = $('#upload-btn-cancel');\n\n    //\n    // Upload a list of local files to the provided bucket and prefix\n    //\n    $scope.uploadFiles = (Bucket, prefix) => {\n        $scope.$apply(() => {\n            $scope.upload.uploading = true;\n        });\n\n        DEBUG.log('Dropped files:', $scope.upload.files);\n\n        $scope.upload.files.forEach((file, ii) => {\n            DEBUG.log('File:', file);\n            DEBUG.log('Index:', ii);\n\n            $(`#upload-td-${ii}`).html(\n                `<div class=\"progress\"><span id=\"upload-td-progress-${ii}\" class=\"progress-bar\" data-percent=\"0\">0%</span></div>`,\n            );\n\n            const s3 = new AWS.S3(AWS.config);\n            const params = {\n                Body: file.file, Bucket, Key: (prefix || '') + (file.file.fullPath ? file.file.fullPath : file.file.name), ContentType: file.file.type,\n            };\n\n            const funcprogress = (evt) => {\n                DEBUG.log('Part:', evt.part, evt.loaded, evt.total);\n                const pc = evt.total ? ((evt.loaded * 100.0) / evt.total) : 0;\n                const pct = Math.round(pc);\n                const pcts = `${pct}%`;\n                const col = $(`#upload-td-progress-${ii}`);\n                col.attr('data-percent', pct);\n                col.css('width', pcts).text(pcts);\n            };\n\n            const funcsend = (err, data) => {\n                if (err) {\n                    // AccessDenied is a normal consequence of lack of permission\n                    // and we do not treat this as completely unexpected\n                    if (err.code === 'AccessDenied') {\n                        $(`#upload-td-${ii}`).html('<span class=\"uploaderror\">Access Denied</span>');\n                    } else {\n                        DEBUG.log(JSON.stringify(err));\n                        $(`#upload-td-${ii}`).html(`<span class=\"uploaderror\">Failed:&nbsp${err.code}</span>`);\n                        SharedService.showError(params, err);\n                    }\n                } else {\n                    DEBUG.log('Uploaded', file.file.name, 'to', data.Location);\n                    let count = $btnUpload.attr('data-filecount');\n                    $btnUpload.attr('data-filecount', --count);\n                    $(`#upload-td-progress-${ii}`).addClass('progress-bar-success');\n\n                    $scope.$apply(() => {\n                        $scope.upload.button = `Upload (${count})`;\n                    });\n\n                    // If all files uploaded then refresh underlying folder view\n                    if (count === 0) {\n                        $btnUpload.hide();\n                        $btnCancel.text('Close');\n                        SharedService.viewRefresh();\n                    }\n                }\n            };\n\n            s3.upload(params)\n                .on('httpUploadProgress', funcprogress)\n                .send(funcsend);\n        });\n    };\n\n    // Wrap readEntries in a promise to make working with readEntries easier\n    async function readEntriesPromise(directoryReader) {\n        try {\n            return await new Promise((resolve, reject) => {\n                directoryReader.readEntries(resolve, reject);\n            });\n        } catch (err) {\n            DEBUG.log(err);\n            return undefined;\n        }\n    }\n\n    // Get all the entries (files or sub-directories) in a directory\n    // by calling readEntries until it returns empty array\n    async function readAllDirectoryEntries(directoryReader) {\n        const entries = [];\n        let readEntries = await readEntriesPromise(directoryReader);\n        while (readEntries.length > 0) {\n            entries.push(...readEntries);\n            readEntries = await readEntriesPromise(directoryReader);\n        }\n        return entries;\n    }\n\n    // Retrieve File object from FileEntry\n    async function filePromise(fileEntry) {\n        try {\n            return await new Promise((resolve, reject) => {\n                fileEntry.file(resolve, reject);\n            });\n        } catch (err) {\n            DEBUG.log(err);\n            return undefined;\n        }\n    }\n\n    // Get all files recursively\n    async function getAllFileEntries(dataTransferItemList) {\n        const fileEntries = [];\n        const queue = [];\n        for (let i = 0; i < dataTransferItemList.length; i++) {\n            const dtItem = dataTransferItemList[i];\n            queue.push(typeof dtItem.webkitGetAsEntry === 'function' ? dtItem.webkitGetAsEntry() : dtItem.getAsEntry());\n        }\n        while (queue.length > 0) {\n            const entry = queue.shift();\n            if (entry.isFile) {\n                const file = await filePromise(entry);\n                file.fullPath = entry.fullPath.substring(1);\n                fileEntries.push(file);\n            } else if (entry.isDirectory) {\n                const reader = entry.createReader();\n                queue.push(...await readAllDirectoryEntries(reader));\n            }\n        }\n        return fileEntries;\n    }\n\n    // Wrapper to get files safe\n    async function getFilesList(dataTransfer) {\n        if (dataTransfer.items.length > 0) {\n            if (typeof dataTransfer.items[0].webkitGetAsEntry === 'function'\n               || typeof dataTransfer.items[0].getAsEntry === 'function') return getAllFileEntries(dataTransfer.items);\n            DEBUG.log('Can not do folders upload, falling back to files only');\n            return dataTransfer.files;\n        } return [];\n    }\n\n    //\n    // Drag/drop handler for files to be uploaded\n    //\n    $scope.dropZone = (target) => {\n        target\n            .on('dragover', () => {\n                target.addClass('dragover');\n                return false;\n            })\n            .on('dragend dragleave', () => {\n                target.removeClass('dragover');\n                return false;\n            })\n            .on('drop', async (e) => {\n                DEBUG.log('Dropped files');\n                e.stopPropagation();\n                e.preventDefault();\n\n                target.removeClass('dragover');\n\n                $bl.addClass('fa-spin');\n                const files = SharedService.hasAddedFiles()\n                    ? SharedService.getAddedFiles()\n                    : await getFilesList(e.originalEvent.dataTransfer);\n                $bl.removeClass('fa-spin');\n\n                $scope.$apply(() => {\n                    $scope.upload.files = [];\n                    for (let ii = 0; ii < files.length; ii++) {\n                        const fileii = files[ii];\n                        if (fileii.type || fileii.size % 4096 !== 0 || fileii.size > 1048576) {\n                            DEBUG.log('File:', fileii.name, 'Size:', fileii.size, 'Type:', fileii.type);\n                            $scope.upload.files.push({\n                                file: fileii,\n                                name: fileii.fullPath ? fileii.fullPath : fileii.name,\n                                type: fileii.type,\n                                size: bytesToSize(fileii.size),\n                                short: path2short(fileii.fullPath ? fileii.fullPath : fileii.name),\n                            });\n                        }\n                    }\n                });\n\n                const { bucket } = SharedService.getSettings();\n                const prefix = SharedService.getViewPrefix();\n\n                // Remove any prior click handler from Upload button\n                $btnUpload.unbind('click');\n\n                // Add new click handler for Upload button\n                $btnUpload.click((e2) => {\n                    e2.preventDefault();\n                    $scope.uploadFiles(bucket, prefix);\n                });\n\n                // Reset buttons for initial use\n                $btnUpload.show();\n                $btnCancel.text('Cancel');\n\n                // Bind file count into button\n                $btnUpload.attr('data-filecount', files.length);\n                $scope.$apply(() => {\n                    $scope.upload.title = `${bucket}/${prefix || ''}`;\n                    $scope.upload.button = `Upload (${files.length})`;\n                    $scope.upload.uploading = false;\n                });\n\n                // Reset files selector\n                if (SharedService.hasAddedFiles()) {\n                    SharedService.resetAddedFiles();\n                    $('#addedFiles').val('');\n                }\n\n                // Launch the uploader modal\n                $('#UploadModal').modal({ keyboard: true, backdrop: 'static' });\n            });\n    };\n\n    // Enable dropzone behavior and highlighting\n    $scope.dropZone($('.dropzone'));\n\n    // Simulate drop event on change of files selector\n    $('#addedFiles').on('change', (e) => {\n        SharedService.addFiles(e.target.files);\n        $('.dropzone').trigger('drop');\n    });\n}\n\n//\n// ErrorController: code associated with displaying runtime errors.\n//\nfunction ErrorController($scope) {\n    DEBUG.log('ErrorController init');\n    window.errorScope = $scope; // for debugging\n    $scope.error = {\n        errors: [], message: '',\n    };\n\n    $scope.$on('broadcastError', (e, args) => {\n        DEBUG.log('ErrorController', 'broadcast error', args);\n\n        $scope.$apply(() => {\n            Object.assign($scope.error, args);\n            DEBUG.log('scope errors', $scope.error.errors);\n        });\n\n        // Launch the error modal\n        $('#ErrorModal').modal({ keyboard: true, backdrop: 'static' });\n    });\n}\n\n//\n// TrashController: code associated with the Trash modal where the user can\n// delete objects.\n//\n// eslint-disable-next-line no-shadow\nfunction TrashController($scope, SharedService) {\n    DEBUG.log('TrashController init');\n    window.trashScope = $scope; // for debugging\n    $scope.trash = { title: null, button: null };\n\n    // Cache jquery selectors\n    const $btnDelete = $('#trash-btn-delete');\n    const $btnCancel = $('#trash-btn-cancel');\n\n    //\n    // Delete a list of objects from the provided S3 bucket\n    //\n    $scope.deleteFiles = (Bucket, objects, recursion) => {\n        DEBUG.log('Delete files:', objects);\n\n        $scope.$apply(() => {\n            $scope.trash.trashing = true;\n        });\n\n        for (let ii = 0; ii < objects.length; ii++) {\n            DEBUG.log('Delete key:', objects[ii].Key);\n            DEBUG.log('Object:', objects[ii]);\n            DEBUG.log('Index:', ii);\n\n            const s3 = new AWS.S3(AWS.config);\n\n            // If the user is deleting a folder then recursively list\n            // objects and delete them\n            if (isfolder(objects[ii].Key) && SharedService.getSettings().delimiter) {\n                const params = { Bucket, Prefix: objects[ii].Key };\n                s3.listObjects(params, (err, data) => {\n                    if (err) {\n                        if (!recursion) {\n                            // AccessDenied is a normal consequence of lack of permission\n                            // and we do not treat this as completely unexpected\n                            if (err.code === 'AccessDenied') {\n                                $(`#trash-td-${ii}`).html('<span class=\"trasherror\">Access Denied</span>');\n                            } else {\n                                DEBUG.log(JSON.stringify(err));\n                                $(`#trash-td-${ii}`).html(`<span class=\"trasherror\">Failed:&nbsp${err.code}</span>`);\n                                SharedService.showError(params, err);\n                            }\n                        } else {\n                            DEBUG.log(JSON.stringify(err));\n                            SharedService.showError(params, err);\n                        }\n                    } else if (data.Contents.length > 0) {\n                        $scope.deleteFiles(Bucket, data.Contents, true);\n                    }\n                });\n            }\n\n            const params = { Bucket, Key: objects[ii].Key };\n\n            DEBUG.log('Delete params:', params);\n            s3.deleteObject(params, (err, _data) => {\n                if (err) {\n                    if (!recursion) {\n                        // AccessDenied is a normal consequence of lack of permission\n                        // and we do not treat this as completely unexpected\n                        if (err.code === 'AccessDenied') {\n                            $(`#trash-td-${ii}`).html('<span class=\"trasherror\">Access Denied</span>');\n                        } else {\n                            DEBUG.log(JSON.stringify(err));\n                            $(`#trash-td-${ii}`).html(`<span class=\"trasherror\">Failed:&nbsp${err.code}</span>`);\n                            SharedService.showError(params, err);\n                        }\n                    } else {\n                        DEBUG.log(JSON.stringify(err));\n                        SharedService.showError(params, err);\n                    }\n                } else {\n                    DEBUG.log('Deleted', objects[ii].Key, 'from', Bucket);\n                    let count = $btnDelete.attr('data-filecount');\n\n                    if (!recursion) {\n                        $(`#trash-td-${ii}`).html('<span class=\"trashdeleted\">Deleted</span>');\n                        $btnDelete.attr('data-filecount', --count);\n                    }\n\n                    // Update count in Delete button\n                    $scope.$apply(() => {\n                        $scope.trash.button = `Delete (${count})`;\n                    });\n\n                    // If all files deleted then update buttons\n                    if (count === 0) {\n                        $btnDelete.hide();\n                        $btnCancel.text('Close');\n                    }\n\n                    // Refresh underlying folder view\n                    SharedService.viewRefresh();\n                }\n            });\n        }\n    };\n\n    $scope.$on('broadcastTrashObjects', (e, args) => {\n        DEBUG.log('TrashController', 'broadcast trash objects', args);\n\n        $('#trash-tbody tr').remove();\n\n        for (let ii = 0; ii < args.keys.length; ii++) {\n            const obj = args.keys[ii];\n            DEBUG.log('Object to be deleted:', obj);\n\n            const td = [\n                $('<td>').append(ii + 1),\n                $('<td>').append(path2short(isfolder(obj.Key) ? prefix2folder(obj.Key) : fullpath2filename(obj.Key))),\n                $('<td>').append(path2short(isfolder(obj.Key) ? prefix2parentfolder(obj.Key) : fullpath2pathname(obj.Key))),\n                $('<td>').append(isfolder(obj.Key) ? '' : moment(obj.LastModified).fromNow()),\n                $('<td>').append(obj.LastModified ? moment(obj.LastModified).local().format('YYYY-MM-DD HH:mm:ss') : ''),\n                $('<td>').append(isfolder(obj.Key) ? '' : mapStorage[obj.StorageClass]),\n                $('<td>').append(isfolder(obj.Key) ? '' : bytesToSize(obj.Size)),\n                $('<td>').attr('id', `trash-td-${ii}`).append($('<i>').append('n/a')),\n            ];\n\n            const tr = $('<tr>').attr('id', `trash-tr-${ii}`);\n            td.reduce((trac, item) => trac.append(item), tr);\n            $('#trash-tbody').append(tr);\n        }\n\n        // Remove any prior click handler from Delete button\n        $btnDelete.unbind('click');\n\n        // Add new click handler for Delete button\n        $btnDelete.click((e2) => {\n            e2.preventDefault();\n            $scope.deleteFiles(args.bucket, args.keys);\n        });\n\n        // Reset buttons for initial use\n        $btnDelete.show();\n        $btnCancel.text('Cancel');\n\n        // Bind file count into button\n        $btnDelete.attr('data-filecount', args.keys.length);\n        $scope.trash.count = args.keys.length;\n        $scope.trash.button = `Delete (${args.keys.length})`;\n        $scope.trash.trashing = false;\n\n        $('#TrashModal').modal({ keyboard: true, backdrop: 'static' });\n    });\n}\n\n// Create Angular module and attach factory and controllers\nangular.module('aws-js-s3-explorer', [])\n    .factory('SharedService', SharedService)\n    .controller('ErrorController', ErrorController)\n    .controller('ViewController', ViewController)\n    .controller('AddFolderController', AddFolderController)\n    .controller('InfoController', InfoController)\n    .controller('SettingsController', SettingsController)\n    .controller('UploadController', UploadController)\n    .controller('TrashController', TrashController);\n\n$(document).ready(() => {\n    DEBUG.log('Version jQuery', $.fn.jquery);\n\n    // Default AWS region and v4 signature\n    AWS.config.update({ region: '' });\n    AWS.config.update({ signatureVersion: 'v4' });\n\n    // Show navbuttons\n    $('#navbuttons').removeClass('hidden');\n\n    // Close handler for the alert\n    $('[data-hide]').on('click', (e) => {\n        $(e.currentTarget).parent().hide();\n    });\n\n    // Initialize the moment library (for time formatting utilities) and\n    // launch the initial Settings dialog requesting bucket & credentials.\n    moment().format();\n    $('#SettingsModal').modal({ keyboard: true, backdrop: 'static' });\n});\n"], "filenames": ["explorer.js"], "buggy_code_start_loc": [59], "buggy_code_end_loc": [371], "fixing_code_start_loc": [60], "fixing_code_end_loc": [385], "type": "CWE-79", "message": "explorer.js in Amazon AWS JavaScript S3 Explorer (aka aws-js-s3-explorer) v2 alpha before 2019-08-02 allows XSS in certain circumstances.", "other": {"cve": {"id": "CVE-2019-14652", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-13T05:15:11.103", "lastModified": "2020-02-18T19:56:27.463", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "explorer.js in Amazon AWS JavaScript S3 Explorer (aka aws-js-s3-explorer) v2 alpha before 2019-08-02 allows XSS in certain circumstances."}, {"lang": "es", "value": "El archivo explorer.js en Amazon AWS JavaScript S3 Explorer (tambi\u00e9n se conoce como aws-js-s3-explorer) versi\u00f3n v2 alpha anterior al 02-08-2019, permite una vulnerabilidad de tipo XSS en determinadas circunstancias."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_javascript_s3_explorer:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019-08-02", "matchCriteriaId": "99B86374-BF92-4BDE-A414-14DF076787E7"}]}]}], "references": [{"url": "https://github.com/awslabs/aws-js-s3-explorer/commit/7be671e858601455d6969e445d21a911632d6c94", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/awslabs/aws-js-s3-explorer/commit/87efa7d6885c4a9d8473ec5893adf8e4922a8a89", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/awslabs/aws-js-s3-explorer/pull/62", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/awslabs/aws-js-s3-explorer/commit/7be671e858601455d6969e445d21a911632d6c94"}}