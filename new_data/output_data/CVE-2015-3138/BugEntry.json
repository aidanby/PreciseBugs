{"buggy_code": ["/*\n * Copyright (c) 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <tcpdump-stdinc.h>\n\n#include \"interface.h\"\n#include \"addrtoname.h\"\n#include \"extract.h\"\n\nstatic const char tstr[] = \"[|wb]\";\n\n/* XXX need to add byte-swapping macros! */\n/* XXX - you mean like the ones in \"extract.h\"? */\n\n/*\n * Largest packet size.  Everything should fit within this space.\n * For instance, multiline objects are sent piecewise.\n */\n#define MAXFRAMESIZE 1024\n\n/*\n * Multiple drawing ops can be sent in one packet.  Each one starts on a\n * an even multiple of DOP_ALIGN bytes, which must be a power of two.\n */\n#define DOP_ALIGN 4\n#define DOP_ROUNDUP(x)\t((((int)(x)) + (DOP_ALIGN - 1)) & ~(DOP_ALIGN - 1))\n#define DOP_NEXT(d)\\\n\t((struct dophdr *)((u_char *)(d) + \\\n\t\t\t  DOP_ROUNDUP(EXTRACT_16BITS(&(d)->dh_len) + sizeof(*(d)))))\n\n/*\n * Format of the whiteboard packet header.\n * The transport level header.\n */\nstruct pkt_hdr {\n\tuint32_t ph_src;\t\t/* site id of source */\n\tuint32_t ph_ts;\t\t/* time stamp (for skew computation) */\n\tuint16_t ph_version;\t/* version number */\n\tu_char ph_type;\t\t/* message type */\n\tu_char ph_flags;\t/* message flags */\n};\n\n/* Packet types */\n#define PT_DRAWOP\t0\t/* drawing operation */\n#define PT_ID\t\t1\t/* announcement packet */\n#define PT_RREQ\t\t2\t/* repair request */\n#define PT_RREP\t\t3\t/* repair reply */\n#define PT_KILL\t\t4\t/* terminate participation */\n#define PT_PREQ         5       /* page vector request */\n#define PT_PREP         7       /* page vector reply */\n\n#ifdef PF_USER\n#undef PF_USER\t\t\t/* {Digital,Tru64} UNIX define this, alas */\n#endif\n\n/* flags */\n#define PF_USER\t\t0x01\t/* hint that packet has interactive data */\n#define PF_VIS\t\t0x02\t/* only visible ops wanted */\n\nstruct PageID {\n\tuint32_t p_sid;\t\t/* session id of initiator */\n\tuint32_t p_uid;\t\t/* page number */\n};\n\nstruct dophdr {\n\tuint32_t  dh_ts;\t\t/* sender's timestamp */\n\tuint16_t\tdh_len;\t\t/* body length */\n\tu_char\tdh_flags;\n\tu_char\tdh_type;\t/* body type */\n\t/* body follows */\n};\n/*\n * Drawing op sub-types.\n */\n#define DT_RECT         2\n#define DT_LINE         3\n#define DT_ML           4\n#define DT_DEL          5\n#define DT_XFORM        6\n#define DT_ELL          7\n#define DT_CHAR         8\n#define DT_STR          9\n#define DT_NOP          10\n#define DT_PSCODE       11\n#define DT_PSCOMP       12\n#define DT_REF          13\n#define DT_SKIP         14\n#define DT_HOLE         15\n#define DT_MAXTYPE      15\n\n/*\n * A drawing operation.\n */\nstruct pkt_dop {\n\tstruct PageID pd_page;\t/* page that operations apply to */\n\tuint32_t\tpd_sseq;\t/* start sequence number */\n\tuint32_t\tpd_eseq;\t/* end sequence number */\n\t/* drawing ops follow */\n};\n\n/*\n * A repair request.\n */\nstruct pkt_rreq {\n        uint32_t pr_id;           /* source id of drawops to be repaired */\n        struct PageID pr_page;           /* page of drawops */\n        uint32_t pr_sseq;         /* start seqno */\n        uint32_t pr_eseq;         /* end seqno */\n};\n\n/*\n * A repair reply.\n */\nstruct pkt_rrep {\n\tuint32_t pr_id;\t/* original site id of ops  */\n\tstruct pkt_dop pr_dop;\n\t/* drawing ops follow */\n};\n\nstruct id_off {\n        uint32_t id;\n        uint32_t off;\n};\n\nstruct pgstate {\n\tuint32_t slot;\n\tstruct PageID page;\n\tuint16_t nid;\n\tuint16_t rsvd;\n        /* seqptr's */\n};\n\n/*\n * An announcement packet.\n */\nstruct pkt_id {\n\tuint32_t pi_mslot;\n        struct PageID    pi_mpage;        /* current page */\n\tstruct pgstate pi_ps;\n        /* seqptr's */\n        /* null-terminated site name */\n};\n\nstruct pkt_preq {\n        struct PageID  pp_page;\n        uint32_t  pp_low;\n        uint32_t  pp_high;\n};\n\nstruct pkt_prep {\n        uint32_t  pp_n;           /* size of pageid array */\n        /* pgstate's follow */\n};\n\nstatic int\nwb_id(netdissect_options *ndo,\n      const struct pkt_id *id, u_int len)\n{\n\tint i;\n\tconst char *cp;\n\tconst struct id_off *io;\n\tchar c;\n\tint nid;\n\n\tND_PRINT((ndo, \" wb-id:\"));\n\tif (len < sizeof(*id) || !ND_TTEST(*id))\n\t\treturn (-1);\n\tlen -= sizeof(*id);\n\n\tND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\n\t       EXTRACT_32BITS(&id->pi_ps.slot),\n\t       ipaddr_string(ndo, &id->pi_ps.page.p_sid),\n\t       EXTRACT_32BITS(&id->pi_ps.page.p_uid),\n\t       EXTRACT_32BITS(&id->pi_mslot),\n\t       ipaddr_string(ndo, &id->pi_mpage.p_sid),\n\t       EXTRACT_32BITS(&id->pi_mpage.p_uid)));\n\n\tnid = EXTRACT_16BITS(&id->pi_ps.nid);\n\tlen -= sizeof(*io) * nid;\n\tio = (struct id_off *)(id + 1);\n\tcp = (char *)(io + nid);\n\tif (!ND_TTEST2(cp, len)) {\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\n\tc = '<';\n\tfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\n\t\tND_PRINT((ndo, \"%c%s:%u\",\n\t\t    c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\n\t\tc = ',';\n\t}\n\tif (i >= nid) {\n\t\tND_PRINT((ndo, \">\"));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}\n\nstatic int\nwb_rreq(netdissect_options *ndo,\n        const struct pkt_rreq *rreq, u_int len)\n{\n\tND_PRINT((ndo, \" wb-rreq:\"));\n\tif (len < sizeof(*rreq) || !ND_TTEST(*rreq))\n\t\treturn (-1);\n\n\tND_PRINT((ndo, \" please repair %s %s:%u<%u:%u>\",\n\t       ipaddr_string(ndo, &rreq->pr_id),\n\t       ipaddr_string(ndo, &rreq->pr_page.p_sid),\n\t       EXTRACT_32BITS(&rreq->pr_page.p_uid),\n\t       EXTRACT_32BITS(&rreq->pr_sseq),\n\t       EXTRACT_32BITS(&rreq->pr_eseq)));\n\treturn (0);\n}\n\nstatic int\nwb_preq(netdissect_options *ndo,\n        const struct pkt_preq *preq, u_int len)\n{\n\tND_PRINT((ndo, \" wb-preq:\"));\n\tif (len < sizeof(*preq) || !ND_TTEST(*preq))\n\t\treturn (-1);\n\n\tND_PRINT((ndo, \" need %u/%s:%u\",\n\t       EXTRACT_32BITS(&preq->pp_low),\n\t       ipaddr_string(ndo, &preq->pp_page.p_sid),\n\t       EXTRACT_32BITS(&preq->pp_page.p_uid)));\n\treturn (0);\n}\n\nstatic int\nwb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && !ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (struct pgstate *)io;\n\t}\n\treturn ((u_char *)ps <= ep? 0 : -1);\n}\n\n\nstatic const char *dopstr[] = {\n\t\"dop-0!\",\n\t\"dop-1!\",\n\t\"RECT\",\n\t\"LINE\",\n\t\"ML\",\n\t\"DEL\",\n\t\"XFORM\",\n\t\"ELL\",\n\t\"CHAR\",\n\t\"STR\",\n\t\"NOP\",\n\t\"PSCODE\",\n\t\"PSCOMP\",\n\t\"REF\",\n\t\"SKIP\",\n\t\"HOLE\",\n};\n\nstatic int\nwb_dops(netdissect_options *ndo, const struct pkt_dop *dop,\n        uint32_t ss, uint32_t es)\n{\n\tconst struct dophdr *dh = (const struct dophdr *)((const u_char *)dop + sizeof(*dop));\n\n\tND_PRINT((ndo, \" <\"));\n\tfor ( ; ss <= es; ++ss) {\n\t\tint t;\n\n\t\tif (!ND_TTEST(*dh)) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\tbreak;\n\t\t}\n\t\tt = dh->dh_type;\n\n\t\tif (t > DT_MAXTYPE)\n\t\t\tND_PRINT((ndo, \" dop-%d!\", t));\n\t\telse {\n\t\t\tND_PRINT((ndo, \" %s\", dopstr[t]));\n\t\t\tif (t == DT_SKIP || t == DT_HOLE) {\n\t\t\t\tuint32_t ts = EXTRACT_32BITS(&dh->dh_ts);\n\t\t\t\tND_PRINT((ndo, \"%d\", ts - ss + 1));\n\t\t\t\tif (ss > ts || ts > es) {\n\t\t\t\t\tND_PRINT((ndo, \"[|]\"));\n\t\t\t\t\tif (ts < ss)\n\t\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tss = ts;\n\t\t\t}\n\t\t}\n\t\tdh = DOP_NEXT(dh);\n\t}\n\tND_PRINT((ndo, \" >\"));\n\treturn (0);\n}\n\nstatic int\nwb_rrep(netdissect_options *ndo,\n        const struct pkt_rrep *rrep, u_int len)\n{\n\tconst struct pkt_dop *dop = &rrep->pr_dop;\n\n\tND_PRINT((ndo, \" wb-rrep:\"));\n\tif (len < sizeof(*rrep) || !ND_TTEST(*rrep))\n\t\treturn (-1);\n\tlen -= sizeof(*rrep);\n\n\tND_PRINT((ndo, \" for %s %s:%u<%u:%u>\",\n\t    ipaddr_string(ndo, &rrep->pr_id),\n\t    ipaddr_string(ndo, &dop->pd_page.p_sid),\n\t    EXTRACT_32BITS(&dop->pd_page.p_uid),\n\t    EXTRACT_32BITS(&dop->pd_sseq),\n\t    EXTRACT_32BITS(&dop->pd_eseq)));\n\n\tif (ndo->ndo_vflag)\n\t\treturn (wb_dops(ndo, dop,\n\t\t    EXTRACT_32BITS(&dop->pd_sseq),\n\t\t    EXTRACT_32BITS(&dop->pd_eseq)));\n\treturn (0);\n}\n\nstatic int\nwb_drawop(netdissect_options *ndo,\n          const struct pkt_dop *dop, u_int len)\n{\n\tND_PRINT((ndo, \" wb-dop:\"));\n\tif (len < sizeof(*dop) || !ND_TTEST(*dop))\n\t\treturn (-1);\n\tlen -= sizeof(*dop);\n\n\tND_PRINT((ndo, \" %s:%u<%u:%u>\",\n\t    ipaddr_string(ndo, &dop->pd_page.p_sid),\n\t    EXTRACT_32BITS(&dop->pd_page.p_uid),\n\t    EXTRACT_32BITS(&dop->pd_sseq),\n\t    EXTRACT_32BITS(&dop->pd_eseq)));\n\n\tif (ndo->ndo_vflag)\n\t\treturn (wb_dops(ndo, dop,\n\t\t\t\tEXTRACT_32BITS(&dop->pd_sseq),\n\t\t\t\tEXTRACT_32BITS(&dop->pd_eseq)));\n\treturn (0);\n}\n\n/*\n * Print whiteboard multicast packets.\n */\nvoid\nwb_print(netdissect_options *ndo,\n         register const void *hdr, register u_int len)\n{\n\tregister const struct pkt_hdr *ph;\n\n\tph = (const struct pkt_hdr *)hdr;\n\tif (len < sizeof(*ph) || !ND_TTEST(*ph)) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn;\n\t}\n\tlen -= sizeof(*ph);\n\n\tif (ph->ph_flags)\n\t\tND_PRINT((ndo, \"*\"));\n\tswitch (ph->ph_type) {\n\n\tcase PT_KILL:\n\t\tND_PRINT((ndo, \" wb-kill\"));\n\t\treturn;\n\n\tcase PT_ID:\n\t\tif (wb_id(ndo, (struct pkt_id *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_RREQ:\n\t\tif (wb_rreq(ndo, (struct pkt_rreq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_RREP:\n\t\tif (wb_rrep(ndo, (struct pkt_rrep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_DRAWOP:\n\t\tif (wb_drawop(ndo, (struct pkt_dop *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_PREQ:\n\t\tif (wb_preq(ndo, (struct pkt_preq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_PREP:\n\t\tif (wb_prep(ndo, (struct pkt_prep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \" wb-%d!\", ph->ph_type));\n\t\treturn;\n\t}\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1993, 1994, 1995, 1996\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <tcpdump-stdinc.h>\n\n#include \"interface.h\"\n#include \"addrtoname.h\"\n#include \"extract.h\"\n\nstatic const char tstr[] = \"[|wb]\";\n\n/* XXX need to add byte-swapping macros! */\n/* XXX - you mean like the ones in \"extract.h\"? */\n\n/*\n * Largest packet size.  Everything should fit within this space.\n * For instance, multiline objects are sent piecewise.\n */\n#define MAXFRAMESIZE 1024\n\n/*\n * Multiple drawing ops can be sent in one packet.  Each one starts on a\n * an even multiple of DOP_ALIGN bytes, which must be a power of two.\n */\n#define DOP_ALIGN 4\n#define DOP_ROUNDUP(x)\t((((int)(x)) + (DOP_ALIGN - 1)) & ~(DOP_ALIGN - 1))\n#define DOP_NEXT(d)\\\n\t((struct dophdr *)((u_char *)(d) + \\\n\t\t\t  DOP_ROUNDUP(EXTRACT_16BITS(&(d)->dh_len) + sizeof(*(d)))))\n\n/*\n * Format of the whiteboard packet header.\n * The transport level header.\n */\nstruct pkt_hdr {\n\tuint32_t ph_src;\t\t/* site id of source */\n\tuint32_t ph_ts;\t\t/* time stamp (for skew computation) */\n\tuint16_t ph_version;\t/* version number */\n\tu_char ph_type;\t\t/* message type */\n\tu_char ph_flags;\t/* message flags */\n};\n\n/* Packet types */\n#define PT_DRAWOP\t0\t/* drawing operation */\n#define PT_ID\t\t1\t/* announcement packet */\n#define PT_RREQ\t\t2\t/* repair request */\n#define PT_RREP\t\t3\t/* repair reply */\n#define PT_KILL\t\t4\t/* terminate participation */\n#define PT_PREQ         5       /* page vector request */\n#define PT_PREP         7       /* page vector reply */\n\n#ifdef PF_USER\n#undef PF_USER\t\t\t/* {Digital,Tru64} UNIX define this, alas */\n#endif\n\n/* flags */\n#define PF_USER\t\t0x01\t/* hint that packet has interactive data */\n#define PF_VIS\t\t0x02\t/* only visible ops wanted */\n\nstruct PageID {\n\tuint32_t p_sid;\t\t/* session id of initiator */\n\tuint32_t p_uid;\t\t/* page number */\n};\n\nstruct dophdr {\n\tuint32_t  dh_ts;\t\t/* sender's timestamp */\n\tuint16_t\tdh_len;\t\t/* body length */\n\tu_char\tdh_flags;\n\tu_char\tdh_type;\t/* body type */\n\t/* body follows */\n};\n/*\n * Drawing op sub-types.\n */\n#define DT_RECT         2\n#define DT_LINE         3\n#define DT_ML           4\n#define DT_DEL          5\n#define DT_XFORM        6\n#define DT_ELL          7\n#define DT_CHAR         8\n#define DT_STR          9\n#define DT_NOP          10\n#define DT_PSCODE       11\n#define DT_PSCOMP       12\n#define DT_REF          13\n#define DT_SKIP         14\n#define DT_HOLE         15\n#define DT_MAXTYPE      15\n\n/*\n * A drawing operation.\n */\nstruct pkt_dop {\n\tstruct PageID pd_page;\t/* page that operations apply to */\n\tuint32_t\tpd_sseq;\t/* start sequence number */\n\tuint32_t\tpd_eseq;\t/* end sequence number */\n\t/* drawing ops follow */\n};\n\n/*\n * A repair request.\n */\nstruct pkt_rreq {\n        uint32_t pr_id;           /* source id of drawops to be repaired */\n        struct PageID pr_page;           /* page of drawops */\n        uint32_t pr_sseq;         /* start seqno */\n        uint32_t pr_eseq;         /* end seqno */\n};\n\n/*\n * A repair reply.\n */\nstruct pkt_rrep {\n\tuint32_t pr_id;\t/* original site id of ops  */\n\tstruct pkt_dop pr_dop;\n\t/* drawing ops follow */\n};\n\nstruct id_off {\n        uint32_t id;\n        uint32_t off;\n};\n\nstruct pgstate {\n\tuint32_t slot;\n\tstruct PageID page;\n\tuint16_t nid;\n\tuint16_t rsvd;\n        /* seqptr's */\n};\n\n/*\n * An announcement packet.\n */\nstruct pkt_id {\n\tuint32_t pi_mslot;\n        struct PageID    pi_mpage;        /* current page */\n\tstruct pgstate pi_ps;\n        /* seqptr's */\n        /* null-terminated site name */\n};\n\nstruct pkt_preq {\n        struct PageID  pp_page;\n        uint32_t  pp_low;\n        uint32_t  pp_high;\n};\n\nstruct pkt_prep {\n        uint32_t  pp_n;           /* size of pageid array */\n        /* pgstate's follow */\n};\n\nstatic int\nwb_id(netdissect_options *ndo,\n      const struct pkt_id *id, u_int len)\n{\n\tint i;\n\tconst char *cp;\n\tconst struct id_off *io;\n\tchar c;\n\tint nid;\n\n\tND_PRINT((ndo, \" wb-id:\"));\n\tif (len < sizeof(*id) || !ND_TTEST(*id))\n\t\treturn (-1);\n\tlen -= sizeof(*id);\n\n\tND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\n\t       EXTRACT_32BITS(&id->pi_ps.slot),\n\t       ipaddr_string(ndo, &id->pi_ps.page.p_sid),\n\t       EXTRACT_32BITS(&id->pi_ps.page.p_uid),\n\t       EXTRACT_32BITS(&id->pi_mslot),\n\t       ipaddr_string(ndo, &id->pi_mpage.p_sid),\n\t       EXTRACT_32BITS(&id->pi_mpage.p_uid)));\n\n\tnid = EXTRACT_16BITS(&id->pi_ps.nid);\n\tlen -= sizeof(*io) * nid;\n\tio = (struct id_off *)(id + 1);\n\tcp = (char *)(io + nid);\n\tif (ND_TTEST2(cp, len)) {\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\n\tc = '<';\n\tfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\n\t\tND_PRINT((ndo, \"%c%s:%u\",\n\t\t    c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\n\t\tc = ',';\n\t}\n\tif (i >= nid) {\n\t\tND_PRINT((ndo, \">\"));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}\n\nstatic int\nwb_rreq(netdissect_options *ndo,\n        const struct pkt_rreq *rreq, u_int len)\n{\n\tND_PRINT((ndo, \" wb-rreq:\"));\n\tif (len < sizeof(*rreq) || !ND_TTEST(*rreq))\n\t\treturn (-1);\n\n\tND_PRINT((ndo, \" please repair %s %s:%u<%u:%u>\",\n\t       ipaddr_string(ndo, &rreq->pr_id),\n\t       ipaddr_string(ndo, &rreq->pr_page.p_sid),\n\t       EXTRACT_32BITS(&rreq->pr_page.p_uid),\n\t       EXTRACT_32BITS(&rreq->pr_sseq),\n\t       EXTRACT_32BITS(&rreq->pr_eseq)));\n\treturn (0);\n}\n\nstatic int\nwb_preq(netdissect_options *ndo,\n        const struct pkt_preq *preq, u_int len)\n{\n\tND_PRINT((ndo, \" wb-preq:\"));\n\tif (len < sizeof(*preq) || !ND_TTEST(*preq))\n\t\treturn (-1);\n\n\tND_PRINT((ndo, \" need %u/%s:%u\",\n\t       EXTRACT_32BITS(&preq->pp_low),\n\t       ipaddr_string(ndo, &preq->pp_page.p_sid),\n\t       EXTRACT_32BITS(&preq->pp_page.p_uid)));\n\treturn (0);\n}\n\nstatic int\nwb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (struct pgstate *)io;\n\t}\n\treturn ((u_char *)ps <= ep? 0 : -1);\n}\n\n\nstatic const char *dopstr[] = {\n\t\"dop-0!\",\n\t\"dop-1!\",\n\t\"RECT\",\n\t\"LINE\",\n\t\"ML\",\n\t\"DEL\",\n\t\"XFORM\",\n\t\"ELL\",\n\t\"CHAR\",\n\t\"STR\",\n\t\"NOP\",\n\t\"PSCODE\",\n\t\"PSCOMP\",\n\t\"REF\",\n\t\"SKIP\",\n\t\"HOLE\",\n};\n\nstatic int\nwb_dops(netdissect_options *ndo, const struct pkt_dop *dop,\n        uint32_t ss, uint32_t es)\n{\n\tconst struct dophdr *dh = (const struct dophdr *)((const u_char *)dop + sizeof(*dop));\n\n\tND_PRINT((ndo, \" <\"));\n\tfor ( ; ss <= es; ++ss) {\n\t\tint t;\n\n\t\tif (!ND_TTEST(*dh)) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\tbreak;\n\t\t}\n\t\tt = dh->dh_type;\n\n\t\tif (t > DT_MAXTYPE)\n\t\t\tND_PRINT((ndo, \" dop-%d!\", t));\n\t\telse {\n\t\t\tND_PRINT((ndo, \" %s\", dopstr[t]));\n\t\t\tif (t == DT_SKIP || t == DT_HOLE) {\n\t\t\t\tuint32_t ts = EXTRACT_32BITS(&dh->dh_ts);\n\t\t\t\tND_PRINT((ndo, \"%d\", ts - ss + 1));\n\t\t\t\tif (ss > ts || ts > es) {\n\t\t\t\t\tND_PRINT((ndo, \"[|]\"));\n\t\t\t\t\tif (ts < ss)\n\t\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tss = ts;\n\t\t\t}\n\t\t}\n\t\tdh = DOP_NEXT(dh);\n\t}\n\tND_PRINT((ndo, \" >\"));\n\treturn (0);\n}\n\nstatic int\nwb_rrep(netdissect_options *ndo,\n        const struct pkt_rrep *rrep, u_int len)\n{\n\tconst struct pkt_dop *dop = &rrep->pr_dop;\n\n\tND_PRINT((ndo, \" wb-rrep:\"));\n\tif (len < sizeof(*rrep) || !ND_TTEST(*rrep))\n\t\treturn (-1);\n\tlen -= sizeof(*rrep);\n\n\tND_PRINT((ndo, \" for %s %s:%u<%u:%u>\",\n\t    ipaddr_string(ndo, &rrep->pr_id),\n\t    ipaddr_string(ndo, &dop->pd_page.p_sid),\n\t    EXTRACT_32BITS(&dop->pd_page.p_uid),\n\t    EXTRACT_32BITS(&dop->pd_sseq),\n\t    EXTRACT_32BITS(&dop->pd_eseq)));\n\n\tif (ndo->ndo_vflag)\n\t\treturn (wb_dops(ndo, dop,\n\t\t    EXTRACT_32BITS(&dop->pd_sseq),\n\t\t    EXTRACT_32BITS(&dop->pd_eseq)));\n\treturn (0);\n}\n\nstatic int\nwb_drawop(netdissect_options *ndo,\n          const struct pkt_dop *dop, u_int len)\n{\n\tND_PRINT((ndo, \" wb-dop:\"));\n\tif (len < sizeof(*dop) || !ND_TTEST(*dop))\n\t\treturn (-1);\n\tlen -= sizeof(*dop);\n\n\tND_PRINT((ndo, \" %s:%u<%u:%u>\",\n\t    ipaddr_string(ndo, &dop->pd_page.p_sid),\n\t    EXTRACT_32BITS(&dop->pd_page.p_uid),\n\t    EXTRACT_32BITS(&dop->pd_sseq),\n\t    EXTRACT_32BITS(&dop->pd_eseq)));\n\n\tif (ndo->ndo_vflag)\n\t\treturn (wb_dops(ndo, dop,\n\t\t\t\tEXTRACT_32BITS(&dop->pd_sseq),\n\t\t\t\tEXTRACT_32BITS(&dop->pd_eseq)));\n\treturn (0);\n}\n\n/*\n * Print whiteboard multicast packets.\n */\nvoid\nwb_print(netdissect_options *ndo,\n         register const void *hdr, register u_int len)\n{\n\tregister const struct pkt_hdr *ph;\n\n\tph = (const struct pkt_hdr *)hdr;\n\tif (len < sizeof(*ph) || !ND_TTEST(*ph)) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn;\n\t}\n\tlen -= sizeof(*ph);\n\n\tif (ph->ph_flags)\n\t\tND_PRINT((ndo, \"*\"));\n\tswitch (ph->ph_type) {\n\n\tcase PT_KILL:\n\t\tND_PRINT((ndo, \" wb-kill\"));\n\t\treturn;\n\n\tcase PT_ID:\n\t\tif (wb_id(ndo, (struct pkt_id *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_RREQ:\n\t\tif (wb_rreq(ndo, (struct pkt_rreq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_RREP:\n\t\tif (wb_rrep(ndo, (struct pkt_rrep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_DRAWOP:\n\t\tif (wb_drawop(ndo, (struct pkt_dop *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_PREQ:\n\t\tif (wb_preq(ndo, (struct pkt_preq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase PT_PREP:\n\t\tif (wb_prep(ndo, (struct pkt_prep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \" wb-%d!\", ph->ph_type));\n\t\treturn;\n\t}\n}\n"], "filenames": ["print-wb.c"], "buggy_code_start_loc": [204], "buggy_code_end_loc": [279], "fixing_code_start_loc": [204], "fixing_code_end_loc": [279], "type": "CWE-20", "message": "print-wb.c in tcpdump before 4.7.4 allows remote attackers to cause a denial of service (segmentation fault and process crash).", "other": {"cve": {"id": "CVE-2015-3138", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-28T01:29:00.560", "lastModified": "2018-10-30T16:27:33.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "print-wb.c in tcpdump before 4.7.4 allows remote attackers to cause a denial of service (segmentation fault and process crash)."}, {"lang": "es", "value": "print-wb.c en tcpdump en versiones anteriores a la 4.7.4 permite que los atacantes provoquen una denegaci\u00f3n de servicio (fallo de segmentaci\u00f3n y cierre inesperado del proceso)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:tcpdump:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7.3", "matchCriteriaId": "900466DB-0EF9-41D8-B3E9-A0ECF48C6DEA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.2:*:*:*:*:*:*:*", "matchCriteriaId": "1EA337A3-B9A3-4962-B8BD-8E0C7C5B28EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse_project:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "CF605E46-ADCE-45B3-BBBA-E593D3CEE2A6"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-05/msg00018.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1212342", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/issues/446", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70"}}