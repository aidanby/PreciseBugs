{"buggy_code": ["/*\n * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* \\summary: Cisco HDLC printer */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include \"netdissect.h\"\n#include \"addrtoname.h\"\n#include \"ethertype.h\"\n#include \"extract.h\"\n#include \"chdlc.h\"\n\nstatic void chdlc_slarp_print(netdissect_options *, const u_char *, u_int);\n\nstatic const struct tok chdlc_cast_values[] = {\n    { CHDLC_UNICAST, \"unicast\" },\n    { CHDLC_BCAST, \"bcast\" },\n    { 0, NULL}\n};\n\n\n/* Standard CHDLC printer */\nu_int\nchdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\n\tif (caplen < CHDLC_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|chdlc]\"));\n\t\treturn (caplen);\n\t}\n        return (chdlc_print(ndo, p,length));\n}\n\nu_int\nchdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                /* is the fudge byte set ? lets verify by spotting ISO headers */\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\n\treturn (CHDLC_HDRLEN);\n}\n\n/*\n * The fixed-length portion of a SLARP packet.\n */\nstruct cisco_slarp {\n\tuint8_t code[4];\n#define SLARP_REQUEST\t0\n#define SLARP_REPLY\t1\n#define SLARP_KEEPALIVE\t2\n\tunion {\n\t\tstruct {\n\t\t\tuint8_t addr[4];\n\t\t\tuint8_t mask[4];\n\t\t} addr;\n\t\tstruct {\n\t\t\tuint8_t myseq[4];\n\t\t\tuint8_t yourseq[4];\n\t\t\tuint8_t rel[2];\n\t\t} keep;\n\t} un;\n};\n\n#define SLARP_MIN_LEN\t14\n#define SLARP_MAX_LEN\t18\n\nstatic void\nchdlc_slarp_print(netdissect_options *ndo, const u_char *cp, u_int length)\n{\n\tconst struct cisco_slarp *slarp;\n        u_int sec,min,hrs,days;\n\n\tND_PRINT((ndo, \"SLARP (length: %u), \",length));\n\tif (length < SLARP_MIN_LEN)\n\t\tgoto trunc;\n\n\tslarp = (const struct cisco_slarp *)cp;\n\tND_TCHECK2(*slarp, SLARP_MIN_LEN);\n\tswitch (EXTRACT_32BITS(&slarp->code)) {\n\tcase SLARP_REQUEST:\n\t\tND_PRINT((ndo, \"request\"));\n\t\t/*\n\t\t * At least according to William \"Chops\" Westfield's\n\t\t * message in\n\t\t *\n\t\t *\thttp://www.nethelp.no/net/cisco-hdlc.txt\n\t\t *\n\t\t * the address and mask aren't used in requests -\n\t\t * they're just zero.\n\t\t */\n\t\tbreak;\n\tcase SLARP_REPLY:\n\t\tND_PRINT((ndo, \"reply %s/%s\",\n\t\t\tipaddr_string(ndo, &slarp->un.addr.addr),\n\t\t\tipaddr_string(ndo, &slarp->un.addr.mask)));\n\t\tbreak;\n\tcase SLARP_KEEPALIVE:\n\t\tND_PRINT((ndo, \"keepalive: mineseen=0x%08x, yourseen=0x%08x, reliability=0x%04x\",\n                       EXTRACT_32BITS(&slarp->un.keep.myseq),\n                       EXTRACT_32BITS(&slarp->un.keep.yourseq),\n                       EXTRACT_16BITS(&slarp->un.keep.rel)));\n\n                if (length >= SLARP_MAX_LEN) { /* uptime-stamp is optional */\n                        cp += SLARP_MIN_LEN;\n                        ND_TCHECK2(*cp, 4);\n                        sec = EXTRACT_32BITS(cp) / 1000;\n                        min = sec / 60; sec -= min * 60;\n                        hrs = min / 60; min -= hrs * 60;\n                        days = hrs / 24; hrs -= days * 24;\n                        ND_PRINT((ndo, \", link uptime=%ud%uh%um%us\",days,hrs,min,sec));\n                }\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"0x%02x unknown\", EXTRACT_32BITS(&slarp->code)));\n                if (ndo->ndo_vflag <= 1)\n                    print_unknown_data(ndo,cp+4,\"\\n\\t\",length-4);\n\t\tbreak;\n\t}\n\n\tif (SLARP_MAX_LEN < length && ndo->ndo_vflag)\n\t\tND_PRINT((ndo, \", (trailing junk: %d bytes)\", length - SLARP_MAX_LEN));\n        if (ndo->ndo_vflag > 1)\n            print_unknown_data(ndo,cp+4,\"\\n\\t\",length-4);\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|slarp]\"));\n}\n\n\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 8\n * End:\n */\n"], "fixing_code": ["/*\n * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* \\summary: Cisco HDLC printer */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include \"netdissect.h\"\n#include \"addrtoname.h\"\n#include \"ethertype.h\"\n#include \"extract.h\"\n#include \"chdlc.h\"\n\nstatic void chdlc_slarp_print(netdissect_options *, const u_char *, u_int);\n\nstatic const struct tok chdlc_cast_values[] = {\n    { CHDLC_UNICAST, \"unicast\" },\n    { CHDLC_BCAST, \"bcast\" },\n    { 0, NULL}\n};\n\n\n/* Standard CHDLC printer */\nu_int\nchdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\treturn chdlc_print(ndo, p, h->len);\n}\n\nu_int\nchdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                /* is the fudge byte set ? lets verify by spotting ISO headers */\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\n\treturn (CHDLC_HDRLEN);\n\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}\n\n/*\n * The fixed-length portion of a SLARP packet.\n */\nstruct cisco_slarp {\n\tuint8_t code[4];\n#define SLARP_REQUEST\t0\n#define SLARP_REPLY\t1\n#define SLARP_KEEPALIVE\t2\n\tunion {\n\t\tstruct {\n\t\t\tuint8_t addr[4];\n\t\t\tuint8_t mask[4];\n\t\t} addr;\n\t\tstruct {\n\t\t\tuint8_t myseq[4];\n\t\t\tuint8_t yourseq[4];\n\t\t\tuint8_t rel[2];\n\t\t} keep;\n\t} un;\n};\n\n#define SLARP_MIN_LEN\t14\n#define SLARP_MAX_LEN\t18\n\nstatic void\nchdlc_slarp_print(netdissect_options *ndo, const u_char *cp, u_int length)\n{\n\tconst struct cisco_slarp *slarp;\n        u_int sec,min,hrs,days;\n\n\tND_PRINT((ndo, \"SLARP (length: %u), \",length));\n\tif (length < SLARP_MIN_LEN)\n\t\tgoto trunc;\n\n\tslarp = (const struct cisco_slarp *)cp;\n\tND_TCHECK2(*slarp, SLARP_MIN_LEN);\n\tswitch (EXTRACT_32BITS(&slarp->code)) {\n\tcase SLARP_REQUEST:\n\t\tND_PRINT((ndo, \"request\"));\n\t\t/*\n\t\t * At least according to William \"Chops\" Westfield's\n\t\t * message in\n\t\t *\n\t\t *\thttp://www.nethelp.no/net/cisco-hdlc.txt\n\t\t *\n\t\t * the address and mask aren't used in requests -\n\t\t * they're just zero.\n\t\t */\n\t\tbreak;\n\tcase SLARP_REPLY:\n\t\tND_PRINT((ndo, \"reply %s/%s\",\n\t\t\tipaddr_string(ndo, &slarp->un.addr.addr),\n\t\t\tipaddr_string(ndo, &slarp->un.addr.mask)));\n\t\tbreak;\n\tcase SLARP_KEEPALIVE:\n\t\tND_PRINT((ndo, \"keepalive: mineseen=0x%08x, yourseen=0x%08x, reliability=0x%04x\",\n                       EXTRACT_32BITS(&slarp->un.keep.myseq),\n                       EXTRACT_32BITS(&slarp->un.keep.yourseq),\n                       EXTRACT_16BITS(&slarp->un.keep.rel)));\n\n                if (length >= SLARP_MAX_LEN) { /* uptime-stamp is optional */\n                        cp += SLARP_MIN_LEN;\n                        ND_TCHECK2(*cp, 4);\n                        sec = EXTRACT_32BITS(cp) / 1000;\n                        min = sec / 60; sec -= min * 60;\n                        hrs = min / 60; min -= hrs * 60;\n                        days = hrs / 24; hrs -= days * 24;\n                        ND_PRINT((ndo, \", link uptime=%ud%uh%um%us\",days,hrs,min,sec));\n                }\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"0x%02x unknown\", EXTRACT_32BITS(&slarp->code)));\n                if (ndo->ndo_vflag <= 1)\n                    print_unknown_data(ndo,cp+4,\"\\n\\t\",length-4);\n\t\tbreak;\n\t}\n\n\tif (SLARP_MAX_LEN < length && ndo->ndo_vflag)\n\t\tND_PRINT((ndo, \", (trailing junk: %d bytes)\", length - SLARP_MAX_LEN));\n        if (ndo->ndo_vflag > 1)\n            print_unknown_data(ndo,cp+4,\"\\n\\t\",length-4);\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|slarp]\"));\n}\n\n\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 8\n * End:\n */\n"], "filenames": ["print-chdlc.c"], "buggy_code_start_loc": [49], "buggy_code_end_loc": [110], "fixing_code_start_loc": [49], "fixing_code_end_loc": [115], "type": "CWE-125", "message": "The Cisco HDLC parser in tcpdump before 4.9.2 has a buffer over-read in print-chdlc.c:chdlc_print().", "other": {"cve": {"id": "CVE-2017-13687", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-14T06:29:03.297", "lastModified": "2020-10-28T19:35:27.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Cisco HDLC parser in tcpdump before 4.9.2 has a buffer over-read in print-chdlc.c:chdlc_print()."}, {"lang": "es", "value": "El analizador sint\u00e1ctico Cisco HDLC en tcpdump en versiones anteriores a la 4.9.2 tiene una vulnerabilidad de sobrelectura de b\u00fafer en print-chdlc.c:chdlc_print()."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:tcpdump:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.9.1", "matchCriteriaId": "15620492-1343-4632-A942-281535A101B7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3971", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securitytracker.com/id/1039307", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.tcpdump.org/tcpdump-changes.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHEA-2018:0705", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/866c60236c41cea1e1654c8a071897292f64be49", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/a1eefe986065846b6c69dbc09afd9fa1a02c4a3d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201709-23", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/HT208221", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/a1eefe986065846b6c69dbc09afd9fa1a02c4a3d"}}