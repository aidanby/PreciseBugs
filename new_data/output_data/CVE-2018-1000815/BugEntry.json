{"buggy_code": ["// Copyright 2015 The Brave Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// This file provides Brave specific functionality that overrides the\n// functionality in Chrome. It is not a copy.\n#include \"chrome/renderer/content_settings_observer.h\"\n\n#include <string>\n\n#include \"atom/common/api/api_messages.h\"\n#include \"atom/renderer/content_settings_manager.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"chrome/common/render_messages.h\"\n#include \"components/content_settings/core/common/content_settings_pattern.h\"\n#include \"content/public/common/url_constants.h\"\n#include \"content/public/renderer/document_state.h\"\n#include \"content/public/renderer/render_frame.h\"\n#include \"content/public/renderer/render_view.h\"\n#include \"extensions/buildflags/buildflags.h\"\n#include \"third_party/blink/public/platform/url_conversion.h\"\n#include \"third_party/blink/public/platform/web_content_setting_callbacks.h\"\n#include \"third_party/blink/public/platform/web_security_origin.h\"\n#include \"third_party/blink/public/platform/web_url.h\"\n#include \"third_party/blink/public/web/web_document.h\"\n#include \"third_party/blink/public/web/web_local_frame_client.h\"\n#include \"third_party/blink/public/web/web_local_frame.h\"\n#include \"third_party/blink/public/web/web_view.h\"\n#include \"url/url_constants.h\"\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n#include \"extensions/common/constants.h\"\n#include \"extensions/common/extension.h\"\n#include \"extensions/common/permissions/api_permission.h\"\n#include \"extensions/common/permissions/permissions_data.h\"\n#include \"extensions/renderer/dispatcher.h\"\n#include \"extensions/renderer/renderer_extension_registry.h\"\n#endif\n\nusing atom::ContentSettingsManager;\nusing blink::WebContentSettingCallbacks;\nusing blink::WebDocument;\nusing blink::WebFrame;\nusing blink::WebSecurityOrigin;\nusing blink::WebString;\nusing blink::WebURL;\nusing blink::WebView;\nusing content::DocumentState;\nusing content::NavigationState;\n\nContentSettingsObserver::ContentSettingsObserver(\n    content::RenderFrame* render_frame,\n    extensions::Dispatcher* extension_dispatcher,\n    bool should_whitelist,\n    service_manager::BinderRegistry* registry)\n    : content::RenderFrameObserver(render_frame),\n      content::RenderFrameObserverTracker<ContentSettingsObserver>(\n          render_frame),\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n      extension_dispatcher_(extension_dispatcher),\n#endif\n      content_settings_manager_(NULL),\n      allow_running_insecure_content_(false),\n      is_interstitial_page_(false),\n      current_request_id_(0),\n      should_whitelist_(should_whitelist) {\n  ClearBlockedContentSettings();\n  render_frame->GetWebFrame()->SetContentSettingsClient(this);\n\n  content::RenderFrame* main_frame =\n      render_frame->GetRenderView()->GetMainRenderFrame();\n  // TODO(nasko): The main frame is not guaranteed to be in the same process\n  // with this frame with --site-per-process. This code needs to be updated\n  // to handle this case. See https://crbug.com/496670.\n  if (main_frame && main_frame != render_frame) {\n    // Copy all the settings from the main render frame to avoid race conditions\n    // when initializing this data. See https://crbug.com/333308.\n    ContentSettingsObserver* parent = ContentSettingsObserver::Get(main_frame);\n    allow_running_insecure_content_ = parent->allow_running_insecure_content_;\n    temporarily_allowed_plugins_ = parent->temporarily_allowed_plugins_;\n    is_interstitial_page_ = parent->is_interstitial_page_;\n  }\n}\n\nContentSettingsObserver::~ContentSettingsObserver() {\n}\n\nvoid ContentSettingsObserver::SetContentSettingRules(\n    const RendererContentSettingRules* content_setting_rules) {\n  content_setting_rules_ = content_setting_rules;\n}\n\nvoid ContentSettingsObserver::SetContentSettingsManager(\n    atom::ContentSettingsManager* content_settings_manager) {\n  content_settings_manager_ = content_settings_manager;\n}\n\nbool ContentSettingsObserver::IsPluginTemporarilyAllowed(\n    const std::string& identifier) {\n  // If the empty string is in here, it means all plugins are allowed.\n  // TODO(bauerb): Remove this once we only pass in explicit identifiers.\n  return (temporarily_allowed_plugins_.find(identifier) !=\n          temporarily_allowed_plugins_.end()) ||\n         (temporarily_allowed_plugins_.find(std::string()) !=\n          temporarily_allowed_plugins_.end());\n}\n\nvoid ContentSettingsObserver::DidBlockContentType(\n    ContentSettingsType settings_type, const base::string16& details) {\n  std::string settings_type_string = \"unknown\";\n  switch (settings_type) {\n    case CONTENT_SETTINGS_TYPE_COOKIES:\n      settings_type_string = \"cookies\";\n      break;\n    case CONTENT_SETTINGS_TYPE_IMAGES:\n      settings_type_string = \"images\";\n      break;\n    case CONTENT_SETTINGS_TYPE_JAVASCRIPT:\n      settings_type_string = \"javascript\";\n      break;\n    case CONTENT_SETTINGS_TYPE_PLUGINS:\n      settings_type_string = \"plugins\";\n      break;\n    case CONTENT_SETTINGS_TYPE_POPUPS:\n      settings_type_string = \"popups\";\n      break;\n    case CONTENT_SETTINGS_TYPE_GEOLOCATION:\n      settings_type_string = \"geo\";\n      break;\n    case CONTENT_SETTINGS_TYPE_NOTIFICATIONS:\n      settings_type_string = \"notifications\";\n      break;\n    case CONTENT_SETTINGS_TYPE_AUTO_SELECT_CERTIFICATE:\n      settings_type_string = \"auto_select_certificate\";\n      break;\n    case CONTENT_SETTINGS_TYPE_MIXEDSCRIPT:\n      settings_type_string = \"runInsecureContent\";\n      break;\n    case CONTENT_SETTINGS_TYPE_MEDIASTREAM_MIC:\n      settings_type_string = \"mediastream_mic\";\n      break;\n    case CONTENT_SETTINGS_TYPE_MEDIASTREAM_CAMERA:\n      settings_type_string = \"mediastream_camera\";\n      break;\n    case CONTENT_SETTINGS_TYPE_PROTOCOL_HANDLERS:\n      settings_type_string = \"protocol_handlers\";\n      break;\n    case CONTENT_SETTINGS_TYPE_PPAPI_BROKER:\n      settings_type_string = \"ppapi_broker\";\n      break;\n    case CONTENT_SETTINGS_TYPE_AUTOMATIC_DOWNLOADS:\n      settings_type_string = \"automatic_downloads\";\n      break;\n    case CONTENT_SETTINGS_TYPE_MIDI_SYSEX:\n      settings_type_string = \"midi_sysex\";\n      break;\n    case CONTENT_SETTINGS_TYPE_SSL_CERT_DECISIONS:\n      settings_type_string = \"ssl_cert_decisions\";\n      break;\n    case CONTENT_SETTINGS_TYPE_PROTECTED_MEDIA_IDENTIFIER:\n      settings_type_string = \"protected_media_identifiers\";\n      break;\n    case CONTENT_SETTINGS_TYPE_SITE_ENGAGEMENT:\n      settings_type_string = \"site_engagement\";\n      break;\n    case CONTENT_SETTINGS_TYPE_DURABLE_STORAGE:\n      settings_type_string = \"durable_storage\";\n      break;\n    case CONTENT_SETTINGS_TYPE_USB_CHOOSER_DATA:\n      settings_type_string = \"usb_chooser_data\";\n      break;\n    case CONTENT_SETTINGS_TYPE_BLUETOOTH_GUARD:\n      settings_type_string = \"bluetooth_guard\";\n      break;\n    case CONTENT_SETTINGS_TYPE_BACKGROUND_SYNC:\n      settings_type_string = \"background_sync\";\n      break;\n    case CONTENT_SETTINGS_TYPE_AUTOPLAY:\n      settings_type_string = \"autoplay\";\n      break;\n    // do nothing\n    case CONTENT_SETTINGS_TYPE_DEFAULT:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_APP_BANNER:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_IMPORTANT_SITE_INFO:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_PERMISSION_AUTOBLOCKER_DATA:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_ADS:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_ADS_DATA:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_MIDI:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_PASSWORD_PROTECTION:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_MEDIA_ENGAGEMENT:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_SOUND:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_CLIENT_HINTS:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_SENSORS:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_ACCESSIBILITY_EVENTS:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_CLIPBOARD_READ:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_CLIPBOARD_WRITE:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_PLUGINS_DATA:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_PAYMENT_HANDLER:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_USB_GUARD:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_NUM_TYPES:\n      break;\n  }\n  DidBlockContentType(settings_type_string, base::UTF16ToUTF8(details));\n}\n\nvoid ContentSettingsObserver::DidBlockContentType(\n    ContentSettingsType settings_type) {\n  DidBlockContentType(settings_type, base::string16());\n}\n\nvoid ContentSettingsObserver::DidBlockContentType(\n    const std::string& settings_type) {\n  DidBlockContentType(settings_type,\n      blink::WebStringToGURL(render_frame()->GetWebFrame()->\n          GetSecurityOrigin().ToString()).spec());\n}\n\nvoid ContentSettingsObserver::DidBlockContentType(\n    const std::string& settings_type,\n    const std::string& details) {\n  base::ListValue args;\n  args.AppendString(settings_type);\n  args.AppendString(details);\n\n  auto rf = render_frame();\n  rf->Send(new AtomViewHostMsg_Message(\n    rf->GetRoutingID(), base::UTF8ToUTF16(\"content-blocked\"), args));\n}\n\nbool ContentSettingsObserver::OnMessageReceived(const IPC::Message& message) {\n  // Don't swallow LoadBlockedPlugins messages, as they're sent to every\n  // blocked plugin.\n  IPC_BEGIN_MESSAGE_MAP(ContentSettingsObserver, message)\n    IPC_MESSAGE_HANDLER(ChromeViewMsg_LoadBlockedPlugins, OnLoadBlockedPlugins)\n  IPC_END_MESSAGE_MAP()\n\n  return false;\n}\n\nvoid ContentSettingsObserver::DidCommitProvisionalLoad(\n    bool is_new_navigation,\n    bool is_same_page_navigation) {\n  WebFrame* frame = render_frame()->GetWebFrame();\n  if (frame->Parent())\n    return;  // Not a top-level navigation.\n\n  if (!is_same_page_navigation) {\n    ClearBlockedContentSettings();\n    temporarily_allowed_plugins_.clear();\n  }\n}\n\nvoid ContentSettingsObserver::OnDestruct() {\n  delete this;\n}\n\nbool ContentSettingsObserver::AllowDatabase(const WebString& name,\n                                          const WebString& display_name,\n                                          unsigned estimated_size) {  // NOLINT\n  WebFrame* frame = render_frame()->GetWebFrame();\n  if (frame->GetSecurityOrigin().IsUnique() ||\n      frame->Top()->GetSecurityOrigin().IsUnique())\n    return false;\n\n  bool allow = true;\n  GURL secondary_url(\n      blink::WebStringToGURL(frame->GetSecurityOrigin().ToString()));\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(frame),\n          secondary_url,\n          \"cookies\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(\"database\", secondary_url.spec());\n  return allow;\n}\n\n\nvoid ContentSettingsObserver::RequestFileSystemAccessAsync(\n        const WebContentSettingCallbacks& callbacks) {\n  WebFrame* frame = render_frame()->GetWebFrame();\n  WebContentSettingCallbacks permissionCallbacks(callbacks);\n  if (frame->GetSecurityOrigin().IsUnique() ||\n      frame->Top()->GetSecurityOrigin().IsUnique()) {\n      permissionCallbacks.DoDeny();\n      return;\n  }\n\n  bool allow = true;\n  GURL secondary_url(\n      blink::WebStringToGURL(frame->GetSecurityOrigin().ToString()));\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(frame),\n          secondary_url,\n          \"cookies\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n  if (!allow) {\n      DidBlockContentType(\"filesystem\", secondary_url.spec());\n      permissionCallbacks.DoDeny();\n  } else {\n      permissionCallbacks.DoAllow();\n  }\n}\n\nbool ContentSettingsObserver::AllowImage(bool enabled_per_settings,\n                                         const WebURL& image_url) {\n  if (enabled_per_settings && IsWhitelistedForContentSettings())\n    return true;\n\n  bool allow = enabled_per_settings;\n  GURL secondary_url(image_url);\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(\n                render_frame()->GetWebFrame()),\n            secondary_url,\n            \"images\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(\"images\", secondary_url.spec());\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowIndexedDB(const WebString& name,\n                                             const WebSecurityOrigin& origin) {\n  WebFrame* frame = render_frame()->GetWebFrame();\n  if (frame->GetSecurityOrigin().IsUnique() ||\n      frame->Top()->GetSecurityOrigin().IsUnique())\n    return false;\n\n  bool allow = true;\n  GURL secondary_url(\n      blink::WebStringToGURL(frame->GetSecurityOrigin().ToString()));\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(frame),\n            secondary_url,\n            \"cookies\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(\"indexedDB\", secondary_url.spec());\n  return allow;\n}\n\nGURL GetOriginOrURL(const WebFrame* frame) {\n  url::Origin top_origin = url::Origin(frame->Top()->GetSecurityOrigin());\n  // The |top_origin| is unique (\"null\") e.g., for file:// URLs. Use the\n  // document URL as the primary URL in those cases.\n  // TODO(alexmos): This is broken for --site-per-process, since top() can be a\n  // WebRemoteFrame which does not have a document(), and the WebRemoteFrame's\n  // URL is not replicated.  See https://crbug.com/628759.\n  if (top_origin.unique() && frame->Top()->IsWebLocalFrame())\n    return frame->Top()->ToWebLocalFrame()->GetDocument().Url();\n  return top_origin.GetURL();\n}\n\n// Allow passing both WebURL and GURL here, so that we can early return without\n// allocating a new backing string if only the default rule matches.\ntemplate <typename URL>\nContentSetting GetContentSettingFromRules(\n    const ContentSettingsForOneType& rules,\n    const WebFrame* frame,\n    const URL& secondary_url) {\n  // If there is only one rule, it's the default rule and we don't need to match\n  // the patterns.\n  if (rules.size() == 1) {\n    DCHECK(rules[0].primary_pattern == ContentSettingsPattern::Wildcard());\n    DCHECK(rules[0].secondary_pattern == ContentSettingsPattern::Wildcard());\n    return rules[0].GetContentSetting();\n  }\n  const GURL& primary_url = GetOriginOrURL(frame);\n  const GURL& secondary_gurl = secondary_url;\n  for (const auto& rule : rules) {\n    if (rule.primary_pattern.Matches(primary_url) &&\n        rule.secondary_pattern.Matches(secondary_gurl)) {\n      return rule.GetContentSetting();\n    }\n  }\n  NOTREACHED();\n  return CONTENT_SETTING_DEFAULT;\n}\n\nbool IsScriptDisabledForPreview(const content::RenderFrame* render_frame) {\n  return render_frame->GetPreviewsState() & content::NOSCRIPT_ON;\n}\n\nbool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n\n  // Evaluate the content setting rules before\n  // IsWhitelistedForContentSettings(); if there is only the default rule\n  // allowing all scripts, it's quicker this way.\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowScriptFromSource(\n    bool enabled_per_settings,\n    const blink::WebURL& script_url) {\n  if (IsWhitelistedForContentSettings())\n    return true;\n\n  bool allow = enabled_per_settings;\n  GURL secondary_url(script_url);\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),\n          secondary_url,\n          \"javascript\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  allow = allow || IsWhitelistedForContentSettings();\n  if (!allow)\n    DidBlockContentType(\"javascript\", secondary_url.spec());\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowStorage(bool local) {\n  if (IsWhitelistedForContentSettings())\n    return true;\n\n  WebFrame* frame = render_frame()->GetWebFrame();\n  if (frame->GetSecurityOrigin().IsUnique() ||\n      frame->Top()->GetSecurityOrigin().IsUnique())\n    return false;\n\n  StoragePermissionsKey key(\n      blink::WebStringToGURL(frame->ToWebLocalFrame()->GetDocument().GetSecurityOrigin().ToString()),\n      local);\n  std::map<StoragePermissionsKey, bool>::const_iterator permissions =\n      cached_storage_permissions_.find(key);\n  if (permissions != cached_storage_permissions_.end())\n    return permissions->second;\n\n  bool allow = true;\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(frame),\n          blink::WebStringToGURL(frame->GetSecurityOrigin().ToString()),\n          \"cookies\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  cached_storage_permissions_[key] = allow;\n  if (!allow)\n    DidBlockContentType(\"storage\");\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowReadFromClipboard(bool default_value) {\n  bool allowed = default_value;\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  extensions::ScriptContext* current_context =\n      extension_dispatcher_->script_context_set().GetCurrent();\n  if (current_context) {\n    allowed |= current_context->HasAPIPermission(\n        extensions::APIPermission::kClipboardRead);\n  }\n#endif\n  return allowed;\n}\n\nbool ContentSettingsObserver::AllowWriteToClipboard(bool default_value) {\n  bool allowed = default_value;\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // All blessed extension pages could historically write to the clipboard, so\n  // preserve that for compatibility.\n  extensions::ScriptContext* current_context =\n      extension_dispatcher_->script_context_set().GetCurrent();\n  if (current_context) {\n    if (current_context->effective_context_type() ==\n        extensions::Feature::BLESSED_EXTENSION_CONTEXT) {\n      allowed = true;\n    } else {\n      allowed |= current_context->HasAPIPermission(\n          extensions::APIPermission::kClipboardWrite);\n    }\n  }\n#endif\n  return allowed;\n}\n\nbool ContentSettingsObserver::AllowMutationEvents(bool default_value) {\n  if (IsWhitelistedForContentSettings())\n    return true;\n\n  bool allow = default_value;\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(\n                render_frame()->GetWebFrame()),\n            GURL(),\n            \"mutation\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(\"mutation\");\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowRunningInsecureContent(\n    bool allowed_per_settings,\n    const blink::WebSecurityOrigin& origin,\n    const blink::WebURL& resource_url) {\n  // TODO(bridiver) is origin different than web frame top origin?\n  bool allow = allowed_per_settings;\n  GURL secondary_url(resource_url);\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(\n                render_frame()->GetWebFrame()),\n            secondary_url,\n            \"runInsecureContent\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (allow)\n    DidRunInsecureContent(GURL(resource_url));\n  else\n    DidBlockRunInsecureContent(GURL(resource_url));\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowAutoplay(bool default_value) {\n  bool allow = default_value;\n  if (content_settings_manager_->content_settings()) {\n    WebFrame* frame = render_frame()->GetWebFrame();\n    auto origin = frame->ToWebLocalFrame()->GetDocument().GetSecurityOrigin();\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(frame),\n            blink::WebStringToGURL(origin.ToString()),\n            \"autoplay\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(CONTENT_SETTINGS_TYPE_AUTOPLAY);\n  return allow;\n}\n\nvoid ContentSettingsObserver::DidNotAllowPlugins() {\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_PLUGINS);\n}\n\nvoid ContentSettingsObserver::DidNotAllowScript() {\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_JAVASCRIPT);\n}\n\nvoid ContentSettingsObserver::OnLoadBlockedPlugins(\n    const std::string& identifier) {\n  temporarily_allowed_plugins_.insert(identifier);\n}\n\nvoid ContentSettingsObserver::DidRunInsecureContent(GURL resouce_url) {\n  base::ListValue args;\n    args.AppendString(resouce_url.spec());\n\n    auto rf = render_frame();\n    rf->Send(new AtomViewHostMsg_Message(rf->GetRoutingID(),\n        base::UTF8ToUTF16(\"did-run-insecure-content\"), args));\n}\n\nvoid ContentSettingsObserver::DidBlockRunInsecureContent(GURL resouce_url) {\n  base::ListValue args;\n    args.AppendString(resouce_url.spec());\n\n    auto rf = render_frame();\n    rf->Send(new AtomViewHostMsg_Message(rf->GetRoutingID(),\n        base::UTF8ToUTF16(\"did-block-run-insecure-content\"), args));\n}\n\nvoid ContentSettingsObserver::ClearBlockedContentSettings() {\n  cached_storage_permissions_.clear();\n  cached_script_permissions_.clear();\n}\n\nbool ContentSettingsObserver::IsWhitelistedForContentSettings() const {\n  // Whitelist ftp directory listings, as they require JavaScript to function\n  // properly.\n  if (!render_frame()) {\n    return false;\n  }\n\n  if (render_frame()->IsFTPDirectoryListing())\n    return true;\n\n  WebFrame* web_frame = render_frame()->GetWebFrame();\n\n  if (!web_frame) {\n    return false;\n  }\n\n  return IsWhitelistedForContentSettings(\n      web_frame->ToWebLocalFrame()->GetDocument().GetSecurityOrigin(),\n      web_frame->ToWebLocalFrame()->GetDocument().Url());\n}\n\nbool ContentSettingsObserver::IsWhitelistedForContentSettings(\n    const WebSecurityOrigin& origin,\n    const GURL& document_url) {\n  if (document_url == GURL(content::kUnreachableWebDataURL))\n    return true;\n\n  if (origin.IsUnique())\n    return false;  // Uninitialized document?\n\n  base::string16 protocol = origin.Protocol().Utf16();\n  if (base::EqualsASCII(protocol, content::kChromeUIScheme))\n    return true;  // Browser UI elements should still work.\n\n  if (base::EqualsASCII(protocol, content::kChromeDevToolsScheme))\n    return true;  // DevTools UI elements should still work.\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  if (base::EqualsASCII(protocol, extensions::kExtensionScheme))\n    return true;\n#endif\n\n  // If the scheme is file:, an empty file name indicates a directory listing,\n  // which requires JavaScript to function properly.\n  if (base::EqualsASCII(protocol, url::kFileScheme)) {\n    return document_url.SchemeIs(url::kFileScheme) &&\n           document_url.ExtractFileName().empty();\n  }\n\n  return false;\n}\n"], "fixing_code": ["// Copyright 2015 The Brave Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// This file provides Brave specific functionality that overrides the\n// functionality in Chrome. It is not a copy.\n#include \"chrome/renderer/content_settings_observer.h\"\n\n#include <string>\n\n#include \"atom/common/api/api_messages.h\"\n#include \"atom/renderer/content_settings_manager.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"chrome/common/render_messages.h\"\n#include \"components/content_settings/core/common/content_settings_pattern.h\"\n#include \"content/public/common/url_constants.h\"\n#include \"content/public/renderer/document_state.h\"\n#include \"content/public/renderer/render_frame.h\"\n#include \"content/public/renderer/render_view.h\"\n#include \"extensions/buildflags/buildflags.h\"\n#include \"third_party/blink/public/platform/url_conversion.h\"\n#include \"third_party/blink/public/platform/web_content_setting_callbacks.h\"\n#include \"third_party/blink/public/platform/web_security_origin.h\"\n#include \"third_party/blink/public/platform/web_url.h\"\n#include \"third_party/blink/public/web/web_document.h\"\n#include \"third_party/blink/public/web/web_local_frame_client.h\"\n#include \"third_party/blink/public/web/web_local_frame.h\"\n#include \"third_party/blink/public/web/web_view.h\"\n#include \"url/url_constants.h\"\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n#include \"extensions/common/constants.h\"\n#include \"extensions/common/extension.h\"\n#include \"extensions/common/permissions/api_permission.h\"\n#include \"extensions/common/permissions/permissions_data.h\"\n#include \"extensions/renderer/dispatcher.h\"\n#include \"extensions/renderer/renderer_extension_registry.h\"\n#endif\n\nusing atom::ContentSettingsManager;\nusing blink::WebContentSettingCallbacks;\nusing blink::WebDocument;\nusing blink::WebFrame;\nusing blink::WebSecurityOrigin;\nusing blink::WebString;\nusing blink::WebURL;\nusing blink::WebView;\nusing content::DocumentState;\nusing content::NavigationState;\n\nContentSettingsObserver::ContentSettingsObserver(\n    content::RenderFrame* render_frame,\n    extensions::Dispatcher* extension_dispatcher,\n    bool should_whitelist,\n    service_manager::BinderRegistry* registry)\n    : content::RenderFrameObserver(render_frame),\n      content::RenderFrameObserverTracker<ContentSettingsObserver>(\n          render_frame),\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n      extension_dispatcher_(extension_dispatcher),\n#endif\n      content_settings_manager_(NULL),\n      allow_running_insecure_content_(false),\n      is_interstitial_page_(false),\n      current_request_id_(0),\n      should_whitelist_(should_whitelist) {\n  ClearBlockedContentSettings();\n  render_frame->GetWebFrame()->SetContentSettingsClient(this);\n\n  content::RenderFrame* main_frame =\n      render_frame->GetRenderView()->GetMainRenderFrame();\n  // TODO(nasko): The main frame is not guaranteed to be in the same process\n  // with this frame with --site-per-process. This code needs to be updated\n  // to handle this case. See https://crbug.com/496670.\n  if (main_frame && main_frame != render_frame) {\n    // Copy all the settings from the main render frame to avoid race conditions\n    // when initializing this data. See https://crbug.com/333308.\n    ContentSettingsObserver* parent = ContentSettingsObserver::Get(main_frame);\n    allow_running_insecure_content_ = parent->allow_running_insecure_content_;\n    temporarily_allowed_plugins_ = parent->temporarily_allowed_plugins_;\n    is_interstitial_page_ = parent->is_interstitial_page_;\n  }\n}\n\nContentSettingsObserver::~ContentSettingsObserver() {\n}\n\nvoid ContentSettingsObserver::SetContentSettingRules(\n    const RendererContentSettingRules* content_setting_rules) {\n  content_setting_rules_ = content_setting_rules;\n}\n\nvoid ContentSettingsObserver::SetContentSettingsManager(\n    atom::ContentSettingsManager* content_settings_manager) {\n  content_settings_manager_ = content_settings_manager;\n}\n\nbool ContentSettingsObserver::IsPluginTemporarilyAllowed(\n    const std::string& identifier) {\n  // If the empty string is in here, it means all plugins are allowed.\n  // TODO(bauerb): Remove this once we only pass in explicit identifiers.\n  return (temporarily_allowed_plugins_.find(identifier) !=\n          temporarily_allowed_plugins_.end()) ||\n         (temporarily_allowed_plugins_.find(std::string()) !=\n          temporarily_allowed_plugins_.end());\n}\n\nvoid ContentSettingsObserver::DidBlockContentType(\n    ContentSettingsType settings_type, const base::string16& details) {\n  std::string settings_type_string = \"unknown\";\n  switch (settings_type) {\n    case CONTENT_SETTINGS_TYPE_COOKIES:\n      settings_type_string = \"cookies\";\n      break;\n    case CONTENT_SETTINGS_TYPE_IMAGES:\n      settings_type_string = \"images\";\n      break;\n    case CONTENT_SETTINGS_TYPE_JAVASCRIPT:\n      settings_type_string = \"javascript\";\n      break;\n    case CONTENT_SETTINGS_TYPE_PLUGINS:\n      settings_type_string = \"plugins\";\n      break;\n    case CONTENT_SETTINGS_TYPE_POPUPS:\n      settings_type_string = \"popups\";\n      break;\n    case CONTENT_SETTINGS_TYPE_GEOLOCATION:\n      settings_type_string = \"geo\";\n      break;\n    case CONTENT_SETTINGS_TYPE_NOTIFICATIONS:\n      settings_type_string = \"notifications\";\n      break;\n    case CONTENT_SETTINGS_TYPE_AUTO_SELECT_CERTIFICATE:\n      settings_type_string = \"auto_select_certificate\";\n      break;\n    case CONTENT_SETTINGS_TYPE_MIXEDSCRIPT:\n      settings_type_string = \"runInsecureContent\";\n      break;\n    case CONTENT_SETTINGS_TYPE_MEDIASTREAM_MIC:\n      settings_type_string = \"mediastream_mic\";\n      break;\n    case CONTENT_SETTINGS_TYPE_MEDIASTREAM_CAMERA:\n      settings_type_string = \"mediastream_camera\";\n      break;\n    case CONTENT_SETTINGS_TYPE_PROTOCOL_HANDLERS:\n      settings_type_string = \"protocol_handlers\";\n      break;\n    case CONTENT_SETTINGS_TYPE_PPAPI_BROKER:\n      settings_type_string = \"ppapi_broker\";\n      break;\n    case CONTENT_SETTINGS_TYPE_AUTOMATIC_DOWNLOADS:\n      settings_type_string = \"automatic_downloads\";\n      break;\n    case CONTENT_SETTINGS_TYPE_MIDI_SYSEX:\n      settings_type_string = \"midi_sysex\";\n      break;\n    case CONTENT_SETTINGS_TYPE_SSL_CERT_DECISIONS:\n      settings_type_string = \"ssl_cert_decisions\";\n      break;\n    case CONTENT_SETTINGS_TYPE_PROTECTED_MEDIA_IDENTIFIER:\n      settings_type_string = \"protected_media_identifiers\";\n      break;\n    case CONTENT_SETTINGS_TYPE_SITE_ENGAGEMENT:\n      settings_type_string = \"site_engagement\";\n      break;\n    case CONTENT_SETTINGS_TYPE_DURABLE_STORAGE:\n      settings_type_string = \"durable_storage\";\n      break;\n    case CONTENT_SETTINGS_TYPE_USB_CHOOSER_DATA:\n      settings_type_string = \"usb_chooser_data\";\n      break;\n    case CONTENT_SETTINGS_TYPE_BLUETOOTH_GUARD:\n      settings_type_string = \"bluetooth_guard\";\n      break;\n    case CONTENT_SETTINGS_TYPE_BACKGROUND_SYNC:\n      settings_type_string = \"background_sync\";\n      break;\n    case CONTENT_SETTINGS_TYPE_AUTOPLAY:\n      settings_type_string = \"autoplay\";\n      break;\n    // do nothing\n    case CONTENT_SETTINGS_TYPE_DEFAULT:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_APP_BANNER:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_IMPORTANT_SITE_INFO:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_PERMISSION_AUTOBLOCKER_DATA:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_ADS:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_ADS_DATA:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_MIDI:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_PASSWORD_PROTECTION:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_MEDIA_ENGAGEMENT:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_SOUND:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_CLIENT_HINTS:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_SENSORS:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_ACCESSIBILITY_EVENTS:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_CLIPBOARD_READ:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_CLIPBOARD_WRITE:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_PLUGINS_DATA:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_PAYMENT_HANDLER:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_TYPE_USB_GUARD:\n      FALLTHROUGH;\n    case CONTENT_SETTINGS_NUM_TYPES:\n      break;\n  }\n  DidBlockContentType(settings_type_string, base::UTF16ToUTF8(details));\n}\n\nvoid ContentSettingsObserver::DidBlockContentType(\n    ContentSettingsType settings_type) {\n  DidBlockContentType(settings_type, base::string16());\n}\n\nvoid ContentSettingsObserver::DidBlockContentType(\n    const std::string& settings_type) {\n  DidBlockContentType(settings_type,\n      blink::WebStringToGURL(render_frame()->GetWebFrame()->\n          GetSecurityOrigin().ToString()).spec());\n}\n\nvoid ContentSettingsObserver::DidBlockContentType(\n    const std::string& settings_type,\n    const std::string& details) {\n  base::ListValue args;\n  args.AppendString(settings_type);\n  args.AppendString(details);\n\n  auto rf = render_frame();\n  rf->Send(new AtomViewHostMsg_Message(\n    rf->GetRoutingID(), base::UTF8ToUTF16(\"content-blocked\"), args));\n}\n\nbool ContentSettingsObserver::OnMessageReceived(const IPC::Message& message) {\n  // Don't swallow LoadBlockedPlugins messages, as they're sent to every\n  // blocked plugin.\n  IPC_BEGIN_MESSAGE_MAP(ContentSettingsObserver, message)\n    IPC_MESSAGE_HANDLER(ChromeViewMsg_LoadBlockedPlugins, OnLoadBlockedPlugins)\n  IPC_END_MESSAGE_MAP()\n\n  return false;\n}\n\nvoid ContentSettingsObserver::DidCommitProvisionalLoad(\n    bool is_new_navigation,\n    bool is_same_page_navigation) {\n  WebFrame* frame = render_frame()->GetWebFrame();\n  if (frame->Parent())\n    return;  // Not a top-level navigation.\n\n  if (!is_same_page_navigation) {\n    ClearBlockedContentSettings();\n    temporarily_allowed_plugins_.clear();\n  }\n}\n\nvoid ContentSettingsObserver::OnDestruct() {\n  delete this;\n}\n\nbool ContentSettingsObserver::AllowDatabase(const WebString& name,\n                                          const WebString& display_name,\n                                          unsigned estimated_size) {  // NOLINT\n  WebFrame* frame = render_frame()->GetWebFrame();\n  if (frame->GetSecurityOrigin().IsUnique() ||\n      frame->Top()->GetSecurityOrigin().IsUnique())\n    return false;\n\n  bool allow = true;\n  GURL secondary_url(\n      blink::WebStringToGURL(frame->GetSecurityOrigin().ToString()));\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(frame),\n          secondary_url,\n          \"cookies\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(\"database\", secondary_url.spec());\n  return allow;\n}\n\n\nvoid ContentSettingsObserver::RequestFileSystemAccessAsync(\n        const WebContentSettingCallbacks& callbacks) {\n  WebFrame* frame = render_frame()->GetWebFrame();\n  WebContentSettingCallbacks permissionCallbacks(callbacks);\n  if (frame->GetSecurityOrigin().IsUnique() ||\n      frame->Top()->GetSecurityOrigin().IsUnique()) {\n      permissionCallbacks.DoDeny();\n      return;\n  }\n\n  bool allow = true;\n  GURL secondary_url(\n      blink::WebStringToGURL(frame->GetSecurityOrigin().ToString()));\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(frame),\n          secondary_url,\n          \"cookies\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n  if (!allow) {\n      DidBlockContentType(\"filesystem\", secondary_url.spec());\n      permissionCallbacks.DoDeny();\n  } else {\n      permissionCallbacks.DoAllow();\n  }\n}\n\nbool ContentSettingsObserver::AllowImage(bool enabled_per_settings,\n                                         const WebURL& image_url) {\n  if (enabled_per_settings && IsWhitelistedForContentSettings())\n    return true;\n\n  bool allow = enabled_per_settings;\n  GURL secondary_url(image_url);\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(\n                render_frame()->GetWebFrame()),\n            secondary_url,\n            \"images\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(\"images\", secondary_url.spec());\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowIndexedDB(const WebString& name,\n                                             const WebSecurityOrigin& origin) {\n  WebFrame* frame = render_frame()->GetWebFrame();\n  if (frame->GetSecurityOrigin().IsUnique() ||\n      frame->Top()->GetSecurityOrigin().IsUnique())\n    return false;\n\n  bool allow = true;\n  GURL secondary_url(\n      blink::WebStringToGURL(frame->GetSecurityOrigin().ToString()));\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(frame),\n            secondary_url,\n            \"cookies\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(\"indexedDB\", secondary_url.spec());\n  return allow;\n}\n\nGURL GetOriginOrURL(const WebFrame* frame) {\n  url::Origin top_origin = url::Origin(frame->Top()->GetSecurityOrigin());\n  // The |top_origin| is unique (\"null\") e.g., for file:// URLs. Use the\n  // document URL as the primary URL in those cases.\n  // TODO(alexmos): This is broken for --site-per-process, since top() can be a\n  // WebRemoteFrame which does not have a document(), and the WebRemoteFrame's\n  // URL is not replicated.  See https://crbug.com/628759.\n  if (top_origin.unique() && frame->Top()->IsWebLocalFrame())\n    return frame->Top()->ToWebLocalFrame()->GetDocument().Url();\n  return top_origin.GetURL();\n}\n\n// Allow passing both WebURL and GURL here, so that we can early return without\n// allocating a new backing string if only the default rule matches.\ntemplate <typename URL>\nContentSetting GetContentSettingFromRules(\n    const ContentSettingsForOneType& rules,\n    const WebFrame* frame,\n    const URL& secondary_url) {\n  // If there is only one rule, it's the default rule and we don't need to match\n  // the patterns.\n  if (rules.size() == 1) {\n    DCHECK(rules[0].primary_pattern == ContentSettingsPattern::Wildcard());\n    DCHECK(rules[0].secondary_pattern == ContentSettingsPattern::Wildcard());\n    return rules[0].GetContentSetting();\n  }\n  const GURL& primary_url = GetOriginOrURL(frame);\n  const GURL& secondary_gurl = secondary_url;\n  for (const auto& rule : rules) {\n    if (rule.primary_pattern.Matches(primary_url) &&\n        rule.secondary_pattern.Matches(secondary_gurl)) {\n      return rule.GetContentSetting();\n    }\n  }\n  NOTREACHED();\n  return CONTENT_SETTING_DEFAULT;\n}\n\nbool IsScriptDisabledForPreview(const content::RenderFrame* render_frame) {\n  return render_frame->GetPreviewsState() & content::NOSCRIPT_ON;\n}\n\nbool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n\n  // Evaluate the content setting rules before\n  // IsWhitelistedForContentSettings(); if there is only the default rule\n  // allowing all scripts, it's quicker this way.\n  bool allow = true;\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),\n          url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL(),\n          \"javascript\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowScriptFromSource(\n    bool enabled_per_settings,\n    const blink::WebURL& script_url) {\n  if (IsWhitelistedForContentSettings())\n    return true;\n\n  bool allow = enabled_per_settings;\n  GURL secondary_url(script_url);\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),\n          secondary_url,\n          \"javascript\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  allow = allow || IsWhitelistedForContentSettings();\n  if (!allow)\n    DidBlockContentType(\"javascript\", secondary_url.spec());\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowStorage(bool local) {\n  if (IsWhitelistedForContentSettings())\n    return true;\n\n  WebFrame* frame = render_frame()->GetWebFrame();\n  if (frame->GetSecurityOrigin().IsUnique() ||\n      frame->Top()->GetSecurityOrigin().IsUnique())\n    return false;\n\n  StoragePermissionsKey key(\n      blink::WebStringToGURL(frame->ToWebLocalFrame()->GetDocument().GetSecurityOrigin().ToString()),\n      local);\n  std::map<StoragePermissionsKey, bool>::const_iterator permissions =\n      cached_storage_permissions_.find(key);\n  if (permissions != cached_storage_permissions_.end())\n    return permissions->second;\n\n  bool allow = true;\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(frame),\n          blink::WebStringToGURL(frame->GetSecurityOrigin().ToString()),\n          \"cookies\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  cached_storage_permissions_[key] = allow;\n  if (!allow)\n    DidBlockContentType(\"storage\");\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowReadFromClipboard(bool default_value) {\n  bool allowed = default_value;\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  extensions::ScriptContext* current_context =\n      extension_dispatcher_->script_context_set().GetCurrent();\n  if (current_context) {\n    allowed |= current_context->HasAPIPermission(\n        extensions::APIPermission::kClipboardRead);\n  }\n#endif\n  return allowed;\n}\n\nbool ContentSettingsObserver::AllowWriteToClipboard(bool default_value) {\n  bool allowed = default_value;\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // All blessed extension pages could historically write to the clipboard, so\n  // preserve that for compatibility.\n  extensions::ScriptContext* current_context =\n      extension_dispatcher_->script_context_set().GetCurrent();\n  if (current_context) {\n    if (current_context->effective_context_type() ==\n        extensions::Feature::BLESSED_EXTENSION_CONTEXT) {\n      allowed = true;\n    } else {\n      allowed |= current_context->HasAPIPermission(\n          extensions::APIPermission::kClipboardWrite);\n    }\n  }\n#endif\n  return allowed;\n}\n\nbool ContentSettingsObserver::AllowMutationEvents(bool default_value) {\n  if (IsWhitelistedForContentSettings())\n    return true;\n\n  bool allow = default_value;\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(\n                render_frame()->GetWebFrame()),\n            GURL(),\n            \"mutation\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(\"mutation\");\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowRunningInsecureContent(\n    bool allowed_per_settings,\n    const blink::WebSecurityOrigin& origin,\n    const blink::WebURL& resource_url) {\n  // TODO(bridiver) is origin different than web frame top origin?\n  bool allow = allowed_per_settings;\n  GURL secondary_url(resource_url);\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(\n                render_frame()->GetWebFrame()),\n            secondary_url,\n            \"runInsecureContent\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (allow)\n    DidRunInsecureContent(GURL(resource_url));\n  else\n    DidBlockRunInsecureContent(GURL(resource_url));\n  return allow;\n}\n\nbool ContentSettingsObserver::AllowAutoplay(bool default_value) {\n  bool allow = default_value;\n  if (content_settings_manager_->content_settings()) {\n    WebFrame* frame = render_frame()->GetWebFrame();\n    auto origin = frame->ToWebLocalFrame()->GetDocument().GetSecurityOrigin();\n    allow =\n        content_settings_manager_->GetSetting(\n            ContentSettingsManager::GetOriginOrURL(frame),\n            blink::WebStringToGURL(origin.ToString()),\n            \"autoplay\",\n            allow) != CONTENT_SETTING_BLOCK;\n  }\n\n  if (!allow)\n    DidBlockContentType(CONTENT_SETTINGS_TYPE_AUTOPLAY);\n  return allow;\n}\n\nvoid ContentSettingsObserver::DidNotAllowPlugins() {\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_PLUGINS);\n}\n\nvoid ContentSettingsObserver::DidNotAllowScript() {\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_JAVASCRIPT);\n}\n\nvoid ContentSettingsObserver::OnLoadBlockedPlugins(\n    const std::string& identifier) {\n  temporarily_allowed_plugins_.insert(identifier);\n}\n\nvoid ContentSettingsObserver::DidRunInsecureContent(GURL resouce_url) {\n  base::ListValue args;\n    args.AppendString(resouce_url.spec());\n\n    auto rf = render_frame();\n    rf->Send(new AtomViewHostMsg_Message(rf->GetRoutingID(),\n        base::UTF8ToUTF16(\"did-run-insecure-content\"), args));\n}\n\nvoid ContentSettingsObserver::DidBlockRunInsecureContent(GURL resouce_url) {\n  base::ListValue args;\n    args.AppendString(resouce_url.spec());\n\n    auto rf = render_frame();\n    rf->Send(new AtomViewHostMsg_Message(rf->GetRoutingID(),\n        base::UTF8ToUTF16(\"did-block-run-insecure-content\"), args));\n}\n\nvoid ContentSettingsObserver::ClearBlockedContentSettings() {\n  cached_storage_permissions_.clear();\n  cached_script_permissions_.clear();\n}\n\nbool ContentSettingsObserver::IsWhitelistedForContentSettings() const {\n  // Whitelist ftp directory listings, as they require JavaScript to function\n  // properly.\n  if (!render_frame()) {\n    return false;\n  }\n\n  if (render_frame()->IsFTPDirectoryListing())\n    return true;\n\n  WebFrame* web_frame = render_frame()->GetWebFrame();\n\n  if (!web_frame) {\n    return false;\n  }\n\n  return IsWhitelistedForContentSettings(\n      web_frame->ToWebLocalFrame()->GetDocument().GetSecurityOrigin(),\n      web_frame->ToWebLocalFrame()->GetDocument().Url());\n}\n\nbool ContentSettingsObserver::IsWhitelistedForContentSettings(\n    const WebSecurityOrigin& origin,\n    const GURL& document_url) {\n  if (document_url == GURL(content::kUnreachableWebDataURL))\n    return true;\n\n  if (origin.IsUnique())\n    return false;  // Uninitialized document?\n\n  base::string16 protocol = origin.Protocol().Utf16();\n  if (base::EqualsASCII(protocol, content::kChromeUIScheme))\n    return true;  // Browser UI elements should still work.\n\n  if (base::EqualsASCII(protocol, content::kChromeDevToolsScheme))\n    return true;  // DevTools UI elements should still work.\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  if (base::EqualsASCII(protocol, extensions::kExtensionScheme))\n    return true;\n#endif\n\n  // If the scheme is file:, an empty file name indicates a directory listing,\n  // which requires JavaScript to function properly.\n  if (base::EqualsASCII(protocol, url::kFileScheme)) {\n    return document_url.SchemeIs(url::kFileScheme) &&\n           document_url.ExtractFileName().empty();\n  }\n\n  return false;\n}\n"], "filenames": ["chromium_src/chrome/renderer/content_settings_observer.cc"], "buggy_code_start_loc": [435], "buggy_code_end_loc": [440], "fixing_code_start_loc": [435], "fixing_code_end_loc": [442], "type": "CWE-20", "message": "Brave Software Inc. Brave version version 0.22.810 to 0.24.0 contains a Other/Unknown vulnerability in function ContentSettingsObserver::AllowScript() in content_settings_observer.cc that can result in Websites can run inline JavaScript even if script is blocked, making attackers easier to track users. This attack appear to be exploitable via the victim must visit a specially crafted website. This vulnerability appears to have been fixed in 0.25.2.", "other": {"cve": {"id": "CVE-2018-1000815", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-20T15:29:00.547", "lastModified": "2019-02-06T14:36:31.330", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Brave Software Inc. Brave version version 0.22.810 to 0.24.0 contains a Other/Unknown vulnerability in function ContentSettingsObserver::AllowScript() in content_settings_observer.cc that can result in Websites can run inline JavaScript even if script is blocked, making attackers easier to track users. This attack appear to be exploitable via the victim must visit a specially crafted website. This vulnerability appears to have been fixed in 0.25.2."}, {"lang": "es", "value": "Brave, de Brave Software Inc., de la versi\u00f3n 0.22.810 a la 0.24.0, contiene una vulnerabilidad desconocida en la funci\u00f3n ContentSettingsObserver::AllowScript() en content_settings_observer.cc que puede resultar en que los sitios web puedan ejecutar JavaScript inline incluso aunque el script est\u00e9 bloqueado, haciendo que a los atacantes les resulte m\u00e1s f\u00e1cil rastrear usuarios. El ataque parece ser explotable si una v\u00edctima visita un sitio web especialmente manipulado. La vulnerabilidad parece haber sido solucionada en la versi\u00f3n 0.25.2."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:brave:brave:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.22.810", "versionEndIncluding": "0.24.0", "matchCriteriaId": "BBAA049C-DDEE-42A9-8CD0-881CA5A0DE17"}]}]}], "references": [{"url": "https://github.com/brave/browser-laptop/issues/15232", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/brave/muon/commit/c18663aa171c6cdf03da3e8c70df8663645b97c4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/brave/muon/pull/651", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/brave/muon/commit/c18663aa171c6cdf03da3e8c70df8663645b97c4"}}