{"buggy_code": ["package config\n\nimport \"github.com/spf13/viper\"\n\ntype attest struct {\n\tKey      string `yaml:\"key\" json:\"key\" mapstructure:\"key\"`\n\tPassword string `yaml:\"password\" json:\"password\" mapstructure:\"password\"`\n}\n\nfunc (cfg attest) loadDefaultValues(v *viper.Viper) {\n\tv.SetDefault(\"attest.key\", \"\")\n\tv.SetDefault(\"attest.password\", \"\")\n}\n", "package cli\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestPackagesCmdFlags(t *testing.T) {\n\thiddenPackagesImage := \"docker-archive:\" + getFixtureImage(t, \"image-hidden-packages\")\n\tcoverageImage := \"docker-archive:\" + getFixtureImage(t, \"image-pkg-coverage\")\n\tnodeBinaryImage := \"docker-archive:\" + getFixtureImage(t, \"image-node-binary\")\n\t//badBinariesImage := \"docker-archive:\" + getFixtureImage(t, \"image-bad-binaries\")\n\ttmp := t.TempDir() + \"/\"\n\n\ttests := []struct {\n\t\tname       string\n\t\targs       []string\n\t\tenv        map[string]string\n\t\tassertions []traitAssertion\n\t}{\n\t\t{\n\t\t\tname: \"no-args-shows-help\",\n\t\t\targs: []string{\"packages\"},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"an image/directory argument is required\"),              // specific error that should be shown\n\t\t\t\tassertInOutput(\"Generate a packaged-based Software Bill Of Materials\"), // excerpt from help description\n\t\t\t\tassertFailingReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"json-output-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertJsonReport,\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple-output-flags\",\n\t\t\targs: []string{\"packages\", \"-o\", \"table\", \"-o\", \"json=\" + tmp + \".tmp/multiple-output-flag-test.json\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertTableReport,\n\t\t\t\tassertFileExists(tmp + \".tmp/multiple-output-flag-test.json\"),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t// I haven't been able to reproduce locally yet, but in CI this has proven to be unstable:\n\t\t// For the same commit:\n\t\t//   pass: https://github.com/anchore/syft/runs/4611344142?check_suite_focus=true\n\t\t//   fail: https://github.com/anchore/syft/runs/4611343586?check_suite_focus=true\n\t\t// For the meantime this test will be commented out, but should be added back in as soon as possible.\n\t\t//\n\t\t//{\n\t\t//\tname: \"regression-survive-bad-binaries\",\n\t\t//\t// this image has all sorts of rich binaries from the clang-13 test suite that should do pretty bad things\n\t\t//\t// to the go cataloger binary path. We should NEVER let a panic stop the cataloging process for these\n\t\t//\t// specific cases.\n\t\t//\n\t\t//\t// this is more of an integration test, however, to assert the output we want to see from the application\n\t\t//\t// a CLI test is much easier.\n\t\t//\targs: []string{\"packages\", \"-vv\", badBinariesImage},\n\t\t//\tassertions: []traitAssertion{\n\t\t//\t\tassertInOutput(\"could not parse possible go binary\"),\n\t\t//\t\tassertSuccessfulReturnCode,\n\t\t//\t},\n\t\t//},\n\t\t{\n\t\t\tname: \"output-env-binding\",\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_OUTPUT\": \"json\",\n\t\t\t},\n\t\t\targs: []string{\"packages\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertJsonReport,\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"table-output-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"table\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertTableReport,\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"default-output-flag\",\n\t\t\targs: []string{\"packages\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertTableReport,\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"squashed-scope-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"-s\", \"squashed\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(34),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"squashed-scope-flag-hidden-packages\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"-s\", \"squashed\", hiddenPackagesImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(163),\n\t\t\t\tassertNotInOutput(\"vsftpd\"), // hidden package\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"all-layers-scope-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"-s\", \"all-layers\", hiddenPackagesImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(164), // packages are now deduplicated for this case\n\t\t\t\tassertInOutput(\"all-layers\"),\n\t\t\t\tassertInOutput(\"vsftpd\"), // hidden package\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"all-layers-scope-flag-by-env\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", hiddenPackagesImage},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_PACKAGE_CATALOGER_SCOPE\": \"all-layers\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(164), // packages are now deduplicated for this case\n\t\t\t\tassertInOutput(\"all-layers\"),\n\t\t\t\tassertInOutput(\"vsftpd\"), // hidden package\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// we want to make certain that syft can catalog a single go binary and get a SBOM report that is not empty\n\t\t\tname: \"catalog-single-go-binary\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", getSyftBinaryLocation(t)},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertJsonReport,\n\t\t\t\tassertStdoutLengthGreaterThan(1000),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"catalog-node-js-binary\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", nodeBinaryImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertJsonReport,\n\t\t\t\tassertInOutput(\"node.js\"),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"responds-to-package-cataloger-search-options\",\n\t\t\targs: []string{\"packages\", \"-vv\"},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_PACKAGE_SEARCH_UNINDEXED_ARCHIVES\": \"true\",\n\t\t\t\t\"SYFT_PACKAGE_SEARCH_INDEXED_ARCHIVES\":   \"false\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\t// the application config in the log matches that of what we expect to have been configured. Note:\n\t\t\t\t// we are not testing further wiring of this option, only that the config responds to\n\t\t\t\t// package-cataloger-level options.\n\t\t\t\tassertInOutput(\"search-unindexed-archives: true\"),\n\t\t\t\tassertInOutput(\"search-indexed-archives: false\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"platform-option-wired-up\",\n\t\t\targs: []string{\"packages\", \"--platform\", \"arm64\", \"-o\", \"json\", \"registry:busybox:1.31\"},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"sha256:1ee006886991ad4689838d3a288e0dd3fd29b70e276622f16b67a8922831a853\"), // linux/arm64 image digest\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"json-file-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"--file\", filepath.Join(tmp, \"output-1.json\"), coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t\tassertFileOutput(t, filepath.Join(tmp, \"output-1.json\"),\n\t\t\t\t\tassertJsonReport,\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"json-output-flag-to-file\",\n\t\t\targs: []string{\"packages\", \"-o\", fmt.Sprintf(\"json=%s\", filepath.Join(tmp, \"output-2.json\")), coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t\tassertFileOutput(t, filepath.Join(tmp, \"output-2.json\"),\n\t\t\t\t\tassertJsonReport,\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"catalogers-option\",\n\t\t\t// This will detect enable python-index-cataloger, python-package-cataloger and ruby-gemspec cataloger\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"--catalogers\", \"python,ruby-gemspec\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(13),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"override-default-parallelism\",\n\t\t\targs: []string{\"packages\", \"-vvv\", \"-o\", \"json\", coverageImage},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_PARALLELISM\": \"2\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\t// the application config in the log matches that of what we expect to have been configured.\n\t\t\t\tassertInOutput(\"parallelism: 2\"),\n\t\t\t\tassertInOutput(\"parallelism=2\"),\n\t\t\t\tassertPackageCount(34),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"default-parallelism\",\n\t\t\targs: []string{\"packages\", \"-vvv\", \"-o\", \"json\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\t// the application config in the log matches that of what we expect to have been configured.\n\t\t\t\tassertInOutput(\"parallelism: 1\"),\n\t\t\t\tassertInOutput(\"parallelism=1\"),\n\t\t\t\tassertPackageCount(34),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd, stdout, stderr := runSyft(t, test.env, test.args...)\n\t\t\tfor _, traitFn := range test.assertions {\n\t\t\t\ttraitFn(t, stdout, stderr, cmd.ProcessState.ExitCode())\n\t\t\t}\n\t\t\tif t.Failed() {\n\t\t\t\tt.Log(\"STDOUT:\\n\", stdout)\n\t\t\t\tt.Log(\"STDERR:\\n\", stderr)\n\t\t\t\tt.Log(\"COMMAND:\", strings.Join(cmd.Args, \" \"))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRegistryAuth(t *testing.T) {\n\thost := \"localhost:17\"\n\timage := fmt.Sprintf(\"%s/something:latest\", host)\n\targs := []string{\"packages\", \"-vv\", fmt.Sprintf(\"registry:%s\", image)}\n\n\ttests := []struct {\n\t\tname       string\n\t\targs       []string\n\t\tenv        map[string]string\n\t\tassertions []traitAssertion\n\t}{\n\t\t{\n\t\t\tname: \"fallback to keychain\",\n\t\t\targs: args,\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"source=OciRegistry\"),\n\t\t\t\tassertInOutput(image),\n\t\t\t\tassertInOutput(\"no registry credentials configured, using the default keychain\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"use creds\",\n\t\t\targs: args,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_REGISTRY_AUTH_AUTHORITY\": host,\n\t\t\t\t\"SYFT_REGISTRY_AUTH_USERNAME\":  \"username\",\n\t\t\t\t\"SYFT_REGISTRY_AUTH_PASSWORD\":  \"password\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"source=OciRegistry\"),\n\t\t\t\tassertInOutput(image),\n\t\t\t\tassertInOutput(fmt.Sprintf(`using basic auth for registry \"%s\"`, host)),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"use token\",\n\t\t\targs: args,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_REGISTRY_AUTH_AUTHORITY\": host,\n\t\t\t\t\"SYFT_REGISTRY_AUTH_TOKEN\":     \"token\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"source=OciRegistry\"),\n\t\t\t\tassertInOutput(image),\n\t\t\t\tassertInOutput(fmt.Sprintf(`using token for registry \"%s\"`, host)),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"not enough info fallsback to keychain\",\n\t\t\targs: args,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_REGISTRY_AUTH_AUTHORITY\": host,\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"source=OciRegistry\"),\n\t\t\t\tassertInOutput(image),\n\t\t\t\tassertInOutput(`no registry credentials configured, using the default keychain`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"allows insecure http flag\",\n\t\t\targs: args,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_REGISTRY_INSECURE_USE_HTTP\": \"true\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"insecure-use-http: true\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd, stdout, stderr := runSyft(t, test.env, test.args...)\n\t\t\tfor _, traitAssertionFn := range test.assertions {\n\t\t\t\ttraitAssertionFn(t, stdout, stderr, cmd.ProcessState.ExitCode())\n\t\t\t}\n\t\t\tif t.Failed() {\n\t\t\t\tt.Log(\"STDOUT:\\n\", stdout)\n\t\t\t\tt.Log(\"STDERR:\\n\", stderr)\n\t\t\t\tt.Log(\"COMMAND:\", strings.Join(cmd.Args, \" \"))\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["package config\n\nimport \"github.com/spf13/viper\"\n\ntype attest struct {\n\t// IMPORTANT: do not show the attestation key/password in any YAML/JSON output (sensitive information)\n\tKey      string `yaml:\"-\" json:\"-\" mapstructure:\"key\"`\n\tPassword string `yaml:\"-\" json:\"-\" mapstructure:\"password\"`\n}\n\nfunc (cfg attest) loadDefaultValues(v *viper.Viper) {\n\tv.SetDefault(\"attest.key\", \"\")\n\tv.SetDefault(\"attest.password\", \"\")\n}\n", "package cli\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestPackagesCmdFlags(t *testing.T) {\n\thiddenPackagesImage := \"docker-archive:\" + getFixtureImage(t, \"image-hidden-packages\")\n\tcoverageImage := \"docker-archive:\" + getFixtureImage(t, \"image-pkg-coverage\")\n\tnodeBinaryImage := \"docker-archive:\" + getFixtureImage(t, \"image-node-binary\")\n\t//badBinariesImage := \"docker-archive:\" + getFixtureImage(t, \"image-bad-binaries\")\n\ttmp := t.TempDir() + \"/\"\n\n\ttests := []struct {\n\t\tname       string\n\t\targs       []string\n\t\tenv        map[string]string\n\t\tassertions []traitAssertion\n\t}{\n\t\t{\n\t\t\tname: \"no-args-shows-help\",\n\t\t\targs: []string{\"packages\"},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"an image/directory argument is required\"),              // specific error that should be shown\n\t\t\t\tassertInOutput(\"Generate a packaged-based Software Bill Of Materials\"), // excerpt from help description\n\t\t\t\tassertFailingReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"json-output-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertJsonReport,\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple-output-flags\",\n\t\t\targs: []string{\"packages\", \"-o\", \"table\", \"-o\", \"json=\" + tmp + \".tmp/multiple-output-flag-test.json\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertTableReport,\n\t\t\t\tassertFileExists(tmp + \".tmp/multiple-output-flag-test.json\"),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t// I haven't been able to reproduce locally yet, but in CI this has proven to be unstable:\n\t\t// For the same commit:\n\t\t//   pass: https://github.com/anchore/syft/runs/4611344142?check_suite_focus=true\n\t\t//   fail: https://github.com/anchore/syft/runs/4611343586?check_suite_focus=true\n\t\t// For the meantime this test will be commented out, but should be added back in as soon as possible.\n\t\t//\n\t\t//{\n\t\t//\tname: \"regression-survive-bad-binaries\",\n\t\t//\t// this image has all sorts of rich binaries from the clang-13 test suite that should do pretty bad things\n\t\t//\t// to the go cataloger binary path. We should NEVER let a panic stop the cataloging process for these\n\t\t//\t// specific cases.\n\t\t//\n\t\t//\t// this is more of an integration test, however, to assert the output we want to see from the application\n\t\t//\t// a CLI test is much easier.\n\t\t//\targs: []string{\"packages\", \"-vv\", badBinariesImage},\n\t\t//\tassertions: []traitAssertion{\n\t\t//\t\tassertInOutput(\"could not parse possible go binary\"),\n\t\t//\t\tassertSuccessfulReturnCode,\n\t\t//\t},\n\t\t//},\n\t\t{\n\t\t\tname: \"output-env-binding\",\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_OUTPUT\": \"json\",\n\t\t\t},\n\t\t\targs: []string{\"packages\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertJsonReport,\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"table-output-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"table\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertTableReport,\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"default-output-flag\",\n\t\t\targs: []string{\"packages\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertTableReport,\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"squashed-scope-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"-s\", \"squashed\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(34),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"squashed-scope-flag-hidden-packages\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"-s\", \"squashed\", hiddenPackagesImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(163),\n\t\t\t\tassertNotInOutput(\"vsftpd\"), // hidden package\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"all-layers-scope-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"-s\", \"all-layers\", hiddenPackagesImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(164), // packages are now deduplicated for this case\n\t\t\t\tassertInOutput(\"all-layers\"),\n\t\t\t\tassertInOutput(\"vsftpd\"), // hidden package\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"all-layers-scope-flag-by-env\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", hiddenPackagesImage},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_PACKAGE_CATALOGER_SCOPE\": \"all-layers\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(164), // packages are now deduplicated for this case\n\t\t\t\tassertInOutput(\"all-layers\"),\n\t\t\t\tassertInOutput(\"vsftpd\"), // hidden package\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// we want to make certain that syft can catalog a single go binary and get a SBOM report that is not empty\n\t\t\tname: \"catalog-single-go-binary\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", getSyftBinaryLocation(t)},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertJsonReport,\n\t\t\t\tassertStdoutLengthGreaterThan(1000),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"catalog-node-js-binary\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", nodeBinaryImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertJsonReport,\n\t\t\t\tassertInOutput(\"node.js\"),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"responds-to-package-cataloger-search-options\",\n\t\t\targs: []string{\"packages\", \"-vv\"},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_PACKAGE_SEARCH_UNINDEXED_ARCHIVES\": \"true\",\n\t\t\t\t\"SYFT_PACKAGE_SEARCH_INDEXED_ARCHIVES\":   \"false\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\t// the application config in the log matches that of what we expect to have been configured. Note:\n\t\t\t\t// we are not testing further wiring of this option, only that the config responds to\n\t\t\t\t// package-cataloger-level options.\n\t\t\t\tassertInOutput(\"search-unindexed-archives: true\"),\n\t\t\t\tassertInOutput(\"search-indexed-archives: false\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"platform-option-wired-up\",\n\t\t\targs: []string{\"packages\", \"--platform\", \"arm64\", \"-o\", \"json\", \"registry:busybox:1.31\"},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"sha256:1ee006886991ad4689838d3a288e0dd3fd29b70e276622f16b67a8922831a853\"), // linux/arm64 image digest\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"json-file-flag\",\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"--file\", filepath.Join(tmp, \"output-1.json\"), coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t\tassertFileOutput(t, filepath.Join(tmp, \"output-1.json\"),\n\t\t\t\t\tassertJsonReport,\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"json-output-flag-to-file\",\n\t\t\targs: []string{\"packages\", \"-o\", fmt.Sprintf(\"json=%s\", filepath.Join(tmp, \"output-2.json\")), coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t\tassertFileOutput(t, filepath.Join(tmp, \"output-2.json\"),\n\t\t\t\t\tassertJsonReport,\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"catalogers-option\",\n\t\t\t// This will detect enable python-index-cataloger, python-package-cataloger and ruby-gemspec cataloger\n\t\t\targs: []string{\"packages\", \"-o\", \"json\", \"--catalogers\", \"python,ruby-gemspec\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertPackageCount(13),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"override-default-parallelism\",\n\t\t\targs: []string{\"packages\", \"-vvv\", \"-o\", \"json\", coverageImage},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_PARALLELISM\": \"2\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\t// the application config in the log matches that of what we expect to have been configured.\n\t\t\t\tassertInOutput(\"parallelism: 2\"),\n\t\t\t\tassertInOutput(\"parallelism=2\"),\n\t\t\t\tassertPackageCount(34),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"default-parallelism\",\n\t\t\targs: []string{\"packages\", \"-vvv\", \"-o\", \"json\", coverageImage},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\t// the application config in the log matches that of what we expect to have been configured.\n\t\t\t\tassertInOutput(\"parallelism: 1\"),\n\t\t\t\tassertInOutput(\"parallelism=1\"),\n\t\t\t\tassertPackageCount(34),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"password and key not in config output\",\n\t\t\targs: []string{\"packages\", \"-vvv\", \"-o\", \"json\", coverageImage},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_ATTEST_PASSWORD\": \"secret_password\",\n\t\t\t\t\"SYFT_ATTEST_KEY\":      \"secret_key_path\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertNotInOutput(\"secret_password\"),\n\t\t\t\tassertNotInOutput(\"secret_key_path\"),\n\t\t\t\tassertPackageCount(34),\n\t\t\t\tassertSuccessfulReturnCode,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd, stdout, stderr := runSyft(t, test.env, test.args...)\n\t\t\tfor _, traitFn := range test.assertions {\n\t\t\t\ttraitFn(t, stdout, stderr, cmd.ProcessState.ExitCode())\n\t\t\t}\n\t\t\tif t.Failed() {\n\t\t\t\tt.Log(\"STDOUT:\\n\", stdout)\n\t\t\t\tt.Log(\"STDERR:\\n\", stderr)\n\t\t\t\tt.Log(\"COMMAND:\", strings.Join(cmd.Args, \" \"))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRegistryAuth(t *testing.T) {\n\thost := \"localhost:17\"\n\timage := fmt.Sprintf(\"%s/something:latest\", host)\n\targs := []string{\"packages\", \"-vv\", fmt.Sprintf(\"registry:%s\", image)}\n\n\ttests := []struct {\n\t\tname       string\n\t\targs       []string\n\t\tenv        map[string]string\n\t\tassertions []traitAssertion\n\t}{\n\t\t{\n\t\t\tname: \"fallback to keychain\",\n\t\t\targs: args,\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"source=OciRegistry\"),\n\t\t\t\tassertInOutput(image),\n\t\t\t\tassertInOutput(\"no registry credentials configured, using the default keychain\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"use creds\",\n\t\t\targs: args,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_REGISTRY_AUTH_AUTHORITY\": host,\n\t\t\t\t\"SYFT_REGISTRY_AUTH_USERNAME\":  \"username\",\n\t\t\t\t\"SYFT_REGISTRY_AUTH_PASSWORD\":  \"password\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"source=OciRegistry\"),\n\t\t\t\tassertInOutput(image),\n\t\t\t\tassertInOutput(fmt.Sprintf(`using basic auth for registry \"%s\"`, host)),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"use token\",\n\t\t\targs: args,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_REGISTRY_AUTH_AUTHORITY\": host,\n\t\t\t\t\"SYFT_REGISTRY_AUTH_TOKEN\":     \"token\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"source=OciRegistry\"),\n\t\t\t\tassertInOutput(image),\n\t\t\t\tassertInOutput(fmt.Sprintf(`using token for registry \"%s\"`, host)),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"not enough info fallsback to keychain\",\n\t\t\targs: args,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_REGISTRY_AUTH_AUTHORITY\": host,\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"source=OciRegistry\"),\n\t\t\t\tassertInOutput(image),\n\t\t\t\tassertInOutput(`no registry credentials configured, using the default keychain`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"allows insecure http flag\",\n\t\t\targs: args,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"SYFT_REGISTRY_INSECURE_USE_HTTP\": \"true\",\n\t\t\t},\n\t\t\tassertions: []traitAssertion{\n\t\t\t\tassertInOutput(\"insecure-use-http: true\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd, stdout, stderr := runSyft(t, test.env, test.args...)\n\t\t\tfor _, traitAssertionFn := range test.assertions {\n\t\t\t\ttraitAssertionFn(t, stdout, stderr, cmd.ProcessState.ExitCode())\n\t\t\t}\n\t\t\tif t.Failed() {\n\t\t\t\tt.Log(\"STDOUT:\\n\", stdout)\n\t\t\t\tt.Log(\"STDERR:\\n\", stderr)\n\t\t\t\tt.Log(\"COMMAND:\", strings.Join(cmd.Args, \" \"))\n\t\t\t}\n\t\t})\n\t}\n}\n"], "filenames": ["internal/config/attest.go", "test/cli/packages_cmd_test.go"], "buggy_code_start_loc": [6, 231], "buggy_code_end_loc": [8, 231], "fixing_code_start_loc": [6, 232], "fixing_code_end_loc": [9, 246], "type": "CWE-532", "message": "syft is a a CLI tool and Go library for generating a Software Bill of Materials (SBOM) from container images and filesystems. A password disclosure flaw was found in Syft versions v0.69.0 and v0.69.1. This flaw leaks the password stored in the SYFT_ATTEST_PASSWORD environment variable. The `SYFT_ATTEST_PASSWORD` environment variable is for the `syft attest` command to generate attested SBOMs for the given container image. This environment variable is used to decrypt the private key (provided with `syft attest --key <path-to-key-file>`) during the signing process while generating an SBOM attestation. This vulnerability affects users running syft that have the `SYFT_ATTEST_PASSWORD` environment variable set with credentials (regardless of if the attest command is being used or not). Users that do not have the environment variable `SYFT_ATTEST_PASSWORD` set are not affected by this issue. The credentials are leaked in two ways: in the syft logs when `-vv` or `-vvv` are used in the syft command (which is any log level >= `DEBUG`) and in the attestation or SBOM only when the `syft-json` format is used. Note that as of v0.69.0 any generated attestations by the `syft attest` command are uploaded to the OCI registry (if you have write access to that registry) in the same way `cosign attach` is done. This means that any attestations generated for the affected versions of syft when the `SYFT_ATTEST_PASSWORD` environment variable was set would leak credentials in the attestation payload uploaded to the OCI registry. This issue has been patched in commit `9995950c70` and has been released as v0.70.0. There are no workarounds for this vulnerability. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2023-24827", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-07T01:15:09.660", "lastModified": "2023-04-14T18:53:36.360", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "syft is a a CLI tool and Go library for generating a Software Bill of Materials (SBOM) from container images and filesystems. A password disclosure flaw was found in Syft versions v0.69.0 and v0.69.1. This flaw leaks the password stored in the SYFT_ATTEST_PASSWORD environment variable. The `SYFT_ATTEST_PASSWORD` environment variable is for the `syft attest` command to generate attested SBOMs for the given container image. This environment variable is used to decrypt the private key (provided with `syft attest --key <path-to-key-file>`) during the signing process while generating an SBOM attestation. This vulnerability affects users running syft that have the `SYFT_ATTEST_PASSWORD` environment variable set with credentials (regardless of if the attest command is being used or not). Users that do not have the environment variable `SYFT_ATTEST_PASSWORD` set are not affected by this issue. The credentials are leaked in two ways: in the syft logs when `-vv` or `-vvv` are used in the syft command (which is any log level >= `DEBUG`) and in the attestation or SBOM only when the `syft-json` format is used. Note that as of v0.69.0 any generated attestations by the `syft attest` command are uploaded to the OCI registry (if you have write access to that registry) in the same way `cosign attach` is done. This means that any attestations generated for the affected versions of syft when the `SYFT_ATTEST_PASSWORD` environment variable was set would leak credentials in the attestation payload uploaded to the OCI registry. This issue has been patched in commit `9995950c70` and has been released as v0.70.0. There are no workarounds for this vulnerability. Users are advised to upgrade."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:anchore:syft:0.69.0:*:*:*:*:*:*:*", "matchCriteriaId": "6FF5D298-D6A2-4D2A-B6B4-B544F7B0CAE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:anchore:syft:0.69.1:*:*:*:*:*:*:*", "matchCriteriaId": "1588A629-B860-4DDF-95C2-9CBE56E86FE8"}]}]}], "references": [{"url": "https://github.com/anchore/syft/commit/9995950c70e849f9921919faffbfcf46401f71f3", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/anchore/syft/security/advisories/GHSA-jp7v-3587-2956", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/anchore/syft/commit/9995950c70e849f9921919faffbfcf46401f71f3"}}