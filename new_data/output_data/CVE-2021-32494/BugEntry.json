{"buggy_code": ["/* radare - LGPL - Copyright 2009-2019 - pancake */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_core.h>\n#include \"../i/private.h\"\n#include \"mach0/mach0.h\"\n#include \"objc/mach0_classes.h\"\n#include <ht_uu.h>\n\n// wip settings\n\nextern RBinWrite r_bin_write_mach0;\n\nstatic RBinInfo *info(RBinFile *bf);\n\nstatic void swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io);\nstatic int rebasing_and_stripping_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count);\nstatic void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count);\n\n#define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)\n#define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)\n\nstatic Sdb *get_sdb (RBinFile *bf) {\n\tRBinObject *o = bf->o;\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tstruct MACH0_(obj_t) *bin = (struct MACH0_(obj_t) *) o->bin_obj;\n\treturn bin? bin->kv: NULL;\n}\n\nstatic char *entitlements(RBinFile *bf, bool json) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tif (json) {\n\t\tconst char *s = r_str_get ((const char *)bin->signature);\n\t\tPJ *pj = pj_new ();\n\t\tpj_s (pj, s);\n\t\treturn pj_drain (pj);\n\t}\n\treturn r_str_dup (NULL, (const char*)bin->signature);\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb){\n\tr_return_val_if_fail (bf && bin_obj && buf, false);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *res = MACH0_(new_buf) (buf, &opts);\n\tif (res) {\n\t\tif (res->chained_starts) {\n\t\t\tRIO *io = bf->rbin->iob.io;\n\t\t\tswizzle_io_read (res, io);\n\t\t}\n\t\tsdb_ns_set (sdb, \"info\", res->kv);\n\t\t*bin_obj = res;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void destroy(RBinFile *bf) {\n\tMACH0_(mach0_free) (bf->o->bin_obj);\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, UT64_MAX);\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\treturn MACH0_(get_baddr)(bin);\n}\n\nstatic RList *sections(RBinFile *bf) {\n\treturn MACH0_(get_segments) (bf);\n}\n\nstatic RBinAddr *newEntry(ut64 hpaddr, ut64 paddr, int type, int bits) {\n\tRBinAddr *ptr = R_NEW0 (RBinAddr);\n\tif (ptr) {\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = paddr;\n\t\tptr->hpaddr = hpaddr;\n\t\tptr->bits = bits;\n\t\tptr->type = type;\n\t\t//realign due to thumb\n\t\tif (bits == 16 && ptr->vaddr & 1) {\n\t\t\tptr->paddr--;\n\t\t\tptr->vaddr--;\n\t\t}\n\t}\n\treturn ptr;\n}\n\nstatic void process_constructors(RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (strstr (sec->name, \"_mod_fini_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (sec->name, \"_mod_init_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_INIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint read = r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (read < sec->size) {\n\t\t\t\teprintf (\"process_constructors: cannot process section %s\\n\", sec->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; i + 3 < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\tif (ba) {\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i + 7 < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\tif (ba) {\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\n\tRBinAddr *ptr = NULL;\n\tstruct addr_t *entry = NULL;\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tint bits = MACH0_(get_bits) (bf->o->bin_obj);\n\tif (!(entry = MACH0_(get_entrypoint) (bf->o->bin_obj))) {\n\t\treturn ret;\n\t}\n\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\tptr->paddr = entry->offset + bf->o->boffset;\n\t\tptr->vaddr = entry->addr;\n\t\tptr->hpaddr = entry->haddr;\n\t\tptr->bits = bits;\n\t\t//realign due to thumb\n\t\tif (bits == 16) {\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t\tptr->vaddr--;\n\t\t\t}\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\n\tprocess_constructors (bf, ret, bits);\n\t// constructors\n\tfree (entry);\n\treturn ret;\n}\n\nstatic void _handle_arm_thumb(struct MACH0_(obj_t) *bin, RBinSymbol **p) {\n\tRBinSymbol *ptr = *p;\n\tif (bin) {\n\t\tif (ptr->paddr & 1) {\n\t\t\tptr->paddr--;\n\t\t\tptr->vaddr--;\n\t\t\tptr->bits = 16;\n\t\t}\n\t}\n}\n\n#if FEATURE_SYMLIST\nstatic RList *symbols(RBinFile *bf) {\n\tRBinObject *obj = bf? bf->o: NULL;\n\treturn (RList *)MACH0_(get_symbols_list) (obj->bin_obj);\n}\n#else\nstatic RList *symbols(RBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin;\n\tint i;\n\tconst struct symbol_t *syms = NULL;\n\tRBinSymbol *ptr = NULL;\n\tRBinObject *obj = bf? bf->o: NULL;\n\tRList *ret = r_list_newf (free);\n#if 0\n\tconst char *lang = \"c\"; // XXX deprecate this\n#endif\n\tint wordsize = 0;\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (!obj || !obj->bin_obj) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tbool isStripped = false;\n\twordsize = MACH0_(get_bits) (obj->bin_obj);\n\n\t// OLD CODE\n\tif (!(syms = MACH0_(get_symbols) (obj->bin_obj))) {\n\t\treturn ret;\n\t}\n\tSdb *symcache = sdb_new0 ();\n\tbin = (struct MACH0_(obj_t) *) obj->bin_obj;\n\tfor (i = 0; !syms[i].last; i++) {\n\t\tif (syms[i].name == NULL || syms[i].name[0] == '\\0' || syms[i].addr < 100) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup ((char*)syms[i].name);\n\t\tptr->is_imported = syms[i].is_imported;\n\t\tif (ptr->name[0] == '_' && !ptr->is_imported) {\n\t\t\tchar *dn = r_bin_demangle (bf, ptr->name, ptr->name, ptr->vaddr, false);\n\t\t\tif (dn) {\n\t\t\t\tptr->dname = dn;\n\t\t\t\tchar *p = strchr (dn, '.');\n\t\t\t\tif (p) {\n\t\t\t\t\tif (IS_UPPER (ptr->name[0])) {\n\t\t\t\t\t\tptr->classname = strdup (ptr->name);\n\t\t\t\t\t\tptr->classname[p - ptr->name] = 0;\n\t\t\t\t\t} else if (IS_UPPER (p[1])) {\n\t\t\t\t\t\tptr->classname = strdup (p + 1);\n\t\t\t\t\t\tp = strchr (ptr->classname, '.');\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr->forwarder = \"NONE\";\n\t\tptr->bind = (syms[i].type == R_BIN_MACH0_SYMBOL_TYPE_LOCAL)? R_BIN_BIND_LOCAL_STR: R_BIN_BIND_GLOBAL_STR;\n\t\tptr->type = R_BIN_TYPE_FUNC_STR;\n\t\tptr->vaddr = syms[i].addr;\n\t\tptr->paddr = syms[i].offset + obj->boffset;\n\t\tptr->size = syms[i].size;\n\t\tptr->bits = syms[i].bits;\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && wordsize < 64) {\n\t\t\t_handle_arm_thumb (bin, &ptr);\n\t\t}\n\t\tptr->ordinal = i;\n\t\tbin->dbg_info = strncmp (ptr->name, \"radr://\", 7)? 0: 1;\n\t\tsdb_set (symcache, sdb_fmt (\"sym0x%\"PFMT64x, ptr->vaddr), \"found\", 0);\n#if 0\n\t\tif (!strncmp (ptr->name, \"__Z\", 3)) {\n\t\t\tlang = \"c++\";\n\t\t}\n\t\tif (!strncmp (ptr->name, \"type.\", 5)) {\n\t\t\tlang = \"go\";\n\t\t} else if (!strcmp (ptr->name, \"_rust_oom\")) {\n\t\t\tlang = \"rust\";\n\t\t}\n#endif\n\t\tr_list_append (ret, ptr);\n\t}\n\t//functions from LC_FUNCTION_STARTS\n\tif (bin->func_start) {\n\t\tchar symstr[128];\n\t\tut64 value = 0, address = 0;\n\t\tconst ut8 *temp = bin->func_start;\n\t\tconst ut8 *temp_end = bin->func_start + bin->func_size;\n\t\tstrcpy (symstr, \"sym0x\");\n\t\twhile (temp + 3 < temp_end && *temp) {\n\t\t\ttemp = r_uleb128_decode (temp, NULL, &value);\n\t\t\taddress += value;\n\t\t\tptr = R_NEW0 (RBinSymbol);\n\t\t\tif (!ptr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr->vaddr = bin->baddr + address;\n\t\t\tptr->paddr = address;\n\t\t\tptr->size = 0;\n\t\t\tptr->name = r_str_newf (\"func.%08\"PFMT64x, ptr->vaddr);\n\t\t\tptr->type = R_BIN_TYPE_FUNC_STR;\n\t\t\tptr->forwarder = \"NONE\";\n\t\t\tptr->bind = R_BIN_BIND_LOCAL_STR;\n\t\t\tptr->ordinal = i++;\n\t\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && wordsize < 64) {\n\t\t\t\t_handle_arm_thumb (bin, &ptr);\n\t\t\t}\n\t\t\tr_list_append (ret, ptr);\n\t\t\t// if any func is not found in syms then we can consider it is stripped\n\t\t\tif (!isStripped) {\n\t\t\t\tsnprintf (symstr + 5, sizeof (symstr) - 5 , \"%\" PFMT64x, ptr->vaddr);\n\t\t\t\tif (!sdb_const_get (symcache, symstr, 0)) {\n\t\t\t\t\tisStripped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#if 0\n// this must be done in bobj.c not here\n\tif (bin->has_blocks_ext) {\n\t\tlang = !strcmp (lang, \"c++\") ? \"c++ blocks ext.\" : \"c blocks ext.\";\n\t}\n\tbin->lang = lang;\n#endif\n\tif (isStripped) {\n\t\tbin->dbg_info |= R_BIN_DBG_STRIPPED;\n\t}\n\tsdb_free (symcache);\n\treturn ret;\n}\n#endif // FEATURE_SYMLIST\n\nstatic RBinImport *import_from_name(RBin *rbin, const char *orig_name, HtPP *imports_by_name) {\n\tif (imports_by_name) {\n\t\tbool found = false;\n\t\tRBinImport *ptr = ht_pp_find (imports_by_name, orig_name, &found);\n\t\tif (found) {\n\t\t\treturn ptr;\n\t\t}\n\t}\n\n\tRBinImport *ptr = NULL;\n\tif (!(ptr = R_NEW0 (RBinImport))) {\n\t\treturn NULL;\n\t}\n\n\tchar *name = (char*) orig_name;\n\tconst char *_objc_class = \"_OBJC_CLASS_$\";\n\tconst int _objc_class_len = strlen (_objc_class);\n\tconst char *_objc_metaclass = \"_OBJC_METACLASS_$\";\n\tconst int _objc_metaclass_len = strlen (_objc_metaclass);\n\tchar *type = \"FUNC\";\n\n\tif (!strncmp (name, _objc_class, _objc_class_len)) {\n\t\tname += _objc_class_len;\n\t\ttype = \"OBJC_CLASS\";\n\t} else if (!strncmp (name, _objc_metaclass, _objc_metaclass_len)) {\n\t\tname += _objc_metaclass_len;\n\t\ttype = \"OBJC_METACLASS\";\n\t}\n\n\t// Remove the extra underscore that every import seems to have in Mach-O.\n\tif (*name == '_') {\n\t\tname++;\n\t}\n\tptr->name = strdup (name);\n\tptr->bind = \"NONE\";\n\tptr->type = r_str_constpool_get (&rbin->constpool, type);\n\n\tif (imports_by_name) {\n\t\tht_pp_insert (imports_by_name, orig_name, ptr);\n\t}\n\n\treturn ptr;\n}\n\nstatic RList *imports(RBinFile *bf) {\n\tRBinObject *obj = bf ? bf->o : NULL;\n\tstruct MACH0_(obj_t) *bin = bf ? bf->o->bin_obj : NULL;\n\tconst char *name;\n\tRBinImport *ptr = NULL;\n\tint i;\n\n\tif (!obj || !bin || !obj->bin_obj) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_newf((RListFree)r_bin_import_free);\n\tstruct import_t *imports = MACH0_(get_imports)(bf->o->bin_obj);\n\tif (!ret || !imports) {\n\t\tr_list_free (ret);\n\t\tfree (imports);\n\t\treturn NULL;\n\t}\n\tbin->has_canary = false;\n\tbin->has_retguard = -1;\n\tbin->has_sanitizers = false;\n\tbin->has_blocks_ext = false;\n\tfor (i = 0; !imports[i].last; i++) {\n\t\tif (!(ptr = import_from_name (bf->rbin, imports[i].name, NULL))) {\n\t\t\tbreak;\n\t\t}\n\t\tname = ptr->name;\n\t\tptr->ordinal = imports[i].ord;\n\t\tif (bin->imports_by_ord && ptr->ordinal < bin->imports_by_ord_size) {\n\t\t\tbin->imports_by_ord[ptr->ordinal] = ptr;\n\t\t}\n\t\tif (!strcmp (name, \"__stack_chk_fail\") ) {\n\t\t\tbin->has_canary = true;\n\t\t}\n\t\tif (!strcmp (name, \"__asan_init\") ||\n                   !strcmp (name, \"__tsan_init\")) {\n\t\t\tbin->has_sanitizers = true;\n\t\t}\n\t\tif (!strcmp (name, \"_NSConcreteGlobalBlock\")) {\n\t\t\tbin->has_blocks_ext = true;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (imports);\n\treturn ret;\n}\n\nstatic RList *relocs(RBinFile *bf) {\n\tRList *ret = NULL;\n\tstruct MACH0_(obj_t) *bin = NULL;\n\tRBinObject *obj = bf ? bf->o : NULL;\n\tif (bf && bf->o) {\n\t\tbin = bf->o->bin_obj;\n\t}\n\tif (!obj || !obj->bin_obj || !(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\n\tRSkipList *relocs;\n\tif (!(relocs = MACH0_(get_relocs) (bf->o->bin_obj))) {\n\t\treturn ret;\n\t}\n\n\tRSkipListNode *it;\n\tstruct reloc_t *reloc;\n\tr_skiplist_foreach (relocs, it, reloc) {\n\t\tif (reloc->external) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinReloc *ptr = NULL;\n\t\tif (!(ptr = R_NEW0 (RBinReloc))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->type = reloc->type;\n\t\tptr->additive = 0;\n\t\tif (reloc->name[0]) {\n\t\t\tRBinImport *imp;\n\t\t\tif (!(imp = import_from_name (bf->rbin, (char*) reloc->name, bin->imports_by_name))) {\n\t\t\t\tfree (ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr->import = imp;\n\t\t} else if (reloc->ord >= 0 && bin->imports_by_ord && reloc->ord < bin->imports_by_ord_size) {\n\t\t\tptr->import = bin->imports_by_ord[reloc->ord];\n\t\t} else {\n\t\t\tptr->import = NULL;\n\t\t}\n\t\tptr->addend = reloc->addend;\n\t\tptr->vaddr = reloc->addr;\n\t\tptr->paddr = reloc->offset;\n\t\tr_list_append (ret, ptr);\n\t}\n\n\tr_skiplist_free (relocs);\n\n\treturn ret;\n}\n\nstatic RList *libs(RBinFile *bf) {\n\tint i;\n\tchar *ptr = NULL;\n\tstruct lib_t *libs;\n\tRList *ret = NULL;\n\tRBinObject *obj = bf ? bf->o : NULL;\n\n\tif (!obj || !obj->bin_obj || !(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tif ((libs = MACH0_(get_libs) (obj->bin_obj))) {\n\t\tfor (i = 0; !libs[i].last; i++) {\n\t\t\tptr = strdup (libs[i].name);\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t\tfree (libs);\n\t}\n\treturn ret;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin = NULL;\n\tchar *str;\n\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tbin = bf->o->bin_obj;\n\tif (bf->file) {\n\t\tret->file = strdup (bf->file);\n\t}\n\tif ((str = MACH0_(get_class) (bf->o->bin_obj))) {\n\t\tret->bclass = str;\n\t}\n\tif (bin) {\n\t\tret->has_canary = bin->has_canary;\n\t\tret->has_retguard = -1;\n\t\tret->has_sanitizers = bin->has_sanitizers;\n\t\tret->dbg_info = bin->dbg_info;\n\t\tret->lang = bin->lang;\n\t}\n\tret->intrp = r_str_dup (NULL, MACH0_(get_intrp)(bf->o->bin_obj));\n\tret->compiler = r_str_dup (NULL, \"\");\n\tret->rclass = strdup (\"mach0\");\n\tret->os = strdup (MACH0_(get_os)(bf->o->bin_obj));\n\tret->subsystem = strdup (\"darwin\");\n\tret->arch = strdup (MACH0_(get_cputype) (bf->o->bin_obj));\n\tret->machine = MACH0_(get_cpusubtype) (bf->o->bin_obj);\n\tret->has_lit = true;\n\tret->type = MACH0_(get_filetype) (bf->o->bin_obj);\n\tret->big_endian = MACH0_(is_big_endian) (bf->o->bin_obj);\n\tret->bits = 32;\n\tif (bf && bf->o && bf->o->bin_obj) {\n\t\tret->has_crypto = ((struct MACH0_(obj_t)*)\n\t\t\tbf->o->bin_obj)->has_crypto;\n\t\tret->bits = MACH0_(get_bits) (bf->o->bin_obj);\n\t}\n\tret->has_va = true;\n\tret->has_pi = MACH0_(is_pie) (bf->o->bin_obj);\n\tret->has_nx = MACH0_(has_nx) (bf->o->bin_obj);\n\treturn ret;\n}\n\nstatic bool _patch_reloc(struct MACH0_(obj_t) *bin, RIOBind *iob, struct reloc_t * reloc, ut64 symbol_at) {\n\tut64 pc = reloc->addr;\n\tut64 ins_len = 0;\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_X86_64: {\n\t\tswitch (reloc->type) {\n\t\tcase X86_64_RELOC_UNSIGNED:\n\t\t\tbreak;\n\t\tcase X86_64_RELOC_BRANCH:\n\t\t\tpc -= 1;\n\t\t\tins_len = 5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Warning: unsupported reloc type for X86_64 (%d), please file a bug.\\n\", reloc->type);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CPU_TYPE_ARM64:\n\tcase CPU_TYPE_ARM64_32:\n\t\tpc = reloc->addr & ~3;\n\t\tins_len = 4;\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Warning: unsupported architecture for patching relocs, please file a bug. %s\\n\", MACH0_(get_cputype_from_hdr)(&bin->hdr));\n\t\treturn false;\n\t}\n\n\tut64 val = symbol_at;\n\tif (reloc->pc_relative) {\n\t\tval = symbol_at - pc - ins_len;\n\t}\n\n\tut8 buf[8];\n\tr_write_ble (buf, val, false, reloc->size * 8);\n\tiob->write_at (iob->io, reloc->addr, buf, reloc->size);\n\n\treturn true;\n}\n\nstatic RList* patch_relocs(RBin *b) {\n\tRList *ret = NULL;\n\tRIO *io = NULL;\n\tRBinObject *obj = NULL;\n\tstruct MACH0_(obj_t) *bin = NULL;\n\tRIOMap *g = NULL;\n\tHtUU *relocs_by_sym = NULL;\n\tRIODesc *gotr2desc = NULL;\n\n\tr_return_val_if_fail (b, NULL);\n\n\tio = b->iob.io;\n\tif (!io || !io->desc) {\n\t\treturn NULL;\n\t}\n\tobj = r_bin_cur_object (b);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tbin = obj->bin_obj;\n\n\tRSkipList * all_relocs = MACH0_(get_relocs)(bin);\n\tif (!all_relocs) {\n\t\treturn NULL;\n\t}\n\tRList * ext_relocs = r_list_new ();\n\tif (!ext_relocs) {\n\t\tgoto beach;\n\t}\n\tRSkipListNode *it;\n\tstruct reloc_t * reloc;\n\tr_skiplist_foreach (all_relocs, it, reloc) {\n\t\tif (!reloc->external) {\n\t\t\tcontinue;\n\t\t}\n\t\tr_list_append (ext_relocs, reloc);\n\t}\n\tut64 num_ext_relocs = r_list_length (ext_relocs);\n\tif (!num_ext_relocs) {\n\t\tgoto beach;\n\t}\n\n\tif (!io->cached) {\n\t\teprintf (\"Warning: run r2 with -e bin.cache=true to fix relocations in disassembly\\n\");\n\t\tgoto beach;\n\t}\n\n\tint cdsz = obj->info ? obj->info->bits / 8 : 8;\n\n\tut64 offset = 0;\n\tvoid **vit;\n\tr_pvector_foreach (&io->maps, vit) {\n\t\tRIOMap *map = *vit;\n\t\tif (r_io_map_begin (map) > offset) {\n\t\t\toffset = r_io_map_begin (map);\n\t\t\tg = map;\n\t\t}\n\t}\n\tif (!g) {\n\t\tgoto beach;\n\t}\n\tut64 n_vaddr = g->itv.addr + g->itv.size;\n\tut64 size = num_ext_relocs * cdsz;\n\tchar *muri = r_str_newf (\"malloc://%\" PFMT64u, size);\n\tgotr2desc = b->iob.open_at (io, muri, R_PERM_R, 0664, n_vaddr);\n\tfree (muri);\n\tif (!gotr2desc) {\n\t\tgoto beach;\n\t}\n\n\tRIOMap *gotr2map = b->iob.map_get_at (io, n_vaddr);\n\tif (!gotr2map) {\n\t\tgoto beach;\n\t}\n\tgotr2map->name = strdup (\".got.r2\");\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\tgoto beach;\n\t}\n\tif (!(relocs_by_sym = ht_uu_new0 ())) {\n\t\tgoto beach;\n\t}\n\tut64 vaddr = n_vaddr;\n\tRListIter *liter;\n\tr_list_foreach (ext_relocs, liter, reloc) {\n\t\tut64 sym_addr = 0;\n\t\tsym_addr = ht_uu_find (relocs_by_sym, reloc->ord, NULL);\n\t\tif (!sym_addr) {\n\t\t\tsym_addr = vaddr;\n\t\t\tht_uu_insert (relocs_by_sym, reloc->ord, vaddr);\n\t\t\tvaddr += cdsz;\n\t\t}\n\t\tif (!_patch_reloc (bin, &b->iob, reloc, sym_addr)) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinReloc *ptr = NULL;\n\t\tif (!(ptr = R_NEW0 (RBinReloc))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->type = reloc->type;\n\t\tptr->additive = 0;\n\t\tRBinImport *imp;\n\t\tif (!(imp = import_from_name (b, (char*) reloc->name, bin->imports_by_name))) {\n\t\t\tR_FREE (ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->vaddr = sym_addr;\n\t\tptr->import = imp;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif (r_list_empty (ret)) {\n\t\tgoto beach;\n\t}\n\tht_uu_free (relocs_by_sym);\n\tr_list_free (ext_relocs);\n\tr_skiplist_free (all_relocs);\n\treturn ret;\n\nbeach:\n\tr_list_free (ext_relocs);\n\tr_skiplist_free (all_relocs);\n\tr_io_desc_free (gotr2desc);\n\tr_list_free (ret);\n\tht_uu_free (relocs_by_sym);\n\treturn NULL;\n}\n\nstatic void swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io) {\n\tr_return_if_fail (io && io->desc && io->desc->plugin);\n\tRIOPlugin *plugin = io->desc->plugin;\n\tobj->original_io_read = plugin->read;\n\tplugin->read = &rebasing_and_stripping_io_read;\n}\n\nstatic int rebasing_and_stripping_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {\n\tr_return_val_if_fail (io, -1);\n\tRCore *core = (RCore*) io->corebind.core;\n\tif (!core || !core->bin || !core->bin->binfiles) {\n\t\treturn -1;\n\t}\n\tstruct MACH0_(obj_t) *obj = NULL;\n\tRListIter *iter;\n\tRBinFile *bf;\n\tr_list_foreach (core->bin->binfiles, iter, bf) {\n\t\tif (bf->fd == fd->fd ) {\n\t\t\t/* The first field of MACH0_(obj_t) is\n\t\t\t * the mach_header, whose first field is\n\t\t\t * the MH magic.\n\t\t\t * This code assumes that bin objects are\n\t\t\t * at least 4 bytes long.\n\t\t\t */\n\t\t\tut32 *magic = bf->o->bin_obj;\n\t\t\tif (magic && (*magic == MH_MAGIC ||\n\t\t\t\t\t*magic == MH_CIGAM ||\n\t\t\t\t\t*magic == MH_MAGIC_64 ||\n\t\t\t\t\t*magic == MH_CIGAM_64)) {\n\t\t\t\tobj = bf->o->bin_obj;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!obj || !obj->original_io_read) {\n\t\tif (fd->plugin->read == &rebasing_and_stripping_io_read) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn fd->plugin->read (io, fd, buf, count);\n\t}\n\tif (obj->rebasing_buffer) {\n\t\treturn obj->original_io_read (io, fd, buf, count);\n\t}\n\tstatic ut8 *internal_buffer = NULL;\n\tstatic int internal_buf_size = 0;\n\tif (count > internal_buf_size) {\n\t\tif (internal_buffer) {\n\t\t\tR_FREE (internal_buffer);\n\t\t\tinternal_buffer = NULL;\n\t\t}\n\t\tinternal_buf_size = R_MAX (count, 8);\n\t\tinternal_buffer = (ut8 *) malloc (internal_buf_size);\n\t}\n\tut64 io_off = io->off;\n\tint result = obj->original_io_read (io, fd, internal_buffer, count);\n\tif (result == count) {\n\t\trebase_buffer (obj, io_off - bf->o->boffset, fd, internal_buffer, count);\n\t\tmemcpy (buf, internal_buffer, result);\n\t}\n\treturn result;\n}\n\nstatic void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (obj->rebasing_buffer) {\n\t\treturn;\n\t}\n\tobj->rebasing_buffer = true;\n\tut64 eob = off + count;\n\tint i = 0;\n\tfor (; i < obj->nsegs; i++) {\n\t\tif (!obj->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 page_size = obj->chained_starts[i]->page_size;\n\t\tut64 start = obj->segs[i].fileoff;\n\t\tut64 end = start + obj->segs[i].filesize;\n\t\tif (end >= off && start <= eob) {\n\t\t\tut64 page_idx = (R_MAX (start, off) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= obj->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = obj->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < eob && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tif (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta;\n\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t}\n\t\t\t\t\tut64 in_buf = cursor - off;\n\t\t\t\t\tif (cursor >= off && cursor <= eob - 8) {\n\t\t\t\t\t\tr_write_le64 (&buf[in_buf], ptr_value);\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * 8;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tobj->rebasing_buffer = false;\n}\n\n#if !R_BIN_MACH064\n\nstatic bool check_buffer(RBuffer *b) {\n\tif (r_buf_size (b) >= 4) {\n\t\tut8 buf[4] = {0};\n\t\tif (r_buf_read_at (b, 0, buf, 4)) {\n\t\t\tif (!memcmp (buf, \"\\xce\\xfa\\xed\\xfe\", 4) ||\n\t\t\t\t!memcmp (buf, \"\\xfe\\xed\\xfa\\xce\", 4)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nstatic RBuffer *create(RBin *bin, const ut8 *code, int clen, const ut8 *data, int dlen, RBinArchOptions *opt) {\n\tconst bool use_pagezero = true;\n\tconst bool use_main = true;\n\tconst bool use_dylinker = true;\n\tconst bool use_libsystem = true;\n\tconst bool use_linkedit = true;\n\tut32 filesize, codeva, datava;\n\tut32 ncmds, cmdsize, magiclen;\n\tut32 p_codefsz = 0, p_codeva = 0, p_codesz = 0, p_codepa = 0;\n\tut32 p_datafsz = 0, p_datava = 0, p_datasz = 0, p_datapa = 0;\n\tut32 p_cmdsize = 0, p_entry = 0, p_tmp = 0;\n\tut32 baddr = 0x1000;\n\n\tr_return_val_if_fail (bin && opt, NULL);\n\n\tbool is_arm = strstr (opt->arch, \"arm\");\n\tRBuffer *buf = r_buf_new ();\n#ifndef R_BIN_MACH064\n\tif (opt->bits == 64) {\n\t\teprintf (\"TODO: Please use mach064 instead of mach0\\n\");\n\t\tfree (buf);\n\t\treturn NULL;\n\t}\n#endif\n\n#define B(x,y) r_buf_append_bytes(buf,(const ut8*)(x),y)\n#define D(x) r_buf_append_ut32(buf,x)\n#define Z(x) r_buf_append_nbytes(buf,x)\n#define W(x,y,z) r_buf_write_at(buf,x,(const ut8*)(y),z)\n#define WZ(x,y) p_tmp=r_buf_size (buf);Z(x);W(p_tmp,y,strlen(y))\n\n\t/* MACH0 HEADER */\n\tB (\"\\xce\\xfa\\xed\\xfe\", 4); // header\n// 64bit header\tB (\"\\xce\\xfa\\xed\\xfe\", 4); // header\n\tif (is_arm) {\n\t\tD (12); // cpu type (arm)\n\t\tD (3); // subtype (all?)\n\t} else {\n\t\t/* x86-32 */\n\t\tD (7); // cpu type (x86)\n// D(0x1000007); // x86-64\n\t\tD (3); // subtype (i386-all)\n\t}\n\tD (2); // filetype (executable)\n\n\tif (data && dlen > 0) {\n\t\tncmds = 3;\n\t\tcmdsize = 0;\n\t} else {\n\t\tncmds = 2;\n\t\tcmdsize = 0;\n\t}\n\tif (use_pagezero) {\n\t\tncmds++;\n\t}\n\tif (use_dylinker) {\n\t\tncmds++;\n\t\tif (use_linkedit) {\n\t\t\tncmds += 3;\n\t\t}\n\t\tif (use_libsystem) {\n\t\t\tncmds++;\n\t\t}\n\t}\n\n\t/* COMMANDS */\n\tD (ncmds); // ncmds\n\tp_cmdsize = r_buf_size (buf);\n\tD (-1); // cmdsize\n\tD (0); // flags\n\t// D (0x01200085); // alternative flags found in some a.out..\n\tmagiclen = r_buf_size (buf);\n\n\tif (use_pagezero) {\n\t\t/* PAGEZERO */\n\t\tD (1);   // cmd.LC_SEGMENT\n\t\tD (56); // sizeof (cmd)\n\t\tWZ (16, \"__PAGEZERO\");\n\t\tD (0); // vmaddr\n\t\tD (0x00001000); // vmsize XXX\n\t\tD (0); // fileoff\n\t\tD (0); // filesize\n\t\tD (0); // maxprot\n\t\tD (0); // initprot\n\t\tD (0); // nsects\n\t\tD (0); // flags\n\t}\n\n\t/* TEXT SEGMENT */\n\tD (1);   // cmd.LC_SEGMENT\n\tD (124); // sizeof (cmd)\n\tWZ (16, \"__TEXT\");\n\tD (baddr); // vmaddr\n\tD (0x1000); // vmsize XXX\n\tD (0); // fileoff\n\tp_codefsz = r_buf_size (buf);\n\tD (-1); // filesize\n\tD (7); // maxprot\n\tD (5); // initprot\n\tD (1); // nsects\n\tD (0); // flags\n\tWZ (16, \"__text\");\n\tWZ (16, \"__TEXT\");\n\tp_codeva = r_buf_size (buf); // virtual address\n\tD (-1);\n\tp_codesz = r_buf_size (buf); // size of code (end-start)\n\tD (-1);\n\tp_codepa = r_buf_size (buf); // code - baddr\n\tD (-1); //_start-0x1000);\n\tD (0); // align // should be 2 for 64bit\n\tD (0); // reloff\n\tD (0); // nrelocs\n\tD (0); // flags\n\tD (0); // reserved\n\tD (0); // ??\n\n\tif (data && dlen > 0) {\n\t\t/* DATA SEGMENT */\n\t\tD (1); // cmd.LC_SEGMENT\n\t\tD (124); // sizeof (cmd)\n\t\tp_tmp = r_buf_size (buf);\n\t\tZ (16);\n\t\tW (p_tmp, \"__TEXT\", 6); // segment name\n\t\tD (0x2000); // vmaddr\n\t\tD (0x1000); // vmsize\n\t\tD (0); // fileoff\n\t\tp_datafsz = r_buf_size (buf);\n\t\tD (-1); // filesize\n\t\tD (6); // maxprot\n\t\tD (6); // initprot\n\t\tD (1); // nsects\n\t\tD (0); // flags\n\n\t\tWZ (16, \"__data\");\n\t\tWZ (16, \"__DATA\");\n\n\t\tp_datava = r_buf_size (buf);\n\t\tD (-1);\n\t\tp_datasz = r_buf_size (buf);\n\t\tD (-1);\n\t\tp_datapa = r_buf_size (buf);\n\t\tD (-1); //_start-0x1000);\n\t\tD (2); // align\n\t\tD (0); // reloff\n\t\tD (0); // nrelocs\n\t\tD (0); // flags\n\t\tD (0); // reserved\n\t\tD (0);\n\t}\n\n\tif (use_dylinker) {\n\t\tif (use_linkedit) {\n\t\t\t/* LINKEDIT */\n\t\t\tD (1);   // cmd.LC_SEGMENT\n\t\t\tD (56); // sizeof (cmd)\n\t\t\tWZ (16, \"__LINKEDIT\");\n\t\t\tD (0x3000); // vmaddr\n\t\t\tD (0x00001000); // vmsize XXX\n\t\t\tD (0x1000); // fileoff\n\t\t\tD (0); // filesize\n\t\t\tD (7); // maxprot\n\t\t\tD (1); // initprot\n\t\t\tD (0); // nsects\n\t\t\tD (0); // flags\n\n\t\t\t/* LC_SYMTAB */\n\t\t\tD (2); // cmd.LC_SYMTAB\n\t\t\tD (24); // sizeof (cmd)\n\t\t\tD (0x1000); // symtab offset\n\t\t\tD (0); // symtab size\n\t\t\tD (0x1000); // strtab offset\n\t\t\tD (0); // strtab size\n\n\t\t\t/* LC_DYSYMTAB */\n\t\t\tD (0xb); // cmd.LC_DYSYMTAB\n\t\t\tD (80); // sizeof (cmd)\n\t\t\tZ (18 * sizeof (ut32)); // empty\n\t\t}\n\n\t\tconst char *dyld = \"/usr/lib/dyld\";\n\t\tconst int dyld_len = strlen (dyld) + 1;\n\t\tD(0xe); /* LC_DYLINKER */\n\t\tD((4 * 3) + dyld_len);\n\t\tD(dyld_len - 2);\n\t\tWZ(dyld_len, dyld); // path\n\n\t\tif (use_libsystem) {\n\t\t\t/* add libSystem at least ... */\n\t\t\tconst char *lib = \"/usr/lib/libSystem.B.dylib\";\n\t\t\tconst int lib_len = strlen (lib) + 1;\n\t\t\tD (0xc); /* LC_LOAD_DYLIB */\n\t\t\tD (24 + lib_len); // cmdsize\n\t\t\tD (24); // offset where the lib string start\n\t\t\tD (0x2);\n\t\t\tD (0x1);\n\t\t\tD (0x1);\n\t\t\tWZ (lib_len, lib);\n\t\t}\n\t}\n\n\tif (use_main) {\n\t\t/* LC_MAIN */\n\t\tD (0x80000028);   // cmd.LC_MAIN\n\t\tD (24); // sizeof (cmd)\n\t\tD (baddr); // entryoff\n\t\tD (0); // stacksize\n\t\tD (0); // ???\n\t\tD (0); // ???\n\t} else {\n\t\t/* THREAD STATE */\n\t\tD (5); // LC_UNIXTHREAD\n\t\tD (80); // sizeof (cmd)\n\t\tif (is_arm) {\n\t\t\t/* arm */\n\t\t\tD (1); // i386-thread-state\n\t\t\tD (17); // thread-state-count\n\t\t\tp_entry = r_buf_size (buf) + (16 * sizeof (ut32));\n\t\t\tZ (17 * sizeof (ut32));\n\t\t\t// mach0-arm has one byte more\n\t\t} else {\n\t\t\t/* x86-32 */\n\t\t\tD (1); // i386-thread-state\n\t\t\tD (16); // thread-state-count\n\t\t\tp_entry = r_buf_size (buf) + (10 * sizeof (ut32));\n\t\t\tZ (16 * sizeof (ut32));\n\t\t}\n\t}\n\n\t/* padding to make mach_loader checks happy */\n\t/* binaries must be at least of 4KB :( not tiny anymore */\n\tWZ (4096 - r_buf_size (buf), \"\");\n\n\tcmdsize = r_buf_size (buf) - magiclen;\n\tcodeva = r_buf_size (buf) + baddr;\n\tdatava = r_buf_size (buf) + clen + baddr;\n\tif (p_entry != 0) {\n\t\tW (p_entry, &codeva, 4); // set PC\n\t}\n\n\t/* fill header variables */\n\tW (p_cmdsize, &cmdsize, 4);\n\tfilesize = magiclen + cmdsize + clen + dlen;\n\t// TEXT SEGMENT should span the whole file //\n\tW (p_codefsz, &filesize, 4);\n\tW (p_codefsz-8, &filesize, 4); // vmsize = filesize\n\tW (p_codeva, &codeva, 4);\n\t// clen = 4096;\n\tW (p_codesz, &clen, 4);\n\tp_tmp = codeva - baddr;\n\tW (p_codepa, &p_tmp, 4);\n\n\tB (code, clen);\n\n\tif (data && dlen > 0) {\n\t\t/* append data */\n\t\tW (p_datafsz, &filesize, 4);\n\t\tW (p_datava, &datava, 4);\n\t\tW (p_datasz, &dlen, 4);\n\t\tp_tmp = datava - baddr;\n\t\tW (p_datapa, &p_tmp, 4);\n\t\tB (data, dlen);\n\t}\n\n\treturn buf;\n}\n\nstatic RBinAddr *binsym(RBinFile *bf, int sym) {\n\tut64 addr;\n\tRBinAddr *ret = NULL;\n\tswitch (sym) {\n\tcase R_BIN_SYM_MAIN:\n\t\taddr = MACH0_(get_main) (bf->o->bin_obj);\n\t\tif (addr == UT64_MAX || !(ret = R_NEW0 (RBinAddr))) {\n\t\t\treturn NULL;\n\t\t}\n\t\t//if (bf->o->info && bf->o->info->bits == 16) {\n\t\t// align for thumb\n\t\tret->vaddr = ((addr >> 1) << 1);\n\t\t//}\n\t\tret->paddr = ret->vaddr;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic ut64 size(RBinFile *bf) {\n\tut64 off = 0;\n\tut64 len = 0;\n\tif (!bf->o->sections) {\n\t\tRListIter *iter;\n\t\tRBinSection *section;\n\t\tbf->o->sections = sections (bf);\n\t\tr_list_foreach (bf->o->sections, iter, section) {\n\t\t\tif (section->paddr > off) {\n\t\t\t\toff = section->paddr;\n\t\t\t\tlen = section->size;\n\t\t\t}\n\t\t}\n\t}\n\treturn off + len;\n}\n\nRBinPlugin r_bin_plugin_mach0 = {\n\t.name = \"mach0\",\n\t.desc = \"mach0 bin plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.check_buffer = &check_buffer,\n\t.baddr = &baddr,\n\t.binsym = &binsym,\n\t.entries = &entries,\n\t.signature = &entitlements,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.imports = &imports,\n\t.size = &size,\n\t.info = &info,\n\t.header = MACH0_(mach_headerfields),\n\t.fields = MACH0_(mach_fields),\n\t.libs = &libs,\n\t.relocs = &relocs,\n\t.patch_relocs = &patch_relocs,\n\t.create = &create,\n\t.classes = &MACH0_(parse_classes),\n\t.write = &r_bin_write_mach0,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_mach0,\n\t.version = R2_VERSION\n};\n#endif\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2009-2021 - pancake */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_core.h>\n#include \"../i/private.h\"\n#include \"mach0/mach0.h\"\n#include \"objc/mach0_classes.h\"\n#include <ht_uu.h>\n\n// wip settings\n\nextern RBinWrite r_bin_write_mach0;\n\nstatic RBinInfo *info(RBinFile *bf);\n\nstatic void swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io);\nstatic int rebasing_and_stripping_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count);\nstatic void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count);\n\n#define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)\n#define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)\n\nstatic Sdb *get_sdb (RBinFile *bf) {\n\tRBinObject *o = bf->o;\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tstruct MACH0_(obj_t) *bin = (struct MACH0_(obj_t) *) o->bin_obj;\n\treturn bin? bin->kv: NULL;\n}\n\nstatic char *entitlements(RBinFile *bf, bool json) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tif (json) {\n\t\tconst char *s = r_str_get ((const char *)bin->signature);\n\t\tPJ *pj = pj_new ();\n\t\tpj_s (pj, s);\n\t\treturn pj_drain (pj);\n\t}\n\treturn r_str_dup (NULL, (const char*)bin->signature);\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb){\n\tr_return_val_if_fail (bf && bin_obj && buf, false);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *res = MACH0_(new_buf) (buf, &opts);\n\tif (res) {\n\t\tif (res->chained_starts) {\n\t\t\tRIO *io = bf->rbin->iob.io;\n\t\t\tswizzle_io_read (res, io);\n\t\t}\n\t\tsdb_ns_set (sdb, \"info\", res->kv);\n\t\t*bin_obj = res;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void destroy(RBinFile *bf) {\n\tMACH0_(mach0_free) (bf->o->bin_obj);\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, UT64_MAX);\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\treturn MACH0_(get_baddr)(bin);\n}\n\nstatic RList *sections(RBinFile *bf) {\n\treturn MACH0_(get_segments) (bf);\n}\n\nstatic RBinAddr *newEntry(ut64 hpaddr, ut64 paddr, int type, int bits) {\n\tRBinAddr *ptr = R_NEW0 (RBinAddr);\n\tif (ptr) {\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = paddr;\n\t\tptr->hpaddr = hpaddr;\n\t\tptr->bits = bits;\n\t\tptr->type = type;\n\t\t//realign due to thumb\n\t\tif (bits == 16 && ptr->vaddr & 1) {\n\t\t\tptr->paddr--;\n\t\t\tptr->vaddr--;\n\t\t}\n\t}\n\treturn ptr;\n}\n\nstatic void process_constructors(RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (strstr (sec->name, \"_mod_fini_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (sec->name, \"_mod_init_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_INIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint read = r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (read < sec->size) {\n\t\t\t\teprintf (\"process_constructors: cannot process section %s\\n\", sec->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; i + 3 < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\tif (ba) {\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i + 7 < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\tif (ba) {\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\n\tRBinAddr *ptr = NULL;\n\tstruct addr_t *entry = NULL;\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tint bits = MACH0_(get_bits) (bf->o->bin_obj);\n\tif (!(entry = MACH0_(get_entrypoint) (bf->o->bin_obj))) {\n\t\treturn ret;\n\t}\n\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\tptr->paddr = entry->offset + bf->o->boffset;\n\t\tptr->vaddr = entry->addr;\n\t\tptr->hpaddr = entry->haddr;\n\t\tptr->bits = bits;\n\t\t//realign due to thumb\n\t\tif (bits == 16) {\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t\tptr->vaddr--;\n\t\t\t}\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\n\tprocess_constructors (bf, ret, bits);\n\t// constructors\n\tfree (entry);\n\treturn ret;\n}\n\nstatic void _handle_arm_thumb(struct MACH0_(obj_t) *bin, RBinSymbol **p) {\n\tRBinSymbol *ptr = *p;\n\tif (bin) {\n\t\tif (ptr->paddr & 1) {\n\t\t\tptr->paddr--;\n\t\t\tptr->vaddr--;\n\t\t\tptr->bits = 16;\n\t\t}\n\t}\n}\n\n#if FEATURE_SYMLIST\nstatic RList *symbols(RBinFile *bf) {\n\tRBinObject *obj = bf? bf->o: NULL;\n\treturn (RList *)MACH0_(get_symbols_list) (obj->bin_obj);\n}\n#else\nstatic RList *symbols(RBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin;\n\tint i;\n\tconst struct symbol_t *syms = NULL;\n\tRBinSymbol *ptr = NULL;\n\tRBinObject *obj = bf? bf->o: NULL;\n\tRList *ret = r_list_newf (free);\n#if 0\n\tconst char *lang = \"c\"; // XXX deprecate this\n#endif\n\tint wordsize = 0;\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (!obj || !obj->bin_obj) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tbool isStripped = false;\n\twordsize = MACH0_(get_bits) (obj->bin_obj);\n\n\t// OLD CODE\n\tif (!(syms = MACH0_(get_symbols) (obj->bin_obj))) {\n\t\treturn ret;\n\t}\n\tSdb *symcache = sdb_new0 ();\n\tbin = (struct MACH0_(obj_t) *) obj->bin_obj;\n\tfor (i = 0; !syms[i].last; i++) {\n\t\tif (syms[i].name == NULL || syms[i].name[0] == '\\0' || syms[i].addr < 100) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup ((char*)syms[i].name);\n\t\tptr->is_imported = syms[i].is_imported;\n\t\tif (ptr->name[0] == '_' && !ptr->is_imported) {\n\t\t\tchar *dn = r_bin_demangle (bf, ptr->name, ptr->name, ptr->vaddr, false);\n\t\t\tif (dn) {\n\t\t\t\tptr->dname = dn;\n\t\t\t\tchar *p = strchr (dn, '.');\n\t\t\t\tif (p) {\n\t\t\t\t\tif (IS_UPPER (ptr->name[0])) {\n\t\t\t\t\t\tptr->classname = strdup (ptr->name);\n\t\t\t\t\t\tptr->classname[p - ptr->name] = 0;\n\t\t\t\t\t} else if (IS_UPPER (p[1])) {\n\t\t\t\t\t\tptr->classname = strdup (p + 1);\n\t\t\t\t\t\tp = strchr (ptr->classname, '.');\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr->forwarder = \"NONE\";\n\t\tptr->bind = (syms[i].type == R_BIN_MACH0_SYMBOL_TYPE_LOCAL)? R_BIN_BIND_LOCAL_STR: R_BIN_BIND_GLOBAL_STR;\n\t\tptr->type = R_BIN_TYPE_FUNC_STR;\n\t\tptr->vaddr = syms[i].addr;\n\t\tptr->paddr = syms[i].offset + obj->boffset;\n\t\tptr->size = syms[i].size;\n\t\tptr->bits = syms[i].bits;\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && wordsize < 64) {\n\t\t\t_handle_arm_thumb (bin, &ptr);\n\t\t}\n\t\tptr->ordinal = i;\n\t\tbin->dbg_info = strncmp (ptr->name, \"radr://\", 7)? 0: 1;\n\t\tsdb_set (symcache, sdb_fmt (\"sym0x%\"PFMT64x, ptr->vaddr), \"found\", 0);\n#if 0\n\t\tif (!strncmp (ptr->name, \"__Z\", 3)) {\n\t\t\tlang = \"c++\";\n\t\t}\n\t\tif (!strncmp (ptr->name, \"type.\", 5)) {\n\t\t\tlang = \"go\";\n\t\t} else if (!strcmp (ptr->name, \"_rust_oom\")) {\n\t\t\tlang = \"rust\";\n\t\t}\n#endif\n\t\tr_list_append (ret, ptr);\n\t}\n\t//functions from LC_FUNCTION_STARTS\n\tif (bin->func_start) {\n\t\tchar symstr[128];\n\t\tut64 value = 0, address = 0;\n\t\tconst ut8 *temp = bin->func_start;\n\t\tconst ut8 *temp_end = bin->func_start + bin->func_size;\n\t\tstrcpy (symstr, \"sym0x\");\n\t\twhile (temp + 3 < temp_end && *temp) {\n\t\t\ttemp = r_uleb128_decode (temp, NULL, &value);\n\t\t\taddress += value;\n\t\t\tptr = R_NEW0 (RBinSymbol);\n\t\t\tif (!ptr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr->vaddr = bin->baddr + address;\n\t\t\tptr->paddr = address;\n\t\t\tptr->size = 0;\n\t\t\tptr->name = r_str_newf (\"func.%08\"PFMT64x, ptr->vaddr);\n\t\t\tptr->type = R_BIN_TYPE_FUNC_STR;\n\t\t\tptr->forwarder = \"NONE\";\n\t\t\tptr->bind = R_BIN_BIND_LOCAL_STR;\n\t\t\tptr->ordinal = i++;\n\t\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && wordsize < 64) {\n\t\t\t\t_handle_arm_thumb (bin, &ptr);\n\t\t\t}\n\t\t\tr_list_append (ret, ptr);\n\t\t\t// if any func is not found in syms then we can consider it is stripped\n\t\t\tif (!isStripped) {\n\t\t\t\tsnprintf (symstr + 5, sizeof (symstr) - 5 , \"%\" PFMT64x, ptr->vaddr);\n\t\t\t\tif (!sdb_const_get (symcache, symstr, 0)) {\n\t\t\t\t\tisStripped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#if 0\n// this must be done in bobj.c not here\n\tif (bin->has_blocks_ext) {\n\t\tlang = !strcmp (lang, \"c++\") ? \"c++ blocks ext.\" : \"c blocks ext.\";\n\t}\n\tbin->lang = lang;\n#endif\n\tif (isStripped) {\n\t\tbin->dbg_info |= R_BIN_DBG_STRIPPED;\n\t}\n\tsdb_free (symcache);\n\treturn ret;\n}\n#endif // FEATURE_SYMLIST\n\nstatic RBinImport *import_from_name(RBin *rbin, const char *orig_name, HtPP *imports_by_name) {\n\tif (imports_by_name) {\n\t\tbool found = false;\n\t\tRBinImport *ptr = ht_pp_find (imports_by_name, orig_name, &found);\n\t\tif (found) {\n\t\t\treturn ptr;\n\t\t}\n\t}\n\n\tRBinImport *ptr = NULL;\n\tif (!(ptr = R_NEW0 (RBinImport))) {\n\t\treturn NULL;\n\t}\n\n\tchar *name = (char*) orig_name;\n\tconst char *_objc_class = \"_OBJC_CLASS_$\";\n\tconst int _objc_class_len = strlen (_objc_class);\n\tconst char *_objc_metaclass = \"_OBJC_METACLASS_$\";\n\tconst int _objc_metaclass_len = strlen (_objc_metaclass);\n\tchar *type = \"FUNC\";\n\n\tif (!strncmp (name, _objc_class, _objc_class_len)) {\n\t\tname += _objc_class_len;\n\t\ttype = \"OBJC_CLASS\";\n\t} else if (!strncmp (name, _objc_metaclass, _objc_metaclass_len)) {\n\t\tname += _objc_metaclass_len;\n\t\ttype = \"OBJC_METACLASS\";\n\t}\n\n\t// Remove the extra underscore that every import seems to have in Mach-O.\n\tif (*name == '_') {\n\t\tname++;\n\t}\n\tptr->name = strdup (name);\n\tptr->bind = \"NONE\";\n\tptr->type = r_str_constpool_get (&rbin->constpool, type);\n\n\tif (imports_by_name) {\n\t\tht_pp_insert (imports_by_name, orig_name, ptr);\n\t}\n\n\treturn ptr;\n}\n\nstatic RList *imports(RBinFile *bf) {\n\tRBinObject *obj = bf ? bf->o : NULL;\n\tstruct MACH0_(obj_t) *bin = bf ? bf->o->bin_obj : NULL;\n\tconst char *name;\n\tRBinImport *ptr = NULL;\n\tint i;\n\n\tif (!obj || !bin || !obj->bin_obj) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_newf((RListFree)r_bin_import_free);\n\tstruct import_t *imports = MACH0_(get_imports)(bf->o->bin_obj);\n\tif (!ret || !imports) {\n\t\tr_list_free (ret);\n\t\tfree (imports);\n\t\treturn NULL;\n\t}\n\tbin->has_canary = false;\n\tbin->has_retguard = -1;\n\tbin->has_sanitizers = false;\n\tbin->has_blocks_ext = false;\n\tfor (i = 0; !imports[i].last; i++) {\n\t\tif (!(ptr = import_from_name (bf->rbin, imports[i].name, NULL))) {\n\t\t\tbreak;\n\t\t}\n\t\tname = ptr->name;\n\t\tptr->ordinal = imports[i].ord;\n\t\tif (bin->imports_by_ord && ptr->ordinal < bin->imports_by_ord_size) {\n\t\t\tbin->imports_by_ord[ptr->ordinal] = ptr;\n\t\t}\n\t\tif (!strcmp (name, \"__stack_chk_fail\") ) {\n\t\t\tbin->has_canary = true;\n\t\t}\n\t\tif (!strcmp (name, \"__asan_init\") ||\n                   !strcmp (name, \"__tsan_init\")) {\n\t\t\tbin->has_sanitizers = true;\n\t\t}\n\t\tif (!strcmp (name, \"_NSConcreteGlobalBlock\")) {\n\t\t\tbin->has_blocks_ext = true;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (imports);\n\treturn ret;\n}\n\nstatic RList *relocs(RBinFile *bf) {\n\tRList *ret = NULL;\n\tstruct MACH0_(obj_t) *bin = NULL;\n\tRBinObject *obj = bf ? bf->o : NULL;\n\tif (bf && bf->o) {\n\t\tbin = bf->o->bin_obj;\n\t}\n\tif (!obj || !obj->bin_obj || !(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\n\tRSkipList *relocs;\n\tif (!(relocs = MACH0_(get_relocs) (bf->o->bin_obj))) {\n\t\treturn ret;\n\t}\n\n\tRSkipListNode *it;\n\tstruct reloc_t *reloc;\n\tr_skiplist_foreach (relocs, it, reloc) {\n\t\tif (reloc->external) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinReloc *ptr = NULL;\n\t\tif (!(ptr = R_NEW0 (RBinReloc))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->type = reloc->type;\n\t\tptr->additive = 0;\n\t\tif (reloc->name[0]) {\n\t\t\tRBinImport *imp;\n\t\t\tif (!(imp = import_from_name (bf->rbin, (char*) reloc->name, bin->imports_by_name))) {\n\t\t\t\tfree (ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr->import = imp;\n\t\t} else if (reloc->ord >= 0 && bin->imports_by_ord && reloc->ord < bin->imports_by_ord_size) {\n\t\t\tptr->import = bin->imports_by_ord[reloc->ord];\n\t\t} else {\n\t\t\tptr->import = NULL;\n\t\t}\n\t\tptr->addend = reloc->addend;\n\t\tptr->vaddr = reloc->addr;\n\t\tptr->paddr = reloc->offset;\n\t\tr_list_append (ret, ptr);\n\t}\n\n\tr_skiplist_free (relocs);\n\n\treturn ret;\n}\n\nstatic RList *libs(RBinFile *bf) {\n\tint i;\n\tchar *ptr = NULL;\n\tstruct lib_t *libs;\n\tRList *ret = NULL;\n\tRBinObject *obj = bf ? bf->o : NULL;\n\n\tif (!obj || !obj->bin_obj || !(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tif ((libs = MACH0_(get_libs) (obj->bin_obj))) {\n\t\tfor (i = 0; !libs[i].last; i++) {\n\t\t\tptr = strdup (libs[i].name);\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t\tfree (libs);\n\t}\n\treturn ret;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin = NULL;\n\tchar *str;\n\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tbin = bf->o->bin_obj;\n\tif (bf->file) {\n\t\tret->file = strdup (bf->file);\n\t}\n\tif ((str = MACH0_(get_class) (bf->o->bin_obj))) {\n\t\tret->bclass = str;\n\t}\n\tif (bin) {\n\t\tret->has_canary = bin->has_canary;\n\t\tret->has_retguard = -1;\n\t\tret->has_sanitizers = bin->has_sanitizers;\n\t\tret->dbg_info = bin->dbg_info;\n\t\tret->lang = bin->lang;\n\t}\n\tret->intrp = r_str_dup (NULL, MACH0_(get_intrp)(bf->o->bin_obj));\n\tret->compiler = r_str_dup (NULL, \"\");\n\tret->rclass = strdup (\"mach0\");\n\tret->os = strdup (MACH0_(get_os)(bf->o->bin_obj));\n\tret->subsystem = strdup (\"darwin\");\n\tret->arch = strdup (MACH0_(get_cputype) (bf->o->bin_obj));\n\tret->machine = MACH0_(get_cpusubtype) (bf->o->bin_obj);\n\tret->has_lit = true;\n\tret->type = MACH0_(get_filetype) (bf->o->bin_obj);\n\tret->big_endian = MACH0_(is_big_endian) (bf->o->bin_obj);\n\tret->bits = 32;\n\tif (bf && bf->o && bf->o->bin_obj) {\n\t\tret->has_crypto = ((struct MACH0_(obj_t)*)\n\t\t\tbf->o->bin_obj)->has_crypto;\n\t\tret->bits = MACH0_(get_bits) (bf->o->bin_obj);\n\t}\n\tret->has_va = true;\n\tret->has_pi = MACH0_(is_pie) (bf->o->bin_obj);\n\tret->has_nx = MACH0_(has_nx) (bf->o->bin_obj);\n\treturn ret;\n}\n\nstatic bool _patch_reloc(struct MACH0_(obj_t) *bin, RIOBind *iob, struct reloc_t * reloc, ut64 symbol_at) {\n\tut64 pc = reloc->addr;\n\tut64 ins_len = 0;\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_X86_64: {\n\t\tswitch (reloc->type) {\n\t\tcase X86_64_RELOC_UNSIGNED:\n\t\t\tbreak;\n\t\tcase X86_64_RELOC_BRANCH:\n\t\t\tpc -= 1;\n\t\t\tins_len = 5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Warning: unsupported reloc type for X86_64 (%d), please file a bug.\\n\", reloc->type);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CPU_TYPE_ARM64:\n\tcase CPU_TYPE_ARM64_32:\n\t\tpc = reloc->addr & ~3;\n\t\tins_len = 4;\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Warning: unsupported architecture for patching relocs, please file a bug. %s\\n\", MACH0_(get_cputype_from_hdr)(&bin->hdr));\n\t\treturn false;\n\t}\n\n\tut64 val = symbol_at;\n\tif (reloc->pc_relative) {\n\t\tval = symbol_at - pc - ins_len;\n\t}\n\n\tut8 buf[8];\n\tr_write_ble (buf, val, false, reloc->size * 8);\n\tiob->write_at (iob->io, reloc->addr, buf, reloc->size);\n\n\treturn true;\n}\n\nstatic RList* patch_relocs(RBin *b) {\n\tRList *ret = NULL;\n\tRIO *io = NULL;\n\tRBinObject *obj = NULL;\n\tstruct MACH0_(obj_t) *bin = NULL;\n\tRIOMap *g = NULL;\n\tHtUU *relocs_by_sym = NULL;\n\tRIODesc *gotr2desc = NULL;\n\n\tr_return_val_if_fail (b, NULL);\n\n\tio = b->iob.io;\n\tif (!io || !io->desc) {\n\t\treturn NULL;\n\t}\n\tobj = r_bin_cur_object (b);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tbin = obj->bin_obj;\n\n\tRSkipList * all_relocs = MACH0_(get_relocs)(bin);\n\tif (!all_relocs) {\n\t\treturn NULL;\n\t}\n\tRList * ext_relocs = r_list_new ();\n\tif (!ext_relocs) {\n\t\tgoto beach;\n\t}\n\tRSkipListNode *it;\n\tstruct reloc_t * reloc;\n\tr_skiplist_foreach (all_relocs, it, reloc) {\n\t\tif (!reloc->external) {\n\t\t\tcontinue;\n\t\t}\n\t\tr_list_append (ext_relocs, reloc);\n\t}\n\tut64 num_ext_relocs = r_list_length (ext_relocs);\n\tif (!num_ext_relocs) {\n\t\tgoto beach;\n\t}\n\n\tif (!io->cached) {\n\t\teprintf (\"Warning: run r2 with -e bin.cache=true to fix relocations in disassembly\\n\");\n\t\tgoto beach;\n\t}\n\n\tint cdsz = obj->info ? obj->info->bits / 8 : 8;\n\n\tut64 offset = 0;\n\tvoid **vit;\n\tr_pvector_foreach (&io->maps, vit) {\n\t\tRIOMap *map = *vit;\n\t\tif (r_io_map_begin (map) > offset) {\n\t\t\toffset = r_io_map_begin (map);\n\t\t\tg = map;\n\t\t}\n\t}\n\tif (!g) {\n\t\tgoto beach;\n\t}\n\tut64 n_vaddr = g->itv.addr + g->itv.size;\n\tut64 size = num_ext_relocs * cdsz;\n\tchar *muri = r_str_newf (\"malloc://%\" PFMT64u, size);\n\tgotr2desc = b->iob.open_at (io, muri, R_PERM_R, 0664, n_vaddr);\n\tfree (muri);\n\tif (!gotr2desc) {\n\t\tgoto beach;\n\t}\n\n\tRIOMap *gotr2map = b->iob.map_get_at (io, n_vaddr);\n\tif (!gotr2map) {\n\t\tgoto beach;\n\t}\n\tgotr2map->name = strdup (\".got.r2\");\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\tgoto beach;\n\t}\n\tif (!(relocs_by_sym = ht_uu_new0 ())) {\n\t\tgoto beach;\n\t}\n\tut64 vaddr = n_vaddr;\n\tRListIter *liter;\n\tr_list_foreach (ext_relocs, liter, reloc) {\n\t\tut64 sym_addr = 0;\n\t\tsym_addr = ht_uu_find (relocs_by_sym, reloc->ord, NULL);\n\t\tif (!sym_addr) {\n\t\t\tsym_addr = vaddr;\n\t\t\tht_uu_insert (relocs_by_sym, reloc->ord, vaddr);\n\t\t\tvaddr += cdsz;\n\t\t}\n\t\tif (!_patch_reloc (bin, &b->iob, reloc, sym_addr)) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinReloc *ptr = NULL;\n\t\tif (!(ptr = R_NEW0 (RBinReloc))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->type = reloc->type;\n\t\tptr->additive = 0;\n\t\tRBinImport *imp;\n\t\tif (!(imp = import_from_name (b, (char*) reloc->name, bin->imports_by_name))) {\n\t\t\tR_FREE (ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->vaddr = sym_addr;\n\t\tptr->import = imp;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif (r_list_empty (ret)) {\n\t\tgoto beach;\n\t}\n\tht_uu_free (relocs_by_sym);\n\tr_list_free (ext_relocs);\n\tr_skiplist_free (all_relocs);\n\treturn ret;\n\nbeach:\n\tr_list_free (ext_relocs);\n\tr_skiplist_free (all_relocs);\n\tr_io_desc_free (gotr2desc);\n\tr_list_free (ret);\n\tht_uu_free (relocs_by_sym);\n\treturn NULL;\n}\n\nstatic void swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io) {\n\tr_return_if_fail (io && io->desc && io->desc->plugin);\n\tRIOPlugin *plugin = io->desc->plugin;\n\tobj->original_io_read = plugin->read;\n\tplugin->read = &rebasing_and_stripping_io_read;\n}\n\nstatic int rebasing_and_stripping_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {\n\tr_return_val_if_fail (io, -1);\n\tRCore *core = (RCore*) io->corebind.core;\n\tif (!core || !core->bin || !core->bin->binfiles) {\n\t\treturn -1;\n\t}\n\tstruct MACH0_(obj_t) *obj = NULL;\n\tRListIter *iter;\n\tRBinFile *bf;\n\tr_list_foreach (core->bin->binfiles, iter, bf) {\n\t\tif (bf->fd == fd->fd ) {\n\t\t\t/* The first field of MACH0_(obj_t) is\n\t\t\t * the mach_header, whose first field is\n\t\t\t * the MH magic.\n\t\t\t * This code assumes that bin objects are\n\t\t\t * at least 4 bytes long.\n\t\t\t */\n\t\t\tut32 *magic = bf->o->bin_obj;\n\t\t\tif (magic && (*magic == MH_MAGIC ||\n\t\t\t\t\t*magic == MH_CIGAM ||\n\t\t\t\t\t*magic == MH_MAGIC_64 ||\n\t\t\t\t\t*magic == MH_CIGAM_64)) {\n\t\t\t\tobj = bf->o->bin_obj;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!obj || !obj->original_io_read) {\n\t\tif (fd->plugin->read == &rebasing_and_stripping_io_read) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn fd->plugin->read (io, fd, buf, count);\n\t}\n\tif (obj->rebasing_buffer) {\n\t\treturn obj->original_io_read (io, fd, buf, count);\n\t}\n\tstatic ut8 *internal_buffer = NULL;\n\tstatic int internal_buf_size = 0;\n\tif (count > internal_buf_size) {\n\t\tif (internal_buffer) {\n\t\t\tR_FREE (internal_buffer);\n\t\t\tinternal_buffer = NULL;\n\t\t}\n\t\tinternal_buf_size = R_MAX (count, 8);\n\t\tinternal_buffer = (ut8 *) malloc (internal_buf_size);\n\t}\n\tut64 io_off = io->off;\n\tint result = obj->original_io_read (io, fd, internal_buffer, count);\n\tif (result == count) {\n\t\trebase_buffer (obj, io_off - bf->o->boffset, fd, internal_buffer, count);\n\t\tmemcpy (buf, internal_buffer, result);\n\t}\n\treturn result;\n}\n\nstatic void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (obj->rebasing_buffer) {\n\t\treturn;\n\t}\n\tobj->rebasing_buffer = true;\n\tut64 eob = off + count;\n\tint i = 0;\n\tfor (; i < obj->nsegs; i++) {\n\t\tif (!obj->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = obj->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = obj->segs[i].fileoff;\n\t\tut64 end = start + obj->segs[i].filesize;\n\t\tif (end >= off && start <= eob) {\n\t\t\tut64 page_idx = (R_MAX (start, off) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= obj->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = obj->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < eob && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tif (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta;\n\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t}\n\t\t\t\t\tut64 in_buf = cursor - off;\n\t\t\t\t\tif (cursor >= off && cursor <= eob - 8) {\n\t\t\t\t\t\tr_write_le64 (&buf[in_buf], ptr_value);\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * 8;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tobj->rebasing_buffer = false;\n}\n\n#if !R_BIN_MACH064\n\nstatic bool check_buffer(RBuffer *b) {\n\tif (r_buf_size (b) >= 4) {\n\t\tut8 buf[4] = {0};\n\t\tif (r_buf_read_at (b, 0, buf, 4)) {\n\t\t\tif (!memcmp (buf, \"\\xce\\xfa\\xed\\xfe\", 4) ||\n\t\t\t\t!memcmp (buf, \"\\xfe\\xed\\xfa\\xce\", 4)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nstatic RBuffer *create(RBin *bin, const ut8 *code, int clen, const ut8 *data, int dlen, RBinArchOptions *opt) {\n\tconst bool use_pagezero = true;\n\tconst bool use_main = true;\n\tconst bool use_dylinker = true;\n\tconst bool use_libsystem = true;\n\tconst bool use_linkedit = true;\n\tut32 filesize, codeva, datava;\n\tut32 ncmds, cmdsize, magiclen;\n\tut32 p_codefsz = 0, p_codeva = 0, p_codesz = 0, p_codepa = 0;\n\tut32 p_datafsz = 0, p_datava = 0, p_datasz = 0, p_datapa = 0;\n\tut32 p_cmdsize = 0, p_entry = 0, p_tmp = 0;\n\tut32 baddr = 0x1000;\n\n\tr_return_val_if_fail (bin && opt, NULL);\n\n\tbool is_arm = strstr (opt->arch, \"arm\");\n\tRBuffer *buf = r_buf_new ();\n#ifndef R_BIN_MACH064\n\tif (opt->bits == 64) {\n\t\teprintf (\"TODO: Please use mach064 instead of mach0\\n\");\n\t\tfree (buf);\n\t\treturn NULL;\n\t}\n#endif\n\n#define B(x,y) r_buf_append_bytes(buf,(const ut8*)(x),y)\n#define D(x) r_buf_append_ut32(buf,x)\n#define Z(x) r_buf_append_nbytes(buf,x)\n#define W(x,y,z) r_buf_write_at(buf,x,(const ut8*)(y),z)\n#define WZ(x,y) p_tmp=r_buf_size (buf);Z(x);W(p_tmp,y,strlen(y))\n\n\t/* MACH0 HEADER */\n\tB (\"\\xce\\xfa\\xed\\xfe\", 4); // header\n// 64bit header\tB (\"\\xce\\xfa\\xed\\xfe\", 4); // header\n\tif (is_arm) {\n\t\tD (12); // cpu type (arm)\n\t\tD (3); // subtype (all?)\n\t} else {\n\t\t/* x86-32 */\n\t\tD (7); // cpu type (x86)\n// D(0x1000007); // x86-64\n\t\tD (3); // subtype (i386-all)\n\t}\n\tD (2); // filetype (executable)\n\n\tif (data && dlen > 0) {\n\t\tncmds = 3;\n\t\tcmdsize = 0;\n\t} else {\n\t\tncmds = 2;\n\t\tcmdsize = 0;\n\t}\n\tif (use_pagezero) {\n\t\tncmds++;\n\t}\n\tif (use_dylinker) {\n\t\tncmds++;\n\t\tif (use_linkedit) {\n\t\t\tncmds += 3;\n\t\t}\n\t\tif (use_libsystem) {\n\t\t\tncmds++;\n\t\t}\n\t}\n\n\t/* COMMANDS */\n\tD (ncmds); // ncmds\n\tp_cmdsize = r_buf_size (buf);\n\tD (-1); // cmdsize\n\tD (0); // flags\n\t// D (0x01200085); // alternative flags found in some a.out..\n\tmagiclen = r_buf_size (buf);\n\n\tif (use_pagezero) {\n\t\t/* PAGEZERO */\n\t\tD (1);   // cmd.LC_SEGMENT\n\t\tD (56); // sizeof (cmd)\n\t\tWZ (16, \"__PAGEZERO\");\n\t\tD (0); // vmaddr\n\t\tD (0x00001000); // vmsize XXX\n\t\tD (0); // fileoff\n\t\tD (0); // filesize\n\t\tD (0); // maxprot\n\t\tD (0); // initprot\n\t\tD (0); // nsects\n\t\tD (0); // flags\n\t}\n\n\t/* TEXT SEGMENT */\n\tD (1);   // cmd.LC_SEGMENT\n\tD (124); // sizeof (cmd)\n\tWZ (16, \"__TEXT\");\n\tD (baddr); // vmaddr\n\tD (0x1000); // vmsize XXX\n\tD (0); // fileoff\n\tp_codefsz = r_buf_size (buf);\n\tD (-1); // filesize\n\tD (7); // maxprot\n\tD (5); // initprot\n\tD (1); // nsects\n\tD (0); // flags\n\tWZ (16, \"__text\");\n\tWZ (16, \"__TEXT\");\n\tp_codeva = r_buf_size (buf); // virtual address\n\tD (-1);\n\tp_codesz = r_buf_size (buf); // size of code (end-start)\n\tD (-1);\n\tp_codepa = r_buf_size (buf); // code - baddr\n\tD (-1); //_start-0x1000);\n\tD (0); // align // should be 2 for 64bit\n\tD (0); // reloff\n\tD (0); // nrelocs\n\tD (0); // flags\n\tD (0); // reserved\n\tD (0); // ??\n\n\tif (data && dlen > 0) {\n\t\t/* DATA SEGMENT */\n\t\tD (1); // cmd.LC_SEGMENT\n\t\tD (124); // sizeof (cmd)\n\t\tp_tmp = r_buf_size (buf);\n\t\tZ (16);\n\t\tW (p_tmp, \"__TEXT\", 6); // segment name\n\t\tD (0x2000); // vmaddr\n\t\tD (0x1000); // vmsize\n\t\tD (0); // fileoff\n\t\tp_datafsz = r_buf_size (buf);\n\t\tD (-1); // filesize\n\t\tD (6); // maxprot\n\t\tD (6); // initprot\n\t\tD (1); // nsects\n\t\tD (0); // flags\n\n\t\tWZ (16, \"__data\");\n\t\tWZ (16, \"__DATA\");\n\n\t\tp_datava = r_buf_size (buf);\n\t\tD (-1);\n\t\tp_datasz = r_buf_size (buf);\n\t\tD (-1);\n\t\tp_datapa = r_buf_size (buf);\n\t\tD (-1); //_start-0x1000);\n\t\tD (2); // align\n\t\tD (0); // reloff\n\t\tD (0); // nrelocs\n\t\tD (0); // flags\n\t\tD (0); // reserved\n\t\tD (0);\n\t}\n\n\tif (use_dylinker) {\n\t\tif (use_linkedit) {\n\t\t\t/* LINKEDIT */\n\t\t\tD (1);   // cmd.LC_SEGMENT\n\t\t\tD (56); // sizeof (cmd)\n\t\t\tWZ (16, \"__LINKEDIT\");\n\t\t\tD (0x3000); // vmaddr\n\t\t\tD (0x00001000); // vmsize XXX\n\t\t\tD (0x1000); // fileoff\n\t\t\tD (0); // filesize\n\t\t\tD (7); // maxprot\n\t\t\tD (1); // initprot\n\t\t\tD (0); // nsects\n\t\t\tD (0); // flags\n\n\t\t\t/* LC_SYMTAB */\n\t\t\tD (2); // cmd.LC_SYMTAB\n\t\t\tD (24); // sizeof (cmd)\n\t\t\tD (0x1000); // symtab offset\n\t\t\tD (0); // symtab size\n\t\t\tD (0x1000); // strtab offset\n\t\t\tD (0); // strtab size\n\n\t\t\t/* LC_DYSYMTAB */\n\t\t\tD (0xb); // cmd.LC_DYSYMTAB\n\t\t\tD (80); // sizeof (cmd)\n\t\t\tZ (18 * sizeof (ut32)); // empty\n\t\t}\n\n\t\tconst char *dyld = \"/usr/lib/dyld\";\n\t\tconst int dyld_len = strlen (dyld) + 1;\n\t\tD(0xe); /* LC_DYLINKER */\n\t\tD((4 * 3) + dyld_len);\n\t\tD(dyld_len - 2);\n\t\tWZ(dyld_len, dyld); // path\n\n\t\tif (use_libsystem) {\n\t\t\t/* add libSystem at least ... */\n\t\t\tconst char *lib = \"/usr/lib/libSystem.B.dylib\";\n\t\t\tconst int lib_len = strlen (lib) + 1;\n\t\t\tD (0xc); /* LC_LOAD_DYLIB */\n\t\t\tD (24 + lib_len); // cmdsize\n\t\t\tD (24); // offset where the lib string start\n\t\t\tD (0x2);\n\t\t\tD (0x1);\n\t\t\tD (0x1);\n\t\t\tWZ (lib_len, lib);\n\t\t}\n\t}\n\n\tif (use_main) {\n\t\t/* LC_MAIN */\n\t\tD (0x80000028);   // cmd.LC_MAIN\n\t\tD (24); // sizeof (cmd)\n\t\tD (baddr); // entryoff\n\t\tD (0); // stacksize\n\t\tD (0); // ???\n\t\tD (0); // ???\n\t} else {\n\t\t/* THREAD STATE */\n\t\tD (5); // LC_UNIXTHREAD\n\t\tD (80); // sizeof (cmd)\n\t\tif (is_arm) {\n\t\t\t/* arm */\n\t\t\tD (1); // i386-thread-state\n\t\t\tD (17); // thread-state-count\n\t\t\tp_entry = r_buf_size (buf) + (16 * sizeof (ut32));\n\t\t\tZ (17 * sizeof (ut32));\n\t\t\t// mach0-arm has one byte more\n\t\t} else {\n\t\t\t/* x86-32 */\n\t\t\tD (1); // i386-thread-state\n\t\t\tD (16); // thread-state-count\n\t\t\tp_entry = r_buf_size (buf) + (10 * sizeof (ut32));\n\t\t\tZ (16 * sizeof (ut32));\n\t\t}\n\t}\n\n\t/* padding to make mach_loader checks happy */\n\t/* binaries must be at least of 4KB :( not tiny anymore */\n\tWZ (4096 - r_buf_size (buf), \"\");\n\n\tcmdsize = r_buf_size (buf) - magiclen;\n\tcodeva = r_buf_size (buf) + baddr;\n\tdatava = r_buf_size (buf) + clen + baddr;\n\tif (p_entry != 0) {\n\t\tW (p_entry, &codeva, 4); // set PC\n\t}\n\n\t/* fill header variables */\n\tW (p_cmdsize, &cmdsize, 4);\n\tfilesize = magiclen + cmdsize + clen + dlen;\n\t// TEXT SEGMENT should span the whole file //\n\tW (p_codefsz, &filesize, 4);\n\tW (p_codefsz-8, &filesize, 4); // vmsize = filesize\n\tW (p_codeva, &codeva, 4);\n\t// clen = 4096;\n\tW (p_codesz, &clen, 4);\n\tp_tmp = codeva - baddr;\n\tW (p_codepa, &p_tmp, 4);\n\n\tB (code, clen);\n\n\tif (data && dlen > 0) {\n\t\t/* append data */\n\t\tW (p_datafsz, &filesize, 4);\n\t\tW (p_datava, &datava, 4);\n\t\tW (p_datasz, &dlen, 4);\n\t\tp_tmp = datava - baddr;\n\t\tW (p_datapa, &p_tmp, 4);\n\t\tB (data, dlen);\n\t}\n\n\treturn buf;\n}\n\nstatic RBinAddr *binsym(RBinFile *bf, int sym) {\n\tut64 addr;\n\tRBinAddr *ret = NULL;\n\tswitch (sym) {\n\tcase R_BIN_SYM_MAIN:\n\t\taddr = MACH0_(get_main) (bf->o->bin_obj);\n\t\tif (addr == UT64_MAX || !(ret = R_NEW0 (RBinAddr))) {\n\t\t\treturn NULL;\n\t\t}\n\t\t//if (bf->o->info && bf->o->info->bits == 16) {\n\t\t// align for thumb\n\t\tret->vaddr = ((addr >> 1) << 1);\n\t\t//}\n\t\tret->paddr = ret->vaddr;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic ut64 size(RBinFile *bf) {\n\tut64 off = 0;\n\tut64 len = 0;\n\tif (!bf->o->sections) {\n\t\tRListIter *iter;\n\t\tRBinSection *section;\n\t\tbf->o->sections = sections (bf);\n\t\tr_list_foreach (bf->o->sections, iter, section) {\n\t\t\tif (section->paddr > off) {\n\t\t\t\toff = section->paddr;\n\t\t\t\tlen = section->size;\n\t\t\t}\n\t\t}\n\t}\n\treturn off + len;\n}\n\nRBinPlugin r_bin_plugin_mach0 = {\n\t.name = \"mach0\",\n\t.desc = \"mach0 bin plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.check_buffer = &check_buffer,\n\t.baddr = &baddr,\n\t.binsym = &binsym,\n\t.entries = &entries,\n\t.signature = &entitlements,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.imports = &imports,\n\t.size = &size,\n\t.info = &info,\n\t.header = MACH0_(mach_headerfields),\n\t.fields = MACH0_(mach_fields),\n\t.libs = &libs,\n\t.relocs = &relocs,\n\t.patch_relocs = &patch_relocs,\n\t.create = &create,\n\t.classes = &MACH0_(parse_classes),\n\t.write = &r_bin_write_mach0,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_mach0,\n\t.version = R2_VERSION\n};\n#endif\n#endif\n"], "filenames": ["libr/bin/p/bin_mach0.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [775], "fixing_code_start_loc": [1], "fixing_code_end_loc": [778], "type": "CWE-369", "message": "Radare2 has a division by zero vulnerability in Mach-O parser's rebase_buffer function. This allow attackers to create malicious inputs that can cause denial of service.\n\n\n", "other": {"cve": {"id": "CVE-2021-32494", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2023-07-07T19:15:09.507", "lastModified": "2023-07-13T18:37:47.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Radare2 has a division by zero vulnerability in Mach-O parser's rebase_buffer function. This allow attackers to create malicious inputs that can cause denial of service.\n\n\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:5.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "BAF29F76-DF28-4143-9BF5-FDC0F1CA5B81"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/a07dedb804a82bc01c07072861942dd80c6b6d62", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/radareorg/radare2/issues/18667", "source": "patrick@puiterwijk.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/a07dedb804a82bc01c07072861942dd80c6b6d62"}}