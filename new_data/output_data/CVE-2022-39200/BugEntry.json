{"buggy_code": ["package input\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\tfedapi \"github.com/matrix-org/dendrite/federationapi/api\"\n\t\"github.com/matrix-org/dendrite/internal\"\n\t\"github.com/matrix-org/dendrite/roomserver/api\"\n\t\"github.com/matrix-org/dendrite/roomserver/state\"\n\t\"github.com/matrix-org/dendrite/roomserver/storage\"\n\t\"github.com/matrix-org/dendrite/roomserver/types\"\n\t\"github.com/matrix-org/gomatrixserverlib\"\n\t\"github.com/matrix-org/util\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype parsedRespState struct {\n\tAuthEvents  []*gomatrixserverlib.Event\n\tStateEvents []*gomatrixserverlib.Event\n}\n\nfunc (p *parsedRespState) Events() []*gomatrixserverlib.Event {\n\teventsByID := make(map[string]*gomatrixserverlib.Event, len(p.AuthEvents)+len(p.StateEvents))\n\tfor i, event := range p.AuthEvents {\n\t\teventsByID[event.EventID()] = p.AuthEvents[i]\n\t}\n\tfor i, event := range p.StateEvents {\n\t\teventsByID[event.EventID()] = p.StateEvents[i]\n\t}\n\tallEvents := make([]*gomatrixserverlib.Event, 0, len(eventsByID))\n\tfor _, event := range eventsByID {\n\t\tallEvents = append(allEvents, event)\n\t}\n\treturn gomatrixserverlib.ReverseTopologicalOrdering(allEvents, gomatrixserverlib.TopologicalOrderByAuthEvents)\n}\n\ntype missingStateReq struct {\n\torigin          gomatrixserverlib.ServerName\n\tdb              storage.Database\n\troomInfo        *types.RoomInfo\n\tinputer         *Inputer\n\tkeys            gomatrixserverlib.JSONVerifier\n\tfederation      fedapi.RoomserverFederationAPI\n\troomsMu         *internal.MutexByRoom\n\tservers         []gomatrixserverlib.ServerName\n\thadEvents       map[string]bool\n\thadEventsMutex  sync.Mutex\n\thaveEvents      map[string]*gomatrixserverlib.Event\n\thaveEventsMutex sync.Mutex\n}\n\n// processEventWithMissingState is the entrypoint for a missingStateReq\n// request, as called from processRoomEvent.\n// nolint:gocyclo\nfunc (t *missingStateReq) processEventWithMissingState(\n\tctx context.Context, e *gomatrixserverlib.Event, roomVersion gomatrixserverlib.RoomVersion,\n) (*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"processEventWithMissingState\")\n\tdefer span.Finish()\n\n\t// We are missing the previous events for this events.\n\t// This means that there is a gap in our view of the history of the\n\t// room. There two ways that we can handle such a gap:\n\t//   1) We can fill in the gap using /get_missing_events\n\t//   2) We can leave the gap and request the state of the room at\n\t//      this event from the remote server using either /state_ids\n\t//      or /state.\n\t// Synapse will attempt to do 1 and if that fails or if the gap is\n\t// too large then it will attempt 2.\n\t// Synapse will use /state_ids if possible since usually the state\n\t// is largely unchanged and it is more efficient to fetch a list of\n\t// event ids and then use /event to fetch the individual events.\n\t// However not all version of synapse support /state_ids so you may\n\t// need to fallback to /state.\n\tlogger := util.GetLogger(ctx).WithFields(map[string]interface{}{\n\t\t\"txn_event\":       e.EventID(),\n\t\t\"room_id\":         e.RoomID(),\n\t\t\"txn_prev_events\": e.PrevEventIDs(),\n\t})\n\n\t// Attempt to fill in the gap using /get_missing_events\n\t// This will either:\n\t// - fill in the gap completely then process event `e` returning no backwards extremity\n\t// - fail to fill in the gap and tell us to terminate the transaction err=not nil\n\t// - fail to fill in the gap and tell us to fetch state at the new backwards extremity, and to not terminate the transaction\n\tnewEvents, isGapFilled, prevStatesKnown, err := t.getMissingEvents(ctx, e, roomVersion)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.getMissingEvents: %w\", err)\n\t}\n\tif len(newEvents) == 0 {\n\t\treturn nil, fmt.Errorf(\"expected to find missing events but didn't\")\n\t}\n\tif isGapFilled {\n\t\tlogger.Infof(\"Gap filled by /get_missing_events, injecting %d new events\", len(newEvents))\n\t\t// we can just inject all the newEvents as new as we may have only missed 1 or 2 events and have filled\n\t\t// in the gap in the DAG\n\t\tfor _, newEvent := range newEvents {\n\t\t\terr = t.inputer.processRoomEvent(ctx, &api.InputRoomEvent{\n\t\t\t\tKind:         api.KindOld,\n\t\t\t\tEvent:        newEvent.Headered(roomVersion),\n\t\t\t\tOrigin:       t.origin,\n\t\t\t\tSendAsServer: api.DoNotSendToOtherServers,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif _, ok := err.(types.RejectedError); !ok {\n\t\t\t\t\treturn nil, fmt.Errorf(\"t.inputer.processRoomEvent (filling gap): %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we filled the gap *and* we know the state before the prev events\n\t// then there's nothing else to do, we have everything we need to deal\n\t// with the new event.\n\tif isGapFilled && prevStatesKnown {\n\t\tlogger.Infof(\"Gap filled and state found for all prev events\")\n\t\treturn nil, nil\n\t}\n\n\t// Otherwise, if we've reached this point, it's possible that we've\n\t// either not closed the gap, or we did but we still don't seem to\n\t// know the events before the new event. Start by looking up the\n\t// state at the event at the back of the gap and we'll try to roll\n\t// forward the state first.\n\tbackwardsExtremity := newEvents[0]\n\tnewEvents = newEvents[1:]\n\n\tresolvedState, err := t.lookupResolvedStateBeforeEvent(ctx, backwardsExtremity, roomVersion)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.lookupState (backwards extremity): %w\", err)\n\t}\n\n\thadEvents := map[string]bool{}\n\tt.hadEventsMutex.Lock()\n\tfor k, v := range t.hadEvents {\n\t\thadEvents[k] = v\n\t}\n\tt.hadEventsMutex.Unlock()\n\n\tsendOutliers := func(resolvedState *parsedRespState) error {\n\t\toutliers := resolvedState.Events()\n\t\toutlierRoomEvents := make([]api.InputRoomEvent, 0, len(outliers))\n\t\tfor _, outlier := range outliers {\n\t\t\tif hadEvents[outlier.EventID()] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\toutlierRoomEvents = append(outlierRoomEvents, api.InputRoomEvent{\n\t\t\t\tKind:   api.KindOutlier,\n\t\t\t\tEvent:  outlier.Headered(roomVersion),\n\t\t\t\tOrigin: t.origin,\n\t\t\t})\n\t\t}\n\t\tfor _, ire := range outlierRoomEvents {\n\t\t\tif err = t.inputer.processRoomEvent(ctx, &ire); err != nil {\n\t\t\t\tif _, ok := err.(types.RejectedError); !ok {\n\t\t\t\t\treturn fmt.Errorf(\"t.inputer.processRoomEvent (outlier): %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Send outliers first so we can send the state along with the new backwards\n\t// extremity without any missing auth events.\n\tif err = sendOutliers(resolvedState); err != nil {\n\t\treturn nil, fmt.Errorf(\"sendOutliers: %w\", err)\n\t}\n\n\t// Now send the backward extremity into the roomserver with the\n\t// newly resolved state. This marks the \"oldest\" point in the backfill and\n\t// sets the baseline state for any new events after this.\n\tstateIDs := make([]string, 0, len(resolvedState.StateEvents))\n\tfor _, event := range resolvedState.StateEvents {\n\t\tstateIDs = append(stateIDs, event.EventID())\n\t}\n\n\terr = t.inputer.processRoomEvent(ctx, &api.InputRoomEvent{\n\t\tKind:          api.KindOld,\n\t\tEvent:         backwardsExtremity.Headered(roomVersion),\n\t\tOrigin:        t.origin,\n\t\tHasState:      true,\n\t\tStateEventIDs: stateIDs,\n\t\tSendAsServer:  api.DoNotSendToOtherServers,\n\t})\n\tif err != nil {\n\t\tif _, ok := err.(types.RejectedError); !ok {\n\t\t\treturn nil, fmt.Errorf(\"t.inputer.processRoomEvent (backward extremity): %w\", err)\n\t\t}\n\t}\n\n\t// Then send all of the newer backfilled events, of which will all be newer\n\t// than the backward extremity, into the roomserver without state. This way\n\t// they will automatically fast-forward based on the room state at the\n\t// extremity in the last step.\n\tfor _, newEvent := range newEvents {\n\t\terr = t.inputer.processRoomEvent(ctx, &api.InputRoomEvent{\n\t\t\tKind:         api.KindOld,\n\t\t\tEvent:        newEvent.Headered(roomVersion),\n\t\t\tOrigin:       t.origin,\n\t\t\tSendAsServer: api.DoNotSendToOtherServers,\n\t\t})\n\t\tif err != nil {\n\t\t\tif _, ok := err.(types.RejectedError); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"t.inputer.processRoomEvent (fast forward): %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Finally, check again if we know everything we need to know in order to\n\t// make forward progress. If the prev state is known then we consider the\n\t// rolled forward state to be sufficient \u2014 we now know all of the state\n\t// before the prev events. If we don't then we need to look up the state\n\t// before the new event as well, otherwise we will never make any progress.\n\tif t.isPrevStateKnown(ctx, e) {\n\t\treturn nil, nil\n\t}\n\n\t// If we still haven't got the state for the prev events then we'll go and\n\t// ask the federation for it if needed.\n\tresolvedState, err = t.lookupResolvedStateBeforeEvent(ctx, e, roomVersion)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.lookupState (new event): %w\", err)\n\t}\n\n\t// Send the outliers for the retrieved state.\n\tif err = sendOutliers(resolvedState); err != nil {\n\t\treturn nil, fmt.Errorf(\"sendOutliers: %w\", err)\n\t}\n\n\t// Then return the resolved state, for which the caller can replace the\n\t// HasState with the event IDs to create a new state snapshot when we\n\t// process the new event.\n\treturn resolvedState, nil\n}\n\nfunc (t *missingStateReq) lookupResolvedStateBeforeEvent(ctx context.Context, e *gomatrixserverlib.Event, roomVersion gomatrixserverlib.RoomVersion) (*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupResolvedStateBeforeEvent\")\n\tdefer span.Finish()\n\n\ttype respState struct {\n\t\t// A snapshot is considered trustworthy if it came from our own roomserver.\n\t\t// That's because the state will have been through state resolution once\n\t\t// already in QueryStateAfterEvent.\n\t\ttrustworthy bool\n\t\t*parsedRespState\n\t}\n\n\t// at this point we know we're going to have a gap: we need to work out the room state at the new backwards extremity.\n\t// Therefore, we cannot just query /state_ids with this event to get the state before. Instead, we need to query\n\t// the state AFTER all the prev_events for this event, then apply state resolution to that to get the state before the event.\n\tvar states []*respState\n\tfor _, prevEventID := range e.PrevEventIDs() {\n\t\t// Look up what the state is after the backward extremity. This will either\n\t\t// come from the roomserver, if we know all the required events, or it will\n\t\t// come from a remote server via /state_ids if not.\n\t\tprevState, trustworthy, err := t.lookupStateAfterEvent(ctx, roomVersion, e.RoomID(), prevEventID)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"t.lookupStateAfterEvent: %w\", err)\n\t\t}\n\t\t// Append the state onto the collected state. We'll run this through the\n\t\t// state resolution next.\n\t\tstates = append(states, &respState{trustworthy, prevState})\n\t}\n\n\t// Now that we have collected all of the state from the prev_events, we'll\n\t// run the state through the appropriate state resolution algorithm for the\n\t// room if needed. This does a couple of things:\n\t// 1. Ensures that the state is deduplicated fully for each state-key tuple\n\t// 2. Ensures that we pick the latest events from both sets, in the case that\n\t//    one of the prev_events is quite a bit older than the others\n\tresolvedState := &parsedRespState{}\n\tswitch len(states) {\n\tcase 0:\n\t\textremityIsCreate := e.Type() == gomatrixserverlib.MRoomCreate && e.StateKeyEquals(\"\")\n\t\tif !extremityIsCreate {\n\t\t\t// There are no previous states and this isn't the beginning of the\n\t\t\t// room - this is an error condition!\n\t\t\treturn nil, fmt.Errorf(\"expected %d states but got %d\", len(e.PrevEventIDs()), len(states))\n\t\t}\n\tcase 1:\n\t\t// There's only one previous state - if it's trustworthy (came from a\n\t\t// local state snapshot which will already have been through state res),\n\t\t// use it as-is. There's no point in resolving it again. Only trust a\n\t\t// trustworthy state snapshot if it actually contains some state for all\n\t\t// non-create events, otherwise we need to resolve what came from federation.\n\t\tisCreate := e.Type() == gomatrixserverlib.MRoomCreate && e.StateKeyEquals(\"\")\n\t\tif states[0].trustworthy && (isCreate || len(states[0].StateEvents) > 0) {\n\t\t\tresolvedState = states[0].parsedRespState\n\t\t\tbreak\n\t\t}\n\t\t// Otherwise, if it isn't trustworthy (came from federation), run it through\n\t\t// state resolution anyway for safety, in case there are duplicates.\n\t\tfallthrough\n\tdefault:\n\t\trespStates := make([]*parsedRespState, len(states))\n\t\tfor i := range states {\n\t\t\trespStates[i] = states[i].parsedRespState\n\t\t}\n\t\t// There's more than one previous state - run them all through state res\n\t\tvar err error\n\t\tt.roomsMu.Lock(e.RoomID())\n\t\tresolvedState, err = t.resolveStatesAndCheck(ctx, roomVersion, respStates, e)\n\t\tt.roomsMu.Unlock(e.RoomID())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"t.resolveStatesAndCheck: %w\", err)\n\t\t}\n\t}\n\n\treturn resolvedState, nil\n}\n\n// lookupStateAfterEvent returns the room state after `eventID`, which is the state before eventID with the state of `eventID` (if it's a state event)\n// added into the mix.\nfunc (t *missingStateReq) lookupStateAfterEvent(ctx context.Context, roomVersion gomatrixserverlib.RoomVersion, roomID, eventID string) (*parsedRespState, bool, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupStateAfterEvent\")\n\tdefer span.Finish()\n\n\t// try doing all this locally before we resort to querying federation\n\trespState := t.lookupStateAfterEventLocally(ctx, roomID, eventID)\n\tif respState != nil {\n\t\treturn respState, true, nil\n\t}\n\n\tlogrus.WithContext(ctx).Warnf(\"State for event %s not available locally, falling back to federation (via %d servers)\", eventID, len(t.servers))\n\trespState, err := t.lookupStateBeforeEvent(ctx, roomVersion, roomID, eventID)\n\tif err != nil {\n\t\tlogrus.WithContext(ctx).WithError(err).Errorf(\"Failed to look up state before event %s\", eventID)\n\t\treturn nil, false, fmt.Errorf(\"t.lookupStateBeforeEvent: %w\", err)\n\t}\n\n\t// fetch the event we're missing and add it to the pile\n\th, err := t.lookupEvent(ctx, roomVersion, roomID, eventID, false)\n\tswitch err.(type) {\n\tcase verifySigError:\n\t\treturn respState, false, nil\n\tcase nil:\n\t\t// do nothing\n\tdefault:\n\t\tlogrus.WithContext(ctx).WithError(err).Errorf(\"Failed to look up event %s\", eventID)\n\t\treturn nil, false, fmt.Errorf(\"t.lookupEvent: %w\", err)\n\t}\n\th = t.cacheAndReturn(h)\n\tif h.StateKey() != nil {\n\t\taddedToState := false\n\t\tfor i := range respState.StateEvents {\n\t\t\tse := respState.StateEvents[i]\n\t\t\tif se.Type() == h.Type() && se.StateKeyEquals(*h.StateKey()) {\n\t\t\t\trespState.StateEvents[i] = h\n\t\t\t\taddedToState = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !addedToState {\n\t\t\trespState.StateEvents = append(respState.StateEvents, h)\n\t\t}\n\t}\n\n\treturn respState, false, nil\n}\n\nfunc (t *missingStateReq) cacheAndReturn(ev *gomatrixserverlib.Event) *gomatrixserverlib.Event {\n\tt.haveEventsMutex.Lock()\n\tdefer t.haveEventsMutex.Unlock()\n\tif cached, exists := t.haveEvents[ev.EventID()]; exists {\n\t\treturn cached\n\t}\n\tt.haveEvents[ev.EventID()] = ev\n\treturn ev\n}\n\nfunc (t *missingStateReq) lookupStateAfterEventLocally(ctx context.Context, roomID, eventID string) *parsedRespState {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupStateAfterEventLocally\")\n\tdefer span.Finish()\n\n\tvar res parsedRespState\n\troomState := state.NewStateResolution(t.db, t.roomInfo)\n\tstateAtEvents, err := t.db.StateAtEventIDs(ctx, []string{eventID})\n\tif err != nil {\n\t\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).WithError(err).Warnf(\"failed to get state after %s locally\", eventID)\n\t\treturn nil\n\t}\n\tstateEntries, err := roomState.LoadCombinedStateAfterEvents(ctx, stateAtEvents)\n\tif err != nil {\n\t\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).WithError(err).Warnf(\"failed to load combined state after %s locally\", eventID)\n\t\treturn nil\n\t}\n\tstateEventNIDs := make([]types.EventNID, 0, len(stateEntries))\n\tfor _, entry := range stateEntries {\n\t\tstateEventNIDs = append(stateEventNIDs, entry.EventNID)\n\t}\n\tstateEvents, err := t.db.Events(ctx, stateEventNIDs)\n\tif err != nil {\n\t\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).WithError(err).Warnf(\"failed to load state events locally\")\n\t\treturn nil\n\t}\n\tres.StateEvents = make([]*gomatrixserverlib.Event, 0, len(stateEvents))\n\tfor _, ev := range stateEvents {\n\t\t// set the event from the haveEvents cache - this means we will share pointers with other prev_event branches for this\n\t\t// processEvent request, which is better for memory.\n\t\tres.StateEvents = append(res.StateEvents, t.cacheAndReturn(ev.Event))\n\t\tt.hadEvent(ev.EventID())\n\t}\n\n\t// encourage GC\n\tstateEvents, stateEventNIDs, stateEntries, stateAtEvents = nil, nil, nil, nil // nolint:ineffassign\n\n\tmissingAuthEvents := map[string]bool{}\n\tres.AuthEvents = make([]*gomatrixserverlib.Event, 0, len(stateEvents)*3)\n\tfor _, ev := range stateEvents {\n\t\tt.haveEventsMutex.Lock()\n\t\tfor _, ae := range ev.AuthEventIDs() {\n\t\t\tif aev, ok := t.haveEvents[ae]; ok {\n\t\t\t\tres.AuthEvents = append(res.AuthEvents, aev)\n\t\t\t} else {\n\t\t\t\tmissingAuthEvents[ae] = true\n\t\t\t}\n\t\t}\n\t\tt.haveEventsMutex.Unlock()\n\t}\n\t// QueryStateAfterEvents does not return the auth events, so fetch them now. We know the roomserver has them else it wouldn't\n\t// have stored the event.\n\tif len(missingAuthEvents) > 0 {\n\t\tvar missingEventList []string\n\t\tfor evID := range missingAuthEvents {\n\t\t\tmissingEventList = append(missingEventList, evID)\n\t\t}\n\t\tutil.GetLogger(ctx).WithField(\"count\", len(missingEventList)).Debugf(\"Fetching missing auth events\")\n\t\tevents, err := t.db.EventsFromIDs(ctx, missingEventList)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tfor i, ev := range events {\n\t\t\tres.AuthEvents = append(res.AuthEvents, t.cacheAndReturn(events[i].Event))\n\t\t\tt.hadEvent(ev.EventID())\n\t\t}\n\t}\n\n\treturn &res\n}\n\n// lookuptStateBeforeEvent returns the room state before the event e, which is just /state_ids and/or /state depending on what\n// the server supports.\nfunc (t *missingStateReq) lookupStateBeforeEvent(ctx context.Context, roomVersion gomatrixserverlib.RoomVersion, roomID, eventID string) (\n\t*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupStateBeforeEvent\")\n\tdefer span.Finish()\n\n\t// Attempt to fetch the missing state using /state_ids and /events\n\treturn t.lookupMissingStateViaStateIDs(ctx, roomID, eventID, roomVersion)\n}\n\nfunc (t *missingStateReq) resolveStatesAndCheck(ctx context.Context, roomVersion gomatrixserverlib.RoomVersion, states []*parsedRespState, backwardsExtremity *gomatrixserverlib.Event) (*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"resolveStatesAndCheck\")\n\tdefer span.Finish()\n\n\tvar authEventList []*gomatrixserverlib.Event\n\tvar stateEventList []*gomatrixserverlib.Event\n\tfor _, state := range states {\n\t\tauthEventList = append(authEventList, state.AuthEvents...)\n\t\tstateEventList = append(stateEventList, state.StateEvents...)\n\t}\n\tresolvedStateEvents, err := gomatrixserverlib.ResolveConflicts(roomVersion, stateEventList, authEventList)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// apply the current event\nretryAllowedState:\n\tif err = checkAllowedByState(backwardsExtremity, resolvedStateEvents); err != nil {\n\t\tswitch missing := err.(type) {\n\t\tcase gomatrixserverlib.MissingAuthEventError:\n\t\t\th, err2 := t.lookupEvent(ctx, roomVersion, backwardsExtremity.RoomID(), missing.AuthEventID, true)\n\t\t\tswitch err2.(type) {\n\t\t\tcase verifySigError:\n\t\t\t\treturn &parsedRespState{\n\t\t\t\t\tAuthEvents:  authEventList,\n\t\t\t\t\tStateEvents: resolvedStateEvents,\n\t\t\t\t}, nil\n\t\t\tcase nil:\n\t\t\t\t// do nothing\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"missing auth event %s and failed to look it up: %w\", missing.AuthEventID, err2)\n\t\t\t}\n\t\t\tutil.GetLogger(ctx).Tracef(\"fetched event %s\", missing.AuthEventID)\n\t\t\tresolvedStateEvents = append(resolvedStateEvents, h)\n\t\t\tgoto retryAllowedState\n\t\tdefault:\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &parsedRespState{\n\t\tAuthEvents:  authEventList,\n\t\tStateEvents: resolvedStateEvents,\n\t}, nil\n}\n\n// get missing events for `e`. If `isGapFilled`=true then `newEvents` contains all the events to inject,\n// without `e`. If `isGapFilled=false` then `newEvents` contains the response to /get_missing_events\nfunc (t *missingStateReq) getMissingEvents(ctx context.Context, e *gomatrixserverlib.Event, roomVersion gomatrixserverlib.RoomVersion) (newEvents []*gomatrixserverlib.Event, isGapFilled, prevStateKnown bool, err error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"getMissingEvents\")\n\tdefer span.Finish()\n\n\tlogger := util.GetLogger(ctx).WithField(\"event_id\", e.EventID()).WithField(\"room_id\", e.RoomID())\n\tlatest, _, _, err := t.db.LatestEventIDs(ctx, t.roomInfo.RoomNID)\n\tif err != nil {\n\t\treturn nil, false, false, fmt.Errorf(\"t.DB.LatestEventIDs: %w\", err)\n\t}\n\tlatestEvents := make([]string, len(latest))\n\tfor i, ev := range latest {\n\t\tlatestEvents[i] = ev.EventID\n\t\tt.hadEvent(ev.EventID)\n\t}\n\n\tvar missingResp *gomatrixserverlib.RespMissingEvents\n\tfor _, server := range t.servers {\n\t\tvar m gomatrixserverlib.RespMissingEvents\n\t\tif m, err = t.federation.LookupMissingEvents(ctx, server, e.RoomID(), gomatrixserverlib.MissingEvents{\n\t\t\tLimit: 20,\n\t\t\t// The latest event IDs that the sender already has. These are skipped when retrieving the previous events of latest_events.\n\t\t\tEarliestEvents: latestEvents,\n\t\t\t// The event IDs to retrieve the previous events for.\n\t\t\tLatestEvents: []string{e.EventID()},\n\t\t}, roomVersion); err == nil {\n\t\t\tmissingResp = &m\n\t\t\tbreak\n\t\t} else {\n\t\t\tlogger.WithError(err).Warnf(\"%s pushed us an event but %q did not respond to /get_missing_events\", t.origin, server)\n\t\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done(): // the parent request context timed out\n\t\t\t\t\treturn nil, false, false, context.DeadlineExceeded\n\t\t\t\tdefault: // this request exceed its own timeout\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif missingResp == nil {\n\t\tlogger.WithError(err).Warnf(\n\t\t\t\"%s pushed us an event but %d server(s) couldn't give us details about prev_events via /get_missing_events - dropping this event until it can\",\n\t\t\tt.origin, len(t.servers),\n\t\t)\n\t\treturn nil, false, false, missingPrevEventsError{\n\t\t\teventID: e.EventID(),\n\t\t\terr:     err,\n\t\t}\n\t}\n\n\t// Make sure events from the missingResp are using the cache - missing events\n\t// will be added and duplicates will be removed.\n\tlogger.Debugf(\"get_missing_events returned %d events\", len(missingResp.Events))\n\tmissingEvents := make([]*gomatrixserverlib.Event, 0, len(missingResp.Events))\n\tfor _, ev := range missingResp.Events.UntrustedEvents(roomVersion) {\n\t\tmissingEvents = append(missingEvents, t.cacheAndReturn(ev))\n\t}\n\n\t// topologically sort and sanity check that we are making forward progress\n\tnewEvents = gomatrixserverlib.ReverseTopologicalOrdering(missingEvents, gomatrixserverlib.TopologicalOrderByPrevEvents)\n\tshouldHaveSomeEventIDs := e.PrevEventIDs()\n\thasPrevEvent := false\nEvent:\n\tfor _, pe := range shouldHaveSomeEventIDs {\n\t\tfor _, ev := range newEvents {\n\t\t\tif ev.EventID() == pe {\n\t\t\t\thasPrevEvent = true\n\t\t\t\tbreak Event\n\t\t\t}\n\t\t}\n\t}\n\tif !hasPrevEvent {\n\t\terr = fmt.Errorf(\"called /get_missing_events but server %s didn't return any prev_events with IDs %v\", t.origin, shouldHaveSomeEventIDs)\n\t\tlogger.WithError(err).Warnf(\n\t\t\t\"%s pushed us an event but couldn't give us details about prev_events via /get_missing_events - dropping this event until it can\",\n\t\t\tt.origin,\n\t\t)\n\t\treturn nil, false, false, missingPrevEventsError{\n\t\t\teventID: e.EventID(),\n\t\t\terr:     err,\n\t\t}\n\t}\n\tif len(newEvents) == 0 {\n\t\treturn nil, false, false, nil // TODO: error instead?\n\t}\n\n\tearliestNewEvent := newEvents[0]\n\n\t// If we retrieved back to the beginning of the room then there's nothing else\n\t// to do - we closed the gap.\n\tif len(earliestNewEvent.PrevEventIDs()) == 0 && earliestNewEvent.Type() == gomatrixserverlib.MRoomCreate && earliestNewEvent.StateKeyEquals(\"\") {\n\t\treturn newEvents, true, t.isPrevStateKnown(ctx, e), nil\n\t}\n\n\t// If our backward extremity was not a known event to us then we obviously didn't\n\t// close the gap.\n\tif state, err := t.db.StateAtEventIDs(ctx, []string{earliestNewEvent.EventID()}); err != nil || len(state) == 0 && state[0].BeforeStateSnapshotNID == 0 {\n\t\treturn newEvents, false, false, nil\n\t}\n\n\t// At this point we are satisfied that we know the state both at the earliest\n\t// retrieved event and at the prev events of the new event.\n\treturn newEvents, true, t.isPrevStateKnown(ctx, e), nil\n}\n\nfunc (t *missingStateReq) isPrevStateKnown(ctx context.Context, e *gomatrixserverlib.Event) bool {\n\texpected := len(e.PrevEventIDs())\n\tstate, err := t.db.StateAtEventIDs(ctx, e.PrevEventIDs())\n\tif err != nil || len(state) != expected {\n\t\t// We didn't get as many state snapshots as we expected, or there was an error,\n\t\t// so we haven't completely solved the problem for the new event.\n\t\treturn false\n\t}\n\t// Check to see if we have a populated state snapshot for all of the prev events.\n\tfor _, stateAtEvent := range state {\n\t\tif stateAtEvent.BeforeStateSnapshotNID == 0 {\n\t\t\t// One of the prev events still has unknown state, so we haven't really\n\t\t\t// solved the problem.\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (t *missingStateReq) lookupMissingStateViaState(\n\tctx context.Context, roomID, eventID string, roomVersion gomatrixserverlib.RoomVersion,\n) (respState *parsedRespState, err error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupMissingStateViaState\")\n\tdefer span.Finish()\n\n\tstate, err := t.federation.LookupState(ctx, t.origin, roomID, eventID, roomVersion)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check that the returned state is valid.\n\tauthEvents, stateEvents, err := state.Check(ctx, roomVersion, t.keys, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparsedState := &parsedRespState{\n\t\tAuthEvents:  authEvents,\n\t\tStateEvents: stateEvents,\n\t}\n\t// Cache the results of this state lookup and deduplicate anything we already\n\t// have in the cache, freeing up memory.\n\t// We load these as trusted as we called state.Check before which loaded them as untrusted.\n\tfor i, evJSON := range state.AuthEvents {\n\t\tev, _ := gomatrixserverlib.NewEventFromTrustedJSON(evJSON, false, roomVersion)\n\t\tparsedState.AuthEvents[i] = t.cacheAndReturn(ev)\n\t}\n\tfor i, evJSON := range state.StateEvents {\n\t\tev, _ := gomatrixserverlib.NewEventFromTrustedJSON(evJSON, false, roomVersion)\n\t\tparsedState.StateEvents[i] = t.cacheAndReturn(ev)\n\t}\n\treturn parsedState, nil\n}\n\nfunc (t *missingStateReq) lookupMissingStateViaStateIDs(ctx context.Context, roomID, eventID string, roomVersion gomatrixserverlib.RoomVersion) (\n\t*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupMissingStateViaStateIDs\")\n\tdefer span.Finish()\n\n\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).Infof(\"lookupMissingStateViaStateIDs %s\", eventID)\n\t// fetch the state event IDs at the time of the event\n\tvar stateIDs gomatrixserverlib.RespStateIDs\n\tvar err error\n\tcount := 0\n\ttotalctx, totalcancel := context.WithTimeout(ctx, time.Minute*5)\n\tfor _, serverName := range t.servers {\n\t\treqctx, reqcancel := context.WithTimeout(totalctx, time.Second*20)\n\t\tstateIDs, err = t.federation.LookupStateIDs(reqctx, serverName, roomID, eventID)\n\t\treqcancel()\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tcount++\n\t}\n\ttotalcancel()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.federation.LookupStateIDs tried %d server(s), last error: %w\", count, err)\n\t}\n\t// work out which auth/state IDs are missing\n\twantIDs := append(stateIDs.StateEventIDs, stateIDs.AuthEventIDs...)\n\tmissing := make(map[string]bool)\n\tvar missingEventList []string\n\tt.haveEventsMutex.Lock()\n\tfor _, sid := range wantIDs {\n\t\tif _, ok := t.haveEvents[sid]; !ok {\n\t\t\tif !missing[sid] {\n\t\t\t\tmissing[sid] = true\n\t\t\t\tmissingEventList = append(missingEventList, sid)\n\t\t\t}\n\t\t}\n\t}\n\tt.haveEventsMutex.Unlock()\n\n\tevents, err := t.db.EventsFromIDs(ctx, missingEventList)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.db.EventsFromIDs: %w\", err)\n\t}\n\n\tfor i, ev := range events {\n\t\tevents[i].Event = t.cacheAndReturn(events[i].Event)\n\t\tt.hadEvent(ev.EventID())\n\t\tevID := events[i].EventID()\n\t\tif missing[evID] {\n\t\t\tdelete(missing, evID)\n\t\t}\n\t}\n\n\t// encourage GC\n\tevents = nil // nolint:ineffassign\n\n\tconcurrentRequests := 8\n\tmissingCount := len(missing)\n\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).WithField(\"event_id\", eventID).Debugf(\"lookupMissingStateViaStateIDs missing %d/%d events\", missingCount, len(wantIDs))\n\n\t// If over 50% of the auth/state events from /state_ids are missing\n\t// then we'll just call /state instead, otherwise we'll just end up\n\t// hammering the remote side with /event requests unnecessarily.\n\tif missingCount > concurrentRequests && missingCount > len(wantIDs)/2 {\n\t\tutil.GetLogger(ctx).WithFields(logrus.Fields{\n\t\t\t\"missing\":           missingCount,\n\t\t\t\"event_id\":          eventID,\n\t\t\t\"room_id\":           roomID,\n\t\t\t\"total_state\":       len(stateIDs.StateEventIDs),\n\t\t\t\"total_auth_events\": len(stateIDs.AuthEventIDs),\n\t\t}).Debug(\"Fetching all state at event\")\n\t\treturn t.lookupMissingStateViaState(ctx, roomID, eventID, roomVersion)\n\t}\n\n\tif missingCount > 0 {\n\t\tutil.GetLogger(ctx).WithFields(logrus.Fields{\n\t\t\t\"missing\":             missingCount,\n\t\t\t\"event_id\":            eventID,\n\t\t\t\"room_id\":             roomID,\n\t\t\t\"total_state\":         len(stateIDs.StateEventIDs),\n\t\t\t\"total_auth_events\":   len(stateIDs.AuthEventIDs),\n\t\t\t\"concurrent_requests\": concurrentRequests,\n\t\t}).Debug(\"Fetching missing state at event\")\n\n\t\t// Create a queue containing all of the missing event IDs that we want\n\t\t// to retrieve.\n\t\tpending := make(chan string, missingCount)\n\t\tfor missingEventID := range missing {\n\t\t\tpending <- missingEventID\n\t\t}\n\t\tclose(pending)\n\n\t\t// Define how many workers we should start to do this.\n\t\tif missingCount < concurrentRequests {\n\t\t\tconcurrentRequests = missingCount\n\t\t}\n\n\t\t// Create the wait group.\n\t\tvar fetchgroup sync.WaitGroup\n\t\tfetchgroup.Add(concurrentRequests)\n\n\t\t// This is the only place where we'll write to t.haveEvents from\n\t\t// multiple goroutines, and everywhere else is blocked on this\n\t\t// synchronous function anyway.\n\t\tvar haveEventsMutex sync.Mutex\n\n\t\t// Define what we'll do in order to fetch the missing event ID.\n\t\tfetch := func(missingEventID string) {\n\t\t\th, herr := t.lookupEvent(ctx, roomVersion, roomID, missingEventID, false)\n\t\t\tswitch herr.(type) {\n\t\t\tcase verifySigError:\n\t\t\t\treturn\n\t\t\tcase nil:\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tutil.GetLogger(ctx).WithFields(logrus.Fields{\n\t\t\t\t\t\"event_id\": missingEventID,\n\t\t\t\t\t\"room_id\":  roomID,\n\t\t\t\t}).WithError(herr).Warn(\"Failed to fetch missing event\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\thaveEventsMutex.Lock()\n\t\t\tt.cacheAndReturn(h)\n\t\t\thaveEventsMutex.Unlock()\n\t\t}\n\n\t\t// Create the worker.\n\t\tworker := func(ch <-chan string) {\n\t\t\tdefer fetchgroup.Done()\n\t\t\tfor missingEventID := range ch {\n\t\t\t\tfetch(missingEventID)\n\t\t\t}\n\t\t}\n\n\t\t// Start the workers.\n\t\tfor i := 0; i < concurrentRequests; i++ {\n\t\t\tgo worker(pending)\n\t\t}\n\n\t\t// Wait for the workers to finish.\n\t\tfetchgroup.Wait()\n\t}\n\n\tresp, err := t.createRespStateFromStateIDs(stateIDs)\n\treturn resp, err\n}\n\nfunc (t *missingStateReq) createRespStateFromStateIDs(\n\tstateIDs gomatrixserverlib.RespStateIDs,\n) (*parsedRespState, error) { // nolint:unparam\n\tt.haveEventsMutex.Lock()\n\tdefer t.haveEventsMutex.Unlock()\n\n\t// create a RespState response using the response to /state_ids as a guide\n\trespState := parsedRespState{}\n\n\tfor i := range stateIDs.StateEventIDs {\n\t\tev, ok := t.haveEvents[stateIDs.StateEventIDs[i]]\n\t\tif !ok {\n\t\t\tlogrus.Tracef(\"Missing state event in createRespStateFromStateIDs: %s\", stateIDs.StateEventIDs[i])\n\t\t\tcontinue\n\t\t}\n\t\trespState.StateEvents = append(respState.StateEvents, ev)\n\t}\n\tfor i := range stateIDs.AuthEventIDs {\n\t\tev, ok := t.haveEvents[stateIDs.AuthEventIDs[i]]\n\t\tif !ok {\n\t\t\tlogrus.Tracef(\"Missing auth event in createRespStateFromStateIDs: %s\", stateIDs.AuthEventIDs[i])\n\t\t\tcontinue\n\t\t}\n\t\trespState.AuthEvents = append(respState.AuthEvents, ev)\n\t}\n\t// We purposefully do not do auth checks on the returned events, as they will still\n\t// be processed in the exact same way, just as a 'rejected' event\n\t// TODO: Add a field to HeaderedEvent to indicate if the event is rejected.\n\treturn &respState, nil\n}\n\nfunc (t *missingStateReq) lookupEvent(ctx context.Context, roomVersion gomatrixserverlib.RoomVersion, _, missingEventID string, localFirst bool) (*gomatrixserverlib.Event, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupEvent\")\n\tdefer span.Finish()\n\n\tif localFirst {\n\t\t// fetch from the roomserver\n\t\tevents, err := t.db.EventsFromIDs(ctx, []string{missingEventID})\n\t\tif err != nil {\n\t\t\tutil.GetLogger(ctx).Warnf(\"Failed to query roomserver for missing event %s: %s - falling back to remote\", missingEventID, err)\n\t\t} else if len(events) == 1 {\n\t\t\treturn events[0].Event, nil\n\t\t}\n\t}\n\tvar event *gomatrixserverlib.Event\n\tfound := false\n\tfor _, serverName := range t.servers {\n\t\treqctx, cancel := context.WithTimeout(ctx, time.Second*30)\n\t\tdefer cancel()\n\t\ttxn, err := t.federation.GetEvent(reqctx, serverName, missingEventID)\n\t\tif err != nil || len(txn.PDUs) == 0 {\n\t\t\tutil.GetLogger(ctx).WithError(err).WithField(\"event_id\", missingEventID).Warn(\"Failed to get missing /event for event ID\")\n\t\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\tselect {\n\t\t\t\tcase <-reqctx.Done(): // this server took too long\n\t\t\t\t\tcontinue\n\t\t\t\tcase <-ctx.Done(): // the input request timed out\n\t\t\t\t\treturn nil, context.DeadlineExceeded\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tevent, err = gomatrixserverlib.NewEventFromUntrustedJSON(txn.PDUs[0], roomVersion)\n\t\tif err != nil {\n\t\t\tutil.GetLogger(ctx).WithError(err).WithField(\"event_id\", missingEventID).Warnf(\"Failed to parse event JSON of event returned from /event\")\n\t\t\tcontinue\n\t\t}\n\t\tfound = true\n\t\tbreak\n\t}\n\tif !found {\n\t\tutil.GetLogger(ctx).WithField(\"event_id\", missingEventID).Warnf(\"Failed to get missing /event for event ID from %d server(s)\", len(t.servers))\n\t\treturn nil, fmt.Errorf(\"wasn't able to find event via %d server(s)\", len(t.servers))\n\t}\n\tif err := event.VerifyEventSignatures(ctx, t.keys); err != nil {\n\t\tutil.GetLogger(ctx).WithError(err).Warnf(\"Couldn't validate signature of event %q from /event\", event.EventID())\n\t\treturn nil, verifySigError{event.EventID(), err}\n\t}\n\treturn t.cacheAndReturn(event), nil\n}\n\nfunc checkAllowedByState(e *gomatrixserverlib.Event, stateEvents []*gomatrixserverlib.Event) error {\n\tauthUsingState := gomatrixserverlib.NewAuthEvents(nil)\n\tfor i := range stateEvents {\n\t\terr := authUsingState.AddEvent(stateEvents[i])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn gomatrixserverlib.Allowed(e, &authUsingState)\n}\n\nfunc (t *missingStateReq) hadEvent(eventID string) {\n\tt.hadEventsMutex.Lock()\n\tdefer t.hadEventsMutex.Unlock()\n\tt.hadEvents[eventID] = true\n}\n\ntype verifySigError struct {\n\teventID string\n\terr     error\n}\ntype missingPrevEventsError struct {\n\teventID string\n\terr     error\n}\n\nfunc (e verifySigError) Error() string {\n\treturn fmt.Sprintf(\"unable to verify signature of event %q: %s\", e.eventID, e.err)\n}\nfunc (e missingPrevEventsError) Error() string {\n\treturn fmt.Sprintf(\"unable to get prev_events for event %q: %s\", e.eventID, e.err)\n}\n"], "fixing_code": ["package input\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\tfedapi \"github.com/matrix-org/dendrite/federationapi/api\"\n\t\"github.com/matrix-org/dendrite/internal\"\n\t\"github.com/matrix-org/dendrite/roomserver/api\"\n\t\"github.com/matrix-org/dendrite/roomserver/state\"\n\t\"github.com/matrix-org/dendrite/roomserver/storage\"\n\t\"github.com/matrix-org/dendrite/roomserver/types\"\n\t\"github.com/matrix-org/gomatrixserverlib\"\n\t\"github.com/matrix-org/util\"\n\t\"github.com/opentracing/opentracing-go\"\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype parsedRespState struct {\n\tAuthEvents  []*gomatrixserverlib.Event\n\tStateEvents []*gomatrixserverlib.Event\n}\n\nfunc (p *parsedRespState) Events() []*gomatrixserverlib.Event {\n\teventsByID := make(map[string]*gomatrixserverlib.Event, len(p.AuthEvents)+len(p.StateEvents))\n\tfor i, event := range p.AuthEvents {\n\t\teventsByID[event.EventID()] = p.AuthEvents[i]\n\t}\n\tfor i, event := range p.StateEvents {\n\t\teventsByID[event.EventID()] = p.StateEvents[i]\n\t}\n\tallEvents := make([]*gomatrixserverlib.Event, 0, len(eventsByID))\n\tfor _, event := range eventsByID {\n\t\tallEvents = append(allEvents, event)\n\t}\n\treturn gomatrixserverlib.ReverseTopologicalOrdering(allEvents, gomatrixserverlib.TopologicalOrderByAuthEvents)\n}\n\ntype missingStateReq struct {\n\torigin          gomatrixserverlib.ServerName\n\tdb              storage.Database\n\troomInfo        *types.RoomInfo\n\tinputer         *Inputer\n\tkeys            gomatrixserverlib.JSONVerifier\n\tfederation      fedapi.RoomserverFederationAPI\n\troomsMu         *internal.MutexByRoom\n\tservers         []gomatrixserverlib.ServerName\n\thadEvents       map[string]bool\n\thadEventsMutex  sync.Mutex\n\thaveEvents      map[string]*gomatrixserverlib.Event\n\thaveEventsMutex sync.Mutex\n}\n\n// processEventWithMissingState is the entrypoint for a missingStateReq\n// request, as called from processRoomEvent.\n// nolint:gocyclo\nfunc (t *missingStateReq) processEventWithMissingState(\n\tctx context.Context, e *gomatrixserverlib.Event, roomVersion gomatrixserverlib.RoomVersion,\n) (*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"processEventWithMissingState\")\n\tdefer span.Finish()\n\n\t// We are missing the previous events for this events.\n\t// This means that there is a gap in our view of the history of the\n\t// room. There two ways that we can handle such a gap:\n\t//   1) We can fill in the gap using /get_missing_events\n\t//   2) We can leave the gap and request the state of the room at\n\t//      this event from the remote server using either /state_ids\n\t//      or /state.\n\t// Synapse will attempt to do 1 and if that fails or if the gap is\n\t// too large then it will attempt 2.\n\t// Synapse will use /state_ids if possible since usually the state\n\t// is largely unchanged and it is more efficient to fetch a list of\n\t// event ids and then use /event to fetch the individual events.\n\t// However not all version of synapse support /state_ids so you may\n\t// need to fallback to /state.\n\tlogger := util.GetLogger(ctx).WithFields(map[string]interface{}{\n\t\t\"txn_event\":       e.EventID(),\n\t\t\"room_id\":         e.RoomID(),\n\t\t\"txn_prev_events\": e.PrevEventIDs(),\n\t})\n\n\t// Attempt to fill in the gap using /get_missing_events\n\t// This will either:\n\t// - fill in the gap completely then process event `e` returning no backwards extremity\n\t// - fail to fill in the gap and tell us to terminate the transaction err=not nil\n\t// - fail to fill in the gap and tell us to fetch state at the new backwards extremity, and to not terminate the transaction\n\tnewEvents, isGapFilled, prevStatesKnown, err := t.getMissingEvents(ctx, e, roomVersion)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.getMissingEvents: %w\", err)\n\t}\n\tif len(newEvents) == 0 {\n\t\treturn nil, fmt.Errorf(\"expected to find missing events but didn't\")\n\t}\n\tif isGapFilled {\n\t\tlogger.Infof(\"Gap filled by /get_missing_events, injecting %d new events\", len(newEvents))\n\t\t// we can just inject all the newEvents as new as we may have only missed 1 or 2 events and have filled\n\t\t// in the gap in the DAG\n\t\tfor _, newEvent := range newEvents {\n\t\t\terr = t.inputer.processRoomEvent(ctx, &api.InputRoomEvent{\n\t\t\t\tKind:         api.KindOld,\n\t\t\t\tEvent:        newEvent.Headered(roomVersion),\n\t\t\t\tOrigin:       t.origin,\n\t\t\t\tSendAsServer: api.DoNotSendToOtherServers,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tif _, ok := err.(types.RejectedError); !ok {\n\t\t\t\t\treturn nil, fmt.Errorf(\"t.inputer.processRoomEvent (filling gap): %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we filled the gap *and* we know the state before the prev events\n\t// then there's nothing else to do, we have everything we need to deal\n\t// with the new event.\n\tif isGapFilled && prevStatesKnown {\n\t\tlogger.Infof(\"Gap filled and state found for all prev events\")\n\t\treturn nil, nil\n\t}\n\n\t// Otherwise, if we've reached this point, it's possible that we've\n\t// either not closed the gap, or we did but we still don't seem to\n\t// know the events before the new event. Start by looking up the\n\t// state at the event at the back of the gap and we'll try to roll\n\t// forward the state first.\n\tbackwardsExtremity := newEvents[0]\n\tnewEvents = newEvents[1:]\n\n\tresolvedState, err := t.lookupResolvedStateBeforeEvent(ctx, backwardsExtremity, roomVersion)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.lookupState (backwards extremity): %w\", err)\n\t}\n\n\thadEvents := map[string]bool{}\n\tt.hadEventsMutex.Lock()\n\tfor k, v := range t.hadEvents {\n\t\thadEvents[k] = v\n\t}\n\tt.hadEventsMutex.Unlock()\n\n\tsendOutliers := func(resolvedState *parsedRespState) error {\n\t\toutliers := resolvedState.Events()\n\t\toutlierRoomEvents := make([]api.InputRoomEvent, 0, len(outliers))\n\t\tfor _, outlier := range outliers {\n\t\t\tif hadEvents[outlier.EventID()] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\toutlierRoomEvents = append(outlierRoomEvents, api.InputRoomEvent{\n\t\t\t\tKind:   api.KindOutlier,\n\t\t\t\tEvent:  outlier.Headered(roomVersion),\n\t\t\t\tOrigin: t.origin,\n\t\t\t})\n\t\t}\n\t\tfor _, ire := range outlierRoomEvents {\n\t\t\tif err = t.inputer.processRoomEvent(ctx, &ire); err != nil {\n\t\t\t\tif _, ok := err.(types.RejectedError); !ok {\n\t\t\t\t\treturn fmt.Errorf(\"t.inputer.processRoomEvent (outlier): %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Send outliers first so we can send the state along with the new backwards\n\t// extremity without any missing auth events.\n\tif err = sendOutliers(resolvedState); err != nil {\n\t\treturn nil, fmt.Errorf(\"sendOutliers: %w\", err)\n\t}\n\n\t// Now send the backward extremity into the roomserver with the\n\t// newly resolved state. This marks the \"oldest\" point in the backfill and\n\t// sets the baseline state for any new events after this.\n\tstateIDs := make([]string, 0, len(resolvedState.StateEvents))\n\tfor _, event := range resolvedState.StateEvents {\n\t\tstateIDs = append(stateIDs, event.EventID())\n\t}\n\n\terr = t.inputer.processRoomEvent(ctx, &api.InputRoomEvent{\n\t\tKind:          api.KindOld,\n\t\tEvent:         backwardsExtremity.Headered(roomVersion),\n\t\tOrigin:        t.origin,\n\t\tHasState:      true,\n\t\tStateEventIDs: stateIDs,\n\t\tSendAsServer:  api.DoNotSendToOtherServers,\n\t})\n\tif err != nil {\n\t\tif _, ok := err.(types.RejectedError); !ok {\n\t\t\treturn nil, fmt.Errorf(\"t.inputer.processRoomEvent (backward extremity): %w\", err)\n\t\t}\n\t}\n\n\t// Then send all of the newer backfilled events, of which will all be newer\n\t// than the backward extremity, into the roomserver without state. This way\n\t// they will automatically fast-forward based on the room state at the\n\t// extremity in the last step.\n\tfor _, newEvent := range newEvents {\n\t\terr = t.inputer.processRoomEvent(ctx, &api.InputRoomEvent{\n\t\t\tKind:         api.KindOld,\n\t\t\tEvent:        newEvent.Headered(roomVersion),\n\t\t\tOrigin:       t.origin,\n\t\t\tSendAsServer: api.DoNotSendToOtherServers,\n\t\t})\n\t\tif err != nil {\n\t\t\tif _, ok := err.(types.RejectedError); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"t.inputer.processRoomEvent (fast forward): %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Finally, check again if we know everything we need to know in order to\n\t// make forward progress. If the prev state is known then we consider the\n\t// rolled forward state to be sufficient \u2014 we now know all of the state\n\t// before the prev events. If we don't then we need to look up the state\n\t// before the new event as well, otherwise we will never make any progress.\n\tif t.isPrevStateKnown(ctx, e) {\n\t\treturn nil, nil\n\t}\n\n\t// If we still haven't got the state for the prev events then we'll go and\n\t// ask the federation for it if needed.\n\tresolvedState, err = t.lookupResolvedStateBeforeEvent(ctx, e, roomVersion)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.lookupState (new event): %w\", err)\n\t}\n\n\t// Send the outliers for the retrieved state.\n\tif err = sendOutliers(resolvedState); err != nil {\n\t\treturn nil, fmt.Errorf(\"sendOutliers: %w\", err)\n\t}\n\n\t// Then return the resolved state, for which the caller can replace the\n\t// HasState with the event IDs to create a new state snapshot when we\n\t// process the new event.\n\treturn resolvedState, nil\n}\n\nfunc (t *missingStateReq) lookupResolvedStateBeforeEvent(ctx context.Context, e *gomatrixserverlib.Event, roomVersion gomatrixserverlib.RoomVersion) (*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupResolvedStateBeforeEvent\")\n\tdefer span.Finish()\n\n\ttype respState struct {\n\t\t// A snapshot is considered trustworthy if it came from our own roomserver.\n\t\t// That's because the state will have been through state resolution once\n\t\t// already in QueryStateAfterEvent.\n\t\ttrustworthy bool\n\t\t*parsedRespState\n\t}\n\n\t// at this point we know we're going to have a gap: we need to work out the room state at the new backwards extremity.\n\t// Therefore, we cannot just query /state_ids with this event to get the state before. Instead, we need to query\n\t// the state AFTER all the prev_events for this event, then apply state resolution to that to get the state before the event.\n\tvar states []*respState\n\tfor _, prevEventID := range e.PrevEventIDs() {\n\t\t// Look up what the state is after the backward extremity. This will either\n\t\t// come from the roomserver, if we know all the required events, or it will\n\t\t// come from a remote server via /state_ids if not.\n\t\tprevState, trustworthy, err := t.lookupStateAfterEvent(ctx, roomVersion, e.RoomID(), prevEventID)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"t.lookupStateAfterEvent: %w\", err)\n\t\t}\n\t\t// Append the state onto the collected state. We'll run this through the\n\t\t// state resolution next.\n\t\tstates = append(states, &respState{trustworthy, prevState})\n\t}\n\n\t// Now that we have collected all of the state from the prev_events, we'll\n\t// run the state through the appropriate state resolution algorithm for the\n\t// room if needed. This does a couple of things:\n\t// 1. Ensures that the state is deduplicated fully for each state-key tuple\n\t// 2. Ensures that we pick the latest events from both sets, in the case that\n\t//    one of the prev_events is quite a bit older than the others\n\tresolvedState := &parsedRespState{}\n\tswitch len(states) {\n\tcase 0:\n\t\textremityIsCreate := e.Type() == gomatrixserverlib.MRoomCreate && e.StateKeyEquals(\"\")\n\t\tif !extremityIsCreate {\n\t\t\t// There are no previous states and this isn't the beginning of the\n\t\t\t// room - this is an error condition!\n\t\t\treturn nil, fmt.Errorf(\"expected %d states but got %d\", len(e.PrevEventIDs()), len(states))\n\t\t}\n\tcase 1:\n\t\t// There's only one previous state - if it's trustworthy (came from a\n\t\t// local state snapshot which will already have been through state res),\n\t\t// use it as-is. There's no point in resolving it again. Only trust a\n\t\t// trustworthy state snapshot if it actually contains some state for all\n\t\t// non-create events, otherwise we need to resolve what came from federation.\n\t\tisCreate := e.Type() == gomatrixserverlib.MRoomCreate && e.StateKeyEquals(\"\")\n\t\tif states[0].trustworthy && (isCreate || len(states[0].StateEvents) > 0) {\n\t\t\tresolvedState = states[0].parsedRespState\n\t\t\tbreak\n\t\t}\n\t\t// Otherwise, if it isn't trustworthy (came from federation), run it through\n\t\t// state resolution anyway for safety, in case there are duplicates.\n\t\tfallthrough\n\tdefault:\n\t\trespStates := make([]*parsedRespState, len(states))\n\t\tfor i := range states {\n\t\t\trespStates[i] = states[i].parsedRespState\n\t\t}\n\t\t// There's more than one previous state - run them all through state res\n\t\tvar err error\n\t\tt.roomsMu.Lock(e.RoomID())\n\t\tresolvedState, err = t.resolveStatesAndCheck(ctx, roomVersion, respStates, e)\n\t\tt.roomsMu.Unlock(e.RoomID())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"t.resolveStatesAndCheck: %w\", err)\n\t\t}\n\t}\n\n\treturn resolvedState, nil\n}\n\n// lookupStateAfterEvent returns the room state after `eventID`, which is the state before eventID with the state of `eventID` (if it's a state event)\n// added into the mix.\nfunc (t *missingStateReq) lookupStateAfterEvent(ctx context.Context, roomVersion gomatrixserverlib.RoomVersion, roomID, eventID string) (*parsedRespState, bool, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupStateAfterEvent\")\n\tdefer span.Finish()\n\n\t// try doing all this locally before we resort to querying federation\n\trespState := t.lookupStateAfterEventLocally(ctx, roomID, eventID)\n\tif respState != nil {\n\t\treturn respState, true, nil\n\t}\n\n\tlogrus.WithContext(ctx).Warnf(\"State for event %s not available locally, falling back to federation (via %d servers)\", eventID, len(t.servers))\n\trespState, err := t.lookupStateBeforeEvent(ctx, roomVersion, roomID, eventID)\n\tif err != nil {\n\t\tlogrus.WithContext(ctx).WithError(err).Errorf(\"Failed to look up state before event %s\", eventID)\n\t\treturn nil, false, fmt.Errorf(\"t.lookupStateBeforeEvent: %w\", err)\n\t}\n\n\t// fetch the event we're missing and add it to the pile\n\th, err := t.lookupEvent(ctx, roomVersion, roomID, eventID, false)\n\tswitch err.(type) {\n\tcase verifySigError:\n\t\treturn respState, false, nil\n\tcase nil:\n\t\t// do nothing\n\tdefault:\n\t\tlogrus.WithContext(ctx).WithError(err).Errorf(\"Failed to look up event %s\", eventID)\n\t\treturn nil, false, fmt.Errorf(\"t.lookupEvent: %w\", err)\n\t}\n\th = t.cacheAndReturn(h)\n\tif h.StateKey() != nil {\n\t\taddedToState := false\n\t\tfor i := range respState.StateEvents {\n\t\t\tse := respState.StateEvents[i]\n\t\t\tif se.Type() == h.Type() && se.StateKeyEquals(*h.StateKey()) {\n\t\t\t\trespState.StateEvents[i] = h\n\t\t\t\taddedToState = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !addedToState {\n\t\t\trespState.StateEvents = append(respState.StateEvents, h)\n\t\t}\n\t}\n\n\treturn respState, false, nil\n}\n\nfunc (t *missingStateReq) cacheAndReturn(ev *gomatrixserverlib.Event) *gomatrixserverlib.Event {\n\tt.haveEventsMutex.Lock()\n\tdefer t.haveEventsMutex.Unlock()\n\tif cached, exists := t.haveEvents[ev.EventID()]; exists {\n\t\treturn cached\n\t}\n\tt.haveEvents[ev.EventID()] = ev\n\treturn ev\n}\n\nfunc (t *missingStateReq) lookupStateAfterEventLocally(ctx context.Context, roomID, eventID string) *parsedRespState {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupStateAfterEventLocally\")\n\tdefer span.Finish()\n\n\tvar res parsedRespState\n\troomState := state.NewStateResolution(t.db, t.roomInfo)\n\tstateAtEvents, err := t.db.StateAtEventIDs(ctx, []string{eventID})\n\tif err != nil {\n\t\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).WithError(err).Warnf(\"failed to get state after %s locally\", eventID)\n\t\treturn nil\n\t}\n\tstateEntries, err := roomState.LoadCombinedStateAfterEvents(ctx, stateAtEvents)\n\tif err != nil {\n\t\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).WithError(err).Warnf(\"failed to load combined state after %s locally\", eventID)\n\t\treturn nil\n\t}\n\tstateEventNIDs := make([]types.EventNID, 0, len(stateEntries))\n\tfor _, entry := range stateEntries {\n\t\tstateEventNIDs = append(stateEventNIDs, entry.EventNID)\n\t}\n\tstateEvents, err := t.db.Events(ctx, stateEventNIDs)\n\tif err != nil {\n\t\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).WithError(err).Warnf(\"failed to load state events locally\")\n\t\treturn nil\n\t}\n\tres.StateEvents = make([]*gomatrixserverlib.Event, 0, len(stateEvents))\n\tfor _, ev := range stateEvents {\n\t\t// set the event from the haveEvents cache - this means we will share pointers with other prev_event branches for this\n\t\t// processEvent request, which is better for memory.\n\t\tres.StateEvents = append(res.StateEvents, t.cacheAndReturn(ev.Event))\n\t\tt.hadEvent(ev.EventID())\n\t}\n\n\t// encourage GC\n\tstateEvents, stateEventNIDs, stateEntries, stateAtEvents = nil, nil, nil, nil // nolint:ineffassign\n\n\tmissingAuthEvents := map[string]bool{}\n\tres.AuthEvents = make([]*gomatrixserverlib.Event, 0, len(stateEvents)*3)\n\tfor _, ev := range stateEvents {\n\t\tt.haveEventsMutex.Lock()\n\t\tfor _, ae := range ev.AuthEventIDs() {\n\t\t\tif aev, ok := t.haveEvents[ae]; ok {\n\t\t\t\tres.AuthEvents = append(res.AuthEvents, aev)\n\t\t\t} else {\n\t\t\t\tmissingAuthEvents[ae] = true\n\t\t\t}\n\t\t}\n\t\tt.haveEventsMutex.Unlock()\n\t}\n\t// QueryStateAfterEvents does not return the auth events, so fetch them now. We know the roomserver has them else it wouldn't\n\t// have stored the event.\n\tif len(missingAuthEvents) > 0 {\n\t\tvar missingEventList []string\n\t\tfor evID := range missingAuthEvents {\n\t\t\tmissingEventList = append(missingEventList, evID)\n\t\t}\n\t\tutil.GetLogger(ctx).WithField(\"count\", len(missingEventList)).Debugf(\"Fetching missing auth events\")\n\t\tevents, err := t.db.EventsFromIDs(ctx, missingEventList)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tfor i, ev := range events {\n\t\t\tres.AuthEvents = append(res.AuthEvents, t.cacheAndReturn(events[i].Event))\n\t\t\tt.hadEvent(ev.EventID())\n\t\t}\n\t}\n\n\treturn &res\n}\n\n// lookuptStateBeforeEvent returns the room state before the event e, which is just /state_ids and/or /state depending on what\n// the server supports.\nfunc (t *missingStateReq) lookupStateBeforeEvent(ctx context.Context, roomVersion gomatrixserverlib.RoomVersion, roomID, eventID string) (\n\t*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupStateBeforeEvent\")\n\tdefer span.Finish()\n\n\t// Attempt to fetch the missing state using /state_ids and /events\n\treturn t.lookupMissingStateViaStateIDs(ctx, roomID, eventID, roomVersion)\n}\n\nfunc (t *missingStateReq) resolveStatesAndCheck(ctx context.Context, roomVersion gomatrixserverlib.RoomVersion, states []*parsedRespState, backwardsExtremity *gomatrixserverlib.Event) (*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"resolveStatesAndCheck\")\n\tdefer span.Finish()\n\n\tvar authEventList []*gomatrixserverlib.Event\n\tvar stateEventList []*gomatrixserverlib.Event\n\tfor _, state := range states {\n\t\tauthEventList = append(authEventList, state.AuthEvents...)\n\t\tstateEventList = append(stateEventList, state.StateEvents...)\n\t}\n\tresolvedStateEvents, err := gomatrixserverlib.ResolveConflicts(roomVersion, stateEventList, authEventList)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// apply the current event\nretryAllowedState:\n\tif err = checkAllowedByState(backwardsExtremity, resolvedStateEvents); err != nil {\n\t\tswitch missing := err.(type) {\n\t\tcase gomatrixserverlib.MissingAuthEventError:\n\t\t\th, err2 := t.lookupEvent(ctx, roomVersion, backwardsExtremity.RoomID(), missing.AuthEventID, true)\n\t\t\tswitch err2.(type) {\n\t\t\tcase verifySigError:\n\t\t\t\treturn &parsedRespState{\n\t\t\t\t\tAuthEvents:  authEventList,\n\t\t\t\t\tStateEvents: resolvedStateEvents,\n\t\t\t\t}, nil\n\t\t\tcase nil:\n\t\t\t\t// do nothing\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"missing auth event %s and failed to look it up: %w\", missing.AuthEventID, err2)\n\t\t\t}\n\t\t\tutil.GetLogger(ctx).Tracef(\"fetched event %s\", missing.AuthEventID)\n\t\t\tresolvedStateEvents = append(resolvedStateEvents, h)\n\t\t\tgoto retryAllowedState\n\t\tdefault:\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &parsedRespState{\n\t\tAuthEvents:  authEventList,\n\t\tStateEvents: resolvedStateEvents,\n\t}, nil\n}\n\n// get missing events for `e`. If `isGapFilled`=true then `newEvents` contains all the events to inject,\n// without `e`. If `isGapFilled=false` then `newEvents` contains the response to /get_missing_events\nfunc (t *missingStateReq) getMissingEvents(ctx context.Context, e *gomatrixserverlib.Event, roomVersion gomatrixserverlib.RoomVersion) (newEvents []*gomatrixserverlib.Event, isGapFilled, prevStateKnown bool, err error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"getMissingEvents\")\n\tdefer span.Finish()\n\n\tlogger := util.GetLogger(ctx).WithField(\"event_id\", e.EventID()).WithField(\"room_id\", e.RoomID())\n\tlatest, _, _, err := t.db.LatestEventIDs(ctx, t.roomInfo.RoomNID)\n\tif err != nil {\n\t\treturn nil, false, false, fmt.Errorf(\"t.DB.LatestEventIDs: %w\", err)\n\t}\n\tlatestEvents := make([]string, len(latest))\n\tfor i, ev := range latest {\n\t\tlatestEvents[i] = ev.EventID\n\t\tt.hadEvent(ev.EventID)\n\t}\n\n\tvar missingResp *gomatrixserverlib.RespMissingEvents\n\tfor _, server := range t.servers {\n\t\tvar m gomatrixserverlib.RespMissingEvents\n\t\tif m, err = t.federation.LookupMissingEvents(ctx, server, e.RoomID(), gomatrixserverlib.MissingEvents{\n\t\t\tLimit: 20,\n\t\t\t// The latest event IDs that the sender already has. These are skipped when retrieving the previous events of latest_events.\n\t\t\tEarliestEvents: latestEvents,\n\t\t\t// The event IDs to retrieve the previous events for.\n\t\t\tLatestEvents: []string{e.EventID()},\n\t\t}, roomVersion); err == nil {\n\t\t\tmissingResp = &m\n\t\t\tbreak\n\t\t} else {\n\t\t\tlogger.WithError(err).Warnf(\"%s pushed us an event but %q did not respond to /get_missing_events\", t.origin, server)\n\t\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done(): // the parent request context timed out\n\t\t\t\t\treturn nil, false, false, context.DeadlineExceeded\n\t\t\t\tdefault: // this request exceed its own timeout\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif missingResp == nil {\n\t\tlogger.WithError(err).Warnf(\n\t\t\t\"%s pushed us an event but %d server(s) couldn't give us details about prev_events via /get_missing_events - dropping this event until it can\",\n\t\t\tt.origin, len(t.servers),\n\t\t)\n\t\treturn nil, false, false, missingPrevEventsError{\n\t\t\teventID: e.EventID(),\n\t\t\terr:     err,\n\t\t}\n\t}\n\n\t// Make sure events from the missingResp are using the cache - missing events\n\t// will be added and duplicates will be removed.\n\tmissingEvents := make([]*gomatrixserverlib.Event, 0, len(missingResp.Events))\n\tfor _, ev := range missingResp.Events.UntrustedEvents(roomVersion) {\n\t\tif err = ev.VerifyEventSignatures(ctx, t.keys); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tmissingEvents = append(missingEvents, t.cacheAndReturn(ev))\n\t}\n\tlogger.Debugf(\"get_missing_events returned %d events (%d passed signature checks)\", len(missingResp.Events), len(missingEvents))\n\n\t// topologically sort and sanity check that we are making forward progress\n\tnewEvents = gomatrixserverlib.ReverseTopologicalOrdering(missingEvents, gomatrixserverlib.TopologicalOrderByPrevEvents)\n\tshouldHaveSomeEventIDs := e.PrevEventIDs()\n\thasPrevEvent := false\nEvent:\n\tfor _, pe := range shouldHaveSomeEventIDs {\n\t\tfor _, ev := range newEvents {\n\t\t\tif ev.EventID() == pe {\n\t\t\t\thasPrevEvent = true\n\t\t\t\tbreak Event\n\t\t\t}\n\t\t}\n\t}\n\tif !hasPrevEvent {\n\t\terr = fmt.Errorf(\"called /get_missing_events but server %s didn't return any prev_events with IDs %v\", t.origin, shouldHaveSomeEventIDs)\n\t\tlogger.WithError(err).Warnf(\n\t\t\t\"%s pushed us an event but couldn't give us details about prev_events via /get_missing_events - dropping this event until it can\",\n\t\t\tt.origin,\n\t\t)\n\t\treturn nil, false, false, missingPrevEventsError{\n\t\t\teventID: e.EventID(),\n\t\t\terr:     err,\n\t\t}\n\t}\n\tif len(newEvents) == 0 {\n\t\treturn nil, false, false, nil // TODO: error instead?\n\t}\n\n\tearliestNewEvent := newEvents[0]\n\n\t// If we retrieved back to the beginning of the room then there's nothing else\n\t// to do - we closed the gap.\n\tif len(earliestNewEvent.PrevEventIDs()) == 0 && earliestNewEvent.Type() == gomatrixserverlib.MRoomCreate && earliestNewEvent.StateKeyEquals(\"\") {\n\t\treturn newEvents, true, t.isPrevStateKnown(ctx, e), nil\n\t}\n\n\t// If our backward extremity was not a known event to us then we obviously didn't\n\t// close the gap.\n\tif state, err := t.db.StateAtEventIDs(ctx, []string{earliestNewEvent.EventID()}); err != nil || len(state) == 0 && state[0].BeforeStateSnapshotNID == 0 {\n\t\treturn newEvents, false, false, nil\n\t}\n\n\t// At this point we are satisfied that we know the state both at the earliest\n\t// retrieved event and at the prev events of the new event.\n\treturn newEvents, true, t.isPrevStateKnown(ctx, e), nil\n}\n\nfunc (t *missingStateReq) isPrevStateKnown(ctx context.Context, e *gomatrixserverlib.Event) bool {\n\texpected := len(e.PrevEventIDs())\n\tstate, err := t.db.StateAtEventIDs(ctx, e.PrevEventIDs())\n\tif err != nil || len(state) != expected {\n\t\t// We didn't get as many state snapshots as we expected, or there was an error,\n\t\t// so we haven't completely solved the problem for the new event.\n\t\treturn false\n\t}\n\t// Check to see if we have a populated state snapshot for all of the prev events.\n\tfor _, stateAtEvent := range state {\n\t\tif stateAtEvent.BeforeStateSnapshotNID == 0 {\n\t\t\t// One of the prev events still has unknown state, so we haven't really\n\t\t\t// solved the problem.\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (t *missingStateReq) lookupMissingStateViaState(\n\tctx context.Context, roomID, eventID string, roomVersion gomatrixserverlib.RoomVersion,\n) (respState *parsedRespState, err error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupMissingStateViaState\")\n\tdefer span.Finish()\n\n\tstate, err := t.federation.LookupState(ctx, t.origin, roomID, eventID, roomVersion)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check that the returned state is valid.\n\tauthEvents, stateEvents, err := state.Check(ctx, roomVersion, t.keys, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparsedState := &parsedRespState{\n\t\tAuthEvents:  authEvents,\n\t\tStateEvents: stateEvents,\n\t}\n\t// Cache the results of this state lookup and deduplicate anything we already\n\t// have in the cache, freeing up memory.\n\t// We load these as trusted as we called state.Check before which loaded them as untrusted.\n\tfor i, evJSON := range state.AuthEvents {\n\t\tev, _ := gomatrixserverlib.NewEventFromTrustedJSON(evJSON, false, roomVersion)\n\t\tparsedState.AuthEvents[i] = t.cacheAndReturn(ev)\n\t}\n\tfor i, evJSON := range state.StateEvents {\n\t\tev, _ := gomatrixserverlib.NewEventFromTrustedJSON(evJSON, false, roomVersion)\n\t\tparsedState.StateEvents[i] = t.cacheAndReturn(ev)\n\t}\n\treturn parsedState, nil\n}\n\nfunc (t *missingStateReq) lookupMissingStateViaStateIDs(ctx context.Context, roomID, eventID string, roomVersion gomatrixserverlib.RoomVersion) (\n\t*parsedRespState, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupMissingStateViaStateIDs\")\n\tdefer span.Finish()\n\n\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).Infof(\"lookupMissingStateViaStateIDs %s\", eventID)\n\t// fetch the state event IDs at the time of the event\n\tvar stateIDs gomatrixserverlib.RespStateIDs\n\tvar err error\n\tcount := 0\n\ttotalctx, totalcancel := context.WithTimeout(ctx, time.Minute*5)\n\tfor _, serverName := range t.servers {\n\t\treqctx, reqcancel := context.WithTimeout(totalctx, time.Second*20)\n\t\tstateIDs, err = t.federation.LookupStateIDs(reqctx, serverName, roomID, eventID)\n\t\treqcancel()\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tcount++\n\t}\n\ttotalcancel()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.federation.LookupStateIDs tried %d server(s), last error: %w\", count, err)\n\t}\n\t// work out which auth/state IDs are missing\n\twantIDs := append(stateIDs.StateEventIDs, stateIDs.AuthEventIDs...)\n\tmissing := make(map[string]bool)\n\tvar missingEventList []string\n\tt.haveEventsMutex.Lock()\n\tfor _, sid := range wantIDs {\n\t\tif _, ok := t.haveEvents[sid]; !ok {\n\t\t\tif !missing[sid] {\n\t\t\t\tmissing[sid] = true\n\t\t\t\tmissingEventList = append(missingEventList, sid)\n\t\t\t}\n\t\t}\n\t}\n\tt.haveEventsMutex.Unlock()\n\n\tevents, err := t.db.EventsFromIDs(ctx, missingEventList)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"t.db.EventsFromIDs: %w\", err)\n\t}\n\n\tfor i, ev := range events {\n\t\tevents[i].Event = t.cacheAndReturn(events[i].Event)\n\t\tt.hadEvent(ev.EventID())\n\t\tevID := events[i].EventID()\n\t\tif missing[evID] {\n\t\t\tdelete(missing, evID)\n\t\t}\n\t}\n\n\t// encourage GC\n\tevents = nil // nolint:ineffassign\n\n\tconcurrentRequests := 8\n\tmissingCount := len(missing)\n\tutil.GetLogger(ctx).WithField(\"room_id\", roomID).WithField(\"event_id\", eventID).Debugf(\"lookupMissingStateViaStateIDs missing %d/%d events\", missingCount, len(wantIDs))\n\n\t// If over 50% of the auth/state events from /state_ids are missing\n\t// then we'll just call /state instead, otherwise we'll just end up\n\t// hammering the remote side with /event requests unnecessarily.\n\tif missingCount > concurrentRequests && missingCount > len(wantIDs)/2 {\n\t\tutil.GetLogger(ctx).WithFields(logrus.Fields{\n\t\t\t\"missing\":           missingCount,\n\t\t\t\"event_id\":          eventID,\n\t\t\t\"room_id\":           roomID,\n\t\t\t\"total_state\":       len(stateIDs.StateEventIDs),\n\t\t\t\"total_auth_events\": len(stateIDs.AuthEventIDs),\n\t\t}).Debug(\"Fetching all state at event\")\n\t\treturn t.lookupMissingStateViaState(ctx, roomID, eventID, roomVersion)\n\t}\n\n\tif missingCount > 0 {\n\t\tutil.GetLogger(ctx).WithFields(logrus.Fields{\n\t\t\t\"missing\":             missingCount,\n\t\t\t\"event_id\":            eventID,\n\t\t\t\"room_id\":             roomID,\n\t\t\t\"total_state\":         len(stateIDs.StateEventIDs),\n\t\t\t\"total_auth_events\":   len(stateIDs.AuthEventIDs),\n\t\t\t\"concurrent_requests\": concurrentRequests,\n\t\t}).Debug(\"Fetching missing state at event\")\n\n\t\t// Create a queue containing all of the missing event IDs that we want\n\t\t// to retrieve.\n\t\tpending := make(chan string, missingCount)\n\t\tfor missingEventID := range missing {\n\t\t\tpending <- missingEventID\n\t\t}\n\t\tclose(pending)\n\n\t\t// Define how many workers we should start to do this.\n\t\tif missingCount < concurrentRequests {\n\t\t\tconcurrentRequests = missingCount\n\t\t}\n\n\t\t// Create the wait group.\n\t\tvar fetchgroup sync.WaitGroup\n\t\tfetchgroup.Add(concurrentRequests)\n\n\t\t// This is the only place where we'll write to t.haveEvents from\n\t\t// multiple goroutines, and everywhere else is blocked on this\n\t\t// synchronous function anyway.\n\t\tvar haveEventsMutex sync.Mutex\n\n\t\t// Define what we'll do in order to fetch the missing event ID.\n\t\tfetch := func(missingEventID string) {\n\t\t\th, herr := t.lookupEvent(ctx, roomVersion, roomID, missingEventID, false)\n\t\t\tswitch herr.(type) {\n\t\t\tcase verifySigError:\n\t\t\t\treturn\n\t\t\tcase nil:\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tutil.GetLogger(ctx).WithFields(logrus.Fields{\n\t\t\t\t\t\"event_id\": missingEventID,\n\t\t\t\t\t\"room_id\":  roomID,\n\t\t\t\t}).WithError(herr).Warn(\"Failed to fetch missing event\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\thaveEventsMutex.Lock()\n\t\t\tt.cacheAndReturn(h)\n\t\t\thaveEventsMutex.Unlock()\n\t\t}\n\n\t\t// Create the worker.\n\t\tworker := func(ch <-chan string) {\n\t\t\tdefer fetchgroup.Done()\n\t\t\tfor missingEventID := range ch {\n\t\t\t\tfetch(missingEventID)\n\t\t\t}\n\t\t}\n\n\t\t// Start the workers.\n\t\tfor i := 0; i < concurrentRequests; i++ {\n\t\t\tgo worker(pending)\n\t\t}\n\n\t\t// Wait for the workers to finish.\n\t\tfetchgroup.Wait()\n\t}\n\n\tresp, err := t.createRespStateFromStateIDs(stateIDs)\n\treturn resp, err\n}\n\nfunc (t *missingStateReq) createRespStateFromStateIDs(\n\tstateIDs gomatrixserverlib.RespStateIDs,\n) (*parsedRespState, error) { // nolint:unparam\n\tt.haveEventsMutex.Lock()\n\tdefer t.haveEventsMutex.Unlock()\n\n\t// create a RespState response using the response to /state_ids as a guide\n\trespState := parsedRespState{}\n\n\tfor i := range stateIDs.StateEventIDs {\n\t\tev, ok := t.haveEvents[stateIDs.StateEventIDs[i]]\n\t\tif !ok {\n\t\t\tlogrus.Tracef(\"Missing state event in createRespStateFromStateIDs: %s\", stateIDs.StateEventIDs[i])\n\t\t\tcontinue\n\t\t}\n\t\trespState.StateEvents = append(respState.StateEvents, ev)\n\t}\n\tfor i := range stateIDs.AuthEventIDs {\n\t\tev, ok := t.haveEvents[stateIDs.AuthEventIDs[i]]\n\t\tif !ok {\n\t\t\tlogrus.Tracef(\"Missing auth event in createRespStateFromStateIDs: %s\", stateIDs.AuthEventIDs[i])\n\t\t\tcontinue\n\t\t}\n\t\trespState.AuthEvents = append(respState.AuthEvents, ev)\n\t}\n\t// We purposefully do not do auth checks on the returned events, as they will still\n\t// be processed in the exact same way, just as a 'rejected' event\n\t// TODO: Add a field to HeaderedEvent to indicate if the event is rejected.\n\treturn &respState, nil\n}\n\nfunc (t *missingStateReq) lookupEvent(ctx context.Context, roomVersion gomatrixserverlib.RoomVersion, _, missingEventID string, localFirst bool) (*gomatrixserverlib.Event, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"lookupEvent\")\n\tdefer span.Finish()\n\n\tif localFirst {\n\t\t// fetch from the roomserver\n\t\tevents, err := t.db.EventsFromIDs(ctx, []string{missingEventID})\n\t\tif err != nil {\n\t\t\tutil.GetLogger(ctx).Warnf(\"Failed to query roomserver for missing event %s: %s - falling back to remote\", missingEventID, err)\n\t\t} else if len(events) == 1 {\n\t\t\treturn events[0].Event, nil\n\t\t}\n\t}\n\tvar event *gomatrixserverlib.Event\n\tfound := false\n\tfor _, serverName := range t.servers {\n\t\treqctx, cancel := context.WithTimeout(ctx, time.Second*30)\n\t\tdefer cancel()\n\t\ttxn, err := t.federation.GetEvent(reqctx, serverName, missingEventID)\n\t\tif err != nil || len(txn.PDUs) == 0 {\n\t\t\tutil.GetLogger(ctx).WithError(err).WithField(\"event_id\", missingEventID).Warn(\"Failed to get missing /event for event ID\")\n\t\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\tselect {\n\t\t\t\tcase <-reqctx.Done(): // this server took too long\n\t\t\t\t\tcontinue\n\t\t\t\tcase <-ctx.Done(): // the input request timed out\n\t\t\t\t\treturn nil, context.DeadlineExceeded\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tevent, err = gomatrixserverlib.NewEventFromUntrustedJSON(txn.PDUs[0], roomVersion)\n\t\tif err != nil {\n\t\t\tutil.GetLogger(ctx).WithError(err).WithField(\"event_id\", missingEventID).Warnf(\"Failed to parse event JSON of event returned from /event\")\n\t\t\tcontinue\n\t\t}\n\t\tfound = true\n\t\tbreak\n\t}\n\tif !found {\n\t\tutil.GetLogger(ctx).WithField(\"event_id\", missingEventID).Warnf(\"Failed to get missing /event for event ID from %d server(s)\", len(t.servers))\n\t\treturn nil, fmt.Errorf(\"wasn't able to find event via %d server(s)\", len(t.servers))\n\t}\n\tif err := event.VerifyEventSignatures(ctx, t.keys); err != nil {\n\t\tutil.GetLogger(ctx).WithError(err).Warnf(\"Couldn't validate signature of event %q from /event\", event.EventID())\n\t\treturn nil, verifySigError{event.EventID(), err}\n\t}\n\treturn t.cacheAndReturn(event), nil\n}\n\nfunc checkAllowedByState(e *gomatrixserverlib.Event, stateEvents []*gomatrixserverlib.Event) error {\n\tauthUsingState := gomatrixserverlib.NewAuthEvents(nil)\n\tfor i := range stateEvents {\n\t\terr := authUsingState.AddEvent(stateEvents[i])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn gomatrixserverlib.Allowed(e, &authUsingState)\n}\n\nfunc (t *missingStateReq) hadEvent(eventID string) {\n\tt.hadEventsMutex.Lock()\n\tdefer t.hadEventsMutex.Unlock()\n\tt.hadEvents[eventID] = true\n}\n\ntype verifySigError struct {\n\teventID string\n\terr     error\n}\ntype missingPrevEventsError struct {\n\teventID string\n\terr     error\n}\n\nfunc (e verifySigError) Error() string {\n\treturn fmt.Sprintf(\"unable to verify signature of event %q: %s\", e.eventID, e.err)\n}\nfunc (e missingPrevEventsError) Error() string {\n\treturn fmt.Sprintf(\"unable to get prev_events for event %q: %s\", e.eventID, e.err)\n}\n"], "filenames": ["roomserver/internal/input/input_missing.go"], "buggy_code_start_loc": [556], "buggy_code_end_loc": [560], "fixing_code_start_loc": [555], "fixing_code_end_loc": [564], "type": "CWE-347", "message": "Dendrite is a Matrix homeserver written in Go. In affected versions events retrieved from a remote homeserver using the `/get_missing_events` path did not have their signatures verified correctly. This could potentially allow a remote homeserver to provide invalid/modified events to Dendrite via this endpoint. Note that this does not apply to events retrieved through other endpoints (e.g. `/event`, `/state`) as they have been correctly verified. Homeservers that have federation disabled are not vulnerable. The problem has been fixed in Dendrite 0.9.8. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-39200", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-12T20:15:12.960", "lastModified": "2022-09-15T18:53:01.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dendrite is a Matrix homeserver written in Go. In affected versions events retrieved from a remote homeserver using the `/get_missing_events` path did not have their signatures verified correctly. This could potentially allow a remote homeserver to provide invalid/modified events to Dendrite via this endpoint. Note that this does not apply to events retrieved through other endpoints (e.g. `/event`, `/state`) as they have been correctly verified. Homeservers that have federation disabled are not vulnerable. The problem has been fixed in Dendrite 0.9.8. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Dendrite es un servidor dom\u00e9stico de Matrix escrito en Go. En las versiones afectadas, los eventos recuperados de un servidor dom\u00e9stico remoto usando la ruta \"/get_missing_events\" no presentaban sus firmas verificadas correctamente. Esto podr\u00eda permitir que un servidor dom\u00e9stico remoto proporcionara eventos no v\u00e1lidos/modificados a Dendrite por medio de este endpoint. Ten en cuenta que esto no es aplicado a eventos recuperados mediante otros endpoints (por ejemplo, \"/event\", \"/state\") ya que han sido correctamente verificados. Los servidores dom\u00e9sticos que presentan la federaci\u00f3n deshabilitada no son vulnerables. El problema ha sido corregido en Dendrite versi\u00f3n 0.9.8. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:dendrite:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.8", "matchCriteriaId": "6C742B40-80E7-4128-A0D0-26585D60D546"}]}]}], "references": [{"url": "https://github.com/matrix-org/dendrite/commit/2792d0490f3771488bad346981b8c26479a872c3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/dendrite/security/advisories/GHSA-pfw4-xjgm-267c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/dendrite/commit/2792d0490f3771488bad346981b8c26479a872c3"}}