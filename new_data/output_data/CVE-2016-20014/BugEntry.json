{"buggy_code": ["/* pam_tacplus.c - PAM interface for TACACS+ protocol.\n *\n * Copyright (C) 2010, Pawel Krawczyk <pawel.krawczyk@hush.com> and\n * Jeroen Nijhof <jeroen@jeroennijhof.nl>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program - see the file COPYING.\n *\n * See `CHANGES' file for revision history.\n */\n\n#include \"pam_tacplus.h\"\n#include \"support.h\"\n\n#include <stdlib.h>     /* malloc */\n#include <stdio.h>\n#include <syslog.h>\n#include <netdb.h>      /* gethostbyname */\n#include <sys/socket.h> /* in_addr */\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdarg.h>     /* va_ */\n#include <signal.h>\n#include <string.h>     /* strdup */\n#include <ctype.h>\n#include <time.h>\n#include <unistd.h>\n#include <strings.h>\n\n#ifdef HAVE_CONFIG_H\n  #include \"config.h\"\n#endif\n\n/* address of server discovered by pam_sm_authenticate */\nstatic tacplus_server_t active_server;\n\n/* accounting task identifier */\nstatic short int task_id = 0;\n\n\n/* Helper functions */\nint _pam_send_account(int tac_fd, int type, const char *user, char *tty,\n    char *r_addr, char *cmd) {\n\n    char buf[64];\n    struct tac_attrib *attr;\n    int retval;\n\n    attr=(struct tac_attrib *)xcalloc(1, sizeof(struct tac_attrib));\n\n    sprintf(buf, \"%lu\", (unsigned long)time(NULL));\n\n    if (type == TAC_PLUS_ACCT_FLAG_START) {\n        tac_add_attrib(&attr, \"start_time\", buf);\n    } else if (type == TAC_PLUS_ACCT_FLAG_STOP) {\n        tac_add_attrib(&attr, \"stop_time\", buf);\n    }\n    sprintf(buf, \"%hu\", task_id);\n    tac_add_attrib(&attr, \"task_id\", buf);\n    tac_add_attrib(&attr, \"service\", tac_service);\n    if(tac_protocol[0] != '\\0')\n      tac_add_attrib(&attr, \"protocol\", tac_protocol);\n    if (cmd != NULL) {\n        tac_add_attrib(&attr, \"cmd\", cmd);\n    }\n\n    retval = tac_acct_send(tac_fd, type, user, tty, r_addr, attr);\n\n    /* this is no longer needed */\n    tac_free_attrib(&attr);\n\n    if(retval < 0) {\n        _pam_log (LOG_WARNING, \"%s: send %s accounting failed (task %hu)\",\n            __FUNCTION__,\n            tac_acct_flag2str(type),\n            task_id);\n        close(tac_fd);\n        return -1;\n    }\n\n    struct areply re;\n    if( tac_acct_read(tac_fd, &re) != TAC_PLUS_ACCT_STATUS_SUCCESS ) {\n        _pam_log (LOG_WARNING, \"%s: accounting %s failed (task %hu)\",\n            __FUNCTION__,\n            tac_acct_flag2str(type),\n            task_id);\n\n        if(re.msg != NULL)\n            free(re.msg);\n\n        close(tac_fd);\n        return -1;\n    }\n\n    if(re.msg != NULL)\n        free(re.msg);\n\n    close(tac_fd);\n    return 0;\n}\n\nint _pam_account(pam_handle_t *pamh, int argc, const char **argv,\n    int type, char *cmd) {\n\n    int retval;\n    static int ctrl;\n    char *user = NULL;\n    char *tty = NULL;\n    char *r_addr = NULL;\n    char *typemsg;\n    int status = PAM_SESSION_ERR;\n    int srv_i, tac_fd;\n\n    typemsg = tac_acct_flag2str(type);\n    ctrl = _pam_parse (argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        syslog (LOG_DEBUG, \"%s: [%s] called (pam_tacplus v%u.%u.%u)\",\n            __FUNCTION__, typemsg, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n        syslog(LOG_DEBUG, \"%s: tac_srv_no=%d\", __FUNCTION__, tac_srv_no);\n    }\n\n    if ((user = _pam_get_user(pamh)) == NULL)\n        return PAM_USER_UNKNOWN;\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: username [%s] obtained\", __FUNCTION__, user);\n\n    tty = _pam_get_terminal(pamh);\n    if(!strncmp(tty, \"/dev/\", 5))\n        tty += 5;\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);\n\n    r_addr = _pam_get_rhost(pamh);\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);\n\n    /* checks for specific data required by TACACS+, which should\n       be supplied in command line  */\n    if(*tac_service == '\\0') {\n        _pam_log (LOG_ERR, \"ACC: TACACS+ service type not configured\");\n        return PAM_AUTH_ERR;\n    }\n    if(*tac_protocol == '\\0') {\n        _pam_log (LOG_ERR, \"ACC: TACACS+ protocol type not configured (IGNORED)\");\n    }\n\n    /* when this module is called from within pppd or other\n       application dealing with serial lines, it is likely\n       that we will get hit with signal caused by modem hangup;\n       this is important only for STOP packets, it's relatively\n       rare that modem hangs up on accounting start */\n    if(type == TAC_PLUS_ACCT_FLAG_STOP) {\n        signal(SIGALRM, SIG_IGN);\n        signal(SIGCHLD, SIG_IGN);\n        signal(SIGHUP, SIG_IGN);\n    }\n\n    status = PAM_SESSION_ERR;\n    for(srv_i = 0; srv_i < tac_srv_no; srv_i++) {\n        tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);\n        if (tac_fd < 0) {\n            _pam_log(LOG_WARNING, \"%s: error sending %s (fd)\",\n                __FUNCTION__, typemsg);\n            continue;\n        }\n        if (ctrl & PAM_TAC_DEBUG)\n            syslog(LOG_DEBUG, \"%s: connected with fd=%d (srv %d)\", __FUNCTION__, tac_fd, srv_i);\n\n        retval = _pam_send_account(tac_fd, type, user, tty, r_addr, cmd);\n        if (retval < 0) {\n            _pam_log(LOG_WARNING, \"%s: error sending %s (acct)\",\n                __FUNCTION__, typemsg);\n        } else {\n            status = PAM_SUCCESS;\n            if (ctrl & PAM_TAC_DEBUG)\n                syslog(LOG_DEBUG, \"%s: [%s] for [%s] sent\", __FUNCTION__, typemsg, user);\n        }\n        close(tac_fd);\n\n        if ((status == PAM_SUCCESS) && !(ctrl & PAM_TAC_ACCT)) {\n            /* do not send acct start/stop packets to _all_ servers */\n            break;\n        }\n    }\n\n    if (type == TAC_PLUS_ACCT_FLAG_STOP) {\n        signal(SIGALRM, SIG_DFL);\n        signal(SIGCHLD, SIG_DFL);\n        signal(SIGHUP, SIG_DFL);\n    }\n    return status;\n}\n\n\n/* Main PAM functions */\n\n/* authenticates user on remote TACACS+ server\n * returns PAM_SUCCESS if the supplied username and password\n * pair is valid\n */\nPAM_EXTERN\nint pam_sm_authenticate (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    int ctrl, retval;\n    char *user;\n    char *pass;\n    char *tty;\n    char *r_addr;\n    int srv_i;\n    int tac_fd, status, msg, communicating;\n\n    user = pass = tty = r_addr = NULL;\n\n    ctrl = _pam_parse(argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\",\n            __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n\n    if ((user = _pam_get_user(pamh)) == NULL)\n        return PAM_USER_UNKNOWN;\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: user [%s] obtained\", __FUNCTION__, user);\n\n    retval = tacacs_get_password (pamh, flags, ctrl, &pass);\n    if (retval != PAM_SUCCESS || pass == NULL || *pass == '\\0') {\n        _pam_log(LOG_ERR, \"unable to obtain password\");\n        free(pass);\n        return PAM_CRED_INSUFFICIENT;\n    }\n\n    retval = pam_set_item (pamh, PAM_AUTHTOK, pass);\n    if (retval != PAM_SUCCESS) {\n        _pam_log(LOG_ERR, \"unable to set password\");\n        free(pass);\n        return PAM_CRED_INSUFFICIENT;\n    }\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: password obtained\", __FUNCTION__);\n\n    tty = _pam_get_terminal(pamh);\n    if (!strncmp(tty, \"/dev/\", 5))\n        tty += 5;\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);\n\n    r_addr = _pam_get_rhost(pamh);\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);\n\n    status = PAM_AUTHINFO_UNAVAIL;\n    for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {\n        if (ctrl & PAM_TAC_DEBUG)\n            syslog(LOG_DEBUG, \"%s: trying srv %d\", __FUNCTION__, srv_i );\n\n        tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);\n        if (tac_fd < 0) {\n            _pam_log(LOG_ERR, \"connection failed srv %d: %m\", srv_i);\n            continue;\n        }\n        if (tac_authen_send(tac_fd, user, pass, tty, r_addr, TAC_PLUS_AUTHEN_LOGIN) < 0) {\n            close(tac_fd);\n            _pam_log(LOG_ERR, \"error sending auth req to TACACS+ server\");\n            continue;\n        }\n        communicating = 1;\n        while (communicating) {\n            struct areply re = { .attr = NULL, .msg = NULL, status = 0, flags = 0 };\n            struct pam_message conv_msg = { .msg_style = 0, .msg = NULL };\n            struct pam_response *resp = NULL;\n\n            msg = tac_authen_read(tac_fd, &re);\n\n            if (NULL != re.msg) {\n                conv_msg.msg = re.msg;\n            }\n\n            /* talk the protocol */\n            switch (msg) {\n                case TAC_PLUS_AUTHEN_STATUS_PASS:\n                    /* success */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_PASS\");\n  \n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n\n                        conv_msg.msg_style = PAM_TEXT_INFO;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                        }\n\n                    }\n                    status = PAM_SUCCESS;\n                    communicating = 0;\n                    active_server.addr = tac_srv[srv_i].addr;\n                    active_server.key = tac_srv[srv_i].key;\n\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"%s: active srv %d\", __FUNCTION__, srv_i);\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_FAIL:\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FAIL\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n\n                        conv_msg.msg_style = PAM_ERROR_MSG;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                        }\n\n                    }\n                    status = PAM_AUTH_ERR;\n                    communicating = 0;\n\n                    _pam_log(LOG_ERR, \"auth failed: %d\", msg);\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETDATA:\n                    if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETDATA\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n                        int echo_off = (0x1 == (re.flags & 0x1));\n                        \n                        conv_msg.msg_style = echo_off ? PAM_PROMPT_ECHO_OFF : PAM_PROMPT_ECHO_ON;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG)) \n                                syslog(LOG_DEBUG, \"sent msg=\\\"%s\\\", resp=\\\"%s\\\"\",\n                                       conv_msg.msg, resp->resp);\n\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);\n\n                            if (0 > tac_cont_send_seq(tac_fd, resp->resp, re.seq_no + 1)) {\n                                _pam_log(LOG_ERR, \"error sending continue req to TACACS+ server\");\n                                status = PAM_AUTH_ERR;\n                                communicating = 0;\n                            }\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d (%s)\",\n                                     __FUNCTION__, conv_msg.msg, retval, pam_strerror(pamh, retval));\n                            status = PAM_AUTH_ERR;\n                            communicating = 0;\n                        }\n                    }\n                    else { \n                        syslog(LOG_ERR, \"GETDATA response with no message, returning PAM_AUTH_ERR\");\n\n                        status = PAM_AUTH_ERR;\n                        communicating = 0;\n                    }\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETUSER:\n                    /* not implemented */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETUSER\");\n\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETPASS:\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETPASS\");\n\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"%s: tac_cont_send called\", __FUNCTION__);\n\n                    if (tac_cont_send(tac_fd, pass) < 0) {\n                        _pam_log (LOG_ERR, \"error sending continue req to TACACS+ server\");\n                        communicating = 0;\n                    }\n                    /* continue the while loop; go read tac response */\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_RESTART:\n                    /* try it again */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_RESTART\");\n\n                    /*\n                     * not implemented\n                     * WdJ: I *think* you can just do tac_authen_send(user, pass) again\n                     *      but I'm not sure\n                     */\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_ERROR:\n                    /* server has problems */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_ERROR\");\n\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_FOLLOW:\n                    /* server tells to try a different server address */\n                    /* not implemented */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FOLLOW\");\n\n                    communicating = 0;\n                    break;\n\n                default:\n                    if (msg < 0) {\n                        /* connection error */\n                        communicating = 0;\n                        if (ctrl & PAM_TAC_DEBUG)\n                            syslog(LOG_DEBUG, \"error communicating with tacacs server\");\n                        break;\n                    }\n\n                    /* unknown response code */\n                    communicating = 0;\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: unknown response 0x%02x\", msg);\n            }\n\n            if (NULL != resp) {\n                free(resp->resp);\n                free(resp);\n            }\n                \n            free(re.msg);\n\n        }    /* end while(communicating) */\n        close(tac_fd);\n\n        if (status == PAM_SUCCESS || status == PAM_AUTH_ERR)\n            break;\n    }\n    if (status != PAM_SUCCESS && status != PAM_AUTH_ERR)\n        _pam_log(LOG_ERR, \"no more servers to connect\");\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: exit with pam status: %d\", __FUNCTION__, status);\n\n    if (NULL != pass) {\n        bzero(pass, strlen (pass));\n        free(pass);\n        pass = NULL;\n    }\n\n    return status;\n}    /* pam_sm_authenticate */\n\n\n/* no-op function to satisfy PAM authentication module */\nPAM_EXTERN\nint pam_sm_setcred (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    int ctrl = _pam_parse (argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"\n            , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n\n    return PAM_SUCCESS;\n}    /* pam_sm_setcred */\n\n\n/* authorizes user on remote TACACS+ server, i.e. checks\n * his permission to access requested service\n * returns PAM_SUCCESS if the service is allowed\n */\nPAM_EXTERN\nint pam_sm_acct_mgmt (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    int retval, ctrl, status=PAM_AUTH_ERR;\n    char *user;\n    char *tty;\n    char *r_addr;\n    struct areply arep;\n    struct tac_attrib *attr = NULL;\n    int tac_fd;\n\n    user = tty = r_addr = NULL;\n\n    /* this also obtains service name for authorization\n       this should be normally performed by pam_get_item(PAM_SERVICE)\n       but since PAM service names are incompatible TACACS+\n       we have to pass it via command line argument until a better\n       solution is found ;) */\n    ctrl = _pam_parse (argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"\n            , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n\n    if ((user = _pam_get_user(pamh)) == NULL)\n        return PAM_USER_UNKNOWN;\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: username obtained [%s]\", __FUNCTION__, user);\n\n    tty = _pam_get_terminal(pamh);\n    if(!strncmp(tty, \"/dev/\", 5))\n        tty += 5;\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: tty obtained [%s]\", __FUNCTION__, tty);\n\n    r_addr = _pam_get_rhost(pamh);\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: rhost obtained [%s]\", __FUNCTION__, r_addr);\n\n    /* checks if user has been successfully authenticated\n       by TACACS+; we cannot solely authorize user if it hasn't\n       been authenticated or has been authenticated by method other\n       than TACACS+ */\n    if(active_server.addr == NULL) {\n        _pam_log (LOG_ERR, \"user not authenticated by TACACS+\");\n        return PAM_AUTH_ERR;\n    }\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog (LOG_DEBUG, \"%s: active server is [%s]\", __FUNCTION__,\n            tac_ntop(active_server.addr->ai_addr));\n\n    /* checks for specific data required by TACACS+, which should\n       be supplied in command line  */\n    if(!*tac_service) {\n        _pam_log (LOG_ERR, \"SM: TACACS+ service type not configured\");\n        return PAM_AUTH_ERR;\n    }\n    if(!*tac_protocol) {\n        _pam_log (LOG_ERR, \"SM: TACACS+ protocol type not configured (IGNORED)\");\n    }\n\n    tac_add_attrib(&attr, \"service\", tac_service);\n    if(tac_protocol[0] != '\\0')\n      tac_add_attrib(&attr, \"protocol\", tac_protocol);\n\n    tac_fd = tac_connect_single(active_server.addr, active_server.key, NULL, tac_timeout);\n    if(tac_fd < 0) {\n        _pam_log (LOG_ERR, \"TACACS+ server unavailable\");\n        if(arep.msg != NULL)\n            free (arep.msg);\n        return PAM_AUTH_ERR;\n    }\n\n    retval = tac_author_send(tac_fd, user, tty, r_addr, attr);\n\n    tac_free_attrib(&attr);\n\n    if(retval < 0) {\n        _pam_log (LOG_ERR, \"error getting authorization\");\n        if(arep.msg != NULL)\n            free (arep.msg);\n\n        close(tac_fd);\n        return PAM_AUTH_ERR;\n    }\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: sent authorization request\", __FUNCTION__);\n\n    tac_author_read(tac_fd, &arep);\n\n    if(arep.status != AUTHOR_STATUS_PASS_ADD &&\n        arep.status != AUTHOR_STATUS_PASS_REPL) {\n\n        _pam_log (LOG_ERR, \"TACACS+ authorisation failed for [%s]\", user);\n        if(arep.msg != NULL)\n            free (arep.msg);\n\n        close(tac_fd);\n        return PAM_PERM_DENIED;\n    }\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: user [%s] successfully authorized\", __FUNCTION__, user);\n\n    status = PAM_SUCCESS;\n\n    attr = arep.attr;\n    while (attr != NULL)  {\n        char attribute[attr->attr_len];\n        char value[attr->attr_len];\n        char *sep;\n\n        sep = index(attr->attr, '=');\n        if(sep == NULL)\n            sep = index(attr->attr, '*');\n        if(sep != NULL) {\n            bcopy(attr->attr, attribute, attr->attr_len-strlen(sep));\n            attribute[attr->attr_len-strlen(sep)] = '\\0';\n            bcopy(sep, value, strlen(sep));\n            value[strlen(sep)] = '\\0';\n\n            size_t i;\n            for (i = 0; attribute[i] != '\\0'; i++) {\n                attribute[i] = toupper(attribute[i]);\n                if (attribute[i] == '-')\n                    attribute[i] = '_';\n            }\n\n            if (ctrl & PAM_TAC_DEBUG)\n                syslog(LOG_DEBUG, \"%s: returned attribute `%s%s' from server\", __FUNCTION__, attribute, value);\n\n            /* make returned attributes available for other PAM modules via PAM environment */\n            if (pam_putenv(pamh, strncat(attribute, value, strlen(value))) != PAM_SUCCESS)\n                syslog(LOG_WARNING, \"%s: unable to set PAM environment\", __FUNCTION__);\n\n        } else {\n            syslog(LOG_WARNING, \"%s: invalid attribute `%s', no separator\", __FUNCTION__, attr->attr);\n        }\n        attr = attr->next;\n    }\n\n    /* free returned attributes */\n    if(arep.attr != NULL)\n        tac_free_attrib(&arep.attr);\n\n    if(arep.msg != NULL)\n        free (arep.msg);\n\n    close(tac_fd);\n\n    return status;\n}    /* pam_sm_acct_mgmt */\n\n/* sends START accounting request to the remote TACACS+ server\n * returns PAM error only if the request was refused or there\n * were problems connection to the server\n */\n/* accounting packets may be directed to any TACACS+ server,\n * independent from those used for authentication and authorization;\n * it may be also directed to all specified servers\n */\nPAM_EXTERN\nint pam_sm_open_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    task_id=(short int) magic();\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}    /* pam_sm_open_session */\n\n/* sends STOP accounting request to the remote TACACS+ server\n * returns PAM error only if the request was refused or there\n * were problems connection to the server\n */\nPAM_EXTERN\nint pam_sm_close_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_STOP, NULL);\n}    /* pam_sm_close_session */\n\n\n#ifdef PAM_SM_PASSWORD\n/* no-op function for future use */\nPAM_EXTERN\nint pam_sm_chauthtok(pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    int ctrl, retval;\n    char *user;\n    char *pass;\n    char *tty;\n    char *r_addr;\n    const void *pam_pass = NULL;\n    int srv_i;\n    int tac_fd, status, msg, communicating;\n\n    user = pass = tty = r_addr = NULL;\n\n    ctrl = _pam_parse(argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"\n            , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n\n    syslog(LOG_DEBUG, \"%s(flags=%d, argc=%d)\", __func__, flags, argc);\n\n    if (   (pam_get_item(pamh, PAM_OLDAUTHTOK, &pam_pass) == PAM_SUCCESS)\n        && (pam_pass != NULL) ) {\n         if ((pass = strdup(pam_pass)) == NULL)\n              return PAM_BUF_ERR;\n    } else {\n        pass = strdup(\"\");\n    }\n    \n    if ((user = _pam_get_user(pamh)) == NULL) {\n        if(pass) {\n                free(pass);\n        }\n        return PAM_USER_UNKNOWN;\n    }\n    \n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: user [%s] obtained\", __FUNCTION__, user);\n\n    tty = _pam_get_terminal(pamh);\n    if (!strncmp(tty, \"/dev/\", 5))\n        tty += 5;\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);\n\n    r_addr = _pam_get_rhost(pamh);\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);\n\n    if (PAM_SILENT == (flags & PAM_SILENT)) {\n        status = PAM_AUTHTOK_ERR;\n        goto finish;\n    }\n\n    status = PAM_TRY_AGAIN;\n    for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {\n        if (ctrl & PAM_TAC_DEBUG)\n            syslog(LOG_DEBUG, \"%s: trying srv %d\", __FUNCTION__, srv_i );\n\n        tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);\n        if (tac_fd < 0) {\n            _pam_log(LOG_ERR, \"connection failed srv %d: %m\", srv_i);\n            continue;\n        }\n        if (PAM_PRELIM_CHECK == (flags & PAM_PRELIM_CHECK)) {\n            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                syslog(LOG_DEBUG, \"%s: finishing PAM_PRELIM_CHECK with srv %d\",\n                       __FUNCTION__, srv_i);\n\n            close(tac_fd);\n            status = PAM_SUCCESS;\n            goto finish;\n        }\n\n        if (tac_authen_send(tac_fd, user, \"\", tty, r_addr, TAC_PLUS_AUTHEN_CHPASS) < 0) {\n            close(tac_fd);\n            _pam_log(LOG_ERR, \"error sending auth req to TACACS+ server\");\n            continue;\n        }\n        communicating = 1;\n        while (communicating) {\n            struct areply re = { .attr = NULL, .msg = NULL, status = 0, flags = 0 };\n            struct pam_message conv_msg = { .msg_style = 0, .msg = NULL };\n            struct pam_response *resp = NULL;\n\n            msg = tac_authen_read(tac_fd, &re);\n\n            if (NULL != re.msg) {\n                conv_msg.msg = re.msg;\n            }\n\n            /* talk the protocol */\n            switch (msg) {\n                case TAC_PLUS_AUTHEN_STATUS_PASS:\n                    /* success */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_PASS\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n\n                        conv_msg.msg_style = PAM_TEXT_INFO;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                        }\n\n                    }\n                    status = PAM_SUCCESS;\n                    communicating = 0;\n\n                    active_server.addr = tac_srv[srv_i].addr;\n                    active_server.key = tac_srv[srv_i].key;\n\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"%s: active srv %d\", __FUNCTION__, srv_i);\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_FAIL:\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FAIL\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n\n                        conv_msg.msg_style = PAM_ERROR_MSG;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                        }\n\n                    }\n                    status = PAM_AUTHTOK_ERR;\n                    communicating = 0;\n\n                    _pam_log(LOG_ERR, \"chauthtok failed: %d\", msg);\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETDATA:\n                    if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETDATA\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n                        int echo_off = (0x1 == (re.flags & 0x1));\n                        \n                        conv_msg.msg_style = echo_off ? PAM_PROMPT_ECHO_OFF : PAM_PROMPT_ECHO_ON;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG)) \n                                syslog(LOG_DEBUG, \"sent msg=\\\"%s\\\", resp=\\\"%s\\\"\",\n                                       conv_msg.msg, resp->resp);\n\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);\n\n                            if (0 > tac_cont_send_seq(tac_fd, resp->resp, re.seq_no + 1)) {\n                                _pam_log(LOG_ERR, \"error sending continue req to TACACS+ server\");\n                                communicating = 0;\n                            }\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                            communicating = 0;\n                        }\n                    }\n                    else { \n                        syslog(LOG_ERR, \"GETDATA response with no message, returning PAM_TRY_AGAIN\");\n                        communicating = 0;\n                    }\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETUSER:\n                    /* not implemented */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETUSER\");\n\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETPASS:\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETPASS\");\n\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);\n\n                    if (tac_cont_send(tac_fd, pass) < 0) {\n                        _pam_log (LOG_ERR, \"error sending continue req to TACACS+ server\");\n                        communicating = 0;\n                        break;\n                    }\n                    /* continue the while loop; go read tac response */\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_RESTART:\n                    /* try it again */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_RESTART\");\n\n                    /*\n                     * not implemented\n                     * WdJ: I *think* you can just do tac_authen_send(user, pass) again\n                     *      but I'm not sure\n                     */\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_ERROR:\n                    /* server has problems */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_ERROR\");\n\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_FOLLOW:\n                    /* server tells to try a different server address */\n                    /* not implemented */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FOLLOW\");\n\n                    communicating = 0;\n                    break;\n\n                default:\n                    if (msg < 0) {\n                        /* connection error */\n                        communicating = 0;\n                        if (ctrl & PAM_TAC_DEBUG)\n                            syslog(LOG_DEBUG, \"error communicating with tacacs server\");\n                        break;\n                    }\n\n                    /* unknown response code */\n                    communicating = 0;\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: unknown response 0x%02x\", msg);\n            }\n\n            if (NULL != resp) {\n                free(resp->resp);\n                free(resp);\n            }\n\n            free(re.msg);\n\n        }    /* end while(communicating) */\n        close(tac_fd);\n\n        if (status == PAM_SUCCESS || status == PAM_AUTHTOK_ERR)\n            break;\n    }\n\nfinish:\n    if (status != PAM_SUCCESS && status != PAM_AUTHTOK_ERR)\n        _pam_log(LOG_ERR, \"no more servers to connect\");\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: exit with pam status: %d\", __FUNCTION__, status);\n\n    if (NULL != pass) {\n        bzero(pass, strlen(pass));\n        free(pass);\n        pass = NULL;\n    }\n\n    return status;\n}    /* pam_sm_chauthtok */\n#endif\n\n\n#ifdef PAM_STATIC\nstruct pam_module _pam_tacplus_modstruct {\n    \"pam_tacplus\",\n    pam_sm_authenticate,\n    pam_sm_setcred,\n    pam_sm_acct_mgmt,\n    pam_sm_open_session,\n    pam_sm_close_session,\n#ifdef PAM_SM_PASSWORD\n    pam_sm_chauthtok\n#else\n    NULL\n#endif\n};\n#endif\n\n"], "fixing_code": ["/* pam_tacplus.c - PAM interface for TACACS+ protocol.\n *\n * Copyright (C) 2010, Pawel Krawczyk <pawel.krawczyk@hush.com> and\n * Jeroen Nijhof <jeroen@jeroennijhof.nl>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program - see the file COPYING.\n *\n * See `CHANGES' file for revision history.\n */\n\n#include \"pam_tacplus.h\"\n#include \"support.h\"\n\n#include <stdlib.h>     /* malloc */\n#include <stdio.h>\n#include <syslog.h>\n#include <netdb.h>      /* gethostbyname */\n#include <sys/socket.h> /* in_addr */\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdarg.h>     /* va_ */\n#include <signal.h>\n#include <string.h>     /* strdup */\n#include <ctype.h>\n#include <time.h>\n#include <unistd.h>\n#include <strings.h>\n\n#ifdef HAVE_CONFIG_H\n  #include \"config.h\"\n#endif\n\n/* address of server discovered by pam_sm_authenticate */\nstatic tacplus_server_t active_server;\n\n/* accounting task identifier */\nstatic short int task_id = 0;\n\n\n/* Helper functions */\nint _pam_send_account(int tac_fd, int type, const char *user, char *tty,\n    char *r_addr, char *cmd) {\n\n    char buf[64];\n    struct tac_attrib *attr;\n    int retval;\n\n    attr=(struct tac_attrib *)xcalloc(1, sizeof(struct tac_attrib));\n\n    sprintf(buf, \"%lu\", (unsigned long)time(NULL));\n\n    if (type == TAC_PLUS_ACCT_FLAG_START) {\n        tac_add_attrib(&attr, \"start_time\", buf);\n    } else if (type == TAC_PLUS_ACCT_FLAG_STOP) {\n        tac_add_attrib(&attr, \"stop_time\", buf);\n    }\n    sprintf(buf, \"%hu\", task_id);\n    tac_add_attrib(&attr, \"task_id\", buf);\n    tac_add_attrib(&attr, \"service\", tac_service);\n    if(tac_protocol[0] != '\\0')\n      tac_add_attrib(&attr, \"protocol\", tac_protocol);\n    if (cmd != NULL) {\n        tac_add_attrib(&attr, \"cmd\", cmd);\n    }\n\n    retval = tac_acct_send(tac_fd, type, user, tty, r_addr, attr);\n\n    /* this is no longer needed */\n    tac_free_attrib(&attr);\n\n    if(retval < 0) {\n        _pam_log (LOG_WARNING, \"%s: send %s accounting failed (task %hu)\",\n            __FUNCTION__,\n            tac_acct_flag2str(type),\n            task_id);\n        close(tac_fd);\n        return -1;\n    }\n\n    struct areply re;\n    if( tac_acct_read(tac_fd, &re) != TAC_PLUS_ACCT_STATUS_SUCCESS ) {\n        _pam_log (LOG_WARNING, \"%s: accounting %s failed (task %hu)\",\n            __FUNCTION__,\n            tac_acct_flag2str(type),\n            task_id);\n\n        if(re.msg != NULL)\n            free(re.msg);\n\n        close(tac_fd);\n        return -1;\n    }\n\n    if(re.msg != NULL)\n        free(re.msg);\n\n    close(tac_fd);\n    return 0;\n}\n\nint _pam_account(pam_handle_t *pamh, int argc, const char **argv,\n    int type, char *cmd) {\n\n    int retval;\n    static int ctrl;\n    char *user = NULL;\n    char *tty = NULL;\n    char *r_addr = NULL;\n    char *typemsg;\n    int status = PAM_SESSION_ERR;\n    int srv_i, tac_fd;\n\n    typemsg = tac_acct_flag2str(type);\n    ctrl = _pam_parse (argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        syslog (LOG_DEBUG, \"%s: [%s] called (pam_tacplus v%u.%u.%u)\",\n            __FUNCTION__, typemsg, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n        syslog(LOG_DEBUG, \"%s: tac_srv_no=%d\", __FUNCTION__, tac_srv_no);\n    }\n\n    if ((user = _pam_get_user(pamh)) == NULL)\n        return PAM_USER_UNKNOWN;\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: username [%s] obtained\", __FUNCTION__, user);\n\n    tty = _pam_get_terminal(pamh);\n    if(!strncmp(tty, \"/dev/\", 5))\n        tty += 5;\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);\n\n    r_addr = _pam_get_rhost(pamh);\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);\n\n    /* checks for specific data required by TACACS+, which should\n       be supplied in command line  */\n    if(*tac_service == '\\0') {\n        _pam_log (LOG_ERR, \"ACC: TACACS+ service type not configured\");\n        return PAM_AUTH_ERR;\n    }\n    if(*tac_protocol == '\\0') {\n        _pam_log (LOG_ERR, \"ACC: TACACS+ protocol type not configured (IGNORED)\");\n    }\n\n    /* when this module is called from within pppd or other\n       application dealing with serial lines, it is likely\n       that we will get hit with signal caused by modem hangup;\n       this is important only for STOP packets, it's relatively\n       rare that modem hangs up on accounting start */\n    if(type == TAC_PLUS_ACCT_FLAG_STOP) {\n        signal(SIGALRM, SIG_IGN);\n        signal(SIGCHLD, SIG_IGN);\n        signal(SIGHUP, SIG_IGN);\n    }\n\n    status = PAM_SESSION_ERR;\n    for(srv_i = 0; srv_i < tac_srv_no; srv_i++) {\n        tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);\n        if (tac_fd < 0) {\n            _pam_log(LOG_WARNING, \"%s: error sending %s (fd)\",\n                __FUNCTION__, typemsg);\n            continue;\n        }\n        if (ctrl & PAM_TAC_DEBUG)\n            syslog(LOG_DEBUG, \"%s: connected with fd=%d (srv %d)\", __FUNCTION__, tac_fd, srv_i);\n\n        retval = _pam_send_account(tac_fd, type, user, tty, r_addr, cmd);\n        if (retval < 0) {\n            _pam_log(LOG_WARNING, \"%s: error sending %s (acct)\",\n                __FUNCTION__, typemsg);\n        } else {\n            status = PAM_SUCCESS;\n            if (ctrl & PAM_TAC_DEBUG)\n                syslog(LOG_DEBUG, \"%s: [%s] for [%s] sent\", __FUNCTION__, typemsg, user);\n        }\n        close(tac_fd);\n\n        if ((status == PAM_SUCCESS) && !(ctrl & PAM_TAC_ACCT)) {\n            /* do not send acct start/stop packets to _all_ servers */\n            break;\n        }\n    }\n\n    if (type == TAC_PLUS_ACCT_FLAG_STOP) {\n        signal(SIGALRM, SIG_DFL);\n        signal(SIGCHLD, SIG_DFL);\n        signal(SIGHUP, SIG_DFL);\n    }\n    return status;\n}\n\n\n/* Main PAM functions */\n\n/* authenticates user on remote TACACS+ server\n * returns PAM_SUCCESS if the supplied username and password\n * pair is valid\n */\nPAM_EXTERN\nint pam_sm_authenticate (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    int ctrl, retval;\n    char *user;\n    char *pass;\n    char *tty;\n    char *r_addr;\n    int srv_i;\n    int tac_fd, status, msg, communicating;\n\n    user = pass = tty = r_addr = NULL;\n\n    ctrl = _pam_parse(argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\",\n            __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n\n    if ((user = _pam_get_user(pamh)) == NULL)\n        return PAM_USER_UNKNOWN;\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: user [%s] obtained\", __FUNCTION__, user);\n\n    retval = tacacs_get_password (pamh, flags, ctrl, &pass);\n    if (retval != PAM_SUCCESS || pass == NULL || *pass == '\\0') {\n        _pam_log(LOG_ERR, \"unable to obtain password\");\n        free(pass);\n        return PAM_CRED_INSUFFICIENT;\n    }\n\n    retval = pam_set_item (pamh, PAM_AUTHTOK, pass);\n    if (retval != PAM_SUCCESS) {\n        _pam_log(LOG_ERR, \"unable to set password\");\n        free(pass);\n        return PAM_CRED_INSUFFICIENT;\n    }\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: password obtained\", __FUNCTION__);\n\n    tty = _pam_get_terminal(pamh);\n    if (!strncmp(tty, \"/dev/\", 5))\n        tty += 5;\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);\n\n    r_addr = _pam_get_rhost(pamh);\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);\n\n    status = PAM_AUTHINFO_UNAVAIL;\n    for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {\n        if (ctrl & PAM_TAC_DEBUG)\n            syslog(LOG_DEBUG, \"%s: trying srv %d\", __FUNCTION__, srv_i );\n\n        tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);\n        if (tac_fd < 0) {\n            _pam_log(LOG_ERR, \"connection failed srv %d: %m\", srv_i);\n            continue;\n        }\n        if (tac_authen_send(tac_fd, user, pass, tty, r_addr, TAC_PLUS_AUTHEN_LOGIN) < 0) {\n            close(tac_fd);\n            _pam_log(LOG_ERR, \"error sending auth req to TACACS+ server\");\n            continue;\n        }\n        communicating = 1;\n        while (communicating) {\n            struct areply re = { .attr = NULL, .msg = NULL, status = 0, flags = 0 };\n            struct pam_message conv_msg = { .msg_style = 0, .msg = NULL };\n            struct pam_response *resp = NULL;\n\n            msg = tac_authen_read(tac_fd, &re);\n\n            if (NULL != re.msg) {\n                conv_msg.msg = re.msg;\n            }\n\n            /* talk the protocol */\n            switch (msg) {\n                case TAC_PLUS_AUTHEN_STATUS_PASS:\n                    /* success */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_PASS\");\n  \n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n\n                        conv_msg.msg_style = PAM_TEXT_INFO;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                        }\n\n                    }\n                    status = PAM_SUCCESS;\n                    communicating = 0;\n                    active_server.addr = tac_srv[srv_i].addr;\n                    active_server.key = tac_srv[srv_i].key;\n\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"%s: active srv %d\", __FUNCTION__, srv_i);\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_FAIL:\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FAIL\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n\n                        conv_msg.msg_style = PAM_ERROR_MSG;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                        }\n\n                    }\n                    status = PAM_AUTH_ERR;\n                    communicating = 0;\n\n                    _pam_log(LOG_ERR, \"auth failed: %d\", msg);\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETDATA:\n                    if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETDATA\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n                        int echo_off = (0x1 == (re.flags & 0x1));\n                        \n                        conv_msg.msg_style = echo_off ? PAM_PROMPT_ECHO_OFF : PAM_PROMPT_ECHO_ON;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG)) \n                                syslog(LOG_DEBUG, \"sent msg=\\\"%s\\\", resp=\\\"%s\\\"\",\n                                       conv_msg.msg, resp->resp);\n\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);\n\n                            if (0 > tac_cont_send_seq(tac_fd, resp->resp, re.seq_no + 1)) {\n                                _pam_log(LOG_ERR, \"error sending continue req to TACACS+ server\");\n                                status = PAM_AUTH_ERR;\n                                communicating = 0;\n                            }\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d (%s)\",\n                                     __FUNCTION__, conv_msg.msg, retval, pam_strerror(pamh, retval));\n                            status = PAM_AUTH_ERR;\n                            communicating = 0;\n                        }\n                    }\n                    else { \n                        syslog(LOG_ERR, \"GETDATA response with no message, returning PAM_AUTH_ERR\");\n\n                        status = PAM_AUTH_ERR;\n                        communicating = 0;\n                    }\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETUSER:\n                    /* not implemented */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETUSER\");\n\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETPASS:\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETPASS\");\n\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"%s: tac_cont_send called\", __FUNCTION__);\n\n                    if (tac_cont_send(tac_fd, pass) < 0) {\n                        _pam_log (LOG_ERR, \"error sending continue req to TACACS+ server\");\n                        communicating = 0;\n                    }\n                    /* continue the while loop; go read tac response */\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_RESTART:\n                    /* try it again */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_RESTART\");\n\n                    /*\n                     * not implemented\n                     * WdJ: I *think* you can just do tac_authen_send(user, pass) again\n                     *      but I'm not sure\n                     */\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_ERROR:\n                    /* server has problems */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_ERROR\");\n\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_FOLLOW:\n                    /* server tells to try a different server address */\n                    /* not implemented */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FOLLOW\");\n\n                    communicating = 0;\n                    break;\n\n                default:\n                    if (msg < 0) {\n                        /* connection error */\n                        communicating = 0;\n                        if (ctrl & PAM_TAC_DEBUG)\n                            syslog(LOG_DEBUG, \"error communicating with tacacs server\");\n                        break;\n                    }\n\n                    /* unknown response code */\n                    communicating = 0;\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: unknown response 0x%02x\", msg);\n            }\n\n            if (NULL != resp) {\n                free(resp->resp);\n                free(resp);\n            }\n                \n            free(re.msg);\n\n        }    /* end while(communicating) */\n        close(tac_fd);\n\n        if (status == PAM_SUCCESS || status == PAM_AUTH_ERR)\n            break;\n    }\n    if (status != PAM_SUCCESS && status != PAM_AUTH_ERR)\n        _pam_log(LOG_ERR, \"no more servers to connect\");\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: exit with pam status: %d\", __FUNCTION__, status);\n\n    if (NULL != pass) {\n        bzero(pass, strlen (pass));\n        free(pass);\n        pass = NULL;\n    }\n\n    return status;\n}    /* pam_sm_authenticate */\n\n\n/* no-op function to satisfy PAM authentication module */\nPAM_EXTERN\nint pam_sm_setcred (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    int ctrl = _pam_parse (argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"\n            , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n\n    return PAM_SUCCESS;\n}    /* pam_sm_setcred */\n\n\n/* authorizes user on remote TACACS+ server, i.e. checks\n * his permission to access requested service\n * returns PAM_SUCCESS if the service is allowed\n */\nPAM_EXTERN\nint pam_sm_acct_mgmt (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    int retval, ctrl, status=PAM_AUTH_ERR;\n    char *user;\n    char *tty;\n    char *r_addr;\n    struct areply arep;\n    struct tac_attrib *attr = NULL;\n    int tac_fd;\n\n    user = tty = r_addr = NULL;\n    memset(&arep, 0, sizeof(arep));\n\n    /* this also obtains service name for authorization\n       this should be normally performed by pam_get_item(PAM_SERVICE)\n       but since PAM service names are incompatible TACACS+\n       we have to pass it via command line argument until a better\n       solution is found ;) */\n    ctrl = _pam_parse (argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"\n            , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n\n    if ((user = _pam_get_user(pamh)) == NULL)\n        return PAM_USER_UNKNOWN;\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: username obtained [%s]\", __FUNCTION__, user);\n\n    tty = _pam_get_terminal(pamh);\n    if(!strncmp(tty, \"/dev/\", 5))\n        tty += 5;\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: tty obtained [%s]\", __FUNCTION__, tty);\n\n    r_addr = _pam_get_rhost(pamh);\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: rhost obtained [%s]\", __FUNCTION__, r_addr);\n\n    /* checks if user has been successfully authenticated\n       by TACACS+; we cannot solely authorize user if it hasn't\n       been authenticated or has been authenticated by method other\n       than TACACS+ */\n    if(active_server.addr == NULL) {\n        _pam_log (LOG_ERR, \"user not authenticated by TACACS+\");\n        return PAM_AUTH_ERR;\n    }\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog (LOG_DEBUG, \"%s: active server is [%s]\", __FUNCTION__,\n            tac_ntop(active_server.addr->ai_addr));\n\n    /* checks for specific data required by TACACS+, which should\n       be supplied in command line  */\n    if(!*tac_service) {\n        _pam_log (LOG_ERR, \"SM: TACACS+ service type not configured\");\n        return PAM_AUTH_ERR;\n    }\n    if(!*tac_protocol) {\n        _pam_log (LOG_ERR, \"SM: TACACS+ protocol type not configured (IGNORED)\");\n    }\n\n    tac_add_attrib(&attr, \"service\", tac_service);\n    if(tac_protocol[0] != '\\0')\n      tac_add_attrib(&attr, \"protocol\", tac_protocol);\n\n    tac_fd = tac_connect_single(active_server.addr, active_server.key, NULL, tac_timeout);\n    if(tac_fd < 0) {\n        _pam_log (LOG_ERR, \"TACACS+ server unavailable\");\n        if(arep.msg != NULL)\n            free (arep.msg);\n        return PAM_AUTH_ERR;\n    }\n\n    retval = tac_author_send(tac_fd, user, tty, r_addr, attr);\n\n    tac_free_attrib(&attr);\n\n    if(retval < 0) {\n        _pam_log (LOG_ERR, \"error getting authorization\");\n        if(arep.msg != NULL)\n            free (arep.msg);\n\n        close(tac_fd);\n        return PAM_AUTH_ERR;\n    }\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: sent authorization request\", __FUNCTION__);\n\n    tac_author_read(tac_fd, &arep);\n\n    if(arep.status != AUTHOR_STATUS_PASS_ADD &&\n        arep.status != AUTHOR_STATUS_PASS_REPL) {\n\n        _pam_log (LOG_ERR, \"TACACS+ authorisation failed for [%s]\", user);\n        if(arep.msg != NULL)\n            free (arep.msg);\n\n        close(tac_fd);\n        return PAM_PERM_DENIED;\n    }\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: user [%s] successfully authorized\", __FUNCTION__, user);\n\n    status = PAM_SUCCESS;\n\n    attr = arep.attr;\n    while (attr != NULL)  {\n        char attribute[attr->attr_len];\n        char value[attr->attr_len];\n        char *sep;\n\n        sep = index(attr->attr, '=');\n        if(sep == NULL)\n            sep = index(attr->attr, '*');\n        if(sep != NULL) {\n            bcopy(attr->attr, attribute, attr->attr_len-strlen(sep));\n            attribute[attr->attr_len-strlen(sep)] = '\\0';\n            bcopy(sep, value, strlen(sep));\n            value[strlen(sep)] = '\\0';\n\n            size_t i;\n            for (i = 0; attribute[i] != '\\0'; i++) {\n                attribute[i] = toupper(attribute[i]);\n                if (attribute[i] == '-')\n                    attribute[i] = '_';\n            }\n\n            if (ctrl & PAM_TAC_DEBUG)\n                syslog(LOG_DEBUG, \"%s: returned attribute `%s%s' from server\", __FUNCTION__, attribute, value);\n\n            /* make returned attributes available for other PAM modules via PAM environment */\n            if (pam_putenv(pamh, strncat(attribute, value, strlen(value))) != PAM_SUCCESS)\n                syslog(LOG_WARNING, \"%s: unable to set PAM environment\", __FUNCTION__);\n\n        } else {\n            syslog(LOG_WARNING, \"%s: invalid attribute `%s', no separator\", __FUNCTION__, attr->attr);\n        }\n        attr = attr->next;\n    }\n\n    /* free returned attributes */\n    if(arep.attr != NULL)\n        tac_free_attrib(&arep.attr);\n\n    if(arep.msg != NULL)\n        free (arep.msg);\n\n    close(tac_fd);\n\n    return status;\n}    /* pam_sm_acct_mgmt */\n\n/* sends START accounting request to the remote TACACS+ server\n * returns PAM error only if the request was refused or there\n * were problems connection to the server\n */\n/* accounting packets may be directed to any TACACS+ server,\n * independent from those used for authentication and authorization;\n * it may be also directed to all specified servers\n */\nPAM_EXTERN\nint pam_sm_open_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    task_id=(short int) magic();\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}    /* pam_sm_open_session */\n\n/* sends STOP accounting request to the remote TACACS+ server\n * returns PAM error only if the request was refused or there\n * were problems connection to the server\n */\nPAM_EXTERN\nint pam_sm_close_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_STOP, NULL);\n}    /* pam_sm_close_session */\n\n\n#ifdef PAM_SM_PASSWORD\n/* no-op function for future use */\nPAM_EXTERN\nint pam_sm_chauthtok(pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n\n    int ctrl, retval;\n    char *user;\n    char *pass;\n    char *tty;\n    char *r_addr;\n    const void *pam_pass = NULL;\n    int srv_i;\n    int tac_fd, status, msg, communicating;\n\n    user = pass = tty = r_addr = NULL;\n\n    ctrl = _pam_parse(argc, argv);\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\"\n            , __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);\n\n    syslog(LOG_DEBUG, \"%s(flags=%d, argc=%d)\", __func__, flags, argc);\n\n    if (   (pam_get_item(pamh, PAM_OLDAUTHTOK, &pam_pass) == PAM_SUCCESS)\n        && (pam_pass != NULL) ) {\n         if ((pass = strdup(pam_pass)) == NULL)\n              return PAM_BUF_ERR;\n    } else {\n        pass = strdup(\"\");\n    }\n    \n    if ((user = _pam_get_user(pamh)) == NULL) {\n        if(pass) {\n                free(pass);\n        }\n        return PAM_USER_UNKNOWN;\n    }\n    \n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: user [%s] obtained\", __FUNCTION__, user);\n\n    tty = _pam_get_terminal(pamh);\n    if (!strncmp(tty, \"/dev/\", 5))\n        tty += 5;\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: tty [%s] obtained\", __FUNCTION__, tty);\n\n    r_addr = _pam_get_rhost(pamh);\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: rhost [%s] obtained\", __FUNCTION__, r_addr);\n\n    if (PAM_SILENT == (flags & PAM_SILENT)) {\n        status = PAM_AUTHTOK_ERR;\n        goto finish;\n    }\n\n    status = PAM_TRY_AGAIN;\n    for (srv_i = 0; srv_i < tac_srv_no; srv_i++) {\n        if (ctrl & PAM_TAC_DEBUG)\n            syslog(LOG_DEBUG, \"%s: trying srv %d\", __FUNCTION__, srv_i );\n\n        tac_fd = tac_connect_single(tac_srv[srv_i].addr, tac_srv[srv_i].key, NULL, tac_timeout);\n        if (tac_fd < 0) {\n            _pam_log(LOG_ERR, \"connection failed srv %d: %m\", srv_i);\n            continue;\n        }\n        if (PAM_PRELIM_CHECK == (flags & PAM_PRELIM_CHECK)) {\n            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                syslog(LOG_DEBUG, \"%s: finishing PAM_PRELIM_CHECK with srv %d\",\n                       __FUNCTION__, srv_i);\n\n            close(tac_fd);\n            status = PAM_SUCCESS;\n            goto finish;\n        }\n\n        if (tac_authen_send(tac_fd, user, \"\", tty, r_addr, TAC_PLUS_AUTHEN_CHPASS) < 0) {\n            close(tac_fd);\n            _pam_log(LOG_ERR, \"error sending auth req to TACACS+ server\");\n            continue;\n        }\n        communicating = 1;\n        while (communicating) {\n            struct areply re = { .attr = NULL, .msg = NULL, status = 0, flags = 0 };\n            struct pam_message conv_msg = { .msg_style = 0, .msg = NULL };\n            struct pam_response *resp = NULL;\n\n            msg = tac_authen_read(tac_fd, &re);\n\n            if (NULL != re.msg) {\n                conv_msg.msg = re.msg;\n            }\n\n            /* talk the protocol */\n            switch (msg) {\n                case TAC_PLUS_AUTHEN_STATUS_PASS:\n                    /* success */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_PASS\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n\n                        conv_msg.msg_style = PAM_TEXT_INFO;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                        }\n\n                    }\n                    status = PAM_SUCCESS;\n                    communicating = 0;\n\n                    active_server.addr = tac_srv[srv_i].addr;\n                    active_server.key = tac_srv[srv_i].key;\n\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"%s: active srv %d\", __FUNCTION__, srv_i);\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_FAIL:\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FAIL\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n\n                        conv_msg.msg_style = PAM_ERROR_MSG;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"send msg=\\\"%s\\\"\", conv_msg.msg);\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                        }\n\n                    }\n                    status = PAM_AUTHTOK_ERR;\n                    communicating = 0;\n\n                    _pam_log(LOG_ERR, \"chauthtok failed: %d\", msg);\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETDATA:\n                    if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETDATA\");\n\n                    if (NULL != conv_msg.msg) {\n                        int retval = -1;\n                        int echo_off = (0x1 == (re.flags & 0x1));\n                        \n                        conv_msg.msg_style = echo_off ? PAM_PROMPT_ECHO_OFF : PAM_PROMPT_ECHO_ON;\n                        retval = converse(pamh, 1, &conv_msg, &resp);\n                        if (PAM_SUCCESS == retval) {\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG)) \n                                syslog(LOG_DEBUG, \"sent msg=\\\"%s\\\", resp=\\\"%s\\\"\",\n                                       conv_msg.msg, resp->resp);\n\n                            if (PAM_TAC_DEBUG == (ctrl & PAM_TAC_DEBUG))\n                                syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);\n\n                            if (0 > tac_cont_send_seq(tac_fd, resp->resp, re.seq_no + 1)) {\n                                _pam_log(LOG_ERR, \"error sending continue req to TACACS+ server\");\n                                communicating = 0;\n                            }\n                        }\n                        else {\n                            _pam_log(LOG_WARNING, \"%s: error sending msg=\\\"%s\\\", retval=%d\",\n                                     __FUNCTION__, conv_msg.msg, retval);\n                            communicating = 0;\n                        }\n                    }\n                    else { \n                        syslog(LOG_ERR, \"GETDATA response with no message, returning PAM_TRY_AGAIN\");\n                        communicating = 0;\n                    }\n\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETUSER:\n                    /* not implemented */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETUSER\");\n\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_GETPASS:\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_GETPASS\");\n\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"%s: calling tac_cont_send\", __FUNCTION__);\n\n                    if (tac_cont_send(tac_fd, pass) < 0) {\n                        _pam_log (LOG_ERR, \"error sending continue req to TACACS+ server\");\n                        communicating = 0;\n                        break;\n                    }\n                    /* continue the while loop; go read tac response */\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_RESTART:\n                    /* try it again */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_RESTART\");\n\n                    /*\n                     * not implemented\n                     * WdJ: I *think* you can just do tac_authen_send(user, pass) again\n                     *      but I'm not sure\n                     */\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_ERROR:\n                    /* server has problems */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_ERROR\");\n\n                    communicating = 0;\n                    break;\n\n                case TAC_PLUS_AUTHEN_STATUS_FOLLOW:\n                    /* server tells to try a different server address */\n                    /* not implemented */\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: TAC_PLUS_AUTHEN_STATUS_FOLLOW\");\n\n                    communicating = 0;\n                    break;\n\n                default:\n                    if (msg < 0) {\n                        /* connection error */\n                        communicating = 0;\n                        if (ctrl & PAM_TAC_DEBUG)\n                            syslog(LOG_DEBUG, \"error communicating with tacacs server\");\n                        break;\n                    }\n\n                    /* unknown response code */\n                    communicating = 0;\n                    if (ctrl & PAM_TAC_DEBUG)\n                        syslog(LOG_DEBUG, \"tacacs status: unknown response 0x%02x\", msg);\n            }\n\n            if (NULL != resp) {\n                free(resp->resp);\n                free(resp);\n            }\n\n            free(re.msg);\n\n        }    /* end while(communicating) */\n        close(tac_fd);\n\n        if (status == PAM_SUCCESS || status == PAM_AUTHTOK_ERR)\n            break;\n    }\n\nfinish:\n    if (status != PAM_SUCCESS && status != PAM_AUTHTOK_ERR)\n        _pam_log(LOG_ERR, \"no more servers to connect\");\n\n    if (ctrl & PAM_TAC_DEBUG)\n        syslog(LOG_DEBUG, \"%s: exit with pam status: %d\", __FUNCTION__, status);\n\n    if (NULL != pass) {\n        bzero(pass, strlen(pass));\n        free(pass);\n        pass = NULL;\n    }\n\n    return status;\n}    /* pam_sm_chauthtok */\n#endif\n\n\n#ifdef PAM_STATIC\nstruct pam_module _pam_tacplus_modstruct {\n    \"pam_tacplus\",\n    pam_sm_authenticate,\n    pam_sm_setcred,\n    pam_sm_acct_mgmt,\n    pam_sm_open_session,\n    pam_sm_close_session,\n#ifdef PAM_SM_PASSWORD\n    pam_sm_chauthtok\n#else\n    NULL\n#endif\n};\n#endif\n\n"], "filenames": ["pam_tacplus.c"], "buggy_code_start_loc": [518], "buggy_code_end_loc": [518], "fixing_code_start_loc": [519], "fixing_code_end_loc": [520], "type": "NVD-CWE-Other", "message": "In pam_tacplus.c in pam_tacplus before 1.4.1, pam_sm_acct_mgmt does not zero out the arep data structure.", "other": {"cve": {"id": "CVE-2016-20014", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-21T04:15:09.203", "lastModified": "2022-05-02T18:16:02.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In pam_tacplus.c in pam_tacplus before 1.4.1, pam_sm_acct_mgmt does not zero out the arep data structure."}, {"lang": "es", "value": "En el archivo pam_tacplus.c en pam_tacplus versiones anteriores a 1.4.1, la funci\u00f3n pam_sm_acct_mgmt no pone a cero la estructura de datos arep"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pam_tacplus_project:pam_tacplus:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.1", "matchCriteriaId": "EB1244AC-5342-4405-8B88-1615435F798C"}]}]}], "references": [{"url": "https://github.com/kravietz/pam_tacplus/commit/e4c00eba70a0f72c4de77b5f072c69708ec2beab", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kravietz/pam_tacplus/commit/e4c00eba70a0f72c4de77b5f072c69708ec2beab"}}