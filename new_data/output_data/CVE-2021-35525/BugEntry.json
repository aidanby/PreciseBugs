{"buggy_code": ["/* PostSRSd - Sender Rewriting Scheme daemon for Postfix\n * Copyright (c) 2012-2020 Timo R\u00f6hling <timo@gaussglocke.de>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* This program uses the libsrs2 library. The relevant source\n * files have been added to this distribution. */\n\n#include \"srs2.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <netdb.h>\n#include <poll.h>\n#include <pwd.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#ifdef HAVE_SYS_TIME_H\n#    include <sys/time.h>\n#endif\n#ifdef HAVE_TIME_H\n#    include <time.h>\n#endif\n#ifdef HAVE_SYS_WAIT_H\n#    include <sys/wait.h>\n#endif\n#ifdef HAVE_WAIT_H\n#    include <wait.h>\n#endif\n#include <syslog.h>\n\nstatic char *self = NULL;\n\nstatic size_t bind_service(const char *listen_addr, const char *service,\n                           int family, int *socks, size_t max_socks)\n{\n    struct addrinfo *addr, *it;\n    struct addrinfo hints;\n    int err, sock, flags;\n    size_t count = 0;\n    static const int one = 1;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_socktype = SOCK_STREAM;\n\n    err = getaddrinfo(listen_addr, service, &hints, &addr);\n    if (err != 0)\n    {\n        fprintf(stderr, \"%s: bind_service(%s): %s\\n\", self, service,\n                gai_strerror(err));\n        return count;\n    }\n    sock = -1;\n    for (it = addr; it; it = it->ai_next)\n    {\n        if (max_socks == 0)\n            break;\n        sock = socket(it->ai_family, it->ai_socktype, it->ai_protocol);\n        if (sock < 0)\n            goto fail;\n        if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) < 0)\n            goto fail;\n        if (bind(sock, it->ai_addr, it->ai_addrlen) < 0)\n            goto fail;\n        if (listen(sock, 10) < 0)\n            goto fail;\n        flags = fcntl(sock, F_GETFL, 0);\n        if (flags < 0)\n            goto fail;\n        if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0)\n            goto fail;\n        *socks++ = sock;\n        ++count;\n        --max_socks;\n        continue;\n    fail:\n        err = errno;\n        if (sock >= 0)\n            close(sock);\n    }\n    freeaddrinfo(addr);\n    if (count == 0)\n        fprintf(stderr, \"%s: bind_service(%s): %s\\n\", self, service,\n                strerror(err));\n    return count;\n}\n\nstatic int is_hexdigit(char c)\n{\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')\n           || (c >= 'A' && c <= 'F');\n}\n\nstatic char hex2num(char c)\n{\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    return 0;\n}\n\nstatic char num2hex(char c)\n{\n    if (c < 10)\n        return '0' + c;\n    return 'a' + c - 10;\n}\n\nstatic char hex2char(const char *s)\n{\n    return 16 * hex2num(s[0]) + hex2num(s[1]);\n}\n\nstatic void char2hex(char c, char *buf)\n{\n    buf[0] = num2hex((c >> 4) & 0xf);\n    buf[1] = num2hex((c)&0xf);\n}\n\nstatic char *url_decode(char *buf, size_t len, const char *input)\n{\n    char *output = buf;\n    if (!input || !output || len == 0)\n        return NULL;\n\n    while (*input && --len)\n    {\n        if (*input == '%')\n        {\n            if (is_hexdigit(input[1]) && is_hexdigit(input[2]))\n            {\n                *output++ = hex2char(++input);\n                input += 2;\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        else\n        {\n            *output++ = *input++;\n        }\n    }\n    *output = 0;\n    return buf;\n}\n\nstatic char *url_encode(char *buf, size_t len, const char *input)\n{\n    char *output = buf;\n    if (!input || !output || len == 0)\n        return NULL;\n    while (*input && --len)\n    {\n        if (!isascii(*input) || !isgraph(*input) || *input == '%')\n        {\n            if (len <= 2)\n                break;\n            *output++ = '%';\n            char2hex(*input++, output);\n            output += 2;\n            len -= 2;\n        }\n        else\n        {\n            *output++ = *input++;\n        }\n    }\n    *output = 0;\n    return buf;\n}\n\nstatic void handle_forward(srs_t *srs, FILE *fp, const char *address,\n                           const char *domain, const char **excludes)\n{\n    int result;\n    size_t addrlen;\n    char value[1024];\n    char outputbuf[1024], *output;\n\n    addrlen = strlen(address);\n    for (; *excludes; excludes++)\n    {\n        size_t len;\n        len = strlen(*excludes);\n        if (len >= addrlen)\n            continue;\n        if (strcasecmp(*excludes, &address[addrlen - len]) == 0\n            && (**excludes == '.' || address[addrlen - len - 1] == '@'))\n        {\n            syslog(LOG_MAIL | LOG_INFO,\n                   \"srs_forward: <%s> not rewritten: Domain excluded by policy\",\n                   address);\n            fputs(\"500 Domain excluded py policy\\n\", fp);\n            fflush(fp);\n            return;\n        }\n    }\n    if (srs_reverse(srs, value, sizeof(value), address) == SRS_SUCCESS)\n    {\n        fprintf(fp, \"500 Already rewritten\\n\");\n        fflush(fp);\n        syslog(LOG_MAIL | LOG_NOTICE,\n               \"srs_forward: <%s> not rewritten: Valid SRS address for <%s>\",\n               address, value);\n        return;\n    }\n    result = srs_forward(srs, value, sizeof(value), address, domain);\n    if (result == SRS_SUCCESS)\n    {\n        output = url_encode(outputbuf, sizeof(outputbuf), value);\n        fprintf(fp, \"200 %s\\n\", output);\n        if (strcmp(address, value) != 0)\n            syslog(LOG_MAIL | LOG_INFO, \"srs_forward: <%s> rewritten as <%s>\",\n                   address, value);\n    }\n    else\n    {\n        fprintf(fp, \"500 %s\\n\", srs_strerror(result));\n        if (result != SRS_ENOTREWRITTEN)\n            syslog(LOG_MAIL | LOG_INFO, \"srs_forward: <%s> not rewritten: %s\",\n                   address, srs_strerror(result));\n    }\n    fflush(fp);\n}\n\nstatic void handle_reverse(srs_t *srs, FILE *fp, const char *address,\n                           const char *domain __attribute__((unused)),\n                           const char **excludes __attribute__((unused)))\n{\n    int result;\n    char value[1024];\n    char outputbuf[1024], *output;\n    result = srs_reverse(srs, value, sizeof(value), address);\n    if (result == SRS_SUCCESS)\n    {\n        output = url_encode(outputbuf, sizeof(outputbuf), value);\n        fprintf(fp, \"200 %s\\n\", output);\n        syslog(LOG_MAIL | LOG_INFO, \"srs_reverse: <%s> rewritten as <%s>\",\n               address, value);\n    }\n    else\n    {\n        fprintf(fp, \"500 %s\\n\", srs_strerror(result));\n        if (result != SRS_ENOTREWRITTEN && result != SRS_ENOTSRSADDRESS)\n            syslog(LOG_MAIL | LOG_INFO, \"srs_reverse: <%s> not rewritten: %s\",\n                   address, srs_strerror(result));\n    }\n    fflush(fp);\n}\n\nstatic void show_help()\n{\n    fprintf(\n        stdout,\n        \"Sender Rewriting Scheme implementation for Postfix.\\n\\n\"\n        \"Implements two TCP lookup tables to rewrite mail addresses\\n\"\n        \"as needed. The forward SRS is for sender envelope addresses\\n\"\n        \"to prevent SPF-related bounces. The reverse SRS is for\\n\"\n        \"recipient envelope addresses so that bounced mails can be\\n\"\n        \"routed back to their original sender.\\n\"\n        \"\\n\"\n        \"Usage: %s -s<file> -d<domain> [other options]\\n\"\n        \"Options:\\n\"\n        \"   -s<file>       read secrets from file (required)\\n\"\n        \"   -d<domain>     set domain name for rewrite (required)\\n\"\n        \"   -a<char>       set first separator character which can be one of: \"\n        \"-=+ (default: =)\\n\"\n        \"   -n<num>        length of hash to be used in rewritten addresses \"\n        \"(default: 4)\\n\"\n        \"   -N<num>        minimum length of hash to accept for validation \"\n        \"(default: 4)\\n\"\n        \"   -l<addr>       set socket listen address (default: 127.0.0.1)\\n\"\n        \"   -f<port>       set port for the forward SRS lookup (default: \"\n        \"10001)\\n\"\n        \"   -r<port>       set port for the reverse SRS lookup (default: \"\n        \"10002)\\n\"\n        \"   -p<pidfile>    write process ID to pidfile (default: none)\\n\"\n        \"   -c<dir>        chroot to <dir> (default: none)\\n\"\n        \"   -u<user>       switch user id after port bind (default: none)\\n\"\n        \"   -t<seconds>    timeout for idle client connections (default: \"\n        \"1800)\\n\"\n        \"   -X<domain>     exclude additional domain from address rewriting\\n\"\n        \"   -A             always rewrite addresses\\n\"\n        \"   -e             attempt to read above parameters from environment\\n\"\n        \"   -D             fork into background\\n\"\n        \"   -4             force IPv4 socket (default: any)\\n\"\n        \"   -6             force IPv6 socket (default: any)\\n\"\n        \"   -h             show this help\\n\"\n        \"   -v             show version\\n\"\n        \"\\n\",\n        self);\n}\n\ntypedef void (*handle_t)(srs_t *, FILE *, const char *, const char *,\n                         const char **);\n\nint main(int argc, char **argv)\n{\n    int opt, timeout = 1800, family = AF_UNSPEC, hashlength = 0, hashmin = 0;\n    int daemonize = FALSE, always_rewrite = FALSE;\n    char *listen_addr = NULL, *forward_service = NULL, *reverse_service = NULL,\n         *user = NULL, *domain = NULL, *chroot_dir = NULL;\n    char separator = '=';\n    char *secret_file = NULL, *pid_file = NULL;\n    FILE *pf = NULL, *sf = NULL;\n    struct passwd *pwd = NULL;\n    char secretbuf[1024], *secret = NULL;\n    char *tmp;\n    time_t now;\n    srs_t *srs;\n    const char **excludes;\n    size_t s1 = 0, s2 = 1;\n    struct pollfd fds[4];\n    size_t socket_count = 0, sc;\n    int sockets[4] = {-1, -1, -1, -1};\n    handle_t handler[4] = {0, 0, 0, 0};\n    int fd, maxfd;\n\n    excludes = (const char **)calloc(1, sizeof(char *));\n    tmp = strrchr(argv[0], '/');\n    if (tmp)\n        self = strdup(tmp + 1);\n    else\n        self = strdup(argv[0]);\n\n    while ((opt = getopt(argc, argv, \"46d:a:l:f:r:s:n:N:u:t:p:c:X::ADhev\"))\n           != -1)\n    {\n        switch (opt)\n        {\n            case '?':\n                return EXIT_FAILURE;\n            case '4':\n                family = AF_INET;\n                break;\n            case '6':\n                family = AF_INET6;\n                break;\n            case 'd':\n                domain = strdup(optarg);\n                break;\n            case 'a':\n                separator = *optarg;\n                break;\n            case 'l':\n                listen_addr = strdup(optarg);\n                break;\n            case 'f':\n                forward_service = strdup(optarg);\n                break;\n            case 'r':\n                reverse_service = strdup(optarg);\n                break;\n            case 't':\n                timeout = atoi(optarg);\n                break;\n            case 's':\n                secret_file = strdup(optarg);\n                break;\n            case 'n':\n                hashlength = atoi(optarg);\n                break;\n            case 'N':\n                hashmin = atoi(optarg);\n                break;\n            case 'p':\n                pid_file = strdup(optarg);\n                break;\n            case 'u':\n                user = strdup(optarg);\n                break;\n            case 'c':\n                chroot_dir = strdup(optarg);\n                break;\n            case 'D':\n                daemonize = TRUE;\n                break;\n            case 'A':\n                always_rewrite = TRUE;\n                break;\n            case 'h':\n                show_help();\n                return EXIT_SUCCESS;\n            case 'X':\n                if (optarg != NULL)\n                {\n                    tmp = strtok(optarg, \",; \\t\\r\\n\");\n                    while (tmp)\n                    {\n                        if (s1 + 1 >= s2)\n                        {\n                            s2 *= 2;\n                            excludes = (const char **)realloc(\n                                excludes, s2 * sizeof(char *));\n                            if (excludes == NULL)\n                            {\n                                fprintf(stderr, \"%s: Out of memory\\n\\n\", self);\n                                return EXIT_FAILURE;\n                            }\n                        }\n                        excludes[s1++] = strdup(tmp);\n                        tmp = strtok(NULL, \",; \\t\\r\\n\");\n                    }\n                    excludes[s1] = NULL;\n                }\n                break;\n            case 'e':\n                if (getenv(\"SRS_DOMAIN\") != NULL)\n                    domain = strdup(getenv(\"SRS_DOMAIN\"));\n                if (getenv(\"SRS_SEPARATOR\") != NULL)\n                    separator = *getenv(\"SRS_SEPARATOR\");\n                if (getenv(\"SRS_HASHLENGTH\") != NULL)\n                    hashlength = atoi(getenv(\"SRS_HASHLENGTH\"));\n                if (getenv(\"SRS_HASHMIN\") != NULL)\n                    hashmin = atoi(getenv(\"SRS_HASHMIN\"));\n                if (getenv(\"SRS_FORWARD_PORT\") != NULL)\n                    forward_service = strdup(getenv(\"SRS_FORWARD_PORT\"));\n                if (getenv(\"SRS_REVERSE_PORT\") != NULL)\n                    reverse_service = strdup(getenv(\"SRS_REVERSE_PORT\"));\n                if (getenv(\"SRS_TIMEOUT\") != NULL)\n                    timeout = atoi(getenv(\"SRS_TIMEOUT\"));\n                if (getenv(\"SRS_SECRET\") != NULL)\n                    secret_file = strdup(getenv(\"SRS_SECRET\"));\n                if (getenv(\"SRS_PID_FILE\") != NULL)\n                    pid_file = strdup(getenv(\"SRS_PID_FILE\"));\n                if (getenv(\"RUN_AS\") != NULL)\n                    user = strdup(getenv(\"RUN_AS\"));\n                if (getenv(\"CHROOT\") != NULL)\n                    chroot_dir = strdup(getenv(\"CHROOT\"));\n                if (getenv(\"SRS_EXCLUDE_DOMAINS\") != NULL)\n                {\n                    tmp = strtok(getenv(\"SRS_EXCLUDE_DOMAINS\"), \",; \\t\\r\\n\");\n                    while (tmp)\n                    {\n                        if (s1 + 1 >= s2)\n                        {\n                            s2 *= 2;\n                            excludes = (const char **)realloc(\n                                excludes, s2 * sizeof(char *));\n                            if (excludes == NULL)\n                            {\n                                fprintf(stderr, \"%s: Out of memory\\n\\n\", self);\n                                return EXIT_FAILURE;\n                            }\n                        }\n                        excludes[s1++] = strdup(tmp);\n                        tmp = strtok(NULL, \",; \\t\\r\\n\");\n                    }\n                    excludes[s1] = NULL;\n                }\n                break;\n            case 'v':\n                fprintf(stdout, \"%s\\n\", POSTSRSD_VERSION);\n                return EXIT_SUCCESS;\n        }\n    }\n    if (optind < argc)\n    {\n        fprintf(stderr, \"%s: extra argument on command line: %s\\n\", self,\n                argv[optind]);\n        return EXIT_FAILURE;\n    }\n    if (domain == NULL || *domain == 0)\n    {\n        fprintf(stderr, \"%s: You must set a home domain (-d)\\n\", self);\n        return EXIT_FAILURE;\n    }\n\n    if (separator != '=' && separator != '+' && separator != '-')\n    {\n        fprintf(stderr, \"%s: SRS separator character must be one of '=+-'\\n\",\n                self);\n        return EXIT_FAILURE;\n    }\n    if (forward_service == NULL)\n        forward_service = strdup(\"10001\");\n    if (reverse_service == NULL)\n        reverse_service = strdup(\"10002\");\n\n    /* Close all file descriptors (std ones will be closed later). */\n    maxfd = sysconf(_SC_OPEN_MAX);\n    for (fd = 3; fd < maxfd; fd++)\n        close(fd);\n\n    /* The stuff we do first may not be possible from within chroot or without\n     * privileges */\n\n    /* Open pid file for writing (the actual process ID is filled in later) */\n    if (pid_file)\n    {\n        pf = fopen(pid_file, \"w\");\n        if (pf == NULL)\n        {\n            fprintf(stderr, \"%s: Cannot write PID: %s\\n\\n\", self, pid_file);\n            return EXIT_FAILURE;\n        }\n    }\n    /* Read secret. The default installation makes this root accessible only. */\n    if (secret_file != NULL)\n    {\n        sf = fopen(secret_file, \"rb\");\n        if (sf == NULL)\n        {\n            fprintf(stderr, \"%s: Cannot open file with secret: %s\\n\", self,\n                    secret_file);\n            return EXIT_FAILURE;\n        }\n    }\n    else\n    {\n        fprintf(stderr, \"%s: You must set a secret (-s)\\n\", self);\n        return EXIT_FAILURE;\n    }\n    /* Bind ports. May require privileges if the config specifies ports below\n     * 1024 */\n    sc = bind_service(listen_addr, forward_service, family,\n                      &sockets[socket_count], 4 - socket_count);\n    if (sc == 0)\n        return EXIT_FAILURE;\n    while (sc-- > 0)\n        handler[socket_count++] = handle_forward;\n    free(forward_service);\n    sc = bind_service(listen_addr, reverse_service, family,\n                      &sockets[socket_count], 4 - socket_count);\n    if (sc == 0)\n        return EXIT_FAILURE;\n    while (sc-- > 0)\n        handler[socket_count++] = handle_reverse;\n    free(reverse_service);\n    /* Open syslog now (NDELAY), because it may no longer be reachable from\n     * chroot */\n    openlog(self, LOG_PID | LOG_NDELAY, LOG_MAIL);\n    /* Force loading of timezone info (suggested by patrickdk77) */\n    now = time(NULL);\n    localtime(&now);\n    /* We also have to lookup the uid of the unprivileged user before the\n     * chroot. */\n    if (user)\n    {\n        errno = 0;\n        pwd = getpwnam(user);\n        if (pwd == NULL)\n        {\n            if (errno != 0)\n                fprintf(stderr, \"%s: Failed to lookup user: %s\\n\", self,\n                        strerror(errno));\n            else\n                fprintf(stderr, \"%s: No such user: %s\\n\", self, user);\n            return EXIT_FAILURE;\n        }\n    }\n    /* Now we can chroot, which again requires root privileges */\n    if (chroot_dir)\n    {\n        if (chdir(chroot_dir) < 0)\n        {\n            fprintf(stderr, \"%s: Cannot change to chroot: %s\\n\", self,\n                    strerror(errno));\n            return EXIT_FAILURE;\n        }\n        if (chroot(chroot_dir) < 0)\n        {\n            fprintf(stderr, \"%s: Failed to enable chroot: %s\\n\", self,\n                    strerror(errno));\n            return EXIT_FAILURE;\n        }\n    }\n    /* Finally, we revert to the unprivileged user */\n    if (pwd)\n    {\n        if (setgid(pwd->pw_gid) < 0)\n        {\n            fprintf(stderr, \"%s: Failed to switch group id: %s\\n\", self,\n                    strerror(errno));\n            return EXIT_FAILURE;\n        }\n        if (setuid(pwd->pw_uid) < 0)\n        {\n            fprintf(stderr, \"%s: Failed to switch user id: %s\\n\", self,\n                    strerror(errno));\n            return EXIT_FAILURE;\n        }\n    }\n    /* Standard double fork technique to disavow all knowledge about the\n     * controlling terminal */\n    if (daemonize)\n    {\n        close(0);\n        close(1);\n        close(2);\n        if (fork() != 0)\n            return EXIT_SUCCESS;\n        setsid();\n        if (fork() != 0)\n            return EXIT_SUCCESS;\n    }\n    /* Make note of our actual process ID */\n    if (pf)\n    {\n        fprintf(pf, \"%d\", (int)getpid());\n        fclose(pf);\n    }\n\n    srs = srs_new();\n    while ((secret = fgets(secretbuf, sizeof(secretbuf), sf)))\n    {\n        secret = strtok(secret, \"\\r\\n\");\n        if (secret)\n            srs_add_secret(srs, secret);\n    }\n    fclose(sf);\n\n    srs_set_alwaysrewrite(srs, always_rewrite);\n    srs_set_separator(srs, separator);\n    if (hashlength)\n        srs_set_hashlength(srs, hashlength);\n    if (hashmin)\n        srs_set_hashmin(srs, hashmin);\n\n    for (sc = 0; sc < socket_count; ++sc)\n    {\n        fds[sc].fd = sockets[sc];\n        fds[sc].events = POLLIN;\n    }\n    while (TRUE)\n    {\n        int conn;\n        FILE *fp;\n        char linebuf[1024], *line;\n        char keybuf[1024], *key;\n\n        if (poll(fds, socket_count, 1000) < 0)\n        {\n            if (errno == EINTR)\n                continue;\n            if (daemonize)\n                syslog(LOG_MAIL | LOG_ERR, \"Poll failure: %s\", strerror(errno));\n            else\n                fprintf(stderr, \"%s: Poll failure: %s\\n\", self,\n                        strerror(errno));\n            return EXIT_FAILURE;\n        }\n        for (sc = 0; sc < socket_count; ++sc)\n        {\n            if (fds[sc].revents)\n            {\n                conn = accept(fds[sc].fd, NULL, NULL);\n                if (conn < 0)\n                    continue;\n                if (fork() == 0)\n                {\n                    int i;\n                    /* close listen sockets so that we don't stop the main\n                     * daemon process from restarting */\n                    for (i = 0; i < socket_count; ++i)\n                        close(sockets[i]);\n\n                    fp = fdopen(conn, \"r+\");\n                    if (fp == NULL)\n                        exit(EXIT_FAILURE);\n                    fds[0].fd = conn;\n                    fds[0].events = POLLIN;\n                    if (poll(fds, 1, timeout * 1000) <= 0)\n                        return EXIT_FAILURE;\n                    line = fgets(linebuf, sizeof(linebuf), fp);\n                    while (line)\n                    {\n                        fseek(fp, 0, SEEK_CUR); /* Workaround for Solaris */\n                        char *token;\n                        token = strtok(line, \" \\r\\n\");\n                        if (token == NULL || strcmp(token, \"get\") != 0)\n                        {\n                            fprintf(fp, \"500 Invalid request\\n\");\n                            fflush(fp);\n                            return EXIT_FAILURE;\n                        }\n                        token = strtok(NULL, \"\\r\\n\");\n                        if (!token)\n                        {\n                            fprintf(fp, \"500 Invalid request\\n\");\n                            fflush(fp);\n                            return EXIT_FAILURE;\n                        }\n                        key = url_decode(keybuf, sizeof(keybuf), token);\n                        if (!key)\n                        {\n                            fprintf(fp, \"500 Invalid request\\n\");\n                            fflush(fp);\n                            return EXIT_FAILURE;\n                        }\n                        handler[sc](srs, fp, key, domain, excludes);\n                        fflush(fp);\n                        if (poll(fds, 1, timeout * 1000) <= 0)\n                            break;\n                        line = fgets(linebuf, sizeof(linebuf), fp);\n                    }\n                    fclose(fp);\n                    return EXIT_SUCCESS;\n                }\n                close(conn);\n            }\n        }\n        waitpid(-1, NULL, WNOHANG);\n    }\n    return EXIT_SUCCESS;\n}\n", "#!/usr/bin/env bats\n# vim: filetype=bash:\n\nif [ ! -x \"$POSTSRSD\" ]\nthen\n\tfor builddir in . build* obj*\n\tdo\n\t\tif [ -x \"${builddir}/postsrsd\" ]\n\t\tthen\n\t\t\tPOSTSRSD=\"${builddir}/postsrsd\"\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\nif [ ! -x \"$POSTSRSD\" ]\nthen\n\tcat>&2 <<- EOF\n\tcannot find postsrsd executable (looked in ., build*, obj*)\n\tplease build the executable first, or set the POSTSRSD\n\tenvironment variable if it is in a different location.\n\n\tEOF\n\texit 1\nfi\n\nLANG=C.UTF-8\n\n\nstart_postsrsd_at()\n{\n\techo 'tops3cr3t' > \"$BATS_TMPDIR/postsrsd.secret\"\n\tlocal faketime=\"$1\"\n\tshift\n\tfaketime \"${faketime}\" ${POSTSRSD} -D -f 10001 -r 10002 -p \"$BATS_TMPDIR/postsrsd.pid\" -s \"$BATS_TMPDIR/postsrsd.secret\" -d example.com \"$@\"\n}\n\nstop_postsrsd()\n{\n\tif [ -r $BATS_TMPDIR/postsrsd.pid ] && kill -0 $(< $BATS_TMPDIR/postsrsd.pid) &>/dev/null\n\tthen\n\t\tkill -TERM $(< $BATS_TMPDIR/postsrsd.pid)\n\tfi\n\trm -f $BATS_TMPDIR/postsrsd.pid\n}\n\nteardown()\n{\n\tstop_postsrsd\n}\n\n@test \"SRS forward rewrite\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\t# email address that needs not be rewritten\n\techo>&9 \"get test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" = \"200 test@example.com\" ]]\n\t# regular email address rewrite\n\techo>&9 \"get test@otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=vmyz=2W=otherdomain.com=test@example.com\" ]]\n\t# invalid email address without domain part\n\techo>&9 \"get bla\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No at sign\" ]]\n\t# Test double-rewrite\n\techo>&9 \"get SRS0=XjO9=2V=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Already rewritten\" ]]\n\t# Test rewrite of an SRS0 address from somewhere else\n\techo>&9 \"get SRS0=opaque+string@otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS1=\" ]]\n\t# Test rewrite of an SRS1 aaddress\n\techo>&9 \"get SRS1=X=thirddomain.com==opaque+string@otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS1=JIBX=thirddomain.com==opaque+string@example.com\" ]]\n\t# rewrite address with URL encoding\n\techo>&9 \"get test%40otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=vmyz=2W=otherdomain.com=test@example.com\" ]]\n}\n\n@test \"SRS reverse rewrite\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n\texec 9<>/dev/tcp/127.0.0.1/10002\n\t# Test regular SRS reversal\n\techo>&9 \"get SRS0=XjO9=2V=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 test@otherdomain.com\" ]]\n\t# Test SRS1 address\n\techo>&9 \"get SRS1=JIBX=thirddomain.com==opaque+string@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=opaque+string@thirddomain.com\" ]]\n\t# Test non-SRS address\n\techo>&9 \"get test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Not an SRS address\" ]]\n\t# Test valid address with timestamp 6 months in the past\n\techo>&9 \"get SRS0=te87=T7=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Time stamp out of date\" ]]\n\t# Test valid address with timestamp 6 months in the future\n\techo>&9 \"get SRS0=VcIb=7N=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Time stamp out of date\" ]]\n\t# Test address with invalid hash\n\techo>&9 \"get SRS0=FAKE=2V=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Hash invalid\" ]]\n\t# Test valid address with munged case #1\n\techo>&9 \"get srs0=xjo9=2v=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 test@otherdomain.com\" ]]\n\t# Test valid address with munged case #2\n\techo>&9 \"get SRS0=XJO9=2V=OTHERDOMAIN.COM=TEST@EXAMPLE.COM\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 TEST@OTHERDOMAIN.COM\" ]]\n\t# Test address without hash\n\techo>&9 \"get SRS0=@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No hash\" ]]\n\t# Test address without time stamp\n\techo>&9 \"get SRS0=XjO9@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No time\" ]]\n\t# Test address without host\n\techo>&9 \"get SRS0=XjO9=2V@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No host\" ]]\n\t# Test address without local part\n\techo>&9 \"get SRS0=XjO9=2V=otherdomain.com@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No user\" ]]\n}\n\n@test \"SRS always rewrite option\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\" -A\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"get test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=\" ]]\n}\n\n@test \"SRS exclude domains\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\" -X\"excluded.com .exclude-subdomains.com\"\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"get test@excluded.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Domain excluded\" ]]\n\techo>&9 \"get test@subdomain.of.excluded.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=\" ]]\n\techo>&9 \"get test@exclude-subdomains.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=\" ]]\n\techo>&9 \"get test@subdomain.of.exclude-subdomains.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Domain excluded\" ]]\n}\n\n@test \"SRS invalid requests\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"get\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^500 ]]\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^500 ]]\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"get encoding%error@otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^500 ]]\n}\n"], "fixing_code": ["/* PostSRSd - Sender Rewriting Scheme daemon for Postfix\n * Copyright (c) 2012-2020 Timo R\u00f6hling <timo@gaussglocke.de>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* This program uses the libsrs2 library. The relevant source\n * files have been added to this distribution. */\n\n#include \"srs2.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <netdb.h>\n#include <poll.h>\n#include <pwd.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#ifdef HAVE_SYS_TIME_H\n#    include <sys/time.h>\n#endif\n#ifdef HAVE_TIME_H\n#    include <time.h>\n#endif\n#ifdef HAVE_SYS_WAIT_H\n#    include <sys/wait.h>\n#endif\n#ifdef HAVE_WAIT_H\n#    include <wait.h>\n#endif\n#include <syslog.h>\n\nstatic char *self = NULL;\n\nstatic size_t bind_service(const char *listen_addr, const char *service,\n                           int family, int *socks, size_t max_socks)\n{\n    struct addrinfo *addr, *it;\n    struct addrinfo hints;\n    int err, sock, flags;\n    size_t count = 0;\n    static const int one = 1;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_socktype = SOCK_STREAM;\n\n    err = getaddrinfo(listen_addr, service, &hints, &addr);\n    if (err != 0)\n    {\n        fprintf(stderr, \"%s: bind_service(%s): %s\\n\", self, service,\n                gai_strerror(err));\n        return count;\n    }\n    sock = -1;\n    for (it = addr; it; it = it->ai_next)\n    {\n        if (max_socks == 0)\n            break;\n        sock = socket(it->ai_family, it->ai_socktype, it->ai_protocol);\n        if (sock < 0)\n            goto fail;\n        if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) < 0)\n            goto fail;\n        if (bind(sock, it->ai_addr, it->ai_addrlen) < 0)\n            goto fail;\n        if (listen(sock, 10) < 0)\n            goto fail;\n        flags = fcntl(sock, F_GETFL, 0);\n        if (flags < 0)\n            goto fail;\n        if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0)\n            goto fail;\n        *socks++ = sock;\n        ++count;\n        --max_socks;\n        continue;\n    fail:\n        err = errno;\n        if (sock >= 0)\n            close(sock);\n    }\n    freeaddrinfo(addr);\n    if (count == 0)\n        fprintf(stderr, \"%s: bind_service(%s): %s\\n\", self, service,\n                strerror(err));\n    return count;\n}\n\nstatic int is_hexdigit(char c)\n{\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')\n           || (c >= 'A' && c <= 'F');\n}\n\nstatic char hex2num(char c)\n{\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    return 0;\n}\n\nstatic char num2hex(char c)\n{\n    if (c < 10)\n        return '0' + c;\n    return 'a' + c - 10;\n}\n\nstatic char hex2char(const char *s)\n{\n    return 16 * hex2num(s[0]) + hex2num(s[1]);\n}\n\nstatic void char2hex(char c, char *buf)\n{\n    buf[0] = num2hex((c >> 4) & 0xf);\n    buf[1] = num2hex((c)&0xf);\n}\n\nstatic char *url_decode(char *buf, size_t len, const char *input)\n{\n    char *output = buf;\n    if (!input || !output || len == 0)\n        return NULL;\n\n    while (*input && --len)\n    {\n        if (*input == '%')\n        {\n            if (is_hexdigit(input[1]) && is_hexdigit(input[2]))\n            {\n                *output++ = hex2char(++input);\n                input += 2;\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        else\n        {\n            *output++ = *input++;\n        }\n    }\n    *output = 0;\n    return buf;\n}\n\nstatic char *url_encode(char *buf, size_t len, const char *input)\n{\n    char *output = buf;\n    if (!input || !output || len == 0)\n        return NULL;\n    while (*input && --len)\n    {\n        if (!isascii(*input) || !isgraph(*input) || *input == '%')\n        {\n            if (len <= 2)\n                break;\n            *output++ = '%';\n            char2hex(*input++, output);\n            output += 2;\n            len -= 2;\n        }\n        else\n        {\n            *output++ = *input++;\n        }\n    }\n    *output = 0;\n    return buf;\n}\n\nstatic void handle_forward(srs_t *srs, FILE *fp, const char *address,\n                           const char *domain, const char **excludes)\n{\n    int result;\n    size_t addrlen;\n    char value[1024];\n    char outputbuf[1024], *output;\n\n    addrlen = strlen(address);\n    for (; *excludes; excludes++)\n    {\n        size_t len;\n        len = strlen(*excludes);\n        if (len >= addrlen)\n            continue;\n        if (strcasecmp(*excludes, &address[addrlen - len]) == 0\n            && (**excludes == '.' || address[addrlen - len - 1] == '@'))\n        {\n            syslog(LOG_MAIL | LOG_INFO,\n                   \"srs_forward: <%s> not rewritten: Domain excluded by policy\",\n                   address);\n            fputs(\"500 Domain excluded py policy\\n\", fp);\n            fflush(fp);\n            return;\n        }\n    }\n    if (srs_reverse(srs, value, sizeof(value), address) == SRS_SUCCESS)\n    {\n        fprintf(fp, \"500 Already rewritten\\n\");\n        fflush(fp);\n        syslog(LOG_MAIL | LOG_NOTICE,\n               \"srs_forward: <%s> not rewritten: Valid SRS address for <%s>\",\n               address, value);\n        return;\n    }\n    result = srs_forward(srs, value, sizeof(value), address, domain);\n    if (result == SRS_SUCCESS)\n    {\n        output = url_encode(outputbuf, sizeof(outputbuf), value);\n        fprintf(fp, \"200 %s\\n\", output);\n        if (strcmp(address, value) != 0)\n            syslog(LOG_MAIL | LOG_INFO, \"srs_forward: <%s> rewritten as <%s>\",\n                   address, value);\n    }\n    else\n    {\n        fprintf(fp, \"500 %s\\n\", srs_strerror(result));\n        if (result != SRS_ENOTREWRITTEN)\n            syslog(LOG_MAIL | LOG_INFO, \"srs_forward: <%s> not rewritten: %s\",\n                   address, srs_strerror(result));\n    }\n    fflush(fp);\n}\n\nstatic void handle_reverse(srs_t *srs, FILE *fp, const char *address,\n                           const char *domain __attribute__((unused)),\n                           const char **excludes __attribute__((unused)))\n{\n    int result;\n    char value[1024];\n    char outputbuf[1024], *output;\n    result = srs_reverse(srs, value, sizeof(value), address);\n    if (result == SRS_SUCCESS)\n    {\n        output = url_encode(outputbuf, sizeof(outputbuf), value);\n        fprintf(fp, \"200 %s\\n\", output);\n        syslog(LOG_MAIL | LOG_INFO, \"srs_reverse: <%s> rewritten as <%s>\",\n               address, value);\n    }\n    else\n    {\n        fprintf(fp, \"500 %s\\n\", srs_strerror(result));\n        if (result != SRS_ENOTREWRITTEN && result != SRS_ENOTSRSADDRESS)\n            syslog(LOG_MAIL | LOG_INFO, \"srs_reverse: <%s> not rewritten: %s\",\n                   address, srs_strerror(result));\n    }\n    fflush(fp);\n}\n\nstatic void show_help()\n{\n    fprintf(\n        stdout,\n        \"Sender Rewriting Scheme implementation for Postfix.\\n\\n\"\n        \"Implements two TCP lookup tables to rewrite mail addresses\\n\"\n        \"as needed. The forward SRS is for sender envelope addresses\\n\"\n        \"to prevent SPF-related bounces. The reverse SRS is for\\n\"\n        \"recipient envelope addresses so that bounced mails can be\\n\"\n        \"routed back to their original sender.\\n\"\n        \"\\n\"\n        \"Usage: %s -s<file> -d<domain> [other options]\\n\"\n        \"Options:\\n\"\n        \"   -s<file>       read secrets from file (required)\\n\"\n        \"   -d<domain>     set domain name for rewrite (required)\\n\"\n        \"   -a<char>       set first separator character which can be one of: \"\n        \"-=+ (default: =)\\n\"\n        \"   -n<num>        length of hash to be used in rewritten addresses \"\n        \"(default: 4)\\n\"\n        \"   -N<num>        minimum length of hash to accept for validation \"\n        \"(default: 4)\\n\"\n        \"   -l<addr>       set socket listen address (default: 127.0.0.1)\\n\"\n        \"   -f<port>       set port for the forward SRS lookup (default: \"\n        \"10001)\\n\"\n        \"   -r<port>       set port for the reverse SRS lookup (default: \"\n        \"10002)\\n\"\n        \"   -p<pidfile>    write process ID to pidfile (default: none)\\n\"\n        \"   -c<dir>        chroot to <dir> (default: none)\\n\"\n        \"   -u<user>       switch user id after port bind (default: none)\\n\"\n        \"   -t<seconds>    timeout for idle client connections (default: \"\n        \"1800)\\n\"\n        \"   -X<domain>     exclude additional domain from address rewriting\\n\"\n        \"   -A             always rewrite addresses\\n\"\n        \"   -e             attempt to read above parameters from environment\\n\"\n        \"   -D             fork into background\\n\"\n        \"   -4             force IPv4 socket (default: any)\\n\"\n        \"   -6             force IPv6 socket (default: any)\\n\"\n        \"   -h             show this help\\n\"\n        \"   -v             show version\\n\"\n        \"\\n\",\n        self);\n}\n\ntypedef void (*handle_t)(srs_t *, FILE *, const char *, const char *,\n                         const char **);\n\nint main(int argc, char **argv)\n{\n    int opt, timeout = 1800, family = AF_UNSPEC, hashlength = 0, hashmin = 0;\n    int daemonize = FALSE, always_rewrite = FALSE;\n    char *listen_addr = NULL, *forward_service = NULL, *reverse_service = NULL,\n         *user = NULL, *domain = NULL, *chroot_dir = NULL;\n    char separator = '=';\n    char *secret_file = NULL, *pid_file = NULL;\n    FILE *pf = NULL, *sf = NULL;\n    struct passwd *pwd = NULL;\n    char secretbuf[1024], *secret = NULL;\n    char *tmp;\n    time_t now;\n    srs_t *srs;\n    const char **excludes;\n    size_t s1 = 0, s2 = 1;\n    struct pollfd fds[4];\n    size_t socket_count = 0, sc;\n    int sockets[4] = {-1, -1, -1, -1};\n    handle_t handler[4] = {0, 0, 0, 0};\n    int fd, maxfd;\n\n    excludes = (const char **)calloc(1, sizeof(char *));\n    tmp = strrchr(argv[0], '/');\n    if (tmp)\n        self = strdup(tmp + 1);\n    else\n        self = strdup(argv[0]);\n\n    while ((opt = getopt(argc, argv, \"46d:a:l:f:r:s:n:N:u:t:p:c:X::ADhev\"))\n           != -1)\n    {\n        switch (opt)\n        {\n            case '?':\n                return EXIT_FAILURE;\n            case '4':\n                family = AF_INET;\n                break;\n            case '6':\n                family = AF_INET6;\n                break;\n            case 'd':\n                domain = strdup(optarg);\n                break;\n            case 'a':\n                separator = *optarg;\n                break;\n            case 'l':\n                listen_addr = strdup(optarg);\n                break;\n            case 'f':\n                forward_service = strdup(optarg);\n                break;\n            case 'r':\n                reverse_service = strdup(optarg);\n                break;\n            case 't':\n                timeout = atoi(optarg);\n                break;\n            case 's':\n                secret_file = strdup(optarg);\n                break;\n            case 'n':\n                hashlength = atoi(optarg);\n                break;\n            case 'N':\n                hashmin = atoi(optarg);\n                break;\n            case 'p':\n                pid_file = strdup(optarg);\n                break;\n            case 'u':\n                user = strdup(optarg);\n                break;\n            case 'c':\n                chroot_dir = strdup(optarg);\n                break;\n            case 'D':\n                daemonize = TRUE;\n                break;\n            case 'A':\n                always_rewrite = TRUE;\n                break;\n            case 'h':\n                show_help();\n                return EXIT_SUCCESS;\n            case 'X':\n                if (optarg != NULL)\n                {\n                    tmp = strtok(optarg, \",; \\t\\r\\n\");\n                    while (tmp)\n                    {\n                        if (s1 + 1 >= s2)\n                        {\n                            s2 *= 2;\n                            excludes = (const char **)realloc(\n                                excludes, s2 * sizeof(char *));\n                            if (excludes == NULL)\n                            {\n                                fprintf(stderr, \"%s: Out of memory\\n\\n\", self);\n                                return EXIT_FAILURE;\n                            }\n                        }\n                        excludes[s1++] = strdup(tmp);\n                        tmp = strtok(NULL, \",; \\t\\r\\n\");\n                    }\n                    excludes[s1] = NULL;\n                }\n                break;\n            case 'e':\n                if (getenv(\"SRS_DOMAIN\") != NULL)\n                    domain = strdup(getenv(\"SRS_DOMAIN\"));\n                if (getenv(\"SRS_SEPARATOR\") != NULL)\n                    separator = *getenv(\"SRS_SEPARATOR\");\n                if (getenv(\"SRS_HASHLENGTH\") != NULL)\n                    hashlength = atoi(getenv(\"SRS_HASHLENGTH\"));\n                if (getenv(\"SRS_HASHMIN\") != NULL)\n                    hashmin = atoi(getenv(\"SRS_HASHMIN\"));\n                if (getenv(\"SRS_FORWARD_PORT\") != NULL)\n                    forward_service = strdup(getenv(\"SRS_FORWARD_PORT\"));\n                if (getenv(\"SRS_REVERSE_PORT\") != NULL)\n                    reverse_service = strdup(getenv(\"SRS_REVERSE_PORT\"));\n                if (getenv(\"SRS_TIMEOUT\") != NULL)\n                    timeout = atoi(getenv(\"SRS_TIMEOUT\"));\n                if (getenv(\"SRS_SECRET\") != NULL)\n                    secret_file = strdup(getenv(\"SRS_SECRET\"));\n                if (getenv(\"SRS_PID_FILE\") != NULL)\n                    pid_file = strdup(getenv(\"SRS_PID_FILE\"));\n                if (getenv(\"RUN_AS\") != NULL)\n                    user = strdup(getenv(\"RUN_AS\"));\n                if (getenv(\"CHROOT\") != NULL)\n                    chroot_dir = strdup(getenv(\"CHROOT\"));\n                if (getenv(\"SRS_EXCLUDE_DOMAINS\") != NULL)\n                {\n                    tmp = strtok(getenv(\"SRS_EXCLUDE_DOMAINS\"), \",; \\t\\r\\n\");\n                    while (tmp)\n                    {\n                        if (s1 + 1 >= s2)\n                        {\n                            s2 *= 2;\n                            excludes = (const char **)realloc(\n                                excludes, s2 * sizeof(char *));\n                            if (excludes == NULL)\n                            {\n                                fprintf(stderr, \"%s: Out of memory\\n\\n\", self);\n                                return EXIT_FAILURE;\n                            }\n                        }\n                        excludes[s1++] = strdup(tmp);\n                        tmp = strtok(NULL, \",; \\t\\r\\n\");\n                    }\n                    excludes[s1] = NULL;\n                }\n                break;\n            case 'v':\n                fprintf(stdout, \"%s\\n\", POSTSRSD_VERSION);\n                return EXIT_SUCCESS;\n        }\n    }\n    if (optind < argc)\n    {\n        fprintf(stderr, \"%s: extra argument on command line: %s\\n\", self,\n                argv[optind]);\n        return EXIT_FAILURE;\n    }\n    if (domain == NULL || *domain == 0)\n    {\n        fprintf(stderr, \"%s: You must set a home domain (-d)\\n\", self);\n        return EXIT_FAILURE;\n    }\n\n    if (separator != '=' && separator != '+' && separator != '-')\n    {\n        fprintf(stderr, \"%s: SRS separator character must be one of '=+-'\\n\",\n                self);\n        return EXIT_FAILURE;\n    }\n    if (forward_service == NULL)\n        forward_service = strdup(\"10001\");\n    if (reverse_service == NULL)\n        reverse_service = strdup(\"10002\");\n\n    /* Close all file descriptors (std ones will be closed later). */\n    maxfd = sysconf(_SC_OPEN_MAX);\n    for (fd = 3; fd < maxfd; fd++)\n        close(fd);\n\n    /* The stuff we do first may not be possible from within chroot or without\n     * privileges */\n\n    /* Open pid file for writing (the actual process ID is filled in later) */\n    if (pid_file)\n    {\n        pf = fopen(pid_file, \"w\");\n        if (pf == NULL)\n        {\n            fprintf(stderr, \"%s: Cannot write PID: %s\\n\\n\", self, pid_file);\n            return EXIT_FAILURE;\n        }\n    }\n    /* Read secret. The default installation makes this root accessible only. */\n    if (secret_file != NULL)\n    {\n        sf = fopen(secret_file, \"rb\");\n        if (sf == NULL)\n        {\n            fprintf(stderr, \"%s: Cannot open file with secret: %s\\n\", self,\n                    secret_file);\n            return EXIT_FAILURE;\n        }\n    }\n    else\n    {\n        fprintf(stderr, \"%s: You must set a secret (-s)\\n\", self);\n        return EXIT_FAILURE;\n    }\n    /* Bind ports. May require privileges if the config specifies ports below\n     * 1024 */\n    sc = bind_service(listen_addr, forward_service, family,\n                      &sockets[socket_count], 4 - socket_count);\n    if (sc == 0)\n        return EXIT_FAILURE;\n    while (sc-- > 0)\n        handler[socket_count++] = handle_forward;\n    free(forward_service);\n    sc = bind_service(listen_addr, reverse_service, family,\n                      &sockets[socket_count], 4 - socket_count);\n    if (sc == 0)\n        return EXIT_FAILURE;\n    while (sc-- > 0)\n        handler[socket_count++] = handle_reverse;\n    free(reverse_service);\n    /* Open syslog now (NDELAY), because it may no longer be reachable from\n     * chroot */\n    openlog(self, LOG_PID | LOG_NDELAY, LOG_MAIL);\n    /* Force loading of timezone info (suggested by patrickdk77) */\n    now = time(NULL);\n    localtime(&now);\n    /* We also have to lookup the uid of the unprivileged user before the\n     * chroot. */\n    if (user)\n    {\n        errno = 0;\n        pwd = getpwnam(user);\n        if (pwd == NULL)\n        {\n            if (errno != 0)\n                fprintf(stderr, \"%s: Failed to lookup user: %s\\n\", self,\n                        strerror(errno));\n            else\n                fprintf(stderr, \"%s: No such user: %s\\n\", self, user);\n            return EXIT_FAILURE;\n        }\n    }\n    /* Now we can chroot, which again requires root privileges */\n    if (chroot_dir)\n    {\n        if (chdir(chroot_dir) < 0)\n        {\n            fprintf(stderr, \"%s: Cannot change to chroot: %s\\n\", self,\n                    strerror(errno));\n            return EXIT_FAILURE;\n        }\n        if (chroot(chroot_dir) < 0)\n        {\n            fprintf(stderr, \"%s: Failed to enable chroot: %s\\n\", self,\n                    strerror(errno));\n            return EXIT_FAILURE;\n        }\n    }\n    /* Finally, we revert to the unprivileged user */\n    if (pwd)\n    {\n        if (setgid(pwd->pw_gid) < 0)\n        {\n            fprintf(stderr, \"%s: Failed to switch group id: %s\\n\", self,\n                    strerror(errno));\n            return EXIT_FAILURE;\n        }\n        if (setuid(pwd->pw_uid) < 0)\n        {\n            fprintf(stderr, \"%s: Failed to switch user id: %s\\n\", self,\n                    strerror(errno));\n            return EXIT_FAILURE;\n        }\n    }\n    /* Standard double fork technique to disavow all knowledge about the\n     * controlling terminal */\n    if (daemonize)\n    {\n        close(0);\n        close(1);\n        close(2);\n        if (fork() != 0)\n            return EXIT_SUCCESS;\n        setsid();\n        if (fork() != 0)\n            return EXIT_SUCCESS;\n    }\n    /* Make note of our actual process ID */\n    if (pf)\n    {\n        fprintf(pf, \"%d\", (int)getpid());\n        fclose(pf);\n    }\n\n    srs = srs_new();\n    while ((secret = fgets(secretbuf, sizeof(secretbuf), sf)))\n    {\n        secret = strtok(secret, \"\\r\\n\");\n        if (secret)\n            srs_add_secret(srs, secret);\n    }\n    fclose(sf);\n\n    srs_set_alwaysrewrite(srs, always_rewrite);\n    srs_set_separator(srs, separator);\n    if (hashlength)\n        srs_set_hashlength(srs, hashlength);\n    if (hashmin)\n        srs_set_hashmin(srs, hashmin);\n\n    for (sc = 0; sc < socket_count; ++sc)\n    {\n        fds[sc].fd = sockets[sc];\n        fds[sc].events = POLLIN;\n    }\n    while (TRUE)\n    {\n        int conn;\n        FILE *fp_read, *fp_write;\n        char linebuf[1024], *line;\n        char keybuf[1024], *key;\n\n        if (poll(fds, socket_count, 1000) < 0)\n        {\n            if (errno == EINTR)\n                continue;\n            if (daemonize)\n                syslog(LOG_MAIL | LOG_ERR, \"Poll failure: %s\", strerror(errno));\n            else\n                fprintf(stderr, \"%s: Poll failure: %s\\n\", self,\n                        strerror(errno));\n            return EXIT_FAILURE;\n        }\n        for (sc = 0; sc < socket_count; ++sc)\n        {\n            if (fds[sc].revents)\n            {\n                conn = accept(fds[sc].fd, NULL, NULL);\n                if (conn < 0)\n                    continue;\n                if (fork() == 0)\n                {\n                    int i;\n                    /* close listen sockets so that we don't stop the main\n                     * daemon process from restarting */\n                    for (i = 0; i < socket_count; ++i)\n                        close(sockets[i]);\n                    /* create separate input/output streams */\n                    fp_read = fdopen(conn, \"r\");\n                    if (fp_read == NULL)\n                        return EXIT_FAILURE;\n                    fp_write = fdopen(dup(conn), \"w\");\n                    if (fp_write == NULL)\n                        return EXIT_FAILURE;\n                    errno = 0;\n                    alarm(timeout);\n                    if (errno != 0)\n                        return EXIT_FAILURE;\n                    while ((line = fgets(linebuf, sizeof(linebuf), fp_read)))\n                    {\n                        char *token;\n                        alarm(0);\n                        if (strlen(line) >= sizeof(linebuf) - 1)\n                        {\n                            fprintf(fp_write, \"500 Invalid request\\n\");\n                            fflush(fp_write);\n                            return EXIT_FAILURE;\n                        }\n                        token = strtok(line, \" \\r\\n\");\n                        if (token == NULL || strcmp(token, \"get\") != 0)\n                        {\n                            fprintf(fp_write, \"500 Invalid request\\n\");\n                            fflush(fp_write);\n                            return EXIT_FAILURE;\n                        }\n                        token = strtok(NULL, \"\\r\\n\");\n                        if (!token)\n                        {\n                            fprintf(fp_write, \"500 Invalid request\\n\");\n                            fflush(fp_write);\n                            return EXIT_FAILURE;\n                        }\n                        key = url_decode(keybuf, sizeof(keybuf), token);\n                        if (!key)\n                        {\n                            fprintf(fp_write, \"500 Invalid request\\n\");\n                            fflush(fp_write);\n                            return EXIT_FAILURE;\n                        }\n                        handler[sc](srs, fp_write, key, domain, excludes);\n                        fflush(fp_write);\n                        errno = 0;\n                        alarm(timeout);\n                        if (errno != 0)\n                            return EXIT_FAILURE;\n                    }\n                    fclose(fp_write);\n                    fclose(fp_read);\n                    return EXIT_SUCCESS;\n                }\n                close(conn);\n            }\n        }\n        waitpid(-1, NULL, WNOHANG);\n    }\n    return EXIT_SUCCESS;\n}\n", "#!/usr/bin/env bats\n# vim: filetype=bash:\n\nif [ ! -x \"$POSTSRSD\" ]\nthen\n\tfor builddir in . build* obj* _build*\n\tdo\n\t\tif [ -x \"${builddir}/postsrsd\" ]\n\t\tthen\n\t\t\tPOSTSRSD=\"${builddir}/postsrsd\"\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\nif [ ! -x \"$POSTSRSD\" ]\nthen\n\tcat>&2 <<- EOF\n\tcannot find postsrsd executable (looked in ., build*, obj*, _build*)\n\tplease build the executable first, or set the POSTSRSD\n\tenvironment variable if it is in a different location.\n\n\tEOF\n\texit 1\nfi\n\nLANG=C.UTF-8\n\n\nfillchar()\n{\n        local count=\"$1\"\n        local char=\"$2\"\n        eval 'printf \"'\"$char\"'%.0s\" {1..'\"$count\"'}'\n}\n\nstart_postsrsd_at()\n{\n\techo 'tops3cr3t' > \"$BATS_TMPDIR/postsrsd.secret\"\n\tlocal faketime=\"$1\"\n\tshift\n\tfaketime \"${faketime}\" ${POSTSRSD} -D -t1 -f 10001 -r 10002 -p \"$BATS_TMPDIR/postsrsd.pid\" -s \"$BATS_TMPDIR/postsrsd.secret\" -d example.com \"$@\"\n}\n\nstop_postsrsd()\n{\n\tif [ -r $BATS_TMPDIR/postsrsd.pid ] && kill -0 $(< $BATS_TMPDIR/postsrsd.pid) &>/dev/null\n\tthen\n\t\tkill -TERM $(< $BATS_TMPDIR/postsrsd.pid)\n\tfi\n\trm -f $BATS_TMPDIR/postsrsd.pid\n}\n\nteardown()\n{\n\tstop_postsrsd\n}\n\n@test \"SRS forward rewrite\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\t# email address that needs not be rewritten\n\techo>&9 \"get test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" = \"200 test@example.com\" ]]\n\t# regular email address rewrite\n\techo>&9 \"get test@otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=vmyz=2W=otherdomain.com=test@example.com\" ]]\n\t# invalid email address without domain part\n\techo>&9 \"get bla\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No at sign\" ]]\n\t# Test double-rewrite\n\techo>&9 \"get SRS0=XjO9=2V=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Already rewritten\" ]]\n\t# Test rewrite of an SRS0 address from somewhere else\n\techo>&9 \"get SRS0=opaque+string@otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS1=\" ]]\n\t# Test rewrite of an SRS1 aaddress\n\techo>&9 \"get SRS1=X=thirddomain.com==opaque+string@otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS1=JIBX=thirddomain.com==opaque+string@example.com\" ]]\n\t# rewrite address with URL encoding\n\techo>&9 \"get test%40otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=vmyz=2W=otherdomain.com=test@example.com\" ]]\n}\n\n@test \"SRS reverse rewrite\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n\texec 9<>/dev/tcp/127.0.0.1/10002\n\t# Test regular SRS reversal\n\techo>&9 \"get SRS0=XjO9=2V=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 test@otherdomain.com\" ]]\n\t# Test SRS1 address\n\techo>&9 \"get SRS1=JIBX=thirddomain.com==opaque+string@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=opaque+string@thirddomain.com\" ]]\n\t# Test non-SRS address\n\techo>&9 \"get test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Not an SRS address\" ]]\n\t# Test valid address with timestamp 6 months in the past\n\techo>&9 \"get SRS0=te87=T7=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Time stamp out of date\" ]]\n\t# Test valid address with timestamp 6 months in the future\n\techo>&9 \"get SRS0=VcIb=7N=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Time stamp out of date\" ]]\n\t# Test address with invalid hash\n\techo>&9 \"get SRS0=FAKE=2V=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Hash invalid\" ]]\n\t# Test valid address with munged case #1\n\techo>&9 \"get srs0=xjo9=2v=otherdomain.com=test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 test@otherdomain.com\" ]]\n\t# Test valid address with munged case #2\n\techo>&9 \"get SRS0=XJO9=2V=OTHERDOMAIN.COM=TEST@EXAMPLE.COM\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 TEST@OTHERDOMAIN.COM\" ]]\n\t# Test address without hash\n\techo>&9 \"get SRS0=@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No hash\" ]]\n\t# Test address without time stamp\n\techo>&9 \"get SRS0=XjO9@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No time\" ]]\n\t# Test address without host\n\techo>&9 \"get SRS0=XjO9=2V@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No host\" ]]\n\t# Test address without local part\n\techo>&9 \"get SRS0=XjO9=2V=otherdomain.com@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 No user\" ]]\n}\n\n@test \"SRS always rewrite option\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\" -A\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"get test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=\" ]]\n}\n\n@test \"SRS exclude domains\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\" -X\"excluded.com .exclude-subdomains.com\"\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"get test@excluded.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Domain excluded\" ]]\n\techo>&9 \"get test@subdomain.of.excluded.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=\" ]]\n\techo>&9 \"get test@exclude-subdomains.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"200 SRS0=\" ]]\n\techo>&9 \"get test@subdomain.of.exclude-subdomains.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^\"500 Domain excluded\" ]]\n}\n\n@test \"Malformed or invalid requests\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"get\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^500 ]]\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"test@example.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^500 ]]\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\techo>&9 \"get encoding%error@otherdomain.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^500 ]]\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\t# Try to overflow the input buffer\n\techo>&9 \"get too_long@`fillchar 1024 a`.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^500 ]]\n}\n\n@test \"Pipelining multiple requests\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\t# Send two requests at once and see if PostSRSd answers both\n\techo>&9 -e \"get test@domain1.com\\nget test@domain2.com\"\n\tread<&9 line\n\t[[ \"$line\" =~ ^200 ]]\n\tread<&9 line\n\t[[ \"$line\" =~ ^200 ]]\n}\n\n@test \"Session timeout\" {\n\tstart_postsrsd_at \"2020-01-01 00:01:00 UTC\"\n\texec 9<>/dev/tcp/127.0.0.1/10001\n\t# Wait until PostSRSd disconnects due to inactivity\n\tsleep 2\n\techo >&9 \"get test@example.com\"\n\t! read <&9 line\n}\n"], "filenames": ["postsrsd.c", "run_postsrsd_tests.bats"], "buggy_code_start_loc": [648, 6], "buggy_code_end_loc": [718, 177], "fixing_code_start_loc": [648, 6], "fixing_code_end_loc": [728, 209], "type": "NVD-CWE-noinfo", "message": "PostSRSd before 1.11 allows a denial of service (subprocess hang) if Postfix sends certain long data fields such as multiple concatenated email addresses. NOTE: the PostSRSd maintainer acknowledges \"theoretically, this error should never occur ... I'm not sure if there's a reliable way to trigger this condition by an external attacker, but it is a security bug in PostSRSd nevertheless.\"", "other": {"cve": {"id": "CVE-2021-35525", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-28T18:15:08.030", "lastModified": "2021-09-20T18:52:21.870", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PostSRSd before 1.11 allows a denial of service (subprocess hang) if Postfix sends certain long data fields such as multiple concatenated email addresses. NOTE: the PostSRSd maintainer acknowledges \"theoretically, this error should never occur ... I'm not sure if there's a reliable way to trigger this condition by an external attacker, but it is a security bug in PostSRSd nevertheless.\""}, {"lang": "es", "value": "PostSRSd versiones anteriores a 1.11, permite una denegaci\u00f3n de servicio (colgado del subproceso) si Postfix env\u00eda determinados campos de datos largos, como m\u00faltiples direcciones de correo electr\u00f3nico concatenadas. NOTA: el mantenedor de PostSRSd reconoce que \"theoretically, this error should never occur ... I'm not sure if there's a reliable way to trigger this condition by an external attacker, but it is a security bug in PostSRSd nevertheless.\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:postsrsd_project:postsrsd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.11", "matchCriteriaId": "CF51DB73-7F3A-49C5-9AC2-99EE17EE0B5B"}]}]}], "references": [{"url": "https://bugs.gentoo.org/793674", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/roehling/postsrsd/commit/077be98d8c8a9847e4ae0c7dc09e7474cbe27db2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/roehling/postsrsd/releases/tag/1.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-08", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/roehling/postsrsd/commit/077be98d8c8a9847e4ae0c7dc09e7474cbe27db2"}}