{"buggy_code": ["/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: xinhua.guo  <woshiguo35@gmail.com>                        |\n  +----------------------------------------------------------------------+\n */\n\n#include \"php_swoole.h\"\n#include \"swoole_serialize.h\"\n#ifdef __SSE2__\n#include <emmintrin.h>\n#endif\n\n#if PHP_MAJOR_VERSION >= 7\n#define CPINLINE sw_inline\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_serialize_pack, 0, 0, 1)\nZEND_ARG_INFO(0, data)\nZEND_ARG_INFO(0, flag)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_serialize_unpack, 0, 0, 1)\nZEND_ARG_INFO(0, string)\nZEND_ARG_INFO(0, args)\nZEND_END_ARG_INFO()\n\nstatic void swoole_serialize_object(seriaString *buffer, zval *zvalue, size_t start);\nstatic void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue);\nstatic void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t num, long flag);\nstatic void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag);\n\nstatic PHP_METHOD(swoole_serialize, pack);\nstatic PHP_METHOD(swoole_serialize, unpack);\n\n\nstatic const zend_function_entry swoole_serialize_methods[] = {\n    PHP_ME(swoole_serialize, pack, arginfo_swoole_serialize_pack, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)\n    PHP_ME(swoole_serialize, unpack, arginfo_swoole_serialize_unpack, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)\n    PHP_FE_END\n};\n\nzend_class_entry swoole_serialize_ce;\nzend_class_entry *swoole_serialize_class_entry_ptr;\n\n#define SWOOLE_SERI_EOF \"EOF\"\n\nstatic struct _swSeriaG swSeriaG;\n\nvoid swoole_serialize_init(int module_number TSRMLS_DC)\n{\n    SWOOLE_INIT_CLASS_ENTRY(swoole_serialize_ce, \"swoole_serialize\", \"Swoole\\\\Serialize\", swoole_serialize_methods);\n    swoole_serialize_class_entry_ptr = zend_register_internal_class(&swoole_serialize_ce TSRMLS_CC);\n    SWOOLE_CLASS_ALIAS(swoole_serialize, \"Swoole\\\\Serialize\");\n\n    //    ZVAL_STRING(&swSeriaG.sleep_fname, \"__sleep\");\n    zend_string *zstr_sleep = zend_string_init(\"__sleep\", sizeof (\"__sleep\") - 1, 1);\n    zend_string *zstr_weekup = zend_string_init(\"__weekup\", sizeof (\"__weekup\") - 1, 1);\n    ZVAL_STR(&swSeriaG.sleep_fname, zstr_sleep);\n    ZVAL_STR(&swSeriaG.weekup_fname, zstr_weekup);\n    //    ZVAL_STRING(&swSeriaG.weekup_fname, \"__weekup\");\n\n    memset(&swSeriaG.filter, 0, sizeof (swSeriaG.filter));\n    memset(&mini_filter, 0, sizeof (mini_filter));\n\n    REGISTER_LONG_CONSTANT(\"SWOOLE_FAST_PACK\", SW_FAST_PACK, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"UNSERIALIZE_OBJECT_TO_ARRAY\", UNSERIALIZE_OBJECT_TO_ARRAY, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"UNSERIALIZE_OBJECT_TO_STDCLASS\", UNSERIALIZE_OBJECT_TO_STDCLASS, CONST_CS | CONST_PERSISTENT);\n}\n\nstatic CPINLINE int swoole_string_new(size_t size, seriaString *str, zend_uchar type)\n{\n    int total = ZEND_MM_ALIGNED_SIZE(_STR_HEADER_SIZE + size + 1);\n    str->total = total;\n    //escape the header for later\n    str->offset = _STR_HEADER_SIZE;\n    //zend string addr\n    str->buffer = ecalloc(1, total);\n    if (!str->buffer)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR, \"malloc Error: %s [%d]\", strerror(errno), errno);\n    }\n\n    SBucketType real_type = {0};\n    real_type.data_type = type;\n    *(SBucketType*) (str->buffer + str->offset) = real_type;\n    str->offset += sizeof (SBucketType);\n    return 0;\n}\n\nstatic CPINLINE void swoole_check_size(seriaString *str, size_t len)\n{\n    int new_size = len + str->offset;\n    //    int new_size = len + str->offset + 3 + sizeof (zend_ulong); //space 1 for the type and 2 for key string len or index len and(zend_ulong) for key h\n    if (str->total < new_size)\n    {//extend it\n\n        new_size = ZEND_MM_ALIGNED_SIZE(new_size + SERIA_SIZE);\n        str->buffer = erealloc2(str->buffer, new_size, str->offset);\n        if (!str->buffer)\n        {\n            php_error_docref(NULL TSRMLS_CC, E_ERROR, \"realloc Error: %s [%d]\", strerror(errno), errno);\n        }\n        str->total = new_size;\n    }\n}\n#ifdef __SSE2__\nvoid CPINLINE swoole_mini_memcpy(void *dst, const void *src, size_t len)\n{\n    register unsigned char *dd = (unsigned char*) dst + len;\n    register const unsigned char *ss = (const unsigned char*) src + len;\n    switch (len)\n    {\n        case 68: *((int*) (dd - 68)) = *((int*) (ss - 68));\n        /* no break */\n        case 64: *((int*) (dd - 64)) = *((int*) (ss - 64));\n        /* no break */\n        case 60: *((int*) (dd - 60)) = *((int*) (ss - 60));\n        /* no break */\n        case 56: *((int*) (dd - 56)) = *((int*) (ss - 56));\n        /* no break */\n        case 52: *((int*) (dd - 52)) = *((int*) (ss - 52));\n        /* no break */\n        case 48: *((int*) (dd - 48)) = *((int*) (ss - 48));\n        /* no break */\n        case 44: *((int*) (dd - 44)) = *((int*) (ss - 44));\n        /* no break */\n        case 40: *((int*) (dd - 40)) = *((int*) (ss - 40));\n        /* no break */\n        case 36: *((int*) (dd - 36)) = *((int*) (ss - 36));\n        /* no break */\n        case 32: *((int*) (dd - 32)) = *((int*) (ss - 32));\n        /* no break */\n        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));\n        /* no break */\n        case 24: *((int*) (dd - 24)) = *((int*) (ss - 24));\n        /* no break */\n        case 20: *((int*) (dd - 20)) = *((int*) (ss - 20));\n        /* no break */\n        case 16: *((int*) (dd - 16)) = *((int*) (ss - 16));\n        /* no break */\n        case 12: *((int*) (dd - 12)) = *((int*) (ss - 12));\n        /* no break */\n        case 8: *((int*) (dd - 8)) = *((int*) (ss - 8));\n        /* no break */\n        case 4: *((int*) (dd - 4)) = *((int*) (ss - 4));\n            break;\n        case 67: *((int*) (dd - 67)) = *((int*) (ss - 67));\n        /* no break */\n        case 63: *((int*) (dd - 63)) = *((int*) (ss - 63));\n        /* no break */\n        case 59: *((int*) (dd - 59)) = *((int*) (ss - 59));\n        /* no break */\n        case 55: *((int*) (dd - 55)) = *((int*) (ss - 55));\n        /* no break */\n        case 51: *((int*) (dd - 51)) = *((int*) (ss - 51));\n        /* no break */\n        case 47: *((int*) (dd - 47)) = *((int*) (ss - 47));\n        /* no break */\n        case 43: *((int*) (dd - 43)) = *((int*) (ss - 43));\n        /* no break */\n        case 39: *((int*) (dd - 39)) = *((int*) (ss - 39));\n        /* no break */\n        case 35: *((int*) (dd - 35)) = *((int*) (ss - 35));\n        /* no break */\n        case 31: *((int*) (dd - 31)) = *((int*) (ss - 31));\n        /* no break */\n        case 27: *((int*) (dd - 27)) = *((int*) (ss - 27));\n        /* no break */\n        case 23: *((int*) (dd - 23)) = *((int*) (ss - 23));\n        /* no break */\n        case 19: *((int*) (dd - 19)) = *((int*) (ss - 19));\n        /* no break */\n        case 15: *((int*) (dd - 15)) = *((int*) (ss - 15));\n        /* no break */\n        case 11: *((int*) (dd - 11)) = *((int*) (ss - 11));\n        /* no break */\n        case 7: *((int*) (dd - 7)) = *((int*) (ss - 7));\n            *((int*) (dd - 4)) = *((int*) (ss - 4));\n            break;\n        case 3: *((short*) (dd - 3)) = *((short*) (ss - 3));\n            dd[-1] = ss[-1];\n            break;\n        case 66: *((int*) (dd - 66)) = *((int*) (ss - 66));\n        /* no break */\n        case 62: *((int*) (dd - 62)) = *((int*) (ss - 62));\n        /* no break */\n        case 58: *((int*) (dd - 58)) = *((int*) (ss - 58));\n        /* no break */\n        case 54: *((int*) (dd - 54)) = *((int*) (ss - 54));\n        /* no break */\n        case 50: *((int*) (dd - 50)) = *((int*) (ss - 50));\n        /* no break */\n        case 46: *((int*) (dd - 46)) = *((int*) (ss - 46));\n        /* no break */\n        case 42: *((int*) (dd - 42)) = *((int*) (ss - 42));\n        /* no break */\n        case 38: *((int*) (dd - 38)) = *((int*) (ss - 38));\n        /* no break */\n        case 34: *((int*) (dd - 34)) = *((int*) (ss - 34));\n        /* no break */\n        case 30: *((int*) (dd - 30)) = *((int*) (ss - 30));\n        /* no break */\n        case 26: *((int*) (dd - 26)) = *((int*) (ss - 26));\n        /* no break */\n        case 22: *((int*) (dd - 22)) = *((int*) (ss - 22));\n        /* no break */\n        case 18: *((int*) (dd - 18)) = *((int*) (ss - 18));\n        /* no break */\n        case 14: *((int*) (dd - 14)) = *((int*) (ss - 14));\n        /* no break */\n        case 10: *((int*) (dd - 10)) = *((int*) (ss - 10));\n        /* no break */\n        case 6: *((int*) (dd - 6)) = *((int*) (ss - 6));\n        /* no break */\n        case 2: *((short*) (dd - 2)) = *((short*) (ss - 2));\n            break;\n        case 65: *((int*) (dd - 65)) = *((int*) (ss - 65));\n        /* no break */\n        case 61: *((int*) (dd - 61)) = *((int*) (ss - 61));\n        /* no break */\n        case 57: *((int*) (dd - 57)) = *((int*) (ss - 57));\n        /* no break */\n        case 53: *((int*) (dd - 53)) = *((int*) (ss - 53));\n        /* no break */\n        case 49: *((int*) (dd - 49)) = *((int*) (ss - 49));\n        /* no break */\n        case 45: *((int*) (dd - 45)) = *((int*) (ss - 45));\n        /* no break */\n        case 41: *((int*) (dd - 41)) = *((int*) (ss - 41));\n        /* no break */\n        case 37: *((int*) (dd - 37)) = *((int*) (ss - 37));\n        /* no break */\n        case 33: *((int*) (dd - 33)) = *((int*) (ss - 33));\n        /* no break */\n        case 29: *((int*) (dd - 29)) = *((int*) (ss - 29));\n        /* no break */\n        case 25: *((int*) (dd - 25)) = *((int*) (ss - 25));\n        /* no break */\n        case 21: *((int*) (dd - 21)) = *((int*) (ss - 21));\n        /* no break */\n        case 17: *((int*) (dd - 17)) = *((int*) (ss - 17));\n        /* no break */\n        case 13: *((int*) (dd - 13)) = *((int*) (ss - 13));\n        /* no break */\n        case 9: *((int*) (dd - 9)) = *((int*) (ss - 9));\n        /* no break */\n        case 5: *((int*) (dd - 5)) = *((int*) (ss - 5));\n        /* no break */\n        case 1: dd[-1] = ss[-1];\n            break;\n        case 0:\n        default: break;\n    }\n}\n\nvoid CPINLINE swoole_memcpy_fast(void *destination, const void *source, size_t size)\n{\n    unsigned char *dst = (unsigned char*) destination;\n    const unsigned char *src = (const unsigned char*) source;\n\n    // small memory copy\n    if (size < 64)\n    {\n        swoole_mini_memcpy(dst, src, size);\n        return;\n    }\n\n    size_t diff = (((size_t) dst + 15L) & (~15L)) - ((size_t) dst);\n    if (diff > 0)\n    {\n        swoole_mini_memcpy(dst, src, diff);\n        dst += diff;\n        src += diff;\n        size -= diff;\n    }\n\n    // 4\u4e2a\u5bc4\u5b58\u5668\n    __m128i c1, c2, c3, c4;\n\n    if ((((size_t) src) & 15L) == 0)\n    {\n        for(; size >= 64; size -= 64)\n        {\n            //load \u65f6\u5019\u5c06\u4e0b\u6b21\u8981\u7528\u7684\u6570\u636e\u63d0\u524dfetch\n            _mm_prefetch((const char*) (src + 64), _MM_HINT_NTA);\n            _mm_prefetch((const char*) (dst + 64), _MM_HINT_T0);\n            //\u4ece\u5185\u5b58\u4e2dload\u5230\u5bc4\u5b58\u5668\n            c1 = _mm_load_si128(((const __m128i*) src) + 0);\n            c2 = _mm_load_si128(((const __m128i*) src) + 1);\n            c3 = _mm_load_si128(((const __m128i*) src) + 2);\n            c4 = _mm_load_si128(((const __m128i*) src) + 3);\n            src += 64;\n            //\u5199\u56de\u5185\u5b58\n            _mm_store_si128((((__m128i*) dst) + 0), c1);\n            _mm_store_si128((((__m128i*) dst) + 1), c2);\n            _mm_store_si128((((__m128i*) dst) + 2), c3);\n            _mm_store_si128((((__m128i*) dst) + 3), c4);\n            dst += 64;\n        }\n    }\n    else\n    {\n        for(; size >= 64; size -= 64)\n        {\n            _mm_prefetch((const char*) (src + 64), _MM_HINT_NTA);\n            _mm_prefetch((const char*) (dst + 64), _MM_HINT_T0);\n            c1 = _mm_loadu_si128(((const __m128i*) src) + 0);\n            c2 = _mm_loadu_si128(((const __m128i*) src) + 1);\n            c3 = _mm_loadu_si128(((const __m128i*) src) + 2);\n            c4 = _mm_loadu_si128(((const __m128i*) src) + 3);\n            src += 64;\n            _mm_store_si128((((__m128i*) dst) + 0), c1);\n            _mm_store_si128((((__m128i*) dst) + 1), c2);\n            _mm_store_si128((((__m128i*) dst) + 2), c3);\n            _mm_store_si128((((__m128i*) dst) + 3), c4);\n            dst += 64;\n        }\n    }\n    // _mm_sfence();\n\n    // return memcpy_tiny(dst, src, size);\n}\n#endif\n\nstatic CPINLINE void swoole_string_cpy(seriaString *str, void *mem, size_t len)\n{\n    swoole_check_size(str, len + 15L);\n    //example:13+15=28   28& 11111111 11111111 11111111 11110000\n    //str->offset = ((str->offset + 15L) & ~15L);\n    //    swoole_memcspy_fast(str->buffer + str->offset, mem, len);\n    memcpy(str->buffer + str->offset, mem, len);\n    str->offset = len + str->offset;\n}\n\nstatic CPINLINE void swoole_set_zend_value(seriaString *str, void *value)\n{\n    swoole_check_size(str, sizeof (zend_value));\n    *(zend_value*) (str->buffer + str->offset) = *((zend_value*) value);\n    str->offset = sizeof (zend_value) + str->offset;\n}\n\nstatic CPINLINE void swoole_serialize_long(seriaString *buffer, zval *zvalue, SBucketType* type)\n{\n    zend_long value = Z_LVAL_P(zvalue);\n    //01111111 - 11111111\n    if (value <= 0x7f && value >= -0x7f)\n    {\n        type->data_len = 0;\n        SERIA_SET_ENTRY_TYPE_WITH_MINUS(buffer, value);\n    }\n    else if (value <= 0x7fff && value >= -0x7fff)\n    {\n        type->data_len = 1;\n        SERIA_SET_ENTRY_SHORT_WITH_MINUS(buffer, value);\n    }\n    else if (value <= 0x7fffffff && value >= -0x7fffffff)\n    {\n        type->data_len = 2;\n        SERIA_SET_ENTRY_SIZE4_WITH_MINUS(buffer, value);\n    }\n    else\n    {\n        type->data_len = 3;\n        swoole_string_cpy(buffer, &zvalue->value, sizeof (zend_value));\n    }\n\n}\n\nstatic CPINLINE void* swoole_unserialize_long(void *buffer, zval *ret_value, SBucketType type)\n{\n    if (type.data_len == 0)\n    {//1 byte\n        Z_LVAL_P(ret_value) = *((char*) buffer);\n        buffer += sizeof (char);\n    }\n    else if (type.data_len == 1)\n    {//2 byte\n        Z_LVAL_P(ret_value) = *((short*) buffer);\n        buffer += sizeof (short);\n    }\n    else if (type.data_len == 2)\n    {//4 byte\n        Z_LVAL_P(ret_value) = *((int32_t *) buffer);\n        buffer += sizeof (int32_t);\n    }\n    else\n    {//8 byte\n        ret_value->value = *((zend_value*) buffer);\n        buffer += sizeof (zend_value);\n    }\n    return buffer;\n}\n\nstatic uint32_t CPINLINE cp_zend_hash_check_size(uint32_t nSize)\n{\n#if defined(ZEND_WIN32)\n    unsigned long index;\n#endif\n\n    /* Use big enough power of 2 */\n    /* size should be between HT_MIN_SIZE and HT_MAX_SIZE */\n    if (nSize < HT_MIN_SIZE)\n    {\n        nSize = HT_MIN_SIZE;\n    }//    else if (UNEXPECTED(nSize >= 1000000))\n    else if (UNEXPECTED(nSize >= HT_MAX_SIZE))\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"invalid unserialize data\");\n        return 0;\n    }\n\n#if defined(ZEND_WIN32)\n    if (BitScanReverse(&index, nSize - 1))\n    {\n        return 0x2 << ((31 - index) ^ 0x1f);\n    }\n    else\n    {\n        /* nSize is ensured to be in the valid range, fall back to it\n           rather than using an undefined bis scan result. */\n        return nSize;\n    }\n#elif (defined(__GNUC__) || __has_builtin(__builtin_clz))  && defined(PHP_HAVE_BUILTIN_CLZ)\n    return 0x2 << (__builtin_clz(nSize - 1) ^ 0x1f);\n#else\n    nSize -= 1;\n    nSize |= (nSize >> 1);\n    nSize |= (nSize >> 2);\n    nSize |= (nSize >> 4);\n    nSize |= (nSize >> 8);\n    nSize |= (nSize >> 16);\n    return nSize + 1;\n#endif\n}\n\nstatic CPINLINE void swoole_mini_filter_clear()\n{\n    if (swSeriaG.pack_string)\n    {\n        memset(&mini_filter, 0, sizeof (mini_filter));\n        if (bigger_filter)\n        {\n            efree(bigger_filter);\n            bigger_filter = NULL;\n\n        }\n        memset(&swSeriaG.filter, 0, sizeof (struct _swMinFilter));\n    }\n}\n\nstatic CPINLINE void swoole_make_bigger_filter_size()\n{\n    if (FILTER_SIZE <= swSeriaG.filter.mini_fillter_miss_cnt &&\n            swSeriaG.filter.mini_fillter_find_cnt < swSeriaG.filter.mini_fillter_miss_cnt)\n        //        if (FILTER_SIZE <= swSeriaG.filter.mini_fillter_miss_cnt &&\n        //                (swSeriaG.filter.mini_fillter_find_cnt / swSeriaG.filter.mini_fillter_miss_cnt) < 1)\n    {\n        swSeriaG.filter.bigger_fillter_size = swSeriaG.filter.mini_fillter_miss_cnt * 128;\n        bigger_filter = (swPoolstr*) ecalloc(1, sizeof (swPoolstr) * swSeriaG.filter.bigger_fillter_size);\n        memcpy(bigger_filter, &mini_filter, sizeof (mini_filter));\n    }\n}\n\nstatic CPINLINE void swoole_mini_filter_add(zend_string *zstr, size_t offset, zend_uchar byte)\n{\n    if (swSeriaG.pack_string)\n    {\n        offset -= _STR_HEADER_SIZE;\n        //head 3bit is overhead\n        if (offset >= 0x1fffffff)\n        {\n            return;\n        }\n        if (bigger_filter)\n        {\n            uint32_t mod_big = zstr->h & (swSeriaG.filter.bigger_fillter_size - 1);\n\n            bigger_filter[mod_big].offset = offset << 3;\n            if (offset <= 0x1fff)\n            {\n                bigger_filter[mod_big].offset |= byte;\n            }\n            else\n            {\n                bigger_filter[mod_big].offset |= (byte | 4);\n            }\n            bigger_filter[mod_big].str = zstr;\n        }\n        else\n        {\n            uint16_t mod = zstr->h & (FILTER_SIZE - 1);\n            //repalce it is effective,cause the principle of locality\n            mini_filter[mod].offset = offset << 3;\n            if (offset <= 0x1fff)\n            {\n                mini_filter[mod].offset |= byte;\n            }\n            else\n            {\n                mini_filter[mod].offset |= (byte | 4);\n            }\n            mini_filter[mod].str = zstr;\n            swSeriaG.filter.mini_fillter_miss_cnt++;\n            swoole_make_bigger_filter_size();\n        }\n    }\n\n}\n\nstatic CPINLINE swPoolstr* swoole_mini_filter_find(zend_string *zstr)\n{\n    if (swSeriaG.pack_string)\n    {\n        zend_ulong h = zend_string_hash_val(zstr);\n        swPoolstr* str = NULL;\n        if (bigger_filter)\n        {\n            str = &bigger_filter[h & (swSeriaG.filter.bigger_fillter_size - 1)];\n        }\n        else\n        {\n            str = &mini_filter[h & (FILTER_SIZE - 1)];\n        }\n\n        if (!str->str)\n        {\n            return NULL;\n        }\n\n        if (str->str->h == h &&\n                zstr->len == str->str->len &&\n                memcmp(zstr->val, str->str->val, zstr->len) == 0)\n        {\n            swSeriaG.filter.mini_fillter_find_cnt++;\n            return str;\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n/*\n * arr layout\n * type|key?|bucketlen|buckets\n */\nstatic CPINLINE void seria_array_type(zend_array *ht, seriaString *buffer, size_t type_offset, size_t blen_offset)\n{\n    buffer->offset = blen_offset;\n    if (ht->nNumOfElements <= 0xff)\n    {\n        ((SBucketType*) (buffer->buffer + type_offset))->data_len = 1;\n        SERIA_SET_ENTRY_TYPE(buffer, ht->nNumOfElements)\n    }\n    else if (ht->nNumOfElements <= 0xffff)\n    {\n        ((SBucketType*) (buffer->buffer + type_offset))->data_len = 2;\n        SERIA_SET_ENTRY_SHORT(buffer, ht->nNumOfElements);\n    }\n    else\n    {\n        ((SBucketType*) (buffer->buffer + type_offset))->data_len = 0;\n        swoole_string_cpy(buffer, &ht->nNumOfElements, sizeof (uint32_t));\n    }\n}\n\n/*\n * buffer is bucket len addr\n */\nstatic CPINLINE void* get_array_real_len(void *buffer, zend_uchar data_len, uint32_t *nNumOfElements)\n{\n    if (data_len == 1)\n    {\n        *nNumOfElements = *((zend_uchar*) buffer);\n        return buffer + sizeof (zend_uchar);\n    }\n    else if (data_len == 2)\n    {\n        *nNumOfElements = *((unsigned short*) buffer);\n        return buffer + sizeof (short);\n    }\n    else\n    {\n        *nNumOfElements = *((uint32_t*) buffer);\n        return buffer + sizeof (uint32_t);\n    }\n}\n\nstatic CPINLINE void * get_pack_string_len_addr(void ** buffer, size_t *strlen)\n{\n\n    uint8_t overhead = (*(uint8_t*) * buffer);\n    uint32_t real_offset;\n    uint8_t len_byte;\n\n    if (overhead & 4)\n    {\n        real_offset = (*(uint32_t*) * buffer) >> 3;\n        len_byte = overhead & 3;\n        (*buffer) += 4;\n    }\n    else\n    {\n        real_offset = (*(uint16_t*) * buffer) >> 3;\n        len_byte = overhead & 3;\n        (*buffer) += 2;\n    }\n    void *str_pool_addr = unser_start + real_offset;\n    if (len_byte == 1)\n    {\n        *strlen = *((zend_uchar*) str_pool_addr);\n        str_pool_addr = str_pool_addr + sizeof (zend_uchar);\n    }\n    else if (len_byte == 2)\n    {\n        *strlen = *((unsigned short*) str_pool_addr);\n        str_pool_addr = str_pool_addr + sizeof (unsigned short);\n    }\n    else\n    {\n        *strlen = *((size_t*) str_pool_addr);\n        str_pool_addr = str_pool_addr + sizeof (size_t);\n    }\n    //    size_t tmp = *strlen;\n    return str_pool_addr;\n}\n\n/*\n * array\n */\n\nstatic void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfElements, long flag)\n{\n    //Initialize zend array\n    zend_ulong h, nIndex, max_index = 0;\n    uint32_t size = cp_zend_hash_check_size(nNumOfElements);\n    if (!size)\n    {\n        return NULL;\n    }\n    if (!buffer)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    ZVAL_NEW_ARR(zvalue);\n    //Initialize buckets\n    zend_array *ht = Z_ARR_P(zvalue);\n    ht->nTableSize = size;\n    ht->nNumUsed = nNumOfElements;\n    ht->nNumOfElements = nNumOfElements;\n    ht->nNextFreeElement = 0;\n#ifdef HASH_FLAG_APPLY_PROTECTION\n    ht->u.flags = HASH_FLAG_APPLY_PROTECTION;\n#endif\n    ht->nTableMask = -(ht->nTableSize);\n    ht->pDestructor = ZVAL_PTR_DTOR;\n\n    GC_SET_REFCOUNT(ht, 1);\n    GC_TYPE_INFO(ht) = IS_ARRAY;\n    // if (ht->nNumUsed)\n    //{\n    //    void *arData = ecalloc(1, len);\n    HT_SET_DATA_ADDR(ht, emalloc(HT_SIZE(ht)));\n    ht->u.flags |= HASH_FLAG_INITIALIZED;\n    int ht_hash_size = HT_HASH_SIZE((ht)->nTableMask);\n    if (ht_hash_size <= 0)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    HT_HASH_RESET(ht);\n    //}\n\n\n    int idx;\n    Bucket *p;\n    for(idx = 0; idx < nNumOfElements; idx++)\n    {\n        if (!buffer)\n        {\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal array unserialize data\");\n            return NULL;\n        }\n        SBucketType type = *((SBucketType*) buffer);\n        buffer += sizeof (SBucketType);\n        p = ht->arData + idx;\n        /* Initialize key */\n        if (type.key_type == KEY_TYPE_STRING)\n        {\n            size_t key_len;\n            if (type.key_len == 3)\n            {//read the same mem\n                void *str_pool_addr = get_pack_string_len_addr(&buffer, &key_len);\n                p->key = zend_string_init((char*) str_pool_addr, key_len, 0);\n                h = zend_inline_hash_func((char*) str_pool_addr, key_len);\n                p->key->h = p->h = h;\n            }\n            else\n            {//move step\n                if (type.key_len == 1)\n                {\n                    key_len = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.key_len == 2)\n                {\n                    key_len = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    key_len = *((size_t*) buffer);\n                    buffer += sizeof (size_t);\n                }\n                p->key = zend_string_init((char*) buffer, key_len, 0);\n                //           h = zend_inline_hash_func((char*) buffer, key_len);\n                h = zend_inline_hash_func((char*) buffer, key_len);\n                buffer += key_len;\n                p->key->h = p->h = h;\n            }\n        }\n        else\n        {\n            if (type.key_len == 0)\n            {\n                //means pack\n                h = p->h = idx;\n                p->key = NULL;\n                max_index = p->h + 1;\n                //                ht->u.flags |= HASH_FLAG_PACKED;\n            }\n            else\n            {\n                if (type.key_len == 1)\n                {\n                    h = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.key_len == 2)\n                {\n                    h = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    h = *((zend_ulong*) buffer);\n                    buffer += sizeof (zend_ulong);\n                }\n                p->h = h;\n                p->key = NULL;\n                if (h >= max_index)\n                {\n                    max_index = h + 1;\n                }\n            }\n        }\n        /* Initialize hash */\n        nIndex = h | ht->nTableMask;\n        Z_NEXT(p->val) = HT_HASH(ht, nIndex);\n        HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\n        /* Initialize data type */\n        p->val.u1.v.type = type.data_type;\n        Z_TYPE_FLAGS(p->val) = 0;\n\n        /* Initialize data */\n        if (type.data_type == IS_STRING)\n        {\n            size_t data_len;\n            if (type.data_len == 3)\n            {//read the same mem\n                void *str_pool_addr = get_pack_string_len_addr(&buffer, &data_len);\n                p->val.value.str = zend_string_init((char*) str_pool_addr, data_len, 0);\n            }\n            else\n            {\n                if (type.data_len == 1)\n                {\n                    data_len = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.data_len == 2)\n                {\n                    data_len = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    data_len = *((size_t*) buffer);\n                    buffer += sizeof (size_t);\n                }\n                p->val.value.str = zend_string_init((char*) buffer, data_len, 0);\n                buffer += data_len;\n            }\n            Z_TYPE_INFO(p->val) = IS_STRING_EX;\n        }\n        else if (type.data_type == IS_ARRAY)\n        {\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            buffer = swoole_unserialize_arr(buffer, &p->val, num, flag);\n        }\n        else if (type.data_type == IS_LONG)\n        {\n            buffer = swoole_unserialize_long(buffer, &p->val, type);\n        }\n        else if (type.data_type == IS_DOUBLE)\n        {\n            p->val.value = *((zend_value*) buffer);\n            buffer += sizeof (zend_value);\n        }\n        else if (type.data_type == IS_UNDEF)\n        {\n            buffer = swoole_unserialize_object(buffer, &p->val, type.data_len, NULL, flag);\n            Z_TYPE_INFO(p->val) = IS_OBJECT_EX;\n        }\n\n    }\n    ht->nNextFreeElement = max_index;\n\n    return buffer;\n\n}\n\n/*\n * arr layout\n * type|key?|bucketlen|buckets\n */\nstatic void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue)\n{\n    zval *data;\n    zend_string *key;\n    zend_ulong index;\n    swPoolstr *swStr = NULL;\n    zend_uchar is_pack = zvalue->u.flags & HASH_FLAG_PACKED;\n\n    ZEND_HASH_FOREACH_KEY_VAL(zvalue, index, key, data)\n    {\n        SBucketType type = {0};\n        type.data_type = Z_TYPE_P(data);\n        //start point\n        size_t p = buffer->offset;\n\n        if (is_pack && zvalue->nNextFreeElement == zvalue->nNumOfElements)\n        {\n            type.key_type = KEY_TYPE_INDEX;\n            type.key_len = 0;\n            SERIA_SET_ENTRY_TYPE(buffer, type);\n        }\n        else\n        {\n            //seria key\n            if (key)\n            {\n                type.key_type = KEY_TYPE_STRING;\n                if ((swStr = swoole_mini_filter_find(key)))\n                {\n                    type.key_len = 3; //means use same string\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    if (swStr->offset & 4)\n                    {\n                        SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);\n                    }\n                    else\n                    {\n                        SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);\n                    }\n                }\n                else\n                {\n                    if (key->len <= 0xff)\n                    {\n                        type.key_len = 1;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 1);\n                        SERIA_SET_ENTRY_TYPE(buffer, key->len);\n                        swoole_string_cpy(buffer, key->val, key->len);\n                    }\n                    else if (key->len <= 0xffff)\n                    {//if more than this  don't need optimize\n                        type.key_len = 2;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 2);\n                        SERIA_SET_ENTRY_SHORT(buffer, key->len);\n                        swoole_string_cpy(buffer, key->val, key->len);\n                    }\n                    else\n                    {\n                        type.key_len = 0;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 3);\n                        swoole_string_cpy(buffer, key + XtOffsetOf(zend_string, len), sizeof (size_t) + key->len);\n                    }\n                }\n            }\n            else\n            {\n                type.key_type = KEY_TYPE_INDEX;\n                if (index <= 0xff)\n                {\n                    type.key_len = 1;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_TYPE(buffer, index);\n                }\n                else if (index <= 0xffff)\n                {\n                    type.key_len = 2;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_SHORT(buffer, index);\n                }\n                else\n                {\n                    type.key_len = 3;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_ULONG(buffer, index);\n                }\n\n            }\n        }\n        //seria data\ntry_again:\n        switch (Z_TYPE_P(data))\n        {\n            case IS_STRING:\n            {\n                if ((swStr = swoole_mini_filter_find(Z_STR_P(data))))\n                {\n                    ((SBucketType*) (buffer->buffer + p))->data_len = 3; //means use same string\n                    if (swStr->offset & 4)\n                    {\n                        SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);\n                    }\n                    else\n                    {\n                        SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);\n                    }\n                }\n                else\n                {\n                    if (Z_STRLEN_P(data) <= 0xff)\n                    {\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 1;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 1);\n                        SERIA_SET_ENTRY_TYPE(buffer, Z_STRLEN_P(data));\n                        swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));\n                    }\n                    else if (Z_STRLEN_P(data) <= 0xffff)\n                    {\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 2;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 2);\n                        SERIA_SET_ENTRY_SHORT(buffer, Z_STRLEN_P(data));\n                        swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));\n                    }\n                    else\n                    {//if more than this  don't need optimize\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 0;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 3);\n                        swoole_string_cpy(buffer, (char*) Z_STR_P(data) + XtOffsetOf(zend_string, len), sizeof (size_t) + Z_STRLEN_P(data));\n                    }\n                }\n                break;\n            }\n            case IS_LONG:\n            {\n                SBucketType* long_type = (SBucketType*) (buffer->buffer + p);\n                swoole_serialize_long(buffer, data, long_type);\n                break;\n            }\n            case IS_DOUBLE:\n                swoole_set_zend_value(buffer, &(data->value));\n                break;\n            case IS_REFERENCE:\n                data = Z_REFVAL_P(data);\n                ((SBucketType*) (buffer->buffer + p))->data_type = Z_TYPE_P(data);\n                goto try_again;\n                break;\n            case IS_ARRAY:\n            {\n                zend_array *ht = Z_ARRVAL_P(data);\n\n                if (GC_IS_RECURSIVE(ht))\n                {\n                    ((SBucketType*) (buffer->buffer + p))->data_type = IS_NULL;//reset type null\n                    php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the array has cycle ref\");\n                }\n                else\n                {\n                    seria_array_type(ht, buffer, p, buffer->offset);\n                    if (ZEND_HASH_APPLY_PROTECTION(ht))\n                    {\n                        GC_PROTECT_RECURSION(ht);\n                        swoole_serialize_arr(buffer, ht);\n                        GC_UNPROTECT_RECURSION(ht);\n                    }\n                    else\n                    {\n                        swoole_serialize_arr(buffer, ht);\n                    }\n\n                }\n                break;\n            }\n                //object propterty table is this type\n            case IS_INDIRECT:\n                data = Z_INDIRECT_P(data);\n                zend_uchar type = Z_TYPE_P(data);\n                ((SBucketType*) (buffer->buffer + p))->data_type = (type == IS_UNDEF ? IS_NULL : type);\n                goto try_again;\n                break;\n            case IS_OBJECT:\n            {\n                /*\n                 * layout\n                 * type | key | namelen | name | bucket len |buckets\n                 */\n                ((SBucketType*) (buffer->buffer + p))->data_type = IS_UNDEF;\n\n                if (ZEND_HASH_APPLY_PROTECTION(Z_OBJPROP_P(data)))\n                {\n                    GC_PROTECT_RECURSION(Z_OBJPROP_P(data));\n                    swoole_serialize_object(buffer, data, p);\n                    GC_UNPROTECT_RECURSION(Z_OBJPROP_P(data));\n                }\n                else\n                {\n                    swoole_serialize_object(buffer, data, p);\n                }\n\n                break;\n            }\n            default://\n                break;\n\n        }\n\n    }\n    ZEND_HASH_FOREACH_END();\n}\n\n/*\n * string\n */\nstatic CPINLINE void swoole_serialize_string(seriaString *buffer, zval *zvalue)\n{\n\n    swoole_string_cpy(buffer, Z_STRVAL_P(zvalue), Z_STRLEN_P(zvalue));\n}\n\nstatic CPINLINE zend_string* swoole_unserialize_string(void *buffer, size_t len)\n{\n\n    return zend_string_init(buffer, len, 0);\n}\n\n/*\n * raw\n */\nstatic CPINLINE void swoole_unserialize_raw(void *buffer, zval *zvalue)\n{\n\n    memcpy(&zvalue->value, buffer, sizeof (zend_value));\n}\n\n#if 0\n/*\n * null\n */\nstatic CPINLINE void swoole_unserialize_null(void *buffer, zval *zvalue)\n{\n\n    memcpy(&zvalue->value, buffer, sizeof (zend_value));\n}\n#endif\n\nstatic CPINLINE void swoole_serialize_raw(seriaString *buffer, zval *zvalue)\n{\n\n    swoole_string_cpy(buffer, &zvalue->value, sizeof (zend_value));\n}\n\n/*\n * obj layout\n * type|bucket key|name len| name| buket len |buckets\n */\nstatic void swoole_serialize_object(seriaString *buffer, zval *obj, size_t start)\n{\n    zend_string *name = Z_OBJCE_P(obj)->name;\n    if (GC_IS_RECURSIVE(Z_OBJPROP_P(obj)))\n    {\n        zend_throw_exception_ex(NULL, 0, \"the object %s has cycle ref.\", name->val);\n        return;\n    }\n    if (name->len > 0xffff)\n    {//so long?\n        zend_throw_exception_ex(NULL, 0, \"the object name is too long.\");\n    }\n    else\n    {\n        SERIA_SET_ENTRY_SHORT(buffer, name->len);\n        swoole_string_cpy(buffer, name->val, name->len);\n    }\n\n    zend_class_entry *ce = Z_OBJ_P(obj)->ce;\n    if (ce && zend_hash_exists(&ce->function_table, Z_STR(swSeriaG.sleep_fname)))\n    {\n        zval retval;\n        if (call_user_function_ex(NULL, obj, &swSeriaG.sleep_fname, &retval, 0, 0, 1, NULL) == SUCCESS)\n        {\n            if (EG(exception))\n            {\n                zval_dtor(&retval);\n                return;\n            }\n            if (Z_TYPE(retval) == IS_ARRAY)\n            {\n                zend_string *prop_key;\n                zval *prop_value, *sleep_value;\n                const char *prop_name, *class_name;\n                size_t prop_key_len;\n                int got_num = 0;\n\n                //for the zero malloc\n                zend_array tmp_arr;\n                zend_array *ht = (zend_array *) & tmp_arr;\n#if PHP_VERSION_ID >= 70300\n                _zend_hash_init(ht, zend_hash_num_elements(Z_ARRVAL(retval)), ZVAL_PTR_DTOR, 0);\n#else\n                _zend_hash_init(ht, zend_hash_num_elements(Z_ARRVAL(retval)), ZVAL_PTR_DTOR, 0 ZEND_FILE_LINE_CC);\n#endif\n                ht->nTableMask = -(ht)->nTableSize;\n                ALLOCA_FLAG(use_heap);\n                void *ht_addr = do_alloca(HT_SIZE(ht), use_heap);\n                HT_SET_DATA_ADDR(ht, ht_addr);\n                ht->u.flags |= HASH_FLAG_INITIALIZED;\n                HT_HASH_RESET(ht);\n\n                //just clean property do not add null when does not exist\n                //we double for each, cause we do not malloc  and release it\n\n                ZEND_HASH_FOREACH_STR_KEY_VAL(Z_OBJPROP_P(obj), prop_key, prop_value)\n                {\n                    //get origin property name\n                    zend_unmangle_property_name_ex(prop_key, &class_name, &prop_name, &prop_key_len);\n\n                    ZEND_HASH_FOREACH_VAL(Z_ARRVAL(retval), sleep_value)\n                    {\n                        if (Z_TYPE_P(sleep_value) == IS_STRING &&\n                                Z_STRLEN_P(sleep_value) == prop_key_len &&\n                                memcmp(Z_STRVAL_P(sleep_value), prop_name, prop_key_len) == 0)\n                        {\n                            got_num++;\n                            //add mangle key,unmangle in unseria\n                            _zend_hash_add_or_update(ht, prop_key, prop_value, HASH_UPDATE ZEND_FILE_LINE_CC);\n\n                            break;\n                        }\n\n                    }\n                    ZEND_HASH_FOREACH_END();\n\n                }\n                ZEND_HASH_FOREACH_END();\n\n                //there some member not in property\n                if (zend_hash_num_elements(Z_ARRVAL(retval)) > got_num)\n                {\n                    php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"__sleep() retrun a member but does not exist in property\");\n\n                }\n                seria_array_type(ht, buffer, start, buffer->offset);\n                swoole_serialize_arr(buffer, ht);\n                ZSTR_ALLOCA_FREE(ht_addr, use_heap);\n                zval_dtor(&retval);\n                return;\n\n            }\n            else\n            {\n                php_error_docref(NULL TSRMLS_CC, E_NOTICE, \" __sleep should return an array only containing the \"\n                        \"names of instance-variables to serialize\");\n                zval_dtor(&retval);\n            }\n\n        }\n    }\n    seria_array_type(Z_OBJPROP_P(obj), buffer, start, buffer->offset);\n    swoole_serialize_arr(buffer, Z_OBJPROP_P(obj));\n    //    printf(\"hash2 %u\\n\",ce->properties_info.arData[0].key->h);\n}\n\n/*\n * for the zero malloc\n */\nstatic CPINLINE zend_string * swoole_string_init(const char *str, size_t len)\n{\n#ifdef ZEND_DEBUG\n    return zend_string_init(str, len, 0);\n#else\n    ALLOCA_FLAG(use_heap);\n    zend_string *ret;\n    ZSTR_ALLOCA_INIT(ret, str, len, use_heap);\n\n    return ret;\n#endif\n}\n\n/*\n * for the zero malloc\n */\nstatic CPINLINE void swoole_string_release(zend_string *str)\n{\n#ifdef ZEND_DEBUG\n    zend_string_release(str);\n#else\n    //if dont support alloc 0 will ignore\n    //if support alloc size is definitely < ZEND_ALLOCA_MAX_SIZE\n    ZSTR_ALLOCA_FREE(str, 0);\n#endif\n}\n\nstatic CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    //user class , do not support incomplete class now\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    // try call unserialize callback and retry lookup\n    zval user_func, args[1], retval;\n\n    /* Check for unserialize callback */\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    \n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n\n    swoole_string_release(fname);\n\n    //user class , do not support incomplete class now\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}\n\n/*\n * obj layout\n * type| key[0|1] |name len| name| buket len |buckets\n */\nstatic void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag)\n{\n    zval property;\n    uint32_t arr_num = 0;\n    size_t name_len = *((unsigned short*) buffer);\n    if (!name_len)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    buffer += 2;\n    zend_string *class_name;\n    if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS) \n    {\n        class_name = swoole_string_init(ZEND_STRL(\"StdClass\"));\n    } \n    else \n    {\n        class_name = swoole_string_init((char*) buffer, name_len);\n    }\n    buffer += name_len;\n    zend_class_entry *ce = swoole_try_get_ce(class_name);\n    swoole_string_release(class_name);\n\n    if (!ce)\n    {\n        return NULL;\n    }\n\n    buffer = get_array_real_len(buffer, bucket_len, &arr_num);\n    buffer = swoole_unserialize_arr(buffer, &property, arr_num, flag);\n\n    object_init_ex(return_value, ce);\n\n    zval *data,*d;\n    zend_string *key;\n    zend_ulong index;\n\n    \n    ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data)\n    {\n        const char *prop_name, *tmp;\n        size_t prop_len;\n        if (key)\n        {\n\n            if ((d = zend_hash_find(Z_OBJPROP_P(return_value), key)) != NULL)\n            {\n                if (Z_TYPE_P(d) == IS_INDIRECT)\n                {\n                    d = Z_INDIRECT_P(d);\n                }\n                zval_dtor(d);\n                ZVAL_COPY(d, data);\n            }\n            else\n            {\n                zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len);\n                zend_update_property(ce, return_value, prop_name, prop_len, data);\n            }\n//            zend_hash_update(Z_OBJPROP_P(return_value),key,data);\n//            zend_update_property(ce, return_value, ZSTR_VAL(key), ZSTR_LEN(key), data);\n        }\n        else\n        {\n            zend_hash_next_index_insert(Z_OBJPROP_P(return_value), data);\n        }\n    }\n    ZEND_HASH_FOREACH_END();\n    zval_dtor(&property);\n\n    if (ce->constructor)\n    {\n        //        zend_fcall_info fci = {0};\n        //        zend_fcall_info_cache fcc = {0};\n        //        fci.size = sizeof (zend_fcall_info);\n        //        zval retval;\n        //        ZVAL_UNDEF(&fci.function_name);\n        //        fci.retval = &retval;\n        //        fci.param_count = 0;\n        //        fci.params = NULL;\n        //        fci.no_separation = 1;\n        //        fci.object = Z_OBJ_P(return_value);\n        //\n        //        zend_fcall_info_args_ex(&fci, ce->constructor, args);\n        //\n        //        fcc.initialized = 1;\n        //        fcc.function_handler = ce->constructor;\n        //        //        fcc.calling_scope = EG(scope);\n        //        fcc.called_scope = Z_OBJCE_P(return_value);\n        //        fcc.object = Z_OBJ_P(return_value);\n        //\n        //        if (zend_call_function(&fci, &fcc) == FAILURE)\n        //        {\n        //            zend_throw_exception_ex(NULL, 0, \"could not call class constructor\");\n        //        }\n        //        zend_fcall_info_args_clear(&fci, 1);\n    }\n\n\n    //call object __wakeup\n    if (zend_hash_str_exists(&ce->function_table, ZEND_STRL(\"__wakeup\")))\n    {\n        zval ret, wakeup;\n        zend_string *fname = swoole_string_init(ZEND_STRL(\"__wakeup\"));\n        Z_STR(wakeup) = fname;\n        Z_TYPE_INFO(wakeup) = IS_STRING_EX;\n        call_user_function_ex(CG(function_table), return_value, &wakeup, &ret, 0, NULL, 1, NULL);\n        swoole_string_release(fname);\n        zval_ptr_dtor(&ret);\n    }\n\n    return buffer;\n\n}\n\n/*\n * dispatch\n */\n\nstatic CPINLINE void swoole_seria_dispatch(seriaString *buffer, zval *zvalue)\n{\nagain:\n    switch (Z_TYPE_P(zvalue))\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            break;\n        case IS_LONG:\n        {\n            SBucketType* type = (SBucketType*) (buffer->buffer + _STR_HEADER_SIZE);\n            swoole_serialize_long(buffer, zvalue, type);\n            break;\n        }\n        case IS_DOUBLE:\n            swoole_serialize_raw(buffer, zvalue);\n            break;\n        case IS_STRING:\n            swoole_serialize_string(buffer, zvalue);\n            break;\n        case IS_ARRAY:\n        {\n            seria_array_type(Z_ARRVAL_P(zvalue), buffer, _STR_HEADER_SIZE, _STR_HEADER_SIZE + 1);\n            swoole_serialize_arr(buffer, Z_ARRVAL_P(zvalue));\n            swoole_string_cpy(buffer, SWOOLE_SERI_EOF, 3);\n            swoole_mini_filter_clear();\n            break;\n        }\n        case IS_REFERENCE:\n            zvalue = Z_REFVAL_P(zvalue);\n            goto again;\n            break;\n        case IS_OBJECT:\n        {\n            SBucketType* type = (SBucketType*) (buffer->buffer + _STR_HEADER_SIZE);\n            type->data_type = IS_UNDEF;\n            swoole_serialize_object(buffer, zvalue, _STR_HEADER_SIZE);\n            swoole_string_cpy(buffer, SWOOLE_SERI_EOF, 3);\n            swoole_mini_filter_clear();\n            break;\n        }\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n\n            break;\n    }\n}\n\nPHPAPI zend_string* php_swoole_serialize(zval *zvalue)\n{\n\n    seriaString str;\n    swoole_string_new(SERIA_SIZE, &str, Z_TYPE_P(zvalue));\n    swoole_seria_dispatch(&str, zvalue); //serialize into a string\n    zend_string *z_str = (zend_string *) str.buffer;\n\n    z_str->len = str.offset - _STR_HEADER_SIZE;\n    z_str->val[z_str->len] = '\\0';\n    z_str->h = 0;\n    GC_SET_REFCOUNT(z_str, 1);\n    GC_TYPE_INFO(z_str) = IS_STRING_EX;\n\n    return z_str;\n}\n\nstatic CPINLINE int swoole_seria_check_eof(void *buffer, size_t len)\n{\n    void *eof_str = buffer - sizeof (SBucketType) + len - 3;\n    if (memcmp(eof_str, SWOOLE_SERI_EOF, 3) == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return -1;\n    }\n}\n\n/*\n * buffer is seria string buffer\n * len is string len\n * return_value is unseria bucket\n * args is for the object ctor (can be NULL)\n */\nPHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)\n{\n    SBucketType type = *(SBucketType*) (buffer);\n    zend_uchar real_type = type.data_type;\n    buffer += sizeof (SBucketType);\n    switch (real_type)\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_LONG:\n            swoole_unserialize_long(buffer, return_value, type);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_DOUBLE:\n            swoole_unserialize_raw(buffer, return_value);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_STRING:\n            len -= sizeof (SBucketType);\n            zend_string *str = swoole_unserialize_string(buffer, len);\n            ZVAL_STR(return_value, str);\n            break;\n        case IS_ARRAY:\n        {\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            if (!swoole_unserialize_arr(buffer, return_value, num, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        }\n        case IS_UNDEF:\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n            return SW_FALSE;\n    }\n\n    return SW_TRUE;\n}\n\nstatic PHP_METHOD(swoole_serialize, pack)\n{\n    zval *zvalue;\n    zend_size_t is_fast = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|l\", &zvalue, &is_fast) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n    swSeriaG.pack_string = !is_fast;\n    zend_string *z_str = php_swoole_serialize(zvalue);\n\n    RETURN_STR(z_str);\n}\n\nstatic PHP_METHOD(swoole_serialize, unpack)\n{\n    char *buffer = NULL;\n    size_t arg_len;\n    zval *args = NULL; //for object\n    long flag = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|la\", &buffer, &arg_len, &flag, &args) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n    if (!php_swoole_unserialize(buffer, arg_len, return_value, args, flag))\n    {\n        RETURN_FALSE;\n    }\n}\n\n#endif\n"], "fixing_code": ["/*\n  +----------------------------------------------------------------------+\n  | Swoole                                                               |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 2.0 of the Apache license,    |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.apache.org/licenses/LICENSE-2.0.html                      |\n  | If you did not receive a copy of the Apache2.0 license and are unable|\n  | to obtain it through the world-wide-web, please send a note to       |\n  | license@swoole.com so we can mail you a copy immediately.            |\n  +----------------------------------------------------------------------+\n  | Author: xinhua.guo  <woshiguo35@gmail.com>                        |\n  +----------------------------------------------------------------------+\n */\n\n#include \"php_swoole.h\"\n#include \"swoole_serialize.h\"\n#ifdef __SSE2__\n#include <emmintrin.h>\n#endif\n\n#if PHP_MAJOR_VERSION >= 7\n#define CPINLINE sw_inline\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_serialize_pack, 0, 0, 1)\nZEND_ARG_INFO(0, data)\nZEND_ARG_INFO(0, flag)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_serialize_unpack, 0, 0, 1)\nZEND_ARG_INFO(0, string)\nZEND_ARG_INFO(0, args)\nZEND_END_ARG_INFO()\n\nstatic void swoole_serialize_object(seriaString *buffer, zval *zvalue, size_t start);\nstatic void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue);\nstatic void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t num, long flag);\nstatic void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag);\n\nstatic PHP_METHOD(swoole_serialize, pack);\nstatic PHP_METHOD(swoole_serialize, unpack);\n\n\nstatic const zend_function_entry swoole_serialize_methods[] = {\n    PHP_ME(swoole_serialize, pack, arginfo_swoole_serialize_pack, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)\n    PHP_ME(swoole_serialize, unpack, arginfo_swoole_serialize_unpack, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)\n    PHP_FE_END\n};\n\nzend_class_entry swoole_serialize_ce;\nzend_class_entry *swoole_serialize_class_entry_ptr;\n\n#define SWOOLE_SERI_EOF \"EOF\"\n#define CHECK_STEP if(buffer>unseri_buffer_end){ php_error_docref(NULL TSRMLS_CC, E_ERROR, \"illegal unserialize data\"); return NULL;}\n\nstatic struct _swSeriaG swSeriaG;\nchar *unseri_buffer_end = NULL;\n\nvoid swoole_serialize_init(int module_number TSRMLS_DC)\n{\n    SWOOLE_INIT_CLASS_ENTRY(swoole_serialize_ce, \"swoole_serialize\", \"Swoole\\\\Serialize\", swoole_serialize_methods);\n    swoole_serialize_class_entry_ptr = zend_register_internal_class(&swoole_serialize_ce TSRMLS_CC);\n    SWOOLE_CLASS_ALIAS(swoole_serialize, \"Swoole\\\\Serialize\");\n\n    //    ZVAL_STRING(&swSeriaG.sleep_fname, \"__sleep\");\n    zend_string *zstr_sleep = zend_string_init(\"__sleep\", sizeof (\"__sleep\") - 1, 1);\n    zend_string *zstr_weekup = zend_string_init(\"__weekup\", sizeof (\"__weekup\") - 1, 1);\n    ZVAL_STR(&swSeriaG.sleep_fname, zstr_sleep);\n    ZVAL_STR(&swSeriaG.weekup_fname, zstr_weekup);\n    //    ZVAL_STRING(&swSeriaG.weekup_fname, \"__weekup\");\n\n    memset(&swSeriaG.filter, 0, sizeof (swSeriaG.filter));\n    memset(&mini_filter, 0, sizeof (mini_filter));\n\n    REGISTER_LONG_CONSTANT(\"SWOOLE_FAST_PACK\", SW_FAST_PACK, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"UNSERIALIZE_OBJECT_TO_ARRAY\", UNSERIALIZE_OBJECT_TO_ARRAY, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"UNSERIALIZE_OBJECT_TO_STDCLASS\", UNSERIALIZE_OBJECT_TO_STDCLASS, CONST_CS | CONST_PERSISTENT);\n}\n\nstatic CPINLINE int swoole_string_new(size_t size, seriaString *str, zend_uchar type)\n{\n    int total = ZEND_MM_ALIGNED_SIZE(_STR_HEADER_SIZE + size + 1);\n    str->total = total;\n    //escape the header for later\n    str->offset = _STR_HEADER_SIZE;\n    //zend string addr\n    str->buffer = ecalloc(1, total);\n    if (!str->buffer)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR, \"malloc Error: %s [%d]\", strerror(errno), errno);\n    }\n\n    SBucketType real_type = {0};\n    real_type.data_type = type;\n    *(SBucketType*) (str->buffer + str->offset) = real_type;\n    str->offset += sizeof (SBucketType);\n    return 0;\n}\n\nstatic CPINLINE void swoole_check_size(seriaString *str, size_t len)\n{\n    int new_size = len + str->offset;\n    //    int new_size = len + str->offset + 3 + sizeof (zend_ulong); //space 1 for the type and 2 for key string len or index len and(zend_ulong) for key h\n    if (str->total < new_size)\n    {//extend it\n\n        new_size = ZEND_MM_ALIGNED_SIZE(new_size + SERIA_SIZE);\n        str->buffer = erealloc2(str->buffer, new_size, str->offset);\n        if (!str->buffer)\n        {\n            php_error_docref(NULL TSRMLS_CC, E_ERROR, \"realloc Error: %s [%d]\", strerror(errno), errno);\n        }\n        str->total = new_size;\n    }\n}\n#ifdef __SSE2__\n\nvoid CPINLINE swoole_mini_memcpy(void *dst, const void *src, size_t len)\n{\n    register unsigned char *dd = (unsigned char*) dst + len;\n    register const unsigned char *ss = (const unsigned char*) src + len;\n    switch (len)\n    {\n        case 68: *((int*) (dd - 68)) = *((int*) (ss - 68));\n            /* no break */\n        case 64: *((int*) (dd - 64)) = *((int*) (ss - 64));\n            /* no break */\n        case 60: *((int*) (dd - 60)) = *((int*) (ss - 60));\n            /* no break */\n        case 56: *((int*) (dd - 56)) = *((int*) (ss - 56));\n            /* no break */\n        case 52: *((int*) (dd - 52)) = *((int*) (ss - 52));\n            /* no break */\n        case 48: *((int*) (dd - 48)) = *((int*) (ss - 48));\n            /* no break */\n        case 44: *((int*) (dd - 44)) = *((int*) (ss - 44));\n            /* no break */\n        case 40: *((int*) (dd - 40)) = *((int*) (ss - 40));\n            /* no break */\n        case 36: *((int*) (dd - 36)) = *((int*) (ss - 36));\n            /* no break */\n        case 32: *((int*) (dd - 32)) = *((int*) (ss - 32));\n            /* no break */\n        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));\n            /* no break */\n        case 24: *((int*) (dd - 24)) = *((int*) (ss - 24));\n            /* no break */\n        case 20: *((int*) (dd - 20)) = *((int*) (ss - 20));\n            /* no break */\n        case 16: *((int*) (dd - 16)) = *((int*) (ss - 16));\n            /* no break */\n        case 12: *((int*) (dd - 12)) = *((int*) (ss - 12));\n            /* no break */\n        case 8: *((int*) (dd - 8)) = *((int*) (ss - 8));\n            /* no break */\n        case 4: *((int*) (dd - 4)) = *((int*) (ss - 4));\n            break;\n        case 67: *((int*) (dd - 67)) = *((int*) (ss - 67));\n            /* no break */\n        case 63: *((int*) (dd - 63)) = *((int*) (ss - 63));\n            /* no break */\n        case 59: *((int*) (dd - 59)) = *((int*) (ss - 59));\n            /* no break */\n        case 55: *((int*) (dd - 55)) = *((int*) (ss - 55));\n            /* no break */\n        case 51: *((int*) (dd - 51)) = *((int*) (ss - 51));\n            /* no break */\n        case 47: *((int*) (dd - 47)) = *((int*) (ss - 47));\n            /* no break */\n        case 43: *((int*) (dd - 43)) = *((int*) (ss - 43));\n            /* no break */\n        case 39: *((int*) (dd - 39)) = *((int*) (ss - 39));\n            /* no break */\n        case 35: *((int*) (dd - 35)) = *((int*) (ss - 35));\n            /* no break */\n        case 31: *((int*) (dd - 31)) = *((int*) (ss - 31));\n            /* no break */\n        case 27: *((int*) (dd - 27)) = *((int*) (ss - 27));\n            /* no break */\n        case 23: *((int*) (dd - 23)) = *((int*) (ss - 23));\n            /* no break */\n        case 19: *((int*) (dd - 19)) = *((int*) (ss - 19));\n            /* no break */\n        case 15: *((int*) (dd - 15)) = *((int*) (ss - 15));\n            /* no break */\n        case 11: *((int*) (dd - 11)) = *((int*) (ss - 11));\n            /* no break */\n        case 7: *((int*) (dd - 7)) = *((int*) (ss - 7));\n            *((int*) (dd - 4)) = *((int*) (ss - 4));\n            break;\n        case 3: *((short*) (dd - 3)) = *((short*) (ss - 3));\n            dd[-1] = ss[-1];\n            break;\n        case 66: *((int*) (dd - 66)) = *((int*) (ss - 66));\n            /* no break */\n        case 62: *((int*) (dd - 62)) = *((int*) (ss - 62));\n            /* no break */\n        case 58: *((int*) (dd - 58)) = *((int*) (ss - 58));\n            /* no break */\n        case 54: *((int*) (dd - 54)) = *((int*) (ss - 54));\n            /* no break */\n        case 50: *((int*) (dd - 50)) = *((int*) (ss - 50));\n            /* no break */\n        case 46: *((int*) (dd - 46)) = *((int*) (ss - 46));\n            /* no break */\n        case 42: *((int*) (dd - 42)) = *((int*) (ss - 42));\n            /* no break */\n        case 38: *((int*) (dd - 38)) = *((int*) (ss - 38));\n            /* no break */\n        case 34: *((int*) (dd - 34)) = *((int*) (ss - 34));\n            /* no break */\n        case 30: *((int*) (dd - 30)) = *((int*) (ss - 30));\n            /* no break */\n        case 26: *((int*) (dd - 26)) = *((int*) (ss - 26));\n            /* no break */\n        case 22: *((int*) (dd - 22)) = *((int*) (ss - 22));\n            /* no break */\n        case 18: *((int*) (dd - 18)) = *((int*) (ss - 18));\n            /* no break */\n        case 14: *((int*) (dd - 14)) = *((int*) (ss - 14));\n            /* no break */\n        case 10: *((int*) (dd - 10)) = *((int*) (ss - 10));\n            /* no break */\n        case 6: *((int*) (dd - 6)) = *((int*) (ss - 6));\n            /* no break */\n        case 2: *((short*) (dd - 2)) = *((short*) (ss - 2));\n            break;\n        case 65: *((int*) (dd - 65)) = *((int*) (ss - 65));\n            /* no break */\n        case 61: *((int*) (dd - 61)) = *((int*) (ss - 61));\n            /* no break */\n        case 57: *((int*) (dd - 57)) = *((int*) (ss - 57));\n            /* no break */\n        case 53: *((int*) (dd - 53)) = *((int*) (ss - 53));\n            /* no break */\n        case 49: *((int*) (dd - 49)) = *((int*) (ss - 49));\n            /* no break */\n        case 45: *((int*) (dd - 45)) = *((int*) (ss - 45));\n            /* no break */\n        case 41: *((int*) (dd - 41)) = *((int*) (ss - 41));\n            /* no break */\n        case 37: *((int*) (dd - 37)) = *((int*) (ss - 37));\n            /* no break */\n        case 33: *((int*) (dd - 33)) = *((int*) (ss - 33));\n            /* no break */\n        case 29: *((int*) (dd - 29)) = *((int*) (ss - 29));\n            /* no break */\n        case 25: *((int*) (dd - 25)) = *((int*) (ss - 25));\n            /* no break */\n        case 21: *((int*) (dd - 21)) = *((int*) (ss - 21));\n            /* no break */\n        case 17: *((int*) (dd - 17)) = *((int*) (ss - 17));\n            /* no break */\n        case 13: *((int*) (dd - 13)) = *((int*) (ss - 13));\n            /* no break */\n        case 9: *((int*) (dd - 9)) = *((int*) (ss - 9));\n            /* no break */\n        case 5: *((int*) (dd - 5)) = *((int*) (ss - 5));\n            /* no break */\n        case 1: dd[-1] = ss[-1];\n            break;\n        case 0:\n        default: break;\n    }\n}\n\nvoid CPINLINE swoole_memcpy_fast(void *destination, const void *source, size_t size)\n{\n    unsigned char *dst = (unsigned char*) destination;\n    const unsigned char *src = (const unsigned char*) source;\n\n    // small memory copy\n    if (size < 64)\n    {\n        swoole_mini_memcpy(dst, src, size);\n        return;\n    }\n\n    size_t diff = (((size_t) dst + 15L) & (~15L)) - ((size_t) dst);\n    if (diff > 0)\n    {\n        swoole_mini_memcpy(dst, src, diff);\n        dst += diff;\n        src += diff;\n        size -= diff;\n    }\n\n    // 4\u4e2a\u5bc4\u5b58\u5668\n    __m128i c1, c2, c3, c4;\n\n    if ((((size_t) src) & 15L) == 0)\n    {\n        for(; size >= 64; size -= 64)\n        {\n            //load \u65f6\u5019\u5c06\u4e0b\u6b21\u8981\u7528\u7684\u6570\u636e\u63d0\u524dfetch\n            _mm_prefetch((const char*) (src + 64), _MM_HINT_NTA);\n            _mm_prefetch((const char*) (dst + 64), _MM_HINT_T0);\n            //\u4ece\u5185\u5b58\u4e2dload\u5230\u5bc4\u5b58\u5668\n            c1 = _mm_load_si128(((const __m128i*) src) + 0);\n            c2 = _mm_load_si128(((const __m128i*) src) + 1);\n            c3 = _mm_load_si128(((const __m128i*) src) + 2);\n            c4 = _mm_load_si128(((const __m128i*) src) + 3);\n            src += 64;\n            //\u5199\u56de\u5185\u5b58\n            _mm_store_si128((((__m128i*) dst) + 0), c1);\n            _mm_store_si128((((__m128i*) dst) + 1), c2);\n            _mm_store_si128((((__m128i*) dst) + 2), c3);\n            _mm_store_si128((((__m128i*) dst) + 3), c4);\n            dst += 64;\n        }\n    }\n    else\n    {\n        for(; size >= 64; size -= 64)\n        {\n            _mm_prefetch((const char*) (src + 64), _MM_HINT_NTA);\n            _mm_prefetch((const char*) (dst + 64), _MM_HINT_T0);\n            c1 = _mm_loadu_si128(((const __m128i*) src) + 0);\n            c2 = _mm_loadu_si128(((const __m128i*) src) + 1);\n            c3 = _mm_loadu_si128(((const __m128i*) src) + 2);\n            c4 = _mm_loadu_si128(((const __m128i*) src) + 3);\n            src += 64;\n            _mm_store_si128((((__m128i*) dst) + 0), c1);\n            _mm_store_si128((((__m128i*) dst) + 1), c2);\n            _mm_store_si128((((__m128i*) dst) + 2), c3);\n            _mm_store_si128((((__m128i*) dst) + 3), c4);\n            dst += 64;\n        }\n    }\n    // _mm_sfence();\n\n    // return memcpy_tiny(dst, src, size);\n}\n#endif\n\nstatic CPINLINE void swoole_string_cpy(seriaString *str, void *mem, size_t len)\n{\n    swoole_check_size(str, len + 15L);\n    //example:13+15=28   28& 11111111 11111111 11111111 11110000\n    //str->offset = ((str->offset + 15L) & ~15L);\n    //    swoole_memcspy_fast(str->buffer + str->offset, mem, len);\n    memcpy(str->buffer + str->offset, mem, len);\n    str->offset = len + str->offset;\n}\n\nstatic CPINLINE void swoole_set_zend_value(seriaString *str, void *value)\n{\n    swoole_check_size(str, sizeof (zend_value));\n    *(zend_value*) (str->buffer + str->offset) = *((zend_value*) value);\n    str->offset = sizeof (zend_value) + str->offset;\n}\n\nstatic CPINLINE void swoole_serialize_long(seriaString *buffer, zval *zvalue, SBucketType* type)\n{\n    zend_long value = Z_LVAL_P(zvalue);\n    //01111111 - 11111111\n    if (value <= 0x7f && value >= -0x7f)\n    {\n        type->data_len = 0;\n        SERIA_SET_ENTRY_TYPE_WITH_MINUS(buffer, value);\n    }\n    else if (value <= 0x7fff && value >= -0x7fff)\n    {\n        type->data_len = 1;\n        SERIA_SET_ENTRY_SHORT_WITH_MINUS(buffer, value);\n    }\n    else if (value <= 0x7fffffff && value >= -0x7fffffff)\n    {\n        type->data_len = 2;\n        SERIA_SET_ENTRY_SIZE4_WITH_MINUS(buffer, value);\n    }\n    else\n    {\n        type->data_len = 3;\n        swoole_string_cpy(buffer, &zvalue->value, sizeof (zend_value));\n    }\n\n}\n\nstatic CPINLINE void* swoole_unserialize_long(void *buffer, zval *ret_value, SBucketType type)\n{\n    if (type.data_len == 0)\n    {//1 byte\n        Z_LVAL_P(ret_value) = *((char*) buffer);\n        buffer += sizeof (char);\n    }\n    else if (type.data_len == 1)\n    {//2 byte\n        Z_LVAL_P(ret_value) = *((short*) buffer);\n        buffer += sizeof (short);\n    }\n    else if (type.data_len == 2)\n    {//4 byte\n        Z_LVAL_P(ret_value) = *((int32_t *) buffer);\n        buffer += sizeof (int32_t);\n    }\n    else\n    {//8 byte\n        ret_value->value = *((zend_value*) buffer);\n        buffer += sizeof (zend_value);\n    }\n    return buffer;\n}\n\nstatic uint32_t CPINLINE cp_zend_hash_check_size(uint32_t nSize)\n{\n#if defined(ZEND_WIN32)\n    unsigned long index;\n#endif\n\n    /* Use big enough power of 2 */\n    /* size should be between HT_MIN_SIZE and HT_MAX_SIZE */\n    if (nSize < HT_MIN_SIZE)\n    {\n        nSize = HT_MIN_SIZE;\n    }//    else if (UNEXPECTED(nSize >= 1000000))\n    else if (UNEXPECTED(nSize >= HT_MAX_SIZE))\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"invalid unserialize data\");\n        return 0;\n    }\n\n#if defined(ZEND_WIN32)\n    if (BitScanReverse(&index, nSize - 1))\n    {\n        return 0x2 << ((31 - index) ^ 0x1f);\n    }\n    else\n    {\n        /* nSize is ensured to be in the valid range, fall back to it\n           rather than using an undefined bis scan result. */\n        return nSize;\n    }\n#elif (defined(__GNUC__) || __has_builtin(__builtin_clz))  && defined(PHP_HAVE_BUILTIN_CLZ)\n    return 0x2 << (__builtin_clz(nSize - 1) ^ 0x1f);\n#else\n    nSize -= 1;\n    nSize |= (nSize >> 1);\n    nSize |= (nSize >> 2);\n    nSize |= (nSize >> 4);\n    nSize |= (nSize >> 8);\n    nSize |= (nSize >> 16);\n    return nSize + 1;\n#endif\n}\n\nstatic CPINLINE void swoole_mini_filter_clear()\n{\n    if (swSeriaG.pack_string)\n    {\n        memset(&mini_filter, 0, sizeof (mini_filter));\n        if (bigger_filter)\n        {\n            efree(bigger_filter);\n            bigger_filter = NULL;\n\n        }\n        memset(&swSeriaG.filter, 0, sizeof (struct _swMinFilter));\n    }\n}\n\nstatic CPINLINE void swoole_make_bigger_filter_size()\n{\n    if (FILTER_SIZE <= swSeriaG.filter.mini_fillter_miss_cnt &&\n            swSeriaG.filter.mini_fillter_find_cnt < swSeriaG.filter.mini_fillter_miss_cnt)\n        //        if (FILTER_SIZE <= swSeriaG.filter.mini_fillter_miss_cnt &&\n        //                (swSeriaG.filter.mini_fillter_find_cnt / swSeriaG.filter.mini_fillter_miss_cnt) < 1)\n    {\n        swSeriaG.filter.bigger_fillter_size = swSeriaG.filter.mini_fillter_miss_cnt * 128;\n        bigger_filter = (swPoolstr*) ecalloc(1, sizeof (swPoolstr) * swSeriaG.filter.bigger_fillter_size);\n        memcpy(bigger_filter, &mini_filter, sizeof (mini_filter));\n    }\n}\n\nstatic CPINLINE void swoole_mini_filter_add(zend_string *zstr, size_t offset, zend_uchar byte)\n{\n    if (swSeriaG.pack_string)\n    {\n        offset -= _STR_HEADER_SIZE;\n        //head 3bit is overhead\n        if (offset >= 0x1fffffff)\n        {\n            return;\n        }\n        if (bigger_filter)\n        {\n            uint32_t mod_big = zstr->h & (swSeriaG.filter.bigger_fillter_size - 1);\n\n            bigger_filter[mod_big].offset = offset << 3;\n            if (offset <= 0x1fff)\n            {\n                bigger_filter[mod_big].offset |= byte;\n            }\n            else\n            {\n                bigger_filter[mod_big].offset |= (byte | 4);\n            }\n            bigger_filter[mod_big].str = zstr;\n        }\n        else\n        {\n            uint16_t mod = zstr->h & (FILTER_SIZE - 1);\n            //repalce it is effective,cause the principle of locality\n            mini_filter[mod].offset = offset << 3;\n            if (offset <= 0x1fff)\n            {\n                mini_filter[mod].offset |= byte;\n            }\n            else\n            {\n                mini_filter[mod].offset |= (byte | 4);\n            }\n            mini_filter[mod].str = zstr;\n            swSeriaG.filter.mini_fillter_miss_cnt++;\n            swoole_make_bigger_filter_size();\n        }\n    }\n\n}\n\nstatic CPINLINE swPoolstr* swoole_mini_filter_find(zend_string *zstr)\n{\n    if (swSeriaG.pack_string)\n    {\n        zend_ulong h = zend_string_hash_val(zstr);\n        swPoolstr* str = NULL;\n        if (bigger_filter)\n        {\n            str = &bigger_filter[h & (swSeriaG.filter.bigger_fillter_size - 1)];\n        }\n        else\n        {\n            str = &mini_filter[h & (FILTER_SIZE - 1)];\n        }\n\n        if (!str->str)\n        {\n            return NULL;\n        }\n\n        if (str->str->h == h &&\n                zstr->len == str->str->len &&\n                memcmp(zstr->val, str->str->val, zstr->len) == 0)\n        {\n            swSeriaG.filter.mini_fillter_find_cnt++;\n            return str;\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n/*\n * arr layout\n * type|key?|bucketlen|buckets\n */\nstatic CPINLINE void seria_array_type(zend_array *ht, seriaString *buffer, size_t type_offset, size_t blen_offset)\n{\n    buffer->offset = blen_offset;\n    if (ht->nNumOfElements <= 0xff)\n    {\n        ((SBucketType*) (buffer->buffer + type_offset))->data_len = 1;\n        SERIA_SET_ENTRY_TYPE(buffer, ht->nNumOfElements)\n    }\n    else if (ht->nNumOfElements <= 0xffff)\n    {\n        ((SBucketType*) (buffer->buffer + type_offset))->data_len = 2;\n        SERIA_SET_ENTRY_SHORT(buffer, ht->nNumOfElements);\n    }\n    else\n    {\n        ((SBucketType*) (buffer->buffer + type_offset))->data_len = 0;\n        swoole_string_cpy(buffer, &ht->nNumOfElements, sizeof (uint32_t));\n    }\n}\n\n/*\n * buffer is bucket len addr\n */\nstatic CPINLINE void* get_array_real_len(void *buffer, zend_uchar data_len, uint32_t *nNumOfElements)\n{\n    if (data_len == 1)\n    {\n        *nNumOfElements = *((zend_uchar*) buffer);\n        return buffer + sizeof (zend_uchar);\n    }\n    else if (data_len == 2)\n    {\n        *nNumOfElements = *((unsigned short*) buffer);\n        return buffer + sizeof (short);\n    }\n    else\n    {\n        *nNumOfElements = *((uint32_t*) buffer);\n        return buffer + sizeof (uint32_t);\n    }\n}\n\nstatic CPINLINE void * get_pack_string_len_addr(void ** buffer, size_t *strlen)\n{\n\n    uint8_t overhead = (*(uint8_t*) * buffer);\n    uint32_t real_offset;\n    uint8_t len_byte;\n\n    if (overhead & 4)\n    {\n        real_offset = (*(uint32_t*) * buffer) >> 3;\n        len_byte = overhead & 3;\n        (*buffer) += 4;\n    }\n    else\n    {\n        real_offset = (*(uint16_t*) * buffer) >> 3;\n        len_byte = overhead & 3;\n        (*buffer) += 2;\n    }\n    void *str_pool_addr = unser_start + real_offset;\n    if (len_byte == 1)\n    {\n        *strlen = *((zend_uchar*) str_pool_addr);\n        str_pool_addr = str_pool_addr + sizeof (zend_uchar);\n    }\n    else if (len_byte == 2)\n    {\n        *strlen = *((unsigned short*) str_pool_addr);\n        str_pool_addr = str_pool_addr + sizeof (unsigned short);\n    }\n    else\n    {\n        *strlen = *((size_t*) str_pool_addr);\n        str_pool_addr = str_pool_addr + sizeof (size_t);\n    }\n    //    size_t tmp = *strlen;\n    return str_pool_addr;\n}\n\n/*\n * array\n */\n\nstatic void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfElements, long flag)\n{\n    //Initialize zend array\n    zend_ulong h, nIndex, max_index = 0;\n    uint32_t size = cp_zend_hash_check_size(nNumOfElements);\n    CHECK_STEP;\n    if (!size)\n    {\n        return NULL;\n    }\n    if (!buffer)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    ZVAL_NEW_ARR(zvalue);\n    //Initialize buckets\n    zend_array *ht = Z_ARR_P(zvalue);\n    ht->nTableSize = size;\n    ht->nNumUsed = nNumOfElements;\n    ht->nNumOfElements = nNumOfElements;\n    ht->nNextFreeElement = 0;\n#ifdef HASH_FLAG_APPLY_PROTECTION\n    ht->u.flags = HASH_FLAG_APPLY_PROTECTION;\n#endif\n    ht->nTableMask = -(ht->nTableSize);\n    ht->pDestructor = ZVAL_PTR_DTOR;\n\n    GC_SET_REFCOUNT(ht, 1);\n    GC_TYPE_INFO(ht) = IS_ARRAY;\n    // if (ht->nNumUsed)\n    //{\n    //    void *arData = ecalloc(1, len);\n    HT_SET_DATA_ADDR(ht, emalloc(HT_SIZE(ht)));\n    ht->u.flags |= HASH_FLAG_INITIALIZED;\n    int ht_hash_size = HT_HASH_SIZE((ht)->nTableMask);\n    if (ht_hash_size <= 0)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    HT_HASH_RESET(ht);\n    //}\n\n\n    int idx;\n    Bucket *p;\n    for(idx = 0; idx < nNumOfElements; idx++)\n    {\n        if (!buffer)\n        {\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal array unserialize data\");\n            return NULL;\n        }\n        SBucketType type = *((SBucketType*) buffer);\n        buffer += sizeof (SBucketType);\n        p = ht->arData + idx;\n        /* Initialize key */\n        if (type.key_type == KEY_TYPE_STRING)\n        {\n            size_t key_len;\n            if (type.key_len == 3)\n            {//read the same mem\n                void *str_pool_addr = get_pack_string_len_addr(&buffer, &key_len);\n                p->key = zend_string_init((char*) str_pool_addr, key_len, 0);\n                h = zend_inline_hash_func((char*) str_pool_addr, key_len);\n                p->key->h = p->h = h;\n            }\n            else\n            {//move step\n                if (type.key_len == 1)\n                {\n                    key_len = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.key_len == 2)\n                {\n                    key_len = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    key_len = *((size_t*) buffer);\n                    buffer += sizeof (size_t);\n                }\n                CHECK_STEP;\n                p->key = zend_string_init((char*) buffer, key_len, 0);\n                //           h = zend_inline_hash_func((char*) buffer, key_len);\n                h = zend_inline_hash_func((char*) buffer, key_len);\n                buffer += key_len;\n                p->key->h = p->h = h;\n            }\n        }\n        else\n        {\n            if (type.key_len == 0)\n            {\n                //means pack\n                h = p->h = idx;\n                p->key = NULL;\n                max_index = p->h + 1;\n                //                ht->u.flags |= HASH_FLAG_PACKED;\n            }\n            else\n            {\n                if (type.key_len == 1)\n                {\n                    h = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.key_len == 2)\n                {\n                    h = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    h = *((zend_ulong*) buffer);\n                    buffer += sizeof (zend_ulong);\n                }\n                p->h = h;\n                p->key = NULL;\n                if (h >= max_index)\n                {\n                    max_index = h + 1;\n                }\n            }\n        }\n        /* Initialize hash */\n        nIndex = h | ht->nTableMask;\n        Z_NEXT(p->val) = HT_HASH(ht, nIndex);\n        HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\n        /* Initialize data type */\n        p->val.u1.v.type = type.data_type;\n        Z_TYPE_FLAGS(p->val) = 0;\n\n        /* Initialize data */\n        if (type.data_type == IS_STRING)\n        {\n            size_t data_len;\n            if (type.data_len == 3)\n            {//read the same mem\n                void *str_pool_addr = get_pack_string_len_addr(&buffer, &data_len);\n                p->val.value.str = zend_string_init((char*) str_pool_addr, data_len, 0);\n            }\n            else\n            {\n                if (type.data_len == 1)\n                {\n                    data_len = *((zend_uchar*) buffer);\n                    buffer += sizeof (zend_uchar);\n                }\n                else if (type.data_len == 2)\n                {\n                    data_len = *((unsigned short*) buffer);\n                    buffer += sizeof (unsigned short);\n                }\n                else\n                {\n                    data_len = *((size_t*) buffer);\n                    buffer += sizeof (size_t);\n                }\n                CHECK_STEP;\n                p->val.value.str = zend_string_init((char*) buffer, data_len, 0);\n                buffer += data_len;\n            }\n            Z_TYPE_INFO(p->val) = IS_STRING_EX;\n        }\n        else if (type.data_type == IS_ARRAY)\n        {\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            buffer = swoole_unserialize_arr(buffer, &p->val, num, flag);\n        }\n        else if (type.data_type == IS_LONG)\n        {\n            buffer = swoole_unserialize_long(buffer, &p->val, type);\n        }\n        else if (type.data_type == IS_DOUBLE)\n        {\n            p->val.value = *((zend_value*) buffer);\n            buffer += sizeof (zend_value);\n        }\n        else if (type.data_type == IS_UNDEF)\n        {\n            buffer = swoole_unserialize_object(buffer, &p->val, type.data_len, NULL, flag);\n            Z_TYPE_INFO(p->val) = IS_OBJECT_EX;\n        }\n\n    }\n    ht->nNextFreeElement = max_index;\n    CHECK_STEP;\n\n    return buffer;\n\n}\n\n/*\n * arr layout\n * type|key?|bucketlen|buckets\n */\nstatic void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue)\n{\n    zval *data;\n    zend_string *key;\n    zend_ulong index;\n    swPoolstr *swStr = NULL;\n    zend_uchar is_pack = zvalue->u.flags & HASH_FLAG_PACKED;\n\n    ZEND_HASH_FOREACH_KEY_VAL(zvalue, index, key, data)\n    {\n        SBucketType type = {0};\n        type.data_type = Z_TYPE_P(data);\n        //start point\n        size_t p = buffer->offset;\n\n        if (is_pack && zvalue->nNextFreeElement == zvalue->nNumOfElements)\n        {\n            type.key_type = KEY_TYPE_INDEX;\n            type.key_len = 0;\n            SERIA_SET_ENTRY_TYPE(buffer, type);\n        }\n        else\n        {\n            //seria key\n            if (key)\n            {\n                type.key_type = KEY_TYPE_STRING;\n                if ((swStr = swoole_mini_filter_find(key)))\n                {\n                    type.key_len = 3; //means use same string\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    if (swStr->offset & 4)\n                    {\n                        SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);\n                    }\n                    else\n                    {\n                        SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);\n                    }\n                }\n                else\n                {\n                    if (key->len <= 0xff)\n                    {\n                        type.key_len = 1;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 1);\n                        SERIA_SET_ENTRY_TYPE(buffer, key->len);\n                        swoole_string_cpy(buffer, key->val, key->len);\n                    }\n                    else if (key->len <= 0xffff)\n                    {//if more than this  don't need optimize\n                        type.key_len = 2;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 2);\n                        SERIA_SET_ENTRY_SHORT(buffer, key->len);\n                        swoole_string_cpy(buffer, key->val, key->len);\n                    }\n                    else\n                    {\n                        type.key_len = 0;\n                        SERIA_SET_ENTRY_TYPE(buffer, type);\n                        swoole_mini_filter_add(key, buffer->offset, 3);\n                        swoole_string_cpy(buffer, key + XtOffsetOf(zend_string, len), sizeof (size_t) + key->len);\n                    }\n                }\n            }\n            else\n            {\n                type.key_type = KEY_TYPE_INDEX;\n                if (index <= 0xff)\n                {\n                    type.key_len = 1;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_TYPE(buffer, index);\n                }\n                else if (index <= 0xffff)\n                {\n                    type.key_len = 2;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_SHORT(buffer, index);\n                }\n                else\n                {\n                    type.key_len = 3;\n                    SERIA_SET_ENTRY_TYPE(buffer, type);\n                    SERIA_SET_ENTRY_ULONG(buffer, index);\n                }\n\n            }\n        }\n        //seria data\ntry_again:\n        switch (Z_TYPE_P(data))\n        {\n            case IS_STRING:\n            {\n                if ((swStr = swoole_mini_filter_find(Z_STR_P(data))))\n                {\n                    ((SBucketType*) (buffer->buffer + p))->data_len = 3; //means use same string\n                    if (swStr->offset & 4)\n                    {\n                        SERIA_SET_ENTRY_SIZE4(buffer, swStr->offset);\n                    }\n                    else\n                    {\n                        SERIA_SET_ENTRY_SHORT(buffer, swStr->offset);\n                    }\n                }\n                else\n                {\n                    if (Z_STRLEN_P(data) <= 0xff)\n                    {\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 1;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 1);\n                        SERIA_SET_ENTRY_TYPE(buffer, Z_STRLEN_P(data));\n                        swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));\n                    }\n                    else if (Z_STRLEN_P(data) <= 0xffff)\n                    {\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 2;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 2);\n                        SERIA_SET_ENTRY_SHORT(buffer, Z_STRLEN_P(data));\n                        swoole_string_cpy(buffer, Z_STRVAL_P(data), Z_STRLEN_P(data));\n                    }\n                    else\n                    {//if more than this  don't need optimize\n                        ((SBucketType*) (buffer->buffer + p))->data_len = 0;\n                        swoole_mini_filter_add(Z_STR_P(data), buffer->offset, 3);\n                        swoole_string_cpy(buffer, (char*) Z_STR_P(data) + XtOffsetOf(zend_string, len), sizeof (size_t) + Z_STRLEN_P(data));\n                    }\n                }\n                break;\n            }\n            case IS_LONG:\n            {\n                SBucketType* long_type = (SBucketType*) (buffer->buffer + p);\n                swoole_serialize_long(buffer, data, long_type);\n                break;\n            }\n            case IS_DOUBLE:\n                swoole_set_zend_value(buffer, &(data->value));\n                break;\n            case IS_REFERENCE:\n                data = Z_REFVAL_P(data);\n                ((SBucketType*) (buffer->buffer + p))->data_type = Z_TYPE_P(data);\n                goto try_again;\n                break;\n            case IS_ARRAY:\n            {\n                zend_array *ht = Z_ARRVAL_P(data);\n\n                if (GC_IS_RECURSIVE(ht))\n                {\n                    ((SBucketType*) (buffer->buffer + p))->data_type = IS_NULL; //reset type null\n                    php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the array has cycle ref\");\n                }\n                else\n                {\n                    seria_array_type(ht, buffer, p, buffer->offset);\n                    if (ZEND_HASH_APPLY_PROTECTION(ht))\n                    {\n                        GC_PROTECT_RECURSION(ht);\n                        swoole_serialize_arr(buffer, ht);\n                        GC_UNPROTECT_RECURSION(ht);\n                    }\n                    else\n                    {\n                        swoole_serialize_arr(buffer, ht);\n                    }\n\n                }\n                break;\n            }\n                //object propterty table is this type\n            case IS_INDIRECT:\n                data = Z_INDIRECT_P(data);\n                zend_uchar type = Z_TYPE_P(data);\n                ((SBucketType*) (buffer->buffer + p))->data_type = (type == IS_UNDEF ? IS_NULL : type);\n                goto try_again;\n                break;\n            case IS_OBJECT:\n            {\n                /*\n                 * layout\n                 * type | key | namelen | name | bucket len |buckets\n                 */\n                ((SBucketType*) (buffer->buffer + p))->data_type = IS_UNDEF;\n\n                if (ZEND_HASH_APPLY_PROTECTION(Z_OBJPROP_P(data)))\n                {\n                    GC_PROTECT_RECURSION(Z_OBJPROP_P(data));\n                    swoole_serialize_object(buffer, data, p);\n                    GC_UNPROTECT_RECURSION(Z_OBJPROP_P(data));\n                }\n                else\n                {\n                    swoole_serialize_object(buffer, data, p);\n                }\n\n                break;\n            }\n            default://\n                break;\n\n        }\n\n    }\n    ZEND_HASH_FOREACH_END();\n}\n\n/*\n * string\n */\nstatic CPINLINE void swoole_serialize_string(seriaString *buffer, zval *zvalue)\n{\n\n    swoole_string_cpy(buffer, Z_STRVAL_P(zvalue), Z_STRLEN_P(zvalue));\n}\n\nstatic CPINLINE zend_string* swoole_unserialize_string(void *buffer, size_t len)\n{\n\n    return zend_string_init(buffer, len, 0);\n}\n\n/*\n * raw\n */\nstatic CPINLINE void swoole_unserialize_raw(void *buffer, zval *zvalue)\n{\n\n    memcpy(&zvalue->value, buffer, sizeof (zend_value));\n}\n\n#if 0\n\n/*\n * null\n */\nstatic CPINLINE void swoole_unserialize_null(void *buffer, zval *zvalue)\n{\n\n    memcpy(&zvalue->value, buffer, sizeof (zend_value));\n}\n#endif\n\nstatic CPINLINE void swoole_serialize_raw(seriaString *buffer, zval *zvalue)\n{\n\n    swoole_string_cpy(buffer, &zvalue->value, sizeof (zend_value));\n}\n\n/*\n * obj layout\n * type|bucket key|name len| name| buket len |buckets\n */\nstatic void swoole_serialize_object(seriaString *buffer, zval *obj, size_t start)\n{\n    zend_string *name = Z_OBJCE_P(obj)->name;\n    if (GC_IS_RECURSIVE(Z_OBJPROP_P(obj)))\n    {\n        zend_throw_exception_ex(NULL, 0, \"the object %s has cycle ref.\", name->val);\n        return;\n    }\n    if (name->len > 0xffff)\n    {//so long?\n        zend_throw_exception_ex(NULL, 0, \"the object name is too long.\");\n    }\n    else\n    {\n        SERIA_SET_ENTRY_SHORT(buffer, name->len);\n        swoole_string_cpy(buffer, name->val, name->len);\n    }\n\n    zend_class_entry *ce = Z_OBJ_P(obj)->ce;\n    if (ce && zend_hash_exists(&ce->function_table, Z_STR(swSeriaG.sleep_fname)))\n    {\n        zval retval;\n        if (call_user_function_ex(NULL, obj, &swSeriaG.sleep_fname, &retval, 0, 0, 1, NULL) == SUCCESS)\n        {\n            if (EG(exception))\n            {\n                zval_dtor(&retval);\n                return;\n            }\n            if (Z_TYPE(retval) == IS_ARRAY)\n            {\n                zend_string *prop_key;\n                zval *prop_value, *sleep_value;\n                const char *prop_name, *class_name;\n                size_t prop_key_len;\n                int got_num = 0;\n\n                //for the zero malloc\n                zend_array tmp_arr;\n                zend_array *ht = (zend_array *) & tmp_arr;\n#if PHP_VERSION_ID >= 70300\n                _zend_hash_init(ht, zend_hash_num_elements(Z_ARRVAL(retval)), ZVAL_PTR_DTOR, 0);\n#else\n                _zend_hash_init(ht, zend_hash_num_elements(Z_ARRVAL(retval)), ZVAL_PTR_DTOR, 0 ZEND_FILE_LINE_CC);\n#endif\n                ht->nTableMask = -(ht)->nTableSize;\n                ALLOCA_FLAG(use_heap);\n                void *ht_addr = do_alloca(HT_SIZE(ht), use_heap);\n                HT_SET_DATA_ADDR(ht, ht_addr);\n                ht->u.flags |= HASH_FLAG_INITIALIZED;\n                HT_HASH_RESET(ht);\n\n                //just clean property do not add null when does not exist\n                //we double for each, cause we do not malloc  and release it\n\n                ZEND_HASH_FOREACH_STR_KEY_VAL(Z_OBJPROP_P(obj), prop_key, prop_value)\n                {\n                    //get origin property name\n                    zend_unmangle_property_name_ex(prop_key, &class_name, &prop_name, &prop_key_len);\n\n                    ZEND_HASH_FOREACH_VAL(Z_ARRVAL(retval), sleep_value)\n                    {\n                        if (Z_TYPE_P(sleep_value) == IS_STRING &&\n                                Z_STRLEN_P(sleep_value) == prop_key_len &&\n                                memcmp(Z_STRVAL_P(sleep_value), prop_name, prop_key_len) == 0)\n                        {\n                            got_num++;\n                            //add mangle key,unmangle in unseria\n                            _zend_hash_add_or_update(ht, prop_key, prop_value, HASH_UPDATE ZEND_FILE_LINE_CC);\n\n                            break;\n                        }\n\n                    }\n                    ZEND_HASH_FOREACH_END();\n\n                }\n                ZEND_HASH_FOREACH_END();\n\n                //there some member not in property\n                if (zend_hash_num_elements(Z_ARRVAL(retval)) > got_num)\n                {\n                    php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"__sleep() retrun a member but does not exist in property\");\n\n                }\n                seria_array_type(ht, buffer, start, buffer->offset);\n                swoole_serialize_arr(buffer, ht);\n                ZSTR_ALLOCA_FREE(ht_addr, use_heap);\n                zval_dtor(&retval);\n                return;\n\n            }\n            else\n            {\n                php_error_docref(NULL TSRMLS_CC, E_NOTICE, \" __sleep should return an array only containing the \"\n                        \"names of instance-variables to serialize\");\n                zval_dtor(&retval);\n            }\n\n        }\n    }\n    seria_array_type(Z_OBJPROP_P(obj), buffer, start, buffer->offset);\n    swoole_serialize_arr(buffer, Z_OBJPROP_P(obj));\n    //    printf(\"hash2 %u\\n\",ce->properties_info.arData[0].key->h);\n}\n\n/*\n * for the zero malloc\n */\nstatic CPINLINE zend_string * swoole_string_init(const char *str, size_t len)\n{\n#ifdef ZEND_DEBUG\n    return zend_string_init(str, len, 0);\n#else\n    ALLOCA_FLAG(use_heap);\n    zend_string *ret;\n    ZSTR_ALLOCA_INIT(ret, str, len, use_heap);\n\n    return ret;\n#endif\n}\n\n/*\n * for the zero malloc\n */\nstatic CPINLINE void swoole_string_release(zend_string *str)\n{\n#ifdef ZEND_DEBUG\n    zend_string_release(str);\n#else\n    //if dont support alloc 0 will ignore\n    //if support alloc size is definitely < ZEND_ALLOCA_MAX_SIZE\n    ZSTR_ALLOCA_FREE(str, 0);\n#endif\n}\n\nstatic CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    //user class , do not support incomplete class now\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    // try call unserialize callback and retry lookup\n    zval user_func, args[1], retval;\n\n    /* Check for unserialize callback */\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n\n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n\n    swoole_string_release(fname);\n\n    //user class , do not support incomplete class now\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}\n\n/*\n * obj layout\n * type| key[0|1] |name len| name| buket len |buckets\n */\nstatic void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag)\n{\n    zval property;\n    uint32_t arr_num = 0;\n    size_t name_len = *((unsigned short*) buffer);\n    CHECK_STEP;\n    if (!name_len)\n    {\n        php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n        return NULL;\n    }\n    buffer += 2;\n    zend_string *class_name;\n    if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS)\n    {\n        class_name = swoole_string_init(ZEND_STRL(\"StdClass\"));\n    }\n    else\n    {\n        class_name = swoole_string_init((char*) buffer, name_len);\n    }\n    buffer += name_len;\n    zend_class_entry *ce = swoole_try_get_ce(class_name);\n    swoole_string_release(class_name);\n    CHECK_STEP;\n\n    if (!ce)\n    {\n        return NULL;\n    }\n\n    buffer = get_array_real_len(buffer, bucket_len, &arr_num);\n    buffer = swoole_unserialize_arr(buffer, &property, arr_num, flag);\n\n    object_init_ex(return_value, ce);\n\n    zval *data, *d;\n    zend_string *key;\n    zend_ulong index;\n\n    ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data)\n    {\n        const char *prop_name, *tmp;\n        size_t prop_len;\n        if (key)\n        {\n\n            if ((d = zend_hash_find(Z_OBJPROP_P(return_value), key)) != NULL)\n            {\n                if (Z_TYPE_P(d) == IS_INDIRECT)\n                {\n                    d = Z_INDIRECT_P(d);\n                }\n                zval_dtor(d);\n                ZVAL_COPY(d, data);\n            }\n            else\n            {\n                zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len);\n                zend_update_property(ce, return_value, prop_name, prop_len, data);\n            }\n            //            zend_hash_update(Z_OBJPROP_P(return_value),key,data);\n            //            zend_update_property(ce, return_value, ZSTR_VAL(key), ZSTR_LEN(key), data);\n        }\n        else\n        {\n            zend_hash_next_index_insert(Z_OBJPROP_P(return_value), data);\n        }\n    }\n    ZEND_HASH_FOREACH_END();\n    zval_dtor(&property);\n\n    if (ce->constructor)\n    {\n        //        zend_fcall_info fci = {0};\n        //        zend_fcall_info_cache fcc = {0};\n        //        fci.size = sizeof (zend_fcall_info);\n        //        zval retval;\n        //        ZVAL_UNDEF(&fci.function_name);\n        //        fci.retval = &retval;\n        //        fci.param_count = 0;\n        //        fci.params = NULL;\n        //        fci.no_separation = 1;\n        //        fci.object = Z_OBJ_P(return_value);\n        //\n        //        zend_fcall_info_args_ex(&fci, ce->constructor, args);\n        //\n        //        fcc.initialized = 1;\n        //        fcc.function_handler = ce->constructor;\n        //        //        fcc.calling_scope = EG(scope);\n        //        fcc.called_scope = Z_OBJCE_P(return_value);\n        //        fcc.object = Z_OBJ_P(return_value);\n        //\n        //        if (zend_call_function(&fci, &fcc) == FAILURE)\n        //        {\n        //            zend_throw_exception_ex(NULL, 0, \"could not call class constructor\");\n        //        }\n        //        zend_fcall_info_args_clear(&fci, 1);\n    }\n\n\n    //call object __wakeup\n    if (zend_hash_str_exists(&ce->function_table, ZEND_STRL(\"__wakeup\")))\n    {\n        zval ret, wakeup;\n        zend_string *fname = swoole_string_init(ZEND_STRL(\"__wakeup\"));\n        Z_STR(wakeup) = fname;\n        Z_TYPE_INFO(wakeup) = IS_STRING_EX;\n        call_user_function_ex(CG(function_table), return_value, &wakeup, &ret, 0, NULL, 1, NULL);\n        swoole_string_release(fname);\n        zval_ptr_dtor(&ret);\n    }\n    CHECK_STEP;\n    return buffer;\n\n}\n\n/*\n * dispatch\n */\n\nstatic CPINLINE void swoole_seria_dispatch(seriaString *buffer, zval *zvalue)\n{\nagain:\n    switch (Z_TYPE_P(zvalue))\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            break;\n        case IS_LONG:\n        {\n            SBucketType* type = (SBucketType*) (buffer->buffer + _STR_HEADER_SIZE);\n            swoole_serialize_long(buffer, zvalue, type);\n            break;\n        }\n        case IS_DOUBLE:\n            swoole_serialize_raw(buffer, zvalue);\n            break;\n        case IS_STRING:\n            swoole_serialize_string(buffer, zvalue);\n            break;\n        case IS_ARRAY:\n        {\n            seria_array_type(Z_ARRVAL_P(zvalue), buffer, _STR_HEADER_SIZE, _STR_HEADER_SIZE + 1);\n            swoole_serialize_arr(buffer, Z_ARRVAL_P(zvalue));\n            swoole_string_cpy(buffer, SWOOLE_SERI_EOF, 3);\n            swoole_mini_filter_clear();\n            break;\n        }\n        case IS_REFERENCE:\n            zvalue = Z_REFVAL_P(zvalue);\n            goto again;\n            break;\n        case IS_OBJECT:\n        {\n            SBucketType* type = (SBucketType*) (buffer->buffer + _STR_HEADER_SIZE);\n            type->data_type = IS_UNDEF;\n            swoole_serialize_object(buffer, zvalue, _STR_HEADER_SIZE);\n            swoole_string_cpy(buffer, SWOOLE_SERI_EOF, 3);\n            swoole_mini_filter_clear();\n            break;\n        }\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n\n            break;\n    }\n}\n\nPHPAPI zend_string* php_swoole_serialize(zval *zvalue)\n{\n\n    seriaString str;\n    swoole_string_new(SERIA_SIZE, &str, Z_TYPE_P(zvalue));\n    swoole_seria_dispatch(&str, zvalue); //serialize into a string\n    zend_string *z_str = (zend_string *) str.buffer;\n\n    z_str->len = str.offset - _STR_HEADER_SIZE;\n    z_str->val[z_str->len] = '\\0';\n    z_str->h = 0;\n    GC_SET_REFCOUNT(z_str, 1);\n    GC_TYPE_INFO(z_str) = IS_STRING_EX;\n\n    return z_str;\n}\n\nstatic CPINLINE int swoole_seria_check_eof(void *buffer, size_t len)\n{\n    void *eof_str = buffer - sizeof (SBucketType) + len - 3;\n    if (memcmp(eof_str, SWOOLE_SERI_EOF, 3) == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return -1;\n    }\n}\n\n/*\n * buffer is seria string buffer\n * len is string len\n * return_value is unseria bucket\n * args is for the object ctor (can be NULL)\n */\nPHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)\n{\n    SBucketType type = *(SBucketType*) (buffer);\n    zend_uchar real_type = type.data_type;\n    unseri_buffer_end = buffer + len;\n    buffer += sizeof (SBucketType);\n    switch (real_type)\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_LONG:\n            swoole_unserialize_long(buffer, return_value, type);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_DOUBLE:\n            swoole_unserialize_raw(buffer, return_value);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_STRING:\n            len -= sizeof (SBucketType);\n            zend_string *str = swoole_unserialize_string(buffer, len);\n            ZVAL_STR(return_value, str);\n            break;\n        case IS_ARRAY:\n        {\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            if (!swoole_unserialize_arr(buffer, return_value, num, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        }\n        case IS_UNDEF:\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n            return SW_FALSE;\n    }\n\n    return SW_TRUE;\n}\n\nstatic PHP_METHOD(swoole_serialize, pack)\n{\n    zval *zvalue;\n    zend_size_t is_fast = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|l\", &zvalue, &is_fast) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n    swSeriaG.pack_string = !is_fast;\n    zend_string *z_str = php_swoole_serialize(zvalue);\n\n    RETURN_STR(z_str);\n}\n\nstatic PHP_METHOD(swoole_serialize, unpack)\n{\n    char *buffer = NULL;\n    size_t arg_len;\n    zval *args = NULL; //for object\n    long flag = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|la\", &buffer, &arg_len, &flag, &args) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n    if (!php_swoole_unserialize(buffer, arg_len, return_value, args, flag))\n    {\n        RETURN_FALSE;\n    }\n}\n\n#endif\n"], "filenames": ["swoole_serialize.c"], "buggy_code_start_loc": [54], "buggy_code_end_loc": [1531], "fixing_code_start_loc": [55], "fixing_code_end_loc": [1541], "type": "CWE-502", "message": "The unpack implementation in Swoole version 4.0.4 lacks correct size checks in the deserialization process. An attacker can craft a serialized object to exploit this vulnerability and cause a SEGV.", "other": {"cve": {"id": "CVE-2018-15503", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-18T02:29:01.903", "lastModified": "2018-11-08T20:49:48.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The unpack implementation in Swoole version 4.0.4 lacks correct size checks in the deserialization process. An attacker can craft a serialized object to exploit this vulnerability and cause a SEGV."}, {"lang": "es", "value": "La implementaci\u00f3n de desempaquetado en la versi\u00f3n 4.0.4 de Swoole carece de controles de tama\u00f1o correctos en el proceso de deserializaci\u00f3n. Un atacante puede crear un objeto serializado para explotar esta vulnerabilidad y provocar un SEGV."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:swoole:swoole:4.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "93EF17F5-CCB3-4CB8-AFE3-706C531F3B1F"}]}]}], "references": [{"url": "https://github.com/swoole/swoole-src/commit/4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/swoole/swoole-src/issues/1882", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://x-c3ll.github.io/posts/swoole-deserialization-cve-2018-15503/", "source": "cve@mitre.org", "tags": ["Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/swoole/swoole-src/commit/4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76"}}