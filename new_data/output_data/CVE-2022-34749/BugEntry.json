{"buggy_code": ["import re\nfrom .scanner import ScannerParser\nfrom .util import PUNCTUATION, ESCAPE_TEXT, escape_url, unikey\n\nHTML_TAGNAME = r'[A-Za-z][A-Za-z0-9-]*'\nHTML_ATTRIBUTES = (\n    r'(?:\\s+[A-Za-z_:][A-Za-z0-9_.:-]*'\n    r'(?:\\s*=\\s*(?:[^ \"\\'=<>`]+|\\'[^\\']*?\\'|\"[^\\\"]*?\"))?)*'\n)\nESCAPE_CHAR = re.compile(r'\\\\([' + PUNCTUATION + r'])')\nLINK_TEXT = r'(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?'\nLINK_LABEL = r'(?:[^\\\\\\[\\]]|' + ESCAPE_TEXT + r'){0,1000}'\n\n\nclass InlineParser(ScannerParser):\n    ESCAPE = ESCAPE_TEXT\n\n    #: link or email syntax::\n    #:\n    #: <https://example.com>\n    AUTO_LINK = (\n        r'(?<!\\\\)(?:\\\\\\\\)*<([A-Za-z][A-Za-z0-9+.-]{1,31}:'\n        r\"[^ <>]*?|[A-Za-z0-9.!#$%&'*+/=?^_`{|}~-]+@[A-Za-z0-9]\"\n        r'(?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?'\n        r'(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*)>'\n    )\n\n    #: link or image syntax::\n    #:\n    #: [text](/link \"title\")\n    #: ![alt](/src \"title\")\n    STD_LINK = (\n        r'!?\\[(' + LINK_TEXT + r')\\]\\(\\s*'\n\n        r'(<(?:\\\\[<>]?|[^\\s<>\\\\])*>|'\n        r'(?:\\\\[()]?|\\([^\\s\\x00-\\x1f\\\\]*\\)|[^\\s\\x00-\\x1f()\\\\])*?)'\n\n        r'(?:\\s+('\n        r'''\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)'''\n        r'))?\\s*\\)'\n    )\n\n    #: Get link from references. References are defined in DEF_LINK in blocks.\n    #: The syntax looks like::\n    #:\n    #:    [an example][id]\n    #:\n    #:    [id]: https://example.com \"optional title\"\n    REF_LINK = (\n        r'!?\\[(' + LINK_TEXT + r')\\]'\n        r'\\[(' + LINK_LABEL + r')\\]'\n    )\n\n    #: Simple form of reference link::\n    #:\n    #:    [an example]\n    #:\n    #:    [an example]: https://example.com \"optional title\"\n    REF_LINK2 = r'!?\\[(' + LINK_LABEL + r')\\]'\n\n    #: emphasis and strong * or _::\n    #:\n    #:    *emphasis*  **strong**\n    #:    _emphasis_  __strong__\n    ASTERISK_EMPHASIS = (\n        r'(\\*{1,2})(?=[^\\s*])('\n        r'(?:\\\\[\\\\*]|[^*])*'\n        r'(?:' + ESCAPE_TEXT + r'|[^\\s*]))\\1'\n    )\n    UNDERSCORE_EMPHASIS = (\n        r'\\b(_{1,2})(?=[^\\s_])([\\s\\S]*?'\n        r'(?:' + ESCAPE_TEXT + r'|[^\\s_]))\\1'\n        r'(?!_|[^\\s' + PUNCTUATION + r'])\\b'\n    )\n\n    #: codespan with `::\n    #:\n    #:    `code`\n    CODESPAN = (\n        r'(?<!\\\\|`)(?:\\\\\\\\)*(`+)(?!`)([\\s\\S]+?)(?<!`)\\1(?!`)'\n    )\n\n    #: linebreak leaves two spaces at the end of line\n    LINEBREAK = r'(?:\\\\| {2,})\\n(?!\\s*$)'\n\n    INLINE_HTML = (\n        r'(?<!\\\\)<' + HTML_TAGNAME + HTML_ATTRIBUTES + r'\\s*/?>|'  # open tag\n        r'(?<!\\\\)</' + HTML_TAGNAME + r'\\s*>|'  # close tag\n        r'(?<!\\\\)<!--(?!>|->)(?:(?!--)[\\s\\S])+?(?<!-)-->|'  # comment\n        r'(?<!\\\\)<\\?[\\s\\S]+?\\?>|'\n        r'(?<!\\\\)<![A-Z][\\s\\S]+?>|'  # doctype\n        r'(?<!\\\\)<!\\[CDATA[\\s\\S]+?\\]\\]>'  # cdata\n    )\n\n    RULE_NAMES = (\n        'escape', 'inline_html', 'auto_link',\n        'std_link', 'ref_link', 'ref_link2',\n        'asterisk_emphasis', 'underscore_emphasis',\n        'codespan', 'linebreak',\n    )\n\n    def __init__(self, renderer, hard_wrap=False):\n        super(InlineParser, self).__init__()\n        if hard_wrap:\n            #: every new line becomes <br>\n            self.LINEBREAK = r' *\\n(?!\\s*$)'\n        self.renderer = renderer\n        rules = list(self.RULE_NAMES)\n        rules.remove('ref_link')\n        rules.remove('ref_link2')\n        self.ref_link_rules = rules\n\n    def parse_escape(self, m, state):\n        text = m.group(0)[1:]\n        return 'text', text\n\n    def parse_auto_link(self, m, state):\n        if state.get('_in_link'):\n            return 'text', m.group(0)\n\n        text = m.group(1)\n        schemes = ('mailto:', 'http://', 'https://')\n        if '@' in text and not text.lower().startswith(schemes):\n            link = 'mailto:' + text\n        else:\n            link = text\n        return 'link', escape_url(link), text\n\n    def parse_std_link(self, m, state):\n        line = m.group(0)\n        text = m.group(1)\n        link = ESCAPE_CHAR.sub(r'\\1', m.group(2))\n        if link.startswith('<') and link.endswith('>'):\n            link = link[1:-1]\n\n        title = m.group(3)\n        if title:\n            title = ESCAPE_CHAR.sub(r'\\1', title[1:-1])\n\n        if line[0] == '!':\n            return 'image', escape_url(link), text, title\n\n        return self.tokenize_link(line, link, text, title, state)\n\n    def parse_ref_link(self, m, state):\n        line = m.group(0)\n        text = m.group(1)\n        key = unikey(m.group(2) or text)\n        def_links = state.get('def_links')\n        if not def_links or key not in def_links:\n            return list(self._scan(line, state, self.ref_link_rules))\n\n        link, title = def_links.get(key)\n        link = ESCAPE_CHAR.sub(r'\\1', link)\n        if title:\n            title = ESCAPE_CHAR.sub(r'\\1', title)\n\n        if line[0] == '!':\n            return 'image', escape_url(link), text, title\n\n        return self.tokenize_link(line, link, text, title, state)\n\n    def parse_ref_link2(self, m, state):\n        return self.parse_ref_link(m, state)\n\n    def tokenize_link(self, line, link, text, title, state):\n        if state.get('_in_link'):\n            return 'text', line\n        state['_in_link'] = True\n        text = self.render(text, state)\n        state['_in_link'] = False\n        return 'link', escape_url(link), text, title\n\n    def parse_asterisk_emphasis(self, m, state):\n        return self.tokenize_emphasis(m, state)\n\n    def parse_underscore_emphasis(self, m, state):\n        return self.tokenize_emphasis(m, state)\n\n    def tokenize_emphasis(self, m, state):\n        marker = m.group(1)\n        text = m.group(2)\n        if len(marker) == 1:\n            return 'emphasis', self.render(text, state)\n        return 'strong', self.render(text, state)\n\n    def parse_codespan(self, m, state):\n        code = re.sub(r'[ \\n]+', ' ', m.group(2).strip())\n        return 'codespan', code\n\n    def parse_linebreak(self, m, state):\n        return 'linebreak',\n\n    def parse_inline_html(self, m, state):\n        html = m.group(0)\n        return 'inline_html', html\n\n    def parse_text(self, text, state):\n        return 'text', text\n\n    def parse(self, s, state, rules=None):\n        if rules is None:\n            rules = self.rules\n\n        tokens = (\n            self.renderer._get_method(t[0])(*t[1:])\n            for t in self._scan(s, state, rules)\n        )\n        return tokens\n\n    def render(self, s, state, rules=None):\n        tokens = self.parse(s, state, rules)\n        return self.renderer.finalize(tokens)\n\n    def __call__(self, s, state):\n        return self.render(s, state)\n", "# Links\n\n```````````````````````````````` example\n[**foo**]\n.\n<p>[<strong>foo</strong>]</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[link [foo [bar]]](/uri)\n.\n<p>[link [foo [bar]]](/uri)</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[link *foo **bar** `#`*](/uri)\n.\n<p><a href=\"/uri\">link *foo <strong>bar</strong> <code>#</code>*</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo [bar](/uri)](/uri)\n.\n<p><a href=\"/uri\">foo [bar](/uri)</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n*[foo*](/uri)\n.\n<p><em>[foo</em>](/uri)</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo <bar attr=\"](baz)\">\n.\n<p><a href=\"baz\">foo &lt;bar attr=&quot;</a>&quot;&gt;</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo`](/uri)`\n.\n<p>[foo`](/uri)`</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo<http://example.com/?search=](uri)>\n.\n<p><a href=\"uri\">foo&lt;http://example.com/?search=</a>&gt;</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[link *foo **bar** `#`*][ref]\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">link *foo <strong>bar</strong> <code>#</code>*</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo [bar](/uri)][ref]\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">foo [bar](/uri)</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n*[foo*][ref]\n\n[ref]: /uri\n.\n<p><em>[foo</em>]<a href=\"/uri\">ref</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo *bar][ref]\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">foo *bar</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo <bar attr=\"][ref]\">\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">foo &lt;bar attr=&quot;</a>&quot;&gt;</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo<http://example.com/?search=][ref]>\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">foo&lt;http://example.com/?search=</a>&gt;</p>\n````````````````````````````````\n\n```````````````````````````````` example\n**[hello](/)**\n.\n<p><strong><a href=\"/\">hello</a></strong></p>\n````````````````````````````````\n\nLinks can't contain links.\n\n```````````````````````````````` example\n[<https://example.com>](/foo)\n.\n<p><a href=\"/foo\">&lt;https://example.com&gt;</a></p>\n````````````````````````````````\n\nHarmful link protection:\n\n```````````````````````````````` example\n<javascript:alert(0)>\n.\n<p><a href=\"#harmful-link\">javascript:alert(0)</a></p>\n````````````````````````````````\n\n## Lists\n\n```````````````````````````````` example\n- foo\n  - baz\n- baz\n.\n<ul>\n<li>foo<ul>\n<li>baz</li>\n</ul>\n</li>\n<li>baz</li>\n</ul>\n````````````````````````````````\n\n```````````````````````````````` example\n- a\n  - b\n    - c\n      - d\n        - e\n          - f\n            - g\n.\n<ul>\n<li>a<ul>\n<li>b<ul>\n<li>c<ul>\n<li>d<ul>\n<li>e<ul>\n<li>f\n- g</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n````````````````````````````````\n\n\n```````````````````````````````` example\n* test\n    ```\n    print()\n    ```\n.\n<ul>\n<li>test<pre><code>print()\n</code></pre>\n</li>\n</ul>\n````````````````````````````````\n"], "fixing_code": ["import re\nfrom .scanner import ScannerParser\nfrom .util import PUNCTUATION, ESCAPE_TEXT, escape_url, unikey\n\nHTML_TAGNAME = r'[A-Za-z][A-Za-z0-9-]*'\nHTML_ATTRIBUTES = (\n    r'(?:\\s+[A-Za-z_:][A-Za-z0-9_.:-]*'\n    r'(?:\\s*=\\s*(?:[^ \"\\'=<>`]+|\\'[^\\']*?\\'|\"[^\\\"]*?\"))?)*'\n)\nESCAPE_CHAR = re.compile(r'\\\\([' + PUNCTUATION + r'])')\nLINK_TEXT = r'(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?'\nLINK_LABEL = r'(?:[^\\\\\\[\\]]|' + ESCAPE_TEXT + r'){0,1000}'\n\n\nclass InlineParser(ScannerParser):\n    ESCAPE = ESCAPE_TEXT\n\n    #: link or email syntax::\n    #:\n    #: <https://example.com>\n    AUTO_LINK = (\n        r'(?<!\\\\)(?:\\\\\\\\)*<([A-Za-z][A-Za-z0-9+.-]{1,31}:'\n        r\"[^ <>]*?|[A-Za-z0-9.!#$%&'*+/=?^_`{|}~-]+@[A-Za-z0-9]\"\n        r'(?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?'\n        r'(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*)>'\n    )\n\n    #: link or image syntax::\n    #:\n    #: [text](/link \"title\")\n    #: ![alt](/src \"title\")\n    STD_LINK = (\n        r'!?\\[(' + LINK_TEXT + r')\\]\\(\\s*'\n\n        r'(<(?:\\\\[<>]?|[^\\s<>\\\\])*>|'\n        r'(?:\\\\[()]?|\\([^\\s\\x00-\\x1f\\\\]*\\)|[^\\s\\x00-\\x1f()\\\\])*?)'\n\n        r'(?:\\s+('\n        r'''\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)'''\n        r'))?\\s*\\)'\n    )\n\n    #: Get link from references. References are defined in DEF_LINK in blocks.\n    #: The syntax looks like::\n    #:\n    #:    [an example][id]\n    #:\n    #:    [id]: https://example.com \"optional title\"\n    REF_LINK = (\n        r'!?\\[(' + LINK_TEXT + r')\\]'\n        r'\\[(' + LINK_LABEL + r')\\]'\n    )\n\n    #: Simple form of reference link::\n    #:\n    #:    [an example]\n    #:\n    #:    [an example]: https://example.com \"optional title\"\n    REF_LINK2 = r'!?\\[(' + LINK_LABEL + r')\\]'\n\n    #: emphasis and strong * or _::\n    #:\n    #:    *emphasis*  **strong**\n    #:    _emphasis_  __strong__\n    ASTERISK_EMPHASIS = (\n        r'(\\*{1,2})(?=[^\\s*])('\n        r'(?:(?:(?<!\\\\)(?:\\\\\\\\)*\\*)|[^*])+'\n        r')(?<!\\\\)\\1'\n    )\n    UNDERSCORE_EMPHASIS = (\n        r'\\b(_{1,2})(?=[^\\s_])([\\s\\S]*?'\n        r'(?:' + ESCAPE_TEXT + r'|[^\\s_]))\\1'\n        r'(?!_|[^\\s' + PUNCTUATION + r'])\\b'\n    )\n\n    #: codespan with `::\n    #:\n    #:    `code`\n    CODESPAN = (\n        r'(?<!\\\\|`)(?:\\\\\\\\)*(`+)(?!`)([\\s\\S]+?)(?<!`)\\1(?!`)'\n    )\n\n    #: linebreak leaves two spaces at the end of line\n    LINEBREAK = r'(?:\\\\| {2,})\\n(?!\\s*$)'\n\n    INLINE_HTML = (\n        r'(?<!\\\\)<' + HTML_TAGNAME + HTML_ATTRIBUTES + r'\\s*/?>|'  # open tag\n        r'(?<!\\\\)</' + HTML_TAGNAME + r'\\s*>|'  # close tag\n        r'(?<!\\\\)<!--(?!>|->)(?:(?!--)[\\s\\S])+?(?<!-)-->|'  # comment\n        r'(?<!\\\\)<\\?[\\s\\S]+?\\?>|'\n        r'(?<!\\\\)<![A-Z][\\s\\S]+?>|'  # doctype\n        r'(?<!\\\\)<!\\[CDATA[\\s\\S]+?\\]\\]>'  # cdata\n    )\n\n    RULE_NAMES = (\n        'escape', 'inline_html', 'auto_link',\n        'std_link', 'ref_link', 'ref_link2',\n        'asterisk_emphasis', 'underscore_emphasis',\n        'codespan', 'linebreak',\n    )\n\n    def __init__(self, renderer, hard_wrap=False):\n        super(InlineParser, self).__init__()\n        if hard_wrap:\n            #: every new line becomes <br>\n            self.LINEBREAK = r' *\\n(?!\\s*$)'\n        self.renderer = renderer\n        rules = list(self.RULE_NAMES)\n        rules.remove('ref_link')\n        rules.remove('ref_link2')\n        self.ref_link_rules = rules\n\n    def parse_escape(self, m, state):\n        text = m.group(0)[1:]\n        return 'text', text\n\n    def parse_auto_link(self, m, state):\n        if state.get('_in_link'):\n            return 'text', m.group(0)\n\n        text = m.group(1)\n        schemes = ('mailto:', 'http://', 'https://')\n        if '@' in text and not text.lower().startswith(schemes):\n            link = 'mailto:' + text\n        else:\n            link = text\n        return 'link', escape_url(link), text\n\n    def parse_std_link(self, m, state):\n        line = m.group(0)\n        text = m.group(1)\n        link = ESCAPE_CHAR.sub(r'\\1', m.group(2))\n        if link.startswith('<') and link.endswith('>'):\n            link = link[1:-1]\n\n        title = m.group(3)\n        if title:\n            title = ESCAPE_CHAR.sub(r'\\1', title[1:-1])\n\n        if line[0] == '!':\n            return 'image', escape_url(link), text, title\n\n        return self.tokenize_link(line, link, text, title, state)\n\n    def parse_ref_link(self, m, state):\n        line = m.group(0)\n        text = m.group(1)\n        key = unikey(m.group(2) or text)\n        def_links = state.get('def_links')\n        if not def_links or key not in def_links:\n            return list(self._scan(line, state, self.ref_link_rules))\n\n        link, title = def_links.get(key)\n        link = ESCAPE_CHAR.sub(r'\\1', link)\n        if title:\n            title = ESCAPE_CHAR.sub(r'\\1', title)\n\n        if line[0] == '!':\n            return 'image', escape_url(link), text, title\n\n        return self.tokenize_link(line, link, text, title, state)\n\n    def parse_ref_link2(self, m, state):\n        return self.parse_ref_link(m, state)\n\n    def tokenize_link(self, line, link, text, title, state):\n        if state.get('_in_link'):\n            return 'text', line\n        state['_in_link'] = True\n        text = self.render(text, state)\n        state['_in_link'] = False\n        return 'link', escape_url(link), text, title\n\n    def parse_asterisk_emphasis(self, m, state):\n        return self.tokenize_emphasis(m, state)\n\n    def parse_underscore_emphasis(self, m, state):\n        return self.tokenize_emphasis(m, state)\n\n    def tokenize_emphasis(self, m, state):\n        marker = m.group(1)\n        text = m.group(2)\n        if len(marker) == 1:\n            return 'emphasis', self.render(text, state)\n        return 'strong', self.render(text, state)\n\n    def parse_codespan(self, m, state):\n        code = re.sub(r'[ \\n]+', ' ', m.group(2).strip())\n        return 'codespan', code\n\n    def parse_linebreak(self, m, state):\n        return 'linebreak',\n\n    def parse_inline_html(self, m, state):\n        html = m.group(0)\n        return 'inline_html', html\n\n    def parse_text(self, text, state):\n        return 'text', text\n\n    def parse(self, s, state, rules=None):\n        if rules is None:\n            rules = self.rules\n\n        tokens = (\n            self.renderer._get_method(t[0])(*t[1:])\n            for t in self._scan(s, state, rules)\n        )\n        return tokens\n\n    def render(self, s, state, rules=None):\n        tokens = self.parse(s, state, rules)\n        return self.renderer.finalize(tokens)\n\n    def __call__(self, s, state):\n        return self.render(s, state)\n", "# Links\n\n```````````````````````````````` example\n[**foo**]\n.\n<p>[<strong>foo</strong>]</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[link [foo [bar]]](/uri)\n.\n<p>[link [foo [bar]]](/uri)</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo [bar](/uri)](/uri)\n.\n<p><a href=\"/uri\">foo [bar](/uri)</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n*[foo*](/uri)\n.\n<p><em>[foo</em>](/uri)</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo <bar attr=\"](baz)\">\n.\n<p><a href=\"baz\">foo &lt;bar attr=&quot;</a>&quot;&gt;</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo`](/uri)`\n.\n<p>[foo`](/uri)`</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo<http://example.com/?search=](uri)>\n.\n<p><a href=\"uri\">foo&lt;http://example.com/?search=</a>&gt;</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo [bar](/uri)][ref]\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">foo [bar](/uri)</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n*[foo*][ref]\n\n[ref]: /uri\n.\n<p><em>[foo</em>]<a href=\"/uri\">ref</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo *bar][ref]\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">foo *bar</a></p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo <bar attr=\"][ref]\">\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">foo &lt;bar attr=&quot;</a>&quot;&gt;</p>\n````````````````````````````````\n\n```````````````````````````````` example\n[foo<http://example.com/?search=][ref]>\n\n[ref]: /uri\n.\n<p><a href=\"/uri\">foo&lt;http://example.com/?search=</a>&gt;</p>\n````````````````````````````````\n\n```````````````````````````````` example\n**[hello](/)**\n.\n<p><strong><a href=\"/\">hello</a></strong></p>\n````````````````````````````````\n\nLinks can't contain links.\n\n```````````````````````````````` example\n[<https://example.com>](/foo)\n.\n<p><a href=\"/foo\">&lt;https://example.com&gt;</a></p>\n````````````````````````````````\n\nHarmful link protection:\n\n```````````````````````````````` example\n<javascript:alert(0)>\n.\n<p><a href=\"#harmful-link\">javascript:alert(0)</a></p>\n````````````````````````````````\n\n## Lists\n\n```````````````````````````````` example\n- foo\n  - baz\n- baz\n.\n<ul>\n<li>foo<ul>\n<li>baz</li>\n</ul>\n</li>\n<li>baz</li>\n</ul>\n````````````````````````````````\n\n```````````````````````````````` example\n- a\n  - b\n    - c\n      - d\n        - e\n          - f\n            - g\n.\n<ul>\n<li>a<ul>\n<li>b<ul>\n<li>c<ul>\n<li>d<ul>\n<li>e<ul>\n<li>f\n- g</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n````````````````````````````````\n\n\n```````````````````````````````` example\n* test\n    ```\n    print()\n    ```\n.\n<ul>\n<li>test<pre><code>print()\n</code></pre>\n</li>\n</ul>\n````````````````````````````````\n"], "filenames": ["mistune/inline_parser.py", "tests/fixtures/non-commonmark.txt"], "buggy_code_start_loc": [67, 13], "buggy_code_end_loc": [69, 57], "fixing_code_start_loc": [67, 12], "fixing_code_end_loc": [69, 42], "type": "NVD-CWE-Other", "message": "In mistune through 2.0.2, support of inline markup is implemented by using regular expressions that can involve a high amount of backtracking on certain edge cases. This behavior is commonly named catastrophic backtracking.", "other": {"cve": {"id": "CVE-2022-34749", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-25T23:15:07.837", "lastModified": "2022-12-08T22:35:03.513", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In mistune through 2.0.2, support of inline markup is implemented by using regular expressions that can involve a high amount of backtracking on certain edge cases. This behavior is commonly named catastrophic backtracking."}, {"lang": "es", "value": "En mistune versiones hasta 2.0.2, la compatibilidad con el marcado en l\u00ednea es implementado mediante el uso de expresiones regulares que pueden implicar una gran cantidad de retroceso en determinados casos l\u00edmite. Este comportamiento es com\u00fanmente llamado backtracking catastr\u00f3fico."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mistune_project:mistune:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.2", "matchCriteriaId": "83D21671-1162-49C5-BCB6-EF4267DC2BE7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/lepture/mistune/commit/a6d43215132fe4f3d93f8d7e90ba83b16a0838b2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lepture/mistune/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TQHXITQ2DSBYOILKHXBSBB7PFBPZHF63/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lepture/mistune/commit/a6d43215132fe4f3d93f8d7e90ba83b16a0838b2"}}