{"buggy_code": ["/*\n * Asterisk -- An open source telephony toolkit.\n *\n * Copyright (C) 2013, Fairview 5 Engineering, LLC\n *\n * George Joseph <george.joseph@fairview5.com>\n * Jos\u00e9 Lopes <jose.lopes@nfon.com>\n * Naveen Albert <asterisk@phreaknet.org>\n *\n * See http://www.asterisk.org for more information about\n * the Asterisk project. Please do not directly contact\n * any of the maintainers of this project for assistance;\n * the project provides a web site, mailing lists and IRC\n * channels for your use.\n *\n * This program is free software, distributed under the terms of\n * the GNU General Public License Version 2. See the LICENSE file\n * at the top of the source tree.\n */\n\n/*** MODULEINFO\n\t<depend>pjproject</depend>\n\t<depend>res_pjsip</depend>\n\t<depend>res_pjsip_session</depend>\n\t<support_level>core</support_level>\n ***/\n\n#include \"asterisk.h\"\n\n#include <pjsip.h>\n#include <pjsip_ua.h>\n\n#include \"asterisk/res_pjsip.h\"\n#include \"asterisk/res_pjsip_session.h\"\n#include \"asterisk/channel.h\"\n#include \"asterisk/pbx.h\"\n#include \"asterisk/app.h\"\n#include \"asterisk/module.h\"\n#include \"asterisk/utils.h\"\n\n/*** DOCUMENTATION\n\t<function name=\"PJSIP_HEADER\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGets headers from an inbound PJSIP channel. Adds, updates or removes the\n\t\t\tspecified SIP header from an outbound PJSIP channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"action\" required=\"true\">\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"read\"><para>Returns instance <replaceable>number</replaceable>\n\t\t\t\t\tof header <replaceable>name</replaceable>. A <literal>*</literal>\n\t\t\t\t\tmay be appended to <replaceable>name</replaceable> to iterate over all \n\t\t\t\t\theaders <emphasis>beginning with</emphasis> <replaceable>name</replaceable>.\n\t\t\t\t\t</para></enum>\n\n\t\t\t\t\t<enum name=\"add\"><para>Adds a new header <replaceable>name</replaceable>\n\t\t\t\t\tto this session.</para></enum>\n\n\t\t\t\t\t<enum name=\"update\"><para>Updates instance <replaceable>number</replaceable>\n\t\t\t\t\tof header <replaceable>name</replaceable> to a new value.\n\t\t\t\t\tThe header must already exist.</para></enum>\n\n\t\t\t\t\t<enum name=\"remove\"><para>Removes all instances of previously added headers\n\t\t\t\t\twhose names match <replaceable>name</replaceable>. A <literal>*</literal>\n\t\t\t\t\tmay be appended to <replaceable>name</replaceable> to remove all headers\n\t\t\t\t\t<emphasis>beginning with</emphasis> <replaceable>name</replaceable>.\n\t\t\t\t\t<replaceable>name</replaceable> may be set to a single <literal>*</literal>\n\t\t\t\t\tto clear <emphasis>all</emphasis> previously added headers. In all cases,\n\t\t\t\t\tthe number of headers actually removed is returned.</para></enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\n\t\t\t<parameter name=\"name\" required=\"true\"><para>The name of the header.</para></parameter>\n\n\t\t\t<parameter name=\"number\" required=\"false\">\n\t\t\t\t<para>If there's more than 1 header with the same name, this specifies which header\n\t\t\t\tto read or update.  If not specified, defaults to <literal>1</literal> meaning\n\t\t\t\tthe first matching header.  Not valid for <literal>add</literal> or\n\t\t\t\t<literal>remove</literal>.</para>\n\t\t\t</parameter>\n\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>PJSIP_HEADER allows you to read specific SIP headers from the inbound\n\t\t\tPJSIP channel as well as write(add, update, remove) headers on the outbound\n\t\t\tchannel. One exception is that you can read headers that you have already\n\t\t\tadded on the outbound channel.</para>\n\t\t\t<para>Examples:</para>\n\t\t\t<example title=\"Set somevar to the value of the From header\">\n\t\t\texten => 1,1,Set(somevar=${PJSIP_HEADER(read,From)})\n\t\t\t</example>\n\t\t\t<example title=\"Set via2 to the value of the 2nd Via header\">\n\t\t\texten => 1,1,Set(via2=${PJSIP_HEADER(read,Via,2)})\n\t\t\t</example>\n\t\t\t<example title=\"Set xhdr to the value of the 1st X-header\">\n\t\t\texten => 1,1,Set(xhdr=${PJSIP_HEADER(read,X-*,1)})\n\t\t\t</example>\n\t\t\t<example title=\"Add an X-Myheader header with the value of myvalue\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(add,X-MyHeader)=myvalue)\n\t\t\t</example>\n\t\t\t<example title=\"Add an X-Myheader header with an empty value\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(add,X-MyHeader)=)\n\t\t\t</example>\n\t\t\t<example title=\"Update the value of the header named X-Myheader to newvalue\">\n\t\t\t; 'X-Myheader' must already exist or the call will fail.\n\t\t\texten => 1,1,Set(PJSIP_HEADER(update,X-MyHeader)=newvalue)\n\t\t\t</example>\n\t\t\t<example title=\"Remove all headers whose names exactly match X-MyHeader\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(remove,X-MyHeader)=)\n\t\t\t</example>\n\t\t\t<example title=\"Remove all headers that begin with X-My\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(remove,X-My*)=)\n\t\t\t</example>\n\t\t\t<example title=\"Remove all previously added headers\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(remove,*)=)\n\t\t\t</example>\n\t\t\t<note><para>The <literal>remove</literal> action can be called by reading\n\t\t\t<emphasis>or</emphasis> writing PJSIP_HEADER.</para></note>\n\t\t\t<example title=\"Display the number of headers removed\">\n\t\t\texten => 1,1,Verbose( Removed ${PJSIP_HEADER(remove,X-MyHeader)} headers)\n\t\t\t</example>\n\t\t\t<example title=\"Set a variable to the number of headers removed\">\n\t\t\texten => 1,1,Set(count=${PJSIP_HEADER(remove,X-MyHeader)})\n\t\t\t</example>\n\t\t\t<example title=\"Just remove them ignoring any count\">\n\t\t\texten => 1,1,Set(=${PJSIP_HEADER(remove,X-MyHeader)})\n\t\t\texten => 1,1,Set(PJSIP_HEADER(remove,X-MyHeader)=)\n\t\t\t</example>\n\n\t\t\t<note><para>If you call PJSIP_HEADER in a normal dialplan context you'll be\n\t\t\toperating on the <emphasis>caller's (incoming)</emphasis> channel which\n\t\t\tmay not be what you want. To operate on the <emphasis>callee's (outgoing)</emphasis>\n\t\t\tchannel call PJSIP_HEADER in a pre-dial handler. </para></note>\n\t\t\t<example title=\"Set headers on callee channel\">\n\t\t\t[handler]\n\t\t\texten => addheader,1,Set(PJSIP_HEADER(add,X-MyHeader)=myvalue)\n\t\t\texten => addheader,2,Set(PJSIP_HEADER(add,X-MyHeader2)=myvalue2)\n\n\t\t\t[somecontext]\n\t\t\texten => 1,1,Dial(PJSIP/${EXTEN},,b(handler^addheader^1))\n\t\t\t</example>\n\t\t</description>\n\t</function>\n\t<function name=\"PJSIP_HEADERS\" language=\"en_US\">\n\t\t<since>\n\t\t\t<version>16.20.0</version>\n\t\t\t<version>18.6.0</version>\n\t\t\t<version>19.0.0</version>\n\t\t</since>\n\t\t<synopsis>\n\t\t\tGets the list of SIP header names from an INVITE message.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"prefix\">\n\t\t\t\t<para>If specified, only the headers matching the given prefix are returned.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Returns a comma-separated list of header names (without values) from the\n\t\t\tINVITE message. Multiple headers with the same name are included in the list only once.\n\t\t\t</para>\n\t\t\t<para>For example, <literal>${PJSIP_HEADERS(Co)}</literal> might return\n\t\t\t<literal>Contact,Content-Length,Content-Type</literal>. As a practical example,\n\t\t\tyou may use <literal>${PJSIP_HEADERS(X-)}</literal> to enumerate optional extended\n\t\t\theaders.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"function\">PJSIP_HEADER</ref>\n\t\t</see-also>\n\t</function>\n\t<function name=\"PJSIP_RESPONSE_HEADER\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGets headers of 200 response from an outbound PJSIP channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"action\" required=\"true\">\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"read\">\n\t\t\t\t\t\t<para>Returns instance <replaceable>number</replaceable>\n\t\t\t\t\t\tof response header <replaceable>name</replaceable>.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\n\t\t\t<parameter name=\"name\" required=\"true\">\n\t\t\t\t<para>The <replaceable>name</replaceable> of the response header.\n\t\t\t\tA <literal>*</literal> can be appended to the <replaceable>name</replaceable>\n\t\t\t\tto iterate over all response headers <emphasis>beginning with</emphasis>\n\t\t\t\t<replaceable>name</replaceable>.</para>\n\t\t\t</parameter>\n\n\t\t\t<parameter name=\"number\" required=\"false\">\n\t\t\t\t<para>If there's more than 1 header with the same name, this specifies which header\n\t\t\t\tto read.  If not specified, defaults to <literal>1</literal> meaning\n\t\t\t\tthe first matching header.\n\t\t\t\t</para>\n\t\t\t</parameter>\n\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>PJSIP_RESPONSE_HEADER allows you to read specific SIP headers of 200 response\n\t\t\tfrom the outbound PJSIP channel.</para>\n\t\t\t<para>Examples:</para>\n\t\t\t<example title=\"Set 'somevar' to the value of the 'From' header\">\n\t\t\t\texten => 1,1,Set(somevar=${PJSIP_RESPONSE_HEADER(read,From)})\n\t\t\t</example>\n\t\t\t<example title=\"Set 'via2' to the value of the 2nd 'Via' header\">\n\t\t\t\texten => 1,1,Set(via2=${PJSIP_RESPONSE_HEADER(read,Via,2)})\n\t\t\t</example>\n\t\t\t<example title=\"Set 'xhdr' to the value of the 1sx X-header\">\n\t\t\t\texten => 1,1,Set(xhdr=${PJSIP_RESPONSE_HEADER(read,X-*,1)})\n\t\t\t</example>\n\n\t\t\t<note><para>If you call PJSIP_RESPONSE_HEADER in a normal dialplan context you'll be\n\t\t\toperating on the <emphasis>caller's (incoming)</emphasis> channel which\n\t\t\tmay not be what you want. To operate on the <emphasis>callee's (outgoing)</emphasis>\n\t\t\tchannel call PJSIP_RESPONSE_HEADER in a pre-connect handler.</para>\n\t\t\t</note>\n\t\t\t<example title=\"Usage on pre-connect handler\">\n\t\t\t\t[handler]\n\t\t\t\texten => readheader,1,NoOp(PJSIP_RESPONSE_HEADER(read,X-MyHeader))\n\t\t\t\t[somecontext]\n\t\t\t\texten => 1,1,Dial(PJSIP/${EXTEN},,U(handler^readheader^1))\n\t\t\t</example>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"function\">PJSIP_RESPONSE_HEADERS</ref>\n\t\t\t<ref type=\"function\">PJSIP_HEADER</ref>\n\t\t</see-also>\n\t</function>\n\t<function name=\"PJSIP_RESPONSE_HEADERS\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGets the list of SIP header names from the 200 response of INVITE message.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"prefix\">\n\t\t\t\t<para>If specified, only the headers matching the given prefix are returned.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Returns a comma-separated list of header names (without values) from the 200\n\t\t\tresponse of INVITE message. Multiple headers with the same name are included in the\n\t\t\tlist only once.</para>\n\t\t\t<para>For example, <literal>${PJSIP_RESPONSE_HEADERS(Co)}</literal> might return\n\t\t\t<literal>Contact,Content-Length,Content-Type</literal>. As a practical example,\n\t\t\tyou may use <literal>${PJSIP_RESPONSE_HEADERS(X-)}</literal> to enumerate optional\n\t\t\textended headers.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"function\">PJSIP_RESPONSE_HEADER</ref>\n\t\t\t<ref type=\"function\">PJSIP_HEADERS</ref>\n\t\t</see-also>\n\t</function>\n\t<function name=\"PJSIP_HEADER_PARAM\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGet or set header/URI parameters on a PJSIP channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"header_name\" required=\"true\">\n\t\t\t\t<para>Header in which parameter should be read or set.</para>\n\t\t\t\t<para>Currently, the only supported header is <literal>From</literal>.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"parameter_type\" required=\"true\">\n\t\t\t\t<para>The type of parameter to get or set.</para>\n\t\t\t\t<para>Default is header parameter.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"header\">\n\t\t\t\t\t\t<para>Header parameter.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t\t<enum name=\"uri\">\n\t\t\t\t\t\t<para>URI parameter.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"parameter_name\" required=\"true\">\n\t\t\t\t<para>Name of parameter.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>PJSIP_HEADER_PARAM allows you to read or set parameters in a SIP header on a\n\t\t\tPJSIP channel.</para>\n\t\t\t<para>Both URI parameters and header parameters can be read and set using\n\t\t\tthis function. URI parameters appear in the URI (inside the &lt;&gt; in the header)\n\t\t\twhile header parameters appear afterwards.</para>\n\t\t\t<note><para>If you call PJSIP_HEADER_PARAM in a normal dialplan context you'll be\n\t\t\toperating on the <emphasis>caller's (incoming)</emphasis> channel which\n\t\t\tmay not be what you want. To operate on the <emphasis>callee's (outgoing)</emphasis>\n\t\t\tchannel call PJSIP_HEADER_PARAM in a pre-dial handler. </para></note>\n\t\t\t<example title=\"Set URI parameter in From header on outbound channel\">\n\t\t\t[handler]\n\t\t\texten => addheader,1,Set(PJSIP_HEADER_PARAM(From,uri,isup-oli)=27)\n\t\t\tsame => n,Return()\n\t\t\t[somecontext]\n\t\t\texten => 1,1,Dial(PJSIP/${EXTEN},,b(handler^addheader^1))\n\t\t\t</example>\n\t\t\t<example title=\"Read URI parameter in From header on inbound channel\">\n\t\t\tsame => n,Set(value=${PJSIP_HEADER_PARAM(From,uri,isup-oli)})\n\t\t\t</example>\n\t\t</description>\n\t</function>\n ***/\n\n/*! \\brief Linked list for accumulating headers */\nstruct hdr_list_entry {\n\tpjsip_hdr *hdr;\n\tAST_LIST_ENTRY(hdr_list_entry) nextptr;\n};\nAST_LIST_HEAD_NOLOCK(hdr_list, hdr_list_entry);\n\n/*! \\brief Datastore for saving headers */\nstatic const struct ast_datastore_info header_datastore = {\n\t.type = \"header_datastore\",\n};\n/*! \\brief Datastore for saving response headers */\nstatic const struct ast_datastore_info response_header_datastore = {\n\t.type = \"response_header_datastore\",\n};\n\n/*! \\brief Data structure used for ast_sip_push_task_wait_serializer  */\nstruct header_data {\n\tstruct ast_sip_channel_pvt *channel;\n\tchar *header_name;\n\tconst char *header_value;\n\tchar *buf;\n\tint header_number;\n\tsize_t len;\n\tconst struct ast_datastore_info *header_datastore;\n};\n\n/*!\n * \\internal\n * \\brief Insert the header pointers into the linked list.\n *\n * For each header in the message, allocate a list entry,\n * clone the header, then insert the entry.\n */\nstatic int insert_headers(pj_pool_t * pool, struct hdr_list *list, pjsip_msg * msg)\n{\n\tpjsip_hdr *hdr = msg->hdr.next;\n\tstruct hdr_list_entry *le;\n\n\twhile (hdr && hdr != &msg->hdr) {\n\t\tle = pj_pool_zalloc(pool, sizeof(struct hdr_list_entry));\n\t\tle->hdr = pjsip_hdr_clone(pool, hdr);\n\t\tAST_LIST_INSERT_TAIL(list, le, nextptr);\n\t\thdr = hdr->next;\n\t}\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Session supplement callback on an incoming INVITE request\n *\n * Retrieve the header_datastore from the session or create one if it doesn't exist.\n * Create and initialize the list if needed.\n * Insert the headers.\n */\nstatic int incoming_request(struct ast_sip_session *session, pjsip_rx_data * rdata)\n{\n\tpj_pool_t *pool = session->inv_session->dlg->pool;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(session, header_datastore.type), ao2_cleanup);\n\n\tif (!datastore) {\n\t\tif (!(datastore =\n\t\t\t  ast_sip_session_alloc_datastore(&header_datastore, header_datastore.type))\n\t\t\t||\n\t\t\t!(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list))) ||\n\t\t\tast_sip_session_add_datastore(session, datastore)) {\n\t\t\tast_log(AST_LOG_ERROR, \"Unable to create datastore for header functions.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tAST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);\n\t}\n\tinsert_headers(pool, (struct hdr_list *) datastore->data, rdata->msg_info.msg);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Session supplement callback on an incoming INVITE response\n *\n * Retrieve the response_header_datastore from the session or create one if it doesn't exist.\n * Create and initialize the list if needed.\n * Insert the headers.\n */\nstatic void incoming_response(struct ast_sip_session *session, pjsip_rx_data * rdata)\n{\n\tpj_pool_t *pool = session->inv_session->dlg->pool;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(session, response_header_datastore.type), ao2_cleanup);\n\tpjsip_status_line status = rdata->msg_info.msg->line.status;\n\n\t/* Skip responses different of 200 OK, when 2xx is received. */\n\tif (session->inv_session->state != PJSIP_INV_STATE_CONNECTING || status.code!=200) {\n\t\treturn;\n\t}\n\n\tif (!datastore) {\n\t\tif (!(datastore =\n\t\t\t  ast_sip_session_alloc_datastore(&response_header_datastore, response_header_datastore.type))\n\t\t\t||\n\t\t\t!(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list))) ||\n\t\t\tast_sip_session_add_datastore(session, datastore)) {\n\t\t\tast_log(AST_LOG_ERROR, \"Unable to create datastore for header functions.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tAST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);\n\t}\n\tinsert_headers(pool, (struct hdr_list *) datastore->data, rdata->msg_info.msg);\n\n\treturn;\n}\n\n/*!\n * \\internal\n * \\brief Search list for nth occurrence of specific header.\n */\nstatic pjsip_hdr *find_header(struct hdr_list *list, const char *header_name,\n\t\t\t\t\t\t\t  int header_number)\n{\n\tstruct hdr_list_entry *le;\n\tpjsip_hdr *hdr = NULL;\n\tint i = 1;\n\n\tif (!list || ast_strlen_zero(header_name) || header_number < 1) {\n\t\treturn NULL;\n\t}\n\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tif (pj_stricmp2(&le->hdr->name, header_name) == 0 && i++ == header_number) {\n\t\t\thdr = le->hdr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hdr;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADERS/PJSIP_RESPONSE_HEADERS by searching for the requested header prefix.\n *\n * Retrieve the header_datastore.\n * Search for the all matching headers.\n * Validate the pjsip_hdr found.\n * Parse pjsip_hdr into a name and copy to the buffer.\n * Return the value.\n */\nstatic int read_headers(void *obj)\n{\n\tstruct header_data *data = obj;\n\tsize_t len = !ast_strlen_zero(data->header_name) ? strlen(data->header_name) : 0;\n\tpjsip_hdr *hdr = NULL;\n\tchar *pj_hdr_string;\n\tint pj_hdr_string_len;\n\tchar *p;\n\tchar *pos;\n\tsize_t plen, wlen = 0;\n\tstruct hdr_list_entry *le;\n\tstruct hdr_list *list;\n\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_debug(1, \"There was no datastore from which to read headers.\\n\");\n\t\treturn -1;\n\t}\n\n\tlist = datastore->data;\n\tpj_hdr_string = ast_alloca(data->len);\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tif (!len || pj_strnicmp2(&le->hdr->name, data->header_name, len) == 0) {\n\t\t\t/* Found matched header, append to buf */\n\t\t\thdr = le->hdr;\n\n\t\t\tpj_hdr_string_len = pjsip_hdr_print_on(hdr, pj_hdr_string, data->len - 1);\n\t\t\tif (pj_hdr_string_len == -1) {\n\t\t\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\t\"Not enough buffer space in pjsip_hdr_print_on\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpj_hdr_string[pj_hdr_string_len] = '\\0';\n\t\t\tp = strchr(pj_hdr_string, ':');\n\t\t\tif (!p) {\n\t\t\t\tast_log(AST_LOG_WARNING,\n\t\t\t\t\t\"A malformed header was returned from pjsip_hdr_print_on\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpj_hdr_string[p - pj_hdr_string] = '\\0';\n\t\t\tp = ast_strip(pj_hdr_string);\n\t\t\tplen = strlen(p);\n\t\t\tif (wlen + plen + 1 > data->len) {\n\t\t\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\t\t\"Buffer isn't big enough to hold header value.  %zu > %zu\\n\", plen + 1,\n\t\t\t\t\t\tdata->len);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpos = strstr(data->buf, p);\n\t\t\tif (pos && pos[1] == ',') {\n\t\t\t\tif (pos == data->buf) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (pos[-1] == ',') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_copy_string(data->buf + wlen, p, data->len - wlen);\n\t\t\twlen += plen;\n\t\t\tast_copy_string(data->buf + wlen, \",\", data->len - wlen);\n\t\t\twlen++;\n\t\t}\n\t}\n\n\tif (wlen == 0) {\n\t\tif (!len) {\n\t\t\t/* No headers at all on this channel */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tast_debug(1, \"There was no header beginning with %s.\\n\", data->header_name);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tdata->buf[wlen-1] = '\\0';\n\t}\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER/PJSIP_RESPONSE_HEADER 'read' by searching the for the requested header.\n *\n * Retrieve the header_datastore.\n * Search for the nth matching header.\n * Validate the pjsip_hdr found.\n * Parse pjsip_hdr into a name and value.\n * Return the value.\n */\nstatic int read_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tsize_t len = strlen(data->header_name);\n\tpjsip_hdr *hdr = NULL;\n\tchar *pj_hdr_string;\n\tint pj_hdr_string_len;\n\tchar *p;\n\tsize_t plen;\n\tstruct hdr_list_entry *le;\n\tstruct hdr_list *list;\n\tint i = 1;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_debug(1, \"There was no datastore from which to read headers.\\n\");\n\t\treturn -1;\n\t}\n\n\tlist = datastore->data;\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tif (data->header_name[len - 1] == '*') {\n\t\t\tif (pj_strnicmp2(&le->hdr->name, data->header_name, len - 1) == 0 && i++ == data->header_number) {\n\t\t\t\thdr = le->hdr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pj_stricmp2(&le->hdr->name, data->header_name) == 0 && i++ == data->header_number) {\n\t\t\t\thdr = le->hdr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!hdr) {\n\t\tast_debug(1, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\n\tpj_hdr_string = ast_alloca(data->len);\n\tpj_hdr_string_len = pjsip_hdr_print_on(hdr, pj_hdr_string, data->len - 1);\n\tif (pj_hdr_string_len == -1) {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\"Not enough buffer space in pjsip_hdr_print_on\\n\");\n\t\treturn -1;\n\t}\n\n\tpj_hdr_string[pj_hdr_string_len] = '\\0';\n\n\tp = strchr(pj_hdr_string, ':');\n\tif (!p) {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"A malformed header was returned from pjsip_hdr_print_on.\\n\");\n\t\treturn -1;\n\t}\n\n\t++p;\n\tp = ast_strip(p);\n\tplen = strlen(p);\n\tif (plen + 1 > data->len) {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"Buffer isn't big enough to hold header value.  %zu > %zu\\n\", plen + 1,\n\t\t\t\tdata->len);\n\t\treturn -1;\n\t}\n\n\tast_copy_string(data->buf, p, data->len);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER 'add' by inserting the specified header into the list.\n *\n * Retrieve the header_datastore from the session or create one if it doesn't exist.\n * Create and initialize the list if needed.\n * Create the pj_strs for name and value.\n * Create pjsip_msg and hdr_list_entry.\n * Add the entry to the list.\n */\nstatic int add_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tstruct ast_sip_session *session = data->channel->session;\n\tpj_pool_t *pool = session->inv_session->dlg->pool;\n\tpj_str_t pj_header_name;\n\tpj_str_t pj_header_value;\n\tstruct hdr_list_entry *le;\n\tstruct hdr_list *list;\n\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(session, data->header_datastore->type), ao2_cleanup);\n\n\tif (!datastore) {\n\t\tif (!(datastore = ast_sip_session_alloc_datastore(data->header_datastore,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata->header_datastore->type))\n\t\t\t|| !(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list)))\n\t\t\t|| ast_sip_session_add_datastore(session, datastore)) {\n\t\t\tast_log(AST_LOG_ERROR, \"Unable to create datastore for header functions.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tAST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);\n\t}\n\n\tast_debug(1, \"Adding header %s with value %s\\n\", data->header_name,\n\t\t\t  data->header_value);\n\n\tpj_cstr(&pj_header_name, data->header_name);\n\tpj_cstr(&pj_header_value, data->header_value);\n\tle = pj_pool_zalloc(pool, sizeof(struct hdr_list_entry));\n\tle->hdr = (pjsip_hdr *) pjsip_generic_string_hdr_create(pool, &pj_header_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&pj_header_value);\n\tlist = datastore->data;\n\n\tAST_LIST_INSERT_TAIL(list, le, nextptr);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER 'update' by finding the specified header and updating it.\n *\n * Retrieve the header_datastore from the session or create one if it doesn't exist.\n * Create and initialize the list if needed.\n * Create the pj_strs for name and value.\n * Create pjsip_msg and hdr_list_entry.\n * Add the entry to the list.\n */\nstatic int update_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tpjsip_hdr *hdr = NULL;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\n\thdr = find_header((struct hdr_list *) datastore->data, data->header_name,\n\t\t\t\t\t  data->header_number);\n\n\tif (!hdr) {\n\t\tast_log(AST_LOG_ERROR, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\n\tpj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER 'remove' by finding the specified header and removing it.\n *\n * Retrieve the header_datastore from the session.  Fail if it doesn't exist.\n * If the header_name is exactly '*', the entire list is simply destroyed.\n * Otherwise search the list for the matching header name which may be a partial name.\n */\nstatic int remove_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tsize_t len = strlen(data->header_name);\n\tstruct hdr_list *list;\n\tstruct hdr_list_entry *le;\n\tint removed_count = 0;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\n\tlist = datastore->data;\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(list, le, nextptr) {\n\t\tif (data->header_name[len - 1] == '*') {\n\t\t\tif (pj_strnicmp2(&le->hdr->name, data->header_name, len - 1) == 0) {\n\t\t\t\tAST_LIST_REMOVE_CURRENT(nextptr);\n\t\t\t\tremoved_count++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pj_stricmp2(&le->hdr->name, data->header_name) == 0) {\n\t\t\t\tAST_LIST_REMOVE_CURRENT(nextptr);\n\t\t\t\tremoved_count++;\n\t\t\t}\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\n\tif (data->buf && data->len) {\n\t\tsnprintf(data->buf, data->len, \"%d\", removed_count);\n\t}\n\n\treturn 0;\n}\n\n/*!\n * \\brief Read list of unique SIP headers\n */\nstatic int func_read_headers(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(header_pattern);\n\t);\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!chan || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_pattern;\n\theader_data.header_value = NULL;\n\theader_data.buf = buf;\n\theader_data.len = len;\n\theader_data.header_datastore = &header_datastore;\n\n\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_headers, &header_data);\n\n}\n\n/*!\n * \\brief Read list of unique SIP response headers\n */\nstatic int func_response_read_headers(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(header_pattern);\n\t);\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!chan || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ast_strlen_zero(args.header_pattern)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a pattern.\\n\");\n\t\treturn -1;\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_pattern;\n\theader_data.header_value = NULL;\n\theader_data.buf = buf;\n\theader_data.len = len;\n\theader_data.header_datastore = &response_header_datastore;\n\n\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_headers, &header_data);\n\n}\n\n/*!\n * \\brief Implements PJSIP_HEADER function 'read' callback.\n *\n * Valid actions are 'read' and 'remove'.\n */\nstatic int func_read_header(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tint number;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t\t\t\t AST_APP_ARG(action);\n\t\t\t\t\t\t AST_APP_ARG(header_name); AST_APP_ARG(header_number););\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ast_strlen_zero(args.action)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires an action.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.header_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a header name.\\n\");\n\t\treturn -1;\n\t}\n\tif (!args.header_number) {\n\t\tnumber = 1;\n\t} else {\n\t\tsscanf(args.header_number, \"%30d\", &number);\n\t\tif (number < 1) {\n\t\t\tnumber = 1;\n\t\t}\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_name;\n\theader_data.header_number = number;\n\theader_data.header_value = NULL;\n\theader_data.buf = buf;\n\theader_data.len = len;\n\theader_data.header_datastore = &header_datastore;\n\n\tif (!strcasecmp(args.action, \"read\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_header, &header_data);\n\t} else if (!strcasecmp(args.action, \"remove\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer,\n\t\t\tremove_header, &header_data);\n\t} else {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"Unknown action '%s' is not valid, must be 'read' or 'remove'.\\n\",\n\t\t\t\targs.action);\n\t\treturn -1;\n\t}\n}\n\n/*!\n * \\brief Implements PJSIP_RESPONSE_HEADER function 'read' callback.\n *\n * Valid actions are 'read'\n */\nstatic int func_response_read_header(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tint number;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t\t\t\t AST_APP_ARG(action);\n\t\t\t\t\t\t AST_APP_ARG(header_name); AST_APP_ARG(header_number););\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ast_strlen_zero(args.action)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires an action.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.header_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a header name.\\n\");\n\t\treturn -1;\n\t}\n\tif (!args.header_number) {\n\t\tnumber = 1;\n\t} else {\n\t\tsscanf(args.header_number, \"%30d\", &number);\n\t\tif (number < 1) {\n\t\t\tnumber = 1;\n\t\t}\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_name;\n\theader_data.header_number = number;\n\theader_data.header_value = NULL;\n\theader_data.buf = buf;\n\theader_data.len = len;\n\theader_data.header_datastore = &response_header_datastore;\n\n\tif (!strcasecmp(args.action, \"read\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_header, &header_data);\n\t} else {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"Unknown action '%s' is not valid, must be 'read'.\\n\",\n\t\t\t\targs.action);\n\t\treturn -1;\n\t}\n}\n\n/*!\n * \\brief Implements PJSIP_HEADER function 'write' callback.\n *\n * Valid actions are 'add', 'update' and 'remove'.\n */\nstatic int func_write_header(struct ast_channel *chan, const char *cmd, char *data,\n\t\t\t\t\t\t\t const char *value)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tint header_number;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t\t\t\t AST_APP_ARG(action);\n\t\t\t\t\t\t AST_APP_ARG(header_name); AST_APP_ARG(header_number););\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ast_strlen_zero(args.action)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires an action.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.header_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a header name.\\n\");\n\t\treturn -1;\n\t}\n\tif (!args.header_number) {\n\t\theader_number = 1;\n\t} else {\n\t\tsscanf(args.header_number, \"%30d\", &header_number);\n\t\tif (header_number < 1) {\n\t\t\theader_number = 1;\n\t\t}\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_name;\n\theader_data.header_number = header_number;\n\theader_data.header_value = value;\n\theader_data.buf = NULL;\n\theader_data.len = 0;\n\theader_data.header_datastore = &header_datastore;\n\n\tif (!strcasecmp(args.action, \"add\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer,\n\t\t\tadd_header, &header_data);\n\t} else if (!strcasecmp(args.action, \"update\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer,\n\t\t\tupdate_header, &header_data);\n\t} else if (!strcasecmp(args.action, \"remove\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer,\n\t\t\tremove_header, &header_data);\n\t} else {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"Unknown action '%s' is not valid, must be 'add', 'update', or 'remove'.\\n\",\n\t\t\t\targs.action);\n\t\treturn -1;\n\t}\n}\n\nstatic struct ast_custom_function pjsip_header_function = {\n\t.name = \"PJSIP_HEADER\",\n\t.read = func_read_header,\n\t.write = func_write_header,\n};\n\nstatic struct ast_custom_function pjsip_headers_function = {\n\t.name = \"PJSIP_HEADERS\",\n\t.read = func_read_headers\n};\n\nstatic struct ast_custom_function pjsip_response_header_function = {\n\t.name = \"PJSIP_RESPONSE_HEADER\",\n\t.read = func_response_read_header\n};\n\nstatic struct ast_custom_function pjsip_response_headers_function = {\n\t.name = \"PJSIP_RESPONSE_HEADERS\",\n\t.read = func_response_read_headers\n};\n\n/*!\n * \\internal\n * \\brief Session supplement callback for outgoing INVITE requests\n *\n * Retrieve the header_datastore from the session.\n * Add each header in the list to the outgoing message.\n *\n * These pjsip_hdr structures will have been created by add_header.\n * Because outgoing_request may be called more than once with the same header\n * list (as in the case of an authentication exchange), each pjsip_hdr structure\n * MUST be newly cloned for each outgoing message.\n */\nstatic void outgoing_request(struct ast_sip_session *session, pjsip_tx_data * tdata)\n{\n\tstruct hdr_list *list;\n\tstruct hdr_list_entry *le;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(session, header_datastore.type), ao2_cleanup);\n\n\tif (!datastore || !datastore->data ||\n\t\t(session->inv_session->state >= PJSIP_INV_STATE_CONFIRMED)) {\n\t\treturn;\n\t}\n\n\tlist = datastore->data;\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr *) pjsip_hdr_clone(tdata->pool, le->hdr));\n\t}\n\tast_sip_session_remove_datastore(session, datastore->uid);\n}\n\nstatic struct ast_sip_session_supplement header_funcs_supplement = {\n\t.method = \"INVITE\",\n\t.priority = AST_SIP_SUPPLEMENT_PRIORITY_CHANNEL - 1000,\n\t.incoming_request = incoming_request,\n\t.outgoing_request = outgoing_request,\n\t.incoming_response = incoming_response,\n};\n\nenum param_type {\n\tPARAMETER_HEADER,\n\tPARAMETER_URI,\n};\n\nstruct param_data {\n\tstruct ast_sip_channel_pvt *channel;\n\tchar *header_name;\n\tchar *param_name;\n\tconst char *param_value; /* Only used for write */\n\tenum param_type paramtype;\n\t/* For read function only */\n\tchar *buf;\n\tsize_t len;\n};\n\nstatic int read_param(void *obj)\n{\n\tstruct param_data *data = obj;\n\tstruct ast_sip_session *session = data->channel->session;\n\tpj_str_t param_name;\n\n\tpjsip_fromto_hdr *dlg_info;\n\tpjsip_name_addr *dlg_info_name_addr;\n\tpjsip_sip_uri *dlg_info_uri;\n\tpjsip_param *param;\n\tsize_t param_len;\n\n\tdlg_info = session->inv_session->dlg->remote.info; /* Remote dialog for incoming */\n\tdlg_info_name_addr = (pjsip_name_addr *) dlg_info->uri;\n\tdlg_info_uri = pjsip_uri_get_uri(dlg_info_name_addr);\n\n\tpj_cstr(&param_name, data->param_name);\n\n\tif (data->paramtype == PARAMETER_URI) { /* URI parameter */\n\t\tparam = pjsip_param_find(&dlg_info_uri->other_param, &param_name);\n\t} else { /* Header parameter */\n\t\tparam = pjsip_param_find(&dlg_info->other_param, &param_name);\n\t}\n\n\tif (!param) {\n\t\tast_debug(1, \"No %s parameter found named %s\\n\",\n\t\t\tdata->paramtype == PARAMETER_URI ? \"URI\" : \"header\", data->param_name);\n\t\treturn -1;\n\t}\n\n\tparam_len = pj_strlen(&param->value);\n\tif (param_len >= data->len) {\n\t\tast_log(LOG_ERROR, \"Buffer is too small for parameter value (%zu > %zu)\\n\", param_len, data->len);\n\t\treturn -1;\n\t}\n\n\tast_debug(2, \"Successfully read %s parameter %s (length %zu)\\n\",\n\t\tdata->paramtype == PARAMETER_URI ? \"URI\" : \"header\", data->param_name, param_len);\n\tif (param_len) {\n\t\tast_copy_string(data->buf, pj_strbuf(&param->value), data->len);\n\t}\n\tdata->buf[param_len] = '\\0';\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER_PARAM 'add' by adding the specified parameter.\n * \\note Unlike add_header, we can't add parameters in the outgoing_request callback: that's too late.\n *       That's why we do it here and not in a callback.\n */\nstatic int add_param(void *obj)\n{\n\tstruct param_data *data = obj;\n\tstruct ast_sip_session *session = data->channel->session;\n\tpj_pool_t *pool = session->inv_session->dlg->pool;\n\n\tpjsip_fromto_hdr *dlg_info;\n\tpjsip_name_addr *dlg_info_name_addr;\n\tpjsip_sip_uri *dlg_info_uri;\n\n\tdlg_info = session->inv_session->dlg->local.info; /* Local for outgoing */\n\tdlg_info_name_addr = (pjsip_name_addr *) dlg_info->uri;\n\tdlg_info_uri = pjsip_uri_get_uri(dlg_info_name_addr);\n\tif (!PJSIP_URI_SCHEME_IS_SIP(dlg_info_uri) && !PJSIP_URI_SCHEME_IS_SIPS(dlg_info_uri)) {\n\t\tast_log(LOG_WARNING, \"Non SIP/SIPS URI\\n\");\n\t\treturn -1;\n\t}\n\n\tast_debug(1, \"Adding custom %s param %s = %s\\n\",\n\t\tdata->paramtype == PARAMETER_URI ? \"URI\" : \"header\", data->param_name, data->param_value);\n\n\t/* This works the same as doing this in set_from_header in res_pjsip_session.c\n\t * The way that this maps to pjproject is a little confusing.\n\t * Say we have <sip:foo@bar.com;p1=abc;p2=def?h1=qrs&h2=tuv>;o1=foo;o2=bar\n\t * p1 and p2 are URI parameters.\n\t * (h1 and h2 are URI headers)\n\t * o1 and o2 are header parameters (and don't have anything to do with the URI)\n\t * In pjproject, other_param is used for adding all custom parameters.\n\t * We use the URI for URI stuff, including URI parameters, and the header directly for header parameters.\n\t */\n\n#define param_add(pool, list, pname, pvalue) { \\\n\tpjsip_param *param; \\\n\tparam = PJ_POOL_ALLOC_T(pool, pjsip_param); \\\n\tpj_strdup2(pool, &param->name, pname); \\\n\tpj_strdup2(pool, &param->value, pvalue); \\\n\tpj_list_insert_before(list, param); \\\n}\n\n\tif (data->paramtype == PARAMETER_URI) { /* URI parameter */\n\t\tparam_add(pool, &dlg_info_uri->other_param, data->param_name, S_OR(data->param_value, \"\"));\n\t} else { /* Header parameter */\n\t\tparam_add(pool, &dlg_info->other_param, data->param_name, S_OR(data->param_value, \"\"));\n\t}\n\n\treturn 0;\n}\n\nstatic int func_read_param(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct param_data param_data;\n\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(header_name);\n\t\tAST_APP_ARG(param_type);\n\t\tAST_APP_ARG(param_name);\n\t);\n\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tparam_data.channel = channel;\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.param_type)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a parameter type.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.param_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a parameter name.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Currently, only From is supported, but this could be extended in the future. */\n\tif (ast_strlen_zero(args.header_name) || strcasecmp(args.header_name, \"From\")) {\n\t\tast_log(LOG_WARNING, \"Only the From header is currently supported\\n\");\n\t\treturn -1;\n\t}\n\n\tparam_data.param_name = args.param_name;\n\tif (!strcasecmp(args.param_type, \"header\")) {\n\t\tparam_data.paramtype = PARAMETER_HEADER;\n\t} else if (!strcasecmp(args.param_type, \"uri\")) {\n\t\tparam_data.paramtype = PARAMETER_URI;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Parameter type '%s' is invalid: must be 'header' or 'uri'\\n\", args.param_type);\n\t\treturn -1;\n\t}\n\n\tparam_data.buf = buf;\n\tparam_data.len = len;\n\n\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_param, &param_data);\n}\n\nstatic int func_write_param(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct param_data param_data;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(header_name);\n\t\tAST_APP_ARG(param_type);\n\t\tAST_APP_ARG(param_name);\n\t);\n\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tparam_data.channel = channel;\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.param_type)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a parameter type.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.param_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a parameter name.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Currently, only From is supported, but this could be extended in the future. */\n\tif (ast_strlen_zero(args.header_name) || strcasecmp(args.header_name, \"From\")) {\n\t\tast_log(LOG_WARNING, \"Only the From header is currently supported\\n\");\n\t\treturn -1;\n\t}\n\n\tparam_data.param_name = args.param_name;\n\tif (!strcasecmp(args.param_type, \"header\")) {\n\t\tparam_data.paramtype = PARAMETER_HEADER;\n\t} else if (!strcasecmp(args.param_type, \"uri\")) {\n\t\tparam_data.paramtype = PARAMETER_URI;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Parameter type '%s' is invalid: must be 'header' or 'uri'\\n\", args.param_type);\n\t\treturn -1;\n\t}\n\tparam_data.param_value = value;\n\n\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, add_param, &param_data);\n}\n\nstatic struct ast_custom_function pjsip_header_param_function = {\n\t.name = \"PJSIP_HEADER_PARAM\",\n\t.read = func_read_param,\n\t.write = func_write_param,\n};\n\nstatic int load_module(void)\n{\n\tast_sip_session_register_supplement(&header_funcs_supplement);\n\tast_custom_function_register(&pjsip_header_function);\n\tast_custom_function_register(&pjsip_headers_function);\n\tast_custom_function_register(&pjsip_response_header_function);\n\tast_custom_function_register(&pjsip_response_headers_function);\n\tast_custom_function_register(&pjsip_header_param_function);\n\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n\nstatic int unload_module(void)\n{\n\tast_custom_function_unregister(&pjsip_header_function);\n\tast_custom_function_unregister(&pjsip_headers_function);\n\tast_custom_function_unregister(&pjsip_response_header_function);\n\tast_custom_function_unregister(&pjsip_response_headers_function);\n\tast_custom_function_unregister(&pjsip_header_param_function);\n\tast_sip_session_unregister_supplement(&header_funcs_supplement);\n\treturn 0;\n}\n\nAST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, \"PJSIP Header Functions\",\n\t.support_level = AST_MODULE_SUPPORT_CORE,\n\t.load = load_module,\n\t.unload = unload_module,\n\t.load_pri = AST_MODPRI_APP_DEPEND,\n\t.requires = \"res_pjsip,res_pjsip_session\",\n);\n"], "fixing_code": ["/*\n * Asterisk -- An open source telephony toolkit.\n *\n * Copyright (C) 2013, Fairview 5 Engineering, LLC\n *\n * George Joseph <george.joseph@fairview5.com>\n * Jos\u00e9 Lopes <jose.lopes@nfon.com>\n * Naveen Albert <asterisk@phreaknet.org>\n *\n * See http://www.asterisk.org for more information about\n * the Asterisk project. Please do not directly contact\n * any of the maintainers of this project for assistance;\n * the project provides a web site, mailing lists and IRC\n * channels for your use.\n *\n * This program is free software, distributed under the terms of\n * the GNU General Public License Version 2. See the LICENSE file\n * at the top of the source tree.\n */\n\n/*** MODULEINFO\n\t<depend>pjproject</depend>\n\t<depend>res_pjsip</depend>\n\t<depend>res_pjsip_session</depend>\n\t<support_level>core</support_level>\n ***/\n\n#include \"asterisk.h\"\n\n#include <pjsip.h>\n#include <pjsip_ua.h>\n\n#include \"asterisk/res_pjsip.h\"\n#include \"asterisk/res_pjsip_session.h\"\n#include \"asterisk/channel.h\"\n#include \"asterisk/pbx.h\"\n#include \"asterisk/app.h\"\n#include \"asterisk/module.h\"\n#include \"asterisk/utils.h\"\n\n/*** DOCUMENTATION\n\t<function name=\"PJSIP_HEADER\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGets headers from an inbound PJSIP channel. Adds, updates or removes the\n\t\t\tspecified SIP header from an outbound PJSIP channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"action\" required=\"true\">\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"read\"><para>Returns instance <replaceable>number</replaceable>\n\t\t\t\t\tof header <replaceable>name</replaceable>. A <literal>*</literal>\n\t\t\t\t\tmay be appended to <replaceable>name</replaceable> to iterate over all \n\t\t\t\t\theaders <emphasis>beginning with</emphasis> <replaceable>name</replaceable>.\n\t\t\t\t\t</para></enum>\n\n\t\t\t\t\t<enum name=\"add\"><para>Adds a new header <replaceable>name</replaceable>\n\t\t\t\t\tto this session.</para></enum>\n\n\t\t\t\t\t<enum name=\"update\"><para>Updates instance <replaceable>number</replaceable>\n\t\t\t\t\tof header <replaceable>name</replaceable> to a new value.\n\t\t\t\t\tThe header must already exist.</para></enum>\n\n\t\t\t\t\t<enum name=\"remove\"><para>Removes all instances of previously added headers\n\t\t\t\t\twhose names match <replaceable>name</replaceable>. A <literal>*</literal>\n\t\t\t\t\tmay be appended to <replaceable>name</replaceable> to remove all headers\n\t\t\t\t\t<emphasis>beginning with</emphasis> <replaceable>name</replaceable>.\n\t\t\t\t\t<replaceable>name</replaceable> may be set to a single <literal>*</literal>\n\t\t\t\t\tto clear <emphasis>all</emphasis> previously added headers. In all cases,\n\t\t\t\t\tthe number of headers actually removed is returned.</para></enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\n\t\t\t<parameter name=\"name\" required=\"true\"><para>The name of the header.</para></parameter>\n\n\t\t\t<parameter name=\"number\" required=\"false\">\n\t\t\t\t<para>If there's more than 1 header with the same name, this specifies which header\n\t\t\t\tto read or update.  If not specified, defaults to <literal>1</literal> meaning\n\t\t\t\tthe first matching header.  Not valid for <literal>add</literal> or\n\t\t\t\t<literal>remove</literal>.</para>\n\t\t\t</parameter>\n\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>PJSIP_HEADER allows you to read specific SIP headers from the inbound\n\t\t\tPJSIP channel as well as write(add, update, remove) headers on the outbound\n\t\t\tchannel. One exception is that you can read headers that you have already\n\t\t\tadded on the outbound channel.</para>\n\t\t\t<para>Examples:</para>\n\t\t\t<example title=\"Set somevar to the value of the From header\">\n\t\t\texten => 1,1,Set(somevar=${PJSIP_HEADER(read,From)})\n\t\t\t</example>\n\t\t\t<example title=\"Set via2 to the value of the 2nd Via header\">\n\t\t\texten => 1,1,Set(via2=${PJSIP_HEADER(read,Via,2)})\n\t\t\t</example>\n\t\t\t<example title=\"Set xhdr to the value of the 1st X-header\">\n\t\t\texten => 1,1,Set(xhdr=${PJSIP_HEADER(read,X-*,1)})\n\t\t\t</example>\n\t\t\t<example title=\"Add an X-Myheader header with the value of myvalue\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(add,X-MyHeader)=myvalue)\n\t\t\t</example>\n\t\t\t<example title=\"Add an X-Myheader header with an empty value\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(add,X-MyHeader)=)\n\t\t\t</example>\n\t\t\t<example title=\"Update the value of the header named X-Myheader to newvalue\">\n\t\t\t; 'X-Myheader' must already exist or the call will fail.\n\t\t\texten => 1,1,Set(PJSIP_HEADER(update,X-MyHeader)=newvalue)\n\t\t\t</example>\n\t\t\t<example title=\"Remove all headers whose names exactly match X-MyHeader\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(remove,X-MyHeader)=)\n\t\t\t</example>\n\t\t\t<example title=\"Remove all headers that begin with X-My\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(remove,X-My*)=)\n\t\t\t</example>\n\t\t\t<example title=\"Remove all previously added headers\">\n\t\t\texten => 1,1,Set(PJSIP_HEADER(remove,*)=)\n\t\t\t</example>\n\t\t\t<note><para>The <literal>remove</literal> action can be called by reading\n\t\t\t<emphasis>or</emphasis> writing PJSIP_HEADER.</para></note>\n\t\t\t<example title=\"Display the number of headers removed\">\n\t\t\texten => 1,1,Verbose( Removed ${PJSIP_HEADER(remove,X-MyHeader)} headers)\n\t\t\t</example>\n\t\t\t<example title=\"Set a variable to the number of headers removed\">\n\t\t\texten => 1,1,Set(count=${PJSIP_HEADER(remove,X-MyHeader)})\n\t\t\t</example>\n\t\t\t<example title=\"Just remove them ignoring any count\">\n\t\t\texten => 1,1,Set(=${PJSIP_HEADER(remove,X-MyHeader)})\n\t\t\texten => 1,1,Set(PJSIP_HEADER(remove,X-MyHeader)=)\n\t\t\t</example>\n\n\t\t\t<note><para>If you call PJSIP_HEADER in a normal dialplan context you'll be\n\t\t\toperating on the <emphasis>caller's (incoming)</emphasis> channel which\n\t\t\tmay not be what you want. To operate on the <emphasis>callee's (outgoing)</emphasis>\n\t\t\tchannel call PJSIP_HEADER in a pre-dial handler. </para></note>\n\t\t\t<example title=\"Set headers on callee channel\">\n\t\t\t[handler]\n\t\t\texten => addheader,1,Set(PJSIP_HEADER(add,X-MyHeader)=myvalue)\n\t\t\texten => addheader,2,Set(PJSIP_HEADER(add,X-MyHeader2)=myvalue2)\n\n\t\t\t[somecontext]\n\t\t\texten => 1,1,Dial(PJSIP/${EXTEN},,b(handler^addheader^1))\n\t\t\t</example>\n\t\t</description>\n\t</function>\n\t<function name=\"PJSIP_HEADERS\" language=\"en_US\">\n\t\t<since>\n\t\t\t<version>16.20.0</version>\n\t\t\t<version>18.6.0</version>\n\t\t\t<version>19.0.0</version>\n\t\t</since>\n\t\t<synopsis>\n\t\t\tGets the list of SIP header names from an INVITE message.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"prefix\">\n\t\t\t\t<para>If specified, only the headers matching the given prefix are returned.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Returns a comma-separated list of header names (without values) from the\n\t\t\tINVITE message. Multiple headers with the same name are included in the list only once.\n\t\t\t</para>\n\t\t\t<para>For example, <literal>${PJSIP_HEADERS(Co)}</literal> might return\n\t\t\t<literal>Contact,Content-Length,Content-Type</literal>. As a practical example,\n\t\t\tyou may use <literal>${PJSIP_HEADERS(X-)}</literal> to enumerate optional extended\n\t\t\theaders.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"function\">PJSIP_HEADER</ref>\n\t\t</see-also>\n\t</function>\n\t<function name=\"PJSIP_RESPONSE_HEADER\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGets headers of 200 response from an outbound PJSIP channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"action\" required=\"true\">\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"read\">\n\t\t\t\t\t\t<para>Returns instance <replaceable>number</replaceable>\n\t\t\t\t\t\tof response header <replaceable>name</replaceable>.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\n\t\t\t<parameter name=\"name\" required=\"true\">\n\t\t\t\t<para>The <replaceable>name</replaceable> of the response header.\n\t\t\t\tA <literal>*</literal> can be appended to the <replaceable>name</replaceable>\n\t\t\t\tto iterate over all response headers <emphasis>beginning with</emphasis>\n\t\t\t\t<replaceable>name</replaceable>.</para>\n\t\t\t</parameter>\n\n\t\t\t<parameter name=\"number\" required=\"false\">\n\t\t\t\t<para>If there's more than 1 header with the same name, this specifies which header\n\t\t\t\tto read.  If not specified, defaults to <literal>1</literal> meaning\n\t\t\t\tthe first matching header.\n\t\t\t\t</para>\n\t\t\t</parameter>\n\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>PJSIP_RESPONSE_HEADER allows you to read specific SIP headers of 200 response\n\t\t\tfrom the outbound PJSIP channel.</para>\n\t\t\t<para>Examples:</para>\n\t\t\t<example title=\"Set 'somevar' to the value of the 'From' header\">\n\t\t\t\texten => 1,1,Set(somevar=${PJSIP_RESPONSE_HEADER(read,From)})\n\t\t\t</example>\n\t\t\t<example title=\"Set 'via2' to the value of the 2nd 'Via' header\">\n\t\t\t\texten => 1,1,Set(via2=${PJSIP_RESPONSE_HEADER(read,Via,2)})\n\t\t\t</example>\n\t\t\t<example title=\"Set 'xhdr' to the value of the 1sx X-header\">\n\t\t\t\texten => 1,1,Set(xhdr=${PJSIP_RESPONSE_HEADER(read,X-*,1)})\n\t\t\t</example>\n\n\t\t\t<note><para>If you call PJSIP_RESPONSE_HEADER in a normal dialplan context you'll be\n\t\t\toperating on the <emphasis>caller's (incoming)</emphasis> channel which\n\t\t\tmay not be what you want. To operate on the <emphasis>callee's (outgoing)</emphasis>\n\t\t\tchannel call PJSIP_RESPONSE_HEADER in a pre-connect handler.</para>\n\t\t\t</note>\n\t\t\t<example title=\"Usage on pre-connect handler\">\n\t\t\t\t[handler]\n\t\t\t\texten => readheader,1,NoOp(PJSIP_RESPONSE_HEADER(read,X-MyHeader))\n\t\t\t\t[somecontext]\n\t\t\t\texten => 1,1,Dial(PJSIP/${EXTEN},,U(handler^readheader^1))\n\t\t\t</example>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"function\">PJSIP_RESPONSE_HEADERS</ref>\n\t\t\t<ref type=\"function\">PJSIP_HEADER</ref>\n\t\t</see-also>\n\t</function>\n\t<function name=\"PJSIP_RESPONSE_HEADERS\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGets the list of SIP header names from the 200 response of INVITE message.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"prefix\">\n\t\t\t\t<para>If specified, only the headers matching the given prefix are returned.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>Returns a comma-separated list of header names (without values) from the 200\n\t\t\tresponse of INVITE message. Multiple headers with the same name are included in the\n\t\t\tlist only once.</para>\n\t\t\t<para>For example, <literal>${PJSIP_RESPONSE_HEADERS(Co)}</literal> might return\n\t\t\t<literal>Contact,Content-Length,Content-Type</literal>. As a practical example,\n\t\t\tyou may use <literal>${PJSIP_RESPONSE_HEADERS(X-)}</literal> to enumerate optional\n\t\t\textended headers.</para>\n\t\t</description>\n\t\t<see-also>\n\t\t\t<ref type=\"function\">PJSIP_RESPONSE_HEADER</ref>\n\t\t\t<ref type=\"function\">PJSIP_HEADERS</ref>\n\t\t</see-also>\n\t</function>\n\t<function name=\"PJSIP_HEADER_PARAM\" language=\"en_US\">\n\t\t<synopsis>\n\t\t\tGet or set header/URI parameters on a PJSIP channel.\n\t\t</synopsis>\n\t\t<syntax>\n\t\t\t<parameter name=\"header_name\" required=\"true\">\n\t\t\t\t<para>Header in which parameter should be read or set.</para>\n\t\t\t\t<para>Currently, the only supported header is <literal>From</literal>.</para>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"parameter_type\" required=\"true\">\n\t\t\t\t<para>The type of parameter to get or set.</para>\n\t\t\t\t<para>Default is header parameter.</para>\n\t\t\t\t<enumlist>\n\t\t\t\t\t<enum name=\"header\">\n\t\t\t\t\t\t<para>Header parameter.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t\t<enum name=\"uri\">\n\t\t\t\t\t\t<para>URI parameter.</para>\n\t\t\t\t\t</enum>\n\t\t\t\t</enumlist>\n\t\t\t</parameter>\n\t\t\t<parameter name=\"parameter_name\" required=\"true\">\n\t\t\t\t<para>Name of parameter.</para>\n\t\t\t</parameter>\n\t\t</syntax>\n\t\t<description>\n\t\t\t<para>PJSIP_HEADER_PARAM allows you to read or set parameters in a SIP header on a\n\t\t\tPJSIP channel.</para>\n\t\t\t<para>Both URI parameters and header parameters can be read and set using\n\t\t\tthis function. URI parameters appear in the URI (inside the &lt;&gt; in the header)\n\t\t\twhile header parameters appear afterwards.</para>\n\t\t\t<note><para>If you call PJSIP_HEADER_PARAM in a normal dialplan context you'll be\n\t\t\toperating on the <emphasis>caller's (incoming)</emphasis> channel which\n\t\t\tmay not be what you want. To operate on the <emphasis>callee's (outgoing)</emphasis>\n\t\t\tchannel call PJSIP_HEADER_PARAM in a pre-dial handler. </para></note>\n\t\t\t<example title=\"Set URI parameter in From header on outbound channel\">\n\t\t\t[handler]\n\t\t\texten => addheader,1,Set(PJSIP_HEADER_PARAM(From,uri,isup-oli)=27)\n\t\t\tsame => n,Return()\n\t\t\t[somecontext]\n\t\t\texten => 1,1,Dial(PJSIP/${EXTEN},,b(handler^addheader^1))\n\t\t\t</example>\n\t\t\t<example title=\"Read URI parameter in From header on inbound channel\">\n\t\t\tsame => n,Set(value=${PJSIP_HEADER_PARAM(From,uri,isup-oli)})\n\t\t\t</example>\n\t\t</description>\n\t</function>\n ***/\n\n/*! \\brief Linked list for accumulating headers */\nstruct hdr_list_entry {\n\tpjsip_hdr *hdr;\n\tAST_LIST_ENTRY(hdr_list_entry) nextptr;\n};\nAST_LIST_HEAD_NOLOCK(hdr_list, hdr_list_entry);\n\n/*! \\brief Datastore for saving headers */\nstatic const struct ast_datastore_info header_datastore = {\n\t.type = \"header_datastore\",\n};\n/*! \\brief Datastore for saving response headers */\nstatic const struct ast_datastore_info response_header_datastore = {\n\t.type = \"response_header_datastore\",\n};\n\n/*! \\brief Data structure used for ast_sip_push_task_wait_serializer  */\nstruct header_data {\n\tstruct ast_sip_channel_pvt *channel;\n\tchar *header_name;\n\tconst char *header_value;\n\tchar *buf;\n\tint header_number;\n\tsize_t len;\n\tconst struct ast_datastore_info *header_datastore;\n};\n\n/*!\n * \\internal\n * \\brief Insert the header pointers into the linked list.\n *\n * For each header in the message, allocate a list entry,\n * clone the header, then insert the entry.\n */\nstatic int insert_headers(pj_pool_t * pool, struct hdr_list *list, pjsip_msg * msg)\n{\n\tpjsip_hdr *hdr = msg->hdr.next;\n\tstruct hdr_list_entry *le;\n\n\twhile (hdr && hdr != &msg->hdr) {\n\t\tle = pj_pool_zalloc(pool, sizeof(struct hdr_list_entry));\n\t\tle->hdr = pjsip_hdr_clone(pool, hdr);\n\t\tAST_LIST_INSERT_TAIL(list, le, nextptr);\n\t\thdr = hdr->next;\n\t}\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Session supplement callback on an incoming INVITE request\n *\n * Retrieve the header_datastore from the session or create one if it doesn't exist.\n * Create and initialize the list if needed.\n * Insert the headers.\n */\nstatic int incoming_request(struct ast_sip_session *session, pjsip_rx_data * rdata)\n{\n\tpj_pool_t *pool = session->inv_session->dlg->pool;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(session, header_datastore.type), ao2_cleanup);\n\n\tif (!datastore) {\n\t\tif (!(datastore =\n\t\t\t  ast_sip_session_alloc_datastore(&header_datastore, header_datastore.type))\n\t\t\t||\n\t\t\t!(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list))) ||\n\t\t\tast_sip_session_add_datastore(session, datastore)) {\n\t\t\tast_log(AST_LOG_ERROR, \"Unable to create datastore for header functions.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tAST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);\n\t}\n\tinsert_headers(pool, (struct hdr_list *) datastore->data, rdata->msg_info.msg);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Session supplement callback on an incoming INVITE response\n *\n * Retrieve the response_header_datastore from the session or create one if it doesn't exist.\n * Create and initialize the list if needed.\n * Insert the headers.\n */\nstatic void incoming_response(struct ast_sip_session *session, pjsip_rx_data * rdata)\n{\n\tpj_pool_t *pool = session->inv_session->dlg->pool;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(session, response_header_datastore.type), ao2_cleanup);\n\tpjsip_status_line status = rdata->msg_info.msg->line.status;\n\n\t/* Skip responses different of 200 OK, when 2xx is received. */\n\tif (session->inv_session->state != PJSIP_INV_STATE_CONNECTING || status.code!=200) {\n\t\treturn;\n\t}\n\n\tif (!datastore) {\n\t\tif (!(datastore =\n\t\t\t  ast_sip_session_alloc_datastore(&response_header_datastore, response_header_datastore.type))\n\t\t\t||\n\t\t\t!(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list))) ||\n\t\t\tast_sip_session_add_datastore(session, datastore)) {\n\t\t\tast_log(AST_LOG_ERROR, \"Unable to create datastore for header functions.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tAST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);\n\t}\n\tinsert_headers(pool, (struct hdr_list *) datastore->data, rdata->msg_info.msg);\n\n\treturn;\n}\n\n/*!\n * \\internal\n * \\brief Search list for nth occurrence of specific header.\n */\nstatic pjsip_hdr *find_header(struct hdr_list *list, const char *header_name,\n\t\t\t\t\t\t\t  int header_number)\n{\n\tstruct hdr_list_entry *le;\n\tpjsip_hdr *hdr = NULL;\n\tint i = 1;\n\n\tif (!list || ast_strlen_zero(header_name) || header_number < 1) {\n\t\treturn NULL;\n\t}\n\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tif (pj_stricmp2(&le->hdr->name, header_name) == 0 && i++ == header_number) {\n\t\t\thdr = le->hdr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hdr;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADERS/PJSIP_RESPONSE_HEADERS by searching for the requested header prefix.\n *\n * Retrieve the header_datastore.\n * Search for the all matching headers.\n * Validate the pjsip_hdr found.\n * Parse pjsip_hdr into a name and copy to the buffer.\n * Return the value.\n */\nstatic int read_headers(void *obj)\n{\n\tstruct header_data *data = obj;\n\tsize_t len = !ast_strlen_zero(data->header_name) ? strlen(data->header_name) : 0;\n\tpjsip_hdr *hdr = NULL;\n\tchar *pj_hdr_string;\n\tint pj_hdr_string_len;\n\tchar *p;\n\tchar *pos;\n\tsize_t plen, wlen = 0;\n\tstruct hdr_list_entry *le;\n\tstruct hdr_list *list;\n\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_debug(1, \"There was no datastore from which to read headers.\\n\");\n\t\treturn -1;\n\t}\n\n\tlist = datastore->data;\n\tpj_hdr_string = ast_alloca(data->len);\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tif (!len || pj_strnicmp2(&le->hdr->name, data->header_name, len) == 0) {\n\t\t\t/* Found matched header, append to buf */\n\t\t\thdr = le->hdr;\n\n\t\t\tpj_hdr_string_len = pjsip_hdr_print_on(hdr, pj_hdr_string, data->len - 1);\n\t\t\tif (pj_hdr_string_len == -1) {\n\t\t\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\t\"Not enough buffer space in pjsip_hdr_print_on\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpj_hdr_string[pj_hdr_string_len] = '\\0';\n\t\t\tp = strchr(pj_hdr_string, ':');\n\t\t\tif (!p) {\n\t\t\t\tast_log(AST_LOG_WARNING,\n\t\t\t\t\t\"A malformed header was returned from pjsip_hdr_print_on\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpj_hdr_string[p - pj_hdr_string] = '\\0';\n\t\t\tp = ast_strip(pj_hdr_string);\n\t\t\tplen = strlen(p);\n\t\t\tif (wlen + plen + 1 > data->len) {\n\t\t\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\t\t\"Buffer isn't big enough to hold header value.  %zu > %zu\\n\", plen + 1,\n\t\t\t\t\t\tdata->len);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpos = strstr(data->buf, p);\n\t\t\tif (pos && pos[1] == ',') {\n\t\t\t\tif (pos == data->buf) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (pos[-1] == ',') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_copy_string(data->buf + wlen, p, data->len - wlen);\n\t\t\twlen += plen;\n\t\t\tast_copy_string(data->buf + wlen, \",\", data->len - wlen);\n\t\t\twlen++;\n\t\t}\n\t}\n\n\tif (wlen == 0) {\n\t\tif (!len) {\n\t\t\t/* No headers at all on this channel */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tast_debug(1, \"There was no header beginning with %s.\\n\", data->header_name);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tdata->buf[wlen-1] = '\\0';\n\t}\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER/PJSIP_RESPONSE_HEADER 'read' by searching the for the requested header.\n *\n * Retrieve the header_datastore.\n * Search for the nth matching header.\n * Validate the pjsip_hdr found.\n * Parse pjsip_hdr into a name and value.\n * Return the value.\n */\nstatic int read_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tsize_t len = strlen(data->header_name);\n\tpjsip_hdr *hdr = NULL;\n\tchar *pj_hdr_string;\n\tint pj_hdr_string_len;\n\tchar *p;\n\tsize_t plen;\n\tstruct hdr_list_entry *le;\n\tstruct hdr_list *list;\n\tint i = 1;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_debug(1, \"There was no datastore from which to read headers.\\n\");\n\t\treturn -1;\n\t}\n\n\tlist = datastore->data;\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tif (data->header_name[len - 1] == '*') {\n\t\t\tif (pj_strnicmp2(&le->hdr->name, data->header_name, len - 1) == 0 && i++ == data->header_number) {\n\t\t\t\thdr = le->hdr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pj_stricmp2(&le->hdr->name, data->header_name) == 0 && i++ == data->header_number) {\n\t\t\t\thdr = le->hdr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!hdr) {\n\t\tast_debug(1, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\n\tpj_hdr_string = ast_alloca(data->len);\n\tpj_hdr_string_len = pjsip_hdr_print_on(hdr, pj_hdr_string, data->len - 1);\n\tif (pj_hdr_string_len == -1) {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\"Not enough buffer space in pjsip_hdr_print_on\\n\");\n\t\treturn -1;\n\t}\n\n\tpj_hdr_string[pj_hdr_string_len] = '\\0';\n\n\tp = strchr(pj_hdr_string, ':');\n\tif (!p) {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"A malformed header was returned from pjsip_hdr_print_on.\\n\");\n\t\treturn -1;\n\t}\n\n\t++p;\n\tp = ast_strip(p);\n\tplen = strlen(p);\n\tif (plen + 1 > data->len) {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"Buffer isn't big enough to hold header value.  %zu > %zu\\n\", plen + 1,\n\t\t\t\tdata->len);\n\t\treturn -1;\n\t}\n\n\tast_copy_string(data->buf, p, data->len);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER 'add' by inserting the specified header into the list.\n *\n * Retrieve the header_datastore from the session or create one if it doesn't exist.\n * Create and initialize the list if needed.\n * Create the pj_strs for name and value.\n * Create pjsip_msg and hdr_list_entry.\n * Add the entry to the list.\n */\nstatic int add_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tstruct ast_sip_session *session = data->channel->session;\n\tpj_pool_t *pool = session->inv_session->dlg->pool;\n\tpj_str_t pj_header_name;\n\tpj_str_t pj_header_value;\n\tstruct hdr_list_entry *le;\n\tstruct hdr_list *list;\n\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(session, data->header_datastore->type), ao2_cleanup);\n\n\tif (!datastore) {\n\t\tif (!(datastore = ast_sip_session_alloc_datastore(data->header_datastore,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata->header_datastore->type))\n\t\t\t|| !(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list)))\n\t\t\t|| ast_sip_session_add_datastore(session, datastore)) {\n\t\t\tast_log(AST_LOG_ERROR, \"Unable to create datastore for header functions.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tAST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);\n\t}\n\n\tast_debug(1, \"Adding header %s with value %s\\n\", data->header_name,\n\t\t\t  data->header_value);\n\n\tpj_cstr(&pj_header_name, data->header_name);\n\tpj_cstr(&pj_header_value, data->header_value);\n\tle = pj_pool_zalloc(pool, sizeof(struct hdr_list_entry));\n\tle->hdr = (pjsip_hdr *) pjsip_generic_string_hdr_create(pool, &pj_header_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&pj_header_value);\n\tlist = datastore->data;\n\n\tAST_LIST_INSERT_TAIL(list, le, nextptr);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER 'update' by finding the specified header and updating it.\n *\n * Retrieve the header_datastore from the session or create one if it doesn't exist.\n * Create and initialize the list if needed.\n * Create the pj_strs for name and value.\n * Create pjsip_msg and hdr_list_entry.\n * Add the entry to the list.\n */\nstatic int update_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tpj_pool_t *pool = data->channel->session->inv_session->dlg->pool;\n\tpjsip_hdr *hdr = NULL;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\n\thdr = find_header((struct hdr_list *) datastore->data, data->header_name,\n\t\t\t\t\t  data->header_number);\n\n\tif (!hdr) {\n\t\tast_log(AST_LOG_ERROR, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\n\tpj_strdup2(pool, &((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER 'remove' by finding the specified header and removing it.\n *\n * Retrieve the header_datastore from the session.  Fail if it doesn't exist.\n * If the header_name is exactly '*', the entire list is simply destroyed.\n * Otherwise search the list for the matching header name which may be a partial name.\n */\nstatic int remove_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tsize_t len = strlen(data->header_name);\n\tstruct hdr_list *list;\n\tstruct hdr_list_entry *le;\n\tint removed_count = 0;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\n\tlist = datastore->data;\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(list, le, nextptr) {\n\t\tif (data->header_name[len - 1] == '*') {\n\t\t\tif (pj_strnicmp2(&le->hdr->name, data->header_name, len - 1) == 0) {\n\t\t\t\tAST_LIST_REMOVE_CURRENT(nextptr);\n\t\t\t\tremoved_count++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pj_stricmp2(&le->hdr->name, data->header_name) == 0) {\n\t\t\t\tAST_LIST_REMOVE_CURRENT(nextptr);\n\t\t\t\tremoved_count++;\n\t\t\t}\n\t\t}\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\n\tif (data->buf && data->len) {\n\t\tsnprintf(data->buf, data->len, \"%d\", removed_count);\n\t}\n\n\treturn 0;\n}\n\n/*!\n * \\brief Read list of unique SIP headers\n */\nstatic int func_read_headers(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(header_pattern);\n\t);\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!chan || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_pattern;\n\theader_data.header_value = NULL;\n\theader_data.buf = buf;\n\theader_data.len = len;\n\theader_data.header_datastore = &header_datastore;\n\n\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_headers, &header_data);\n\n}\n\n/*!\n * \\brief Read list of unique SIP response headers\n */\nstatic int func_response_read_headers(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(header_pattern);\n\t);\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!chan || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ast_strlen_zero(args.header_pattern)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a pattern.\\n\");\n\t\treturn -1;\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_pattern;\n\theader_data.header_value = NULL;\n\theader_data.buf = buf;\n\theader_data.len = len;\n\theader_data.header_datastore = &response_header_datastore;\n\n\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_headers, &header_data);\n\n}\n\n/*!\n * \\brief Implements PJSIP_HEADER function 'read' callback.\n *\n * Valid actions are 'read' and 'remove'.\n */\nstatic int func_read_header(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tint number;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t\t\t\t AST_APP_ARG(action);\n\t\t\t\t\t\t AST_APP_ARG(header_name); AST_APP_ARG(header_number););\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ast_strlen_zero(args.action)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires an action.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.header_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a header name.\\n\");\n\t\treturn -1;\n\t}\n\tif (!args.header_number) {\n\t\tnumber = 1;\n\t} else {\n\t\tsscanf(args.header_number, \"%30d\", &number);\n\t\tif (number < 1) {\n\t\t\tnumber = 1;\n\t\t}\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_name;\n\theader_data.header_number = number;\n\theader_data.header_value = NULL;\n\theader_data.buf = buf;\n\theader_data.len = len;\n\theader_data.header_datastore = &header_datastore;\n\n\tif (!strcasecmp(args.action, \"read\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_header, &header_data);\n\t} else if (!strcasecmp(args.action, \"remove\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer,\n\t\t\tremove_header, &header_data);\n\t} else {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"Unknown action '%s' is not valid, must be 'read' or 'remove'.\\n\",\n\t\t\t\targs.action);\n\t\treturn -1;\n\t}\n}\n\n/*!\n * \\brief Implements PJSIP_RESPONSE_HEADER function 'read' callback.\n *\n * Valid actions are 'read'\n */\nstatic int func_response_read_header(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tint number;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t\t\t\t AST_APP_ARG(action);\n\t\t\t\t\t\t AST_APP_ARG(header_name); AST_APP_ARG(header_number););\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ast_strlen_zero(args.action)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires an action.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.header_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a header name.\\n\");\n\t\treturn -1;\n\t}\n\tif (!args.header_number) {\n\t\tnumber = 1;\n\t} else {\n\t\tsscanf(args.header_number, \"%30d\", &number);\n\t\tif (number < 1) {\n\t\t\tnumber = 1;\n\t\t}\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_name;\n\theader_data.header_number = number;\n\theader_data.header_value = NULL;\n\theader_data.buf = buf;\n\theader_data.len = len;\n\theader_data.header_datastore = &response_header_datastore;\n\n\tif (!strcasecmp(args.action, \"read\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_header, &header_data);\n\t} else {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"Unknown action '%s' is not valid, must be 'read'.\\n\",\n\t\t\t\targs.action);\n\t\treturn -1;\n\t}\n}\n\n/*!\n * \\brief Implements PJSIP_HEADER function 'write' callback.\n *\n * Valid actions are 'add', 'update' and 'remove'.\n */\nstatic int func_write_header(struct ast_channel *chan, const char *cmd, char *data,\n\t\t\t\t\t\t\t const char *value)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct header_data header_data;\n\tint header_number;\n\tAST_DECLARE_APP_ARGS(args,\n\t\t\t\t\t\t AST_APP_ARG(action);\n\t\t\t\t\t\t AST_APP_ARG(header_name); AST_APP_ARG(header_number););\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ast_strlen_zero(args.action)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires an action.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.header_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a header name.\\n\");\n\t\treturn -1;\n\t}\n\tif (!args.header_number) {\n\t\theader_number = 1;\n\t} else {\n\t\tsscanf(args.header_number, \"%30d\", &header_number);\n\t\tif (header_number < 1) {\n\t\t\theader_number = 1;\n\t\t}\n\t}\n\n\theader_data.channel = channel;\n\theader_data.header_name = args.header_name;\n\theader_data.header_number = header_number;\n\theader_data.header_value = value;\n\theader_data.buf = NULL;\n\theader_data.len = 0;\n\theader_data.header_datastore = &header_datastore;\n\n\tif (!strcasecmp(args.action, \"add\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer,\n\t\t\tadd_header, &header_data);\n\t} else if (!strcasecmp(args.action, \"update\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer,\n\t\t\tupdate_header, &header_data);\n\t} else if (!strcasecmp(args.action, \"remove\")) {\n\t\treturn ast_sip_push_task_wait_serializer(channel->session->serializer,\n\t\t\tremove_header, &header_data);\n\t} else {\n\t\tast_log(AST_LOG_ERROR,\n\t\t\t\t\"Unknown action '%s' is not valid, must be 'add', 'update', or 'remove'.\\n\",\n\t\t\t\targs.action);\n\t\treturn -1;\n\t}\n}\n\nstatic struct ast_custom_function pjsip_header_function = {\n\t.name = \"PJSIP_HEADER\",\n\t.read = func_read_header,\n\t.write = func_write_header,\n};\n\nstatic struct ast_custom_function pjsip_headers_function = {\n\t.name = \"PJSIP_HEADERS\",\n\t.read = func_read_headers\n};\n\nstatic struct ast_custom_function pjsip_response_header_function = {\n\t.name = \"PJSIP_RESPONSE_HEADER\",\n\t.read = func_response_read_header\n};\n\nstatic struct ast_custom_function pjsip_response_headers_function = {\n\t.name = \"PJSIP_RESPONSE_HEADERS\",\n\t.read = func_response_read_headers\n};\n\n/*!\n * \\internal\n * \\brief Session supplement callback for outgoing INVITE requests\n *\n * Retrieve the header_datastore from the session.\n * Add each header in the list to the outgoing message.\n *\n * These pjsip_hdr structures will have been created by add_header.\n * Because outgoing_request may be called more than once with the same header\n * list (as in the case of an authentication exchange), each pjsip_hdr structure\n * MUST be newly cloned for each outgoing message.\n */\nstatic void outgoing_request(struct ast_sip_session *session, pjsip_tx_data * tdata)\n{\n\tstruct hdr_list *list;\n\tstruct hdr_list_entry *le;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(session, header_datastore.type), ao2_cleanup);\n\n\tif (!datastore || !datastore->data ||\n\t\t(session->inv_session->state >= PJSIP_INV_STATE_CONFIRMED)) {\n\t\treturn;\n\t}\n\n\tlist = datastore->data;\n\tAST_LIST_TRAVERSE(list, le, nextptr) {\n\t\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr *) pjsip_hdr_clone(tdata->pool, le->hdr));\n\t}\n\tast_sip_session_remove_datastore(session, datastore->uid);\n}\n\nstatic struct ast_sip_session_supplement header_funcs_supplement = {\n\t.method = \"INVITE\",\n\t.priority = AST_SIP_SUPPLEMENT_PRIORITY_CHANNEL - 1000,\n\t.incoming_request = incoming_request,\n\t.outgoing_request = outgoing_request,\n\t.incoming_response = incoming_response,\n};\n\nenum param_type {\n\tPARAMETER_HEADER,\n\tPARAMETER_URI,\n};\n\nstruct param_data {\n\tstruct ast_sip_channel_pvt *channel;\n\tchar *header_name;\n\tchar *param_name;\n\tconst char *param_value; /* Only used for write */\n\tenum param_type paramtype;\n\t/* For read function only */\n\tchar *buf;\n\tsize_t len;\n};\n\nstatic int read_param(void *obj)\n{\n\tstruct param_data *data = obj;\n\tstruct ast_sip_session *session = data->channel->session;\n\tpj_str_t param_name;\n\n\tpjsip_fromto_hdr *dlg_info;\n\tpjsip_name_addr *dlg_info_name_addr;\n\tpjsip_sip_uri *dlg_info_uri;\n\tpjsip_param *param;\n\tsize_t param_len;\n\n\tdlg_info = session->inv_session->dlg->remote.info; /* Remote dialog for incoming */\n\tdlg_info_name_addr = (pjsip_name_addr *) dlg_info->uri;\n\tdlg_info_uri = pjsip_uri_get_uri(dlg_info_name_addr);\n\n\tpj_cstr(&param_name, data->param_name);\n\n\tif (data->paramtype == PARAMETER_URI) { /* URI parameter */\n\t\tparam = pjsip_param_find(&dlg_info_uri->other_param, &param_name);\n\t} else { /* Header parameter */\n\t\tparam = pjsip_param_find(&dlg_info->other_param, &param_name);\n\t}\n\n\tif (!param) {\n\t\tast_debug(1, \"No %s parameter found named %s\\n\",\n\t\t\tdata->paramtype == PARAMETER_URI ? \"URI\" : \"header\", data->param_name);\n\t\treturn -1;\n\t}\n\n\tparam_len = pj_strlen(&param->value);\n\tif (param_len >= data->len) {\n\t\tast_log(LOG_ERROR, \"Buffer is too small for parameter value (%zu > %zu)\\n\", param_len, data->len);\n\t\treturn -1;\n\t}\n\n\tast_debug(2, \"Successfully read %s parameter %s (length %zu)\\n\",\n\t\tdata->paramtype == PARAMETER_URI ? \"URI\" : \"header\", data->param_name, param_len);\n\tif (param_len) {\n\t\tast_copy_string(data->buf, pj_strbuf(&param->value), data->len);\n\t}\n\tdata->buf[param_len] = '\\0';\n\n\treturn 0;\n}\n\n/*!\n * \\internal\n * \\brief Implements PJSIP_HEADER_PARAM 'add' by adding the specified parameter.\n * \\note Unlike add_header, we can't add parameters in the outgoing_request callback: that's too late.\n *       That's why we do it here and not in a callback.\n */\nstatic int add_param(void *obj)\n{\n\tstruct param_data *data = obj;\n\tstruct ast_sip_session *session = data->channel->session;\n\tpj_pool_t *pool = session->inv_session->dlg->pool;\n\n\tpjsip_fromto_hdr *dlg_info;\n\tpjsip_name_addr *dlg_info_name_addr;\n\tpjsip_sip_uri *dlg_info_uri;\n\n\tdlg_info = session->inv_session->dlg->local.info; /* Local for outgoing */\n\tdlg_info_name_addr = (pjsip_name_addr *) dlg_info->uri;\n\tdlg_info_uri = pjsip_uri_get_uri(dlg_info_name_addr);\n\tif (!PJSIP_URI_SCHEME_IS_SIP(dlg_info_uri) && !PJSIP_URI_SCHEME_IS_SIPS(dlg_info_uri)) {\n\t\tast_log(LOG_WARNING, \"Non SIP/SIPS URI\\n\");\n\t\treturn -1;\n\t}\n\n\tast_debug(1, \"Adding custom %s param %s = %s\\n\",\n\t\tdata->paramtype == PARAMETER_URI ? \"URI\" : \"header\", data->param_name, data->param_value);\n\n\t/* This works the same as doing this in set_from_header in res_pjsip_session.c\n\t * The way that this maps to pjproject is a little confusing.\n\t * Say we have <sip:foo@bar.com;p1=abc;p2=def?h1=qrs&h2=tuv>;o1=foo;o2=bar\n\t * p1 and p2 are URI parameters.\n\t * (h1 and h2 are URI headers)\n\t * o1 and o2 are header parameters (and don't have anything to do with the URI)\n\t * In pjproject, other_param is used for adding all custom parameters.\n\t * We use the URI for URI stuff, including URI parameters, and the header directly for header parameters.\n\t */\n\n#define param_add(pool, list, pname, pvalue) { \\\n\tpjsip_param *param; \\\n\tparam = PJ_POOL_ALLOC_T(pool, pjsip_param); \\\n\tpj_strdup2(pool, &param->name, pname); \\\n\tpj_strdup2(pool, &param->value, pvalue); \\\n\tpj_list_insert_before(list, param); \\\n}\n\n\tif (data->paramtype == PARAMETER_URI) { /* URI parameter */\n\t\tparam_add(pool, &dlg_info_uri->other_param, data->param_name, S_OR(data->param_value, \"\"));\n\t} else { /* Header parameter */\n\t\tparam_add(pool, &dlg_info->other_param, data->param_name, S_OR(data->param_value, \"\"));\n\t}\n\n\treturn 0;\n}\n\nstatic int func_read_param(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct param_data param_data;\n\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(header_name);\n\t\tAST_APP_ARG(param_type);\n\t\tAST_APP_ARG(param_name);\n\t);\n\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tparam_data.channel = channel;\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.param_type)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a parameter type.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.param_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a parameter name.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Currently, only From is supported, but this could be extended in the future. */\n\tif (ast_strlen_zero(args.header_name) || strcasecmp(args.header_name, \"From\")) {\n\t\tast_log(LOG_WARNING, \"Only the From header is currently supported\\n\");\n\t\treturn -1;\n\t}\n\n\tparam_data.param_name = args.param_name;\n\tif (!strcasecmp(args.param_type, \"header\")) {\n\t\tparam_data.paramtype = PARAMETER_HEADER;\n\t} else if (!strcasecmp(args.param_type, \"uri\")) {\n\t\tparam_data.paramtype = PARAMETER_URI;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Parameter type '%s' is invalid: must be 'header' or 'uri'\\n\", args.param_type);\n\t\treturn -1;\n\t}\n\n\tparam_data.buf = buf;\n\tparam_data.len = len;\n\n\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, read_param, &param_data);\n}\n\nstatic int func_write_param(struct ast_channel *chan, const char *cmd, char *data, const char *value)\n{\n\tstruct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;\n\tstruct param_data param_data;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(header_name);\n\t\tAST_APP_ARG(param_type);\n\t\tAST_APP_ARG(param_name);\n\t);\n\n\tAST_STANDARD_APP_ARGS(args, data);\n\n\tparam_data.channel = channel;\n\n\tif (!channel || strncmp(ast_channel_name(chan), \"PJSIP/\", 6)) {\n\t\tast_log(LOG_ERROR, \"This function requires a PJSIP channel.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.param_type)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a parameter type.\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_strlen_zero(args.param_name)) {\n\t\tast_log(AST_LOG_ERROR, \"This function requires a parameter name.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Currently, only From is supported, but this could be extended in the future. */\n\tif (ast_strlen_zero(args.header_name) || strcasecmp(args.header_name, \"From\")) {\n\t\tast_log(LOG_WARNING, \"Only the From header is currently supported\\n\");\n\t\treturn -1;\n\t}\n\n\tparam_data.param_name = args.param_name;\n\tif (!strcasecmp(args.param_type, \"header\")) {\n\t\tparam_data.paramtype = PARAMETER_HEADER;\n\t} else if (!strcasecmp(args.param_type, \"uri\")) {\n\t\tparam_data.paramtype = PARAMETER_URI;\n\t} else {\n\t\tast_log(LOG_WARNING, \"Parameter type '%s' is invalid: must be 'header' or 'uri'\\n\", args.param_type);\n\t\treturn -1;\n\t}\n\tparam_data.param_value = value;\n\n\treturn ast_sip_push_task_wait_serializer(channel->session->serializer, add_param, &param_data);\n}\n\nstatic struct ast_custom_function pjsip_header_param_function = {\n\t.name = \"PJSIP_HEADER_PARAM\",\n\t.read = func_read_param,\n\t.write = func_write_param,\n};\n\nstatic int load_module(void)\n{\n\tast_sip_session_register_supplement(&header_funcs_supplement);\n\tast_custom_function_register(&pjsip_header_function);\n\tast_custom_function_register(&pjsip_headers_function);\n\tast_custom_function_register(&pjsip_response_header_function);\n\tast_custom_function_register(&pjsip_response_headers_function);\n\tast_custom_function_register(&pjsip_header_param_function);\n\n\treturn AST_MODULE_LOAD_SUCCESS;\n}\n\nstatic int unload_module(void)\n{\n\tast_custom_function_unregister(&pjsip_header_function);\n\tast_custom_function_unregister(&pjsip_headers_function);\n\tast_custom_function_unregister(&pjsip_response_header_function);\n\tast_custom_function_unregister(&pjsip_response_headers_function);\n\tast_custom_function_unregister(&pjsip_header_param_function);\n\tast_sip_session_unregister_supplement(&header_funcs_supplement);\n\treturn 0;\n}\n\nAST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, \"PJSIP Header Functions\",\n\t.support_level = AST_MODULE_SUPPORT_CORE,\n\t.load = load_module,\n\t.unload = unload_module,\n\t.load_pri = AST_MODPRI_APP_DEPEND,\n\t.requires = \"res_pjsip,res_pjsip_session\",\n);\n"], "filenames": ["res/res_pjsip_header_funcs.c"], "buggy_code_start_loc": [678], "buggy_code_end_loc": [698], "fixing_code_start_loc": [679], "fixing_code_end_loc": [699], "type": "CWE-120", "message": "Asterisk is an open source private branch exchange and telephony toolkit. In Asterisk versions 18.20.0 and prior, 20.5.0 and prior, and 21.0.0; as well as ceritifed-asterisk 18.9-cert5 and prior, the 'update' functionality of the PJSIP_HEADER dialplan function can exceed the available buffer space for storing the new value of a header. By doing so this can overwrite memory or cause a crash. This is not externally exploitable, unless dialplan is explicitly written to update a header based on data from an outside source. If the 'update' functionality is not used the vulnerability does not occur. A patch is available at commit a1ca0268254374b515fa5992f01340f7717113fa.", "other": {"cve": {"id": "CVE-2023-37457", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-14T20:15:52.260", "lastModified": "2023-12-29T00:15:49.697", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Asterisk is an open source private branch exchange and telephony toolkit. In Asterisk versions 18.20.0 and prior, 20.5.0 and prior, and 21.0.0; as well as ceritifed-asterisk 18.9-cert5 and prior, the 'update' functionality of the PJSIP_HEADER dialplan function can exceed the available buffer space for storing the new value of a header. By doing so this can overwrite memory or cause a crash. This is not externally exploitable, unless dialplan is explicitly written to update a header based on data from an outside source. If the 'update' functionality is not used the vulnerability does not occur. A patch is available at commit a1ca0268254374b515fa5992f01340f7717113fa."}, {"lang": "es", "value": "Asterisk es un conjunto de herramientas de telefon\u00eda y centralita privada de c\u00f3digo abierto. En las versiones de Asterisk 18.20.0 y anteriores, 20.5.0 y anteriores y 21.0.0; as\u00ed como ceritifed-asterisk 18.9-cert5 y anteriores, la funcionalidad de 'actualizaci\u00f3n' de la funci\u00f3n de dialplan PJSIP_HEADER puede exceder el espacio de b\u00fafer disponible para almacenar el nuevo valor de un encabezado. Al hacerlo, esto puede sobrescribir la memoria o provocar un bloqueo. Esto no se puede explotar externamente, a menos que el dialplan est\u00e9 escrito expl\u00edcitamente para actualizar un encabezado en funci\u00f3n de datos de una fuente externa. Si no se utiliza la funcionalidad de 'actualizaci\u00f3n', la vulnerabilidad no se produce. Hay un parche disponible en el commit a1ca0268254374b515fa5992f01340f7717113fa."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:*:*:*:*:*:*:*:*", "versionEndIncluding": "18.20.0", "matchCriteriaId": "2AD913C8-79A0-4FE9-9BBD-52BD3260AB2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "19.0.0", "versionEndIncluding": "20.5.0", "matchCriteriaId": "DA2E162A-E994-4F25-AE13-D7C889394AC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:digium:asterisk:21.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D3E690E3-3E92-42ED-87DD-1C6B838A3FF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:*:*:*:*:*:*:*", "matchCriteriaId": "2AFE2011-05AA-45A6-A561-65C6C664DA7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "C1117AA4-CE6B-479B-9995-A9F71C430663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc1:*:*:*:*:*:*", "matchCriteriaId": "775041BD-5C86-42B6-8B34-E1D5171B3D87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc2:*:*:*:*:*:*", "matchCriteriaId": "55EC2877-2FF5-4777-B118-E764A94BCE56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc3:*:*:*:*:*:*", "matchCriteriaId": "EB0392C9-A5E9-4D71-8B8D-63FB96E055A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert1-rc4:*:*:*:*:*:*", "matchCriteriaId": "09AF962D-D4BB-40BA-B435-A59E4402931C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "559D1063-7F37-44F8-B5C6-94758B675FDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "185B2B4B-B246-4379-906B-9BDA7CDD4400"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "73D3592D-3CE5-4462-9FE8-4BCB54E74B5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:13.13.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B3CCE9E0-5DC4-43A2-96DB-9ABEA60EC157"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "1EAD713A-CBA2-40C3-9DE3-5366827F18C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "A5F5A8B7-29C9-403C-9561-7B3E96F9FCA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert10:*:*:*:*:*:*", "matchCriteriaId": "F9B96A53-2263-463C-9CCA-0F29865FE500"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert11:*:*:*:*:*:*", "matchCriteriaId": "A53049F1-8551-453E-834A-68826A7AA959"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert12:*:*:*:*:*:*", "matchCriteriaId": "B224A4E9-4B6B-4187-B0D6-E4BAE2637960"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "9501DBFF-516D-4F26-BBF6-1B453EE2A630"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "9D3E9AC0-C0B4-4E87-8D48-2B688D28B678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert4:*:*:*:*:*:*", "matchCriteriaId": "1A8628F6-F8D1-4C0C-BD89-8E2EEF19A5F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert5:*:*:*:*:*:*", "matchCriteriaId": "E27A6FD1-9321-4C9E-B32B-D6330CD3DC92"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert6:*:*:*:*:*:*", "matchCriteriaId": "B6BF5EDB-9D17-453D-A22E-FDDC4DCDD85B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert7:*:*:*:*:*:*", "matchCriteriaId": "4C75A21E-5D05-434B-93DE-8DAC4DD3E587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert8:*:*:*:*:*:*", "matchCriteriaId": "1D725758-C9F5-4DB2-8C45-CC052518D3FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:16.8.0:cert9:*:*:*:*:*:*", "matchCriteriaId": "B5E2AECC-B681-4EA5-9DE5-2086BB37A5F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert1:*:*:*:*:*:*", "matchCriteriaId": "79EEB5E5-B79E-454B-8DCD-3272BA337A9E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert2:*:*:*:*:*:*", "matchCriteriaId": "892BAE5D-A64E-4FE0-9A99-8C07F342A042"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert3:*:*:*:*:*:*", "matchCriteriaId": "1A716A45-7075-4CA6-9EF5-2DD088248A5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert4:*:*:*:*:*:*", "matchCriteriaId": "80EFA05B-E22D-49CE-BDD6-5C7123F1C12B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:certified_asterisk:18.9:cert5:*:*:*:*:*:*", "matchCriteriaId": "20FD475F-2B46-47C9-B535-1561E29CB7A1"}]}]}], "references": [{"url": "https://github.com/asterisk/asterisk/commit/a1ca0268254374b515fa5992f01340f7717113fa", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/asterisk/asterisk/security/advisories/GHSA-98rc-4j27-74hh", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/12/msg00019.html", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/asterisk/asterisk/commit/a1ca0268254374b515fa5992f01340f7717113fa"}}