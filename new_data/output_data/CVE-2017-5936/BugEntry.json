{"buggy_code": ["# Copyright 2011 Justin Santa Barbara\n# Copyright 2015 Canonical Ltd\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport socket\n\nfrom nova import exception\nfrom nova import i18n\nfrom nova.virt import configdrive\n\nfrom oslo_config import cfg\nfrom oslo_log import log as logging\nfrom oslo_utils import excutils\n\nfrom nova_lxd.nova.virt.lxd import session\nfrom nova_lxd.nova.virt.lxd import utils as container_dir\nfrom nova_lxd.nova.virt.lxd import vif\n\n_ = i18n._\n_LE = i18n._LE\n_LI = i18n._LI\n\nCONF = cfg.CONF\nCONF.import_opt('my_ip', 'nova.netconf')\nLOG = logging.getLogger(__name__)\n\n\nclass LXDContainerConfig(object):\n    \"\"\"LXD configuration methods.\"\"\"\n\n    def __init__(self):\n        self.container_dir = container_dir.LXDContainerDirectories()\n        self.session = session.LXDAPISession()\n        self.vif_driver = vif.LXDGenericDriver()\n\n    def create_container(self, instance):\n        \"\"\"Create a LXD container dictionary so that we can\n           use it to initialize a container\n\n           :param instance: nova instance object\n        \"\"\"\n        LOG.debug('create_container called for instance', instance=instance)\n\n        instance_name = instance.name\n        try:\n\n            # Fetch the container configuration from the current nova\n            # instance object\n            container_config = {\n                'name': instance_name,\n                'profiles': [str(instance.name)],\n                'source': self.get_container_source(instance),\n                'devices': {}\n            }\n\n            # if a configdrive is required, setup the mount point for\n            # the container\n            if configdrive.required_by(instance):\n                configdrive_dir = \\\n                    self.container_dir.get_container_configdrive(\n                        instance.name)\n                config = self.configure_disk_path(configdrive_dir,\n                                                  'var/lib/cloud/data',\n                                                  'configdrive', instance)\n                container_config['devices'].update(config)\n\n            if container_config is None:\n                msg = _('Failed to get container configuration for %s') \\\n                    % instance_name\n                raise exception.NovaException(msg)\n            return container_config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error('Failed to get container configuration'\n                          ' %(instance)s: %(ex)s',\n                          {'instance': instance_name, 'ex': ex},\n                          instance=instance)\n\n    def create_profile(self, instance, network_info):\n        \"\"\"Create a LXD container profile configuration\n\n        :param instance: nova instance object\n        :param network_info: nova network configuration object\n        :return: LXD container profile dictionary\n        \"\"\"\n        LOG.debug('create_container_profile called for instance',\n                  instance=instance)\n        instance_name = instance.name\n        try:\n            config = {}\n            config['name'] = str(instance_name)\n            config['config'] = self.create_config(instance_name, instance)\n\n            # Restrict the size of the \"/\" disk\n            config['devices'] = self.configure_container_root(instance)\n\n            if network_info:\n                config['devices'].update(self.create_network(instance_name,\n                                                             instance,\n                                                             network_info))\n\n            return config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(\n                    _LE('Failed to create profile %(instance)s: %(ex)s'),\n                    {'instance': instance_name, 'ex': ex}, instance=instance)\n\n    def create_config(self, instance_name, instance):\n        \"\"\"Create the LXD container resources\n\n        :param instance_name: instance name\n        :param instance: nova instance object\n        :return: LXD resources dictionary\n        \"\"\"\n        LOG.debug('create_config called for instance', instance=instance)\n        try:\n            config = {}\n\n            # Update continaer options\n            config.update(self.config_instance_options(config, instance))\n\n            # Set the instance memory limit\n            mem = instance.memory_mb\n            if mem >= 0:\n                config['limits.memory'] = '%sMB' % mem\n\n            # Set the instance vcpu limit\n            vcpus = instance.flavor.vcpus\n            if vcpus >= 0:\n                config['limits.cpu'] = str(vcpus)\n\n            # Configure the console for the instance\n            config['raw.lxc'] = 'lxc.console.logfile=%s\\n' \\\n                % self.container_dir.get_console_path(instance_name)\n\n            return config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(\n                    _LE('Failed to set container resources %(instance)s: '\n                        '%(ex)s'), {'instance': instance_name, 'ex': ex},\n                    instance=instance)\n\n    def config_instance_options(self, config, instance):\n        LOG.debug('config_instance_options called for instance',\n                  instance=instance)\n\n        # Set the container to autostart when the host reboots\n        config['boot.autostart'] = 'True'\n\n        # Determine if we require a nested container\n        flavor = instance.flavor\n        lxd_nested_allowed = flavor.extra_specs.get(\n            'lxd:nested_allowed', False)\n        if lxd_nested_allowed:\n            config['security.nesting'] = 'True'\n\n        # Determine if we require a privileged container\n        lxd_privileged_allowed = flavor.extra_specs.get(\n            'lxd:privileged_allowed', False)\n        if lxd_privileged_allowed:\n            config['security.privileged'] = 'True'\n\n        lxd_isolated = flavor.extra_specs.get(\n            'lxd:isolated', False)\n        if lxd_isolated:\n            extensions = self.session.get_host_extensions()\n            if 'id_map' in extensions:\n                config['security.idmap.isolated'] = 'True'\n            else:\n                msg = _('Host does not support isolated instances')\n                raise exception.NovaException(msg)\n\n        return config\n\n    def configure_container_root(self, instance):\n        LOG.debug('configure_container_root called for instance',\n                  instance=instance)\n        try:\n            config = {}\n            lxd_config = self.session.get_host_config(instance)\n            if str(lxd_config['storage']) in ['btrfs', 'zfs']:\n                config['root'] = {'path': '/',\n                                  'type': 'disk',\n                                  'size': '%sGB' % str(instance.root_gb)}\n            else:\n                config['root'] = {'path': '/',\n                                  'type': 'disk'}\n            return config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_LE('Failed to configure disk for '\n                              '%(instance)s: %(ex)s'),\n                          {'instance': instance.name, 'ex': ex},\n                          instance=instance)\n\n    def create_network(self, instance_name, instance, network_info):\n        \"\"\"Create the LXD container network on the host\n\n        :param instance_name: nova instance name\n        :param instance: nova instance object\n        :param network_info: instance network configuration object\n        :return:network configuration dictionary\n        \"\"\"\n        LOG.debug('create_network called for instance', instance=instance)\n        try:\n            network_devices = {}\n\n            if not network_info:\n                return\n\n            for vifaddr in network_info:\n                cfg = self.vif_driver.get_config(instance, vifaddr)\n                network_devices[str(cfg['bridge'])] = \\\n                    {'nictype': 'bridged',\n                     'hwaddr': str(cfg['mac_address']),\n                     'parent': str(cfg['bridge']),\n                     'type': 'nic'}\n                return network_devices\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(\n                    _LE('Fail to configure network for %(instance)s: %(ex)s'),\n                    {'instance': instance_name, 'ex': ex}, instance=instance)\n\n    def get_container_source(self, instance):\n        \"\"\"Set the LXD container image for the instance.\n\n        :param instance: nova instance object\n        :return: the container source\n        \"\"\"\n        LOG.debug('get_container_source called for instance',\n                  instance=instance)\n        try:\n            container_source = {'type': 'image',\n                                'alias': str(instance.image_ref)}\n            if container_source is None:\n                msg = _('Failed to determine container source for %s') \\\n                    % instance.name\n                raise exception.NovaException(msg)\n            return container_source\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(\n                    _LE('Failed to configure container source '\n                        '%(instance)s: %(ex)s'),\n                    {'instance': instance.name, 'ex': ex},\n                    instance=instance)\n\n    def get_container_migrate(self, container_migrate, migration,\n                              host, instance):\n        LOG.debug('get_container_migrate called for instance',\n                  instance=instance)\n        try:\n            # Generate the container config\n            host = socket.gethostbyname(host)\n            container_metadata = container_migrate['metadata']\n            container_control = container_metadata['metadata']['control']\n            container_fs = container_metadata['metadata']['fs']\n\n            container_url = 'https://%s:8443%s' \\\n                % (host, container_migrate.get('operation'))\n\n            container_migrate = {\n                'base_image': '',\n                'mode': 'pull',\n                'certificate': str(self.session.host_certificate(instance,\n                                                                 host)),\n                'operation': str(container_url),\n                'secrets': {\n                        'control': str(container_control),\n                        'fs': str(container_fs)\n                },\n                'type': 'migration'\n            }\n\n            return container_migrate\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_LE('Failed to configure migation source '\n                              '%(instance)s: %(ex)s'),\n                          {'instance': instance.name, 'ex': ex},\n                          instance=instance)\n\n    def configure_disk_path(self, src_path, dest_path, vfs_type, instance):\n        \"\"\"Configure the host mount point for the LXD container\n\n        :param src_path: source path on the house\n        :param dest_path: destination path on the LXD container\n        :param vfs_type: dictionary identifier\n        :param instance: nova instance object\n        :return: container disk paths\n        \"\"\"\n        LOG.debug('configure_disk_path called for instance',\n                  instance=instance)\n        try:\n            config = {}\n            config[vfs_type] = {'path': dest_path,\n                                'source': src_path,\n                                'type': 'disk',\n                                'optional': 'True'}\n            return config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_LE('Failed to configure disk for '\n                              '%(instance)s: %(ex)s'),\n                          {'instance': instance.name, 'ex': ex},\n                          instance=instance)\n\n    def create_container_net_device(self, instance, vif):\n        \"\"\"Translate nova network object into a LXD interface\n\n        :param instance: nova instance object\n        :param vif: network instaance object\n        \"\"\"\n        LOG.debug('create_container_net_device called for instance',\n                  insance=instance)\n        try:\n            network_config = self.vif_driver.get_config(instance, vif)\n\n            config = {}\n            config[self.get_network_device(instance)] = {\n                'nictype': 'bridged',\n                'hwaddr': str(vif['address']),\n                'parent': str(network_config['bridge']),\n                'type': 'nic'}\n\n            return config\n        except Exception as ex:\n            LOG.error(_LE('Failed to configure network for '\n                          '%(instance)s: %(ex)s'),\n                      {'instance': instance.name, 'ex': ex},\n                      instance=instance)\n\n    def get_network_device(self, instance):\n        \"\"\"Try to detect which network interfaces are available in a contianer\n\n        :param instance: nova instance object\n        \"\"\"\n        LOG.debug('get_network_device called for instance', instance=instance)\n        data = self.session.container_info(instance)\n        lines = open('/proc/%s/net/dev' % data['init']).readlines()\n        interfaces = []\n        for line in lines[2:]:\n            if line.find(':') < 0:\n                continue\n            face, _ = line.split(':')\n            if 'eth' in face:\n                interfaces.append(face.strip())\n\n        if len(interfaces) == 1:\n            return 'eth1'\n        else:\n            return 'eth%s' % int(len(interfaces) - 1)\n", "[metadata]\nname = nova-lxd\nsummary = native lxd driver for openstack\ndescription-file =\n    README.md\nversion = 13.2.0\nauthor = OpenStack\nauthor-email = openstack-dev@lists.openstack.org\nhome-page = http://www.openstack.org/\nclassifier =\n    Environment :: OpenStack\n    Intended Audience :: Information Technology\n    Intended Audience :: System Administrators\n    License :: OSI Approved :: Apache Software License\n    Operating System :: POSIX :: Linux\n    Programming Language :: Python\n    Programming Language :: Python :: 2\n    Programming Language :: Python :: 2.7\n    Programming Language :: Python :: 2.6\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.3\n    Programming Language :: Python :: 3.4\n\n[files]\npackages =\n    nova_lxd\nnamespace_packages = \n\tnova_lxd\n\n[entry_points]\nconsole_scripts =\n   lxc-image-converter = nova_lxd.cmd.converter:main\n\n[build_sphinx]\nsource-dir = doc/source\nbuild-dir = doc/build\nall_files = 1\n\n[upload_sphinx]\nupload-dir = doc/build/html\n\n[compile_catalog]\ndirectory = nova_lxd/locale\ndomain = nova_lxd\n\n[update_catalog]\ndomain = nova_lxd\noutput_dir = nova_lxd/locale\ninput_file = nova_lxd/locale/nova_lxd.pot\n\n[extract_messages]\nkeywords = _ gettext ngettext l_ lazy_gettext\nmapping_file = babel.cfg\noutput_file = nova_lxd/locale/nova_lxd.pot\n"], "fixing_code": ["# Copyright 2011 Justin Santa Barbara\n# Copyright 2015 Canonical Ltd\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport socket\n\nfrom nova import exception\nfrom nova import i18n\nfrom nova.virt import configdrive\n\nfrom oslo_config import cfg\nfrom oslo_log import log as logging\nfrom oslo_utils import excutils\n\nfrom nova_lxd.nova.virt.lxd import session\nfrom nova_lxd.nova.virt.lxd import utils as container_dir\nfrom nova_lxd.nova.virt.lxd import vif\n\n_ = i18n._\n_LE = i18n._LE\n_LI = i18n._LI\n\nCONF = cfg.CONF\nCONF.import_opt('my_ip', 'nova.netconf')\nLOG = logging.getLogger(__name__)\n\n\nclass LXDContainerConfig(object):\n    \"\"\"LXD configuration methods.\"\"\"\n\n    def __init__(self):\n        self.container_dir = container_dir.LXDContainerDirectories()\n        self.session = session.LXDAPISession()\n        self.vif_driver = vif.LXDGenericDriver()\n\n    def create_container(self, instance):\n        \"\"\"Create a LXD container dictionary so that we can\n           use it to initialize a container\n\n           :param instance: nova instance object\n        \"\"\"\n        LOG.debug('create_container called for instance', instance=instance)\n\n        instance_name = instance.name\n        try:\n\n            # Fetch the container configuration from the current nova\n            # instance object\n            container_config = {\n                'name': instance_name,\n                'profiles': [str(instance.name)],\n                'source': self.get_container_source(instance),\n                'devices': {}\n            }\n\n            # if a configdrive is required, setup the mount point for\n            # the container\n            if configdrive.required_by(instance):\n                configdrive_dir = \\\n                    self.container_dir.get_container_configdrive(\n                        instance.name)\n                config = self.configure_disk_path(configdrive_dir,\n                                                  'var/lib/cloud/data',\n                                                  'configdrive', instance)\n                container_config['devices'].update(config)\n\n            if container_config is None:\n                msg = _('Failed to get container configuration for %s') \\\n                    % instance_name\n                raise exception.NovaException(msg)\n            return container_config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error('Failed to get container configuration'\n                          ' %(instance)s: %(ex)s',\n                          {'instance': instance_name, 'ex': ex},\n                          instance=instance)\n\n    def create_profile(self, instance, network_info):\n        \"\"\"Create a LXD container profile configuration\n\n        :param instance: nova instance object\n        :param network_info: nova network configuration object\n        :return: LXD container profile dictionary\n        \"\"\"\n        LOG.debug('create_container_profile called for instance',\n                  instance=instance)\n        instance_name = instance.name\n        try:\n            config = {}\n            config['name'] = str(instance_name)\n            config['config'] = self.create_config(instance_name, instance)\n\n            # Restrict the size of the \"/\" disk\n            config['devices'] = self.configure_container_root(instance)\n\n            if network_info:\n                config['devices'].update(self.create_network(instance_name,\n                                                             instance,\n                                                             network_info))\n\n            return config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(\n                    _LE('Failed to create profile %(instance)s: %(ex)s'),\n                    {'instance': instance_name, 'ex': ex}, instance=instance)\n\n    def create_config(self, instance_name, instance):\n        \"\"\"Create the LXD container resources\n\n        :param instance_name: instance name\n        :param instance: nova instance object\n        :return: LXD resources dictionary\n        \"\"\"\n        LOG.debug('create_config called for instance', instance=instance)\n        try:\n            config = {}\n\n            # Update continaer options\n            config.update(self.config_instance_options(config, instance))\n\n            # Set the instance memory limit\n            mem = instance.memory_mb\n            if mem >= 0:\n                config['limits.memory'] = '%sMB' % mem\n\n            # Set the instance vcpu limit\n            vcpus = instance.flavor.vcpus\n            if vcpus >= 0:\n                config['limits.cpu'] = str(vcpus)\n\n            # Configure the console for the instance\n            config['raw.lxc'] = 'lxc.console.logfile=%s\\n' \\\n                % self.container_dir.get_console_path(instance_name)\n\n            return config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(\n                    _LE('Failed to set container resources %(instance)s: '\n                        '%(ex)s'), {'instance': instance_name, 'ex': ex},\n                    instance=instance)\n\n    def config_instance_options(self, config, instance):\n        LOG.debug('config_instance_options called for instance',\n                  instance=instance)\n\n        # Set the container to autostart when the host reboots\n        config['boot.autostart'] = 'True'\n\n        # Determine if we require a nested container\n        flavor = instance.flavor\n        lxd_nested_allowed = flavor.extra_specs.get(\n            'lxd:nested_allowed', False)\n        if lxd_nested_allowed:\n            config['security.nesting'] = 'True'\n\n        # Determine if we require a privileged container\n        lxd_privileged_allowed = flavor.extra_specs.get(\n            'lxd:privileged_allowed', False)\n        if lxd_privileged_allowed:\n            config['security.privileged'] = 'True'\n\n        lxd_isolated = flavor.extra_specs.get(\n            'lxd:isolated', False)\n        if lxd_isolated:\n            extensions = self.session.get_host_extensions()\n            if 'id_map' in extensions:\n                config['security.idmap.isolated'] = 'True'\n            else:\n                msg = _('Host does not support isolated instances')\n                raise exception.NovaException(msg)\n\n        return config\n\n    def configure_container_root(self, instance):\n        LOG.debug('configure_container_root called for instance',\n                  instance=instance)\n        try:\n            config = {}\n            lxd_config = self.session.get_host_config(instance)\n            if str(lxd_config['storage']) in ['btrfs', 'zfs']:\n                config['root'] = {'path': '/',\n                                  'type': 'disk',\n                                  'size': '%sGB' % str(instance.root_gb)}\n            else:\n                config['root'] = {'path': '/',\n                                  'type': 'disk'}\n            return config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_LE('Failed to configure disk for '\n                              '%(instance)s: %(ex)s'),\n                          {'instance': instance.name, 'ex': ex},\n                          instance=instance)\n\n    def create_network(self, instance_name, instance, network_info):\n        \"\"\"Create the LXD container network on the host\n\n        :param instance_name: nova instance name\n        :param instance: nova instance object\n        :param network_info: instance network configuration object\n        :return:network configuration dictionary\n        \"\"\"\n        LOG.debug('create_network called for instance', instance=instance)\n        try:\n            network_devices = {}\n\n            if not network_info:\n                return\n\n            for vifaddr in network_info:\n                cfg = self.vif_driver.get_config(instance, vifaddr)\n                key = str(cfg['bridge'])\n                network_devices[key] = \\\n                    {'nictype': 'bridged',\n                     'hwaddr': str(cfg['mac_address']),\n                     'parent': key,\n                     'type': 'nic'}\n                host_device = self.vif_driver.get_vif_devname(vifaddr)\n                if host_device:\n                    network_devices[key]['host_name'] = host_device\n                return network_devices\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(\n                    _LE('Fail to configure network for %(instance)s: %(ex)s'),\n                    {'instance': instance_name, 'ex': ex}, instance=instance)\n\n    def get_container_source(self, instance):\n        \"\"\"Set the LXD container image for the instance.\n\n        :param instance: nova instance object\n        :return: the container source\n        \"\"\"\n        LOG.debug('get_container_source called for instance',\n                  instance=instance)\n        try:\n            container_source = {'type': 'image',\n                                'alias': str(instance.image_ref)}\n            if container_source is None:\n                msg = _('Failed to determine container source for %s') \\\n                    % instance.name\n                raise exception.NovaException(msg)\n            return container_source\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(\n                    _LE('Failed to configure container source '\n                        '%(instance)s: %(ex)s'),\n                    {'instance': instance.name, 'ex': ex},\n                    instance=instance)\n\n    def get_container_migrate(self, container_migrate, migration,\n                              host, instance):\n        LOG.debug('get_container_migrate called for instance',\n                  instance=instance)\n        try:\n            # Generate the container config\n            host = socket.gethostbyname(host)\n            container_metadata = container_migrate['metadata']\n            container_control = container_metadata['metadata']['control']\n            container_fs = container_metadata['metadata']['fs']\n\n            container_url = 'https://%s:8443%s' \\\n                % (host, container_migrate.get('operation'))\n\n            container_migrate = {\n                'base_image': '',\n                'mode': 'pull',\n                'certificate': str(self.session.host_certificate(instance,\n                                                                 host)),\n                'operation': str(container_url),\n                'secrets': {\n                        'control': str(container_control),\n                        'fs': str(container_fs)\n                },\n                'type': 'migration'\n            }\n\n            return container_migrate\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_LE('Failed to configure migation source '\n                              '%(instance)s: %(ex)s'),\n                          {'instance': instance.name, 'ex': ex},\n                          instance=instance)\n\n    def configure_disk_path(self, src_path, dest_path, vfs_type, instance):\n        \"\"\"Configure the host mount point for the LXD container\n\n        :param src_path: source path on the house\n        :param dest_path: destination path on the LXD container\n        :param vfs_type: dictionary identifier\n        :param instance: nova instance object\n        :return: container disk paths\n        \"\"\"\n        LOG.debug('configure_disk_path called for instance',\n                  instance=instance)\n        try:\n            config = {}\n            config[vfs_type] = {'path': dest_path,\n                                'source': src_path,\n                                'type': 'disk',\n                                'optional': 'True'}\n            return config\n        except Exception as ex:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_LE('Failed to configure disk for '\n                              '%(instance)s: %(ex)s'),\n                          {'instance': instance.name, 'ex': ex},\n                          instance=instance)\n\n    def create_container_net_device(self, instance, vif):\n        \"\"\"Translate nova network object into a LXD interface\n\n        :param instance: nova instance object\n        :param vif: network instaance object\n        \"\"\"\n        LOG.debug('create_container_net_device called for instance',\n                  insance=instance)\n        try:\n            network_config = self.vif_driver.get_config(instance, vif)\n\n            config = {}\n            config[self.get_network_device(instance)] = {\n                'nictype': 'bridged',\n                'hwaddr': str(vif['address']),\n                'parent': str(network_config['bridge']),\n                'type': 'nic'}\n\n            return config\n        except Exception as ex:\n            LOG.error(_LE('Failed to configure network for '\n                          '%(instance)s: %(ex)s'),\n                      {'instance': instance.name, 'ex': ex},\n                      instance=instance)\n\n    def get_network_device(self, instance):\n        \"\"\"Try to detect which network interfaces are available in a contianer\n\n        :param instance: nova instance object\n        \"\"\"\n        LOG.debug('get_network_device called for instance', instance=instance)\n        data = self.session.container_info(instance)\n        lines = open('/proc/%s/net/dev' % data['init']).readlines()\n        interfaces = []\n        for line in lines[2:]:\n            if line.find(':') < 0:\n                continue\n            face, _ = line.split(':')\n            if 'eth' in face:\n                interfaces.append(face.strip())\n\n        if len(interfaces) == 1:\n            return 'eth1'\n        else:\n            return 'eth%s' % int(len(interfaces) - 1)\n", "[metadata]\nname = nova-lxd\nsummary = native lxd driver for openstack\ndescription-file =\n    README.md\nauthor = OpenStack\nauthor-email = openstack-dev@lists.openstack.org\nhome-page = http://www.openstack.org/\nclassifier =\n    Environment :: OpenStack\n    Intended Audience :: Information Technology\n    Intended Audience :: System Administrators\n    License :: OSI Approved :: Apache Software License\n    Operating System :: POSIX :: Linux\n    Programming Language :: Python\n    Programming Language :: Python :: 2\n    Programming Language :: Python :: 2.7\n    Programming Language :: Python :: 2.6\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.3\n    Programming Language :: Python :: 3.4\n\n[files]\npackages =\n    nova_lxd\nnamespace_packages = \n\tnova_lxd\n\n[entry_points]\nconsole_scripts =\n   lxc-image-converter = nova_lxd.cmd.converter:main\n\n[build_sphinx]\nsource-dir = doc/source\nbuild-dir = doc/build\nall_files = 1\n\n[upload_sphinx]\nupload-dir = doc/build/html\n\n[compile_catalog]\ndirectory = nova_lxd/locale\ndomain = nova_lxd\n\n[update_catalog]\ndomain = nova_lxd\noutput_dir = nova_lxd/locale\ninput_file = nova_lxd/locale/nova_lxd.pot\n\n[extract_messages]\nkeywords = _ gettext ngettext l_ lazy_gettext\nmapping_file = babel.cfg\noutput_file = nova_lxd/locale/nova_lxd.pot\n"], "filenames": ["nova_lxd/nova/virt/lxd/config.py", "setup.cfg"], "buggy_code_start_loc": [227, 6], "buggy_code_end_loc": [231, 7], "fixing_code_start_loc": [227, 5], "fixing_code_end_loc": [236, 5], "type": "NVD-CWE-noinfo", "message": "OpenStack Nova-LXD before 13.1.1 uses the wrong name for the veth pairs when applying Neutron security group rules for instances, which allows remote attackers to bypass intended security restrictions.", "other": {"cve": {"id": "CVE-2017-5936", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-12T22:59:00.740", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenStack Nova-LXD before 13.1.1 uses the wrong name for the veth pairs when applying Neutron security group rules for instances, which allows remote attackers to bypass intended security restrictions."}, {"lang": "es", "value": "OpenStack Nova-LXD en versiones anteriores a 13.1.1 usa el nombre incorrecto en los pares veth cuando se aplican las reglas del grupo de seguridad Neutron por instancias, lo que permite a atacantes remotos eludir las restricciones de seguridad previstas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:nova-lxd:*:*:*:*:*:*:*:*", "versionEndIncluding": "13.1.0", "matchCriteriaId": "1EC9109B-4DD9-4530-A5C5-A108F7732554"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/02/09/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96182", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-3195-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.launchpad.net/nova-lxd/+bug/1656847", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/openstack/nova-lxd/commit/1b76cefb92081efa1e88cd8f330253f857028bd2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openstack/nova-lxd/commit/1b76cefb92081efa1e88cd8f330253f857028bd2"}}