{"buggy_code": ["/*-\n * Copyright (c) 2003-2011 Tim Kientzle\n * Copyright (c) 2011-2012 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_string.c 201095 2009-12-28 02:33:22Z kientzle $\");\n\n/*\n * Basic resizable string support, to simplify manipulating arbitrary-sized\n * strings while minimizing heap activity.\n *\n * In particular, the buffer used by a string object is only grown, it\n * never shrinks, so you can clear and reuse the same string object\n * without incurring additional memory allocations.\n */\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_ICONV_H\n#include <iconv.h>\n#endif\n#ifdef HAVE_LANGINFO_H\n#include <langinfo.h>\n#endif\n#ifdef HAVE_LOCALCHARSET_H\n#include <localcharset.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#ifdef HAVE_WCHAR_H\n#include <wchar.h>\n#endif\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#include <locale.h>\n#endif\n\n#include \"archive_endian.h\"\n#include \"archive_private.h\"\n#include \"archive_string.h\"\n#include \"archive_string_composition.h\"\n\n#if !defined(HAVE_WMEMCPY) && !defined(wmemcpy)\n#define wmemcpy(a,b,i)  (wchar_t *)memcpy((a), (b), (i) * sizeof(wchar_t))\n#endif\n\n#if !defined(HAVE_WMEMMOVE) && !defined(wmemmove)\n#define wmemmove(a,b,i)  (wchar_t *)memmove((a), (b), (i) * sizeof(wchar_t))\n#endif\n\nstruct archive_string_conv {\n\tstruct archive_string_conv\t*next;\n\tchar\t\t\t\t*from_charset;\n\tchar\t\t\t\t*to_charset;\n\tunsigned\t\t\t from_cp;\n\tunsigned\t\t\t to_cp;\n\t/* Set 1 if from_charset and to_charset are the same. */\n\tint\t\t\t\t same;\n\tint\t\t\t\t flag;\n#define SCONV_TO_CHARSET\t1\t/* MBS is being converted to specified\n\t\t\t\t\t * charset. */\n#define SCONV_FROM_CHARSET\t(1<<1)\t/* MBS is being converted from\n\t\t\t\t\t * specified charset. */\n#define SCONV_BEST_EFFORT \t(1<<2)\t/* Copy at least ASCII code. */\n#define SCONV_WIN_CP\t \t(1<<3)\t/* Use Windows API for converting\n\t\t\t\t\t * MBS. */\n#define SCONV_UTF8_LIBARCHIVE_2 (1<<4)\t/* Incorrect UTF-8 made by libarchive\n\t\t\t\t\t * 2.x in the wrong assumption. */\n#define SCONV_NORMALIZATION_C\t(1<<6)\t/* Need normalization to be Form C.\n\t\t\t\t\t * Before UTF-8 characters are actually\n\t\t\t\t\t * processed. */\n#define SCONV_NORMALIZATION_D\t(1<<7)\t/* Need normalization to be Form D.\n\t\t\t\t\t * Before UTF-8 characters are actually\n\t\t\t\t\t * processed.\n\t\t\t\t\t * Currently this only for MAC OS X. */\n#define SCONV_TO_UTF8\t\t(1<<8)\t/* \"to charset\" side is UTF-8. */\n#define SCONV_FROM_UTF8\t\t(1<<9)\t/* \"from charset\" side is UTF-8. */\n#define SCONV_TO_UTF16BE \t(1<<10)\t/* \"to charset\" side is UTF-16BE. */\n#define SCONV_FROM_UTF16BE \t(1<<11)\t/* \"from charset\" side is UTF-16BE. */\n#define SCONV_TO_UTF16LE \t(1<<12)\t/* \"to charset\" side is UTF-16LE. */\n#define SCONV_FROM_UTF16LE \t(1<<13)\t/* \"from charset\" side is UTF-16LE. */\n#define SCONV_TO_UTF16\t\t(SCONV_TO_UTF16BE | SCONV_TO_UTF16LE)\n#define SCONV_FROM_UTF16\t(SCONV_FROM_UTF16BE | SCONV_FROM_UTF16LE)\n\n#if HAVE_ICONV\n\ticonv_t\t\t\t\t cd;\n\ticonv_t\t\t\t\t cd_w;/* Use at archive_mstring on\n\t\t\t\t \t       * Windows. */\n#endif\n\t/* A temporary buffer for normalization. */\n\tstruct archive_string\t\t utftmp;\n\tint (*converter[2])(struct archive_string *, const void *, size_t,\n\t    struct archive_string_conv *);\n\tint\t\t\t\t nconverter;\n};\n\n#define CP_C_LOCALE\t0\t/* \"C\" locale only for this file. */\n#define CP_UTF16LE\t1200\n#define CP_UTF16BE\t1201\n\n#define IS_HIGH_SURROGATE_LA(uc) ((uc) >= 0xD800 && (uc) <= 0xDBFF)\n#define IS_LOW_SURROGATE_LA(uc)\t ((uc) >= 0xDC00 && (uc) <= 0xDFFF)\n#define IS_SURROGATE_PAIR_LA(uc) ((uc) >= 0xD800 && (uc) <= 0xDFFF)\n#define UNICODE_MAX\t\t0x10FFFF\n#define UNICODE_R_CHAR\t\t0xFFFD\t/* Replacement character. */\n/* Set U+FFFD(Replacement character) in UTF-8. */\nstatic const char utf8_replacement_char[] = {0xef, 0xbf, 0xbd};\n\nstatic struct archive_string_conv *find_sconv_object(struct archive *,\n\tconst char *, const char *);\nstatic void add_sconv_object(struct archive *, struct archive_string_conv *);\nstatic struct archive_string_conv *create_sconv_object(const char *,\n\tconst char *, unsigned, int);\nstatic void free_sconv_object(struct archive_string_conv *);\nstatic struct archive_string_conv *get_sconv_object(struct archive *,\n\tconst char *, const char *, int);\nstatic unsigned make_codepage_from_charset(const char *);\nstatic unsigned get_current_codepage(void);\nstatic unsigned get_current_oemcp(void);\nstatic size_t mbsnbytes(const void *, size_t);\nstatic size_t utf16nbytes(const void *, size_t);\n#if defined(_WIN32) && !defined(__CYGWIN__)\nstatic int archive_wstring_append_from_mbs_in_codepage(\n    struct archive_wstring *, const char *, size_t,\n    struct archive_string_conv *);\nstatic int archive_string_append_from_wcs_in_codepage(struct archive_string *,\n    const wchar_t *, size_t, struct archive_string_conv *);\nstatic int is_big_endian(void);\nstatic int strncat_in_codepage(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int win_strncat_from_utf16be(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int win_strncat_from_utf16le(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int win_strncat_to_utf16be(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int win_strncat_to_utf16le(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\n#endif\nstatic int best_effort_strncat_from_utf16be(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int best_effort_strncat_from_utf16le(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int best_effort_strncat_to_utf16be(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int best_effort_strncat_to_utf16le(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\n#if defined(HAVE_ICONV)\nstatic int iconv_strncat_in_locale(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\n#endif\nstatic int best_effort_strncat_in_locale(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int _utf8_to_unicode(uint32_t *, const char *, size_t);\nstatic int utf8_to_unicode(uint32_t *, const char *, size_t);\nstatic inline uint32_t combine_surrogate_pair(uint32_t, uint32_t);\nstatic int cesu8_to_unicode(uint32_t *, const char *, size_t);\nstatic size_t unicode_to_utf8(char *, size_t, uint32_t);\nstatic int utf16_to_unicode(uint32_t *, const char *, size_t, int);\nstatic size_t unicode_to_utf16be(char *, size_t, uint32_t);\nstatic size_t unicode_to_utf16le(char *, size_t, uint32_t);\nstatic int strncat_from_utf8_libarchive2(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int strncat_from_utf8_to_utf8(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int archive_string_normalize_C(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int archive_string_normalize_D(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int archive_string_append_unicode(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\n\nstatic struct archive_string *\narchive_string_append(struct archive_string *as, const char *p, size_t s)\n{\n\tif (archive_string_ensure(as, as->length + s + 1) == NULL)\n\t\treturn (NULL);\n\tif (s)\n\t\tmemmove(as->s + as->length, p, s);\n\tas->length += s;\n\tas->s[as->length] = 0;\n\treturn (as);\n}\n\nstatic struct archive_wstring *\narchive_wstring_append(struct archive_wstring *as, const wchar_t *p, size_t s)\n{\n\tif (archive_wstring_ensure(as, as->length + s + 1) == NULL)\n\t\treturn (NULL);\n\tif (s)\n\t\twmemmove(as->s + as->length, p, s);\n\tas->length += s;\n\tas->s[as->length] = 0;\n\treturn (as);\n}\n\nstruct archive_string *\narchive_array_append(struct archive_string *as, const char *p, size_t s)\n{\n\treturn archive_string_append(as, p, s);\n}\n\nvoid\narchive_string_concat(struct archive_string *dest, struct archive_string *src)\n{\n\tif (archive_string_append(dest, src->s, src->length) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n}\n\nvoid\narchive_wstring_concat(struct archive_wstring *dest,\n    struct archive_wstring *src)\n{\n\tif (archive_wstring_append(dest, src->s, src->length) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n}\n\nvoid\narchive_string_free(struct archive_string *as)\n{\n\tas->length = 0;\n\tas->buffer_length = 0;\n\tfree(as->s);\n\tas->s = NULL;\n}\n\nvoid\narchive_wstring_free(struct archive_wstring *as)\n{\n\tas->length = 0;\n\tas->buffer_length = 0;\n\tfree(as->s);\n\tas->s = NULL;\n}\n\nstruct archive_wstring *\narchive_wstring_ensure(struct archive_wstring *as, size_t s)\n{\n\treturn (struct archive_wstring *)\n\t\tarchive_string_ensure((struct archive_string *)as,\n\t\t\t\t\ts * sizeof(wchar_t));\n}\n\n/* Returns NULL on any allocation failure. */\nstruct archive_string *\narchive_string_ensure(struct archive_string *as, size_t s)\n{\n\tchar *p;\n\tsize_t new_length;\n\n\t/* If buffer is already big enough, don't reallocate. */\n\tif (as->s && (s <= as->buffer_length))\n\t\treturn (as);\n\n\t/*\n\t * Growing the buffer at least exponentially ensures that\n\t * append operations are always linear in the number of\n\t * characters appended.  Using a smaller growth rate for\n\t * larger buffers reduces memory waste somewhat at the cost of\n\t * a larger constant factor.\n\t */\n\tif (as->buffer_length < 32)\n\t\t/* Start with a minimum 32-character buffer. */\n\t\tnew_length = 32;\n\telse if (as->buffer_length < 8192)\n\t\t/* Buffers under 8k are doubled for speed. */\n\t\tnew_length = as->buffer_length + as->buffer_length;\n\telse {\n\t\t/* Buffers 8k and over grow by at least 25% each time. */\n\t\tnew_length = as->buffer_length + as->buffer_length / 4;\n\t\t/* Be safe: If size wraps, fail. */\n\t\tif (new_length < as->buffer_length) {\n\t\t\t/* On failure, wipe the string and return NULL. */\n\t\t\tarchive_string_free(as);\n\t\t\terrno = ENOMEM;/* Make sure errno has ENOMEM. */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\t/*\n\t * The computation above is a lower limit to how much we'll\n\t * grow the buffer.  In any case, we have to grow it enough to\n\t * hold the request.\n\t */\n\tif (new_length < s)\n\t\tnew_length = s;\n\t/* Now we can reallocate the buffer. */\n\tp = (char *)realloc(as->s, new_length);\n\tif (p == NULL) {\n\t\t/* On failure, wipe the string and return NULL. */\n\t\tarchive_string_free(as);\n\t\terrno = ENOMEM;/* Make sure errno has ENOMEM. */\n\t\treturn (NULL);\n\t}\n\n\tas->s = p;\n\tas->buffer_length = new_length;\n\treturn (as);\n}\n\n/*\n * TODO: See if there's a way to avoid scanning\n * the source string twice.  Then test to see\n * if it actually helps (remember that we're almost\n * always called with pretty short arguments, so\n * such an optimization might not help).\n */\nstruct archive_string *\narchive_strncat(struct archive_string *as, const void *_p, size_t n)\n{\n\tsize_t s;\n\tconst char *p, *pp;\n\n\tp = (const char *)_p;\n\n\t/* Like strlen(p), except won't examine positions beyond p[n]. */\n\ts = 0;\n\tpp = p;\n\twhile (s < n && *pp) {\n\t\tpp++;\n\t\ts++;\n\t}\n\tif ((as = archive_string_append(as, p, s)) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n\treturn (as);\n}\n\nstruct archive_wstring *\narchive_wstrncat(struct archive_wstring *as, const wchar_t *p, size_t n)\n{\n\tsize_t s;\n\tconst wchar_t *pp;\n\n\t/* Like strlen(p), except won't examine positions beyond p[n]. */\n\ts = 0;\n\tpp = p;\n\twhile (s < n && *pp) {\n\t\tpp++;\n\t\ts++;\n\t}\n\tif ((as = archive_wstring_append(as, p, s)) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n\treturn (as);\n}\n\nstruct archive_string *\narchive_strcat(struct archive_string *as, const void *p)\n{\n\t/* strcat is just strncat without an effective limit. \n\t * Assert that we'll never get called with a source\n\t * string over 16MB.\n\t * TODO: Review all uses of strcat in the source\n\t * and try to replace them with strncat().\n\t */\n\treturn archive_strncat(as, p, 0x1000000);\n}\n\nstruct archive_wstring *\narchive_wstrcat(struct archive_wstring *as, const wchar_t *p)\n{\n\t/* Ditto. */\n\treturn archive_wstrncat(as, p, 0x1000000);\n}\n\nstruct archive_string *\narchive_strappend_char(struct archive_string *as, char c)\n{\n\tif ((as = archive_string_append(as, &c, 1)) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n\treturn (as);\n}\n\nstruct archive_wstring *\narchive_wstrappend_wchar(struct archive_wstring *as, wchar_t c)\n{\n\tif ((as = archive_wstring_append(as, &c, 1)) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n\treturn (as);\n}\n\n/*\n * Get the \"current character set\" name to use with iconv.\n * On FreeBSD, the empty character set name \"\" chooses\n * the correct character encoding for the current locale,\n * so this isn't necessary.\n * But iconv on Mac OS 10.6 doesn't seem to handle this correctly;\n * on that system, we have to explicitly call nl_langinfo()\n * to get the right name.  Not sure about other platforms.\n *\n * NOTE: GNU libiconv does not recognize the character-set name\n * which some platform nl_langinfo(CODESET) returns, so we should\n * use locale_charset() instead of nl_langinfo(CODESET) for GNU libiconv.\n */\nstatic const char *\ndefault_iconv_charset(const char *charset) {\n\tif (charset != NULL && charset[0] != '\\0')\n\t\treturn charset;\n#if HAVE_LOCALE_CHARSET && !defined(__APPLE__)\n\t/* locale_charset() is broken on Mac OS */\n\treturn locale_charset();\n#elif HAVE_NL_LANGINFO\n\treturn nl_langinfo(CODESET);\n#else\n\treturn \"\";\n#endif\n}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\n/*\n * Convert MBS to WCS.\n * Note: returns -1 if conversion fails.\n */\nint\narchive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\treturn archive_wstring_append_from_mbs_in_codepage(dest, p, len, NULL);\n}\n\nstatic int\narchive_wstring_append_from_mbs_in_codepage(struct archive_wstring *dest,\n    const char *s, size_t length, struct archive_string_conv *sc)\n{\n\tint count, ret = 0;\n\tUINT from_cp;\n\n\tif (sc != NULL)\n\t\tfrom_cp = sc->from_cp;\n\telse\n\t\tfrom_cp = get_current_codepage();\n\n\tif (from_cp == CP_C_LOCALE) {\n\t\t/*\n\t\t * \"C\" locale special processing.\n\t\t */\n\t\twchar_t *ws;\n\t\tconst unsigned char *mp;\n\n\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t    dest->length + length + 1))\n\t\t\treturn (-1);\n\n\t\tws = dest->s + dest->length;\n\t\tmp = (const unsigned char *)s;\n\t\tcount = 0;\n\t\twhile (count < (int)length && *mp) {\n\t\t\t*ws++ = (wchar_t)*mp++;\n\t\t\tcount++;\n\t\t}\n\t} else if (sc != NULL &&\n\t    (sc->flag & (SCONV_NORMALIZATION_C | SCONV_NORMALIZATION_D))) {\n\t\t/*\n\t\t * Normalize UTF-8 and UTF-16BE and convert it directly\n\t\t * to UTF-16 as wchar_t.\n\t\t */\n\t\tstruct archive_string u16;\n\t\tint saved_flag = sc->flag;/* save current flag. */\n\n\t\tif (is_big_endian())\n\t\t\tsc->flag |= SCONV_TO_UTF16BE;\n\t\telse\n\t\t\tsc->flag |= SCONV_TO_UTF16LE;\n\n\t\tif (sc->flag & SCONV_FROM_UTF16) {\n\t\t\t/*\n\t\t\t *  UTF-16BE/LE NFD ===> UTF-16 NFC\n\t\t\t *  UTF-16BE/LE NFC ===> UTF-16 NFD\n\t\t\t */\n\t\t\tcount = (int)utf16nbytes(s, length);\n\t\t} else {\n\t\t\t/*\n\t\t\t *  UTF-8 NFD ===> UTF-16 NFC\n\t\t\t *  UTF-8 NFC ===> UTF-16 NFD\n\t\t\t */\n\t\t\tcount = (int)mbsnbytes(s, length);\n\t\t}\n\t\tu16.s = (char *)dest->s;\n\t\tu16.length = dest->length << 1;;\n\t\tu16.buffer_length = dest->buffer_length;\n\t\tif (sc->flag & SCONV_NORMALIZATION_C)\n\t\t\tret = archive_string_normalize_C(&u16, s, count, sc);\n\t\telse\n\t\t\tret = archive_string_normalize_D(&u16, s, count, sc);\n\t\tdest->s = (wchar_t *)u16.s;\n\t\tdest->length = u16.length >> 1;\n\t\tdest->buffer_length = u16.buffer_length;\n\t\tsc->flag = saved_flag;/* restore the saved flag. */\n\t\treturn (ret);\n\t} else if (sc != NULL && (sc->flag & SCONV_FROM_UTF16)) {\n\t\tcount = (int)utf16nbytes(s, length);\n\t\tcount >>= 1; /* to be WCS length */\n\t\t/* Allocate memory for WCS. */\n\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t    dest->length + count + 1))\n\t\t\treturn (-1);\n\t\twmemcpy(dest->s + dest->length, (const wchar_t *)s, count);\n\t\tif ((sc->flag & SCONV_FROM_UTF16BE) && !is_big_endian()) {\n\t\t\tuint16_t *u16 = (uint16_t *)(dest->s + dest->length);\n\t\t\tint b;\n\t\t\tfor (b = 0; b < count; b++) {\n\t\t\t\tuint16_t val = archive_le16dec(u16+b);\n\t\t\t\tarchive_be16enc(u16+b, val);\n\t\t\t}\n\t\t} else if ((sc->flag & SCONV_FROM_UTF16LE) && is_big_endian()) {\n\t\t\tuint16_t *u16 = (uint16_t *)(dest->s + dest->length);\n\t\t\tint b;\n\t\t\tfor (b = 0; b < count; b++) {\n\t\t\t\tuint16_t val = archive_be16dec(u16+b);\n\t\t\t\tarchive_le16enc(u16+b, val);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDWORD mbflag;\n\t\tsize_t buffsize;\n\n\t\tif (sc == NULL)\n\t\t\tmbflag = 0;\n\t\telse if (sc->flag & SCONV_FROM_CHARSET) {\n\t\t\t/* Do not trust the length which comes from\n\t\t\t * an archive file. */\n\t\t\tlength = mbsnbytes(s, length);\n\t\t\tmbflag = 0;\n\t\t} else\n\t\t\tmbflag = MB_PRECOMPOSED;\n\n\t\tbuffsize = dest->length + length + 1;\n\t\tdo {\n\t\t\t/* Allocate memory for WCS. */\n\t\t\tif (NULL == archive_wstring_ensure(dest, buffsize))\n\t\t\t\treturn (-1);\n\t\t\t/* Convert MBS to WCS. */\n\t\t\tcount = MultiByteToWideChar(from_cp,\n\t\t\t    mbflag, s, (int)length, dest->s + dest->length,\n\t\t\t    (int)(dest->buffer_length >> 1) -1);\n\t\t\tif (count == 0 &&\n\t\t\t    GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\t\t/* Expand the WCS buffer. */\n\t\t\t\tbuffsize = dest->buffer_length << 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (count == 0 && length != 0)\n\t\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tdest->length += count;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret);\n}\n\n#else\n\n/*\n * Convert MBS to WCS.\n * Note: returns -1 if conversion fails.\n */\nint\narchive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\t/*\n\t * No single byte will be more than one wide character,\n\t * so this length estimate will always be big enough.\n\t */\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\t/*\n\t * We cannot use mbsrtowcs/mbstowcs here because those may convert\n\t * extra MBS when strlen(p) > len and one wide character consists of\n\t * multi bytes.\n\t */\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}\n\n#endif\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\n/*\n * WCS ==> MBS.\n * Note: returns -1 if conversion fails.\n *\n * Win32 builds use WideCharToMultiByte from the Windows API.\n * (Maybe Cygwin should too?  WideCharToMultiByte will know a\n * lot more about local character encodings than the wcrtomb()\n * wrapper is going to know.)\n */\nint\narchive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\treturn archive_string_append_from_wcs_in_codepage(as, w, len, NULL);\n}\n\nstatic int\narchive_string_append_from_wcs_in_codepage(struct archive_string *as,\n    const wchar_t *ws, size_t len, struct archive_string_conv *sc)\n{\n\tBOOL defchar_used, *dp;\n\tint count, ret = 0;\n\tUINT to_cp;\n\tint wslen = (int)len;\n\n\tif (sc != NULL)\n\t\tto_cp = sc->to_cp;\n\telse\n\t\tto_cp = get_current_codepage();\n\n\tif (to_cp == CP_C_LOCALE) {\n\t\t/*\n\t\t * \"C\" locale special processing.\n\t\t */\n\t\tconst wchar_t *wp = ws;\n\t\tchar *p;\n\n\t\tif (NULL == archive_string_ensure(as,\n\t\t    as->length + wslen +1))\n\t\t\treturn (-1);\n\t\tp = as->s + as->length;\n\t\tcount = 0;\n\t\tdefchar_used = 0;\n\t\twhile (count < wslen && *wp) {\n\t\t\tif (*wp > 255) {\n\t\t\t\t*p++ = '?';\n\t\t\t\twp++;\n\t\t\t\tdefchar_used = 1;\n\t\t\t} else\n\t\t\t\t*p++ = (char)*wp++;\n\t\t\tcount++;\n\t\t}\n\t} else if (sc != NULL && (sc->flag & SCONV_TO_UTF16)) {\n\t\tuint16_t *u16;\n\n\t\tif (NULL ==\n\t\t    archive_string_ensure(as, as->length + len * 2 + 2))\n\t\t\treturn (-1);\n\t\tu16 = (uint16_t *)(as->s + as->length);\n\t\tcount = 0;\n\t\tdefchar_used = 0;\n\t\tif (sc->flag & SCONV_TO_UTF16BE) {\n\t\t\twhile (count < (int)len && *ws) {\n\t\t\t\tarchive_be16enc(u16+count, *ws);\n\t\t\t\tws++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (count < (int)len && *ws) {\n\t\t\t\tarchive_le16enc(u16+count, *ws);\n\t\t\t\tws++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcount <<= 1; /* to be byte size */\n\t} else {\n\t\t/* Make sure the MBS buffer has plenty to set. */\n\t\tif (NULL ==\n\t\t    archive_string_ensure(as, as->length + len * 2 + 1))\n\t\t\treturn (-1);\n\t\tdo {\n\t\t\tdefchar_used = 0;\n\t\t\tif (to_cp == CP_UTF8 || sc == NULL)\n\t\t\t\tdp = NULL;\n\t\t\telse\n\t\t\t\tdp = &defchar_used;\n\t\t\tcount = WideCharToMultiByte(to_cp, 0, ws, wslen,\n\t\t\t    as->s + as->length, (int)as->buffer_length-1, NULL, dp);\n\t\t\tif (count == 0 &&\n\t\t\t    GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\t\t/* Expand the MBS buffer and retry. */\n\t\t\t\tif (NULL == archive_string_ensure(as,\n\t\t\t\t\tas->buffer_length + len))\n\t\t\t\t\treturn (-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (count == 0)\n\t\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tas->length += count;\n\tas->s[as->length] = '\\0';\n\treturn (defchar_used?-1:ret);\n}\n\n#elif defined(HAVE_WCTOMB) || defined(HAVE_WCRTOMB)\n\n/*\n * Translates a wide character string into current locale character set\n * and appends to the archive_string.  Note: returns -1 if conversion\n * fails.\n */\nint\narchive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\t/* We cannot use the standard wcstombs() here because it\n\t * cannot tell us how big the output buffer should be.  So\n\t * I've built a loop around wcrtomb() or wctomb() that\n\t * converts a character at a time and resizes the string as\n\t * needed.  We prefer wcrtomb() when it's available because\n\t * it's thread-safe. */\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\t/* Clear the shift state before starting. */\n\twctomb(NULL, L'\\0');\n#endif\n\t/*\n\t * Allocate buffer for MBS.\n\t * We need this allocation here since it is possible that\n\t * as->s is still NULL.\n\t */\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\t/* Re-allocate buffer for MBS. */\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t/* Skip an illegal wide char. */\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}\n\n#else /* HAVE_WCTOMB || HAVE_WCRTOMB */\n\n/*\n * TODO: Test if __STDC_ISO_10646__ is defined.\n * Non-Windows uses ISO C wcrtomb() or wctomb() to perform the conversion\n * one character at a time.  If a non-Windows platform doesn't have\n * either of these, fall back to the built-in UTF8 conversion.\n */\nint\narchive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\t(void)as;/* UNUSED */\n\t(void)w;/* UNUSED */\n\t(void)len;/* UNUSED */\n\terrno = ENOSYS;\n\treturn (-1);\n}\n\n#endif /* HAVE_WCTOMB || HAVE_WCRTOMB */\n\n/*\n * Find a string conversion object by a pair of 'from' charset name\n * and 'to' charset name from an archive object.\n * Return NULL if not found.\n */\nstatic struct archive_string_conv *\nfind_sconv_object(struct archive *a, const char *fc, const char *tc)\n{\n\tstruct archive_string_conv *sc; \n\n\tif (a == NULL)\n\t\treturn (NULL);\n\n\tfor (sc = a->sconv; sc != NULL; sc = sc->next) {\n\t\tif (strcmp(sc->from_charset, fc) == 0 &&\n\t\t    strcmp(sc->to_charset, tc) == 0)\n\t\t\tbreak;\n\t}\n\treturn (sc);\n}\n\n/*\n * Register a string object to an archive object.\n */\nstatic void\nadd_sconv_object(struct archive *a, struct archive_string_conv *sc)\n{\n\tstruct archive_string_conv **psc; \n\n\t/* Add a new sconv to sconv list. */\n\tpsc = &(a->sconv);\n\twhile (*psc != NULL)\n\t\tpsc = &((*psc)->next);\n\t*psc = sc;\n}\n\nstatic void\nadd_converter(struct archive_string_conv *sc, int (*converter)\n    (struct archive_string *, const void *, size_t,\n     struct archive_string_conv *))\n{\n\tif (sc == NULL || sc->nconverter >= 2)\n\t\t__archive_errx(1, \"Programming error\");\n\tsc->converter[sc->nconverter++] = converter;\n}\n\nstatic void\nsetup_converter(struct archive_string_conv *sc)\n{\n\n\t/* Reset. */\n\tsc->nconverter = 0;\n\n\t/*\n\t * Perform special sequence for the incorrect UTF-8 filenames\n\t * made by libarchive2.x.\n\t */\n\tif (sc->flag & SCONV_UTF8_LIBARCHIVE_2) {\n\t\tadd_converter(sc, strncat_from_utf8_libarchive2);\n\t\treturn;\n\t}\n\n\t/*\n\t * Convert a string to UTF-16BE/LE.\n\t */\n\tif (sc->flag & SCONV_TO_UTF16) {\n\t\t/*\n\t\t * If the current locale is UTF-8, we can translate\n\t\t * a UTF-8 string into a UTF-16BE string.\n\t\t */\n\t\tif (sc->flag & SCONV_FROM_UTF8) {\n\t\t\tadd_converter(sc, archive_string_append_unicode);\n\t\t\treturn;\n\t\t}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tif (sc->flag & SCONV_WIN_CP) {\n\t\t\tif (sc->flag & SCONV_TO_UTF16BE)\n\t\t\t\tadd_converter(sc, win_strncat_to_utf16be);\n\t\t\telse\n\t\t\t\tadd_converter(sc, win_strncat_to_utf16le);\n\t\t\treturn;\n\t\t}\n#endif\n\n#if defined(HAVE_ICONV)\n\t\tif (sc->cd != (iconv_t)-1) {\n\t\t\tadd_converter(sc, iconv_strncat_in_locale);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif (sc->flag & SCONV_BEST_EFFORT) {\n\t\t\tif (sc->flag & SCONV_TO_UTF16BE)\n\t\t\t\tadd_converter(sc,\n\t\t\t\t\tbest_effort_strncat_to_utf16be);\n\t\t\telse\n\t\t\t\tadd_converter(sc,\n\t\t\t\t\tbest_effort_strncat_to_utf16le);\n\t\t} else\n\t\t\t/* Make sure we have no converter. */\n\t\t\tsc->nconverter = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Convert a string from UTF-16BE/LE.\n\t */\n\tif (sc->flag & SCONV_FROM_UTF16) {\n\t\t/*\n\t\t * At least we should normalize a UTF-16BE string.\n\t\t */\n\t\tif (sc->flag & SCONV_NORMALIZATION_D)\n\t\t\tadd_converter(sc,archive_string_normalize_D);\n\t\telse if (sc->flag & SCONV_NORMALIZATION_C)\n\t\t\tadd_converter(sc, archive_string_normalize_C);\n\n\t\tif (sc->flag & SCONV_TO_UTF8) {\n\t\t\t/*\n\t\t\t * If the current locale is UTF-8, we can translate\n\t\t\t * a UTF-16BE/LE string into a UTF-8 string directly.\n\t\t\t */\n\t\t\tif (!(sc->flag &\n\t\t\t    (SCONV_NORMALIZATION_D |SCONV_NORMALIZATION_C)))\n\t\t\t\tadd_converter(sc,\n\t\t\t\t    archive_string_append_unicode);\n\t\t\treturn;\n\t\t}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tif (sc->flag & SCONV_WIN_CP) {\n\t\t\tif (sc->flag & SCONV_FROM_UTF16BE)\n\t\t\t\tadd_converter(sc, win_strncat_from_utf16be);\n\t\t\telse\n\t\t\t\tadd_converter(sc, win_strncat_from_utf16le);\n\t\t\treturn;\n\t\t}\n#endif\n\n#if defined(HAVE_ICONV)\n\t\tif (sc->cd != (iconv_t)-1) {\n\t\t\tadd_converter(sc, iconv_strncat_in_locale);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif ((sc->flag & (SCONV_BEST_EFFORT | SCONV_FROM_UTF16BE))\n\t\t    == (SCONV_BEST_EFFORT | SCONV_FROM_UTF16BE))\n\t\t\tadd_converter(sc, best_effort_strncat_from_utf16be);\n\t\telse if ((sc->flag & (SCONV_BEST_EFFORT | SCONV_FROM_UTF16LE))\n\t\t    == (SCONV_BEST_EFFORT | SCONV_FROM_UTF16LE))\n\t\t\tadd_converter(sc, best_effort_strncat_from_utf16le);\n\t\telse\n\t\t\t/* Make sure we have no converter. */\n\t\t\tsc->nconverter = 0;\n\t\treturn;\n\t}\n\n\tif (sc->flag & SCONV_FROM_UTF8) {\n\t\t/*\n\t\t * At least we should normalize a UTF-8 string.\n\t\t */\n\t\tif (sc->flag & SCONV_NORMALIZATION_D)\n\t\t\tadd_converter(sc,archive_string_normalize_D);\n\t\telse if (sc->flag & SCONV_NORMALIZATION_C)\n\t\t\tadd_converter(sc, archive_string_normalize_C);\n\n\t\t/*\n\t\t * Copy UTF-8 string with a check of CESU-8.\n\t\t * Apparently, iconv does not check surrogate pairs in UTF-8\n\t\t * when both from-charset and to-charset are UTF-8, and then\n\t\t * we use our UTF-8 copy code.\n\t\t */\n\t\tif (sc->flag & SCONV_TO_UTF8) {\n\t\t\t/*\n\t\t\t * If the current locale is UTF-8, we can translate\n\t\t\t * a UTF-16BE string into a UTF-8 string directly.\n\t\t\t */\n\t\t\tif (!(sc->flag &\n\t\t\t    (SCONV_NORMALIZATION_D |SCONV_NORMALIZATION_C)))\n\t\t\t\tadd_converter(sc, strncat_from_utf8_to_utf8);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/*\n\t * On Windows we can use Windows API for a string conversion.\n\t */\n\tif (sc->flag & SCONV_WIN_CP) {\n\t\tadd_converter(sc, strncat_in_codepage);\n\t\treturn;\n\t}\n#endif\n\n#if HAVE_ICONV\n\tif (sc->cd != (iconv_t)-1) {\n\t\tadd_converter(sc, iconv_strncat_in_locale);\n\t\t/*\n\t\t * iconv generally does not support UTF-8-MAC and so\n\t\t * we have to the output of iconv from NFC to NFD if\n\t\t * need.\n\t\t */\n\t\tif ((sc->flag & SCONV_FROM_CHARSET) &&\n\t\t    (sc->flag & SCONV_TO_UTF8)) {\n\t\t\tif (sc->flag & SCONV_NORMALIZATION_D)\n\t\t\t\tadd_converter(sc, archive_string_normalize_D);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * Try conversion in the best effort or no conversion.\n\t */\n\tif ((sc->flag & SCONV_BEST_EFFORT) || sc->same)\n\t\tadd_converter(sc, best_effort_strncat_in_locale);\n\telse\n\t\t/* Make sure we have no converter. */\n\t\tsc->nconverter = 0;\n}\n\n/*\n * Return canonicalized charset-name but this supports just UTF-8, UTF-16BE\n * and CP932 which are referenced in create_sconv_object().\n */\nstatic const char *\ncanonical_charset_name(const char *charset)\n{\n\tchar cs[16];\n\tchar *p;\n\tconst char *s;\n\n\tif (charset == NULL || charset[0] == '\\0'\n\t    || strlen(charset) > 15)\n\t\treturn (charset);\n\n\t/* Copy name to uppercase. */\n\tp = cs;\n\ts = charset;\n\twhile (*s) {\n\t\tchar c = *s++;\n\t\tif (c >= 'a' && c <= 'z')\n\t\t\tc -= 'a' - 'A';\n\t\t*p++ = c;\n\t}\n\t*p++ = '\\0';\n\n\tif (strcmp(cs, \"UTF-8\") == 0 ||\n\t    strcmp(cs, \"UTF8\") == 0)\n\t\treturn (\"UTF-8\");\n\tif (strcmp(cs, \"UTF-16BE\") == 0 ||\n\t    strcmp(cs, \"UTF16BE\") == 0)\n\t\treturn (\"UTF-16BE\");\n\tif (strcmp(cs, \"UTF-16LE\") == 0 ||\n\t    strcmp(cs, \"UTF16LE\") == 0)\n\t\treturn (\"UTF-16LE\");\n\tif (strcmp(cs, \"CP932\") == 0)\n\t\treturn (\"CP932\");\n\treturn (charset);\n}\n\n/*\n * Create a string conversion object.\n */\nstatic struct archive_string_conv *\ncreate_sconv_object(const char *fc, const char *tc,\n    unsigned current_codepage, int flag)\n{\n\tstruct archive_string_conv *sc; \n\n\tsc = calloc(1, sizeof(*sc));\n\tif (sc == NULL)\n\t\treturn (NULL);\n\tsc->next = NULL;\n\tsc->from_charset = strdup(fc);\n\tif (sc->from_charset == NULL) {\n\t\tfree(sc);\n\t\treturn (NULL);\n\t}\n\tsc->to_charset = strdup(tc);\n\tif (sc->to_charset == NULL) {\n\t\tfree(sc->from_charset);\n\t\tfree(sc);\n\t\treturn (NULL);\n\t}\n\tarchive_string_init(&sc->utftmp);\n\n\tif (flag & SCONV_TO_CHARSET) {\n\t\t/*\n\t\t * Convert characters from the current locale charset to\n\t\t * a specified charset.\n\t\t */\n\t\tsc->from_cp = current_codepage;\n\t\tsc->to_cp = make_codepage_from_charset(tc);\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tif (IsValidCodePage(sc->to_cp))\n\t\t\tflag |= SCONV_WIN_CP;\n#endif\n\t} else if (flag & SCONV_FROM_CHARSET) {\n\t\t/*\n\t\t * Convert characters from a specified charset to\n\t\t * the current locale charset.\n\t\t */\n\t\tsc->to_cp = current_codepage;\n\t\tsc->from_cp = make_codepage_from_charset(fc);\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tif (IsValidCodePage(sc->from_cp))\n\t\t\tflag |= SCONV_WIN_CP;\n#endif\n\t}\n\n\t/*\n\t * Check if \"from charset\" and \"to charset\" are the same.\n\t */\n\tif (strcmp(fc, tc) == 0 ||\n\t    (sc->from_cp != (unsigned)-1 && sc->from_cp == sc->to_cp))\n\t\tsc->same = 1;\n\telse\n\t\tsc->same = 0;\n\n\t/*\n\t * Mark if \"from charset\" or \"to charset\" are UTF-8 or UTF-16BE/LE.\n\t */\n\tif (strcmp(tc, \"UTF-8\") == 0)\n\t\tflag |= SCONV_TO_UTF8;\n\telse if (strcmp(tc, \"UTF-16BE\") == 0)\n\t\tflag |= SCONV_TO_UTF16BE;\n\telse if (strcmp(tc, \"UTF-16LE\") == 0)\n\t\tflag |= SCONV_TO_UTF16LE;\n\tif (strcmp(fc, \"UTF-8\") == 0)\n\t\tflag |= SCONV_FROM_UTF8;\n\telse if (strcmp(fc, \"UTF-16BE\") == 0)\n\t\tflag |= SCONV_FROM_UTF16BE;\n\telse if (strcmp(fc, \"UTF-16LE\") == 0)\n\t\tflag |= SCONV_FROM_UTF16LE;\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\tif (sc->to_cp == CP_UTF8)\n\t\tflag |= SCONV_TO_UTF8;\n\telse if (sc->to_cp == CP_UTF16BE)\n\t\tflag |= SCONV_TO_UTF16BE | SCONV_WIN_CP;\n\telse if (sc->to_cp == CP_UTF16LE)\n\t\tflag |= SCONV_TO_UTF16LE | SCONV_WIN_CP;\n\tif (sc->from_cp == CP_UTF8)\n\t\tflag |= SCONV_FROM_UTF8;\n\telse if (sc->from_cp == CP_UTF16BE)\n\t\tflag |= SCONV_FROM_UTF16BE | SCONV_WIN_CP;\n\telse if (sc->from_cp == CP_UTF16LE)\n\t\tflag |= SCONV_FROM_UTF16LE | SCONV_WIN_CP;\n#endif\n\n\t/*\n\t * Set a flag for Unicode NFD. Usually iconv cannot correctly\n\t * handle it. So we have to translate NFD characters to NFC ones\n\t * ourselves before iconv handles. Another reason is to prevent\n\t * that the same sight of two filenames, one is NFC and other\n\t * is NFD, would be in its directory.\n\t * On Mac OS X, although its filesystem layer automatically\n\t * convert filenames to NFD, it would be useful for filename\n\t * comparing to find out the same filenames that we normalize\n\t * that to be NFD ourselves.\n\t */\n\tif ((flag & SCONV_FROM_CHARSET) &&\n\t    (flag & (SCONV_FROM_UTF16 | SCONV_FROM_UTF8))) {\n#if defined(__APPLE__)\n\t\tif (flag & SCONV_TO_UTF8)\n\t\t\tflag |= SCONV_NORMALIZATION_D;\n\t\telse\n#endif\n\t\t\tflag |= SCONV_NORMALIZATION_C;\n\t}\n#if defined(__APPLE__)\n\t/*\n\t * In case writing an archive file, make sure that a filename\n\t * going to be passed to iconv is a Unicode NFC string since\n\t * a filename in HFS Plus filesystem is a Unicode NFD one and\n\t * iconv cannot handle it with \"UTF-8\" charset. It is simpler\n\t * than a use of \"UTF-8-MAC\" charset.\n\t */\n\tif ((flag & SCONV_TO_CHARSET) &&\n\t    (flag & (SCONV_FROM_UTF16 | SCONV_FROM_UTF8)) &&\n\t    !(flag & (SCONV_TO_UTF16 | SCONV_TO_UTF8)))\n\t\tflag |= SCONV_NORMALIZATION_C;\n\t/*\n\t * In case reading an archive file. make sure that a filename\n\t * will be passed to users is a Unicode NFD string in order to\n\t * correctly compare the filename with other one which comes\n\t * from HFS Plus filesystem.\n\t */\n\tif ((flag & SCONV_FROM_CHARSET) &&\n\t   !(flag & (SCONV_FROM_UTF16 | SCONV_FROM_UTF8)) &&\n\t    (flag & SCONV_TO_UTF8))\n\t\tflag |= SCONV_NORMALIZATION_D;\n#endif\n\n#if defined(HAVE_ICONV)\n\tsc->cd_w = (iconv_t)-1;\n\t/*\n\t * Create an iconv object.\n\t */\n\tif (((flag & (SCONV_TO_UTF8 | SCONV_TO_UTF16)) &&\n\t    (flag & (SCONV_FROM_UTF8 | SCONV_FROM_UTF16))) ||\n\t    (flag & SCONV_WIN_CP)) {\n\t\t/* This case we won't use iconv. */\n\t\tsc->cd = (iconv_t)-1;\n\t} else {\n\t\tsc->cd = iconv_open(tc, fc);\n\t\tif (sc->cd == (iconv_t)-1 && (sc->flag & SCONV_BEST_EFFORT)) {\n\t\t\t/*\n\t\t\t * Unfortunately, all of iconv implements do support\n\t\t\t * \"CP932\" character-set, so we should use \"SJIS\"\n\t\t\t * instead if iconv_open failed.\n\t\t\t */\n\t\t\tif (strcmp(tc, \"CP932\") == 0)\n\t\t\t\tsc->cd = iconv_open(\"SJIS\", fc);\n\t\t\telse if (strcmp(fc, \"CP932\") == 0)\n\t\t\t\tsc->cd = iconv_open(tc, \"SJIS\");\n\t\t}\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\t/*\n\t\t * archive_mstring on Windows directly convert multi-bytes\n\t\t * into archive_wstring in order not to depend on locale\n\t\t * so that you can do a I18N programming. This will be\n\t\t * used only in archive_mstring_copy_mbs_len_l so far.\n\t\t */\n\t\tif (flag & SCONV_FROM_CHARSET) {\n\t\t\tsc->cd_w = iconv_open(\"UTF-8\", fc);\n\t\t\tif (sc->cd_w == (iconv_t)-1 &&\n\t\t\t    (sc->flag & SCONV_BEST_EFFORT)) {\n\t\t\t\tif (strcmp(fc, \"CP932\") == 0)\n\t\t\t\t\tsc->cd_w = iconv_open(\"UTF-8\", \"SJIS\");\n\t\t\t}\n\t\t}\n#endif /* _WIN32 && !__CYGWIN__ */\n\t}\n#endif\t/* HAVE_ICONV */\n\n\tsc->flag = flag;\n\n\t/*\n\t * Set up converters.\n\t */\n\tsetup_converter(sc);\n\n\treturn (sc);\n}\n\n/*\n * Free a string conversion object.\n */\nstatic void\nfree_sconv_object(struct archive_string_conv *sc)\n{\n\tfree(sc->from_charset);\n\tfree(sc->to_charset);\n\tarchive_string_free(&sc->utftmp);\n#if HAVE_ICONV\n\tif (sc->cd != (iconv_t)-1)\n\t\ticonv_close(sc->cd);\n\tif (sc->cd_w != (iconv_t)-1)\n\t\ticonv_close(sc->cd_w);\n#endif\n\tfree(sc);\n}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\nstatic unsigned\nmy_atoi(const char *p)\n{\n\tunsigned cp;\n\n\tcp = 0;\n\twhile (*p) {\n\t\tif (*p >= '0' && *p <= '9')\n\t\t\tcp = cp * 10 + (*p - '0');\n\t\telse\n\t\t\treturn (-1);\n\t\tp++;\n\t}\n\treturn (cp);\n}\n\n/*\n * Translate Charset name (as used by iconv) into CodePage (as used by Windows)\n * Return -1 if failed.\n *\n * Note: This translation code may be insufficient.\n */\nstatic struct charset {\n\tconst char *name;\n\tunsigned cp;\n} charsets[] = {\n\t/* MUST BE SORTED! */\n\t{\"ASCII\", 1252},\n\t{\"ASMO-708\", 708},\n\t{\"BIG5\", 950},\n\t{\"CHINESE\", 936},\n\t{\"CP367\", 1252},\n\t{\"CP819\", 1252},\n\t{\"CP1025\", 21025},\n\t{\"DOS-720\", 720},\n\t{\"DOS-862\", 862},\n\t{\"EUC-CN\", 51936},\n\t{\"EUC-JP\", 51932},\n\t{\"EUC-KR\", 949},\n\t{\"EUCCN\", 51936},\n\t{\"EUCJP\", 51932},\n\t{\"EUCKR\", 949},\n\t{\"GB18030\", 54936},\n\t{\"GB2312\", 936},\n\t{\"HEBREW\", 1255},\n\t{\"HZ-GB-2312\", 52936},\n\t{\"IBM273\", 20273},\n\t{\"IBM277\", 20277},\n\t{\"IBM278\", 20278},\n\t{\"IBM280\", 20280},\n\t{\"IBM284\", 20284},\n\t{\"IBM285\", 20285},\n\t{\"IBM290\", 20290},\n\t{\"IBM297\", 20297},\n\t{\"IBM367\", 1252},\n\t{\"IBM420\", 20420},\n\t{\"IBM423\", 20423},\n\t{\"IBM424\", 20424},\n\t{\"IBM819\", 1252},\n\t{\"IBM871\", 20871},\n\t{\"IBM880\", 20880},\n\t{\"IBM905\", 20905},\n\t{\"IBM924\", 20924},\n\t{\"ISO-8859-1\", 28591},\n\t{\"ISO-8859-13\", 28603},\n\t{\"ISO-8859-15\", 28605},\n\t{\"ISO-8859-2\", 28592},\n\t{\"ISO-8859-3\", 28593},\n\t{\"ISO-8859-4\", 28594},\n\t{\"ISO-8859-5\", 28595},\n\t{\"ISO-8859-6\", 28596},\n\t{\"ISO-8859-7\", 28597},\n\t{\"ISO-8859-8\", 28598},\n\t{\"ISO-8859-9\", 28599},\n\t{\"ISO8859-1\", 28591},\n\t{\"ISO8859-13\", 28603},\n\t{\"ISO8859-15\", 28605},\n\t{\"ISO8859-2\", 28592},\n\t{\"ISO8859-3\", 28593},\n\t{\"ISO8859-4\", 28594},\n\t{\"ISO8859-5\", 28595},\n\t{\"ISO8859-6\", 28596},\n\t{\"ISO8859-7\", 28597},\n\t{\"ISO8859-8\", 28598},\n\t{\"ISO8859-9\", 28599},\n\t{\"JOHAB\", 1361},\n\t{\"KOI8-R\", 20866},\n\t{\"KOI8-U\", 21866},\n\t{\"KS_C_5601-1987\", 949},\n\t{\"LATIN1\", 1252},\n\t{\"LATIN2\", 28592},\n\t{\"MACINTOSH\", 10000},\n\t{\"SHIFT-JIS\", 932},\n\t{\"SHIFT_JIS\", 932},\n\t{\"SJIS\", 932},\n\t{\"US\", 1252},\n\t{\"US-ASCII\", 1252},\n\t{\"UTF-16\", 1200},\n\t{\"UTF-16BE\", 1201},\n\t{\"UTF-16LE\", 1200},\n\t{\"UTF-8\", CP_UTF8},\n\t{\"X-EUROPA\", 29001},\n\t{\"X-MAC-ARABIC\", 10004},\n\t{\"X-MAC-CE\", 10029},\n\t{\"X-MAC-CHINESEIMP\", 10008},\n\t{\"X-MAC-CHINESETRAD\", 10002},\n\t{\"X-MAC-CROATIAN\", 10082},\n\t{\"X-MAC-CYRILLIC\", 10007},\n\t{\"X-MAC-GREEK\", 10006},\n\t{\"X-MAC-HEBREW\", 10005},\n\t{\"X-MAC-ICELANDIC\", 10079},\n\t{\"X-MAC-JAPANESE\", 10001},\n\t{\"X-MAC-KOREAN\", 10003},\n\t{\"X-MAC-ROMANIAN\", 10010},\n\t{\"X-MAC-THAI\", 10021},\n\t{\"X-MAC-TURKISH\", 10081},\n\t{\"X-MAC-UKRAINIAN\", 10017},\n};\nstatic unsigned\nmake_codepage_from_charset(const char *charset)\n{\n\tchar cs[16];\n\tchar *p;\n\tunsigned cp;\n\tint a, b;\n\n\tif (charset == NULL || strlen(charset) > 15)\n\t\treturn -1;\n\n\t/* Copy name to uppercase. */\n\tp = cs;\n\twhile (*charset) {\n\t\tchar c = *charset++;\n\t\tif (c >= 'a' && c <= 'z')\n\t\t\tc -= 'a' - 'A';\n\t\t*p++ = c;\n\t}\n\t*p++ = '\\0';\n\tcp = -1;\n\n\t/* Look it up in the table first, so that we can easily\n\t * override CP367, which we map to 1252 instead of 367. */\n\ta = 0;\n\tb = sizeof(charsets)/sizeof(charsets[0]);\n\twhile (b > a) {\n\t\tint c = (b + a) / 2;\n\t\tint r = strcmp(charsets[c].name, cs);\n\t\tif (r < 0)\n\t\t\ta = c + 1;\n\t\telse if (r > 0)\n\t\t\tb = c;\n\t\telse\n\t\t\treturn charsets[c].cp;\n\t}\n\n\t/* If it's not in the table, try to parse it. */\n\tswitch (*cs) {\n\tcase 'C':\n\t\tif (cs[1] == 'P' && cs[2] >= '0' && cs[2] <= '9') {\n\t\t\tcp = my_atoi(cs + 2);\n\t\t} else if (strcmp(cs, \"CP_ACP\") == 0)\n\t\t\tcp = get_current_codepage();\n\t\telse if (strcmp(cs, \"CP_OEMCP\") == 0)\n\t\t\tcp = get_current_oemcp();\n\t\tbreak;\n\tcase 'I':\n\t\tif (cs[1] == 'B' && cs[2] == 'M' &&\n\t\t    cs[3] >= '0' && cs[3] <= '9') {\n\t\t\tcp = my_atoi(cs + 3);\n\t\t}\n\t\tbreak;\n\tcase 'W':\n\t\tif (strncmp(cs, \"WINDOWS-\", 8) == 0) {\n\t\t\tcp = my_atoi(cs + 8);\n\t\t\tif (cp != 874 && (cp < 1250 || cp > 1258))\n\t\t\t\tcp = -1;/* This may invalid code. */\n\t\t}\n\t\tbreak;\n\t}\n\treturn (cp);\n}\n\n/*\n * Return ANSI Code Page of current locale set by setlocale().\n */\nstatic unsigned\nget_current_codepage(void)\n{\n\tchar *locale, *p;\n\tunsigned cp;\n\n\tlocale = setlocale(LC_CTYPE, NULL);\n\tif (locale == NULL)\n\t\treturn (GetACP());\n\tif (locale[0] == 'C' && locale[1] == '\\0')\n\t\treturn (CP_C_LOCALE);\n\tp = strrchr(locale, '.');\n\tif (p == NULL)\n\t\treturn (GetACP());\n\tif (strcmp(p+1, \"utf8\") == 0)\n\t\treturn CP_UTF8;\n\tcp = my_atoi(p+1);\n\tif ((int)cp <= 0)\n\t\treturn (GetACP());\n\treturn (cp);\n}\n\n/*\n * Translation table between Locale Name and ACP/OEMCP.\n */\nstatic struct {\n\tunsigned acp;\n\tunsigned ocp;\n\tconst char *locale;\n} acp_ocp_map[] = {\n\t{  950,  950, \"Chinese_Taiwan\" },\n\t{  936,  936, \"Chinese_People's Republic of China\" },\n\t{  950,  950, \"Chinese_Taiwan\" },\n\t{ 1250,  852, \"Czech_Czech Republic\" },\n\t{ 1252,  850, \"Danish_Denmark\" },\n\t{ 1252,  850, \"Dutch_Netherlands\" },\n\t{ 1252,  850, \"Dutch_Belgium\" },\n\t{ 1252,  437, \"English_United States\" },\n\t{ 1252,  850, \"English_Australia\" },\n\t{ 1252,  850, \"English_Canada\" },\n\t{ 1252,  850, \"English_New Zealand\" },\n\t{ 1252,  850, \"English_United Kingdom\" },\n\t{ 1252,  437, \"English_United States\" },\n\t{ 1252,  850, \"Finnish_Finland\" },\n\t{ 1252,  850, \"French_France\" },\n\t{ 1252,  850, \"French_Belgium\" },\n\t{ 1252,  850, \"French_Canada\" },\n\t{ 1252,  850, \"French_Switzerland\" },\n\t{ 1252,  850, \"German_Germany\" },\n\t{ 1252,  850, \"German_Austria\" },\n\t{ 1252,  850, \"German_Switzerland\" },\n\t{ 1253,  737, \"Greek_Greece\" },\n\t{ 1250,  852, \"Hungarian_Hungary\" },\n\t{ 1252,  850, \"Icelandic_Iceland\" },\n\t{ 1252,  850, \"Italian_Italy\" },\n\t{ 1252,  850, \"Italian_Switzerland\" },\n\t{  932,  932, \"Japanese_Japan\" },\n\t{  949,  949, \"Korean_Korea\" },\n\t{ 1252,  850, \"Norwegian (BokmOl)_Norway\" },\n\t{ 1252,  850, \"Norwegian (BokmOl)_Norway\" },\n\t{ 1252,  850, \"Norwegian-Nynorsk_Norway\" },\n\t{ 1250,  852, \"Polish_Poland\" },\n\t{ 1252,  850, \"Portuguese_Portugal\" },\n\t{ 1252,  850, \"Portuguese_Brazil\" },\n\t{ 1251,  866, \"Russian_Russia\" },\n\t{ 1250,  852, \"Slovak_Slovakia\" },\n\t{ 1252,  850, \"Spanish_Spain\" },\n\t{ 1252,  850, \"Spanish_Mexico\" },\n\t{ 1252,  850, \"Spanish_Spain\" },\n\t{ 1252,  850, \"Swedish_Sweden\" },\n\t{ 1254,  857, \"Turkish_Turkey\" },\n\t{ 0, 0, NULL}\n};\n\n/*\n * Return OEM Code Page of current locale set by setlocale().\n */\nstatic unsigned\nget_current_oemcp(void)\n{\n\tint i;\n\tchar *locale, *p;\n\tsize_t len;\n\n\tlocale = setlocale(LC_CTYPE, NULL);\n\tif (locale == NULL)\n\t\treturn (GetOEMCP());\n\tif (locale[0] == 'C' && locale[1] == '\\0')\n\t\treturn (CP_C_LOCALE);\n\n\tp = strrchr(locale, '.');\n\tif (p == NULL)\n\t\treturn (GetOEMCP());\n\tlen = p - locale;\n\tfor (i = 0; acp_ocp_map[i].acp; i++) {\n\t\tif (strncmp(acp_ocp_map[i].locale, locale, len) == 0)\n\t\t\treturn (acp_ocp_map[i].ocp);\n\t}\n\treturn (GetOEMCP());\n}\n#else\n\n/*\n * POSIX platform does not use CodePage.\n */\n\nstatic unsigned\nget_current_codepage(void)\n{\n\treturn (-1);/* Unknown */\n}\nstatic unsigned\nmake_codepage_from_charset(const char *charset)\n{\n\t(void)charset; /* UNUSED */\n\treturn (-1);/* Unknown */\n}\nstatic unsigned\nget_current_oemcp(void)\n{\n\treturn (-1);/* Unknown */\n}\n\n#endif /* defined(_WIN32) && !defined(__CYGWIN__) */\n\n/*\n * Return a string conversion object.\n */\nstatic struct archive_string_conv *\nget_sconv_object(struct archive *a, const char *fc, const char *tc, int flag)\n{\n\tstruct archive_string_conv *sc;\n\tunsigned current_codepage;\n\n\t/* Check if we have made the sconv object. */\n\tsc = find_sconv_object(a, fc, tc);\n\tif (sc != NULL)\n\t\treturn (sc);\n\n\tif (a == NULL)\n\t\tcurrent_codepage = get_current_codepage();\n\telse\n\t\tcurrent_codepage = a->current_codepage;\n\n\tsc = create_sconv_object(canonical_charset_name(fc),\n\t    canonical_charset_name(tc), current_codepage, flag);\n\tif (sc == NULL) {\n\t\tif (a != NULL)\n\t\t\tarchive_set_error(a, ENOMEM,\n\t\t\t    \"Could not allocate memory for \"\n\t\t\t    \"a string conversion object\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * If there is no converter for current string conversion object,\n\t * we cannot handle this conversion.\n\t */\n\tif (sc->nconverter == 0) {\n\t\tif (a != NULL) {\n#if HAVE_ICONV\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"iconv_open failed : Cannot handle ``%s''\",\n\t\t\t    (flag & SCONV_TO_CHARSET)?tc:fc);\n#else\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"A character-set conversion not fully supported \"\n\t\t\t    \"on this platform\");\n#endif\n\t\t}\n\t\t/* Failed; free a sconv object. */\n\t\tfree_sconv_object(sc);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Success!\n\t */\n\tif (a != NULL)\n\t\tadd_sconv_object(a, sc);\n\treturn (sc);\n}\n\nstatic const char *\nget_current_charset(struct archive *a)\n{\n\tconst char *cur_charset;\n\n\tif (a == NULL)\n\t\tcur_charset = default_iconv_charset(\"\");\n\telse {\n\t\tcur_charset = default_iconv_charset(a->current_code);\n\t\tif (a->current_code == NULL) {\n\t\t\ta->current_code = strdup(cur_charset);\n\t\t\ta->current_codepage = get_current_codepage();\n\t\t\ta->current_oemcp = get_current_oemcp();\n\t\t}\n\t}\n\treturn (cur_charset);\n}\n\n/*\n * Make and Return a string conversion object.\n * Return NULL if the platform does not support the specified conversion\n * and best_effort is 0.\n * If best_effort is set, A string conversion object must be returned\n * unless memory allocation for the object fails, but the conversion\n * might fail when non-ASCII code is found.\n */\nstruct archive_string_conv *\narchive_string_conversion_to_charset(struct archive *a, const char *charset,\n    int best_effort)\n{\n\tint flag = SCONV_TO_CHARSET;\n\n\tif (best_effort)\n\t\tflag |= SCONV_BEST_EFFORT;\n\treturn (get_sconv_object(a, get_current_charset(a), charset, flag));\n}\n\nstruct archive_string_conv *\narchive_string_conversion_from_charset(struct archive *a, const char *charset,\n    int best_effort)\n{\n\tint flag = SCONV_FROM_CHARSET;\n\n\tif (best_effort)\n\t\tflag |= SCONV_BEST_EFFORT;\n\treturn (get_sconv_object(a, charset, get_current_charset(a), flag));\n}\n\n/*\n * archive_string_default_conversion_*_archive() are provided for Windows\n * platform because other archiver application use CP_OEMCP for\n * MultiByteToWideChar() and WideCharToMultiByte() for the filenames\n * in tar or zip files. But mbstowcs/wcstombs(CRT) usually use CP_ACP\n * unless you use setlocale(LC_ALL, \".OCP\")(specify CP_OEMCP).\n * So we should make a string conversion between CP_ACP and CP_OEMCP\n * for compatibility.\n */\n#if defined(_WIN32) && !defined(__CYGWIN__)\nstruct archive_string_conv *\narchive_string_default_conversion_for_read(struct archive *a)\n{\n\tconst char *cur_charset = get_current_charset(a);\n\tchar oemcp[16];\n\n\t/* NOTE: a check of cur_charset is unneeded but we need\n\t * that get_current_charset() has been surely called at\n\t * this time whatever C compiler optimized. */\n\tif (cur_charset != NULL &&\n\t    (a->current_codepage == CP_C_LOCALE ||\n\t     a->current_codepage == a->current_oemcp))\n\t\treturn (NULL);/* no conversion. */\n\n\t_snprintf(oemcp, sizeof(oemcp)-1, \"CP%d\", a->current_oemcp);\n\t/* Make sure a null termination must be set. */\n\toemcp[sizeof(oemcp)-1] = '\\0';\n\treturn (get_sconv_object(a, oemcp, cur_charset,\n\t    SCONV_FROM_CHARSET));\n}\n\nstruct archive_string_conv *\narchive_string_default_conversion_for_write(struct archive *a)\n{\n\tconst char *cur_charset = get_current_charset(a);\n\tchar oemcp[16];\n\n\t/* NOTE: a check of cur_charset is unneeded but we need\n\t * that get_current_charset() has been surely called at\n\t * this time whatever C compiler optimized. */\n\tif (cur_charset != NULL &&\n\t    (a->current_codepage == CP_C_LOCALE ||\n\t     a->current_codepage == a->current_oemcp))\n\t\treturn (NULL);/* no conversion. */\n\n\t_snprintf(oemcp, sizeof(oemcp)-1, \"CP%d\", a->current_oemcp);\n\t/* Make sure a null termination must be set. */\n\toemcp[sizeof(oemcp)-1] = '\\0';\n\treturn (get_sconv_object(a, cur_charset, oemcp,\n\t    SCONV_TO_CHARSET));\n}\n#else\nstruct archive_string_conv *\narchive_string_default_conversion_for_read(struct archive *a)\n{\n\t(void)a; /* UNUSED */\n\treturn (NULL);\n}\n\nstruct archive_string_conv *\narchive_string_default_conversion_for_write(struct archive *a)\n{\n\t(void)a; /* UNUSED */\n\treturn (NULL);\n}\n#endif\n\n/*\n * Dispose of all character conversion objects in the archive object.\n */\nvoid\narchive_string_conversion_free(struct archive *a)\n{\n\tstruct archive_string_conv *sc; \n\tstruct archive_string_conv *sc_next; \n\n\tfor (sc = a->sconv; sc != NULL; sc = sc_next) {\n\t\tsc_next = sc->next;\n\t\tfree_sconv_object(sc);\n\t}\n\ta->sconv = NULL;\n\tfree(a->current_code);\n\ta->current_code = NULL;\n}\n\n/*\n * Return a conversion charset name.\n */\nconst char *\narchive_string_conversion_charset_name(struct archive_string_conv *sc)\n{\n\tif (sc->flag & SCONV_TO_CHARSET)\n\t\treturn (sc->to_charset);\n\telse\n\t\treturn (sc->from_charset);\n}\n\n/*\n * Change the behavior of a string conversion.\n */\nvoid\narchive_string_conversion_set_opt(struct archive_string_conv *sc, int opt)\n{\n\tswitch (opt) {\n\t/*\n\t * A filename in UTF-8 was made with libarchive 2.x in a wrong\n\t * assumption that wchar_t was Unicode.\n\t * This option enables simulating the assumption in order to read\n\t * that filename correctly.\n\t */\n\tcase SCONV_SET_OPT_UTF8_LIBARCHIVE2X:\n#if (defined(_WIN32) && !defined(__CYGWIN__)) \\\n\t || defined(__STDC_ISO_10646__) || defined(__APPLE__)\n\t\t/*\n\t\t * Nothing to do for it since wchar_t on these platforms\n\t\t * is really Unicode.\n\t\t */\n\t\t(void)sc; /* UNUSED */\n#else\n\t\tif ((sc->flag & SCONV_UTF8_LIBARCHIVE_2) == 0) {\n\t\t\tsc->flag |= SCONV_UTF8_LIBARCHIVE_2;\n\t\t\t/* Set up string converters. */\n\t\t\tsetup_converter(sc);\n\t\t}\n#endif\n\t\tbreak;\n\tcase SCONV_SET_OPT_NORMALIZATION_C:\n\t\tif ((sc->flag & SCONV_NORMALIZATION_C) == 0) {\n\t\t\tsc->flag |= SCONV_NORMALIZATION_C;\n\t\t\tsc->flag &= ~SCONV_NORMALIZATION_D;\n\t\t\t/* Set up string converters. */\n\t\t\tsetup_converter(sc);\n\t\t}\n\t\tbreak;\n\tcase SCONV_SET_OPT_NORMALIZATION_D:\n#if defined(HAVE_ICONV)\n\t\t/*\n\t\t * If iconv will take the string, do not change the\n\t\t * setting of the normalization.\n\t\t */\n\t\tif (!(sc->flag & SCONV_WIN_CP) &&\n\t\t     (sc->flag & (SCONV_FROM_UTF16 | SCONV_FROM_UTF8)) &&\n\t\t    !(sc->flag & (SCONV_TO_UTF16 | SCONV_TO_UTF8)))\n\t\t\tbreak;\n#endif\n\t\tif ((sc->flag & SCONV_NORMALIZATION_D) == 0) {\n\t\t\tsc->flag |= SCONV_NORMALIZATION_D;\n\t\t\tsc->flag &= ~SCONV_NORMALIZATION_C;\n\t\t\t/* Set up string converters. */\n\t\t\tsetup_converter(sc);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n *\n * Copy one archive_string to another in locale conversion.\n *\n *\tarchive_strncat_l();\n *\tarchive_strncpy_l();\n *\n */\n\nstatic size_t\nmbsnbytes(const void *_p, size_t n)\n{\n\tsize_t s;\n\tconst char *p, *pp;\n\n\tif (_p == NULL)\n\t\treturn (0);\n\tp = (const char *)_p;\n\n\t/* Like strlen(p), except won't examine positions beyond p[n]. */\n\ts = 0;\n\tpp = p;\n\twhile (s < n && *pp) {\n\t\tpp++;\n\t\ts++;\n\t}\n\treturn (s);\n}\n\nstatic size_t\nutf16nbytes(const void *_p, size_t n)\n{\n\tsize_t s;\n\tconst char *p, *pp;\n\n\tif (_p == NULL)\n\t\treturn (0);\n\tp = (const char *)_p;\n\n\t/* Like strlen(p), except won't examine positions beyond p[n]. */\n\ts = 0;\n\tpp = p;\n\tn >>= 1;\n\twhile (s < n && (pp[0] || pp[1])) {\n\t\tpp += 2;\n\t\ts++;\n\t}\n\treturn (s<<1);\n}\n\nint\narchive_strncpy_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tas->length = 0;\n\treturn (archive_strncat_l(as, _p, n, sc));\n}\n\nint\narchive_strncat_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tconst void *s;\n\tsize_t length = 0;\n\tint i, r = 0, r2;\n\n\tif (_p != NULL && n > 0) {\n\t\tif (sc != NULL && (sc->flag & SCONV_FROM_UTF16))\n\t\t\tlength = utf16nbytes(_p, n);\n\t\telse\n\t\t\tlength = mbsnbytes(_p, n);\n\t}\n\n\t/* We must allocate memory even if there is no data for conversion\n\t * or copy. This simulates archive_string_append behavior. */\n\tif (length == 0) {\n\t\tint tn = 1;\n\t\tif (sc != NULL && (sc->flag & SCONV_TO_UTF16))\n\t\t\ttn = 2;\n\t\tif (archive_string_ensure(as, as->length + tn) == NULL)\n\t\t\treturn (-1);\n\t\tas->s[as->length] = 0;\n\t\tif (tn == 2)\n\t\t\tas->s[as->length+1] = 0;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * If sc is NULL, we just make a copy.\n\t */\n\tif (sc == NULL) {\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);/* No memory */\n\t\treturn (0);\n\t}\n\n\ts = _p;\n\ti = 0;\n\tif (sc->nconverter > 1) {\n\t\tsc->utftmp.length = 0;\n\t\tr2 = sc->converter[0](&(sc->utftmp), s, length, sc);\n\t\tif (r2 != 0 && errno == ENOMEM)\n\t\t\treturn (r2);\n\t\tif (r > r2)\n\t\t\tr = r2;\n\t\ts = sc->utftmp.s;\n\t\tlength = sc->utftmp.length;\n\t\t++i;\n\t}\n\tr2 = sc->converter[i](as, s, length, sc);\n\tif (r > r2)\n\t\tr = r2;\n\treturn (r);\n}\n\n#if HAVE_ICONV\n\n/*\n * Return -1 if conversion fails.\n */\nstatic int\niconv_strncat_in_locale(struct archive_string *as, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\tICONV_CONST char *itp;\n\tsize_t remaining;\n\ticonv_t cd;\n\tchar *outp;\n\tsize_t avail, bs;\n\tint return_value = 0; /* success */\n\tint to_size, from_size;\n\n\tif (sc->flag & SCONV_TO_UTF16)\n\t\tto_size = 2;\n\telse\n\t\tto_size = 1;\n\tif (sc->flag & SCONV_FROM_UTF16)\n\t\tfrom_size = 2;\n\telse\n\t\tfrom_size = 1;\n\n\tif (archive_string_ensure(as, as->length + length*2+to_size) == NULL)\n\t\treturn (-1);\n\n\tcd = sc->cd;\n\titp = (char *)(uintptr_t)_p;\n\tremaining = length;\n\toutp = as->s + as->length;\n\tavail = as->buffer_length - as->length - to_size;\n\twhile (remaining >= (size_t)from_size) {\n\t\tsize_t result = iconv(cd, &itp, &remaining, &outp, &avail);\n\n\t\tif (result != (size_t)-1)\n\t\t\tbreak; /* Conversion completed. */\n\n\t\tif (errno == EILSEQ || errno == EINVAL) {\n\t\t\t/*\n\t\t \t * If an output charset is UTF-8 or UTF-16BE/LE,\n\t\t\t * unknown character should be U+FFFD\n\t\t\t * (replacement character).\n\t\t\t */\n\t\t\tif (sc->flag & (SCONV_TO_UTF8 | SCONV_TO_UTF16)) {\n\t\t\t\tsize_t rbytes;\n\t\t\t\tif (sc->flag & SCONV_TO_UTF8)\n\t\t\t\t\trbytes = sizeof(utf8_replacement_char);\n\t\t\t\telse\n\t\t\t\t\trbytes = 2;\n\n\t\t\t\tif (avail < rbytes) {\n\t\t\t\t\tas->length = outp - as->s;\n\t\t\t\t\tbs = as->buffer_length +\n\t\t\t\t\t    (remaining * to_size) + rbytes;\n\t\t\t\t\tif (NULL ==\n\t\t\t\t\t    archive_string_ensure(as, bs))\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\toutp = as->s + as->length;\n\t\t\t\t\tavail = as->buffer_length\n\t\t\t\t\t    - as->length - to_size;\n\t\t\t\t}\n\t\t\t\tif (sc->flag & SCONV_TO_UTF8)\n\t\t\t\t\tmemcpy(outp, utf8_replacement_char, sizeof(utf8_replacement_char));\n\t\t\t\telse if (sc->flag & SCONV_TO_UTF16BE)\n\t\t\t\t\tarchive_be16enc(outp, UNICODE_R_CHAR);\n\t\t\t\telse\n\t\t\t\t\tarchive_le16enc(outp, UNICODE_R_CHAR);\n\t\t\t\toutp += rbytes;\n\t\t\t\tavail -= rbytes;\n\t\t\t} else {\n\t\t\t\t/* Skip the illegal input bytes. */\n\t\t\t\t*outp++ = '?';\n\t\t\t\tavail--;\n\t\t\t}\n\t\t\titp += from_size;\n\t\t\tremaining -= from_size;\n\t\t\treturn_value = -1; /* failure */\n\t\t} else {\n\t\t\t/* E2BIG no output buffer,\n\t\t\t * Increase an output buffer.  */\n\t\t\tas->length = outp - as->s;\n\t\t\tbs = as->buffer_length + remaining * 2;\n\t\t\tif (NULL == archive_string_ensure(as, bs))\n\t\t\t\treturn (-1);\n\t\t\toutp = as->s + as->length;\n\t\t\tavail = as->buffer_length - as->length - to_size;\n\t\t}\n\t}\n\tas->length = outp - as->s;\n\tas->s[as->length] = 0;\n\tif (to_size == 2)\n\t\tas->s[as->length+1] = 0;\n\treturn (return_value);\n}\n\n#endif /* HAVE_ICONV */\n\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\n/*\n * Translate a string from a some CodePage to an another CodePage by\n * Windows APIs, and copy the result. Return -1 if conversion fails.\n */\nstatic int\nstrncat_in_codepage(struct archive_string *as,\n    const void *_p, size_t length, struct archive_string_conv *sc)\n{\n\tconst char *s = (const char *)_p;\n\tstruct archive_wstring aws;\n\tsize_t l;\n\tint r, saved_flag;\n\n\tarchive_string_init(&aws);\n\tsaved_flag = sc->flag;\n\tsc->flag &= ~(SCONV_NORMALIZATION_D | SCONV_NORMALIZATION_C);\n\tr = archive_wstring_append_from_mbs_in_codepage(&aws, s, length, sc);\n\tsc->flag = saved_flag;\n\tif (r != 0) {\n\t\tarchive_wstring_free(&aws);\n\t\tif (errno != ENOMEM)\n\t\t\tarchive_string_append(as, s, length);\n\t\treturn (-1);\n\t}\n\n\tl = as->length;\n\tr = archive_string_append_from_wcs_in_codepage(\n\t    as, aws.s, aws.length, sc);\n\tif (r != 0 && errno != ENOMEM && l == as->length)\n\t\tarchive_string_append(as, s, length);\n\tarchive_wstring_free(&aws);\n\treturn (r);\n}\n\n/*\n * Test whether MBS ==> WCS is okay.\n */\nstatic int\ninvalid_mbs(const void *_p, size_t n, struct archive_string_conv *sc)\n{\n\tconst char *p = (const char *)_p;\n\tunsigned codepage;\n\tDWORD mbflag = MB_ERR_INVALID_CHARS;\n\n\tif (sc->flag & SCONV_FROM_CHARSET)\n\t\tcodepage = sc->to_cp;\n\telse\n\t\tcodepage = sc->from_cp;\n\n\tif (codepage == CP_C_LOCALE)\n\t\treturn (0);\n\tif (codepage != CP_UTF8)\n\t\tmbflag |= MB_PRECOMPOSED;\n\n\tif (MultiByteToWideChar(codepage, mbflag, p, (int)n, NULL, 0) == 0)\n\t\treturn (-1); /* Invalid */\n\treturn (0); /* Okay */\n}\n\n#else\n\n/*\n * Test whether MBS ==> WCS is okay.\n */\nstatic int\ninvalid_mbs(const void *_p, size_t n, struct archive_string_conv *sc)\n{\n\tconst char *p = (const char *)_p;\n\tsize_t r;\n\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\t/* Clear the shift state before starting. */\n\tmbtowc(NULL, NULL, 0);\n#endif\n\twhile (n) {\n\t\twchar_t wc;\n\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(&wc, p, n, &shift_state);\n#else\n\t\tr = mbtowc(&wc, p, n);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2)\n\t\t\treturn (-1);/* Invalid. */\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tp += r;\n\t\tn -= r;\n\t}\n\t(void)sc; /* UNUSED */\n\treturn (0); /* All Okey. */\n}\n\n#endif /* defined(_WIN32) && !defined(__CYGWIN__) */\n\n/*\n * Basically returns -1 because we cannot make a conversion of charset\n * without iconv but in some cases this would return 0.\n * Returns 0 if all copied characters are ASCII.\n * Returns 0 if both from-locale and to-locale are the same and those\n * can be WCS with no error.\n */\nstatic int\nbest_effort_strncat_in_locale(struct archive_string *as, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\tsize_t remaining;\n\tconst uint8_t *itp;\n\tint return_value = 0; /* success */\n\n\t/*\n\t * If both from-locale and to-locale is the same, this makes a copy.\n\t * And then this checks all copied MBS can be WCS if so returns 0.\n\t */\n\tif (sc->same) {\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);/* No memory */\n\t\treturn (invalid_mbs(_p, length, sc));\n\t}\n\n\t/*\n\t * If a character is ASCII, this just copies it. If not, this\n\t * assigns '?' character instead but in UTF-8 locale this assigns\n\t * byte sequence 0xEF 0xBD 0xBD, which are code point U+FFFD,\n\t * a Replacement Character in Unicode.\n\t */\n\n\tremaining = length;\n\titp = (const uint8_t *)_p;\n\twhile (*itp && remaining > 0) {\n\t\tif (*itp > 127) {\n\t\t\t// Non-ASCII: Substitute with suitable replacement\n\t\t\tif (sc->flag & SCONV_TO_UTF8) {\n\t\t\t\tif (archive_string_append(as, utf8_replacement_char, sizeof(utf8_replacement_char)) == NULL) {\n\t\t\t\t\t__archive_errx(1, \"Out of memory\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarchive_strappend_char(as, '?');\n\t\t\t}\n\t\t\treturn_value = -1;\n\t\t} else {\n\t\t\tarchive_strappend_char(as, *itp);\n\t\t}\n\t\t++itp;\n\t}\n\treturn (return_value);\n}\n\n\n/*\n * Unicode conversion functions.\n *   - UTF-8 <===> UTF-8 in removing surrogate pairs.\n *   - UTF-8 NFD ===> UTF-8 NFC in removing surrogate pairs.\n *   - UTF-8 made by libarchive 2.x ===> UTF-8.\n *   - UTF-16BE <===> UTF-8.\n *\n */\n\n/*\n * Utility to convert a single UTF-8 sequence.\n *\n * Usually return used bytes, return used byte in negative value when\n * a unicode character is replaced with U+FFFD.\n * See also http://unicode.org/review/pr-121.html Public Review Issue #121\n * Recommended Practice for Replacement Characters.\n */\nstatic int\n_utf8_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\tstatic const char utf8_count[256] = {\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 00 - 0F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 10 - 1F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 20 - 2F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 30 - 3F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 40 - 4F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 50 - 5F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 60 - 6F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 70 - 7F */\n\t\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,/* 80 - 8F */\n\t\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,/* 90 - 9F */\n\t\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,/* A0 - AF */\n\t\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,/* B0 - BF */\n\t\t 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,/* C0 - CF */\n\t\t 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,/* D0 - DF */\n\t\t 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,/* E0 - EF */\n\t\t 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /* F0 - FF */\n\t};\n\tint ch, i;\n\tint cnt;\n\tuint32_t wc;\n\n\t/* Sanity check. */\n\tif (n == 0)\n\t\treturn (0);\n\t/*\n\t * Decode 1-4 bytes depending on the value of the first byte.\n\t */\n\tch = (unsigned char)*s;\n\tif (ch == 0)\n\t\treturn (0); /* Standard:  return 0 for end-of-string. */\n\tcnt = utf8_count[ch];\n\n\t/* Invalid sequence or there are not plenty bytes. */\n\tif ((int)n < cnt) {\n\t\tcnt = (int)n;\n\t\tfor (i = 1; i < cnt; i++) {\n\t\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\t\tcnt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgoto invalid_sequence;\n\t}\n\n\t/* Make a Unicode code point from a single UTF-8 sequence. */\n\tswitch (cnt) {\n\tcase 1:\t/* 1 byte sequence. */\n\t\t*pwc = ch & 0x7f;\n\t\treturn (cnt);\n\tcase 2:\t/* 2 bytes sequence. */\n\t\tif ((s[1] & 0xc0) != 0x80) {\n\t\t\tcnt = 1;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\t*pwc = ((ch & 0x1f) << 6) | (s[1] & 0x3f);\n\t\treturn (cnt);\n\tcase 3:\t/* 3 bytes sequence. */\n\t\tif ((s[1] & 0xc0) != 0x80) {\n\t\t\tcnt = 1;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\tif ((s[2] & 0xc0) != 0x80) {\n\t\t\tcnt = 2;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\twc = ((ch & 0x0f) << 12)\n\t\t    | ((s[1] & 0x3f) << 6)\n\t\t    | (s[2] & 0x3f);\n\t\tif (wc < 0x800)\n\t\t\tgoto invalid_sequence;/* Overlong sequence. */\n\t\tbreak;\n\tcase 4:\t/* 4 bytes sequence. */\n\t\tif ((s[1] & 0xc0) != 0x80) {\n\t\t\tcnt = 1;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\tif ((s[2] & 0xc0) != 0x80) {\n\t\t\tcnt = 2;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\tif ((s[3] & 0xc0) != 0x80) {\n\t\t\tcnt = 3;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\twc = ((ch & 0x07) << 18)\n\t\t    | ((s[1] & 0x3f) << 12)\n\t\t    | ((s[2] & 0x3f) << 6)\n\t\t    | (s[3] & 0x3f);\n\t\tif (wc < 0x10000)\n\t\t\tgoto invalid_sequence;/* Overlong sequence. */\n\t\tbreak;\n\tdefault: /* Others are all invalid sequence. */\n\t\tif (ch == 0xc0 || ch == 0xc1)\n\t\t\tcnt = 2;\n\t\telse if (ch >= 0xf5 && ch <= 0xf7)\n\t\t\tcnt = 4;\n\t\telse if (ch >= 0xf8 && ch <= 0xfb)\n\t\t\tcnt = 5;\n\t\telse if (ch == 0xfc || ch == 0xfd)\n\t\t\tcnt = 6;\n\t\telse\n\t\t\tcnt = 1;\n\t\tif ((int)n < cnt)\n\t\t\tcnt = (int)n;\n\t\tfor (i = 1; i < cnt; i++) {\n\t\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\t\tcnt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgoto invalid_sequence;\n\t}\n\n\t/* The code point larger than 0x10FFFF is not legal\n\t * Unicode values. */\n\tif (wc > UNICODE_MAX)\n\t\tgoto invalid_sequence;\n\t/* Correctly gets a Unicode, returns used bytes. */\n\t*pwc = wc;\n\treturn (cnt);\ninvalid_sequence:\n\t*pwc = UNICODE_R_CHAR;/* set the Replacement Character instead. */\n\treturn (cnt * -1);\n}\n\nstatic int\nutf8_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\tint cnt;\n\n\tcnt = _utf8_to_unicode(pwc, s, n);\n\t/* Any of Surrogate pair is not legal Unicode values. */\n\tif (cnt == 3 && IS_SURROGATE_PAIR_LA(*pwc))\n\t\treturn (-3);\n\treturn (cnt);\n}\n\nstatic inline uint32_t\ncombine_surrogate_pair(uint32_t uc, uint32_t uc2)\n{\n\tuc -= 0xD800;\n\tuc *= 0x400;\n\tuc += uc2 - 0xDC00;\n\tuc += 0x10000;\n\treturn (uc);\n}\n\n/*\n * Convert a single UTF-8/CESU-8 sequence to a Unicode code point in\n * removing surrogate pairs.\n *\n * CESU-8: The Compatibility Encoding Scheme for UTF-16.\n *\n * Usually return used bytes, return used byte in negative value when\n * a unicode character is replaced with U+FFFD.\n */\nstatic int\ncesu8_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\tuint32_t wc = 0;\n\tint cnt;\n\n\tcnt = _utf8_to_unicode(&wc, s, n);\n\tif (cnt == 3 && IS_HIGH_SURROGATE_LA(wc)) {\n\t\tuint32_t wc2 = 0;\n\t\tif (n - 3 < 3) {\n\t\t\t/* Invalid byte sequence. */\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\tcnt = _utf8_to_unicode(&wc2, s+3, n-3);\n\t\tif (cnt != 3 || !IS_LOW_SURROGATE_LA(wc2)) {\n\t\t\t/* Invalid byte sequence. */\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\twc = combine_surrogate_pair(wc, wc2);\n\t\tcnt = 6;\n\t} else if (cnt == 3 && IS_LOW_SURROGATE_LA(wc)) {\n\t\t/* Invalid byte sequence. */\n\t\tgoto invalid_sequence;\n\t}\n\t*pwc = wc;\n\treturn (cnt);\ninvalid_sequence:\n\t*pwc = UNICODE_R_CHAR;/* set the Replacement Character instead. */\n\tif (cnt > 0)\n\t\tcnt *= -1;\n\treturn (cnt);\n}\n\n/*\n * Convert a Unicode code point to a single UTF-8 sequence.\n *\n * NOTE:This function does not check if the Unicode is legal or not.\n * Please you definitely check it before calling this.\n */\nstatic size_t\nunicode_to_utf8(char *p, size_t remaining, uint32_t uc)\n{\n\tchar *_p = p;\n\n\t/* Invalid Unicode char maps to Replacement character */\n\tif (uc > UNICODE_MAX)\n\t\tuc = UNICODE_R_CHAR;\n\t/* Translate code point to UTF8 */\n\tif (uc <= 0x7f) {\n\t\tif (remaining == 0)\n\t\t\treturn (0);\n\t\t*p++ = (char)uc;\n\t} else if (uc <= 0x7ff) {\n\t\tif (remaining < 2)\n\t\t\treturn (0);\n\t\t*p++ = 0xc0 | ((uc >> 6) & 0x1f);\n\t\t*p++ = 0x80 | (uc & 0x3f);\n\t} else if (uc <= 0xffff) {\n\t\tif (remaining < 3)\n\t\t\treturn (0);\n\t\t*p++ = 0xe0 | ((uc >> 12) & 0x0f);\n\t\t*p++ = 0x80 | ((uc >> 6) & 0x3f);\n\t\t*p++ = 0x80 | (uc & 0x3f);\n\t} else {\n\t\tif (remaining < 4)\n\t\t\treturn (0);\n\t\t*p++ = 0xf0 | ((uc >> 18) & 0x07);\n\t\t*p++ = 0x80 | ((uc >> 12) & 0x3f);\n\t\t*p++ = 0x80 | ((uc >> 6) & 0x3f);\n\t\t*p++ = 0x80 | (uc & 0x3f);\n\t}\n\treturn (p - _p);\n}\n\nstatic int\nutf16be_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\treturn (utf16_to_unicode(pwc, s, n, 1));\n}\n\nstatic int\nutf16le_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\treturn (utf16_to_unicode(pwc, s, n, 0));\n}\n\nstatic int\nutf16_to_unicode(uint32_t *pwc, const char *s, size_t n, int be)\n{\n\tconst char *utf16 = s;\n\tunsigned uc;\n\n\tif (n == 0)\n\t\treturn (0);\n\tif (n == 1) {\n\t\t/* set the Replacement Character instead. */\n\t\t*pwc = UNICODE_R_CHAR;\n\t\treturn (-1);\n\t}\n\n\tif (be)\n\t\tuc = archive_be16dec(utf16);\n\telse\n\t\tuc = archive_le16dec(utf16);\n\tutf16 += 2;\n\t\t\n\t/* If this is a surrogate pair, assemble the full code point.*/\n\tif (IS_HIGH_SURROGATE_LA(uc)) {\n\t\tunsigned uc2;\n\n\t\tif (n >= 4) {\n\t\t\tif (be)\n\t\t\t\tuc2 = archive_be16dec(utf16);\n\t\t\telse\n\t\t\t\tuc2 = archive_le16dec(utf16);\n\t\t} else\n\t\t\tuc2 = 0;\n\t\tif (IS_LOW_SURROGATE_LA(uc2)) {\n\t\t\tuc = combine_surrogate_pair(uc, uc2);\n\t\t\tutf16 += 2;\n\t\t} else {\n\t \t\t/* Undescribed code point should be U+FFFD\n\t\t \t* (replacement character). */\n\t\t\t*pwc = UNICODE_R_CHAR;\n\t\t\treturn (-2);\n\t\t}\n\t}\n\n\t/*\n\t * Surrogate pair values(0xd800 through 0xdfff) are only\n\t * used by UTF-16, so, after above calculation, the code\n\t * must not be surrogate values, and Unicode has no codes\n\t * larger than 0x10ffff. Thus, those are not legal Unicode\n\t * values.\n\t */\n\tif (IS_SURROGATE_PAIR_LA(uc) || uc > UNICODE_MAX) {\n\t \t/* Undescribed code point should be U+FFFD\n\t \t* (replacement character). */\n\t\t*pwc = UNICODE_R_CHAR;\n\t\treturn (((int)(utf16 - s)) * -1);\n\t}\n\t*pwc = uc;\n\treturn ((int)(utf16 - s));\n}\n\nstatic size_t\nunicode_to_utf16be(char *p, size_t remaining, uint32_t uc)\n{\n\tchar *utf16 = p;\n\n\tif (uc > 0xffff) {\n\t\t/* We have a code point that won't fit into a\n\t\t * wchar_t; convert it to a surrogate pair. */\n\t\tif (remaining < 4)\n\t\t\treturn (0);\n\t\tuc -= 0x10000;\n\t\tarchive_be16enc(utf16, ((uc >> 10) & 0x3ff) + 0xD800);\n\t\tarchive_be16enc(utf16+2, (uc & 0x3ff) + 0xDC00);\n\t\treturn (4);\n\t} else {\n\t\tif (remaining < 2)\n\t\t\treturn (0);\n\t\tarchive_be16enc(utf16, uc);\n\t\treturn (2);\n\t}\n}\n\nstatic size_t\nunicode_to_utf16le(char *p, size_t remaining, uint32_t uc)\n{\n\tchar *utf16 = p;\n\n\tif (uc > 0xffff) {\n\t\t/* We have a code point that won't fit into a\n\t\t * wchar_t; convert it to a surrogate pair. */\n\t\tif (remaining < 4)\n\t\t\treturn (0);\n\t\tuc -= 0x10000;\n\t\tarchive_le16enc(utf16, ((uc >> 10) & 0x3ff) + 0xD800);\n\t\tarchive_le16enc(utf16+2, (uc & 0x3ff) + 0xDC00);\n\t\treturn (4);\n\t} else {\n\t\tif (remaining < 2)\n\t\t\treturn (0);\n\t\tarchive_le16enc(utf16, uc);\n\t\treturn (2);\n\t}\n}\n\n/*\n * Copy UTF-8 string in checking surrogate pair.\n * If any surrogate pair are found, it would be canonicalized.\n */\nstatic int\nstrncat_from_utf8_to_utf8(struct archive_string *as, const void *_p,\n    size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tchar *p, *endp;\n\tint n, ret = 0;\n\n\t(void)sc; /* UNUSED */\n\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tendp = as->s + as->buffer_length -1;\n\tdo {\n\t\tuint32_t uc;\n\t\tconst char *ss = s;\n\t\tsize_t w;\n\n\t\t/*\n\t\t * Forward byte sequence until a conversion of that is needed.\n\t\t */\n\t\twhile ((n = utf8_to_unicode(&uc, s, len)) > 0) {\n\t\t\ts += n;\n\t\t\tlen -= n;\n\t\t}\n\t\tif (ss < s) {\n\t\t\tif (p + (s - ss) > endp) {\n\t\t\t\tas->length = p - as->s;\n\t\t\t\tif (archive_string_ensure(as,\n\t\t\t\t    as->buffer_length + len + 1) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tp = as->s + as->length;\n\t\t\t\tendp = as->s + as->buffer_length -1;\n\t\t\t}\n\n\t\t\tmemcpy(p, ss, s - ss);\n\t\t\tp += s - ss;\n\t\t}\n\n\t\t/*\n\t\t * If n is negative, current byte sequence needs a replacement.\n\t\t */\n\t\tif (n < 0) {\n\t\t\tif (n == -3 && IS_SURROGATE_PAIR_LA(uc)) {\n\t\t\t\t/* Current byte sequence may be CESU-8. */\n\t\t\t\tn = cesu8_to_unicode(&uc, s, len);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tret = -1;\n\t\t\t\tn *= -1;/* Use a replaced unicode character. */\n\t\t\t}\n\n\t\t\t/* Rebuild UTF-8 byte sequence. */\n\t\t\twhile ((w = unicode_to_utf8(p, endp - p, uc)) == 0) {\n\t\t\t\tas->length = p - as->s;\n\t\t\t\tif (archive_string_ensure(as,\n\t\t\t\t    as->buffer_length + len + 1) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tp = as->s + as->length;\n\t\t\t\tendp = as->s + as->buffer_length -1;\n\t\t\t}\n\t\t\tp += w;\n\t\t\ts += n;\n\t\t\tlen -= n;\n\t\t}\n\t} while (n > 0);\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret);\n}\n\nstatic int\narchive_string_append_unicode(struct archive_string *as, const void *_p,\n    size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tchar *p, *endp;\n\tuint32_t uc;\n\tsize_t w;\n\tint n, ret = 0, ts, tm;\n\tint (*parse)(uint32_t *, const char *, size_t);\n\tsize_t (*unparse)(char *, size_t, uint32_t);\n\n\tif (sc->flag & SCONV_TO_UTF16BE) {\n\t\tunparse = unicode_to_utf16be;\n\t\tts = 2;\n\t} else if (sc->flag & SCONV_TO_UTF16LE) {\n\t\tunparse = unicode_to_utf16le;\n\t\tts = 2;\n\t} else if (sc->flag & SCONV_TO_UTF8) {\n\t\tunparse = unicode_to_utf8;\n\t\tts = 1;\n\t} else {\n\t\t/*\n\t\t * This case is going to be converted to another\n\t\t * character-set through iconv.\n\t\t */\n\t\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\t\tunparse = unicode_to_utf16be;\n\t\t\tts = 2;\n\t\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\t\tunparse = unicode_to_utf16le;\n\t\t\tts = 2;\n\t\t} else {\n\t\t\tunparse = unicode_to_utf8;\n\t\t\tts = 1;\n\t\t}\n\t}\n\n\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\tparse = utf16be_to_unicode;\n\t\ttm = 1;\n\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\tparse = utf16le_to_unicode;\n\t\ttm = 1;\n\t} else {\n\t\tparse = cesu8_to_unicode;\n\t\ttm = ts;\n\t}\n\n\tif (archive_string_ensure(as, as->length + len * tm + ts) == NULL)\n\t\treturn (-1);\n\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tendp = as->s + as->buffer_length - ts;\n\twhile ((n = parse(&uc, s, len)) != 0) {\n\t\tif (n < 0) {\n\t\t\t/* Use a replaced unicode character. */\n\t\t\tn *= -1;\n\t\t\tret = -1;\n\t\t}\n\t\ts += n;\n\t\tlen -= n;\n\t\twhile ((w = unparse(p, endp - p, uc)) == 0) {\n\t\t\t/* There is not enough output buffer so\n\t\t\t * we have to expand it. */\n\t\t\tas->length = p - as->s;\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->buffer_length + len * tm + ts) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tendp = as->s + as->buffer_length - ts;\n\t\t}\n\t\tp += w;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\tif (ts == 2)\n\t\tas->s[as->length+1] = '\\0';\n\treturn (ret);\n}\n\n/*\n * Following Constants for Hangul compositions this information comes from\n * Unicode Standard Annex #15  http://unicode.org/reports/tr15/\n */\n#define HC_SBASE\t0xAC00\n#define HC_LBASE\t0x1100\n#define HC_VBASE\t0x1161\n#define HC_TBASE\t0x11A7\n#define HC_LCOUNT\t19\n#define HC_VCOUNT\t21\n#define HC_TCOUNT\t28\n#define HC_NCOUNT\t(HC_VCOUNT * HC_TCOUNT)\n#define HC_SCOUNT\t(HC_LCOUNT * HC_NCOUNT)\n\nstatic uint32_t\nget_nfc(uint32_t uc, uint32_t uc2)\n{\n\tint t, b;\n\n\tt = 0;\n\tb = sizeof(u_composition_table)/sizeof(u_composition_table[0]) -1;\n\twhile (b >= t) {\n\t\tint m = (t + b) / 2;\n\t\tif (u_composition_table[m].cp1 < uc)\n\t\t\tt = m + 1;\n\t\telse if (u_composition_table[m].cp1 > uc)\n\t\t\tb = m - 1;\n\t\telse if (u_composition_table[m].cp2 < uc2)\n\t\t\tt = m + 1;\n\t\telse if (u_composition_table[m].cp2 > uc2)\n\t\t\tb = m - 1;\n\t\telse\n\t\t\treturn (u_composition_table[m].nfc);\n\t}\n\treturn (0);\n}\n\n#define FDC_MAX 10\t/* The maximum number of Following Decomposable\n\t\t\t * Characters. */\n\n/*\n * Update first code point.\n */\n#define UPDATE_UC(new_uc)\tdo {\t\t\\\n\tuc = new_uc;\t\t\t\t\\\n\tucptr = NULL;\t\t\t\t\\\n} while (0)\n\n/*\n * Replace first code point with second code point.\n */\n#define REPLACE_UC_WITH_UC2() do {\t\t\\\n\tuc = uc2;\t\t\t\t\\\n\tucptr = uc2ptr;\t\t\t\t\\\n\tn = n2;\t\t\t\t\t\\\n} while (0)\n\n#define EXPAND_BUFFER() do {\t\t\t\\\n\tas->length = p - as->s;\t\t\t\\\n\tif (archive_string_ensure(as,\t\t\\\n\t    as->buffer_length + len * tm + ts) == NULL)\\\n\t\treturn (-1);\t\t\t\\\n\tp = as->s + as->length;\t\t\t\\\n\tendp = as->s + as->buffer_length - ts;\t\\\n} while (0)\n\n#define UNPARSE(p, endp, uc)\tdo {\t\t\\\n\twhile ((w = unparse(p, (endp) - (p), uc)) == 0) {\\\n\t\tEXPAND_BUFFER();\t\t\\\n\t}\t\t\t\t\t\\\n\tp += w;\t\t\t\t\t\\\n} while (0)\n\n/*\n * Write first code point.\n * If the code point has not be changed from its original code,\n * this just copies it from its original buffer pointer.\n * If not, this converts it to UTF-8 byte sequence and copies it.\n */\n#define WRITE_UC()\tdo {\t\t\t\\\n\tif (ucptr) {\t\t\t\t\\\n\t\tif (p + n > endp)\t\t\\\n\t\t\tEXPAND_BUFFER();\t\\\n\t\tswitch (n) {\t\t\t\\\n\t\tcase 4:\t\t\t\t\\\n\t\t\t*p++ = *ucptr++;\t\\\n\t\t\t/* FALL THROUGH */\t\\\n\t\tcase 3:\t\t\t\t\\\n\t\t\t*p++ = *ucptr++;\t\\\n\t\t\t/* FALL THROUGH */\t\\\n\t\tcase 2:\t\t\t\t\\\n\t\t\t*p++ = *ucptr++;\t\\\n\t\t\t/* FALL THROUGH */\t\\\n\t\tcase 1:\t\t\t\t\\\n\t\t\t*p++ = *ucptr;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\t}\t\t\t\t\\\n\t\tucptr = NULL;\t\t\t\\\n\t} else {\t\t\t\t\\\n\t\tUNPARSE(p, endp, uc);\t\t\\\n\t}\t\t\t\t\t\\\n} while (0)\n\n/*\n * Collect following decomposable code points.\n */\n#define COLLECT_CPS(start)\tdo {\t\t\\\n\tint _i;\t\t\t\t\t\\\n\tfor (_i = start; _i < FDC_MAX ; _i++) {\t\\\n\t\tnx = parse(&ucx[_i], s, len);\t\\\n\t\tif (nx <= 0)\t\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcx = CCC(ucx[_i]);\t\t\\\n\t\tif (cl >= cx && cl != 228 && cx != 228)\\\n\t\t\tbreak;\t\t\t\\\n\t\ts += nx;\t\t\t\\\n\t\tlen -= nx;\t\t\t\\\n\t\tcl = cx;\t\t\t\\\n\t\tccx[_i] = cx;\t\t\t\\\n\t}\t\t\t\t\t\\\n\tif (_i >= FDC_MAX) {\t\t\t\\\n\t\tret = -1;\t\t\t\\\n\t\tucx_size = FDC_MAX;\t\t\\\n\t} else\t\t\t\t\t\\\n\t\tucx_size = _i;\t\t\t\\\n} while (0)\n\n/*\n * Normalize UTF-8/UTF-16BE characters to Form C and copy the result.\n *\n * TODO: Convert composition exclusions, which are never converted\n * from NFC,NFD,NFKC and NFKD, to Form C.\n */\nstatic int\narchive_string_normalize_C(struct archive_string *as, const void *_p,\n    size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s = (const char *)_p;\n\tchar *p, *endp;\n\tuint32_t uc, uc2;\n\tsize_t w;\n\tint always_replace, n, n2, ret = 0, spair, ts, tm;\n\tint (*parse)(uint32_t *, const char *, size_t);\n\tsize_t (*unparse)(char *, size_t, uint32_t);\n\n\talways_replace = 1;\n\tts = 1;/* text size. */\n\tif (sc->flag & SCONV_TO_UTF16BE) {\n\t\tunparse = unicode_to_utf16be;\n\t\tts = 2;\n\t\tif (sc->flag & SCONV_FROM_UTF16BE)\n\t\t\talways_replace = 0;\n\t} else if (sc->flag & SCONV_TO_UTF16LE) {\n\t\tunparse = unicode_to_utf16le;\n\t\tts = 2;\n\t\tif (sc->flag & SCONV_FROM_UTF16LE)\n\t\t\talways_replace = 0;\n\t} else if (sc->flag & SCONV_TO_UTF8) {\n\t\tunparse = unicode_to_utf8;\n\t\tif (sc->flag & SCONV_FROM_UTF8)\n\t\t\talways_replace = 0;\n\t} else {\n\t\t/*\n\t\t * This case is going to be converted to another\n\t\t * character-set through iconv.\n\t\t */\n\t\talways_replace = 0;\n\t\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\t\tunparse = unicode_to_utf16be;\n\t\t\tts = 2;\n\t\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\t\tunparse = unicode_to_utf16le;\n\t\t\tts = 2;\n\t\t} else {\n\t\t\tunparse = unicode_to_utf8;\n\t\t}\n\t}\n\n\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\tparse = utf16be_to_unicode;\n\t\ttm = 1;\n\t\tspair = 4;/* surrogate pair size in UTF-16. */\n\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\tparse = utf16le_to_unicode;\n\t\ttm = 1;\n\t\tspair = 4;/* surrogate pair size in UTF-16. */\n\t} else {\n\t\tparse = cesu8_to_unicode;\n\t\ttm = ts;\n\t\tspair = 6;/* surrogate pair size in UTF-8. */\n\t}\n\n\tif (archive_string_ensure(as, as->length + len * tm + ts) == NULL)\n\t\treturn (-1);\n\n\tp = as->s + as->length;\n\tendp = as->s + as->buffer_length - ts;\n\twhile ((n = parse(&uc, s, len)) != 0) {\n\t\tconst char *ucptr, *uc2ptr;\n\n\t\tif (n < 0) {\n\t\t\t/* Use a replaced unicode character. */\n\t\t\tUNPARSE(p, endp, uc);\n\t\t\ts += n*-1;\n\t\t\tlen -= n*-1;\n\t\t\tret = -1;\n\t\t\tcontinue;\n\t\t} else if (n == spair || always_replace)\n\t\t\t/* uc is converted from a surrogate pair.\n\t\t\t * this should be treated as a changed code. */\n\t\t\tucptr = NULL;\n\t\telse\n\t\t\tucptr = s;\n\t\ts += n;\n\t\tlen -= n;\n\n\t\t/* Read second code point. */\n\t\twhile ((n2 = parse(&uc2, s, len)) > 0) {\n\t\t\tuint32_t ucx[FDC_MAX];\n\t\t\tint ccx[FDC_MAX];\n\t\t\tint cl, cx, i, nx, ucx_size;\n\t\t\tint LIndex,SIndex;\n\t\t\tuint32_t nfc;\n\n\t\t\tif (n2 == spair || always_replace)\n\t\t\t\t/* uc2 is converted from a surrogate pair.\n\t\t\t \t * this should be treated as a changed code. */\n\t\t\t\tuc2ptr = NULL;\n\t\t\telse\n\t\t\t\tuc2ptr = s;\n\t\t\ts += n2;\n\t\t\tlen -= n2;\n\n\t\t\t/*\n\t\t\t * If current second code point is out of decomposable\n\t\t\t * code points, finding compositions is unneeded.\n\t\t\t */\n\t\t\tif (!IS_DECOMPOSABLE_BLOCK(uc2)) {\n\t\t\t\tWRITE_UC();\n\t\t\t\tREPLACE_UC_WITH_UC2();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to combine current code points.\n\t\t\t */\n\t\t\t/*\n\t\t\t * We have to combine Hangul characters according to\n\t\t\t * http://uniicode.org/reports/tr15/#Hangul\n\t\t\t */\n\t\t\tif (0 <= (LIndex = uc - HC_LBASE) &&\n\t\t\t    LIndex < HC_LCOUNT) {\n\t\t\t\t/*\n\t\t\t\t * Hangul Composition.\n\t\t\t\t * 1. Two current code points are L and V.\n\t\t\t\t */\n\t\t\t\tint VIndex = uc2 - HC_VBASE;\n\t\t\t\tif (0 <= VIndex && VIndex < HC_VCOUNT) {\n\t\t\t\t\t/* Make syllable of form LV. */\n\t\t\t\t\tUPDATE_UC(HC_SBASE +\n\t\t\t\t\t    (LIndex * HC_VCOUNT + VIndex) *\n\t\t\t\t\t     HC_TCOUNT);\n\t\t\t\t} else {\n\t\t\t\t\tWRITE_UC();\n\t\t\t\t\tREPLACE_UC_WITH_UC2();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (0 <= (SIndex = uc - HC_SBASE) &&\n\t\t\t    SIndex < HC_SCOUNT && (SIndex % HC_TCOUNT) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Hangul Composition.\n\t\t\t\t * 2. Two current code points are LV and T.\n\t\t\t\t */\n\t\t\t\tint TIndex = uc2 - HC_TBASE;\n\t\t\t\tif (0 < TIndex && TIndex < HC_TCOUNT) {\n\t\t\t\t\t/* Make syllable of form LVT. */\n\t\t\t\t\tUPDATE_UC(uc + TIndex);\n\t\t\t\t} else {\n\t\t\t\t\tWRITE_UC();\n\t\t\t\t\tREPLACE_UC_WITH_UC2();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if ((nfc = get_nfc(uc, uc2)) != 0) {\n\t\t\t\t/* A composition to current code points\n\t\t\t\t * is found. */\n\t\t\t\tUPDATE_UC(nfc);\n\t\t\t\tcontinue;\n\t\t\t} else if ((cl = CCC(uc2)) == 0) {\n\t\t\t\t/* Clearly 'uc2' the second code point is not\n\t\t\t\t * a decomposable code. */\n\t\t\t\tWRITE_UC();\n\t\t\t\tREPLACE_UC_WITH_UC2();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Collect following decomposable code points.\n\t\t\t */\n\t\t\tcx = 0;\n\t\t\tucx[0] = uc2;\n\t\t\tccx[0] = cl;\n\t\t\tCOLLECT_CPS(1);\n\n\t\t\t/*\n\t\t\t * Find a composed code in the collected code points.\n\t\t\t */\n\t\t\ti = 1;\n\t\t\twhile (i < ucx_size) {\n\t\t\t\tint j;\n\n\t\t\t\tif ((nfc = get_nfc(uc, ucx[i])) == 0) {\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * nfc is composed of uc and ucx[i].\n\t\t\t\t */\n\t\t\t\tUPDATE_UC(nfc);\n\n\t\t\t\t/*\n\t\t\t\t * Remove ucx[i] by shifting\n\t\t\t\t * following code points.\n\t\t\t\t */\n\t\t\t\tfor (j = i; j+1 < ucx_size; j++) {\n\t\t\t\t\tucx[j] = ucx[j+1];\n\t\t\t\t\tccx[j] = ccx[j+1];\n\t\t\t\t}\n\t\t\t\tucx_size --;\n\n\t\t\t\t/*\n\t\t\t\t * Collect following code points blocked\n\t\t\t\t * by ucx[i] the removed code point.\n\t\t\t\t */\n\t\t\t\tif (ucx_size > 0 && i == ucx_size &&\n\t\t\t\t    nx > 0 && cx == cl) {\n\t\t\t\t\tcl =  ccx[ucx_size-1];\n\t\t\t\t\tCOLLECT_CPS(ucx_size);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Restart finding a composed code with\n\t\t\t\t * the updated uc from the top of the\n\t\t\t\t * collected code points.\n\t\t\t\t */\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Apparently the current code points are not\n\t\t\t * decomposed characters or already composed.\n\t\t\t */\n\t\t\tWRITE_UC();\n\t\t\tfor (i = 0; i < ucx_size; i++)\n\t\t\t\tUNPARSE(p, endp, ucx[i]);\n\n\t\t\t/*\n\t\t\t * Flush out remaining canonical combining characters.\n\t\t\t */\n\t\t\tif (nx > 0 && cx == cl && len > 0) {\n\t\t\t\twhile ((nx = parse(&ucx[0], s, len))\n\t\t\t\t    > 0) {\n\t\t\t\t\tcx = CCC(ucx[0]);\n\t\t\t\t\tif (cl > cx)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ts += nx;\n\t\t\t\t\tlen -= nx;\n\t\t\t\t\tcl = cx;\n\t\t\t\t\tUNPARSE(p, endp, ucx[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (n2 < 0) {\n\t\t\tWRITE_UC();\n\t\t\t/* Use a replaced unicode character. */\n\t\t\tUNPARSE(p, endp, uc2);\n\t\t\ts += n2*-1;\n\t\t\tlen -= n2*-1;\n\t\t\tret = -1;\n\t\t\tcontinue;\n\t\t} else if (n2 == 0) {\n\t\t\tWRITE_UC();\n\t\t\tbreak;\n\t\t}\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\tif (ts == 2)\n\t\tas->s[as->length+1] = '\\0';\n\treturn (ret);\n}\n\nstatic int\nget_nfd(uint32_t *cp1, uint32_t *cp2, uint32_t uc)\n{\n\tint t, b;\n\n\t/*\n\t * These are not converted to NFD on Mac OS.\n\t */\n\tif ((uc >= 0x2000 && uc <= 0x2FFF) ||\n\t    (uc >= 0xF900 && uc <= 0xFAFF) ||\n\t    (uc >= 0x2F800 && uc <= 0x2FAFF))\n\t\treturn (0);\n\t/*\n\t * Those code points are not converted to NFD on Mac OS.\n\t * I do not know the reason because it is undocumented.\n\t *   NFC        NFD\n\t *   1109A  ==> 11099 110BA\n\t *   1109C  ==> 1109B 110BA\n\t *   110AB  ==> 110A5 110BA\n\t */\n\tif (uc == 0x1109A || uc == 0x1109C || uc == 0x110AB)\n\t\treturn (0);\n\n\tt = 0;\n\tb = sizeof(u_decomposition_table)/sizeof(u_decomposition_table[0]) -1;\n\twhile (b >= t) {\n\t\tint m = (t + b) / 2;\n\t\tif (u_decomposition_table[m].nfc < uc)\n\t\t\tt = m + 1;\n\t\telse if (u_decomposition_table[m].nfc > uc)\n\t\t\tb = m - 1;\n\t\telse {\n\t\t\t*cp1 = u_decomposition_table[m].cp1;\n\t\t\t*cp2 = u_decomposition_table[m].cp2;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\n#define REPLACE_UC_WITH(cp) do {\t\t\\\n\tuc = cp;\t\t\t\t\\\n\tucptr = NULL;\t\t\t\t\\\n} while (0)\n\n/*\n * Normalize UTF-8 characters to Form D and copy the result.\n */\nstatic int\narchive_string_normalize_D(struct archive_string *as, const void *_p,\n    size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s = (const char *)_p;\n\tchar *p, *endp;\n\tuint32_t uc, uc2;\n\tsize_t w;\n\tint always_replace, n, n2, ret = 0, spair, ts, tm;\n\tint (*parse)(uint32_t *, const char *, size_t);\n\tsize_t (*unparse)(char *, size_t, uint32_t);\n\n\talways_replace = 1;\n\tts = 1;/* text size. */\n\tif (sc->flag & SCONV_TO_UTF16BE) {\n\t\tunparse = unicode_to_utf16be;\n\t\tts = 2;\n\t\tif (sc->flag & SCONV_FROM_UTF16BE)\n\t\t\talways_replace = 0;\n\t} else if (sc->flag & SCONV_TO_UTF16LE) {\n\t\tunparse = unicode_to_utf16le;\n\t\tts = 2;\n\t\tif (sc->flag & SCONV_FROM_UTF16LE)\n\t\t\talways_replace = 0;\n\t} else if (sc->flag & SCONV_TO_UTF8) {\n\t\tunparse = unicode_to_utf8;\n\t\tif (sc->flag & SCONV_FROM_UTF8)\n\t\t\talways_replace = 0;\n\t} else {\n\t\t/*\n\t\t * This case is going to be converted to another\n\t\t * character-set through iconv.\n\t\t */\n\t\talways_replace = 0;\n\t\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\t\tunparse = unicode_to_utf16be;\n\t\t\tts = 2;\n\t\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\t\tunparse = unicode_to_utf16le;\n\t\t\tts = 2;\n\t\t} else {\n\t\t\tunparse = unicode_to_utf8;\n\t\t}\n\t}\n\n\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\tparse = utf16be_to_unicode;\n\t\ttm = 1;\n\t\tspair = 4;/* surrogate pair size in UTF-16. */\n\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\tparse = utf16le_to_unicode;\n\t\ttm = 1;\n\t\tspair = 4;/* surrogate pair size in UTF-16. */\n\t} else {\n\t\tparse = cesu8_to_unicode;\n\t\ttm = ts;\n\t\tspair = 6;/* surrogate pair size in UTF-8. */\n\t}\n\n\tif (archive_string_ensure(as, as->length + len * tm + ts) == NULL)\n\t\treturn (-1);\n\n\tp = as->s + as->length;\n\tendp = as->s + as->buffer_length - ts;\n\twhile ((n = parse(&uc, s, len)) != 0) {\n\t\tconst char *ucptr;\n\t\tuint32_t cp1, cp2;\n\t\tint SIndex;\n\t\tstruct {\n\t\t\tuint32_t uc;\n\t\t\tint ccc;\n\t\t} fdc[FDC_MAX];\n\t\tint fdi, fdj;\n\t\tint ccc;\n\ncheck_first_code:\n\t\tif (n < 0) {\n\t\t\t/* Use a replaced unicode character. */\n\t\t\tUNPARSE(p, endp, uc);\n\t\t\ts += n*-1;\n\t\t\tlen -= n*-1;\n\t\t\tret = -1;\n\t\t\tcontinue;\n\t\t} else if (n == spair || always_replace)\n\t\t\t/* uc is converted from a surrogate pair.\n\t\t\t * this should be treated as a changed code. */\n\t\t\tucptr = NULL;\n\t\telse\n\t\t\tucptr = s;\n\t\ts += n;\n\t\tlen -= n;\n\n\t\t/* Hangul Decomposition. */\n\t\tif ((SIndex = uc - HC_SBASE) >= 0 && SIndex < HC_SCOUNT) {\n\t\t\tint L = HC_LBASE + SIndex / HC_NCOUNT;\n\t\t\tint V = HC_VBASE + (SIndex % HC_NCOUNT) / HC_TCOUNT;\n\t\t\tint T = HC_TBASE + SIndex % HC_TCOUNT;\n\n\t\t\tREPLACE_UC_WITH(L);\n\t\t\tWRITE_UC();\n\t\t\tREPLACE_UC_WITH(V);\n\t\t\tWRITE_UC();\n\t\t\tif (T != HC_TBASE) {\n\t\t\t\tREPLACE_UC_WITH(T);\n\t\t\t\tWRITE_UC();\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_DECOMPOSABLE_BLOCK(uc) && CCC(uc) != 0) {\n\t\t\tWRITE_UC();\n\t\t\tcontinue;\n\t\t}\n\n\t\tfdi = 0;\n\t\twhile (get_nfd(&cp1, &cp2, uc) && fdi < FDC_MAX) {\n\t\t\tint k;\n\n\t\t\tfor (k = fdi; k > 0; k--)\n\t\t\t\tfdc[k] = fdc[k-1];\n\t\t\tfdc[0].ccc = CCC(cp2);\n\t\t\tfdc[0].uc = cp2;\n\t\t\tfdi++;\n\t\t\tREPLACE_UC_WITH(cp1);\n\t\t}\n\n\t\t/* Read following code points. */\n\t\twhile ((n2 = parse(&uc2, s, len)) > 0 &&\n\t\t    (ccc = CCC(uc2)) != 0 && fdi < FDC_MAX) {\n\t\t\tint j, k;\n\n\t\t\ts += n2;\n\t\t\tlen -= n2;\n\t\t\tfor (j = 0; j < fdi; j++) {\n\t\t\t\tif (fdc[j].ccc > ccc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < fdi) {\n\t\t\t\tfor (k = fdi; k > j; k--)\n\t\t\t\t\tfdc[k] = fdc[k-1];\n\t\t\t\tfdc[j].ccc = ccc;\n\t\t\t\tfdc[j].uc = uc2;\n\t\t\t} else {\n\t\t\t\tfdc[fdi].ccc = ccc;\n\t\t\t\tfdc[fdi].uc = uc2;\n\t\t\t}\n\t\t\tfdi++;\n\t\t}\n\n\t\tWRITE_UC();\n\t\tfor (fdj = 0; fdj < fdi; fdj++) {\n\t\t\tREPLACE_UC_WITH(fdc[fdj].uc);\n\t\t\tWRITE_UC();\n\t\t}\n\n\t\tif (n2 == 0)\n\t\t\tbreak;\n\t\tREPLACE_UC_WITH(uc2);\n\t\tn = n2;\n\t\tgoto check_first_code;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\tif (ts == 2)\n\t\tas->s[as->length+1] = '\\0';\n\treturn (ret);\n}\n\n/*\n * libarchive 2.x made incorrect UTF-8 strings in the wrong assumption\n * that WCS is Unicode. It is true for several platforms but some are false.\n * And then people who did not use UTF-8 locale on the non Unicode WCS\n * platform and made a tar file with libarchive(mostly bsdtar) 2.x. Those\n * now cannot get right filename from libarchive 3.x and later since we\n * fixed the wrong assumption and it is incompatible to older its versions.\n * So we provide special option, \"compat-2x.x\", for resolving it.\n * That option enable the string conversion of libarchive 2.x.\n *\n * Translates the wrong UTF-8 string made by libarchive 2.x into current\n * locale character set and appends to the archive_string.\n * Note: returns -1 if conversion fails.\n */\nstatic int\nstrncat_from_utf8_libarchive2(struct archive_string *as,\n    const void *_p, size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tint n;\n\tchar *p;\n\tchar *end;\n\tuint32_t unicode;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\t/* Clear the shift state before starting. */\n\twctomb(NULL, L'\\0');\n#endif\n\t(void)sc; /* UNUSED */\n\t/*\n\t * Allocate buffer for MBS.\n\t * We need this allocation here since it is possible that\n\t * as->s is still NULL.\n\t */\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {\n\t\twchar_t wc;\n\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\t/* Re-allocate buffer for MBS. */\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n\n\t\t/*\n\t\t * As libarchive 2.x, translates the UTF-8 characters into\n\t\t * wide-characters in the assumption that WCS is Unicode.\n\t\t */\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\twc = L'?';\n\t\t} else\n\t\t\twc = (wchar_t)unicode;\n\n\t\ts += n;\n\t\tlen -= n;\n\t\t/*\n\t\t * Translates the wide-character into the current locale MBS.\n\t\t */\n#if HAVE_WCRTOMB\n\t\tn = (int)wcrtomb(p, wc, &shift_state);\n#else\n\t\tn = (int)wctomb(p, wc);\n#endif\n\t\tif (n == -1)\n\t\t\treturn (-1);\n\t\tp += n;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (0);\n}\n\n\n/*\n * Conversion functions between current locale dependent MBS and UTF-16BE.\n *   strncat_from_utf16be() : UTF-16BE --> MBS\n *   strncat_to_utf16be()   : MBS --> UTF16BE\n */\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\n/*\n * Convert a UTF-16BE/LE string to current locale and copy the result.\n * Return -1 if conversion fails.\n */\nstatic int\nwin_strncat_from_utf16(struct archive_string *as, const void *_p, size_t bytes,\n    struct archive_string_conv *sc, int be)\n{\n\tstruct archive_string tmp;\n\tconst char *u16;\n\tint ll;\n\tBOOL defchar;\n\tchar *mbs;\n\tsize_t mbs_size, b;\n\tint ret = 0;\n\n\tbytes &= ~1;\n\tif (archive_string_ensure(as, as->length + bytes +1) == NULL)\n\t\treturn (-1);\n\n\tmbs = as->s + as->length;\n\tmbs_size = as->buffer_length - as->length -1;\n\n\tif (sc->to_cp == CP_C_LOCALE) {\n\t\t/*\n\t\t * \"C\" locale special process.\n\t\t */\n\t\tu16 = _p;\n\t\tll = 0;\n\t\tfor (b = 0; b < bytes; b += 2) {\n\t\t\tuint16_t val;\n\t\t\tif (be)\n\t\t\t\tval = archive_be16dec(u16+b);\n\t\t\telse\n\t\t\t\tval = archive_le16dec(u16+b);\n\t\t\tif (val > 255) {\n\t\t\t\t*mbs++ = '?';\n\t\t\t\tret = -1;\n\t\t\t} else\n\t\t\t\t*mbs++ = (char)(val&0xff);\n\t\t\tll++;\n\t\t}\n\t\tas->length += ll;\n\t\tas->s[as->length] = '\\0';\n\t\treturn (ret);\n\t}\n\n\tarchive_string_init(&tmp);\n\tif (be) {\n\t\tif (is_big_endian()) {\n\t\t\tu16 = _p;\n\t\t} else {\n\t\t\tif (archive_string_ensure(&tmp, bytes+2) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tmemcpy(tmp.s, _p, bytes);\n\t\t\tfor (b = 0; b < bytes; b += 2) {\n\t\t\t\tuint16_t val = archive_be16dec(tmp.s+b);\n\t\t\t\tarchive_le16enc(tmp.s+b, val);\n\t\t\t}\n\t\t\tu16 = tmp.s;\n\t\t}\n\t} else {\n\t\tif (!is_big_endian()) {\n\t\t\tu16 = _p;\n\t\t} else {\n\t\t\tif (archive_string_ensure(&tmp, bytes+2) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tmemcpy(tmp.s, _p, bytes);\n\t\t\tfor (b = 0; b < bytes; b += 2) {\n\t\t\t\tuint16_t val = archive_le16dec(tmp.s+b);\n\t\t\t\tarchive_be16enc(tmp.s+b, val);\n\t\t\t}\n\t\t\tu16 = tmp.s;\n\t\t}\n\t}\n\n\tdo {\n\t\tdefchar = 0;\n\t\tll = WideCharToMultiByte(sc->to_cp, 0,\n\t\t    (LPCWSTR)u16, (int)bytes>>1, mbs, (int)mbs_size,\n\t\t\tNULL, &defchar);\n\t\t/* Exit loop if we succeeded */\n\t\tif (ll != 0 ||\n\t\t    GetLastError() != ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Else expand buffer and loop to try again. */\n\t\tll = WideCharToMultiByte(sc->to_cp, 0,\n\t\t    (LPCWSTR)u16, (int)bytes, NULL, 0, NULL, NULL);\n\t\tif (archive_string_ensure(as, ll +1) == NULL)\n\t\t\treturn (-1);\n\t\tmbs = as->s + as->length;\n\t\tmbs_size = as->buffer_length - as->length -1;\n\t} while (1);\n\tarchive_string_free(&tmp);\n\tas->length += ll;\n\tas->s[as->length] = '\\0';\n\tif (ll == 0 || defchar)\n\t\tret = -1;\n\treturn (ret);\n}\n\nstatic int\nwin_strncat_from_utf16be(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc)\n{\n\treturn (win_strncat_from_utf16(as, _p, bytes, sc, 1));\n}\n\nstatic int\nwin_strncat_from_utf16le(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc)\n{\n\treturn (win_strncat_from_utf16(as, _p, bytes, sc, 0));\n}\n\nstatic int\nis_big_endian(void)\n{\n\tuint16_t d = 1;\n\n\treturn (archive_be16dec(&d) == 1);\n}\n\n/*\n * Convert a current locale string to UTF-16BE/LE and copy the result.\n * Return -1 if conversion fails.\n */\nstatic int\nwin_strncat_to_utf16(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc, int bigendian)\n{\n\tconst char *s = (const char *)_p;\n\tchar *u16;\n\tsize_t count, avail;\n\n\tif (archive_string_ensure(as16,\n\t    as16->length + (length + 1) * 2) == NULL)\n\t\treturn (-1);\n\n\tu16 = as16->s + as16->length;\n\tavail = as16->buffer_length - 2;\n\tif (sc->from_cp == CP_C_LOCALE) {\n\t\t/*\n\t\t * \"C\" locale special process.\n\t\t */\n\t\tcount = 0;\n\t\twhile (count < length && *s) {\n\t\t\tif (bigendian)\n\t\t\t\tarchive_be16enc(u16, *s);\n\t\t\telse\n\t\t\t\tarchive_le16enc(u16, *s);\n\t\t\tu16 += 2;\n\t\t\ts++;\n\t\t\tcount++;\n\t\t}\n\t\tas16->length += count << 1;\n\t\tas16->s[as16->length] = 0;\n\t\tas16->s[as16->length+1] = 0;\n\t\treturn (0);\n\t}\n\tdo {\n\t\tcount = MultiByteToWideChar(sc->from_cp,\n\t\t    MB_PRECOMPOSED, s, (int)length, (LPWSTR)u16, (int)avail>>1);\n\t\t/* Exit loop if we succeeded */\n\t\tif (count != 0 ||\n\t\t    GetLastError() != ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Expand buffer and try again */\n\t\tcount = MultiByteToWideChar(sc->from_cp,\n\t\t    MB_PRECOMPOSED, s, (int)length, NULL, 0);\n\t\tif (archive_string_ensure(as16, (count +1) * 2)\n\t\t    == NULL)\n\t\t\treturn (-1);\n\t\tu16 = as16->s + as16->length;\n\t\tavail = as16->buffer_length - 2;\n\t} while (1);\n\tas16->length += count * 2;\n\tas16->s[as16->length] = 0;\n\tas16->s[as16->length+1] = 0;\n\tif (count == 0)\n\t\treturn (-1);\n\n\tif (is_big_endian()) {\n\t\tif (!bigendian) {\n\t\t\twhile (count > 0) {\n\t\t\t\tuint16_t v = archive_be16dec(u16);\n\t\t\t\tarchive_le16enc(u16, v);\n\t\t\t\tu16 += 2;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (bigendian) {\n\t\t\twhile (count > 0) {\n\t\t\t\tuint16_t v = archive_le16dec(u16);\n\t\t\t\tarchive_be16enc(u16, v);\n\t\t\t\tu16 += 2;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nwin_strncat_to_utf16be(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\treturn (win_strncat_to_utf16(as16, _p, length, sc, 1));\n}\n\nstatic int\nwin_strncat_to_utf16le(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\treturn (win_strncat_to_utf16(as16, _p, length, sc, 0));\n}\n\n#endif /* _WIN32 && !__CYGWIN__ */\n\n/*\n * Do the best effort for conversions.\n * We cannot handle UTF-16BE character-set without such iconv,\n * but there is a chance if a string consists just ASCII code or\n * a current locale is UTF-8.\n */\n\n/*\n * Convert a UTF-16BE string to current locale and copy the result.\n * Return -1 if conversion fails.\n */\nstatic int\nbest_effort_strncat_from_utf16(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc, int be)\n{\n\tconst char *utf16 = (const char *)_p;\n\tchar *mbs;\n\tuint32_t uc;\n\tint n, ret;\n\n\t(void)sc; /* UNUSED */\n\t/*\n\t * Other case, we should do the best effort.\n\t * If all character are ASCII(<0x7f), we can convert it.\n\t * if not , we set a alternative character and return -1.\n\t */\n\tret = 0;\n\tif (archive_string_ensure(as, as->length + bytes +1) == NULL)\n\t\treturn (-1);\n\tmbs = as->s + as->length;\n\n\twhile ((n = utf16_to_unicode(&uc, utf16, bytes, be)) != 0) {\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\tret =  -1;\n\t\t}\n\t\tbytes -= n;\n\t\tutf16 += n;\n\n\t\tif (uc > 127) {\n\t\t\t/* We cannot handle it. */\n\t\t\t*mbs++ = '?';\n\t\t\tret =  -1;\n\t\t} else\n\t\t\t*mbs++ = (char)uc;\n\t}\n\tas->length = mbs - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret);\n}\n\nstatic int\nbest_effort_strncat_from_utf16be(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc)\n{\n\treturn (best_effort_strncat_from_utf16(as, _p, bytes, sc, 1));\n}\n\nstatic int\nbest_effort_strncat_from_utf16le(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc)\n{\n\treturn (best_effort_strncat_from_utf16(as, _p, bytes, sc, 0));\n}\n\n/*\n * Convert a current locale string to UTF-16BE/LE and copy the result.\n * Return -1 if conversion fails.\n */\nstatic int\nbest_effort_strncat_to_utf16(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc, int bigendian)\n{\n\tconst char *s = (const char *)_p;\n\tchar *utf16;\n\tsize_t remaining;\n\tint ret;\n\n\t(void)sc; /* UNUSED */\n\t/*\n\t * Other case, we should do the best effort.\n\t * If all character are ASCII(<0x7f), we can convert it.\n\t * if not , we set a alternative character and return -1.\n\t */\n\tret = 0;\n\tremaining = length;\n\n\tif (archive_string_ensure(as16,\n\t    as16->length + (length + 1) * 2) == NULL)\n\t\treturn (-1);\n\n\tutf16 = as16->s + as16->length;\n\twhile (remaining--) {\n\t\tunsigned c = *s++;\n\t\tif (c > 127) {\n\t\t\t/* We cannot handle it. */\n\t\t\tc = UNICODE_R_CHAR;\n\t\t\tret = -1;\n\t\t}\n\t\tif (bigendian)\n\t\t\tarchive_be16enc(utf16, c);\n\t\telse\n\t\t\tarchive_le16enc(utf16, c);\n\t\tutf16 += 2;\n\t}\n\tas16->length = utf16 - as16->s;\n\tas16->s[as16->length] = 0;\n\tas16->s[as16->length+1] = 0;\n\treturn (ret);\n}\n\nstatic int\nbest_effort_strncat_to_utf16be(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\treturn (best_effort_strncat_to_utf16(as16, _p, length, sc, 1));\n}\n\nstatic int\nbest_effort_strncat_to_utf16le(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\treturn (best_effort_strncat_to_utf16(as16, _p, length, sc, 0));\n}\n\n\n/*\n * Multistring operations.\n */\n\nvoid\narchive_mstring_clean(struct archive_mstring *aes)\n{\n\tarchive_wstring_free(&(aes->aes_wcs));\n\tarchive_string_free(&(aes->aes_mbs));\n\tarchive_string_free(&(aes->aes_utf8));\n\tarchive_string_free(&(aes->aes_mbs_in_locale));\n\taes->aes_set = 0;\n}\n\nvoid\narchive_mstring_copy(struct archive_mstring *dest, struct archive_mstring *src)\n{\n\tdest->aes_set = src->aes_set;\n\tarchive_string_copy(&(dest->aes_mbs), &(src->aes_mbs));\n\tarchive_string_copy(&(dest->aes_utf8), &(src->aes_utf8));\n\tarchive_wstring_copy(&(dest->aes_wcs), &(src->aes_wcs));\n}\n\nint\narchive_mstring_get_utf8(struct archive *a, struct archive_mstring *aes,\n  const char **p)\n{\n\tstruct archive_string_conv *sc;\n\tint r;\n\n\t/* If we already have a UTF8 form, return that immediately. */\n\tif (aes->aes_set & AES_SET_UTF8) {\n\t\t*p = aes->aes_utf8.s;\n\t\treturn (0);\n\t}\n\n\t*p = NULL;\n\tif (aes->aes_set & AES_SET_MBS) {\n\t\tsc = archive_string_conversion_to_charset(a, \"UTF-8\", 1);\n\t\tif (sc == NULL)\n\t\t\treturn (-1);/* Couldn't allocate memory for sc. */\n\t\tr = archive_strncpy_l(&(aes->aes_utf8), aes->aes_mbs.s,\n\t\t    aes->aes_mbs.length, sc);\n\t\tif (a == NULL)\n\t\t\tfree_sconv_object(sc);\n\t\tif (r == 0) {\n\t\t\taes->aes_set |= AES_SET_UTF8;\n\t\t\t*p = aes->aes_utf8.s;\n\t\t\treturn (0);/* success. */\n\t\t} else\n\t\t\treturn (-1);/* failure. */\n\t}\n\treturn (0);/* success. */\n}\n\nint\narchive_mstring_get_mbs(struct archive *a, struct archive_mstring *aes,\n    const char **p)\n{\n\tint r, ret = 0;\n\n\t(void)a; /* UNUSED */\n\t/* If we already have an MBS form, return that immediately. */\n\tif (aes->aes_set & AES_SET_MBS) {\n\t\t*p = aes->aes_mbs.s;\n\t\treturn (ret);\n\t}\n\n\t*p = NULL;\n\t/* If there's a WCS form, try converting with the native locale. */\n\tif (aes->aes_set & AES_SET_WCS) {\n\t\tarchive_string_empty(&(aes->aes_mbs));\n\t\tr = archive_string_append_from_wcs(&(aes->aes_mbs),\n\t\t    aes->aes_wcs.s, aes->aes_wcs.length);\n\t\t*p = aes->aes_mbs.s;\n\t\tif (r == 0) {\n\t\t\taes->aes_set |= AES_SET_MBS;\n\t\t\treturn (ret);\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\t/*\n\t * Only a UTF-8 form cannot avail because its conversion already\n\t * failed at archive_mstring_update_utf8().\n\t */\n\treturn (ret);\n}\n\nint\narchive_mstring_get_wcs(struct archive *a, struct archive_mstring *aes,\n    const wchar_t **wp)\n{\n\tint r, ret = 0;\n\n\t(void)a;/* UNUSED */\n\t/* Return WCS form if we already have it. */\n\tif (aes->aes_set & AES_SET_WCS) {\n\t\t*wp = aes->aes_wcs.s;\n\t\treturn (ret);\n\t}\n\n\t*wp = NULL;\n\t/* Try converting MBS to WCS using native locale. */\n\tif (aes->aes_set & AES_SET_MBS) {\n\t\tarchive_wstring_empty(&(aes->aes_wcs));\n\t\tr = archive_wstring_append_from_mbs(&(aes->aes_wcs),\n\t\t    aes->aes_mbs.s, aes->aes_mbs.length);\n\t\tif (r == 0) {\n\t\t\taes->aes_set |= AES_SET_WCS;\n\t\t\t*wp = aes->aes_wcs.s;\n\t\t} else\n\t\t\tret = -1;/* failure. */\n\t}\n\treturn (ret);\n}\n\nint\narchive_mstring_get_mbs_l(struct archive_mstring *aes,\n    const char **p, size_t *length, struct archive_string_conv *sc)\n{\n\tint r, ret = 0;\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/*\n\t * Internationalization programming on Windows must use Wide\n\t * characters because Windows platform cannot make locale UTF-8.\n\t */\n\tif (sc != NULL && (aes->aes_set & AES_SET_WCS) != 0) {\n\t\tarchive_string_empty(&(aes->aes_mbs_in_locale));\n\t\tr = archive_string_append_from_wcs_in_codepage(\n\t\t    &(aes->aes_mbs_in_locale), aes->aes_wcs.s,\n\t\t    aes->aes_wcs.length, sc);\n\t\tif (r == 0) {\n\t\t\t*p = aes->aes_mbs_in_locale.s;\n\t\t\tif (length != NULL)\n\t\t\t\t*length = aes->aes_mbs_in_locale.length;\n\t\t\treturn (0);\n\t\t} else if (errno == ENOMEM)\n\t\t\treturn (-1);\n\t\telse\n\t\t\tret = -1;\n\t}\n#endif\n\n\t/* If there is not an MBS form but is a WCS form, try converting\n\t * with the native locale to be used for translating it to specified\n\t * character-set. */\n\tif ((aes->aes_set & AES_SET_MBS) == 0 &&\n\t    (aes->aes_set & AES_SET_WCS) != 0) {\n\t\tarchive_string_empty(&(aes->aes_mbs));\n\t\tr = archive_string_append_from_wcs(&(aes->aes_mbs),\n\t\t    aes->aes_wcs.s, aes->aes_wcs.length);\n\t\tif (r == 0)\n\t\t\taes->aes_set |= AES_SET_MBS;\n\t\telse if (errno == ENOMEM)\n\t\t\treturn (-1);\n\t\telse\n\t\t\tret = -1;\n\t}\n\t/* If we already have an MBS form, use it to be translated to\n\t * specified character-set. */\n\tif (aes->aes_set & AES_SET_MBS) {\n\t\tif (sc == NULL) {\n\t\t\t/* Conversion is unneeded. */\n\t\t\t*p = aes->aes_mbs.s;\n\t\t\tif (length != NULL)\n\t\t\t\t*length = aes->aes_mbs.length;\n\t\t\treturn (0);\n\t\t}\n\t\tret = archive_strncpy_l(&(aes->aes_mbs_in_locale),\n\t\t    aes->aes_mbs.s, aes->aes_mbs.length, sc);\n\t\t*p = aes->aes_mbs_in_locale.s;\n\t\tif (length != NULL)\n\t\t\t*length = aes->aes_mbs_in_locale.length;\n\t} else {\n\t\t*p = NULL;\n\t\tif (length != NULL)\n\t\t\t*length = 0;\n\t}\n\treturn (ret);\n}\n\nint\narchive_mstring_copy_mbs(struct archive_mstring *aes, const char *mbs)\n{\n\tif (mbs == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0);\n\t}\n\treturn (archive_mstring_copy_mbs_len(aes, mbs, strlen(mbs)));\n}\n\nint\narchive_mstring_copy_mbs_len(struct archive_mstring *aes, const char *mbs,\n    size_t len)\n{\n\tif (mbs == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0);\n\t}\n\taes->aes_set = AES_SET_MBS; /* Only MBS form is set now. */\n\tarchive_strncpy(&(aes->aes_mbs), mbs, len);\n\tarchive_string_empty(&(aes->aes_utf8));\n\tarchive_wstring_empty(&(aes->aes_wcs));\n\treturn (0);\n}\n\nint\narchive_mstring_copy_wcs(struct archive_mstring *aes, const wchar_t *wcs)\n{\n\treturn archive_mstring_copy_wcs_len(aes, wcs,\n\t\t\t\twcs == NULL ? 0 : wcslen(wcs));\n}\n\nint\narchive_mstring_copy_utf8(struct archive_mstring *aes, const char *utf8)\n{\n  if (utf8 == NULL) {\n    aes->aes_set = 0;\n    return (0);\n  }\n  aes->aes_set = AES_SET_UTF8;\n  archive_string_empty(&(aes->aes_mbs));\n  archive_string_empty(&(aes->aes_wcs));\n  archive_strncpy(&(aes->aes_utf8), utf8, strlen(utf8));\n  return (int)strlen(utf8);\n}\n\nint\narchive_mstring_copy_wcs_len(struct archive_mstring *aes, const wchar_t *wcs,\n    size_t len)\n{\n\tif (wcs == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0);\n\t}\n\taes->aes_set = AES_SET_WCS; /* Only WCS form set. */\n\tarchive_string_empty(&(aes->aes_mbs));\n\tarchive_string_empty(&(aes->aes_utf8));\n\tarchive_wstrncpy(&(aes->aes_wcs), wcs, len);\n\treturn (0);\n}\n\nint\narchive_mstring_copy_mbs_len_l(struct archive_mstring *aes,\n    const char *mbs, size_t len, struct archive_string_conv *sc)\n{\n\tint r;\n\n\tif (mbs == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0);\n\t}\n\tarchive_string_empty(&(aes->aes_mbs));\n\tarchive_wstring_empty(&(aes->aes_wcs));\n\tarchive_string_empty(&(aes->aes_utf8));\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/*\n\t * Internationalization programming on Windows must use Wide\n\t * characters because Windows platform cannot make locale UTF-8.\n\t */\n\tif (sc == NULL) {\n\t\tif (archive_string_append(&(aes->aes_mbs),\n\t\t\tmbs, mbsnbytes(mbs, len)) == NULL) {\n\t\t\taes->aes_set = 0;\n\t\t\tr = -1;\n\t\t} else {\n\t\t\taes->aes_set = AES_SET_MBS;\n\t\t\tr = 0;\n\t\t}\n#if defined(HAVE_ICONV)\n\t} else if (sc != NULL && sc->cd_w != (iconv_t)-1) {\n\t\t/*\n\t\t * This case happens only when MultiByteToWideChar() cannot\n\t\t * handle sc->from_cp, and we have to iconv in order to\n\t\t * translate character-set to wchar_t,UTF-16.\n\t\t */\n\t\ticonv_t cd = sc->cd;\n\t\tunsigned from_cp;\n\t\tint flag;\n\n\t\t/*\n\t\t * Translate multi-bytes from some character-set to UTF-8.\n\t\t */ \n\t\tsc->cd = sc->cd_w;\n\t\tr = archive_strncpy_l(&(aes->aes_utf8), mbs, len, sc);\n\t\tsc->cd = cd;\n\t\tif (r != 0) {\n\t\t\taes->aes_set = 0;\n\t\t\treturn (r);\n\t\t}\n\t\taes->aes_set = AES_SET_UTF8;\n\n\t\t/*\n\t\t * Append the UTF-8 string into wstring.\n\t\t */ \n\t\tflag = sc->flag;\n\t\tsc->flag &= ~(SCONV_NORMALIZATION_C\n\t\t\t\t| SCONV_TO_UTF16| SCONV_FROM_UTF16);\n\t\tfrom_cp = sc->from_cp;\n\t\tsc->from_cp = CP_UTF8;\n\t\tr = archive_wstring_append_from_mbs_in_codepage(&(aes->aes_wcs),\n\t\t\taes->aes_utf8.s, aes->aes_utf8.length, sc);\n\t\tsc->flag = flag;\n\t\tsc->from_cp = from_cp;\n\t\tif (r == 0)\n\t\t\taes->aes_set |= AES_SET_WCS;\n#endif\n\t} else {\n\t\tr = archive_wstring_append_from_mbs_in_codepage(\n\t\t    &(aes->aes_wcs), mbs, len, sc);\n\t\tif (r == 0)\n\t\t\taes->aes_set = AES_SET_WCS;\n\t\telse\n\t\t\taes->aes_set = 0;\n\t}\n#else\n\tr = archive_strncpy_l(&(aes->aes_mbs), mbs, len, sc);\n\tif (r == 0)\n\t\taes->aes_set = AES_SET_MBS; /* Only MBS form is set now. */\n\telse\n\t\taes->aes_set = 0;\n#endif\n\treturn (r);\n}\n\n/*\n * The 'update' form tries to proactively update all forms of\n * this string (WCS and MBS) and returns an error if any of\n * them fail.  This is used by the 'pax' handler, for instance,\n * to detect and report character-conversion failures early while\n * still allowing clients to get potentially useful values from\n * the more tolerant lazy conversions.  (get_mbs and get_wcs will\n * strive to give the user something useful, so you can get hopefully\n * usable values even if some of the character conversions are failing.)\n */\nint\narchive_mstring_update_utf8(struct archive *a, struct archive_mstring *aes,\n    const char *utf8)\n{\n\tstruct archive_string_conv *sc;\n\tint r;\n\n\tif (utf8 == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0); /* Succeeded in clearing everything. */\n\t}\n\n\t/* Save the UTF8 string. */\n\tarchive_strcpy(&(aes->aes_utf8), utf8);\n\n\t/* Empty the mbs and wcs strings. */\n\tarchive_string_empty(&(aes->aes_mbs));\n\tarchive_wstring_empty(&(aes->aes_wcs));\n\n\taes->aes_set = AES_SET_UTF8;\t/* Only UTF8 is set now. */\n\n\t/* Try converting UTF-8 to MBS, return false on failure. */\n\tsc = archive_string_conversion_from_charset(a, \"UTF-8\", 1);\n\tif (sc == NULL)\n\t\treturn (-1);/* Couldn't allocate memory for sc. */\n\tr = archive_strcpy_l(&(aes->aes_mbs), utf8, sc);\n\tif (a == NULL)\n\t\tfree_sconv_object(sc);\n\tif (r != 0)\n\t\treturn (-1);\n\taes->aes_set = AES_SET_UTF8 | AES_SET_MBS; /* Both UTF8 and MBS set. */\n\n\t/* Try converting MBS to WCS, return false on failure. */\n\tif (archive_wstring_append_from_mbs(&(aes->aes_wcs), aes->aes_mbs.s,\n\t    aes->aes_mbs.length))\n\t\treturn (-1);\n\taes->aes_set = AES_SET_UTF8 | AES_SET_WCS | AES_SET_MBS;\n\n\t/* All conversions succeeded. */\n\treturn (0);\n}\n"], "fixing_code": ["/*-\n * Copyright (c) 2003-2011 Tim Kientzle\n * Copyright (c) 2011-2012 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_string.c 201095 2009-12-28 02:33:22Z kientzle $\");\n\n/*\n * Basic resizable string support, to simplify manipulating arbitrary-sized\n * strings while minimizing heap activity.\n *\n * In particular, the buffer used by a string object is only grown, it\n * never shrinks, so you can clear and reuse the same string object\n * without incurring additional memory allocations.\n */\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_ICONV_H\n#include <iconv.h>\n#endif\n#ifdef HAVE_LANGINFO_H\n#include <langinfo.h>\n#endif\n#ifdef HAVE_LOCALCHARSET_H\n#include <localcharset.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#ifdef HAVE_WCHAR_H\n#include <wchar.h>\n#endif\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#include <locale.h>\n#endif\n\n#include \"archive_endian.h\"\n#include \"archive_private.h\"\n#include \"archive_string.h\"\n#include \"archive_string_composition.h\"\n\n#if !defined(HAVE_WMEMCPY) && !defined(wmemcpy)\n#define wmemcpy(a,b,i)  (wchar_t *)memcpy((a), (b), (i) * sizeof(wchar_t))\n#endif\n\n#if !defined(HAVE_WMEMMOVE) && !defined(wmemmove)\n#define wmemmove(a,b,i)  (wchar_t *)memmove((a), (b), (i) * sizeof(wchar_t))\n#endif\n\nstruct archive_string_conv {\n\tstruct archive_string_conv\t*next;\n\tchar\t\t\t\t*from_charset;\n\tchar\t\t\t\t*to_charset;\n\tunsigned\t\t\t from_cp;\n\tunsigned\t\t\t to_cp;\n\t/* Set 1 if from_charset and to_charset are the same. */\n\tint\t\t\t\t same;\n\tint\t\t\t\t flag;\n#define SCONV_TO_CHARSET\t1\t/* MBS is being converted to specified\n\t\t\t\t\t * charset. */\n#define SCONV_FROM_CHARSET\t(1<<1)\t/* MBS is being converted from\n\t\t\t\t\t * specified charset. */\n#define SCONV_BEST_EFFORT \t(1<<2)\t/* Copy at least ASCII code. */\n#define SCONV_WIN_CP\t \t(1<<3)\t/* Use Windows API for converting\n\t\t\t\t\t * MBS. */\n#define SCONV_UTF8_LIBARCHIVE_2 (1<<4)\t/* Incorrect UTF-8 made by libarchive\n\t\t\t\t\t * 2.x in the wrong assumption. */\n#define SCONV_NORMALIZATION_C\t(1<<6)\t/* Need normalization to be Form C.\n\t\t\t\t\t * Before UTF-8 characters are actually\n\t\t\t\t\t * processed. */\n#define SCONV_NORMALIZATION_D\t(1<<7)\t/* Need normalization to be Form D.\n\t\t\t\t\t * Before UTF-8 characters are actually\n\t\t\t\t\t * processed.\n\t\t\t\t\t * Currently this only for MAC OS X. */\n#define SCONV_TO_UTF8\t\t(1<<8)\t/* \"to charset\" side is UTF-8. */\n#define SCONV_FROM_UTF8\t\t(1<<9)\t/* \"from charset\" side is UTF-8. */\n#define SCONV_TO_UTF16BE \t(1<<10)\t/* \"to charset\" side is UTF-16BE. */\n#define SCONV_FROM_UTF16BE \t(1<<11)\t/* \"from charset\" side is UTF-16BE. */\n#define SCONV_TO_UTF16LE \t(1<<12)\t/* \"to charset\" side is UTF-16LE. */\n#define SCONV_FROM_UTF16LE \t(1<<13)\t/* \"from charset\" side is UTF-16LE. */\n#define SCONV_TO_UTF16\t\t(SCONV_TO_UTF16BE | SCONV_TO_UTF16LE)\n#define SCONV_FROM_UTF16\t(SCONV_FROM_UTF16BE | SCONV_FROM_UTF16LE)\n\n#if HAVE_ICONV\n\ticonv_t\t\t\t\t cd;\n\ticonv_t\t\t\t\t cd_w;/* Use at archive_mstring on\n\t\t\t\t \t       * Windows. */\n#endif\n\t/* A temporary buffer for normalization. */\n\tstruct archive_string\t\t utftmp;\n\tint (*converter[2])(struct archive_string *, const void *, size_t,\n\t    struct archive_string_conv *);\n\tint\t\t\t\t nconverter;\n};\n\n#define CP_C_LOCALE\t0\t/* \"C\" locale only for this file. */\n#define CP_UTF16LE\t1200\n#define CP_UTF16BE\t1201\n\n#define IS_HIGH_SURROGATE_LA(uc) ((uc) >= 0xD800 && (uc) <= 0xDBFF)\n#define IS_LOW_SURROGATE_LA(uc)\t ((uc) >= 0xDC00 && (uc) <= 0xDFFF)\n#define IS_SURROGATE_PAIR_LA(uc) ((uc) >= 0xD800 && (uc) <= 0xDFFF)\n#define UNICODE_MAX\t\t0x10FFFF\n#define UNICODE_R_CHAR\t\t0xFFFD\t/* Replacement character. */\n/* Set U+FFFD(Replacement character) in UTF-8. */\nstatic const char utf8_replacement_char[] = {0xef, 0xbf, 0xbd};\n\nstatic struct archive_string_conv *find_sconv_object(struct archive *,\n\tconst char *, const char *);\nstatic void add_sconv_object(struct archive *, struct archive_string_conv *);\nstatic struct archive_string_conv *create_sconv_object(const char *,\n\tconst char *, unsigned, int);\nstatic void free_sconv_object(struct archive_string_conv *);\nstatic struct archive_string_conv *get_sconv_object(struct archive *,\n\tconst char *, const char *, int);\nstatic unsigned make_codepage_from_charset(const char *);\nstatic unsigned get_current_codepage(void);\nstatic unsigned get_current_oemcp(void);\nstatic size_t mbsnbytes(const void *, size_t);\nstatic size_t utf16nbytes(const void *, size_t);\n#if defined(_WIN32) && !defined(__CYGWIN__)\nstatic int archive_wstring_append_from_mbs_in_codepage(\n    struct archive_wstring *, const char *, size_t,\n    struct archive_string_conv *);\nstatic int archive_string_append_from_wcs_in_codepage(struct archive_string *,\n    const wchar_t *, size_t, struct archive_string_conv *);\nstatic int is_big_endian(void);\nstatic int strncat_in_codepage(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int win_strncat_from_utf16be(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int win_strncat_from_utf16le(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int win_strncat_to_utf16be(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int win_strncat_to_utf16le(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\n#endif\nstatic int best_effort_strncat_from_utf16be(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int best_effort_strncat_from_utf16le(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int best_effort_strncat_to_utf16be(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int best_effort_strncat_to_utf16le(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\n#if defined(HAVE_ICONV)\nstatic int iconv_strncat_in_locale(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\n#endif\nstatic int best_effort_strncat_in_locale(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int _utf8_to_unicode(uint32_t *, const char *, size_t);\nstatic int utf8_to_unicode(uint32_t *, const char *, size_t);\nstatic inline uint32_t combine_surrogate_pair(uint32_t, uint32_t);\nstatic int cesu8_to_unicode(uint32_t *, const char *, size_t);\nstatic size_t unicode_to_utf8(char *, size_t, uint32_t);\nstatic int utf16_to_unicode(uint32_t *, const char *, size_t, int);\nstatic size_t unicode_to_utf16be(char *, size_t, uint32_t);\nstatic size_t unicode_to_utf16le(char *, size_t, uint32_t);\nstatic int strncat_from_utf8_libarchive2(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\nstatic int strncat_from_utf8_to_utf8(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int archive_string_normalize_C(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int archive_string_normalize_D(struct archive_string *, const void *,\n    size_t, struct archive_string_conv *);\nstatic int archive_string_append_unicode(struct archive_string *,\n    const void *, size_t, struct archive_string_conv *);\n\nstatic struct archive_string *\narchive_string_append(struct archive_string *as, const char *p, size_t s)\n{\n\tif (archive_string_ensure(as, as->length + s + 1) == NULL)\n\t\treturn (NULL);\n\tif (s)\n\t\tmemmove(as->s + as->length, p, s);\n\tas->length += s;\n\tas->s[as->length] = 0;\n\treturn (as);\n}\n\nstatic struct archive_wstring *\narchive_wstring_append(struct archive_wstring *as, const wchar_t *p, size_t s)\n{\n\tif (archive_wstring_ensure(as, as->length + s + 1) == NULL)\n\t\treturn (NULL);\n\tif (s)\n\t\twmemmove(as->s + as->length, p, s);\n\tas->length += s;\n\tas->s[as->length] = 0;\n\treturn (as);\n}\n\nstruct archive_string *\narchive_array_append(struct archive_string *as, const char *p, size_t s)\n{\n\treturn archive_string_append(as, p, s);\n}\n\nvoid\narchive_string_concat(struct archive_string *dest, struct archive_string *src)\n{\n\tif (archive_string_append(dest, src->s, src->length) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n}\n\nvoid\narchive_wstring_concat(struct archive_wstring *dest,\n    struct archive_wstring *src)\n{\n\tif (archive_wstring_append(dest, src->s, src->length) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n}\n\nvoid\narchive_string_free(struct archive_string *as)\n{\n\tas->length = 0;\n\tas->buffer_length = 0;\n\tfree(as->s);\n\tas->s = NULL;\n}\n\nvoid\narchive_wstring_free(struct archive_wstring *as)\n{\n\tas->length = 0;\n\tas->buffer_length = 0;\n\tfree(as->s);\n\tas->s = NULL;\n}\n\nstruct archive_wstring *\narchive_wstring_ensure(struct archive_wstring *as, size_t s)\n{\n\treturn (struct archive_wstring *)\n\t\tarchive_string_ensure((struct archive_string *)as,\n\t\t\t\t\ts * sizeof(wchar_t));\n}\n\n/* Returns NULL on any allocation failure. */\nstruct archive_string *\narchive_string_ensure(struct archive_string *as, size_t s)\n{\n\tchar *p;\n\tsize_t new_length;\n\n\t/* If buffer is already big enough, don't reallocate. */\n\tif (as->s && (s <= as->buffer_length))\n\t\treturn (as);\n\n\t/*\n\t * Growing the buffer at least exponentially ensures that\n\t * append operations are always linear in the number of\n\t * characters appended.  Using a smaller growth rate for\n\t * larger buffers reduces memory waste somewhat at the cost of\n\t * a larger constant factor.\n\t */\n\tif (as->buffer_length < 32)\n\t\t/* Start with a minimum 32-character buffer. */\n\t\tnew_length = 32;\n\telse if (as->buffer_length < 8192)\n\t\t/* Buffers under 8k are doubled for speed. */\n\t\tnew_length = as->buffer_length + as->buffer_length;\n\telse {\n\t\t/* Buffers 8k and over grow by at least 25% each time. */\n\t\tnew_length = as->buffer_length + as->buffer_length / 4;\n\t\t/* Be safe: If size wraps, fail. */\n\t\tif (new_length < as->buffer_length) {\n\t\t\t/* On failure, wipe the string and return NULL. */\n\t\t\tarchive_string_free(as);\n\t\t\terrno = ENOMEM;/* Make sure errno has ENOMEM. */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\t/*\n\t * The computation above is a lower limit to how much we'll\n\t * grow the buffer.  In any case, we have to grow it enough to\n\t * hold the request.\n\t */\n\tif (new_length < s)\n\t\tnew_length = s;\n\t/* Now we can reallocate the buffer. */\n\tp = (char *)realloc(as->s, new_length);\n\tif (p == NULL) {\n\t\t/* On failure, wipe the string and return NULL. */\n\t\tarchive_string_free(as);\n\t\terrno = ENOMEM;/* Make sure errno has ENOMEM. */\n\t\treturn (NULL);\n\t}\n\n\tas->s = p;\n\tas->buffer_length = new_length;\n\treturn (as);\n}\n\n/*\n * TODO: See if there's a way to avoid scanning\n * the source string twice.  Then test to see\n * if it actually helps (remember that we're almost\n * always called with pretty short arguments, so\n * such an optimization might not help).\n */\nstruct archive_string *\narchive_strncat(struct archive_string *as, const void *_p, size_t n)\n{\n\tsize_t s;\n\tconst char *p, *pp;\n\n\tp = (const char *)_p;\n\n\t/* Like strlen(p), except won't examine positions beyond p[n]. */\n\ts = 0;\n\tpp = p;\n\twhile (s < n && *pp) {\n\t\tpp++;\n\t\ts++;\n\t}\n\tif ((as = archive_string_append(as, p, s)) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n\treturn (as);\n}\n\nstruct archive_wstring *\narchive_wstrncat(struct archive_wstring *as, const wchar_t *p, size_t n)\n{\n\tsize_t s;\n\tconst wchar_t *pp;\n\n\t/* Like strlen(p), except won't examine positions beyond p[n]. */\n\ts = 0;\n\tpp = p;\n\twhile (s < n && *pp) {\n\t\tpp++;\n\t\ts++;\n\t}\n\tif ((as = archive_wstring_append(as, p, s)) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n\treturn (as);\n}\n\nstruct archive_string *\narchive_strcat(struct archive_string *as, const void *p)\n{\n\t/* strcat is just strncat without an effective limit. \n\t * Assert that we'll never get called with a source\n\t * string over 16MB.\n\t * TODO: Review all uses of strcat in the source\n\t * and try to replace them with strncat().\n\t */\n\treturn archive_strncat(as, p, 0x1000000);\n}\n\nstruct archive_wstring *\narchive_wstrcat(struct archive_wstring *as, const wchar_t *p)\n{\n\t/* Ditto. */\n\treturn archive_wstrncat(as, p, 0x1000000);\n}\n\nstruct archive_string *\narchive_strappend_char(struct archive_string *as, char c)\n{\n\tif ((as = archive_string_append(as, &c, 1)) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n\treturn (as);\n}\n\nstruct archive_wstring *\narchive_wstrappend_wchar(struct archive_wstring *as, wchar_t c)\n{\n\tif ((as = archive_wstring_append(as, &c, 1)) == NULL)\n\t\t__archive_errx(1, \"Out of memory\");\n\treturn (as);\n}\n\n/*\n * Get the \"current character set\" name to use with iconv.\n * On FreeBSD, the empty character set name \"\" chooses\n * the correct character encoding for the current locale,\n * so this isn't necessary.\n * But iconv on Mac OS 10.6 doesn't seem to handle this correctly;\n * on that system, we have to explicitly call nl_langinfo()\n * to get the right name.  Not sure about other platforms.\n *\n * NOTE: GNU libiconv does not recognize the character-set name\n * which some platform nl_langinfo(CODESET) returns, so we should\n * use locale_charset() instead of nl_langinfo(CODESET) for GNU libiconv.\n */\nstatic const char *\ndefault_iconv_charset(const char *charset) {\n\tif (charset != NULL && charset[0] != '\\0')\n\t\treturn charset;\n#if HAVE_LOCALE_CHARSET && !defined(__APPLE__)\n\t/* locale_charset() is broken on Mac OS */\n\treturn locale_charset();\n#elif HAVE_NL_LANGINFO\n\treturn nl_langinfo(CODESET);\n#else\n\treturn \"\";\n#endif\n}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\n/*\n * Convert MBS to WCS.\n * Note: returns -1 if conversion fails.\n */\nint\narchive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\treturn archive_wstring_append_from_mbs_in_codepage(dest, p, len, NULL);\n}\n\nstatic int\narchive_wstring_append_from_mbs_in_codepage(struct archive_wstring *dest,\n    const char *s, size_t length, struct archive_string_conv *sc)\n{\n\tint count, ret = 0;\n\tUINT from_cp;\n\n\tif (sc != NULL)\n\t\tfrom_cp = sc->from_cp;\n\telse\n\t\tfrom_cp = get_current_codepage();\n\n\tif (from_cp == CP_C_LOCALE) {\n\t\t/*\n\t\t * \"C\" locale special processing.\n\t\t */\n\t\twchar_t *ws;\n\t\tconst unsigned char *mp;\n\n\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t    dest->length + length + 1))\n\t\t\treturn (-1);\n\n\t\tws = dest->s + dest->length;\n\t\tmp = (const unsigned char *)s;\n\t\tcount = 0;\n\t\twhile (count < (int)length && *mp) {\n\t\t\t*ws++ = (wchar_t)*mp++;\n\t\t\tcount++;\n\t\t}\n\t} else if (sc != NULL &&\n\t    (sc->flag & (SCONV_NORMALIZATION_C | SCONV_NORMALIZATION_D))) {\n\t\t/*\n\t\t * Normalize UTF-8 and UTF-16BE and convert it directly\n\t\t * to UTF-16 as wchar_t.\n\t\t */\n\t\tstruct archive_string u16;\n\t\tint saved_flag = sc->flag;/* save current flag. */\n\n\t\tif (is_big_endian())\n\t\t\tsc->flag |= SCONV_TO_UTF16BE;\n\t\telse\n\t\t\tsc->flag |= SCONV_TO_UTF16LE;\n\n\t\tif (sc->flag & SCONV_FROM_UTF16) {\n\t\t\t/*\n\t\t\t *  UTF-16BE/LE NFD ===> UTF-16 NFC\n\t\t\t *  UTF-16BE/LE NFC ===> UTF-16 NFD\n\t\t\t */\n\t\t\tcount = (int)utf16nbytes(s, length);\n\t\t} else {\n\t\t\t/*\n\t\t\t *  UTF-8 NFD ===> UTF-16 NFC\n\t\t\t *  UTF-8 NFC ===> UTF-16 NFD\n\t\t\t */\n\t\t\tcount = (int)mbsnbytes(s, length);\n\t\t}\n\t\tu16.s = (char *)dest->s;\n\t\tu16.length = dest->length << 1;;\n\t\tu16.buffer_length = dest->buffer_length;\n\t\tif (sc->flag & SCONV_NORMALIZATION_C)\n\t\t\tret = archive_string_normalize_C(&u16, s, count, sc);\n\t\telse\n\t\t\tret = archive_string_normalize_D(&u16, s, count, sc);\n\t\tdest->s = (wchar_t *)u16.s;\n\t\tdest->length = u16.length >> 1;\n\t\tdest->buffer_length = u16.buffer_length;\n\t\tsc->flag = saved_flag;/* restore the saved flag. */\n\t\treturn (ret);\n\t} else if (sc != NULL && (sc->flag & SCONV_FROM_UTF16)) {\n\t\tcount = (int)utf16nbytes(s, length);\n\t\tcount >>= 1; /* to be WCS length */\n\t\t/* Allocate memory for WCS. */\n\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t    dest->length + count + 1))\n\t\t\treturn (-1);\n\t\twmemcpy(dest->s + dest->length, (const wchar_t *)s, count);\n\t\tif ((sc->flag & SCONV_FROM_UTF16BE) && !is_big_endian()) {\n\t\t\tuint16_t *u16 = (uint16_t *)(dest->s + dest->length);\n\t\t\tint b;\n\t\t\tfor (b = 0; b < count; b++) {\n\t\t\t\tuint16_t val = archive_le16dec(u16+b);\n\t\t\t\tarchive_be16enc(u16+b, val);\n\t\t\t}\n\t\t} else if ((sc->flag & SCONV_FROM_UTF16LE) && is_big_endian()) {\n\t\t\tuint16_t *u16 = (uint16_t *)(dest->s + dest->length);\n\t\t\tint b;\n\t\t\tfor (b = 0; b < count; b++) {\n\t\t\t\tuint16_t val = archive_be16dec(u16+b);\n\t\t\t\tarchive_le16enc(u16+b, val);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDWORD mbflag;\n\t\tsize_t buffsize;\n\n\t\tif (sc == NULL)\n\t\t\tmbflag = 0;\n\t\telse if (sc->flag & SCONV_FROM_CHARSET) {\n\t\t\t/* Do not trust the length which comes from\n\t\t\t * an archive file. */\n\t\t\tlength = mbsnbytes(s, length);\n\t\t\tmbflag = 0;\n\t\t} else\n\t\t\tmbflag = MB_PRECOMPOSED;\n\n\t\tbuffsize = dest->length + length + 1;\n\t\tdo {\n\t\t\t/* Allocate memory for WCS. */\n\t\t\tif (NULL == archive_wstring_ensure(dest, buffsize))\n\t\t\t\treturn (-1);\n\t\t\t/* Convert MBS to WCS. */\n\t\t\tcount = MultiByteToWideChar(from_cp,\n\t\t\t    mbflag, s, (int)length, dest->s + dest->length,\n\t\t\t    (int)(dest->buffer_length >> 1) -1);\n\t\t\tif (count == 0 &&\n\t\t\t    GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\t\t/* Expand the WCS buffer. */\n\t\t\t\tbuffsize = dest->buffer_length << 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (count == 0 && length != 0)\n\t\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tdest->length += count;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret);\n}\n\n#else\n\n/*\n * Convert MBS to WCS.\n * Note: returns -1 if conversion fails.\n */\nint\narchive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\t/*\n\t * No single byte will be more than one wide character,\n\t * so this length estimate will always be big enough.\n\t */\n\t// size_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\t/*\n\t * As we decided to have wcs_length == mbs_length == len\n\t * we can use len here instead of wcs_length\n\t */\n\tif (NULL == archive_wstring_ensure(dest, dest->length + len + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\t/*\n\t * We cannot use mbsrtowcs/mbstowcs here because those may convert\n\t * extra MBS when strlen(p) > len and one wide character consists of\n\t * multi bytes.\n\t */\n\twhile (*mbs && mbs_length > 0) {\n\t\t/*\n\t\t * The buffer we allocated is always big enough.\n\t\t * Keep this code path in a comment if we decide to choose\n\t\t * smaller wcs_length in the future\n\t\t */\n/*\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n*/\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, mbs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, mbs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\t// wcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}\n\n#endif\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\n/*\n * WCS ==> MBS.\n * Note: returns -1 if conversion fails.\n *\n * Win32 builds use WideCharToMultiByte from the Windows API.\n * (Maybe Cygwin should too?  WideCharToMultiByte will know a\n * lot more about local character encodings than the wcrtomb()\n * wrapper is going to know.)\n */\nint\narchive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\treturn archive_string_append_from_wcs_in_codepage(as, w, len, NULL);\n}\n\nstatic int\narchive_string_append_from_wcs_in_codepage(struct archive_string *as,\n    const wchar_t *ws, size_t len, struct archive_string_conv *sc)\n{\n\tBOOL defchar_used, *dp;\n\tint count, ret = 0;\n\tUINT to_cp;\n\tint wslen = (int)len;\n\n\tif (sc != NULL)\n\t\tto_cp = sc->to_cp;\n\telse\n\t\tto_cp = get_current_codepage();\n\n\tif (to_cp == CP_C_LOCALE) {\n\t\t/*\n\t\t * \"C\" locale special processing.\n\t\t */\n\t\tconst wchar_t *wp = ws;\n\t\tchar *p;\n\n\t\tif (NULL == archive_string_ensure(as,\n\t\t    as->length + wslen +1))\n\t\t\treturn (-1);\n\t\tp = as->s + as->length;\n\t\tcount = 0;\n\t\tdefchar_used = 0;\n\t\twhile (count < wslen && *wp) {\n\t\t\tif (*wp > 255) {\n\t\t\t\t*p++ = '?';\n\t\t\t\twp++;\n\t\t\t\tdefchar_used = 1;\n\t\t\t} else\n\t\t\t\t*p++ = (char)*wp++;\n\t\t\tcount++;\n\t\t}\n\t} else if (sc != NULL && (sc->flag & SCONV_TO_UTF16)) {\n\t\tuint16_t *u16;\n\n\t\tif (NULL ==\n\t\t    archive_string_ensure(as, as->length + len * 2 + 2))\n\t\t\treturn (-1);\n\t\tu16 = (uint16_t *)(as->s + as->length);\n\t\tcount = 0;\n\t\tdefchar_used = 0;\n\t\tif (sc->flag & SCONV_TO_UTF16BE) {\n\t\t\twhile (count < (int)len && *ws) {\n\t\t\t\tarchive_be16enc(u16+count, *ws);\n\t\t\t\tws++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (count < (int)len && *ws) {\n\t\t\t\tarchive_le16enc(u16+count, *ws);\n\t\t\t\tws++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcount <<= 1; /* to be byte size */\n\t} else {\n\t\t/* Make sure the MBS buffer has plenty to set. */\n\t\tif (NULL ==\n\t\t    archive_string_ensure(as, as->length + len * 2 + 1))\n\t\t\treturn (-1);\n\t\tdo {\n\t\t\tdefchar_used = 0;\n\t\t\tif (to_cp == CP_UTF8 || sc == NULL)\n\t\t\t\tdp = NULL;\n\t\t\telse\n\t\t\t\tdp = &defchar_used;\n\t\t\tcount = WideCharToMultiByte(to_cp, 0, ws, wslen,\n\t\t\t    as->s + as->length, (int)as->buffer_length-1, NULL, dp);\n\t\t\tif (count == 0 &&\n\t\t\t    GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\t\t/* Expand the MBS buffer and retry. */\n\t\t\t\tif (NULL == archive_string_ensure(as,\n\t\t\t\t\tas->buffer_length + len))\n\t\t\t\t\treturn (-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (count == 0)\n\t\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tas->length += count;\n\tas->s[as->length] = '\\0';\n\treturn (defchar_used?-1:ret);\n}\n\n#elif defined(HAVE_WCTOMB) || defined(HAVE_WCRTOMB)\n\n/*\n * Translates a wide character string into current locale character set\n * and appends to the archive_string.  Note: returns -1 if conversion\n * fails.\n */\nint\narchive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\t/* We cannot use the standard wcstombs() here because it\n\t * cannot tell us how big the output buffer should be.  So\n\t * I've built a loop around wcrtomb() or wctomb() that\n\t * converts a character at a time and resizes the string as\n\t * needed.  We prefer wcrtomb() when it's available because\n\t * it's thread-safe. */\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\t/* Clear the shift state before starting. */\n\twctomb(NULL, L'\\0');\n#endif\n\t/*\n\t * Allocate buffer for MBS.\n\t * We need this allocation here since it is possible that\n\t * as->s is still NULL.\n\t */\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\t/* Re-allocate buffer for MBS. */\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t/* Skip an illegal wide char. */\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}\n\n#else /* HAVE_WCTOMB || HAVE_WCRTOMB */\n\n/*\n * TODO: Test if __STDC_ISO_10646__ is defined.\n * Non-Windows uses ISO C wcrtomb() or wctomb() to perform the conversion\n * one character at a time.  If a non-Windows platform doesn't have\n * either of these, fall back to the built-in UTF8 conversion.\n */\nint\narchive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\t(void)as;/* UNUSED */\n\t(void)w;/* UNUSED */\n\t(void)len;/* UNUSED */\n\terrno = ENOSYS;\n\treturn (-1);\n}\n\n#endif /* HAVE_WCTOMB || HAVE_WCRTOMB */\n\n/*\n * Find a string conversion object by a pair of 'from' charset name\n * and 'to' charset name from an archive object.\n * Return NULL if not found.\n */\nstatic struct archive_string_conv *\nfind_sconv_object(struct archive *a, const char *fc, const char *tc)\n{\n\tstruct archive_string_conv *sc; \n\n\tif (a == NULL)\n\t\treturn (NULL);\n\n\tfor (sc = a->sconv; sc != NULL; sc = sc->next) {\n\t\tif (strcmp(sc->from_charset, fc) == 0 &&\n\t\t    strcmp(sc->to_charset, tc) == 0)\n\t\t\tbreak;\n\t}\n\treturn (sc);\n}\n\n/*\n * Register a string object to an archive object.\n */\nstatic void\nadd_sconv_object(struct archive *a, struct archive_string_conv *sc)\n{\n\tstruct archive_string_conv **psc; \n\n\t/* Add a new sconv to sconv list. */\n\tpsc = &(a->sconv);\n\twhile (*psc != NULL)\n\t\tpsc = &((*psc)->next);\n\t*psc = sc;\n}\n\nstatic void\nadd_converter(struct archive_string_conv *sc, int (*converter)\n    (struct archive_string *, const void *, size_t,\n     struct archive_string_conv *))\n{\n\tif (sc == NULL || sc->nconverter >= 2)\n\t\t__archive_errx(1, \"Programming error\");\n\tsc->converter[sc->nconverter++] = converter;\n}\n\nstatic void\nsetup_converter(struct archive_string_conv *sc)\n{\n\n\t/* Reset. */\n\tsc->nconverter = 0;\n\n\t/*\n\t * Perform special sequence for the incorrect UTF-8 filenames\n\t * made by libarchive2.x.\n\t */\n\tif (sc->flag & SCONV_UTF8_LIBARCHIVE_2) {\n\t\tadd_converter(sc, strncat_from_utf8_libarchive2);\n\t\treturn;\n\t}\n\n\t/*\n\t * Convert a string to UTF-16BE/LE.\n\t */\n\tif (sc->flag & SCONV_TO_UTF16) {\n\t\t/*\n\t\t * If the current locale is UTF-8, we can translate\n\t\t * a UTF-8 string into a UTF-16BE string.\n\t\t */\n\t\tif (sc->flag & SCONV_FROM_UTF8) {\n\t\t\tadd_converter(sc, archive_string_append_unicode);\n\t\t\treturn;\n\t\t}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tif (sc->flag & SCONV_WIN_CP) {\n\t\t\tif (sc->flag & SCONV_TO_UTF16BE)\n\t\t\t\tadd_converter(sc, win_strncat_to_utf16be);\n\t\t\telse\n\t\t\t\tadd_converter(sc, win_strncat_to_utf16le);\n\t\t\treturn;\n\t\t}\n#endif\n\n#if defined(HAVE_ICONV)\n\t\tif (sc->cd != (iconv_t)-1) {\n\t\t\tadd_converter(sc, iconv_strncat_in_locale);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif (sc->flag & SCONV_BEST_EFFORT) {\n\t\t\tif (sc->flag & SCONV_TO_UTF16BE)\n\t\t\t\tadd_converter(sc,\n\t\t\t\t\tbest_effort_strncat_to_utf16be);\n\t\t\telse\n\t\t\t\tadd_converter(sc,\n\t\t\t\t\tbest_effort_strncat_to_utf16le);\n\t\t} else\n\t\t\t/* Make sure we have no converter. */\n\t\t\tsc->nconverter = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Convert a string from UTF-16BE/LE.\n\t */\n\tif (sc->flag & SCONV_FROM_UTF16) {\n\t\t/*\n\t\t * At least we should normalize a UTF-16BE string.\n\t\t */\n\t\tif (sc->flag & SCONV_NORMALIZATION_D)\n\t\t\tadd_converter(sc,archive_string_normalize_D);\n\t\telse if (sc->flag & SCONV_NORMALIZATION_C)\n\t\t\tadd_converter(sc, archive_string_normalize_C);\n\n\t\tif (sc->flag & SCONV_TO_UTF8) {\n\t\t\t/*\n\t\t\t * If the current locale is UTF-8, we can translate\n\t\t\t * a UTF-16BE/LE string into a UTF-8 string directly.\n\t\t\t */\n\t\t\tif (!(sc->flag &\n\t\t\t    (SCONV_NORMALIZATION_D |SCONV_NORMALIZATION_C)))\n\t\t\t\tadd_converter(sc,\n\t\t\t\t    archive_string_append_unicode);\n\t\t\treturn;\n\t\t}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tif (sc->flag & SCONV_WIN_CP) {\n\t\t\tif (sc->flag & SCONV_FROM_UTF16BE)\n\t\t\t\tadd_converter(sc, win_strncat_from_utf16be);\n\t\t\telse\n\t\t\t\tadd_converter(sc, win_strncat_from_utf16le);\n\t\t\treturn;\n\t\t}\n#endif\n\n#if defined(HAVE_ICONV)\n\t\tif (sc->cd != (iconv_t)-1) {\n\t\t\tadd_converter(sc, iconv_strncat_in_locale);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif ((sc->flag & (SCONV_BEST_EFFORT | SCONV_FROM_UTF16BE))\n\t\t    == (SCONV_BEST_EFFORT | SCONV_FROM_UTF16BE))\n\t\t\tadd_converter(sc, best_effort_strncat_from_utf16be);\n\t\telse if ((sc->flag & (SCONV_BEST_EFFORT | SCONV_FROM_UTF16LE))\n\t\t    == (SCONV_BEST_EFFORT | SCONV_FROM_UTF16LE))\n\t\t\tadd_converter(sc, best_effort_strncat_from_utf16le);\n\t\telse\n\t\t\t/* Make sure we have no converter. */\n\t\t\tsc->nconverter = 0;\n\t\treturn;\n\t}\n\n\tif (sc->flag & SCONV_FROM_UTF8) {\n\t\t/*\n\t\t * At least we should normalize a UTF-8 string.\n\t\t */\n\t\tif (sc->flag & SCONV_NORMALIZATION_D)\n\t\t\tadd_converter(sc,archive_string_normalize_D);\n\t\telse if (sc->flag & SCONV_NORMALIZATION_C)\n\t\t\tadd_converter(sc, archive_string_normalize_C);\n\n\t\t/*\n\t\t * Copy UTF-8 string with a check of CESU-8.\n\t\t * Apparently, iconv does not check surrogate pairs in UTF-8\n\t\t * when both from-charset and to-charset are UTF-8, and then\n\t\t * we use our UTF-8 copy code.\n\t\t */\n\t\tif (sc->flag & SCONV_TO_UTF8) {\n\t\t\t/*\n\t\t\t * If the current locale is UTF-8, we can translate\n\t\t\t * a UTF-16BE string into a UTF-8 string directly.\n\t\t\t */\n\t\t\tif (!(sc->flag &\n\t\t\t    (SCONV_NORMALIZATION_D |SCONV_NORMALIZATION_C)))\n\t\t\t\tadd_converter(sc, strncat_from_utf8_to_utf8);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/*\n\t * On Windows we can use Windows API for a string conversion.\n\t */\n\tif (sc->flag & SCONV_WIN_CP) {\n\t\tadd_converter(sc, strncat_in_codepage);\n\t\treturn;\n\t}\n#endif\n\n#if HAVE_ICONV\n\tif (sc->cd != (iconv_t)-1) {\n\t\tadd_converter(sc, iconv_strncat_in_locale);\n\t\t/*\n\t\t * iconv generally does not support UTF-8-MAC and so\n\t\t * we have to the output of iconv from NFC to NFD if\n\t\t * need.\n\t\t */\n\t\tif ((sc->flag & SCONV_FROM_CHARSET) &&\n\t\t    (sc->flag & SCONV_TO_UTF8)) {\n\t\t\tif (sc->flag & SCONV_NORMALIZATION_D)\n\t\t\t\tadd_converter(sc, archive_string_normalize_D);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * Try conversion in the best effort or no conversion.\n\t */\n\tif ((sc->flag & SCONV_BEST_EFFORT) || sc->same)\n\t\tadd_converter(sc, best_effort_strncat_in_locale);\n\telse\n\t\t/* Make sure we have no converter. */\n\t\tsc->nconverter = 0;\n}\n\n/*\n * Return canonicalized charset-name but this supports just UTF-8, UTF-16BE\n * and CP932 which are referenced in create_sconv_object().\n */\nstatic const char *\ncanonical_charset_name(const char *charset)\n{\n\tchar cs[16];\n\tchar *p;\n\tconst char *s;\n\n\tif (charset == NULL || charset[0] == '\\0'\n\t    || strlen(charset) > 15)\n\t\treturn (charset);\n\n\t/* Copy name to uppercase. */\n\tp = cs;\n\ts = charset;\n\twhile (*s) {\n\t\tchar c = *s++;\n\t\tif (c >= 'a' && c <= 'z')\n\t\t\tc -= 'a' - 'A';\n\t\t*p++ = c;\n\t}\n\t*p++ = '\\0';\n\n\tif (strcmp(cs, \"UTF-8\") == 0 ||\n\t    strcmp(cs, \"UTF8\") == 0)\n\t\treturn (\"UTF-8\");\n\tif (strcmp(cs, \"UTF-16BE\") == 0 ||\n\t    strcmp(cs, \"UTF16BE\") == 0)\n\t\treturn (\"UTF-16BE\");\n\tif (strcmp(cs, \"UTF-16LE\") == 0 ||\n\t    strcmp(cs, \"UTF16LE\") == 0)\n\t\treturn (\"UTF-16LE\");\n\tif (strcmp(cs, \"CP932\") == 0)\n\t\treturn (\"CP932\");\n\treturn (charset);\n}\n\n/*\n * Create a string conversion object.\n */\nstatic struct archive_string_conv *\ncreate_sconv_object(const char *fc, const char *tc,\n    unsigned current_codepage, int flag)\n{\n\tstruct archive_string_conv *sc; \n\n\tsc = calloc(1, sizeof(*sc));\n\tif (sc == NULL)\n\t\treturn (NULL);\n\tsc->next = NULL;\n\tsc->from_charset = strdup(fc);\n\tif (sc->from_charset == NULL) {\n\t\tfree(sc);\n\t\treturn (NULL);\n\t}\n\tsc->to_charset = strdup(tc);\n\tif (sc->to_charset == NULL) {\n\t\tfree(sc->from_charset);\n\t\tfree(sc);\n\t\treturn (NULL);\n\t}\n\tarchive_string_init(&sc->utftmp);\n\n\tif (flag & SCONV_TO_CHARSET) {\n\t\t/*\n\t\t * Convert characters from the current locale charset to\n\t\t * a specified charset.\n\t\t */\n\t\tsc->from_cp = current_codepage;\n\t\tsc->to_cp = make_codepage_from_charset(tc);\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tif (IsValidCodePage(sc->to_cp))\n\t\t\tflag |= SCONV_WIN_CP;\n#endif\n\t} else if (flag & SCONV_FROM_CHARSET) {\n\t\t/*\n\t\t * Convert characters from a specified charset to\n\t\t * the current locale charset.\n\t\t */\n\t\tsc->to_cp = current_codepage;\n\t\tsc->from_cp = make_codepage_from_charset(fc);\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\tif (IsValidCodePage(sc->from_cp))\n\t\t\tflag |= SCONV_WIN_CP;\n#endif\n\t}\n\n\t/*\n\t * Check if \"from charset\" and \"to charset\" are the same.\n\t */\n\tif (strcmp(fc, tc) == 0 ||\n\t    (sc->from_cp != (unsigned)-1 && sc->from_cp == sc->to_cp))\n\t\tsc->same = 1;\n\telse\n\t\tsc->same = 0;\n\n\t/*\n\t * Mark if \"from charset\" or \"to charset\" are UTF-8 or UTF-16BE/LE.\n\t */\n\tif (strcmp(tc, \"UTF-8\") == 0)\n\t\tflag |= SCONV_TO_UTF8;\n\telse if (strcmp(tc, \"UTF-16BE\") == 0)\n\t\tflag |= SCONV_TO_UTF16BE;\n\telse if (strcmp(tc, \"UTF-16LE\") == 0)\n\t\tflag |= SCONV_TO_UTF16LE;\n\tif (strcmp(fc, \"UTF-8\") == 0)\n\t\tflag |= SCONV_FROM_UTF8;\n\telse if (strcmp(fc, \"UTF-16BE\") == 0)\n\t\tflag |= SCONV_FROM_UTF16BE;\n\telse if (strcmp(fc, \"UTF-16LE\") == 0)\n\t\tflag |= SCONV_FROM_UTF16LE;\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\tif (sc->to_cp == CP_UTF8)\n\t\tflag |= SCONV_TO_UTF8;\n\telse if (sc->to_cp == CP_UTF16BE)\n\t\tflag |= SCONV_TO_UTF16BE | SCONV_WIN_CP;\n\telse if (sc->to_cp == CP_UTF16LE)\n\t\tflag |= SCONV_TO_UTF16LE | SCONV_WIN_CP;\n\tif (sc->from_cp == CP_UTF8)\n\t\tflag |= SCONV_FROM_UTF8;\n\telse if (sc->from_cp == CP_UTF16BE)\n\t\tflag |= SCONV_FROM_UTF16BE | SCONV_WIN_CP;\n\telse if (sc->from_cp == CP_UTF16LE)\n\t\tflag |= SCONV_FROM_UTF16LE | SCONV_WIN_CP;\n#endif\n\n\t/*\n\t * Set a flag for Unicode NFD. Usually iconv cannot correctly\n\t * handle it. So we have to translate NFD characters to NFC ones\n\t * ourselves before iconv handles. Another reason is to prevent\n\t * that the same sight of two filenames, one is NFC and other\n\t * is NFD, would be in its directory.\n\t * On Mac OS X, although its filesystem layer automatically\n\t * convert filenames to NFD, it would be useful for filename\n\t * comparing to find out the same filenames that we normalize\n\t * that to be NFD ourselves.\n\t */\n\tif ((flag & SCONV_FROM_CHARSET) &&\n\t    (flag & (SCONV_FROM_UTF16 | SCONV_FROM_UTF8))) {\n#if defined(__APPLE__)\n\t\tif (flag & SCONV_TO_UTF8)\n\t\t\tflag |= SCONV_NORMALIZATION_D;\n\t\telse\n#endif\n\t\t\tflag |= SCONV_NORMALIZATION_C;\n\t}\n#if defined(__APPLE__)\n\t/*\n\t * In case writing an archive file, make sure that a filename\n\t * going to be passed to iconv is a Unicode NFC string since\n\t * a filename in HFS Plus filesystem is a Unicode NFD one and\n\t * iconv cannot handle it with \"UTF-8\" charset. It is simpler\n\t * than a use of \"UTF-8-MAC\" charset.\n\t */\n\tif ((flag & SCONV_TO_CHARSET) &&\n\t    (flag & (SCONV_FROM_UTF16 | SCONV_FROM_UTF8)) &&\n\t    !(flag & (SCONV_TO_UTF16 | SCONV_TO_UTF8)))\n\t\tflag |= SCONV_NORMALIZATION_C;\n\t/*\n\t * In case reading an archive file. make sure that a filename\n\t * will be passed to users is a Unicode NFD string in order to\n\t * correctly compare the filename with other one which comes\n\t * from HFS Plus filesystem.\n\t */\n\tif ((flag & SCONV_FROM_CHARSET) &&\n\t   !(flag & (SCONV_FROM_UTF16 | SCONV_FROM_UTF8)) &&\n\t    (flag & SCONV_TO_UTF8))\n\t\tflag |= SCONV_NORMALIZATION_D;\n#endif\n\n#if defined(HAVE_ICONV)\n\tsc->cd_w = (iconv_t)-1;\n\t/*\n\t * Create an iconv object.\n\t */\n\tif (((flag & (SCONV_TO_UTF8 | SCONV_TO_UTF16)) &&\n\t    (flag & (SCONV_FROM_UTF8 | SCONV_FROM_UTF16))) ||\n\t    (flag & SCONV_WIN_CP)) {\n\t\t/* This case we won't use iconv. */\n\t\tsc->cd = (iconv_t)-1;\n\t} else {\n\t\tsc->cd = iconv_open(tc, fc);\n\t\tif (sc->cd == (iconv_t)-1 && (sc->flag & SCONV_BEST_EFFORT)) {\n\t\t\t/*\n\t\t\t * Unfortunately, all of iconv implements do support\n\t\t\t * \"CP932\" character-set, so we should use \"SJIS\"\n\t\t\t * instead if iconv_open failed.\n\t\t\t */\n\t\t\tif (strcmp(tc, \"CP932\") == 0)\n\t\t\t\tsc->cd = iconv_open(\"SJIS\", fc);\n\t\t\telse if (strcmp(fc, \"CP932\") == 0)\n\t\t\t\tsc->cd = iconv_open(tc, \"SJIS\");\n\t\t}\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t\t/*\n\t\t * archive_mstring on Windows directly convert multi-bytes\n\t\t * into archive_wstring in order not to depend on locale\n\t\t * so that you can do a I18N programming. This will be\n\t\t * used only in archive_mstring_copy_mbs_len_l so far.\n\t\t */\n\t\tif (flag & SCONV_FROM_CHARSET) {\n\t\t\tsc->cd_w = iconv_open(\"UTF-8\", fc);\n\t\t\tif (sc->cd_w == (iconv_t)-1 &&\n\t\t\t    (sc->flag & SCONV_BEST_EFFORT)) {\n\t\t\t\tif (strcmp(fc, \"CP932\") == 0)\n\t\t\t\t\tsc->cd_w = iconv_open(\"UTF-8\", \"SJIS\");\n\t\t\t}\n\t\t}\n#endif /* _WIN32 && !__CYGWIN__ */\n\t}\n#endif\t/* HAVE_ICONV */\n\n\tsc->flag = flag;\n\n\t/*\n\t * Set up converters.\n\t */\n\tsetup_converter(sc);\n\n\treturn (sc);\n}\n\n/*\n * Free a string conversion object.\n */\nstatic void\nfree_sconv_object(struct archive_string_conv *sc)\n{\n\tfree(sc->from_charset);\n\tfree(sc->to_charset);\n\tarchive_string_free(&sc->utftmp);\n#if HAVE_ICONV\n\tif (sc->cd != (iconv_t)-1)\n\t\ticonv_close(sc->cd);\n\tif (sc->cd_w != (iconv_t)-1)\n\t\ticonv_close(sc->cd_w);\n#endif\n\tfree(sc);\n}\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\nstatic unsigned\nmy_atoi(const char *p)\n{\n\tunsigned cp;\n\n\tcp = 0;\n\twhile (*p) {\n\t\tif (*p >= '0' && *p <= '9')\n\t\t\tcp = cp * 10 + (*p - '0');\n\t\telse\n\t\t\treturn (-1);\n\t\tp++;\n\t}\n\treturn (cp);\n}\n\n/*\n * Translate Charset name (as used by iconv) into CodePage (as used by Windows)\n * Return -1 if failed.\n *\n * Note: This translation code may be insufficient.\n */\nstatic struct charset {\n\tconst char *name;\n\tunsigned cp;\n} charsets[] = {\n\t/* MUST BE SORTED! */\n\t{\"ASCII\", 1252},\n\t{\"ASMO-708\", 708},\n\t{\"BIG5\", 950},\n\t{\"CHINESE\", 936},\n\t{\"CP367\", 1252},\n\t{\"CP819\", 1252},\n\t{\"CP1025\", 21025},\n\t{\"DOS-720\", 720},\n\t{\"DOS-862\", 862},\n\t{\"EUC-CN\", 51936},\n\t{\"EUC-JP\", 51932},\n\t{\"EUC-KR\", 949},\n\t{\"EUCCN\", 51936},\n\t{\"EUCJP\", 51932},\n\t{\"EUCKR\", 949},\n\t{\"GB18030\", 54936},\n\t{\"GB2312\", 936},\n\t{\"HEBREW\", 1255},\n\t{\"HZ-GB-2312\", 52936},\n\t{\"IBM273\", 20273},\n\t{\"IBM277\", 20277},\n\t{\"IBM278\", 20278},\n\t{\"IBM280\", 20280},\n\t{\"IBM284\", 20284},\n\t{\"IBM285\", 20285},\n\t{\"IBM290\", 20290},\n\t{\"IBM297\", 20297},\n\t{\"IBM367\", 1252},\n\t{\"IBM420\", 20420},\n\t{\"IBM423\", 20423},\n\t{\"IBM424\", 20424},\n\t{\"IBM819\", 1252},\n\t{\"IBM871\", 20871},\n\t{\"IBM880\", 20880},\n\t{\"IBM905\", 20905},\n\t{\"IBM924\", 20924},\n\t{\"ISO-8859-1\", 28591},\n\t{\"ISO-8859-13\", 28603},\n\t{\"ISO-8859-15\", 28605},\n\t{\"ISO-8859-2\", 28592},\n\t{\"ISO-8859-3\", 28593},\n\t{\"ISO-8859-4\", 28594},\n\t{\"ISO-8859-5\", 28595},\n\t{\"ISO-8859-6\", 28596},\n\t{\"ISO-8859-7\", 28597},\n\t{\"ISO-8859-8\", 28598},\n\t{\"ISO-8859-9\", 28599},\n\t{\"ISO8859-1\", 28591},\n\t{\"ISO8859-13\", 28603},\n\t{\"ISO8859-15\", 28605},\n\t{\"ISO8859-2\", 28592},\n\t{\"ISO8859-3\", 28593},\n\t{\"ISO8859-4\", 28594},\n\t{\"ISO8859-5\", 28595},\n\t{\"ISO8859-6\", 28596},\n\t{\"ISO8859-7\", 28597},\n\t{\"ISO8859-8\", 28598},\n\t{\"ISO8859-9\", 28599},\n\t{\"JOHAB\", 1361},\n\t{\"KOI8-R\", 20866},\n\t{\"KOI8-U\", 21866},\n\t{\"KS_C_5601-1987\", 949},\n\t{\"LATIN1\", 1252},\n\t{\"LATIN2\", 28592},\n\t{\"MACINTOSH\", 10000},\n\t{\"SHIFT-JIS\", 932},\n\t{\"SHIFT_JIS\", 932},\n\t{\"SJIS\", 932},\n\t{\"US\", 1252},\n\t{\"US-ASCII\", 1252},\n\t{\"UTF-16\", 1200},\n\t{\"UTF-16BE\", 1201},\n\t{\"UTF-16LE\", 1200},\n\t{\"UTF-8\", CP_UTF8},\n\t{\"X-EUROPA\", 29001},\n\t{\"X-MAC-ARABIC\", 10004},\n\t{\"X-MAC-CE\", 10029},\n\t{\"X-MAC-CHINESEIMP\", 10008},\n\t{\"X-MAC-CHINESETRAD\", 10002},\n\t{\"X-MAC-CROATIAN\", 10082},\n\t{\"X-MAC-CYRILLIC\", 10007},\n\t{\"X-MAC-GREEK\", 10006},\n\t{\"X-MAC-HEBREW\", 10005},\n\t{\"X-MAC-ICELANDIC\", 10079},\n\t{\"X-MAC-JAPANESE\", 10001},\n\t{\"X-MAC-KOREAN\", 10003},\n\t{\"X-MAC-ROMANIAN\", 10010},\n\t{\"X-MAC-THAI\", 10021},\n\t{\"X-MAC-TURKISH\", 10081},\n\t{\"X-MAC-UKRAINIAN\", 10017},\n};\nstatic unsigned\nmake_codepage_from_charset(const char *charset)\n{\n\tchar cs[16];\n\tchar *p;\n\tunsigned cp;\n\tint a, b;\n\n\tif (charset == NULL || strlen(charset) > 15)\n\t\treturn -1;\n\n\t/* Copy name to uppercase. */\n\tp = cs;\n\twhile (*charset) {\n\t\tchar c = *charset++;\n\t\tif (c >= 'a' && c <= 'z')\n\t\t\tc -= 'a' - 'A';\n\t\t*p++ = c;\n\t}\n\t*p++ = '\\0';\n\tcp = -1;\n\n\t/* Look it up in the table first, so that we can easily\n\t * override CP367, which we map to 1252 instead of 367. */\n\ta = 0;\n\tb = sizeof(charsets)/sizeof(charsets[0]);\n\twhile (b > a) {\n\t\tint c = (b + a) / 2;\n\t\tint r = strcmp(charsets[c].name, cs);\n\t\tif (r < 0)\n\t\t\ta = c + 1;\n\t\telse if (r > 0)\n\t\t\tb = c;\n\t\telse\n\t\t\treturn charsets[c].cp;\n\t}\n\n\t/* If it's not in the table, try to parse it. */\n\tswitch (*cs) {\n\tcase 'C':\n\t\tif (cs[1] == 'P' && cs[2] >= '0' && cs[2] <= '9') {\n\t\t\tcp = my_atoi(cs + 2);\n\t\t} else if (strcmp(cs, \"CP_ACP\") == 0)\n\t\t\tcp = get_current_codepage();\n\t\telse if (strcmp(cs, \"CP_OEMCP\") == 0)\n\t\t\tcp = get_current_oemcp();\n\t\tbreak;\n\tcase 'I':\n\t\tif (cs[1] == 'B' && cs[2] == 'M' &&\n\t\t    cs[3] >= '0' && cs[3] <= '9') {\n\t\t\tcp = my_atoi(cs + 3);\n\t\t}\n\t\tbreak;\n\tcase 'W':\n\t\tif (strncmp(cs, \"WINDOWS-\", 8) == 0) {\n\t\t\tcp = my_atoi(cs + 8);\n\t\t\tif (cp != 874 && (cp < 1250 || cp > 1258))\n\t\t\t\tcp = -1;/* This may invalid code. */\n\t\t}\n\t\tbreak;\n\t}\n\treturn (cp);\n}\n\n/*\n * Return ANSI Code Page of current locale set by setlocale().\n */\nstatic unsigned\nget_current_codepage(void)\n{\n\tchar *locale, *p;\n\tunsigned cp;\n\n\tlocale = setlocale(LC_CTYPE, NULL);\n\tif (locale == NULL)\n\t\treturn (GetACP());\n\tif (locale[0] == 'C' && locale[1] == '\\0')\n\t\treturn (CP_C_LOCALE);\n\tp = strrchr(locale, '.');\n\tif (p == NULL)\n\t\treturn (GetACP());\n\tif (strcmp(p+1, \"utf8\") == 0)\n\t\treturn CP_UTF8;\n\tcp = my_atoi(p+1);\n\tif ((int)cp <= 0)\n\t\treturn (GetACP());\n\treturn (cp);\n}\n\n/*\n * Translation table between Locale Name and ACP/OEMCP.\n */\nstatic struct {\n\tunsigned acp;\n\tunsigned ocp;\n\tconst char *locale;\n} acp_ocp_map[] = {\n\t{  950,  950, \"Chinese_Taiwan\" },\n\t{  936,  936, \"Chinese_People's Republic of China\" },\n\t{  950,  950, \"Chinese_Taiwan\" },\n\t{ 1250,  852, \"Czech_Czech Republic\" },\n\t{ 1252,  850, \"Danish_Denmark\" },\n\t{ 1252,  850, \"Dutch_Netherlands\" },\n\t{ 1252,  850, \"Dutch_Belgium\" },\n\t{ 1252,  437, \"English_United States\" },\n\t{ 1252,  850, \"English_Australia\" },\n\t{ 1252,  850, \"English_Canada\" },\n\t{ 1252,  850, \"English_New Zealand\" },\n\t{ 1252,  850, \"English_United Kingdom\" },\n\t{ 1252,  437, \"English_United States\" },\n\t{ 1252,  850, \"Finnish_Finland\" },\n\t{ 1252,  850, \"French_France\" },\n\t{ 1252,  850, \"French_Belgium\" },\n\t{ 1252,  850, \"French_Canada\" },\n\t{ 1252,  850, \"French_Switzerland\" },\n\t{ 1252,  850, \"German_Germany\" },\n\t{ 1252,  850, \"German_Austria\" },\n\t{ 1252,  850, \"German_Switzerland\" },\n\t{ 1253,  737, \"Greek_Greece\" },\n\t{ 1250,  852, \"Hungarian_Hungary\" },\n\t{ 1252,  850, \"Icelandic_Iceland\" },\n\t{ 1252,  850, \"Italian_Italy\" },\n\t{ 1252,  850, \"Italian_Switzerland\" },\n\t{  932,  932, \"Japanese_Japan\" },\n\t{  949,  949, \"Korean_Korea\" },\n\t{ 1252,  850, \"Norwegian (BokmOl)_Norway\" },\n\t{ 1252,  850, \"Norwegian (BokmOl)_Norway\" },\n\t{ 1252,  850, \"Norwegian-Nynorsk_Norway\" },\n\t{ 1250,  852, \"Polish_Poland\" },\n\t{ 1252,  850, \"Portuguese_Portugal\" },\n\t{ 1252,  850, \"Portuguese_Brazil\" },\n\t{ 1251,  866, \"Russian_Russia\" },\n\t{ 1250,  852, \"Slovak_Slovakia\" },\n\t{ 1252,  850, \"Spanish_Spain\" },\n\t{ 1252,  850, \"Spanish_Mexico\" },\n\t{ 1252,  850, \"Spanish_Spain\" },\n\t{ 1252,  850, \"Swedish_Sweden\" },\n\t{ 1254,  857, \"Turkish_Turkey\" },\n\t{ 0, 0, NULL}\n};\n\n/*\n * Return OEM Code Page of current locale set by setlocale().\n */\nstatic unsigned\nget_current_oemcp(void)\n{\n\tint i;\n\tchar *locale, *p;\n\tsize_t len;\n\n\tlocale = setlocale(LC_CTYPE, NULL);\n\tif (locale == NULL)\n\t\treturn (GetOEMCP());\n\tif (locale[0] == 'C' && locale[1] == '\\0')\n\t\treturn (CP_C_LOCALE);\n\n\tp = strrchr(locale, '.');\n\tif (p == NULL)\n\t\treturn (GetOEMCP());\n\tlen = p - locale;\n\tfor (i = 0; acp_ocp_map[i].acp; i++) {\n\t\tif (strncmp(acp_ocp_map[i].locale, locale, len) == 0)\n\t\t\treturn (acp_ocp_map[i].ocp);\n\t}\n\treturn (GetOEMCP());\n}\n#else\n\n/*\n * POSIX platform does not use CodePage.\n */\n\nstatic unsigned\nget_current_codepage(void)\n{\n\treturn (-1);/* Unknown */\n}\nstatic unsigned\nmake_codepage_from_charset(const char *charset)\n{\n\t(void)charset; /* UNUSED */\n\treturn (-1);/* Unknown */\n}\nstatic unsigned\nget_current_oemcp(void)\n{\n\treturn (-1);/* Unknown */\n}\n\n#endif /* defined(_WIN32) && !defined(__CYGWIN__) */\n\n/*\n * Return a string conversion object.\n */\nstatic struct archive_string_conv *\nget_sconv_object(struct archive *a, const char *fc, const char *tc, int flag)\n{\n\tstruct archive_string_conv *sc;\n\tunsigned current_codepage;\n\n\t/* Check if we have made the sconv object. */\n\tsc = find_sconv_object(a, fc, tc);\n\tif (sc != NULL)\n\t\treturn (sc);\n\n\tif (a == NULL)\n\t\tcurrent_codepage = get_current_codepage();\n\telse\n\t\tcurrent_codepage = a->current_codepage;\n\n\tsc = create_sconv_object(canonical_charset_name(fc),\n\t    canonical_charset_name(tc), current_codepage, flag);\n\tif (sc == NULL) {\n\t\tif (a != NULL)\n\t\t\tarchive_set_error(a, ENOMEM,\n\t\t\t    \"Could not allocate memory for \"\n\t\t\t    \"a string conversion object\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * If there is no converter for current string conversion object,\n\t * we cannot handle this conversion.\n\t */\n\tif (sc->nconverter == 0) {\n\t\tif (a != NULL) {\n#if HAVE_ICONV\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"iconv_open failed : Cannot handle ``%s''\",\n\t\t\t    (flag & SCONV_TO_CHARSET)?tc:fc);\n#else\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"A character-set conversion not fully supported \"\n\t\t\t    \"on this platform\");\n#endif\n\t\t}\n\t\t/* Failed; free a sconv object. */\n\t\tfree_sconv_object(sc);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Success!\n\t */\n\tif (a != NULL)\n\t\tadd_sconv_object(a, sc);\n\treturn (sc);\n}\n\nstatic const char *\nget_current_charset(struct archive *a)\n{\n\tconst char *cur_charset;\n\n\tif (a == NULL)\n\t\tcur_charset = default_iconv_charset(\"\");\n\telse {\n\t\tcur_charset = default_iconv_charset(a->current_code);\n\t\tif (a->current_code == NULL) {\n\t\t\ta->current_code = strdup(cur_charset);\n\t\t\ta->current_codepage = get_current_codepage();\n\t\t\ta->current_oemcp = get_current_oemcp();\n\t\t}\n\t}\n\treturn (cur_charset);\n}\n\n/*\n * Make and Return a string conversion object.\n * Return NULL if the platform does not support the specified conversion\n * and best_effort is 0.\n * If best_effort is set, A string conversion object must be returned\n * unless memory allocation for the object fails, but the conversion\n * might fail when non-ASCII code is found.\n */\nstruct archive_string_conv *\narchive_string_conversion_to_charset(struct archive *a, const char *charset,\n    int best_effort)\n{\n\tint flag = SCONV_TO_CHARSET;\n\n\tif (best_effort)\n\t\tflag |= SCONV_BEST_EFFORT;\n\treturn (get_sconv_object(a, get_current_charset(a), charset, flag));\n}\n\nstruct archive_string_conv *\narchive_string_conversion_from_charset(struct archive *a, const char *charset,\n    int best_effort)\n{\n\tint flag = SCONV_FROM_CHARSET;\n\n\tif (best_effort)\n\t\tflag |= SCONV_BEST_EFFORT;\n\treturn (get_sconv_object(a, charset, get_current_charset(a), flag));\n}\n\n/*\n * archive_string_default_conversion_*_archive() are provided for Windows\n * platform because other archiver application use CP_OEMCP for\n * MultiByteToWideChar() and WideCharToMultiByte() for the filenames\n * in tar or zip files. But mbstowcs/wcstombs(CRT) usually use CP_ACP\n * unless you use setlocale(LC_ALL, \".OCP\")(specify CP_OEMCP).\n * So we should make a string conversion between CP_ACP and CP_OEMCP\n * for compatibility.\n */\n#if defined(_WIN32) && !defined(__CYGWIN__)\nstruct archive_string_conv *\narchive_string_default_conversion_for_read(struct archive *a)\n{\n\tconst char *cur_charset = get_current_charset(a);\n\tchar oemcp[16];\n\n\t/* NOTE: a check of cur_charset is unneeded but we need\n\t * that get_current_charset() has been surely called at\n\t * this time whatever C compiler optimized. */\n\tif (cur_charset != NULL &&\n\t    (a->current_codepage == CP_C_LOCALE ||\n\t     a->current_codepage == a->current_oemcp))\n\t\treturn (NULL);/* no conversion. */\n\n\t_snprintf(oemcp, sizeof(oemcp)-1, \"CP%d\", a->current_oemcp);\n\t/* Make sure a null termination must be set. */\n\toemcp[sizeof(oemcp)-1] = '\\0';\n\treturn (get_sconv_object(a, oemcp, cur_charset,\n\t    SCONV_FROM_CHARSET));\n}\n\nstruct archive_string_conv *\narchive_string_default_conversion_for_write(struct archive *a)\n{\n\tconst char *cur_charset = get_current_charset(a);\n\tchar oemcp[16];\n\n\t/* NOTE: a check of cur_charset is unneeded but we need\n\t * that get_current_charset() has been surely called at\n\t * this time whatever C compiler optimized. */\n\tif (cur_charset != NULL &&\n\t    (a->current_codepage == CP_C_LOCALE ||\n\t     a->current_codepage == a->current_oemcp))\n\t\treturn (NULL);/* no conversion. */\n\n\t_snprintf(oemcp, sizeof(oemcp)-1, \"CP%d\", a->current_oemcp);\n\t/* Make sure a null termination must be set. */\n\toemcp[sizeof(oemcp)-1] = '\\0';\n\treturn (get_sconv_object(a, cur_charset, oemcp,\n\t    SCONV_TO_CHARSET));\n}\n#else\nstruct archive_string_conv *\narchive_string_default_conversion_for_read(struct archive *a)\n{\n\t(void)a; /* UNUSED */\n\treturn (NULL);\n}\n\nstruct archive_string_conv *\narchive_string_default_conversion_for_write(struct archive *a)\n{\n\t(void)a; /* UNUSED */\n\treturn (NULL);\n}\n#endif\n\n/*\n * Dispose of all character conversion objects in the archive object.\n */\nvoid\narchive_string_conversion_free(struct archive *a)\n{\n\tstruct archive_string_conv *sc; \n\tstruct archive_string_conv *sc_next; \n\n\tfor (sc = a->sconv; sc != NULL; sc = sc_next) {\n\t\tsc_next = sc->next;\n\t\tfree_sconv_object(sc);\n\t}\n\ta->sconv = NULL;\n\tfree(a->current_code);\n\ta->current_code = NULL;\n}\n\n/*\n * Return a conversion charset name.\n */\nconst char *\narchive_string_conversion_charset_name(struct archive_string_conv *sc)\n{\n\tif (sc->flag & SCONV_TO_CHARSET)\n\t\treturn (sc->to_charset);\n\telse\n\t\treturn (sc->from_charset);\n}\n\n/*\n * Change the behavior of a string conversion.\n */\nvoid\narchive_string_conversion_set_opt(struct archive_string_conv *sc, int opt)\n{\n\tswitch (opt) {\n\t/*\n\t * A filename in UTF-8 was made with libarchive 2.x in a wrong\n\t * assumption that wchar_t was Unicode.\n\t * This option enables simulating the assumption in order to read\n\t * that filename correctly.\n\t */\n\tcase SCONV_SET_OPT_UTF8_LIBARCHIVE2X:\n#if (defined(_WIN32) && !defined(__CYGWIN__)) \\\n\t || defined(__STDC_ISO_10646__) || defined(__APPLE__)\n\t\t/*\n\t\t * Nothing to do for it since wchar_t on these platforms\n\t\t * is really Unicode.\n\t\t */\n\t\t(void)sc; /* UNUSED */\n#else\n\t\tif ((sc->flag & SCONV_UTF8_LIBARCHIVE_2) == 0) {\n\t\t\tsc->flag |= SCONV_UTF8_LIBARCHIVE_2;\n\t\t\t/* Set up string converters. */\n\t\t\tsetup_converter(sc);\n\t\t}\n#endif\n\t\tbreak;\n\tcase SCONV_SET_OPT_NORMALIZATION_C:\n\t\tif ((sc->flag & SCONV_NORMALIZATION_C) == 0) {\n\t\t\tsc->flag |= SCONV_NORMALIZATION_C;\n\t\t\tsc->flag &= ~SCONV_NORMALIZATION_D;\n\t\t\t/* Set up string converters. */\n\t\t\tsetup_converter(sc);\n\t\t}\n\t\tbreak;\n\tcase SCONV_SET_OPT_NORMALIZATION_D:\n#if defined(HAVE_ICONV)\n\t\t/*\n\t\t * If iconv will take the string, do not change the\n\t\t * setting of the normalization.\n\t\t */\n\t\tif (!(sc->flag & SCONV_WIN_CP) &&\n\t\t     (sc->flag & (SCONV_FROM_UTF16 | SCONV_FROM_UTF8)) &&\n\t\t    !(sc->flag & (SCONV_TO_UTF16 | SCONV_TO_UTF8)))\n\t\t\tbreak;\n#endif\n\t\tif ((sc->flag & SCONV_NORMALIZATION_D) == 0) {\n\t\t\tsc->flag |= SCONV_NORMALIZATION_D;\n\t\t\tsc->flag &= ~SCONV_NORMALIZATION_C;\n\t\t\t/* Set up string converters. */\n\t\t\tsetup_converter(sc);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n *\n * Copy one archive_string to another in locale conversion.\n *\n *\tarchive_strncat_l();\n *\tarchive_strncpy_l();\n *\n */\n\nstatic size_t\nmbsnbytes(const void *_p, size_t n)\n{\n\tsize_t s;\n\tconst char *p, *pp;\n\n\tif (_p == NULL)\n\t\treturn (0);\n\tp = (const char *)_p;\n\n\t/* Like strlen(p), except won't examine positions beyond p[n]. */\n\ts = 0;\n\tpp = p;\n\twhile (s < n && *pp) {\n\t\tpp++;\n\t\ts++;\n\t}\n\treturn (s);\n}\n\nstatic size_t\nutf16nbytes(const void *_p, size_t n)\n{\n\tsize_t s;\n\tconst char *p, *pp;\n\n\tif (_p == NULL)\n\t\treturn (0);\n\tp = (const char *)_p;\n\n\t/* Like strlen(p), except won't examine positions beyond p[n]. */\n\ts = 0;\n\tpp = p;\n\tn >>= 1;\n\twhile (s < n && (pp[0] || pp[1])) {\n\t\tpp += 2;\n\t\ts++;\n\t}\n\treturn (s<<1);\n}\n\nint\narchive_strncpy_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tas->length = 0;\n\treturn (archive_strncat_l(as, _p, n, sc));\n}\n\nint\narchive_strncat_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tconst void *s;\n\tsize_t length = 0;\n\tint i, r = 0, r2;\n\n\tif (_p != NULL && n > 0) {\n\t\tif (sc != NULL && (sc->flag & SCONV_FROM_UTF16))\n\t\t\tlength = utf16nbytes(_p, n);\n\t\telse\n\t\t\tlength = mbsnbytes(_p, n);\n\t}\n\n\t/* We must allocate memory even if there is no data for conversion\n\t * or copy. This simulates archive_string_append behavior. */\n\tif (length == 0) {\n\t\tint tn = 1;\n\t\tif (sc != NULL && (sc->flag & SCONV_TO_UTF16))\n\t\t\ttn = 2;\n\t\tif (archive_string_ensure(as, as->length + tn) == NULL)\n\t\t\treturn (-1);\n\t\tas->s[as->length] = 0;\n\t\tif (tn == 2)\n\t\t\tas->s[as->length+1] = 0;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * If sc is NULL, we just make a copy.\n\t */\n\tif (sc == NULL) {\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);/* No memory */\n\t\treturn (0);\n\t}\n\n\ts = _p;\n\ti = 0;\n\tif (sc->nconverter > 1) {\n\t\tsc->utftmp.length = 0;\n\t\tr2 = sc->converter[0](&(sc->utftmp), s, length, sc);\n\t\tif (r2 != 0 && errno == ENOMEM)\n\t\t\treturn (r2);\n\t\tif (r > r2)\n\t\t\tr = r2;\n\t\ts = sc->utftmp.s;\n\t\tlength = sc->utftmp.length;\n\t\t++i;\n\t}\n\tr2 = sc->converter[i](as, s, length, sc);\n\tif (r > r2)\n\t\tr = r2;\n\treturn (r);\n}\n\n#if HAVE_ICONV\n\n/*\n * Return -1 if conversion fails.\n */\nstatic int\niconv_strncat_in_locale(struct archive_string *as, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\tICONV_CONST char *itp;\n\tsize_t remaining;\n\ticonv_t cd;\n\tchar *outp;\n\tsize_t avail, bs;\n\tint return_value = 0; /* success */\n\tint to_size, from_size;\n\n\tif (sc->flag & SCONV_TO_UTF16)\n\t\tto_size = 2;\n\telse\n\t\tto_size = 1;\n\tif (sc->flag & SCONV_FROM_UTF16)\n\t\tfrom_size = 2;\n\telse\n\t\tfrom_size = 1;\n\n\tif (archive_string_ensure(as, as->length + length*2+to_size) == NULL)\n\t\treturn (-1);\n\n\tcd = sc->cd;\n\titp = (char *)(uintptr_t)_p;\n\tremaining = length;\n\toutp = as->s + as->length;\n\tavail = as->buffer_length - as->length - to_size;\n\twhile (remaining >= (size_t)from_size) {\n\t\tsize_t result = iconv(cd, &itp, &remaining, &outp, &avail);\n\n\t\tif (result != (size_t)-1)\n\t\t\tbreak; /* Conversion completed. */\n\n\t\tif (errno == EILSEQ || errno == EINVAL) {\n\t\t\t/*\n\t\t \t * If an output charset is UTF-8 or UTF-16BE/LE,\n\t\t\t * unknown character should be U+FFFD\n\t\t\t * (replacement character).\n\t\t\t */\n\t\t\tif (sc->flag & (SCONV_TO_UTF8 | SCONV_TO_UTF16)) {\n\t\t\t\tsize_t rbytes;\n\t\t\t\tif (sc->flag & SCONV_TO_UTF8)\n\t\t\t\t\trbytes = sizeof(utf8_replacement_char);\n\t\t\t\telse\n\t\t\t\t\trbytes = 2;\n\n\t\t\t\tif (avail < rbytes) {\n\t\t\t\t\tas->length = outp - as->s;\n\t\t\t\t\tbs = as->buffer_length +\n\t\t\t\t\t    (remaining * to_size) + rbytes;\n\t\t\t\t\tif (NULL ==\n\t\t\t\t\t    archive_string_ensure(as, bs))\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\toutp = as->s + as->length;\n\t\t\t\t\tavail = as->buffer_length\n\t\t\t\t\t    - as->length - to_size;\n\t\t\t\t}\n\t\t\t\tif (sc->flag & SCONV_TO_UTF8)\n\t\t\t\t\tmemcpy(outp, utf8_replacement_char, sizeof(utf8_replacement_char));\n\t\t\t\telse if (sc->flag & SCONV_TO_UTF16BE)\n\t\t\t\t\tarchive_be16enc(outp, UNICODE_R_CHAR);\n\t\t\t\telse\n\t\t\t\t\tarchive_le16enc(outp, UNICODE_R_CHAR);\n\t\t\t\toutp += rbytes;\n\t\t\t\tavail -= rbytes;\n\t\t\t} else {\n\t\t\t\t/* Skip the illegal input bytes. */\n\t\t\t\t*outp++ = '?';\n\t\t\t\tavail--;\n\t\t\t}\n\t\t\titp += from_size;\n\t\t\tremaining -= from_size;\n\t\t\treturn_value = -1; /* failure */\n\t\t} else {\n\t\t\t/* E2BIG no output buffer,\n\t\t\t * Increase an output buffer.  */\n\t\t\tas->length = outp - as->s;\n\t\t\tbs = as->buffer_length + remaining * 2;\n\t\t\tif (NULL == archive_string_ensure(as, bs))\n\t\t\t\treturn (-1);\n\t\t\toutp = as->s + as->length;\n\t\t\tavail = as->buffer_length - as->length - to_size;\n\t\t}\n\t}\n\tas->length = outp - as->s;\n\tas->s[as->length] = 0;\n\tif (to_size == 2)\n\t\tas->s[as->length+1] = 0;\n\treturn (return_value);\n}\n\n#endif /* HAVE_ICONV */\n\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\n/*\n * Translate a string from a some CodePage to an another CodePage by\n * Windows APIs, and copy the result. Return -1 if conversion fails.\n */\nstatic int\nstrncat_in_codepage(struct archive_string *as,\n    const void *_p, size_t length, struct archive_string_conv *sc)\n{\n\tconst char *s = (const char *)_p;\n\tstruct archive_wstring aws;\n\tsize_t l;\n\tint r, saved_flag;\n\n\tarchive_string_init(&aws);\n\tsaved_flag = sc->flag;\n\tsc->flag &= ~(SCONV_NORMALIZATION_D | SCONV_NORMALIZATION_C);\n\tr = archive_wstring_append_from_mbs_in_codepage(&aws, s, length, sc);\n\tsc->flag = saved_flag;\n\tif (r != 0) {\n\t\tarchive_wstring_free(&aws);\n\t\tif (errno != ENOMEM)\n\t\t\tarchive_string_append(as, s, length);\n\t\treturn (-1);\n\t}\n\n\tl = as->length;\n\tr = archive_string_append_from_wcs_in_codepage(\n\t    as, aws.s, aws.length, sc);\n\tif (r != 0 && errno != ENOMEM && l == as->length)\n\t\tarchive_string_append(as, s, length);\n\tarchive_wstring_free(&aws);\n\treturn (r);\n}\n\n/*\n * Test whether MBS ==> WCS is okay.\n */\nstatic int\ninvalid_mbs(const void *_p, size_t n, struct archive_string_conv *sc)\n{\n\tconst char *p = (const char *)_p;\n\tunsigned codepage;\n\tDWORD mbflag = MB_ERR_INVALID_CHARS;\n\n\tif (sc->flag & SCONV_FROM_CHARSET)\n\t\tcodepage = sc->to_cp;\n\telse\n\t\tcodepage = sc->from_cp;\n\n\tif (codepage == CP_C_LOCALE)\n\t\treturn (0);\n\tif (codepage != CP_UTF8)\n\t\tmbflag |= MB_PRECOMPOSED;\n\n\tif (MultiByteToWideChar(codepage, mbflag, p, (int)n, NULL, 0) == 0)\n\t\treturn (-1); /* Invalid */\n\treturn (0); /* Okay */\n}\n\n#else\n\n/*\n * Test whether MBS ==> WCS is okay.\n */\nstatic int\ninvalid_mbs(const void *_p, size_t n, struct archive_string_conv *sc)\n{\n\tconst char *p = (const char *)_p;\n\tsize_t r;\n\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\t/* Clear the shift state before starting. */\n\tmbtowc(NULL, NULL, 0);\n#endif\n\twhile (n) {\n\t\twchar_t wc;\n\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(&wc, p, n, &shift_state);\n#else\n\t\tr = mbtowc(&wc, p, n);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2)\n\t\t\treturn (-1);/* Invalid. */\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tp += r;\n\t\tn -= r;\n\t}\n\t(void)sc; /* UNUSED */\n\treturn (0); /* All Okey. */\n}\n\n#endif /* defined(_WIN32) && !defined(__CYGWIN__) */\n\n/*\n * Basically returns -1 because we cannot make a conversion of charset\n * without iconv but in some cases this would return 0.\n * Returns 0 if all copied characters are ASCII.\n * Returns 0 if both from-locale and to-locale are the same and those\n * can be WCS with no error.\n */\nstatic int\nbest_effort_strncat_in_locale(struct archive_string *as, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\tsize_t remaining;\n\tconst uint8_t *itp;\n\tint return_value = 0; /* success */\n\n\t/*\n\t * If both from-locale and to-locale is the same, this makes a copy.\n\t * And then this checks all copied MBS can be WCS if so returns 0.\n\t */\n\tif (sc->same) {\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);/* No memory */\n\t\treturn (invalid_mbs(_p, length, sc));\n\t}\n\n\t/*\n\t * If a character is ASCII, this just copies it. If not, this\n\t * assigns '?' character instead but in UTF-8 locale this assigns\n\t * byte sequence 0xEF 0xBD 0xBD, which are code point U+FFFD,\n\t * a Replacement Character in Unicode.\n\t */\n\n\tremaining = length;\n\titp = (const uint8_t *)_p;\n\twhile (*itp && remaining > 0) {\n\t\tif (*itp > 127) {\n\t\t\t// Non-ASCII: Substitute with suitable replacement\n\t\t\tif (sc->flag & SCONV_TO_UTF8) {\n\t\t\t\tif (archive_string_append(as, utf8_replacement_char, sizeof(utf8_replacement_char)) == NULL) {\n\t\t\t\t\t__archive_errx(1, \"Out of memory\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarchive_strappend_char(as, '?');\n\t\t\t}\n\t\t\treturn_value = -1;\n\t\t} else {\n\t\t\tarchive_strappend_char(as, *itp);\n\t\t}\n\t\t++itp;\n\t}\n\treturn (return_value);\n}\n\n\n/*\n * Unicode conversion functions.\n *   - UTF-8 <===> UTF-8 in removing surrogate pairs.\n *   - UTF-8 NFD ===> UTF-8 NFC in removing surrogate pairs.\n *   - UTF-8 made by libarchive 2.x ===> UTF-8.\n *   - UTF-16BE <===> UTF-8.\n *\n */\n\n/*\n * Utility to convert a single UTF-8 sequence.\n *\n * Usually return used bytes, return used byte in negative value when\n * a unicode character is replaced with U+FFFD.\n * See also http://unicode.org/review/pr-121.html Public Review Issue #121\n * Recommended Practice for Replacement Characters.\n */\nstatic int\n_utf8_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\tstatic const char utf8_count[256] = {\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 00 - 0F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 10 - 1F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 20 - 2F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 30 - 3F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 40 - 4F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 50 - 5F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 60 - 6F */\n\t\t 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,/* 70 - 7F */\n\t\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,/* 80 - 8F */\n\t\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,/* 90 - 9F */\n\t\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,/* A0 - AF */\n\t\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,/* B0 - BF */\n\t\t 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,/* C0 - CF */\n\t\t 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,/* D0 - DF */\n\t\t 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,/* E0 - EF */\n\t\t 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /* F0 - FF */\n\t};\n\tint ch, i;\n\tint cnt;\n\tuint32_t wc;\n\n\t/* Sanity check. */\n\tif (n == 0)\n\t\treturn (0);\n\t/*\n\t * Decode 1-4 bytes depending on the value of the first byte.\n\t */\n\tch = (unsigned char)*s;\n\tif (ch == 0)\n\t\treturn (0); /* Standard:  return 0 for end-of-string. */\n\tcnt = utf8_count[ch];\n\n\t/* Invalid sequence or there are not plenty bytes. */\n\tif ((int)n < cnt) {\n\t\tcnt = (int)n;\n\t\tfor (i = 1; i < cnt; i++) {\n\t\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\t\tcnt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgoto invalid_sequence;\n\t}\n\n\t/* Make a Unicode code point from a single UTF-8 sequence. */\n\tswitch (cnt) {\n\tcase 1:\t/* 1 byte sequence. */\n\t\t*pwc = ch & 0x7f;\n\t\treturn (cnt);\n\tcase 2:\t/* 2 bytes sequence. */\n\t\tif ((s[1] & 0xc0) != 0x80) {\n\t\t\tcnt = 1;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\t*pwc = ((ch & 0x1f) << 6) | (s[1] & 0x3f);\n\t\treturn (cnt);\n\tcase 3:\t/* 3 bytes sequence. */\n\t\tif ((s[1] & 0xc0) != 0x80) {\n\t\t\tcnt = 1;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\tif ((s[2] & 0xc0) != 0x80) {\n\t\t\tcnt = 2;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\twc = ((ch & 0x0f) << 12)\n\t\t    | ((s[1] & 0x3f) << 6)\n\t\t    | (s[2] & 0x3f);\n\t\tif (wc < 0x800)\n\t\t\tgoto invalid_sequence;/* Overlong sequence. */\n\t\tbreak;\n\tcase 4:\t/* 4 bytes sequence. */\n\t\tif ((s[1] & 0xc0) != 0x80) {\n\t\t\tcnt = 1;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\tif ((s[2] & 0xc0) != 0x80) {\n\t\t\tcnt = 2;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\tif ((s[3] & 0xc0) != 0x80) {\n\t\t\tcnt = 3;\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\twc = ((ch & 0x07) << 18)\n\t\t    | ((s[1] & 0x3f) << 12)\n\t\t    | ((s[2] & 0x3f) << 6)\n\t\t    | (s[3] & 0x3f);\n\t\tif (wc < 0x10000)\n\t\t\tgoto invalid_sequence;/* Overlong sequence. */\n\t\tbreak;\n\tdefault: /* Others are all invalid sequence. */\n\t\tif (ch == 0xc0 || ch == 0xc1)\n\t\t\tcnt = 2;\n\t\telse if (ch >= 0xf5 && ch <= 0xf7)\n\t\t\tcnt = 4;\n\t\telse if (ch >= 0xf8 && ch <= 0xfb)\n\t\t\tcnt = 5;\n\t\telse if (ch == 0xfc || ch == 0xfd)\n\t\t\tcnt = 6;\n\t\telse\n\t\t\tcnt = 1;\n\t\tif ((int)n < cnt)\n\t\t\tcnt = (int)n;\n\t\tfor (i = 1; i < cnt; i++) {\n\t\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\t\tcnt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgoto invalid_sequence;\n\t}\n\n\t/* The code point larger than 0x10FFFF is not legal\n\t * Unicode values. */\n\tif (wc > UNICODE_MAX)\n\t\tgoto invalid_sequence;\n\t/* Correctly gets a Unicode, returns used bytes. */\n\t*pwc = wc;\n\treturn (cnt);\ninvalid_sequence:\n\t*pwc = UNICODE_R_CHAR;/* set the Replacement Character instead. */\n\treturn (cnt * -1);\n}\n\nstatic int\nutf8_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\tint cnt;\n\n\tcnt = _utf8_to_unicode(pwc, s, n);\n\t/* Any of Surrogate pair is not legal Unicode values. */\n\tif (cnt == 3 && IS_SURROGATE_PAIR_LA(*pwc))\n\t\treturn (-3);\n\treturn (cnt);\n}\n\nstatic inline uint32_t\ncombine_surrogate_pair(uint32_t uc, uint32_t uc2)\n{\n\tuc -= 0xD800;\n\tuc *= 0x400;\n\tuc += uc2 - 0xDC00;\n\tuc += 0x10000;\n\treturn (uc);\n}\n\n/*\n * Convert a single UTF-8/CESU-8 sequence to a Unicode code point in\n * removing surrogate pairs.\n *\n * CESU-8: The Compatibility Encoding Scheme for UTF-16.\n *\n * Usually return used bytes, return used byte in negative value when\n * a unicode character is replaced with U+FFFD.\n */\nstatic int\ncesu8_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\tuint32_t wc = 0;\n\tint cnt;\n\n\tcnt = _utf8_to_unicode(&wc, s, n);\n\tif (cnt == 3 && IS_HIGH_SURROGATE_LA(wc)) {\n\t\tuint32_t wc2 = 0;\n\t\tif (n - 3 < 3) {\n\t\t\t/* Invalid byte sequence. */\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\tcnt = _utf8_to_unicode(&wc2, s+3, n-3);\n\t\tif (cnt != 3 || !IS_LOW_SURROGATE_LA(wc2)) {\n\t\t\t/* Invalid byte sequence. */\n\t\t\tgoto invalid_sequence;\n\t\t}\n\t\twc = combine_surrogate_pair(wc, wc2);\n\t\tcnt = 6;\n\t} else if (cnt == 3 && IS_LOW_SURROGATE_LA(wc)) {\n\t\t/* Invalid byte sequence. */\n\t\tgoto invalid_sequence;\n\t}\n\t*pwc = wc;\n\treturn (cnt);\ninvalid_sequence:\n\t*pwc = UNICODE_R_CHAR;/* set the Replacement Character instead. */\n\tif (cnt > 0)\n\t\tcnt *= -1;\n\treturn (cnt);\n}\n\n/*\n * Convert a Unicode code point to a single UTF-8 sequence.\n *\n * NOTE:This function does not check if the Unicode is legal or not.\n * Please you definitely check it before calling this.\n */\nstatic size_t\nunicode_to_utf8(char *p, size_t remaining, uint32_t uc)\n{\n\tchar *_p = p;\n\n\t/* Invalid Unicode char maps to Replacement character */\n\tif (uc > UNICODE_MAX)\n\t\tuc = UNICODE_R_CHAR;\n\t/* Translate code point to UTF8 */\n\tif (uc <= 0x7f) {\n\t\tif (remaining == 0)\n\t\t\treturn (0);\n\t\t*p++ = (char)uc;\n\t} else if (uc <= 0x7ff) {\n\t\tif (remaining < 2)\n\t\t\treturn (0);\n\t\t*p++ = 0xc0 | ((uc >> 6) & 0x1f);\n\t\t*p++ = 0x80 | (uc & 0x3f);\n\t} else if (uc <= 0xffff) {\n\t\tif (remaining < 3)\n\t\t\treturn (0);\n\t\t*p++ = 0xe0 | ((uc >> 12) & 0x0f);\n\t\t*p++ = 0x80 | ((uc >> 6) & 0x3f);\n\t\t*p++ = 0x80 | (uc & 0x3f);\n\t} else {\n\t\tif (remaining < 4)\n\t\t\treturn (0);\n\t\t*p++ = 0xf0 | ((uc >> 18) & 0x07);\n\t\t*p++ = 0x80 | ((uc >> 12) & 0x3f);\n\t\t*p++ = 0x80 | ((uc >> 6) & 0x3f);\n\t\t*p++ = 0x80 | (uc & 0x3f);\n\t}\n\treturn (p - _p);\n}\n\nstatic int\nutf16be_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\treturn (utf16_to_unicode(pwc, s, n, 1));\n}\n\nstatic int\nutf16le_to_unicode(uint32_t *pwc, const char *s, size_t n)\n{\n\treturn (utf16_to_unicode(pwc, s, n, 0));\n}\n\nstatic int\nutf16_to_unicode(uint32_t *pwc, const char *s, size_t n, int be)\n{\n\tconst char *utf16 = s;\n\tunsigned uc;\n\n\tif (n == 0)\n\t\treturn (0);\n\tif (n == 1) {\n\t\t/* set the Replacement Character instead. */\n\t\t*pwc = UNICODE_R_CHAR;\n\t\treturn (-1);\n\t}\n\n\tif (be)\n\t\tuc = archive_be16dec(utf16);\n\telse\n\t\tuc = archive_le16dec(utf16);\n\tutf16 += 2;\n\t\t\n\t/* If this is a surrogate pair, assemble the full code point.*/\n\tif (IS_HIGH_SURROGATE_LA(uc)) {\n\t\tunsigned uc2;\n\n\t\tif (n >= 4) {\n\t\t\tif (be)\n\t\t\t\tuc2 = archive_be16dec(utf16);\n\t\t\telse\n\t\t\t\tuc2 = archive_le16dec(utf16);\n\t\t} else\n\t\t\tuc2 = 0;\n\t\tif (IS_LOW_SURROGATE_LA(uc2)) {\n\t\t\tuc = combine_surrogate_pair(uc, uc2);\n\t\t\tutf16 += 2;\n\t\t} else {\n\t \t\t/* Undescribed code point should be U+FFFD\n\t\t \t* (replacement character). */\n\t\t\t*pwc = UNICODE_R_CHAR;\n\t\t\treturn (-2);\n\t\t}\n\t}\n\n\t/*\n\t * Surrogate pair values(0xd800 through 0xdfff) are only\n\t * used by UTF-16, so, after above calculation, the code\n\t * must not be surrogate values, and Unicode has no codes\n\t * larger than 0x10ffff. Thus, those are not legal Unicode\n\t * values.\n\t */\n\tif (IS_SURROGATE_PAIR_LA(uc) || uc > UNICODE_MAX) {\n\t \t/* Undescribed code point should be U+FFFD\n\t \t* (replacement character). */\n\t\t*pwc = UNICODE_R_CHAR;\n\t\treturn (((int)(utf16 - s)) * -1);\n\t}\n\t*pwc = uc;\n\treturn ((int)(utf16 - s));\n}\n\nstatic size_t\nunicode_to_utf16be(char *p, size_t remaining, uint32_t uc)\n{\n\tchar *utf16 = p;\n\n\tif (uc > 0xffff) {\n\t\t/* We have a code point that won't fit into a\n\t\t * wchar_t; convert it to a surrogate pair. */\n\t\tif (remaining < 4)\n\t\t\treturn (0);\n\t\tuc -= 0x10000;\n\t\tarchive_be16enc(utf16, ((uc >> 10) & 0x3ff) + 0xD800);\n\t\tarchive_be16enc(utf16+2, (uc & 0x3ff) + 0xDC00);\n\t\treturn (4);\n\t} else {\n\t\tif (remaining < 2)\n\t\t\treturn (0);\n\t\tarchive_be16enc(utf16, uc);\n\t\treturn (2);\n\t}\n}\n\nstatic size_t\nunicode_to_utf16le(char *p, size_t remaining, uint32_t uc)\n{\n\tchar *utf16 = p;\n\n\tif (uc > 0xffff) {\n\t\t/* We have a code point that won't fit into a\n\t\t * wchar_t; convert it to a surrogate pair. */\n\t\tif (remaining < 4)\n\t\t\treturn (0);\n\t\tuc -= 0x10000;\n\t\tarchive_le16enc(utf16, ((uc >> 10) & 0x3ff) + 0xD800);\n\t\tarchive_le16enc(utf16+2, (uc & 0x3ff) + 0xDC00);\n\t\treturn (4);\n\t} else {\n\t\tif (remaining < 2)\n\t\t\treturn (0);\n\t\tarchive_le16enc(utf16, uc);\n\t\treturn (2);\n\t}\n}\n\n/*\n * Copy UTF-8 string in checking surrogate pair.\n * If any surrogate pair are found, it would be canonicalized.\n */\nstatic int\nstrncat_from_utf8_to_utf8(struct archive_string *as, const void *_p,\n    size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tchar *p, *endp;\n\tint n, ret = 0;\n\n\t(void)sc; /* UNUSED */\n\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tendp = as->s + as->buffer_length -1;\n\tdo {\n\t\tuint32_t uc;\n\t\tconst char *ss = s;\n\t\tsize_t w;\n\n\t\t/*\n\t\t * Forward byte sequence until a conversion of that is needed.\n\t\t */\n\t\twhile ((n = utf8_to_unicode(&uc, s, len)) > 0) {\n\t\t\ts += n;\n\t\t\tlen -= n;\n\t\t}\n\t\tif (ss < s) {\n\t\t\tif (p + (s - ss) > endp) {\n\t\t\t\tas->length = p - as->s;\n\t\t\t\tif (archive_string_ensure(as,\n\t\t\t\t    as->buffer_length + len + 1) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tp = as->s + as->length;\n\t\t\t\tendp = as->s + as->buffer_length -1;\n\t\t\t}\n\n\t\t\tmemcpy(p, ss, s - ss);\n\t\t\tp += s - ss;\n\t\t}\n\n\t\t/*\n\t\t * If n is negative, current byte sequence needs a replacement.\n\t\t */\n\t\tif (n < 0) {\n\t\t\tif (n == -3 && IS_SURROGATE_PAIR_LA(uc)) {\n\t\t\t\t/* Current byte sequence may be CESU-8. */\n\t\t\t\tn = cesu8_to_unicode(&uc, s, len);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tret = -1;\n\t\t\t\tn *= -1;/* Use a replaced unicode character. */\n\t\t\t}\n\n\t\t\t/* Rebuild UTF-8 byte sequence. */\n\t\t\twhile ((w = unicode_to_utf8(p, endp - p, uc)) == 0) {\n\t\t\t\tas->length = p - as->s;\n\t\t\t\tif (archive_string_ensure(as,\n\t\t\t\t    as->buffer_length + len + 1) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tp = as->s + as->length;\n\t\t\t\tendp = as->s + as->buffer_length -1;\n\t\t\t}\n\t\t\tp += w;\n\t\t\ts += n;\n\t\t\tlen -= n;\n\t\t}\n\t} while (n > 0);\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret);\n}\n\nstatic int\narchive_string_append_unicode(struct archive_string *as, const void *_p,\n    size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tchar *p, *endp;\n\tuint32_t uc;\n\tsize_t w;\n\tint n, ret = 0, ts, tm;\n\tint (*parse)(uint32_t *, const char *, size_t);\n\tsize_t (*unparse)(char *, size_t, uint32_t);\n\n\tif (sc->flag & SCONV_TO_UTF16BE) {\n\t\tunparse = unicode_to_utf16be;\n\t\tts = 2;\n\t} else if (sc->flag & SCONV_TO_UTF16LE) {\n\t\tunparse = unicode_to_utf16le;\n\t\tts = 2;\n\t} else if (sc->flag & SCONV_TO_UTF8) {\n\t\tunparse = unicode_to_utf8;\n\t\tts = 1;\n\t} else {\n\t\t/*\n\t\t * This case is going to be converted to another\n\t\t * character-set through iconv.\n\t\t */\n\t\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\t\tunparse = unicode_to_utf16be;\n\t\t\tts = 2;\n\t\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\t\tunparse = unicode_to_utf16le;\n\t\t\tts = 2;\n\t\t} else {\n\t\t\tunparse = unicode_to_utf8;\n\t\t\tts = 1;\n\t\t}\n\t}\n\n\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\tparse = utf16be_to_unicode;\n\t\ttm = 1;\n\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\tparse = utf16le_to_unicode;\n\t\ttm = 1;\n\t} else {\n\t\tparse = cesu8_to_unicode;\n\t\ttm = ts;\n\t}\n\n\tif (archive_string_ensure(as, as->length + len * tm + ts) == NULL)\n\t\treturn (-1);\n\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tendp = as->s + as->buffer_length - ts;\n\twhile ((n = parse(&uc, s, len)) != 0) {\n\t\tif (n < 0) {\n\t\t\t/* Use a replaced unicode character. */\n\t\t\tn *= -1;\n\t\t\tret = -1;\n\t\t}\n\t\ts += n;\n\t\tlen -= n;\n\t\twhile ((w = unparse(p, endp - p, uc)) == 0) {\n\t\t\t/* There is not enough output buffer so\n\t\t\t * we have to expand it. */\n\t\t\tas->length = p - as->s;\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->buffer_length + len * tm + ts) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tendp = as->s + as->buffer_length - ts;\n\t\t}\n\t\tp += w;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\tif (ts == 2)\n\t\tas->s[as->length+1] = '\\0';\n\treturn (ret);\n}\n\n/*\n * Following Constants for Hangul compositions this information comes from\n * Unicode Standard Annex #15  http://unicode.org/reports/tr15/\n */\n#define HC_SBASE\t0xAC00\n#define HC_LBASE\t0x1100\n#define HC_VBASE\t0x1161\n#define HC_TBASE\t0x11A7\n#define HC_LCOUNT\t19\n#define HC_VCOUNT\t21\n#define HC_TCOUNT\t28\n#define HC_NCOUNT\t(HC_VCOUNT * HC_TCOUNT)\n#define HC_SCOUNT\t(HC_LCOUNT * HC_NCOUNT)\n\nstatic uint32_t\nget_nfc(uint32_t uc, uint32_t uc2)\n{\n\tint t, b;\n\n\tt = 0;\n\tb = sizeof(u_composition_table)/sizeof(u_composition_table[0]) -1;\n\twhile (b >= t) {\n\t\tint m = (t + b) / 2;\n\t\tif (u_composition_table[m].cp1 < uc)\n\t\t\tt = m + 1;\n\t\telse if (u_composition_table[m].cp1 > uc)\n\t\t\tb = m - 1;\n\t\telse if (u_composition_table[m].cp2 < uc2)\n\t\t\tt = m + 1;\n\t\telse if (u_composition_table[m].cp2 > uc2)\n\t\t\tb = m - 1;\n\t\telse\n\t\t\treturn (u_composition_table[m].nfc);\n\t}\n\treturn (0);\n}\n\n#define FDC_MAX 10\t/* The maximum number of Following Decomposable\n\t\t\t * Characters. */\n\n/*\n * Update first code point.\n */\n#define UPDATE_UC(new_uc)\tdo {\t\t\\\n\tuc = new_uc;\t\t\t\t\\\n\tucptr = NULL;\t\t\t\t\\\n} while (0)\n\n/*\n * Replace first code point with second code point.\n */\n#define REPLACE_UC_WITH_UC2() do {\t\t\\\n\tuc = uc2;\t\t\t\t\\\n\tucptr = uc2ptr;\t\t\t\t\\\n\tn = n2;\t\t\t\t\t\\\n} while (0)\n\n#define EXPAND_BUFFER() do {\t\t\t\\\n\tas->length = p - as->s;\t\t\t\\\n\tif (archive_string_ensure(as,\t\t\\\n\t    as->buffer_length + len * tm + ts) == NULL)\\\n\t\treturn (-1);\t\t\t\\\n\tp = as->s + as->length;\t\t\t\\\n\tendp = as->s + as->buffer_length - ts;\t\\\n} while (0)\n\n#define UNPARSE(p, endp, uc)\tdo {\t\t\\\n\twhile ((w = unparse(p, (endp) - (p), uc)) == 0) {\\\n\t\tEXPAND_BUFFER();\t\t\\\n\t}\t\t\t\t\t\\\n\tp += w;\t\t\t\t\t\\\n} while (0)\n\n/*\n * Write first code point.\n * If the code point has not be changed from its original code,\n * this just copies it from its original buffer pointer.\n * If not, this converts it to UTF-8 byte sequence and copies it.\n */\n#define WRITE_UC()\tdo {\t\t\t\\\n\tif (ucptr) {\t\t\t\t\\\n\t\tif (p + n > endp)\t\t\\\n\t\t\tEXPAND_BUFFER();\t\\\n\t\tswitch (n) {\t\t\t\\\n\t\tcase 4:\t\t\t\t\\\n\t\t\t*p++ = *ucptr++;\t\\\n\t\t\t/* FALL THROUGH */\t\\\n\t\tcase 3:\t\t\t\t\\\n\t\t\t*p++ = *ucptr++;\t\\\n\t\t\t/* FALL THROUGH */\t\\\n\t\tcase 2:\t\t\t\t\\\n\t\t\t*p++ = *ucptr++;\t\\\n\t\t\t/* FALL THROUGH */\t\\\n\t\tcase 1:\t\t\t\t\\\n\t\t\t*p++ = *ucptr;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\t}\t\t\t\t\\\n\t\tucptr = NULL;\t\t\t\\\n\t} else {\t\t\t\t\\\n\t\tUNPARSE(p, endp, uc);\t\t\\\n\t}\t\t\t\t\t\\\n} while (0)\n\n/*\n * Collect following decomposable code points.\n */\n#define COLLECT_CPS(start)\tdo {\t\t\\\n\tint _i;\t\t\t\t\t\\\n\tfor (_i = start; _i < FDC_MAX ; _i++) {\t\\\n\t\tnx = parse(&ucx[_i], s, len);\t\\\n\t\tif (nx <= 0)\t\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcx = CCC(ucx[_i]);\t\t\\\n\t\tif (cl >= cx && cl != 228 && cx != 228)\\\n\t\t\tbreak;\t\t\t\\\n\t\ts += nx;\t\t\t\\\n\t\tlen -= nx;\t\t\t\\\n\t\tcl = cx;\t\t\t\\\n\t\tccx[_i] = cx;\t\t\t\\\n\t}\t\t\t\t\t\\\n\tif (_i >= FDC_MAX) {\t\t\t\\\n\t\tret = -1;\t\t\t\\\n\t\tucx_size = FDC_MAX;\t\t\\\n\t} else\t\t\t\t\t\\\n\t\tucx_size = _i;\t\t\t\\\n} while (0)\n\n/*\n * Normalize UTF-8/UTF-16BE characters to Form C and copy the result.\n *\n * TODO: Convert composition exclusions, which are never converted\n * from NFC,NFD,NFKC and NFKD, to Form C.\n */\nstatic int\narchive_string_normalize_C(struct archive_string *as, const void *_p,\n    size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s = (const char *)_p;\n\tchar *p, *endp;\n\tuint32_t uc, uc2;\n\tsize_t w;\n\tint always_replace, n, n2, ret = 0, spair, ts, tm;\n\tint (*parse)(uint32_t *, const char *, size_t);\n\tsize_t (*unparse)(char *, size_t, uint32_t);\n\n\talways_replace = 1;\n\tts = 1;/* text size. */\n\tif (sc->flag & SCONV_TO_UTF16BE) {\n\t\tunparse = unicode_to_utf16be;\n\t\tts = 2;\n\t\tif (sc->flag & SCONV_FROM_UTF16BE)\n\t\t\talways_replace = 0;\n\t} else if (sc->flag & SCONV_TO_UTF16LE) {\n\t\tunparse = unicode_to_utf16le;\n\t\tts = 2;\n\t\tif (sc->flag & SCONV_FROM_UTF16LE)\n\t\t\talways_replace = 0;\n\t} else if (sc->flag & SCONV_TO_UTF8) {\n\t\tunparse = unicode_to_utf8;\n\t\tif (sc->flag & SCONV_FROM_UTF8)\n\t\t\talways_replace = 0;\n\t} else {\n\t\t/*\n\t\t * This case is going to be converted to another\n\t\t * character-set through iconv.\n\t\t */\n\t\talways_replace = 0;\n\t\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\t\tunparse = unicode_to_utf16be;\n\t\t\tts = 2;\n\t\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\t\tunparse = unicode_to_utf16le;\n\t\t\tts = 2;\n\t\t} else {\n\t\t\tunparse = unicode_to_utf8;\n\t\t}\n\t}\n\n\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\tparse = utf16be_to_unicode;\n\t\ttm = 1;\n\t\tspair = 4;/* surrogate pair size in UTF-16. */\n\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\tparse = utf16le_to_unicode;\n\t\ttm = 1;\n\t\tspair = 4;/* surrogate pair size in UTF-16. */\n\t} else {\n\t\tparse = cesu8_to_unicode;\n\t\ttm = ts;\n\t\tspair = 6;/* surrogate pair size in UTF-8. */\n\t}\n\n\tif (archive_string_ensure(as, as->length + len * tm + ts) == NULL)\n\t\treturn (-1);\n\n\tp = as->s + as->length;\n\tendp = as->s + as->buffer_length - ts;\n\twhile ((n = parse(&uc, s, len)) != 0) {\n\t\tconst char *ucptr, *uc2ptr;\n\n\t\tif (n < 0) {\n\t\t\t/* Use a replaced unicode character. */\n\t\t\tUNPARSE(p, endp, uc);\n\t\t\ts += n*-1;\n\t\t\tlen -= n*-1;\n\t\t\tret = -1;\n\t\t\tcontinue;\n\t\t} else if (n == spair || always_replace)\n\t\t\t/* uc is converted from a surrogate pair.\n\t\t\t * this should be treated as a changed code. */\n\t\t\tucptr = NULL;\n\t\telse\n\t\t\tucptr = s;\n\t\ts += n;\n\t\tlen -= n;\n\n\t\t/* Read second code point. */\n\t\twhile ((n2 = parse(&uc2, s, len)) > 0) {\n\t\t\tuint32_t ucx[FDC_MAX];\n\t\t\tint ccx[FDC_MAX];\n\t\t\tint cl, cx, i, nx, ucx_size;\n\t\t\tint LIndex,SIndex;\n\t\t\tuint32_t nfc;\n\n\t\t\tif (n2 == spair || always_replace)\n\t\t\t\t/* uc2 is converted from a surrogate pair.\n\t\t\t \t * this should be treated as a changed code. */\n\t\t\t\tuc2ptr = NULL;\n\t\t\telse\n\t\t\t\tuc2ptr = s;\n\t\t\ts += n2;\n\t\t\tlen -= n2;\n\n\t\t\t/*\n\t\t\t * If current second code point is out of decomposable\n\t\t\t * code points, finding compositions is unneeded.\n\t\t\t */\n\t\t\tif (!IS_DECOMPOSABLE_BLOCK(uc2)) {\n\t\t\t\tWRITE_UC();\n\t\t\t\tREPLACE_UC_WITH_UC2();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to combine current code points.\n\t\t\t */\n\t\t\t/*\n\t\t\t * We have to combine Hangul characters according to\n\t\t\t * http://uniicode.org/reports/tr15/#Hangul\n\t\t\t */\n\t\t\tif (0 <= (LIndex = uc - HC_LBASE) &&\n\t\t\t    LIndex < HC_LCOUNT) {\n\t\t\t\t/*\n\t\t\t\t * Hangul Composition.\n\t\t\t\t * 1. Two current code points are L and V.\n\t\t\t\t */\n\t\t\t\tint VIndex = uc2 - HC_VBASE;\n\t\t\t\tif (0 <= VIndex && VIndex < HC_VCOUNT) {\n\t\t\t\t\t/* Make syllable of form LV. */\n\t\t\t\t\tUPDATE_UC(HC_SBASE +\n\t\t\t\t\t    (LIndex * HC_VCOUNT + VIndex) *\n\t\t\t\t\t     HC_TCOUNT);\n\t\t\t\t} else {\n\t\t\t\t\tWRITE_UC();\n\t\t\t\t\tREPLACE_UC_WITH_UC2();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (0 <= (SIndex = uc - HC_SBASE) &&\n\t\t\t    SIndex < HC_SCOUNT && (SIndex % HC_TCOUNT) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Hangul Composition.\n\t\t\t\t * 2. Two current code points are LV and T.\n\t\t\t\t */\n\t\t\t\tint TIndex = uc2 - HC_TBASE;\n\t\t\t\tif (0 < TIndex && TIndex < HC_TCOUNT) {\n\t\t\t\t\t/* Make syllable of form LVT. */\n\t\t\t\t\tUPDATE_UC(uc + TIndex);\n\t\t\t\t} else {\n\t\t\t\t\tWRITE_UC();\n\t\t\t\t\tREPLACE_UC_WITH_UC2();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if ((nfc = get_nfc(uc, uc2)) != 0) {\n\t\t\t\t/* A composition to current code points\n\t\t\t\t * is found. */\n\t\t\t\tUPDATE_UC(nfc);\n\t\t\t\tcontinue;\n\t\t\t} else if ((cl = CCC(uc2)) == 0) {\n\t\t\t\t/* Clearly 'uc2' the second code point is not\n\t\t\t\t * a decomposable code. */\n\t\t\t\tWRITE_UC();\n\t\t\t\tREPLACE_UC_WITH_UC2();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Collect following decomposable code points.\n\t\t\t */\n\t\t\tcx = 0;\n\t\t\tucx[0] = uc2;\n\t\t\tccx[0] = cl;\n\t\t\tCOLLECT_CPS(1);\n\n\t\t\t/*\n\t\t\t * Find a composed code in the collected code points.\n\t\t\t */\n\t\t\ti = 1;\n\t\t\twhile (i < ucx_size) {\n\t\t\t\tint j;\n\n\t\t\t\tif ((nfc = get_nfc(uc, ucx[i])) == 0) {\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * nfc is composed of uc and ucx[i].\n\t\t\t\t */\n\t\t\t\tUPDATE_UC(nfc);\n\n\t\t\t\t/*\n\t\t\t\t * Remove ucx[i] by shifting\n\t\t\t\t * following code points.\n\t\t\t\t */\n\t\t\t\tfor (j = i; j+1 < ucx_size; j++) {\n\t\t\t\t\tucx[j] = ucx[j+1];\n\t\t\t\t\tccx[j] = ccx[j+1];\n\t\t\t\t}\n\t\t\t\tucx_size --;\n\n\t\t\t\t/*\n\t\t\t\t * Collect following code points blocked\n\t\t\t\t * by ucx[i] the removed code point.\n\t\t\t\t */\n\t\t\t\tif (ucx_size > 0 && i == ucx_size &&\n\t\t\t\t    nx > 0 && cx == cl) {\n\t\t\t\t\tcl =  ccx[ucx_size-1];\n\t\t\t\t\tCOLLECT_CPS(ucx_size);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Restart finding a composed code with\n\t\t\t\t * the updated uc from the top of the\n\t\t\t\t * collected code points.\n\t\t\t\t */\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Apparently the current code points are not\n\t\t\t * decomposed characters or already composed.\n\t\t\t */\n\t\t\tWRITE_UC();\n\t\t\tfor (i = 0; i < ucx_size; i++)\n\t\t\t\tUNPARSE(p, endp, ucx[i]);\n\n\t\t\t/*\n\t\t\t * Flush out remaining canonical combining characters.\n\t\t\t */\n\t\t\tif (nx > 0 && cx == cl && len > 0) {\n\t\t\t\twhile ((nx = parse(&ucx[0], s, len))\n\t\t\t\t    > 0) {\n\t\t\t\t\tcx = CCC(ucx[0]);\n\t\t\t\t\tif (cl > cx)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ts += nx;\n\t\t\t\t\tlen -= nx;\n\t\t\t\t\tcl = cx;\n\t\t\t\t\tUNPARSE(p, endp, ucx[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (n2 < 0) {\n\t\t\tWRITE_UC();\n\t\t\t/* Use a replaced unicode character. */\n\t\t\tUNPARSE(p, endp, uc2);\n\t\t\ts += n2*-1;\n\t\t\tlen -= n2*-1;\n\t\t\tret = -1;\n\t\t\tcontinue;\n\t\t} else if (n2 == 0) {\n\t\t\tWRITE_UC();\n\t\t\tbreak;\n\t\t}\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\tif (ts == 2)\n\t\tas->s[as->length+1] = '\\0';\n\treturn (ret);\n}\n\nstatic int\nget_nfd(uint32_t *cp1, uint32_t *cp2, uint32_t uc)\n{\n\tint t, b;\n\n\t/*\n\t * These are not converted to NFD on Mac OS.\n\t */\n\tif ((uc >= 0x2000 && uc <= 0x2FFF) ||\n\t    (uc >= 0xF900 && uc <= 0xFAFF) ||\n\t    (uc >= 0x2F800 && uc <= 0x2FAFF))\n\t\treturn (0);\n\t/*\n\t * Those code points are not converted to NFD on Mac OS.\n\t * I do not know the reason because it is undocumented.\n\t *   NFC        NFD\n\t *   1109A  ==> 11099 110BA\n\t *   1109C  ==> 1109B 110BA\n\t *   110AB  ==> 110A5 110BA\n\t */\n\tif (uc == 0x1109A || uc == 0x1109C || uc == 0x110AB)\n\t\treturn (0);\n\n\tt = 0;\n\tb = sizeof(u_decomposition_table)/sizeof(u_decomposition_table[0]) -1;\n\twhile (b >= t) {\n\t\tint m = (t + b) / 2;\n\t\tif (u_decomposition_table[m].nfc < uc)\n\t\t\tt = m + 1;\n\t\telse if (u_decomposition_table[m].nfc > uc)\n\t\t\tb = m - 1;\n\t\telse {\n\t\t\t*cp1 = u_decomposition_table[m].cp1;\n\t\t\t*cp2 = u_decomposition_table[m].cp2;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\n#define REPLACE_UC_WITH(cp) do {\t\t\\\n\tuc = cp;\t\t\t\t\\\n\tucptr = NULL;\t\t\t\t\\\n} while (0)\n\n/*\n * Normalize UTF-8 characters to Form D and copy the result.\n */\nstatic int\narchive_string_normalize_D(struct archive_string *as, const void *_p,\n    size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s = (const char *)_p;\n\tchar *p, *endp;\n\tuint32_t uc, uc2;\n\tsize_t w;\n\tint always_replace, n, n2, ret = 0, spair, ts, tm;\n\tint (*parse)(uint32_t *, const char *, size_t);\n\tsize_t (*unparse)(char *, size_t, uint32_t);\n\n\talways_replace = 1;\n\tts = 1;/* text size. */\n\tif (sc->flag & SCONV_TO_UTF16BE) {\n\t\tunparse = unicode_to_utf16be;\n\t\tts = 2;\n\t\tif (sc->flag & SCONV_FROM_UTF16BE)\n\t\t\talways_replace = 0;\n\t} else if (sc->flag & SCONV_TO_UTF16LE) {\n\t\tunparse = unicode_to_utf16le;\n\t\tts = 2;\n\t\tif (sc->flag & SCONV_FROM_UTF16LE)\n\t\t\talways_replace = 0;\n\t} else if (sc->flag & SCONV_TO_UTF8) {\n\t\tunparse = unicode_to_utf8;\n\t\tif (sc->flag & SCONV_FROM_UTF8)\n\t\t\talways_replace = 0;\n\t} else {\n\t\t/*\n\t\t * This case is going to be converted to another\n\t\t * character-set through iconv.\n\t\t */\n\t\talways_replace = 0;\n\t\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\t\tunparse = unicode_to_utf16be;\n\t\t\tts = 2;\n\t\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\t\tunparse = unicode_to_utf16le;\n\t\t\tts = 2;\n\t\t} else {\n\t\t\tunparse = unicode_to_utf8;\n\t\t}\n\t}\n\n\tif (sc->flag & SCONV_FROM_UTF16BE) {\n\t\tparse = utf16be_to_unicode;\n\t\ttm = 1;\n\t\tspair = 4;/* surrogate pair size in UTF-16. */\n\t} else if (sc->flag & SCONV_FROM_UTF16LE) {\n\t\tparse = utf16le_to_unicode;\n\t\ttm = 1;\n\t\tspair = 4;/* surrogate pair size in UTF-16. */\n\t} else {\n\t\tparse = cesu8_to_unicode;\n\t\ttm = ts;\n\t\tspair = 6;/* surrogate pair size in UTF-8. */\n\t}\n\n\tif (archive_string_ensure(as, as->length + len * tm + ts) == NULL)\n\t\treturn (-1);\n\n\tp = as->s + as->length;\n\tendp = as->s + as->buffer_length - ts;\n\twhile ((n = parse(&uc, s, len)) != 0) {\n\t\tconst char *ucptr;\n\t\tuint32_t cp1, cp2;\n\t\tint SIndex;\n\t\tstruct {\n\t\t\tuint32_t uc;\n\t\t\tint ccc;\n\t\t} fdc[FDC_MAX];\n\t\tint fdi, fdj;\n\t\tint ccc;\n\ncheck_first_code:\n\t\tif (n < 0) {\n\t\t\t/* Use a replaced unicode character. */\n\t\t\tUNPARSE(p, endp, uc);\n\t\t\ts += n*-1;\n\t\t\tlen -= n*-1;\n\t\t\tret = -1;\n\t\t\tcontinue;\n\t\t} else if (n == spair || always_replace)\n\t\t\t/* uc is converted from a surrogate pair.\n\t\t\t * this should be treated as a changed code. */\n\t\t\tucptr = NULL;\n\t\telse\n\t\t\tucptr = s;\n\t\ts += n;\n\t\tlen -= n;\n\n\t\t/* Hangul Decomposition. */\n\t\tif ((SIndex = uc - HC_SBASE) >= 0 && SIndex < HC_SCOUNT) {\n\t\t\tint L = HC_LBASE + SIndex / HC_NCOUNT;\n\t\t\tint V = HC_VBASE + (SIndex % HC_NCOUNT) / HC_TCOUNT;\n\t\t\tint T = HC_TBASE + SIndex % HC_TCOUNT;\n\n\t\t\tREPLACE_UC_WITH(L);\n\t\t\tWRITE_UC();\n\t\t\tREPLACE_UC_WITH(V);\n\t\t\tWRITE_UC();\n\t\t\tif (T != HC_TBASE) {\n\t\t\t\tREPLACE_UC_WITH(T);\n\t\t\t\tWRITE_UC();\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_DECOMPOSABLE_BLOCK(uc) && CCC(uc) != 0) {\n\t\t\tWRITE_UC();\n\t\t\tcontinue;\n\t\t}\n\n\t\tfdi = 0;\n\t\twhile (get_nfd(&cp1, &cp2, uc) && fdi < FDC_MAX) {\n\t\t\tint k;\n\n\t\t\tfor (k = fdi; k > 0; k--)\n\t\t\t\tfdc[k] = fdc[k-1];\n\t\t\tfdc[0].ccc = CCC(cp2);\n\t\t\tfdc[0].uc = cp2;\n\t\t\tfdi++;\n\t\t\tREPLACE_UC_WITH(cp1);\n\t\t}\n\n\t\t/* Read following code points. */\n\t\twhile ((n2 = parse(&uc2, s, len)) > 0 &&\n\t\t    (ccc = CCC(uc2)) != 0 && fdi < FDC_MAX) {\n\t\t\tint j, k;\n\n\t\t\ts += n2;\n\t\t\tlen -= n2;\n\t\t\tfor (j = 0; j < fdi; j++) {\n\t\t\t\tif (fdc[j].ccc > ccc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < fdi) {\n\t\t\t\tfor (k = fdi; k > j; k--)\n\t\t\t\t\tfdc[k] = fdc[k-1];\n\t\t\t\tfdc[j].ccc = ccc;\n\t\t\t\tfdc[j].uc = uc2;\n\t\t\t} else {\n\t\t\t\tfdc[fdi].ccc = ccc;\n\t\t\t\tfdc[fdi].uc = uc2;\n\t\t\t}\n\t\t\tfdi++;\n\t\t}\n\n\t\tWRITE_UC();\n\t\tfor (fdj = 0; fdj < fdi; fdj++) {\n\t\t\tREPLACE_UC_WITH(fdc[fdj].uc);\n\t\t\tWRITE_UC();\n\t\t}\n\n\t\tif (n2 == 0)\n\t\t\tbreak;\n\t\tREPLACE_UC_WITH(uc2);\n\t\tn = n2;\n\t\tgoto check_first_code;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\tif (ts == 2)\n\t\tas->s[as->length+1] = '\\0';\n\treturn (ret);\n}\n\n/*\n * libarchive 2.x made incorrect UTF-8 strings in the wrong assumption\n * that WCS is Unicode. It is true for several platforms but some are false.\n * And then people who did not use UTF-8 locale on the non Unicode WCS\n * platform and made a tar file with libarchive(mostly bsdtar) 2.x. Those\n * now cannot get right filename from libarchive 3.x and later since we\n * fixed the wrong assumption and it is incompatible to older its versions.\n * So we provide special option, \"compat-2x.x\", for resolving it.\n * That option enable the string conversion of libarchive 2.x.\n *\n * Translates the wrong UTF-8 string made by libarchive 2.x into current\n * locale character set and appends to the archive_string.\n * Note: returns -1 if conversion fails.\n */\nstatic int\nstrncat_from_utf8_libarchive2(struct archive_string *as,\n    const void *_p, size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tint n;\n\tchar *p;\n\tchar *end;\n\tuint32_t unicode;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\t/* Clear the shift state before starting. */\n\twctomb(NULL, L'\\0');\n#endif\n\t(void)sc; /* UNUSED */\n\t/*\n\t * Allocate buffer for MBS.\n\t * We need this allocation here since it is possible that\n\t * as->s is still NULL.\n\t */\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {\n\t\twchar_t wc;\n\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\t/* Re-allocate buffer for MBS. */\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n\n\t\t/*\n\t\t * As libarchive 2.x, translates the UTF-8 characters into\n\t\t * wide-characters in the assumption that WCS is Unicode.\n\t\t */\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\twc = L'?';\n\t\t} else\n\t\t\twc = (wchar_t)unicode;\n\n\t\ts += n;\n\t\tlen -= n;\n\t\t/*\n\t\t * Translates the wide-character into the current locale MBS.\n\t\t */\n#if HAVE_WCRTOMB\n\t\tn = (int)wcrtomb(p, wc, &shift_state);\n#else\n\t\tn = (int)wctomb(p, wc);\n#endif\n\t\tif (n == -1)\n\t\t\treturn (-1);\n\t\tp += n;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (0);\n}\n\n\n/*\n * Conversion functions between current locale dependent MBS and UTF-16BE.\n *   strncat_from_utf16be() : UTF-16BE --> MBS\n *   strncat_to_utf16be()   : MBS --> UTF16BE\n */\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\n/*\n * Convert a UTF-16BE/LE string to current locale and copy the result.\n * Return -1 if conversion fails.\n */\nstatic int\nwin_strncat_from_utf16(struct archive_string *as, const void *_p, size_t bytes,\n    struct archive_string_conv *sc, int be)\n{\n\tstruct archive_string tmp;\n\tconst char *u16;\n\tint ll;\n\tBOOL defchar;\n\tchar *mbs;\n\tsize_t mbs_size, b;\n\tint ret = 0;\n\n\tbytes &= ~1;\n\tif (archive_string_ensure(as, as->length + bytes +1) == NULL)\n\t\treturn (-1);\n\n\tmbs = as->s + as->length;\n\tmbs_size = as->buffer_length - as->length -1;\n\n\tif (sc->to_cp == CP_C_LOCALE) {\n\t\t/*\n\t\t * \"C\" locale special process.\n\t\t */\n\t\tu16 = _p;\n\t\tll = 0;\n\t\tfor (b = 0; b < bytes; b += 2) {\n\t\t\tuint16_t val;\n\t\t\tif (be)\n\t\t\t\tval = archive_be16dec(u16+b);\n\t\t\telse\n\t\t\t\tval = archive_le16dec(u16+b);\n\t\t\tif (val > 255) {\n\t\t\t\t*mbs++ = '?';\n\t\t\t\tret = -1;\n\t\t\t} else\n\t\t\t\t*mbs++ = (char)(val&0xff);\n\t\t\tll++;\n\t\t}\n\t\tas->length += ll;\n\t\tas->s[as->length] = '\\0';\n\t\treturn (ret);\n\t}\n\n\tarchive_string_init(&tmp);\n\tif (be) {\n\t\tif (is_big_endian()) {\n\t\t\tu16 = _p;\n\t\t} else {\n\t\t\tif (archive_string_ensure(&tmp, bytes+2) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tmemcpy(tmp.s, _p, bytes);\n\t\t\tfor (b = 0; b < bytes; b += 2) {\n\t\t\t\tuint16_t val = archive_be16dec(tmp.s+b);\n\t\t\t\tarchive_le16enc(tmp.s+b, val);\n\t\t\t}\n\t\t\tu16 = tmp.s;\n\t\t}\n\t} else {\n\t\tif (!is_big_endian()) {\n\t\t\tu16 = _p;\n\t\t} else {\n\t\t\tif (archive_string_ensure(&tmp, bytes+2) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tmemcpy(tmp.s, _p, bytes);\n\t\t\tfor (b = 0; b < bytes; b += 2) {\n\t\t\t\tuint16_t val = archive_le16dec(tmp.s+b);\n\t\t\t\tarchive_be16enc(tmp.s+b, val);\n\t\t\t}\n\t\t\tu16 = tmp.s;\n\t\t}\n\t}\n\n\tdo {\n\t\tdefchar = 0;\n\t\tll = WideCharToMultiByte(sc->to_cp, 0,\n\t\t    (LPCWSTR)u16, (int)bytes>>1, mbs, (int)mbs_size,\n\t\t\tNULL, &defchar);\n\t\t/* Exit loop if we succeeded */\n\t\tif (ll != 0 ||\n\t\t    GetLastError() != ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Else expand buffer and loop to try again. */\n\t\tll = WideCharToMultiByte(sc->to_cp, 0,\n\t\t    (LPCWSTR)u16, (int)bytes, NULL, 0, NULL, NULL);\n\t\tif (archive_string_ensure(as, ll +1) == NULL)\n\t\t\treturn (-1);\n\t\tmbs = as->s + as->length;\n\t\tmbs_size = as->buffer_length - as->length -1;\n\t} while (1);\n\tarchive_string_free(&tmp);\n\tas->length += ll;\n\tas->s[as->length] = '\\0';\n\tif (ll == 0 || defchar)\n\t\tret = -1;\n\treturn (ret);\n}\n\nstatic int\nwin_strncat_from_utf16be(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc)\n{\n\treturn (win_strncat_from_utf16(as, _p, bytes, sc, 1));\n}\n\nstatic int\nwin_strncat_from_utf16le(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc)\n{\n\treturn (win_strncat_from_utf16(as, _p, bytes, sc, 0));\n}\n\nstatic int\nis_big_endian(void)\n{\n\tuint16_t d = 1;\n\n\treturn (archive_be16dec(&d) == 1);\n}\n\n/*\n * Convert a current locale string to UTF-16BE/LE and copy the result.\n * Return -1 if conversion fails.\n */\nstatic int\nwin_strncat_to_utf16(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc, int bigendian)\n{\n\tconst char *s = (const char *)_p;\n\tchar *u16;\n\tsize_t count, avail;\n\n\tif (archive_string_ensure(as16,\n\t    as16->length + (length + 1) * 2) == NULL)\n\t\treturn (-1);\n\n\tu16 = as16->s + as16->length;\n\tavail = as16->buffer_length - 2;\n\tif (sc->from_cp == CP_C_LOCALE) {\n\t\t/*\n\t\t * \"C\" locale special process.\n\t\t */\n\t\tcount = 0;\n\t\twhile (count < length && *s) {\n\t\t\tif (bigendian)\n\t\t\t\tarchive_be16enc(u16, *s);\n\t\t\telse\n\t\t\t\tarchive_le16enc(u16, *s);\n\t\t\tu16 += 2;\n\t\t\ts++;\n\t\t\tcount++;\n\t\t}\n\t\tas16->length += count << 1;\n\t\tas16->s[as16->length] = 0;\n\t\tas16->s[as16->length+1] = 0;\n\t\treturn (0);\n\t}\n\tdo {\n\t\tcount = MultiByteToWideChar(sc->from_cp,\n\t\t    MB_PRECOMPOSED, s, (int)length, (LPWSTR)u16, (int)avail>>1);\n\t\t/* Exit loop if we succeeded */\n\t\tif (count != 0 ||\n\t\t    GetLastError() != ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Expand buffer and try again */\n\t\tcount = MultiByteToWideChar(sc->from_cp,\n\t\t    MB_PRECOMPOSED, s, (int)length, NULL, 0);\n\t\tif (archive_string_ensure(as16, (count +1) * 2)\n\t\t    == NULL)\n\t\t\treturn (-1);\n\t\tu16 = as16->s + as16->length;\n\t\tavail = as16->buffer_length - 2;\n\t} while (1);\n\tas16->length += count * 2;\n\tas16->s[as16->length] = 0;\n\tas16->s[as16->length+1] = 0;\n\tif (count == 0)\n\t\treturn (-1);\n\n\tif (is_big_endian()) {\n\t\tif (!bigendian) {\n\t\t\twhile (count > 0) {\n\t\t\t\tuint16_t v = archive_be16dec(u16);\n\t\t\t\tarchive_le16enc(u16, v);\n\t\t\t\tu16 += 2;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (bigendian) {\n\t\t\twhile (count > 0) {\n\t\t\t\tuint16_t v = archive_le16dec(u16);\n\t\t\t\tarchive_be16enc(u16, v);\n\t\t\t\tu16 += 2;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nwin_strncat_to_utf16be(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\treturn (win_strncat_to_utf16(as16, _p, length, sc, 1));\n}\n\nstatic int\nwin_strncat_to_utf16le(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\treturn (win_strncat_to_utf16(as16, _p, length, sc, 0));\n}\n\n#endif /* _WIN32 && !__CYGWIN__ */\n\n/*\n * Do the best effort for conversions.\n * We cannot handle UTF-16BE character-set without such iconv,\n * but there is a chance if a string consists just ASCII code or\n * a current locale is UTF-8.\n */\n\n/*\n * Convert a UTF-16BE string to current locale and copy the result.\n * Return -1 if conversion fails.\n */\nstatic int\nbest_effort_strncat_from_utf16(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc, int be)\n{\n\tconst char *utf16 = (const char *)_p;\n\tchar *mbs;\n\tuint32_t uc;\n\tint n, ret;\n\n\t(void)sc; /* UNUSED */\n\t/*\n\t * Other case, we should do the best effort.\n\t * If all character are ASCII(<0x7f), we can convert it.\n\t * if not , we set a alternative character and return -1.\n\t */\n\tret = 0;\n\tif (archive_string_ensure(as, as->length + bytes +1) == NULL)\n\t\treturn (-1);\n\tmbs = as->s + as->length;\n\n\twhile ((n = utf16_to_unicode(&uc, utf16, bytes, be)) != 0) {\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\tret =  -1;\n\t\t}\n\t\tbytes -= n;\n\t\tutf16 += n;\n\n\t\tif (uc > 127) {\n\t\t\t/* We cannot handle it. */\n\t\t\t*mbs++ = '?';\n\t\t\tret =  -1;\n\t\t} else\n\t\t\t*mbs++ = (char)uc;\n\t}\n\tas->length = mbs - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret);\n}\n\nstatic int\nbest_effort_strncat_from_utf16be(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc)\n{\n\treturn (best_effort_strncat_from_utf16(as, _p, bytes, sc, 1));\n}\n\nstatic int\nbest_effort_strncat_from_utf16le(struct archive_string *as, const void *_p,\n    size_t bytes, struct archive_string_conv *sc)\n{\n\treturn (best_effort_strncat_from_utf16(as, _p, bytes, sc, 0));\n}\n\n/*\n * Convert a current locale string to UTF-16BE/LE and copy the result.\n * Return -1 if conversion fails.\n */\nstatic int\nbest_effort_strncat_to_utf16(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc, int bigendian)\n{\n\tconst char *s = (const char *)_p;\n\tchar *utf16;\n\tsize_t remaining;\n\tint ret;\n\n\t(void)sc; /* UNUSED */\n\t/*\n\t * Other case, we should do the best effort.\n\t * If all character are ASCII(<0x7f), we can convert it.\n\t * if not , we set a alternative character and return -1.\n\t */\n\tret = 0;\n\tremaining = length;\n\n\tif (archive_string_ensure(as16,\n\t    as16->length + (length + 1) * 2) == NULL)\n\t\treturn (-1);\n\n\tutf16 = as16->s + as16->length;\n\twhile (remaining--) {\n\t\tunsigned c = *s++;\n\t\tif (c > 127) {\n\t\t\t/* We cannot handle it. */\n\t\t\tc = UNICODE_R_CHAR;\n\t\t\tret = -1;\n\t\t}\n\t\tif (bigendian)\n\t\t\tarchive_be16enc(utf16, c);\n\t\telse\n\t\t\tarchive_le16enc(utf16, c);\n\t\tutf16 += 2;\n\t}\n\tas16->length = utf16 - as16->s;\n\tas16->s[as16->length] = 0;\n\tas16->s[as16->length+1] = 0;\n\treturn (ret);\n}\n\nstatic int\nbest_effort_strncat_to_utf16be(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\treturn (best_effort_strncat_to_utf16(as16, _p, length, sc, 1));\n}\n\nstatic int\nbest_effort_strncat_to_utf16le(struct archive_string *as16, const void *_p,\n    size_t length, struct archive_string_conv *sc)\n{\n\treturn (best_effort_strncat_to_utf16(as16, _p, length, sc, 0));\n}\n\n\n/*\n * Multistring operations.\n */\n\nvoid\narchive_mstring_clean(struct archive_mstring *aes)\n{\n\tarchive_wstring_free(&(aes->aes_wcs));\n\tarchive_string_free(&(aes->aes_mbs));\n\tarchive_string_free(&(aes->aes_utf8));\n\tarchive_string_free(&(aes->aes_mbs_in_locale));\n\taes->aes_set = 0;\n}\n\nvoid\narchive_mstring_copy(struct archive_mstring *dest, struct archive_mstring *src)\n{\n\tdest->aes_set = src->aes_set;\n\tarchive_string_copy(&(dest->aes_mbs), &(src->aes_mbs));\n\tarchive_string_copy(&(dest->aes_utf8), &(src->aes_utf8));\n\tarchive_wstring_copy(&(dest->aes_wcs), &(src->aes_wcs));\n}\n\nint\narchive_mstring_get_utf8(struct archive *a, struct archive_mstring *aes,\n  const char **p)\n{\n\tstruct archive_string_conv *sc;\n\tint r;\n\n\t/* If we already have a UTF8 form, return that immediately. */\n\tif (aes->aes_set & AES_SET_UTF8) {\n\t\t*p = aes->aes_utf8.s;\n\t\treturn (0);\n\t}\n\n\t*p = NULL;\n\tif (aes->aes_set & AES_SET_MBS) {\n\t\tsc = archive_string_conversion_to_charset(a, \"UTF-8\", 1);\n\t\tif (sc == NULL)\n\t\t\treturn (-1);/* Couldn't allocate memory for sc. */\n\t\tr = archive_strncpy_l(&(aes->aes_utf8), aes->aes_mbs.s,\n\t\t    aes->aes_mbs.length, sc);\n\t\tif (a == NULL)\n\t\t\tfree_sconv_object(sc);\n\t\tif (r == 0) {\n\t\t\taes->aes_set |= AES_SET_UTF8;\n\t\t\t*p = aes->aes_utf8.s;\n\t\t\treturn (0);/* success. */\n\t\t} else\n\t\t\treturn (-1);/* failure. */\n\t}\n\treturn (0);/* success. */\n}\n\nint\narchive_mstring_get_mbs(struct archive *a, struct archive_mstring *aes,\n    const char **p)\n{\n\tint r, ret = 0;\n\n\t(void)a; /* UNUSED */\n\t/* If we already have an MBS form, return that immediately. */\n\tif (aes->aes_set & AES_SET_MBS) {\n\t\t*p = aes->aes_mbs.s;\n\t\treturn (ret);\n\t}\n\n\t*p = NULL;\n\t/* If there's a WCS form, try converting with the native locale. */\n\tif (aes->aes_set & AES_SET_WCS) {\n\t\tarchive_string_empty(&(aes->aes_mbs));\n\t\tr = archive_string_append_from_wcs(&(aes->aes_mbs),\n\t\t    aes->aes_wcs.s, aes->aes_wcs.length);\n\t\t*p = aes->aes_mbs.s;\n\t\tif (r == 0) {\n\t\t\taes->aes_set |= AES_SET_MBS;\n\t\t\treturn (ret);\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\t/*\n\t * Only a UTF-8 form cannot avail because its conversion already\n\t * failed at archive_mstring_update_utf8().\n\t */\n\treturn (ret);\n}\n\nint\narchive_mstring_get_wcs(struct archive *a, struct archive_mstring *aes,\n    const wchar_t **wp)\n{\n\tint r, ret = 0;\n\n\t(void)a;/* UNUSED */\n\t/* Return WCS form if we already have it. */\n\tif (aes->aes_set & AES_SET_WCS) {\n\t\t*wp = aes->aes_wcs.s;\n\t\treturn (ret);\n\t}\n\n\t*wp = NULL;\n\t/* Try converting MBS to WCS using native locale. */\n\tif (aes->aes_set & AES_SET_MBS) {\n\t\tarchive_wstring_empty(&(aes->aes_wcs));\n\t\tr = archive_wstring_append_from_mbs(&(aes->aes_wcs),\n\t\t    aes->aes_mbs.s, aes->aes_mbs.length);\n\t\tif (r == 0) {\n\t\t\taes->aes_set |= AES_SET_WCS;\n\t\t\t*wp = aes->aes_wcs.s;\n\t\t} else\n\t\t\tret = -1;/* failure. */\n\t}\n\treturn (ret);\n}\n\nint\narchive_mstring_get_mbs_l(struct archive_mstring *aes,\n    const char **p, size_t *length, struct archive_string_conv *sc)\n{\n\tint r, ret = 0;\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/*\n\t * Internationalization programming on Windows must use Wide\n\t * characters because Windows platform cannot make locale UTF-8.\n\t */\n\tif (sc != NULL && (aes->aes_set & AES_SET_WCS) != 0) {\n\t\tarchive_string_empty(&(aes->aes_mbs_in_locale));\n\t\tr = archive_string_append_from_wcs_in_codepage(\n\t\t    &(aes->aes_mbs_in_locale), aes->aes_wcs.s,\n\t\t    aes->aes_wcs.length, sc);\n\t\tif (r == 0) {\n\t\t\t*p = aes->aes_mbs_in_locale.s;\n\t\t\tif (length != NULL)\n\t\t\t\t*length = aes->aes_mbs_in_locale.length;\n\t\t\treturn (0);\n\t\t} else if (errno == ENOMEM)\n\t\t\treturn (-1);\n\t\telse\n\t\t\tret = -1;\n\t}\n#endif\n\n\t/* If there is not an MBS form but is a WCS form, try converting\n\t * with the native locale to be used for translating it to specified\n\t * character-set. */\n\tif ((aes->aes_set & AES_SET_MBS) == 0 &&\n\t    (aes->aes_set & AES_SET_WCS) != 0) {\n\t\tarchive_string_empty(&(aes->aes_mbs));\n\t\tr = archive_string_append_from_wcs(&(aes->aes_mbs),\n\t\t    aes->aes_wcs.s, aes->aes_wcs.length);\n\t\tif (r == 0)\n\t\t\taes->aes_set |= AES_SET_MBS;\n\t\telse if (errno == ENOMEM)\n\t\t\treturn (-1);\n\t\telse\n\t\t\tret = -1;\n\t}\n\t/* If we already have an MBS form, use it to be translated to\n\t * specified character-set. */\n\tif (aes->aes_set & AES_SET_MBS) {\n\t\tif (sc == NULL) {\n\t\t\t/* Conversion is unneeded. */\n\t\t\t*p = aes->aes_mbs.s;\n\t\t\tif (length != NULL)\n\t\t\t\t*length = aes->aes_mbs.length;\n\t\t\treturn (0);\n\t\t}\n\t\tret = archive_strncpy_l(&(aes->aes_mbs_in_locale),\n\t\t    aes->aes_mbs.s, aes->aes_mbs.length, sc);\n\t\t*p = aes->aes_mbs_in_locale.s;\n\t\tif (length != NULL)\n\t\t\t*length = aes->aes_mbs_in_locale.length;\n\t} else {\n\t\t*p = NULL;\n\t\tif (length != NULL)\n\t\t\t*length = 0;\n\t}\n\treturn (ret);\n}\n\nint\narchive_mstring_copy_mbs(struct archive_mstring *aes, const char *mbs)\n{\n\tif (mbs == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0);\n\t}\n\treturn (archive_mstring_copy_mbs_len(aes, mbs, strlen(mbs)));\n}\n\nint\narchive_mstring_copy_mbs_len(struct archive_mstring *aes, const char *mbs,\n    size_t len)\n{\n\tif (mbs == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0);\n\t}\n\taes->aes_set = AES_SET_MBS; /* Only MBS form is set now. */\n\tarchive_strncpy(&(aes->aes_mbs), mbs, len);\n\tarchive_string_empty(&(aes->aes_utf8));\n\tarchive_wstring_empty(&(aes->aes_wcs));\n\treturn (0);\n}\n\nint\narchive_mstring_copy_wcs(struct archive_mstring *aes, const wchar_t *wcs)\n{\n\treturn archive_mstring_copy_wcs_len(aes, wcs,\n\t\t\t\twcs == NULL ? 0 : wcslen(wcs));\n}\n\nint\narchive_mstring_copy_utf8(struct archive_mstring *aes, const char *utf8)\n{\n  if (utf8 == NULL) {\n    aes->aes_set = 0;\n    return (0);\n  }\n  aes->aes_set = AES_SET_UTF8;\n  archive_string_empty(&(aes->aes_mbs));\n  archive_string_empty(&(aes->aes_wcs));\n  archive_strncpy(&(aes->aes_utf8), utf8, strlen(utf8));\n  return (int)strlen(utf8);\n}\n\nint\narchive_mstring_copy_wcs_len(struct archive_mstring *aes, const wchar_t *wcs,\n    size_t len)\n{\n\tif (wcs == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0);\n\t}\n\taes->aes_set = AES_SET_WCS; /* Only WCS form set. */\n\tarchive_string_empty(&(aes->aes_mbs));\n\tarchive_string_empty(&(aes->aes_utf8));\n\tarchive_wstrncpy(&(aes->aes_wcs), wcs, len);\n\treturn (0);\n}\n\nint\narchive_mstring_copy_mbs_len_l(struct archive_mstring *aes,\n    const char *mbs, size_t len, struct archive_string_conv *sc)\n{\n\tint r;\n\n\tif (mbs == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0);\n\t}\n\tarchive_string_empty(&(aes->aes_mbs));\n\tarchive_wstring_empty(&(aes->aes_wcs));\n\tarchive_string_empty(&(aes->aes_utf8));\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/*\n\t * Internationalization programming on Windows must use Wide\n\t * characters because Windows platform cannot make locale UTF-8.\n\t */\n\tif (sc == NULL) {\n\t\tif (archive_string_append(&(aes->aes_mbs),\n\t\t\tmbs, mbsnbytes(mbs, len)) == NULL) {\n\t\t\taes->aes_set = 0;\n\t\t\tr = -1;\n\t\t} else {\n\t\t\taes->aes_set = AES_SET_MBS;\n\t\t\tr = 0;\n\t\t}\n#if defined(HAVE_ICONV)\n\t} else if (sc != NULL && sc->cd_w != (iconv_t)-1) {\n\t\t/*\n\t\t * This case happens only when MultiByteToWideChar() cannot\n\t\t * handle sc->from_cp, and we have to iconv in order to\n\t\t * translate character-set to wchar_t,UTF-16.\n\t\t */\n\t\ticonv_t cd = sc->cd;\n\t\tunsigned from_cp;\n\t\tint flag;\n\n\t\t/*\n\t\t * Translate multi-bytes from some character-set to UTF-8.\n\t\t */ \n\t\tsc->cd = sc->cd_w;\n\t\tr = archive_strncpy_l(&(aes->aes_utf8), mbs, len, sc);\n\t\tsc->cd = cd;\n\t\tif (r != 0) {\n\t\t\taes->aes_set = 0;\n\t\t\treturn (r);\n\t\t}\n\t\taes->aes_set = AES_SET_UTF8;\n\n\t\t/*\n\t\t * Append the UTF-8 string into wstring.\n\t\t */ \n\t\tflag = sc->flag;\n\t\tsc->flag &= ~(SCONV_NORMALIZATION_C\n\t\t\t\t| SCONV_TO_UTF16| SCONV_FROM_UTF16);\n\t\tfrom_cp = sc->from_cp;\n\t\tsc->from_cp = CP_UTF8;\n\t\tr = archive_wstring_append_from_mbs_in_codepage(&(aes->aes_wcs),\n\t\t\taes->aes_utf8.s, aes->aes_utf8.length, sc);\n\t\tsc->flag = flag;\n\t\tsc->from_cp = from_cp;\n\t\tif (r == 0)\n\t\t\taes->aes_set |= AES_SET_WCS;\n#endif\n\t} else {\n\t\tr = archive_wstring_append_from_mbs_in_codepage(\n\t\t    &(aes->aes_wcs), mbs, len, sc);\n\t\tif (r == 0)\n\t\t\taes->aes_set = AES_SET_WCS;\n\t\telse\n\t\t\taes->aes_set = 0;\n\t}\n#else\n\tr = archive_strncpy_l(&(aes->aes_mbs), mbs, len, sc);\n\tif (r == 0)\n\t\taes->aes_set = AES_SET_MBS; /* Only MBS form is set now. */\n\telse\n\t\taes->aes_set = 0;\n#endif\n\treturn (r);\n}\n\n/*\n * The 'update' form tries to proactively update all forms of\n * this string (WCS and MBS) and returns an error if any of\n * them fail.  This is used by the 'pax' handler, for instance,\n * to detect and report character-conversion failures early while\n * still allowing clients to get potentially useful values from\n * the more tolerant lazy conversions.  (get_mbs and get_wcs will\n * strive to give the user something useful, so you can get hopefully\n * usable values even if some of the character conversions are failing.)\n */\nint\narchive_mstring_update_utf8(struct archive *a, struct archive_mstring *aes,\n    const char *utf8)\n{\n\tstruct archive_string_conv *sc;\n\tint r;\n\n\tif (utf8 == NULL) {\n\t\taes->aes_set = 0;\n\t\treturn (0); /* Succeeded in clearing everything. */\n\t}\n\n\t/* Save the UTF8 string. */\n\tarchive_strcpy(&(aes->aes_utf8), utf8);\n\n\t/* Empty the mbs and wcs strings. */\n\tarchive_string_empty(&(aes->aes_mbs));\n\tarchive_wstring_empty(&(aes->aes_wcs));\n\n\taes->aes_set = AES_SET_UTF8;\t/* Only UTF8 is set now. */\n\n\t/* Try converting UTF-8 to MBS, return false on failure. */\n\tsc = archive_string_conversion_from_charset(a, \"UTF-8\", 1);\n\tif (sc == NULL)\n\t\treturn (-1);/* Couldn't allocate memory for sc. */\n\tr = archive_strcpy_l(&(aes->aes_mbs), utf8, sc);\n\tif (a == NULL)\n\t\tfree_sconv_object(sc);\n\tif (r != 0)\n\t\treturn (-1);\n\taes->aes_set = AES_SET_UTF8 | AES_SET_MBS; /* Both UTF8 and MBS set. */\n\n\t/* Try converting MBS to WCS, return false on failure. */\n\tif (archive_wstring_append_from_mbs(&(aes->aes_wcs), aes->aes_mbs.s,\n\t    aes->aes_mbs.length))\n\t\treturn (-1);\n\taes->aes_set = AES_SET_UTF8 | AES_SET_WCS | AES_SET_MBS;\n\n\t/* All conversions succeeded. */\n\treturn (0);\n}\n"], "filenames": ["libarchive/archive_string.c"], "buggy_code_start_loc": [594], "buggy_code_end_loc": [639], "fixing_code_start_loc": [594], "fixing_code_end_loc": [645], "type": "CWE-125", "message": "In Libarchive 3.4.0, archive_wstring_append_from_mbs in archive_string.c has an out-of-bounds read because of an incorrect mbrtowc or mbtowc call. For example, bsdtar crashes via a crafted archive.", "other": {"cve": {"id": "CVE-2019-19221", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-21T23:15:13.887", "lastModified": "2022-12-03T14:24:54.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Libarchive 3.4.0, archive_wstring_append_from_mbs in archive_string.c has an out-of-bounds read because of an incorrect mbrtowc or mbtowc call. For example, bsdtar crashes via a crafted archive."}, {"lang": "es", "value": "En Libarchive versi\u00f3n 3.4.0, la funci\u00f3n archive_wstring_append_from_mbs en el archivo archive_string.c presenta una lectura fuera de l\u00edmites debido a una llamada mbrtowc o mbtowc incorrecta. Por ejemplo, bsdtar se bloquea por medio de un archivo dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:3.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "89750E2E-3206-45C0-B882-EF74E66D45C4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "https://github.com/libarchive/libarchive/commit/22b1db9d46654afc6f0c28f90af8cdc84a199f41", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/issues/1276", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/04/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00030.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RHFV25AVTASTWZRF3KTSL357AQ6TYHM4/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4293-1/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/22b1db9d46654afc6f0c28f90af8cdc84a199f41"}}