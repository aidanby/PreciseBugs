{"buggy_code": ["/*\n * @Author: LinkLeong link@icewhale.com\n * @Date: 2022-07-26 11:08:48\n * @LastEditors: LinkLeong\n * @LastEditTime: 2022-08-17 18:25:42\n * @FilePath: /CasaOS/route/v1/samba.go\n * @Description:\n * @Website: https://www.casaos.io\n * Copyright (c) 2022 by icewhale, All Rights Reserved.\n */\npackage v1\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/systemctl\"\n\t\"go.uber.org/zap\"\n\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/samba\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/file\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\"\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\tmodel2 \"github.com/IceWhaleTech/CasaOS/service/model\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// service\n\nfunc GetSambaStatus(c *gin.Context) {\n\tif status, err := systemctl.IsServiceRunning(\"smbd\"); err != nil || !status {\n\t\tc.JSON(http.StatusInternalServerError, model.Result{\n\t\t\tSuccess: common_err.SERVICE_NOT_RUNNING,\n\t\t\tMessage: common_err.GetMsg(common_err.SERVICE_NOT_RUNNING),\n\t\t})\n\t\treturn\n\t}\n\n\tneedInit := true\n\tif file.Exists(\"/etc/samba/smb.conf\") {\n\t\tstr := file.ReadLine(1, \"/etc/samba/smb.conf\")\n\t\tif strings.Contains(str, \"# Copyright (c) 2021-2022 CasaOS Inc. All rights reserved.\") {\n\t\t\tneedInit = false\n\t\t}\n\t}\n\tdata := make(map[string]string, 1)\n\tdata[\"need_init\"] = fmt.Sprintf(\"%v\", needInit)\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: data})\n}\n\nfunc GetSambaSharesList(c *gin.Context) {\n\tshares := service.MyService.Shares().GetSharesList()\n\tshareList := []model.Shares{}\n\tfor _, v := range shares {\n\t\tshareList = append(shareList, model.Shares{\n\t\t\tAnonymous: v.Anonymous,\n\t\t\tPath:      v.Path,\n\t\t\tID:        v.ID,\n\t\t})\n\t}\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: shareList})\n}\n\nfunc PostSambaSharesCreate(c *gin.Context) {\n\tshares := []model.Shares{}\n\tc.ShouldBindJSON(&shares)\n\tfor _, v := range shares {\n\t\tif v.Path == \"\" {\n\t\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INSUFFICIENT_PERMISSIONS, Message: common_err.GetMsg(common_err.INSUFFICIENT_PERMISSIONS)})\n\t\t\treturn\n\t\t}\n\t\tif !file.Exists(v.Path) {\n\t\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.DIR_NOT_EXISTS, Message: common_err.GetMsg(common_err.DIR_NOT_EXISTS)})\n\t\t\treturn\n\t\t}\n\t\tif len(service.MyService.Shares().GetSharesByPath(v.Path)) > 0 {\n\t\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.SHARE_ALREADY_EXISTS, Message: common_err.GetMsg(common_err.SHARE_ALREADY_EXISTS)})\n\t\t\treturn\n\t\t}\n\t\tif len(service.MyService.Shares().GetSharesByPath(filepath.Base(v.Path))) > 0 {\n\t\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.SHARE_NAME_ALREADY_EXISTS, Message: common_err.GetMsg(common_err.SHARE_NAME_ALREADY_EXISTS)})\n\t\t\treturn\n\t\t}\n\t}\n\tfor _, v := range shares {\n\t\tshareDBModel := model2.SharesDBModel{}\n\t\tshareDBModel.Anonymous = true\n\t\tshareDBModel.Path = v.Path\n\t\tshareDBModel.Name = filepath.Base(v.Path)\n\t\tos.Chmod(v.Path, 0o777)\n\t\tservice.MyService.Shares().CreateShare(shareDBModel)\n\t}\n\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: shares})\n}\n\nfunc DeleteSambaShares(c *gin.Context) {\n\tid := c.Param(\"id\")\n\tif id == \"\" {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INSUFFICIENT_PERMISSIONS, Message: common_err.GetMsg(common_err.INSUFFICIENT_PERMISSIONS)})\n\t\treturn\n\t}\n\tservice.MyService.Shares().DeleteShare(id)\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: id})\n}\n\n// client\nfunc GetSambaConnectionsList(c *gin.Context) {\n\tconnections := service.MyService.Connections().GetConnectionsList()\n\tconnectionList := []model.Connections{}\n\tfor _, v := range connections {\n\t\tconnectionList = append(connectionList, model.Connections{\n\t\t\tID:         v.ID,\n\t\t\tUsername:   v.Username,\n\t\t\tPort:       v.Port,\n\t\t\tHost:       v.Host,\n\t\t\tMountPoint: v.MountPoint,\n\t\t})\n\t}\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: connectionList})\n}\n\nfunc PostSambaConnectionsCreate(c *gin.Context) {\n\tconnection := model.Connections{}\n\tc.ShouldBindJSON(&connection)\n\tif connection.Port == \"\" {\n\t\tconnection.Port = \"445\"\n\t}\n\tif connection.Username == \"\" || connection.Host == \"\" {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.CHARACTER_LIMIT, Message: common_err.GetMsg(common_err.CHARACTER_LIMIT)})\n\t\treturn\n\t}\n\n\tif ok, _ := regexp.MatchString(`^[\\w@#*.]{4,30}$`, connection.Password); !ok {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.CHARACTER_LIMIT, Message: common_err.GetMsg(common_err.CHARACTER_LIMIT)})\n\t\treturn\n\t}\n\tif ok, _ := regexp.MatchString(`^[\\w@#*.]{4,30}$`, connection.Username); !ok {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INVALID_PARAMS, Message: common_err.GetMsg(common_err.INVALID_PARAMS)})\n\t\treturn\n\t}\n\tif !ip_helper.IsIPv4(connection.Host) && !ip_helper.IsIPv6(connection.Host) {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INVALID_PARAMS, Message: common_err.GetMsg(common_err.INVALID_PARAMS)})\n\t\treturn\n\t}\n\tif ok, _ := regexp.MatchString(\"^[0-9]{1,6}$\", connection.Port); !ok {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INVALID_PARAMS, Message: common_err.GetMsg(common_err.INVALID_PARAMS)})\n\t\treturn\n\t}\n\n\tconnection.Host = strings.Split(connection.Host, \"/\")[0]\n\t// check is exists\n\tconnections := service.MyService.Connections().GetConnectionByHost(connection.Host)\n\tif len(connections) > 0 {\n\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.Record_ALREADY_EXIST, Message: common_err.GetMsg(common_err.Record_ALREADY_EXIST), Data: common_err.GetMsg(common_err.Record_ALREADY_EXIST)})\n\t\treturn\n\t}\n\t// check connect is ok\n\tdirectories, err := samba.GetSambaSharesList(connection.Host, connection.Port, connection.Username, connection.Password)\n\tif err != nil {\n\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\n\tconnectionDBModel := model2.ConnectionsDBModel{}\n\tconnectionDBModel.Username = connection.Username\n\tconnectionDBModel.Password = connection.Password\n\tconnectionDBModel.Host = connection.Host\n\tconnectionDBModel.Port = connection.Port\n\tconnectionDBModel.Directories = strings.Join(directories, \",\")\n\tbaseHostPath := \"/mnt/\" + connection.Host\n\tconnectionDBModel.MountPoint = baseHostPath\n\tconnection.MountPoint = baseHostPath\n\tfile.IsNotExistMkDir(baseHostPath)\n\tfor _, v := range directories {\n\t\tmountPoint := baseHostPath + \"/\" + v\n\t\tfile.IsNotExistMkDir(mountPoint)\n\t\tservice.MyService.Connections().MountSmaba(connectionDBModel.Username, connectionDBModel.Host, v, connectionDBModel.Port, mountPoint, connectionDBModel.Password)\n\t}\n\n\tservice.MyService.Connections().CreateConnection(&connectionDBModel)\n\n\tconnection.ID = connectionDBModel.ID\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: connection})\n}\n\nfunc DeleteSambaConnections(c *gin.Context) {\n\tid := c.Param(\"id\")\n\tconnection := service.MyService.Connections().GetConnectionByID(id)\n\tif connection.Username == \"\" {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.Record_NOT_EXIST, Message: common_err.GetMsg(common_err.Record_NOT_EXIST)})\n\t\treturn\n\t}\n\tmountPointList, err := samba.GetSambaSharesList(connection.Host, connection.Port, connection.Username, connection.Password)\n\t//mountPointList, err := service.MyService.System().GetDirPath(connection.MountPoint)\n\tif err != nil {\n\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\tbaseHostPath := \"/mnt/\" + connection.Host\n\tfor _, v := range mountPointList {\n\t\tif service.IsMounted(baseHostPath + \"/\" + v) {\n\t\t\terr := service.MyService.Connections().UnmountSmaba(baseHostPath + \"/\" + v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"unmount smaba error\", zap.Error(err), zap.Any(\"path\", baseHostPath+\"/\"+v))\n\t\t\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t}\n\tdir, _ := ioutil.ReadDir(connection.MountPoint)\n\tif len(dir) == 0 {\n\t\tos.RemoveAll(connection.MountPoint)\n\t}\n\tservice.MyService.Connections().DeleteConnection(id)\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: id})\n}\n", "/*\n * @Author: LinkLeong link@icewhale.org\n * @Date: 2022-07-26 18:13:22\n * @LastEditors: LinkLeong\n * @LastEditTime: 2022-08-04 20:10:31\n * @FilePath: /CasaOS/service/connections.go\n * @Description:\n * @Website: https://www.casaos.io\n * Copyright (c) 2022 by icewhale, All Rights Reserved.\n */\npackage service\n\nimport (\n\t\"github.com/IceWhaleTech/CasaOS/pkg/config\"\n\tcommand2 \"github.com/IceWhaleTech/CasaOS/pkg/utils/command\"\n\t\"github.com/IceWhaleTech/CasaOS/service/model\"\n\tmodel2 \"github.com/IceWhaleTech/CasaOS/service/model\"\n\t\"github.com/moby/sys/mount\"\n\t\"gorm.io/gorm\"\n)\n\ntype ConnectionsService interface {\n\tGetConnectionsList() (connections []model2.ConnectionsDBModel)\n\tGetConnectionByHost(host string) (connections []model2.ConnectionsDBModel)\n\tGetConnectionByID(id string) (connections model2.ConnectionsDBModel)\n\tCreateConnection(connection *model2.ConnectionsDBModel)\n\tDeleteConnection(id string)\n\tUpdateConnection(connection *model2.ConnectionsDBModel)\n\tMountSmaba(username, host, directory, port, mountPoint, password string) string\n\tUnmountSmaba(mountPoint string) error\n}\n\ntype connectionsStruct struct {\n\tdb *gorm.DB\n}\n\nfunc (s *connectionsStruct) GetConnectionByHost(host string) (connections []model2.ConnectionsDBModel) {\n\ts.db.Select(\"username,host,status,id\").Where(\"host = ?\", host).Find(&connections)\n\treturn\n}\nfunc (s *connectionsStruct) GetConnectionByID(id string) (connections model2.ConnectionsDBModel) {\n\ts.db.Select(\"username,password,host,status,id,directories,mount_point,port\").Where(\"id = ?\", id).First(&connections)\n\treturn\n}\nfunc (s *connectionsStruct) GetConnectionsList() (connections []model2.ConnectionsDBModel) {\n\ts.db.Select(\"username,host,port,status,id,mount_point\").Find(&connections)\n\treturn\n}\nfunc (s *connectionsStruct) CreateConnection(connection *model2.ConnectionsDBModel) {\n\ts.db.Create(connection)\n}\nfunc (s *connectionsStruct) UpdateConnection(connection *model2.ConnectionsDBModel) {\n\ts.db.Save(connection)\n}\nfunc (s *connectionsStruct) DeleteConnection(id string) {\n\ts.db.Where(\"id= ?\", id).Delete(&model.ConnectionsDBModel{})\n}\n\nfunc (s *connectionsStruct) MountSmaba(username, host, directory, port, mountPoint, password string) string {\n\tstr := command2.ExecResultStr(\"source \" + config.AppInfo.ShellPath + \"/helper.sh ;MountCIFS \" + username + \" \" + host + \" \" + directory + \" \" + port + \" \" + mountPoint + \" \" + password)\n\treturn str\n}\nfunc (s *connectionsStruct) UnmountSmaba(mountPoint string) error {\n\treturn mount.Unmount(mountPoint)\n}\n\nfunc NewConnectionsService(db *gorm.DB) ConnectionsService {\n\treturn &connectionsStruct{db: db}\n}\n"], "fixing_code": ["/*\n * @Author: LinkLeong link@icewhale.com\n * @Date: 2022-07-26 11:08:48\n * @LastEditors: LinkLeong\n * @LastEditTime: 2022-08-17 18:25:42\n * @FilePath: /CasaOS/route/v1/samba.go\n * @Description:\n * @Website: https://www.casaos.io\n * Copyright (c) 2022 by icewhale, All Rights Reserved.\n */\npackage v1\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/systemctl\"\n\t\"go.uber.org/zap\"\n\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/samba\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/file\"\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\tmodel2 \"github.com/IceWhaleTech/CasaOS/service/model\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// service\n\nfunc GetSambaStatus(c *gin.Context) {\n\tif status, err := systemctl.IsServiceRunning(\"smbd\"); err != nil || !status {\n\t\tc.JSON(http.StatusInternalServerError, model.Result{\n\t\t\tSuccess: common_err.SERVICE_NOT_RUNNING,\n\t\t\tMessage: common_err.GetMsg(common_err.SERVICE_NOT_RUNNING),\n\t\t})\n\t\treturn\n\t}\n\n\tneedInit := true\n\tif file.Exists(\"/etc/samba/smb.conf\") {\n\t\tstr := file.ReadLine(1, \"/etc/samba/smb.conf\")\n\t\tif strings.Contains(str, \"# Copyright (c) 2021-2022 CasaOS Inc. All rights reserved.\") {\n\t\t\tneedInit = false\n\t\t}\n\t}\n\tdata := make(map[string]string, 1)\n\tdata[\"need_init\"] = fmt.Sprintf(\"%v\", needInit)\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: data})\n}\n\nfunc GetSambaSharesList(c *gin.Context) {\n\tshares := service.MyService.Shares().GetSharesList()\n\tshareList := []model.Shares{}\n\tfor _, v := range shares {\n\t\tshareList = append(shareList, model.Shares{\n\t\t\tAnonymous: v.Anonymous,\n\t\t\tPath:      v.Path,\n\t\t\tID:        v.ID,\n\t\t})\n\t}\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: shareList})\n}\n\nfunc PostSambaSharesCreate(c *gin.Context) {\n\tshares := []model.Shares{}\n\tc.ShouldBindJSON(&shares)\n\tfor _, v := range shares {\n\t\tif v.Path == \"\" {\n\t\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INSUFFICIENT_PERMISSIONS, Message: common_err.GetMsg(common_err.INSUFFICIENT_PERMISSIONS)})\n\t\t\treturn\n\t\t}\n\t\tif !file.Exists(v.Path) {\n\t\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.DIR_NOT_EXISTS, Message: common_err.GetMsg(common_err.DIR_NOT_EXISTS)})\n\t\t\treturn\n\t\t}\n\t\tif len(service.MyService.Shares().GetSharesByPath(v.Path)) > 0 {\n\t\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.SHARE_ALREADY_EXISTS, Message: common_err.GetMsg(common_err.SHARE_ALREADY_EXISTS)})\n\t\t\treturn\n\t\t}\n\t\tif len(service.MyService.Shares().GetSharesByPath(filepath.Base(v.Path))) > 0 {\n\t\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.SHARE_NAME_ALREADY_EXISTS, Message: common_err.GetMsg(common_err.SHARE_NAME_ALREADY_EXISTS)})\n\t\t\treturn\n\t\t}\n\t}\n\tfor _, v := range shares {\n\t\tshareDBModel := model2.SharesDBModel{}\n\t\tshareDBModel.Anonymous = true\n\t\tshareDBModel.Path = v.Path\n\t\tshareDBModel.Name = filepath.Base(v.Path)\n\t\tos.Chmod(v.Path, 0o777)\n\t\tservice.MyService.Shares().CreateShare(shareDBModel)\n\t}\n\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: shares})\n}\n\nfunc DeleteSambaShares(c *gin.Context) {\n\tid := c.Param(\"id\")\n\tif id == \"\" {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INSUFFICIENT_PERMISSIONS, Message: common_err.GetMsg(common_err.INSUFFICIENT_PERMISSIONS)})\n\t\treturn\n\t}\n\tservice.MyService.Shares().DeleteShare(id)\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: id})\n}\n\n// client\nfunc GetSambaConnectionsList(c *gin.Context) {\n\tconnections := service.MyService.Connections().GetConnectionsList()\n\tconnectionList := []model.Connections{}\n\tfor _, v := range connections {\n\t\tconnectionList = append(connectionList, model.Connections{\n\t\t\tID:         v.ID,\n\t\t\tUsername:   v.Username,\n\t\t\tPort:       v.Port,\n\t\t\tHost:       v.Host,\n\t\t\tMountPoint: v.MountPoint,\n\t\t})\n\t}\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: connectionList})\n}\n\nfunc PostSambaConnectionsCreate(c *gin.Context) {\n\tconnection := model.Connections{}\n\tc.ShouldBindJSON(&connection)\n\tif connection.Port == \"\" {\n\t\tconnection.Port = \"445\"\n\t}\n\tif connection.Username == \"\" || connection.Host == \"\" {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.CHARACTER_LIMIT, Message: common_err.GetMsg(common_err.CHARACTER_LIMIT)})\n\t\treturn\n\t}\n\n\t// if ok, _ := regexp.MatchString(`^[\\w@#*.]{4,30}$`, connection.Password); !ok {\n\t// \tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.CHARACTER_LIMIT, Message: common_err.GetMsg(common_err.CHARACTER_LIMIT)})\n\t// \treturn\n\t// }\n\t// if ok, _ := regexp.MatchString(`^[\\w@#*.]{4,30}$`, connection.Username); !ok {\n\t// \tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INVALID_PARAMS, Message: common_err.GetMsg(common_err.INVALID_PARAMS)})\n\t// \treturn\n\t// }\n\t// if !ip_helper.IsIPv4(connection.Host) && !ip_helper.IsIPv6(connection.Host) {\n\t// \tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INVALID_PARAMS, Message: common_err.GetMsg(common_err.INVALID_PARAMS)})\n\t// \treturn\n\t// }\n\t// if ok, _ := regexp.MatchString(\"^[0-9]{1,6}$\", connection.Port); !ok {\n\t// \tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.INVALID_PARAMS, Message: common_err.GetMsg(common_err.INVALID_PARAMS)})\n\t// \treturn\n\t// }\n\n\tconnection.Host = strings.Split(connection.Host, \"/\")[0]\n\t// check is exists\n\tconnections := service.MyService.Connections().GetConnectionByHost(connection.Host)\n\tif len(connections) > 0 {\n\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.Record_ALREADY_EXIST, Message: common_err.GetMsg(common_err.Record_ALREADY_EXIST), Data: common_err.GetMsg(common_err.Record_ALREADY_EXIST)})\n\t\treturn\n\t}\n\t// check connect is ok\n\tdirectories, err := samba.GetSambaSharesList(connection.Host, connection.Port, connection.Username, connection.Password)\n\tif err != nil {\n\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\n\tconnectionDBModel := model2.ConnectionsDBModel{}\n\tconnectionDBModel.Username = connection.Username\n\tconnectionDBModel.Password = connection.Password\n\tconnectionDBModel.Host = connection.Host\n\tconnectionDBModel.Port = connection.Port\n\tconnectionDBModel.Directories = strings.Join(directories, \",\")\n\tbaseHostPath := \"/mnt/\" + connection.Host\n\tconnectionDBModel.MountPoint = baseHostPath\n\tconnection.MountPoint = baseHostPath\n\tfile.IsNotExistMkDir(baseHostPath)\n\tfor _, v := range directories {\n\t\tmountPoint := baseHostPath + \"/\" + v\n\t\tfile.IsNotExistMkDir(mountPoint)\n\t\tservice.MyService.Connections().MountSmaba(connectionDBModel.Username, connectionDBModel.Host, v, connectionDBModel.Port, mountPoint, connectionDBModel.Password)\n\t}\n\n\tservice.MyService.Connections().CreateConnection(&connectionDBModel)\n\n\tconnection.ID = connectionDBModel.ID\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: connection})\n}\n\nfunc DeleteSambaConnections(c *gin.Context) {\n\tid := c.Param(\"id\")\n\tconnection := service.MyService.Connections().GetConnectionByID(id)\n\tif connection.Username == \"\" {\n\t\tc.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.Record_NOT_EXIST, Message: common_err.GetMsg(common_err.Record_NOT_EXIST)})\n\t\treturn\n\t}\n\tmountPointList, err := samba.GetSambaSharesList(connection.Host, connection.Port, connection.Username, connection.Password)\n\t//mountPointList, err := service.MyService.System().GetDirPath(connection.MountPoint)\n\tif err != nil {\n\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\treturn\n\t}\n\tbaseHostPath := \"/mnt/\" + connection.Host\n\tfor _, v := range mountPointList {\n\t\tif service.IsMounted(baseHostPath + \"/\" + v) {\n\t\t\terr := service.MyService.Connections().UnmountSmaba(baseHostPath + \"/\" + v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"unmount smaba error\", zap.Error(err), zap.Any(\"path\", baseHostPath+\"/\"+v))\n\t\t\t\tc.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t}\n\tdir, _ := ioutil.ReadDir(connection.MountPoint)\n\tif len(dir) == 0 {\n\t\tos.RemoveAll(connection.MountPoint)\n\t}\n\tservice.MyService.Connections().DeleteConnection(id)\n\tc.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: id})\n}\n", "/*\n * @Author: LinkLeong link@icewhale.org\n * @Date: 2022-07-26 18:13:22\n * @LastEditors: LinkLeong\n * @LastEditTime: 2022-08-04 20:10:31\n * @FilePath: /CasaOS/service/connections.go\n * @Description:\n * @Website: https://www.casaos.io\n * Copyright (c) 2022 by icewhale, All Rights Reserved.\n */\npackage service\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/IceWhaleTech/CasaOS/service/model\"\n\tmodel2 \"github.com/IceWhaleTech/CasaOS/service/model\"\n\t\"github.com/moby/sys/mount\"\n\t\"golang.org/x/sys/unix\"\n\t\"gorm.io/gorm\"\n)\n\ntype ConnectionsService interface {\n\tGetConnectionsList() (connections []model2.ConnectionsDBModel)\n\tGetConnectionByHost(host string) (connections []model2.ConnectionsDBModel)\n\tGetConnectionByID(id string) (connections model2.ConnectionsDBModel)\n\tCreateConnection(connection *model2.ConnectionsDBModel)\n\tDeleteConnection(id string)\n\tUpdateConnection(connection *model2.ConnectionsDBModel)\n\tMountSmaba(username, host, directory, port, mountPoint, password string) error\n\tUnmountSmaba(mountPoint string) error\n}\n\ntype connectionsStruct struct {\n\tdb *gorm.DB\n}\n\nfunc (s *connectionsStruct) GetConnectionByHost(host string) (connections []model2.ConnectionsDBModel) {\n\ts.db.Select(\"username,host,status,id\").Where(\"host = ?\", host).Find(&connections)\n\treturn\n}\nfunc (s *connectionsStruct) GetConnectionByID(id string) (connections model2.ConnectionsDBModel) {\n\ts.db.Select(\"username,password,host,status,id,directories,mount_point,port\").Where(\"id = ?\", id).First(&connections)\n\treturn\n}\nfunc (s *connectionsStruct) GetConnectionsList() (connections []model2.ConnectionsDBModel) {\n\ts.db.Select(\"username,host,port,status,id,mount_point\").Find(&connections)\n\treturn\n}\nfunc (s *connectionsStruct) CreateConnection(connection *model2.ConnectionsDBModel) {\n\ts.db.Create(connection)\n}\nfunc (s *connectionsStruct) UpdateConnection(connection *model2.ConnectionsDBModel) {\n\ts.db.Save(connection)\n}\nfunc (s *connectionsStruct) DeleteConnection(id string) {\n\ts.db.Where(\"id= ?\", id).Delete(&model.ConnectionsDBModel{})\n}\n\nfunc (s *connectionsStruct) MountSmaba(username, host, directory, port, mountPoint, password string) error {\n\terr := unix.Mount(\n\t\tfmt.Sprintf(\"//%s/%s\", host, directory),\n\t\tmountPoint,\n\t\t\"cifs\",\n\t\tunix.MS_NOATIME|unix.MS_NODEV|unix.MS_NOSUID,\n\t\tfmt.Sprintf(\"username=%s,password=%s\", username, password),\n\t)\n\treturn err\n\t//str := command2.ExecResultStr(\"source \" + config.AppInfo.ShellPath + \"/helper.sh ;MountCIFS \" + username + \" \" + host + \" \" + directory + \" \" + port + \" \" + mountPoint + \" \" + password)\n\t//return str\n}\nfunc (s *connectionsStruct) UnmountSmaba(mountPoint string) error {\n\treturn mount.Unmount(mountPoint)\n}\n\nfunc NewConnectionsService(db *gorm.DB) ConnectionsService {\n\treturn &connectionsStruct{db: db}\n}\n"], "filenames": ["route/v1/samba.go", "service/connections.go"], "buggy_code_start_loc": [19, 14], "buggy_code_end_loc": [158, 62], "fixing_code_start_loc": [18, 14], "fixing_code_end_loc": [156, 71], "type": "CWE-77", "message": "CasaOS is an open-source personal cloud system. Prior to version 0.4.4, if an authenticated user using CasaOS is able to successfully connect to a controlled SMB server, they are able to execute arbitrary commands. Version 0.4.4 contains a patch for the issue.", "other": {"cve": {"id": "CVE-2023-37469", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-24T23:15:08.700", "lastModified": "2023-08-29T16:09:43.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CasaOS is an open-source personal cloud system. Prior to version 0.4.4, if an authenticated user using CasaOS is able to successfully connect to a controlled SMB server, they are able to execute arbitrary commands. Version 0.4.4 contains a patch for the issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:icewhale:casaos:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.4", "matchCriteriaId": "D7FF418A-FDDC-4509-9AD3-F9B087F66947"}]}]}], "references": [{"url": "https://github.com/IceWhaleTech/CasaOS/blob/96e92842357230098c771bc41fd3baf46189b859/route/v1/samba.go#L121", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/IceWhaleTech/CasaOS/blob/96e92842357230098c771bc41fd3baf46189b859/service/connections.go#L58", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/IceWhaleTech/CasaOS/commit/af440eac5563644854ff33f72041e52d3fd1f47c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/IceWhaleTech/CasaOS/releases/tag/v0.4.4", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2022-119_CasaOS/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/IceWhaleTech/CasaOS/commit/af440eac5563644854ff33f72041e52d3fd1f47c"}}