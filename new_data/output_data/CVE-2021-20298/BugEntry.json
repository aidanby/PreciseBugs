{"buggy_code": ["///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2006, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n\n//-----------------------------------------------------------------------------\n//\n//\tclass B44Compressor\n//\n//\tThis compressor is lossy for HALF channels; the compression rate\n//\tis fixed at 32/14 (approximately 2.28).  FLOAT and UINT channels\n//\tare not compressed; their data are preserved exactly.\n//\n//\tEach HALF channel is split into blocks of 4 by 4 pixels.  An\n//\tuncompressed block occupies 32 bytes, which are re-interpreted\n//\tas sixteen 16-bit unsigned integers, t[0] ... t[15].  Compression\n//\tshrinks the block to 14 bytes.  The compressed 14-byte block\n//\tcontains\n//\n//\t - t[0]\n//\n//\t - a 6-bit shift value\n//\n//\t - 15 densely packed 6-bit values, r[0] ... r[14], which are\n//         computed by subtracting adjacent pixel values and right-\n//\t   shifting the differences according to the stored shift value.\n//\n//\t   Differences between adjacent pixels are computed according\n//\t   to the following diagram:\n//\n//\t\t 0 -------->  1 -------->  2 -------->  3\n//               |     3            7           11\n//               |\n//               | 0\n//               |\n//               v \n//\t\t 4 -------->  5 -------->  6 -------->  7\n//               |     4            8           12\n//               |\n//               | 1\n//               |\n//               v\n//\t\t 8 -------->  9 --------> 10 --------> 11\n//               |     5            9           13\n//               |\n//               | 2\n//               |\n//               v\n//\t\t12 --------> 13 --------> 14 --------> 15\n//                     6           10           14\n//\n//\t    Here\n//\n//               5 ---------> 6\n//                     8\n//\n//\t    means that r[8] is the difference between t[5] and t[6].\n//\n//\t - optionally, a 4-by-4 pixel block where all pixels have the\n//\t   same value can be treated as a special case, where the\n//\t   compressed block contains only 3 instead of 14 bytes:\n//\t   t[0], followed by an \"impossible\" 6-bit shift value and\n//\t   two padding bits.\n//\n//\tThis compressor can handle positive and negative pixel values.\n//\tNaNs and infinities are replaced with zeroes before compression.\n//\n//-----------------------------------------------------------------------------\n\n#include \"ImfB44Compressor.h\"\n#include \"ImfHeader.h\"\n#include \"ImfChannelList.h\"\n#include \"ImfMisc.h\"\n#include \"ImfCheckedArithmetic.h\"\n#include <ImathFun.h>\n#include <ImathBox.h>\n#include <Iex.h>\n#include <ImfIO.h>\n#include <ImfXdr.h>\n#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"ImfNamespace.h\"\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\n\nusing IMATH_NAMESPACE::divp;\nusing IMATH_NAMESPACE::modp;\nusing IMATH_NAMESPACE::Box2i;\nusing IMATH_NAMESPACE::V2i;\nusing std::min;\n\nnamespace {\n\n//\n// Lookup tables for\n//\ty = exp (x / 8)\n// and \n//\tx = 8 * log (y)\n//\n\n#include \"b44ExpLogTable.h\"\n\n\ninline void\nconvertFromLinear (unsigned short s[16])\n{\n    for (int i = 0; i < 16; ++i)\n\ts[i] = expTable[s[i]];\n}\n\n\ninline void\nconvertToLinear (unsigned short s[16])\n{\n    for (int i = 0; i < 16; ++i)\n\ts[i] = logTable[s[i]];\n}\n\n\ninline int\nshiftAndRound (int x, int shift)\n{\n    //\n    // Compute\n    //\n    //     y = x * pow (2, -shift),\n    //\n    // then round y to the nearest integer.\n    // In case of a tie, where y is exactly\n    // halfway between two integers, round\n    // to the even one.\n    //\n\n    x <<= 1;\n    int a = (1 << shift) - 1;\n    shift += 1;\n    int b = (x >> shift) & 1;\n    return (x + a + b) >> shift;\n}\n\n\nint\npack (const unsigned short s[16],\n      unsigned char b[14],\n      bool optFlatFields,\n      bool exactMax)\n{\n    //\n    // Pack a block of 4 by 4 16-bit pixels (32 bytes) into\n    // either 14 or 3 bytes.\n    //\n\n    //\n    // Integers s[0] ... s[15] represent floating-point numbers\n    // in what is essentially a sign-magnitude format.  Convert\n    // s[0] .. s[15] into a new set of integers, t[0] ... t[15],\n    // such that if t[i] is greater than t[j], the floating-point\n    // number that corresponds to s[i] is always greater than\n    // the floating-point number that corresponds to s[j].\n    //\n    // Also, replace any bit patterns that represent NaNs or\n    // infinities with bit patterns that represent floating-point\n    // zeroes.\n    //\n    //\tbit pattern\tfloating-point\t\tbit pattern\n    //\tin s[i]\t\tvalue\t\t\tin t[i]\n    //\n    //  0x7fff\t\tNAN\t\t\t0x8000\n    //  0x7ffe\t\tNAN\t\t\t0x8000\n    //\t  ...\t\t\t\t\t  ...\n    //  0x7c01\t\tNAN\t\t\t0x8000\n    //  0x7c00\t\t+infinity\t\t0x8000\n    //  0x7bff\t\t+HALF_MAX\t\t0xfbff\n    //  0x7bfe\t\t\t\t\t0xfbfe\n    //  0x7bfd\t\t\t\t\t0xfbfd\n    //\t  ...\t\t\t\t\t  ...\n    //  0x0002\t\t+2 * HALF_MIN\t\t0x8002\n    //  0x0001\t\t+HALF_MIN\t\t0x8001\n    //  0x0000\t\t+0.0\t\t\t0x8000\n    //  0x8000\t\t-0.0\t\t\t0x7fff\n    //  0x8001\t\t-HALF_MIN\t\t0x7ffe\n    //  0x8002\t\t-2 * HALF_MIN\t\t0x7ffd\n    //\t  ...\t\t\t\t\t  ...\n    //  0xfbfd\t\t\t\t\t0x0f02\n    //  0xfbfe\t\t\t\t\t0x0401\n    //  0xfbff\t\t-HALF_MAX\t\t0x0400\n    //  0xfc00\t\t-infinity\t\t0x8000\n    //  0xfc01\t\tNAN\t\t\t0x8000\n    //\t  ...\t\t\t\t\t  ...\n    //  0xfffe\t\tNAN\t\t\t0x8000\n    //  0xffff\t\tNAN\t\t\t0x8000\n    //\n\n    unsigned short t[16];\n\n    for (int i = 0; i < 16; ++i)\n    {\n\tif ((s[i] & 0x7c00) == 0x7c00)\n\t    t[i] = 0x8000;\n\telse if (s[i] & 0x8000)\n\t    t[i] = ~s[i];\n\telse\n\t    t[i] = s[i] | 0x8000;\n    }\n    \n    //\n    // Find the maximum, tMax, of t[0] ... t[15].\n    //\n\n    unsigned short tMax = 0;\n\n    for (int i = 0; i < 16; ++i)\n\tif (tMax < t[i])\n\t    tMax = t[i];\n\n    //\n    // Compute a set of running differences, r[0] ... r[14]:\n    // Find a shift value such that after rounding off the\n    // rightmost bits and shifting all differenes are between\n    // -32 and +31.  Then bias the differences so that they\n    // end up between 0 and 63.\n    //\n\n    int shift = -1;\n    int d[16];\n    int r[15];\n    int rMin;\n    int rMax;\n\n    const int bias = 0x20;\n\n    do\n    {\n        shift += 1;\n\n        //\n        // Compute absolute differences, d[0] ... d[15],\n        // between tMax and t[0] ... t[15].\n        //\n        // Shift and round the absolute differences.\n        //\n\n        for (int i = 0; i < 16; ++i)\n            d[i] = shiftAndRound (tMax - t[i], shift);\n\n        //\n        // Convert d[0] .. d[15] into running differences\n        //\n\n        r[ 0] = d[ 0] - d[ 4] + bias;\n        r[ 1] = d[ 4] - d[ 8] + bias;\n        r[ 2] = d[ 8] - d[12] + bias;\n\n        r[ 3] = d[ 0] - d[ 1] + bias;\n        r[ 4] = d[ 4] - d[ 5] + bias;\n        r[ 5] = d[ 8] - d[ 9] + bias;\n        r[ 6] = d[12] - d[13] + bias;\n\n        r[ 7] = d[ 1] - d[ 2] + bias;\n        r[ 8] = d[ 5] - d[ 6] + bias;\n        r[ 9] = d[ 9] - d[10] + bias;\n        r[10] = d[13] - d[14] + bias;\n\n        r[11] = d[ 2] - d[ 3] + bias;\n        r[12] = d[ 6] - d[ 7] + bias;\n        r[13] = d[10] - d[11] + bias;\n        r[14] = d[14] - d[15] + bias;\n\n        rMin = r[0];\n        rMax = r[0];\n\n        for (int i = 1; i < 15; ++i)\n        {\n            if (rMin > r[i])\n                rMin = r[i];\n\n            if (rMax < r[i])\n                rMax = r[i];\n        }\n    }\n    while (rMin < 0 || rMax > 0x3f);\n\n    if (rMin == bias && rMax == bias && optFlatFields)\n    {\n        //\n        // Special case - all pixels have the same value.\n        // We encode this in 3 instead of 14 bytes by\n        // storing the value 0xfc in the third output byte,\n        // which cannot occur in the 14-byte encoding.\n        //\n\n        b[0] = (t[0] >> 8);\n        b[1] = (unsigned char) t[0];\n        b[2] = 0xfc;\n\n        return 3;\n    }\n\n    if (exactMax)\n    {\n        //\n        // Adjust t[0] so that the pixel whose value is equal\n        // to tMax gets represented as accurately as possible.\n        //\n\n        t[0] = tMax - (d[0] << shift);\n    }\n\n    //\n    // Pack t[0], shift and r[0] ... r[14] into 14 bytes:\n    //\n\n    b[ 0] = (t[0] >> 8);\n    b[ 1] = (unsigned char) t[0];\n\n    b[ 2] = (unsigned char) ((shift << 2) | (r[ 0] >> 4));\n    b[ 3] = (unsigned char) ((r[ 0] << 4) | (r[ 1] >> 2));\n    b[ 4] = (unsigned char) ((r[ 1] << 6) |  r[ 2]      );\n\n    b[ 5] = (unsigned char) ((r[ 3] << 2) | (r[ 4] >> 4));\n    b[ 6] = (unsigned char) ((r[ 4] << 4) | (r[ 5] >> 2));\n    b[ 7] = (unsigned char) ((r[ 5] << 6) |  r[ 6]      );\n\n    b[ 8] = (unsigned char) ((r[ 7] << 2) | (r[ 8] >> 4));\n    b[ 9] = (unsigned char) ((r[ 8] << 4) | (r[ 9] >> 2));\n    b[10] = (unsigned char) ((r[ 9] << 6) |  r[10]      );\n\n    b[11] = (unsigned char) ((r[11] << 2) | (r[12] >> 4));\n    b[12] = (unsigned char) ((r[12] << 4) | (r[13] >> 2));\n    b[13] = (unsigned char) ((r[13] << 6) |  r[14]      );\n\n    return 14;\n}\n\n\ninline\nvoid\nunpack14 (const unsigned char b[14], unsigned short s[16])\n{\n    //\n    // Unpack a 14-byte block into 4 by 4 16-bit pixels.\n    //\n\n    #if defined (DEBUG)\n\tassert (b[2] != 0xfc);\n    #endif\n\n    s[ 0] = (b[0] << 8) | b[1];\n\n    unsigned short shift = (b[ 2] >> 2);\n    unsigned short bias = (0x20u << shift);\n\n    s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3fu) << shift) - bias;\n    s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3fu) << shift) - bias;\n    s[12] = s[ 8] +   ((b[ 4]                       & 0x3fu) << shift) - bias;\n    \n    s[ 1] = s[ 0] +   ((unsigned int) (b[ 5] >> 2)           << shift) - bias;\n    s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3fu) << shift) - bias;\n    s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3fu) << shift) - bias;\n    s[13] = s[12] +   ((b[ 7]                       & 0x3fu) << shift) - bias;\n    \n    s[ 2] = s[ 1] +   ((unsigned int)(b[ 8] >> 2)            << shift) - bias;\n    s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3fu) << shift) - bias;\n    s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3fu) << shift) - bias;\n    s[14] = s[13] +   ((b[10]                       & 0x3fu) << shift) - bias;\n    \n    s[ 3] = s[ 2] +   ((unsigned int)(b[11] >> 2)            << shift) - bias;\n    s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3fu) << shift) - bias;\n    s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3fu) << shift) - bias;\n    s[15] = s[14] +   ((b[13]                       & 0x3fu) << shift) - bias;\n\n    for (int i = 0; i < 16; ++i)\n    {\n\tif (s[i] & 0x8000)\n\t    s[i] &= 0x7fff;\n\telse\n\t    s[i] = ~s[i];\n    }\n}\n\n\ninline\nvoid\nunpack3 (const unsigned char b[3], unsigned short s[16])\n{\n    //\n    // Unpack a 3-byte block into 4 by 4 identical 16-bit pixels.\n    //\n\n    #if defined (DEBUG)\n\tassert (b[2] == 0xfc);\n    #endif\n\n    s[0] = (b[0] << 8) | b[1];\n\n    if (s[0] & 0x8000)\n\ts[0] &= 0x7fff;\n    else\n\ts[0] = ~s[0];\n\n    for (int i = 1; i < 16; ++i)\n\ts[i] = s[0];\n}\n\n\nvoid\nnotEnoughData ()\n{\n    throw IEX_NAMESPACE::InputExc (\"Error decompressing data \"\n\t\t\t \"(input data are shorter than expected).\");\n}\n\n\nvoid\ntooMuchData ()\n{\n    throw IEX_NAMESPACE::InputExc (\"Error decompressing data \"\n\t\t\t \"(input data are longer than expected).\");\n}\n\n} // namespace\n\n\nstruct B44Compressor::ChannelData\n{\n    unsigned short *\tstart;\n    unsigned short *\tend;\n    int\t\t\tnx;\n    int\t\t\tny;\n    int\t\t\tys;\n    PixelType\t\ttype;\n    bool\t\tpLinear;\n    int\t\t\tsize;\n};\n\n\nB44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    // TODO: Remove this when we can change the ABI\n    (void)_maxScanLineSize;\n    //\n    // Allocate buffers for compressed an uncompressed pixel data,\n    // allocate a set of ChannelData structs to help speed up the\n    // compress() and uncompress() functions, below, and determine\n    // if uncompressed pixel data should be in native or Xdr format.\n    //\n\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n\n    //\n    // Compressed data may be larger than the input data\n    //\n\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n\n    _channelData = new ChannelData[_numChans];\n\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n\n    const Box2i &dataWindow = hdr.dataWindow();\n\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n\n    //\n    // We can support uncompressed data in the machine's native\n    // format only if all image channels are of type HALF.\n    //\n\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}\n\n\nB44Compressor::~B44Compressor ()\n{\n    delete [] _tmpBuffer;\n    delete [] _outBuffer;\n    delete [] _channelData;\n}\n\n\nint\nB44Compressor::numScanLines () const\n{\n    return _numScanLines;\n}\n\n\nCompressor::Format\nB44Compressor::format () const\n{\n    return _format;\n}\n\n\nint\nB44Compressor::compress (const char *inPtr,\n\t\t\t int inSize,\n\t\t\t int minY,\n\t\t\t const char *&outPtr)\n{\n    return compress (inPtr,\n\t\t     inSize,\n\t\t     Box2i (V2i (_minX, minY),\n\t\t\t    V2i (_maxX, minY + numScanLines() - 1)),\n\t\t     outPtr);\n}\n\n\nint\nB44Compressor::compressTile (const char *inPtr,\n\t\t\t     int inSize,\n\t\t\t     IMATH_NAMESPACE::Box2i range,\n\t\t\t     const char *&outPtr)\n{\n    return compress (inPtr, inSize, range, outPtr);\n}\n\n\nint\nB44Compressor::uncompress (const char *inPtr,\n\t\t\t   int inSize,\n\t\t\t   int minY,\n\t\t\t   const char *&outPtr)\n{\n    return uncompress (inPtr,\n\t\t       inSize,\n\t\t       Box2i (V2i (_minX, minY),\n\t\t\t      V2i (_maxX, minY + numScanLines() - 1)),\n\t\t       outPtr);\n}\n\n\nint\nB44Compressor::uncompressTile (const char *inPtr,\n\t\t\t       int inSize,\n\t\t\t       IMATH_NAMESPACE::Box2i range,\n\t\t\t       const char *&outPtr)\n{\n    return uncompress (inPtr, inSize, range, outPtr);\n}\n\n\nint\nB44Compressor::compress (const char *inPtr,\n\t\t\t int inSize,\n\t\t\t IMATH_NAMESPACE::Box2i range,\n\t\t\t const char *&outPtr)\n{\n    //\n    // Compress a block of pixel data:  First copy the input pixels\n    // from the input buffer into _tmpBuffer, rearranging them such\n    // that blocks of 4x4 pixels of a single channel can be accessed\n    // conveniently.  Then compress each 4x4 block of HALF pixel data\n    // and append the result to the output buffer.  Copy UINT and\n    // FLOAT data to the output buffer without compressing them.\n    //\n\n    outPtr = _outBuffer;\n\n    if (inSize == 0)\n    {\n\t//\n\t// Special case - empty input buffer.\n\t//\n\n\treturn 0;\n    }\n\n    //\n    // For each channel, detemine how many pixels are stored\n    // in the input buffer, and where those pixels will be\n    // placed in _tmpBuffer.\n    //\n\n    int minX = range.min.x;\n    int maxX = min (range.max.x, _maxX);\n    int minY = range.min.y;\n    int maxY = min (range.max.y, _maxY);\n    \n    unsigned short *tmpBufferEnd = _tmpBuffer;\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = _channels.begin();\n\t c != _channels.end();\n\t ++c, ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tcd.start = tmpBufferEnd;\n\tcd.end = cd.start;\n\n\tcd.nx = numSamples (c.channel().xSampling, minX, maxX);\n\tcd.ny = numSamples (c.channel().ySampling, minY, maxY);\n\n\ttmpBufferEnd += cd.nx * cd.ny * cd.size;\n    }\n\n    if (_format == XDR)\n    {\n\t//\n\t// The data in the input buffer are in the machine-independent\n\t// Xdr format.  Copy the HALF channels into _tmpBuffer and\n\t// convert them back into native format for compression.\n\t// Copy UINT and FLOAT channels verbatim into _tmpBuffer.\n\t//\n\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tif (cd.type == HALF)\n\t\t{\n\t\t    for (int x = cd.nx; x > 0; --x)\n\t\t    {\n\t\t\tXdr::read <CharPtrIO> (inPtr, *cd.end);\n\t\t\t++cd.end;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    int n = cd.nx * cd.size;\n\t\t    memcpy (cd.end, inPtr, n * sizeof (unsigned short));\n\t\t    inPtr += n * sizeof (unsigned short);\n\t\t    cd.end += n;\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\t//\n\t// The input buffer contains only HALF channels, and they\n\t// are in native, machine-dependent format.  Copy the pixels\n\t// into _tmpBuffer.\n\t//\n\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\t#if defined (DEBUG)\n\t\t    assert (cd.type == HALF);\n\t\t#endif\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tint n = cd.nx * cd.size;\n\t\tmemcpy (cd.end, inPtr, n * sizeof (unsigned short));\n\t\tinPtr  += n * sizeof (unsigned short);\n\t\tcd.end += n;\n\t    }\n\t}\n    }\n\n    //\n    // The pixels for each channel have been packed into a contiguous\n    // block in _tmpBuffer.  HALF channels are in native format; UINT\n    // and FLOAT channels are in Xdr format.\n    //\n\n    #if defined (DEBUG)\n\n\tfor (int i = 1; i < _numChans; ++i)\n\t    assert (_channelData[i-1].end == _channelData[i].start);\n\n\tassert (_channelData[_numChans-1].end == tmpBufferEnd);\n\n    #endif\n\n    //\n    // For each HALF channel, split the data in _tmpBuffer into 4x4\n    // pixel blocks.  Compress each block and append the compressed\n    // data to the output buffer.\n    //\n    // UINT and FLOAT channels are copied from _tmpBuffer into the\n    // output buffer without further processing.\n    //\n\n    char *outEnd = _outBuffer;\n\n    for (int i = 0; i < _numChans; ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\t\n\tif (cd.type != HALF)\n\t{\n\t    //\n\t    // UINT or FLOAT channel.\n\t    //\n\n\t    int n = cd.nx * cd.ny * cd.size * sizeof (unsigned short);\n\t    memcpy (outEnd, cd.start, n);\n\t    outEnd += n;\n\n\t    continue;\n\t}\n\t\n\t//\n\t// HALF channel\n\t//\n\n\tfor (int y = 0; y < cd.ny; y += 4)\n\t{\n\t    //\n\t    // Copy the next 4x4 pixel block into array s.\n\t    // If the width, cd.nx, or the height, cd.ny, of\n\t    // the pixel data in _tmpBuffer is not divisible\n\t    // by 4, then pad the data by repeating the\n\t    // rightmost column and the bottom row.\n\t    // \n\n\t    unsigned short *row0 = cd.start + y * cd.nx;\n\t    unsigned short *row1 = row0 + cd.nx;\n\t    unsigned short *row2 = row1 + cd.nx;\n\t    unsigned short *row3 = row2 + cd.nx;\n\n\t    if (y + 3 >= cd.ny)\n\t    {\n\t\tif (y + 1 >= cd.ny)\n\t\t    row1 = row0;\n\n\t\tif (y + 2 >= cd.ny)\n\t\t    row2 = row1;\n\n\t\trow3 = row2;\n\t    }\n\n\t    for (int x = 0; x < cd.nx; x += 4)\n\t    {\n\t\tunsigned short s[16];\n\n\t\tif (x + 3 >= cd.nx)\n\t\t{\n\t\t    int n = cd.nx - x;\n\n\t\t    for (int i = 0; i < 4; ++i)\n\t\t    {\n\t\t\tint j = min (i, n - 1);\n\n\t\t\ts[i +  0] = row0[j];\n\t\t\ts[i +  4] = row1[j];\n\t\t\ts[i +  8] = row2[j];\n\t\t\ts[i + 12] = row3[j];\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    memcpy (&s[ 0], row0, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[ 4], row1, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[ 8], row2, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[12], row3, 4 * sizeof (unsigned short));\n\t\t}\n\n\t\trow0 += 4;\n\t\trow1 += 4;\n\t\trow2 += 4;\n\t\trow3 += 4;\n\n\t\t//\n\t\t// Compress the contents of array s and append the\n\t\t// results to the output buffer.\n\t\t//\n\n\t\tif (cd.pLinear)\n\t\t    convertFromLinear (s);\n\n\t\toutEnd += pack (s, (unsigned char *) outEnd,\n\t\t\t\t_optFlatFields, !cd.pLinear);\n\t    }\n\t}\n    }\n\n    return outEnd - _outBuffer;\n}\n\n\nint\nB44Compressor::uncompress (const char *inPtr,\n\t\t\t   int inSize,\n\t\t\t   IMATH_NAMESPACE::Box2i range,\n\t\t\t   const char *&outPtr)\n{\n    //\n    // This function is the reverse of the compress() function,\n    // above.  First all pixels are moved from the input buffer\n    // into _tmpBuffer.  UINT and FLOAT channels are copied\n    // verbatim; HALF channels are uncompressed in blocks of\n    // 4x4 pixels.  Then the pixels in _tmpBuffer are copied\n    // into the output buffer and rearranged such that the data\n    // for for each scan line form a contiguous block.\n    //\n\n    outPtr = _outBuffer;\n\n    if (inSize == 0)\n    {\n\treturn 0;\n    }\n\n    int minX = range.min.x;\n    int maxX = min (range.max.x, _maxX);\n    int minY = range.min.y;\n    int maxY = min (range.max.y, _maxY);\n    \n    unsigned short *tmpBufferEnd = _tmpBuffer;\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = _channels.begin();\n\t c != _channels.end();\n\t ++c, ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tcd.start = tmpBufferEnd;\n\tcd.end = cd.start;\n\n\tcd.nx = numSamples (c.channel().xSampling, minX, maxX);\n\tcd.ny = numSamples (c.channel().ySampling, minY, maxY);\n\n\ttmpBufferEnd += cd.nx * cd.ny * cd.size;\n    }\n\n    for (int i = 0; i < _numChans; ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tif (cd.type != HALF)\n\t{\n\t    //\n\t    // UINT or FLOAT channel.\n\t    //\n\n\t    int n = cd.nx * cd.ny * cd.size * sizeof (unsigned short);\n\n\t    if (inSize < n)\n\t\tnotEnoughData();\n\n\t    memcpy (cd.start, inPtr, n);\n\t    inPtr += n;\n\t    inSize -= n;\n\n\t    continue;\n\t}\n\n\t//\n\t// HALF channel\n\t//\n\n\tfor (int y = 0; y < cd.ny; y += 4)\n\t{\n\t    unsigned short *row0 = cd.start + y * cd.nx;\n\t    unsigned short *row1 = row0 + cd.nx;\n\t    unsigned short *row2 = row1 + cd.nx;\n\t    unsigned short *row3 = row2 + cd.nx;\n\n\t    for (int x = 0; x < cd.nx; x += 4)\n\t    {\n\t\tunsigned short s[16]; \n\n\t\tif (inSize < 3)\n\t\t    notEnoughData();\n\n                //\n                // If shift exponent is 63, call unpack14 (ignoring unused bits)\n                //\n\t\tif (((const unsigned char *)inPtr)[2] >= (13<<2) )\n\t\t{\n\t\t    unpack3 ((const unsigned char *)inPtr, s);\n\t\t    inPtr += 3;\n\t\t    inSize -= 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (inSize < 14)\n\t\t\tnotEnoughData();\n\n\t\t    unpack14 ((const unsigned char *)inPtr, s);\n\t\t    inPtr += 14;\n\t\t    inSize -= 14;\n\t\t}\n\n\t\tif (cd.pLinear)\n\t\t    convertToLinear (s);\n\n\t\tint n = (x + 3 < cd.nx)?\n\t\t\t    4 * sizeof (unsigned short) :\n\t\t\t    (cd.nx - x) * sizeof (unsigned short);\n\n\t\tif (y + 3 < cd.ny)\n\t\t{\n\t\t    memcpy (row0, &s[ 0], n);\n\t\t    memcpy (row1, &s[ 4], n);\n\t\t    memcpy (row2, &s[ 8], n);\n\t\t    memcpy (row3, &s[12], n);\n\t\t}\n\t\telse\n\t\t{\n\t\t    memcpy (row0, &s[ 0], n);\n\n\t\t    if (y + 1 < cd.ny)\n\t\t\tmemcpy (row1, &s[ 4], n);\n\n\t\t    if (y + 2 < cd.ny)\n\t\t\tmemcpy (row2, &s[ 8], n);\n\t\t}\n\n\t\trow0 += 4;\n\t\trow1 += 4;\n\t\trow2 += 4;\n\t\trow3 += 4;\n\t    }\n\t}\n    }\n\n    char *outEnd = _outBuffer;\n\n    if (_format == XDR)\n    {\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tif (cd.type == HALF)\n\t\t{\n\t\t    for (int x = cd.nx; x > 0; --x)\n\t\t    {\n\t\t\tXdr::write <CharPtrIO> (outEnd, *cd.end);\n\t\t\t++cd.end;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    int n = cd.nx * cd.size;\n\t\t    memcpy (outEnd, cd.end, n * sizeof (unsigned short));\n\t\t    outEnd += n * sizeof (unsigned short);\n\t\t    cd.end += n;\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\t#if defined (DEBUG)\n\t\t    assert (cd.type == HALF);\n\t\t#endif\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tint n = cd.nx * cd.size;\n\t\tmemcpy (outEnd, cd.end, n * sizeof (unsigned short));\n\t\toutEnd += n * sizeof (unsigned short);\n\t\tcd.end += n;\n\t    }\n\t}\n    }\n\n    #if defined (DEBUG)\n\n\tfor (int i = 1; i < _numChans; ++i)\n\t    assert (_channelData[i-1].end == _channelData[i].start);\n\n\tassert (_channelData[_numChans-1].end == tmpBufferEnd);\n\n    #endif\n\n    if (inSize > 0)\n\ttooMuchData();\n\n    outPtr = _outBuffer;\n    return outEnd - _outBuffer;\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n"], "fixing_code": ["///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2006, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n\n//-----------------------------------------------------------------------------\n//\n//\tclass B44Compressor\n//\n//\tThis compressor is lossy for HALF channels; the compression rate\n//\tis fixed at 32/14 (approximately 2.28).  FLOAT and UINT channels\n//\tare not compressed; their data are preserved exactly.\n//\n//\tEach HALF channel is split into blocks of 4 by 4 pixels.  An\n//\tuncompressed block occupies 32 bytes, which are re-interpreted\n//\tas sixteen 16-bit unsigned integers, t[0] ... t[15].  Compression\n//\tshrinks the block to 14 bytes.  The compressed 14-byte block\n//\tcontains\n//\n//\t - t[0]\n//\n//\t - a 6-bit shift value\n//\n//\t - 15 densely packed 6-bit values, r[0] ... r[14], which are\n//         computed by subtracting adjacent pixel values and right-\n//\t   shifting the differences according to the stored shift value.\n//\n//\t   Differences between adjacent pixels are computed according\n//\t   to the following diagram:\n//\n//\t\t 0 -------->  1 -------->  2 -------->  3\n//               |     3            7           11\n//               |\n//               | 0\n//               |\n//               v \n//\t\t 4 -------->  5 -------->  6 -------->  7\n//               |     4            8           12\n//               |\n//               | 1\n//               |\n//               v\n//\t\t 8 -------->  9 --------> 10 --------> 11\n//               |     5            9           13\n//               |\n//               | 2\n//               |\n//               v\n//\t\t12 --------> 13 --------> 14 --------> 15\n//                     6           10           14\n//\n//\t    Here\n//\n//               5 ---------> 6\n//                     8\n//\n//\t    means that r[8] is the difference between t[5] and t[6].\n//\n//\t - optionally, a 4-by-4 pixel block where all pixels have the\n//\t   same value can be treated as a special case, where the\n//\t   compressed block contains only 3 instead of 14 bytes:\n//\t   t[0], followed by an \"impossible\" 6-bit shift value and\n//\t   two padding bits.\n//\n//\tThis compressor can handle positive and negative pixel values.\n//\tNaNs and infinities are replaced with zeroes before compression.\n//\n//-----------------------------------------------------------------------------\n\n#include \"ImfB44Compressor.h\"\n#include \"ImfHeader.h\"\n#include \"ImfChannelList.h\"\n#include \"ImfMisc.h\"\n#include \"ImfCheckedArithmetic.h\"\n#include <ImathFun.h>\n#include <ImathBox.h>\n#include <Iex.h>\n#include <ImfIO.h>\n#include <ImfXdr.h>\n#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"ImfNamespace.h\"\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\n\nusing IMATH_NAMESPACE::divp;\nusing IMATH_NAMESPACE::modp;\nusing IMATH_NAMESPACE::Box2i;\nusing IMATH_NAMESPACE::V2i;\nusing std::min;\n\nnamespace {\n\n//\n// Lookup tables for\n//\ty = exp (x / 8)\n// and \n//\tx = 8 * log (y)\n//\n\n#include \"b44ExpLogTable.h\"\n\n\ninline void\nconvertFromLinear (unsigned short s[16])\n{\n    for (int i = 0; i < 16; ++i)\n\ts[i] = expTable[s[i]];\n}\n\n\ninline void\nconvertToLinear (unsigned short s[16])\n{\n    for (int i = 0; i < 16; ++i)\n\ts[i] = logTable[s[i]];\n}\n\n\ninline int\nshiftAndRound (int x, int shift)\n{\n    //\n    // Compute\n    //\n    //     y = x * pow (2, -shift),\n    //\n    // then round y to the nearest integer.\n    // In case of a tie, where y is exactly\n    // halfway between two integers, round\n    // to the even one.\n    //\n\n    x <<= 1;\n    int a = (1 << shift) - 1;\n    shift += 1;\n    int b = (x >> shift) & 1;\n    return (x + a + b) >> shift;\n}\n\n\nint\npack (const unsigned short s[16],\n      unsigned char b[14],\n      bool optFlatFields,\n      bool exactMax)\n{\n    //\n    // Pack a block of 4 by 4 16-bit pixels (32 bytes) into\n    // either 14 or 3 bytes.\n    //\n\n    //\n    // Integers s[0] ... s[15] represent floating-point numbers\n    // in what is essentially a sign-magnitude format.  Convert\n    // s[0] .. s[15] into a new set of integers, t[0] ... t[15],\n    // such that if t[i] is greater than t[j], the floating-point\n    // number that corresponds to s[i] is always greater than\n    // the floating-point number that corresponds to s[j].\n    //\n    // Also, replace any bit patterns that represent NaNs or\n    // infinities with bit patterns that represent floating-point\n    // zeroes.\n    //\n    //\tbit pattern\tfloating-point\t\tbit pattern\n    //\tin s[i]\t\tvalue\t\t\tin t[i]\n    //\n    //  0x7fff\t\tNAN\t\t\t0x8000\n    //  0x7ffe\t\tNAN\t\t\t0x8000\n    //\t  ...\t\t\t\t\t  ...\n    //  0x7c01\t\tNAN\t\t\t0x8000\n    //  0x7c00\t\t+infinity\t\t0x8000\n    //  0x7bff\t\t+HALF_MAX\t\t0xfbff\n    //  0x7bfe\t\t\t\t\t0xfbfe\n    //  0x7bfd\t\t\t\t\t0xfbfd\n    //\t  ...\t\t\t\t\t  ...\n    //  0x0002\t\t+2 * HALF_MIN\t\t0x8002\n    //  0x0001\t\t+HALF_MIN\t\t0x8001\n    //  0x0000\t\t+0.0\t\t\t0x8000\n    //  0x8000\t\t-0.0\t\t\t0x7fff\n    //  0x8001\t\t-HALF_MIN\t\t0x7ffe\n    //  0x8002\t\t-2 * HALF_MIN\t\t0x7ffd\n    //\t  ...\t\t\t\t\t  ...\n    //  0xfbfd\t\t\t\t\t0x0f02\n    //  0xfbfe\t\t\t\t\t0x0401\n    //  0xfbff\t\t-HALF_MAX\t\t0x0400\n    //  0xfc00\t\t-infinity\t\t0x8000\n    //  0xfc01\t\tNAN\t\t\t0x8000\n    //\t  ...\t\t\t\t\t  ...\n    //  0xfffe\t\tNAN\t\t\t0x8000\n    //  0xffff\t\tNAN\t\t\t0x8000\n    //\n\n    unsigned short t[16];\n\n    for (int i = 0; i < 16; ++i)\n    {\n\tif ((s[i] & 0x7c00) == 0x7c00)\n\t    t[i] = 0x8000;\n\telse if (s[i] & 0x8000)\n\t    t[i] = ~s[i];\n\telse\n\t    t[i] = s[i] | 0x8000;\n    }\n    \n    //\n    // Find the maximum, tMax, of t[0] ... t[15].\n    //\n\n    unsigned short tMax = 0;\n\n    for (int i = 0; i < 16; ++i)\n\tif (tMax < t[i])\n\t    tMax = t[i];\n\n    //\n    // Compute a set of running differences, r[0] ... r[14]:\n    // Find a shift value such that after rounding off the\n    // rightmost bits and shifting all differenes are between\n    // -32 and +31.  Then bias the differences so that they\n    // end up between 0 and 63.\n    //\n\n    int shift = -1;\n    int d[16];\n    int r[15];\n    int rMin;\n    int rMax;\n\n    const int bias = 0x20;\n\n    do\n    {\n        shift += 1;\n\n        //\n        // Compute absolute differences, d[0] ... d[15],\n        // between tMax and t[0] ... t[15].\n        //\n        // Shift and round the absolute differences.\n        //\n\n        for (int i = 0; i < 16; ++i)\n            d[i] = shiftAndRound (tMax - t[i], shift);\n\n        //\n        // Convert d[0] .. d[15] into running differences\n        //\n\n        r[ 0] = d[ 0] - d[ 4] + bias;\n        r[ 1] = d[ 4] - d[ 8] + bias;\n        r[ 2] = d[ 8] - d[12] + bias;\n\n        r[ 3] = d[ 0] - d[ 1] + bias;\n        r[ 4] = d[ 4] - d[ 5] + bias;\n        r[ 5] = d[ 8] - d[ 9] + bias;\n        r[ 6] = d[12] - d[13] + bias;\n\n        r[ 7] = d[ 1] - d[ 2] + bias;\n        r[ 8] = d[ 5] - d[ 6] + bias;\n        r[ 9] = d[ 9] - d[10] + bias;\n        r[10] = d[13] - d[14] + bias;\n\n        r[11] = d[ 2] - d[ 3] + bias;\n        r[12] = d[ 6] - d[ 7] + bias;\n        r[13] = d[10] - d[11] + bias;\n        r[14] = d[14] - d[15] + bias;\n\n        rMin = r[0];\n        rMax = r[0];\n\n        for (int i = 1; i < 15; ++i)\n        {\n            if (rMin > r[i])\n                rMin = r[i];\n\n            if (rMax < r[i])\n                rMax = r[i];\n        }\n    }\n    while (rMin < 0 || rMax > 0x3f);\n\n    if (rMin == bias && rMax == bias && optFlatFields)\n    {\n        //\n        // Special case - all pixels have the same value.\n        // We encode this in 3 instead of 14 bytes by\n        // storing the value 0xfc in the third output byte,\n        // which cannot occur in the 14-byte encoding.\n        //\n\n        b[0] = (t[0] >> 8);\n        b[1] = (unsigned char) t[0];\n        b[2] = 0xfc;\n\n        return 3;\n    }\n\n    if (exactMax)\n    {\n        //\n        // Adjust t[0] so that the pixel whose value is equal\n        // to tMax gets represented as accurately as possible.\n        //\n\n        t[0] = tMax - (d[0] << shift);\n    }\n\n    //\n    // Pack t[0], shift and r[0] ... r[14] into 14 bytes:\n    //\n\n    b[ 0] = (t[0] >> 8);\n    b[ 1] = (unsigned char) t[0];\n\n    b[ 2] = (unsigned char) ((shift << 2) | (r[ 0] >> 4));\n    b[ 3] = (unsigned char) ((r[ 0] << 4) | (r[ 1] >> 2));\n    b[ 4] = (unsigned char) ((r[ 1] << 6) |  r[ 2]      );\n\n    b[ 5] = (unsigned char) ((r[ 3] << 2) | (r[ 4] >> 4));\n    b[ 6] = (unsigned char) ((r[ 4] << 4) | (r[ 5] >> 2));\n    b[ 7] = (unsigned char) ((r[ 5] << 6) |  r[ 6]      );\n\n    b[ 8] = (unsigned char) ((r[ 7] << 2) | (r[ 8] >> 4));\n    b[ 9] = (unsigned char) ((r[ 8] << 4) | (r[ 9] >> 2));\n    b[10] = (unsigned char) ((r[ 9] << 6) |  r[10]      );\n\n    b[11] = (unsigned char) ((r[11] << 2) | (r[12] >> 4));\n    b[12] = (unsigned char) ((r[12] << 4) | (r[13] >> 2));\n    b[13] = (unsigned char) ((r[13] << 6) |  r[14]      );\n\n    return 14;\n}\n\n\ninline\nvoid\nunpack14 (const unsigned char b[14], unsigned short s[16])\n{\n    //\n    // Unpack a 14-byte block into 4 by 4 16-bit pixels.\n    //\n\n    #if defined (DEBUG)\n\tassert (b[2] != 0xfc);\n    #endif\n\n    s[ 0] = (b[0] << 8) | b[1];\n\n    unsigned short shift = (b[ 2] >> 2);\n    unsigned short bias = (0x20u << shift);\n\n    s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3fu) << shift) - bias;\n    s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3fu) << shift) - bias;\n    s[12] = s[ 8] +   ((b[ 4]                       & 0x3fu) << shift) - bias;\n    \n    s[ 1] = s[ 0] +   ((unsigned int) (b[ 5] >> 2)           << shift) - bias;\n    s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3fu) << shift) - bias;\n    s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3fu) << shift) - bias;\n    s[13] = s[12] +   ((b[ 7]                       & 0x3fu) << shift) - bias;\n    \n    s[ 2] = s[ 1] +   ((unsigned int)(b[ 8] >> 2)            << shift) - bias;\n    s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3fu) << shift) - bias;\n    s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3fu) << shift) - bias;\n    s[14] = s[13] +   ((b[10]                       & 0x3fu) << shift) - bias;\n    \n    s[ 3] = s[ 2] +   ((unsigned int)(b[11] >> 2)            << shift) - bias;\n    s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3fu) << shift) - bias;\n    s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3fu) << shift) - bias;\n    s[15] = s[14] +   ((b[13]                       & 0x3fu) << shift) - bias;\n\n    for (int i = 0; i < 16; ++i)\n    {\n\tif (s[i] & 0x8000)\n\t    s[i] &= 0x7fff;\n\telse\n\t    s[i] = ~s[i];\n    }\n}\n\n\ninline\nvoid\nunpack3 (const unsigned char b[3], unsigned short s[16])\n{\n    //\n    // Unpack a 3-byte block into 4 by 4 identical 16-bit pixels.\n    //\n\n    #if defined (DEBUG)\n\tassert (b[2] == 0xfc);\n    #endif\n\n    s[0] = (b[0] << 8) | b[1];\n\n    if (s[0] & 0x8000)\n\ts[0] &= 0x7fff;\n    else\n\ts[0] = ~s[0];\n\n    for (int i = 1; i < 16; ++i)\n\ts[i] = s[0];\n}\n\n\nvoid\nnotEnoughData ()\n{\n    throw IEX_NAMESPACE::InputExc (\"Error decompressing data \"\n\t\t\t \"(input data are shorter than expected).\");\n}\n\n\nvoid\ntooMuchData ()\n{\n    throw IEX_NAMESPACE::InputExc (\"Error decompressing data \"\n\t\t\t \"(input data are longer than expected).\");\n}\n\n} // namespace\n\n\nstruct B44Compressor::ChannelData\n{\n    unsigned short *\tstart;\n    unsigned short *\tend;\n    int\t\t\tnx;\n    int\t\t\tny;\n    int\t\t\tys;\n    PixelType\t\ttype;\n    bool\t\tpLinear;\n    int\t\t\tsize;\n};\n\n\nB44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    // TODO: Remove this when we can change the ABI\n    (void)_maxScanLineSize;\n    //\n    // Allocate buffers for compressed an uncompressed pixel data,\n    // allocate a set of ChannelData structs to help speed up the\n    // compress() and uncompress() functions, below, and determine\n    // if uncompressed pixel data should be in native or Xdr format.\n    //\n\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize / sizeof(unsigned short), numScanLines),\n                         sizeof (unsigned short))];\n\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n\n    //\n    // Compressed data may be larger than the input data\n    //\n\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n\n    _channelData = new ChannelData[_numChans];\n\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n\n    const Box2i &dataWindow = hdr.dataWindow();\n\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n\n    //\n    // We can support uncompressed data in the machine's native\n    // format only if all image channels are of type HALF.\n    //\n\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}\n\n\nB44Compressor::~B44Compressor ()\n{\n    delete [] _tmpBuffer;\n    delete [] _outBuffer;\n    delete [] _channelData;\n}\n\n\nint\nB44Compressor::numScanLines () const\n{\n    return _numScanLines;\n}\n\n\nCompressor::Format\nB44Compressor::format () const\n{\n    return _format;\n}\n\n\nint\nB44Compressor::compress (const char *inPtr,\n\t\t\t int inSize,\n\t\t\t int minY,\n\t\t\t const char *&outPtr)\n{\n    return compress (inPtr,\n\t\t     inSize,\n\t\t     Box2i (V2i (_minX, minY),\n\t\t\t    V2i (_maxX, minY + numScanLines() - 1)),\n\t\t     outPtr);\n}\n\n\nint\nB44Compressor::compressTile (const char *inPtr,\n\t\t\t     int inSize,\n\t\t\t     IMATH_NAMESPACE::Box2i range,\n\t\t\t     const char *&outPtr)\n{\n    return compress (inPtr, inSize, range, outPtr);\n}\n\n\nint\nB44Compressor::uncompress (const char *inPtr,\n\t\t\t   int inSize,\n\t\t\t   int minY,\n\t\t\t   const char *&outPtr)\n{\n    return uncompress (inPtr,\n\t\t       inSize,\n\t\t       Box2i (V2i (_minX, minY),\n\t\t\t      V2i (_maxX, minY + numScanLines() - 1)),\n\t\t       outPtr);\n}\n\n\nint\nB44Compressor::uncompressTile (const char *inPtr,\n\t\t\t       int inSize,\n\t\t\t       IMATH_NAMESPACE::Box2i range,\n\t\t\t       const char *&outPtr)\n{\n    return uncompress (inPtr, inSize, range, outPtr);\n}\n\n\nint\nB44Compressor::compress (const char *inPtr,\n\t\t\t int inSize,\n\t\t\t IMATH_NAMESPACE::Box2i range,\n\t\t\t const char *&outPtr)\n{\n    //\n    // Compress a block of pixel data:  First copy the input pixels\n    // from the input buffer into _tmpBuffer, rearranging them such\n    // that blocks of 4x4 pixels of a single channel can be accessed\n    // conveniently.  Then compress each 4x4 block of HALF pixel data\n    // and append the result to the output buffer.  Copy UINT and\n    // FLOAT data to the output buffer without compressing them.\n    //\n\n    outPtr = _outBuffer;\n\n    if (inSize == 0)\n    {\n\t//\n\t// Special case - empty input buffer.\n\t//\n\n\treturn 0;\n    }\n\n    //\n    // For each channel, detemine how many pixels are stored\n    // in the input buffer, and where those pixels will be\n    // placed in _tmpBuffer.\n    //\n\n    int minX = range.min.x;\n    int maxX = min (range.max.x, _maxX);\n    int minY = range.min.y;\n    int maxY = min (range.max.y, _maxY);\n    \n    unsigned short *tmpBufferEnd = _tmpBuffer;\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = _channels.begin();\n\t c != _channels.end();\n\t ++c, ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tcd.start = tmpBufferEnd;\n\tcd.end = cd.start;\n\n\tcd.nx = numSamples (c.channel().xSampling, minX, maxX);\n\tcd.ny = numSamples (c.channel().ySampling, minY, maxY);\n\n\ttmpBufferEnd += cd.nx * cd.ny * cd.size;\n    }\n\n    if (_format == XDR)\n    {\n\t//\n\t// The data in the input buffer are in the machine-independent\n\t// Xdr format.  Copy the HALF channels into _tmpBuffer and\n\t// convert them back into native format for compression.\n\t// Copy UINT and FLOAT channels verbatim into _tmpBuffer.\n\t//\n\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tif (cd.type == HALF)\n\t\t{\n\t\t    for (int x = cd.nx; x > 0; --x)\n\t\t    {\n\t\t\tXdr::read <CharPtrIO> (inPtr, *cd.end);\n\t\t\t++cd.end;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    int n = cd.nx * cd.size;\n\t\t    memcpy (cd.end, inPtr, n * sizeof (unsigned short));\n\t\t    inPtr += n * sizeof (unsigned short);\n\t\t    cd.end += n;\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\t//\n\t// The input buffer contains only HALF channels, and they\n\t// are in native, machine-dependent format.  Copy the pixels\n\t// into _tmpBuffer.\n\t//\n\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\t#if defined (DEBUG)\n\t\t    assert (cd.type == HALF);\n\t\t#endif\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tint n = cd.nx * cd.size;\n\t\tmemcpy (cd.end, inPtr, n * sizeof (unsigned short));\n\t\tinPtr  += n * sizeof (unsigned short);\n\t\tcd.end += n;\n\t    }\n\t}\n    }\n\n    //\n    // The pixels for each channel have been packed into a contiguous\n    // block in _tmpBuffer.  HALF channels are in native format; UINT\n    // and FLOAT channels are in Xdr format.\n    //\n\n    #if defined (DEBUG)\n\n\tfor (int i = 1; i < _numChans; ++i)\n\t    assert (_channelData[i-1].end == _channelData[i].start);\n\n\tassert (_channelData[_numChans-1].end == tmpBufferEnd);\n\n    #endif\n\n    //\n    // For each HALF channel, split the data in _tmpBuffer into 4x4\n    // pixel blocks.  Compress each block and append the compressed\n    // data to the output buffer.\n    //\n    // UINT and FLOAT channels are copied from _tmpBuffer into the\n    // output buffer without further processing.\n    //\n\n    char *outEnd = _outBuffer;\n\n    for (int i = 0; i < _numChans; ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\t\n\tif (cd.type != HALF)\n\t{\n\t    //\n\t    // UINT or FLOAT channel.\n\t    //\n\n\t    int n = cd.nx * cd.ny * cd.size * sizeof (unsigned short);\n\t    memcpy (outEnd, cd.start, n);\n\t    outEnd += n;\n\n\t    continue;\n\t}\n\t\n\t//\n\t// HALF channel\n\t//\n\n\tfor (int y = 0; y < cd.ny; y += 4)\n\t{\n\t    //\n\t    // Copy the next 4x4 pixel block into array s.\n\t    // If the width, cd.nx, or the height, cd.ny, of\n\t    // the pixel data in _tmpBuffer is not divisible\n\t    // by 4, then pad the data by repeating the\n\t    // rightmost column and the bottom row.\n\t    // \n\n\t    unsigned short *row0 = cd.start + y * cd.nx;\n\t    unsigned short *row1 = row0 + cd.nx;\n\t    unsigned short *row2 = row1 + cd.nx;\n\t    unsigned short *row3 = row2 + cd.nx;\n\n\t    if (y + 3 >= cd.ny)\n\t    {\n\t\tif (y + 1 >= cd.ny)\n\t\t    row1 = row0;\n\n\t\tif (y + 2 >= cd.ny)\n\t\t    row2 = row1;\n\n\t\trow3 = row2;\n\t    }\n\n\t    for (int x = 0; x < cd.nx; x += 4)\n\t    {\n\t\tunsigned short s[16];\n\n\t\tif (x + 3 >= cd.nx)\n\t\t{\n\t\t    int n = cd.nx - x;\n\n\t\t    for (int i = 0; i < 4; ++i)\n\t\t    {\n\t\t\tint j = min (i, n - 1);\n\n\t\t\ts[i +  0] = row0[j];\n\t\t\ts[i +  4] = row1[j];\n\t\t\ts[i +  8] = row2[j];\n\t\t\ts[i + 12] = row3[j];\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    memcpy (&s[ 0], row0, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[ 4], row1, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[ 8], row2, 4 * sizeof (unsigned short));\n\t\t    memcpy (&s[12], row3, 4 * sizeof (unsigned short));\n\t\t}\n\n\t\trow0 += 4;\n\t\trow1 += 4;\n\t\trow2 += 4;\n\t\trow3 += 4;\n\n\t\t//\n\t\t// Compress the contents of array s and append the\n\t\t// results to the output buffer.\n\t\t//\n\n\t\tif (cd.pLinear)\n\t\t    convertFromLinear (s);\n\n\t\toutEnd += pack (s, (unsigned char *) outEnd,\n\t\t\t\t_optFlatFields, !cd.pLinear);\n\t    }\n\t}\n    }\n\n    return outEnd - _outBuffer;\n}\n\n\nint\nB44Compressor::uncompress (const char *inPtr,\n\t\t\t   int inSize,\n\t\t\t   IMATH_NAMESPACE::Box2i range,\n\t\t\t   const char *&outPtr)\n{\n    //\n    // This function is the reverse of the compress() function,\n    // above.  First all pixels are moved from the input buffer\n    // into _tmpBuffer.  UINT and FLOAT channels are copied\n    // verbatim; HALF channels are uncompressed in blocks of\n    // 4x4 pixels.  Then the pixels in _tmpBuffer are copied\n    // into the output buffer and rearranged such that the data\n    // for for each scan line form a contiguous block.\n    //\n\n    outPtr = _outBuffer;\n\n    if (inSize == 0)\n    {\n\treturn 0;\n    }\n\n    int minX = range.min.x;\n    int maxX = min (range.max.x, _maxX);\n    int minY = range.min.y;\n    int maxY = min (range.max.y, _maxY);\n    \n    unsigned short *tmpBufferEnd = _tmpBuffer;\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = _channels.begin();\n\t c != _channels.end();\n\t ++c, ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tcd.start = tmpBufferEnd;\n\tcd.end = cd.start;\n\n\tcd.nx = numSamples (c.channel().xSampling, minX, maxX);\n\tcd.ny = numSamples (c.channel().ySampling, minY, maxY);\n\n\ttmpBufferEnd += cd.nx * cd.ny * cd.size;\n    }\n\n    for (int i = 0; i < _numChans; ++i)\n    {\n\tChannelData &cd = _channelData[i];\n\n\tif (cd.type != HALF)\n\t{\n\t    //\n\t    // UINT or FLOAT channel.\n\t    //\n\n\t    int n = cd.nx * cd.ny * cd.size * sizeof (unsigned short);\n\n\t    if (inSize < n)\n\t\tnotEnoughData();\n\n\t    memcpy (cd.start, inPtr, n);\n\t    inPtr += n;\n\t    inSize -= n;\n\n\t    continue;\n\t}\n\n\t//\n\t// HALF channel\n\t//\n\n\tfor (int y = 0; y < cd.ny; y += 4)\n\t{\n\t    unsigned short *row0 = cd.start + y * cd.nx;\n\t    unsigned short *row1 = row0 + cd.nx;\n\t    unsigned short *row2 = row1 + cd.nx;\n\t    unsigned short *row3 = row2 + cd.nx;\n\n\t    for (int x = 0; x < cd.nx; x += 4)\n\t    {\n\t\tunsigned short s[16]; \n\n\t\tif (inSize < 3)\n\t\t    notEnoughData();\n\n                //\n                // If shift exponent is 63, call unpack14 (ignoring unused bits)\n                //\n\t\tif (((const unsigned char *)inPtr)[2] >= (13<<2) )\n\t\t{\n\t\t    unpack3 ((const unsigned char *)inPtr, s);\n\t\t    inPtr += 3;\n\t\t    inSize -= 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (inSize < 14)\n\t\t\tnotEnoughData();\n\n\t\t    unpack14 ((const unsigned char *)inPtr, s);\n\t\t    inPtr += 14;\n\t\t    inSize -= 14;\n\t\t}\n\n\t\tif (cd.pLinear)\n\t\t    convertToLinear (s);\n\n\t\tint n = (x + 3 < cd.nx)?\n\t\t\t    4 * sizeof (unsigned short) :\n\t\t\t    (cd.nx - x) * sizeof (unsigned short);\n\n\t\tif (y + 3 < cd.ny)\n\t\t{\n\t\t    memcpy (row0, &s[ 0], n);\n\t\t    memcpy (row1, &s[ 4], n);\n\t\t    memcpy (row2, &s[ 8], n);\n\t\t    memcpy (row3, &s[12], n);\n\t\t}\n\t\telse\n\t\t{\n\t\t    memcpy (row0, &s[ 0], n);\n\n\t\t    if (y + 1 < cd.ny)\n\t\t\tmemcpy (row1, &s[ 4], n);\n\n\t\t    if (y + 2 < cd.ny)\n\t\t\tmemcpy (row2, &s[ 8], n);\n\t\t}\n\n\t\trow0 += 4;\n\t\trow1 += 4;\n\t\trow2 += 4;\n\t\trow3 += 4;\n\t    }\n\t}\n    }\n\n    char *outEnd = _outBuffer;\n\n    if (_format == XDR)\n    {\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tif (cd.type == HALF)\n\t\t{\n\t\t    for (int x = cd.nx; x > 0; --x)\n\t\t    {\n\t\t\tXdr::write <CharPtrIO> (outEnd, *cd.end);\n\t\t\t++cd.end;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    int n = cd.nx * cd.size;\n\t\t    memcpy (outEnd, cd.end, n * sizeof (unsigned short));\n\t\t    outEnd += n * sizeof (unsigned short);\n\t\t    cd.end += n;\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (int y = minY; y <= maxY; ++y)\n\t{\n\t    for (int i = 0; i < _numChans; ++i)\n\t    {\n\t\tChannelData &cd = _channelData[i];\n\n\t\t#if defined (DEBUG)\n\t\t    assert (cd.type == HALF);\n\t\t#endif\n\n\t\tif (modp (y, cd.ys) != 0)\n\t\t    continue;\n\n\t\tint n = cd.nx * cd.size;\n\t\tmemcpy (outEnd, cd.end, n * sizeof (unsigned short));\n\t\toutEnd += n * sizeof (unsigned short);\n\t\tcd.end += n;\n\t    }\n\t}\n    }\n\n    #if defined (DEBUG)\n\n\tfor (int i = 1; i < _numChans; ++i)\n\t    assert (_channelData[i-1].end == _channelData[i].start);\n\n\tassert (_channelData[_numChans-1].end == tmpBufferEnd);\n\n    #endif\n\n    if (inSize > 0)\n\ttooMuchData();\n\n    outPtr = _outBuffer;\n    return outEnd - _outBuffer;\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n"], "filenames": ["OpenEXR/IlmImf/ImfB44Compressor.cpp"], "buggy_code_start_loc": [497], "buggy_code_end_loc": [498], "fixing_code_start_loc": [497], "fixing_code_end_loc": [498], "type": "CWE-787", "message": "A flaw was found in OpenEXR's B44Compressor. This flaw allows an attacker who can submit a crafted file to be processed by OpenEXR, to exhaust all memory accessible to the application. The highest threat from this vulnerability is to system availability.", "other": {"cve": {"id": "CVE-2021-20298", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T16:15:09.020", "lastModified": "2022-12-13T02:24:50.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in OpenEXR's B44Compressor. This flaw allows an attacker who can submit a crafted file to be processed by OpenEXR, to exhaust all memory accessible to the application. The highest threat from this vulnerability is to system availability."}, {"lang": "es", "value": "Se ha encontrado un fallo en B44Compressor de OpenEXR. Este fallo permite a un atacante que puede enviar un archivo dise\u00f1ado para ser procesado por OpenEXR, agotar toda la memoria accesible a la aplicaci\u00f3n. La mayor amenaza de esta vulnerabilidad es la disponibilidad del sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openexr:openexr:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.7", "matchCriteriaId": "5AA57D0D-80D4-442D-8686-698527811EA4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-20298", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25913", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1939156", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/commit/85fd638ae0d5fa132434f4cbf32590261c1dba97", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/pull/843", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/12/msg00022.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/85fd638ae0d5fa132434f4cbf32590261c1dba97"}}