{"buggy_code": ["/*\n * radius.c\tFunctions to send/receive radius packets.\n *\n * Version:\t$Id$\n *\n *   This library is free software; you can redistribute it and/or\n *   modify it under the terms of the GNU Lesser General Public\n *   License as published by the Free Software Foundation; either\n *   version 2.1 of the License, or (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n *   Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public\n *   License along with this library; if not, write to the Free Software\n *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n *\n * Copyright 2000-2003  The FreeRADIUS server project\n */\n\nstatic const char rcsid[] = \"$Id$\";\n\n#include\t\"autoconf.h\"\n#include\t\"md5.h\"\n\n#include\t<stdlib.h>\n\n#ifdef HAVE_UNISTD_H\n#include\t<unistd.h>\n#endif\n\n#include\t<fcntl.h>\n#include\t<string.h>\n#include\t<ctype.h>\n\n#include\t\"libradius.h\"\n#ifdef WITH_UDPFROMTO\n#include\t\"udpfromto.h\"\n#endif\n\n#ifdef HAVE_NETINET_IN_H\n#include\t<netinet/in.h>\n#endif\n\n#include\t<sys/socket.h>\n\n#ifdef HAVE_ARPA_INET_H\n#include\t<arpa/inet.h>\n#endif\n\n#ifdef HAVE_MALLOC_H\n#include\t<malloc.h>\n#endif\n\n#ifdef WIN32\n#include\t<process.h>\n#endif\n\n/*\n *  The RFC says 4096 octets max, and most packets are less than 256.\n */\n#define MAX_PACKET_LEN 4096\n\n/*\n *\tThe maximum number of attributes which we allow in an incoming\n *\trequest.  If there are more attributes than this, the request\n *\tis rejected.\n *\n *\tThis helps to minimize the potential for a DoS, when an\n *\tattacker spoofs Access-Request packets, which don't have a\n *\tMessage-Authenticator attribute.  This means that the packet\n *\tis unsigned, and the attacker can use resources on the server,\n *\teven if the end request is rejected.\n */\nint librad_max_attributes = 0;\n\ntypedef struct radius_packet_t {\n  uint8_t\tcode;\n  uint8_t\tid;\n  uint8_t\tlength[2];\n  uint8_t\tvector[AUTH_VECTOR_LEN];\n  uint8_t\tdata[1];\n} radius_packet_t;\n\nstatic lrad_randctx lrad_rand_pool;\t/* across multiple calls */\nstatic volatile int lrad_rand_index = -1;\nstatic unsigned int salt_offset = 0;\n\nstatic const char *packet_codes[] = {\n  \"\",\n  \"Access-Request\",\n  \"Access-Accept\",\n  \"Access-Reject\",\n  \"Accounting-Request\",\n  \"Accounting-Response\",\n  \"Accounting-Status\",\n  \"Password-Request\",\n  \"Password-Accept\",\n  \"Password-Reject\",\n  \"Accounting-Message\",\n  \"Access-Challenge\",\n  \"Status-Server\",\n  \"Status-Client\",\n  \"14\",\n  \"15\",\n  \"16\",\n  \"17\",\n  \"18\",\n  \"19\",\n  \"20\",\n  \"Resource-Free-Request\",\n  \"Resource-Free-Response\",\n  \"Resource-Query-Request\",\n  \"Resource-Query-Response\",\n  \"Alternate-Resource-Reclaim-Request\",\n  \"NAS-Reboot-Request\",\n  \"NAS-Reboot-Response\",\n  \"28\",\n  \"Next-Passcode\",\n  \"New-Pin\",\n  \"Terminate-Session\",\n  \"Password-Expired\",\n  \"Event-Request\",\n  \"Event-Response\",\n  \"35\",\n  \"36\",\n  \"37\",\n  \"38\",\n  \"39\",\n  \"Disconnect-Request\",\n  \"Disconnect-ACK\",\n  \"Disconnect-NAK\",\n  \"CoA-Request\",\n  \"CoA-ACK\",\n  \"CoA-NAK\",\n  \"46\",\n  \"47\",\n  \"48\",\n  \"49\",\n  \"IP-Address-Allocate\",\n  \"IP-Address-Release\"\n};\n\n\n#define AUTH_PASS_LEN (AUTH_VECTOR_LEN)\n/*************************************************************************\n *\n *      Function: make_secret\n *\n *      Purpose: Build an encrypted secret value to return in a reply\n *               packet.  The secret is hidden by xoring with a MD5 digest\n *               created from the shared secret and the authentication\n *               vector.  We put them into MD5 in the reverse order from\n *               that used when encrypting passwords to RADIUS.\n *\n *************************************************************************/\nstatic void make_secret(uint8_t *digest, const uint8_t *vector,\n\t\t\tconst char *secret, const uint8_t *value)\n{\n\tMD5_CTX context;\n        int             i;\n\n\tMD5Init(&context);\n\tMD5Update(&context, vector, AUTH_VECTOR_LEN);\n\tMD5Update(&context, secret, strlen(secret));\n\tMD5Final(digest, &context);\n\n        for ( i = 0; i < AUTH_VECTOR_LEN; i++ ) {\n\t\tdigest[i] ^= value[i];\n        }\n}\n\n#define MAX_PASS_LEN (128)\nstatic void make_passwd(uint8_t *output, int *outlen,\n\t\t\tconst uint8_t *input, int inlen,\n\t\t\tconst char *secret, const uint8_t *vector)\n{\n\tMD5_CTX context, old;\n\tuint8_t\tdigest[AUTH_VECTOR_LEN];\n\tuint8_t passwd[MAX_PASS_LEN];\n\tint\ti, n;\n\tint\tlen;\n\n\t/*\n\t *\tIf the length is zero, round it up.\n\t */\n\tlen = inlen;\n\tif (len == 0) {\n\t\tlen = AUTH_PASS_LEN;\n\t}\n\telse if (len > MAX_PASS_LEN) len = MAX_PASS_LEN;\n\n\telse if ((len & 0x0f) != 0) {\n\t\tlen += 0x0f;\n\t\tlen &= ~0x0f;\n\t}\n\t*outlen = len;\n\n\tmemcpy(passwd, input, len);\n\tmemset(passwd + len, 0, sizeof(passwd) - len);\n\n\tMD5Init(&context);\n\tMD5Update(&context, secret, strlen(secret));\n\told = context;\n\n\t/*\n\t *\tDo first pass.\n\t */\n\tMD5Update(&context, vector, AUTH_PASS_LEN);\n\n\tfor (n = 0; n < len; n += AUTH_PASS_LEN) {\n\t\tif (n > 0) {\n\t\t\tcontext = old;\n\t\t\tMD5Update(&context,\n\t\t\t\t       passwd + n - AUTH_PASS_LEN,\n\t\t\t\t       AUTH_PASS_LEN);\n\t\t}\n\n\t\tMD5Final(digest, &context);\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++) {\n\t\t\tpasswd[i + n] ^= digest[i];\n\t\t}\n\t}\n\n\tmemcpy(output, passwd, len);\n}\n\nstatic void make_tunnel_passwd(uint8_t *output, int *outlen,\n\t\t\t       const uint8_t *input, int inlen, int room,\n\t\t\t       const char *secret, const uint8_t *vector)\n{\n\tMD5_CTX context, old;\n\tuint8_t\tdigest[AUTH_VECTOR_LEN];\n\tuint8_t passwd[MAX_STRING_LEN + AUTH_VECTOR_LEN];\n\tint\ti, n;\n\tint\tlen;\n\n\t/*\n\t *\tAccount for 2 bytes of the salt, and round the room\n\t *\tavailable down to the nearest multiple of 16.  Then,\n\t *\tsubtract one from that to account for the length byte,\n\t *\tand the resulting number is the upper bound on the data\n\t *\tto copy.\n\t *\n\t *\tWe could short-cut this calculation just be forcing\n\t *\tinlen to be no more than 239.  It would work for all\n\t *\tVSA's, as we don't pack multiple VSA's into one\n\t *\tattribute.\n\t *\n\t *\tHowever, this calculation is more general, if a little\n\t *\tcomplex.  And it will work in the future for all possible\n\t *\tkinds of weird attribute packing.\n\t */\n\troom -= 2;\n\troom -= (room & 0x0f);\n\troom--;\n\n\tif (inlen > room) inlen = room;\n\n\t/*\n\t *\tLength of the encrypted data is password length plus\n\t *\tone byte for the length of the password.\n\t */\n\tlen = inlen + 1;\n\tif ((len & 0x0f) != 0) {\n\t\tlen += 0x0f;\n\t\tlen &= ~0x0f;\n\t}\n\t*outlen = len + 2;\t/* account for the salt */\n\n\t/*\n\t *\tCopy the password over.\n\t */\n\tmemcpy(passwd + 3, input, inlen);\n\tmemset(passwd + 3 + inlen, 0, sizeof(passwd) - 3 - inlen);\n\n\t/*\n\t *\tGenerate salt.  The RFC's say:\n\t *\n\t *\tThe high bit of salt[0] must be set, each salt in a\n\t *\tpacket should be unique, and they should be random\n\t *\n\t *\tSo, we set the high bit, add in a counter, and then\n\t *\tadd in some CSPRNG data.  should be OK..\n\t */\n\tpasswd[0] = (0x80 | ( ((salt_offset++) & 0x0f) << 3) |\n\t\t     (lrad_rand() & 0x07));\n\tpasswd[1] = lrad_rand();\n\tpasswd[2] = inlen;\t/* length of the password string */\n\n\tMD5Init(&context);\n\tMD5Update(&context, secret, strlen(secret));\n\told = context;\n\n\tMD5Update(&context, vector, AUTH_VECTOR_LEN);\n\tMD5Update(&context, &passwd[0], 2);\n\n\tfor (n = 0; n < len; n += AUTH_PASS_LEN) {\n\t\tif (n > 0) {\n\t\t\tcontext = old;\n\t\t\tMD5Update(&context,\n\t\t\t\t       passwd + 2 + n - AUTH_PASS_LEN,\n\t\t\t\t       AUTH_PASS_LEN);\n\t\t}\n\n\t\tMD5Final(digest, &context);\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++) {\n\t\t\tpasswd[i + 2 + n] ^= digest[i];\n\t\t}\n\t}\n\tmemcpy(output, passwd, len + 2);\n}\n\n\n/*\n *\tParse a data structure into a RADIUS attribute.\n */\nint rad_vp2attr(const RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t\tconst char *secret, const VALUE_PAIR *vp, uint8_t *ptr)\n{\n\tint\t\tvendorcode;\n\tint\t\toffset, len, total_length;\n\tuint32_t\tlvalue;\n\tuint8_t\t\t*length_ptr, *vsa_length_ptr;\n\tconst uint8_t\t*data = NULL;\n\tuint8_t\t\tarray[4];\n\n\tvendorcode = total_length = 0;\n\tlength_ptr = vsa_length_ptr = NULL;\n\t\n\t/*\n\t *\tFor interoperability, always put vendor attributes\n\t *\tinto their own VSA.\n\t */\n\tif ((vendorcode = VENDOR(vp->attribute)) != 0) {\n\t\t/*\n\t\t *\tBuild a VSA header.\n\t\t */\n\t\t*ptr++ = PW_VENDOR_SPECIFIC;\n\t\tvsa_length_ptr = ptr;\n\t\t*ptr++ = 6;\n\t\tlvalue = htonl(vendorcode);\n\t\tmemcpy(ptr, &lvalue, 4);\n\t\tptr += 4;\n\t\ttotal_length += 6;\n\t\t\n\t\tif (vendorcode == VENDORPEC_USR) {\n\t\t\tlvalue = htonl(vp->attribute & 0xFFFF);\n\t\t\tmemcpy(ptr, &lvalue, 4);\n\t\t\t\n\t\t\tlength_ptr = vsa_length_ptr;\n\t\t\t\n\t\t\ttotal_length += 4;\n\t\t\t*length_ptr  += 4;\n\t\t\tptr          += 4;\n\t\t\t\n\t\t\t/*\n\t\t\t *\tWe don't have two different lengths.\n\t\t\t */\n\t\t\tvsa_length_ptr = NULL;\n\t\t\t\n\t\t} else if (vendorcode == VENDORPEC_LUCENT) {\n\t\t\t/*\n\t\t\t *\t16-bit attribute, 8-bit length\n\t\t\t */\n\t\t\t*ptr++ = ((vp->attribute >> 8) & 0xFF);\n\t\t\t*ptr++ = (vp->attribute & 0xFF);\n\t\t\tlength_ptr = ptr;\n\t\t\t*vsa_length_ptr += 3;\n\t\t\t*ptr++ = 3;\n\t\t\ttotal_length += 3;\n\n\t\t} else if (vendorcode == VENDORPEC_STARENT) {\n\t\t\t/*\n\t\t\t *\t16-bit attribute, 16-bit length\n\t\t\t *\twith the upper 8 bits of the length\n\t\t\t *\talways zero!\n\t\t\t */\n\t\t\t*ptr++ = ((vp->attribute >> 8) & 0xFF);\n\t\t\t*ptr++ = (vp->attribute & 0xFF);\n\t\t\t*ptr++ = 0;\n\t\t\tlength_ptr = ptr;\n\t\t\t*vsa_length_ptr += 4;\n\t\t\t*ptr++ = 4;\n\t\t\ttotal_length += 4;\n\t\t} else {\n\t\t\t/*\n\t\t\t *\tAll other VSA's are encoded the same\n\t\t\t *\tas RFC attributes.\n\t\t\t */\n\t\t\t*vsa_length_ptr += 2;\n\t\t\tgoto rfc;\n\t\t}\n\t} else {\n\trfc:\n\t\t/*\n\t\t *\tAll other attributes are encoded as\n\t\t *\tper the RFC.\n\t\t */\n\t\t*ptr++ = (vp->attribute & 0xFF);\n\t\tlength_ptr = ptr;\n\t\t*ptr++ = 2;\n\t\ttotal_length += 2;\n\t}\n\n\toffset = 0;\n\tif (vp->flags.has_tag) {\n\t\tif (TAG_VALID(vp->flags.tag)) {\n\t\t\tptr[0] = vp->flags.tag & 0xff;\n\t\t\toffset = 1;\n\t    \n\t\t} else if (vp->flags.encrypt == FLAG_ENCRYPT_TUNNEL_PASSWORD) {\n\t\t\t/*\n\t\t\t *\tTunnel passwords REQUIRE a tag, even\n\t\t\t *\tif don't have a valid tag.\n\t\t\t */\n\t\t\tptr[0] = 0;\n\t\t\toffset = 1;\n\t\t} /* else don't write a tag */\n\t} /* else the attribute doesn't have a tag */\n\t\n\t/*\n\t *\tSet up the default sources for the data.\n\t */\n\tdata = vp->strvalue;\n\tlen = vp->length;\n\n\t/*\n\t *\tEncrypted passwords can't be very long.\n\t *\tThis check also ensures that the hashed version\n\t *\tof the password + attribute header fits into one\n\t *\tattribute.\n\t *\n\t *\tFIXME: Print a warning message if it's too long?\n\t */\n\tif (vp->flags.encrypt && (len > MAX_PASS_LEN)) {\n\t\tlen = MAX_PASS_LEN;\n\t}\n\n\tswitch(vp->type) {\n\tcase PW_TYPE_STRING:\n\tcase PW_TYPE_OCTETS:\n\tcase PW_TYPE_IFID:\n\tcase PW_TYPE_IPV6ADDR:\n\tcase PW_TYPE_IPV6PREFIX:\n\tcase PW_TYPE_ABINARY:\n\t\t/* nothing more to do */\n\t\tbreak;\n\t\t\t\n\tcase PW_TYPE_INTEGER:\n\t\tlen = 4;\t/* just in case */\n\t\tlvalue = htonl(vp->lvalue);\n\t\tmemcpy(array, &lvalue, sizeof(lvalue));\n\n\t\t/*\n\t\t *\tPerhaps discard the first octet.\n\t\t */\n\t\tdata = &array[offset];\n\t\tlen -= offset;\n\t\tbreak;\n\t\t\t\n\tcase PW_TYPE_IPADDR:\n\t\tdata = (const uint8_t *) &vp->lvalue;\n\t\tlen = 4;\t/* just in case */\n\t\tbreak;\n\n\t\t/*\n\t\t *  There are no tagged date attributes.\n\t\t */\n\tcase PW_TYPE_DATE:\n\t\tlvalue = htonl(vp->lvalue);\n\t\tdata = (const uint8_t *) &lvalue;\n\t\tlen = 4;\t/* just in case */\n\t\tbreak;\n\n\tdefault:\t\t/* unknown type: ignore it */\n\t\tlibrad_log(\"ERROR: Unknown attribute type %d\", vp->type);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tBound the data to 255 bytes.\n\t */\n\tif (len + offset + total_length > 255) {\n\t\tlen = 255 - offset - total_length;\n\t}\t\n\n\t/*\n\t *\tEncrypt the various password styles\n\t *\n\t *\tAttributes with encrypted values MUST be less than\n\t *\t128 bytes long.\n\t */\n\tswitch (vp->flags.encrypt) {\n\tcase FLAG_ENCRYPT_USER_PASSWORD:\n\t\tmake_passwd(ptr + offset, &len,\n\t\t\t    data, len,\n\t\t\t    secret, packet->vector);\n\t\tbreak;\n\t\t\n\tcase FLAG_ENCRYPT_TUNNEL_PASSWORD:\n\t\tif (!original) {\n\t\t\tlibrad_log(\"ERROR: No request packet, cannot encrypt %s attribute in the vp.\", vp->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t *\tCheck if 255 - offset - total_length is less\n\t\t *\tthan 18.  If so, we can't fit the data into\n\t\t *\tthe available space, and we discard the\n\t\t *\tattribute.\n\t\t *\n\t\t *\tThis is ONLY a problem if we have multiple VSA's\n\t\t *\tin one Vendor-Specific, though.\n\t\t */\n\t\tif ((255 - offset - total_length) < 18) return 0;\n\n\t\t/*\n\t\t *\tCan't make the password, suppress it.\n\t\t */\n\t\tmake_tunnel_passwd(ptr + offset, &len,\n\t\t\t\t   data, len, 255 - offset - total_length,\n\t\t\t\t   secret, original->vector);\n\t\tbreak;\n\n\t\t/*\n\t\t *\tThe code above ensures that this attribute\n\t\t *\talways fits.\n\t\t */\n\tcase FLAG_ENCRYPT_ASCEND_SECRET:\n\t\tmake_secret(ptr + offset, packet->vector,\n\t\t\t    secret, data);\n\t\tlen = AUTH_VECTOR_LEN;\n\t\tbreak;\n\n\t\t\n\tdefault:\n\t\t/*\n\t\t *\tJust copy the data over\n\t\t */\n\t\tmemcpy(ptr + offset, data, len);\n\t\tbreak;\n\t} /* switch over encryption flags */\n\n\t/*\n\t *\tAccount for the tag (if any).\n\t */\n\tlen += offset;\n\n\t/*\n\t *\tRFC 2865 section 5 says that zero-length attributes\n\t *\tMUST NOT be sent.\n\t */\n\tif (len == 0) return 0;\n\n\t/*\n\t *\tUpdate the various lengths.\n\t */\n\t*length_ptr += len;\n\tif (vsa_length_ptr) *vsa_length_ptr += len;\n\tptr += len;\n\ttotal_length += len;\n\n\treturn total_length;\t/* of attribute */\n}\n\n\n/*\n *\tEncode a packet.\n */\nint rad_encode(RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t       const char *secret)\n{\n\tradius_packet_t\t*hdr;\n\tuint8_t\t        *ptr;\n\tuint16_t\ttotal_length;\n\tint\t\tlen;\n\tVALUE_PAIR\t*reply;\n\t\n\t/*\n\t *\tFor simplicity in the following logic, we allow\n\t *\tthe attributes to \"overflow\" the 4k maximum\n\t *\tRADIUS packet size, by one attribute.\n\t *\n\t *\tIt's uint32_t, for alignment purposes.\n\t */\n\tuint32_t\tdata[(MAX_PACKET_LEN + 256) / 4];\n\n\t/*\n\t *\tDouble-check some things based on packet code.\n\t */\n\tswitch (packet->code) {\n\tcase PW_AUTHENTICATION_ACK:\n\tcase PW_AUTHENTICATION_REJECT:\n\tcase PW_ACCESS_CHALLENGE:\n\t\tif (!original) {\n\t\t\tlibrad_log(\"ERROR: Cannot sign response packet without a request packet.\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tThese packet vectors start off as all zero.\n\t\t */\n\tcase PW_ACCOUNTING_REQUEST:\n\tcase PW_DISCONNECT_REQUEST:\n\tcase PW_COA_REQUEST:\n\t\tmemset(packet->vector, 0, sizeof(packet->vector));\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tbreak;\n\t}\n\t\t\n\t/*\n\t *\tUse memory on the stack, until we know how\n\t *\tlarge the packet will be.\n\t */\n\thdr = (radius_packet_t *) data;\n\t\n\t/*\n\t *\tBuild standard header\n\t */\n\thdr->code = packet->code;\n\thdr->id = packet->id;\n\t\n\tmemcpy(hdr->vector, packet->vector, sizeof(hdr->vector));\n\n\ttotal_length = AUTH_HDR_LEN;\n\tpacket->verified = 0;\n\t\n\t/*\n\t *\tLoad up the configuration values for the user\n\t */\n\tptr = hdr->data;\n\n\t/*\n\t *\tFIXME: Loop twice over the reply list.  The first time,\n\t *\tcalculate the total length of data.  The second time,\n\t *\tallocate the memory, and fill in the VP's.\n\t *\n\t *\tHmm... this may be slower than just doing a small\n\t *\tmemcpy.\n\t */\n\t\n\t/*\n\t *\tLoop over the reply attributes for the packet.\n\t */\n\tfor (reply = packet->vps; reply; reply = reply->next) {\n\t\t/*\n\t\t *\tIgnore non-wire attributes\n\t\t */\n\t\tif ((VENDOR(reply->attribute) == 0) &&\n\t\t    ((reply->attribute & 0xFFFF) > 0xff)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tSet the Message-Authenticator to the correct\n\t\t *\tlength and initial value.\n\t\t */\n\t\tif (reply->attribute == PW_MESSAGE_AUTHENTICATOR) {\n\t\t\treply->length = AUTH_VECTOR_LEN;\n\t\t\tmemset(reply->strvalue, 0, AUTH_VECTOR_LEN);\n\t\t\tpacket->verified = total_length; /* HACK! */\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tPrint out ONLY the attributes which\n\t\t *\twe're sending over the wire, and print\n\t\t *\tthem out BEFORE they're encrypted.\n\t\t */\n\t\tdebug_pair(reply);\n\n\t\tlen = rad_vp2attr(packet, original, secret, reply, ptr);\n\t\tif (len < 0) return -1;\n\n\t\t/*\n\t\t *\tCheck that the packet is no more than 4k in\n\t\t *\tsize, AFTER writing the attribute past the 4k\n\t\t *\tboundary, but BEFORE deciding to increase the\n\t\t *\tsize of the packet. Note that the 'data'\n\t\t *\tbuffer, above, is one attribute longer than\n\t\t *\tnecessary, in order to permit this overflow.\n\t\t */\n\t\tif ((total_length + len) > MAX_PACKET_LEN) {\n\t\t\tbreak;\n\t\t}\n\n\t\tptr += len;\n\t\ttotal_length += len;\n\t} /* done looping over all attributes */\n\t\n\t/*\n\t *\tFill in the rest of the fields, and copy the data over\n\t *\tfrom the local stack to the newly allocated memory.\n\t *\n\t *\tYes, all this 'memcpy' is slow, but it means\n\t *\tthat we only allocate the minimum amount of\n\t *\tmemory for a request.\n\t */\n\tpacket->data_len = total_length;\n\tpacket->data = (uint8_t *) malloc(packet->data_len);\n\tif (!packet->data) {\n\t\tlibrad_log(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data, data, packet->data_len);\n\thdr = (radius_packet_t *) packet->data;\n\t\n\ttotal_length = htons(total_length);\n\tmemcpy(hdr->length, &total_length, sizeof(total_length));\n\n\treturn 0;\n}\n\n\n/*\n *\tSign a previously encoded packet.\n */\nint rad_sign(RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t     const char *secret)\n{\n\tradius_packet_t\t*hdr = (radius_packet_t *)packet->data;\n\n\t/*\n\t *\tIt wasn't assigned an Id, this is bad!\n\t */\n\tif (packet->id < 0) {\n\t\tlibrad_log(\"ERROR: RADIUS packets must be assigned an Id.\");\n\t\treturn -1;\n\t}\n\n\tif (!packet->data || (packet->data_len < AUTH_HDR_LEN) ||\n\t    (packet->verified < 0)) {\n\t\tlibrad_log(\"ERROR: You must call rad_encode() before rad_sign()\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tIf there's a Message-Authenticator, update it\n\t *\tnow, BEFORE updating the authentication vector.\n\t *\n\t *\tThis is a hack...\n\t */\n\tif (packet->verified > 0) {\n\t\tuint8_t calc_auth_vector[AUTH_VECTOR_LEN];\n\t\t\n\t\tswitch (packet->code) {\n\t\tcase PW_ACCOUNTING_REQUEST:\n\t\tcase PW_ACCOUNTING_RESPONSE:\n\t\tcase PW_DISCONNECT_REQUEST:\n\t\tcase PW_DISCONNECT_ACK:\n\t\tcase PW_DISCONNECT_NAK:\n\t\tcase PW_COA_REQUEST:\n\t\tcase PW_COA_ACK:\n\t\tcase PW_COA_NAK:\n\t\t\tmemset(hdr->vector, 0, AUTH_VECTOR_LEN);\n\t\t\tbreak;\n\n\t\tcase PW_AUTHENTICATION_ACK:\n\t\tcase PW_AUTHENTICATION_REJECT:\n\t\tcase PW_ACCESS_CHALLENGE:\n\t\t\tif (!original) {\n\t\t\t\tlibrad_log(\"ERROR: Cannot sign response packet without a request packet.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmemcpy(hdr->vector, original->vector,\n\t\t\t       AUTH_VECTOR_LEN);\n\t\t\tbreak;\n\n\t\tdefault:\t/* others have vector already set to zero */\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tSet the authentication vector to zero,\n\t\t *\tcalculate the signature, and put it\n\t\t *\tinto the Message-Authenticator\n\t\t *\tattribute.\n\t\t */\n\t\tlrad_hmac_md5(packet->data, packet->data_len,\n\t\t\t      secret, strlen(secret),\n\t\t\t      calc_auth_vector);\n\t\tmemcpy(packet->data + packet->verified + 2,\n\t\t       calc_auth_vector, AUTH_VECTOR_LEN);\n\t\t\n\t\t/*\n\t\t *\tCopy the original request vector back\n\t\t *\tto the raw packet.\n\t\t */\n\t\tmemcpy(hdr->vector, packet->vector, AUTH_VECTOR_LEN);\n\t}\n\t\n\t/*\n\t *\tSwitch over the packet code, deciding how to\n\t *\tsign the packet.\n\t */\n\tswitch (packet->code) {\n\t\t/*\n\t\t *\tRequest packets are not signed, bur\n\t\t *\thave a random authentication vector.\n\t\t */\n\tcase PW_AUTHENTICATION_REQUEST:\n\tcase PW_STATUS_SERVER:\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tReply packets are signed with the\n\t\t *\tauthentication vector of the request.\n\t\t */\n\tdefault:\n\t\t{\n\t\t\tuint8_t digest[16];\n\t\t\t\n\t\t\tMD5_CTX\tcontext;\n\t\t\tMD5Init(&context);\n\t\t\tMD5Update(&context, packet->data, packet->data_len);\n\t\t\tMD5Update(&context, secret, strlen(secret));\n\t\t\tMD5Final(digest, &context);\n\t\t\t\n\t\t\tmemcpy(hdr->vector, digest, AUTH_VECTOR_LEN);\n\t\t\tmemcpy(packet->vector, digest, AUTH_VECTOR_LEN);\n\t\t\tbreak;\n\t\t}\n\t}/* switch over packet codes */\n\n\treturn 0;\n}\n\n/*\n *\tReply to the request.  Also attach\n *\treply attribute value pairs and any user message provided.\n */\nint rad_send(RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t     const char *secret)\n{\n\tVALUE_PAIR\t\t*reply;\n\tconst char\t\t*what;\n\tchar\t\t\tip_buffer[128];\n\tstruct\tsockaddr_in\tsaremote;\n\tstruct\tsockaddr_in\t*sa;\n\n\t/*\n\t *\tMaybe it's a fake packet.  Don't send it.\n\t */\n\tif (!packet || (packet->sockfd < 0)) {\n\t\treturn 0;\n\t}\n\n\tif ((packet->code > 0) && (packet->code < 52)) {\n\t\twhat = packet_codes[packet->code];\n\t} else {\n\t\twhat = \"Reply\";\n\t}\n\n\t/*\n\t *  First time through, allocate room for the packet\n\t */\n\tif (!packet->data) {\n\t\tDEBUG(\"Sending %s of id %d to %s port %d\\n\",\n\t\t      what, packet->id,\n\t\t      ip_ntoa(ip_buffer, packet->dst_ipaddr),\n\t\t      packet->dst_port);\n\t\t\n\t\t/*\n\t\t *\tEncode the packet.\n\t\t */\n\t\tif (rad_encode(packet, original, secret) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tRe-sign it, including updating the\n\t\t *\tMessage-Authenticator.\n\t\t */\n\t\tif (rad_sign(packet, original, secret) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t *\tIf packet->data points to data, then we print out\n\t\t *\tthe VP list again only for debugging.\n\t\t */\n\t} else if (librad_debug) {\n\t  \tDEBUG(\"Re-sending %s of id %d to %s port %d\\n\", what, packet->id,\n\t\t      ip_ntoa(ip_buffer, packet->dst_ipaddr),\n\t\t      packet->dst_port);\n\n\t\tfor (reply = packet->vps; reply; reply = reply->next) {\n\t\t\t/* FIXME: ignore attributes > 0xff */\n\t\t\tdebug_pair(reply);\n\t\t}\n\t}\n\n\t/*\n\t *\tAnd send it on it's way.\n\t */\n\tsa = (struct sockaddr_in *) &saremote;\n        memset ((char *) sa, '\\0', sizeof (saremote));\n\tsa->sin_family = AF_INET;\n\tsa->sin_addr.s_addr = packet->dst_ipaddr;\n\tsa->sin_port = htons(packet->dst_port);\n#ifndef WITH_UDPFROMTO\n\treturn sendto(packet->sockfd, packet->data, (int)packet->data_len, 0,\n\t\t      (struct sockaddr *)&saremote, sizeof(struct sockaddr_in));\n#else\n\t{\n\t\tstruct sockaddr_in salocal;\n\t\tmemset ((char *) &salocal, '\\0', sizeof (salocal));\n\t\tsalocal.sin_family = AF_INET;\n\t\tsalocal.sin_addr.s_addr = packet->src_ipaddr;\n\t\t\n\t\treturn sendfromto(packet->sockfd, packet->data, (int)packet->data_len, 0,\n\t\t\t\t  (struct sockaddr *)&salocal,  sizeof(struct sockaddr_in),\n\t\t\t\t  (struct sockaddr *)&saremote, sizeof(struct sockaddr_in));\n\t}\n#endif\n}\n\n\n/*\n *\tValidates the requesting client NAS.  Calculates the\n *\tsignature based on the clients private key.\n */\nstatic int calc_acctdigest(RADIUS_PACKET *packet, const char *secret)\n{\n\tu_char\t\tdigest[AUTH_VECTOR_LEN];\n\tMD5_CTX\t\tcontext;\n\n\t/*\n\t *\tOlder clients have the authentication vector set to\n\t *\tall zeros. Return `1' in that case.\n\t */\n\tmemset(digest, 0, sizeof(digest));\n\tif (memcmp(packet->vector, digest, AUTH_VECTOR_LEN) == 0) {\n\t\tpacket->verified = 1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t *\tZero out the auth_vector in the received packet.\n\t *\tThen append the shared secret to the received packet,\n\t *\tand calculate the MD5 sum. This must be the same\n\t *\tas the original MD5 sum (packet->vector).\n\t */\n\tmemset(packet->data + 4, 0, AUTH_VECTOR_LEN);\n\n\t/*\n\t *  MD5(packet + secret);\n\t */\n\tMD5Init(&context);\n\tMD5Update(&context, packet->data, packet->data_len);\n\tMD5Update(&context, secret, strlen(secret));\n\tMD5Final(digest, &context);\n\n\t/*\n\t *\tReturn 0 if OK, 2 if not OK.\n\t */\n\tpacket->verified =\n\tmemcmp(digest, packet->vector, AUTH_VECTOR_LEN) ? 2 : 0;\n\n\treturn packet->verified;\n}\n\n/*\n *\tValidates the requesting client NAS.  Calculates the\n *\tsignature based on the clients private key.\n */\nstatic int calc_replydigest(RADIUS_PACKET *packet, RADIUS_PACKET *original,\n\t\t\t    const char *secret)\n{\n\tuint8_t\t\tcalc_digest[AUTH_VECTOR_LEN];\n\tMD5_CTX\t\tcontext;\n\n\t/*\n\t *\tVery bad!\n\t */\n\tif (original == NULL) {\n\t\treturn 3;\n\t}\n\n\t/*\n\t *  Copy the original vector in place.\n\t */\n\tmemcpy(packet->data + 4, original->vector, AUTH_VECTOR_LEN);\n\n\t/*\n\t *  MD5(packet + secret);\n\t */\n\tMD5Init(&context);\n\tMD5Update(&context, packet->data, packet->data_len);\n\tMD5Update(&context, secret, strlen(secret));\n\tMD5Final(calc_digest, &context);\n\n\t/*\n\t *  Copy the packet's vector back to the packet.\n\t */\n\tmemcpy(packet->data + 4, packet->vector, AUTH_VECTOR_LEN);\n\n\t/*\n\t *\tReturn 0 if OK, 2 if not OK.\n\t */\n\tpacket->verified =\n\t\tmemcmp(packet->vector, calc_digest, AUTH_VECTOR_LEN) ? 2 : 0;\n\treturn packet->verified;\n}\n\n/*\n *\tReceive UDP client requests, and fill in\n *\tthe basics of a RADIUS_PACKET structure.\n */\nRADIUS_PACKET *rad_recv(int fd)\n{\n\tRADIUS_PACKET\t\t*packet;\n\tstruct sockaddr_in\tsaremote;\n\tint\t\t\ttotallen;\n\tsocklen_t\t\tsalen;\n\tuint8_t\t\t\t*attr;\n\tint\t\t\tcount;\n\tradius_packet_t\t\t*hdr;\n\tchar\t\t\thost_ipaddr[16];\n\tint\t\t\trequire_ma = 0;\n\tint\t\t\tseen_ma = 0;\n\tuint8_t\t\t\tdata[MAX_PACKET_LEN];\n\tint\t\t\tnum_attributes;\n\n\t/*\n\t *\tAllocate the new request data structure\n\t */\n\tif ((packet = malloc(sizeof(RADIUS_PACKET))) == NULL) {\n\t\tlibrad_log(\"out of memory\");\n\t\treturn NULL;\n\t}\n\tmemset(packet, 0, sizeof(RADIUS_PACKET));\n\n\t/*\n\t *\tReceive the packet.\n\t */\n\tsalen = sizeof(saremote);\n\tmemset(&saremote, 0, sizeof(saremote));\n#ifndef WITH_UDPFROMTO\n\tpacket->data_len = recvfrom(fd, data, sizeof(data),\n\t\t\t\t    0, (struct sockaddr *)&saremote, &salen);\n\tpacket->dst_ipaddr = htonl(INADDR_ANY); /* i.e. unknown */\n#else\n\t{\n\t\tsocklen_t\t\tsalen_local;\n\t\tstruct sockaddr_in\tsalocal;\n\t\tsalen_local = sizeof(salocal);\n\t\tmemset(&salocal, 0, sizeof(salocal));\n\t\tpacket->data_len = recvfromto(fd, data, sizeof(data), 0,\n\t\t\t\t\t      (struct sockaddr *)&saremote, &salen,\n\t\t\t\t\t      (struct sockaddr *)&salocal, &salen_local);\n\t\tpacket->dst_ipaddr = salocal.sin_addr.s_addr;\n\t}\n#endif\n\n\t/*\n\t *\tCheck for socket errors.\n\t */\n\tif (packet->data_len < 0) {\n\t\tlibrad_log(\"Error receiving packet: %s\", strerror(errno));\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tFill IP header fields.  We need these for the error\n\t *\tmessages which may come later.\n\t */\n\tpacket->sockfd = fd;\n\tpacket->src_ipaddr = saremote.sin_addr.s_addr;\n\tpacket->src_port = ntohs(saremote.sin_port);\n\n\t/*\n\t *\tFIXME: Do even more filtering by only permitting\n\t *\tcertain IP's.  The problem is that we don't know\n\t *\thow to do this properly for all possible clients...\n\t */\n\n\t/*\n\t *\tExplicitely set the VP list to empty.\n\t */\n\tpacket->vps = NULL;\n\n\t/*\n\t *\tCheck for packets smaller than the packet header.\n\t *\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\"The minimum length is 20 ...\"\n\t */\n\tif (packet->data_len < AUTH_HDR_LEN) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: too short (received %d < minimum %d)\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   packet->data_len, AUTH_HDR_LEN);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\" ... and maximum length is 4096.\"\n\t */\n\tif (packet->data_len > MAX_PACKET_LEN) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: too long (received %d > maximum %d)\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   packet->data_len, MAX_PACKET_LEN);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tCheck for packets with mismatched size.\n\t *\ti.e. We've received 128 bytes, and the packet header\n\t *\tsays it's 256 bytes long.\n\t */\n\ttotallen = (data[2] << 8) | data[3];\n\thdr = (radius_packet_t *)data;\n\n\t/*\n\t *\tCode of 0 is not understood.\n\t *\tCode of 16 or greate is not understood.\n\t */\n\tif ((hdr->code == 0) ||\n\t    (hdr->code >= 52)) {\n\t\tlibrad_log(\"WARNING: Bad RADIUS packet from host %s: unknown packet code %d\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   hdr->code);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tMessage-Authenticator is required in Status-Server\n\t *\tpackets, otherwise they can be trivially forged.\n\t */\n\tif (hdr->code == PW_STATUS_SERVER) require_ma = 1;\n\n\t/*\n\t *\tRepeat the length checks.  This time, instead of\n\t *\tlooking at the data we received, look at the value\n\t *\tof the 'length' field inside of the packet.\n\t *\n\t *\tCheck for packets smaller than the packet header.\n\t *\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\"The minimum length is 20 ...\"\n\t */\n\tif (totallen < AUTH_HDR_LEN) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: too short (length %d < minimum %d)\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   totallen, AUTH_HDR_LEN);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tAnd again, for the value of the 'length' field.\n\t *\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\" ... and maximum length is 4096.\"\n\t */\n\tif (totallen > MAX_PACKET_LEN) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: too long (length %d > maximum %d)\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   totallen, MAX_PACKET_LEN);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\"If the packet is shorter than the Length field\n\t *\tindicates, it MUST be silently discarded.\"\n\t *\n\t *\ti.e. No response to the NAS.\n\t */\n\tif (packet->data_len < totallen) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: received %d octets, packet length says %d\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   packet->data_len, totallen);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\"Octets outside the range of the Length field MUST be\n\t *\ttreated as padding and ignored on reception.\"\n\t */\n\tif (packet->data_len > totallen) {\n\t\t/*\n\t\t *\tWe're shortening the packet below, but just\n\t\t *\tto be paranoid, zero out the extra data.\n\t\t */\n\t\tmemset(data + totallen, 0, packet->data_len - totallen);\n\t\tpacket->data_len = totallen;\n\t}\n\n\t/*\n\t *\tWalk through the packet's attributes, ensuring that\n\t *\tthey add up EXACTLY to the size of the packet.\n\t *\n\t *\tIf they don't, then the attributes either under-fill\n\t *\tor over-fill the packet.  Any parsing of the packet\n\t *\tis impossible, and will result in unknown side effects.\n\t *\n\t *\tThis would ONLY happen with buggy RADIUS implementations,\n\t *\tor with an intentional attack.  Either way, we do NOT want\n\t *\tto be vulnerable to this problem.\n\t */\n\tattr = hdr->data;\n\tcount = totallen - AUTH_HDR_LEN;\n\tnum_attributes = 0;\n\n\twhile (count > 0) {\n\t\t/*\n\t\t *\tAttribute number zero is NOT defined.\n\t\t */\n\t\tif (attr[0] == 0) {\n\t\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: Invalid attribute 0\",\n\t\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr));\n\t\t\tfree(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t *\tAttributes are at LEAST as long as the ID & length\n\t\t *\tfields.  Anything shorter is an invalid attribute.\n\t\t */\n       \t\tif (attr[1] < 2) {\n\t\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: attribute %d too short\",\n\t\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t\t   attr[0]);\n\t\t\tfree(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t *\tSanity check the attributes for length.\n\t\t */\n\t\tswitch (attr[0]) {\n\t\tdefault:\t/* don't do anything by default */\n\t\t\tbreak;\n\n\n\t\t\t/*\n\t\t\t *\tIf there's an EAP-Message, we require\n\t\t\t *\ta Message-Authenticator.\n\t\t\t */\n\t\tcase PW_EAP_MESSAGE:\n\t\t\trequire_ma = 1;\n\t\t\tbreak;\n\n\t\tcase PW_MESSAGE_AUTHENTICATOR:\n\t\t\tif (attr[1] != 2 + AUTH_VECTOR_LEN) {\n\t\t\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: Message-Authenticator has invalid length %d\",\n\t\t\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t\t\t   attr[1] - 2);\n\t\t\t\tfree(packet);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tseen_ma = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t *\tFIXME: Look up the base 255 attributes in the\n\t\t *\tdictionary, and switch over their type.  For\n\t\t *\tinteger/date/ip, the attribute length SHOULD\n\t\t *\tbe 6.\n\t\t */\n\t\tcount -= attr[1];\t/* grab the attribute length */\n\t\tattr += attr[1];\n\t\tnum_attributes++;\t/* seen one more attribute */\n\t}\n\n\t/*\n\t *\tIf the attributes add up to a packet, it's allowed.\n\t *\n\t *\tIf not, we complain, and throw the packet away.\n\t */\n\tif (count != 0) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: packet attributes do NOT exactly fill the packet\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr));\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tIf we're configured to look for a maximum number of\n\t *\tattributes, and we've seen more than that maximum,\n\t *\tthen throw the packet away, as a possible DoS.\n\t */\n\tif ((librad_max_attributes > 0) &&\n\t    (num_attributes > librad_max_attributes)) {\n\t\tlibrad_log(\"WARNING: Possible DoS attack from host %s: Too many attributes in request (received %d, max %d are allowed).\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   num_attributes, librad_max_attributes);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * \thttp://www.freeradius.org/rfc/rfc2869.html#EAP-Message\n\t *\n\t *\tA packet with an EAP-Message attribute MUST also have\n\t *\ta Message-Authenticator attribute.\n\t *\n\t *\tA Message-Authenticator all by itself is OK, though.\n\t *\n\t *\tSimilarly, Status-Server packets MUST contain\n\t *\tMessage-Authenticator attributes.\n\t */\n\tif (require_ma && ! seen_ma) {\n\t\tlibrad_log(\"WARNING: Insecure packet from host %s:  Packet does not contain required Message-Authenticator attribute\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr));\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\tif (librad_debug) {\n\t\tif ((hdr->code > 0) && (hdr->code < 52)) {\n\t\t\tprintf(\"rad_recv: %s packet from host %s:%d\",\n\t\t\t       packet_codes[hdr->code],\n\t\t\t       ip_ntoa(host_ipaddr, packet->src_ipaddr), packet->src_port);\n\t\t} else {\n\t\t\tprintf(\"rad_recv: Packet from host %s:%d code=%d\",\n\t\t\t       ip_ntoa(host_ipaddr, packet->src_ipaddr), packet->src_port,\n\t\t\t       hdr->code);\n\t\t}\n\t\tprintf(\", id=%d, length=%d\\n\", hdr->id, totallen);\n\t}\n\n\t/*\n\t *\tFill RADIUS header fields\n\t */\n\tpacket->code = hdr->code;\n\tpacket->id = hdr->id;\n\tmemcpy(packet->vector, hdr->vector, AUTH_VECTOR_LEN);\n\n\t/*\n\t *  Now that we've sanity checked the packet, we can allocate\n\t *  memory for it, and copy the data from the local area to\n\t *  the packet buffer.\n\t */\n\tif ((packet->data = malloc(packet->data_len)) == NULL) {\n\t  free(packet);\n\t  librad_log(\"out of memory\");\n\t  return NULL;\n\t}\n\tmemcpy(packet->data, data, packet->data_len);\n\n\treturn packet;\n}\n\n\n/*\n *\tVerify the signature of a packet.\n */\nint rad_verify(RADIUS_PACKET *packet, RADIUS_PACKET *original,\n\t       const char *secret)\n{\n\tuint8_t\t\t\t*ptr;\n\tint\t\t\tlength;\n\tint\t\t\tattrlen;\n\n\tif (!packet || !packet->data) return -1;\n\n\t/*\n\t *\tBefore we allocate memory for the attributes, do more\n\t *\tsanity checking.\n\t */\n\tptr = packet->data + AUTH_HDR_LEN;\n\tlength = packet->data_len - AUTH_HDR_LEN;\n\twhile (length > 0) {\n\t\tuint8_t\tmsg_auth_vector[AUTH_VECTOR_LEN];\n\t\tuint8_t calc_auth_vector[AUTH_VECTOR_LEN];\n\n\t\tattrlen = ptr[1];\n\n\t\tswitch (ptr[0]) {\n\t\tdefault:\t/* don't do anything. */\n\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t *\tNote that more than one Message-Authenticator\n\t\t\t *\tattribute is invalid.\n\t\t\t */\n\t\tcase PW_MESSAGE_AUTHENTICATOR:\n\t\t\tmemcpy(msg_auth_vector, &ptr[2], sizeof(msg_auth_vector));\n\t\t\tmemset(&ptr[2], 0, AUTH_VECTOR_LEN);\n\n\t\t\tswitch (packet->code) {\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t\tcase PW_ACCOUNTING_REQUEST:\n\t\t\tcase PW_ACCOUNTING_RESPONSE:\n\t\t\tcase PW_DISCONNECT_REQUEST:\n\t\t\tcase PW_DISCONNECT_ACK:\n\t\t\tcase PW_DISCONNECT_NAK:\n\t\t\tcase PW_COA_REQUEST:\n\t\t\tcase PW_COA_ACK:\n\t\t\tcase PW_COA_NAK:\n\t\t\t  \tmemset(packet->data + 4, 0, AUTH_VECTOR_LEN);\n\t\t\t\tbreak;\n\n\t\t\tcase PW_AUTHENTICATION_ACK:\n\t\t\tcase PW_AUTHENTICATION_REJECT:\n\t\t\tcase PW_ACCESS_CHALLENGE:\n\t\t\t\tif (!original) {\n\t\t\t\t\tlibrad_log(\"ERROR: Cannot validate Message-Authenticator in response packet without a request packet.\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemcpy(packet->data + 4, original->vector, AUTH_VECTOR_LEN);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlrad_hmac_md5(packet->data, packet->data_len,\n\t\t\t\t      secret, strlen(secret), calc_auth_vector);\n\t\t\tif (memcmp(calc_auth_vector, msg_auth_vector,\n\t\t\t\t   sizeof(calc_auth_vector)) != 0) {\n\t\t\t\tchar buffer[32];\n\t\t\t\tlibrad_log(\"Received packet from %s with invalid Message-Authenticator!  (Shared secret is incorrect.)\",\n\t\t\t\t\t   ip_ntoa(buffer, packet->src_ipaddr));\n\t\t\t\t/* Silently drop packet, according to RFC 3579 */\n\t\t\t\treturn -2;\n\t\t\t} /* else the message authenticator was good */\n\n\t\t\t/*\n\t\t\t *\tReinitialize Authenticators.\n\t\t\t */\n\t\t\tmemcpy(&ptr[2], msg_auth_vector, AUTH_VECTOR_LEN);\n\t\t\tmemcpy(packet->data + 4, packet->vector, AUTH_VECTOR_LEN);\n\t\t\tbreak;\n\t\t} /* switch over the attributes */\n\n\t\tptr += attrlen;\n\t\tlength -= attrlen;\n\t} /* loop over the packet, sanity checking the attributes */\n\n\t/*\n\t *\tCalculate and/or verify digest.\n\t */\n\tswitch(packet->code) {\n\t\tint rcode;\n\n\t\tcase PW_AUTHENTICATION_REQUEST:\n\t\tcase PW_STATUS_SERVER:\n\t\tcase PW_DISCONNECT_REQUEST:\n\t\t\t/*\n\t\t\t *\tThe authentication vector is random\n\t\t\t *\tnonsense, invented by the client.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase PW_ACCOUNTING_REQUEST:\n\t\t\tif (calc_acctdigest(packet, secret) > 1) {\n\t\t\t\tchar buffer[32];\n\t\t\t\tlibrad_log(\"Received Accounting-Request packet \"\n\t\t\t\t\t   \"from %s with invalid signature!  (Shared secret is incorrect.)\",\n\t\t\t\t\t   ip_ntoa(buffer, packet->src_ipaddr));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Verify the reply digest */\n\t\tcase PW_AUTHENTICATION_ACK:\n\t\tcase PW_AUTHENTICATION_REJECT:\n\t\tcase PW_ACCESS_CHALLENGE:\n\t\tcase PW_ACCOUNTING_RESPONSE:\n\t\t\trcode = calc_replydigest(packet, original, secret);\n\t\t\tif (rcode > 1) {\n\t\t\t\tchar buffer[32];\n\t\t\t\tlibrad_log(\"Received %s packet \"\n\t\t\t\t\t   \"from client %s port %d with invalid signature (err=%d)!  (Shared secret is incorrect.)\",\n\t\t\t\t\t   packet_codes[packet->code],\n\t\t\t\t\t   ip_ntoa(buffer, packet->src_ipaddr),\n\t\t\t\t\t   packet->src_port,\n\t\t\t\t\t   rcode);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t  break;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n *\tParse a RADIUS attribute into a data structure.\n */\nstatic VALUE_PAIR *rad_attr2vp(const RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t\t\tconst char *secret, int attribute, int length,\n\t\t\tconst uint8_t *data)\n{\n\tint offset = 0;\n\tVALUE_PAIR *vp;\n\n\tif ((vp = paircreate(attribute, PW_TYPE_OCTETS)) == NULL) {\n\t\treturn NULL;\n\t}\n\t\n\t/*\n\t *\tIf length is greater than 253, something is SERIOUSLY\n\t *\twrong.\n\t */\n\tif (length > 253) length = 253;\t/* paranoia (pair-anoia?) */\n\n\tvp->length = length;\n\tvp->operator = T_OP_EQ;\n\tvp->next = NULL;\n\n\t/*\n\t *\tHandle tags.\n\t */\n\tif (vp->flags.has_tag) {\n\t\tif (TAG_VALID(data[0]) ||\n\t\t    (vp->flags.encrypt == FLAG_ENCRYPT_TUNNEL_PASSWORD)) {\n\t\t\t/*\n\t\t\t *\tTunnel passwords REQUIRE a tag, even\n\t\t\t *\tif don't have a valid tag.\n\t\t\t */\n\t\t\tvp->flags.tag = data[0];\n\n\t\t\tif ((vp->type == PW_TYPE_STRING) ||\n\t\t\t    (vp->type == PW_TYPE_OCTETS)) offset = 1;\n\t\t}\n\t}\n\n\t/*\n\t *\tCopy the data to be decrypted\n\t */\n\tmemcpy(&vp->strvalue[0], data + offset, length - offset);\n\tvp->length -= offset;\n\n\t/*\n\t *\tDecrypt the attribute.\n\t */\n\tswitch (vp->flags.encrypt) {\n\t\t/*\n\t\t *  User-Password\n\t\t */\n\tcase FLAG_ENCRYPT_USER_PASSWORD:\n\t\tif (original) {\n\t\t\trad_pwdecode((char *)vp->strvalue,\n\t\t\t\t     vp->length, secret,\n\t\t\t\t     original->vector);\n\t\t} else {\n\t\t\trad_pwdecode((char *)vp->strvalue,\n\t\t\t\t     vp->length, secret,\n\t\t\t\t     packet->vector);\n\t\t}\n\t\tif (vp->attribute == PW_USER_PASSWORD) {\n\t\t\tvp->length = strlen(vp->strvalue);\n\t\t}\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tTunnel-Password's may go ONLY\n\t\t *\tin response packets.\n\t\t */\n\tcase FLAG_ENCRYPT_TUNNEL_PASSWORD:\n\t\tif (!original) goto raw;\n\t\t\n\t\tif (rad_tunnel_pwdecode(vp->strvalue, &vp->length,\n\t\t\t\t\tsecret, original->vector) < 0) {\n\t\t\tgoto raw;\n\t\t}\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *  Ascend-Send-Secret\n\t\t *  Ascend-Receive-Secret\n\t\t */\n\tcase FLAG_ENCRYPT_ASCEND_SECRET:\n\t\tif (!original) {\n\t\t\tgoto raw;\n\t\t} else {\n\t\t\tuint8_t my_digest[AUTH_VECTOR_LEN];\n\t\t\tmake_secret(my_digest,\n\t\t\t\t    original->vector,\n\t\t\t\t    secret, data);\n\t\t\tmemcpy(vp->strvalue, my_digest,\n\t\t\t       AUTH_VECTOR_LEN );\n\t\t\tvp->strvalue[AUTH_VECTOR_LEN] = '\\0';\n\t\t\tvp->length = strlen(vp->strvalue);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t} /* switch over encryption flags */\n\n\n\tswitch (vp->type) {\n\tcase PW_TYPE_STRING:\n\tcase PW_TYPE_OCTETS:\n\tcase PW_TYPE_ABINARY:\n\t\t/* nothing more to do */\n\t\tbreak;\n\n\tcase PW_TYPE_INTEGER:\n\t\tif (vp->length != 4) goto raw;\n\n\t\tmemcpy(&vp->lvalue, vp->strvalue, 4);\n\t\tvp->lvalue = ntohl(vp->lvalue);\n\n\t\tif (vp->flags.has_tag) vp->lvalue &= 0x00ffffff;\n\n\t\t/*\n\t\t *\tTry to get named VALUEs\n\t\t */\n\t\t{\n\t\t\tDICT_VALUE *dval;\n\t\t\tdval = dict_valbyattr(vp->attribute,\n\t\t\t\t\t      vp->lvalue);\n\t\t\tif (dval) {\n\t\t\t\tstrNcpy(vp->strvalue,\n\t\t\t\t\tdval->name,\n\t\t\t\t\tsizeof(vp->strvalue));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase PW_TYPE_DATE:\n\t\tif (vp->length != 4) goto raw;\n\n\t\tmemcpy(&vp->lvalue, vp->strvalue, 4);\n\t\tvp->lvalue = ntohl(vp->lvalue);\n\t\tbreak;\n\n\t\t/*\n\t\t *\tIPv4 address. Keep it in network byte order in\n\t\t *\tvp->lvalue and put ASCII IP address in standard\n\t\t *\tdot notation into vp->strvalue.\n\t\t */\n\tcase PW_TYPE_IPADDR:\n\t\tif (vp->length != 4) goto raw;\n\n\t\tmemcpy(&vp->lvalue, vp->strvalue, 4);\n\t\tip_ntoa(vp->strvalue, vp->lvalue);\n\t\tbreak;\n\n\t\t/*\n\t\t *\tIPv6 interface ID is 8 octets long.\n\t\t */\n\tcase PW_TYPE_IFID:\n\t\tif (vp->length != 8) goto raw;\n\t\t/* vp->vp_ifid == vp->strvalue */\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tIPv6 addresses are 16 octets long\n\t\t */\n\tcase PW_TYPE_IPV6ADDR:\n\t\tif (vp->length != 16) goto raw;\n\t\t/* vp->vp_ipv6addr == vp->strvalue */\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tIPv6 prefixes are 2 to 18 octets long.\n\t\t *\n\t\t *\tRFC 3162: The first octet is unused.\n\t\t *\tThe second is the length of the prefix\n\t\t *\tthe rest are the prefix data.\n\t\t *\n\t\t *\tThe prefix length can have value 0 to 128.\n\t\t */\n\tcase PW_TYPE_IPV6PREFIX:\n\t\tif (vp->length < 2 || vp->length > 18) goto raw;\n\t\tif (vp->strvalue[1] > 128) goto raw;\n\n\t\t/*\n\t\t *\tFIXME: double-check that\n\t\t *\t(vp->strvalue[1] >> 3) matches vp->length + 2\n\t\t */\n\t\tif (vp->length < 18) {\n\t\t\tmemset(vp->strvalue + vp->length, 0,\n\t\t\t       18 - vp->length);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\traw:\n\t\tvp->type = PW_TYPE_OCTETS;\n\t\tvp->length = length;\n\t\tmemcpy(vp->strvalue, data, length);\n\t\t\n\n\t\t/*\n\t\t *\tEnsure there's no encryption or tag stuff,\n\t\t *\twe just pass the attribute as-is.\n\t\t */\n\t\tmemset(&vp->flags, 0, sizeof(vp->flags));\n\t}\n\n\treturn vp;\n}\n\n\n/*\n *\tCalculate/check digest, and decode radius attributes.\n */\nint rad_decode(RADIUS_PACKET *packet, RADIUS_PACKET *original,\n\t       const char *secret)\n{\n\tuint32_t\t\tlvalue;\n\tuint32_t\t\tvendorcode;\n\tVALUE_PAIR\t\t**tail;\n\tVALUE_PAIR\t\t*pair;\n\tuint8_t\t\t\t*ptr;\n\tint\t\t\tpacket_length;\n\tint\t\t\tattribute;\n\tint\t\t\tattrlen;\n\tint\t\t\tvendorlen;\n\tradius_packet_t\t\t*hdr;\n\tint\t\t\tvsa_tlen, vsa_llen;\n\tDICT_VENDOR\t\t*dv = NULL;\n\n\t/*\n\t *\tExtract attribute-value pairs\n\t */\n\thdr = (radius_packet_t *)packet->data;\n\tptr = hdr->data;\n\tpacket_length = packet->data_len - AUTH_HDR_LEN;\n\n\t/*\n\t *\tThere may be VP's already in the packet.  Don't\n\t *\tdestroy them.\n\t */\n\tfor (tail = &packet->vps; *tail != NULL; tail = &((*tail)->next)) {\n\t\t/* nothing */\n\t}\n\n\tvendorcode = 0;\n\tvendorlen  = 0;\n\tvsa_tlen = vsa_llen = 1;\n\n\t/*\n\t *\tWe have to read at least two bytes.\n\t *\n\t *\trad_recv() above ensures that this is OK.\n\t */\n\twhile (packet_length > 0) {\n\t\tattribute = -1;\n\t\tattrlen = -1;\n\n\t\t/*\n\t\t *\tNormal attribute, handle it like normal.\n\t\t */\n\t\tif (vendorcode == 0) {\n\t\t\t/*\n\t\t\t *\tNo room to read attr/length,\n\t\t\t *\tor bad attribute, or attribute is\n\t\t\t *\ttoo short, or attribute is too long,\n\t\t\t *\tstop processing the packet.\n\t\t\t */\n\t\t\tif ((packet_length < 2) ||\n\t\t\t    (ptr[0] == 0) ||  (ptr[1] < 2) ||\n\t\t\t    (ptr[1] > packet_length)) break;\n\n\t\t\tattribute = *ptr++;\n\t\t\tattrlen   = *ptr++;\n\n\t\t\tattrlen -= 2;\n\t\t\tpacket_length  -= 2;\n\n\t\t\tif (attribute != PW_VENDOR_SPECIFIC) goto create_pair;\n\t\t\t\n\t\t\t/*\n\t\t\t *\tNo vendor code, or ONLY vendor code.\n\t\t\t */\n\t\t\tif (attrlen <= 4) goto create_pair;\n\n\t\t\tvendorlen = 0;\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tHandle Vendor-Specific\n\t\t */\n\t\tif (vendorlen == 0) {\n\t\t\tuint8_t *subptr;\n\t\t\tint sublen;\n\t\t\tint myvendor;\n\t\t\t\n\t\t\t/*\n\t\t\t *\tattrlen was checked above.\n\t\t\t */\n\t\t\tmemcpy(&lvalue, ptr, 4);\n\t\t\tmyvendor = ntohl(lvalue);\n\n\t\t\t/*\n\t\t\t *\tZero isn't allowed.\n\t\t\t */\n\t\t\tif (myvendor == 0) goto create_pair;\n\t\t\t\n\t\t\t/*\n\t\t\t *\tThis is an implementation issue.\n\t\t\t *\tWe currently pack vendor into the upper\n\t\t\t *\t16 bits of a 32-bit attribute number,\n\t\t\t *\tso we can't handle vendor numbers larger\n\t\t\t *\tthan 16 bits.\n\t\t\t */\n\t\t\tif (myvendor > 65535) goto create_pair;\n\t\t\t\n\t\t\tvsa_tlen = vsa_llen = 1;\n\t\t\tdv = dict_vendorbyvalue(myvendor);\n\t\t\tif (dv) {\n\t\t\t\tvsa_tlen = dv->type;\n\t\t\t\tvsa_llen = dv->length;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t *\tSweep through the list of VSA's,\n\t\t\t *\tseeing if they exactly fill the\n\t\t\t *\touter Vendor-Specific attribute.\n\t\t\t *\n\t\t\t *\tIf not, create a raw Vendor-Specific.\n\t\t\t */\n\t\t\tsubptr = ptr + 4;\n\t\t\tsublen = attrlen - 4;\n\n\t\t\t/*\n\t\t\t *\tSee if we can parse it.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tint myattr = 0;\n\n\t\t\t\t/*\n\t\t\t\t *\tDon't have a type, it's bad.\n\t\t\t\t */\n\t\t\t\tif (sublen < vsa_tlen) goto create_pair;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t *\tEnsure that the attribute number\n\t\t\t\t *\tis OK.\n\t\t\t\t */\n\t\t\t\tswitch (vsa_tlen) {\n\t\t\t\tcase 1:\n\t\t\t\t\tmyattr = subptr[0];\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tmyattr = (subptr[0] << 8) | subptr[1];\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tif ((subptr[0] != 0) ||\n\t\t\t\t\t    (subptr[1] != 0)) goto create_pair;\n\t\t\t\t\t\n\t\t\t\t\tmyattr = (subptr[2] << 8) | subptr[3];\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t *\tOur dictionary is broken.\n\t\t\t\t\t */\n\t\t\t\tdefault:\n\t\t\t\t\tgoto create_pair;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t *\tNot enough room for one more\n\t\t\t\t *\tattribute.  Die!\n\t\t\t\t */\n\t\t\t\tif (sublen < vsa_tlen + vsa_llen) goto create_pair;\n\t\t\t\tswitch (vsa_llen) {\n\t\t\t\tcase 0:\n\t\t\t\t\tattribute = (myvendor << 16) | myattr;\n\t\t\t\t\tptr += 4 + vsa_tlen;\n\t\t\t\t\tattrlen -= (4 + vsa_tlen);\n\t\t\t\t\tpacket_length -= 4 + vsa_tlen;\n\t\t\t\t\tgoto create_pair;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tif (subptr[vsa_tlen] < (vsa_tlen + vsa_llen))\n\t\t\t\t\t\tgoto create_pair;\n\n\t\t\t\t\tif (subptr[vsa_tlen] > sublen)\n\t\t\t\t\t\tgoto create_pair;\n\t\t\t\t\tsublen -= subptr[vsa_tlen];\n\t\t\t\t\tsubptr += subptr[vsa_tlen];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tif (subptr[vsa_tlen] != 0) goto create_pair;\n\t\t\t\t\tif (subptr[vsa_tlen + 1] < (vsa_tlen + vsa_llen))\n\t\t\t\t\t\tgoto create_pair;\n\t\t\t\t\tif (subptr[vsa_tlen + 1] > sublen)\n\t\t\t\t\t\tgoto create_pair;\n\t\t\t\t\tsublen -= subptr[vsa_tlen + 1];\n\t\t\t\t\tsubptr += subptr[vsa_tlen + 1];\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t/*\n\t\t\t\t\t *\tOur dictionaries are\n\t\t\t\t\t *\tbroken.\n\t\t\t\t\t */\n\t\t\t\tdefault:\n\t\t\t\t\tgoto create_pair;\n\t\t\t\t}\n\t\t\t} while (sublen > 0);\n\n\t\t\tvendorcode = myvendor;\n\t\t\tvendorlen = attrlen - 4;\n\t\t\tpacket_length -= 4;\n\n\t\t\tptr += 4;\n\t\t}\n\n\t\t/*\n\t\t *\tattrlen is the length of this attribute.\n\t\t *\ttotal_len is the length of the encompassing\n\t\t *\tattribute.\n\t\t */\n\t\tswitch (vsa_tlen) {\n\t\tcase 1:\n\t\t\tattribute = ptr[0];\n\t\t\tbreak;\n\t\t\t\n\t\tcase 2:\n\t\t\tattribute = (ptr[0] << 8) | ptr[1];\n\t\t\tbreak;\n\n\t\tdefault:\t/* can't hit this. */\n\t\t\treturn -1;\n\t\t}\n\t\tattribute |= (vendorcode << 16);\n\t\tptr += vsa_tlen;\n\n\t\tswitch (vsa_llen) {\n\t\tcase 1:\n\t\t\tattrlen = ptr[0] - (vsa_tlen + vsa_llen);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 2:\n\t\t\tattrlen = ptr[1] - (vsa_tlen + vsa_llen);\n\t\t\tbreak;\n\n\t\tdefault:\t/* can't hit this. */\n\t\t\treturn -1;\n\t\t}\n\t\tptr += vsa_llen;\n\t\tvendorlen -= vsa_tlen + vsa_llen + attrlen;\n\t\tif (vendorlen == 0) vendorcode = 0;\n\t\tpacket_length -= (vsa_tlen + vsa_llen);\n\n\t\t/*\n\t\t *\tCreate the attribute, setting the default type\n\t\t *\tto 'octects'.  If the type in the dictionary\n\t\t *\tis different, then the dictionary type will\n\t\t *\tover-ride this one.\n\t\t */\n\tcreate_pair:\n\t\tpair = rad_attr2vp(packet, original, secret,\n\t\t\t\t attribute, attrlen, ptr);\n\t\tif (!pair) {\n\t\t\tpairfree(&packet->vps);\n\t\t\tlibrad_log(\"out of memory\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tdebug_pair(pair);\n\t\t*tail = pair;\n\t\ttail = &pair->next;\n\n\t\tptr += attrlen;\n\t\tpacket_length -= attrlen;\n\t}\n\n\t/*\n\t *\tMerge information from the outside world into our\n\t *\trandom pool.\n\t */\n\tlrad_rand_seed(packet->data, AUTH_HDR_LEN);\n\t  \n\treturn 0;\n}\n\n\n/*\n *\tEncode password.\n *\n *\tWe assume that the passwd buffer passed is big enough.\n *\tRFC2138 says the password is max 128 chars, so the size\n *\tof the passwd buffer must be at least 129 characters.\n *\tPreferably it's just MAX_STRING_LEN.\n *\n *\tint *pwlen is updated to the new length of the encrypted\n *\tpassword - a multiple of 16 bytes.\n */\nint rad_pwencode(char *passwd, int *pwlen, const char *secret,\n\t\t const char *vector)\n{\n\tuint8_t\tbuffer[AUTH_VECTOR_LEN + MAX_STRING_LEN + 1];\n\tchar\tdigest[AUTH_VECTOR_LEN];\n\tint\ti, n, secretlen;\n\tint\tlen;\n\n\t/*\n\t *\tPad password to multiple of AUTH_PASS_LEN bytes.\n\t */\n\tlen = *pwlen;\n\tif (len > 128) len = 128;\n\t*pwlen = len;\n\tif (len % AUTH_PASS_LEN != 0) {\n\t\tn = AUTH_PASS_LEN - (len % AUTH_PASS_LEN);\n\t\tfor (i = len; n > 0; n--, i++)\n\t\t\tpasswd[i] = 0;\n\t\tlen = *pwlen = i;\n\n\t} else if (len == 0) {\n\t\tmemset(passwd, 0, AUTH_PASS_LEN);\n\t\t*pwlen = len = AUTH_PASS_LEN;\n\t}\n\n\t/*\n\t *\tUse the secret to setup the decryption digest\n\t */\n\tsecretlen = strlen(secret);\n\tmemcpy(buffer, secret, secretlen);\n\tmemcpy(buffer + secretlen, vector, AUTH_VECTOR_LEN);\n\tlibrad_md5_calc((u_char *)digest, buffer, secretlen + AUTH_VECTOR_LEN);\n\n\t/*\n\t *\tNow we can encode the password *in place*\n\t */\n\tfor (i = 0; i < AUTH_PASS_LEN; i++)\n\t\tpasswd[i] ^= digest[i];\n\n\tif (len <= AUTH_PASS_LEN) return 0;\n\n\t/*\n\t *\tLength > AUTH_PASS_LEN, so we need to use the extended\n\t *\talgorithm.\n\t */\n\tfor (n = 0; n < 128 && n <= (len - AUTH_PASS_LEN); n += AUTH_PASS_LEN) {\n\t\tmemcpy(buffer + secretlen, passwd + n, AUTH_PASS_LEN);\n\t\tlibrad_md5_calc((u_char *)digest, buffer, secretlen + AUTH_PASS_LEN);\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++)\n\t\t\tpasswd[i + n + AUTH_PASS_LEN] ^= digest[i];\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tDecode password.\n */\nint rad_pwdecode(char *passwd, int pwlen, const char *secret,\n\t\t const char *vector)\n{\n\tuint8_t\tbuffer[AUTH_VECTOR_LEN + MAX_STRING_LEN + 1];\n\tchar\tdigest[AUTH_VECTOR_LEN];\n\tchar\tr[AUTH_VECTOR_LEN];\n\tchar\t*s;\n\tint\ti, n, secretlen;\n\tint\trlen;\n\n\t/*\n\t *\tUse the secret to setup the decryption digest\n\t */\n\tsecretlen = strlen(secret);\n\tmemcpy(buffer, secret, secretlen);\n\tmemcpy(buffer + secretlen, vector, AUTH_VECTOR_LEN);\n\tlibrad_md5_calc((u_char *)digest, buffer, secretlen + AUTH_VECTOR_LEN);\n\n\t/*\n\t *\tNow we can decode the password *in place*\n\t */\n\tmemcpy(r, passwd, AUTH_PASS_LEN);\n\tfor (i = 0; i < AUTH_PASS_LEN && i < pwlen; i++)\n\t\tpasswd[i] ^= digest[i];\n\n\tif (pwlen <= AUTH_PASS_LEN) {\n\t\tpasswd[pwlen+1] = 0;\n\t\treturn pwlen;\n\t}\n\n\t/*\n\t *\tLength > AUTH_PASS_LEN, so we need to use the extended\n\t *\talgorithm.\n\t */\n\trlen = ((pwlen - 1) / AUTH_PASS_LEN) * AUTH_PASS_LEN;\n\n\tfor (n = rlen; n > 0; n -= AUTH_PASS_LEN ) {\n\t\ts = (n == AUTH_PASS_LEN) ? r : (passwd + n - AUTH_PASS_LEN);\n\t\tmemcpy(buffer + secretlen, s, AUTH_PASS_LEN);\n\t\tlibrad_md5_calc((u_char *)digest, buffer, secretlen + AUTH_PASS_LEN);\n\t\tfor (i = 0; i < AUTH_PASS_LEN && (i + n) < pwlen; i++)\n\t\t\tpasswd[i + n] ^= digest[i];\n\t}\n\tpasswd[pwlen] = 0;\n\n\treturn pwlen;\n}\n\n\n/*\n *\tEncode Tunnel-Password attributes when sending them out on the wire.\n *\n *\tint *pwlen is updated to the new length of the encrypted\n *\tpassword - a multiple of 16 bytes.\n *\n *      This is per RFC-2868 which adds a two char SALT to the initial intermediate\n *      value MD5 hash.\n */\nint rad_tunnel_pwencode(char *passwd, int *pwlen, const char *secret,\n\t\t\tconst char *vector)\n{\n\tuint8_t\tbuffer[AUTH_VECTOR_LEN + MAX_STRING_LEN + 3];\n\tunsigned char\tdigest[AUTH_VECTOR_LEN];\n\tchar*   salt;\n\tint\ti, n, secretlen;\n\tunsigned len, n2;\n\n\tlen = *pwlen;\n\n\tif (len > 127) len = 127;\n\t/*\n\t * Shift the password 3 positions right to place a salt and original\n\t * length, tag will be added automatically on packet send\n\t */\n\tfor (n=len ; n>=0 ; n--) passwd[n+3] = passwd[n];\n\tsalt = passwd;\n\tpasswd += 2;\n\t/*\n\t * save original password length as first password character;\n\t */\n\t*passwd = len;\n\tlen += 1;\n\n\n\t/*\n\t *\tGenerate salt.  The RFC's say:\n\t *\n\t *\tThe high bit of salt[0] must be set, each salt in a\n\t *\tpacket should be unique, and they should be random\n\t *\n\t *\tSo, we set the high bit, add in a counter, and then\n\t *\tadd in some CSPRNG data.  should be OK..\n\t */\n\tsalt[0] = (0x80 | ( ((salt_offset++) & 0x0f) << 3) |\n\t\t   (lrad_rand() & 0x07));\n\tsalt[1] = lrad_rand();\n\n\t/*\n\t *\tPadd password to multiple of AUTH_PASS_LEN bytes.\n\t */\n\tn = len % AUTH_PASS_LEN;\n\tif (n) {\n\t\tn = AUTH_PASS_LEN - n;\n\t\tfor (; n > 0; n--, len++)\n\t\t\tpasswd[len] = 0;\n\t}\n\t/* set new password length */\n\t*pwlen = len + 2;\n\n\t/*\n\t *\tUse the secret to setup the decryption digest\n\t */\n\tsecretlen = strlen(secret);\n\tmemcpy(buffer, secret, secretlen);\n\n\tfor (n2 = 0; n2 < len; n2+=AUTH_PASS_LEN) {\n\t\tif (!n2) {\n\t\t\tmemcpy(buffer + secretlen, vector, AUTH_VECTOR_LEN);\n\t\t\tmemcpy(buffer + secretlen + AUTH_VECTOR_LEN, salt, 2);\n\t\t\tlibrad_md5_calc(digest, buffer, secretlen + AUTH_VECTOR_LEN + 2);\n\t\t} else {\n\t\t\tmemcpy(buffer + secretlen, passwd + n2 - AUTH_PASS_LEN, AUTH_PASS_LEN);\n\t\t\tlibrad_md5_calc(digest, buffer, secretlen + AUTH_PASS_LEN);\n\t\t}\n\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++) {\n\t\t\tpasswd[i + n2] ^= digest[i];\n\t\t}\n\t}\n\tpasswd[n2] = 0;\n\treturn 0;\n}\n\n/*\n *\tDecode Tunnel-Password encrypted attributes.\n *\n *      Defined in RFC-2868, this uses a two char SALT along with the\n *      initial intermediate value, to differentiate it from the\n *      above.\n */\nint rad_tunnel_pwdecode(uint8_t *passwd, int *pwlen, const char *secret,\n\t\t\tconst char *vector)\n{\n\tuint8_t\t\tbuffer[AUTH_VECTOR_LEN + MAX_STRING_LEN + 3];\n\tuint8_t\t\tdigest[AUTH_VECTOR_LEN];\n\tuint8_t\t\tdecrypted[MAX_STRING_LEN + 1];\n\tint\t\tsecretlen;\n\tunsigned\ti, n, len;\n\n\tlen = *pwlen;\n\n\t/*\n\t *\tWe need at least a salt.\n\t */\n\tif (len < 2) {\n\t\tlibrad_log(\"tunnel password is too short\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tThere's a salt, but no password.  Or, there's a salt\n\t *\tand a 'data_len' octet.  It's wrong, but at least we\n\t *\tcan figure out what it means: the password is empty.\n\t *\n\t *\tNote that this means we ignore the 'data_len' field,\n\t *\tif the attribute length tells us that there's no\n\t *\tmore data.  So the 'data_len' field may be wrong,\n\t *\tbut that's ok...\n\t */\n\tif (len <= 3) {\n\t\tpasswd[0] = 0;\n\t\t*pwlen = 0;\n\t\treturn 0;\n\t}\n\n\tlen -= 2;\t\t/* discount the salt */\n\n\t/*\n\t *\tUse the secret to setup the decryption digest\n\t */\n\tsecretlen = strlen(secret);\n\n\t/*\n\t *\tSet up the initial key:\n\t *\n\t *\t b(1) = MD5(secret + vector + salt)\n\t */\n\tmemcpy(buffer, secret, secretlen);\n\tmemcpy(buffer + secretlen, vector, AUTH_VECTOR_LEN);\n\tmemcpy(buffer + secretlen + AUTH_VECTOR_LEN, passwd, 2);\n\tlibrad_md5_calc(digest, buffer, secretlen + AUTH_VECTOR_LEN + 2);\n\n\t/*\n\t *\tA quick check: decrypt the first octet of the password,\n\t *\twhich is the 'data_len' field.  Ensure it's sane.\n\t *\n\t *\t'n' doesn't include the 'data_len' octet\n\t *\t'len' does.\n\t */\n\tn = passwd[2] ^ digest[0];\n\tif (n >= len) {\n\t\tlibrad_log(\"tunnel password is too long for the attribute\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tLoop over the data, decrypting it, and generating\n\t *\tthe key for the next round of decryption.\n\t */\n\tfor (n = 0; n < len; n += AUTH_PASS_LEN) {\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++) {\n\t\t\tdecrypted[n + i] = passwd[n + i + 2] ^ digest[i];\n\n\t\t\t/*\n\t\t\t *\tEncrypted password may not be aligned\n\t\t\t *\ton 16 octets, so we catch that here...\n\t\t\t */\n\t\t\tif ((n + i) == len) break;\n\t\t}\n\n\t\t/*\n\t\t *\tUpdate the digest, based on\n\t\t *\n\t\t *\tb(n) = MD5(secret + cleartext(n-1)\n\t\t *\n\t\t *\tbut only if there's more data...\n\t\t */\n\t\tmemcpy(buffer + secretlen, passwd + n + 2, AUTH_PASS_LEN);\n\t\tlibrad_md5_calc(digest, buffer, secretlen + AUTH_PASS_LEN);\n\t}\n\n\t/*\n\t *\tWe've already validated the length of the decrypted\n\t *\tpassword.  Copy it back to the caller.\n\t */\n\tmemcpy(passwd, decrypted + 1, decrypted[0]);\n\tpasswd[decrypted[0]] = 0;\n\t*pwlen = decrypted[0];\n\n\treturn decrypted[0];\n}\n\n/*\n *\tEncode a CHAP password\n *\n *\tFIXME: might not work with Ascend because\n *\twe use vp->length, and Ascend gear likes\n *\tto send an extra '\\0' in the string!\n */\nint rad_chap_encode(RADIUS_PACKET *packet, char *output, int id,\n\t\t    VALUE_PAIR *password)\n{\n\tint\t\ti;\n\tchar\t\t*ptr;\n\tchar\t\tstring[MAX_STRING_LEN * 2 + 1];\n\tVALUE_PAIR\t*challenge;\n\n\t/*\n\t *\tSanity check the input parameters\n\t */\n\tif ((packet == NULL) || (password == NULL)) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tNote that the password VP can be EITHER\n\t *\ta User-Password attribute (from a check-item list),\n\t *\tor a CHAP-Password attribute (the client asking\n\t *\tthe library to encode it).\n\t */\n\n\ti = 0;\n\tptr = string;\n\t*ptr++ = id;\n\n\ti++;\n\tmemcpy(ptr, password->strvalue, password->length);\n\tptr += password->length;\n\ti += password->length;\n\n\t/*\n\t *\tUse Chap-Challenge pair if present,\n\t *\tRequest-Authenticator otherwise.\n\t */\n\tchallenge = pairfind(packet->vps, PW_CHAP_CHALLENGE);\n\tif (challenge) {\n\t\tmemcpy(ptr, challenge->strvalue, challenge->length);\n\t\ti += challenge->length;\n\t} else {\n\t\tmemcpy(ptr, packet->vector, AUTH_VECTOR_LEN);\n\t\ti += AUTH_VECTOR_LEN;\n\t}\n\n\t*output = id;\n\tlibrad_md5_calc((u_char *)output + 1, (u_char *)string, i);\n\n\treturn 0;\n}\n\n\n/*\n *\tSeed the random number generator.\n *\n *\tMay be called any number of times.\n */\nvoid lrad_rand_seed(const void *data, size_t size)\n{\n\tuint32_t hash;\n\n\t/*\n\t *\tEnsure that the pool is initialized.\n\t */\n\tif (lrad_rand_index < 0) {\n\t\tint fd;\n\t\t\n\t\tmemset(&lrad_rand_pool, 0, sizeof(lrad_rand_pool));\n\n\t\tfd = open(\"/dev/urandom\", O_RDONLY);\n\t\tif (fd >= 0) {\n\t\t\tsize_t total;\n\t\t\tssize_t this;\n\n\t\t\ttotal = this = 0;\n\t\t\twhile (total < sizeof(lrad_rand_pool.randrsl)) {\n\t\t\t\tthis = read(fd, lrad_rand_pool.randrsl,\n\t\t\t\t\t    sizeof(lrad_rand_pool.randrsl) - total);\n\t\t\t\tif ((this < 0) && (errno != EINTR)) break;\n\t\t\t\tif (this > 0) total += this;\n \t\t\t}\n\t\t\tclose(fd);\n\t\t} else {\n\t\t\tlrad_rand_pool.randrsl[0] = fd;\n\t\t\tlrad_rand_pool.randrsl[1] = time(NULL);\n\t\t\tlrad_rand_pool.randrsl[2] = errno;\n\t\t}\n\n\t\tlrad_randinit(&lrad_rand_pool, 1);\n\t\tlrad_rand_index = 0;\n\t}\n\n\tif (!data) return;\n\n\t/*\n\t *\tHash the user data\n\t */\n\thash = lrad_hash(data, size);\n\t\n\tlrad_rand_pool.randrsl[lrad_rand_index & 0xff] ^= hash;\n\tlrad_rand_index++;\n\tlrad_rand_index &= 0xff;\n\n\t/*\n\t *\tChurn the pool every so often after seeding it.\n\t */\n\tif (((int) (hash & 0xff)) == lrad_rand_index) {\n\t\tlrad_isaac(&lrad_rand_pool);\n\t}\n}\n\n\n/*\n *\tReturn a 32-bit random number.\n */\nuint32_t lrad_rand(void)\n{\n\tuint32_t num;\n\n\t/*\n\t *\tEnsure that the pool is initialized.\n\t */\n\tif (lrad_rand_index < 0) {\n\t\tlrad_rand_seed(NULL, 0);\n\t}\n\n\t/*\n\t *\tWe don't return data directly from the pool.\n\t *\tRather, we return a summary of the data.\n\t */\n\tnum = lrad_rand_pool.randrsl[lrad_rand_index & 0xff];\n\tlrad_rand_index++;\n\tlrad_rand_index &= 0xff;\n\n\t/*\n\t *\tEvery so often, churn the pool.\n\t */\n\tif (((int) (num & 0xff)) == lrad_rand_index) {\n\t\tlrad_isaac(&lrad_rand_pool);\n\t}\n\n\treturn num;\n}\n\n/*\n *\tAllocate a new RADIUS_PACKET\n */\nRADIUS_PACKET *rad_alloc(int newvector)\n{\n\tRADIUS_PACKET\t*rp;\n\n\tif ((rp = malloc(sizeof(RADIUS_PACKET))) == NULL) {\n\t\tlibrad_log(\"out of memory\");\n\t\treturn NULL;\n\t}\n\tmemset(rp, 0, sizeof(RADIUS_PACKET));\n\tif (newvector) {\n\t\tint i;\n\t\tuint32_t hash, base;\n\n\t\t/*\n\t\t *\tDon't expose the actual contents of the random\n\t\t *\tpool.\n\t\t */\n\t\tbase = lrad_rand();\n\t\tfor (i = 0; i < AUTH_VECTOR_LEN; i += sizeof(uint32_t)) {\n\t\t\thash = lrad_rand() ^ base;\n\t\t\tmemcpy(rp->vector + i, &hash, sizeof(hash));\n\t\t}\n\t}\n\tlrad_rand();\n\n\treturn rp;\n}\n\n/*\n *\tFree a RADIUS_PACKET\n */\nvoid rad_free(RADIUS_PACKET **radius_packet_ptr)\n{\n\tRADIUS_PACKET *radius_packet;\n\n\tif (!radius_packet_ptr) return;\n\tradius_packet = *radius_packet_ptr;\n\n\tif (radius_packet->data) free(radius_packet->data);\n\tif (radius_packet->vps) pairfree(&radius_packet->vps);\n\n\tfree(radius_packet);\n\n\t*radius_packet_ptr = NULL;\n}\n"], "fixing_code": ["/*\n * radius.c\tFunctions to send/receive radius packets.\n *\n * Version:\t$Id$\n *\n *   This library is free software; you can redistribute it and/or\n *   modify it under the terms of the GNU Lesser General Public\n *   License as published by the Free Software Foundation; either\n *   version 2.1 of the License, or (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n *   Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public\n *   License along with this library; if not, write to the Free Software\n *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n *\n * Copyright 2000-2003  The FreeRADIUS server project\n */\n\nstatic const char rcsid[] = \"$Id$\";\n\n#include\t\"autoconf.h\"\n#include\t\"md5.h\"\n\n#include\t<stdlib.h>\n\n#ifdef HAVE_UNISTD_H\n#include\t<unistd.h>\n#endif\n\n#include\t<fcntl.h>\n#include\t<string.h>\n#include\t<ctype.h>\n\n#include\t\"libradius.h\"\n#ifdef WITH_UDPFROMTO\n#include\t\"udpfromto.h\"\n#endif\n\n#ifdef HAVE_NETINET_IN_H\n#include\t<netinet/in.h>\n#endif\n\n#include\t<sys/socket.h>\n\n#ifdef HAVE_ARPA_INET_H\n#include\t<arpa/inet.h>\n#endif\n\n#ifdef HAVE_MALLOC_H\n#include\t<malloc.h>\n#endif\n\n#ifdef WIN32\n#include\t<process.h>\n#endif\n\n/*\n *  The RFC says 4096 octets max, and most packets are less than 256.\n */\n#define MAX_PACKET_LEN 4096\n\n/*\n *\tThe maximum number of attributes which we allow in an incoming\n *\trequest.  If there are more attributes than this, the request\n *\tis rejected.\n *\n *\tThis helps to minimize the potential for a DoS, when an\n *\tattacker spoofs Access-Request packets, which don't have a\n *\tMessage-Authenticator attribute.  This means that the packet\n *\tis unsigned, and the attacker can use resources on the server,\n *\teven if the end request is rejected.\n */\nint librad_max_attributes = 0;\n\ntypedef struct radius_packet_t {\n  uint8_t\tcode;\n  uint8_t\tid;\n  uint8_t\tlength[2];\n  uint8_t\tvector[AUTH_VECTOR_LEN];\n  uint8_t\tdata[1];\n} radius_packet_t;\n\nstatic lrad_randctx lrad_rand_pool;\t/* across multiple calls */\nstatic volatile int lrad_rand_index = -1;\nstatic unsigned int salt_offset = 0;\n\nstatic const char *packet_codes[] = {\n  \"\",\n  \"Access-Request\",\n  \"Access-Accept\",\n  \"Access-Reject\",\n  \"Accounting-Request\",\n  \"Accounting-Response\",\n  \"Accounting-Status\",\n  \"Password-Request\",\n  \"Password-Accept\",\n  \"Password-Reject\",\n  \"Accounting-Message\",\n  \"Access-Challenge\",\n  \"Status-Server\",\n  \"Status-Client\",\n  \"14\",\n  \"15\",\n  \"16\",\n  \"17\",\n  \"18\",\n  \"19\",\n  \"20\",\n  \"Resource-Free-Request\",\n  \"Resource-Free-Response\",\n  \"Resource-Query-Request\",\n  \"Resource-Query-Response\",\n  \"Alternate-Resource-Reclaim-Request\",\n  \"NAS-Reboot-Request\",\n  \"NAS-Reboot-Response\",\n  \"28\",\n  \"Next-Passcode\",\n  \"New-Pin\",\n  \"Terminate-Session\",\n  \"Password-Expired\",\n  \"Event-Request\",\n  \"Event-Response\",\n  \"35\",\n  \"36\",\n  \"37\",\n  \"38\",\n  \"39\",\n  \"Disconnect-Request\",\n  \"Disconnect-ACK\",\n  \"Disconnect-NAK\",\n  \"CoA-Request\",\n  \"CoA-ACK\",\n  \"CoA-NAK\",\n  \"46\",\n  \"47\",\n  \"48\",\n  \"49\",\n  \"IP-Address-Allocate\",\n  \"IP-Address-Release\"\n};\n\n\n#define AUTH_PASS_LEN (AUTH_VECTOR_LEN)\n/*************************************************************************\n *\n *      Function: make_secret\n *\n *      Purpose: Build an encrypted secret value to return in a reply\n *               packet.  The secret is hidden by xoring with a MD5 digest\n *               created from the shared secret and the authentication\n *               vector.  We put them into MD5 in the reverse order from\n *               that used when encrypting passwords to RADIUS.\n *\n *************************************************************************/\nstatic void make_secret(uint8_t *digest, const uint8_t *vector,\n\t\t\tconst char *secret, const uint8_t *value)\n{\n\tMD5_CTX context;\n        int             i;\n\n\tMD5Init(&context);\n\tMD5Update(&context, vector, AUTH_VECTOR_LEN);\n\tMD5Update(&context, secret, strlen(secret));\n\tMD5Final(digest, &context);\n\n        for ( i = 0; i < AUTH_VECTOR_LEN; i++ ) {\n\t\tdigest[i] ^= value[i];\n        }\n}\n\n#define MAX_PASS_LEN (128)\nstatic void make_passwd(uint8_t *output, int *outlen,\n\t\t\tconst uint8_t *input, int inlen,\n\t\t\tconst char *secret, const uint8_t *vector)\n{\n\tMD5_CTX context, old;\n\tuint8_t\tdigest[AUTH_VECTOR_LEN];\n\tuint8_t passwd[MAX_PASS_LEN];\n\tint\ti, n;\n\tint\tlen;\n\n\t/*\n\t *\tIf the length is zero, round it up.\n\t */\n\tlen = inlen;\n\tif (len == 0) {\n\t\tlen = AUTH_PASS_LEN;\n\t}\n\telse if (len > MAX_PASS_LEN) len = MAX_PASS_LEN;\n\n\telse if ((len & 0x0f) != 0) {\n\t\tlen += 0x0f;\n\t\tlen &= ~0x0f;\n\t}\n\t*outlen = len;\n\n\tmemcpy(passwd, input, len);\n\tmemset(passwd + len, 0, sizeof(passwd) - len);\n\n\tMD5Init(&context);\n\tMD5Update(&context, secret, strlen(secret));\n\told = context;\n\n\t/*\n\t *\tDo first pass.\n\t */\n\tMD5Update(&context, vector, AUTH_PASS_LEN);\n\n\tfor (n = 0; n < len; n += AUTH_PASS_LEN) {\n\t\tif (n > 0) {\n\t\t\tcontext = old;\n\t\t\tMD5Update(&context,\n\t\t\t\t       passwd + n - AUTH_PASS_LEN,\n\t\t\t\t       AUTH_PASS_LEN);\n\t\t}\n\n\t\tMD5Final(digest, &context);\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++) {\n\t\t\tpasswd[i + n] ^= digest[i];\n\t\t}\n\t}\n\n\tmemcpy(output, passwd, len);\n}\n\nstatic void make_tunnel_passwd(uint8_t *output, int *outlen,\n\t\t\t       const uint8_t *input, int inlen, int room,\n\t\t\t       const char *secret, const uint8_t *vector)\n{\n\tMD5_CTX context, old;\n\tuint8_t\tdigest[AUTH_VECTOR_LEN];\n\tuint8_t passwd[MAX_STRING_LEN + AUTH_VECTOR_LEN];\n\tint\ti, n;\n\tint\tlen;\n\n\t/*\n\t *\tAccount for 2 bytes of the salt, and round the room\n\t *\tavailable down to the nearest multiple of 16.  Then,\n\t *\tsubtract one from that to account for the length byte,\n\t *\tand the resulting number is the upper bound on the data\n\t *\tto copy.\n\t *\n\t *\tWe could short-cut this calculation just be forcing\n\t *\tinlen to be no more than 239.  It would work for all\n\t *\tVSA's, as we don't pack multiple VSA's into one\n\t *\tattribute.\n\t *\n\t *\tHowever, this calculation is more general, if a little\n\t *\tcomplex.  And it will work in the future for all possible\n\t *\tkinds of weird attribute packing.\n\t */\n\troom -= 2;\n\troom -= (room & 0x0f);\n\troom--;\n\n\tif (inlen > room) inlen = room;\n\n\t/*\n\t *\tLength of the encrypted data is password length plus\n\t *\tone byte for the length of the password.\n\t */\n\tlen = inlen + 1;\n\tif ((len & 0x0f) != 0) {\n\t\tlen += 0x0f;\n\t\tlen &= ~0x0f;\n\t}\n\t*outlen = len + 2;\t/* account for the salt */\n\n\t/*\n\t *\tCopy the password over.\n\t */\n\tmemcpy(passwd + 3, input, inlen);\n\tmemset(passwd + 3 + inlen, 0, sizeof(passwd) - 3 - inlen);\n\n\t/*\n\t *\tGenerate salt.  The RFC's say:\n\t *\n\t *\tThe high bit of salt[0] must be set, each salt in a\n\t *\tpacket should be unique, and they should be random\n\t *\n\t *\tSo, we set the high bit, add in a counter, and then\n\t *\tadd in some CSPRNG data.  should be OK..\n\t */\n\tpasswd[0] = (0x80 | ( ((salt_offset++) & 0x0f) << 3) |\n\t\t     (lrad_rand() & 0x07));\n\tpasswd[1] = lrad_rand();\n\tpasswd[2] = inlen;\t/* length of the password string */\n\n\tMD5Init(&context);\n\tMD5Update(&context, secret, strlen(secret));\n\told = context;\n\n\tMD5Update(&context, vector, AUTH_VECTOR_LEN);\n\tMD5Update(&context, &passwd[0], 2);\n\n\tfor (n = 0; n < len; n += AUTH_PASS_LEN) {\n\t\tif (n > 0) {\n\t\t\tcontext = old;\n\t\t\tMD5Update(&context,\n\t\t\t\t       passwd + 2 + n - AUTH_PASS_LEN,\n\t\t\t\t       AUTH_PASS_LEN);\n\t\t}\n\n\t\tMD5Final(digest, &context);\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++) {\n\t\t\tpasswd[i + 2 + n] ^= digest[i];\n\t\t}\n\t}\n\tmemcpy(output, passwd, len + 2);\n}\n\n\n/*\n *\tParse a data structure into a RADIUS attribute.\n */\nint rad_vp2attr(const RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t\tconst char *secret, const VALUE_PAIR *vp, uint8_t *ptr)\n{\n\tint\t\tvendorcode;\n\tint\t\toffset, len, total_length;\n\tuint32_t\tlvalue;\n\tuint8_t\t\t*length_ptr, *vsa_length_ptr;\n\tconst uint8_t\t*data = NULL;\n\tuint8_t\t\tarray[4];\n\n\tvendorcode = total_length = 0;\n\tlength_ptr = vsa_length_ptr = NULL;\n\t\n\t/*\n\t *\tFor interoperability, always put vendor attributes\n\t *\tinto their own VSA.\n\t */\n\tif ((vendorcode = VENDOR(vp->attribute)) != 0) {\n\t\t/*\n\t\t *\tBuild a VSA header.\n\t\t */\n\t\t*ptr++ = PW_VENDOR_SPECIFIC;\n\t\tvsa_length_ptr = ptr;\n\t\t*ptr++ = 6;\n\t\tlvalue = htonl(vendorcode);\n\t\tmemcpy(ptr, &lvalue, 4);\n\t\tptr += 4;\n\t\ttotal_length += 6;\n\t\t\n\t\tif (vendorcode == VENDORPEC_USR) {\n\t\t\tlvalue = htonl(vp->attribute & 0xFFFF);\n\t\t\tmemcpy(ptr, &lvalue, 4);\n\t\t\t\n\t\t\tlength_ptr = vsa_length_ptr;\n\t\t\t\n\t\t\ttotal_length += 4;\n\t\t\t*length_ptr  += 4;\n\t\t\tptr          += 4;\n\t\t\t\n\t\t\t/*\n\t\t\t *\tWe don't have two different lengths.\n\t\t\t */\n\t\t\tvsa_length_ptr = NULL;\n\t\t\t\n\t\t} else if (vendorcode == VENDORPEC_LUCENT) {\n\t\t\t/*\n\t\t\t *\t16-bit attribute, 8-bit length\n\t\t\t */\n\t\t\t*ptr++ = ((vp->attribute >> 8) & 0xFF);\n\t\t\t*ptr++ = (vp->attribute & 0xFF);\n\t\t\tlength_ptr = ptr;\n\t\t\t*vsa_length_ptr += 3;\n\t\t\t*ptr++ = 3;\n\t\t\ttotal_length += 3;\n\n\t\t} else if (vendorcode == VENDORPEC_STARENT) {\n\t\t\t/*\n\t\t\t *\t16-bit attribute, 16-bit length\n\t\t\t *\twith the upper 8 bits of the length\n\t\t\t *\talways zero!\n\t\t\t */\n\t\t\t*ptr++ = ((vp->attribute >> 8) & 0xFF);\n\t\t\t*ptr++ = (vp->attribute & 0xFF);\n\t\t\t*ptr++ = 0;\n\t\t\tlength_ptr = ptr;\n\t\t\t*vsa_length_ptr += 4;\n\t\t\t*ptr++ = 4;\n\t\t\ttotal_length += 4;\n\t\t} else {\n\t\t\t/*\n\t\t\t *\tAll other VSA's are encoded the same\n\t\t\t *\tas RFC attributes.\n\t\t\t */\n\t\t\t*vsa_length_ptr += 2;\n\t\t\tgoto rfc;\n\t\t}\n\t} else {\n\trfc:\n\t\t/*\n\t\t *\tAll other attributes are encoded as\n\t\t *\tper the RFC.\n\t\t */\n\t\t*ptr++ = (vp->attribute & 0xFF);\n\t\tlength_ptr = ptr;\n\t\t*ptr++ = 2;\n\t\ttotal_length += 2;\n\t}\n\n\toffset = 0;\n\tif (vp->flags.has_tag) {\n\t\tif (TAG_VALID(vp->flags.tag)) {\n\t\t\tptr[0] = vp->flags.tag & 0xff;\n\t\t\toffset = 1;\n\t    \n\t\t} else if (vp->flags.encrypt == FLAG_ENCRYPT_TUNNEL_PASSWORD) {\n\t\t\t/*\n\t\t\t *\tTunnel passwords REQUIRE a tag, even\n\t\t\t *\tif don't have a valid tag.\n\t\t\t */\n\t\t\tptr[0] = 0;\n\t\t\toffset = 1;\n\t\t} /* else don't write a tag */\n\t} /* else the attribute doesn't have a tag */\n\t\n\t/*\n\t *\tSet up the default sources for the data.\n\t */\n\tdata = vp->strvalue;\n\tlen = vp->length;\n\n\t/*\n\t *\tEncrypted passwords can't be very long.\n\t *\tThis check also ensures that the hashed version\n\t *\tof the password + attribute header fits into one\n\t *\tattribute.\n\t *\n\t *\tFIXME: Print a warning message if it's too long?\n\t */\n\tif (vp->flags.encrypt && (len > MAX_PASS_LEN)) {\n\t\tlen = MAX_PASS_LEN;\n\t}\n\n\tswitch(vp->type) {\n\tcase PW_TYPE_STRING:\n\tcase PW_TYPE_OCTETS:\n\tcase PW_TYPE_IFID:\n\tcase PW_TYPE_IPV6ADDR:\n\tcase PW_TYPE_IPV6PREFIX:\n\tcase PW_TYPE_ABINARY:\n\t\t/* nothing more to do */\n\t\tbreak;\n\t\t\t\n\tcase PW_TYPE_INTEGER:\n\t\tlen = 4;\t/* just in case */\n\t\tlvalue = htonl(vp->lvalue);\n\t\tmemcpy(array, &lvalue, sizeof(lvalue));\n\n\t\t/*\n\t\t *\tPerhaps discard the first octet.\n\t\t */\n\t\tdata = &array[offset];\n\t\tlen -= offset;\n\t\tbreak;\n\t\t\t\n\tcase PW_TYPE_IPADDR:\n\t\tdata = (const uint8_t *) &vp->lvalue;\n\t\tlen = 4;\t/* just in case */\n\t\tbreak;\n\n\t\t/*\n\t\t *  There are no tagged date attributes.\n\t\t */\n\tcase PW_TYPE_DATE:\n\t\tlvalue = htonl(vp->lvalue);\n\t\tdata = (const uint8_t *) &lvalue;\n\t\tlen = 4;\t/* just in case */\n\t\tbreak;\n\n\tdefault:\t\t/* unknown type: ignore it */\n\t\tlibrad_log(\"ERROR: Unknown attribute type %d\", vp->type);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tBound the data to 255 bytes.\n\t */\n\tif (len + offset + total_length > 255) {\n\t\tlen = 255 - offset - total_length;\n\t}\t\n\n\t/*\n\t *\tEncrypt the various password styles\n\t *\n\t *\tAttributes with encrypted values MUST be less than\n\t *\t128 bytes long.\n\t */\n\tswitch (vp->flags.encrypt) {\n\tcase FLAG_ENCRYPT_USER_PASSWORD:\n\t\tmake_passwd(ptr + offset, &len,\n\t\t\t    data, len,\n\t\t\t    secret, packet->vector);\n\t\tbreak;\n\t\t\n\tcase FLAG_ENCRYPT_TUNNEL_PASSWORD:\n\t\tif (!original) {\n\t\t\tlibrad_log(\"ERROR: No request packet, cannot encrypt %s attribute in the vp.\", vp->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t *\tCheck if 255 - offset - total_length is less\n\t\t *\tthan 18.  If so, we can't fit the data into\n\t\t *\tthe available space, and we discard the\n\t\t *\tattribute.\n\t\t *\n\t\t *\tThis is ONLY a problem if we have multiple VSA's\n\t\t *\tin one Vendor-Specific, though.\n\t\t */\n\t\tif ((255 - offset - total_length) < 18) return 0;\n\n\t\t/*\n\t\t *\tCan't make the password, suppress it.\n\t\t */\n\t\tmake_tunnel_passwd(ptr + offset, &len,\n\t\t\t\t   data, len, 255 - offset - total_length,\n\t\t\t\t   secret, original->vector);\n\t\tbreak;\n\n\t\t/*\n\t\t *\tThe code above ensures that this attribute\n\t\t *\talways fits.\n\t\t */\n\tcase FLAG_ENCRYPT_ASCEND_SECRET:\n\t\tmake_secret(ptr + offset, packet->vector,\n\t\t\t    secret, data);\n\t\tlen = AUTH_VECTOR_LEN;\n\t\tbreak;\n\n\t\t\n\tdefault:\n\t\t/*\n\t\t *\tJust copy the data over\n\t\t */\n\t\tmemcpy(ptr + offset, data, len);\n\t\tbreak;\n\t} /* switch over encryption flags */\n\n\t/*\n\t *\tAccount for the tag (if any).\n\t */\n\tlen += offset;\n\n\t/*\n\t *\tRFC 2865 section 5 says that zero-length attributes\n\t *\tMUST NOT be sent.\n\t */\n\tif (len == 0) return 0;\n\n\t/*\n\t *\tUpdate the various lengths.\n\t */\n\t*length_ptr += len;\n\tif (vsa_length_ptr) *vsa_length_ptr += len;\n\tptr += len;\n\ttotal_length += len;\n\n\treturn total_length;\t/* of attribute */\n}\n\n\n/*\n *\tEncode a packet.\n */\nint rad_encode(RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t       const char *secret)\n{\n\tradius_packet_t\t*hdr;\n\tuint8_t\t        *ptr;\n\tuint16_t\ttotal_length;\n\tint\t\tlen;\n\tVALUE_PAIR\t*reply;\n\t\n\t/*\n\t *\tFor simplicity in the following logic, we allow\n\t *\tthe attributes to \"overflow\" the 4k maximum\n\t *\tRADIUS packet size, by one attribute.\n\t *\n\t *\tIt's uint32_t, for alignment purposes.\n\t */\n\tuint32_t\tdata[(MAX_PACKET_LEN + 256) / 4];\n\n\t/*\n\t *\tDouble-check some things based on packet code.\n\t */\n\tswitch (packet->code) {\n\tcase PW_AUTHENTICATION_ACK:\n\tcase PW_AUTHENTICATION_REJECT:\n\tcase PW_ACCESS_CHALLENGE:\n\t\tif (!original) {\n\t\t\tlibrad_log(\"ERROR: Cannot sign response packet without a request packet.\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tThese packet vectors start off as all zero.\n\t\t */\n\tcase PW_ACCOUNTING_REQUEST:\n\tcase PW_DISCONNECT_REQUEST:\n\tcase PW_COA_REQUEST:\n\t\tmemset(packet->vector, 0, sizeof(packet->vector));\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tbreak;\n\t}\n\t\t\n\t/*\n\t *\tUse memory on the stack, until we know how\n\t *\tlarge the packet will be.\n\t */\n\thdr = (radius_packet_t *) data;\n\t\n\t/*\n\t *\tBuild standard header\n\t */\n\thdr->code = packet->code;\n\thdr->id = packet->id;\n\t\n\tmemcpy(hdr->vector, packet->vector, sizeof(hdr->vector));\n\n\ttotal_length = AUTH_HDR_LEN;\n\tpacket->verified = 0;\n\t\n\t/*\n\t *\tLoad up the configuration values for the user\n\t */\n\tptr = hdr->data;\n\n\t/*\n\t *\tFIXME: Loop twice over the reply list.  The first time,\n\t *\tcalculate the total length of data.  The second time,\n\t *\tallocate the memory, and fill in the VP's.\n\t *\n\t *\tHmm... this may be slower than just doing a small\n\t *\tmemcpy.\n\t */\n\t\n\t/*\n\t *\tLoop over the reply attributes for the packet.\n\t */\n\tfor (reply = packet->vps; reply; reply = reply->next) {\n\t\t/*\n\t\t *\tIgnore non-wire attributes\n\t\t */\n\t\tif ((VENDOR(reply->attribute) == 0) &&\n\t\t    ((reply->attribute & 0xFFFF) > 0xff)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tSet the Message-Authenticator to the correct\n\t\t *\tlength and initial value.\n\t\t */\n\t\tif (reply->attribute == PW_MESSAGE_AUTHENTICATOR) {\n\t\t\treply->length = AUTH_VECTOR_LEN;\n\t\t\tmemset(reply->strvalue, 0, AUTH_VECTOR_LEN);\n\t\t\tpacket->verified = total_length; /* HACK! */\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tPrint out ONLY the attributes which\n\t\t *\twe're sending over the wire, and print\n\t\t *\tthem out BEFORE they're encrypted.\n\t\t */\n\t\tdebug_pair(reply);\n\n\t\tlen = rad_vp2attr(packet, original, secret, reply, ptr);\n\t\tif (len < 0) return -1;\n\n\t\t/*\n\t\t *\tCheck that the packet is no more than 4k in\n\t\t *\tsize, AFTER writing the attribute past the 4k\n\t\t *\tboundary, but BEFORE deciding to increase the\n\t\t *\tsize of the packet. Note that the 'data'\n\t\t *\tbuffer, above, is one attribute longer than\n\t\t *\tnecessary, in order to permit this overflow.\n\t\t */\n\t\tif ((total_length + len) > MAX_PACKET_LEN) {\n\t\t\tbreak;\n\t\t}\n\n\t\tptr += len;\n\t\ttotal_length += len;\n\t} /* done looping over all attributes */\n\t\n\t/*\n\t *\tFill in the rest of the fields, and copy the data over\n\t *\tfrom the local stack to the newly allocated memory.\n\t *\n\t *\tYes, all this 'memcpy' is slow, but it means\n\t *\tthat we only allocate the minimum amount of\n\t *\tmemory for a request.\n\t */\n\tpacket->data_len = total_length;\n\tpacket->data = (uint8_t *) malloc(packet->data_len);\n\tif (!packet->data) {\n\t\tlibrad_log(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data, data, packet->data_len);\n\thdr = (radius_packet_t *) packet->data;\n\t\n\ttotal_length = htons(total_length);\n\tmemcpy(hdr->length, &total_length, sizeof(total_length));\n\n\treturn 0;\n}\n\n\n/*\n *\tSign a previously encoded packet.\n */\nint rad_sign(RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t     const char *secret)\n{\n\tradius_packet_t\t*hdr = (radius_packet_t *)packet->data;\n\n\t/*\n\t *\tIt wasn't assigned an Id, this is bad!\n\t */\n\tif (packet->id < 0) {\n\t\tlibrad_log(\"ERROR: RADIUS packets must be assigned an Id.\");\n\t\treturn -1;\n\t}\n\n\tif (!packet->data || (packet->data_len < AUTH_HDR_LEN) ||\n\t    (packet->verified < 0)) {\n\t\tlibrad_log(\"ERROR: You must call rad_encode() before rad_sign()\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tIf there's a Message-Authenticator, update it\n\t *\tnow, BEFORE updating the authentication vector.\n\t *\n\t *\tThis is a hack...\n\t */\n\tif (packet->verified > 0) {\n\t\tuint8_t calc_auth_vector[AUTH_VECTOR_LEN];\n\t\t\n\t\tswitch (packet->code) {\n\t\tcase PW_ACCOUNTING_REQUEST:\n\t\tcase PW_ACCOUNTING_RESPONSE:\n\t\tcase PW_DISCONNECT_REQUEST:\n\t\tcase PW_DISCONNECT_ACK:\n\t\tcase PW_DISCONNECT_NAK:\n\t\tcase PW_COA_REQUEST:\n\t\tcase PW_COA_ACK:\n\t\tcase PW_COA_NAK:\n\t\t\tmemset(hdr->vector, 0, AUTH_VECTOR_LEN);\n\t\t\tbreak;\n\n\t\tcase PW_AUTHENTICATION_ACK:\n\t\tcase PW_AUTHENTICATION_REJECT:\n\t\tcase PW_ACCESS_CHALLENGE:\n\t\t\tif (!original) {\n\t\t\t\tlibrad_log(\"ERROR: Cannot sign response packet without a request packet.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmemcpy(hdr->vector, original->vector,\n\t\t\t       AUTH_VECTOR_LEN);\n\t\t\tbreak;\n\n\t\tdefault:\t/* others have vector already set to zero */\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tSet the authentication vector to zero,\n\t\t *\tcalculate the signature, and put it\n\t\t *\tinto the Message-Authenticator\n\t\t *\tattribute.\n\t\t */\n\t\tlrad_hmac_md5(packet->data, packet->data_len,\n\t\t\t      secret, strlen(secret),\n\t\t\t      calc_auth_vector);\n\t\tmemcpy(packet->data + packet->verified + 2,\n\t\t       calc_auth_vector, AUTH_VECTOR_LEN);\n\t\t\n\t\t/*\n\t\t *\tCopy the original request vector back\n\t\t *\tto the raw packet.\n\t\t */\n\t\tmemcpy(hdr->vector, packet->vector, AUTH_VECTOR_LEN);\n\t}\n\t\n\t/*\n\t *\tSwitch over the packet code, deciding how to\n\t *\tsign the packet.\n\t */\n\tswitch (packet->code) {\n\t\t/*\n\t\t *\tRequest packets are not signed, bur\n\t\t *\thave a random authentication vector.\n\t\t */\n\tcase PW_AUTHENTICATION_REQUEST:\n\tcase PW_STATUS_SERVER:\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tReply packets are signed with the\n\t\t *\tauthentication vector of the request.\n\t\t */\n\tdefault:\n\t\t{\n\t\t\tuint8_t digest[16];\n\t\t\t\n\t\t\tMD5_CTX\tcontext;\n\t\t\tMD5Init(&context);\n\t\t\tMD5Update(&context, packet->data, packet->data_len);\n\t\t\tMD5Update(&context, secret, strlen(secret));\n\t\t\tMD5Final(digest, &context);\n\t\t\t\n\t\t\tmemcpy(hdr->vector, digest, AUTH_VECTOR_LEN);\n\t\t\tmemcpy(packet->vector, digest, AUTH_VECTOR_LEN);\n\t\t\tbreak;\n\t\t}\n\t}/* switch over packet codes */\n\n\treturn 0;\n}\n\n/*\n *\tReply to the request.  Also attach\n *\treply attribute value pairs and any user message provided.\n */\nint rad_send(RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t     const char *secret)\n{\n\tVALUE_PAIR\t\t*reply;\n\tconst char\t\t*what;\n\tchar\t\t\tip_buffer[128];\n\tstruct\tsockaddr_in\tsaremote;\n\tstruct\tsockaddr_in\t*sa;\n\n\t/*\n\t *\tMaybe it's a fake packet.  Don't send it.\n\t */\n\tif (!packet || (packet->sockfd < 0)) {\n\t\treturn 0;\n\t}\n\n\tif ((packet->code > 0) && (packet->code < 52)) {\n\t\twhat = packet_codes[packet->code];\n\t} else {\n\t\twhat = \"Reply\";\n\t}\n\n\t/*\n\t *  First time through, allocate room for the packet\n\t */\n\tif (!packet->data) {\n\t\tDEBUG(\"Sending %s of id %d to %s port %d\\n\",\n\t\t      what, packet->id,\n\t\t      ip_ntoa(ip_buffer, packet->dst_ipaddr),\n\t\t      packet->dst_port);\n\t\t\n\t\t/*\n\t\t *\tEncode the packet.\n\t\t */\n\t\tif (rad_encode(packet, original, secret) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tRe-sign it, including updating the\n\t\t *\tMessage-Authenticator.\n\t\t */\n\t\tif (rad_sign(packet, original, secret) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t *\tIf packet->data points to data, then we print out\n\t\t *\tthe VP list again only for debugging.\n\t\t */\n\t} else if (librad_debug) {\n\t  \tDEBUG(\"Re-sending %s of id %d to %s port %d\\n\", what, packet->id,\n\t\t      ip_ntoa(ip_buffer, packet->dst_ipaddr),\n\t\t      packet->dst_port);\n\n\t\tfor (reply = packet->vps; reply; reply = reply->next) {\n\t\t\t/* FIXME: ignore attributes > 0xff */\n\t\t\tdebug_pair(reply);\n\t\t}\n\t}\n\n\t/*\n\t *\tAnd send it on it's way.\n\t */\n\tsa = (struct sockaddr_in *) &saremote;\n        memset ((char *) sa, '\\0', sizeof (saremote));\n\tsa->sin_family = AF_INET;\n\tsa->sin_addr.s_addr = packet->dst_ipaddr;\n\tsa->sin_port = htons(packet->dst_port);\n#ifndef WITH_UDPFROMTO\n\treturn sendto(packet->sockfd, packet->data, (int)packet->data_len, 0,\n\t\t      (struct sockaddr *)&saremote, sizeof(struct sockaddr_in));\n#else\n\t{\n\t\tstruct sockaddr_in salocal;\n\t\tmemset ((char *) &salocal, '\\0', sizeof (salocal));\n\t\tsalocal.sin_family = AF_INET;\n\t\tsalocal.sin_addr.s_addr = packet->src_ipaddr;\n\t\t\n\t\treturn sendfromto(packet->sockfd, packet->data, (int)packet->data_len, 0,\n\t\t\t\t  (struct sockaddr *)&salocal,  sizeof(struct sockaddr_in),\n\t\t\t\t  (struct sockaddr *)&saremote, sizeof(struct sockaddr_in));\n\t}\n#endif\n}\n\n\n/*\n *\tValidates the requesting client NAS.  Calculates the\n *\tsignature based on the clients private key.\n */\nstatic int calc_acctdigest(RADIUS_PACKET *packet, const char *secret)\n{\n\tu_char\t\tdigest[AUTH_VECTOR_LEN];\n\tMD5_CTX\t\tcontext;\n\n\t/*\n\t *\tOlder clients have the authentication vector set to\n\t *\tall zeros. Return `1' in that case.\n\t */\n\tmemset(digest, 0, sizeof(digest));\n\tif (memcmp(packet->vector, digest, AUTH_VECTOR_LEN) == 0) {\n\t\tpacket->verified = 1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t *\tZero out the auth_vector in the received packet.\n\t *\tThen append the shared secret to the received packet,\n\t *\tand calculate the MD5 sum. This must be the same\n\t *\tas the original MD5 sum (packet->vector).\n\t */\n\tmemset(packet->data + 4, 0, AUTH_VECTOR_LEN);\n\n\t/*\n\t *  MD5(packet + secret);\n\t */\n\tMD5Init(&context);\n\tMD5Update(&context, packet->data, packet->data_len);\n\tMD5Update(&context, secret, strlen(secret));\n\tMD5Final(digest, &context);\n\n\t/*\n\t *\tReturn 0 if OK, 2 if not OK.\n\t */\n\tpacket->verified =\n\tmemcmp(digest, packet->vector, AUTH_VECTOR_LEN) ? 2 : 0;\n\n\treturn packet->verified;\n}\n\n/*\n *\tValidates the requesting client NAS.  Calculates the\n *\tsignature based on the clients private key.\n */\nstatic int calc_replydigest(RADIUS_PACKET *packet, RADIUS_PACKET *original,\n\t\t\t    const char *secret)\n{\n\tuint8_t\t\tcalc_digest[AUTH_VECTOR_LEN];\n\tMD5_CTX\t\tcontext;\n\n\t/*\n\t *\tVery bad!\n\t */\n\tif (original == NULL) {\n\t\treturn 3;\n\t}\n\n\t/*\n\t *  Copy the original vector in place.\n\t */\n\tmemcpy(packet->data + 4, original->vector, AUTH_VECTOR_LEN);\n\n\t/*\n\t *  MD5(packet + secret);\n\t */\n\tMD5Init(&context);\n\tMD5Update(&context, packet->data, packet->data_len);\n\tMD5Update(&context, secret, strlen(secret));\n\tMD5Final(calc_digest, &context);\n\n\t/*\n\t *  Copy the packet's vector back to the packet.\n\t */\n\tmemcpy(packet->data + 4, packet->vector, AUTH_VECTOR_LEN);\n\n\t/*\n\t *\tReturn 0 if OK, 2 if not OK.\n\t */\n\tpacket->verified =\n\t\tmemcmp(packet->vector, calc_digest, AUTH_VECTOR_LEN) ? 2 : 0;\n\treturn packet->verified;\n}\n\n/*\n *\tReceive UDP client requests, and fill in\n *\tthe basics of a RADIUS_PACKET structure.\n */\nRADIUS_PACKET *rad_recv(int fd)\n{\n\tRADIUS_PACKET\t\t*packet;\n\tstruct sockaddr_in\tsaremote;\n\tint\t\t\ttotallen;\n\tsocklen_t\t\tsalen;\n\tuint8_t\t\t\t*attr;\n\tint\t\t\tcount;\n\tradius_packet_t\t\t*hdr;\n\tchar\t\t\thost_ipaddr[16];\n\tint\t\t\trequire_ma = 0;\n\tint\t\t\tseen_ma = 0;\n\tuint8_t\t\t\tdata[MAX_PACKET_LEN];\n\tint\t\t\tnum_attributes;\n\n\t/*\n\t *\tAllocate the new request data structure\n\t */\n\tif ((packet = malloc(sizeof(RADIUS_PACKET))) == NULL) {\n\t\tlibrad_log(\"out of memory\");\n\t\treturn NULL;\n\t}\n\tmemset(packet, 0, sizeof(RADIUS_PACKET));\n\n\t/*\n\t *\tReceive the packet.\n\t */\n\tsalen = sizeof(saremote);\n\tmemset(&saremote, 0, sizeof(saremote));\n#ifndef WITH_UDPFROMTO\n\tpacket->data_len = recvfrom(fd, data, sizeof(data),\n\t\t\t\t    0, (struct sockaddr *)&saremote, &salen);\n\tpacket->dst_ipaddr = htonl(INADDR_ANY); /* i.e. unknown */\n#else\n\t{\n\t\tsocklen_t\t\tsalen_local;\n\t\tstruct sockaddr_in\tsalocal;\n\t\tsalen_local = sizeof(salocal);\n\t\tmemset(&salocal, 0, sizeof(salocal));\n\t\tpacket->data_len = recvfromto(fd, data, sizeof(data), 0,\n\t\t\t\t\t      (struct sockaddr *)&saremote, &salen,\n\t\t\t\t\t      (struct sockaddr *)&salocal, &salen_local);\n\t\tpacket->dst_ipaddr = salocal.sin_addr.s_addr;\n\t}\n#endif\n\n\t/*\n\t *\tCheck for socket errors.\n\t */\n\tif (packet->data_len < 0) {\n\t\tlibrad_log(\"Error receiving packet: %s\", strerror(errno));\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tFill IP header fields.  We need these for the error\n\t *\tmessages which may come later.\n\t */\n\tpacket->sockfd = fd;\n\tpacket->src_ipaddr = saremote.sin_addr.s_addr;\n\tpacket->src_port = ntohs(saremote.sin_port);\n\n\t/*\n\t *\tFIXME: Do even more filtering by only permitting\n\t *\tcertain IP's.  The problem is that we don't know\n\t *\thow to do this properly for all possible clients...\n\t */\n\n\t/*\n\t *\tExplicitely set the VP list to empty.\n\t */\n\tpacket->vps = NULL;\n\n\t/*\n\t *\tCheck for packets smaller than the packet header.\n\t *\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\"The minimum length is 20 ...\"\n\t */\n\tif (packet->data_len < AUTH_HDR_LEN) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: too short (received %d < minimum %d)\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   packet->data_len, AUTH_HDR_LEN);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\" ... and maximum length is 4096.\"\n\t */\n\tif (packet->data_len > MAX_PACKET_LEN) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: too long (received %d > maximum %d)\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   packet->data_len, MAX_PACKET_LEN);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tCheck for packets with mismatched size.\n\t *\ti.e. We've received 128 bytes, and the packet header\n\t *\tsays it's 256 bytes long.\n\t */\n\ttotallen = (data[2] << 8) | data[3];\n\thdr = (radius_packet_t *)data;\n\n\t/*\n\t *\tCode of 0 is not understood.\n\t *\tCode of 16 or greate is not understood.\n\t */\n\tif ((hdr->code == 0) ||\n\t    (hdr->code >= 52)) {\n\t\tlibrad_log(\"WARNING: Bad RADIUS packet from host %s: unknown packet code %d\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   hdr->code);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tMessage-Authenticator is required in Status-Server\n\t *\tpackets, otherwise they can be trivially forged.\n\t */\n\tif (hdr->code == PW_STATUS_SERVER) require_ma = 1;\n\n\t/*\n\t *\tRepeat the length checks.  This time, instead of\n\t *\tlooking at the data we received, look at the value\n\t *\tof the 'length' field inside of the packet.\n\t *\n\t *\tCheck for packets smaller than the packet header.\n\t *\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\"The minimum length is 20 ...\"\n\t */\n\tif (totallen < AUTH_HDR_LEN) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: too short (length %d < minimum %d)\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   totallen, AUTH_HDR_LEN);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tAnd again, for the value of the 'length' field.\n\t *\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\" ... and maximum length is 4096.\"\n\t */\n\tif (totallen > MAX_PACKET_LEN) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: too long (length %d > maximum %d)\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   totallen, MAX_PACKET_LEN);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\"If the packet is shorter than the Length field\n\t *\tindicates, it MUST be silently discarded.\"\n\t *\n\t *\ti.e. No response to the NAS.\n\t */\n\tif (packet->data_len < totallen) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: received %d octets, packet length says %d\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   packet->data_len, totallen);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tRFC 2865, Section 3., subsection 'length' says:\n\t *\n\t *\t\"Octets outside the range of the Length field MUST be\n\t *\ttreated as padding and ignored on reception.\"\n\t */\n\tif (packet->data_len > totallen) {\n\t\t/*\n\t\t *\tWe're shortening the packet below, but just\n\t\t *\tto be paranoid, zero out the extra data.\n\t\t */\n\t\tmemset(data + totallen, 0, packet->data_len - totallen);\n\t\tpacket->data_len = totallen;\n\t}\n\n\t/*\n\t *\tWalk through the packet's attributes, ensuring that\n\t *\tthey add up EXACTLY to the size of the packet.\n\t *\n\t *\tIf they don't, then the attributes either under-fill\n\t *\tor over-fill the packet.  Any parsing of the packet\n\t *\tis impossible, and will result in unknown side effects.\n\t *\n\t *\tThis would ONLY happen with buggy RADIUS implementations,\n\t *\tor with an intentional attack.  Either way, we do NOT want\n\t *\tto be vulnerable to this problem.\n\t */\n\tattr = hdr->data;\n\tcount = totallen - AUTH_HDR_LEN;\n\tnum_attributes = 0;\n\n\twhile (count > 0) {\n\t\t/*\n\t\t *\tAttribute number zero is NOT defined.\n\t\t */\n\t\tif (attr[0] == 0) {\n\t\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: Invalid attribute 0\",\n\t\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr));\n\t\t\tfree(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t *\tAttributes are at LEAST as long as the ID & length\n\t\t *\tfields.  Anything shorter is an invalid attribute.\n\t\t */\n       \t\tif (attr[1] < 2) {\n\t\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: attribute %d too short\",\n\t\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t\t   attr[0]);\n\t\t\tfree(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t *\tSanity check the attributes for length.\n\t\t */\n\t\tswitch (attr[0]) {\n\t\tdefault:\t/* don't do anything by default */\n\t\t\tbreak;\n\n\n\t\t\t/*\n\t\t\t *\tIf there's an EAP-Message, we require\n\t\t\t *\ta Message-Authenticator.\n\t\t\t */\n\t\tcase PW_EAP_MESSAGE:\n\t\t\trequire_ma = 1;\n\t\t\tbreak;\n\n\t\tcase PW_MESSAGE_AUTHENTICATOR:\n\t\t\tif (attr[1] != 2 + AUTH_VECTOR_LEN) {\n\t\t\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: Message-Authenticator has invalid length %d\",\n\t\t\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t\t\t   attr[1] - 2);\n\t\t\t\tfree(packet);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tseen_ma = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t *\tFIXME: Look up the base 255 attributes in the\n\t\t *\tdictionary, and switch over their type.  For\n\t\t *\tinteger/date/ip, the attribute length SHOULD\n\t\t *\tbe 6.\n\t\t */\n\t\tcount -= attr[1];\t/* grab the attribute length */\n\t\tattr += attr[1];\n\t\tnum_attributes++;\t/* seen one more attribute */\n\t}\n\n\t/*\n\t *\tIf the attributes add up to a packet, it's allowed.\n\t *\n\t *\tIf not, we complain, and throw the packet away.\n\t */\n\tif (count != 0) {\n\t\tlibrad_log(\"WARNING: Malformed RADIUS packet from host %s: packet attributes do NOT exactly fill the packet\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr));\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tIf we're configured to look for a maximum number of\n\t *\tattributes, and we've seen more than that maximum,\n\t *\tthen throw the packet away, as a possible DoS.\n\t */\n\tif ((librad_max_attributes > 0) &&\n\t    (num_attributes > librad_max_attributes)) {\n\t\tlibrad_log(\"WARNING: Possible DoS attack from host %s: Too many attributes in request (received %d, max %d are allowed).\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr),\n\t\t\t   num_attributes, librad_max_attributes);\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * \thttp://www.freeradius.org/rfc/rfc2869.html#EAP-Message\n\t *\n\t *\tA packet with an EAP-Message attribute MUST also have\n\t *\ta Message-Authenticator attribute.\n\t *\n\t *\tA Message-Authenticator all by itself is OK, though.\n\t *\n\t *\tSimilarly, Status-Server packets MUST contain\n\t *\tMessage-Authenticator attributes.\n\t */\n\tif (require_ma && ! seen_ma) {\n\t\tlibrad_log(\"WARNING: Insecure packet from host %s:  Packet does not contain required Message-Authenticator attribute\",\n\t\t\t   ip_ntoa(host_ipaddr, packet->src_ipaddr));\n\t\tfree(packet);\n\t\treturn NULL;\n\t}\n\n\tif (librad_debug) {\n\t\tif ((hdr->code > 0) && (hdr->code < 52)) {\n\t\t\tprintf(\"rad_recv: %s packet from host %s:%d\",\n\t\t\t       packet_codes[hdr->code],\n\t\t\t       ip_ntoa(host_ipaddr, packet->src_ipaddr), packet->src_port);\n\t\t} else {\n\t\t\tprintf(\"rad_recv: Packet from host %s:%d code=%d\",\n\t\t\t       ip_ntoa(host_ipaddr, packet->src_ipaddr), packet->src_port,\n\t\t\t       hdr->code);\n\t\t}\n\t\tprintf(\", id=%d, length=%d\\n\", hdr->id, totallen);\n\t}\n\n\t/*\n\t *\tFill RADIUS header fields\n\t */\n\tpacket->code = hdr->code;\n\tpacket->id = hdr->id;\n\tmemcpy(packet->vector, hdr->vector, AUTH_VECTOR_LEN);\n\n\t/*\n\t *  Now that we've sanity checked the packet, we can allocate\n\t *  memory for it, and copy the data from the local area to\n\t *  the packet buffer.\n\t */\n\tif ((packet->data = malloc(packet->data_len)) == NULL) {\n\t  free(packet);\n\t  librad_log(\"out of memory\");\n\t  return NULL;\n\t}\n\tmemcpy(packet->data, data, packet->data_len);\n\n\treturn packet;\n}\n\n\n/*\n *\tVerify the signature of a packet.\n */\nint rad_verify(RADIUS_PACKET *packet, RADIUS_PACKET *original,\n\t       const char *secret)\n{\n\tuint8_t\t\t\t*ptr;\n\tint\t\t\tlength;\n\tint\t\t\tattrlen;\n\n\tif (!packet || !packet->data) return -1;\n\n\t/*\n\t *\tBefore we allocate memory for the attributes, do more\n\t *\tsanity checking.\n\t */\n\tptr = packet->data + AUTH_HDR_LEN;\n\tlength = packet->data_len - AUTH_HDR_LEN;\n\twhile (length > 0) {\n\t\tuint8_t\tmsg_auth_vector[AUTH_VECTOR_LEN];\n\t\tuint8_t calc_auth_vector[AUTH_VECTOR_LEN];\n\n\t\tattrlen = ptr[1];\n\n\t\tswitch (ptr[0]) {\n\t\tdefault:\t/* don't do anything. */\n\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t *\tNote that more than one Message-Authenticator\n\t\t\t *\tattribute is invalid.\n\t\t\t */\n\t\tcase PW_MESSAGE_AUTHENTICATOR:\n\t\t\tmemcpy(msg_auth_vector, &ptr[2], sizeof(msg_auth_vector));\n\t\t\tmemset(&ptr[2], 0, AUTH_VECTOR_LEN);\n\n\t\t\tswitch (packet->code) {\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t\tcase PW_ACCOUNTING_REQUEST:\n\t\t\tcase PW_ACCOUNTING_RESPONSE:\n\t\t\tcase PW_DISCONNECT_REQUEST:\n\t\t\tcase PW_DISCONNECT_ACK:\n\t\t\tcase PW_DISCONNECT_NAK:\n\t\t\tcase PW_COA_REQUEST:\n\t\t\tcase PW_COA_ACK:\n\t\t\tcase PW_COA_NAK:\n\t\t\t  \tmemset(packet->data + 4, 0, AUTH_VECTOR_LEN);\n\t\t\t\tbreak;\n\n\t\t\tcase PW_AUTHENTICATION_ACK:\n\t\t\tcase PW_AUTHENTICATION_REJECT:\n\t\t\tcase PW_ACCESS_CHALLENGE:\n\t\t\t\tif (!original) {\n\t\t\t\t\tlibrad_log(\"ERROR: Cannot validate Message-Authenticator in response packet without a request packet.\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemcpy(packet->data + 4, original->vector, AUTH_VECTOR_LEN);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlrad_hmac_md5(packet->data, packet->data_len,\n\t\t\t\t      secret, strlen(secret), calc_auth_vector);\n\t\t\tif (memcmp(calc_auth_vector, msg_auth_vector,\n\t\t\t\t   sizeof(calc_auth_vector)) != 0) {\n\t\t\t\tchar buffer[32];\n\t\t\t\tlibrad_log(\"Received packet from %s with invalid Message-Authenticator!  (Shared secret is incorrect.)\",\n\t\t\t\t\t   ip_ntoa(buffer, packet->src_ipaddr));\n\t\t\t\t/* Silently drop packet, according to RFC 3579 */\n\t\t\t\treturn -2;\n\t\t\t} /* else the message authenticator was good */\n\n\t\t\t/*\n\t\t\t *\tReinitialize Authenticators.\n\t\t\t */\n\t\t\tmemcpy(&ptr[2], msg_auth_vector, AUTH_VECTOR_LEN);\n\t\t\tmemcpy(packet->data + 4, packet->vector, AUTH_VECTOR_LEN);\n\t\t\tbreak;\n\t\t} /* switch over the attributes */\n\n\t\tptr += attrlen;\n\t\tlength -= attrlen;\n\t} /* loop over the packet, sanity checking the attributes */\n\n\t/*\n\t *\tCalculate and/or verify digest.\n\t */\n\tswitch(packet->code) {\n\t\tint rcode;\n\n\t\tcase PW_AUTHENTICATION_REQUEST:\n\t\tcase PW_STATUS_SERVER:\n\t\tcase PW_DISCONNECT_REQUEST:\n\t\t\t/*\n\t\t\t *\tThe authentication vector is random\n\t\t\t *\tnonsense, invented by the client.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase PW_ACCOUNTING_REQUEST:\n\t\t\tif (calc_acctdigest(packet, secret) > 1) {\n\t\t\t\tchar buffer[32];\n\t\t\t\tlibrad_log(\"Received Accounting-Request packet \"\n\t\t\t\t\t   \"from %s with invalid signature!  (Shared secret is incorrect.)\",\n\t\t\t\t\t   ip_ntoa(buffer, packet->src_ipaddr));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Verify the reply digest */\n\t\tcase PW_AUTHENTICATION_ACK:\n\t\tcase PW_AUTHENTICATION_REJECT:\n\t\tcase PW_ACCESS_CHALLENGE:\n\t\tcase PW_ACCOUNTING_RESPONSE:\n\t\t\trcode = calc_replydigest(packet, original, secret);\n\t\t\tif (rcode > 1) {\n\t\t\t\tchar buffer[32];\n\t\t\t\tlibrad_log(\"Received %s packet \"\n\t\t\t\t\t   \"from client %s port %d with invalid signature (err=%d)!  (Shared secret is incorrect.)\",\n\t\t\t\t\t   packet_codes[packet->code],\n\t\t\t\t\t   ip_ntoa(buffer, packet->src_ipaddr),\n\t\t\t\t\t   packet->src_port,\n\t\t\t\t\t   rcode);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t  break;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n *\tParse a RADIUS attribute into a data structure.\n */\nstatic VALUE_PAIR *rad_attr2vp(const RADIUS_PACKET *packet, const RADIUS_PACKET *original,\n\t\t\tconst char *secret, int attribute, int length,\n\t\t\tconst uint8_t *data)\n{\n\tint offset = 0;\n\tVALUE_PAIR *vp;\n\n\tif ((vp = paircreate(attribute, PW_TYPE_OCTETS)) == NULL) {\n\t\treturn NULL;\n\t}\n\t\n\t/*\n\t *\tIf length is greater than 253, something is SERIOUSLY\n\t *\twrong.\n\t */\n\tif (length > 253) length = 253;\t/* paranoia (pair-anoia?) */\n\n\tvp->length = length;\n\tvp->operator = T_OP_EQ;\n\tvp->next = NULL;\n\n\t/*\n\t *\tHandle tags.\n\t */\n\tif (vp->flags.has_tag) {\n\t\tif (TAG_VALID(data[0]) ||\n\t\t    (vp->flags.encrypt == FLAG_ENCRYPT_TUNNEL_PASSWORD)) {\n\t\t\t/*\n\t\t\t *\tTunnel passwords REQUIRE a tag, even\n\t\t\t *\tif don't have a valid tag.\n\t\t\t */\n\t\t\tvp->flags.tag = data[0];\n\n\t\t\tif ((vp->type == PW_TYPE_STRING) ||\n\t\t\t    (vp->type == PW_TYPE_OCTETS)) offset = 1;\n\t\t}\n\t}\n\n\t/*\n\t *\tCopy the data to be decrypted\n\t */\n\tmemcpy(&vp->strvalue[0], data + offset, length - offset);\n\tvp->length -= offset;\n\n\t/*\n\t *\tDecrypt the attribute.\n\t */\n\tswitch (vp->flags.encrypt) {\n\t\t/*\n\t\t *  User-Password\n\t\t */\n\tcase FLAG_ENCRYPT_USER_PASSWORD:\n\t\tif (original) {\n\t\t\trad_pwdecode((char *)vp->strvalue,\n\t\t\t\t     vp->length, secret,\n\t\t\t\t     original->vector);\n\t\t} else {\n\t\t\trad_pwdecode((char *)vp->strvalue,\n\t\t\t\t     vp->length, secret,\n\t\t\t\t     packet->vector);\n\t\t}\n\t\tif (vp->attribute == PW_USER_PASSWORD) {\n\t\t\tvp->length = strlen(vp->strvalue);\n\t\t}\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tTunnel-Password's may go ONLY\n\t\t *\tin response packets.\n\t\t */\n\tcase FLAG_ENCRYPT_TUNNEL_PASSWORD:\n\t\tif (!original) goto raw;\n\t\t\n\t\tif (rad_tunnel_pwdecode(vp->strvalue, &vp->length,\n\t\t\t\t\tsecret, original->vector) < 0) {\n\t\t\tgoto raw;\n\t\t}\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *  Ascend-Send-Secret\n\t\t *  Ascend-Receive-Secret\n\t\t */\n\tcase FLAG_ENCRYPT_ASCEND_SECRET:\n\t\tif (!original) {\n\t\t\tgoto raw;\n\t\t} else {\n\t\t\tuint8_t my_digest[AUTH_VECTOR_LEN];\n\t\t\tmake_secret(my_digest,\n\t\t\t\t    original->vector,\n\t\t\t\t    secret, data);\n\t\t\tmemcpy(vp->strvalue, my_digest,\n\t\t\t       AUTH_VECTOR_LEN );\n\t\t\tvp->strvalue[AUTH_VECTOR_LEN] = '\\0';\n\t\t\tvp->length = strlen(vp->strvalue);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t} /* switch over encryption flags */\n\n\n\tswitch (vp->type) {\n\tcase PW_TYPE_STRING:\n\tcase PW_TYPE_OCTETS:\n\tcase PW_TYPE_ABINARY:\n\t\t/* nothing more to do */\n\t\tbreak;\n\n\tcase PW_TYPE_INTEGER:\n\t\tif (vp->length != 4) goto raw;\n\n\t\tmemcpy(&vp->lvalue, vp->strvalue, 4);\n\t\tvp->lvalue = ntohl(vp->lvalue);\n\n\t\tif (vp->flags.has_tag) vp->lvalue &= 0x00ffffff;\n\n\t\t/*\n\t\t *\tTry to get named VALUEs\n\t\t */\n\t\t{\n\t\t\tDICT_VALUE *dval;\n\t\t\tdval = dict_valbyattr(vp->attribute,\n\t\t\t\t\t      vp->lvalue);\n\t\t\tif (dval) {\n\t\t\t\tstrNcpy(vp->strvalue,\n\t\t\t\t\tdval->name,\n\t\t\t\t\tsizeof(vp->strvalue));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase PW_TYPE_DATE:\n\t\tif (vp->length != 4) goto raw;\n\n\t\tmemcpy(&vp->lvalue, vp->strvalue, 4);\n\t\tvp->lvalue = ntohl(vp->lvalue);\n\t\tbreak;\n\n\t\t/*\n\t\t *\tIPv4 address. Keep it in network byte order in\n\t\t *\tvp->lvalue and put ASCII IP address in standard\n\t\t *\tdot notation into vp->strvalue.\n\t\t */\n\tcase PW_TYPE_IPADDR:\n\t\tif (vp->length != 4) goto raw;\n\n\t\tmemcpy(&vp->lvalue, vp->strvalue, 4);\n\t\tip_ntoa(vp->strvalue, vp->lvalue);\n\t\tbreak;\n\n\t\t/*\n\t\t *\tIPv6 interface ID is 8 octets long.\n\t\t */\n\tcase PW_TYPE_IFID:\n\t\tif (vp->length != 8) goto raw;\n\t\t/* vp->vp_ifid == vp->strvalue */\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tIPv6 addresses are 16 octets long\n\t\t */\n\tcase PW_TYPE_IPV6ADDR:\n\t\tif (vp->length != 16) goto raw;\n\t\t/* vp->vp_ipv6addr == vp->strvalue */\n\t\tbreak;\n\t\t\n\t\t/*\n\t\t *\tIPv6 prefixes are 2 to 18 octets long.\n\t\t *\n\t\t *\tRFC 3162: The first octet is unused.\n\t\t *\tThe second is the length of the prefix\n\t\t *\tthe rest are the prefix data.\n\t\t *\n\t\t *\tThe prefix length can have value 0 to 128.\n\t\t */\n\tcase PW_TYPE_IPV6PREFIX:\n\t\tif (vp->length < 2 || vp->length > 18) goto raw;\n\t\tif (vp->strvalue[1] > 128) goto raw;\n\n\t\t/*\n\t\t *\tFIXME: double-check that\n\t\t *\t(vp->strvalue[1] >> 3) matches vp->length + 2\n\t\t */\n\t\tif (vp->length < 18) {\n\t\t\tmemset(vp->strvalue + vp->length, 0,\n\t\t\t       18 - vp->length);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\traw:\n\t\tvp->type = PW_TYPE_OCTETS;\n\t\tvp->length = length;\n\t\tmemcpy(vp->strvalue, data, length);\n\t\t\n\n\t\t/*\n\t\t *\tEnsure there's no encryption or tag stuff,\n\t\t *\twe just pass the attribute as-is.\n\t\t */\n\t\tmemset(&vp->flags, 0, sizeof(vp->flags));\n\t}\n\n\treturn vp;\n}\n\n\n/*\n *\tCalculate/check digest, and decode radius attributes.\n */\nint rad_decode(RADIUS_PACKET *packet, RADIUS_PACKET *original,\n\t       const char *secret)\n{\n\tuint32_t\t\tlvalue;\n\tuint32_t\t\tvendorcode;\n\tVALUE_PAIR\t\t**tail;\n\tVALUE_PAIR\t\t*pair;\n\tuint8_t\t\t\t*ptr;\n\tint\t\t\tpacket_length;\n\tint\t\t\tattribute;\n\tint\t\t\tattrlen;\n\tint\t\t\tvendorlen;\n\tradius_packet_t\t\t*hdr;\n\tint\t\t\tvsa_tlen, vsa_llen;\n\tDICT_VENDOR\t\t*dv = NULL;\n\n\t/*\n\t *\tExtract attribute-value pairs\n\t */\n\thdr = (radius_packet_t *)packet->data;\n\tptr = hdr->data;\n\tpacket_length = packet->data_len - AUTH_HDR_LEN;\n\n\t/*\n\t *\tThere may be VP's already in the packet.  Don't\n\t *\tdestroy them.\n\t */\n\tfor (tail = &packet->vps; *tail != NULL; tail = &((*tail)->next)) {\n\t\t/* nothing */\n\t}\n\n\tvendorcode = 0;\n\tvendorlen  = 0;\n\tvsa_tlen = vsa_llen = 1;\n\n\t/*\n\t *\tWe have to read at least two bytes.\n\t *\n\t *\trad_recv() above ensures that this is OK.\n\t */\n\twhile (packet_length > 0) {\n\t\tattribute = -1;\n\t\tattrlen = -1;\n\n\t\t/*\n\t\t *\tNormal attribute, handle it like normal.\n\t\t */\n\t\tif (vendorcode == 0) {\n\t\t\t/*\n\t\t\t *\tNo room to read attr/length,\n\t\t\t *\tor bad attribute, or attribute is\n\t\t\t *\ttoo short, or attribute is too long,\n\t\t\t *\tstop processing the packet.\n\t\t\t */\n\t\t\tif ((packet_length < 2) ||\n\t\t\t    (ptr[0] == 0) ||  (ptr[1] < 2) ||\n\t\t\t    (ptr[1] > packet_length)) break;\n\n\t\t\tattribute = *ptr++;\n\t\t\tattrlen   = *ptr++;\n\n\t\t\tattrlen -= 2;\n\t\t\tpacket_length  -= 2;\n\n\t\t\tif (attribute != PW_VENDOR_SPECIFIC) goto create_pair;\n\t\t\t\n\t\t\t/*\n\t\t\t *\tNo vendor code, or ONLY vendor code.\n\t\t\t */\n\t\t\tif (attrlen <= 4) goto create_pair;\n\n\t\t\tvendorlen = 0;\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tHandle Vendor-Specific\n\t\t */\n\t\tif (vendorlen == 0) {\n\t\t\tuint8_t *subptr;\n\t\t\tint sublen;\n\t\t\tint myvendor;\n\t\t\t\n\t\t\t/*\n\t\t\t *\tattrlen was checked above.\n\t\t\t */\n\t\t\tmemcpy(&lvalue, ptr, 4);\n\t\t\tmyvendor = ntohl(lvalue);\n\n\t\t\t/*\n\t\t\t *\tZero isn't allowed.\n\t\t\t */\n\t\t\tif (myvendor == 0) goto create_pair;\n\t\t\t\n\t\t\t/*\n\t\t\t *\tThis is an implementation issue.\n\t\t\t *\tWe currently pack vendor into the upper\n\t\t\t *\t16 bits of a 32-bit attribute number,\n\t\t\t *\tso we can't handle vendor numbers larger\n\t\t\t *\tthan 16 bits.\n\t\t\t */\n\t\t\tif (myvendor > 65535) goto create_pair;\n\t\t\t\n\t\t\tvsa_tlen = vsa_llen = 1;\n\t\t\tdv = dict_vendorbyvalue(myvendor);\n\t\t\tif (dv) {\n\t\t\t\tvsa_tlen = dv->type;\n\t\t\t\tvsa_llen = dv->length;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t *\tSweep through the list of VSA's,\n\t\t\t *\tseeing if they exactly fill the\n\t\t\t *\touter Vendor-Specific attribute.\n\t\t\t *\n\t\t\t *\tIf not, create a raw Vendor-Specific.\n\t\t\t */\n\t\t\tsubptr = ptr + 4;\n\t\t\tsublen = attrlen - 4;\n\n\t\t\t/*\n\t\t\t *\tSee if we can parse it.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tint myattr = 0;\n\n\t\t\t\t/*\n\t\t\t\t *\tDon't have a type, it's bad.\n\t\t\t\t */\n\t\t\t\tif (sublen < vsa_tlen) goto create_pair;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t *\tEnsure that the attribute number\n\t\t\t\t *\tis OK.\n\t\t\t\t */\n\t\t\t\tswitch (vsa_tlen) {\n\t\t\t\tcase 1:\n\t\t\t\t\tmyattr = subptr[0];\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tmyattr = (subptr[0] << 8) | subptr[1];\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tif ((subptr[0] != 0) ||\n\t\t\t\t\t    (subptr[1] != 0)) goto create_pair;\n\t\t\t\t\t\n\t\t\t\t\tmyattr = (subptr[2] << 8) | subptr[3];\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t *\tOur dictionary is broken.\n\t\t\t\t\t */\n\t\t\t\tdefault:\n\t\t\t\t\tgoto create_pair;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t *\tNot enough room for one more\n\t\t\t\t *\tattribute.  Die!\n\t\t\t\t */\n\t\t\t\tif (sublen < vsa_tlen + vsa_llen) goto create_pair;\n\t\t\t\tswitch (vsa_llen) {\n\t\t\t\tcase 0:\n\t\t\t\t\tattribute = (myvendor << 16) | myattr;\n\t\t\t\t\tptr += 4 + vsa_tlen;\n\t\t\t\t\tattrlen -= (4 + vsa_tlen);\n\t\t\t\t\tpacket_length -= 4 + vsa_tlen;\n\t\t\t\t\tgoto create_pair;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tif (subptr[vsa_tlen] < (vsa_tlen + vsa_llen))\n\t\t\t\t\t\tgoto create_pair;\n\n\t\t\t\t\tif (subptr[vsa_tlen] > sublen)\n\t\t\t\t\t\tgoto create_pair;\n\t\t\t\t\tsublen -= subptr[vsa_tlen];\n\t\t\t\t\tsubptr += subptr[vsa_tlen];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tif (subptr[vsa_tlen] != 0) goto create_pair;\n\t\t\t\t\tif (subptr[vsa_tlen + 1] < (vsa_tlen + vsa_llen))\n\t\t\t\t\t\tgoto create_pair;\n\t\t\t\t\tif (subptr[vsa_tlen + 1] > sublen)\n\t\t\t\t\t\tgoto create_pair;\n\t\t\t\t\tsublen -= subptr[vsa_tlen + 1];\n\t\t\t\t\tsubptr += subptr[vsa_tlen + 1];\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t/*\n\t\t\t\t\t *\tOur dictionaries are\n\t\t\t\t\t *\tbroken.\n\t\t\t\t\t */\n\t\t\t\tdefault:\n\t\t\t\t\tgoto create_pair;\n\t\t\t\t}\n\t\t\t} while (sublen > 0);\n\n\t\t\tvendorcode = myvendor;\n\t\t\tvendorlen = attrlen - 4;\n\t\t\tpacket_length -= 4;\n\n\t\t\tptr += 4;\n\t\t}\n\n\t\t/*\n\t\t *\tattrlen is the length of this attribute.\n\t\t *\ttotal_len is the length of the encompassing\n\t\t *\tattribute.\n\t\t */\n\t\tswitch (vsa_tlen) {\n\t\tcase 1:\n\t\t\tattribute = ptr[0];\n\t\t\tbreak;\n\t\t\t\n\t\tcase 2:\n\t\t\tattribute = (ptr[0] << 8) | ptr[1];\n\t\t\tbreak;\n\n\t\tdefault:\t/* can't hit this. */\n\t\t\treturn -1;\n\t\t}\n\t\tattribute |= (vendorcode << 16);\n\t\tptr += vsa_tlen;\n\n\t\tswitch (vsa_llen) {\n\t\tcase 1:\n\t\t\tattrlen = ptr[0] - (vsa_tlen + vsa_llen);\n\t\t\tbreak;\n\t\t\t\n\t\tcase 2:\n\t\t\tattrlen = ptr[1] - (vsa_tlen + vsa_llen);\n\t\t\tbreak;\n\n\t\tdefault:\t/* can't hit this. */\n\t\t\treturn -1;\n\t\t}\n\t\tptr += vsa_llen;\n\t\tvendorlen -= vsa_tlen + vsa_llen + attrlen;\n\t\tif (vendorlen == 0) vendorcode = 0;\n\t\tpacket_length -= (vsa_tlen + vsa_llen);\n\n\t\t/*\n\t\t *\tCreate the attribute, setting the default type\n\t\t *\tto 'octects'.  If the type in the dictionary\n\t\t *\tis different, then the dictionary type will\n\t\t *\tover-ride this one.\n\t\t */\n\tcreate_pair:\n\t\t/*\n\t\t *\tIgnore VSAs that have no data.\n\t\t */\n\t\tif (attrlen == 0) goto next;\n\n\t\tpair = rad_attr2vp(packet, original, secret,\n\t\t\t\t attribute, attrlen, ptr);\n\t\tif (!pair) {\n\t\t\tpairfree(&packet->vps);\n\t\t\tlibrad_log(\"out of memory\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tdebug_pair(pair);\n\t\t*tail = pair;\n\t\ttail = &pair->next;\n\n\tnext:\n\t\tptr += attrlen;\n\t\tpacket_length -= attrlen;\n\t}\n\n\t/*\n\t *\tMerge information from the outside world into our\n\t *\trandom pool.\n\t */\n\tlrad_rand_seed(packet->data, AUTH_HDR_LEN);\n\t  \n\treturn 0;\n}\n\n\n/*\n *\tEncode password.\n *\n *\tWe assume that the passwd buffer passed is big enough.\n *\tRFC2138 says the password is max 128 chars, so the size\n *\tof the passwd buffer must be at least 129 characters.\n *\tPreferably it's just MAX_STRING_LEN.\n *\n *\tint *pwlen is updated to the new length of the encrypted\n *\tpassword - a multiple of 16 bytes.\n */\nint rad_pwencode(char *passwd, int *pwlen, const char *secret,\n\t\t const char *vector)\n{\n\tuint8_t\tbuffer[AUTH_VECTOR_LEN + MAX_STRING_LEN + 1];\n\tchar\tdigest[AUTH_VECTOR_LEN];\n\tint\ti, n, secretlen;\n\tint\tlen;\n\n\t/*\n\t *\tPad password to multiple of AUTH_PASS_LEN bytes.\n\t */\n\tlen = *pwlen;\n\tif (len > 128) len = 128;\n\t*pwlen = len;\n\tif (len % AUTH_PASS_LEN != 0) {\n\t\tn = AUTH_PASS_LEN - (len % AUTH_PASS_LEN);\n\t\tfor (i = len; n > 0; n--, i++)\n\t\t\tpasswd[i] = 0;\n\t\tlen = *pwlen = i;\n\n\t} else if (len == 0) {\n\t\tmemset(passwd, 0, AUTH_PASS_LEN);\n\t\t*pwlen = len = AUTH_PASS_LEN;\n\t}\n\n\t/*\n\t *\tUse the secret to setup the decryption digest\n\t */\n\tsecretlen = strlen(secret);\n\tmemcpy(buffer, secret, secretlen);\n\tmemcpy(buffer + secretlen, vector, AUTH_VECTOR_LEN);\n\tlibrad_md5_calc((u_char *)digest, buffer, secretlen + AUTH_VECTOR_LEN);\n\n\t/*\n\t *\tNow we can encode the password *in place*\n\t */\n\tfor (i = 0; i < AUTH_PASS_LEN; i++)\n\t\tpasswd[i] ^= digest[i];\n\n\tif (len <= AUTH_PASS_LEN) return 0;\n\n\t/*\n\t *\tLength > AUTH_PASS_LEN, so we need to use the extended\n\t *\talgorithm.\n\t */\n\tfor (n = 0; n < 128 && n <= (len - AUTH_PASS_LEN); n += AUTH_PASS_LEN) {\n\t\tmemcpy(buffer + secretlen, passwd + n, AUTH_PASS_LEN);\n\t\tlibrad_md5_calc((u_char *)digest, buffer, secretlen + AUTH_PASS_LEN);\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++)\n\t\t\tpasswd[i + n + AUTH_PASS_LEN] ^= digest[i];\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tDecode password.\n */\nint rad_pwdecode(char *passwd, int pwlen, const char *secret,\n\t\t const char *vector)\n{\n\tuint8_t\tbuffer[AUTH_VECTOR_LEN + MAX_STRING_LEN + 1];\n\tchar\tdigest[AUTH_VECTOR_LEN];\n\tchar\tr[AUTH_VECTOR_LEN];\n\tchar\t*s;\n\tint\ti, n, secretlen;\n\tint\trlen;\n\n\t/*\n\t *\tUse the secret to setup the decryption digest\n\t */\n\tsecretlen = strlen(secret);\n\tmemcpy(buffer, secret, secretlen);\n\tmemcpy(buffer + secretlen, vector, AUTH_VECTOR_LEN);\n\tlibrad_md5_calc((u_char *)digest, buffer, secretlen + AUTH_VECTOR_LEN);\n\n\t/*\n\t *\tNow we can decode the password *in place*\n\t */\n\tmemcpy(r, passwd, AUTH_PASS_LEN);\n\tfor (i = 0; i < AUTH_PASS_LEN && i < pwlen; i++)\n\t\tpasswd[i] ^= digest[i];\n\n\tif (pwlen <= AUTH_PASS_LEN) {\n\t\tpasswd[pwlen+1] = 0;\n\t\treturn pwlen;\n\t}\n\n\t/*\n\t *\tLength > AUTH_PASS_LEN, so we need to use the extended\n\t *\talgorithm.\n\t */\n\trlen = ((pwlen - 1) / AUTH_PASS_LEN) * AUTH_PASS_LEN;\n\n\tfor (n = rlen; n > 0; n -= AUTH_PASS_LEN ) {\n\t\ts = (n == AUTH_PASS_LEN) ? r : (passwd + n - AUTH_PASS_LEN);\n\t\tmemcpy(buffer + secretlen, s, AUTH_PASS_LEN);\n\t\tlibrad_md5_calc((u_char *)digest, buffer, secretlen + AUTH_PASS_LEN);\n\t\tfor (i = 0; i < AUTH_PASS_LEN && (i + n) < pwlen; i++)\n\t\t\tpasswd[i + n] ^= digest[i];\n\t}\n\tpasswd[pwlen] = 0;\n\n\treturn pwlen;\n}\n\n\n/*\n *\tEncode Tunnel-Password attributes when sending them out on the wire.\n *\n *\tint *pwlen is updated to the new length of the encrypted\n *\tpassword - a multiple of 16 bytes.\n *\n *      This is per RFC-2868 which adds a two char SALT to the initial intermediate\n *      value MD5 hash.\n */\nint rad_tunnel_pwencode(char *passwd, int *pwlen, const char *secret,\n\t\t\tconst char *vector)\n{\n\tuint8_t\tbuffer[AUTH_VECTOR_LEN + MAX_STRING_LEN + 3];\n\tunsigned char\tdigest[AUTH_VECTOR_LEN];\n\tchar*   salt;\n\tint\ti, n, secretlen;\n\tunsigned len, n2;\n\n\tlen = *pwlen;\n\n\tif (len > 127) len = 127;\n\t/*\n\t * Shift the password 3 positions right to place a salt and original\n\t * length, tag will be added automatically on packet send\n\t */\n\tfor (n=len ; n>=0 ; n--) passwd[n+3] = passwd[n];\n\tsalt = passwd;\n\tpasswd += 2;\n\t/*\n\t * save original password length as first password character;\n\t */\n\t*passwd = len;\n\tlen += 1;\n\n\n\t/*\n\t *\tGenerate salt.  The RFC's say:\n\t *\n\t *\tThe high bit of salt[0] must be set, each salt in a\n\t *\tpacket should be unique, and they should be random\n\t *\n\t *\tSo, we set the high bit, add in a counter, and then\n\t *\tadd in some CSPRNG data.  should be OK..\n\t */\n\tsalt[0] = (0x80 | ( ((salt_offset++) & 0x0f) << 3) |\n\t\t   (lrad_rand() & 0x07));\n\tsalt[1] = lrad_rand();\n\n\t/*\n\t *\tPadd password to multiple of AUTH_PASS_LEN bytes.\n\t */\n\tn = len % AUTH_PASS_LEN;\n\tif (n) {\n\t\tn = AUTH_PASS_LEN - n;\n\t\tfor (; n > 0; n--, len++)\n\t\t\tpasswd[len] = 0;\n\t}\n\t/* set new password length */\n\t*pwlen = len + 2;\n\n\t/*\n\t *\tUse the secret to setup the decryption digest\n\t */\n\tsecretlen = strlen(secret);\n\tmemcpy(buffer, secret, secretlen);\n\n\tfor (n2 = 0; n2 < len; n2+=AUTH_PASS_LEN) {\n\t\tif (!n2) {\n\t\t\tmemcpy(buffer + secretlen, vector, AUTH_VECTOR_LEN);\n\t\t\tmemcpy(buffer + secretlen + AUTH_VECTOR_LEN, salt, 2);\n\t\t\tlibrad_md5_calc(digest, buffer, secretlen + AUTH_VECTOR_LEN + 2);\n\t\t} else {\n\t\t\tmemcpy(buffer + secretlen, passwd + n2 - AUTH_PASS_LEN, AUTH_PASS_LEN);\n\t\t\tlibrad_md5_calc(digest, buffer, secretlen + AUTH_PASS_LEN);\n\t\t}\n\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++) {\n\t\t\tpasswd[i + n2] ^= digest[i];\n\t\t}\n\t}\n\tpasswd[n2] = 0;\n\treturn 0;\n}\n\n/*\n *\tDecode Tunnel-Password encrypted attributes.\n *\n *      Defined in RFC-2868, this uses a two char SALT along with the\n *      initial intermediate value, to differentiate it from the\n *      above.\n */\nint rad_tunnel_pwdecode(uint8_t *passwd, int *pwlen, const char *secret,\n\t\t\tconst char *vector)\n{\n\tuint8_t\t\tbuffer[AUTH_VECTOR_LEN + MAX_STRING_LEN + 3];\n\tuint8_t\t\tdigest[AUTH_VECTOR_LEN];\n\tuint8_t\t\tdecrypted[MAX_STRING_LEN + 1];\n\tint\t\tsecretlen;\n\tunsigned\ti, n, len;\n\n\tlen = *pwlen;\n\n\t/*\n\t *\tWe need at least a salt.\n\t */\n\tif (len < 2) {\n\t\tlibrad_log(\"tunnel password is too short\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tThere's a salt, but no password.  Or, there's a salt\n\t *\tand a 'data_len' octet.  It's wrong, but at least we\n\t *\tcan figure out what it means: the password is empty.\n\t *\n\t *\tNote that this means we ignore the 'data_len' field,\n\t *\tif the attribute length tells us that there's no\n\t *\tmore data.  So the 'data_len' field may be wrong,\n\t *\tbut that's ok...\n\t */\n\tif (len <= 3) {\n\t\tpasswd[0] = 0;\n\t\t*pwlen = 0;\n\t\treturn 0;\n\t}\n\n\tlen -= 2;\t\t/* discount the salt */\n\n\t/*\n\t *\tUse the secret to setup the decryption digest\n\t */\n\tsecretlen = strlen(secret);\n\n\t/*\n\t *\tSet up the initial key:\n\t *\n\t *\t b(1) = MD5(secret + vector + salt)\n\t */\n\tmemcpy(buffer, secret, secretlen);\n\tmemcpy(buffer + secretlen, vector, AUTH_VECTOR_LEN);\n\tmemcpy(buffer + secretlen + AUTH_VECTOR_LEN, passwd, 2);\n\tlibrad_md5_calc(digest, buffer, secretlen + AUTH_VECTOR_LEN + 2);\n\n\t/*\n\t *\tA quick check: decrypt the first octet of the password,\n\t *\twhich is the 'data_len' field.  Ensure it's sane.\n\t *\n\t *\t'n' doesn't include the 'data_len' octet\n\t *\t'len' does.\n\t */\n\tn = passwd[2] ^ digest[0];\n\tif (n >= len) {\n\t\tlibrad_log(\"tunnel password is too long for the attribute\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tLoop over the data, decrypting it, and generating\n\t *\tthe key for the next round of decryption.\n\t */\n\tfor (n = 0; n < len; n += AUTH_PASS_LEN) {\n\t\tfor (i = 0; i < AUTH_PASS_LEN; i++) {\n\t\t\tdecrypted[n + i] = passwd[n + i + 2] ^ digest[i];\n\n\t\t\t/*\n\t\t\t *\tEncrypted password may not be aligned\n\t\t\t *\ton 16 octets, so we catch that here...\n\t\t\t */\n\t\t\tif ((n + i) == len) break;\n\t\t}\n\n\t\t/*\n\t\t *\tUpdate the digest, based on\n\t\t *\n\t\t *\tb(n) = MD5(secret + cleartext(n-1)\n\t\t *\n\t\t *\tbut only if there's more data...\n\t\t */\n\t\tmemcpy(buffer + secretlen, passwd + n + 2, AUTH_PASS_LEN);\n\t\tlibrad_md5_calc(digest, buffer, secretlen + AUTH_PASS_LEN);\n\t}\n\n\t/*\n\t *\tWe've already validated the length of the decrypted\n\t *\tpassword.  Copy it back to the caller.\n\t */\n\tmemcpy(passwd, decrypted + 1, decrypted[0]);\n\tpasswd[decrypted[0]] = 0;\n\t*pwlen = decrypted[0];\n\n\treturn decrypted[0];\n}\n\n/*\n *\tEncode a CHAP password\n *\n *\tFIXME: might not work with Ascend because\n *\twe use vp->length, and Ascend gear likes\n *\tto send an extra '\\0' in the string!\n */\nint rad_chap_encode(RADIUS_PACKET *packet, char *output, int id,\n\t\t    VALUE_PAIR *password)\n{\n\tint\t\ti;\n\tchar\t\t*ptr;\n\tchar\t\tstring[MAX_STRING_LEN * 2 + 1];\n\tVALUE_PAIR\t*challenge;\n\n\t/*\n\t *\tSanity check the input parameters\n\t */\n\tif ((packet == NULL) || (password == NULL)) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tNote that the password VP can be EITHER\n\t *\ta User-Password attribute (from a check-item list),\n\t *\tor a CHAP-Password attribute (the client asking\n\t *\tthe library to encode it).\n\t */\n\n\ti = 0;\n\tptr = string;\n\t*ptr++ = id;\n\n\ti++;\n\tmemcpy(ptr, password->strvalue, password->length);\n\tptr += password->length;\n\ti += password->length;\n\n\t/*\n\t *\tUse Chap-Challenge pair if present,\n\t *\tRequest-Authenticator otherwise.\n\t */\n\tchallenge = pairfind(packet->vps, PW_CHAP_CHALLENGE);\n\tif (challenge) {\n\t\tmemcpy(ptr, challenge->strvalue, challenge->length);\n\t\ti += challenge->length;\n\t} else {\n\t\tmemcpy(ptr, packet->vector, AUTH_VECTOR_LEN);\n\t\ti += AUTH_VECTOR_LEN;\n\t}\n\n\t*output = id;\n\tlibrad_md5_calc((u_char *)output + 1, (u_char *)string, i);\n\n\treturn 0;\n}\n\n\n/*\n *\tSeed the random number generator.\n *\n *\tMay be called any number of times.\n */\nvoid lrad_rand_seed(const void *data, size_t size)\n{\n\tuint32_t hash;\n\n\t/*\n\t *\tEnsure that the pool is initialized.\n\t */\n\tif (lrad_rand_index < 0) {\n\t\tint fd;\n\t\t\n\t\tmemset(&lrad_rand_pool, 0, sizeof(lrad_rand_pool));\n\n\t\tfd = open(\"/dev/urandom\", O_RDONLY);\n\t\tif (fd >= 0) {\n\t\t\tsize_t total;\n\t\t\tssize_t this;\n\n\t\t\ttotal = this = 0;\n\t\t\twhile (total < sizeof(lrad_rand_pool.randrsl)) {\n\t\t\t\tthis = read(fd, lrad_rand_pool.randrsl,\n\t\t\t\t\t    sizeof(lrad_rand_pool.randrsl) - total);\n\t\t\t\tif ((this < 0) && (errno != EINTR)) break;\n\t\t\t\tif (this > 0) total += this;\n \t\t\t}\n\t\t\tclose(fd);\n\t\t} else {\n\t\t\tlrad_rand_pool.randrsl[0] = fd;\n\t\t\tlrad_rand_pool.randrsl[1] = time(NULL);\n\t\t\tlrad_rand_pool.randrsl[2] = errno;\n\t\t}\n\n\t\tlrad_randinit(&lrad_rand_pool, 1);\n\t\tlrad_rand_index = 0;\n\t}\n\n\tif (!data) return;\n\n\t/*\n\t *\tHash the user data\n\t */\n\thash = lrad_hash(data, size);\n\t\n\tlrad_rand_pool.randrsl[lrad_rand_index & 0xff] ^= hash;\n\tlrad_rand_index++;\n\tlrad_rand_index &= 0xff;\n\n\t/*\n\t *\tChurn the pool every so often after seeding it.\n\t */\n\tif (((int) (hash & 0xff)) == lrad_rand_index) {\n\t\tlrad_isaac(&lrad_rand_pool);\n\t}\n}\n\n\n/*\n *\tReturn a 32-bit random number.\n */\nuint32_t lrad_rand(void)\n{\n\tuint32_t num;\n\n\t/*\n\t *\tEnsure that the pool is initialized.\n\t */\n\tif (lrad_rand_index < 0) {\n\t\tlrad_rand_seed(NULL, 0);\n\t}\n\n\t/*\n\t *\tWe don't return data directly from the pool.\n\t *\tRather, we return a summary of the data.\n\t */\n\tnum = lrad_rand_pool.randrsl[lrad_rand_index & 0xff];\n\tlrad_rand_index++;\n\tlrad_rand_index &= 0xff;\n\n\t/*\n\t *\tEvery so often, churn the pool.\n\t */\n\tif (((int) (num & 0xff)) == lrad_rand_index) {\n\t\tlrad_isaac(&lrad_rand_pool);\n\t}\n\n\treturn num;\n}\n\n/*\n *\tAllocate a new RADIUS_PACKET\n */\nRADIUS_PACKET *rad_alloc(int newvector)\n{\n\tRADIUS_PACKET\t*rp;\n\n\tif ((rp = malloc(sizeof(RADIUS_PACKET))) == NULL) {\n\t\tlibrad_log(\"out of memory\");\n\t\treturn NULL;\n\t}\n\tmemset(rp, 0, sizeof(RADIUS_PACKET));\n\tif (newvector) {\n\t\tint i;\n\t\tuint32_t hash, base;\n\n\t\t/*\n\t\t *\tDon't expose the actual contents of the random\n\t\t *\tpool.\n\t\t */\n\t\tbase = lrad_rand();\n\t\tfor (i = 0; i < AUTH_VECTOR_LEN; i += sizeof(uint32_t)) {\n\t\t\thash = lrad_rand() ^ base;\n\t\t\tmemcpy(rp->vector + i, &hash, sizeof(hash));\n\t\t}\n\t}\n\tlrad_rand();\n\n\treturn rp;\n}\n\n/*\n *\tFree a RADIUS_PACKET\n */\nvoid rad_free(RADIUS_PACKET **radius_packet_ptr)\n{\n\tRADIUS_PACKET *radius_packet;\n\n\tif (!radius_packet_ptr) return;\n\tradius_packet = *radius_packet_ptr;\n\n\tif (radius_packet->data) free(radius_packet->data);\n\tif (radius_packet->vps) pairfree(&radius_packet->vps);\n\n\tfree(radius_packet);\n\n\t*radius_packet_ptr = NULL;\n}\n"], "filenames": ["src/lib/radius.c"], "buggy_code_start_loc": [1966], "buggy_code_end_loc": [1978], "fixing_code_start_loc": [1967], "fixing_code_end_loc": [1985], "type": "NVD-CWE-Other", "message": "The rad_decode function in FreeRADIUS before 1.1.8 allows remote attackers to cause a denial of service (radiusd crash) via zero-length Tunnel-Password attributes, as demonstrated by a certain module in VulnDisco Pack Professional 7.6 through 8.11.  NOTE: this is a regression error related to CVE-2003-0967.", "other": {"cve": {"id": "CVE-2009-3111", "sourceIdentifier": "cve@mitre.org", "published": "2009-09-09T18:30:00.860", "lastModified": "2017-09-19T01:29:28.047", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The rad_decode function in FreeRADIUS before 1.1.8 allows remote attackers to cause a denial of service (radiusd crash) via zero-length Tunnel-Password attributes, as demonstrated by a certain module in VulnDisco Pack Professional 7.6 through 8.11.  NOTE: this is a regression error related to CVE-2003-0967."}, {"lang": "es", "value": "La funci\u00f3n rad_decode FreeRADIUS  anterior a v1.1.8, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de radiusd) a trav\u00e9s de los atributos zero-length Tunnel-Password. NOTA: esto es una regresi\u00f3n al error relacionado con el CVE-2003-0967."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.7", "matchCriteriaId": "F6D6F259-6145-48C9-A81B-5A331F43A76D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.2:*:*:*:*:*:*:*", "matchCriteriaId": "5AEDD86F-92B9-43EC-80E3-54010E249FC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "BFDB110B-4057-4BA4-993A-9DA14888A093"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.4:*:*:*:*:*:*:*", "matchCriteriaId": "52C8708B-4D1A-48A7-87DF-DF4B53E66D06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "0369C1A6-A0FE-4BF8-89F5-5ED384565DAC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.8:*:*:*:*:*:*:*", "matchCriteriaId": "1638CC08-8886-4863-8532-883A8616592F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "0E4FD4F2-0449-4562-ABF2-927206CB77DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "636F3F00-97A5-4497-A6A9-722AFC5BD689"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "EECDFCD7-0189-4C59-842D-C5F9064033A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "1D3EC2A3-5FB6-4D39-B1EA-C8E17AF1F0B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:0.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "AD634946-ED9B-47EB-8D0F-88EA6057D17C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "49152208-4DBD-4AF7-BCB3-3D56650899F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "90AF846A-F239-4963-B260-7CB48334B8B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "E95ADE53-BFBE-4B06-A1BF-EF576D567554"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "3F03F8FE-80BA-41A3-85CE-FFB6A18E6DCE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "4C48FE12-68CB-462D-B75E-204894325F5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "1321F1E7-4B14-4B16-91D0-AE9E9951D12A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "313EFEC5-1580-4ACE-BB9C-84E3714F2C37"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B93BEF0-09C1-4DF8-8761-582DE975F306"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "4F927232-6275-497E-BF09-B4DCF19642C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "F07F89D7-504B-4892-9840-A3FED5274F5A"}]}]}], "references": [{"url": "http://github.com/alandekok/freeradius-server/commit/860cad9e02ba344edb0038419e415fe05a9a01f4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://intevydis.com/vd-list.shtml", "source": "cve@mitre.org"}, {"url": "http://lists.apple.com/archives/security-announce/2009/Nov/msg00000.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2009-10/msg00001.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2009-11/msg00004.html", "source": "cve@mitre.org"}, {"url": "http://support.apple.com/kb/HT3937", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2009/09/09/1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.redhat.com/support/errata/RHSA-2009-1451.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/36263", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2009/3184", "source": "cve@mitre.org"}, {"url": "https://oval.cisecurity.org/repository/search/definition/oval%3Aorg.mitre.oval%3Adef%3A9919", "source": "cve@mitre.org"}]}, "github_commit_url": "http://github.com/alandekok/freeradius-server/commit/860cad9e02ba344edb0038419e415fe05a9a01f4"}}