{"buggy_code": ["/* libguestfs\n * Copyright (C) 2010-2012 Red Hat Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n#ifdef HAVE_ENDIAN_H\n#include <endian.h>\n#endif\n\n#include <pcre.h>\n\n#include \"ignore-value.h\"\n#include \"xstrtol.h\"\n\n#include \"guestfs.h\"\n#include \"guestfs-internal.h\"\n#include \"guestfs-internal-actions.h\"\n#include \"guestfs_protocol.h\"\n\n/* Compile all the regular expressions once when the shared library is\n * loaded.  PCRE is thread safe so we're supposedly OK here if\n * multiple threads call into the libguestfs API functions below\n * simultaneously.\n */\nstatic pcre *re_first_partition;\nstatic pcre *re_major_minor;\n\nstatic void compile_regexps (void) __attribute__((constructor));\nstatic void free_regexps (void) __attribute__((destructor));\n\nstatic void\ncompile_regexps (void)\n{\n  const char *err;\n  int offset;\n\n#define COMPILE(re,pattern,options)                                     \\\n  do {                                                                  \\\n    re = pcre_compile ((pattern), (options), &err, &offset, NULL);      \\\n    if (re == NULL) {                                                   \\\n      ignore_value (write (2, err, strlen (err)));                      \\\n      abort ();                                                         \\\n    }                                                                   \\\n  } while (0)\n\n  COMPILE (re_first_partition, \"^/dev/(?:h|s|v)d.1$\", 0);\n  COMPILE (re_major_minor, \"(\\\\d+)\\\\.(\\\\d+)\", 0);\n}\n\nstatic void\nfree_regexps (void)\n{\n  pcre_free (re_first_partition);\n  pcre_free (re_major_minor);\n}\n\nstatic int check_filesystem (guestfs_h *g, const char *mountable,\n                             const struct guestfs_internal_mountable *m,\n                             int whole_device);\nstatic int extend_fses (guestfs_h *g);\n\n/* Find out if 'device' contains a filesystem.  If it does, add\n * another entry in g->fses.\n */\nint\nguestfs___check_for_filesystem_on (guestfs_h *g, const char *mountable)\n{\n  CLEANUP_FREE char *vfs_type = NULL;\n  int is_swap, r;\n  struct inspect_fs *fs;\n  CLEANUP_FREE_INTERNAL_MOUNTABLE struct guestfs_internal_mountable *m = NULL;\n  int whole_device = 0;\n\n  /* Get vfs-type in order to check if it's a Linux(?) swap device.\n   * If there's an error we should ignore it, so to do that we have to\n   * temporarily replace the error handler with a null one.\n   */\n  guestfs_push_error_handler (g, NULL, NULL);\n  vfs_type = guestfs_vfs_type (g, mountable);\n  guestfs_pop_error_handler (g);\n\n  is_swap = vfs_type && STREQ (vfs_type, \"swap\");\n  debug (g, \"check_for_filesystem_on: %s (%s)\",\n         mountable, vfs_type ? vfs_type : \"failed to get vfs type\");\n\n  if (is_swap) {\n    if (extend_fses (g) == -1)\n      return -1;\n    fs = &g->fses[g->nr_fses-1];\n    fs->mountable = safe_strdup (g, mountable);\n    return 0;\n  }\n\n  m = guestfs_internal_parse_mountable (g, mountable);\n  if (m == NULL)\n    return -1;\n\n  /* If it's a whole device, see if it is an install ISO. */\n  if (m->im_type == MOUNTABLE_DEVICE) {\n    whole_device = guestfs_is_whole_device (g, m->im_device);\n    if (whole_device == -1) {\n      return -1;\n    }\n  }\n\n  if (whole_device) {\n    if (extend_fses (g) == -1)\n      return -1;\n    fs = &g->fses[g->nr_fses-1];\n\n    r = guestfs___check_installer_iso (g, fs, m->im_device);\n    if (r == -1) {              /* Fatal error. */\n      g->nr_fses--;\n      return -1;\n    }\n    if (r > 0)                  /* Found something. */\n      return 0;\n\n    /* Didn't find anything.  Fall through ... */\n    g->nr_fses--;\n  }\n\n  /* Try mounting the device.  As above, ignore errors. */\n  guestfs_push_error_handler (g, NULL, NULL);\n  if (vfs_type && STREQ (vfs_type, \"ufs\")) { /* Hack for the *BSDs. */\n    /* FreeBSD fs is a variant of ufs called ufs2 ... */\n    r = guestfs_mount_vfs (g, \"ro,ufstype=ufs2\", \"ufs\", mountable, \"/\");\n    if (r == -1)\n      /* while NetBSD and OpenBSD use another variant labeled 44bsd */\n      r = guestfs_mount_vfs (g, \"ro,ufstype=44bsd\", \"ufs\", mountable, \"/\");\n  } else {\n    r = guestfs_mount_ro (g, mountable, \"/\");\n  }\n  guestfs_pop_error_handler (g);\n  if (r == -1)\n    return 0;\n\n  /* Do the rest of the checks. */\n  r = check_filesystem (g, mountable, m, whole_device);\n\n  /* Unmount the filesystem. */\n  if (guestfs_umount_all (g) == -1)\n    return -1;\n\n  return r;\n}\n\nstatic int\ncheck_filesystem (guestfs_h *g, const char *mountable,\n                  const struct guestfs_internal_mountable *m,\n                  int whole_device)\n{\n  if (extend_fses (g) == -1)\n    return -1;\n\n  int partnum = -1;\n  if (!whole_device && m->im_type == MOUNTABLE_DEVICE) {\n    guestfs_push_error_handler (g, NULL, NULL);\n    partnum = guestfs_part_to_partnum (g, m->im_device);\n    guestfs_pop_error_handler (g);\n  }\n\n  struct inspect_fs *fs = &g->fses[g->nr_fses-1];\n\n  fs->mountable = safe_strdup (g, mountable);\n\n  /* Optimize some of the tests by avoiding multiple tests of the same thing. */\n  int is_dir_etc = guestfs_is_dir (g, \"/etc\") > 0;\n  int is_dir_bin = guestfs_is_dir (g, \"/bin\") > 0;\n  int is_dir_share = guestfs_is_dir (g, \"/share\") > 0;\n\n  /* Grub /boot? */\n  if (guestfs_is_file (g, \"/grub/menu.lst\") > 0 ||\n      guestfs_is_file (g, \"/grub/grub.conf\") > 0 ||\n      guestfs_is_file (g, \"/grub2/grub.cfg\") > 0)\n    ;\n  /* FreeBSD root? */\n  else if (is_dir_etc &&\n           is_dir_bin &&\n           guestfs_is_file (g, \"/etc/freebsd-update.conf\") > 0 &&\n           guestfs_is_file (g, \"/etc/fstab\") > 0) {\n    /* Ignore /dev/sda1 which is a shadow of the real root filesystem\n     * that is probably /dev/sda5 (see:\n     * http://www.freebsd.org/doc/handbook/disk-organization.html)\n     */\n    if (m->im_type == MOUNTABLE_DEVICE &&\n        match (g, m->im_device, re_first_partition))\n      return 0;\n\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    if (guestfs___check_freebsd_root (g, fs) == -1)\n      return -1;\n  }\n  else if (is_dir_etc &&\n           is_dir_bin &&\n           guestfs_is_file (g, \"/etc/fstab\") > 0 &&\n           guestfs_is_file (g, \"/etc/release\") > 0) {\n    /* Ignore /dev/sda1 which is a shadow of the real root filesystem\n     * that is probably /dev/sda5 (see:\n     * http://www.freebsd.org/doc/handbook/disk-organization.html)\n     */\n    if (m->im_type == MOUNTABLE_DEVICE &&\n        match (g, m->im_device, re_first_partition))\n      return 0;\n\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    if (guestfs___check_netbsd_root (g, fs) == -1)\n      return -1;\n  }\n  /* Hurd root? */\n  else if (guestfs_is_file (g, \"/hurd/console\") > 0 &&\n           guestfs_is_file (g, \"/hurd/hello\") > 0 &&\n           guestfs_is_file (g, \"/hurd/null\") > 0) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED; /* XXX could be more specific */\n    if (guestfs___check_hurd_root (g, fs) == -1)\n      return -1;\n  }\n  /* Linux root? */\n  else if (is_dir_etc &&\n           (is_dir_bin ||\n            (guestfs_is_symlink (g, \"/bin\") > 0 &&\n             guestfs_is_dir (g, \"/usr/bin\") > 0)) &&\n           guestfs_is_file (g, \"/etc/fstab\") > 0) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    if (guestfs___check_linux_root (g, fs) == -1)\n      return -1;\n  }\n  /* Linux /usr/local? */\n  else if (is_dir_etc &&\n           is_dir_bin &&\n           is_dir_share &&\n           guestfs_exists (g, \"/local\") == 0 &&\n           guestfs_is_file (g, \"/etc/fstab\") == 0)\n    ;\n  /* Linux /usr? */\n  else if (is_dir_etc &&\n           is_dir_bin &&\n           is_dir_share &&\n           guestfs_exists (g, \"/local\") > 0 &&\n           guestfs_is_file (g, \"/etc/fstab\") == 0)\n    ;\n  /* Linux /var? */\n  else if (guestfs_is_dir (g, \"/log\") > 0 &&\n           guestfs_is_dir (g, \"/run\") > 0 &&\n           guestfs_is_dir (g, \"/spool\") > 0)\n    ;\n  /* Windows root? */\n  else if (guestfs___has_windows_systemroot (g) >= 0) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    if (guestfs___check_windows_root (g, fs) == -1)\n      return -1;\n  }\n  /* Windows volume with installed applications (but not root)? */\n  else if (guestfs___is_dir_nocase (g, \"/System Volume Information\") > 0 &&\n           guestfs___is_dir_nocase (g, \"/Program Files\") > 0)\n    ;\n  /* Windows volume (but not root)? */\n  else if (guestfs___is_dir_nocase (g, \"/System Volume Information\") > 0)\n    ;\n  /* FreeDOS? */\n  else if (guestfs___is_dir_nocase (g, \"/FDOS\") > 0 &&\n           guestfs___is_file_nocase (g, \"/FDOS/FREEDOS.BSS\") > 0) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    fs->type = OS_TYPE_DOS;\n    fs->distro = OS_DISTRO_FREEDOS;\n    /* FreeDOS is a mix of 16 and 32 bit, but assume it requires a\n     * 32 bit i386 processor.\n     */\n    fs->arch = safe_strdup (g, \"i386\");\n  }\n  /* Install CD/disk?\n   *\n   * Note that we checked (above) for an install ISO, but there are\n   * other types of install image (eg. USB keys) which that check\n   * wouldn't have picked up.\n   *\n   * Skip these checks if it's not a whole device (eg. CD) or the\n   * first partition (eg. bootable USB key).\n   */\n  else if ((whole_device || partnum == 1) &&\n           (guestfs_is_file (g, \"/isolinux/isolinux.cfg\") > 0 ||\n            guestfs_is_dir (g, \"/EFI/BOOT\") > 0 ||\n            guestfs_is_file (g, \"/images/install.img\") > 0 ||\n            guestfs_is_dir (g, \"/.disk\") > 0 ||\n            guestfs_is_file (g, \"/.discinfo\") > 0 ||\n            guestfs_is_file (g, \"/i386/txtsetup.sif\") > 0 ||\n            guestfs_is_file (g, \"/amd64/txtsetup.sif\") > 0 ||\n            guestfs_is_file (g, \"/freedos/freedos.ico\") > 0)) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLER;\n    if (guestfs___check_installer_root (g, fs) == -1)\n      return -1;\n  }\n\n  /* The above code should have set fs->type and fs->distro fields, so\n   * we can now guess the package management system.\n   */\n  guestfs___check_package_format (g, fs);\n  guestfs___check_package_management (g, fs);\n\n  return 0;\n}\n\nstatic int\nextend_fses (guestfs_h *g)\n{\n  size_t n = g->nr_fses + 1;\n  struct inspect_fs *p;\n\n  p = realloc (g->fses, n * sizeof (struct inspect_fs));\n  if (p == NULL) {\n    perrorf (g, \"realloc\");\n    return -1;\n  }\n\n  g->fses = p;\n  g->nr_fses = n;\n\n  memset (&g->fses[n-1], 0, sizeof (struct inspect_fs));\n\n  return 0;\n}\n\nint\nguestfs___is_file_nocase (guestfs_h *g, const char *path)\n{\n  CLEANUP_FREE char *p = NULL;\n  int r;\n\n  p = guestfs___case_sensitive_path_silently (g, path);\n  if (!p)\n    return 0;\n  r = guestfs_is_file (g, p);\n  return r > 0;\n}\n\nint\nguestfs___is_dir_nocase (guestfs_h *g, const char *path)\n{\n  CLEANUP_FREE char *p = NULL;\n  int r;\n\n  p = guestfs___case_sensitive_path_silently (g, path);\n  if (!p)\n    return 0;\n  r = guestfs_is_dir (g, p);\n  return r > 0;\n}\n\n/* Parse small, unsigned ints, as used in version numbers. */\nint\nguestfs___parse_unsigned_int (guestfs_h *g, const char *str)\n{\n  long ret;\n  int r = xstrtol (str, NULL, 10, &ret, \"\");\n  if (r != LONGINT_OK) {\n    error (g, _(\"could not parse integer in version number: %s\"), str);\n    return -1;\n  }\n  return ret;\n}\n\n/* Like parse_unsigned_int, but ignore trailing stuff. */\nint\nguestfs___parse_unsigned_int_ignore_trailing (guestfs_h *g, const char *str)\n{\n  long ret;\n  int r = xstrtol (str, NULL, 10, &ret, NULL);\n  if (r != LONGINT_OK) {\n    error (g, _(\"could not parse integer in version number: %s\"), str);\n    return -1;\n  }\n  return ret;\n}\n\n/* Parse generic MAJOR.MINOR from the fs->product_name string. */\nint\nguestfs___parse_major_minor (guestfs_h *g, struct inspect_fs *fs)\n{\n  char *major, *minor;\n\n  if (match2 (g, fs->product_name, re_major_minor, &major, &minor)) {\n    fs->major_version = guestfs___parse_unsigned_int (g, major);\n    free (major);\n    if (fs->major_version == -1) {\n      free (minor);\n      return -1;\n    }\n    fs->minor_version = guestfs___parse_unsigned_int (g, minor);\n    free (minor);\n    if (fs->minor_version == -1)\n      return -1;\n  }\n  return 0;\n}\n\n/* At the moment, package format and package management is just a\n * simple function of the distro and major_version fields, so these\n * can never return an error.  We might be cleverer in future.\n */\nvoid\nguestfs___check_package_format (guestfs_h *g, struct inspect_fs *fs)\n{\n  switch (fs->distro) {\n  case OS_DISTRO_FEDORA:\n  case OS_DISTRO_MEEGO:\n  case OS_DISTRO_REDHAT_BASED:\n  case OS_DISTRO_RHEL:\n  case OS_DISTRO_MAGEIA:\n  case OS_DISTRO_MANDRIVA:\n  case OS_DISTRO_SUSE_BASED:\n  case OS_DISTRO_OPENSUSE:\n  case OS_DISTRO_SLES:\n  case OS_DISTRO_CENTOS:\n  case OS_DISTRO_SCIENTIFIC_LINUX:\n    fs->package_format = OS_PACKAGE_FORMAT_RPM;\n    break;\n\n  case OS_DISTRO_DEBIAN:\n  case OS_DISTRO_UBUNTU:\n  case OS_DISTRO_LINUX_MINT:\n    fs->package_format = OS_PACKAGE_FORMAT_DEB;\n    break;\n\n  case OS_DISTRO_ARCHLINUX:\n    fs->package_format = OS_PACKAGE_FORMAT_PACMAN;\n    break;\n  case OS_DISTRO_GENTOO:\n    fs->package_format = OS_PACKAGE_FORMAT_EBUILD;\n    break;\n  case OS_DISTRO_PARDUS:\n    fs->package_format = OS_PACKAGE_FORMAT_PISI;\n    break;\n\n  case OS_DISTRO_SLACKWARE:\n  case OS_DISTRO_TTYLINUX:\n  case OS_DISTRO_WINDOWS:\n  case OS_DISTRO_BUILDROOT:\n  case OS_DISTRO_CIRROS:\n  case OS_DISTRO_FREEDOS:\n  case OS_DISTRO_OPENBSD:\n  case OS_DISTRO_UNKNOWN:\n    fs->package_format = OS_PACKAGE_FORMAT_UNKNOWN;\n    break;\n  }\n}\n\nvoid\nguestfs___check_package_management (guestfs_h *g, struct inspect_fs *fs)\n{\n  switch (fs->distro) {\n  case OS_DISTRO_FEDORA:\n  case OS_DISTRO_MEEGO:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_YUM;\n    break;\n\n  case OS_DISTRO_REDHAT_BASED:\n  case OS_DISTRO_RHEL:\n  case OS_DISTRO_CENTOS:\n  case OS_DISTRO_SCIENTIFIC_LINUX:\n    if (fs->major_version >= 5)\n      fs->package_management = OS_PACKAGE_MANAGEMENT_YUM;\n    else\n      fs->package_management = OS_PACKAGE_MANAGEMENT_UP2DATE;\n    break;\n\n  case OS_DISTRO_DEBIAN:\n  case OS_DISTRO_UBUNTU:\n  case OS_DISTRO_LINUX_MINT:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_APT;\n    break;\n\n  case OS_DISTRO_ARCHLINUX:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_PACMAN;\n    break;\n  case OS_DISTRO_GENTOO:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_PORTAGE;\n    break;\n  case OS_DISTRO_PARDUS:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_PISI;\n    break;\n  case OS_DISTRO_MAGEIA:\n  case OS_DISTRO_MANDRIVA:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_URPMI;\n    break;\n\n  case OS_DISTRO_SUSE_BASED:\n  case OS_DISTRO_OPENSUSE:\n  case OS_DISTRO_SLES:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_ZYPPER;\n    break;\n\n  case OS_DISTRO_SLACKWARE:\n  case OS_DISTRO_TTYLINUX:\n  case OS_DISTRO_WINDOWS:\n  case OS_DISTRO_BUILDROOT:\n  case OS_DISTRO_CIRROS:\n  case OS_DISTRO_FREEDOS:\n  case OS_DISTRO_OPENBSD:\n  case OS_DISTRO_UNKNOWN:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_UNKNOWN;\n    break;\n  }\n}\n\n/* Get the first line of a small file, without any trailing newline\n * character.\n *\n * NOTE: If the file is completely empty or begins with a '\\n'\n * character, this returns an empty string (not NULL).  The caller\n * will usually need to check for this case.\n */\nchar *\nguestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; /* sic: not CLEANUP_FREE_STRING_LIST */\n  int64_t size;\n  char *ret;\n\n  /* Don't trust guestfs_head_n not to break with very large files.\n   * Check the file size is something reasonable first.\n   */\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    /* guestfs_filesize failed and has already set error in handle */\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    /* Empty file: Return an empty string as explained above. */\n    return safe_strdup (g, \"\");\n  }\n  /* lines[1] should be NULL because of '1' argument above ... */\n\n  ret = lines[0];               /* caller frees */\n\n  return ret;\n}\n\n/* Get the first matching line (using egrep [-i]) of a small file,\n * without any trailing newline character.\n *\n * Returns: 1 = returned a line (in *ret)\n *          0 = no match\n *          -1 = error\n */\nint\nguestfs___first_egrep_of_file (guestfs_h *g, const char *filename,\n                               const char *eregex, int iflag, char **ret)\n{\n  char **lines;\n  int64_t size;\n  size_t i;\n  struct guestfs_grep_opts_argv optargs;\n\n  /* Don't trust guestfs_grep not to break with very large files.\n   * Check the file size is something reasonable first.\n   */\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    /* guestfs_filesize failed and has already set error in handle */\n    return -1;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return -1;\n  }\n\n  optargs.bitmask = GUESTFS_GREP_OPTS_EXTENDED_BITMASK;\n  optargs.extended = 1;\n  if (iflag) {\n    optargs.bitmask |= GUESTFS_GREP_OPTS_INSENSITIVE_BITMASK;\n    optargs.insensitive = 1;\n  }\n  lines = guestfs_grep_opts_argv (g, eregex, filename, &optargs);\n  if (lines == NULL)\n    return -1;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return 0;\n  }\n\n  *ret = lines[0];              /* caller frees */\n\n  /* free up any other matches and the array itself */\n  for (i = 1; lines[i] != NULL; ++i)\n    free (lines[i]);\n  free (lines);\n\n  return 1;\n}\n"], "fixing_code": ["/* libguestfs\n * Copyright (C) 2010-2012 Red Hat Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n#ifdef HAVE_ENDIAN_H\n#include <endian.h>\n#endif\n\n#include <pcre.h>\n\n#include \"ignore-value.h\"\n#include \"xstrtol.h\"\n\n#include \"guestfs.h\"\n#include \"guestfs-internal.h\"\n#include \"guestfs-internal-actions.h\"\n#include \"guestfs_protocol.h\"\n\n/* Compile all the regular expressions once when the shared library is\n * loaded.  PCRE is thread safe so we're supposedly OK here if\n * multiple threads call into the libguestfs API functions below\n * simultaneously.\n */\nstatic pcre *re_first_partition;\nstatic pcre *re_major_minor;\n\nstatic void compile_regexps (void) __attribute__((constructor));\nstatic void free_regexps (void) __attribute__((destructor));\n\nstatic void\ncompile_regexps (void)\n{\n  const char *err;\n  int offset;\n\n#define COMPILE(re,pattern,options)                                     \\\n  do {                                                                  \\\n    re = pcre_compile ((pattern), (options), &err, &offset, NULL);      \\\n    if (re == NULL) {                                                   \\\n      ignore_value (write (2, err, strlen (err)));                      \\\n      abort ();                                                         \\\n    }                                                                   \\\n  } while (0)\n\n  COMPILE (re_first_partition, \"^/dev/(?:h|s|v)d.1$\", 0);\n  COMPILE (re_major_minor, \"(\\\\d+)\\\\.(\\\\d+)\", 0);\n}\n\nstatic void\nfree_regexps (void)\n{\n  pcre_free (re_first_partition);\n  pcre_free (re_major_minor);\n}\n\nstatic int check_filesystem (guestfs_h *g, const char *mountable,\n                             const struct guestfs_internal_mountable *m,\n                             int whole_device);\nstatic int extend_fses (guestfs_h *g);\n\n/* Find out if 'device' contains a filesystem.  If it does, add\n * another entry in g->fses.\n */\nint\nguestfs___check_for_filesystem_on (guestfs_h *g, const char *mountable)\n{\n  CLEANUP_FREE char *vfs_type = NULL;\n  int is_swap, r;\n  struct inspect_fs *fs;\n  CLEANUP_FREE_INTERNAL_MOUNTABLE struct guestfs_internal_mountable *m = NULL;\n  int whole_device = 0;\n\n  /* Get vfs-type in order to check if it's a Linux(?) swap device.\n   * If there's an error we should ignore it, so to do that we have to\n   * temporarily replace the error handler with a null one.\n   */\n  guestfs_push_error_handler (g, NULL, NULL);\n  vfs_type = guestfs_vfs_type (g, mountable);\n  guestfs_pop_error_handler (g);\n\n  is_swap = vfs_type && STREQ (vfs_type, \"swap\");\n  debug (g, \"check_for_filesystem_on: %s (%s)\",\n         mountable, vfs_type ? vfs_type : \"failed to get vfs type\");\n\n  if (is_swap) {\n    if (extend_fses (g) == -1)\n      return -1;\n    fs = &g->fses[g->nr_fses-1];\n    fs->mountable = safe_strdup (g, mountable);\n    return 0;\n  }\n\n  m = guestfs_internal_parse_mountable (g, mountable);\n  if (m == NULL)\n    return -1;\n\n  /* If it's a whole device, see if it is an install ISO. */\n  if (m->im_type == MOUNTABLE_DEVICE) {\n    whole_device = guestfs_is_whole_device (g, m->im_device);\n    if (whole_device == -1) {\n      return -1;\n    }\n  }\n\n  if (whole_device) {\n    if (extend_fses (g) == -1)\n      return -1;\n    fs = &g->fses[g->nr_fses-1];\n\n    r = guestfs___check_installer_iso (g, fs, m->im_device);\n    if (r == -1) {              /* Fatal error. */\n      g->nr_fses--;\n      return -1;\n    }\n    if (r > 0)                  /* Found something. */\n      return 0;\n\n    /* Didn't find anything.  Fall through ... */\n    g->nr_fses--;\n  }\n\n  /* Try mounting the device.  As above, ignore errors. */\n  guestfs_push_error_handler (g, NULL, NULL);\n  if (vfs_type && STREQ (vfs_type, \"ufs\")) { /* Hack for the *BSDs. */\n    /* FreeBSD fs is a variant of ufs called ufs2 ... */\n    r = guestfs_mount_vfs (g, \"ro,ufstype=ufs2\", \"ufs\", mountable, \"/\");\n    if (r == -1)\n      /* while NetBSD and OpenBSD use another variant labeled 44bsd */\n      r = guestfs_mount_vfs (g, \"ro,ufstype=44bsd\", \"ufs\", mountable, \"/\");\n  } else {\n    r = guestfs_mount_ro (g, mountable, \"/\");\n  }\n  guestfs_pop_error_handler (g);\n  if (r == -1)\n    return 0;\n\n  /* Do the rest of the checks. */\n  r = check_filesystem (g, mountable, m, whole_device);\n\n  /* Unmount the filesystem. */\n  if (guestfs_umount_all (g) == -1)\n    return -1;\n\n  return r;\n}\n\nstatic int\ncheck_filesystem (guestfs_h *g, const char *mountable,\n                  const struct guestfs_internal_mountable *m,\n                  int whole_device)\n{\n  if (extend_fses (g) == -1)\n    return -1;\n\n  int partnum = -1;\n  if (!whole_device && m->im_type == MOUNTABLE_DEVICE) {\n    guestfs_push_error_handler (g, NULL, NULL);\n    partnum = guestfs_part_to_partnum (g, m->im_device);\n    guestfs_pop_error_handler (g);\n  }\n\n  struct inspect_fs *fs = &g->fses[g->nr_fses-1];\n\n  fs->mountable = safe_strdup (g, mountable);\n\n  /* Optimize some of the tests by avoiding multiple tests of the same thing. */\n  int is_dir_etc = guestfs_is_dir (g, \"/etc\") > 0;\n  int is_dir_bin = guestfs_is_dir (g, \"/bin\") > 0;\n  int is_dir_share = guestfs_is_dir (g, \"/share\") > 0;\n\n  /* Grub /boot? */\n  if (guestfs_is_file (g, \"/grub/menu.lst\") > 0 ||\n      guestfs_is_file (g, \"/grub/grub.conf\") > 0 ||\n      guestfs_is_file (g, \"/grub2/grub.cfg\") > 0)\n    ;\n  /* FreeBSD root? */\n  else if (is_dir_etc &&\n           is_dir_bin &&\n           guestfs_is_file (g, \"/etc/freebsd-update.conf\") > 0 &&\n           guestfs_is_file (g, \"/etc/fstab\") > 0) {\n    /* Ignore /dev/sda1 which is a shadow of the real root filesystem\n     * that is probably /dev/sda5 (see:\n     * http://www.freebsd.org/doc/handbook/disk-organization.html)\n     */\n    if (m->im_type == MOUNTABLE_DEVICE &&\n        match (g, m->im_device, re_first_partition))\n      return 0;\n\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    if (guestfs___check_freebsd_root (g, fs) == -1)\n      return -1;\n  }\n  else if (is_dir_etc &&\n           is_dir_bin &&\n           guestfs_is_file (g, \"/etc/fstab\") > 0 &&\n           guestfs_is_file (g, \"/etc/release\") > 0) {\n    /* Ignore /dev/sda1 which is a shadow of the real root filesystem\n     * that is probably /dev/sda5 (see:\n     * http://www.freebsd.org/doc/handbook/disk-organization.html)\n     */\n    if (m->im_type == MOUNTABLE_DEVICE &&\n        match (g, m->im_device, re_first_partition))\n      return 0;\n\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    if (guestfs___check_netbsd_root (g, fs) == -1)\n      return -1;\n  }\n  /* Hurd root? */\n  else if (guestfs_is_file (g, \"/hurd/console\") > 0 &&\n           guestfs_is_file (g, \"/hurd/hello\") > 0 &&\n           guestfs_is_file (g, \"/hurd/null\") > 0) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED; /* XXX could be more specific */\n    if (guestfs___check_hurd_root (g, fs) == -1)\n      return -1;\n  }\n  /* Linux root? */\n  else if (is_dir_etc &&\n           (is_dir_bin ||\n            (guestfs_is_symlink (g, \"/bin\") > 0 &&\n             guestfs_is_dir (g, \"/usr/bin\") > 0)) &&\n           guestfs_is_file (g, \"/etc/fstab\") > 0) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    if (guestfs___check_linux_root (g, fs) == -1)\n      return -1;\n  }\n  /* Linux /usr/local? */\n  else if (is_dir_etc &&\n           is_dir_bin &&\n           is_dir_share &&\n           guestfs_exists (g, \"/local\") == 0 &&\n           guestfs_is_file (g, \"/etc/fstab\") == 0)\n    ;\n  /* Linux /usr? */\n  else if (is_dir_etc &&\n           is_dir_bin &&\n           is_dir_share &&\n           guestfs_exists (g, \"/local\") > 0 &&\n           guestfs_is_file (g, \"/etc/fstab\") == 0)\n    ;\n  /* Linux /var? */\n  else if (guestfs_is_dir (g, \"/log\") > 0 &&\n           guestfs_is_dir (g, \"/run\") > 0 &&\n           guestfs_is_dir (g, \"/spool\") > 0)\n    ;\n  /* Windows root? */\n  else if (guestfs___has_windows_systemroot (g) >= 0) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    if (guestfs___check_windows_root (g, fs) == -1)\n      return -1;\n  }\n  /* Windows volume with installed applications (but not root)? */\n  else if (guestfs___is_dir_nocase (g, \"/System Volume Information\") > 0 &&\n           guestfs___is_dir_nocase (g, \"/Program Files\") > 0)\n    ;\n  /* Windows volume (but not root)? */\n  else if (guestfs___is_dir_nocase (g, \"/System Volume Information\") > 0)\n    ;\n  /* FreeDOS? */\n  else if (guestfs___is_dir_nocase (g, \"/FDOS\") > 0 &&\n           guestfs___is_file_nocase (g, \"/FDOS/FREEDOS.BSS\") > 0) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLED;\n    fs->type = OS_TYPE_DOS;\n    fs->distro = OS_DISTRO_FREEDOS;\n    /* FreeDOS is a mix of 16 and 32 bit, but assume it requires a\n     * 32 bit i386 processor.\n     */\n    fs->arch = safe_strdup (g, \"i386\");\n  }\n  /* Install CD/disk?\n   *\n   * Note that we checked (above) for an install ISO, but there are\n   * other types of install image (eg. USB keys) which that check\n   * wouldn't have picked up.\n   *\n   * Skip these checks if it's not a whole device (eg. CD) or the\n   * first partition (eg. bootable USB key).\n   */\n  else if ((whole_device || partnum == 1) &&\n           (guestfs_is_file (g, \"/isolinux/isolinux.cfg\") > 0 ||\n            guestfs_is_dir (g, \"/EFI/BOOT\") > 0 ||\n            guestfs_is_file (g, \"/images/install.img\") > 0 ||\n            guestfs_is_dir (g, \"/.disk\") > 0 ||\n            guestfs_is_file (g, \"/.discinfo\") > 0 ||\n            guestfs_is_file (g, \"/i386/txtsetup.sif\") > 0 ||\n            guestfs_is_file (g, \"/amd64/txtsetup.sif\") > 0 ||\n            guestfs_is_file (g, \"/freedos/freedos.ico\") > 0)) {\n    fs->is_root = 1;\n    fs->format = OS_FORMAT_INSTALLER;\n    if (guestfs___check_installer_root (g, fs) == -1)\n      return -1;\n  }\n\n  /* The above code should have set fs->type and fs->distro fields, so\n   * we can now guess the package management system.\n   */\n  guestfs___check_package_format (g, fs);\n  guestfs___check_package_management (g, fs);\n\n  return 0;\n}\n\nstatic int\nextend_fses (guestfs_h *g)\n{\n  size_t n = g->nr_fses + 1;\n  struct inspect_fs *p;\n\n  p = realloc (g->fses, n * sizeof (struct inspect_fs));\n  if (p == NULL) {\n    perrorf (g, \"realloc\");\n    return -1;\n  }\n\n  g->fses = p;\n  g->nr_fses = n;\n\n  memset (&g->fses[n-1], 0, sizeof (struct inspect_fs));\n\n  return 0;\n}\n\nint\nguestfs___is_file_nocase (guestfs_h *g, const char *path)\n{\n  CLEANUP_FREE char *p = NULL;\n  int r;\n\n  p = guestfs___case_sensitive_path_silently (g, path);\n  if (!p)\n    return 0;\n  r = guestfs_is_file (g, p);\n  return r > 0;\n}\n\nint\nguestfs___is_dir_nocase (guestfs_h *g, const char *path)\n{\n  CLEANUP_FREE char *p = NULL;\n  int r;\n\n  p = guestfs___case_sensitive_path_silently (g, path);\n  if (!p)\n    return 0;\n  r = guestfs_is_dir (g, p);\n  return r > 0;\n}\n\n/* Parse small, unsigned ints, as used in version numbers. */\nint\nguestfs___parse_unsigned_int (guestfs_h *g, const char *str)\n{\n  long ret;\n  int r = xstrtol (str, NULL, 10, &ret, \"\");\n  if (r != LONGINT_OK) {\n    error (g, _(\"could not parse integer in version number: %s\"), str);\n    return -1;\n  }\n  return ret;\n}\n\n/* Like parse_unsigned_int, but ignore trailing stuff. */\nint\nguestfs___parse_unsigned_int_ignore_trailing (guestfs_h *g, const char *str)\n{\n  long ret;\n  int r = xstrtol (str, NULL, 10, &ret, NULL);\n  if (r != LONGINT_OK) {\n    error (g, _(\"could not parse integer in version number: %s\"), str);\n    return -1;\n  }\n  return ret;\n}\n\n/* Parse generic MAJOR.MINOR from the fs->product_name string. */\nint\nguestfs___parse_major_minor (guestfs_h *g, struct inspect_fs *fs)\n{\n  char *major, *minor;\n\n  if (match2 (g, fs->product_name, re_major_minor, &major, &minor)) {\n    fs->major_version = guestfs___parse_unsigned_int (g, major);\n    free (major);\n    if (fs->major_version == -1) {\n      free (minor);\n      return -1;\n    }\n    fs->minor_version = guestfs___parse_unsigned_int (g, minor);\n    free (minor);\n    if (fs->minor_version == -1)\n      return -1;\n  }\n  return 0;\n}\n\n/* At the moment, package format and package management is just a\n * simple function of the distro and major_version fields, so these\n * can never return an error.  We might be cleverer in future.\n */\nvoid\nguestfs___check_package_format (guestfs_h *g, struct inspect_fs *fs)\n{\n  switch (fs->distro) {\n  case OS_DISTRO_FEDORA:\n  case OS_DISTRO_MEEGO:\n  case OS_DISTRO_REDHAT_BASED:\n  case OS_DISTRO_RHEL:\n  case OS_DISTRO_MAGEIA:\n  case OS_DISTRO_MANDRIVA:\n  case OS_DISTRO_SUSE_BASED:\n  case OS_DISTRO_OPENSUSE:\n  case OS_DISTRO_SLES:\n  case OS_DISTRO_CENTOS:\n  case OS_DISTRO_SCIENTIFIC_LINUX:\n    fs->package_format = OS_PACKAGE_FORMAT_RPM;\n    break;\n\n  case OS_DISTRO_DEBIAN:\n  case OS_DISTRO_UBUNTU:\n  case OS_DISTRO_LINUX_MINT:\n    fs->package_format = OS_PACKAGE_FORMAT_DEB;\n    break;\n\n  case OS_DISTRO_ARCHLINUX:\n    fs->package_format = OS_PACKAGE_FORMAT_PACMAN;\n    break;\n  case OS_DISTRO_GENTOO:\n    fs->package_format = OS_PACKAGE_FORMAT_EBUILD;\n    break;\n  case OS_DISTRO_PARDUS:\n    fs->package_format = OS_PACKAGE_FORMAT_PISI;\n    break;\n\n  case OS_DISTRO_SLACKWARE:\n  case OS_DISTRO_TTYLINUX:\n  case OS_DISTRO_WINDOWS:\n  case OS_DISTRO_BUILDROOT:\n  case OS_DISTRO_CIRROS:\n  case OS_DISTRO_FREEDOS:\n  case OS_DISTRO_OPENBSD:\n  case OS_DISTRO_UNKNOWN:\n    fs->package_format = OS_PACKAGE_FORMAT_UNKNOWN;\n    break;\n  }\n}\n\nvoid\nguestfs___check_package_management (guestfs_h *g, struct inspect_fs *fs)\n{\n  switch (fs->distro) {\n  case OS_DISTRO_FEDORA:\n  case OS_DISTRO_MEEGO:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_YUM;\n    break;\n\n  case OS_DISTRO_REDHAT_BASED:\n  case OS_DISTRO_RHEL:\n  case OS_DISTRO_CENTOS:\n  case OS_DISTRO_SCIENTIFIC_LINUX:\n    if (fs->major_version >= 5)\n      fs->package_management = OS_PACKAGE_MANAGEMENT_YUM;\n    else\n      fs->package_management = OS_PACKAGE_MANAGEMENT_UP2DATE;\n    break;\n\n  case OS_DISTRO_DEBIAN:\n  case OS_DISTRO_UBUNTU:\n  case OS_DISTRO_LINUX_MINT:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_APT;\n    break;\n\n  case OS_DISTRO_ARCHLINUX:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_PACMAN;\n    break;\n  case OS_DISTRO_GENTOO:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_PORTAGE;\n    break;\n  case OS_DISTRO_PARDUS:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_PISI;\n    break;\n  case OS_DISTRO_MAGEIA:\n  case OS_DISTRO_MANDRIVA:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_URPMI;\n    break;\n\n  case OS_DISTRO_SUSE_BASED:\n  case OS_DISTRO_OPENSUSE:\n  case OS_DISTRO_SLES:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_ZYPPER;\n    break;\n\n  case OS_DISTRO_SLACKWARE:\n  case OS_DISTRO_TTYLINUX:\n  case OS_DISTRO_WINDOWS:\n  case OS_DISTRO_BUILDROOT:\n  case OS_DISTRO_CIRROS:\n  case OS_DISTRO_FREEDOS:\n  case OS_DISTRO_OPENBSD:\n  case OS_DISTRO_UNKNOWN:\n    fs->package_management = OS_PACKAGE_MANAGEMENT_UNKNOWN;\n    break;\n  }\n}\n\n/* Get the first line of a small file, without any trailing newline\n * character.\n *\n * NOTE: If the file is completely empty or begins with a '\\n'\n * character, this returns an empty string (not NULL).  The caller\n * will usually need to check for this case.\n */\nchar *\nguestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  char **lines = NULL; /* sic: not CLEANUP_FREE_STRING_LIST */\n  int64_t size;\n  char *ret;\n\n  /* Don't trust guestfs_head_n not to break with very large files.\n   * Check the file size is something reasonable first.\n   */\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    /* guestfs_filesize failed and has already set error in handle */\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    /* Empty file: Return an empty string as explained above. */\n    return safe_strdup (g, \"\");\n  }\n  /* lines[1] should be NULL because of '1' argument above ... */\n\n  ret = lines[0];               /* caller frees */\n\n  free (lines);\n\n  return ret;\n}\n\n/* Get the first matching line (using egrep [-i]) of a small file,\n * without any trailing newline character.\n *\n * Returns: 1 = returned a line (in *ret)\n *          0 = no match\n *          -1 = error\n */\nint\nguestfs___first_egrep_of_file (guestfs_h *g, const char *filename,\n                               const char *eregex, int iflag, char **ret)\n{\n  char **lines;\n  int64_t size;\n  size_t i;\n  struct guestfs_grep_opts_argv optargs;\n\n  /* Don't trust guestfs_grep not to break with very large files.\n   * Check the file size is something reasonable first.\n   */\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    /* guestfs_filesize failed and has already set error in handle */\n    return -1;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return -1;\n  }\n\n  optargs.bitmask = GUESTFS_GREP_OPTS_EXTENDED_BITMASK;\n  optargs.extended = 1;\n  if (iflag) {\n    optargs.bitmask |= GUESTFS_GREP_OPTS_INSENSITIVE_BITMASK;\n    optargs.insensitive = 1;\n  }\n  lines = guestfs_grep_opts_argv (g, eregex, filename, &optargs);\n  if (lines == NULL)\n    return -1;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return 0;\n  }\n\n  *ret = lines[0];              /* caller frees */\n\n  /* free up any other matches and the array itself */\n  for (i = 1; lines[i] != NULL; ++i)\n    free (lines[i]);\n  free (lines);\n\n  return 1;\n}\n"], "filenames": ["src/inspect-fs.c"], "buggy_code_start_loc": [547], "buggy_code_end_loc": [575], "fixing_code_start_loc": [547], "fixing_code_end_loc": [578], "type": "NVD-CWE-Other", "message": "Double free vulnerability in inspect-fs.c in LibguestFS 1.20.x before 1.20.7, 1.21.x, 1.22.0, and 1.23.0 allows remote attackers to cause a denial of service (crash) via empty guest files.", "other": {"cve": {"id": "CVE-2013-2124", "sourceIdentifier": "secalert@redhat.com", "published": "2014-05-27T14:55:06.870", "lastModified": "2017-08-29T01:33:14.277", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/415.html\n\n\"CWE-415: Double Free\"", "descriptions": [{"lang": "en", "value": "Double free vulnerability in inspect-fs.c in LibguestFS 1.20.x before 1.20.7, 1.21.x, 1.22.0, and 1.23.0 allows remote attackers to cause a denial of service (crash) via empty guest files."}, {"lang": "es", "value": "Vulnerabilidad de doble liberaci\u00f3n en inspect-fs.c en LibguestFS 1.20.x anterior a 1.20.7, 1.21.x, 1.22.0 y 1.23.0 permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de archivos de invitados vac\u00edos."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.20.0:*:*:*:*:*:*:*", "matchCriteriaId": "662D8743-9FBE-4048-8511-6C9AF4193706"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.20.1:*:*:*:*:*:*:*", "matchCriteriaId": "6CEAA548-615C-4B5B-9E2C-7E65620EEFE6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.20.2:*:*:*:*:*:*:*", "matchCriteriaId": "9825024C-F3AD-4B76-8B43-B6F78DB0B3EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.20.3:*:*:*:*:*:*:*", "matchCriteriaId": "A6A1FC10-0A20-4EA6-94D5-34629D059E03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.20.4:*:*:*:*:*:*:*", "matchCriteriaId": "B688FBA6-1892-4EDC-A049-E90867EC4EEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.20.5:*:*:*:*:*:*:*", "matchCriteriaId": "ACA9267E-D50E-4AE9-873C-C07797E4B8D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.20.6:*:*:*:*:*:*:*", "matchCriteriaId": "02DF3922-A28E-4CFA-9907-2FAED0D72029"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.1:*:*:*:*:*:*:*", "matchCriteriaId": "A13F7320-1B55-4814-A098-940D21A462F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.2:*:*:*:*:*:*:*", "matchCriteriaId": "D27A0A05-6482-4B3F-A4A4-B1E0F82885DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.3:*:*:*:*:*:*:*", "matchCriteriaId": "0D91BEF4-301D-4A74-8C43-697B23B2E8B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.4:*:*:*:*:*:*:*", "matchCriteriaId": "4A76C10D-BD16-443D-9A7D-8938AAC6552C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.5:*:*:*:*:*:*:*", "matchCriteriaId": "8A12C8F3-C5B2-43ED-B729-FD51DE870952"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.6:*:*:*:*:*:*:*", "matchCriteriaId": "4A57EF2D-E4C8-46A7-8889-349091EDE1B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.7:*:*:*:*:*:*:*", "matchCriteriaId": "DE39222C-BEAA-428D-A165-44DB34F79F9E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.8:*:*:*:*:*:*:*", "matchCriteriaId": "09A64839-3B75-404C-A48F-3D5784627303"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.9:*:*:*:*:*:*:*", "matchCriteriaId": "8B126466-0774-43AD-9A16-74B3681AFEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.10:*:*:*:*:*:*:*", "matchCriteriaId": "B5315942-D14F-4D2A-BDA5-B4885C090784"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.11:*:*:*:*:*:*:*", "matchCriteriaId": "5F7DCCBA-7340-49BC-8123-3539AA1B9BAC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.12:*:*:*:*:*:*:*", "matchCriteriaId": "672D8506-6DC4-4E40-8843-FCB22212EBC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.13:*:*:*:*:*:*:*", "matchCriteriaId": "013A015E-AE93-44AE-991E-034DF06AE079"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.14:*:*:*:*:*:*:*", "matchCriteriaId": "AEA156D2-8AB4-477F-A75E-6BAB37361955"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.15:*:*:*:*:*:*:*", "matchCriteriaId": "C9147F40-98D4-44B3-8FF5-DAB43BC23759"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.16:*:*:*:*:*:*:*", "matchCriteriaId": "F71EDD82-6320-4A68-9107-0436887BD86B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.17:*:*:*:*:*:*:*", "matchCriteriaId": "5E37E1CF-3969-483C-B68F-8A42E65DB050"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.18:*:*:*:*:*:*:*", "matchCriteriaId": "51693632-CFAB-466C-B0A0-49257871BA0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.19:*:*:*:*:*:*:*", "matchCriteriaId": "0EA5DE95-07D8-4DB2-91CE-C7DE34E0D603"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.20:*:*:*:*:*:*:*", "matchCriteriaId": "3E39349B-5656-4989-96E2-EF0351C582E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.21:*:*:*:*:*:*:*", "matchCriteriaId": "8B72D9E7-A1D4-4273-A7F1-FECB74D3AFE4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.22:*:*:*:*:*:*:*", "matchCriteriaId": "2B23A55A-9E76-4ED6-8327-2F6362813C8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.23:*:*:*:*:*:*:*", "matchCriteriaId": "9C4AD1A3-962B-4575-A8A6-BAADB193D352"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.24:*:*:*:*:*:*:*", "matchCriteriaId": "9B1F3731-012A-4323-9000-153105F4B5C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.25:*:*:*:*:*:*:*", "matchCriteriaId": "F71207B8-E4BD-403D-8C0E-01E57179A3F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.26:*:*:*:*:*:*:*", "matchCriteriaId": "16F95FE6-A5A2-4F96-8AAE-A478E0C5E2B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.27:*:*:*:*:*:*:*", "matchCriteriaId": "96C11574-11A3-408F-B84F-AC9D6C3A7D37"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.28:*:*:*:*:*:*:*", "matchCriteriaId": "01AFC167-0E2E-4EA7-B7E6-DFBB947EEE28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.29:*:*:*:*:*:*:*", "matchCriteriaId": "44D1FD90-C5CD-454E-A233-D979E118F20B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.30:*:*:*:*:*:*:*", "matchCriteriaId": "39F723F4-5261-4BEE-BDD7-5E8B86E220EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.31:*:*:*:*:*:*:*", "matchCriteriaId": "0EFFBA88-0803-4FA1-B94E-98EA4542071E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.32:*:*:*:*:*:*:*", "matchCriteriaId": "34208517-5E4C-42BA-9D85-76DC55FD10BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.33:*:*:*:*:*:*:*", "matchCriteriaId": "E7E9392B-178B-41DF-B7EA-146DF22301B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.34:*:*:*:*:*:*:*", "matchCriteriaId": "AF4E45B3-14CF-44D4-B64B-4C07B726ADC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.35:*:*:*:*:*:*:*", "matchCriteriaId": "7E354617-F38F-4982-B418-FB3F6DD7E215"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCC2A523-707B-4F0A-8ACD-2951C6C269BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.37:*:*:*:*:*:*:*", "matchCriteriaId": "62216E2C-7A84-4F4D-92CC-EC32EECE7B82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.38:*:*:*:*:*:*:*", "matchCriteriaId": "B523AB06-16E6-4F6C-B96A-F705550AACC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.39:*:*:*:*:*:*:*", "matchCriteriaId": "F7198CD5-595C-4DB2-AC26-218DF2005CBB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.21.40:*:*:*:*:*:*:*", "matchCriteriaId": "B8080CA6-AE70-43A7-8F76-0B316DD876A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.22.0:*:*:*:*:*:*:*", "matchCriteriaId": "D05D11AF-F047-4072-892F-A93C702A94EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libguestfs:libguestfs:1.23.0:*:*:*:*:*:*:*", "matchCriteriaId": "E484129B-92AD-4A85-845F-4944BDBCF87A"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2013/q2/431", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/60205", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/85145", "source": "secalert@redhat.com"}, {"url": "https://github.com/libguestfs/libguestfs/commit/fa6a76050d82894365dfe32916903ef7fee3ffcd", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://www.redhat.com/archives/libguestfs/2013-May/msg00079.html", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://www.redhat.com/archives/libguestfs/2013-May/msg00080.html", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/libguestfs/libguestfs/commit/fa6a76050d82894365dfe32916903ef7fee3ffcd"}}