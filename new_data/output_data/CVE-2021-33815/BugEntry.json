{"buggy_code": ["/*\n * OpenEXR (.exr) image decoder\n * Copyright (c) 2006 Industrial Light & Magic, a division of Lucas Digital Ltd. LLC\n * Copyright (c) 2009 Jimmy Christensen\n *\n * B44/B44A, Tile, UINT32 added by Jokyo Images support by CNC - French National Center for Cinema\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * OpenEXR decoder\n * @author Jimmy Christensen\n *\n * For more information on the OpenEXR format, visit:\n *  http://openexr.com/\n */\n\n#include <float.h>\n#include <zlib.h>\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/color_utils.h\"\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n\n#if HAVE_BIGENDIAN\n#include \"bswapdsp.h\"\n#endif\n\n#include \"exrdsp.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n#include \"half2float.h\"\n#include \"mathops.h\"\n#include \"thread.h\"\n\nenum ExrCompr {\n    EXR_RAW,\n    EXR_RLE,\n    EXR_ZIP1,\n    EXR_ZIP16,\n    EXR_PIZ,\n    EXR_PXR24,\n    EXR_B44,\n    EXR_B44A,\n    EXR_DWAA,\n    EXR_DWAB,\n    EXR_UNKN,\n};\n\nenum ExrPixelType {\n    EXR_UINT,\n    EXR_HALF,\n    EXR_FLOAT,\n    EXR_UNKNOWN,\n};\n\nenum ExrTileLevelMode {\n    EXR_TILE_LEVEL_ONE,\n    EXR_TILE_LEVEL_MIPMAP,\n    EXR_TILE_LEVEL_RIPMAP,\n    EXR_TILE_LEVEL_UNKNOWN,\n};\n\nenum ExrTileLevelRound {\n    EXR_TILE_ROUND_UP,\n    EXR_TILE_ROUND_DOWN,\n    EXR_TILE_ROUND_UNKNOWN,\n};\n\ntypedef struct HuffEntry {\n    uint8_t  len;\n    uint16_t sym;\n    uint32_t code;\n} HuffEntry;\n\ntypedef struct EXRChannel {\n    int xsub, ysub;\n    enum ExrPixelType pixel_type;\n} EXRChannel;\n\ntypedef struct EXRTileAttribute {\n    int32_t xSize;\n    int32_t ySize;\n    enum ExrTileLevelMode level_mode;\n    enum ExrTileLevelRound level_round;\n} EXRTileAttribute;\n\ntypedef struct EXRThreadData {\n    uint8_t *uncompressed_data;\n    int uncompressed_size;\n\n    uint8_t *tmp;\n    int tmp_size;\n\n    uint8_t *bitmap;\n    uint16_t *lut;\n\n    uint8_t *ac_data;\n    unsigned ac_size;\n\n    uint8_t *dc_data;\n    unsigned dc_size;\n\n    uint8_t *rle_data;\n    unsigned rle_size;\n\n    uint8_t *rle_raw_data;\n    unsigned rle_raw_size;\n\n    float block[3][64];\n\n    int ysize, xsize;\n\n    int channel_line_size;\n\n    int run_sym;\n    HuffEntry *he;\n    uint64_t *freq;\n    VLC vlc;\n} EXRThreadData;\n\ntypedef struct EXRContext {\n    AVClass *class;\n    AVFrame *picture;\n    AVCodecContext *avctx;\n    ExrDSPContext dsp;\n\n#if HAVE_BIGENDIAN\n    BswapDSPContext bbdsp;\n#endif\n\n    enum ExrCompr compression;\n    enum ExrPixelType pixel_type;\n    int channel_offsets[4]; // 0 = red, 1 = green, 2 = blue and 3 = alpha\n    const AVPixFmtDescriptor *desc;\n\n    int w, h;\n    uint32_t sar;\n    int32_t xmax, xmin;\n    int32_t ymax, ymin;\n    uint32_t xdelta, ydelta;\n\n    int scan_lines_per_block;\n\n    EXRTileAttribute tile_attr; /* header data attribute of tile */\n    int is_tile; /* 0 if scanline, 1 if tile */\n    int is_multipart;\n    int current_part;\n\n    int is_luma;/* 1 if there is an Y plane */\n\n    GetByteContext gb;\n    const uint8_t *buf;\n    int buf_size;\n\n    EXRChannel *channels;\n    int nb_channels;\n    int current_channel_offset;\n    uint32_t chunk_count;\n\n    EXRThreadData *thread_data;\n\n    const char *layer;\n    int selected_part;\n\n    enum AVColorTransferCharacteristic apply_trc_type;\n    float gamma;\n    union av_intfloat32 gamma_table[65536];\n\n    uint32_t mantissatable[2048];\n    uint32_t exponenttable[64];\n    uint16_t offsettable[64];\n} EXRContext;\n\nstatic int zip_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    unsigned long dest_len = uncompressed_size;\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK ||\n        dest_len != uncompressed_size)\n        return AVERROR_INVALIDDATA;\n\n    av_assert1(uncompressed_size % 2 == 0);\n\n    s->dsp.predictor(td->tmp, uncompressed_size);\n    s->dsp.reorder_pixels(td->uncompressed_data, td->tmp, uncompressed_size);\n\n    return 0;\n}\n\nstatic int rle(uint8_t *dst, const uint8_t *src,\n               int compressed_size, int uncompressed_size)\n{\n    uint8_t *d      = dst;\n    const int8_t *s = src;\n    int ssize       = compressed_size;\n    int dsize       = uncompressed_size;\n    uint8_t *dend   = d + dsize;\n    int count;\n\n    while (ssize > 0) {\n        count = *s++;\n\n        if (count < 0) {\n            count = -count;\n\n            if ((dsize -= count) < 0 ||\n                (ssize -= count + 1) < 0)\n                return AVERROR_INVALIDDATA;\n\n            while (count--)\n                *d++ = *s++;\n        } else {\n            count++;\n\n            if ((dsize -= count) < 0 ||\n                (ssize -= 2) < 0)\n                return AVERROR_INVALIDDATA;\n\n            while (count--)\n                *d++ = *s;\n\n            s++;\n        }\n    }\n\n    if (dend != d)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int rle_uncompress(EXRContext *ctx, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    rle(td->tmp, src, compressed_size, uncompressed_size);\n\n    av_assert1(uncompressed_size % 2 == 0);\n\n    ctx->dsp.predictor(td->tmp, uncompressed_size);\n    ctx->dsp.reorder_pixels(td->uncompressed_data, td->tmp, uncompressed_size);\n\n    return 0;\n}\n\n#define USHORT_RANGE (1 << 16)\n#define BITMAP_SIZE  (1 << 13)\n\nstatic uint16_t reverse_lut(const uint8_t *bitmap, uint16_t *lut)\n{\n    int i, k = 0;\n\n    for (i = 0; i < USHORT_RANGE; i++)\n        if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))\n            lut[k++] = i;\n\n    i = k - 1;\n\n    memset(lut + k, 0, (USHORT_RANGE - k) * 2);\n\n    return i;\n}\n\nstatic void apply_lut(const uint16_t *lut, uint16_t *dst, int dsize)\n{\n    int i;\n\n    for (i = 0; i < dsize; ++i)\n        dst[i] = lut[dst[i]];\n}\n\n#define HUF_ENCBITS 16  // literal (value) bit length\n#define HUF_ENCSIZE ((1 << HUF_ENCBITS) + 1)  // encoding table size\n\nstatic void huf_canonical_code_table(uint64_t *freq)\n{\n    uint64_t c, n[59] = { 0 };\n    int i;\n\n    for (i = 0; i < HUF_ENCSIZE; i++)\n        n[freq[i]] += 1;\n\n    c = 0;\n    for (i = 58; i > 0; --i) {\n        uint64_t nc = ((c + n[i]) >> 1);\n        n[i] = c;\n        c    = nc;\n    }\n\n    for (i = 0; i < HUF_ENCSIZE; ++i) {\n        int l = freq[i];\n\n        if (l > 0)\n            freq[i] = l | (n[l]++ << 6);\n    }\n}\n\n#define SHORT_ZEROCODE_RUN  59\n#define LONG_ZEROCODE_RUN   63\n#define SHORTEST_LONG_RUN   (2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN)\n#define LONGEST_LONG_RUN    (255 + SHORTEST_LONG_RUN)\n\nstatic int huf_unpack_enc_table(GetByteContext *gb,\n                                int32_t im, int32_t iM, uint64_t *freq)\n{\n    GetBitContext gbit;\n    int ret = init_get_bits8(&gbit, gb->buffer, bytestream2_get_bytes_left(gb));\n    if (ret < 0)\n        return ret;\n\n    for (; im <= iM; im++) {\n        uint64_t l = freq[im] = get_bits(&gbit, 6);\n\n        if (l == LONG_ZEROCODE_RUN) {\n            int zerun = get_bits(&gbit, 8) + SHORTEST_LONG_RUN;\n\n            if (im + zerun > iM + 1)\n                return AVERROR_INVALIDDATA;\n\n            while (zerun--)\n                freq[im++] = 0;\n\n            im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n            int zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n            if (im + zerun > iM + 1)\n                return AVERROR_INVALIDDATA;\n\n            while (zerun--)\n                freq[im++] = 0;\n\n            im--;\n        }\n    }\n\n    bytestream2_skip(gb, (get_bits_count(&gbit) + 7) / 8);\n    huf_canonical_code_table(freq);\n\n    return 0;\n}\n\nstatic int huf_build_dec_table(EXRContext *s,\n                               EXRThreadData *td, int im, int iM)\n{\n    int j = 0;\n\n    td->run_sym = -1;\n    for (int i = im; i < iM; i++) {\n        td->he[j].sym = i;\n        td->he[j].len = td->freq[i] & 63;\n        td->he[j].code = td->freq[i] >> 6;\n        if (td->he[j].len > 32) {\n            avpriv_request_sample(s->avctx, \"Too big code length\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (td->he[j].len > 0)\n            j++;\n        else\n            td->run_sym = i;\n    }\n\n    if (im > 0)\n        td->run_sym = 0;\n    else if (iM < 65535)\n        td->run_sym = 65535;\n\n    if (td->run_sym == -1) {\n        avpriv_request_sample(s->avctx, \"No place for run symbol\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    td->he[j].sym = td->run_sym;\n    td->he[j].len = td->freq[iM] & 63;\n    if (td->he[j].len > 32) {\n        avpriv_request_sample(s->avctx, \"Too big code length\");\n        return AVERROR_PATCHWELCOME;\n    }\n    td->he[j].code = td->freq[iM] >> 6;\n    j++;\n\n    ff_free_vlc(&td->vlc);\n    return ff_init_vlc_sparse(&td->vlc, 12, j,\n                              &td->he[0].len, sizeof(td->he[0]), sizeof(td->he[0].len),\n                              &td->he[0].code, sizeof(td->he[0]), sizeof(td->he[0].code),\n                              &td->he[0].sym, sizeof(td->he[0]), sizeof(td->he[0].sym), 0);\n}\n\nstatic int huf_decode(VLC *vlc, GetByteContext *gb, int nbits, int run_sym,\n                      int no, uint16_t *out)\n{\n    GetBitContext gbit;\n    int oe = 0;\n\n    init_get_bits(&gbit, gb->buffer, nbits);\n    while (get_bits_left(&gbit) > 0 && oe < no) {\n        uint16_t x = get_vlc2(&gbit, vlc->table, 12, 3);\n\n        if (x == run_sym) {\n            int run = get_bits(&gbit, 8);\n            uint16_t fill;\n\n            if (oe == 0 || oe + run > no)\n                return AVERROR_INVALIDDATA;\n\n            fill = out[oe - 1];\n\n            while (run-- > 0)\n                out[oe++] = fill;\n        } else {\n            out[oe++] = x;\n        }\n    }\n\n    return 0;\n}\n\nstatic int huf_uncompress(EXRContext *s,\n                          EXRThreadData *td,\n                          GetByteContext *gb,\n                          uint16_t *dst, int dst_size)\n{\n    int32_t im, iM;\n    uint32_t nBits;\n    int ret;\n\n    im       = bytestream2_get_le32(gb);\n    iM       = bytestream2_get_le32(gb);\n    bytestream2_skip(gb, 4);\n    nBits = bytestream2_get_le32(gb);\n    if (im < 0 || im >= HUF_ENCSIZE ||\n        iM < 0 || iM >= HUF_ENCSIZE)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(gb, 4);\n\n    if (!td->freq)\n        td->freq = av_malloc_array(HUF_ENCSIZE, sizeof(*td->freq));\n    if (!td->he)\n        td->he = av_calloc(HUF_ENCSIZE, sizeof(*td->he));\n    if (!td->freq || !td->he) {\n        ret = AVERROR(ENOMEM);\n        return ret;\n    }\n\n    memset(td->freq, 0, sizeof(*td->freq) * HUF_ENCSIZE);\n    if ((ret = huf_unpack_enc_table(gb, im, iM, td->freq)) < 0)\n        return ret;\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n        ret = AVERROR_INVALIDDATA;\n        return ret;\n    }\n\n    if ((ret = huf_build_dec_table(s, td, im, iM)) < 0)\n        return ret;\n    return huf_decode(&td->vlc, gb, nBits, td->run_sym, dst_size, dst);\n}\n\nstatic inline void wdec14(uint16_t l, uint16_t h, uint16_t *a, uint16_t *b)\n{\n    int16_t ls = l;\n    int16_t hs = h;\n    int hi     = hs;\n    int ai     = ls + (hi & 1) + (hi >> 1);\n    int16_t as = ai;\n    int16_t bs = ai - hi;\n\n    *a = as;\n    *b = bs;\n}\n\n#define NBITS      16\n#define A_OFFSET  (1 << (NBITS - 1))\n#define MOD_MASK  ((1 << NBITS) - 1)\n\nstatic inline void wdec16(uint16_t l, uint16_t h, uint16_t *a, uint16_t *b)\n{\n    int m  = l;\n    int d  = h;\n    int bb = (m - (d >> 1)) & MOD_MASK;\n    int aa = (d + bb - A_OFFSET) & MOD_MASK;\n    *b = bb;\n    *a = aa;\n}\n\nstatic void wav_decode(uint16_t *in, int nx, int ox,\n                       int ny, int oy, uint16_t mx)\n{\n    int w14 = (mx < (1 << 14));\n    int n   = (nx > ny) ? ny : nx;\n    int p   = 1;\n    int p2;\n\n    while (p <= n)\n        p <<= 1;\n\n    p >>= 1;\n    p2  = p;\n    p >>= 1;\n\n    while (p >= 1) {\n        uint16_t *py = in;\n        uint16_t *ey = in + oy * (ny - p2);\n        uint16_t i00, i01, i10, i11;\n        int oy1 = oy * p;\n        int oy2 = oy * p2;\n        int ox1 = ox * p;\n        int ox2 = ox * p2;\n\n        for (; py <= ey; py += oy2) {\n            uint16_t *px = py;\n            uint16_t *ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n                uint16_t *p01 = px + ox1;\n                uint16_t *p10 = px + oy1;\n                uint16_t *p11 = p10 + ox1;\n\n                if (w14) {\n                    wdec14(*px, *p10, &i00, &i10);\n                    wdec14(*p01, *p11, &i01, &i11);\n                    wdec14(i00, i01, px, p01);\n                    wdec14(i10, i11, p10, p11);\n                } else {\n                    wdec16(*px, *p10, &i00, &i10);\n                    wdec16(*p01, *p11, &i01, &i11);\n                    wdec16(i00, i01, px, p01);\n                    wdec16(i10, i11, p10, p11);\n                }\n            }\n\n            if (nx & p) {\n                uint16_t *p10 = px + oy1;\n\n                if (w14)\n                    wdec14(*px, *p10, &i00, p10);\n                else\n                    wdec16(*px, *p10, &i00, p10);\n\n                *px = i00;\n            }\n        }\n\n        if (ny & p) {\n            uint16_t *px = py;\n            uint16_t *ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n                uint16_t *p01 = px + ox1;\n\n                if (w14)\n                    wdec14(*px, *p01, &i00, p01);\n                else\n                    wdec16(*px, *p01, &i00, p01);\n\n                *px = i00;\n            }\n        }\n\n        p2  = p;\n        p >>= 1;\n    }\n}\n\nstatic int piz_uncompress(EXRContext *s, const uint8_t *src, int ssize,\n                          int dsize, EXRThreadData *td)\n{\n    GetByteContext gb;\n    uint16_t maxval, min_non_zero, max_non_zero;\n    uint16_t *ptr;\n    uint16_t *tmp = (uint16_t *)td->tmp;\n    uint16_t *out;\n    uint16_t *in;\n    int ret, i, j;\n    int pixel_half_size;/* 1 for half, 2 for float and uint32 */\n    EXRChannel *channel;\n    int tmp_offset;\n\n    if (!td->bitmap)\n        td->bitmap = av_malloc(BITMAP_SIZE);\n    if (!td->lut)\n        td->lut = av_malloc(1 << 17);\n    if (!td->bitmap || !td->lut) {\n        av_freep(&td->bitmap);\n        av_freep(&td->lut);\n        return AVERROR(ENOMEM);\n    }\n\n    bytestream2_init(&gb, src, ssize);\n    min_non_zero = bytestream2_get_le16(&gb);\n    max_non_zero = bytestream2_get_le16(&gb);\n\n    if (max_non_zero >= BITMAP_SIZE)\n        return AVERROR_INVALIDDATA;\n\n    memset(td->bitmap, 0, FFMIN(min_non_zero, BITMAP_SIZE));\n    if (min_non_zero <= max_non_zero)\n        bytestream2_get_buffer(&gb, td->bitmap + min_non_zero,\n                               max_non_zero - min_non_zero + 1);\n    memset(td->bitmap + max_non_zero + 1, 0, BITMAP_SIZE - max_non_zero - 1);\n\n    maxval = reverse_lut(td->bitmap, td->lut);\n\n    bytestream2_skip(&gb, 4);\n    ret = huf_uncompress(s, td, &gb, tmp, dsize / sizeof(uint16_t));\n    if (ret)\n        return ret;\n\n    ptr = tmp;\n    for (i = 0; i < s->nb_channels; i++) {\n        channel = &s->channels[i];\n\n        if (channel->pixel_type == EXR_HALF)\n            pixel_half_size = 1;\n        else\n            pixel_half_size = 2;\n\n        for (j = 0; j < pixel_half_size; j++)\n            wav_decode(ptr + j, td->xsize, pixel_half_size, td->ysize,\n                       td->xsize * pixel_half_size, maxval);\n        ptr += td->xsize * td->ysize * pixel_half_size;\n    }\n\n    apply_lut(td->lut, tmp, dsize / sizeof(uint16_t));\n\n    out = (uint16_t *)td->uncompressed_data;\n    for (i = 0; i < td->ysize; i++) {\n        tmp_offset = 0;\n        for (j = 0; j < s->nb_channels; j++) {\n            channel = &s->channels[j];\n            if (channel->pixel_type == EXR_HALF)\n                pixel_half_size = 1;\n            else\n                pixel_half_size = 2;\n\n            in = tmp + tmp_offset * td->xsize * td->ysize + i * td->xsize * pixel_half_size;\n            tmp_offset += pixel_half_size;\n\n#if HAVE_BIGENDIAN\n            s->bbdsp.bswap16_buf(out, in, td->xsize * pixel_half_size);\n#else\n            memcpy(out, in, td->xsize * 2 * pixel_half_size);\n#endif\n            out += td->xsize * pixel_half_size;\n        }\n    }\n\n    return 0;\n}\n\nstatic int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n                            int compressed_size, int uncompressed_size,\n                            EXRThreadData *td)\n{\n    unsigned long dest_len, expected_len = 0;\n    const uint8_t *in = td->tmp;\n    uint8_t *out;\n    int c, i, j;\n\n    for (i = 0; i < s->nb_channels; i++) {\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n            expected_len += (td->xsize * td->ysize * 2);\n        } else {//UINT 32\n            expected_len += (td->xsize * td->ysize * 4);\n        }\n    }\n\n    dest_len = expected_len;\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n        return AVERROR_INVALIDDATA;\n    } else if (dest_len != expected_len) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    out = td->uncompressed_data;\n    for (i = 0; i < td->ysize; i++)\n        for (c = 0; c < s->nb_channels; c++) {\n            EXRChannel *channel = &s->channels[c];\n            const uint8_t *ptr[4];\n            uint32_t pixel = 0;\n\n            switch (channel->pixel_type) {\n            case EXR_FLOAT:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + td->xsize;\n                ptr[2] = ptr[1] + td->xsize;\n                in     = ptr[2] + td->xsize;\n\n                for (j = 0; j < td->xsize; ++j) {\n                    uint32_t diff = ((unsigned)*(ptr[0]++) << 24) |\n                                    (*(ptr[1]++) << 16) |\n                                    (*(ptr[2]++) << 8);\n                    pixel += diff;\n                    bytestream_put_le32(&out, pixel);\n                }\n                break;\n            case EXR_HALF:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + td->xsize;\n                in     = ptr[1] + td->xsize;\n                for (j = 0; j < td->xsize; j++) {\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n                    pixel += diff;\n                    bytestream_put_le16(&out, pixel);\n                }\n                break;\n            case EXR_UINT:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + s->xdelta;\n                ptr[2] = ptr[1] + s->xdelta;\n                ptr[3] = ptr[2] + s->xdelta;\n                in     = ptr[3] + s->xdelta;\n\n                for (j = 0; j < s->xdelta; ++j) {\n                    uint32_t diff = ((uint32_t)*(ptr[0]++) << 24) |\n                    (*(ptr[1]++) << 16) |\n                    (*(ptr[2]++) << 8 ) |\n                    (*(ptr[3]++));\n                    pixel += diff;\n                    bytestream_put_le32(&out, pixel);\n                }\n                break;\n            default:\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n    return 0;\n}\n\nstatic void unpack_14(const uint8_t b[14], uint16_t s[16])\n{\n    unsigned short shift = (b[ 2] >> 2) & 15;\n    unsigned short bias = (0x20 << shift);\n    int i;\n\n    s[ 0] = (b[0] << 8) | b[1];\n\n    s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3f) << shift) - bias;\n    s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3f) << shift) - bias;\n    s[12] = s[ 8] +   ((b[ 4]                       & 0x3f) << shift) - bias;\n\n    s[ 1] = s[ 0] +   ((b[ 5] >> 2)                         << shift) - bias;\n    s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3f) << shift) - bias;\n    s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3f) << shift) - bias;\n    s[13] = s[12] +   ((b[ 7]                       & 0x3f) << shift) - bias;\n\n    s[ 2] = s[ 1] +   ((b[ 8] >> 2)                         << shift) - bias;\n    s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3f) << shift) - bias;\n    s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3f) << shift) - bias;\n    s[14] = s[13] +   ((b[10]                       & 0x3f) << shift) - bias;\n\n    s[ 3] = s[ 2] +   ((b[11] >> 2)                         << shift) - bias;\n    s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3f) << shift) - bias;\n    s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3f) << shift) - bias;\n    s[15] = s[14] +   ((b[13]                       & 0x3f) << shift) - bias;\n\n    for (i = 0; i < 16; ++i) {\n        if (s[i] & 0x8000)\n            s[i] &= 0x7fff;\n        else\n            s[i] = ~s[i];\n    }\n}\n\nstatic void unpack_3(const uint8_t b[3], uint16_t s[16])\n{\n    int i;\n\n    s[0] = (b[0] << 8) | b[1];\n\n    if (s[0] & 0x8000)\n        s[0] &= 0x7fff;\n    else\n        s[0] = ~s[0];\n\n    for (i = 1; i < 16; i++)\n        s[i] = s[0];\n}\n\n\nstatic int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td) {\n    const int8_t *sr = src;\n    int stay_to_uncompress = compressed_size;\n    int nb_b44_block_w, nb_b44_block_h;\n    int index_tl_x, index_tl_y, index_out, index_tmp;\n    uint16_t tmp_buffer[16]; /* B44 use 4x4 half float pixel */\n    int c, iY, iX, y, x;\n    int target_channel_offset = 0;\n\n    /* calc B44 block count */\n    nb_b44_block_w = td->xsize / 4;\n    if ((td->xsize % 4) != 0)\n        nb_b44_block_w++;\n\n    nb_b44_block_h = td->ysize / 4;\n    if ((td->ysize % 4) != 0)\n        nb_b44_block_h++;\n\n    for (c = 0; c < s->nb_channels; c++) {\n        if (s->channels[c].pixel_type == EXR_HALF) {/* B44 only compress half float data */\n            for (iY = 0; iY < nb_b44_block_h; iY++) {\n                for (iX = 0; iX < nb_b44_block_w; iX++) {/* For each B44 block */\n                    if (stay_to_uncompress < 3) {\n                        av_log(s, AV_LOG_ERROR, \"Not enough data for B44A block: %d\", stay_to_uncompress);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    if (src[compressed_size - stay_to_uncompress + 2] == 0xfc) { /* B44A block */\n                        unpack_3(sr, tmp_buffer);\n                        sr += 3;\n                        stay_to_uncompress -= 3;\n                    }  else {/* B44 Block */\n                        if (stay_to_uncompress < 14) {\n                            av_log(s, AV_LOG_ERROR, \"Not enough data for B44 block: %d\", stay_to_uncompress);\n                            return AVERROR_INVALIDDATA;\n                        }\n                        unpack_14(sr, tmp_buffer);\n                        sr += 14;\n                        stay_to_uncompress -= 14;\n                    }\n\n                    /* copy data to uncompress buffer (B44 block can exceed target resolution)*/\n                    index_tl_x = iX * 4;\n                    index_tl_y = iY * 4;\n\n                    for (y = index_tl_y; y < FFMIN(index_tl_y + 4, td->ysize); y++) {\n                        for (x = index_tl_x; x < FFMIN(index_tl_x + 4, td->xsize); x++) {\n                            index_out = target_channel_offset * td->xsize + y * td->channel_line_size + 2 * x;\n                            index_tmp = (y-index_tl_y) * 4 + (x-index_tl_x);\n                            td->uncompressed_data[index_out] = tmp_buffer[index_tmp] & 0xff;\n                            td->uncompressed_data[index_out + 1] = tmp_buffer[index_tmp] >> 8;\n                        }\n                    }\n                }\n            }\n            target_channel_offset += 2;\n        } else {/* Float or UINT 32 channel */\n            if (stay_to_uncompress < td->ysize * td->xsize * 4) {\n                av_log(s, AV_LOG_ERROR, \"Not enough data for uncompress channel: %d\", stay_to_uncompress);\n                return AVERROR_INVALIDDATA;\n            }\n\n            for (y = 0; y < td->ysize; y++) {\n                index_out = target_channel_offset * td->xsize + y * td->channel_line_size;\n                memcpy(&td->uncompressed_data[index_out], sr, td->xsize * 4);\n                sr += td->xsize * 4;\n            }\n            target_channel_offset += 4;\n\n            stay_to_uncompress -= td->ysize * td->xsize * 4;\n        }\n    }\n\n    return 0;\n}\n\nstatic int ac_uncompress(EXRContext *s, GetByteContext *gb, float *block)\n{\n    int ret = 0, n = 1;\n\n    while (n < 64) {\n        uint16_t val = bytestream2_get_ne16(gb);\n\n        if (val == 0xff00) {\n            n = 64;\n        } else if ((val >> 8) == 0xff) {\n            n += val & 0xff;\n        } else {\n            ret = n;\n            block[ff_zigzag_direct[n]] = av_int2float(half2float(val,\n                                                      s->mantissatable,\n                                                      s->exponenttable,\n                                                      s->offsettable));\n            n++;\n        }\n    }\n\n    return ret;\n}\n\nstatic void idct_1d(float *blk, int step)\n{\n    const float a = .5f * cosf(    M_PI / 4.f);\n    const float b = .5f * cosf(    M_PI / 16.f);\n    const float c = .5f * cosf(    M_PI / 8.f);\n    const float d = .5f * cosf(3.f*M_PI / 16.f);\n    const float e = .5f * cosf(5.f*M_PI / 16.f);\n    const float f = .5f * cosf(3.f*M_PI / 8.f);\n    const float g = .5f * cosf(7.f*M_PI / 16.f);\n\n    float alpha[4], beta[4], theta[4], gamma[4];\n\n    alpha[0] = c * blk[2 * step];\n    alpha[1] = f * blk[2 * step];\n    alpha[2] = c * blk[6 * step];\n    alpha[3] = f * blk[6 * step];\n\n    beta[0] = b * blk[1 * step] + d * blk[3 * step] + e * blk[5 * step] + g * blk[7 * step];\n    beta[1] = d * blk[1 * step] - g * blk[3 * step] - b * blk[5 * step] - e * blk[7 * step];\n    beta[2] = e * blk[1 * step] - b * blk[3 * step] + g * blk[5 * step] + d * blk[7 * step];\n    beta[3] = g * blk[1 * step] - e * blk[3 * step] + d * blk[5 * step] - b * blk[7 * step];\n\n    theta[0] = a * (blk[0 * step] + blk[4 * step]);\n    theta[3] = a * (blk[0 * step] - blk[4 * step]);\n\n    theta[1] = alpha[0] + alpha[3];\n    theta[2] = alpha[1] - alpha[2];\n\n    gamma[0] = theta[0] + theta[1];\n    gamma[1] = theta[3] + theta[2];\n    gamma[2] = theta[3] - theta[2];\n    gamma[3] = theta[0] - theta[1];\n\n    blk[0 * step] = gamma[0] + beta[0];\n    blk[1 * step] = gamma[1] + beta[1];\n    blk[2 * step] = gamma[2] + beta[2];\n    blk[3 * step] = gamma[3] + beta[3];\n\n    blk[4 * step] = gamma[3] - beta[3];\n    blk[5 * step] = gamma[2] - beta[2];\n    blk[6 * step] = gamma[1] - beta[1];\n    blk[7 * step] = gamma[0] - beta[0];\n}\n\nstatic void dct_inverse(float *block)\n{\n    for (int i = 0; i < 8; i++)\n        idct_1d(block + i, 8);\n\n    for (int i = 0; i < 8; i++) {\n        idct_1d(block, 1);\n        block += 8;\n    }\n}\n\nstatic void convert(float y, float u, float v,\n                    float *b, float *g, float *r)\n{\n    *r = y               + 1.5747f * v;\n    *g = y - 0.1873f * u - 0.4682f * v;\n    *b = y + 1.8556f * u;\n}\n\nstatic float to_linear(float x, float scale)\n{\n    float ax = fabsf(x);\n\n    if (ax <= 1.f) {\n        return FFSIGN(x) * powf(ax, 2.2f * scale);\n    } else {\n        const float log_base = expf(2.2f * scale);\n\n        return FFSIGN(x) * powf(log_base, ax - 1.f);\n    }\n}\n\nstatic int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    int64_t version, lo_usize, lo_size;\n    int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;\n    int64_t ac_count, dc_count, ac_compression;\n    const int dc_w = td->xsize >> 3;\n    const int dc_h = td->ysize >> 3;\n    GetByteContext gb, agb;\n    int skip, ret;\n\n    if (compressed_size <= 88)\n        return AVERROR_INVALIDDATA;\n\n    version = AV_RL64(src + 0);\n    if (version != 2)\n        return AVERROR_INVALIDDATA;\n\n    lo_usize = AV_RL64(src + 8);\n    lo_size = AV_RL64(src + 16);\n    ac_size = AV_RL64(src + 24);\n    dc_size = AV_RL64(src + 32);\n    rle_csize = AV_RL64(src + 40);\n    rle_usize = AV_RL64(src + 48);\n    rle_raw_size = AV_RL64(src + 56);\n    ac_count = AV_RL64(src + 64);\n    dc_count = AV_RL64(src + 72);\n    ac_compression = AV_RL64(src + 80);\n\n    if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&gb, src + 88, compressed_size - 88);\n    skip = bytestream2_get_le16(&gb);\n    if (skip < 2)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(&gb, skip - 2);\n\n    if (lo_size > 0) {\n        if (lo_usize > uncompressed_size)\n            return AVERROR_INVALIDDATA;\n        bytestream2_skip(&gb, lo_size);\n    }\n\n    if (ac_size > 0) {\n        unsigned long dest_len = ac_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);\n        if (!td->ac_data)\n            return AVERROR(ENOMEM);\n\n        switch (ac_compression) {\n        case 0:\n            ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);\n            if (ret < 0)\n                return ret;\n            break;\n        case 1:\n            if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||\n                dest_len != ac_count * 2LL)\n                return AVERROR_INVALIDDATA;\n            break;\n        default:\n            return AVERROR_INVALIDDATA;\n        }\n\n        bytestream2_skip(&gb, ac_size);\n    }\n\n    if (dc_size > 0) {\n        unsigned long dest_len = dc_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);\n        if (!td->dc_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||\n            (dest_len != dc_count * 2LL))\n            return AVERROR_INVALIDDATA;\n\n        s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);\n        s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);\n\n        bytestream2_skip(&gb, dc_size);\n    }\n\n    if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {\n        unsigned long dest_len = rle_usize;\n\n        av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);\n        if (!td->rle_data)\n            return AVERROR(ENOMEM);\n\n        av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);\n        if (!td->rle_raw_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||\n            (dest_len != rle_usize))\n            return AVERROR_INVALIDDATA;\n\n        ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);\n        if (ret < 0)\n            return ret;\n        bytestream2_skip(&gb, rle_csize);\n    }\n\n    bytestream2_init(&agb, td->ac_data, ac_count * 2);\n\n    for (int y = 0; y < td->ysize; y += 8) {\n        for (int x = 0; x < td->xsize; x += 8) {\n            memset(td->block, 0, sizeof(td->block));\n\n            for (int j = 0; j < 3; j++) {\n                float *block = td->block[j];\n                const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;\n                uint16_t *dc = (uint16_t *)td->dc_data;\n                union av_intfloat32 dc_val;\n\n                dc_val.i = half2float(dc[idx], s->mantissatable,\n                                      s->exponenttable, s->offsettable);\n\n                block[0] = dc_val.f;\n                ac_uncompress(s, &agb, block);\n                dct_inverse(block);\n            }\n\n            {\n                const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;\n                const int o = s->nb_channels == 4;\n                float *bo = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;\n                float *go = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;\n                float *ro = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;\n                float *yb = td->block[0];\n                float *ub = td->block[1];\n                float *vb = td->block[2];\n\n                for (int yy = 0; yy < 8; yy++) {\n                    for (int xx = 0; xx < 8; xx++) {\n                        const int idx = xx + yy * 8;\n\n                        convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);\n\n                        bo[xx] = to_linear(bo[xx], scale);\n                        go[xx] = to_linear(go[xx], scale);\n                        ro[xx] = to_linear(ro[xx], scale);\n                    }\n\n                    bo += td->xsize * s->nb_channels;\n                    go += td->xsize * s->nb_channels;\n                    ro += td->xsize * s->nb_channels;\n                }\n            }\n        }\n    }\n\n    if (s->nb_channels < 4)\n        return 0;\n\n    for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {\n        uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;\n        uint8_t *ai0 = td->rle_raw_data + y * td->xsize;\n        uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;\n\n        for (int x = 0; x < td->xsize; x++) {\n            uint16_t ha = ai0[x] | (ai1[x] << 8);\n\n            ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_block(AVCodecContext *avctx, void *tdata,\n                        int jobnr, int threadnr)\n{\n    EXRContext *s = avctx->priv_data;\n    AVFrame *const p = s->picture;\n    EXRThreadData *td = &s->thread_data[threadnr];\n    const uint8_t *channel_buffer[4] = { 0 };\n    const uint8_t *buf = s->buf;\n    uint64_t line_offset, uncompressed_size;\n    uint8_t *ptr;\n    uint32_t data_size;\n    int line, col = 0;\n    uint64_t tile_x, tile_y, tile_level_x, tile_level_y;\n    const uint8_t *src;\n    int step = s->desc->flags & AV_PIX_FMT_FLAG_FLOAT ? 4 : 2 * s->desc->nb_components;\n    int bxmin = 0, axmax = 0, window_xoffset = 0;\n    int window_xmin, window_xmax, window_ymin, window_ymax;\n    int data_xoffset, data_yoffset, data_window_offset, xsize, ysize;\n    int i, x, buf_size = s->buf_size;\n    int c, rgb_channel_count;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    int ret;\n\n    line_offset = AV_RL64(s->gb.buffer + jobnr * 8);\n\n    if (s->is_tile) {\n        if (buf_size < 20 || line_offset > buf_size - 20)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 20;\n        if (s->is_multipart)\n            src += 4;\n\n        tile_x = AV_RL32(src - 20);\n        tile_y = AV_RL32(src - 16);\n        tile_level_x = AV_RL32(src - 12);\n        tile_level_y = AV_RL32(src - 8);\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size - line_offset - 20)\n            return AVERROR_INVALIDDATA;\n\n        if (tile_level_x || tile_level_y) { /* tile level, is not the full res level */\n            avpriv_report_missing_feature(s->avctx, \"Subres tile before full res tile\");\n            return AVERROR_PATCHWELCOME;\n        }\n\n        if (tile_x && s->tile_attr.xSize + (int64_t)FFMAX(s->xmin, 0) >= INT_MAX / tile_x )\n            return AVERROR_INVALIDDATA;\n        if (tile_y && s->tile_attr.ySize + (int64_t)FFMAX(s->ymin, 0) >= INT_MAX / tile_y )\n            return AVERROR_INVALIDDATA;\n\n        line = s->ymin + s->tile_attr.ySize * tile_y;\n        col = s->tile_attr.xSize * tile_x;\n\n        if (line < s->ymin || line > s->ymax ||\n            s->xmin + col  < s->xmin ||  s->xmin + col  > s->xmax)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tile_y * s->tile_attr.ySize);\n        td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tile_x * s->tile_attr.xSize);\n\n        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n    } else {\n        if (buf_size < 8 || line_offset > buf_size - 8)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 8;\n        if (s->is_multipart)\n            src += 4;\n        line = AV_RL32(src - 8);\n\n        if (line < s->ymin || line > s->ymax)\n            return AVERROR_INVALIDDATA;\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size - line_offset - 8)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize          = FFMIN(s->scan_lines_per_block, s->ymax - line + 1); /* s->ydelta - line ?? */\n        td->xsize          = s->xdelta;\n\n        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n\n        if ((s->compression == EXR_RAW && (data_size != uncompressed_size ||\n                                           line_offset > buf_size - uncompressed_size)) ||\n            (s->compression != EXR_RAW && (data_size > uncompressed_size ||\n                                           line_offset > buf_size - data_size))) {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    window_xmin = FFMIN(avctx->width, FFMAX(0, s->xmin + col));\n    window_xmax = FFMIN(avctx->width, FFMAX(0, s->xmin + col + td->xsize));\n    window_ymin = FFMIN(avctx->height, FFMAX(0, line ));\n    window_ymax = FFMIN(avctx->height, FFMAX(0, line + td->ysize));\n    xsize = window_xmax - window_xmin;\n    ysize = window_ymax - window_ymin;\n\n    /* tile or scanline not visible skip decoding */\n    if (xsize <= 0 || ysize <= 0)\n        return 0;\n\n    /* is the first tile or is a scanline */\n    if(col == 0) {\n        window_xmin = 0;\n        /* pixels to add at the left of the display window */\n        window_xoffset = FFMAX(0, s->xmin);\n        /* bytes to add at the left of the display window */\n        bxmin = window_xoffset * step;\n    }\n\n    /* is the last tile or is a scanline */\n    if(col + td->xsize == s->xdelta) {\n        window_xmax = avctx->width;\n         /* bytes to add at the right of the display window */\n        axmax = FFMAX(0, (avctx->width - (s->xmax + 1))) * step;\n    }\n\n    if (data_size < uncompressed_size || s->is_tile) { /* td->tmp is use for tile reorganization */\n        av_fast_padded_malloc(&td->tmp, &td->tmp_size, uncompressed_size);\n        if (!td->tmp)\n            return AVERROR(ENOMEM);\n    }\n\n    if (data_size < uncompressed_size) {\n        av_fast_padded_malloc(&td->uncompressed_data,\n                              &td->uncompressed_size, uncompressed_size + 64);/* Force 64 padding for AVX2 reorder_pixels dst */\n\n        if (!td->uncompressed_data)\n            return AVERROR(ENOMEM);\n\n        ret = AVERROR_INVALIDDATA;\n        switch (s->compression) {\n        case EXR_ZIP1:\n        case EXR_ZIP16:\n            ret = zip_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PIZ:\n            ret = piz_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PXR24:\n            ret = pxr24_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_RLE:\n            ret = rle_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_B44:\n        case EXR_B44A:\n            ret = b44_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_DWAA:\n        case EXR_DWAB:\n            ret = dwa_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        }\n        if (ret < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"decode_block() failed.\\n\");\n            return ret;\n        }\n        src = td->uncompressed_data;\n    }\n\n    /* offsets to crop data outside display window */\n    data_xoffset = FFABS(FFMIN(0, s->xmin + col)) * (s->pixel_type == EXR_HALF ? 2 : 4);\n    data_yoffset = FFABS(FFMIN(0, line));\n    data_window_offset = (data_yoffset * td->channel_line_size) + data_xoffset;\n\n    if (!s->is_luma) {\n        channel_buffer[0] = src + (td->xsize * s->channel_offsets[0]) + data_window_offset;\n        channel_buffer[1] = src + (td->xsize * s->channel_offsets[1]) + data_window_offset;\n        channel_buffer[2] = src + (td->xsize * s->channel_offsets[2]) + data_window_offset;\n        rgb_channel_count = 3;\n    } else { /* put y data in the first channel_buffer */\n        channel_buffer[0] = src + (td->xsize * s->channel_offsets[1]) + data_window_offset;\n        rgb_channel_count = 1;\n    }\n     if (s->channel_offsets[3] >= 0)\n        channel_buffer[3] = src + (td->xsize * s->channel_offsets[3]) + data_window_offset;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n        int channel_count = s->channel_offsets[3] >= 0 ? 4 : rgb_channel_count;\n        if (s->is_luma) {\n            channel_buffer[1] = channel_buffer[0];\n            channel_buffer[2] = channel_buffer[0];\n        }\n\n        for (c = 0; c < channel_count; c++) {\n            int plane = s->desc->comp[c].plane;\n            ptr = p->data[plane] + window_ymin * p->linesize[plane] + (window_xmin * 4);\n\n            for (i = 0; i < ysize; i++, ptr += p->linesize[plane]) {\n                const uint8_t *src;\n                union av_intfloat32 *ptr_x;\n\n                src = channel_buffer[c];\n                ptr_x = (union av_intfloat32 *)ptr;\n\n                // Zero out the start if xmin is not 0\n                memset(ptr_x, 0, bxmin);\n                ptr_x += window_xoffset;\n\n                if (s->pixel_type == EXR_FLOAT ||\n                    s->compression == EXR_DWAA ||\n                    s->compression == EXR_DWAB) {\n                    // 32-bit\n                    union av_intfloat32 t;\n                    if (trc_func && c < 3) {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            t.f = trc_func(t.f);\n                            *ptr_x++ = t;\n                        }\n                    } else if (one_gamma != 1.f) {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            if (t.f > 0.0f && c < 3)  /* avoid negative values */\n                                t.f = powf(t.f, one_gamma);\n                            *ptr_x++ = t;\n                        }\n                    } else {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            *ptr_x++ = t;\n                        }\n                    }\n                } else if (s->pixel_type == EXR_HALF) {\n                    // 16-bit\n                    if (c < 3 || !trc_func) {\n                        for (x = 0; x < xsize; x++) {\n                            *ptr_x++ = s->gamma_table[bytestream_get_le16(&src)];\n                        }\n                    } else {\n                        for (x = 0; x < xsize; x++) {\n                            ptr_x[0].i = half2float(bytestream_get_le16(&src),\n                                                    s->mantissatable,\n                                                    s->exponenttable,\n                                                    s->offsettable);\n                            ptr_x++;\n                        }\n                    }\n                }\n\n                // Zero out the end if xmax+1 is not w\n                memset(ptr_x, 0, axmax);\n                channel_buffer[c] += td->channel_line_size;\n            }\n        }\n    } else {\n\n        av_assert1(s->pixel_type == EXR_UINT);\n        ptr = p->data[0] + window_ymin * p->linesize[0] + (window_xmin * s->desc->nb_components * 2);\n\n        for (i = 0; i < ysize; i++, ptr += p->linesize[0]) {\n\n            const uint8_t * a;\n            const uint8_t *rgb[3];\n            uint16_t *ptr_x;\n\n            for (c = 0; c < rgb_channel_count; c++) {\n                rgb[c] = channel_buffer[c];\n            }\n\n            if (channel_buffer[3])\n                a = channel_buffer[3];\n\n            ptr_x = (uint16_t *) ptr;\n\n            // Zero out the start if xmin is not 0\n            memset(ptr_x, 0, bxmin);\n            ptr_x += window_xoffset * s->desc->nb_components;\n\n            for (x = 0; x < xsize; x++) {\n                for (c = 0; c < rgb_channel_count; c++) {\n                    *ptr_x++ = bytestream_get_le32(&rgb[c]) >> 16;\n                }\n\n                if (channel_buffer[3])\n                    *ptr_x++ = bytestream_get_le32(&a) >> 16;\n            }\n\n            // Zero out the end if xmax+1 is not w\n            memset(ptr_x, 0, axmax);\n\n            channel_buffer[0] += td->channel_line_size;\n            channel_buffer[1] += td->channel_line_size;\n            channel_buffer[2] += td->channel_line_size;\n            if (channel_buffer[3])\n                channel_buffer[3] += td->channel_line_size;\n        }\n    }\n\n    return 0;\n}\n\nstatic void skip_header_chunk(EXRContext *s)\n{\n    GetByteContext *gb = &s->gb;\n\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        if (!bytestream2_peek_byte(gb))\n            break;\n\n        // Process unknown variables\n        for (int i = 0; i < 2; i++) // value_name and value_type\n            while (bytestream2_get_byte(gb) != 0);\n\n        // Skip variable length\n        bytestream2_skip(gb, bytestream2_get_le32(gb));\n    }\n}\n\n/**\n * Check if the variable name corresponds to its data type.\n *\n * @param s              the EXRContext\n * @param value_name     name of the variable to check\n * @param value_type     type of the variable to check\n * @param minimum_length minimum length of the variable data\n *\n * @return bytes to read containing variable data\n *         -1 if variable is not found\n *         0 if buffer ended prematurely\n */\nstatic int check_header_variable(EXRContext *s,\n                                 const char *value_name,\n                                 const char *value_type,\n                                 unsigned int minimum_length)\n{\n    GetByteContext *gb = &s->gb;\n    int var_size = -1;\n\n    if (bytestream2_get_bytes_left(gb) >= minimum_length &&\n        !strcmp(gb->buffer, value_name)) {\n        // found value_name, jump to value_type (null terminated strings)\n        gb->buffer += strlen(value_name) + 1;\n        if (!strcmp(gb->buffer, value_type)) {\n            gb->buffer += strlen(value_type) + 1;\n            var_size = bytestream2_get_le32(gb);\n            // don't go read past boundaries\n            if (var_size > bytestream2_get_bytes_left(gb))\n                var_size = 0;\n        } else {\n            // value_type not found, reset the buffer\n            gb->buffer -= strlen(value_name) + 1;\n            av_log(s->avctx, AV_LOG_WARNING,\n                   \"Unknown data type %s for header variable %s.\\n\",\n                   value_type, value_name);\n        }\n    }\n\n    return var_size;\n}\n\nstatic int decode_header(EXRContext *s, AVFrame *frame)\n{\n    AVDictionary *metadata = NULL;\n    GetByteContext *gb = &s->gb;\n    int magic_number, version, flags;\n    int layer_match = 0;\n    int ret;\n    int dup_channels = 0;\n\n    s->current_channel_offset = 0;\n    s->xmin               = ~0;\n    s->xmax               = ~0;\n    s->ymin               = ~0;\n    s->ymax               = ~0;\n    s->xdelta             = ~0;\n    s->ydelta             = ~0;\n    s->channel_offsets[0] = -1;\n    s->channel_offsets[1] = -1;\n    s->channel_offsets[2] = -1;\n    s->channel_offsets[3] = -1;\n    s->pixel_type         = EXR_UNKNOWN;\n    s->compression        = EXR_UNKN;\n    s->nb_channels        = 0;\n    s->w                  = 0;\n    s->h                  = 0;\n    s->tile_attr.xSize    = -1;\n    s->tile_attr.ySize    = -1;\n    s->is_tile            = 0;\n    s->is_multipart       = 0;\n    s->is_luma            = 0;\n    s->current_part       = 0;\n\n    if (bytestream2_get_bytes_left(gb) < 10) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    magic_number = bytestream2_get_le32(gb);\n    if (magic_number != 20000630) {\n        /* As per documentation of OpenEXR, it is supposed to be\n         * int 20000630 little-endian */\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number);\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = bytestream2_get_byte(gb);\n    if (version != 2) {\n        avpriv_report_missing_feature(s->avctx, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    flags = bytestream2_get_le24(gb);\n\n    if (flags & 0x02)\n        s->is_tile = 1;\n    if (flags & 0x10)\n        s->is_multipart = 1;\n    if (flags & 0x08) {\n        avpriv_report_missing_feature(s->avctx, \"deep data\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    // Parse the header\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        int var_size;\n\n        while (s->is_multipart && s->current_part < s->selected_part &&\n               bytestream2_get_bytes_left(gb) > 0) {\n            if (bytestream2_peek_byte(gb)) {\n                skip_header_chunk(s);\n            } else {\n                bytestream2_skip(gb, 1);\n                if (!bytestream2_peek_byte(gb))\n                    break;\n            }\n            bytestream2_skip(gb, 1);\n            s->current_part++;\n        }\n\n        if (!bytestream2_peek_byte(gb)) {\n            if (!s->is_multipart)\n                break;\n            bytestream2_skip(gb, 1);\n            if (s->current_part == s->selected_part) {\n                while (bytestream2_get_bytes_left(gb) > 0) {\n                    if (bytestream2_peek_byte(gb)) {\n                        skip_header_chunk(s);\n                    } else {\n                        bytestream2_skip(gb, 1);\n                        if (!bytestream2_peek_byte(gb))\n                            break;\n                    }\n                }\n            }\n            if (!bytestream2_peek_byte(gb))\n                break;\n            s->current_part++;\n        }\n\n        if ((var_size = check_header_variable(s, \"channels\",\n                                              \"chlist\", 38)) >= 0) {\n            GetByteContext ch_gb;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            bytestream2_init(&ch_gb, gb->buffer, var_size);\n\n            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {\n                EXRChannel *channel;\n                enum ExrPixelType current_pixel_type;\n                int channel_index = -1;\n                int xsub, ysub;\n\n                if (strcmp(s->layer, \"\") != 0) {\n                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {\n                        layer_match = 1;\n                        av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel match layer : %s.\\n\", ch_gb.buffer);\n                        ch_gb.buffer += strlen(s->layer);\n                        if (*ch_gb.buffer == '.')\n                            ch_gb.buffer++;         /* skip dot if not given */\n                    } else {\n                        layer_match = 0;\n                        av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel doesn't match layer : %s.\\n\", ch_gb.buffer);\n                    }\n                } else {\n                    layer_match = 1;\n                }\n\n                if (layer_match) { /* only search channel if the layer match is valid */\n                    if (!av_strcasecmp(ch_gb.buffer, \"R\") ||\n                        !av_strcasecmp(ch_gb.buffer, \"X\") ||\n                        !av_strcasecmp(ch_gb.buffer, \"U\")) {\n                        channel_index = 0;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"G\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"V\")) {\n                        channel_index = 1;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"Y\")) {\n                        channel_index = 1;\n                        s->is_luma = 1;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"B\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"Z\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"W\")) {\n                        channel_index = 2;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"A\")) {\n                        channel_index = 3;\n                    } else {\n                        av_log(s->avctx, AV_LOG_WARNING,\n                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer);\n                    }\n                }\n\n                /* skip until you get a 0 */\n                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&\n                       bytestream2_get_byte(&ch_gb))\n                    continue;\n\n                if (bytestream2_get_bytes_left(&ch_gb) < 4) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n\n                current_pixel_type = bytestream2_get_le32(&ch_gb);\n                if (current_pixel_type >= EXR_UNKNOWN) {\n                    avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",\n                                                  current_pixel_type);\n                    ret = AVERROR_PATCHWELCOME;\n                    goto fail;\n                }\n\n                bytestream2_skip(&ch_gb, 4);\n                xsub = bytestream2_get_le32(&ch_gb);\n                ysub = bytestream2_get_le32(&ch_gb);\n\n                if (xsub != 1 || ysub != 1) {\n                    avpriv_report_missing_feature(s->avctx,\n                                                  \"Subsampling %dx%d\",\n                                                  xsub, ysub);\n                    ret = AVERROR_PATCHWELCOME;\n                    goto fail;\n                }\n\n                if (channel_index >= 0 && s->channel_offsets[channel_index] == -1) { /* channel has not been previously assigned */\n                    if (s->pixel_type != EXR_UNKNOWN &&\n                        s->pixel_type != current_pixel_type) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"RGB channels not of the same depth.\\n\");\n                        ret = AVERROR_INVALIDDATA;\n                        goto fail;\n                    }\n                    s->pixel_type                     = current_pixel_type;\n                    s->channel_offsets[channel_index] = s->current_channel_offset;\n                } else if (channel_index >= 0) {\n                    av_log(s->avctx, AV_LOG_WARNING,\n                            \"Multiple channels with index %d.\\n\", channel_index);\n                    if (++dup_channels > 10) {\n                        ret = AVERROR_INVALIDDATA;\n                        goto fail;\n                    }\n                }\n\n                s->channels = av_realloc(s->channels,\n                                         ++s->nb_channels * sizeof(EXRChannel));\n                if (!s->channels) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                channel             = &s->channels[s->nb_channels - 1];\n                channel->pixel_type = current_pixel_type;\n                channel->xsub       = xsub;\n                channel->ysub       = ysub;\n\n                if (current_pixel_type == EXR_HALF) {\n                    s->current_channel_offset += 2;\n                } else {/* Float or UINT32 */\n                    s->current_channel_offset += 4;\n                }\n            }\n\n            /* Check if all channels are set with an offset or if the channels\n             * are causing an overflow  */\n            if (!s->is_luma) {/* if we expected to have at least 3 channels */\n                if (FFMIN3(s->channel_offsets[0],\n                           s->channel_offsets[1],\n                           s->channel_offsets[2]) < 0) {\n                    if (s->channel_offsets[0] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\");\n                    if (s->channel_offsets[1] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\");\n                    if (s->channel_offsets[2] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n            }\n\n            // skip one last byte and update main gb\n            gb->buffer = ch_gb.buffer + 1;\n            continue;\n        } else if ((var_size = check_header_variable(s, \"dataWindow\", \"box2i\",\n                                                     31)) >= 0) {\n            int xmin, ymin, xmax, ymax;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            xmin   = bytestream2_get_le32(gb);\n            ymin   = bytestream2_get_le32(gb);\n            xmax   = bytestream2_get_le32(gb);\n            ymax   = bytestream2_get_le32(gb);\n\n            if (xmin > xmax || ymin > ymax ||\n                ymax == INT_MAX || xmax == INT_MAX ||\n                (unsigned)xmax - xmin >= INT_MAX ||\n                (unsigned)ymax - ymin >= INT_MAX) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            s->xmin = xmin;\n            s->xmax = xmax;\n            s->ymin = ymin;\n            s->ymax = ymax;\n            s->xdelta = (s->xmax - s->xmin) + 1;\n            s->ydelta = (s->ymax - s->ymin) + 1;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"displayWindow\",\n                                                     \"box2i\", 34)) >= 0) {\n            int32_t sx, sy, dx, dy;\n\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            sx = bytestream2_get_le32(gb);\n            sy = bytestream2_get_le32(gb);\n            dx = bytestream2_get_le32(gb);\n            dy = bytestream2_get_le32(gb);\n\n            s->w = dx - sx + 1;\n            s->h = dy - sy + 1;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"lineOrder\",\n                                                     \"lineOrder\", 25)) >= 0) {\n            int line_order;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            line_order = bytestream2_get_byte(gb);\n            av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order);\n            if (line_order > 2) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"pixelAspectRatio\",\n                                                     \"float\", 31)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            s->sar = bytestream2_get_le32(gb);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"compression\",\n                                                     \"compression\", 29)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            if (s->compression == EXR_UNKN)\n                s->compression = bytestream2_get_byte(gb);\n            else {\n                bytestream2_skip(gb, 1);\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found more than one compression attribute.\\n\");\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"tiles\",\n                                                     \"tiledesc\", 22)) >= 0) {\n            char tileLevel;\n\n            if (!s->is_tile)\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\");\n\n            s->tile_attr.xSize = bytestream2_get_le32(gb);\n            s->tile_attr.ySize = bytestream2_get_le32(gb);\n\n            tileLevel = bytestream2_get_byte(gb);\n            s->tile_attr.level_mode = tileLevel & 0x0f;\n            s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;\n\n            if (s->tile_attr.level_mode >= EXR_TILE_LEVEL_UNKNOWN) {\n                avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",\n                                              s->tile_attr.level_mode);\n                ret = AVERROR_PATCHWELCOME;\n                goto fail;\n            }\n\n            if (s->tile_attr.level_round >= EXR_TILE_ROUND_UNKNOWN) {\n                avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",\n                                              s->tile_attr.level_round);\n                ret = AVERROR_PATCHWELCOME;\n                goto fail;\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"writer\",\n                                                     \"string\", 1)) >= 0) {\n            uint8_t key[256] = { 0 };\n\n            bytestream2_get_buffer(gb, key, FFMIN(sizeof(key) - 1, var_size));\n            av_dict_set(&metadata, \"writer\", key, 0);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"framesPerSecond\",\n                                                     \"rational\", 33)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            s->avctx->framerate.num = bytestream2_get_le32(gb);\n            s->avctx->framerate.den = bytestream2_get_le32(gb);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"chunkCount\",\n                                                     \"int\", 23)) >= 0) {\n\n            s->chunk_count = bytestream2_get_le32(gb);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"type\",\n                                                     \"string\", 16)) >= 0) {\n            uint8_t key[256] = { 0 };\n\n            bytestream2_get_buffer(gb, key, FFMIN(sizeof(key) - 1, var_size));\n            if (strncmp(\"scanlineimage\", key, var_size) &&\n                strncmp(\"tiledimage\", key, var_size))\n                return AVERROR_PATCHWELCOME;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"preview\",\n                                                     \"preview\", 16)) >= 0) {\n            uint32_t pw = bytestream2_get_le32(gb);\n            uint32_t ph = bytestream2_get_le32(gb);\n            int64_t psize = 4LL * pw * ph;\n\n            if (psize >= bytestream2_get_bytes_left(gb))\n                return AVERROR_INVALIDDATA;\n\n            bytestream2_skip(gb, psize);\n\n            continue;\n        }\n\n        // Check if there are enough bytes for a header\n        if (bytestream2_get_bytes_left(gb) <= 9) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        // Process unknown variables\n        {\n            uint8_t name[256] = { 0 };\n            uint8_t type[256] = { 0 };\n            uint8_t value[256] = { 0 };\n            int i = 0, size;\n\n            while (bytestream2_get_bytes_left(gb) > 0 &&\n                   bytestream2_peek_byte(gb) && i < 255) {\n                name[i++] = bytestream2_get_byte(gb);\n            }\n\n            bytestream2_skip(gb, 1);\n            i = 0;\n            while (bytestream2_get_bytes_left(gb) > 0 &&\n                   bytestream2_peek_byte(gb) && i < 255) {\n                type[i++] = bytestream2_get_byte(gb);\n            }\n            bytestream2_skip(gb, 1);\n            size = bytestream2_get_le32(gb);\n\n            bytestream2_get_buffer(gb, value, FFMIN(sizeof(value) - 1, size));\n            if (!strcmp(type, \"string\"))\n                av_dict_set(&metadata, name, value, 0);\n        }\n    }\n\n    if (s->compression == EXR_UNKN) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (s->is_tile) {\n        if (s->tile_attr.xSize < 1 || s->tile_attr.ySize < 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n\n    if (bytestream2_get_bytes_left(gb) <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    frame->metadata = metadata;\n\n    // aaand we are done\n    bytestream2_skip(gb, 1);\n    return 0;\nfail:\n    av_dict_free(&metadata);\n    return ret;\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    EXRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    uint8_t *ptr;\n\n    int i, y, ret, ymax;\n    int planes;\n    int out_line_size;\n    int nb_blocks;   /* nb scanline or nb tile */\n    uint64_t start_offset_table;\n    uint64_t start_next_scanline;\n    PutByteContext offset_table_writer;\n\n    bytestream2_init(gb, avpkt->data, avpkt->size);\n\n    if ((ret = decode_header(s, picture)) < 0)\n        return ret;\n\n    if ((s->compression == EXR_DWAA || s->compression == EXR_DWAB) &&\n        s->pixel_type == EXR_HALF) {\n        s->current_channel_offset *= 2;\n        for (int i = 0; i < 4; i++)\n            s->channel_offsets[i] *= 2;\n    }\n\n    switch (s->pixel_type) {\n    case EXR_FLOAT:\n    case EXR_HALF:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            } else {\n                /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;\n            }\n        }\n        break;\n    case EXR_UINT:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_YA16;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGB48;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n            }\n        }\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)\n        avctx->color_trc = s->apply_trc_type;\n\n    switch (s->compression) {\n    case EXR_RAW:\n    case EXR_RLE:\n    case EXR_ZIP1:\n        s->scan_lines_per_block = 1;\n        break;\n    case EXR_PXR24:\n    case EXR_ZIP16:\n        s->scan_lines_per_block = 16;\n        break;\n    case EXR_PIZ:\n    case EXR_B44:\n    case EXR_B44A:\n    case EXR_DWAA:\n        s->scan_lines_per_block = 32;\n        break;\n    case EXR_DWAB:\n        s->scan_lines_per_block = 256;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* Verify the xmin, xmax, ymin and ymax before setting the actual image size.\n     * It's possible for the data window can larger or outside the display window */\n    if (s->xmin > s->xmax  || s->ymin > s->ymax ||\n        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)\n        return ret;\n\n    ff_set_sar(s->avctx, av_d2q(av_int2float(s->sar), 255));\n\n    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!s->desc)\n        return AVERROR_INVALIDDATA;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        planes           = s->desc->nb_components;\n        out_line_size    = avctx->width * 4;\n    } else {\n        planes           = 1;\n        out_line_size    = avctx->width * 2 * s->desc->nb_components;\n    }\n\n    if (s->is_tile) {\n        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *\n        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);\n    } else { /* scanline */\n        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /\n        s->scan_lines_per_block;\n    }\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    if (bytestream2_get_bytes_left(gb)/8 < nb_blocks)\n        return AVERROR_INVALIDDATA;\n\n    // check offset table and recreate it if need\n    if (!s->is_tile && bytestream2_peek_le64(gb) == 0) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");\n\n        start_offset_table = bytestream2_tell(gb);\n        start_next_scanline = start_offset_table + nb_blocks * 8;\n        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);\n\n        for (y = 0; y < nb_blocks; y++) {\n            /* write offset of prev scanline in offset table */\n            bytestream2_put_le64(&offset_table_writer, start_next_scanline);\n\n            /* get len of next scanline */\n            bytestream2_seek(gb, start_next_scanline + 4, SEEK_SET);/* skip line number */\n            start_next_scanline += (bytestream2_get_le32(gb) + 8);\n        }\n        bytestream2_seek(gb, start_offset_table, SEEK_SET);\n    }\n\n    // save pointer we are going to use in decode_block\n    s->buf      = avpkt->data;\n    s->buf_size = avpkt->size;\n\n    // Zero out the start if ymin is not 0\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i];\n        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    if (ymax < avctx->height)\n        for (i = 0; i < planes; i++) {\n            ptr = picture->data[i] + (ymax * picture->linesize[i]);\n            for (y = ymax; y < avctx->height; y++) {\n                memset(ptr, 0, out_line_size);\n                ptr += picture->linesize[i];\n            }\n        }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    EXRContext *s = avctx->priv_data;\n    uint32_t i;\n    union av_intfloat32 t;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = NULL;\n\n    half2float_table(s->mantissatable, s->exponenttable, s->offsettable);\n\n    s->avctx              = avctx;\n\n    ff_exrdsp_init(&s->dsp);\n\n#if HAVE_BIGENDIAN\n    ff_bswapdsp_init(&s->bbdsp);\n#endif\n\n    trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    if (trc_func) {\n        for (i = 0; i < 65536; ++i) {\n            t.i = half2float(i, s->mantissatable, s->exponenttable, s->offsettable);\n            t.f = trc_func(t.f);\n            s->gamma_table[i] = t;\n        }\n    } else {\n        if (one_gamma > 0.9999f && one_gamma < 1.0001f) {\n            for (i = 0; i < 65536; ++i) {\n                s->gamma_table[i].i = half2float(i, s->mantissatable, s->exponenttable, s->offsettable);\n            }\n        } else {\n            for (i = 0; i < 65536; ++i) {\n                t.i = half2float(i, s->mantissatable, s->exponenttable, s->offsettable);\n                /* If negative value we reuse half value */\n                if (t.f <= 0.0f) {\n                    s->gamma_table[i] = t;\n                } else {\n                    t.f = powf(t.f, one_gamma);\n                    s->gamma_table[i] = t;\n                }\n            }\n        }\n    }\n\n    // allocate thread data, used for non EXR_RAW compression types\n    s->thread_data = av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData));\n    if (!s->thread_data)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    EXRContext *s = avctx->priv_data;\n    int i;\n    for (i = 0; i < avctx->thread_count; i++) {\n        EXRThreadData *td = &s->thread_data[i];\n        av_freep(&td->uncompressed_data);\n        av_freep(&td->tmp);\n        av_freep(&td->bitmap);\n        av_freep(&td->lut);\n        av_freep(&td->he);\n        av_freep(&td->freq);\n        av_freep(&td->ac_data);\n        av_freep(&td->dc_data);\n        av_freep(&td->rle_data);\n        av_freep(&td->rle_raw_data);\n        ff_free_vlc(&td->vlc);\n    }\n\n    av_freep(&s->thread_data);\n    av_freep(&s->channels);\n\n    return 0;\n}\n\n#define OFFSET(x) offsetof(EXRContext, x)\n#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption options[] = {\n    { \"layer\", \"Set the decoding layer\", OFFSET(layer),\n        AV_OPT_TYPE_STRING, { .str = \"\" }, 0, 0, VD },\n    { \"part\",  \"Set the decoding part\", OFFSET(selected_part),\n        AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VD },\n    { \"gamma\", \"Set the float gamma value when decoding\", OFFSET(gamma),\n        AV_OPT_TYPE_FLOAT, { .dbl = 1.0f }, 0.001, FLT_MAX, VD },\n\n    // XXX: Note the abuse of the enum using AVCOL_TRC_UNSPECIFIED to subsume the existing gamma option\n    { \"apply_trc\", \"color transfer characteristics to apply to EXR linear input\", OFFSET(apply_trc_type),\n        AV_OPT_TYPE_INT, {.i64 = AVCOL_TRC_UNSPECIFIED }, 1, AVCOL_TRC_NB-1, VD, \"apply_trc_type\"},\n    { \"bt709\",        \"BT.709\",           0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT709 },        INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma\",        \"gamma\",            0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma22\",      \"BT.470 M\",         0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA22 },      INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma28\",      \"BT.470 BG\",        0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA28 },      INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte170m\",    \"SMPTE 170 M\",      0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE170M },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte240m\",    \"SMPTE 240 M\",      0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE240M },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"linear\",       \"Linear\",           0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LINEAR },       INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"log\",          \"Log\",              0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG },          INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"log_sqrt\",     \"Log square root\",  0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT },     INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"iec61966_2_4\", \"IEC 61966-2-4\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt1361\",       \"BT.1361\",          0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG },   INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"iec61966_2_1\", \"IEC 61966-2-1\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt2020_10bit\", \"BT.2020 - 10 bit\", 0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt2020_12bit\", \"BT.2020 - 12 bit\", 0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte2084\",    \"SMPTE ST 2084\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST2084 },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte428_1\",   \"SMPTE ST 428-1\",   0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST428_1 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n\n    { NULL },\n};\n\nstatic const AVClass exr_class = {\n    .class_name = \"EXR\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nconst AVCodec ff_exr_decoder = {\n    .name             = \"exr\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"OpenEXR image\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_EXR,\n    .priv_data_size   = sizeof(EXRContext),\n    .init             = decode_init,\n    .close            = decode_end,\n    .decode           = decode_frame,\n    .capabilities     = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |\n                        AV_CODEC_CAP_SLICE_THREADS,\n    .priv_class       = &exr_class,\n};\n"], "fixing_code": ["/*\n * OpenEXR (.exr) image decoder\n * Copyright (c) 2006 Industrial Light & Magic, a division of Lucas Digital Ltd. LLC\n * Copyright (c) 2009 Jimmy Christensen\n *\n * B44/B44A, Tile, UINT32 added by Jokyo Images support by CNC - French National Center for Cinema\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * OpenEXR decoder\n * @author Jimmy Christensen\n *\n * For more information on the OpenEXR format, visit:\n *  http://openexr.com/\n */\n\n#include <float.h>\n#include <zlib.h>\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/color_utils.h\"\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n\n#if HAVE_BIGENDIAN\n#include \"bswapdsp.h\"\n#endif\n\n#include \"exrdsp.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n#include \"half2float.h\"\n#include \"mathops.h\"\n#include \"thread.h\"\n\nenum ExrCompr {\n    EXR_RAW,\n    EXR_RLE,\n    EXR_ZIP1,\n    EXR_ZIP16,\n    EXR_PIZ,\n    EXR_PXR24,\n    EXR_B44,\n    EXR_B44A,\n    EXR_DWAA,\n    EXR_DWAB,\n    EXR_UNKN,\n};\n\nenum ExrPixelType {\n    EXR_UINT,\n    EXR_HALF,\n    EXR_FLOAT,\n    EXR_UNKNOWN,\n};\n\nenum ExrTileLevelMode {\n    EXR_TILE_LEVEL_ONE,\n    EXR_TILE_LEVEL_MIPMAP,\n    EXR_TILE_LEVEL_RIPMAP,\n    EXR_TILE_LEVEL_UNKNOWN,\n};\n\nenum ExrTileLevelRound {\n    EXR_TILE_ROUND_UP,\n    EXR_TILE_ROUND_DOWN,\n    EXR_TILE_ROUND_UNKNOWN,\n};\n\ntypedef struct HuffEntry {\n    uint8_t  len;\n    uint16_t sym;\n    uint32_t code;\n} HuffEntry;\n\ntypedef struct EXRChannel {\n    int xsub, ysub;\n    enum ExrPixelType pixel_type;\n} EXRChannel;\n\ntypedef struct EXRTileAttribute {\n    int32_t xSize;\n    int32_t ySize;\n    enum ExrTileLevelMode level_mode;\n    enum ExrTileLevelRound level_round;\n} EXRTileAttribute;\n\ntypedef struct EXRThreadData {\n    uint8_t *uncompressed_data;\n    int uncompressed_size;\n\n    uint8_t *tmp;\n    int tmp_size;\n\n    uint8_t *bitmap;\n    uint16_t *lut;\n\n    uint8_t *ac_data;\n    unsigned ac_size;\n\n    uint8_t *dc_data;\n    unsigned dc_size;\n\n    uint8_t *rle_data;\n    unsigned rle_size;\n\n    uint8_t *rle_raw_data;\n    unsigned rle_raw_size;\n\n    float block[3][64];\n\n    int ysize, xsize;\n\n    int channel_line_size;\n\n    int run_sym;\n    HuffEntry *he;\n    uint64_t *freq;\n    VLC vlc;\n} EXRThreadData;\n\ntypedef struct EXRContext {\n    AVClass *class;\n    AVFrame *picture;\n    AVCodecContext *avctx;\n    ExrDSPContext dsp;\n\n#if HAVE_BIGENDIAN\n    BswapDSPContext bbdsp;\n#endif\n\n    enum ExrCompr compression;\n    enum ExrPixelType pixel_type;\n    int channel_offsets[4]; // 0 = red, 1 = green, 2 = blue and 3 = alpha\n    const AVPixFmtDescriptor *desc;\n\n    int w, h;\n    uint32_t sar;\n    int32_t xmax, xmin;\n    int32_t ymax, ymin;\n    uint32_t xdelta, ydelta;\n\n    int scan_lines_per_block;\n\n    EXRTileAttribute tile_attr; /* header data attribute of tile */\n    int is_tile; /* 0 if scanline, 1 if tile */\n    int is_multipart;\n    int current_part;\n\n    int is_luma;/* 1 if there is an Y plane */\n\n    GetByteContext gb;\n    const uint8_t *buf;\n    int buf_size;\n\n    EXRChannel *channels;\n    int nb_channels;\n    int current_channel_offset;\n    uint32_t chunk_count;\n\n    EXRThreadData *thread_data;\n\n    const char *layer;\n    int selected_part;\n\n    enum AVColorTransferCharacteristic apply_trc_type;\n    float gamma;\n    union av_intfloat32 gamma_table[65536];\n\n    uint32_t mantissatable[2048];\n    uint32_t exponenttable[64];\n    uint16_t offsettable[64];\n} EXRContext;\n\nstatic int zip_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    unsigned long dest_len = uncompressed_size;\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK ||\n        dest_len != uncompressed_size)\n        return AVERROR_INVALIDDATA;\n\n    av_assert1(uncompressed_size % 2 == 0);\n\n    s->dsp.predictor(td->tmp, uncompressed_size);\n    s->dsp.reorder_pixels(td->uncompressed_data, td->tmp, uncompressed_size);\n\n    return 0;\n}\n\nstatic int rle(uint8_t *dst, const uint8_t *src,\n               int compressed_size, int uncompressed_size)\n{\n    uint8_t *d      = dst;\n    const int8_t *s = src;\n    int ssize       = compressed_size;\n    int dsize       = uncompressed_size;\n    uint8_t *dend   = d + dsize;\n    int count;\n\n    while (ssize > 0) {\n        count = *s++;\n\n        if (count < 0) {\n            count = -count;\n\n            if ((dsize -= count) < 0 ||\n                (ssize -= count + 1) < 0)\n                return AVERROR_INVALIDDATA;\n\n            while (count--)\n                *d++ = *s++;\n        } else {\n            count++;\n\n            if ((dsize -= count) < 0 ||\n                (ssize -= 2) < 0)\n                return AVERROR_INVALIDDATA;\n\n            while (count--)\n                *d++ = *s;\n\n            s++;\n        }\n    }\n\n    if (dend != d)\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int rle_uncompress(EXRContext *ctx, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    rle(td->tmp, src, compressed_size, uncompressed_size);\n\n    av_assert1(uncompressed_size % 2 == 0);\n\n    ctx->dsp.predictor(td->tmp, uncompressed_size);\n    ctx->dsp.reorder_pixels(td->uncompressed_data, td->tmp, uncompressed_size);\n\n    return 0;\n}\n\n#define USHORT_RANGE (1 << 16)\n#define BITMAP_SIZE  (1 << 13)\n\nstatic uint16_t reverse_lut(const uint8_t *bitmap, uint16_t *lut)\n{\n    int i, k = 0;\n\n    for (i = 0; i < USHORT_RANGE; i++)\n        if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))\n            lut[k++] = i;\n\n    i = k - 1;\n\n    memset(lut + k, 0, (USHORT_RANGE - k) * 2);\n\n    return i;\n}\n\nstatic void apply_lut(const uint16_t *lut, uint16_t *dst, int dsize)\n{\n    int i;\n\n    for (i = 0; i < dsize; ++i)\n        dst[i] = lut[dst[i]];\n}\n\n#define HUF_ENCBITS 16  // literal (value) bit length\n#define HUF_ENCSIZE ((1 << HUF_ENCBITS) + 1)  // encoding table size\n\nstatic void huf_canonical_code_table(uint64_t *freq)\n{\n    uint64_t c, n[59] = { 0 };\n    int i;\n\n    for (i = 0; i < HUF_ENCSIZE; i++)\n        n[freq[i]] += 1;\n\n    c = 0;\n    for (i = 58; i > 0; --i) {\n        uint64_t nc = ((c + n[i]) >> 1);\n        n[i] = c;\n        c    = nc;\n    }\n\n    for (i = 0; i < HUF_ENCSIZE; ++i) {\n        int l = freq[i];\n\n        if (l > 0)\n            freq[i] = l | (n[l]++ << 6);\n    }\n}\n\n#define SHORT_ZEROCODE_RUN  59\n#define LONG_ZEROCODE_RUN   63\n#define SHORTEST_LONG_RUN   (2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN)\n#define LONGEST_LONG_RUN    (255 + SHORTEST_LONG_RUN)\n\nstatic int huf_unpack_enc_table(GetByteContext *gb,\n                                int32_t im, int32_t iM, uint64_t *freq)\n{\n    GetBitContext gbit;\n    int ret = init_get_bits8(&gbit, gb->buffer, bytestream2_get_bytes_left(gb));\n    if (ret < 0)\n        return ret;\n\n    for (; im <= iM; im++) {\n        uint64_t l = freq[im] = get_bits(&gbit, 6);\n\n        if (l == LONG_ZEROCODE_RUN) {\n            int zerun = get_bits(&gbit, 8) + SHORTEST_LONG_RUN;\n\n            if (im + zerun > iM + 1)\n                return AVERROR_INVALIDDATA;\n\n            while (zerun--)\n                freq[im++] = 0;\n\n            im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n            int zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n            if (im + zerun > iM + 1)\n                return AVERROR_INVALIDDATA;\n\n            while (zerun--)\n                freq[im++] = 0;\n\n            im--;\n        }\n    }\n\n    bytestream2_skip(gb, (get_bits_count(&gbit) + 7) / 8);\n    huf_canonical_code_table(freq);\n\n    return 0;\n}\n\nstatic int huf_build_dec_table(EXRContext *s,\n                               EXRThreadData *td, int im, int iM)\n{\n    int j = 0;\n\n    td->run_sym = -1;\n    for (int i = im; i < iM; i++) {\n        td->he[j].sym = i;\n        td->he[j].len = td->freq[i] & 63;\n        td->he[j].code = td->freq[i] >> 6;\n        if (td->he[j].len > 32) {\n            avpriv_request_sample(s->avctx, \"Too big code length\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (td->he[j].len > 0)\n            j++;\n        else\n            td->run_sym = i;\n    }\n\n    if (im > 0)\n        td->run_sym = 0;\n    else if (iM < 65535)\n        td->run_sym = 65535;\n\n    if (td->run_sym == -1) {\n        avpriv_request_sample(s->avctx, \"No place for run symbol\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    td->he[j].sym = td->run_sym;\n    td->he[j].len = td->freq[iM] & 63;\n    if (td->he[j].len > 32) {\n        avpriv_request_sample(s->avctx, \"Too big code length\");\n        return AVERROR_PATCHWELCOME;\n    }\n    td->he[j].code = td->freq[iM] >> 6;\n    j++;\n\n    ff_free_vlc(&td->vlc);\n    return ff_init_vlc_sparse(&td->vlc, 12, j,\n                              &td->he[0].len, sizeof(td->he[0]), sizeof(td->he[0].len),\n                              &td->he[0].code, sizeof(td->he[0]), sizeof(td->he[0].code),\n                              &td->he[0].sym, sizeof(td->he[0]), sizeof(td->he[0].sym), 0);\n}\n\nstatic int huf_decode(VLC *vlc, GetByteContext *gb, int nbits, int run_sym,\n                      int no, uint16_t *out)\n{\n    GetBitContext gbit;\n    int oe = 0;\n\n    init_get_bits(&gbit, gb->buffer, nbits);\n    while (get_bits_left(&gbit) > 0 && oe < no) {\n        uint16_t x = get_vlc2(&gbit, vlc->table, 12, 3);\n\n        if (x == run_sym) {\n            int run = get_bits(&gbit, 8);\n            uint16_t fill;\n\n            if (oe == 0 || oe + run > no)\n                return AVERROR_INVALIDDATA;\n\n            fill = out[oe - 1];\n\n            while (run-- > 0)\n                out[oe++] = fill;\n        } else {\n            out[oe++] = x;\n        }\n    }\n\n    return 0;\n}\n\nstatic int huf_uncompress(EXRContext *s,\n                          EXRThreadData *td,\n                          GetByteContext *gb,\n                          uint16_t *dst, int dst_size)\n{\n    int32_t im, iM;\n    uint32_t nBits;\n    int ret;\n\n    im       = bytestream2_get_le32(gb);\n    iM       = bytestream2_get_le32(gb);\n    bytestream2_skip(gb, 4);\n    nBits = bytestream2_get_le32(gb);\n    if (im < 0 || im >= HUF_ENCSIZE ||\n        iM < 0 || iM >= HUF_ENCSIZE)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(gb, 4);\n\n    if (!td->freq)\n        td->freq = av_malloc_array(HUF_ENCSIZE, sizeof(*td->freq));\n    if (!td->he)\n        td->he = av_calloc(HUF_ENCSIZE, sizeof(*td->he));\n    if (!td->freq || !td->he) {\n        ret = AVERROR(ENOMEM);\n        return ret;\n    }\n\n    memset(td->freq, 0, sizeof(*td->freq) * HUF_ENCSIZE);\n    if ((ret = huf_unpack_enc_table(gb, im, iM, td->freq)) < 0)\n        return ret;\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n        ret = AVERROR_INVALIDDATA;\n        return ret;\n    }\n\n    if ((ret = huf_build_dec_table(s, td, im, iM)) < 0)\n        return ret;\n    return huf_decode(&td->vlc, gb, nBits, td->run_sym, dst_size, dst);\n}\n\nstatic inline void wdec14(uint16_t l, uint16_t h, uint16_t *a, uint16_t *b)\n{\n    int16_t ls = l;\n    int16_t hs = h;\n    int hi     = hs;\n    int ai     = ls + (hi & 1) + (hi >> 1);\n    int16_t as = ai;\n    int16_t bs = ai - hi;\n\n    *a = as;\n    *b = bs;\n}\n\n#define NBITS      16\n#define A_OFFSET  (1 << (NBITS - 1))\n#define MOD_MASK  ((1 << NBITS) - 1)\n\nstatic inline void wdec16(uint16_t l, uint16_t h, uint16_t *a, uint16_t *b)\n{\n    int m  = l;\n    int d  = h;\n    int bb = (m - (d >> 1)) & MOD_MASK;\n    int aa = (d + bb - A_OFFSET) & MOD_MASK;\n    *b = bb;\n    *a = aa;\n}\n\nstatic void wav_decode(uint16_t *in, int nx, int ox,\n                       int ny, int oy, uint16_t mx)\n{\n    int w14 = (mx < (1 << 14));\n    int n   = (nx > ny) ? ny : nx;\n    int p   = 1;\n    int p2;\n\n    while (p <= n)\n        p <<= 1;\n\n    p >>= 1;\n    p2  = p;\n    p >>= 1;\n\n    while (p >= 1) {\n        uint16_t *py = in;\n        uint16_t *ey = in + oy * (ny - p2);\n        uint16_t i00, i01, i10, i11;\n        int oy1 = oy * p;\n        int oy2 = oy * p2;\n        int ox1 = ox * p;\n        int ox2 = ox * p2;\n\n        for (; py <= ey; py += oy2) {\n            uint16_t *px = py;\n            uint16_t *ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n                uint16_t *p01 = px + ox1;\n                uint16_t *p10 = px + oy1;\n                uint16_t *p11 = p10 + ox1;\n\n                if (w14) {\n                    wdec14(*px, *p10, &i00, &i10);\n                    wdec14(*p01, *p11, &i01, &i11);\n                    wdec14(i00, i01, px, p01);\n                    wdec14(i10, i11, p10, p11);\n                } else {\n                    wdec16(*px, *p10, &i00, &i10);\n                    wdec16(*p01, *p11, &i01, &i11);\n                    wdec16(i00, i01, px, p01);\n                    wdec16(i10, i11, p10, p11);\n                }\n            }\n\n            if (nx & p) {\n                uint16_t *p10 = px + oy1;\n\n                if (w14)\n                    wdec14(*px, *p10, &i00, p10);\n                else\n                    wdec16(*px, *p10, &i00, p10);\n\n                *px = i00;\n            }\n        }\n\n        if (ny & p) {\n            uint16_t *px = py;\n            uint16_t *ex = py + ox * (nx - p2);\n\n            for (; px <= ex; px += ox2) {\n                uint16_t *p01 = px + ox1;\n\n                if (w14)\n                    wdec14(*px, *p01, &i00, p01);\n                else\n                    wdec16(*px, *p01, &i00, p01);\n\n                *px = i00;\n            }\n        }\n\n        p2  = p;\n        p >>= 1;\n    }\n}\n\nstatic int piz_uncompress(EXRContext *s, const uint8_t *src, int ssize,\n                          int dsize, EXRThreadData *td)\n{\n    GetByteContext gb;\n    uint16_t maxval, min_non_zero, max_non_zero;\n    uint16_t *ptr;\n    uint16_t *tmp = (uint16_t *)td->tmp;\n    uint16_t *out;\n    uint16_t *in;\n    int ret, i, j;\n    int pixel_half_size;/* 1 for half, 2 for float and uint32 */\n    EXRChannel *channel;\n    int tmp_offset;\n\n    if (!td->bitmap)\n        td->bitmap = av_malloc(BITMAP_SIZE);\n    if (!td->lut)\n        td->lut = av_malloc(1 << 17);\n    if (!td->bitmap || !td->lut) {\n        av_freep(&td->bitmap);\n        av_freep(&td->lut);\n        return AVERROR(ENOMEM);\n    }\n\n    bytestream2_init(&gb, src, ssize);\n    min_non_zero = bytestream2_get_le16(&gb);\n    max_non_zero = bytestream2_get_le16(&gb);\n\n    if (max_non_zero >= BITMAP_SIZE)\n        return AVERROR_INVALIDDATA;\n\n    memset(td->bitmap, 0, FFMIN(min_non_zero, BITMAP_SIZE));\n    if (min_non_zero <= max_non_zero)\n        bytestream2_get_buffer(&gb, td->bitmap + min_non_zero,\n                               max_non_zero - min_non_zero + 1);\n    memset(td->bitmap + max_non_zero + 1, 0, BITMAP_SIZE - max_non_zero - 1);\n\n    maxval = reverse_lut(td->bitmap, td->lut);\n\n    bytestream2_skip(&gb, 4);\n    ret = huf_uncompress(s, td, &gb, tmp, dsize / sizeof(uint16_t));\n    if (ret)\n        return ret;\n\n    ptr = tmp;\n    for (i = 0; i < s->nb_channels; i++) {\n        channel = &s->channels[i];\n\n        if (channel->pixel_type == EXR_HALF)\n            pixel_half_size = 1;\n        else\n            pixel_half_size = 2;\n\n        for (j = 0; j < pixel_half_size; j++)\n            wav_decode(ptr + j, td->xsize, pixel_half_size, td->ysize,\n                       td->xsize * pixel_half_size, maxval);\n        ptr += td->xsize * td->ysize * pixel_half_size;\n    }\n\n    apply_lut(td->lut, tmp, dsize / sizeof(uint16_t));\n\n    out = (uint16_t *)td->uncompressed_data;\n    for (i = 0; i < td->ysize; i++) {\n        tmp_offset = 0;\n        for (j = 0; j < s->nb_channels; j++) {\n            channel = &s->channels[j];\n            if (channel->pixel_type == EXR_HALF)\n                pixel_half_size = 1;\n            else\n                pixel_half_size = 2;\n\n            in = tmp + tmp_offset * td->xsize * td->ysize + i * td->xsize * pixel_half_size;\n            tmp_offset += pixel_half_size;\n\n#if HAVE_BIGENDIAN\n            s->bbdsp.bswap16_buf(out, in, td->xsize * pixel_half_size);\n#else\n            memcpy(out, in, td->xsize * 2 * pixel_half_size);\n#endif\n            out += td->xsize * pixel_half_size;\n        }\n    }\n\n    return 0;\n}\n\nstatic int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n                            int compressed_size, int uncompressed_size,\n                            EXRThreadData *td)\n{\n    unsigned long dest_len, expected_len = 0;\n    const uint8_t *in = td->tmp;\n    uint8_t *out;\n    int c, i, j;\n\n    for (i = 0; i < s->nb_channels; i++) {\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n            expected_len += (td->xsize * td->ysize * 2);\n        } else {//UINT 32\n            expected_len += (td->xsize * td->ysize * 4);\n        }\n    }\n\n    dest_len = expected_len;\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n        return AVERROR_INVALIDDATA;\n    } else if (dest_len != expected_len) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    out = td->uncompressed_data;\n    for (i = 0; i < td->ysize; i++)\n        for (c = 0; c < s->nb_channels; c++) {\n            EXRChannel *channel = &s->channels[c];\n            const uint8_t *ptr[4];\n            uint32_t pixel = 0;\n\n            switch (channel->pixel_type) {\n            case EXR_FLOAT:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + td->xsize;\n                ptr[2] = ptr[1] + td->xsize;\n                in     = ptr[2] + td->xsize;\n\n                for (j = 0; j < td->xsize; ++j) {\n                    uint32_t diff = ((unsigned)*(ptr[0]++) << 24) |\n                                    (*(ptr[1]++) << 16) |\n                                    (*(ptr[2]++) << 8);\n                    pixel += diff;\n                    bytestream_put_le32(&out, pixel);\n                }\n                break;\n            case EXR_HALF:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + td->xsize;\n                in     = ptr[1] + td->xsize;\n                for (j = 0; j < td->xsize; j++) {\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n                    pixel += diff;\n                    bytestream_put_le16(&out, pixel);\n                }\n                break;\n            case EXR_UINT:\n                ptr[0] = in;\n                ptr[1] = ptr[0] + s->xdelta;\n                ptr[2] = ptr[1] + s->xdelta;\n                ptr[3] = ptr[2] + s->xdelta;\n                in     = ptr[3] + s->xdelta;\n\n                for (j = 0; j < s->xdelta; ++j) {\n                    uint32_t diff = ((uint32_t)*(ptr[0]++) << 24) |\n                    (*(ptr[1]++) << 16) |\n                    (*(ptr[2]++) << 8 ) |\n                    (*(ptr[3]++));\n                    pixel += diff;\n                    bytestream_put_le32(&out, pixel);\n                }\n                break;\n            default:\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n    return 0;\n}\n\nstatic void unpack_14(const uint8_t b[14], uint16_t s[16])\n{\n    unsigned short shift = (b[ 2] >> 2) & 15;\n    unsigned short bias = (0x20 << shift);\n    int i;\n\n    s[ 0] = (b[0] << 8) | b[1];\n\n    s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3f) << shift) - bias;\n    s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3f) << shift) - bias;\n    s[12] = s[ 8] +   ((b[ 4]                       & 0x3f) << shift) - bias;\n\n    s[ 1] = s[ 0] +   ((b[ 5] >> 2)                         << shift) - bias;\n    s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3f) << shift) - bias;\n    s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3f) << shift) - bias;\n    s[13] = s[12] +   ((b[ 7]                       & 0x3f) << shift) - bias;\n\n    s[ 2] = s[ 1] +   ((b[ 8] >> 2)                         << shift) - bias;\n    s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3f) << shift) - bias;\n    s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3f) << shift) - bias;\n    s[14] = s[13] +   ((b[10]                       & 0x3f) << shift) - bias;\n\n    s[ 3] = s[ 2] +   ((b[11] >> 2)                         << shift) - bias;\n    s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3f) << shift) - bias;\n    s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3f) << shift) - bias;\n    s[15] = s[14] +   ((b[13]                       & 0x3f) << shift) - bias;\n\n    for (i = 0; i < 16; ++i) {\n        if (s[i] & 0x8000)\n            s[i] &= 0x7fff;\n        else\n            s[i] = ~s[i];\n    }\n}\n\nstatic void unpack_3(const uint8_t b[3], uint16_t s[16])\n{\n    int i;\n\n    s[0] = (b[0] << 8) | b[1];\n\n    if (s[0] & 0x8000)\n        s[0] &= 0x7fff;\n    else\n        s[0] = ~s[0];\n\n    for (i = 1; i < 16; i++)\n        s[i] = s[0];\n}\n\n\nstatic int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td) {\n    const int8_t *sr = src;\n    int stay_to_uncompress = compressed_size;\n    int nb_b44_block_w, nb_b44_block_h;\n    int index_tl_x, index_tl_y, index_out, index_tmp;\n    uint16_t tmp_buffer[16]; /* B44 use 4x4 half float pixel */\n    int c, iY, iX, y, x;\n    int target_channel_offset = 0;\n\n    /* calc B44 block count */\n    nb_b44_block_w = td->xsize / 4;\n    if ((td->xsize % 4) != 0)\n        nb_b44_block_w++;\n\n    nb_b44_block_h = td->ysize / 4;\n    if ((td->ysize % 4) != 0)\n        nb_b44_block_h++;\n\n    for (c = 0; c < s->nb_channels; c++) {\n        if (s->channels[c].pixel_type == EXR_HALF) {/* B44 only compress half float data */\n            for (iY = 0; iY < nb_b44_block_h; iY++) {\n                for (iX = 0; iX < nb_b44_block_w; iX++) {/* For each B44 block */\n                    if (stay_to_uncompress < 3) {\n                        av_log(s, AV_LOG_ERROR, \"Not enough data for B44A block: %d\", stay_to_uncompress);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    if (src[compressed_size - stay_to_uncompress + 2] == 0xfc) { /* B44A block */\n                        unpack_3(sr, tmp_buffer);\n                        sr += 3;\n                        stay_to_uncompress -= 3;\n                    }  else {/* B44 Block */\n                        if (stay_to_uncompress < 14) {\n                            av_log(s, AV_LOG_ERROR, \"Not enough data for B44 block: %d\", stay_to_uncompress);\n                            return AVERROR_INVALIDDATA;\n                        }\n                        unpack_14(sr, tmp_buffer);\n                        sr += 14;\n                        stay_to_uncompress -= 14;\n                    }\n\n                    /* copy data to uncompress buffer (B44 block can exceed target resolution)*/\n                    index_tl_x = iX * 4;\n                    index_tl_y = iY * 4;\n\n                    for (y = index_tl_y; y < FFMIN(index_tl_y + 4, td->ysize); y++) {\n                        for (x = index_tl_x; x < FFMIN(index_tl_x + 4, td->xsize); x++) {\n                            index_out = target_channel_offset * td->xsize + y * td->channel_line_size + 2 * x;\n                            index_tmp = (y-index_tl_y) * 4 + (x-index_tl_x);\n                            td->uncompressed_data[index_out] = tmp_buffer[index_tmp] & 0xff;\n                            td->uncompressed_data[index_out + 1] = tmp_buffer[index_tmp] >> 8;\n                        }\n                    }\n                }\n            }\n            target_channel_offset += 2;\n        } else {/* Float or UINT 32 channel */\n            if (stay_to_uncompress < td->ysize * td->xsize * 4) {\n                av_log(s, AV_LOG_ERROR, \"Not enough data for uncompress channel: %d\", stay_to_uncompress);\n                return AVERROR_INVALIDDATA;\n            }\n\n            for (y = 0; y < td->ysize; y++) {\n                index_out = target_channel_offset * td->xsize + y * td->channel_line_size;\n                memcpy(&td->uncompressed_data[index_out], sr, td->xsize * 4);\n                sr += td->xsize * 4;\n            }\n            target_channel_offset += 4;\n\n            stay_to_uncompress -= td->ysize * td->xsize * 4;\n        }\n    }\n\n    return 0;\n}\n\nstatic int ac_uncompress(EXRContext *s, GetByteContext *gb, float *block)\n{\n    int ret = 0, n = 1;\n\n    while (n < 64) {\n        uint16_t val = bytestream2_get_ne16(gb);\n\n        if (val == 0xff00) {\n            n = 64;\n        } else if ((val >> 8) == 0xff) {\n            n += val & 0xff;\n        } else {\n            ret = n;\n            block[ff_zigzag_direct[n]] = av_int2float(half2float(val,\n                                                      s->mantissatable,\n                                                      s->exponenttable,\n                                                      s->offsettable));\n            n++;\n        }\n    }\n\n    return ret;\n}\n\nstatic void idct_1d(float *blk, int step)\n{\n    const float a = .5f * cosf(    M_PI / 4.f);\n    const float b = .5f * cosf(    M_PI / 16.f);\n    const float c = .5f * cosf(    M_PI / 8.f);\n    const float d = .5f * cosf(3.f*M_PI / 16.f);\n    const float e = .5f * cosf(5.f*M_PI / 16.f);\n    const float f = .5f * cosf(3.f*M_PI / 8.f);\n    const float g = .5f * cosf(7.f*M_PI / 16.f);\n\n    float alpha[4], beta[4], theta[4], gamma[4];\n\n    alpha[0] = c * blk[2 * step];\n    alpha[1] = f * blk[2 * step];\n    alpha[2] = c * blk[6 * step];\n    alpha[3] = f * blk[6 * step];\n\n    beta[0] = b * blk[1 * step] + d * blk[3 * step] + e * blk[5 * step] + g * blk[7 * step];\n    beta[1] = d * blk[1 * step] - g * blk[3 * step] - b * blk[5 * step] - e * blk[7 * step];\n    beta[2] = e * blk[1 * step] - b * blk[3 * step] + g * blk[5 * step] + d * blk[7 * step];\n    beta[3] = g * blk[1 * step] - e * blk[3 * step] + d * blk[5 * step] - b * blk[7 * step];\n\n    theta[0] = a * (blk[0 * step] + blk[4 * step]);\n    theta[3] = a * (blk[0 * step] - blk[4 * step]);\n\n    theta[1] = alpha[0] + alpha[3];\n    theta[2] = alpha[1] - alpha[2];\n\n    gamma[0] = theta[0] + theta[1];\n    gamma[1] = theta[3] + theta[2];\n    gamma[2] = theta[3] - theta[2];\n    gamma[3] = theta[0] - theta[1];\n\n    blk[0 * step] = gamma[0] + beta[0];\n    blk[1 * step] = gamma[1] + beta[1];\n    blk[2 * step] = gamma[2] + beta[2];\n    blk[3 * step] = gamma[3] + beta[3];\n\n    blk[4 * step] = gamma[3] - beta[3];\n    blk[5 * step] = gamma[2] - beta[2];\n    blk[6 * step] = gamma[1] - beta[1];\n    blk[7 * step] = gamma[0] - beta[0];\n}\n\nstatic void dct_inverse(float *block)\n{\n    for (int i = 0; i < 8; i++)\n        idct_1d(block + i, 8);\n\n    for (int i = 0; i < 8; i++) {\n        idct_1d(block, 1);\n        block += 8;\n    }\n}\n\nstatic void convert(float y, float u, float v,\n                    float *b, float *g, float *r)\n{\n    *r = y               + 1.5747f * v;\n    *g = y - 0.1873f * u - 0.4682f * v;\n    *b = y + 1.8556f * u;\n}\n\nstatic float to_linear(float x, float scale)\n{\n    float ax = fabsf(x);\n\n    if (ax <= 1.f) {\n        return FFSIGN(x) * powf(ax, 2.2f * scale);\n    } else {\n        const float log_base = expf(2.2f * scale);\n\n        return FFSIGN(x) * powf(log_base, ax - 1.f);\n    }\n}\n\nstatic int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    int64_t version, lo_usize, lo_size;\n    int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;\n    int64_t ac_count, dc_count, ac_compression;\n    const int dc_w = td->xsize >> 3;\n    const int dc_h = td->ysize >> 3;\n    GetByteContext gb, agb;\n    int skip, ret;\n\n    if (compressed_size <= 88)\n        return AVERROR_INVALIDDATA;\n\n    version = AV_RL64(src + 0);\n    if (version != 2)\n        return AVERROR_INVALIDDATA;\n\n    lo_usize = AV_RL64(src + 8);\n    lo_size = AV_RL64(src + 16);\n    ac_size = AV_RL64(src + 24);\n    dc_size = AV_RL64(src + 32);\n    rle_csize = AV_RL64(src + 40);\n    rle_usize = AV_RL64(src + 48);\n    rle_raw_size = AV_RL64(src + 56);\n    ac_count = AV_RL64(src + 64);\n    dc_count = AV_RL64(src + 72);\n    ac_compression = AV_RL64(src + 80);\n\n    if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&gb, src + 88, compressed_size - 88);\n    skip = bytestream2_get_le16(&gb);\n    if (skip < 2)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(&gb, skip - 2);\n\n    if (lo_size > 0) {\n        if (lo_usize > uncompressed_size)\n            return AVERROR_INVALIDDATA;\n        bytestream2_skip(&gb, lo_size);\n    }\n\n    if (ac_size > 0) {\n        unsigned long dest_len = ac_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);\n        if (!td->ac_data)\n            return AVERROR(ENOMEM);\n\n        switch (ac_compression) {\n        case 0:\n            ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);\n            if (ret < 0)\n                return ret;\n            break;\n        case 1:\n            if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||\n                dest_len != ac_count * 2LL)\n                return AVERROR_INVALIDDATA;\n            break;\n        default:\n            return AVERROR_INVALIDDATA;\n        }\n\n        bytestream2_skip(&gb, ac_size);\n    }\n\n    {\n        unsigned long dest_len = dc_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (dc_count != dc_w * dc_h * 3)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);\n        if (!td->dc_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||\n            (dest_len != dc_count * 2LL))\n            return AVERROR_INVALIDDATA;\n\n        s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);\n        s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);\n\n        bytestream2_skip(&gb, dc_size);\n    }\n\n    if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {\n        unsigned long dest_len = rle_usize;\n\n        av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);\n        if (!td->rle_data)\n            return AVERROR(ENOMEM);\n\n        av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);\n        if (!td->rle_raw_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||\n            (dest_len != rle_usize))\n            return AVERROR_INVALIDDATA;\n\n        ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);\n        if (ret < 0)\n            return ret;\n        bytestream2_skip(&gb, rle_csize);\n    }\n\n    bytestream2_init(&agb, td->ac_data, ac_count * 2);\n\n    for (int y = 0; y < td->ysize; y += 8) {\n        for (int x = 0; x < td->xsize; x += 8) {\n            memset(td->block, 0, sizeof(td->block));\n\n            for (int j = 0; j < 3; j++) {\n                float *block = td->block[j];\n                const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;\n                uint16_t *dc = (uint16_t *)td->dc_data;\n                union av_intfloat32 dc_val;\n\n                dc_val.i = half2float(dc[idx], s->mantissatable,\n                                      s->exponenttable, s->offsettable);\n\n                block[0] = dc_val.f;\n                ac_uncompress(s, &agb, block);\n                dct_inverse(block);\n            }\n\n            {\n                const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;\n                const int o = s->nb_channels == 4;\n                float *bo = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;\n                float *go = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;\n                float *ro = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;\n                float *yb = td->block[0];\n                float *ub = td->block[1];\n                float *vb = td->block[2];\n\n                for (int yy = 0; yy < 8; yy++) {\n                    for (int xx = 0; xx < 8; xx++) {\n                        const int idx = xx + yy * 8;\n\n                        convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);\n\n                        bo[xx] = to_linear(bo[xx], scale);\n                        go[xx] = to_linear(go[xx], scale);\n                        ro[xx] = to_linear(ro[xx], scale);\n                    }\n\n                    bo += td->xsize * s->nb_channels;\n                    go += td->xsize * s->nb_channels;\n                    ro += td->xsize * s->nb_channels;\n                }\n            }\n        }\n    }\n\n    if (s->nb_channels < 4)\n        return 0;\n\n    for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {\n        uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;\n        uint8_t *ai0 = td->rle_raw_data + y * td->xsize;\n        uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;\n\n        for (int x = 0; x < td->xsize; x++) {\n            uint16_t ha = ai0[x] | (ai1[x] << 8);\n\n            ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);\n        }\n    }\n\n    return 0;\n}\n\nstatic int decode_block(AVCodecContext *avctx, void *tdata,\n                        int jobnr, int threadnr)\n{\n    EXRContext *s = avctx->priv_data;\n    AVFrame *const p = s->picture;\n    EXRThreadData *td = &s->thread_data[threadnr];\n    const uint8_t *channel_buffer[4] = { 0 };\n    const uint8_t *buf = s->buf;\n    uint64_t line_offset, uncompressed_size;\n    uint8_t *ptr;\n    uint32_t data_size;\n    int line, col = 0;\n    uint64_t tile_x, tile_y, tile_level_x, tile_level_y;\n    const uint8_t *src;\n    int step = s->desc->flags & AV_PIX_FMT_FLAG_FLOAT ? 4 : 2 * s->desc->nb_components;\n    int bxmin = 0, axmax = 0, window_xoffset = 0;\n    int window_xmin, window_xmax, window_ymin, window_ymax;\n    int data_xoffset, data_yoffset, data_window_offset, xsize, ysize;\n    int i, x, buf_size = s->buf_size;\n    int c, rgb_channel_count;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    int ret;\n\n    line_offset = AV_RL64(s->gb.buffer + jobnr * 8);\n\n    if (s->is_tile) {\n        if (buf_size < 20 || line_offset > buf_size - 20)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 20;\n        if (s->is_multipart)\n            src += 4;\n\n        tile_x = AV_RL32(src - 20);\n        tile_y = AV_RL32(src - 16);\n        tile_level_x = AV_RL32(src - 12);\n        tile_level_y = AV_RL32(src - 8);\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size - line_offset - 20)\n            return AVERROR_INVALIDDATA;\n\n        if (tile_level_x || tile_level_y) { /* tile level, is not the full res level */\n            avpriv_report_missing_feature(s->avctx, \"Subres tile before full res tile\");\n            return AVERROR_PATCHWELCOME;\n        }\n\n        if (tile_x && s->tile_attr.xSize + (int64_t)FFMAX(s->xmin, 0) >= INT_MAX / tile_x )\n            return AVERROR_INVALIDDATA;\n        if (tile_y && s->tile_attr.ySize + (int64_t)FFMAX(s->ymin, 0) >= INT_MAX / tile_y )\n            return AVERROR_INVALIDDATA;\n\n        line = s->ymin + s->tile_attr.ySize * tile_y;\n        col = s->tile_attr.xSize * tile_x;\n\n        if (line < s->ymin || line > s->ymax ||\n            s->xmin + col  < s->xmin ||  s->xmin + col  > s->xmax)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tile_y * s->tile_attr.ySize);\n        td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tile_x * s->tile_attr.xSize);\n\n        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n    } else {\n        if (buf_size < 8 || line_offset > buf_size - 8)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 8;\n        if (s->is_multipart)\n            src += 4;\n        line = AV_RL32(src - 8);\n\n        if (line < s->ymin || line > s->ymax)\n            return AVERROR_INVALIDDATA;\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size - line_offset - 8)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize          = FFMIN(s->scan_lines_per_block, s->ymax - line + 1); /* s->ydelta - line ?? */\n        td->xsize          = s->xdelta;\n\n        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)\n            return AVERROR_INVALIDDATA;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n\n        if ((s->compression == EXR_RAW && (data_size != uncompressed_size ||\n                                           line_offset > buf_size - uncompressed_size)) ||\n            (s->compression != EXR_RAW && (data_size > uncompressed_size ||\n                                           line_offset > buf_size - data_size))) {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    window_xmin = FFMIN(avctx->width, FFMAX(0, s->xmin + col));\n    window_xmax = FFMIN(avctx->width, FFMAX(0, s->xmin + col + td->xsize));\n    window_ymin = FFMIN(avctx->height, FFMAX(0, line ));\n    window_ymax = FFMIN(avctx->height, FFMAX(0, line + td->ysize));\n    xsize = window_xmax - window_xmin;\n    ysize = window_ymax - window_ymin;\n\n    /* tile or scanline not visible skip decoding */\n    if (xsize <= 0 || ysize <= 0)\n        return 0;\n\n    /* is the first tile or is a scanline */\n    if(col == 0) {\n        window_xmin = 0;\n        /* pixels to add at the left of the display window */\n        window_xoffset = FFMAX(0, s->xmin);\n        /* bytes to add at the left of the display window */\n        bxmin = window_xoffset * step;\n    }\n\n    /* is the last tile or is a scanline */\n    if(col + td->xsize == s->xdelta) {\n        window_xmax = avctx->width;\n         /* bytes to add at the right of the display window */\n        axmax = FFMAX(0, (avctx->width - (s->xmax + 1))) * step;\n    }\n\n    if (data_size < uncompressed_size || s->is_tile) { /* td->tmp is use for tile reorganization */\n        av_fast_padded_malloc(&td->tmp, &td->tmp_size, uncompressed_size);\n        if (!td->tmp)\n            return AVERROR(ENOMEM);\n    }\n\n    if (data_size < uncompressed_size) {\n        av_fast_padded_malloc(&td->uncompressed_data,\n                              &td->uncompressed_size, uncompressed_size + 64);/* Force 64 padding for AVX2 reorder_pixels dst */\n\n        if (!td->uncompressed_data)\n            return AVERROR(ENOMEM);\n\n        ret = AVERROR_INVALIDDATA;\n        switch (s->compression) {\n        case EXR_ZIP1:\n        case EXR_ZIP16:\n            ret = zip_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PIZ:\n            ret = piz_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PXR24:\n            ret = pxr24_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_RLE:\n            ret = rle_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_B44:\n        case EXR_B44A:\n            ret = b44_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_DWAA:\n        case EXR_DWAB:\n            ret = dwa_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        }\n        if (ret < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"decode_block() failed.\\n\");\n            return ret;\n        }\n        src = td->uncompressed_data;\n    }\n\n    /* offsets to crop data outside display window */\n    data_xoffset = FFABS(FFMIN(0, s->xmin + col)) * (s->pixel_type == EXR_HALF ? 2 : 4);\n    data_yoffset = FFABS(FFMIN(0, line));\n    data_window_offset = (data_yoffset * td->channel_line_size) + data_xoffset;\n\n    if (!s->is_luma) {\n        channel_buffer[0] = src + (td->xsize * s->channel_offsets[0]) + data_window_offset;\n        channel_buffer[1] = src + (td->xsize * s->channel_offsets[1]) + data_window_offset;\n        channel_buffer[2] = src + (td->xsize * s->channel_offsets[2]) + data_window_offset;\n        rgb_channel_count = 3;\n    } else { /* put y data in the first channel_buffer */\n        channel_buffer[0] = src + (td->xsize * s->channel_offsets[1]) + data_window_offset;\n        rgb_channel_count = 1;\n    }\n     if (s->channel_offsets[3] >= 0)\n        channel_buffer[3] = src + (td->xsize * s->channel_offsets[3]) + data_window_offset;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n        int channel_count = s->channel_offsets[3] >= 0 ? 4 : rgb_channel_count;\n        if (s->is_luma) {\n            channel_buffer[1] = channel_buffer[0];\n            channel_buffer[2] = channel_buffer[0];\n        }\n\n        for (c = 0; c < channel_count; c++) {\n            int plane = s->desc->comp[c].plane;\n            ptr = p->data[plane] + window_ymin * p->linesize[plane] + (window_xmin * 4);\n\n            for (i = 0; i < ysize; i++, ptr += p->linesize[plane]) {\n                const uint8_t *src;\n                union av_intfloat32 *ptr_x;\n\n                src = channel_buffer[c];\n                ptr_x = (union av_intfloat32 *)ptr;\n\n                // Zero out the start if xmin is not 0\n                memset(ptr_x, 0, bxmin);\n                ptr_x += window_xoffset;\n\n                if (s->pixel_type == EXR_FLOAT ||\n                    s->compression == EXR_DWAA ||\n                    s->compression == EXR_DWAB) {\n                    // 32-bit\n                    union av_intfloat32 t;\n                    if (trc_func && c < 3) {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            t.f = trc_func(t.f);\n                            *ptr_x++ = t;\n                        }\n                    } else if (one_gamma != 1.f) {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            if (t.f > 0.0f && c < 3)  /* avoid negative values */\n                                t.f = powf(t.f, one_gamma);\n                            *ptr_x++ = t;\n                        }\n                    } else {\n                        for (x = 0; x < xsize; x++) {\n                            t.i = bytestream_get_le32(&src);\n                            *ptr_x++ = t;\n                        }\n                    }\n                } else if (s->pixel_type == EXR_HALF) {\n                    // 16-bit\n                    if (c < 3 || !trc_func) {\n                        for (x = 0; x < xsize; x++) {\n                            *ptr_x++ = s->gamma_table[bytestream_get_le16(&src)];\n                        }\n                    } else {\n                        for (x = 0; x < xsize; x++) {\n                            ptr_x[0].i = half2float(bytestream_get_le16(&src),\n                                                    s->mantissatable,\n                                                    s->exponenttable,\n                                                    s->offsettable);\n                            ptr_x++;\n                        }\n                    }\n                }\n\n                // Zero out the end if xmax+1 is not w\n                memset(ptr_x, 0, axmax);\n                channel_buffer[c] += td->channel_line_size;\n            }\n        }\n    } else {\n\n        av_assert1(s->pixel_type == EXR_UINT);\n        ptr = p->data[0] + window_ymin * p->linesize[0] + (window_xmin * s->desc->nb_components * 2);\n\n        for (i = 0; i < ysize; i++, ptr += p->linesize[0]) {\n\n            const uint8_t * a;\n            const uint8_t *rgb[3];\n            uint16_t *ptr_x;\n\n            for (c = 0; c < rgb_channel_count; c++) {\n                rgb[c] = channel_buffer[c];\n            }\n\n            if (channel_buffer[3])\n                a = channel_buffer[3];\n\n            ptr_x = (uint16_t *) ptr;\n\n            // Zero out the start if xmin is not 0\n            memset(ptr_x, 0, bxmin);\n            ptr_x += window_xoffset * s->desc->nb_components;\n\n            for (x = 0; x < xsize; x++) {\n                for (c = 0; c < rgb_channel_count; c++) {\n                    *ptr_x++ = bytestream_get_le32(&rgb[c]) >> 16;\n                }\n\n                if (channel_buffer[3])\n                    *ptr_x++ = bytestream_get_le32(&a) >> 16;\n            }\n\n            // Zero out the end if xmax+1 is not w\n            memset(ptr_x, 0, axmax);\n\n            channel_buffer[0] += td->channel_line_size;\n            channel_buffer[1] += td->channel_line_size;\n            channel_buffer[2] += td->channel_line_size;\n            if (channel_buffer[3])\n                channel_buffer[3] += td->channel_line_size;\n        }\n    }\n\n    return 0;\n}\n\nstatic void skip_header_chunk(EXRContext *s)\n{\n    GetByteContext *gb = &s->gb;\n\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        if (!bytestream2_peek_byte(gb))\n            break;\n\n        // Process unknown variables\n        for (int i = 0; i < 2; i++) // value_name and value_type\n            while (bytestream2_get_byte(gb) != 0);\n\n        // Skip variable length\n        bytestream2_skip(gb, bytestream2_get_le32(gb));\n    }\n}\n\n/**\n * Check if the variable name corresponds to its data type.\n *\n * @param s              the EXRContext\n * @param value_name     name of the variable to check\n * @param value_type     type of the variable to check\n * @param minimum_length minimum length of the variable data\n *\n * @return bytes to read containing variable data\n *         -1 if variable is not found\n *         0 if buffer ended prematurely\n */\nstatic int check_header_variable(EXRContext *s,\n                                 const char *value_name,\n                                 const char *value_type,\n                                 unsigned int minimum_length)\n{\n    GetByteContext *gb = &s->gb;\n    int var_size = -1;\n\n    if (bytestream2_get_bytes_left(gb) >= minimum_length &&\n        !strcmp(gb->buffer, value_name)) {\n        // found value_name, jump to value_type (null terminated strings)\n        gb->buffer += strlen(value_name) + 1;\n        if (!strcmp(gb->buffer, value_type)) {\n            gb->buffer += strlen(value_type) + 1;\n            var_size = bytestream2_get_le32(gb);\n            // don't go read past boundaries\n            if (var_size > bytestream2_get_bytes_left(gb))\n                var_size = 0;\n        } else {\n            // value_type not found, reset the buffer\n            gb->buffer -= strlen(value_name) + 1;\n            av_log(s->avctx, AV_LOG_WARNING,\n                   \"Unknown data type %s for header variable %s.\\n\",\n                   value_type, value_name);\n        }\n    }\n\n    return var_size;\n}\n\nstatic int decode_header(EXRContext *s, AVFrame *frame)\n{\n    AVDictionary *metadata = NULL;\n    GetByteContext *gb = &s->gb;\n    int magic_number, version, flags;\n    int layer_match = 0;\n    int ret;\n    int dup_channels = 0;\n\n    s->current_channel_offset = 0;\n    s->xmin               = ~0;\n    s->xmax               = ~0;\n    s->ymin               = ~0;\n    s->ymax               = ~0;\n    s->xdelta             = ~0;\n    s->ydelta             = ~0;\n    s->channel_offsets[0] = -1;\n    s->channel_offsets[1] = -1;\n    s->channel_offsets[2] = -1;\n    s->channel_offsets[3] = -1;\n    s->pixel_type         = EXR_UNKNOWN;\n    s->compression        = EXR_UNKN;\n    s->nb_channels        = 0;\n    s->w                  = 0;\n    s->h                  = 0;\n    s->tile_attr.xSize    = -1;\n    s->tile_attr.ySize    = -1;\n    s->is_tile            = 0;\n    s->is_multipart       = 0;\n    s->is_luma            = 0;\n    s->current_part       = 0;\n\n    if (bytestream2_get_bytes_left(gb) < 10) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    magic_number = bytestream2_get_le32(gb);\n    if (magic_number != 20000630) {\n        /* As per documentation of OpenEXR, it is supposed to be\n         * int 20000630 little-endian */\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number);\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = bytestream2_get_byte(gb);\n    if (version != 2) {\n        avpriv_report_missing_feature(s->avctx, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    flags = bytestream2_get_le24(gb);\n\n    if (flags & 0x02)\n        s->is_tile = 1;\n    if (flags & 0x10)\n        s->is_multipart = 1;\n    if (flags & 0x08) {\n        avpriv_report_missing_feature(s->avctx, \"deep data\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    // Parse the header\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        int var_size;\n\n        while (s->is_multipart && s->current_part < s->selected_part &&\n               bytestream2_get_bytes_left(gb) > 0) {\n            if (bytestream2_peek_byte(gb)) {\n                skip_header_chunk(s);\n            } else {\n                bytestream2_skip(gb, 1);\n                if (!bytestream2_peek_byte(gb))\n                    break;\n            }\n            bytestream2_skip(gb, 1);\n            s->current_part++;\n        }\n\n        if (!bytestream2_peek_byte(gb)) {\n            if (!s->is_multipart)\n                break;\n            bytestream2_skip(gb, 1);\n            if (s->current_part == s->selected_part) {\n                while (bytestream2_get_bytes_left(gb) > 0) {\n                    if (bytestream2_peek_byte(gb)) {\n                        skip_header_chunk(s);\n                    } else {\n                        bytestream2_skip(gb, 1);\n                        if (!bytestream2_peek_byte(gb))\n                            break;\n                    }\n                }\n            }\n            if (!bytestream2_peek_byte(gb))\n                break;\n            s->current_part++;\n        }\n\n        if ((var_size = check_header_variable(s, \"channels\",\n                                              \"chlist\", 38)) >= 0) {\n            GetByteContext ch_gb;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            bytestream2_init(&ch_gb, gb->buffer, var_size);\n\n            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {\n                EXRChannel *channel;\n                enum ExrPixelType current_pixel_type;\n                int channel_index = -1;\n                int xsub, ysub;\n\n                if (strcmp(s->layer, \"\") != 0) {\n                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {\n                        layer_match = 1;\n                        av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel match layer : %s.\\n\", ch_gb.buffer);\n                        ch_gb.buffer += strlen(s->layer);\n                        if (*ch_gb.buffer == '.')\n                            ch_gb.buffer++;         /* skip dot if not given */\n                    } else {\n                        layer_match = 0;\n                        av_log(s->avctx, AV_LOG_INFO,\n                               \"Channel doesn't match layer : %s.\\n\", ch_gb.buffer);\n                    }\n                } else {\n                    layer_match = 1;\n                }\n\n                if (layer_match) { /* only search channel if the layer match is valid */\n                    if (!av_strcasecmp(ch_gb.buffer, \"R\") ||\n                        !av_strcasecmp(ch_gb.buffer, \"X\") ||\n                        !av_strcasecmp(ch_gb.buffer, \"U\")) {\n                        channel_index = 0;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"G\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"V\")) {\n                        channel_index = 1;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"Y\")) {\n                        channel_index = 1;\n                        s->is_luma = 1;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"B\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"Z\") ||\n                               !av_strcasecmp(ch_gb.buffer, \"W\")) {\n                        channel_index = 2;\n                        s->is_luma = 0;\n                    } else if (!av_strcasecmp(ch_gb.buffer, \"A\")) {\n                        channel_index = 3;\n                    } else {\n                        av_log(s->avctx, AV_LOG_WARNING,\n                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer);\n                    }\n                }\n\n                /* skip until you get a 0 */\n                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&\n                       bytestream2_get_byte(&ch_gb))\n                    continue;\n\n                if (bytestream2_get_bytes_left(&ch_gb) < 4) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n\n                current_pixel_type = bytestream2_get_le32(&ch_gb);\n                if (current_pixel_type >= EXR_UNKNOWN) {\n                    avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",\n                                                  current_pixel_type);\n                    ret = AVERROR_PATCHWELCOME;\n                    goto fail;\n                }\n\n                bytestream2_skip(&ch_gb, 4);\n                xsub = bytestream2_get_le32(&ch_gb);\n                ysub = bytestream2_get_le32(&ch_gb);\n\n                if (xsub != 1 || ysub != 1) {\n                    avpriv_report_missing_feature(s->avctx,\n                                                  \"Subsampling %dx%d\",\n                                                  xsub, ysub);\n                    ret = AVERROR_PATCHWELCOME;\n                    goto fail;\n                }\n\n                if (channel_index >= 0 && s->channel_offsets[channel_index] == -1) { /* channel has not been previously assigned */\n                    if (s->pixel_type != EXR_UNKNOWN &&\n                        s->pixel_type != current_pixel_type) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"RGB channels not of the same depth.\\n\");\n                        ret = AVERROR_INVALIDDATA;\n                        goto fail;\n                    }\n                    s->pixel_type                     = current_pixel_type;\n                    s->channel_offsets[channel_index] = s->current_channel_offset;\n                } else if (channel_index >= 0) {\n                    av_log(s->avctx, AV_LOG_WARNING,\n                            \"Multiple channels with index %d.\\n\", channel_index);\n                    if (++dup_channels > 10) {\n                        ret = AVERROR_INVALIDDATA;\n                        goto fail;\n                    }\n                }\n\n                s->channels = av_realloc(s->channels,\n                                         ++s->nb_channels * sizeof(EXRChannel));\n                if (!s->channels) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                channel             = &s->channels[s->nb_channels - 1];\n                channel->pixel_type = current_pixel_type;\n                channel->xsub       = xsub;\n                channel->ysub       = ysub;\n\n                if (current_pixel_type == EXR_HALF) {\n                    s->current_channel_offset += 2;\n                } else {/* Float or UINT32 */\n                    s->current_channel_offset += 4;\n                }\n            }\n\n            /* Check if all channels are set with an offset or if the channels\n             * are causing an overflow  */\n            if (!s->is_luma) {/* if we expected to have at least 3 channels */\n                if (FFMIN3(s->channel_offsets[0],\n                           s->channel_offsets[1],\n                           s->channel_offsets[2]) < 0) {\n                    if (s->channel_offsets[0] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\");\n                    if (s->channel_offsets[1] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\");\n                    if (s->channel_offsets[2] < 0)\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n            }\n\n            // skip one last byte and update main gb\n            gb->buffer = ch_gb.buffer + 1;\n            continue;\n        } else if ((var_size = check_header_variable(s, \"dataWindow\", \"box2i\",\n                                                     31)) >= 0) {\n            int xmin, ymin, xmax, ymax;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            xmin   = bytestream2_get_le32(gb);\n            ymin   = bytestream2_get_le32(gb);\n            xmax   = bytestream2_get_le32(gb);\n            ymax   = bytestream2_get_le32(gb);\n\n            if (xmin > xmax || ymin > ymax ||\n                ymax == INT_MAX || xmax == INT_MAX ||\n                (unsigned)xmax - xmin >= INT_MAX ||\n                (unsigned)ymax - ymin >= INT_MAX) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            s->xmin = xmin;\n            s->xmax = xmax;\n            s->ymin = ymin;\n            s->ymax = ymax;\n            s->xdelta = (s->xmax - s->xmin) + 1;\n            s->ydelta = (s->ymax - s->ymin) + 1;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"displayWindow\",\n                                                     \"box2i\", 34)) >= 0) {\n            int32_t sx, sy, dx, dy;\n\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            sx = bytestream2_get_le32(gb);\n            sy = bytestream2_get_le32(gb);\n            dx = bytestream2_get_le32(gb);\n            dy = bytestream2_get_le32(gb);\n\n            s->w = dx - sx + 1;\n            s->h = dy - sy + 1;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"lineOrder\",\n                                                     \"lineOrder\", 25)) >= 0) {\n            int line_order;\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            line_order = bytestream2_get_byte(gb);\n            av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order);\n            if (line_order > 2) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"pixelAspectRatio\",\n                                                     \"float\", 31)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            s->sar = bytestream2_get_le32(gb);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"compression\",\n                                                     \"compression\", 29)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            if (s->compression == EXR_UNKN)\n                s->compression = bytestream2_get_byte(gb);\n            else {\n                bytestream2_skip(gb, 1);\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found more than one compression attribute.\\n\");\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"tiles\",\n                                                     \"tiledesc\", 22)) >= 0) {\n            char tileLevel;\n\n            if (!s->is_tile)\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\");\n\n            s->tile_attr.xSize = bytestream2_get_le32(gb);\n            s->tile_attr.ySize = bytestream2_get_le32(gb);\n\n            tileLevel = bytestream2_get_byte(gb);\n            s->tile_attr.level_mode = tileLevel & 0x0f;\n            s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;\n\n            if (s->tile_attr.level_mode >= EXR_TILE_LEVEL_UNKNOWN) {\n                avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",\n                                              s->tile_attr.level_mode);\n                ret = AVERROR_PATCHWELCOME;\n                goto fail;\n            }\n\n            if (s->tile_attr.level_round >= EXR_TILE_ROUND_UNKNOWN) {\n                avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",\n                                              s->tile_attr.level_round);\n                ret = AVERROR_PATCHWELCOME;\n                goto fail;\n            }\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"writer\",\n                                                     \"string\", 1)) >= 0) {\n            uint8_t key[256] = { 0 };\n\n            bytestream2_get_buffer(gb, key, FFMIN(sizeof(key) - 1, var_size));\n            av_dict_set(&metadata, \"writer\", key, 0);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"framesPerSecond\",\n                                                     \"rational\", 33)) >= 0) {\n            if (!var_size) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            s->avctx->framerate.num = bytestream2_get_le32(gb);\n            s->avctx->framerate.den = bytestream2_get_le32(gb);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"chunkCount\",\n                                                     \"int\", 23)) >= 0) {\n\n            s->chunk_count = bytestream2_get_le32(gb);\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"type\",\n                                                     \"string\", 16)) >= 0) {\n            uint8_t key[256] = { 0 };\n\n            bytestream2_get_buffer(gb, key, FFMIN(sizeof(key) - 1, var_size));\n            if (strncmp(\"scanlineimage\", key, var_size) &&\n                strncmp(\"tiledimage\", key, var_size))\n                return AVERROR_PATCHWELCOME;\n\n            continue;\n        } else if ((var_size = check_header_variable(s, \"preview\",\n                                                     \"preview\", 16)) >= 0) {\n            uint32_t pw = bytestream2_get_le32(gb);\n            uint32_t ph = bytestream2_get_le32(gb);\n            int64_t psize = 4LL * pw * ph;\n\n            if (psize >= bytestream2_get_bytes_left(gb))\n                return AVERROR_INVALIDDATA;\n\n            bytestream2_skip(gb, psize);\n\n            continue;\n        }\n\n        // Check if there are enough bytes for a header\n        if (bytestream2_get_bytes_left(gb) <= 9) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        // Process unknown variables\n        {\n            uint8_t name[256] = { 0 };\n            uint8_t type[256] = { 0 };\n            uint8_t value[256] = { 0 };\n            int i = 0, size;\n\n            while (bytestream2_get_bytes_left(gb) > 0 &&\n                   bytestream2_peek_byte(gb) && i < 255) {\n                name[i++] = bytestream2_get_byte(gb);\n            }\n\n            bytestream2_skip(gb, 1);\n            i = 0;\n            while (bytestream2_get_bytes_left(gb) > 0 &&\n                   bytestream2_peek_byte(gb) && i < 255) {\n                type[i++] = bytestream2_get_byte(gb);\n            }\n            bytestream2_skip(gb, 1);\n            size = bytestream2_get_le32(gb);\n\n            bytestream2_get_buffer(gb, value, FFMIN(sizeof(value) - 1, size));\n            if (!strcmp(type, \"string\"))\n                av_dict_set(&metadata, name, value, 0);\n        }\n    }\n\n    if (s->compression == EXR_UNKN) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (s->is_tile) {\n        if (s->tile_attr.xSize < 1 || s->tile_attr.ySize < 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n\n    if (bytestream2_get_bytes_left(gb) <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    frame->metadata = metadata;\n\n    // aaand we are done\n    bytestream2_skip(gb, 1);\n    return 0;\nfail:\n    av_dict_free(&metadata);\n    return ret;\n}\n\nstatic int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    EXRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    uint8_t *ptr;\n\n    int i, y, ret, ymax;\n    int planes;\n    int out_line_size;\n    int nb_blocks;   /* nb scanline or nb tile */\n    uint64_t start_offset_table;\n    uint64_t start_next_scanline;\n    PutByteContext offset_table_writer;\n\n    bytestream2_init(gb, avpkt->data, avpkt->size);\n\n    if ((ret = decode_header(s, picture)) < 0)\n        return ret;\n\n    if ((s->compression == EXR_DWAA || s->compression == EXR_DWAB) &&\n        s->pixel_type == EXR_HALF) {\n        s->current_channel_offset *= 2;\n        for (int i = 0; i < 4; i++)\n            s->channel_offsets[i] *= 2;\n    }\n\n    switch (s->pixel_type) {\n    case EXR_FLOAT:\n    case EXR_HALF:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            } else {\n                /* todo: change this when a floating point pixel format with luma with alpha is implemented */\n                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;\n            }\n        }\n        break;\n    case EXR_UINT:\n        if (s->channel_offsets[3] >= 0) {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_YA16;\n            }\n        } else {\n            if (!s->is_luma) {\n                avctx->pix_fmt = AV_PIX_FMT_RGB48;\n            } else {\n                avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n            }\n        }\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Missing channel list.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)\n        avctx->color_trc = s->apply_trc_type;\n\n    switch (s->compression) {\n    case EXR_RAW:\n    case EXR_RLE:\n    case EXR_ZIP1:\n        s->scan_lines_per_block = 1;\n        break;\n    case EXR_PXR24:\n    case EXR_ZIP16:\n        s->scan_lines_per_block = 16;\n        break;\n    case EXR_PIZ:\n    case EXR_B44:\n    case EXR_B44A:\n    case EXR_DWAA:\n        s->scan_lines_per_block = 32;\n        break;\n    case EXR_DWAB:\n        s->scan_lines_per_block = 256;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* Verify the xmin, xmax, ymin and ymax before setting the actual image size.\n     * It's possible for the data window can larger or outside the display window */\n    if (s->xmin > s->xmax  || s->ymin > s->ymax ||\n        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong or missing size information.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)\n        return ret;\n\n    ff_set_sar(s->avctx, av_d2q(av_int2float(s->sar), 255));\n\n    s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!s->desc)\n        return AVERROR_INVALIDDATA;\n\n    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {\n        planes           = s->desc->nb_components;\n        out_line_size    = avctx->width * 4;\n    } else {\n        planes           = 1;\n        out_line_size    = avctx->width * 2 * s->desc->nb_components;\n    }\n\n    if (s->is_tile) {\n        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *\n        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);\n    } else { /* scanline */\n        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /\n        s->scan_lines_per_block;\n    }\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    if (bytestream2_get_bytes_left(gb)/8 < nb_blocks)\n        return AVERROR_INVALIDDATA;\n\n    // check offset table and recreate it if need\n    if (!s->is_tile && bytestream2_peek_le64(gb) == 0) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");\n\n        start_offset_table = bytestream2_tell(gb);\n        start_next_scanline = start_offset_table + nb_blocks * 8;\n        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);\n\n        for (y = 0; y < nb_blocks; y++) {\n            /* write offset of prev scanline in offset table */\n            bytestream2_put_le64(&offset_table_writer, start_next_scanline);\n\n            /* get len of next scanline */\n            bytestream2_seek(gb, start_next_scanline + 4, SEEK_SET);/* skip line number */\n            start_next_scanline += (bytestream2_get_le32(gb) + 8);\n        }\n        bytestream2_seek(gb, start_offset_table, SEEK_SET);\n    }\n\n    // save pointer we are going to use in decode_block\n    s->buf      = avpkt->data;\n    s->buf_size = avpkt->size;\n\n    // Zero out the start if ymin is not 0\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i];\n        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    if (ymax < avctx->height)\n        for (i = 0; i < planes; i++) {\n            ptr = picture->data[i] + (ymax * picture->linesize[i]);\n            for (y = ymax; y < avctx->height; y++) {\n                memset(ptr, 0, out_line_size);\n                ptr += picture->linesize[i];\n            }\n        }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    EXRContext *s = avctx->priv_data;\n    uint32_t i;\n    union av_intfloat32 t;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = NULL;\n\n    half2float_table(s->mantissatable, s->exponenttable, s->offsettable);\n\n    s->avctx              = avctx;\n\n    ff_exrdsp_init(&s->dsp);\n\n#if HAVE_BIGENDIAN\n    ff_bswapdsp_init(&s->bbdsp);\n#endif\n\n    trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    if (trc_func) {\n        for (i = 0; i < 65536; ++i) {\n            t.i = half2float(i, s->mantissatable, s->exponenttable, s->offsettable);\n            t.f = trc_func(t.f);\n            s->gamma_table[i] = t;\n        }\n    } else {\n        if (one_gamma > 0.9999f && one_gamma < 1.0001f) {\n            for (i = 0; i < 65536; ++i) {\n                s->gamma_table[i].i = half2float(i, s->mantissatable, s->exponenttable, s->offsettable);\n            }\n        } else {\n            for (i = 0; i < 65536; ++i) {\n                t.i = half2float(i, s->mantissatable, s->exponenttable, s->offsettable);\n                /* If negative value we reuse half value */\n                if (t.f <= 0.0f) {\n                    s->gamma_table[i] = t;\n                } else {\n                    t.f = powf(t.f, one_gamma);\n                    s->gamma_table[i] = t;\n                }\n            }\n        }\n    }\n\n    // allocate thread data, used for non EXR_RAW compression types\n    s->thread_data = av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData));\n    if (!s->thread_data)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    EXRContext *s = avctx->priv_data;\n    int i;\n    for (i = 0; i < avctx->thread_count; i++) {\n        EXRThreadData *td = &s->thread_data[i];\n        av_freep(&td->uncompressed_data);\n        av_freep(&td->tmp);\n        av_freep(&td->bitmap);\n        av_freep(&td->lut);\n        av_freep(&td->he);\n        av_freep(&td->freq);\n        av_freep(&td->ac_data);\n        av_freep(&td->dc_data);\n        av_freep(&td->rle_data);\n        av_freep(&td->rle_raw_data);\n        ff_free_vlc(&td->vlc);\n    }\n\n    av_freep(&s->thread_data);\n    av_freep(&s->channels);\n\n    return 0;\n}\n\n#define OFFSET(x) offsetof(EXRContext, x)\n#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption options[] = {\n    { \"layer\", \"Set the decoding layer\", OFFSET(layer),\n        AV_OPT_TYPE_STRING, { .str = \"\" }, 0, 0, VD },\n    { \"part\",  \"Set the decoding part\", OFFSET(selected_part),\n        AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VD },\n    { \"gamma\", \"Set the float gamma value when decoding\", OFFSET(gamma),\n        AV_OPT_TYPE_FLOAT, { .dbl = 1.0f }, 0.001, FLT_MAX, VD },\n\n    // XXX: Note the abuse of the enum using AVCOL_TRC_UNSPECIFIED to subsume the existing gamma option\n    { \"apply_trc\", \"color transfer characteristics to apply to EXR linear input\", OFFSET(apply_trc_type),\n        AV_OPT_TYPE_INT, {.i64 = AVCOL_TRC_UNSPECIFIED }, 1, AVCOL_TRC_NB-1, VD, \"apply_trc_type\"},\n    { \"bt709\",        \"BT.709\",           0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT709 },        INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma\",        \"gamma\",            0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma22\",      \"BT.470 M\",         0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA22 },      INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"gamma28\",      \"BT.470 BG\",        0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA28 },      INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte170m\",    \"SMPTE 170 M\",      0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE170M },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte240m\",    \"SMPTE 240 M\",      0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE240M },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"linear\",       \"Linear\",           0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LINEAR },       INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"log\",          \"Log\",              0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG },          INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"log_sqrt\",     \"Log square root\",  0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT },     INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"iec61966_2_4\", \"IEC 61966-2-4\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt1361\",       \"BT.1361\",          0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG },   INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"iec61966_2_1\", \"IEC 61966-2-1\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt2020_10bit\", \"BT.2020 - 10 bit\", 0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"bt2020_12bit\", \"BT.2020 - 12 bit\", 0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 },    INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte2084\",    \"SMPTE ST 2084\",    0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST2084 },  INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n    { \"smpte428_1\",   \"SMPTE ST 428-1\",   0,\n        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST428_1 }, INT_MIN, INT_MAX, VD, \"apply_trc_type\"},\n\n    { NULL },\n};\n\nstatic const AVClass exr_class = {\n    .class_name = \"EXR\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nconst AVCodec ff_exr_decoder = {\n    .name             = \"exr\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"OpenEXR image\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_EXR,\n    .priv_data_size   = sizeof(EXRContext),\n    .init             = decode_init,\n    .close            = decode_end,\n    .decode           = decode_frame,\n    .capabilities     = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |\n                        AV_CODEC_CAP_SLICE_THREADS,\n    .priv_class       = &exr_class,\n};\n"], "filenames": ["libavcodec/exr.c"], "buggy_code_start_loc": [1062], "buggy_code_end_loc": [1067], "fixing_code_start_loc": [1062], "fixing_code_end_loc": [1067], "type": "CWE-129", "message": "dwa_uncompress in libavcodec/exr.c in FFmpeg 4.4 allows an out-of-bounds array access because dc_count is not strictly checked.", "other": {"cve": {"id": "CVE-2021-33815", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-03T17:15:15.073", "lastModified": "2021-06-07T16:04:14.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "dwa_uncompress in libavcodec/exr.c in FFmpeg 4.4 allows an out-of-bounds array access because dc_count is not strictly checked."}, {"lang": "es", "value": "Una funci\u00f3n dwa_uncompress en el archivo libavcodec/exr.c en FFmpeg versi\u00f3n 4.4, permite un acceso a una matriz fuera de l\u00edmites porque la funci\u00f3n dc_count no es estrictamente comprobada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-129"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "0ADCFDB3-718B-4D16-BDD0-3CF8F1272E5E"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777"}}