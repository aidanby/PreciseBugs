{"buggy_code": ["package cloudsync.connector;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclEntry.Builder;\nimport java.nio.file.attribute.AclEntryFlag;\nimport java.nio.file.attribute.AclEntryPermission;\nimport java.nio.file.attribute.AclEntryType;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.DosFileAttributes;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.GroupPrincipal;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.attribute.UserPrincipalLookupService;\nimport java.nio.file.attribute.UserPrincipalNotFoundException;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport cloudsync.exceptions.FileIOException;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\n\nimport cloudsync.exceptions.CloudsyncException;\nimport cloudsync.helper.CmdOptions;\nimport cloudsync.helper.Handler;\nimport cloudsync.helper.Helper;\nimport cloudsync.model.options.ExistingType;\nimport cloudsync.model.Item;\nimport cloudsync.model.ItemType;\nimport cloudsync.model.options.FollowLinkType;\nimport cloudsync.model.options.PermissionType;\nimport cloudsync.model.LocalStreamData;\nimport cloudsync.model.RemoteStreamData;\n\npublic class LocalFilesystemConnector\n{\n\tprivate static final Logger\t\t\t\t\t\t\tLOGGER\t\t\t= Logger.getLogger(LocalFilesystemConnector.class.getName());\n\n\tprivate static final int\t\t\t\t\t\t\tBUFFER_SIZE\t\t= 1 << 16;\n\tprivate static final DecimalFormat\t\t\t\t\tdf\t\t\t\t= new DecimalFormat(\"00\");\n\n\tprivate static final Map<Integer, PosixFilePermission>\ttoPermMapping\t= new HashMap<>();\n\tstatic\n\t{\n\t\ttoPermMapping.put(0001, PosixFilePermission.OTHERS_EXECUTE);\n\t\ttoPermMapping.put(0002, PosixFilePermission.OTHERS_WRITE);\n\t\ttoPermMapping.put(0004, PosixFilePermission.OTHERS_READ);\n\t\ttoPermMapping.put(0010, PosixFilePermission.GROUP_EXECUTE);\n\t\ttoPermMapping.put(0020, PosixFilePermission.GROUP_WRITE);\n\t\ttoPermMapping.put(0040, PosixFilePermission.GROUP_READ);\n\t\ttoPermMapping.put(0100, PosixFilePermission.OWNER_EXECUTE);\n\t\ttoPermMapping.put(0200, PosixFilePermission.OWNER_WRITE);\n\t\ttoPermMapping.put(0400, PosixFilePermission.OWNER_READ);\n\t}\n\n\tprivate static final Map<PosixFilePermission, Integer>\tfromPermMapping\t= new HashMap<>();\n\n\tprivate static final Map<String, Boolean>\t\t\tprincipal_state\t= new HashMap<>();\n\n\tprivate final String\t\t\t\t\t\t\t\tlocalPath;\n\tprivate final boolean\t\t\t\t\t\t\t\tshowProgress;\n\n\tpublic LocalFilesystemConnector(final CmdOptions options)\n\t{\n\t\tString path = options.getPath();\n\t\tshowProgress = options.showProgress();\n\n\t\tif (path != null)\n\t\t{\n\t\t\tif (path.startsWith(Item.SEPARATOR))\n\t\t\t{\n\t\t\t\tlocalPath = Item.SEPARATOR + Helper.trim(path, Item.SEPARATOR);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocalPath = Helper.trim(path, Item.SEPARATOR);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlocalPath = \"\";\n\t\t}\n\n\t\tfor (final Integer key : toPermMapping.keySet())\n\t\t{\n\t\t\tfinal PosixFilePermission perm = toPermMapping.get(key);\n\t\t\tfromPermMapping.put(perm, key);\n\t\t}\n\t}\n\n\tpublic void prepareUpload(final Handler handler, final Item item, final ExistingType duplicateFlag)\n\t{\n\t\tif (!duplicateFlag.equals(ExistingType.RENAME))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tString path = localPath + Item.SEPARATOR + item.getPath();\n\n\t\tif (exists(Paths.get(path)))\n\t\t{\n\t\t\tint i = 0;\n\t\t\twhile (exists(Paths.get(path + \".\" + i)))\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tpath += \".\" + i;\n\n\t\t\titem.setName(FilenameUtils.getName(path));\n\t\t}\n\t}\n\n\tpublic void prepareParent(Handler handler, Item item) throws CloudsyncException\n\t{\n\t\tif (item.getParent() != null)\n\t\t{\n\t\t\tItem parentItem = item.getParent();\n\n\t\t\tfinal Path parentPath = Paths.get(localPath + Item.SEPARATOR + parentItem.getPath());\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tFiles.createDirectories(parentPath);\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new CloudsyncException(\"Can't create \" + parentItem.getTypeName() + \" '\" + parentItem.getPath() + \"'\", e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void upload(final Handler handler, final Item item, final ExistingType duplicateFlag, final PermissionType permissionType)\n\t\t\tthrows CloudsyncException\n\t{\n\t\tfinal String _path = localPath + Item.SEPARATOR + item.getPath();\n\n\t\tfinal Path path = Paths.get(_path);\n\n\t\tif (exists(path))\n\t\t{\n\t\t\tif (duplicateFlag.equals(ExistingType.SKIP))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!duplicateFlag.equals(ExistingType.UPDATE))\n\t\t\t{\n\t\t\t\tthrow new CloudsyncException(\"Item '\" + item.getPath() + \"' already exists. Try to specify another '--duplicate' behavior.\");\n\t\t\t}\n\n\t\t\tif ((!item.isType(ItemType.FOLDER) || !isDir(path)))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tFiles.delete(path);\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CloudsyncException(\"Can't clear \" + item.getTypeName() + \" on '\" + item.getPath() + \"'\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (item.isType(ItemType.FOLDER))\n\t\t{\n\t\t\tif (!exists(path))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tFiles.createDirectory(path);\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CloudsyncException(\"Can't create \" + item.getTypeName() + \" '\" + item.getPath() + \"'\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (item.getParent() != null)\n\t\t\t{\n\t\t\t\tfinal Path parentPath = Paths.get(localPath + Item.SEPARATOR + item.getParent().getPath());\n\n\t\t\t\tif (!isDir(parentPath))\n\t\t\t\t{\n\n\t\t\t\t\tthrow new CloudsyncException(\"Parent directory of \" + item.getTypeName() + \" '\" + item.getPath() + \"' is missing.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.isType(ItemType.LINK))\n\t\t\t{\n\t\t\t\tRemoteStreamData remoteStreamData = null;\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tremoteStreamData = handler.getRemoteProcessedBinary(item);\n\n\t\t\t\t\tfinal String link = IOUtils.toString( remoteStreamData.getDecryptedStream(), Charset.defaultCharset());\n\t\t\t\t\tFiles.createSymbolicLink(path, Paths.get(link));\n\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CloudsyncException(\"Unexpected error during local update of \" + item.getTypeName() + \" '\" + item.getPath() + \"'\", e);\n\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (remoteStreamData != null) remoteStreamData.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (item.isType(ItemType.FILE))\n\t\t\t{\n\t\t\t\tRemoteStreamData remoteStreamData = null;\n\t\t\t\tOutputStream outputStream = null;\n\t\t\t\tInputStream localChecksumStream = null;\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tremoteStreamData = handler.getRemoteProcessedBinary(item);\n\t\t\t\t\toutputStream = Files.newOutputStream(path);\n\n\t\t\t\t\tfinal long length = item.getFilesize();\n\t\t\t\t\tdouble current = 0;\n\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\t\t\tint len;\n\n\t\t\t\t\t// 2 MB\n\t\t\t\t\tif (showProgress && length > 2097152)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tlong lastTime = System.currentTimeMillis();\n\t\t\t\t\t\tdouble lastBytes = 0;\n\t\t\t\t\t\tString currentSpeed = \"\";\n\n\t\t\t\t\t\twhile ((len = remoteStreamData.getDecryptedStream().read(buffer)) != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toutputStream.write(buffer, 0, len);\n\t\t\t\t\t\t\tcurrent += len;\n\n\t\t\t\t\t\t\tlong currentTime = System.currentTimeMillis();\n\n\t\t\t\t\t\t\tString msg = \"\\r  \" + df.format(Math.ceil(current * 100 / length)) + \"% (\" + convertToKB(current) + \" of \" + convertToKB(length)\n\t\t\t\t\t\t\t\t\t+ \" kb) restored\";\n\t\t\t\t\t\t\tdouble diffTime = ((currentTime - lastTime) / 1000.0);\n\n\t\t\t\t\t\t\tif (diffTime > 5.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlong speed = convertToKB((current - lastBytes) / diffTime);\n\t\t\t\t\t\t\t\tcurrentSpeed = \" - \" + speed + \" kb/s\";\n\n\t\t\t\t\t\t\t\tlastTime = currentTime;\n\t\t\t\t\t\t\t\tlastBytes = current;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOGGER.log(Level.FINEST, msg + currentSpeed, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile ((len = remoteStreamData.getDecryptedStream().read(buffer)) != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toutputStream.write(buffer, 0, len);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlocalChecksumStream = Files.newInputStream(path);\n\n\t\t\t\t\tif (!createChecksum(localChecksumStream).equals(item.getChecksum()))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new CloudsyncException(\"restored filechecksum differs from the original filechecksum\");\n\t\t\t\t\t}\n\t\t\t\t\tif (item.getFilesize() != Files.size(path))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new CloudsyncException(\"restored filesize differs from the original filesize\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CloudsyncException(\"Unexpected error during local update of \" + item.getTypeName() + \" '\" + item.getPath() + \"'\", e);\n\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (remoteStreamData != null) remoteStreamData.close();\n\t\t\t\t\tif (outputStream != null) IOUtils.closeQuietly(outputStream);\n\t\t\t\t\tif (localChecksumStream != null) IOUtils.closeQuietly(localChecksumStream);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new CloudsyncException(\"Unsupported type \" + item.getTypeName() + \"' on '\" + item.getPath() + \"'\");\n\t\t\t}\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tif (item.isType(ItemType.LINK))\n\t\t\t{\n\t\t\t\t// Files.setLastModifiedTime(path, item.getModifyTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFiles.getFileAttributeView(path, BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS).setTimes(item.getModifyTime(), item.getAccessTime(),\n\t\t\t\t\t\titem.getCreationTime());\n\t\t\t}\n\t\t}\n\t\tcatch (final IOException e)\n\t\t{\n\t\t\tthrow new CloudsyncException(\"Can't set create, modify and access time of \" + item.getTypeName() + \" '\" + item.getPath() + \"'\", e);\n\t\t}\n\n\t\tif (permissionType.equals(PermissionType.SET) || permissionType.equals(PermissionType.TRY))\n\t\t{\n\t\t\tfinal UserPrincipalLookupService lookupService = FileSystems.getDefault().getUserPrincipalLookupService();\n\n\t\t\tMap<String, String[]> attributes = item.getAttributes();\n\t\t\tfor (String type : attributes.keySet())\n\t\t\t{\n\t\t\t\tGroupPrincipal group;\n\t\t\t\tUserPrincipal principal;\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tString[] values = attributes.get(type);\n\n\t\t\t\t\tswitch ( type )\n\t\t\t\t\t{\n\t\t\t\t\t\tcase Item.ATTRIBUTE_POSIX:\n\t\t\t\t\t\t\tPosixFileAttributeView posixView = Files.getFileAttributeView(path, PosixFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\t\t\tif (posixView != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgroup = lookupService.lookupPrincipalByGroupName(values[0]);\n\t\t\t\t\t\t\t\tposixView.setGroup(group);\n\t\t\t\t\t\t\t\tprincipal = lookupService.lookupPrincipalByName(values[1]);\n\t\t\t\t\t\t\t\tposixView.setOwner(principal);\n\t\t\t\t\t\t\t\tif (values.length > 2) posixView.setPermissions(toPermissions(Integer.parseInt(values[2])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString msg = \"Can't restore 'posix' permissions on '\" + item.getPath() + \"'. They are not supported.\";\n\t\t\t\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Item.ATTRIBUTE_DOS:\n\t\t\t\t\t\t\tDosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\t\t\tif (dosView != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdosView.setArchive(Boolean.parseBoolean(values[0]));\n\t\t\t\t\t\t\t\tdosView.setHidden(Boolean.parseBoolean(values[1]));\n\t\t\t\t\t\t\t\tdosView.setReadOnly(Boolean.parseBoolean(values[2]));\n\t\t\t\t\t\t\t\tdosView.setSystem(Boolean.parseBoolean(values[3]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString msg = \"Can't restore 'dos' permissions on '\" + item.getPath() + \"'. They are not supported.\";\n\t\t\t\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Item.ATTRIBUTE_ACL:\n\t\t\t\t\t\t\tAclFileAttributeView aclView = Files.getFileAttributeView(path, AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\t\t\tif (aclView != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tList<AclEntry> acls = aclView.getAcl();\n\t\t\t\t\t\t\t\tfor (int i = 0; i < values.length; i = i + 4)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tBuilder aclEntryBuilder = AclEntry.newBuilder();\n\n\t\t\t\t\t\t\t\t\taclEntryBuilder.setType(AclEntryType.valueOf(values[i]));\n\t\t\t\t\t\t\t\t\taclEntryBuilder.setPrincipal(lookupService.lookupPrincipalByName(values[i + 1]));\n\n\t\t\t\t\t\t\t\t\tSet<AclEntryFlag> flags = new HashSet<>();\n\t\t\t\t\t\t\t\t\tfor (String flag : StringUtils.splitPreserveAllTokens(values[i + 2], \",\"))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tflags.add(AclEntryFlag.valueOf(flag));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (flags.size() > 0) aclEntryBuilder.setFlags(flags);\n\n\t\t\t\t\t\t\t\t\tSet<AclEntryPermission> aclPermissions = new HashSet<>();\n\t\t\t\t\t\t\t\t\tfor (String flag : StringUtils.splitPreserveAllTokens(values[i + 3], \",\"))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\taclPermissions.add(AclEntryPermission.valueOf(flag));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (aclPermissions.size() > 0) aclEntryBuilder.setPermissions(aclPermissions);\n\t\t\t\t\t\t\t\t\tacls.add(aclEntryBuilder.build());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taclView.setAcl(acls);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString msg = \"Can't restore 'acl' permissions on '\" + item.getPath() + \"'. They are not supported.\";\n\t\t\t\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Item.ATTRIBUTE_OWNER:\n\t\t\t\t\t\t\tFileOwnerAttributeView ownerView = Files.getFileAttributeView(path, FileOwnerAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\t\t\tif (ownerView != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprincipal = lookupService.lookupPrincipalByName(values[0]);\n\t\t\t\t\t\t\t\townerView.setOwner(principal);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString msg = \"Can't restore 'owner' permissions on '\" + item.getPath() + \"'. They are not supported.\";\n\t\t\t\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (final UserPrincipalNotFoundException e)\n\t\t\t\t{\n\t\t\t\t\tif (!LocalFilesystemConnector.principal_state.containsKey(e.getName()))\n\t\t\t\t\t{\n\t\t\t\t\t\tLocalFilesystemConnector.principal_state.put(e.getName(), true);\n\t\t\t\t\t\tLOGGER.log(Level.WARNING, \"principal with name '\" + e.getName() + \"' not exists\");\n\t\t\t\t\t}\n\t\t\t\t\tString msg = \"Principal '\" + e.getName() + \"' on '\" + item.getPath() + \"' not found.\";\n\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tString msg = \"Can't set permissions of '\" + item.getPath() + \"'.\";\n\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic File[] readFolder(final Item item) \n\t\n\tthrows CloudsyncException\n\t{\n\t\tfinal String currentPath = localPath + (StringUtils.isEmpty(item.getPath()) ? \"\" : Item.SEPARATOR + item.getPath());\n\n\t\tfinal File folder = new File(currentPath);\n\n\t\tif (!Files.exists(folder.toPath(), LinkOption.NOFOLLOW_LINKS))\n\t\t{\n\t\t\tLOGGER.log(Level.WARNING, \"skip '\" + currentPath + \"'. does not exists anymore.\");\n\t\t\treturn new File[] {};\n\t\t}\n\n\t\tFile[] files = folder.listFiles();\n\t\t\n\t\tif( files == null )\n\t\t{\n            throw new CloudsyncException(\"Path '\" + currentPath + \"' is not readable. Check your permissions\");\n\t\t}\n\t\t\n\t\treturn files;\n\t}\n\n\tpublic Item getItem(File file, final FollowLinkType followlinks, List<String> followedLinkPaths ) throws FileIOException\n\t{\n\t\ttry\n\t\t{\n\t\t\tPath path = file.toPath();\n\n\t\t\tItemType type;\n\t\t\t\n\t\t\tif (Files.isSymbolicLink(path))\n\t\t\t{\n\t\t\t\tString target;\n\t\t\t\ttarget = Files.readSymbolicLink(path).toString();\n\t\t\t\tfinal String firstChar = target.substring(0, 1);\n\t\t\t\tif (!firstChar.equals(Item.SEPARATOR))\n\t\t\t\t{\n\t\t\t\t\tif (!firstChar.equals(\".\"))\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget = \".\" + Item.SEPARATOR + target;\n\t\t\t\t\t}\n\t\t\t\t\ttarget = path.toString() + Item.SEPARATOR + target;\n\t\t\t\t}\n\t\t\t\ttarget = Paths.get(target).toFile().getCanonicalPath();\n\n                if (!followlinks.equals(FollowLinkType.NONE) && followlinks.equals(FollowLinkType.EXTERNAL) && !target.startsWith(localPath + Item.SEPARATOR) )\n\t\t\t\t{\n                    boolean foundLink = false;\n                    for( String followedLinkPath: followedLinkPaths )\n                    {\n                        // 1. if the link target is a child of a already followed link, then there is no need to follow again\n                        // 2. and the target should not be equal with a already followed link. Otherwise we are requesting the same item again. So we have to follow.\n                        if( target.startsWith(followedLinkPath) && !target.equals(followedLinkPath) )\n                        {\n                            foundLink = true;\n                            break;\n                        }\n                    }\n                    \n                    if( !foundLink )\n                    {\n                        final Path targetPath = Paths.get(target);\n                        if (Files.exists(targetPath, LinkOption.NOFOLLOW_LINKS))\n                        {\n                            path = targetPath;\n                            followedLinkPaths.add(target);\n                        }\n                    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBasicFileAttributes basic_attr = Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\tfinal Long filesize = basic_attr.size();\n\t\t\tfinal FileTime creationTime = basic_attr.creationTime();\n\t\t\tfinal FileTime modifyTime = basic_attr.lastModifiedTime();\n\t\t\tfinal FileTime accessTime = basic_attr.lastAccessTime();\n\n\t\t\tif (basic_attr.isDirectory())\n\t\t\t{\n\t\t\t\ttype = ItemType.FOLDER;\n\t\t\t}\n\t\t\telse if (basic_attr.isRegularFile())\n\t\t\t{\n\t\t\t\ttype = ItemType.FILE;\n\t\t\t}\n\t\t\telse if (basic_attr.isSymbolicLink())\n\t\t\t{\n\t\t\t\ttype = ItemType.LINK;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttype = ItemType.UNKNOWN;\n\t\t\t}\n\n\t\t\tMap<String, String[]> attributes = new HashMap<>();\n\n\t\t\tPosixFileAttributeView posixView = Files.getFileAttributeView(path, PosixFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\tif (posixView != null)\n\t\t\t{\n\t\t\t\tfinal PosixFileAttributes attr = posixView.readAttributes();\n\t\t\t\tif (type.equals(ItemType.LINK))\n\t\t\t\t{\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_POSIX, new String[] { attr.group().getName(), attr.owner().getName() });\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_POSIX, new String[] { attr.group().getName(), attr.owner().getName(),\n\t\t\t\t\t\t\tfromPermissions(attr.permissions()).toString() });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\tif (dosView != null)\n\t\t\t\t{\n\t\t\t\t\tfinal DosFileAttributes attr = dosView.readAttributes();\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_DOS, new String[] { attr.isArchive() ? \"1\" : \"0\", attr.isHidden() ? \"1\" : \"0\", attr.isReadOnly() ? \"1\" : \"0\",\n\t\t\t\t\t\t\tattr.isSystem() ? \"1\" : \"0\" });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!type.equals(ItemType.LINK))\n\t\t\t{\n\t\t\t\tAclFileAttributeView aclView = Files.getFileAttributeView(path, AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\tif (aclView != null)\n\t\t\t\t{\n\t\t\t\t\tif (!attributes.containsKey(Item.ATTRIBUTE_POSIX)) attributes.put(Item.ATTRIBUTE_OWNER, new String[] { aclView.getOwner().getName() });\n\n\t\t\t\t\tAclFileAttributeView parentAclView = Files.getFileAttributeView(path.getParent(), AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\n\t\t\t\t\tList<AclEntry> aclList = getLocalAclEntries(type, parentAclView.getAcl(), aclView.getAcl());\n\t\t\t\t\tif (aclList.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tList<String> aclData = new ArrayList<>();\n\t\t\t\t\t\tfor (AclEntry acl : aclList)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tList<String> flags = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryFlag flag : acl.flags())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflags.add(flag.name());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tList<String> permissions = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryPermission permission : acl.permissions())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpermissions.add(permission.name());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\taclData.add(acl.type().name());\n\t\t\t\t\t\t\taclData.add(acl.principal().getName());\n\t\t\t\t\t\t\taclData.add(StringUtils.join(flags, \",\"));\n\t\t\t\t\t\t\taclData.add(StringUtils.join(permissions, \",\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString[] arr = new String[aclData.size()];\n\t\t\t\t\t\tarr = aclData.toArray(arr);\n\t\t\t\t\t\tattributes.put(Item.ATTRIBUTE_ACL, arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!attributes.containsKey(Item.ATTRIBUTE_POSIX))\n\t\t\t\t{\n\t\t\t\t\tFileOwnerAttributeView ownerView = Files.getFileAttributeView(path, FileOwnerAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\tif (ownerView != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tattributes.put(Item.ATTRIBUTE_OWNER, new String[] { ownerView.getOwner().getName() });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Item.fromLocalData(file.getName(), type, filesize, creationTime, modifyTime, accessTime, attributes);\n\t\t}\n\t\tcatch (final IOException e)\n\t\t{\n\t\t\tthrow new FileIOException(\"Can't read attributes of '\" + file.getAbsolutePath() + \"'\", e);\n\t\t}\n\t}\n\n\tprivate List<AclEntry> getLocalAclEntries(ItemType type, List<AclEntry> parentAclList, List<AclEntry> childAclList)\n\t{\n\t\tList<AclEntry> aclList = new ArrayList<>();\n\n\t\tfor (AclEntry childEntry : childAclList)\n\t\t{\n\t\t\tboolean found = false;\n\t\t\tfor (AclEntry parentEntry : parentAclList)\n\t\t\t{\n\t\t\t\tif (!parentEntry.type().equals(childEntry.type())) continue;\n\t\t\t\tif (!parentEntry.principal().equals(childEntry.principal())) continue;\n\t\t\t\tif (!parentEntry.permissions().equals(childEntry.permissions())) continue;\n\t\t\t\tif (!parentEntry.flags().equals(childEntry.flags()))\n\t\t\t\t{\n\t\t\t\t\tif (parentEntry.flags().contains(AclEntryFlag.INHERIT_ONLY))\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type.equals(ItemType.FOLDER))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parentEntry.flags().contains(AclEntryFlag.DIRECTORY_INHERIT))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parentEntry.flags().contains(AclEntryFlag.FILE_INHERIT))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (found) continue;\n\n\t\t\t// System.out.println(\"CHILD: \"+childEntry.toString());\n\t\t\t/*\n\t\t\t * System.out.println(\"\\n\\n\");\n\t\t\t * System.out.println(\"CHILD: \"+childEntry.toString());\n\t\t\t * \n\t\t\t * for(AclEntry parentEntry : parentAclList){\n\t\t\t * \n\t\t\t * System.out.println(\"PARENT: \"+parentEntry.toString()); }\n\t\t\t * \n\t\t\t * System.out.println(\"\\n\\n\");\n\t\t\t */\n\n\t\t\taclList.add(childEntry);\n\t\t}\n\t\treturn aclList;\n\t}\n\n\tprivate boolean exists(final Path path)\n\t{\n\t\treturn Files.exists(path, LinkOption.NOFOLLOW_LINKS);\n\t}\n\n\tprivate boolean isDir(final Path path)\n\t{\n\t\treturn Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS);\n\t}\n\n\tprivate Integer fromPermissions(final Set<PosixFilePermission> posixPerms)\n\t{\n\t\tint result = 0;\n\t\tfor (final PosixFilePermission posixPerm : posixPerms)\n\t\t{\n\t\t\tresult += fromPermMapping.get(posixPerm);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate Set<PosixFilePermission> toPermissions(final Integer perm)\n\t{\n\t\tfinal int mode = perm;\n\t\tfinal Set<PosixFilePermission> permissions = new HashSet<>();\n\t\tfor (final int mask : toPermMapping.keySet())\n\t\t{\n\t\t\tif (mask == (mode & mask))\n\t\t\t{\n\t\t\t\tpermissions.add(toPermMapping.get(mask));\n\t\t\t}\n\t\t}\n\t\treturn permissions;\n\t}\n\n\tprivate static String createChecksum(final InputStream data) throws IOException\n\t{\n\t\treturn DigestUtils.md5Hex(data);\n\t}\n\n\tpublic LocalStreamData getFileBinary(final Item item) throws FileIOException\n\t{\n\t\tFile file = new File(localPath + Item.SEPARATOR + item.getPath());\n\n\t\tInputStream checksumInputStream = null;\n\n\t\ttry\n\t\t{\n\t\t\tif (item.isType(ItemType.LINK))\n\t\t\t{\n\t\t\t\tbyte[] data = Files.readSymbolicLink(file.toPath()).toString().getBytes();\n\t\t\t\tchecksumInputStream = new ByteArrayInputStream(data);\n\t\t\t\titem.setChecksum(createChecksum(checksumInputStream));\n\n\t\t\t\treturn new LocalStreamData(new ByteArrayInputStream(data), data.length);\n\n\t\t\t}\n\t\t\telse if (item.isType(ItemType.FILE))\n\t\t\t{\n\t\t\t\tchecksumInputStream = Files.newInputStream(file.toPath());\n\t\t\t\titem.setChecksum(createChecksum(checksumInputStream));\n\n\t\t\t\treturn new LocalStreamData(Files.newInputStream(file.toPath()), Files.size(file.toPath()));\n\t\t\t}\n\t\t\treturn null;\n\n\t\t}\n\t\tcatch (final IOException e)\n\t\t{\n\t\t\tthrow new FileIOException(\"Can't read data of '\" + file.getAbsolutePath() + \"'\", e);\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (checksumInputStream != null) IOUtils.closeQuietly(checksumInputStream);\n\t\t}\n\t}\n\n\tprivate long convertToKB(double size)\n\t{\n\t\treturn (long) Math.ceil(size / 1024);\n\t}\n}\n"], "fixing_code": ["package cloudsync.connector;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclEntry.Builder;\nimport java.nio.file.attribute.AclEntryFlag;\nimport java.nio.file.attribute.AclEntryPermission;\nimport java.nio.file.attribute.AclEntryType;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.DosFileAttributes;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.GroupPrincipal;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.attribute.UserPrincipalLookupService;\nimport java.nio.file.attribute.UserPrincipalNotFoundException;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport cloudsync.exceptions.FileIOException;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\n\nimport cloudsync.exceptions.CloudsyncException;\nimport cloudsync.helper.CmdOptions;\nimport cloudsync.helper.Handler;\nimport cloudsync.helper.Helper;\nimport cloudsync.model.options.ExistingType;\nimport cloudsync.model.Item;\nimport cloudsync.model.ItemType;\nimport cloudsync.model.options.FollowLinkType;\nimport cloudsync.model.options.PermissionType;\nimport cloudsync.model.LocalStreamData;\nimport cloudsync.model.RemoteStreamData;\n\npublic class LocalFilesystemConnector\n{\n\tprivate static final Logger\t\t\t\t\t\t\tLOGGER\t\t\t= Logger.getLogger(LocalFilesystemConnector.class.getName());\n\n\tprivate static final int\t\t\t\t\t\t\tBUFFER_SIZE\t\t= 1 << 16;\n\tprivate static final DecimalFormat\t\t\t\t\tdf\t\t\t\t= new DecimalFormat(\"00\");\n\n\tprivate static final Map<Integer, PosixFilePermission>\ttoPermMapping\t= new HashMap<>();\n\tstatic\n\t{\n\t\ttoPermMapping.put(0001, PosixFilePermission.OTHERS_EXECUTE);\n\t\ttoPermMapping.put(0002, PosixFilePermission.OTHERS_WRITE);\n\t\ttoPermMapping.put(0004, PosixFilePermission.OTHERS_READ);\n\t\ttoPermMapping.put(0010, PosixFilePermission.GROUP_EXECUTE);\n\t\ttoPermMapping.put(0020, PosixFilePermission.GROUP_WRITE);\n\t\ttoPermMapping.put(0040, PosixFilePermission.GROUP_READ);\n\t\ttoPermMapping.put(0100, PosixFilePermission.OWNER_EXECUTE);\n\t\ttoPermMapping.put(0200, PosixFilePermission.OWNER_WRITE);\n\t\ttoPermMapping.put(0400, PosixFilePermission.OWNER_READ);\n\t}\n\n\tprivate static final Map<PosixFilePermission, Integer>\tfromPermMapping\t= new HashMap<>();\n\n\tprivate static final Map<String, Boolean>\t\t\tprincipal_state\t= new HashMap<>();\n\n\tprivate final String\t\t\t\t\t\t\t\tlocalPath;\n\tprivate final boolean\t\t\t\t\t\t\t\tshowProgress;\n\n\tpublic LocalFilesystemConnector(final CmdOptions options)\n\t{\n\t\tString path = options.getPath();\n\t\tshowProgress = options.showProgress();\n\n\t\tif (path != null)\n\t\t{\n\t\t\tif (path.startsWith(Item.SEPARATOR))\n\t\t\t{\n\t\t\t\tlocalPath = Item.SEPARATOR + Helper.trim(path, Item.SEPARATOR);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocalPath = Helper.trim(path, Item.SEPARATOR);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlocalPath = \"\";\n\t\t}\n\n\t\tfor (final Integer key : toPermMapping.keySet())\n\t\t{\n\t\t\tfinal PosixFilePermission perm = toPermMapping.get(key);\n\t\t\tfromPermMapping.put(perm, key);\n\t\t}\n\t}\n\n\tpublic void prepareUpload(final Handler handler, final Item item, final ExistingType duplicateFlag)\n\t{\n\t\tif (!duplicateFlag.equals(ExistingType.RENAME))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tString path = localPath + Item.SEPARATOR + item.getPath();\n\n\t\tif (exists(Paths.get(path)))\n\t\t{\n\t\t\tint i = 0;\n\t\t\twhile (exists(Paths.get(path + \".\" + i)))\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tpath += \".\" + i;\n\n\t\t\titem.setName(FilenameUtils.getName(path));\n\t\t}\n\t}\n\n\tpublic void prepareParent(Handler handler, Item item) throws CloudsyncException\n\t{\n\t\tif (item.getParent() != null)\n\t\t{\n\t\t\tItem parentItem = item.getParent();\n\n\t\t\tfinal Path parentPath = Paths.get(localPath + Item.SEPARATOR + parentItem.getPath());\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tFiles.createDirectories(parentPath);\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new CloudsyncException(\"Can't create \" + parentItem.getTypeName() + \" '\" + parentItem.getPath() + \"'\", e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void upload(final Handler handler, final Item item, final ExistingType duplicateFlag, final PermissionType permissionType)\n\t\t\tthrows CloudsyncException\n\t{\n\t\tfinal String _path = localPath + Item.SEPARATOR + item.getPath();\n\n\t\tfinal Path path = Paths.get(_path);\n\n\t\tif (exists(path))\n\t\t{\n\t\t\tif (duplicateFlag.equals(ExistingType.SKIP))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!duplicateFlag.equals(ExistingType.UPDATE))\n\t\t\t{\n\t\t\t\tthrow new CloudsyncException(\"Item '\" + item.getPath() + \"' already exists. Try to specify another '--duplicate' behavior.\");\n\t\t\t}\n\n\t\t\tif ((!item.isType(ItemType.FOLDER) || !isDir(path)))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tFiles.delete(path);\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CloudsyncException(\"Can't clear \" + item.getTypeName() + \" on '\" + item.getPath() + \"'\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (item.isType(ItemType.FOLDER))\n\t\t{\n\t\t\tif (!exists(path))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tFiles.createDirectory(path);\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CloudsyncException(\"Can't create \" + item.getTypeName() + \" '\" + item.getPath() + \"'\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (item.getParent() != null)\n\t\t\t{\n\t\t\t\tfinal Path parentPath = Paths.get(localPath + Item.SEPARATOR + item.getParent().getPath());\n\n\t\t\t\tif (!isDir(parentPath))\n\t\t\t\t{\n\n\t\t\t\t\tthrow new CloudsyncException(\"Parent directory of \" + item.getTypeName() + \" '\" + item.getPath() + \"' is missing.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.isType(ItemType.LINK))\n\t\t\t{\n\t\t\t\tRemoteStreamData remoteStreamData = null;\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tremoteStreamData = handler.getRemoteProcessedBinary(item);\n\n\t\t\t\t\tfinal String link = IOUtils.toString( remoteStreamData.getDecryptedStream(), Charset.defaultCharset());\n\t\t\t\t\tFiles.createSymbolicLink(path, Paths.get(link));\n\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CloudsyncException(\"Unexpected error during local update of \" + item.getTypeName() + \" '\" + item.getPath() + \"'\", e);\n\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (remoteStreamData != null) remoteStreamData.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (item.isType(ItemType.FILE))\n\t\t\t{\n\t\t\t\tRemoteStreamData remoteStreamData = null;\n\t\t\t\tOutputStream outputStream = null;\n\t\t\t\tInputStream localChecksumStream = null;\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tremoteStreamData = handler.getRemoteProcessedBinary(item);\n\t\t\t\t\toutputStream = Files.newOutputStream(path);\n\n\t\t\t\t\tfinal long length = item.getFilesize();\n\t\t\t\t\tdouble current = 0;\n\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\t\t\tint len;\n\n\t\t\t\t\t// 2 MB\n\t\t\t\t\tif (showProgress && length > 2097152)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tlong lastTime = System.currentTimeMillis();\n\t\t\t\t\t\tdouble lastBytes = 0;\n\t\t\t\t\t\tString currentSpeed = \"\";\n\n\t\t\t\t\t\twhile ((len = remoteStreamData.getDecryptedStream().read(buffer)) != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toutputStream.write(buffer, 0, len);\n\t\t\t\t\t\t\tcurrent += len;\n\n\t\t\t\t\t\t\tlong currentTime = System.currentTimeMillis();\n\n\t\t\t\t\t\t\tString msg = \"\\r  \" + df.format(Math.ceil(current * 100 / length)) + \"% (\" + convertToKB(current) + \" of \" + convertToKB(length)\n\t\t\t\t\t\t\t\t\t+ \" kb) restored\";\n\t\t\t\t\t\t\tdouble diffTime = ((currentTime - lastTime) / 1000.0);\n\n\t\t\t\t\t\t\tif (diffTime > 5.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlong speed = convertToKB((current - lastBytes) / diffTime);\n\t\t\t\t\t\t\t\tcurrentSpeed = \" - \" + speed + \" kb/s\";\n\n\t\t\t\t\t\t\t\tlastTime = currentTime;\n\t\t\t\t\t\t\t\tlastBytes = current;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tLOGGER.log(Level.FINEST, msg + currentSpeed, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile ((len = remoteStreamData.getDecryptedStream().read(buffer)) != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toutputStream.write(buffer, 0, len);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlocalChecksumStream = Files.newInputStream(path);\n\n\t\t\t\t\tif (!createChecksum(localChecksumStream).equals(item.getChecksum()))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new CloudsyncException(\"restored filechecksum differs from the original filechecksum\");\n\t\t\t\t\t}\n\t\t\t\t\tif (item.getFilesize() != Files.size(path))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new CloudsyncException(\"restored filesize differs from the original filesize\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CloudsyncException(\"Unexpected error during local update of \" + item.getTypeName() + \" '\" + item.getPath() + \"'\", e);\n\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (remoteStreamData != null) remoteStreamData.close();\n\t\t\t\t\tif (outputStream != null) IOUtils.closeQuietly(outputStream);\n\t\t\t\t\tif (localChecksumStream != null) IOUtils.closeQuietly(localChecksumStream);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new CloudsyncException(\"Unsupported type \" + item.getTypeName() + \"' on '\" + item.getPath() + \"'\");\n\t\t\t}\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tif (item.isType(ItemType.LINK))\n\t\t\t{\n\t\t\t\t// Files.setLastModifiedTime(path, item.getModifyTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFiles.getFileAttributeView(path, BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS).setTimes(item.getModifyTime(), item.getAccessTime(),\n\t\t\t\t\t\titem.getCreationTime());\n\t\t\t}\n\t\t}\n\t\tcatch (final IOException e)\n\t\t{\n\t\t\tthrow new CloudsyncException(\"Can't set create, modify and access time of \" + item.getTypeName() + \" '\" + item.getPath() + \"'\", e);\n\t\t}\n\n\t\tif (permissionType.equals(PermissionType.SET) || permissionType.equals(PermissionType.TRY))\n\t\t{\n\t\t\tfinal UserPrincipalLookupService lookupService = FileSystems.getDefault().getUserPrincipalLookupService();\n\n\t\t\tMap<String, String[]> attributes = item.getAttributes();\n\t\t\tfor (String type : attributes.keySet())\n\t\t\t{\n\t\t\t\tGroupPrincipal group;\n\t\t\t\tUserPrincipal principal;\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tString[] values = attributes.get(type);\n\n\t\t\t\t\tswitch ( type )\n\t\t\t\t\t{\n\t\t\t\t\t\tcase Item.ATTRIBUTE_POSIX:\n\t\t\t\t\t\t\tPosixFileAttributeView posixView = Files.getFileAttributeView(path, PosixFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\t\t\tif (posixView != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgroup = lookupService.lookupPrincipalByGroupName(values[0]);\n\t\t\t\t\t\t\t\tposixView.setGroup(group);\n\t\t\t\t\t\t\t\tprincipal = lookupService.lookupPrincipalByName(values[1]);\n\t\t\t\t\t\t\t\tposixView.setOwner(principal);\n\t\t\t\t\t\t\t\tif (values.length > 2) posixView.setPermissions(toPermissions(Integer.parseInt(values[2])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString msg = \"Can't restore 'posix' permissions on '\" + item.getPath() + \"'. They are not supported.\";\n\t\t\t\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Item.ATTRIBUTE_DOS:\n\t\t\t\t\t\t\tDosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\t\t\tif (dosView != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdosView.setArchive(Boolean.parseBoolean(values[0]));\n\t\t\t\t\t\t\t\tdosView.setHidden(Boolean.parseBoolean(values[1]));\n\t\t\t\t\t\t\t\tdosView.setReadOnly(Boolean.parseBoolean(values[2]));\n\t\t\t\t\t\t\t\tdosView.setSystem(Boolean.parseBoolean(values[3]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString msg = \"Can't restore 'dos' permissions on '\" + item.getPath() + \"'. They are not supported.\";\n\t\t\t\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Item.ATTRIBUTE_ACL:\n\t\t\t\t\t\t\tAclFileAttributeView aclView = Files.getFileAttributeView(path, AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\t\t\tif (aclView != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tList<AclEntry> acls = aclView.getAcl();\n\t\t\t\t\t\t\t\tfor (int i = 0; i < values.length; i = i + 4)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tBuilder aclEntryBuilder = AclEntry.newBuilder();\n\n\t\t\t\t\t\t\t\t\taclEntryBuilder.setType(AclEntryType.valueOf(values[i]));\n\t\t\t\t\t\t\t\t\taclEntryBuilder.setPrincipal(lookupService.lookupPrincipalByName(values[i + 1]));\n\n\t\t\t\t\t\t\t\t\tSet<AclEntryFlag> flags = new HashSet<>();\n\t\t\t\t\t\t\t\t\tfor (String flag : StringUtils.splitPreserveAllTokens(values[i + 2], \",\"))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tflags.add(AclEntryFlag.valueOf(flag));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (flags.size() > 0) aclEntryBuilder.setFlags(flags);\n\n\t\t\t\t\t\t\t\t\tSet<AclEntryPermission> aclPermissions = new HashSet<>();\n\t\t\t\t\t\t\t\t\tfor (String flag : StringUtils.splitPreserveAllTokens(values[i + 3], \",\"))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\taclPermissions.add(AclEntryPermission.valueOf(flag));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (aclPermissions.size() > 0) aclEntryBuilder.setPermissions(aclPermissions);\n\t\t\t\t\t\t\t\t\tacls.add(aclEntryBuilder.build());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taclView.setAcl(acls);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString msg = \"Can't restore 'acl' permissions on '\" + item.getPath() + \"'. They are not supported.\";\n\t\t\t\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Item.ATTRIBUTE_OWNER:\n\t\t\t\t\t\t\tFileOwnerAttributeView ownerView = Files.getFileAttributeView(path, FileOwnerAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\t\t\tif (ownerView != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprincipal = lookupService.lookupPrincipalByName(values[0]);\n\t\t\t\t\t\t\t\townerView.setOwner(principal);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString msg = \"Can't restore 'owner' permissions on '\" + item.getPath() + \"'. They are not supported.\";\n\t\t\t\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (final UserPrincipalNotFoundException e)\n\t\t\t\t{\n\t\t\t\t\tif (!LocalFilesystemConnector.principal_state.containsKey(e.getName()))\n\t\t\t\t\t{\n\t\t\t\t\t\tLocalFilesystemConnector.principal_state.put(e.getName(), true);\n\t\t\t\t\t\tLOGGER.log(Level.WARNING, \"principal with name '\" + e.getName() + \"' not exists\");\n\t\t\t\t\t}\n\t\t\t\t\tString msg = \"Principal '\" + e.getName() + \"' on '\" + item.getPath() + \"' not found.\";\n\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e)\n\t\t\t\t{\n\t\t\t\t\tString msg = \"Can't set permissions of '\" + item.getPath() + \"'.\";\n\t\t\t\t\tif (permissionType.equals(PermissionType.TRY)) LOGGER.log(Level.WARNING, msg);\n\t\t\t\t\telse throw new CloudsyncException(msg + \"\\n  try to run with '--permissions try'\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic File[] readFolder(final Item item) \n\t\n\tthrows CloudsyncException\n\t{\n\t\tfinal String currentPath = localPath + (StringUtils.isEmpty(item.getPath()) ? \"\" : Item.SEPARATOR + item.getPath());\n\n\t\tfinal File folder = new File(currentPath);\n\n\t\tif (!Files.exists(folder.toPath(), LinkOption.NOFOLLOW_LINKS))\n\t\t{\n\t\t\tLOGGER.log(Level.WARNING, \"skip '\" + currentPath + \"'. does not exists anymore.\");\n\t\t\treturn new File[] {};\n\t\t}\n\n\t\tFile[] files = folder.listFiles();\n\t\t\n\t\tif( files == null )\n\t\t{\n            throw new CloudsyncException(\"Path '\" + currentPath + \"' is not readable. Check your permissions\");\n\t\t}\n\t\t\n\t\treturn files;\n\t}\n\n\tpublic Item getItem(File file, final FollowLinkType followlinks, List<String> followedLinkPaths ) throws FileIOException\n\t{\n\t\ttry\n\t\t{\n\t\t\tPath path = file.toPath();\n\n\t\t\tItemType type;\n\t\t\t\n\t\t\tif (Files.isSymbolicLink(path))\n\t\t\t{\n\t\t\t\tString target;\n\t\t\t\ttarget = Files.readSymbolicLink(path).toString();\n\t\t\t\tfinal String firstChar = target.substring(0, 1);\n\t\t\t\tif (!firstChar.equals(Item.SEPARATOR))\n\t\t\t\t{\n\t\t\t\t\tif (!firstChar.equals(\".\"))\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget = \".\" + Item.SEPARATOR + target;\n\t\t\t\t\t}\n\t\t\t\t\ttarget = path.toString() + Item.SEPARATOR + target;\n\t\t\t\t}\n\t\t\t\ttarget = Paths.get(target).toFile().getCanonicalPath();\n\n                if (!followlinks.equals(FollowLinkType.NONE) && followlinks.equals(FollowLinkType.EXTERNAL) && !Paths.get(target).toFile().getCanonicalFile().toPath().startsWith(localPath + Item.SEPARATOR) )\n\t\t\t\t{\n                    boolean foundLink = false;\n                    for( String followedLinkPath: followedLinkPaths )\n                    {\n                        // 1. if the link target is a child of a already followed link, then there is no need to follow again\n                        // 2. and the target should not be equal with a already followed link. Otherwise we are requesting the same item again. So we have to follow.\n                        if( target.startsWith(followedLinkPath) && !target.equals(followedLinkPath) )\n                        {\n                            foundLink = true;\n                            break;\n                        }\n                    }\n                    \n                    if( !foundLink )\n                    {\n                        final Path targetPath = Paths.get(target);\n                        if (Files.exists(targetPath, LinkOption.NOFOLLOW_LINKS))\n                        {\n                            path = targetPath;\n                            followedLinkPaths.add(target);\n                        }\n                    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBasicFileAttributes basic_attr = Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\tfinal Long filesize = basic_attr.size();\n\t\t\tfinal FileTime creationTime = basic_attr.creationTime();\n\t\t\tfinal FileTime modifyTime = basic_attr.lastModifiedTime();\n\t\t\tfinal FileTime accessTime = basic_attr.lastAccessTime();\n\n\t\t\tif (basic_attr.isDirectory())\n\t\t\t{\n\t\t\t\ttype = ItemType.FOLDER;\n\t\t\t}\n\t\t\telse if (basic_attr.isRegularFile())\n\t\t\t{\n\t\t\t\ttype = ItemType.FILE;\n\t\t\t}\n\t\t\telse if (basic_attr.isSymbolicLink())\n\t\t\t{\n\t\t\t\ttype = ItemType.LINK;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttype = ItemType.UNKNOWN;\n\t\t\t}\n\n\t\t\tMap<String, String[]> attributes = new HashMap<>();\n\n\t\t\tPosixFileAttributeView posixView = Files.getFileAttributeView(path, PosixFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\tif (posixView != null)\n\t\t\t{\n\t\t\t\tfinal PosixFileAttributes attr = posixView.readAttributes();\n\t\t\t\tif (type.equals(ItemType.LINK))\n\t\t\t\t{\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_POSIX, new String[] { attr.group().getName(), attr.owner().getName() });\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_POSIX, new String[] { attr.group().getName(), attr.owner().getName(),\n\t\t\t\t\t\t\tfromPermissions(attr.permissions()).toString() });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\tif (dosView != null)\n\t\t\t\t{\n\t\t\t\t\tfinal DosFileAttributes attr = dosView.readAttributes();\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_DOS, new String[] { attr.isArchive() ? \"1\" : \"0\", attr.isHidden() ? \"1\" : \"0\", attr.isReadOnly() ? \"1\" : \"0\",\n\t\t\t\t\t\t\tattr.isSystem() ? \"1\" : \"0\" });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!type.equals(ItemType.LINK))\n\t\t\t{\n\t\t\t\tAclFileAttributeView aclView = Files.getFileAttributeView(path, AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\tif (aclView != null)\n\t\t\t\t{\n\t\t\t\t\tif (!attributes.containsKey(Item.ATTRIBUTE_POSIX)) attributes.put(Item.ATTRIBUTE_OWNER, new String[] { aclView.getOwner().getName() });\n\n\t\t\t\t\tAclFileAttributeView parentAclView = Files.getFileAttributeView(path.getParent(), AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\n\t\t\t\t\tList<AclEntry> aclList = getLocalAclEntries(type, parentAclView.getAcl(), aclView.getAcl());\n\t\t\t\t\tif (aclList.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tList<String> aclData = new ArrayList<>();\n\t\t\t\t\t\tfor (AclEntry acl : aclList)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tList<String> flags = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryFlag flag : acl.flags())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflags.add(flag.name());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tList<String> permissions = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryPermission permission : acl.permissions())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpermissions.add(permission.name());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\taclData.add(acl.type().name());\n\t\t\t\t\t\t\taclData.add(acl.principal().getName());\n\t\t\t\t\t\t\taclData.add(StringUtils.join(flags, \",\"));\n\t\t\t\t\t\t\taclData.add(StringUtils.join(permissions, \",\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString[] arr = new String[aclData.size()];\n\t\t\t\t\t\tarr = aclData.toArray(arr);\n\t\t\t\t\t\tattributes.put(Item.ATTRIBUTE_ACL, arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!attributes.containsKey(Item.ATTRIBUTE_POSIX))\n\t\t\t\t{\n\t\t\t\t\tFileOwnerAttributeView ownerView = Files.getFileAttributeView(path, FileOwnerAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\tif (ownerView != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tattributes.put(Item.ATTRIBUTE_OWNER, new String[] { ownerView.getOwner().getName() });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Item.fromLocalData(file.getName(), type, filesize, creationTime, modifyTime, accessTime, attributes);\n\t\t}\n\t\tcatch (final IOException e)\n\t\t{\n\t\t\tthrow new FileIOException(\"Can't read attributes of '\" + file.getAbsolutePath() + \"'\", e);\n\t\t}\n\t}\n\n\tprivate List<AclEntry> getLocalAclEntries(ItemType type, List<AclEntry> parentAclList, List<AclEntry> childAclList)\n\t{\n\t\tList<AclEntry> aclList = new ArrayList<>();\n\n\t\tfor (AclEntry childEntry : childAclList)\n\t\t{\n\t\t\tboolean found = false;\n\t\t\tfor (AclEntry parentEntry : parentAclList)\n\t\t\t{\n\t\t\t\tif (!parentEntry.type().equals(childEntry.type())) continue;\n\t\t\t\tif (!parentEntry.principal().equals(childEntry.principal())) continue;\n\t\t\t\tif (!parentEntry.permissions().equals(childEntry.permissions())) continue;\n\t\t\t\tif (!parentEntry.flags().equals(childEntry.flags()))\n\t\t\t\t{\n\t\t\t\t\tif (parentEntry.flags().contains(AclEntryFlag.INHERIT_ONLY))\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type.equals(ItemType.FOLDER))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parentEntry.flags().contains(AclEntryFlag.DIRECTORY_INHERIT))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parentEntry.flags().contains(AclEntryFlag.FILE_INHERIT))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (found) continue;\n\n\t\t\t// System.out.println(\"CHILD: \"+childEntry.toString());\n\t\t\t/*\n\t\t\t * System.out.println(\"\\n\\n\");\n\t\t\t * System.out.println(\"CHILD: \"+childEntry.toString());\n\t\t\t * \n\t\t\t * for(AclEntry parentEntry : parentAclList){\n\t\t\t * \n\t\t\t * System.out.println(\"PARENT: \"+parentEntry.toString()); }\n\t\t\t * \n\t\t\t * System.out.println(\"\\n\\n\");\n\t\t\t */\n\n\t\t\taclList.add(childEntry);\n\t\t}\n\t\treturn aclList;\n\t}\n\n\tprivate boolean exists(final Path path)\n\t{\n\t\treturn Files.exists(path, LinkOption.NOFOLLOW_LINKS);\n\t}\n\n\tprivate boolean isDir(final Path path)\n\t{\n\t\treturn Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS);\n\t}\n\n\tprivate Integer fromPermissions(final Set<PosixFilePermission> posixPerms)\n\t{\n\t\tint result = 0;\n\t\tfor (final PosixFilePermission posixPerm : posixPerms)\n\t\t{\n\t\t\tresult += fromPermMapping.get(posixPerm);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate Set<PosixFilePermission> toPermissions(final Integer perm)\n\t{\n\t\tfinal int mode = perm;\n\t\tfinal Set<PosixFilePermission> permissions = new HashSet<>();\n\t\tfor (final int mask : toPermMapping.keySet())\n\t\t{\n\t\t\tif (mask == (mode & mask))\n\t\t\t{\n\t\t\t\tpermissions.add(toPermMapping.get(mask));\n\t\t\t}\n\t\t}\n\t\treturn permissions;\n\t}\n\n\tprivate static String createChecksum(final InputStream data) throws IOException\n\t{\n\t\treturn DigestUtils.md5Hex(data);\n\t}\n\n\tpublic LocalStreamData getFileBinary(final Item item) throws FileIOException\n\t{\n\t\tFile file = new File(localPath + Item.SEPARATOR + item.getPath());\n\n\t\tInputStream checksumInputStream = null;\n\n\t\ttry\n\t\t{\n\t\t\tif (item.isType(ItemType.LINK))\n\t\t\t{\n\t\t\t\tbyte[] data = Files.readSymbolicLink(file.toPath()).toString().getBytes();\n\t\t\t\tchecksumInputStream = new ByteArrayInputStream(data);\n\t\t\t\titem.setChecksum(createChecksum(checksumInputStream));\n\n\t\t\t\treturn new LocalStreamData(new ByteArrayInputStream(data), data.length);\n\n\t\t\t}\n\t\t\telse if (item.isType(ItemType.FILE))\n\t\t\t{\n\t\t\t\tchecksumInputStream = Files.newInputStream(file.toPath());\n\t\t\t\titem.setChecksum(createChecksum(checksumInputStream));\n\n\t\t\t\treturn new LocalStreamData(Files.newInputStream(file.toPath()), Files.size(file.toPath()));\n\t\t\t}\n\t\t\treturn null;\n\n\t\t}\n\t\tcatch (final IOException e)\n\t\t{\n\t\t\tthrow new FileIOException(\"Can't read data of '\" + file.getAbsolutePath() + \"'\", e);\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (checksumInputStream != null) IOUtils.closeQuietly(checksumInputStream);\n\t\t}\n\t}\n\n\tprivate long convertToKB(double size)\n\t{\n\t\treturn (long) Math.ceil(size / 1024);\n\t}\n}\n"], "filenames": ["src/main/java/cloudsync/connector/LocalFilesystemConnector.java"], "buggy_code_start_loc": [513], "buggy_code_end_loc": [514], "fixing_code_start_loc": [513], "fixing_code_end_loc": [514], "type": "CWE-22", "message": "** UNSUPPPORTED WHEN ASSIGNED **** UNSUPPORTED WHEN ASSIGNED ** A vulnerability classified as problematic was found in cloudsync. Affected by this vulnerability is the function getItem of the file src/main/java/cloudsync/connector/LocalFilesystemConnector.java. The manipulation leads to path traversal. It is possible to launch the attack on the local host. The name of the patch is 3ad796833398af257c28e0ebeade68518e0e612a. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216919. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.", "other": {"cve": {"id": "CVE-2022-4773", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-28T00:15:15.570", "lastModified": "2023-01-06T17:47:53.813", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** UNSUPPPORTED WHEN ASSIGNED **** UNSUPPORTED WHEN ASSIGNED ** A vulnerability classified as problematic was found in cloudsync. Affected by this vulnerability is the function getItem of the file src/main/java/cloudsync/connector/LocalFilesystemConnector.java. The manipulation leads to path traversal. It is possible to launch the attack on the local host. The name of the patch is 3ad796833398af257c28e0ebeade68518e0e612a. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216919. NOTE: This vulnerability only affects products that are no longer supported by the maintainer."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cloudsync_project:cloudsync:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-09-21", "matchCriteriaId": "2C9F663F-3066-4E77-828C-606D425CD31C"}]}]}], "references": [{"url": "https://github.com/HolgerHees/cloudsync/commit/3ad796833398af257c28e0ebeade68518e0e612a", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216919", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216919", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/HolgerHees/cloudsync/commit/3ad796833398af257c28e0ebeade68518e0e612a"}}